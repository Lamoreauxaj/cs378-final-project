"import java.io.BufferedInputStream fun main() {    val jin = FastScanner()    val n = jin.nextInt()    val k = jin.nextInt()    // https://math.stackexchange.com/questions/11002/cn-p-even-or-odd    // cmd f ""it turns out""    fun oddChoose(a: Int, b: Int) = a and b == b    val bs = IntArray(n) { jin.nextInt() }    val answer = IntArray(1 shl 20)    for (j in 0 until n) {        var amtToChoose = n - 3        var already = 2        if (j == 0) {            amtToChoose++            already--        }        if (j == n - 1) {            amtToChoose++            already--        }        var shift = 0        var j2 = j        while (shift < 20 && bs[j].toLong() shl shift < answer.size) {            val x = bs[j] shl shift            val odd = when {                already >= k -> amtToChoose == 0                amtToChoose == 0 -> false                else -> oddChoose(amtToChoose - 1, k - already - 1)            }            if (odd) {                answer[x] = answer[x] xor 1            }            j2++            if (j2 == n) {                break            }            shift += bs[j2]            amtToChoose--            if (j2 == n - 1) {                amtToChoose++                already--            }        }    }    if (answer.all { it == 0 }) {        println(0)    } else {        val last = answer.lastIndexOf(1)        val toPrint = CharArray(last + 1) { '0' + answer[last - it] }        println(toPrint)    }} class FastScanner {    private val BS = 1 shl 16    private val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC    private var `in`: BufferedInputStream? = null     constructor() {        `in` = BufferedInputStream(System.`in`, BS)    }     private val char: Char        private get() {            while (bId == size) {                size = try {                    `in`!!.read(buf)                } catch (e: Exception) {                    return NC                }                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c >= '0' && c <= '9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }}","bitmasks,combinatorics,math,number theory"
"fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()        val logs = readLine()!!.split("" "").map { it.toInt() }        println(if ((logs.sum() - n) % 2 == 0) ""maomao90"" else ""errorgorn"")    }}","games,implementation,math"
"fun main() {    val dp = Array(100) { 0 }    dp[1] = 0    for (i in 2..50) {        val sg = mutableSetOf<Int>()        for (j in 1 until i) {            sg.add(dp[j] xor dp[i - j])        }        dp[i] = (0..50).first { !sg.contains(it) }    }    val t = readLine()!!.toInt()    repeat(t) {        readLine()!!.toInt()        var sg = 0        readLine()!!.split("" "").forEach {            sg = sg xor dp[it.toInt()]        }        println(if (sg == 0) ""maomao90"" else ""errorgorn"")    }}","games,implementation,math"
"/** * Accomplished using the EduTools plugin by JetBrains https://plugins.jetbrains.com/plugin/10081-edutools * * To modify the template, go to Preferences -> Editor -> File and Code Templates -> Other */ fun main() {    val t = readLine()!!.toInt()    repeat(t) {        readLine()        val a = readLine()!!.split(' ').map(String::toLong)        val f = a.map { it - 1 }        val sum = f.sum()//        if (sum <= 1)//            println(""maomao90"")        if (sum % 2L == 0L)            println(""maomao90"")        else            println(""errorgorn"")    }}","games,implementation,math"
"import java.io.BufferedReader fun main() {    val br = System.`in`.bufferedReader()    val bw = System.out.bufferedWriter()    val t = br.readInt()    repeat(t) {        val n = br.readInt()        var moves = 0        repeat(n) {            moves += br.readInt() - 1        }        if(moves and 1 == 0) {            bw.appendLine(""maomao90"")        } else {            bw.appendLine(""errorgorn"")        }    }    bw.flush()} private const val SPACE_INT = ' '.toInt()private const val ZERO_INT = '0'.toInt()private const val NL_INT = '\n'.toInt() private fun BufferedReader.readInt(): Int {    var ret = read()    while (ret <= SPACE_INT) {        ret = read()    }    val neg = ret == '-'.toInt()    if (neg) {        ret = read()    }    ret -= ZERO_INT    var read = read()    while (read >= ZERO_INT) {        ret *= 10        ret += read - ZERO_INT        read = read()    }     while (read <= SPACE_INT && read != -1 && read != NL_INT) {        mark(1)        read = read()    }    if (read > SPACE_INT) {        reset()    }    return if (neg) -ret else ret}","games,implementation,math"
"// 2022-04-22, Fri, 22:44import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.system.measureTimeMillisimport java.util.TreeMapimport java.util.TreeSetimport kotlin.math.absoluteValue inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        val S = fakein.toString()        println(""New Case "")        println(S.take(80))        println(""..."")        fakein.clear()        IN = BufferedInputStream(S.byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} val getintfast:Int get() = IO.nextInt()val getint:Int get(){ val ans = getlong ; if(ans > Int.MAX_VALUE) IntArray(1000000000); return ans.toInt() }val getlong:Long get() = IO.nextLong()val getstr:String get() = IO.nextString()fun getline(n:Int):IntArray{    return IntArray(n){getint}}fun getlineL(n:Int):LongArray{    return LongArray(n){getlong}}fun getbinary(n:Int, asTrue:Char):BooleanArray{    val str = getstr    return BooleanArray(n){str[it] == asTrue}} val List<Char>.ret:Stringget() = this.joinToString("""")var dmark = -1infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    dmark++    var str = ""<${dmark}>   ""    debug()    if(this is String){ str += this    }else if(this is Int){ str += this.toString()    }else if(this is Long){ str += this.toString()    }else{ str += this.toString()}    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is BooleanArray){ println(""$str :${a.map{if(it)'1' else '0'}.joinToString("" "")}"")    }else if(a is Array<*>){        println(""$str : "")        for(c in a){if(c is IntArray){println(c.joinToString("" ""))}        else if(c is LongArray){println(c.joinToString("" ""))}        else if(c is BooleanArray){println(c.map { if(it) '1' else '0' }.joinToString(""""))        }         }        println()    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){    throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){        throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    fun cases(onecase:()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint} else if(mode == solveMode.tc){1 } else randCount        //safety checks        if(pI != 998_244_353 && pI != 1_000_000_007){            throw Exception(""Modding a wrong prime!"")        }        if(withBruteForce){            println(""Brute force is active"")        }         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            onecase()        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }}inline fun<T> T.alsoBrute(cal:() -> T){    if(!withBruteForce) return    val also = cal()    if(this != also){        println(""Checking failed: Got ${this} Brute ${also}"")        crash()    }}// 1. Moddedconst val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}infix fun Int.modM(b:Int):Int{ return ((this.toLong() * b) % pI).toInt() }infix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }fun intPow(x:Int,e:Int,m:Int):Int{    var X = x ; var E =e ; var Y = 1    while(E > 0){        if(E and 1 == 0){            X = ((1L * X * X) % m).toInt()            E = E shr 1        }else{            Y = ((1L * X * Y) % m).toInt()            E -= 1        }    }    return Y}// 2. DP initial valuesconst val plarge = 1_000_000_727const val nlarge = -plargeconst val phuge = 2_727_000_000_000_000_000Lconst val nhuge = -phuge// 3. conveniecen conversionsval Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionval Char.code :Int get() = this.toInt() -  'a'.toInt()//3. hard to write stufffun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val mint:MutableList<Int> get() = mutableListOf<Int>()val mong:MutableList<Long> get() = mutableListOf<Long>()//4. more outputsfun List<Char>.conca():String = this.joinToString("""")val CharArray.conca :String get() = this.joinToString("""")val IntArray.conca :String get() = this.joinToString("" "")@JvmName(""concaInt"")fun List<Int>.conca():String = this.joinToString("" "")val LongArray.conca:String get() = this.joinToString("" "")@JvmName(""concaLong"")fun List<Long>.conca():String = this.joinToString("" "")//5. Pair of intsconst val longmask = (1L shl 32) - 1fun makepair(a:Int, b:Int):Long = (a.toLong() shl 32) xor (longmask and b.toLong()) // remember positev sonlyval Long.first get() = (this ushr 32).toInt()val Long.second get() = this.toInt()//6. stringsval String.size get() = this.lengthconst val randCount = 100//7. bitsfun Int.has(i:Int):Boolean = (this and (1 shl i) != 0)     fun debug(){}const val withBruteForce = falseconst val singleCase = falsefun main(){    solve.cases{        val n = getint        val x = getint        val L = getline(n)         fun IntArray.cost():Long {            var ret = 0L            val n= this.size            for(i in 0 until n-1){                ret += (this[i] - this[i+1]).absoluteValue            }            return ret        }         val base = L.cost()         val important = BooleanArray(n)        important[0] = true        important[n-1] = true        if(n >= 3){            var max = (1 until n-1).maxOf { L[it] }            val min = (1 until n-1).minOf { L[it] }            val i1 = (1 until n-1).first { L[it] == max }            val i2 = (1 until n-1).first { L[it] == min }            important[i1] = true            important[i2] = true        }          val compressed = mint        for(i in 0 until n) {            if(important[i]){                compressed.add(L[i])            }        }        val c = compressed.toIntArray()         val compressedBase = c.cost()         var mincost = phuge        for(i in 0..c.size){            for(j in 0..c.size + 1){                val a = c.toMutableList()                a.add(i,1)                a.add(j,x)//                just dei a                mincost = minOf(mincost, a.toIntArray().cost())            }        }        val minextra = mincost - compressedBase        put(base + minextra)          }    done()}   ","brute force,constructive algorithms,greedy"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"", ""DEPRECATION"")@file:OptIn(ExperimentalStdlibApi::class) import java.io.PrintWriterimport java.util.StringTokenizerimport kotlin.collections.ArrayDequeimport kotlin.math.*import java.util.TreeMapimport java.util.PriorityQueue// import java.util.*// import kotlin.random.* @JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out @JvmField val reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun readLn() = reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readString() = readStrings(1)[0]fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int = 2) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int = 2) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } // val isLocal = System.getenv(""IS_LOCAL_CP"") == ""true"" @JvmFieldval writer = PrintWriter(OUTPUT) // ---------------------------------------------------------------------------- class UnionFind {     private val parents = mutableMapOf<Int, Int>()    private val sizes = mutableMapOf<Int, Int>()     fun union(a: Int, b: Int) {        val fa = find(a)        val fb = find(b)        if (fa != fb) {            parents[fa] = fb            sizes[fb] = (sizes[fb] ?: 1) + (sizes[fa] ?: 1)        }    }     fun find(a: Int): Int {        fun getOrDefault(value: Int) = parents.getOrDefault(value, value)         var parent = getOrDefault(a)        while (parent != getOrDefault(parent)) {            parents[parent] = getOrDefault(getOrDefault(parent))            parent = parents[parent]!!        }        return parent    }     fun connected(a: Int, b: Int): Boolean {        return find(a) == find(b)    }     fun getSize(a: Int): Int {        return sizes[find(a)] ?: 1    }} class UnionFindArray(private val n: Int) {     private val parents = IntArray(n + 1) { it }     fun union(a: Int, b: Int) {        val fa = find(a)        val fb = find(b)        if (fa != fb) {            parents[fa] = fb        }    }     fun find(a: Int): Int {        var parent = parents[a]        while (parent != parents[parent]) {            parents[parent] = parents[parents[parent]]            parent = parents[parent]        }        return parent    }     fun connected(a: Int, b: Int): Boolean {        return find(a) == find(b)    }} class Trie() {     /** Initialize your data structure here. */    private val root = Node()     /** Inserts a word into the trie. */    fun insert(word: String) {        var node = root        for (char in word) {            if (!node.children.contains(char)) {                node.children[char] = Node()            }            node = node.children[char]!!        }        node.hasWord = true    }     /** Returns if the word is in the trie. */    fun search(word: String): Boolean {        return findNode(word)?.hasWord ?: false    }     /** Returns if there is any word in the trie that starts with the given prefix. */    fun startsWith(prefix: String): Boolean {        return findNode(prefix) != null    }     private fun findNode(prefix: String): Node? {        var node = root        for (char in prefix) {            node = node.children[char] ?: return null        }        return node    }     private class Node(        var hasWord: Boolean = false,        val children: MutableMap<Char, Node> = mutableMapOf<Char, Node>()    )} // 所有函数的下标从 0 开始// query(index): sum[0, index]class BinaryIndexedTree {     private val bit: IntArray     constructor(n: Int) {        this.bit = IntArray(n + 1)    }     constructor(nums: IntArray) {        this.bit = IntArray(nums.size + 1)        val prefix = IntArray(bit.size)        for (i in 1 until nums.size + 1) {            prefix[i] = prefix[i - 1] + nums[i - 1]            bit[i] = prefix[i] - prefix[i - lowbit(i)]        }    }     fun query(index: Int): Int {        var result = 0        var i = index + 1        while (i > 0) {            result += bit[i]            i -= lowbit(i)        }        return result    }     fun update(index: Int, x: Int) {        val value = query(index) - query(index - 1)        add(index, x - value)    }     fun add(index: Int, x: Int) {        var i = index + 1        while (i < bit.size) {            bit[i] += x            i += lowbit(i)        }    }     override fun toString(): String {        return IntArray(bit.size - 1) { query(it) - query(it - 1) }.toList().toString()    }     private fun lowbit(x: Int): Int {        return x.and(-x)    }} // 所有函数的下标从 0 开始// query(index): max[0, index]// udpate(index, x): 更新 [0, index] 之间的最大值，只能越来越大class BinaryIndexedTreeMax {     private val bit: IntArray     constructor(n: Int) {        this.bit = IntArray(n + 1)    }     fun query(index: Int): Int {        var result = 0        var i = index + 1        while (i > 0) {            result = Math.max(result, bit[i])            i -= lowbit(i)        }        return result    }     fun update(index: Int, x: Int) {        var i = index + 1        while (i < bit.size) {            bit[i] = Math.max(bit[i], x)            i += lowbit(i)        }    }     private fun lowbit(x: Int): Int {        return x.and(-x)    }} class SparseTableMax(private val nums: IntArray) {     private val st: Array<IntArray>     init {        val n = nums.size        val logN = Integer.numberOfTrailingZeros(Integer.highestOneBit(n))        this.st = Array(n * 2) { IntArray(logN + 1) }        for (i in 0 until n) {            st[i][0] = nums[i]        }        for (j in 1 until logN + 1) {            for (i in 0 until n) {                st[i][j] = st[i][j - 1]                if (i + 1.shl(j - 1) < n) {                    st[i][j] = Math.max(st[i][j], st[i + 1.shl(j - 1)][j - 1])                }            }        }    }     fun query(left: Int, right: Int): Int {        if (left > right) {            return -1        }        val len = right - left + 1        val k = Integer.numberOfTrailingZeros(Integer.highestOneBit(len))        return Math.max(st[left][k], st[right - 1.shl(k) + 1][k])    }} class SparseTableMin(private val nums: IntArray) {     private val st: Array<IntArray>     init {        val n = nums.size        val logN = Integer.numberOfTrailingZeros(Integer.highestOneBit(n))        this.st = Array(n * 2) { IntArray(logN + 1) { Int.MAX_VALUE / 2 } }        for (i in 0 until n) {            st[i][0] = nums[i]        }        for (j in 1 until logN + 1) {            for (i in 0 until n) {                st[i][j] = st[i][j - 1]                if (i + 1.shl(j - 1) < n) {                    st[i][j] = Math.min(st[i][j], st[i + 1.shl(j - 1)][j - 1])                }            }        }    }     fun query(left: Int, right: Int): Int {        if (left > right) {            return -1        }        val len = right - left + 1        val k = Integer.numberOfTrailingZeros(Integer.highestOneBit(len))        return Math.min(st[left][k], st[right - 1.shl(k) + 1][k])    }} class PrefixSum2D(private val grid: Array<IntArray>) {     private val prefix: Array<IntArray>     init {        val (m, n) = Pair(grid.size, grid[0].size)        prefix = Array(m + 1) { IntArray(n + 1) }        for (i in 0 until m) {            var row = 0            for (j in 0 until n) {                row += grid[i][j]                prefix[i + 1][j + 1] = prefix[i][j + 1] + row            }        }    }     fun query(up: Int, left: Int, bottom: Int, right: Int): Int {        return prefix[up][left] + prefix[bottom + 1][right + 1] -            prefix[bottom + 1][left] - prefix[up][right + 1]    }} // ---------------------------------------------------------------------------- private fun PrintWriter.printNums(nums: List<Int>) {    if (nums.isEmpty()) {        println()        return    }    for (i in 0 until nums.size - 1) {        print(nums[i])        print(' ')    }    println(nums.last())} private fun lengthOfLIS(numsInput: List<Int>): Int {    val nums = unify(numsInput)    val bit = BinaryIndexedTreeMax(nums.size + 1)    var result = 0    for (num in nums) {        val len = bit.query(num - 1) + 1        bit.update(num, len)        result = Math.max(result, len)    }    return result} private fun unify(nums: List<Int>): List<Int> {    val numToIndex = nums.sorted().mapIndexed { index, num -> num to index }.toMap()    return nums.map { numToIndex[it]!! }} private fun fastPow(a: Long, exp: Long, mod: Long): Long {    var result = 1L % mod    var base = a % mod    var remain = exp    while (remain != 0L) {        if (remain % 2L == 1L) {            result = (result * base) % mod        }        base = (base * base) % mod        remain /= 2L    }    return result} private fun gcd(a: Int, b: Int): Int {    return if (b == 0) a else gcd(b, a % b)} private fun gcdL(a: Long, b: Long): Long {    return if (b == 0L) a else gcdL(b, a % b)} private fun lcm(a: Int, b: Int): Int {    return ((a.toLong() * b.toLong()) / gcd(a, b)).toInt()} private fun lcmL(a: Long, b: Long): Long {    return (a * b) / gcdL(a, b)} private fun wordToCharCount(word: String): IntArray {    val charCount = IntArray(26)    for (char in word) {        charCount[char.toIndex()]++    }    return charCount} private fun Char.toIndex(): Int {    return this.toInt() - 'a'.toInt()} private fun Char.toDigit(): Int {    return this.toInt() - '0'.toInt()} private fun Boolean.toYesNo(upper: Boolean = false): String {    val yesNo = if (this) ""Yes"" else ""No""    return if (upper) yesNo.toUpperCase() else yesNo} private fun LongArray.modSum(mod: Long = MODL): Long {    var sum = 0L    for (num in this) {        sum = (sum + num) % mod    }    return sum} private fun IntArray.swap(i: Int, j: Int) {    val temp = this[i]    this[i] = this[j]    this[j] = temp} private fun LongArray.swap(i: Int, j: Int) {    val temp = this[i]    this[i] = this[j]    this[j] = temp} private fun CharArray.swap(i: Int, j: Int) {    val temp = this[i]    this[i] = this[j]    this[j] = temp} private fun <T> List<T>.toArrayDeque(): ArrayDeque<T> {    return ArrayDeque(this)} private fun <T> List<T>.toPair(): Pair<T, T> {    return Pair(this[0], this[1])} private fun <T> List<T>.listEquals(other: List<T>): Boolean {    return (0 until this.size).all { this[it] == other[it] }} private fun <T : Comparable<T>> List<T>.isSorted(): Boolean {    return this.listEquals(this.sorted())} private val DIR = listOf(    listOf(1, 0), listOf(0, -1), listOf(-1, 0), listOf(0, 1))  private const val MOD = 998244353private const val MODL = 998244353L// private const val MOD = 1000000007// private const val MODL = 1000000007Lprivate const val EPS = 0.000001 // ---------------------------------------------------------------------------- fun main() {    val go: Runnable = Runnable {        writer.solve()        writer.flush()    }    Thread(null, go, ""thread"", 1L.shl(28)).start()} private fun PrintWriter.solve() {    val t = readInt()    for (tx in 1 until t + 1) {        // print(""Case #$tx: "")        val (n, x) = readInts()        val nums = readInts(n)        println(insertAProg(nums, x))    }} private fun insertAProg(nums: List<Int>, x: Int): Long {    var n = nums.size    var current = nums    if (nums.min()!! > 1) {        var bestIndex = -1        var bestValue = nums[0] - 1        if (nums.last() - 1 < bestValue) {            bestIndex = n - 1            bestValue = nums.last() - 1        }        for (i in 0 until n - 1) {            val current = (nums[i] + nums[i + 1] - 2) - Math.abs(nums[i] - nums[i + 1])            if (current < bestValue) {                bestValue = current                bestIndex = i            }        }        val left = nums.subList(0, bestIndex + 1)        val right = nums.subList(bestIndex + 1, n)        current = left + listOf(1) + right    }    // println(current)    n = current.size    if (nums.max()!! < x) {        var bestIndex = -1        var bestValue = Math.abs(current[0] - x)        if (Math.abs(current.last() - x) < bestValue) {            bestIndex = n - 1            bestValue = Math.abs(current.last() - x)        }        for (i in 0 until n - 1) {            val current = (Math.abs(current[i] - x) + Math.abs(current[i + 1] - x)) - Math.abs(current[i] - current[i + 1])            if (current < bestValue) {                bestValue = current                bestIndex = i            }        }        val left = current.subList(0, bestIndex + 1)        val right = current.subList(bestIndex + 1, n)        current = left + listOf(x) + right    }    // println(current)    return (0 until current.size - 1).map { Math.abs(current[it] - current[it + 1]).toLong() }.sum()}","brute force,constructive algorithms,greedy"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"", ""DEPRECATION"")@file:OptIn(ExperimentalStdlibApi::class) import java.io.PrintWriterimport java.util.StringTokenizerimport kotlin.collections.ArrayDequeimport kotlin.math.*import java.util.TreeMapimport java.util.PriorityQueue// import java.util.*// import kotlin.random.* @JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out @JvmField val reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun readLn() = reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readString() = readStrings(1)[0]fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int = 2) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int = 2) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } // val isLocal = System.getenv(""IS_LOCAL_CP"") == ""true"" @JvmFieldval writer = PrintWriter(OUTPUT) // ---------------------------------------------------------------------------- class UnionFind {     private val parents = mutableMapOf<Int, Int>()    private val sizes = mutableMapOf<Int, Int>()     fun union(a: Int, b: Int) {        val fa = find(a)        val fb = find(b)        if (fa != fb) {            parents[fa] = fb            sizes[fb] = (sizes[fb] ?: 1) + (sizes[fa] ?: 1)        }    }     fun find(a: Int): Int {        fun getOrDefault(value: Int) = parents.getOrDefault(value, value)         var parent = getOrDefault(a)        while (parent != getOrDefault(parent)) {            parents[parent] = getOrDefault(getOrDefault(parent))            parent = parents[parent]!!        }        return parent    }     fun connected(a: Int, b: Int): Boolean {        return find(a) == find(b)    }     fun getSize(a: Int): Int {        return sizes[find(a)] ?: 1    }} class UnionFindArray(private val n: Int) {     private val parents = IntArray(n + 1) { it }     fun union(a: Int, b: Int) {        val fa = find(a)        val fb = find(b)        if (fa != fb) {            parents[fa] = fb        }    }     fun find(a: Int): Int {        var parent = parents[a]        while (parent != parents[parent]) {            parents[parent] = parents[parents[parent]]            parent = parents[parent]        }        return parent    }     fun connected(a: Int, b: Int): Boolean {        return find(a) == find(b)    }} class Trie() {     /** Initialize your data structure here. */    private val root = Node()     /** Inserts a word into the trie. */    fun insert(word: String) {        var node = root        for (char in word) {            if (!node.children.contains(char)) {                node.children[char] = Node()            }            node = node.children[char]!!        }        node.hasWord = true    }     /** Returns if the word is in the trie. */    fun search(word: String): Boolean {        return findNode(word)?.hasWord ?: false    }     /** Returns if there is any word in the trie that starts with the given prefix. */    fun startsWith(prefix: String): Boolean {        return findNode(prefix) != null    }     private fun findNode(prefix: String): Node? {        var node = root        for (char in prefix) {            node = node.children[char] ?: return null        }        return node    }     private class Node(        var hasWord: Boolean = false,        val children: MutableMap<Char, Node> = mutableMapOf<Char, Node>()    )} // 所有函数的下标从 0 开始// query(index): sum[0, index]class BinaryIndexedTree {     private val bit: IntArray     constructor(n: Int) {        this.bit = IntArray(n + 1)    }     constructor(nums: IntArray) {        this.bit = IntArray(nums.size + 1)        val prefix = IntArray(bit.size)        for (i in 1 until nums.size + 1) {            prefix[i] = prefix[i - 1] + nums[i - 1]            bit[i] = prefix[i] - prefix[i - lowbit(i)]        }    }     fun query(index: Int): Int {        var result = 0        var i = index + 1        while (i > 0) {            result += bit[i]            i -= lowbit(i)        }        return result    }     fun update(index: Int, x: Int) {        val value = query(index) - query(index - 1)        add(index, x - value)    }     fun add(index: Int, x: Int) {        var i = index + 1        while (i < bit.size) {            bit[i] += x            i += lowbit(i)        }    }     override fun toString(): String {        return IntArray(bit.size - 1) { query(it) - query(it - 1) }.toList().toString()    }     private fun lowbit(x: Int): Int {        return x.and(-x)    }} // 所有函数的下标从 0 开始// query(index): max[0, index]// udpate(index, x): 更新 [0, index] 之间的最大值，只能越来越大class BinaryIndexedTreeMax {     private val bit: IntArray     constructor(n: Int) {        this.bit = IntArray(n + 1)    }     fun query(index: Int): Int {        var result = 0        var i = index + 1        while (i > 0) {            result = Math.max(result, bit[i])            i -= lowbit(i)        }        return result    }     fun update(index: Int, x: Int) {        var i = index + 1        while (i < bit.size) {            bit[i] = Math.max(bit[i], x)            i += lowbit(i)        }    }     private fun lowbit(x: Int): Int {        return x.and(-x)    }} class SparseTableMax(private val nums: IntArray) {     private val st: Array<IntArray>     init {        val n = nums.size        val logN = Integer.numberOfTrailingZeros(Integer.highestOneBit(n))        this.st = Array(n * 2) { IntArray(logN + 1) }        for (i in 0 until n) {            st[i][0] = nums[i]        }        for (j in 1 until logN + 1) {            for (i in 0 until n) {                st[i][j] = st[i][j - 1]                if (i + 1.shl(j - 1) < n) {                    st[i][j] = Math.max(st[i][j], st[i + 1.shl(j - 1)][j - 1])                }            }        }    }     fun query(left: Int, right: Int): Int {        if (left > right) {            return -1        }        val len = right - left + 1        val k = Integer.numberOfTrailingZeros(Integer.highestOneBit(len))        return Math.max(st[left][k], st[right - 1.shl(k) + 1][k])    }} class SparseTableMin(private val nums: IntArray) {     private val st: Array<IntArray>     init {        val n = nums.size        val logN = Integer.numberOfTrailingZeros(Integer.highestOneBit(n))        this.st = Array(n * 2) { IntArray(logN + 1) { Int.MAX_VALUE / 2 } }        for (i in 0 until n) {            st[i][0] = nums[i]        }        for (j in 1 until logN + 1) {            for (i in 0 until n) {                st[i][j] = st[i][j - 1]                if (i + 1.shl(j - 1) < n) {                    st[i][j] = Math.min(st[i][j], st[i + 1.shl(j - 1)][j - 1])                }            }        }    }     fun query(left: Int, right: Int): Int {        if (left > right) {            return -1        }        val len = right - left + 1        val k = Integer.numberOfTrailingZeros(Integer.highestOneBit(len))        return Math.min(st[left][k], st[right - 1.shl(k) + 1][k])    }} class PrefixSum2D(private val grid: Array<IntArray>) {     private val prefix: Array<IntArray>     init {        val (m, n) = Pair(grid.size, grid[0].size)        prefix = Array(m + 1) { IntArray(n + 1) }        for (i in 0 until m) {            var row = 0            for (j in 0 until n) {                row += grid[i][j]                prefix[i + 1][j + 1] = prefix[i][j + 1] + row            }        }    }     fun query(up: Int, left: Int, bottom: Int, right: Int): Int {        return prefix[up][left] + prefix[bottom + 1][right + 1] -            prefix[bottom + 1][left] - prefix[up][right + 1]    }} // ---------------------------------------------------------------------------- private fun PrintWriter.printNums(nums: List<Int>) {    if (nums.isEmpty()) {        println()        return    }    for (i in 0 until nums.size - 1) {        print(nums[i])        print(' ')    }    println(nums.last())} private fun lengthOfLIS(numsInput: List<Int>): Int {    val nums = unify(numsInput)    val bit = BinaryIndexedTreeMax(nums.size + 1)    var result = 0    for (num in nums) {        val len = bit.query(num - 1) + 1        bit.update(num, len)        result = Math.max(result, len)    }    return result} private fun unify(nums: List<Int>): List<Int> {    val numToIndex = nums.sorted().mapIndexed { index, num -> num to index }.toMap()    return nums.map { numToIndex[it]!! }} private fun fastPow(a: Long, exp: Long, mod: Long): Long {    var result = 1L % mod    var base = a % mod    var remain = exp    while (remain != 0L) {        if (remain % 2L == 1L) {            result = (result * base) % mod        }        base = (base * base) % mod        remain /= 2L    }    return result} private fun gcd(a: Int, b: Int): Int {    return if (b == 0) a else gcd(b, a % b)} private fun gcdL(a: Long, b: Long): Long {    return if (b == 0L) a else gcdL(b, a % b)} private fun lcm(a: Int, b: Int): Int {    return ((a.toLong() * b.toLong()) / gcd(a, b)).toInt()} private fun lcmL(a: Long, b: Long): Long {    return (a * b) / gcdL(a, b)} private fun wordToCharCount(word: String): IntArray {    val charCount = IntArray(26)    for (char in word) {        charCount[char.toIndex()]++    }    return charCount} private fun Char.toIndex(): Int {    return this.toInt() - 'a'.toInt()} private fun Char.toDigit(): Int {    return this.toInt() - '0'.toInt()} private fun Boolean.toYesNo(upper: Boolean = false): String {    val yesNo = if (this) ""Yes"" else ""No""    return if (upper) yesNo.toUpperCase() else yesNo} private fun LongArray.modSum(mod: Long = MODL): Long {    var sum = 0L    for (num in this) {        sum = (sum + num) % mod    }    return sum} private fun IntArray.swap(i: Int, j: Int) {    val temp = this[i]    this[i] = this[j]    this[j] = temp} private fun LongArray.swap(i: Int, j: Int) {    val temp = this[i]    this[i] = this[j]    this[j] = temp} private fun CharArray.swap(i: Int, j: Int) {    val temp = this[i]    this[i] = this[j]    this[j] = temp} private fun <T> List<T>.toArrayDeque(): ArrayDeque<T> {    return ArrayDeque(this)} private fun <T> List<T>.toPair(): Pair<T, T> {    return Pair(this[0], this[1])} private fun <T> List<T>.listEquals(other: List<T>): Boolean {    return (0 until this.size).all { this[it] == other[it] }} private fun <T : Comparable<T>> List<T>.isSorted(): Boolean {    return this.listEquals(this.sorted())} private val DIR = listOf(    listOf(1, 0), listOf(0, -1), listOf(-1, 0), listOf(0, 1))  private const val MOD = 998244353private const val MODL = 998244353L// private const val MOD = 1000000007// private const val MODL = 1000000007Lprivate const val EPS = 0.000001 // ---------------------------------------------------------------------------- fun main() {    val go: Runnable = Runnable {        writer.solve()        writer.flush()    }    Thread(null, go, ""thread"", 1L.shl(28)).start()} private fun PrintWriter.solve() {    val t = readInt()    for (tx in 1 until t + 1) {        // print(""Case #$tx: "")        val (n, x) = readInts()        val nums = readInts(n)        println(insertAProg(nums, x))    }} private fun insertAProg(nums: List<Int>, x: Int): Long {    val result = (0 until nums.size - 1).map { Math.abs(nums[it] - nums[it + 1]).toLong() }.sum()    val min = nums.min()!!    val max = nums.max()!!    val t1 = if (min > 1) minOf(2 * (min - 1), nums[0] - 1, nums.last() - 1) else 0    val t2 = if (max < x) minOf(2 * (x - max), x - nums[0], x - nums.last()) else 0    return result + t1 + t2}  // private fun insertAProg(nums: List<Int>, x: Int): Long {//     var n = nums.size//     var current = nums//     if (nums.min()!! > 1) {//         var bestIndex = -1//         var bestValue = nums[0] - 1//         if (nums.last() - 1 < bestValue) {//             bestIndex = n - 1//             bestValue = nums.last() - 1//         }//         for (i in 0 until n - 1) {//             val current = (nums[i] + nums[i + 1] - 2) - Math.abs(nums[i] - nums[i + 1])//             if (current < bestValue) {//                 bestValue = current//                 bestIndex = i//             }//         }//         val left = nums.subList(0, bestIndex + 1)//         val right = nums.subList(bestIndex + 1, n)//         current = left + listOf(1) + right//     }//     // println(current)//     n = current.size//     if (nums.max()!! < x) {//         var bestIndex = -1//         var bestValue = Math.abs(current[0] - x)//         if (Math.abs(current.last() - x) < bestValue) {//             bestIndex = n - 1//             bestValue = Math.abs(current.last() - x)//         }//         for (i in 0 until n - 1) {//             val current = (Math.abs(current[i] - x) + Math.abs(current[i + 1] - x)) - Math.abs(current[i] - current[i + 1])//             if (current < bestValue) {//                 bestValue = current//                 bestIndex = i//             }//         }//         val left = current.subList(0, bestIndex + 1)//         val right = current.subList(bestIndex + 1, n)//         current = left + listOf(x) + right//     }//     // println(current)//     return (0 until current.size - 1).map { Math.abs(current[it] - current[it + 1]).toLong() }.sum()// }","brute force,constructive algorithms,greedy"
"import kotlin.math.* fun readInts() = readLine()!!.split(' ').map(String::toInt) fun main(args : Array<String>) {  val (t) = readInts()  for (test in 1 .. t) {    var (n, x) = readInts()    var ints = readInts().map { it.toLong() }.toTypedArray()    var result = 0L    var minimum = ints[0]    var maximum = ints[0]    for (i in 1 until n) {      result += abs(ints[i] - ints[i - 1])      if (ints[i] < minimum) minimum = ints[i]      if (ints[i] > maximum) maximum = ints[i]    }    result += min(min(2 * abs(minimum - 1), abs(1 - ints[0])), abs(1 - ints[n - 1]))    if (maximum < x)      result += min(min(2 * abs(maximum - x), abs(x - ints[0])), abs(x - ints[n - 1]))    println(result)  }}","brute force,constructive algorithms,greedy"
"fun readInts() = readLine()!!.split(' ').map { it.toInt() }fun readInt() = readLine()!!.toInt() fun main() {    val t = readInt()    repeat(t) {        var (n, k) = readInts()        val a = readInts()        var maxAnd = 0        for (j in 30 downTo 0) {            var zerosCnt = 0            for (i in 0 until n) {                if (a[i] and (1 shl j) == 0) zerosCnt++            }            if (zerosCnt == 0) {                maxAnd = maxAnd or (1 shl j)            } else if (k >= zerosCnt) {                k -= zerosCnt                maxAnd = maxAnd or (1 shl j)            }        }        println(maxAnd)    }}","bitmasks,greedy,math"
"fun main(args : Array<String>) {    val t = readLine()!!.trim().toInt()     repeat(t) {        val (n, k) = readLine()!!.trim().split("" "").map { it.toInt() }        val aa = readLine()!!.trim().split("" "").map { it.toInt() }        val bitCnt = mutableListOf<Int>()         for (i in 0..30) {            bitCnt.add(aa.map { it.shr(i) % 2 }.sum())        }         var pos = 30        var kRest = k        while (kRest > 0 && pos > -1) {            if ((n-bitCnt[pos]) <= kRest) {                kRest -= (n-bitCnt[pos])                bitCnt[pos] = n            }            pos--        }         var ans = 0        for (i in 0..30) {            if (bitCnt[i] == n) {                ans += Math.pow(2.0, i.toDouble()).toInt()            }        }         println(ans)    }}","bitmasks,greedy,math"
"import java.io.*import java.util.*import kotlin.math.* val INPUT = System.`in`!!val OUTPUT = System.out!!val reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun line() = reader.readLine()!!var st: StringTokenizer = StringTokenizer("""")fun read(): String {    while (st.hasMoreTokens().not())        st = StringTokenizer(reader.readLine() ?: return """", "" "")    return st.nextToken()}fun int() = read().toInt()fun ints(n: Int) = List(n) { read().toInt() }fun intArray(n: Int) = IntArray(n) { read().toInt() }fun long() = read().toLong()fun longs(n: Int) = List(n) { read().toLong() }fun longArray(n: Int) = LongArray(n) { read().toLong() }val writer = PrintWriter(OUTPUT, false)fun main() { writer.solve(); writer.flush() }fun PrintWriter.solve() {    var tt = 1    tt = int()    while (tt-- > 0) {        var (n, k) = ints(2)        val arr = intArray(n)        val bits = Array(n) { IntArray(31) }        for(i in arr.indices) {            var x = arr[i]            for(j in 30 downTo 0) {                if(x % 2 == 1) {                    bits[i][j]++                }                x /= 2            }        }        for(j in 0..30) {            var needed = 0            for(i in 0 until n) {                if(bits[i][j] == 0) needed++            }            if(needed <= k) {                for(i in 0 until n) {                    bits[i][j] = 1                }                k -= needed            }        }        val res = IntArray(31)        for(j in 0..30) {            var ans = 1            for(i in 0 until n) {                ans = ans and bits[i][j]            }            res[j] = ans        }        var final = 0; var count = 0        for(i in 30 downTo 0) {            if(res[i] == 1) {                final += 2.0.pow(count).toInt()            }            count++        }        println(final)    }}","bitmasks,greedy,math"
"import java.io.BufferedInputStreamimport java.io.PrintWriterimport java.util.*import kotlin.system.measureTimeMillisobject IO{	private const val BS = 1 shl 16	private const val NC = 0.toChar()	private val buf = ByteArray(BS)	private var bId = 0	private var size = 0	private var c = NC 	var warningActive = true	var fakein = StringBuilder() 	private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)	val OUT: PrintWriter = PrintWriter(System.out) 	private val char: Char		get() {			while (bId == size) {				size = IN.read(buf) // no need for checked exceptions				if (size == -1) return NC				bId = 0			}			return buf[bId++].toChar()		} 	fun nextInt(): Int {		var neg = false		if (c == NC) c = char		while (c < '0' || c > '9') {			if (c == '-') neg = true			c = char		}		var res = 0		while (c in '0'..'9') {			res = (res shl 3) + (res shl 1) + (c - '0')			c = char		}		return if (neg) -res else res	}	fun nextLong(): Long {		var neg = false		if (c == NC) c = char		while (c < '0' || c > '9') {			if (c == '-') neg = true			c = char		}		var res = 0L		while (c in '0'..'9') {			res = (res shl 3) + (res shl 1) + (c - '0')			c = char		}		return if (neg) -res else res	}	fun nextString():String{		val ret = StringBuilder()		while (true){			c = char			if(!isWhitespace(c)){ break}		}		ret.append(c)		while (true){			c = char			if(isWhitespace(c)){ break}			ret.append(c)		}		return ret.toString()	}	fun isWhitespace(c:Char):Boolean{		return c == ' ' || c == '\n' || c == '\r' || c == '\t'	}}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }val getint:Int get() = IO.nextInt()val getlong:Long get() = IO.nextLong()val getstr:String get() = IO.nextString()fun getline(n:Int):IntArray{	return IntArray(n){getint}}fun getlineL(n:Int):LongArray{	return LongArray(n){getlong}} fun main(){    val t = getint    repeat(t) { _ ->        var n = getint        var k = getint        val s = getline(n)        var ans = 0        val g = IntArray(31){0}        for (q in 0 until n) {            for (r in 0 until 31) {                if ((s[q] and (1 shl r))==0) {                    g[r]++                }            }        }        for (m in 0 until 31) {            var m2 = 30 - m            if (k>=g[m2]) {                k-=g[m2]                ans+=(1 shl m2)            }        }        put(ans)    }    done()}","bitmasks,greedy,math"
"import java.util.*import kotlin.math.*  fun main(args: Array<String>) {     val number = readLine()!!.toInt()    for(i in 0 until number){        val rat = readLine()!!.toInt()        val array = readLine()!!.split("" "").map { it.toInt() }        var all = false        val odd = mutableListOf<Int>()        val even = mutableListOf<Int>()        for(ind in 0 until array.size step 2){            odd.add(array[ind])        }        for(ind in 1 until array.size step 2){            even.add(array[ind])        }        all = odd.all { it % 2 == 0 } or odd.all { it % 2 == 1 }        all = all and (even.all { it % 2 == 0 } or even.all{it % 2 == 1 })        if(all){            println(""YES"")        }else{            println(""NO"")        }     }  }","greedy,greedy,implementation,math"
"/** * Accomplished using the EduTools plugin by JetBrains https://plugins.jetbrains.com/plugin/10081-edutools * * To modify the template, go to Preferences -> Editor -> File and Code Templates -> Other */ fun main() {    val t = readLine()!!.toInt()    repeat(t) {        val n = readLine()!!.toInt()        val a = readLine()!!.split(' ').map { it.toInt() }        val odd1 = a[0] % 2 == 0        val odd2 = a[1] % 2 == 0        var ok = true        for (i in 0 until a.size step 2) {            val cur = a[i] % 2 == 0            if (cur != odd1) ok = false        }        for (i in 1 until a.size step 2) {            val cur = a[i] % 2 == 0            if (cur != odd2) ok = false        }        if (ok) {            println(""YES"")        } else {            println(""NO"")        }    }}","greedy,greedy,implementation,math"
"fun main(args : Array<String>) {    val t = readLine()!!.trim().toInt()     repeat(t) {        val n = readLine()!!.trim().toInt()        val aa = readLine()!!.trim().split("" "").map { it.toInt() }         var oe = 0        var oo = 0        var ee = 0        var eo = 0         aa.forEachIndexed { idx, i ->            if (idx % 2 == 0) {                if (i % 2 == 0) {                    oe++                } else {                    oo++                }            } else {                if (i % 2 == 0) {                    ee++                } else {                    eo++                }            }        }         if ((oe == 0 || oo == 0) && (ee == 0 || eo == 0)) {            println(""Yes"")        } else {            println(""No"")        }    }}","greedy,greedy,implementation,math"
"fun main() {    val number = readLine()?.toInt() ?: 0    val output = StringBuilder()    for (i in 0 until number) {        val num = readLine()?.toInt() ?: 0        val lists = (readLine()?: """").split("" "").map { it.toInt() }        if (isAllSame(lists)){            output.append(""YES\n"")        }else {            val odds =  lists.mapIndexed { index, i ->  if (index % 2 == 0 )  i + 1 else i}            if (isAllSame(odds)){                output.append(""YES\n"")            }else{                val evens =  lists.mapIndexed { index, i ->  if (index % 2 == 1 )  i + 1 else i}                if (isAllSame(evens)){                    output.append(""YES\n"")                }else{                    output.append(""NO\n"")                }            }        }    }    print(output.toString())}  fun isAllSame(lists: List<Int>): Boolean {    return lists.all { it % 2 == 0 } or lists.all { it % 2 != 0 }}","greedy,greedy,implementation,math"
"import java.util.*import kotlin.math.max fun main() {    val out = StringBuilder()    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()        val prefixes = LongArray(n + 1)        val tokenizer = StringTokenizer(readLine()!!)        for (j in 1..n) {            prefixes[j] = prefixes[j - 1] + tokenizer.nextToken().toLong()        }        val xix = mutableMapOf<Long, Int>()        for ((j, x) in prefixes.toSet().sorted().withIndex()) {            xix[x] = j        }        val dp = IntArray(n + 1)        val mapLatest = mutableMapOf<Long, Int>()        mapLatest[0L] = 0        val segTree = SegmentTree(0, xix.size - 1)        segTree.value.fill(Int.MIN_VALUE)        segTree[xix[0L]!!] = 0        for (j in 1..n) {            dp[j] = dp[j - 1] - 1            val ix = xix[prefixes[j]]!!            dp[j] = max(dp[j], j + segTree[0, ix - 1])            if (prefixes[j] in mapLatest) {                dp[j] = max(dp[j], mapLatest[prefixes[j]]!!)            }            mapLatest[prefixes[j]] = dp[j]            segTree[ix] = max(segTree[ix], dp[j] - j)        }        out.appendln(dp[n])    }    print(out)} class SegmentTree(val treeFrom: Int, treeTo: Int) {    val value: IntArray    val length: Int     init {        var e = 0        while (1 shl e < treeTo - treeFrom + 1) {            e++        }        value = IntArray(1 shl (e + 1))        length = 1 shl e    }     operator fun set(index: Int, delta: Int) {        var node = index - treeFrom + length        value[node] = delta        node = node shr 1        while (node > 0) {            value[node] = max(value[node shl 1], value[(node shl 1) + 1])            node = node shr 1        }    }     operator fun get(index: Int) = value[index - treeFrom + length]     operator fun get(fromIndex: Int, toIndex: Int): Int {        if (toIndex < fromIndex) {            return Int.MIN_VALUE        }        var from = fromIndex + length - treeFrom        var to = toIndex + length - treeFrom + 1        var res: Int = Int.MIN_VALUE        while (from + (from and -from) <= to) {            res = max(res, value[from / (from and -from)])            from += from and -from        }        while (to - (to and -to) >= from) {            res = max(res, value[(to - (to and -to)) / (to and -to)])            to -= to and -to        }        return res    }}","data structures,dp"
"import java.io.BufferedReaderimport kotlin.math.maximport kotlin.math.min fun main() {    val br = System.`in`.bufferedReader()    val bw = System.out.bufferedWriter()    val t = br.readInt()    repeat(t) {        val n = br.readInt()        val a = LongArray(n) { br.readInt().toLong() }        val prefix = LongArray(n + 1)        for (i in 0 until n) {            prefix[i + 1] = prefix[i] + a[i]        }        val segTree = OptimalSegment(n + 1)        val dp = IntArray(n + 1)        val sorted = (0..n).sortedWith { u, v ->            if (prefix[u] == prefix[v]) {                v.compareTo(u)            } else {                prefix[u].compareTo(prefix[v])            }        }.toIntArray()        val revSorted = IntArray(n + 1)        for (i in 0..n) {            revSorted[sorted[i]] = i        }        segTree.setMax(revSorted[0], 0)        for (i in 1..n) {            dp[i] = if (a[i - 1] == 0L) {                dp[i - 1]            } else {                dp[i - 1] - 1            }             dp[i] = max(dp[i], segTree.getMax(0, revSorted[i]) + i)             segTree.setMax(revSorted[i], dp[i] - i)        }        bw.append(""${dp.last()}\n"")    }    bw.flush()} private class OptimalSegment(private val n: Int) {    private val tree = IntArray(n shl 1) { Int.MIN_VALUE }     fun setMax(index: Int, value: Int) {        var cur = index + n        while (cur != 0 && value > tree[cur]) {            tree[cur] = value            cur = cur shr 1        }    }      fun getMax(begin: Int, end: Int): Int {        var left = begin + n        var right = end + n        var ans = Int.MIN_VALUE        while (left <= right) {            if (left and 1 == 1) ans = max(ans, tree[left++])            if (right and 1 == 0) ans = max(ans, tree[right--])            left = left shr 1            right = right shr 1        }        return ans    }} //private class OptimalSegment(prefix: LongArray) {//    private val n = Integer.highestOneBit((prefix.size shl 1) - 1)//    private val mins = LongArray(n shl 1)////    init {//        for (i in prefix.indices) {//            mins[i + n] = prefix[i]//        }//        for (i in n - 1 downTo 1) {//            mins[i] = min(mins[i.left()], mins[i.right()])//        }//    }////    fun get(end: Int, v: Long): Int {//        return get(0, end, 1, 0, n - 1, v)//    }////    private fun get(beginTot: Int, endTot: Int, id: Int, begin: Int, end: Int, v: Long): Int {//        val d = (begin + end) shr 1//        if (begin > endTot) return -1//        return if (begin == end) {//            begin//        } else {//            if (mins[id.left()] < v) {//                get(beginTot, endTot, id.left(), begin, d, v)//            } else if (mins[id.right()] < v) {//                get(beginTot, endTot, id.right(), d + 1, end, v)//            } else {//                -1//            }//        }//    }////    private fun Int.right() = (this shl 1) + 1//    private fun Int.left() = this shl 1//} private const val SPACE_INT = ' '.toInt()private const val ZERO_INT = '0'.toInt()private const val NL_INT = '\n'.toInt() private fun BufferedReader.readInt(): Int {    var ret = read()    while (ret <= SPACE_INT) {        ret = read()    }    val neg = ret == '-'.toInt()    if (neg) {        ret = read()    }    ret -= ZERO_INT    var read = read()    while (read >= ZERO_INT) {        ret *= 10        ret += read - ZERO_INT        read = read()    }     while (read <= SPACE_INT && read != -1 && read != NL_INT) {        mark(1)        read = read()    }    if (read > SPACE_INT) {        reset()    }    return if (neg) -ret else ret}","data structures,dp"
"import java.io.BufferedReaderimport kotlin.math.maximport kotlin.math.min fun main() {    val br = System.`in`.bufferedReader()    val bw = System.out.bufferedWriter()    val t = br.readInt()    repeat(t) {        val n = br.readInt()        val a = LongArray(n) { br.readInt().toLong() }        val prefix = LongArray(n + 1)        for (i in 0 until n) {            prefix[i + 1] = prefix[i] + a[i]        }        val segTree = OptimalSegment(n + 1)        val dp = IntArray(n + 1)        val sorted = (0..n).sortedWith { u, v ->            if (prefix[u] == prefix[v]) {                u.compareTo(v)            } else {                prefix[u].compareTo(prefix[v])            }        }.toIntArray()        val revSorted = IntArray(n + 1)        for (i in 0..n) {            revSorted[sorted[i]] = i        }        segTree.setMax(revSorted[0], 0)        for (i in 1..n) {            var low = 0            var high = n            while (low < high) {                val mid = (low + high) shr 1                if (prefix[sorted[mid]] < prefix[i]) {                    low = mid + 1                } else {                    high = mid                }            }            dp[i] = if (a[i - 1] == 0L) {                dp[i - 1]            } else {                dp[i - 1] - 1            }             dp[i] = max(dp[i], segTree.getMax(0, low - 1) + i)             segTree.setMax(revSorted[i], dp[i] - i)        }        bw.append(""${dp.last()}\n"")    }    bw.flush()} private class OptimalSegment(private val n: Int) {    private val tree = IntArray(n shl 1) { Int.MIN_VALUE } // stores right edge of active zones     fun setMax(index: Int, value: Int) {        var cur = index + n        while (cur != 0 && value > tree[cur]) {            tree[cur] = value            cur = cur shr 1        }    }      fun getMax(begin: Int, end: Int): Int {        var left = begin + n        var right = end + n        var ans = Int.MIN_VALUE        while (left <= right) {            if (left and 1 == 1) ans = max(ans, tree[left++])            if (right and 1 == 0) ans = max(ans, tree[right--])            left = left shr 1            right = right shr 1        }        return ans    }} //private class OptimalSegment(prefix: LongArray) {//    private val n = Integer.highestOneBit((prefix.size shl 1) - 1)//    private val mins = LongArray(n shl 1)////    init {//        for (i in prefix.indices) {//            mins[i + n] = prefix[i]//        }//        for (i in n - 1 downTo 1) {//            mins[i] = min(mins[i.left()], mins[i.right()])//        }//    }////    fun get(end: Int, v: Long): Int {//        return get(0, end, 1, 0, n - 1, v)//    }////    private fun get(beginTot: Int, endTot: Int, id: Int, begin: Int, end: Int, v: Long): Int {//        val d = (begin + end) shr 1//        if (begin > endTot) return -1//        return if (begin == end) {//            begin//        } else {//            if (mins[id.left()] < v) {//                get(beginTot, endTot, id.left(), begin, d, v)//            } else if (mins[id.right()] < v) {//                get(beginTot, endTot, id.right(), d + 1, end, v)//            } else {//                -1//            }//        }//    }////    private fun Int.right() = (this shl 1) + 1//    private fun Int.left() = this shl 1//} private const val SPACE_INT = ' '.toInt()private const val ZERO_INT = '0'.toInt()private const val NL_INT = '\n'.toInt() private fun BufferedReader.readInt(): Int {    var ret = read()    while (ret <= SPACE_INT) {        ret = read()    }    val neg = ret == '-'.toInt()    if (neg) {        ret = read()    }    ret -= ZERO_INT    var read = read()    while (read >= ZERO_INT) {        ret *= 10        ret += read - ZERO_INT        read = read()    }     while (read <= SPACE_INT && read != -1 && read != NL_INT) {        mark(1)        read = read()    }    if (read > SPACE_INT) {        reset()    }    return if (neg) -ret else ret}","data structures,dp"
"import java.io.BufferedReaderimport kotlin.math.maximport kotlin.math.min fun main() {    val br = System.`in`.bufferedReader()    val bw = System.out.bufferedWriter()    val t = br.readInt()    repeat(t) {        val n = br.readInt()        val a = LongArray(n) { br.readInt().toLong() }        val prefix = LongArray(n + 1)        for (i in 0 until n) {            prefix[i + 1] = prefix[i] + a[i]        }        val segTree = OptimalSegment(n + 1)        val dp = IntArray(n + 1)        val sorted = (0..n).sortedWith { u, v ->            if (prefix[u] == prefix[v]) {                u.compareTo(v)            } else {                prefix[u].compareTo(prefix[v])            }        }.toIntArray()        val revSorted = IntArray(n + 1)        for (i in 0..n) {            revSorted[sorted[i]] = i        }        segTree.setMax(revSorted[0], 0)        for (i in 1..n) {            var low = 0            var high = n            while (low < high) {                val mid = (low + high) shr 1                if (prefix[sorted[mid]] < prefix[i]) {                    low = mid + 1                } else {                    high = mid                }            }            val c1 = if (low == 0) i else sorted[segTree.getMax(0, low - 1)]             dp[i] = -1 + dp[i - 1]             if (revSorted[i] != 0 && prefix[i] == prefix[sorted[revSorted[i] - 1]]) {                val c2 = sorted[revSorted[i] - 1]                dp[i] = max(dp[i], dp[c2])            }             if (c1 < i) {                dp[i] = max(dp[i], dp[c1] + i - c1)            }            segTree.setMax(revSorted[i], dp[i] - i)        }        bw.append(""${dp.last()}\n"")    }    bw.flush()} private class OptimalSegment(private val n: Int) {    private val underLying = IntArray(n) { Int.MIN_VALUE }    private val treeMax = IntArray(n shl 1) { it - n }     init {        for (i in n - 1 downTo 1) {            if (underLying[treeMax[i.left()]] > underLying[treeMax[i.right()]]) {                treeMax[i] = treeMax[i.left()]            } else {                treeMax[i] = treeMax[i.right()]            }        }    }     fun setMax(index: Int, value: Int) {        underLying[index] = value        var cur = index + n        while (cur != 0 && (treeMax[cur] == index || value > underLying[treeMax[cur]])) {            treeMax[cur] = index            cur = cur shr 1        }    }      fun getMax(begin: Int, end: Int): Int {        var left = begin + n        var right = end + n        var ans = begin        while (left <= right) {            if (left and 1 == 1) {                if (underLying[treeMax[left++]] > underLying[ans]) {                    ans = treeMax[left - 1]                }            }            if (right and 1 == 0) {                if (underLying[treeMax[right--]] > underLying[ans]) {                    ans = treeMax[right + 1]                }            }             left = left shr 1            right = right shr 1        }        return ans    }     private fun Int.right() = (this shl 1) + 1    private fun Int.left() = this shl 1} //private class OptimalSegment(prefix: LongArray) {//    private val n = Integer.highestOneBit((prefix.size shl 1) - 1)//    private val mins = LongArray(n shl 1)////    init {//        for (i in prefix.indices) {//            mins[i + n] = prefix[i]//        }//        for (i in n - 1 downTo 1) {//            mins[i] = min(mins[i.left()], mins[i.right()])//        }//    }////    fun get(end: Int, v: Long): Int {//        return get(0, end, 1, 0, n - 1, v)//    }////    private fun get(beginTot: Int, endTot: Int, id: Int, begin: Int, end: Int, v: Long): Int {//        val d = (begin + end) shr 1//        if (begin > endTot) return -1//        return if (begin == end) {//            begin//        } else {//            if (mins[id.left()] < v) {//                get(beginTot, endTot, id.left(), begin, d, v)//            } else if (mins[id.right()] < v) {//                get(beginTot, endTot, id.right(), d + 1, end, v)//            } else {//                -1//            }//        }//    }////    private fun Int.right() = (this shl 1) + 1//    private fun Int.left() = this shl 1//} private const val SPACE_INT = ' '.toInt()private const val ZERO_INT = '0'.toInt()private const val NL_INT = '\n'.toInt() private fun BufferedReader.readInt(): Int {    var ret = read()    while (ret <= SPACE_INT) {        ret = read()    }    val neg = ret == '-'.toInt()    if (neg) {        ret = read()    }    ret -= ZERO_INT    var read = read()    while (read >= ZERO_INT) {        ret *= 10        ret += read - ZERO_INT        read = read()    }     while (read <= SPACE_INT && read != -1 && read != NL_INT) {        mark(1)        read = read()    }    if (read > SPACE_INT) {        reset()    }    return if (neg) -ret else ret}","data structures,dp"
"fun main() {    repeat(readLine()!!.toInt()) {        var answer = 0L        for (d in 0..29) {            val b = 1L shl d            println(""? ${b - answer} ${(3L * b) - answer}"")            if (readLine()!!.toLong() == 2L * b) {                answer += b            }        }        println(""! $answer"")    }}","bitmasks,chinese remainder theorem,constructive algorithms,games,interactive,math,number theory"
"import java.io.PrintWriterimport java.util.StringTokenizerimport java.util.*import kotlin.math.powimport kotlin.math.sqrt private val INPUT = System.`in`private val OUTPUT = System.out private val bufferedReader = INPUT.bufferedReader()private val outputWriter = PrintWriter(OUTPUT, false)private fun readLn() = bufferedReader.readLine()!! private fun readList() = readLn().split(' ')private var tokenizer = StringTokenizer("""")private fun read(): String {    while (tokenizer.hasMoreTokens().not()) tokenizer = StringTokenizer(readLn(), "" "")    return tokenizer.nextToken()} private fun readInt() = read().toInt()private fun readLong() = read().toLong()private fun readDouble() = read().toDouble() private fun readIntList() = readList().map { it.toInt() }private fun readLongList() = readList().map { it.toLong() }private fun readDoubleList() = readList().map { it.toDouble() } private fun readIntArray(n: Int = 0) =    if (n == 0) readList().run { IntArray(size) { get(it).toInt() } } else IntArray(n) { readInt() } private fun readLongArray(n: Int = 0) =    if (n == 0) readList().run { LongArray(size) { get(it).toLong() } } else LongArray(n) { readLong() } private fun readDoubleArray(n: Int = 0) =    if (n == 0) readList().run { DoubleArray(size) { get(it).toDouble() } } else DoubleArray(n) { readDouble() }  private fun Int.modPositive(other: Int): Int = if (this % other < 0) ((this % other) + other) else (this % other)  private class Main {    fun solveTestCase() {        var k = 1        var ans = 0        repeat (30) {            var res = 0            println(""? ${k-ans} ${3*k-ans}"")            res = readInt()            if (res == k+k) ans += k            k += k        }        println(""! $ans"")    }} fun main(args: Array<String>) {    repeat(readInt()) {        Main()            .solveTestCase()    }}","bitmasks,chinese remainder theorem,constructive algorithms,games,interactive,math,number theory"
"/** * Hmmm isn't this really easy? * Reminds me of the golf gopher problem *  Let us consider gcd(x+1, x+b) for b in 1+[2,3,5,7,11,...] * If it is NOT one then (b-1) divides (x+1) * This way we can find out the prime factors but not the powers in which they appear *  -> Re-ask with (b-1)**2 + 1 ? * Nah that only covers factors up to the 30th prime 131 -> 131**2 = 17161 * We can guess multiple primes at once like *  b = 1 + (2 + 3 + 5) * I guess we do have to look at the result *  2**30 > 10**9  -> 2 can appear a maximum of 30 times in number * Cram primes in their maximum allowable power (maxOccur) * Then take mod to find out actualOccur * * My solution works but the primes here are so large (up to 31607) that it will never work :( * I mean what if we have a fiendish number like *  31607 * 31601 = 998812807 * How are we ever gonna guess the prime factors / get a gcd other than 1 ??? * * Wait *  2**30 ~= 10**9 * Is this binary search * If we could guess a = b this would be trivial -> gcd is x+a itself * do we just guess *  gcd(x + 2**i, x + 2**(i+1)) ? * * OK * Assume x is odd *  gcd(x + 1, x + 3)  =  bin[-1] *  gcd(x + 1, x + 5)  =  bin[-2] * So *  gcd(x + 1, x + 1 + 2**(i+1)) < 2**(i+1) * builds up the binary representation of (x+1) */ fun main() {    val t = readLine()!!.toInt()    (1..t).forEach {        var guess = 1L        val bin = (1..30).map { power ->            println(""? ${guess} ${guess + (1L shl power)}"")  // 2**power            val binny = readLine()!!.toLong() == (1L shl power)            if (!binny)                guess += (1L shl (power - 1))  // adjust so higher number is def a factor            binny        }        //println(bin)        val res = (0..29).map { if (bin[it]) (1L shl it) else 0L }.sum()        println(""! $res"")  // x    }}","bitmasks,chinese remainder theorem,constructive algorithms,games,interactive,math,number theory"
"import java.io.BufferedReaderimport java.io.BufferedWriter class ProblemD {    private fun BufferedReader.readInt() : Int = this.readLine().toInt()    private fun BufferedReader.readIntArray(delimiter: String = "" "") =        this.readLine().split(delimiter).map { it.toInt() }.toIntArray()    private fun BufferedReader.readLongArray(delimiter: String = "" "") =        this.readLine().split(delimiter).map { it.toLong() }.toLongArray()     private fun BufferedWriter.writeLine(s: String) {        this.write(s)        this.newLine()        this.flush()    }     private fun IntArray.swap(i: Int, j:Int) {        val tmp = this[i]        this[i] = this[j]        this[j] = tmp    }    private fun readLong(input: BufferedReader) : Long {        for(i in 1..5){            val line = input.readLine()            if (line != null && line.trim().isNotEmpty()) {                return line.toLong()            }        }        throw IllegalStateException()    }     private fun solveTest(input: BufferedReader, output: BufferedWriter) {        var numSoFar = 0L        val nVal = 1L shl 30        for(i in 0..29) {            val a = (1L shl i)            val b = nVal + a            if(a > 2*1e9 || b > 2*1e9)  break            output.writeLine(""? ${a-numSoFar} ${b-numSoFar}"")            val k = input.readLongArray()[0]            if((k % (1L shl (i+1))) == 0L) {                numSoFar = numSoFar or (1L shl i)            }        }          output.writeLine(""! $numSoFar"")        output.flush()    }     fun solve(input: BufferedReader, output: BufferedWriter) {        val test = input.readInt()        for(t in 0 until test) {            solveTest(input, output)        }        input.close()        output.close()    } } fun main() {    val solution = ProblemD()    solution.solve(System.`in`.bufferedReader(), System.out.bufferedWriter())}","bitmasks,chinese remainder theorem,constructive algorithms,games,interactive,math,number theory"
"import java.util.*import kotlin.math.max fun main() {  val (n, m) = readLine()!!.split("" "").map { it.toInt() }  val p = readLine()!!.split("" "").map { it.toLong() }  val x = readLine()!!.split("" "").map { it.toLong() * 2 }   val shops = TreeSet<Long>().apply { addAll(x) }    val huts = Array(p.size) { Hut(p[it], 200L * it) }   val changes = mutableListOf<Change>()  for (hut in huts) {    val left = shops.floor(hut.x)    val right = shops.ceiling(hut.x)     var r = 1e18.toLong()    if (left != null && r > hut.x - left) r = hut.x - left    if (right != null && r > right - hut.x) r = right - hut.x     if (r == 0L) continue     changes.add(Change(max(hut.x - r + 1, 0), hut.p))    changes.add(Change(hut.x + r, -hut.p))  }   changes.sortBy { it.x }   var best = 0L  var cur = 0L   for (change in changes) {    cur += change.p    if (best < cur) best = cur  }   println(best)} data class Change(val x: Long, val p: Long) data class Hut(val p: Long, val x: Long)","brute force,implementation,sortings"
"// $time$import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.system.measureTimeMillisimport java.util.TreeMapimport java.util.TreeSetimport kotlin.math.ln inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        val S = fakein.toString()        println(""New Case "")        println(S.take(80))        println(""..."")        fakein.clear()        IN = BufferedInputStream(S.byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} val getintfast:Int get() = IO.nextInt()val getint:Int get(){ val ans = getlong ; if(ans > Int.MAX_VALUE) IntArray(1000000000); return ans.toInt() }val getlong:Long get() = IO.nextLong()val getstr:String get() = IO.nextString()fun getline(n:Int):IntArray{    return IntArray(n){getint}}fun getlineL(n:Int):LongArray{    return LongArray(n){getlong}}fun getbinary(n:Int, asTrue:Char):BooleanArray{    val str = getstr    return BooleanArray(n){str[it] == asTrue}} val List<Char>.ret:Stringget() = this.joinToString("""")var dmark = -1infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    dmark++    var str = ""<${dmark}>   ""    debug()    if(this is String){ str += this    }else if(this is Int){ str += this.toString()    }else if(this is Long){ str += this.toString()    }else{ str += this.toString()}    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is BooleanArray){ println(""$str :${a.map{if(it)'1' else '0'}.joinToString("" "")}"")    }else if(a is Array<*>){        println(""$str : "")        for(c in a){if(c is IntArray){println(c.joinToString("" ""))}        else if(c is LongArray){println(c.joinToString("" ""))}        else if(c is BooleanArray){println(c.map { if(it) '1' else '0' }.joinToString(""""))        }         }        println()    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){    throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){        throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    fun cases(onecase:()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint} else if(mode == solveMode.tc){1 } else randCount        //safety checks        if(pI != 998_244_353 && pI != 1_000_000_007){            throw Exception(""Modding a wrong prime!"")        }        if(withBruteForce){            println(""Brute force is active"")        }         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            onecase()        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }}inline fun<T> T.alsoBrute(cal:() -> T){    if(!withBruteForce) return    val also = cal()    if(this != also){        println(""Checking failed: Got ${this} Brute ${also}"")        crash()    }}// 1. Moddedconst val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}infix fun Int.modM(b:Int):Int{ return ((this.toLong() * b) % pI).toInt() }infix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }fun intPow(x:Int,e:Int,m:Int):Int{    var X = x ; var E =e ; var Y = 1    while(E > 0){        if(E and 1 == 0){            X = ((1L * X * X) % m).toInt()            E = E shr 1        }else{            Y = ((1L * X * Y) % m).toInt()            E -= 1        }    }    return Y}// 2. DP initial valuesconst val plarge = 1_000_000_727const val nlarge = -plargeconst val phuge = 2_727_000_000_000_000_000Lconst val nhuge = -phuge// 3. conveniecen conversionsval Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionval Char.code :Int get() = this.toInt() -  'a'.toInt()//3. hard to write stufffun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val mint:MutableList<Int> get() = mutableListOf<Int>()val mong:MutableList<Long> get() = mutableListOf<Long>()//4. more outputsfun List<Char>.conca():String = this.joinToString("""")val CharArray.conca :String get() = this.joinToString("""")val IntArray.conca :String get() = this.joinToString("" "")@JvmName(""concaInt"")fun List<Int>.conca():String = this.joinToString("" "")val LongArray.conca:String get() = this.joinToString("" "")@JvmName(""concaLong"")fun List<Long>.conca():String = this.joinToString("" "")//5. Pair of intsconst val longmask = (1L shl 32) - 1fun makepair(a:Int, b:Int):Long = (a.toLong() shl 32) xor (longmask and b.toLong()) // remember positev sonlyval Long.first get() = (this ushr 32).toInt()val Long.second get() = this.toInt()//6. stringsval String.size get() = this.lengthconst val randCount = 100//7. bitsfun Int.has(i:Int):Boolean = (this and (1 shl i) != 0)   object sieve{     const val sieveMx = 50005    val primeOf = IntArray(sieveMx + 1)    var primeCounter = 0    val primeUpperBound = maxOf(25,(sieveMx.toDouble()/(ln(sieveMx.toDouble()) -4)).toInt() +3)    val primes = IntArray(primeUpperBound)    var sieveCalculated = false    val nextPrime = IntArray(sieveMx+1)    val nextPrimePower = IntArray(sieveMx+1)    val afterPrimePowerDivison = IntArray(sieveMx+1)    var mobius = IntArray(0)     var factors:List<MutableList<Int>> = mutableListOf()     fun calculateSieveFast(){        if(sieveCalculated){            return        }        sieveCalculated = true        for(i in 2..sieveMx){            if(primeOf[i] == 0 ){                primeOf[i] = i                primes[primeCounter] = i                primeCounter += 1            }            for(j in 0 until primeCounter){                val p = primes[j]                val pd = p * i                if(p <= i && pd <= sieveMx){                    primeOf[pd] = p                }else{                    break                }            }        }    }    fun preparePrimePower(){        nextPrime[1] = -1        nextPrimePower[1] = -1        afterPrimePowerDivison[1] = 1        for(i in 2..sieveMx){            val p = primeOf[i]            val new = i / p            nextPrime[i] = p            if(nextPrime[new] == p){                nextPrimePower[i] = nextPrimePower[new]                afterPrimePowerDivison[i] = afterPrimePowerDivison[new]            }else{                afterPrimePowerDivison[i] = new            }            nextPrimePower[i] += 1        }    }    fun prepareFactors(){        // 700ms in 1M        // shoudl not be used for 1M        // 200ms codeforces for 200k        factors = List(sieveMx + 1){ mutableListOf()}        factors[1].add(1)         for(i in 2..sieveMx){            val p = nextPrime[i]            val a = nextPrimePower[i]            val old = afterPrimePowerDivison[i]             var here = 1            repeat(a+1){                for(c in factors[old]){                    factors[i].add(c * here )                }                here *= p            }//            factors[1].ad//            factors[i].addAll(i.factors())        }    }    fun calculateMobius(){        assert(sieveCalculated)        mobius = IntArray(sieveMx + 1)        mobius[1] = 1        for(i in 2..sieveMx){            val p = primeOf[i]            if(p == primeOf[i/p]){                mobius[i] = 0            }else{                mobius[i] = -1 * mobius[i/p]            }        }    }}inline fun Int.eachPrimePower(act:(Int,Int)->Unit){    assert(sieve.sieveCalculated)    var here = this    while(here > 1){        act(sieve.nextPrime[here], sieve.nextPrimePower[here])        here = sieve.afterPrimePowerDivison[here]    }}fun Int.factors():List<Int>{    val ret = mutableListOf(1)    this.eachPrimePower { p, e ->        val s = ret.toList()        var now = 1        repeat(e){            now *= p            ret.addAll(s.map{it * now})        }    }    return ret}fun Long.factors():MutableList<Long> {    val ret = mutableListOf(1L)    val fat = factorSingleNumber(this)     for((p,e) in fat){        val s = ret.toList()        var now = 1L        repeat(e){            now *= p            ret.addAll(s.map{it * now})        }    }    return ret}fun totient(a:Int):Int{    var ret = a    a.eachPrimePower{            p, _ ->        ret /= p        ret *= (p-1)    }    return ret}fun Int.numOfDivisors():Int{    var ret = 1    this.eachPrimePower { _, e -> ret *= (e+1) }    return ret}fun Int.factorLook():List<Int>{    return sieve.factors[this]} fun factorSingleNumber(a:Long): MutableList<Pair<Long, Int>> {    val ret = mutableListOf<Pair<Long,Int>>()    var now = a    for(pi in 0 until sieve.primeCounter){        val p = sieve.primes[pi]        var level = 0        while(now % p == 0L){            now /= p            level ++        }        if(level > 0){            ret.add(Pair(p.toLong(),level ))        }    }    if(now > 1){        ret.add(Pair(now, 1))    }    return ret}  fun debug(){}const val withBruteForce = falseconst val singleCase = falsefun main(){    sieve.calculateSieveFast()    solve.cases{        val x = getlong        val y = getlong        val total = x + y + x + y - 4        val ret = mong        for(v in total.factors()){            val need = listOf(listOf(x-2,y),listOf(x-1,y-1), listOf(x,y-2), listOf(x-1,y,y-2), listOf(x,x-2,y-1))            if(need.any { it.all { s -> s % v == 0L } }){                ret.add(v)                continue            }        }        ret.sort()        put(ret.size)        put(ret.conca())       }    done()}    ","brute force,math"
"fun main() {  repeat(readLine()!!.toInt()) {    val (w, l) = readLine()!!.split("" "").map { it.toInt() }    val res = mutableSetOf<Int>()     val dW = Array(3) { mutableSetOf<Int>() }    val dL = Array(3) { mutableSetOf<Int>() }     var i = 1    while (i * i <= w || i * i <= l) {      if (w % i == 0) dW[0].addAll(listOf(i, w / i))      if ((w - 1) % i == 0) dW[1].addAll(listOf(i, (w - 1) / i))      if ((w - 2) % i == 0) dW[2].addAll(listOf(i, (w - 2) / i))       if (l % i == 0) dL[0].addAll(listOf(i, l / i))      if ((l - 1) % i == 0) dL[1].addAll(listOf(i, (l - 1) / i))      if ((l - 2) % i == 0) dL[2].addAll(listOf(i, (l - 2) / i))       i++    }     res.addAll(dW[0].intersect(dL[2]))    res.addAll(dW[1].intersect(dL[1]))    res.addAll(dW[2].intersect(dL[0]))    res.addAll(dW[0].intersect(dW[2]).intersect(dL[1]))    res.addAll(dL[0].intersect(dL[2]).intersect(dW[1]))     println(""${res.size} ${res.sorted().joinToString("" "")}"")  }}","brute force,math"
"// $time$import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport java.lang.IndexOutOfBoundsExceptionimport kotlin.system.measureTimeMillisimport java.util.TreeMapimport java.util.TreeSet inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        val S = fakein.toString()        println(""New Case "")        println(S.take(80))        println(""..."")        fakein.clear()        IN = BufferedInputStream(S.byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} val getintfast:Int get() = IO.nextInt()val getint:Int get(){ val ans = getlong ; if(ans > Int.MAX_VALUE) IntArray(1000000000); return ans.toInt() }val getlong:Long get() = IO.nextLong()val getstr:String get() = IO.nextString()fun getline(n:Int):IntArray{    return IntArray(n){getint}}fun getlineL(n:Int):LongArray{    return LongArray(n){getlong}}fun getbinary(n:Int, asTrue:Char):BooleanArray{    val str = getstr    return BooleanArray(n){str[it] == asTrue}} val List<Char>.ret:Stringget() = this.joinToString("""")var dmark = -1infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    dmark++    var str = ""<${dmark}>   ""    debug()    if(this is String){ str += this    }else if(this is Int){ str += this.toString()    }else if(this is Long){ str += this.toString()    }else{ str += this.toString()}    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is BooleanArray){ println(""$str :${a.map{if(it)'1' else '0'}.joinToString("" "")}"")    }else if(a is Array<*>){        println(""$str : "")        for(c in a){if(c is IntArray){println(c.joinToString("" ""))}        else if(c is LongArray){println(c.joinToString("" ""))}        else if(c is BooleanArray){println(c.map { if(it) '1' else '0' }.joinToString(""""))        }         }        println()    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){    throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){        throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    fun cases(onecase:()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint} else if(mode == solveMode.tc){1 } else randCount        //safety checks        if(pI != 998_244_353 && pI != 1_000_000_007){            throw Exception(""Modding a wrong prime!"")        }        if(withBruteForce){            println(""Brute force is active"")        }         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            onecase()        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }}inline fun<T> T.alsoBrute(cal:() -> T){    if(!withBruteForce) return    val also = cal()    if(this != also){        println(""Checking failed: Got ${this} Brute ${also}"")        crash()    }}// 1. Moddedconst val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}infix fun Int.modM(b:Int):Int{ return ((this.toLong() * b) % pI).toInt() }infix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }fun intPow(x:Int,e:Int,m:Int):Int{    var X = x ; var E =e ; var Y = 1    while(E > 0){        if(E and 1 == 0){            X = ((1L * X * X) % m).toInt()            E = E shr 1        }else{            Y = ((1L * X * Y) % m).toInt()            E -= 1        }    }    return Y}// 2. DP initial valuesconst val plarge = 1_000_000_727const val nlarge = -plargeconst val phuge = 2_727_000_000_000_000_000Lconst val nhuge = -phuge// 3. conveniecen conversionsval Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionval Char.code :Int get() = this.toInt() -  'a'.toInt()//3. hard to write stufffun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val mint:MutableList<Int> get() = mutableListOf<Int>()val mong:MutableList<Long> get() = mutableListOf<Long>()//4. more outputsfun List<Char>.conca():String = this.joinToString("""")val CharArray.conca :String get() = this.joinToString("""")val IntArray.conca :String get() = this.joinToString("" "")@JvmName(""concaInt"")fun List<Int>.conca():String = this.joinToString("" "")val LongArray.conca:String get() = this.joinToString("" "")@JvmName(""concaLong"")fun List<Long>.conca():String = this.joinToString("" "")//5. Pair of intsconst val longmask = (1L shl 32) - 1fun makepair(a:Int, b:Int):Long = (a.toLong() shl 32) xor (longmask and b.toLong()) // remember positev sonlyval Long.first get() = (this ushr 32).toInt()val Long.second get() = this.toInt()//6. stringsval String.size get() = this.lengthconst val randCount = 100//7. bitsfun Int.has(i:Int):Boolean = (this and (1 shl i) != 0)    private typealias ei = Intprivate typealias earr = IntArray//NOT batle testedclass fastDeque(val l:Int, val r:Int) {    val total = r - l + 1    val st = earr(total)    var startpointer = 0 - l    var endpointer = startpointer - 1    val size: Int get() = endpointer - startpointer + 1     fun isEmpty(): Boolean {        return endpointer < startpointer    }    fun isNotEmpty():Boolean{        return endpointer >= startpointer    }    fun first():ei{        assert(isNotEmpty())        return st[startpointer]    }    fun last():ei{        assert(isNotEmpty())        return st[endpointer]    }    fun addFirst(v:ei ){        startpointer --        st[startpointer]= v    }    fun addLast(v:ei){        endpointer ++        st[endpointer] = v    }    fun removeFirst(): Int {        assert(isNotEmpty())        val ret = st[startpointer]        startpointer ++        return ret    }    fun removeLast(): Int {        assert(isNotEmpty())        val ret = st[endpointer]        endpointer --        return ret    }    fun toArray():earr{        return st.sliceArray(startpointer..endpointer)    }    fun toList():List<ei>{        return st.slice(startpointer..endpointer)    }     inline fun forEach(act:(v:ei)->Unit){        for(i in startpointer..endpointer){            act(st[i])        }    }    inline fun withIndex(act:(i:Int,v:ei)->Unit){        for(i in startpointer..endpointer){            act(i-startpointer,st[i])        }    }    fun reset(){        startpointer = -l        endpointer = startpointer -1    }}fun fastEmptyList(max:Int):fastDeque{    return fastDeque(0,max-1)}class simpleMaxTree (nSuggest  :Int){    //Items lenght must be a power of 2     val void = Int.MIN_VALUE     val n = if(nSuggest >= 2) (nSuggest - 1).takeHighestOneBit() shl 1 else nSuggest    val levels = (31 - n.countLeadingZeroBits()) // (Levels) amount of levels then a layer of leaf    val arr = IntArray(n * 2 + 1 ){void}    val arrSize = n * 2 + 1     constructor(withArray:IntArray):this(withArray.size){        for(i in withArray.indices){            arr[i+n] = withArray[i]        }         updateAll()    }     private fun updateNode(i:Int){        arr[i] = maxOf(arr[i shl 1] , arr[(i shl 1) + 1])    }    private fun updatePath(i:Int){        // i is the endpoint, typically (n+i)        // bottom up, recalculate        var here = i        while(here > 1){            here = here shr 1            updateNode(here)        }    }    fun updateAll(){        for(i in n-1 downTo 1){            updateNode(i)        }    }    fun setValue(i:Int,value:Int){        arr[n+i] = value        updatePath(n+i)    }    fun addValue(i:Int, inc:Int){        arr[n+i] += inc        updatePath(n+i)    }     val firstIndex = n    val lastIndex = (n shl 1 ) - 1    val indices = firstIndex..lastIndex      fun primitiveIndex(a:Int) = a + n    inline fun segmentOrder(act:(here:Int, left:Int,right:Int)->Unit ){        //iterate over all segments bottom up, probably to rebuild tree        for(i in (n-1) downTo 1){            act(i, (i shl 1 ), (i shl 1) + 1)        }    }    inline fun primitiveOrder(act:(here:Int,primitiveIndex:Int)->Unit){        //iterate over all the leaf nodes        for(i in 0 until n){            act(i+n,i)        }    }      inline fun segDivision(l:Int, r:Int, act:(index:Int,level:Int)->Unit){        var left = l + n        var right = r + n + 1        var level = 0        while(left < right){            if(left and 1 != 0){                 act(left,level)                left += 1            }            if(right and 1 != 0){                right -= 1                act(right,level)            }            left = left shr 1            right = right shr 1            level ++        }    }     fun queryFunctional(l:Int,r:Int):Int{        var ret = void        segDivision(l,r){i, _ ->            ret = maxOf(ret,arr[i])        }        return ret    }    fun indexOf(req:Int):Int{        // -1 if not enough        val req = req + 1        if(req > arr[1]){            throw IndexOutOfBoundsException()        }else if(req <= 0 ){            return -1        }        var i = 1        var rightPoint = -1        var cur = 0        for(l in 1..levels){            i = i shl 1            if(cur + arr[i] < req){                rightPoint += 1 shl (levels - l)                cur += arr[i]                i += 1            }        }        return rightPoint +1    }    val Int.leftNode:Int get(){        // assert(this <= n )        return this shl 1    }    val Int.rightNode:Int get(){        // assert(this <= n)        return (this shl 1) + 1    }    val Int.endpoints:Pair<Int,Int> get(){        val offSet = this - this.takeHighestOneBit()        val widthLevel = levels - (31 - this.countLeadingZeroBits())        return Pair(offSet shl widthLevel, (offSet shl widthLevel) + (1 shl widthLevel) - 1)    }     fun maxPos(i:Int):Int{        // rememrbe must be whole array        val max = arr[i]        // -1 if not enough        var here = i        while(here < n){            val left = here shl 1            if(arr[(left )] == max){                here = left            }else{                here = left +1            }        }        return here - n    }    inline fun destroyall(l:Int, r:Int, atleast:Int,justkilled:(Int)->Unit){        segDivision(l,r){            i,l->            while(this.arr[i] >= atleast){                val d = maxPos(i)                setValue(d,Int.MIN_VALUE)                justkilled(d)            }        }    }    fun printall(){        just dei (0 until n).map { queryFunctional(it,it) }.conca()    }}fun debug(){}const val withBruteForce = falseconst val singleCase = falsefun main(){    solve.cases{        val n = getint        val a = getint - 1        val b = getint - 1         val dist = IntArray(n)        val powers = getline(n)         val left = simpleMaxTree(IntArray(n){-(it - powers[it])}) // negated        val right = simpleMaxTree(IntArray(n){it + powers[it]})           val Q = fastEmptyList(n)        Q.addLast(a)        left.setValue(a,Int.MIN_VALUE)        right.setValue(a,Int.MIN_VALUE)         while(Q.isNotEmpty()){            val v = Q.removeFirst()            val p = powers[v]            val d = dist[v]            left.destroyall(v,minOf(v + p,n-1),-v){                w ->                dist[w] = d + 1                Q.addLast(w)                right.setValue(w,Int.MIN_VALUE)            }             right.destroyall(maxOf(0,v-p),v,v){                w ->                dist[w] = d + 1                Q.addLast(w)                left.setValue(w,Int.MIN_VALUE)            } //            ""taken"" dei v//            left.printall()//            right.printall()        }        put(dist[b])        }    done()}    ","data structures,dfs and similar,graphs,graphs,implementation,implementation,shortest paths,shortest paths"
"import java.util.*import java.util.stream.Streamimport kotlin.collections.HashMapimport kotlin.math.abs private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }private fun readLongs() = readStrings().map { it.toLong() } fun main() = P1651D.solve() object P1651D {      fun point(x:Int, y: Int) = (x.toLong() shl 32) or y.toLong()    fun Long.x() = (this shr 32).toInt()    fun Long.y() = this.toInt()    operator fun Long.component1() = (this shr 32).toInt()    operator fun Long.component2() = this.toInt()      fun solve() {        val n = readInt()        val points = (1..n).map {            val (x, y) = readInts()            point(x, y)        }        val present = points.toSet()        val closest = HashMap<Long, Long>()        val queue = LinkedList<Long>()         present.forEach { p ->            val (x, y) = p            Stream.of(point(x+1, y), point(x-1, y), point(x,y-1), point(x, y+1)).filter { it !in present }.findFirst().ifPresent { p2 ->                closest[p] = p2                queue.addLast(p)            }        }         while (queue.isNotEmpty()) {            val p = queue.pop()            val (x, y) = p            Stream.of(point(x+1, y), point(x-1, y), point(x,y-1), point(x, y+1)).filter { it in present && it !in closest }.forEach {                closest[it] = closest[p]!!                queue.addLast(it)            }        }         points.forEach { p ->            val res = closest[p]!!            println(""${res.x()} ${res.y()}"")        }    }} ","binary search,data structures,dfs and similar,graphs,shortest paths"
"fun readStr() = readLine()!!fun readInt() = readLine()!!.toInt()fun readLong() = readLine()!!.toLong()fun readIntPair() = readLine()!!.split("" "").let { it[0].toInt() to it[1].toInt() }fun readIntList() = readLine()!!.split("" "").map { it.toInt() }fun readLongList() = readLine()!!.split("" "").map { it.toLong() }fun readIntArr() = readIntList().toIntArray()fun readDoubleList() = readLine()!!.split("" "").map { it.toDouble() }fun Boolean.toAns() = if (this) ""yes"" else ""no"" fun go(ansBuilder: StringBuilder.() -> Unit) {    val sb = StringBuilder()    val t = readInt()    repeat(t) { sb.ansBuilder() }    println(sb.toString())} fun main() {    val n = readInt()    val points = Array(n) { readIntPair() }    val pWithX = Array(200002) { hashSetOf<Int>() }    val dWithX = Array(200002) { hashMapOf<Int, Int>() }    val ansWithX = Array(200002) { hashMapOf<Int, Pair<Int, Int>>() }    val queue = ArrayDeque<Pair<Int, Int>>()    for ((x, y) in points) {        pWithX[x].add(y)    }    for ((x, y) in points) {        for ((adjx, adjy) in listOf(x + 1 to y, x - 1 to y, x to y - 1, x to y + 1)) {            if (adjy !in pWithX[adjx] && !ansWithX[x].containsKey(y)) {                ansWithX[x][y] = adjx to adjy                dWithX[x][y] = 1                queue.add(x to y)            }        }    }    while (queue.isNotEmpty()) {        val sz = queue.size        repeat(sz) {            val (x, y) = queue.removeFirst()            for ((adjx, adjy) in listOf(x + 1 to y, x - 1 to y, x to y - 1, x to y + 1)) {                if (adjy in pWithX[adjx] && !dWithX[adjx].containsKey(adjy)) {                    dWithX[adjx][adjy] = dWithX[x][y]!! + 1                    ansWithX[adjx][adjy] = ansWithX[x][y]!!                    queue.addLast(adjx to adjy)                }            }        }    }    points.map { (x, y) -> ansWithX[x][y]!! }        .joinToString(""\n"") { ""${it.first} ${it.second}"" }        .let(::println)}    ","binary search,data structures,dfs and similar,graphs,shortest paths"
"import java.util.*import java.util.stream.Streamimport kotlin.collections.HashMapimport kotlin.math.abs private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }private fun readLongs() = readStrings().map { it.toLong() } fun main() = P1651D.solve() object P1651D {     // inv a < b, test(a) == false, test(b) == true    fun <T> lb(i:Int, j: Int, get: (Int) -> T, test: (i: T) -> Boolean ): Int {        if (i+1 == j)            return i        val m = (i+j)/2        return if (test(get(m))) lb(i, m, get, test) else lb(m, j, get,test)    }     fun Pair<Int, Int>.dist(other: Pair<Int, Int>) = abs(first-other.first) + abs(second-other.second)     val INF = 1 shl 30     fun point(x:Int, y: Int) = (x.toLong() shl 32) or y.toLong()    fun Long.x() = (this shr 32).toInt()    fun Long.y() = this.toInt()    operator fun Long.component1() = (this shr 32).toInt()    operator fun Long.component2() = this.toInt()      fun solve() {        val n = readInt()        val points = (1..n).map {            val (x, y) = readInts()            point(x, y)        }        val present = points.toSet()        val closest = HashMap<Long, Long>()        val queue = LinkedList<Long>()         present.forEach { p ->            val (x, y) = p            Stream.of(point(x+1, y), point(x-1, y), point(x,y-1), point(x, y+1)).filter { it !in present }.findFirst().ifPresent { p2 ->                closest[p] = p2                queue.addLast(p)            }        }         while (queue.isNotEmpty()) {            val p = queue.pop()            val (x, y) = p            Stream.of(point(x+1, y), point(x-1, y), point(x,y-1), point(x, y+1)).filter { it in present && it !in closest }.forEach {                closest[it] = closest[p]!!                queue.addLast(it)            }        }         points.forEach { p ->            val res = closest[p]!!            println(""${res.x()} ${res.y()}"")        }    }    fun _solve() {        val n = readInt()        val points = (1..n).map {            val (x, y) = readInts()            x to y        }        val present = points.toSet()        val closest = HashMap<Pair<Int, Int>, Pair<Int, Int>>()        val queue = LinkedList<Pair<Int, Int>>()        present.stream().flatMap { (x, y) ->            Stream.of(x+1 to y, x-1 to y, x to y-1, x to y+1).filter { it !in present }        }.forEach { p ->            closest[p] = p            queue.addLast(p)        }         while (queue.isNotEmpty()) {            val p = queue.pop()            val (x, y) = p            Stream.of(x+1 to y, x-1 to y, x to y-1, x to y+1).filter { it in present && it !in closest }.forEach {                closest[it] = closest[p]!!                queue.addLast(it)            }        }         points.forEach { p ->            val res = closest[p]!!            println(""${res.first} ${res.second}"")        }    } } ","binary search,data structures,dfs and similar,graphs,shortest paths"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"", ""DEPRECATION"")@file:OptIn(ExperimentalStdlibApi::class) import java.io.PrintWriterimport java.util.StringTokenizerimport kotlin.collections.ArrayDequeimport kotlin.math.*import java.util.TreeMap// import java.util.*// import kotlin.random.* @JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out @JvmField val reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun readLn() = reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readString() = readStrings(1)[0]fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int = 2) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int = 2) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } // val isLocal = System.getenv(""IS_LOCAL_CP"") == ""true"" @JvmFieldval writer = PrintWriter(OUTPUT) // ---------------------------------------------------------------------------- class UnionFind {     private val parents = mutableMapOf<Int, Int>()    private val sizes = mutableMapOf<Int, Int>()     fun union(a: Int, b: Int) {        val fa = find(a)        val fb = find(b)        if (fa != fb) {            parents[fa] = fb            sizes[fb] = (sizes[fb] ?: 1) + (sizes[fa] ?: 1)        }    }     fun find(a: Int): Int {        fun getOrDefault(value: Int) = parents.getOrDefault(value, value)         var parent = getOrDefault(a)        while (parent != getOrDefault(parent)) {            parents[parent] = getOrDefault(getOrDefault(parent))            parent = parents[parent]!!        }        return parent    }     fun connected(a: Int, b: Int): Boolean {        return find(a) == find(b)    }     fun getSize(a: Int): Int {        return sizes[find(a)] ?: 1    }} class UnionFindArray(private val n: Int) {     private val parents = IntArray(n + 1) { it }     fun union(a: Int, b: Int) {        val fa = find(a)        val fb = find(b)        if (fa != fb) {            parents[fa] = fb        }    }     fun find(a: Int): Int {        var parent = parents[a]        while (parent != parents[parent]) {            parents[parent] = parents[parents[parent]]            parent = parents[parent]        }        return parent    }     fun connected(a: Int, b: Int): Boolean {        return find(a) == find(b)    }} class Trie() {     /** Initialize your data structure here. */    private val root = Node()     /** Inserts a word into the trie. */    fun insert(word: String) {        var node = root        for (char in word) {            if (!node.children.contains(char)) {                node.children[char] = Node()            }            node = node.children[char]!!        }        node.hasWord = true    }     /** Returns if the word is in the trie. */    fun search(word: String): Boolean {        return findNode(word)?.hasWord ?: false    }     /** Returns if there is any word in the trie that starts with the given prefix. */    fun startsWith(prefix: String): Boolean {        return findNode(prefix) != null    }     private fun findNode(prefix: String): Node? {        var node = root        for (char in prefix) {            node = node.children[char] ?: return null        }        return node    }     private class Node(        var hasWord: Boolean = false,        val children: MutableMap<Char, Node> = mutableMapOf<Char, Node>()    )} // 所有函数的下标从 0 开始// query(index): sum[0, index]class BinaryIndexedTree {     private val bit: IntArray     constructor(n: Int) {        this.bit = IntArray(n + 1)    }     constructor(nums: IntArray) {        this.bit = IntArray(nums.size + 1)        val prefix = IntArray(bit.size)        for (i in 1 until nums.size + 1) {            prefix[i] = prefix[i - 1] + nums[i - 1]            bit[i] = prefix[i] - prefix[i - lowbit(i)]        }    }     fun query(index: Int): Int {        var result = 0        var i = index + 1        while (i > 0) {            result += bit[i]            i -= lowbit(i)        }        return result    }     fun update(index: Int, x: Int) {        val value = query(index) - query(index - 1)        add(index, x - value)    }     fun add(index: Int, x: Int) {        var i = index + 1        while (i < bit.size) {            bit[i] += x            i += lowbit(i)        }    }     override fun toString(): String {        return IntArray(bit.size - 1) { query(it) - query(it - 1) }.toList().toString()    }     private fun lowbit(x: Int): Int {        return x.and(-x)    }} // 所有函数的下标从 0 开始// query(index): max[0, index]// udpate(index, x): 更新 [0, index] 之间的最大值，只能越来越大class BinaryIndexedTreeMax {     private val bit: IntArray     constructor(n: Int) {        this.bit = IntArray(n + 1)    }     fun query(index: Int): Int {        var result = 0        var i = index + 1        while (i > 0) {            result = Math.max(result, bit[i])            i -= lowbit(i)        }        return result    }     fun update(index: Int, x: Int) {        var i = index + 1        while (i < bit.size) {            bit[i] = Math.max(bit[i], x)            i += lowbit(i)        }    }     private fun lowbit(x: Int): Int {        return x.and(-x)    }} class SparseTableMax(private val nums: IntArray) {     private val st: Array<IntArray>     init {        val n = nums.size        val logN = Integer.numberOfTrailingZeros(Integer.highestOneBit(n))        this.st = Array(n * 2) { IntArray(logN + 1) }        for (i in 0 until n) {            st[i][0] = nums[i]        }        for (j in 1 until logN + 1) {            for (i in 0 until n) {                st[i][j] = st[i][j - 1]                if (i + 1.shl(j - 1) < n) {                    st[i][j] = Math.max(st[i][j], st[i + 1.shl(j - 1)][j - 1])                }            }        }    }     fun query(left: Int, right: Int): Int {        if (left > right) {            return -1        }        val len = right - left + 1        val k = Integer.numberOfTrailingZeros(Integer.highestOneBit(len))        return Math.max(st[left][k], st[right - 1.shl(k) + 1][k])    }} class SparseTableMin(private val nums: IntArray) {     private val st: Array<IntArray>     init {        val n = nums.size        val logN = Integer.numberOfTrailingZeros(Integer.highestOneBit(n))        this.st = Array(n * 2) { IntArray(logN + 1) { Int.MAX_VALUE / 2 } }        for (i in 0 until n) {            st[i][0] = nums[i]        }        for (j in 1 until logN + 1) {            for (i in 0 until n) {                st[i][j] = st[i][j - 1]                if (i + 1.shl(j - 1) < n) {                    st[i][j] = Math.min(st[i][j], st[i + 1.shl(j - 1)][j - 1])                }            }        }    }     fun query(left: Int, right: Int): Int {        if (left > right) {            return -1        }        val len = right - left + 1        val k = Integer.numberOfTrailingZeros(Integer.highestOneBit(len))        return Math.min(st[left][k], st[right - 1.shl(k) + 1][k])    }} class PrefixSum2D(private val grid: Array<IntArray>) {     private val prefix: Array<IntArray>     init {        val (m, n) = Pair(grid.size, grid[0].size)        prefix = Array(m + 1) { IntArray(n + 1) }        for (i in 0 until m) {            var row = 0            for (j in 0 until n) {                row += grid[i][j]                prefix[i + 1][j + 1] = prefix[i][j + 1] + row            }        }    }     fun query(up: Int, left: Int, bottom: Int, right: Int): Int {        return prefix[up][left] + prefix[bottom + 1][right + 1] -            prefix[bottom + 1][left] - prefix[up][right + 1]    }} // ---------------------------------------------------------------------------- private fun PrintWriter.printNums(nums: List<Int>) {    if (nums.isEmpty()) {        println()        return    }    for (i in 0 until nums.size - 1) {        print(nums[i])        print(' ')    }    println(nums.last())} private fun lengthOfLIS(numsInput: List<Int>): Int {    val nums = unify(numsInput)    val bit = BinaryIndexedTreeMax(nums.size + 1)    var result = 0    for (num in nums) {        val len = bit.query(num - 1) + 1        bit.update(num, len)        result = Math.max(result, len)    }    return result} private fun unify(nums: List<Int>): List<Int> {    val numToIndex = nums.sorted().mapIndexed { index, num -> num to index }.toMap()    return nums.map { numToIndex[it]!! }} private fun fastPow(a: Long, exp: Long, mod: Long): Long {    var result = 1L % mod    var base = a % mod    var remain = exp    while (remain != 0L) {        if (remain % 2L == 1L) {            result = (result * base) % mod        }        base = (base * base) % mod        remain /= 2L    }    return result} private fun gcd(a: Int, b: Int): Int {    return if (b == 0) a else gcd(b, a % b)} private fun gcdL(a: Long, b: Long): Long {    return if (b == 0L) a else gcdL(b, a % b)} private fun lcm(a: Int, b: Int): Int {    return ((a.toLong() * b.toLong()) / gcd(a, b)).toInt()} private fun lcmL(a: Long, b: Long): Long {    return (a * b) / gcdL(a, b)} private fun wordToCharCount(word: String): IntArray {    val charCount = IntArray(26)    for (char in word) {        charCount[char.toIndex()]++    }    return charCount} private fun Char.toIndex(): Int {    return this.toInt() - 'a'.toInt()} private fun Char.toDigit(): Int {    return this.toInt() - '0'.toInt()} private fun Boolean.toYesNo(upper: Boolean = false): String {    val yesNo = if (this) ""Yes"" else ""No""    return if (upper) yesNo.toUpperCase() else yesNo} private fun LongArray.modSum(mod: Long = MODL): Long {    var sum = 0L    for (num in this) {        sum = (sum + num) % mod    }    return sum} private fun IntArray.swap(i: Int, j: Int) {    val temp = this[i]    this[i] = this[j]    this[j] = temp} private fun LongArray.swap(i: Int, j: Int) {    val temp = this[i]    this[i] = this[j]    this[j] = temp} private fun CharArray.swap(i: Int, j: Int) {    val temp = this[i]    this[i] = this[j]    this[j] = temp} private fun <T> List<T>.toArrayDeque(): ArrayDeque<T> {    return ArrayDeque(this)} private fun <T> List<T>.listEquals(other: List<T>): Boolean {    return (0 until this.size).all { this[it] == other[it] }} private fun <T : Comparable<T>> List<T>.isSorted(): Boolean {    return this.listEquals(this.sorted())} private val DIR = listOf(    listOf(1, 0), listOf(0, -1), listOf(-1, 0), listOf(0, 1))  private const val MOD = 998244353private const val MODL = 998244353L// private const val MOD = 1000000007// private const val MODL = 1000000007Lprivate const val EPS = 0.000001 // ---------------------------------------------------------------------------- fun main() {    val go: Runnable = Runnable {        writer.solve()        writer.flush()    }    Thread(null, go, ""thread"", 1L.shl(28)).start()} private fun PrintWriter.solve() {    val n = readInt()    val pointList = Array(n) { readInts() }    nearestExcluded(pointList).forEach { printNums(it) }} fun point(x:Int, y: Int) = (x.toLong() shl 32) or y.toLong()fun Long.x() = (this shr 32).toInt()fun Long.y() = this.toInt()operator fun Long.component1() = (this shr 32).toInt()operator fun Long.component2() = this.toInt() private fun nearestExcluded(pointList: Array<List<Int>>): Array<List<Int>> {    val points = pointList.map { point(it[0], it[1]) }    val starts = points.toSet()    val closest = mutableMapOf<Long, Long>()    val queue = ArrayDeque<Long>()    for (pos in starts) {        for (dir in DIR) {            val (r, c) = pos            val next = point(r + dir[0], c + dir[1])            if (!starts.contains(next)) {                queue.addLast(pos)                closest[pos] = next                break            }        }    }    // println(closest)     while (queue.isNotEmpty()) {        val pos = queue.removeFirst()        val (r, c) = pos        for (dir in DIR) {            val next = point(r + dir[0], c + dir[1])            if (!starts.contains(next) || closest.contains(next)) {                continue            }            closest[next] = closest[pos]!!            queue.addLast(next)        }    }     return points.map { point ->        val (r, c) = closest[point]!!        listOf(r, c)    }.toTypedArray()} // private fun nearestExcluded(pointList: Array<List<Int>>): Array<List<Int>> {//     val n = pointList.size//     val pointToIndex = mutableMapOf<Long, Int>()//     val starts = mutableSetOf<Long>()//     pointList.forEachIndexed { i, (r, c) ->//         val point = r.toLong().shl(32) + c//         pointToIndex[point] = i//         for (dir in DIR) {//             val nextPoint = (r + dir[0]).toLong().shl(32) + c + dir[1]//             starts.add(nextPoint)//         }//     }//     val queue = ArrayDeque<List<Int>>().apply {//         addAll(starts.filter { !pointToIndex.contains(it) }.map { point ->//             val r = point.shr(32).toInt()//             val c = point.and(1L.shl(32) - 1L).toInt()//             listOf(r, c, r, c)//         })//     }//     // println(queue)//     val result = arrayOfNulls<List<Int>>(n)//     var remain = n//     while (queue.isNotEmpty() && remain != 0) {//         val (or, oc, r, c) = queue.removeFirst()//         for (dir in DIR) {//             val nr = r + dir[0]//             val nc = c + dir[1]//             val point = nr.toLong().shl(32) + nc//             val index = pointToIndex[point] ?: continue//             if (result[index] != null) {//                 continue//             }//             result[index] = listOf(or, oc)//             queue.addLast(listOf(or, oc, nr, nc))//             remain--//         }//     }//     // println(result.toList())//     // println(remain)//     return result.map { it!! }.toTypedArray()// }","binary search,data structures,dfs and similar,graphs,shortest paths"
import java.lang.Math.pow fun main() {    val T = readLine()!!.toInt()    repeat(T) {        val n = readLine()!!.toInt()        val adding = 2L        var begin = 1L         for(i in 0 until n) {            begin *= adding        }        println(begin-1)    }},implementation
"private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of ints  fun main() = P1651A.solve() object P1651A {      fun solve() {        (1..readInt()).forEach {            val n = readInt()            println((1 shl n)-1)        }    } } ",implementation
"import java.util.*import kotlin.math.abs fun readStr() = readLine()!!fun readInt() = readLine()!!.toInt()fun readIntList() = readLine()!!.split("" "").map { it.toInt() }fun readLongList() = readLine()!!.split("" "").map { it.toLong() }fun readIntArr() = readIntList().toIntArray()fun Boolean.toAns() = if (this) ""yes"" else ""no"" fun go(ansBuilder: StringBuilder.() -> Unit) {    val sb = StringBuilder()    val t = readInt()    repeat(t) { sb.ansBuilder() }    println(sb.toString())} fun main() = go {    println((1 shl readInt()) - 1)}",implementation
"import java.io.FileInputStreamimport java.util.* object programkt {  val colors = 100005  var t: Int = 0  var n: Int = 0  var m: Int = 0  var s: Long = 0  var sumy = LongArray(colors)  var count = LongArray(colors)   @JvmStatic fun main(args: Array<String>) {    if (args.size == 1)      System.setIn(FileInputStream(args[0]))    val sc = Scanner(System.`in`)    t = sc.nextInt()     IntRange(1, t).forEach {      n = sc.nextInt()      println(winner(n))    }  }   fun winner(n: Int): Int {    if (n <= 1) {      return 1    } else {      return pow2(n) - 1    }   }   private fun pow2(n: Int): Int {    if (n == 0) {      return 1    } else {      return 2 * pow2(n-1)    }  }}",implementation
"fun main(args : Array<String>) {    val t = readLine()!!.trim().toInt()     repeat(t) {        val (l, r, a) = readLine()!!.trim().split("" "").map { it.toInt() }        val mod = r % a        val rMax = (r/a) + mod        val prevMaxX = r - mod - 1        val prevMax = if (prevMaxX >= l) (prevMaxX/a) + (prevMaxX%a) else 0         println(Math.max(rMax, prevMax))    }}",math
"import kotlin.math.* private fun test(action: (Int)->Unit) = repeat(readLine()!!.toInt(), action)private fun readInt(): Int = readLine()!!.toInt()private fun readLong(): Long = readLine()!!.toLong()private fun <T>readList(transform: (String) -> T) : List<T> = readLine()!!.split("" "").map(transform)private fun readIntList() : List<Int> = readList{ it.toInt() }private fun readLongList() : List<Long> = readList { it.toLong() }private fun println(bool: Boolean) = println(if(bool) ""YES"" else ""NO"")private fun <T>println(list: List<T>) = println(list.joinToString("" "")) fun main() {    test{        val a = readLongList()        val c = a[1]/a[2]+a[1]%a[2]        val x = ((a[1]+1)/a[2]-1)        if((x*a[2]+a[2]-1)>=a[0]) println(max(x+a[2]-1, c))        else println(c)    }}",math
"import java.util.* fun readStr() = readLine()!!fun readInt() = readLine()!!.toInt()fun readPair() = readLine()!!.split("" "").let { it[0].toInt() to it[1].toInt() }fun readIntList() = readLine()!!.split("" "").map { it.toInt() }fun readLongList() = readLine()!!.split("" "").map { it.toLong() }fun readIntArr() = readIntList().toIntArray()fun Boolean.toAns() = if (this) ""yes"" else ""no"" fun go(ansBuilder: StringBuilder.() -> Unit) {    val sb = StringBuilder()    val t = readInt()    repeat(t) { sb.ansBuilder() }    println(sb.toString())} fun main() = go {    val (l, r, a) = readIntList()    if (r % a == a - 1) appendLine(r / a + (r % a))    else {        val rem = r % a        if (r - rem - 1 >= l) appendLine(maxOf((r - rem - 1) / a + ((r - rem - 1) % a), r / a + (r % a)))        else appendLine(r / a + (r % a))    } }",math
"import java.io.*import java.util.*import kotlin.math.* val INPUT = System.`in`!!val OUTPUT = System.out!!val reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun line() = reader.readLine()!!var st: StringTokenizer = StringTokenizer("""")fun read(): String {    while (st.hasMoreTokens().not())        st = StringTokenizer(reader.readLine() ?: return """", "" "")    return st.nextToken()}fun int() = read().toInt()fun ints(n: Int) = List(n) { read().toInt() }fun intArray(n: Int) = IntArray(n) { read().toInt() }val writer = PrintWriter(OUTPUT, false)fun main() { writer.solve(); writer.flush() }fun PrintWriter.solve() {    var tt = 1    tt = int()    while (tt-- > 0) {        val (l, r, a) = ints(3)        val rem = r % a        val x = r - rem        if(x <= l || rem == a - 1) {            println(r / a + r % a)        }        else {            println((x - 1) / a + (x - 1) % a)        }    }}",math
"fun readStr() = readLine()!!fun readInt() = readLine()!!.toInt()fun readPair() = readLine()!!.split("" "").let { it[0].toInt() to it[1].toInt() }fun readIntList() = readLine()!!.split("" "").map { it.toInt() }fun readLongList() = readLine()!!.split("" "").map { it.toLong() }fun readIntArr() = readIntList().toIntArray()fun Boolean.toAns() = if (this) ""yes"" else ""no"" fun go(ansBuilder: StringBuilder.() -> Unit) {    val sb = StringBuilder()    val t = readInt()    repeat(t) { sb.ansBuilder() }    println(sb.toString())} fun main() = go {    val n = readInt()    val loc = readIntArr()    var first = 0    var last = loc.lastIndex    while (first < loc.size && loc[first] == 1) first++    while (last >= 0 && loc[last] == 1) last--    appendLine(maxOf(0, last - first + 2))}",implementation
"import java.io.FileInputStreamimport java.util.* object programkt {  val colors = 100005  var t: Int = 0  var n: Int = 0  var m: Int = 0  var s: Long = 0  var sumy = LongArray(colors)  var count = LongArray(colors)   @JvmStatic fun main(args: Array<String>) {    if (args.size == 1)      System.setIn(FileInputStream(args[0]))    val sc = Scanner(System.`in`)    t = sc.nextInt()     IntRange(1, t).forEach {      var z1 = 0      var z2 = 0      var first = true       n = sc.nextInt()      IntRange(1, n).forEach {        val a = sc.nextInt()        if (first && a == 1) {          z1++        }        if (a == 0) {          first = false          z2 = 0        }        if (a == 1) {          z2++        }      }      if (z1 == n) {        println(0)      } else {        println(n - z1 - z2 + 1)      }    }  } }",implementation
"import java.io.*import java.util.*import kotlin.math.* val INPUT = System.`in`!!val OUTPUT = System.out!!val reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun line() = reader.readLine()!!var st: StringTokenizer = StringTokenizer("""")fun read(): String {    while (st.hasMoreTokens().not())        st = StringTokenizer(reader.readLine() ?: return """", "" "")    return st.nextToken()}fun int() = read().toInt()fun ints(n: Int) = List(n) { read().toInt() }fun intArray(n: Int) = IntArray(n) { read().toInt() }val writer = PrintWriter(OUTPUT, false)fun main() { writer.solve(); writer.flush() }fun PrintWriter.solve() {    var tt = 1    tt = int()    while (tt-- > 0) {        val n = int()        val arr = intArray(n)        if(arr.contains(0)) {            var l = 0; var h = n - 1            while(l < n && arr[l] != 0) l++            while(h >= 0 && arr[h] != 0) h--            println(h - l + 2)        }        else println(0)    }}",implementation
"class Game3 {     fun mySolution(locations: List<Int>): Int =        when {            (locations.indexOf(0) < 0) -> 0            else -> locations.lastIndexOf(0) - locations.indexOf(0) + 2        }} fun main() {    val game3 = Game3()    repeat(readLine()!!.toInt()) {        readLine()        println(game3.mySolution(readLine()!!.split("" "").map(String::toInt)))    }}",implementation
"import java.io.BufferedReader fun main() {    val br = System.`in`.bufferedReader()    val bw = System.out.bufferedWriter()    val t = br.readInt()    repeat(t) {        val n = br.readInt()        val a = IntArray(n) { br.readInt() }        val sorted = a.sorted()        var cur = sorted.first()        var strk = 1        var bad = false        for (x in 1 until n) {            if (cur == sorted[x]) {                strk++            } else if (strk and 1 == 1) {                bad = true            } else {                strk = 1                cur = sorted[x]            }        }        if (strk and 1 == 1) {            bad = true        }        if (bad) {            bw.appendLine(""-1"")        } else {            val moveIds = mutableListOf<Int>()            val moveVals = mutableListOf<Int>()            val rangeSizes = mutableListOf<Int>()            var i = 0            var offset = 0            while (i < n) {                val base = i                i++                while (a[i] != a[base]) {                    i++                }                var dif = 1                while (i + dif < n && base + dif < i && a[base + dif] == a[i + dif]) {                    dif++                }                val movesToMake = i - (base + dif)                for (x in 0 until movesToMake) {                    moveIds += offset + i + dif + x                    moveVals += a[base + dif + x]                }                var startRev = base + dif                var endRev = i + dif - 1                while (startRev < endRev) {                    val temp = a[startRev]                    a[startRev] = a[endRev]                    a[endRev] = temp                    startRev++                    endRev--                }                offset += movesToMake shl 1                rangeSizes += (i - base) shl 1                i += dif - movesToMake            }             bw.appendLine(""${moveIds.size}"")            for (j in moveIds.indices) {                bw.appendLine(""${moveIds[j]} ${moveVals[j]}"")            }            bw.appendLine(""${rangeSizes.size}"")            bw.append(rangeSizes.first().toString())            for (j in 1 until rangeSizes.size) {                bw.append("" ${rangeSizes[j]}"")            }            bw.newLine()        }    }    bw.flush()} private const val SPACE_INT = ' '.toInt()private const val ZERO_INT = '0'.toInt()private const val NL_INT = '\n'.toInt() private fun BufferedReader.readInt(): Int {    var ret = read()    while (ret <= SPACE_INT) {        ret = read()    }    val neg = ret == '-'.toInt()    if (neg) {        ret = read()    }    ret -= ZERO_INT    var read = read()    while (read >= ZERO_INT) {        ret *= 10        ret += read - ZERO_INT        read = read()    }     while (read <= SPACE_INT && read != -1 && read != NL_INT) {        mark(1)        read = read()    }    if (read > SPACE_INT) {        reset()    }    return if (neg) -ret else ret}","constructive algorithms,implementation,sortings"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.lang.AssertionErrorimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007 data class Operation(var pos: Int, var letter: Int)class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  private val reader = BufferedReader(InputStreamReader(stream), 32768)   fun solve() {    val next = IntArray(1000)    val prev = IntArray(1000)    val operations = Array(1e6.toInt()){ Operation(-1, -1) }    for (t in 0 until ni()) {      val N = ni()      val A = na(N)      if (A.groupBy { it }.map{ it.value.size }.any{it%2 == 1}) {        out.println(-1)        continue      }       fun swap(fst: Int, lst: Int) {        var i = fst        var j = lst        while(i < j) {          val tmp = A[i - 1]          A[i - 1] = A[j - 1]          A[j - 1] = tmp          i = next[i]          j = prev[j]        }      }       fun drop(i: Int) {        next[prev[i]] = next[i]        prev[next[i]] = prev[i]      }       fun find(letter: Int, s: Int): Pair<Int, Int> {        var i = s        var len = 1        while(A[i - 1] != letter) {          len++          i = next[i]        }        return Pair(i, len)      }       for (i in 0 .. N + 1) {        if (i > 0) prev[i] = i - 1        if (i < N + 1) next[i] = i + 1      }      prev[0] = -1      next[N + 1] = -1       var p = 0      val tandem = mutableListOf<Int>()      var n = 0      while(next[0] < N + 1) {        val fst = next[0]        val letter = A[fst - 1]        val (snd, len) = find(letter, next[fst])        debug{""$fst $snd $len""}        var i = next[fst]        var j = 0        // 1231 対象がだとする        while (i < snd) {          operations[n].pos = p + 1 + len + j // 1=|1| len=|231|          operations[n].letter = A[i - 1]          n++           i = next[i]          j++        }        tandem += len*2 // |123|*2        swap(next[fst], prev[snd])        drop(snd)        next[0] = next[next[0]] // １つ進める         p += len * 2      }       out.println(n)      for (i in 0 until n) {        val o = operations[i]        out.println(""${o.pos} ${o.letter}"")      }      out.println(tandem.size)      out.println(tandem.joinToString("" ""))    }  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return IntArray(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   /**   * コーナーケースでエラー出たりするので、debug(dp[1])のように添え字付きの場合はdebug{}をつかうこと   */  private inline fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: BooleanArray) {    debug { toString(a) }  }   private inline fun toString(a: BooleanArray) = run{a.map { if (it) 1 else 0 }.joinToString("""")}   private inline fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<BooleanArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }   private inline fun assert(b: Boolean) = run{if (!b) throw AssertionError()}  private inline fun assert(b: Boolean, f: () -> String) = run{if (!b) throw AssertionError(f())}   companion object {    // TestRunnerから呼びたいので単純なmainじゃだめ    fun main() {      val out = java.io.PrintWriter(System.out)      Solver(System.`in`, out).solve()      out.flush()    }  }} /** * judgeから呼ばれる */fun main() = Solver.main()","constructive algorithms,implementation,sortings"
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        val S = fakein.toString()        println(""New Case "")        println(S.take(80))        println(""..."")        fakein.clear()        IN = BufferedInputStream(S.byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} val getint:Int get() = IO.nextInt()val getlong:Long get() = IO.nextLong()val getstr:String get() = IO.nextString()fun getline(n:Int):IntArray{    return IntArray(n){getint}}fun getlineL(n:Int):LongArray{    return LongArray(n){getlong}}fun getbinary(n:Int):BooleanArray{    val str = getstr    return BooleanArray(n){str[it] == '1'}} val List<Char>.ret:Stringget() = this.joinToString("""")infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    var str = """"    if(this is String){ str = this    }else if(this is Int){ str = this.toString()    }else if(this is Long){ str = this.toString()    }    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}const val withBruteForce = falseconst val randCount = 100object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    fun cases(onecase:()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint} else if(mode == solveMode.tc){1 } else randCount        //safety checks        if(pI != 998_244_353 && pI != 1_000_000_007){            throw Exception(""Modding a wrong prime!"")        }         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            currentAnswer = null            currentBruteAnswer = null            onecase()        }        if(withBruteForce){            put(""Checked ${answersChecked}"")        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    inline fun brute(a:()->Unit){        if(withBruteForce){            a()        }    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }      var currentAnswer:String? = null    var currentBruteAnswer:String? = null    fun answer(a:Any){        currentAnswer = a.toString()        if(currentBruteAnswer != null){            checkAnswer()        }    }    fun put2(a:Any){answer(a);put(a) }     fun bruteAnswer(a:Any){        currentBruteAnswer = a.toString()        if(currentAnswer != null){            checkAnswer()        }    }    fun checkAnswer(){        if(currentAnswer != currentBruteAnswer){            throw Exception(""Failed Test: BF $currentBruteAnswer Current $currentAnswer"")        }        answersChecked ++    }}// 1. Moddedconst val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}infix fun Int.modM(b:Int):Int{ return ((this * 1L * b) % pI).toInt() }infix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }// 2. DP initial valuesconst val plarge = 1_000_000_727const val nlarge = -plargeconst val phuge = 2_727_000_000_000_000_000Lconst val nhuge = -phuge// 3. conveniecen conversionsval Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionval Char.code :Int get() = this.toInt() -  'a'.toInt()//3. hard to write stufffun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val mint:MutableList<Int> get() = mutableListOf<Int>()val mong:MutableList<Long> get() = mutableListOf<Long>()  const val singleCase = falsefun main(){    solve.cases{        val n = getint        val L = getline(n)        val things = mutableMapOf<Int,Int>()        for(a in L){            things[a] = things.getOrDefault(a,0) + 1        }        if(things.values.any{it %2 != 0}){            put(-1)            return@cases        }        val ret = mutableListOf<Pair<Int,Int>>()        var shifts =  0        var LL = L.toList()        val total = mutableListOf<Int>()        while(LL.isNotEmpty()){            val here = LL[0]            val next = (1..LL.lastIndex).first { LL[it] == here }            for(i in 1 until next){                ret.add(Pair(LL[i],shifts + i + next))            }            val new2 = LL.slice(1 until next).reversed()            val new3 = LL.slice(next +1 until LL.size)            LL = new2 + new3            shifts += 2 * next            total.add(2 * next) //            shifts dei LL        }        put(ret.size)         for((a,b) in ret){            put(""$b $a"")        }        put(total.size)        put(total.joinToString("" ""))         }    done()}/* 1 2 3 1 3 2 1 3 1 3 3 2 2 3 2 2 161 2 3 1 2 3 */   ","constructive algorithms,implementation,sortings"
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        val S = fakein.toString()        println(""New Case "")        println(S.take(80))        println(""..."")        fakein.clear()        IN = BufferedInputStream(S.byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} val getint:Int get() = IO.nextInt()val getlong:Long get() = IO.nextLong()val getstr:String get() = IO.nextString()fun getline(n:Int):IntArray{    return IntArray(n){getint}}fun getlineL(n:Int):LongArray{    return LongArray(n){getlong}}fun getbinary(n:Int):BooleanArray{    val str = getstr    return BooleanArray(n){str[it] == '1'}} val List<Char>.ret:Stringget() = this.joinToString("""")infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    var str = """"    if(this is String){ str = this    }else if(this is Int){ str = this.toString()    }else if(this is Long){ str = this.toString()    }    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}const val withBruteForce = falseconst val randCount = 100object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    fun cases(onecase:()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint} else if(mode == solveMode.tc){1 } else randCount        //safety checks        if(pI != 998_244_353 && pI != 1_000_000_007){            throw Exception(""Modding a wrong prime!"")        }         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            currentAnswer = null            currentBruteAnswer = null            onecase()        }        if(withBruteForce){            put(""Checked ${answersChecked}"")        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    inline fun brute(a:()->Unit){        if(withBruteForce){            a()        }    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }      var currentAnswer:String? = null    var currentBruteAnswer:String? = null    fun answer(a:Any){        currentAnswer = a.toString()        if(currentBruteAnswer != null){            checkAnswer()        }    }    fun put2(a:Any){answer(a);put(a) }     fun bruteAnswer(a:Any){        currentBruteAnswer = a.toString()        if(currentAnswer != null){            checkAnswer()        }    }    fun checkAnswer(){        if(currentAnswer != currentBruteAnswer){            throw Exception(""Failed Test: BF $currentBruteAnswer Current $currentAnswer"")        }        answersChecked ++    }}// 1. Moddedconst val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}infix fun Int.modM(b:Int):Int{ return ((this * 1L * b) % pI).toInt() }infix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }// 2. DP initial valuesconst val plarge = 1_000_000_727const val nlarge = -plargeconst val phuge = 2_727_000_000_000_000_000Lconst val nhuge = -phuge// 3. conveniecen conversionsval Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionval Char.code :Int get() = this.toInt() -  'a'.toInt()//3. hard to write stufffun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val mint:MutableList<Int> get() = mutableListOf<Int>()val mong:MutableList<Long> get() = mutableListOf<Long>()  const val singleCase = falsefun main(){    solve.cases{        val n = getint        val L = getline(n)        val things = mutableMapOf<Int,Int>()        for(a in L){            things[a] = things.getOrDefault(a,0) + 1        }        if(things.values.any{it %2 != 0}){            put(-1)            return@cases        }        val ret = mutableListOf<Pair<Int,Int>>()        var shifts =  0        var LL = L.toList()        val total = mutableListOf<Int>()        while(LL.isNotEmpty()){            val here = LL[0]            val next = (1..LL.lastIndex).first { LL[it] == here }            for(i in 1 until next){                ret.add(Pair(LL[i],shifts + i + next))            }            val new2 = LL.slice(1 until next).reversed()            val new3 = LL.slice(next +1 until LL.size)            LL = new2 + new3            shifts += 2 * next            total.add(2 * next) //            shifts dei LL        }        put(ret.size)         for((a,b) in ret){            put(""$b $a"")        }        put(total.size)        put(total.joinToString("" ""))         }    done()}/* 1 2 3 1 3 2 1 3 1 3 3 2 2 3 2 2 161 2 3 1 2 3 */   ","constructive algorithms,implementation,sortings"
"fun readStr() = readLine()!!fun readInt() = readLine()!!.toInt()fun readLong() = readLine()!!.toLong()fun readPair() = readLine()!!.split("" "").let { it[0].toInt() to it[1].toInt() }fun readIntList() = readLine()!!.split("" "").map { it.toInt() }fun readLongList() = readLine()!!.split("" "").map { it.toLong() }fun readIntArr() = readIntList().toIntArray()fun readDoubleList() = readLine()!!.split("" "").map { it.toDouble() }fun Boolean.toAns() = if (this) ""yes"" else ""no"" fun go(ansBuilder: StringBuilder.() -> Unit) {    val sb = StringBuilder()    val t = readInt()    repeat(t) { sb.ansBuilder() }    println(sb.toString())} fun main() = go {    val n = readInt()    val p = readIntList().toIntArray()    for (i in p.indices) {        if (p[i] > i + 1) {            val pos = p.indices.find { p[it] == i + 1 }!!            p.reverse(i, pos + 1)            break        }    }    appendLine(p.joinToString("" ""))}","constructive algorithms,greedy,math"
"// 34521import java.io.*;import java.util.*;fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!        val input = readLine()!!.split("" "").map { it -> it.toInt() }.toMutableList()        process(input)    }} private fun process(input: MutableList<Int>) {     val stack = Stack<Pair<Int, Int>>()     var min = Integer.MAX_VALUE     for (i in 0 until input.size) {         val e = input[i]         if (stack.isEmpty()) {             stack.add(e to i)         } else {             if (e > stack.peek().first) {                 stack.add(e to i)             } else {                 if (min == Integer.MAX_VALUE) {                     min = i                 } else {                     if (input[min] > e) {                        min = i                     }                 }               }         }     }     if (min == Integer.MAX_VALUE) {        println(input.joinToString("" ""))        return     }     var l = 0     while (stack.isNotEmpty() && stack.peek().first > input[min]) {         l = stack.pop().second     }     // min is r and l is found      while (l < min) {        val temp = input[l]        input[l] = input[min]        input[min] = temp        l++        min--     }      println(input.joinToString("" ""))}","constructive algorithms,greedy,math"
"import java.util.*  /** * Accomplished using the EduTools plugin by JetBrains https://plugins.jetbrains.com/plugin/10081-edutools * * To modify the template, go to Preferences -> Editor -> File and Code Templates -> Other */ fun solve(seq: List<Int>): List<Int> {    val sorted = seq            .mapIndexed { index, v -> index to v }            .sortedBy { it.second }    var l = 0    while (l < seq.size && seq[l] == sorted[l].second) l++    if (l == seq.size) {        return seq    }    val rCandidates = sorted.filter { it.second == sorted[l].second }     fun List<Int>.v(o1: Pair<Int, Int>, i: Int): Int {        val ind = when {            i < o1.first -> i            i > o1.second -> i            else -> o1.second - (i - o1.first)        }        return this[ind]    }     val comparator = kotlin.Comparator { o1: Pair<Int, Int>, o2: Pair<Int, Int> ->        var result = 0        for (i in seq.indices) {            val v1 = seq.v(o1, i)            val v2 = seq.v(o2, i)            if (v1 != v2) {                result = v1.compareTo(v2)                break            }        }        result    }     val bestChoice = rCandidates            .map { (rCand, v) ->                l to rCand            }            .maxWithOrNull(comparator) ?: error("""")     return (0 until seq.size).map { seq.v(bestChoice, it) }} fun main() {    val sc = Scanner(System.`in`)    val n = sc.nextInt()    repeat(n) {        val t = sc.nextInt()        val seq = (0 until t).map { sc.nextInt() }        println(solve(seq).joinToString("" ""))    }}","constructive algorithms,greedy,math"
"import java.util.*;import java.io.*;import kotlin.collections.*;import kotlin.math.*; const val TESTS = true @ExperimentalStdlibApifun main() {    repeat(if (TESTS) ni() else 1, ::solve)    out.flush()} @ExperimentalStdlibApifun solve(testIdx : Int) {    val n = ni()    val arr = IntArray(n) {ni()}     var min = Int.MAX_VALUE    var minPos = -1    for (i in 0 until n) {        if (arr[i] != i+1 && arr[i] < min) {            min = arr[i]            minPos = i        }    }     if (minPos == -1) {        pln(arr.joinToString("" ""))    } else {        for (i in 0 until min-1) {            pr(""${arr[i]} "")        }        for (i in min-1 .. minPos) {            pr(""${arr[minPos - i + min-1]} "")        }        for (i in minPos+1 until n) {            pr(""${arr[i]} "")        }        pln()    }} fun gcd (a : Int, b : Int) : Int = if (b == 0) a else gcd(b, a % b)fun lcm (a : Int, b : Int) = a * b / gcd(a, b) operator fun String.get(range : IntRange) = substring(range) fun pln (a : Any? = """") = out.println(a)fun pr (a : Any?) = out.print(a) fun ni() = nstr().toInt()fun nl() = nstr().toLong()fun nln() = br.readLine() ?: """"fun nstr() : String {while (!st.hasMoreTokens())    st = StringTokenizer(br.readLine() ?: return """", "" ""); return st.nextToken()} fun nis() = nstrs().map { it.toInt() }fun nls() = nstrs().map { it.toLong() }fun nstrs() = nln().split("" "").toMutableList() val out = PrintWriter(BufferedOutputStream(System.out))val br = BufferedReader(InputStreamReader(System.`in`)) var st = StringTokenizer("""")","constructive algorithms,greedy,math"
"import java.io.PrintWriterimport java.util.*import kotlin.math.* fun findCycle(adj: Array<MutableList<Int>>): List<Int> {    val n = adj.size    val seen = BooleanArray(n) { false }    val finished = BooleanArray(n) { false }    var pos = -1    val hist = Stack<Int>()    fun dfs(v: Int, p: Int) {        seen[v] = true        hist.push(v)        for (w in adj[v]) {            if (w == p) continue            if (finished[w]) continue            if (seen[w] && !finished[w]) {                pos = w                return            }            dfs(w, v)            if (pos != -1) return        }        hist.pop()        finished[v] = true    }    for (i in 0 until n) {        if (!finished[i]) {            dfs(i, -1)            if (pos != -1) break        }    }     val cycle = mutableListOf<Int>()    while (hist.isNotEmpty()) {        val t = hist.pop()        cycle.add(t)        if (t == pos) break    }    return cycle} fun topologicalSort(adj: Array<MutableList<Int>>): List<Int> {    val ans = mutableListOf<Int>()    val n = adj.size    val ind = IntArray(n) { 0 }    for (i in 0 until n) {        for (v in adj[i]) ind[v]++    }    val que: Queue<Int> = ArrayDeque()    for (i in 0 until n) {        if (ind[i] == 0) que.add(i)    }    while (que.isNotEmpty()) {        val now = que.poll()        ans.add(now)        for (v in adj[now]) {            ind[v]--            if (ind[v] == 0) que.add(v)        }    }    return ans} fun PrintWriter.solve() {    val n = nextInt()    val m = nextInt()    val adj = Array(n) { mutableListOf<Int>() }    val edges = mutableListOf<Triple<Int, Int, Int>>()    for (i in 0 until m) {        val type = nextInt()        val v1 = nextInt() - 1        val v2 = nextInt() - 1        adj[v1].add(v2)        adj[v2].add(v1)        edges.add(Triple(type, v1, v2))    }    val choice = Array(n) { 0 }    val visited = BooleanArray(n) { false }    for (i in 0 until n) {        if (choice[i] != 0) continue        val stack = Stack<Pair<Int, Int>>()        stack.push(i to 1)        visited[i] = true        choice[i] = 1        while (stack.isNotEmpty()) {            val (v, dir) = stack.pop()            for (w in adj[v]) {                if (choice[w] == dir) {                    println(""NO"")                    return                }                if (!visited[w]) {                    visited[w] = true                    choice[w] = -dir                    stack.push(w to -dir)                }            }        }    }    val adj2 = Array(n) { mutableListOf<Int>() }    for ((type, v1, v2) in edges) {        if ((type == 1) xor (choice[v1] == 1)) {            adj2[v2].add(v1)        } else {            adj2[v1].add(v2)        }    }    if (findCycle(adj2).isNotEmpty()) {        println(""NO"")        return    }    val ts = topologicalSort(adj2)    val pos = Array(n) { 0 }    for (i in 0 until n) {        pos[ts[i]] = i    }    println(""YES"")    for (i in 0 until n) {        println(""${if (choice[i] == 1) ""L"" else ""R""} ${pos[i]}"")    }} fun main() {    Thread(null, {        val writer = PrintWriter(System.out, false)        writer.solve()        writer.flush()    }, ""solve"", abs(1L.shl(26)))        .apply { setUncaughtExceptionHandler { _, e -> e.printStackTrace(); kotlin.system.exitProcess(1) } }        .apply { start() }.join()} // region Scannerprivate var st = StringTokenizer("""")private val br = System.`in`.bufferedReader() fun next(): String {    while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())    return st.nextToken()} fun nextInt() = next().toInt()fun nextLong() = next().toLong()fun nextLine() = br.readLine()fun nextDouble() = next().toDouble()// endregion","2-sat,constructive algorithms,dfs and similar,dsu,graphs,greedy,sortings"
"import java.io.BufferedReader fun main() {    val br = System.`in`.bufferedReader()    val sb = StringBuilder()    val t = br.readInt()    repeat(t) {        val n = br.readInt()        val k = br.readInt()        val neededInRange = k + ((n - k + 1) shr 1)        val a = IntArray(n) { br.readInt() }        val sorted = a.sorted()        var bestLow = 1        var bestHigh = n        var lowIdx = 0        var highIdx = 0        var curLow = 1        var curHigh = 1        while ((n - lowIdx) >= neededInRange) {            while (highIdx < n && sorted[highIdx] <= curHigh) {                highIdx++            }            while (lowIdx < n && sorted[lowIdx] < curLow) {                lowIdx++            }            if (highIdx - lowIdx >= neededInRange) {                if (curHigh - curLow < bestHigh - bestLow) {                    bestHigh = curHigh                    bestLow = curLow                }                curLow++            } else {                curHigh++            }        }        var begin = 0        var curBalance = 0        var numMade = 0        sb.appendLine(""$bestLow $bestHigh"")        for (end in 0 until n) {            if (a[end] in bestLow..bestHigh) {                curBalance++            } else {                curBalance--            }            if (curBalance > 0 && numMade < k - 1) {                sb.appendLine(""${begin + 1} ${end + 1}"")                numMade++                curBalance = 0                begin = end + 1            }        }        sb.appendLine(""${begin + 1} $n"")    }    println(sb)} private const val SPACE_INT = ' '.toInt()private const val ZERO_INT = '0'.toInt()private const val NL_INT = '\n'.toInt() private fun BufferedReader.readInt(): Int {    var ret = read()    while (ret <= SPACE_INT) {        ret = read()    }    val neg = ret == '-'.toInt()    if (neg) {        ret = read()    }    ret -= ZERO_INT    var read = read()    while (read >= ZERO_INT) {        ret *= 10        ret += read - ZERO_INT        read = read()    }     while (read <= SPACE_INT && read != -1 && read != NL_INT) {        mark(1)        read = read()    }    if (read > SPACE_INT) {        reset()    }    return if (neg) -ret else ret}","binary search,constructive algorithms,data structures,greedy,two pointers"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.lang.AssertionErrorimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007 /** * a, bがマイナスでもうまいこと動く */private inline fun floor_div(a: Long, b: Long): Long {  val sign = java.lang.Long.signum(b)  val x = a*sign  val y = b*sign  return if (x > 0) x/y else -((-x+y-1)/y)} private inline fun ceil_div(a: Long, b: Long): Long {  val sign = java.lang.Long.signum(b)  val x = a*sign  val y = b*sign  return if (x > 0) (x+y-1)/y else x/y} /** * x < a/b を満たす整数xの最大 */private inline fun div_lt(a: Long, b: Long) = ceil_div(a, b) - 1 /** * x <= a/b を満たす整数xの最大 */private inline fun div_le(a: Long, b: Long) = floor_div(a, b) /** * x > a/b を満たす整数xの最小 */private inline fun div_gt(a: Long, b: Long) = floor_div(a, b) + 1 /** * x >= a/b を満たす整数xの最小 */private inline fun div_ge(a: Long, b: Long) = ceil_div(a, b) /** * 結果が負だったら正にする */private inline fun safe_mod(a: Long, m: Long): Long {  val x = a % m  return if (x >= 0) x else x+m}class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  private val reader = BufferedReader(InputStreamReader(stream), 32768)   fun solve() {    for (t in 0 until ni()) {      val (N, K) = na(2)      val A = na(N).toList()      val B = A.sorted()      val pos = div_ge((N + K).toLong(), 2).toInt()      val neg = N - pos      debug { ""pos:$pos neg:$neg"" }       var x = B[0]      var y = B[pos - 1]      for (i in 1 .. N - pos) {        if (abs(B[i + pos - 1] - B[i]) < abs(y - x)) {          x = B[i]          y = B[i + pos - 1]        }      }      out.println(""$x $y"")       var s = 0      var bal = 0      var k = K      for (i in 0 until N) {        if (A[i] in x .. y) bal++        else bal--         if ((bal > 0 && k > 1) || i == N - 1) {          out.println(""${s + 1} ${i + 1}"")          bal = 0          k--          s = i + 1        }      }      assert(s == N)    }  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return IntArray(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   /**   * コーナーケースでエラー出たりするので、debug(dp[1])のように添え字付きの場合はdebug{}をつかうこと   */  private inline fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: BooleanArray) {    debug { toString(a) }  }   private inline fun toString(a: BooleanArray) = run{a.map { if (it) 1 else 0 }.joinToString("""")}   private inline fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<BooleanArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }   private inline fun assert(b: Boolean) = run{if (!b) throw AssertionError()}  private inline fun assert(b: Boolean, f: () -> String) = run{if (!b) throw AssertionError(f())}   companion object {    // TestRunnerから呼びたいので単純なmainじゃだめ    fun main() {      val out = java.io.PrintWriter(System.out)      Solver(System.`in`, out).solve()      out.flush()    }  }} /** * judgeから呼ばれる */fun main() = Solver.main()","binary search,constructive algorithms,data structures,greedy,two pointers"
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.random.Randomimport kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        IN = BufferedInputStream(fakein.toString().byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} fun getint():Int{ return IO.nextInt() }fun getlong():Long{ return IO.nextLong() }fun getline(n:Int):IntArray{    val ret = IntArray(n);repeat(n){ret[it] = getint()};return ret}fun getlineL(n:Int):LongArray{    val ret = LongArray(n);repeat(n){ret[it] = getlong()};return ret}fun getstr():String{ return IO.nextString() }fun MutableList<Int>.streamint(n:Int){ repeat(n){this.add(getint())}}fun MutableList<Long>.streamlong(n:Int){ repeat(n){this.add(getlong())}}inline fun cases(ask:()->Unit){ val t = getint();repeat(t){ ask() }} val List<Char>.ret:Stringget() = this.joinToString("""")infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    var str = """"    if(this is String){ str = this    }else if(this is Int){ str = this.toString()    }else if(this is Long){ str = this.toString()    }    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    inline fun cases(a:solve.()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint()} else if(mode == solveMode.tc){1 } else randCount        //safety checks        if(pI != 998_244_353 && pI != 1_000_000_007){            throw Exception(""Modding a wrong prime!"")        }         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            currentAnswer = null            currentBruteAnswer = null            a()        }        if(withBruteForce){            put(""Checked ${answersChecked}"")        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    inline fun brute(a:()->Unit){        if(withBruteForce){            a()        }    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }      var currentAnswer:String? = null    var currentBruteAnswer:String? = null    fun answer(a:Any){        currentAnswer = a.toString()        if(currentBruteAnswer != null){            checkAnswer()        }    }    fun put2(a:Any){answer(a);put(a) }     fun bruteAnswer(a:Any){        currentBruteAnswer = a.toString()        if(currentAnswer != null){            checkAnswer()        }    }    fun checkAnswer(){        if(currentAnswer != currentBruteAnswer){            throw Exception(""Failed Test: BF $currentBruteAnswer Current $currentAnswer"")        }        answersChecked ++    }}// 1. Moddedconst val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}infix fun Int.modM(b:Int):Int{ return ((this * 1L * b) % pI).toInt() }infix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }fun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val Boolean.chi:Int get() = if(this) 1 else 0 //characteristic function// 2. DP initial valuesconst val plarge = 1_000_000_727const val nlarge = -plargeconst val phuge = 2_727_000_000_000_000_000Lconst val nhuge = -phugeval Char.code :Int get() = this.toInt() -  'a'.toInt()inline fun BinarySearchFirstTrue(l:Int,r:Int,isTrue:(Int)->Boolean):Int?{    //inclusive    var L = l    var R = r    while(L<R){        val m = (L + R) shr 1        if(isTrue(m)){            R = m        }else{            L = m + 1        }    }    return if(isTrue(L)){        L    }else{        if(L == r){            null        }else{            L + 1        }    }} inline fun BinarySearchLastTrue(l:Int,r:Int,isTrue:(Int)->Boolean):Int?{    //inclusive    var L = l    var R = r    while(L<R){        val m = ((L + R) shr 1) + 1        if(isTrue(m)){ L = m }else{ R = m - 1 }    }    return if(isTrue(L)){ L }else{ null }}   const val withBruteForce = falseconst val randCount = 100fun main(){    solve.cases{        val n = getint()        val k = getint()        val L = getline(n)        val counts = IntArray(n+1)         for(a in L){            counts[a] ++        }        val leqcount = counts.copyOf()        for(i in 0 until n){            leqcount[i+1] += leqcount[i]        }        fun rangecount(l:Int, r:Int):Int {            val rr = minOf(r,n)            return leqcount[rr] - leqcount[l-1]        }        val need = (n+k+1)/2        var bestNow = Int.MAX_VALUE        var bestleft = -1        var bestright = -1        for(left in 1..n){            val right = BinarySearchFirstTrue(left,n){                rangecount(left,it) >= need            }            if(right != null ){                if(right - left < bestNow){                    bestNow = right - left                    bestleft = left                    bestright = right                }            }        }         val x = bestleft        val y = bestright        var ones = 0        var zeros = 0        var comps = 0        var start = 0          put(""$x $y"")         for(i in 0 until n){            val here = L[i]            if(here in x..y){                ones ++            }else{                zeros ++            }            if(ones > zeros && comps != k-1){                put(""${start + 1} ${i+1}"")                start = i +1                comps ++                ones = 0                zeros = 0            }        }        put(""${start + 1} ${n}"")     }    done()}const val singleCase = false/* at least that amount 0 1 21 2 32 3 40 24  1 0 11 12 1 22 2  1 1 1 0 0 0 1 1 1  14 21 2 2 2  111 35 5 5 1 5 5 1 5 5 5 1 */","binary search,constructive algorithms,data structures,greedy,two pointers"
"import java.lang.AssertionErrorimport java.lang.StringBuilderimport java.util.*import kotlin.math.* val readQueue = ArrayDeque<String>()fun getInput(): String {    if (readQueue.isEmpty()) readLine()!!.split(' ', '\n').let{ readQueue.addAll(it) }    return readQueue.pop()} fun getInt() = getInput().toInt()fun getLong() = getInput().toLong()fun getString() = getInput() const val MOD107 = 1000000007Lconst val MOD998 = 998244353Lfun myAssert(b : Boolean) {    if (!b) throw AssertionError()} fun main() {    var t = getInt()    while (t-- > 0) {        var (n,k) = Array(2) { getInt() }        var a = Array(n) { getInt() }         var cnt = Array(n + 1) { 0 }        for (i in a)            cnt[i]++         var (ansl, ansr) = arrayOf(1, n)        run {            var l = 1            var sum = -n            for (r in 1 .. n) {                sum += 2 * cnt[r]                while (sum - 2 * cnt[l] >= k) {                    sum -= 2 * cnt[l]                    l++                }                if (sum >= k && r - l < ansr - ansl) {                    ansl = l                    ansr = r                }            }        }         var itv = arrayListOf<Array<Int>>()        var curL = 0        var ps = 0        for (i in 0 until n) {            ps += if (a[i] in ansl .. ansr) +1 else -1            if (ps == +1) {                itv.add(arrayOf(curL + 1, i + 1))                curL = i + 1                ps = 0            }        }         myAssert(itv.size >= k)        itv[k - 1][1] = n        println(""$ansl $ansr\n"" + (0 until k).map { itv[it].joinToString("" "") }.joinToString(""\n""))    }}","binary search,constructive algorithms,data structures,greedy,two pointers"
"fun main(args : Array<String>) {    val t = readLine()!!.trim().toInt()     repeat(t) {        val n = readLine()!!.trim().toInt()        var aa = readLine()!!.trim().split("" "").map { it.toInt() }.map {            var a = it            while (a > n) a /= 2            a        }         val ans = IntArray(n+1) { -1 }        val done = mutableMapOf<Int, Boolean>()         while (done.size < n) {            aa = aa.mapIndexed { idx, a ->                if (done[idx] != true && a > 0 && ans[a] == -1) {                    ans[a] = idx                    done[idx] = true                }                a / 2            }            if (done.size < n && aa.count { it == 0 } == n) {                println(""NO"")                return@repeat            }        }        println(""YES"")    }}","constructive algorithms,flows,graph matchings,greedy,math"
"import java.util.*  fun main() {    val sc = Scanner(System.`in`)    var t = sc.nextInt()    while (t-- > 0) {        val n = sc.nextInt()        val arr = IntArray(n)        val freq = IntArray(n + 1)        Arrays.fill(arr, 0)        for (i in 0 until n) {            arr[i] = sc.nextInt()            while (arr[i] > n) {                arr[i] /= 2            }            freq[arr[i]]++        }        var flag = true        for (i in n downTo 1) {            if (freq[i] == 0) {                flag = false                break            }            freq[i / 2] += freq[i] - 1        }        if (flag) {            println(""YES"")        } else {            println(""NO"")        }    }}    private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readLong() = readLn().toLong()private fun readDouble() = readLn().toDouble()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }private fun readLongs() = readStrings().map { it.toLong() }private fun readDoubles() = readStrings().map { it.toDouble() }","constructive algorithms,flows,graph matchings,greedy,math"
"import java.io.BufferedReaderimport java.io.BufferedWriterimport java.io.InputStreamReaderimport java.io.OutputStreamWriter  val reader = BufferedReader(InputStreamReader(System.`in`))val writer = BufferedWriter(OutputStreamWriter(System.`out`)) fun readLine() = reader.readLine()fun readIntList() = reader.readLine().split(' ').map(String::toInt)fun readLongList() = reader.readLine().split(' ').map(String::toLong)fun readStringList() = reader.readLine().split(' ')fun readInt() = reader.readLine().toInt()fun readLong() = reader.readLine().toLong()fun readDouble() = reader.readLine().toDouble() fun main(args: Array<String>) {     var t = readInt()     while (t > 0) {         var n = readInt()        val list = readLongList()        val map = mutableMapOf<Int, Boolean>()        var answer = ""YES""         list.forEach {            var i = it.toInt()             while (i > 0) {                if (i <= n) {                    if (map[i] == null) {                        map[i] = true                        break                    }                }                i /= 2            }        }         for (i in 1..n){            if (map[i] == null){                answer = ""NO""            }        }         println(answer)        t--    }  }  ","constructive algorithms,flows,graph matchings,greedy,math"
"import java.util.* @JvmFieldval INPUT = System.`in` @JvmFieldval OUTPUT = System.out @JvmFieldval _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!! @JvmFieldvar _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()} fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = Array(n) { read() } // abc deffun readLines(n: Int) = Array(n) { readLn() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() }fun readPairIntArray(n: Int) = readLines(n).map { it.substringBefore("" "").toInt() to it.substringAfter("" "").toInt() } fun hasDuplicates(a: IntArray): Boolean {    return a.size != a.distinct().size} fun main(args: Array<String>) {    val t = readInt()    repeat(t) {        val n = readInt()        val a = readIntArray(n);         // bring them in range        for ((i, num) in a.withIndex()) {            var x = num            while (x > n) {               x = x shr 1            }            a[i] = x        }//        println(a.toList())        // bring them in range        while (hasDuplicates(a) && a.all { it > 0 }) {            a.sort()            for (i in 0 until a.lastIndex) {                if (a[i] == a[i + 1]) {                    a[i] /= 2                    break                }            }//            println(a.toList())        }         if (!hasDuplicates(a) && a.all { it > 0 }) {            println(""YES"")        } else {            println(""NO"")        }//        println(""yo"")    }}                    ","constructive algorithms,flows,graph matchings,greedy,math"
"import java.io.BufferedReaderimport kotlin.math.min fun main() {    val br = System.`in`.bufferedReader()    val sb = StringBuilder()    val q = br.readInt()     fun solve(): Long {        val n = br.readInt()        val s = br.readLine()        val t = br.readLine()        val used = BooleanArray(n)        var ans = Long.MAX_VALUE        val nextLarger = Array(26) { IntArray(n + 1) { n } }        for (x in n - 1 downTo 0) {            val c = s[x] - 'a'            for (y in 0 until c) {                nextLarger[y][x] = nextLarger[y][x + 1]            }            for (y in c until 26) {                nextLarger[y][x] = x            }        }        val indices = IntArray(26)        fun findNextOfOrSmaller(c: Int): Int {            var ret = nextLarger[c][indices[c]]            while (ret < n && used[ret]) {                indices[c] = ret + 1                ret = nextLarger[c][indices[c]]            }            return ret        }         val fenwick = SmallEnoughFenwick(n)         fun calc(tIdx: Int, i: Int): Int {            return i - tIdx + fenwick.get(i + 1, n - 1)        }         var curMoves = 0L        for (x in 0 until n) {            if (ans <= curMoves) break            val c = t[x] - 'a'            if (c > 0) {                val next = findNextOfOrSmaller(c - 1)                if (next != n) {                    ans = min(ans, curMoves + calc(x, next))                }            }            val next = findNextOfOrSmaller(c)            if (next != n) {                used[next] = true                curMoves += calc(x, next)                fenwick.add(next, 1)            } else {                break            }        }        return if (ans == Long.MAX_VALUE) {            -1        } else {            ans        }    }     repeat(q) {        sb.appendLine(solve())    }    println(sb)}  private class SmallEnoughFenwick(val size: Int) {    private val ary = IntArray(size)     fun add(idx: Int, v: Int) {        var k = idx + 1        while (k <= size) {            ary[k - 1] += v            k += k and -k        }    }     fun set(idx: Int, v: Int) {        add(idx, v - get(idx, idx))    }     fun get(idx: Int): Int {        var k = idx + 1        var r = 0        while (k > 0) {            r += ary[k - 1]            k -= k and -k        }        return r    }     fun get(a: Int, b: Int): Int {        return get(b) - get(a - 1)    }     //returns the 0 indexed index of the largest prefix sum that does not exceed the given value    fun prefixSearch(v: Int): Int {        var idx = 0        var curSum = 0        var curBit = Integer.highestOneBit(size)        while (curBit > 0) {            if (curBit + idx <= size) {                if (curSum + ary[curBit + idx - 1] <= v) {                    curSum += ary[curBit + idx - 1]                    idx += curBit                }            }            curBit = curBit shr 1        }        return idx - 1    }} private const val SPACE_INT = ' '.toInt()private const val ZERO_INT = '0'.toInt()private const val NL_INT = '\n'.toInt() private fun BufferedReader.readInt(): Int {    var ret = read()    while (ret <= SPACE_INT) {        ret = read()    }    val neg = ret == '-'.toInt()    if (neg) {        ret = read()    }    ret -= ZERO_INT    var read = read()    while (read >= ZERO_INT) {        ret *= 10        ret += read - ZERO_INT        read = read()    }     while (read <= SPACE_INT && read != -1 && read != NL_INT) {        mark(1)        read = read()    }    if (read > SPACE_INT) {        reset()    }    return if (neg) -ret else ret}","brute force,data structures,greedy,strings"
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport java.lang.IndexOutOfBoundsExceptionimport java.util.*import kotlin.random.Randomimport kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        IN = BufferedInputStream(fakein.toString().byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} fun getint():Int{ return IO.nextInt() }fun getlong():Long{ return IO.nextLong() }fun getline(n:Int):IntArray{    val ret = IntArray(n);repeat(n){ret[it] = getint()};return ret}fun getlineL(n:Int):LongArray{    val ret = LongArray(n);repeat(n){ret[it] = getlong()};return ret}fun getstr():String{ return IO.nextString() }fun MutableList<Int>.streamint(n:Int){ repeat(n){this.add(getint())}}fun MutableList<Long>.streamlong(n:Int){ repeat(n){this.add(getlong())}}inline fun cases(ask:()->Unit){ val t = getint();repeat(t){ ask() }} val List<Char>.ret:Stringget() = this.joinToString("""")infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    var str = """"    if(this is String){ str = this    }else if(this is Int){ str = this.toString()    }else if(this is Long){ str = this.toString()    }    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    inline fun cases(a:solve.()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint()} else if(mode == solveMode.tc){1 } else randCount         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            currentAnswer = null            currentBruteAnswer = null            a()        }        if(withBruteForce){            put(""Checked ${answersChecked}"")        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    inline fun brute(a:()->Unit){        if(withBruteForce){            a()        }    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }      var currentAnswer:String? = null    var currentBruteAnswer:String? = null    fun answer(a:Any){        currentAnswer = a.toString()        if(currentBruteAnswer != null){            checkAnswer()        }    }    fun put2(a:Any){answer(a);put(a) }     fun bruteAnswer(a:Any){        currentBruteAnswer = a.toString()        if(currentAnswer != null){            checkAnswer()        }    }    fun checkAnswer(){        if(currentAnswer != currentBruteAnswer){            throw Exception(""Failed Test: BF $currentBruteAnswer Current $currentAnswer"")        }        answersChecked ++    }}fun Int2(a:Int,b:Int) = List(a){IntArray(b)}fun Int3(a:Int,b:Int,c:Int) = List(a){List(b){IntArray(c)}}const val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}fun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionconst val funny = -777222777 // start array with this to be safe, WYSIconst val huge = 2_727_000_000_000_000_000L // used for seg tree thingsval Char.code :Int get() = this.toInt() -  'a'.toInt() class simpleSegTree (nSuggest  :Int){    //Items lenght must be a power of 2     val n = (maxOf((nSuggest - 1).takeHighestOneBit(),2)) shl 1    val levels = (31 - n.countLeadingZeroBits()) // (Levels) amount of levels then a layer of leaf    val arr = IntArray(n * 2 + 1 )    val arrSize = n * 2 + 1     constructor(withArray:IntArray):this(withArray.size){        for(i in withArray.indices){            arr[i+n] = withArray[i]        }         updateAll()    }     private fun updateNode(i:Int){        arr[i] = arr[i shl 1 ] + arr[(i shl 1) + 1]    }    private fun updatePath(i:Int){        // i is the endpoint, typically (n+i)        // bottom up, recalculate        var here = i        while(here > 1){            here = here shr 1            updateNode(here)        }    }    fun updateAll(){        for(i in n-1 downTo 1){            updateNode(i)        }    }    fun setValue(i:Int,value:Int){        arr[n+i] = value        updatePath(n+i)    }    fun addValue(i:Int, inc:Int){        arr[n+i] += inc        updatePath(n+i)    }     val firstIndex = n    val lastIndex = (n shl 1 ) - 1    val indices = firstIndex..lastIndex      fun primitiveIndex(a:Int) = a + n    inline fun segmentOrder(act:(here:Int, left:Int,right:Int)->Unit ){        //iterate over all segments bottom up, probably to rebuild tree        for(i in (n-1) downTo 1){            act(i, (i shl 1 ), (i shl 1) + 1)        }    }    inline fun primitiveOrder(act:(here:Int,primitiveIndex:Int)->Unit){        //iterate over all the leaf nodes        for(i in 0 until n){            act(i+n,i)        }    }      fun query(l:Int,r:Int): Int {        var ret:Int = 0        var left = l + n        var right = r + n+1        while(left < right){            if(left and 1 != 0){                ret += arr[left]                left += 1            }            if(right and 1 != 0){                right -= 1                ret += arr[right]            }            left = left shr 1            right = right shr 1        }        return ret    }    inline fun segDivision(l:Int, r:Int, act:(index:Int,level:Int)->Unit){        var left = l + n        var right = r + n + 1        var level = 0        while(left < right){            if(left and 1 != 0){                 act(left,level)                left += 1            }            if(right and 1 != 0){                right -= 1                act(right,level)            }            left = left shr 1            right = right shr 1            level ++        }    }     fun queryFunctional(l:Int,r:Int):Int{        var ret = 0        segDivision(l,r){i, _ ->            ret += arr[i]        }        return ret    }    fun indexOf(req:Int):Int{        // -1 if not enough        val req = req + 1        if(req > arr[1]){            throw IndexOutOfBoundsException()        }else if(req <= 0 ){            return -1        }        var i = 1        var rightPoint = -1        var cur = 0        for(l in 1..levels){            i = i shl 1            if(cur + arr[i] < req){                rightPoint += 1 shl (levels - l)                cur += arr[i]                i += 1            }        }        return rightPoint +1    }      val Int.leftNode:Int get(){        // assert(this <= n )        return this shl 1    }    val Int.rightNode:Int get(){        // assert(this <= n)        return (this shl 1) + 1    }    val Int.endpoints:Pair<Int,Int> get(){        val offSet = this - this.takeHighestOneBit()        val widthLevel = levels - (31 - this.countLeadingZeroBits())        return Pair(offSet shl widthLevel, (offSet shl widthLevel) + (1 shl widthLevel) - 1)    }  }const val withBruteForce = falseconst val randCount = 100fun main(){    solve.cases{        val n = getint()        val s = getstr()        val target = getstr()         val pos = Array(26){ mutableListOf<Int>() }         for(i in 0 until n){            val c = s[i]            val cc = c.code            pos[cc].add(i)        }        val occurence = simpleSegTree(n)        for(i in 0 until n){            occurence.addValue(i,1)        }        for(v in pos){            v.sortDescending()        }        var finalret = Long.MAX_VALUE        var res = 0L        for(j in 0 until n){            val cc = target[j].code            for(cd in cc - 1 downTo 0){                if(pos[cd].isNotEmpty()){                    val willgetFrom = pos[cd].last()                    finalret = minOf(finalret, res + occurence.query(0,willgetFrom) - 1)                }            }            if(pos[cc].isNotEmpty()){                val willgetFrom = pos[cc].last()                pos[cc].removeLast()                res += occurence.query(0,willgetFrom) - 1                occurence.addValue(willgetFrom,-1)            }else{                break            }        }        put(if(finalret == Long.MAX_VALUE) -1 else finalret)    }    done()}const val singleCase = false","brute force,data structures,greedy,strings"
"inline fun <T> List<T>.partitionPoint(predicate: (T) -> Boolean): Int {    var min = 0    var max = size    while (min < max) {        val mid = (min + max) shr 1        if (predicate(this[mid])) {            min = mid + 1        }else {            max = mid        }    }    return max}fun <T: Comparable<T>> List<T>.lowerBound(target: T): Int {    return partitionPoint { it < target }}fun main() {    val testCase = readLine()!!.trim().toInt()    repeat(testCase) {        val n = readLine()!!.trim().toInt()        val s = readLine()!!.trim()        val t = readLine()!!.trim()        val indices = Array(26){ArrayDeque<Int>()}        for ((i, c) in s.withIndex()) {            indices[c - 'a'].addLast(i)        }        var result = null as Long?        var count = 0L        for (c in t) {            var minPos = n            for (i in 0 until c - 'a') {                minPos = minOf(minPos, indices[i].firstOrNull() ?: continue)            }            if (minPos < n) {                var add = count                for (i in c - 'a' until 26) {                    add += indices[i].lowerBound(minPos)                }                result = minOf(result ?: add, add)            }            val just = indices[c - 'a'].removeFirstOrNull() ?: break            for (i in 0 until 26) {                if (i == c - 'a') continue                count += indices[i].lowerBound(just)            }        }        println(result ?: -1)    }}","brute force,data structures,greedy,strings"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.io.PrintWriterimport java.util.* val inf = BufferedReader(InputStreamReader(System.`in`))val ouf = PrintWriter(System.out) fun readString() = inf.readLine()!!fun readIntList() = inf.readLine()!!.split(' ').map(String::toInt)fun readInt() = readIntList()[0] const val INFL = Long.MAX_VALUE fun main() {    for (t in 1..readInt()) {        solve()    }    ouf.close()} fun solve() {    val n = readInt()    val s = readString()    val so = object {        val chars = Array(26) { LinkedList<Int>() }        val st = object {            val a: IntArray            val c: Int            init {                var cc = 4                while (cc < n) cc *= 2                c = cc                a = IntArray(c * 2)            }            fun set(i: Int) {                a[i + c] = 1                var j = (i + c) / 2                while (j > 0) {                    a[j] = a[j * 2] + a[j * 2 + 1]                    j /= 2                }            }            fun sum(b: Int, e: Int) = sumInt(b + c, e + c)            fun sumInt(b: Int, e: Int): Int {                if (b == e) return a[b]                if (b + 1 == e) return a[b] + a[e]                var cur = 0                if (b % 2 == 1) cur += a[b]                if (e % 2 == 0) cur += a[e]                return cur + sumInt((b + 1) / 2, (e - 1) / 2)            }        }        init {            s.withIndex().forEach {                chars[it.value - 'a'].add(it.index)            }        }         fun minChar(c: Char): Pair<Char, Int> {            var ans = Pair(c, n)            for (i in 0 until c - 'a') {                if (chars[i].size > 0 && adjust(chars[i].first) < ans.second) {                    ans = Pair('a' + i, adjust(chars[i].first))                }            }            return ans        }         fun eqChar(c: Char): Int {            if (chars[c - 'a'].size == 0) return n            return adjust(chars[c - 'a'].first)        }         fun rm(c: Char) {            val i = chars[c - 'a'].removeFirst()            st.set(i)        }         private fun adjust(i: Int): Int {            return i + st.sum(i, n - 1)        }    }    val t = readString()    var ans = INFL    var cur = 0L    for (i in t.indices) {        val (cm, jm) = so.minChar(t[i])        if (jm < n && cm < t[i]) {            ans = minOf(ans, cur + (jm - i).toLong())        }        val j = so.eqChar(t[i])        if (j == n) break        cur += j - i        so.rm(t[i])    }    if (ans == INFL) ans = -1    ouf.println(ans)}","brute force,data structures,greedy,strings"
"fun main(args: Array<String>){    repeat(readLine()!!.toInt()){        var arr=readLine()!!.split("" "")!!.map{it.toInt()}        var x=arr[0]        var y=arr[1]       // println(""x=$x y=$y"")        if((x+y)%2!=0){            println(""-1 -1"")        }else{            var temp=(x+y)/2            if(y>temp){                println(""0 $temp"")            }else{                temp=temp-y                println(""$temp $y"")            }        }    }}","brute force,constructive algorithms"
"import java.io.*import java.util.*import kotlin.math.absoluteValueimport kotlin.math.floorimport kotlin.math.sqrtimport kotlin.system.measureTimeMillis // @formatter:off val local = System.getProperty(""ONLINE_JUDGE"") == null//val local = false val INPUT: InputStream = if (local) FileInputStream(""input.txt"") else System.`in`//val INPUT: InputStream = System.`in` //val OUTPUT: PrintStream = if (local) PrintStream(""output.txt"") else System.outval OUTPUT: PrintStream = System.out val _reader = INPUT.bufferedReader()var _tokenizer = StringTokenizer("""") fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!!fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()} fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readStrings() = readLn().split("" "")fun readInts() = readStrings().map { it.toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() }fun PrintWriter.yesNo(p: Boolean) {    if (p) this.println(""YES"") else this.println(""NO"")} @JvmFieldval _writer = PrintWriter(OUTPUT, true)// @formatter:on  fun solve(x0: Int, y0: Int): Pair<Int, Int> {    for (x in 0..x0) {        for (y in 0..y0) {            if ( (x + y) == x0 - x + y0 - y) {                return x to y            }        }    }    return -1 to -1 } fun PrintWriter.solve() {     val tcs = readInt()//    val tcs = 1    for (tc in 1..tcs) {        val n = readInt()        val m = readInt()        val res = solve(n, m)        println(""${res.first} ${res.second}"")    }} fun main() {     val elapsedMs = measureTimeMillis {        _writer.solve()        _writer.flush()    }    if (local) {        println(""\n\nElapsed $elapsedMs ms"")    } }","brute force,constructive algorithms"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"", ""DEPRECATION"") import java.io.PrintWriterimport java.util.*import kotlin.math.*import kotlin.random.* @JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out @JvmField val reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun readLn() = reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readString() = readStrings(1)[0]fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int = 2) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int = 2) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmFieldval writer = PrintWriter(OUTPUT, true) // ---------------------------------------------------------------------------- class UnionFind {     private val parents = mutableMapOf<Int, Int>()    private val sizes = mutableMapOf<Int, Int>()     fun union(a: Int, b: Int) {        val fa = find(a)        val fb = find(b)        if (fa != fb) {            parents[fa] = fb            sizes[fb] = (sizes[fb] ?: 1) + (sizes[fa] ?: 1)        }    }     fun find(a: Int): Int {        fun getOrDefault(value: Int) = parents.getOrDefault(value, value)         var parent = getOrDefault(a)        while (parent != getOrDefault(parent)) {            parents[parent] = getOrDefault(getOrDefault(parent))            parent = parents[parent]!!        }        return parent    }     fun connected(a: Int, b: Int): Boolean {        return find(a) == find(b)    }     fun getSize(a: Int): Int {        return sizes[find(a)] ?: 1    }} class Trie() {     /** Initialize your data structure here. */    private val root = Node()     /** Inserts a word into the trie. */    fun insert(word: String) {        var node = root        for (char in word) {            if (!node.children.contains(char)) {                node.children[char] = Node()            }            node = node.children[char]!!        }        node.hasWord = true    }     /** Returns if the word is in the trie. */    fun search(word: String): Boolean {        return findNode(word)?.hasWord ?: false    }     /** Returns if there is any word in the trie that starts with the given prefix. */    fun startsWith(prefix: String): Boolean {        return findNode(prefix) != null    }     private fun findNode(prefix: String): Node? {        var node = root        for (char in prefix) {            node = node.children[char] ?: return null        }        return node    }     private class Node(        var hasWord: Boolean = false,        val children: MutableMap<Char, Node> = mutableMapOf<Char, Node>()    )} // f	f	e=f0gd8f d; 0 e<e'// query(index): sum[0, index]class BinaryIndexedTree {     private val bit: IntArray     constructor(n: Int) {        this.bit = IntArray(n + 1)    }     constructor(nums: IntArray) {        this.bit = IntArray(nums.size + 1)        val prefix = IntArray(bit.size)        for (i in 1 until nums.size + 1) {            prefix[i] = prefix[i - 1] + nums[i - 1]            bit[i] = prefix[i] - prefix[i - lowbit(i)]        }    }     fun query(index: Int): Int {        var result = 0        var i = index + 1        while (i > 0) {            result += bit[i]            i -= lowbit(i)        }        return result    }     fun update(index: Int, x: Int) {        val value = query(index) - query(index - 1)        add(index, x - value)    }     fun add(index: Int, x: Int) {        var i = index + 1        while (i < bit.size) {            bit[i] += x            i += lowbit(i)        }    }     private fun lowbit(x: Int): Int {        return x.and(-x)    }} // ---------------------------------------------------------------------------- private fun PrintWriter.printNums(nums: List<Int>) {    nums.forEach {        print(it)        print(' ')    }    println()} private fun fastPow(a: Long, exp: Long, mod: Long): Long {    var result = 1L % mod    var base = a % mod    var remain = exp    while (remain != 0L) {        if (remain % 2L == 1L) {            result = (result * base) % mod        }        base = (base * base) % mod        remain /= 2L    }    return result} private fun gcd(a: Int, b: Int): Int {    return if (b == 0) a else gcd(b, a % b)} private fun lcm(a: Int, b: Int): Int {    return ((a.toLong() * b.toLong()) / gcd(a, b)).toInt()} private fun wordToCharCount(word: String): IntArray {    val charCount = IntArray(26)    for (char in word) {        charCount[char.toIndex()]++    }    return charCount} private fun Char.toIndex(): Int {    return this.toInt() - 'a'.toInt()} private fun Char.toDigit(): Int {    return this.toInt() - '0'.toInt()} private fun Boolean.toYesNo(upper: Boolean = false): String {    val yesNo = if (this) ""Yes"" else ""No""    return if (upper) yesNo.toUpperCase() else yesNo} private val DIR = listOf(    listOf(0, 1), listOf(1, 0), listOf(0, -1), listOf(-1, 0)) private const val MOD = 998244353private const val MODL = 998244353L // ---------------------------------------------------------------------------- fun main() {    val go: Runnable = Runnable {        writer.solve()        writer.flush()    }    Thread(null, go, ""thread"", 1L.shl(28)).start()} private fun PrintWriter.solve() {    val t = readInt()    repeat(t) {        val (x, y) = readInts()        printNums(getDistance(x, y))    }} private fun getDistance(x: Int, y: Int): List<Int> {    val sum = x + y    if (sum % 2 == 1) {        return listOf(-1, -1)    }    val half = sum / 2    return if (half <= x) {        listOf(half, 0)    } else {        listOf(x, half - x)    }}","brute force,constructive algorithms"
"class Distance {     fun mySolution(x: Int, y: Int): Pair<Int, Int> =        when {            (((x + y) % 2) != 0) -> Pair(-1, -1)            else -> Pair((x + 1) / 2, y / 2)        }} fun main() {    val distance = Distance()    repeat(readLine()!!.toInt()) {        val (x, y) = readLine()!!.split("" "").map { it.toInt() }        println(distance.mySolution(x, y).toList().joinToString("" ""))    }}","brute force,constructive algorithms"
"import java.math.BigInteger //////////////////////////CODEFORCE Deltix//A inline fun isABC(s: CharArray, i: Int) =    i >= 0 && i + 2 < s.size && s[i] == 'a' && s[i+1] == 'b' && s[i+2] == 'c' fun docase(nextLine: () -> String) {     val (n,q) = nextLine().split("" "").map { it.toInt() }    val a = nextLine().trim().toCharArray()     var abcs = (0 until a.size).filter { isABC(a, it) }.toMutableSet() //    println(abcs.size)     for (i in 1..q) {        val query = nextLine().split("" "")        val idx = query[0].toInt() - 1        val c = query[1][0]        if (c != a[idx]) {            abcs.remove(idx)            abcs.remove(idx-1)            abcs.remove(idx-2)            a[idx] = c            if (isABC(a, idx)) abcs.add(idx)            if (isABC(a, idx-1)) abcs.add(idx-1)            if (isABC(a, idx-2)) abcs.add(idx-2)        }        println(abcs.size)//        println(abcs.joinToString("" "") + "" "" + a.joinToString(""""))    } } fun docontest(nextLine: () -> String) {    val N = nextLine().toInt()    (1..N).map {case ->        docase(nextLine)    }} fun main(args: Array<String>) {    val bf = System.`in`.bufferedReader()    docase {        bf.readLine() ?: """"    }  } ","implementation,strings"
"import java.util.*import java.io.*import kotlin.collections.*import kotlin.math.* const val FILE_IO = falseconst val FILE_IN = ""input.txt""const val FILE_OUT = ""output.txt"" const val TESTS = false @kotlin.ExperimentalStdlibApifun main() {    if (TESTS) {        presolve()        repeat(ni(), ::solve)    } else        solve()    output.flush()} @kotlin.ExperimentalStdlibApifun presolve() { } @kotlin.ExperimentalStdlibApifun solve(testIdx : Int = 0) {    val (n, q) = nis()    var str = StringBuilder(nstr())     var cnt = 0     for (i in 0 until n-2) {        if (str.substring(i..i+2) == ""abc"") cnt++    }     for (i in 0 until q) {        val pos = ni()-1        val char = nstr()         var cntOld = 0         for (j in pos-2 .. pos) {            if (j >= 0 && j < n-2 && str.substring(j..j+2) == ""abc"") cntOld++        }         str.setCharAt(pos, char[0])         var cntNew = 0         for (j in pos-2 .. pos) {            if (j >= 0 && j < n-2 && str.substring(j..j+2) == ""abc"") cntNew++        }         if (cntNew < cntOld) cnt--        else if (cntNew > cntOld) cnt++         pln(cnt)    }} fun pln(a : Any = """") = output.println(a)fun pr(a : Any) = output.print(a)fun ipln(a : Any) {output.println(a); output.flush()} fun ni() = nstr().toInt()fun nl() = nstr().toLong()fun nln() = br.readLine() ?: """"fun nstr() : String {while (!st.hasMoreElements()) st = StringTokenizer(br.readLine() ?: return """", "" ""); return st.nextToken()} fun IntArray.read() : IntArray {for (i in indices) this[i] = ni(); return this}fun LongArray.read() : LongArray {for (i in indices) this[i] = nl(); return this}fun Array<String>.read() : Array<String> {for (i in indices) this[i] = nstr(); return this} fun nis(del: String = "" "") = ArrayList(nln().split(del).map {it.toInt()})fun nls(del: String = "" "") = ArrayList(nln().split(del).map {it.toLong()})fun nstrs(del: String = "" "") = ArrayList(nln().split(del)) var output = PrintWriter(BufferedOutputStream(if (FILE_IO) FileOutputStream(FILE_OUT) else System.out))val br = BufferedReader(InputStreamReader(if (FILE_IO) FileInputStream(FILE_IN) else System.`in`))var st = StringTokenizer("""")","implementation,strings"
"import java.util.*import kotlin.math.* fun main() {    val (n, q) = readIntArray(2)    val s = read().toCharArray()    val interesting = BooleanArray(n)    val pos = IntArray(n)    var count = 0     for (i in 0 until n - 2) {        if (s[i] == 'a' && s[i + 1] == 'b' && s[i + 2] == 'c') {            count++            interesting[i] = true            interesting[i + 1] = true            interesting[i + 2] = true             for (j in 1..3) {                pos[i + j - 1] = j            }        }    }     repeat(q) {        val idx = readInt() - 1        val char = read().toCharArray()[0] - 'a'         if ('a' + char == s[idx]) {            println(count)            return@repeat        }         if (interesting[idx]) {            if (pos[idx] != char + 1) {                if (pos[idx] == 1) {                    for (j in 0 until 3) {                        interesting[idx + j] = false                    }                } else if (pos[idx] == 2) {                    for (j in -1..1) {                        interesting[idx + j] = false                    }                } else {                    for (j in -2..0) {                        interesting[idx + j] = false                    }                }                 count--            }        }         s[idx] = 'a' + char        if (char == 0) {            if (idx + 2 < n) {                if (s[idx +  1] == 'b' && s[idx + 2] == 'c') {                    for (j in 0 until 3) {                        interesting[idx + j] = true                        pos[idx + j] = j + 1                    }                     count++                }            }        } else if (char == 1) {            if (idx + 1 < n && idx - 1 >= 0) {                if (s[idx - 1] == 'a' && s[idx + 1] == 'c') {                    for (j in -1..1) {                        interesting[idx + j] = true                        pos[idx + j] = j + 2                    }                    count++                }            }        } else {            if (idx - 2 >= 0) {                if (s[idx - 1] == 'b' && s[idx - 2] == 'a') {                    for (j in -2..0) {                        interesting[idx + j] = true                        pos[idx + j] = j + 3                    }                     count++                }            }        }         println(count)    }} @JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar()        else c    }}  fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(true) {            when(c) {                '\n', Char.MIN_VALUE -> return@buildString                else -> {                    append(c)                    c = readChar()                }            }        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() }","implementation,strings"
"fun main() {    val (n, q) = readLine()!!.split("" "").map { it.toInt() }    val s = readLine()!!.toCharArray()    fun abc(i: Int) = i in 0..n - 3 && s[i] == 'a' && s[i + 1] == 'b' && s[i + 2] == 'c'    var cnt = (0 until n).count { abc(it) }    repeat(q) {        val qs = readLine()!!.split("" "")        val i = qs[0].toInt() - 1        val old = (i - 2..i).count { abc(it) }        s[i] = qs[1][0]        val new = (i - 2..i).count { abc(it) }        cnt += new - old        println(cnt)    }}","implementation,strings"
"import kotlin.math.abs val br = System.`in`.bufferedReader()fun readInt() = br.readLine()!!.toInt()fun readInts() = br.readLine()!!.split("" "").map { it.toInt() }fun readLongs() = br.readLine()!!.split("" "").map { it.toLong() } tailrec fun gcd(a: Long, b: Long): Long = if (b == 0L) a else gcd(b, a % b)val mod = 1000000007Lfun add(a: Long, b: Long) = if (a + b >= mod) a + b - mod else a + b fun main() {    // maybe use dp    val sb = StringBuilder()    repeat(readInt()) {        var (n, a, b) = readInts()        if (a+b+2>n || abs(a-b)>1) sb.appendLine(-1)        else{            val inv = b > a            val ans = MutableList(n) { it+1 }            //println(ans)            repeat(minOf(a, b)){ind->                ans[ind*2+1] = ans[ind*2+2].also { ans[ind*2+2] = ans[ind*2+1] }            }            //println(ans)            if (abs(a-b)==1) ans[n-2] = ans[n-1].also { ans[n-1] = ans[n-2] }            //println(ans)            if (inv) for (i in 0 until n){                ans[i] = n+1-ans[i]            }            //println(ans)            sb.appendLine(ans.joinToString("" ""))        }    }    println(sb)}","constructive algorithms,greedy"
"import java.io.*import java.util.* val INPUT = System.`in`val OUTPUT = System.outval _reader = INPUT.bufferedReader()val _writer = PrintWriter(OUTPUT, false)var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!!fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = Array(n) { read() }fun readLines(n: Int) = Array(n) { readLn() }fun readInts(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = LongArray(n) { read().toLong() }inline fun output(block: PrintWriter.() -> Unit) {    _writer.apply(block).flush()}fun main() {    val run = Runnable { (1..readInt()).forEach { solve(it) } }    val thread = Thread(null, run, ""Solve"", 1L shl 26)    thread.start()} fun solve(tc: Int) {    val n = readInt()    val ar = readInts(2)    var ans = (1..n).toList().toIntArray()    if (ar[0] < ar[1]) {        val tmp = ans[0]; ans[0] = ans[1]; ans[1] = tmp    }     for (i in 1..n-2) {        val t = if (ans[i] >= ans[i-1]) 0 else 1        if (t==0) {            if (ar[t] > 0) {                ar[t]--                val tmp = ans[i]; ans[i] = ans[i+1]; ans[i+1] = tmp            } else {             }        }        if (t==1) {            if (ar[t] > 0) {                ar[t]--            } else {                val tmp = ans[i]; ans[i] = ans[i+1]; ans[i+1] = tmp            }        }    }     if (ar[0] == 0 && ar[1] == 0) {        println(ans.joinToString("" ""))    } else {        println(-1)    }} ","constructive algorithms,greedy"
"import java.io.PrintWriterimport java.util.*import kotlin.apply  fun main() {    val t = readInt()    output {        for (i in 0 until t) {            val (n, a, b) = readInts(3)            var l = 1            var r = n            var min = b            var max = a            if (a == 0 && b == 0) {                while (l <= r) {                    print(""$l "")                    l++                }             } else {                if (a + b > n - 2 || kotlin.math.abs(a - b) > 1) {                    println(-1)                } else {                    when {                        a == b -> {                            print(""$r "")                            r--                            print(""$l "")                            l++                            min--                            while (max > 1) {                                print(""$r "")                                r--                                print(""$l "")                                l++                                min--                                max--                            }                            print(""$r "")                            r--                            while (l <= r) {                                print(""$r "")                                r--                            }                        }                        a < b -> {                            print(""$r "")                            r--                            print(""$l "")                            l++                            min--                            while (min != 0) {                                print(""$r "")                                r--                                print(""$l "")                                l++                                min--                                max--                            }                            while (l <= r) {                                print(""$l "")                                l++                            }                        }                        else -> {                            print(""$l "")                            l++                            print(""$r "")                            r--                            max--                            while (min != 0) {                                print(""$l "")                                l++                                print(""$r "")                                r--                                min--                                max--                            }                             while (l <= r) {                                print(""$r "")                                r--                            }                        }                    }                    println("""")                }            }        }            }} @JvmFieldval INPUT = System.`in` @JvmFieldval OUTPUT = System.out @JvmFieldval _reader = INPUT.bufferedReader()fun readLn() = _reader.readLine()!! @JvmFieldvar _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()} fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readInts(n: Int) = List(n) { read().toInt() }fun readLong() = read().toLong()fun readLines(n: Int) = List(n) { readLn() }fun readLongs(n: Int) = List(n) { read().toLong() } @JvmFieldval _writer = PrintWriter(OUTPUT, false)inline fun output(block: PrintWriter.() -> Unit) {    _writer.apply(block).flush()} fun <T> Array<T>.swap(i: Int, j: Int) {    with(this[i]) {        this@swap[i] = this@swap[j]        this@swap[j] = this    }} ","constructive algorithms,greedy"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"", ""DEPRECATION"") import java.io.PrintWriterimport java.util.*import kotlin.math.*import kotlin.random.* @JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out @JvmField val reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun readLn() = reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readString() = readStrings(1)[0]fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int = 2) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int = 2) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmFieldval writer = PrintWriter(OUTPUT, true) // ---------------------------------------------------------------------------- class UnionFind {     private val parents = mutableMapOf<Int, Int>()    private val sizes = mutableMapOf<Int, Int>()     fun union(a: Int, b: Int) {        val fa = find(a)        val fb = find(b)        if (fa != fb) {            parents[fa] = fb            sizes[fb] = (sizes[fb] ?: 1) + (sizes[fa] ?: 1)        }    }     fun find(a: Int): Int {        fun getOrDefault(value: Int) = parents.getOrDefault(value, value)         var parent = getOrDefault(a)        while (parent != getOrDefault(parent)) {            parents[parent] = getOrDefault(getOrDefault(parent))            parent = parents[parent]!!        }        return parent    }     fun connected(a: Int, b: Int): Boolean {        return find(a) == find(b)    }     fun getSize(a: Int): Int {        return sizes[find(a)] ?: 1    }} class Trie() {     /** Initialize your data structure here. */    private val root = Node()     /** Inserts a word into the trie. */    fun insert(word: String) {        var node = root        for (char in word) {            if (!node.children.contains(char)) {                node.children[char] = Node()            }            node = node.children[char]!!        }        node.hasWord = true    }     /** Returns if the word is in the trie. */    fun search(word: String): Boolean {        return findNode(word)?.hasWord ?: false    }     /** Returns if there is any word in the trie that starts with the given prefix. */    fun startsWith(prefix: String): Boolean {        return findNode(prefix) != null    }     private fun findNode(prefix: String): Node? {        var node = root        for (char in prefix) {            node = node.children[char] ?: return null        }        return node    }     private class Node(        var hasWord: Boolean = false,        val children: MutableMap<Char, Node> = mutableMapOf<Char, Node>()    )} // f	f	e=f0gd8f d; 0 e<e'// query(index): sum[0, index]class BinaryIndexedTree {     private val bit: IntArray     constructor(n: Int) {        this.bit = IntArray(n + 1)    }     constructor(nums: IntArray) {        this.bit = IntArray(nums.size + 1)        val prefix = IntArray(bit.size)        for (i in 1 until nums.size + 1) {            prefix[i] = prefix[i - 1] + nums[i - 1]            bit[i] = prefix[i] - prefix[i - lowbit(i)]        }    }     fun query(index: Int): Int {        var result = 0        var i = index + 1        while (i > 0) {            result += bit[i]            i -= lowbit(i)        }        return result    }     fun update(index: Int, x: Int) {        val value = query(index) - query(index - 1)        add(index, x - value)    }     fun add(index: Int, x: Int) {        var i = index + 1        while (i < bit.size) {            bit[i] += x            i += lowbit(i)        }    }     private fun lowbit(x: Int): Int {        return x.and(-x)    }} // ---------------------------------------------------------------------------- private fun PrintWriter.printNums(nums: List<Int>) {    nums.forEach {        print(it)        print(' ')    }    println()} private fun fastPow(a: Long, exp: Long, mod: Long): Long {    var result = 1L % mod    var base = a % mod    var remain = exp    while (remain != 0L) {        if (remain % 2L == 1L) {            result = (result * base) % mod        }        base = (base * base) % mod        remain /= 2L    }    return result} private fun gcd(a: Int, b: Int): Int {    return if (b == 0) a else gcd(b, a % b)} private fun gcdL(a: Long, b: Long): Long {    return if (b == 0L) a else gcdL(b, a % b)} private fun lcm(a: Int, b: Int): Int {    return ((a.toLong() * b.toLong()) / gcd(a, b)).toInt()} private fun lcmL(a: Long, b: Long): Long {    return (a * b) / gcdL(a, b)} private fun wordToCharCount(word: String): IntArray {    val charCount = IntArray(26)    for (char in word) {        charCount[char.toIndex()]++    }    return charCount} private fun Char.toIndex(): Int {    return this.toInt() - 'a'.toInt()} private fun Char.toDigit(): Int {    return this.toInt() - '0'.toInt()} private fun Boolean.toYesNo(upper: Boolean = false): String {    val yesNo = if (this) ""Yes"" else ""No""    return if (upper) yesNo.toUpperCase() else yesNo} private val DIR = listOf(    listOf(0, 1), listOf(1, 0), listOf(0, -1), listOf(-1, 0)) private const val MOD = 998244353private const val MODL = 998244353L // ---------------------------------------------------------------------------- fun main() {    val go: Runnable = Runnable {        writer.solve()        writer.flush()    }    Thread(null, go, ""thread"", 1L.shl(28)).start()} private fun PrintWriter.solve() {    val t = readInt()    repeat(t) {        val (n, a, b) = readInts(3)        printNums(buildPermute(n, a, b))         // check(n, a, b)    }} private fun buildPermute(n: Int, a: Int, b: Int): List<Int> {    if (Math.abs(a - b) > 1 || a + b > n - 2) {        return listOf(-1)    }     var high = n    var low = 1    val result = ArrayDeque(listOf(low++, high--))    val count = Math.min(a, b)    repeat(count) {        result.addLast(low++)        result.addLast(high--)    }    when {        a > count -> {            while (high >= low) {                result.addLast(high--)            }        }        b > count -> {            while (low <= high) {                result.addFirst(low++)            }        }        else -> {            result.removeLast()            high++            while (low <= high) {                result.addLast(low++)            }        }    }    return result.toList()} private fun check(n: Int, a: Int, b: Int) {    val nums = buildPermute(n, a, b)    if (nums[0] == -1) {        return    }    var max = 0    var min = 0    for (i in 1 until n - 1) {        if (nums[i] < nums[i - 1] && nums[i] < nums[i + 1]) {            min++        } else if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {            max++        }    }    if (max == a && min == b) {        return    }    println(""Error: $n, $a, $b"")}","constructive algorithms,greedy"
"import java.io.BufferedReader val bin = System.`in`.bufferedReader()fun BufferedReader.readInt() = this.readLine()!!.toInt()fun BufferedReader.readInts() = this.readLine()!!.split(' ').map { it.toInt() }.toIntArray() fun main() {    repeat(bin.readInt()) {        bin.readInt()        val vs = bin.readInts()        val possible = vs.size % 2 == 0 || !vs.isStrictlyIncreasing()        println(if (possible) ""YES"" else ""NO"")    }} private fun IntArray.isStrictlyIncreasing(): Boolean {    for (i in 1 until size) {        if (this[i] <= this[i-1]) return false    }    return true} ",
"fun readLongs() = readLine()!!.split("" "").map({it.toLong()})fun readInts() = readLine()!!.split("" "").map({it.toInt()})fun readInt() = readLine()!!.toInt()fun readString() = readLine()!! fun bisquito(){  val n = readInt()  val a = readInts()//  println(""Set: $n: $a"")    if (n == 2){    println(""YES"")    return  }    var up = true  for (i in 0 until (n-1)){    if (a[i] >= a[i+1]){      up = false      break    }  }    if (up && (n % 2 == 1)){    println(""NO"")  } else {    println(""YES"")  }} fun main(args: Array<String>){  val t = readInt()  repeat(t){    bisquito()  }}",
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.* val scanner = FastScanner() // 2 - нечетных 1 - четное// 1 2 3 5 4 6 7 8 9fun solve() {    val n = scanner.nextInt()    val arr = IntArray(n) { scanner.nextInt() }    var fl = false    for (i in 1 until n) {        if (arr[i] <= arr[i - 1]) {            fl = true            break        }    }    if (n % 2 == 0 || fl) {        println(""YES"")        return    }    println(""NO"")} fun main() {    val t = scanner.nextInt()    for (i in 0 until t) {        solve()    }} class FastScanner {    val br = BufferedReader(InputStreamReader(System.`in`))    var st: StringTokenizer? = null     fun next(): String {        while (st?.hasMoreTokens() != true) {            st = StringTokenizer(br.readLine())        }        return st!!.nextToken()    }     fun nextInt() = next().toInt()     fun nextLong() = next().toLong()}",
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"", ""DEPRECATION"") import java.io.PrintWriterimport java.util.*import kotlin.math.*import kotlin.random.* @JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out @JvmField val reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun readLn() = reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readString() = readStrings(1)[0]fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmFieldval writer = PrintWriter(OUTPUT, true) // ---------------------------------------------------------------------------- class UnionFind {     private val parents = mutableMapOf<Int, Int>()    private val sizes = mutableMapOf<Int, Int>()     fun union(a: Int, b: Int) {        val fa = find(a)        val fb = find(b)        if (fa != fb) {            parents[fa] = fb            sizes[fb] = (sizes[fb] ?: 1) + (sizes[fa] ?: 1)        }    }     fun find(a: Int): Int {        fun getOrDefault(value: Int) = parents.getOrDefault(value, value)         var parent = getOrDefault(a)        while (parent != getOrDefault(parent)) {            parents[parent] = getOrDefault(getOrDefault(parent))            parent = parents[parent]!!        }        return parent    }     fun connected(a: Int, b: Int): Boolean {        return find(a) == find(b)    }     fun getSize(a: Int): Int {        return sizes[find(a)] ?: 1    }} class Trie() {     /** Initialize your data structure here. */    private val root = Node()     /** Inserts a word into the trie. */    fun insert(word: String) {        var node = root        for (char in word) {            if (!node.children.contains(char)) {                node.children[char] = Node()            }            node = node.children[char]!!        }        node.hasWord = true    }     /** Returns if the word is in the trie. */    fun search(word: String): Boolean {        return findNode(word)?.hasWord ?: false    }     /** Returns if there is any word in the trie that starts with the given prefix. */    fun startsWith(prefix: String): Boolean {        return findNode(prefix) != null    }     private fun findNode(prefix: String): Node? {        var node = root        for (char in prefix) {            node = node.children[char] ?: return null        }        return node    }     private class Node(        var hasWord: Boolean = false,        val children: MutableMap<Char, Node> = mutableMapOf<Char, Node>()    )} // f	f	e=f0gd8f d; 0 e<e'// query(index): sum[0, index]class BinaryIndexedTree {     private val bit: IntArray     constructor(n: Int) {        this.bit = IntArray(n + 1)    }     constructor(nums: IntArray) {        this.bit = IntArray(nums.size + 1)        val prefix = IntArray(bit.size)        for (i in 1 until nums.size + 1) {            prefix[i] = prefix[i - 1] + nums[i - 1]            bit[i] = prefix[i] - prefix[i - lowbit(i)]        }    }     fun query(index: Int): Int {        var result = 0        var i = index + 1        while (i > 0) {            result += bit[i]            i -= lowbit(i)        }        return result    }     fun update(index: Int, x: Int) {        val value = query(index) - query(index - 1)        add(index, x - value)    }     fun add(index: Int, x: Int) {        var i = index + 1        while (i < bit.size) {            bit[i] += x            i += lowbit(i)        }    }     private fun lowbit(x: Int): Int {        return x.and(-x)    }} // ---------------------------------------------------------------------------- private fun PrintWriter.printNums(nums: List<Int>) {    nums.forEach {        print(it)        print(' ')    }    println()} private fun fastPow(a: Long, exp: Long, mod: Long): Long {    var result = 1L % mod    var base = a % mod    var remain = exp    while (remain != 0L) {        if (remain % 2L == 1L) {            result = (result * base) % mod        }        base = (base * base) % mod        remain /= 2L    }    return result}  private fun gcd(a: Int, b: Int): Int {    return if (b == 0) a else gcd(b, a % b)} private fun lcm(a: Int, b: Int): Int {    return ((a.toLong() * b.toLong()) / gcd(a, b)).toInt()} private fun wordToCharCount(word: String): IntArray {    val charCount = IntArray(26)    for (char in word) {        charCount[char.toIndex()]++    }    return charCount} private fun Char.toIndex(): Int {    return this.toInt() - 'a'.toInt()} private fun Char.toDigit(): Int {    return this.toInt() - '0'.toInt()} private val DIR = listOf(    listOf(0, 1), listOf(1, 0), listOf(0, -1), listOf(-1, 0)) private const val MOD = 998244353private const val MODL = 998244353L // ---------------------------------------------------------------------------- fun main() {    val go: Runnable = Runnable {        writer.solve()        writer.flush()    }    Thread(null, go, ""thread"", 1L.shl(28)).start()} private fun PrintWriter.solve() {    val t = readInt()    repeat(t) {        val n = readInt()        val nums = readInts(n)        println(if (xorLis(nums)) ""YES"" else ""NO"")    }} private fun xorLis(nums: List<Int>): Boolean {    val n = nums.size    if (n % 2 == 0) {        return true    }    for (i in 1 until n) {        if (nums[i] <= nums[i - 1]) {            return true        }    }    return false}",
"fun main() = repeat(readLine()!!.toInt()) {    readLine()    println((readLine()!! zip readLine()!!).firstOrNull { (a, b) -> a == '1' && b == '1' }?.let { ""NO"" } ?: ""YES"")}","brute force,dfs and similar,dp,implementation"
"fun main() = repeat(readLine()!!.toInt()) {    readLine()    val s1 = readLine()!!    val s2 = readLine()!!    println(s1.asSequence().filterIndexed { i, c -> s2[i] == '1' && c == '1' }.firstOrNull()?.let { ""NO"" } ?: ""YES"")}","brute force,dfs and similar,dp,implementation"
"fun main() = List(readLine()!!.toInt()) {    readLine()    val s1 = readLine()!!    val s2 = readLine()!!    (s1 zip s2).firstOrNull { it.first == '1' && it.second == '1' }?.let { ""NO"" } ?: ""YES""}.joinToString(""\n"").let(::println)","brute force,dfs and similar,dp,implementation"
"fun main() = repeat(readLine()!!.toInt()) {    val n = readLine()!!.toInt() - 1    val a = readLine()!!    val b = readLine()!!    var result = true    for (i in 1 until n) if (a[i] == '1' && b[i] == '1') { result = false;break }    println( if (result) ""YES"" else ""NO"")}","brute force,dfs and similar,dp,implementation"
"import java.util.*   fun main(args: Array<String>): Unit {    with(Scanner(System.`in`)) {        val t = nextInt()//    val t = 1        repeat(t) {//            val n = nextInt()            val s = next()            val res = listOf(""00"", ""25"", ""50"", ""75"")                .map { s.cost(it) }                .filter { it >= 0 }                .min()!!            println(res)        }    }} private fun String.cost(it: String): Int {    val ii = lastIndexOf(it[1])    if (ii <= 0) return -1    val ij = lastIndexOf(it[0], ii - 1)    if (ij < 0) return -1    return length - ij - 2}","dfs and similar,dp,greedy,math,math"
"import kotlin.math.min fun main() {    val t = readLine()!!.toInt()    for (i in 1..t) {        var n = readLine()!!.toLong()        checkNumber(n)    }} fun checkNumber(num: Long) {    var cnt = 20    val str=num.toString()    val lastIndex=str.lastIndex    for(i in lastIndex downTo 1){        val diff=lastIndex-i        for(j in i-1 downTo 0){            if(str[i]=='0' && (str[j]=='0' || str[j]=='5')){                cnt = min(cnt,(i-j-1)+diff)                break            }else if(str[i]=='5'&&(str[j]=='2'||str[j]=='7')){                cnt=min(cnt,(i-j-1)+diff)                break            }        }    }    println(cnt)}","dfs and similar,dp,greedy,math,math"
"fun main(){    repeat(readLine()!!.toInt()){        solve()    }}fun solve(){    var s  = readLine()!!.toString()    var index = s.lastIndexOf('5')    var ans=100     var found =false    var t=0    for(i in index-1 downTo 0){        if(s[i]=='7' || s[i]=='2'){            found=true            break        }        t++;    }    if(found){        ans = minOf(ans,s.length-(index-t+1))    }     index = s.lastIndexOf('0')    found=false    t=0    for(i in index-1 downTo 0){        if(s[i] == '0' || s[i]=='5'){            found=true            break;        }        t++    }    ans= minOf(ans,s.length-(index-t+1))    println(ans) }  ","dfs and similar,dp,greedy,math,math"
"import java.io.* fun main() {    val br = BufferedReader(InputStreamReader(System.`in`))    val bw = BufferedWriter(OutputStreamWriter(System.out))     repeat(br.readLine().toInt()) {        val input = br.readLine()        val zeroL = input.lastIndexOf(""0"")        val fiveL = input.lastIndexOf(""5"")         var zeroS = -1        var fiveS = -1        if (zeroL != -1) {            for (i in zeroL - 1 downTo 0) {                if (input[i] == '0' || input[i] == '5') {                    zeroS = i                    break                }            }        }        if (fiveL != -1) {            for (i in fiveL - 1 downTo 0) {                if (input[i] == '2' || input[i] == '7') {                    fiveS = i                    break                }            }        }         val f = input.length - zeroS - 2        val s = input.length - fiveS - 2        bw.write(""${minOf(f, s)}"")        bw.newLine()    }     bw.flush()    bw.close()}","dfs and similar,dp,greedy,math,math"
"import kotlin.math.max fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()        val ay = listOf(0) + readLine()!!.split("" "").map { it.toInt() }        val ofColor = Array(n + 1) { mutableListOf<Int>() }        for (j in n downTo 1) {            ofColor[ay[j]].add(j)        }        val dp = Array(n + 2) { IntArray(n + 2) }        for (l in n downTo 1) {            for (r in l + 1..n) {                dp[l][r] = maxOf(dp[l][r], dp[l + 1][r], dp[l][r - 1])                if (ay[l] == ay[r]) {                    dp[l][r] = max(dp[l][r], 1 + dp[l + 1][r - 1])                }                for (x in ofColor[ay[r]]) {                    if (x <= r) {                        break                    }                    dp[l][x] = max(dp[l][x], dp[l][r] + dp[r][x])                }            }        }        println((n - 1) - dp[1][n])    }}","dp,greedy"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"", ""DEPRECATION"") import java.io.PrintWriterimport java.util.StringTokenizerimport kotlin.math.*import kotlin.random.* @JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out @JvmField val reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun readLn() = reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readString() = readStrings(1)[0]fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmFieldval writer = PrintWriter(OUTPUT, true) fun printNums(nums: List<Int>) {    nums.forEach {        print(it)        print(' ')    }    println()} private fun wordToCharCount(word: String): IntArray {    val charCount = IntArray(26)    for (char in word) {        charCount[char.toIndex()]++    }    return charCount} private fun Char.toIndex(): Int {    return this.toInt() - 'a'.toInt()} private fun Char.toDigit(): Int {    return this.toInt() - '0'.toInt()} private val DIR = listOf(    listOf(0, 1), listOf(1, 0), listOf(0, -1), listOf(-1, 0)) private const val MOD = 998244353private const val MODL = 998244353L // ---------------------------------------------------------------------------- fun main() {    writer.solve()    writer.flush()} fun PrintWriter.solve() {    val t = readInt()    repeat(t) {        val n = readInt()        val nums = readInts(n)        println(paint(nums))    }} private fun paint(nums: List<Int>): Int {    val n = nums.size     val indexes = IntArray(n + 1) { n }    val nexts = IntArray(n)    for (i in n - 1 downTo 0) {        nexts[i] = indexes[nums[i]]        indexes[nums[i]] = i    }    // println(nums.toList())    // println(nexts.toList())     val dp = Array(n) { IntArray(n) { Int.MAX_VALUE / 2 } }    for (len in 0 until n) {        for (i in 0 until n - len) {            val j = i + len            if (i == j) {                dp[i][j] = 0                continue            }            dp[i][j] = Math.min(dp[i + 1][j], dp[i][j - 1]) + 1            var k = nexts[i]            while (k <= j) {                dp[i][j] = Math.min(dp[i][j], dp[i][k - 1] + dp[k][j])                k = nexts[k]            }        }    }    return dp[0][n - 1]}","dp,greedy"
"class Attack(val a: Int, val b: Int, val i: Int) fun main() {	val (n, m) = readLine()!!.split("" "").map { it.toInt() }	val ev = ArrayList<Attack>() 	for (i in 0 until n) {		val k = readLine()!!.toInt()		val a = readLine()!!.split("" "").map { it.toInt() }		val b = readLine()!!.split("" "").map { it.toInt() }		for (j in 0 until k) {			ev.add(Attack(a[j], b[j], i))		}	}	ev.sortWith(compareBy({ -it.b }, { it.i }))		val INF = 1e18.toLong()	val mx = m + n + 1	val f = LongArray(mx) { -INF }		fun update(pos: Int, x: Long) {		var i = pos		while (i < mx) {			f[i] = maxOf(f[i], x)			i = i or (i + 1)		}	}		fun query(pos: Int) : Long {		var res = -INF		var i = pos		while (i >= 0) {			res = maxOf(res, f[i])			i = (i and (i + 1)) - 1		}		return res	}		update(m - 1, 0L)	for (it in ev) {		val dp = query(it.i + it.b - 1) + it.a		update(it.i + it.b, dp)	}	println(query(mx - 1))}","*special,data structures,dp"
"fun main() {    fun readInt() = readLine()!!.toInt()    fun readInts() = readLine()!!.split(' ').map { it.toInt() }.toIntArray()    val (n, m) = readInts()    val g = Array(m + 1) { mutableListOf<Pair<Int, Int>>()}    for (i in 1..n) {        val k = readInt()        val a = readInts()        val b = readInts()        for (j in 0 until k)            g[b[j]].add(Pair(i, a[j]))    }    val inf = 300000000000000L    val bit = LongArray(m + n + 2){-inf}    var x = m + 1    while (x <= m + n + 1) {        bit[x] = 0L        x += x and -x    }    var ans = 0L    for (b in m downTo 0)        for ((index, a) in g[b]) {            var dp = -inf            var x = index + b            while (x > 0) {                dp = maxOf(dp, bit[x])                x -= x and -x            }            dp += a            //println(""$index $a $b $dp"")            ans = maxOf(ans, dp)            x = index + b + 1            while (x <= m + n + 1) {                bit[x] = maxOf(bit[x], dp)                x += x and -x            }        }    println(ans)}","*special,data structures,dp"
"fun main() {    fun readInt() = readLine()!!.toInt()    fun readInts() = readLine()!!.split(' ').map { it.toInt() }.toIntArray()    val (n, m) = readInts()    val g = Array(m + 1) { mutableListOf<Pair<Int, Int>>()}    for (i in 1..n) {        val k = readInt()        val a = readInts()        val b = readInts()        for (j in 0 until k)            g[b[j]].add(Pair(i, a[j]))    }    val inf = 300000000000000L    val bit = LongArray(m + n + 2){-inf}    var x = m + 1    while (x <= m + n + 1) {        bit[x] = 0L        x += x and -x    }    var ans = 0L    for (b in m downTo 0)        for ((index, a) in g[b]) {            var dp = -inf            var x = index + b            while (x > 0) {                dp = maxOf(dp, bit[x])                x -= x and -x            }            dp += a            //println(""$index $a $b $dp"")            ans = maxOf(ans, dp)            x = index + b + 1            while (x <= m + n + 1) {                bit[x] = maxOf(bit[x], dp)                x += x and -x            }        }    println(ans)}","*special,data structures,dp"
"fun main() {    fun readInt() = readLine()!!.toInt()    fun readInts() = readLine()!!.split(' ').map { it.toInt() }.toIntArray()    val (n, m) = readInts()    val g = Array(m + 1) { mutableListOf<Pair<Int, Int>>()}    for (i in 1..n) {        val k = readInt()        val a = readInts()        val b = readInts()        for (j in 0 until k)            g[b[j]].add(Pair(i, a[j]))    }    val inf = 300000000000000L    val bit = LongArray(m + n + 2){-inf}    var x = m + 1    while (x <= m + n + 1) {        bit[x] = 0L        x += x and -x    }    var ans = 0L    for (b in m downTo 0)        for ((index, a) in g[b]) {            var dp = -inf            var x = index + b            while (x > 0) {                dp = maxOf(dp, bit[x])                x -= x and -x            }            dp += a            //println(""$index $a $b $dp"")            ans = maxOf(ans, dp)            x = index + b + 1            while (x <= m + n + 1) {                bit[x] = maxOf(bit[x], dp)                x += x and -x            }        }    println(ans)}","*special,data structures,dp"
"fun main() {    val out = StringBuilder()    repeat(readLine()!!.toInt()) {        var (s, n) = readLine()!!.split("" "").map { it.toLong() }        val answer = mutableListOf<Long>()        while (n > 0L) {            n--            if (n == 0L) {                answer.add(s)            } else {                var rem = s - n                var x = 1L                while (rem >= 10L) {                    rem /= 10L                    x *= 10L                }                answer.add(x)                s -= x            }        }        out.appendln(answer.joinToString("" ""))    }    print(out)}","constructive algorithms,greedy,implementation,math"
"import java.util.*import kotlin.math.*import kotlin.system.* private fun readInt() = readLine()!!.toInt()private fun readLong() = readLine()!!.toLong()private fun readIntList() = readLine()!!.split("" "").map { it.toInt() }private fun readLongList() = readLine()!!.split("" "").map { it.toLong() } fun main() {	val tc = readInt()	repeat(tc) {		val (s, n) = readIntList()		val res = mutableListOf<Int>()		var x = s		var c = 1		while (x > 0) {			for (i in 0 until x % 10) {				res.add(c)			}			x /= 10			c *= 10		}		res.sort()		while (res.size < n) {			for (i in 0 until res.size) {				if (res[i] == 1) continue				repeat(10) {					res.add(res[i] / 10);				}				res.removeAt(i)				break			}			res.sort()		}		for (i in 0 until (n - 1)) {			print(res[i])			print("" "")		}		var sum = 0		for (i in (n - 1) until res.size) {			sum += res[i]		}		println(sum)	}}","constructive algorithms,greedy,implementation,math"
"import java.io.BufferedReaderimport java.io.PrintWriterimport java.util.* val bin = System.`in`.bufferedReader()fun BufferedReader.readInt() = this.readLine()!!.toInt()fun BufferedReader.readInts() = this.readLine()!!.split(' ').map { it.toInt() }.toIntArray() fun main() {    repeat(bin.readInt()) {        val (s, n) = bin.readInts()        val res = solve(s, n)        println(res.joinToString(separator="" ""))    }} fun solve(s_in: Int, n: Int): List<Int> {    var pow10 = 1    val res = PriorityQueue<Int>()    var s = s_in     while (s > 0) {        if (res.size == n-1) {            res.add(s * pow10)            return res.toList()        } else if (s % 10 != 0) {            res.add(pow10)            s--        } else {            pow10 *= 10            s /= 10        }    }     var ones = 0    while (res.size + ones < n) {        val next = res.poll()        if (next == 1) {            ones++        } else {            for (d in 0..9) {                if (res.size + ones + 1 == n) {                    res.add((10 - d) * (next/10))                    repeat(ones) { res.add(1) }                    return res.toList()                }                res.add(next/10)            }        }    }     error(""Huh?"")}","constructive algorithms,greedy,implementation,math"
"import java.io.PrintWriterimport java.util.*import kotlin.math.* fun PrintWriter.solve() {    val numCases = nextInt()    case@ for (_i in 0 until numCases) {        val s = nextInt()        val n = nextInt()        val ans = mutableListOf<Int>()        val pow10 = IntArray(10) { 1 }        for (i in 1 until 10) {            pow10[i] = pow10[i - 1] * 10        }        fun dfs(v: Int, i: Int) {            if (i == n - 1) {                ans.add(v)                return            }            val t = v.toString()            for (d in t.length - 1 downTo 0) {                val w = v - pow10[d]                if (w < n - i - 1) continue                dfs(w, i + 1)                if (ans.isNotEmpty()) {                    ans.add(pow10[d])                    return                }            }        }        dfs(s, 0)        println(ans.joinToString("" ""))    }} fun main() {    Thread(null, {        val writer = PrintWriter(System.out, false)        writer.solve()        writer.flush()    }, ""solve"", 1.shl(26))        .apply { setUncaughtExceptionHandler { _, e -> e.printStackTrace(); kotlin.system.exitProcess(1) } }        .apply { start() }.join()} // region Scannerprivate var st = StringTokenizer("""")private val br = System.`in`.bufferedReader() fun next(): String {    while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())    return st.nextToken()} fun nextInt() = next().toInt()fun nextLong() = next().toLong()fun nextLine() = br.readLine()fun nextDouble() = next().toDouble()// endregion","constructive algorithms,greedy,implementation,math"
"private fun solve() {	readLn()	val a = readLn()	val b = readLn()	var ans = 0	var have1 = false	var want1 = false	for (i in a.indices) {		val c = (a[i] + """" + b[i])		if (""0"" in c && ""1"" in c) {			ans += 2			have1 = false			want1 = false			continue		}		if (""1"" !in c) { // 00			ans += 1			if (have1) {				ans++			} else {				want1 = true			}			have1 = false			continue		}		if (want1) {			ans++			want1 = false			continue		}		have1 = true	}	println(ans)} fun main() = repeat(readInt()) { solve() } private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","bitmasks,constructive algorithms,dp,greedy"
"fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()        val s1 = readLine()!!        val s2 = readLine()!!        val s = s1.map { it - '0' }.zip(s2.map { it - '0' }).map { (x, y) -> x + y }        var answer = 0        val isTaken = BooleanArray(n)        for (j in 0 until n) {            if (s[j] == 0) {                answer++            } else if (s[j] == 2) {                if (j > 0 && s[j - 1] == 0 && !isTaken[j - 1]) {                    answer++                } else if (j < n - 1 && s[j + 1] == 0) {                    answer++                    isTaken[j + 1] = true                }            } else {                answer += 2            }        }        println(answer)    }}","bitmasks,constructive algorithms,dp,greedy"
"import java.util.*import kotlin.math.*import kotlin.system.* private fun readInt() = readLine()!!.toInt()private fun readLong() = readLine()!!.toLong()private fun readIntList() = readLine()!!.split("" "").map { it.toInt() }private fun readLongList() = readLine()!!.split("" "").map { it.toLong() } fun mex(a: Int, b: Int) : Int {	var res = 0	while (res == a || res == b) res++	return res}fun main() {	val tc = readInt()	repeat (tc) {		val n = readInt()		val str1 = readLine()!!		var str2 = readLine()!!		val a = MutableList<Int>(n) { mex(str1[it].toString().toInt(), str2[it].toString().toInt()) }				var res = 0		for (i in 0 until n) res += a[i]				run {			var i = 1			while (i < n) {				if (a[i] == 0 && a[i - 1] == 1) {					res++					i++				} else if (a[i] == 1 && a[i - 1] == 0) {					res++					i++				}				i++			}		}		println(res)	}}","bitmasks,constructive algorithms,dp,greedy"
"import java.io.* fun main() {    val br = BufferedReader(InputStreamReader(System.`in`))    val bw = BufferedWriter(OutputStreamWriter(System.out))     repeat(br.readLine().toInt()) {        val n = br.readLine().toInt()        val f = br.readLine()        val s = br.readLine()         var cnt = 0        var i = 0        while (i < n) {            if (f[i] == '0' && s[i] == '0') {                if (i + 1 < n && f[i + 1] == '1' && s[i + 1] == '1') {                    cnt += 2                    i++                } else cnt++            } else if ((f[i] - '0') + (s[i] - '0') == 1) {                cnt += 2            } else {                if (i + 1 < n && f[i + 1] == '0' && s[i + 1] == '0') {                    cnt += 2                    i++                }            }            i++        }         bw.write(""$cnt"")        bw.newLine()    }     bw.flush()    bw.close()}","bitmasks,constructive algorithms,dp,greedy"
"import java.util.*import kotlin.math.maximport kotlin.math.min fun main() {    val (n, q) = readLine()!!.split("" "").map { it.toInt() }    val tokenizerA = StringTokenizer(readLine()!!)    val tokenizerB = StringTokenizer(readLine()!!)    val sds = LongArray(n + 1)    val minSegTree = MinSegmentTree(1, n)    val maxSegTree = MaxSegmentTree(1, n)    for (j in 1..n) {        sds[j] = sds[j - 1] + tokenizerB.nextToken().toLong() - tokenizerA.nextToken().toLong()        minSegTree[j] = sds[j]        maxSegTree[j] = sds[j]    }    val out = StringBuilder()    repeat(q) {        val (l, r) = readLine()!!.split("" "").map { it.toInt() }        if (sds[l - 1] != sds[r] || minSegTree[l, r] < sds[l - 1]) {            out.appendln(-1)        } else {            out.appendln(maxSegTree[l, r] - sds[l - 1])        }    }    print(out)} class MinSegmentTree(val treeFrom: Int, treeTo: Int) {    val value: LongArray    val length: Int     init {        var e = 0        while (1 shl e < treeTo - treeFrom + 1) {            e++        }        value = LongArray(1 shl (e + 1))        length = 1 shl e    }     operator fun set(index: Int, delta: Long) {        var node = index - treeFrom + length        value[node] = delta        node = node shr 1        while (node > 0) {            value[node] = min(value[node shl 1], value[(node shl 1) + 1])            node = node shr 1        }    }     operator fun get(index: Int) = value[index - treeFrom + length]     operator fun get(fromIndex: Int, toIndex: Int): Long {        if (toIndex < fromIndex) {            return Long.MAX_VALUE        }        var from = fromIndex + length - treeFrom        var to = toIndex + length - treeFrom + 1        var res: Long = Long.MAX_VALUE        while (from + (from and -from) <= to) {            res = min(res, value[from / (from and -from)])            from += from and -from        }        while (to - (to and -to) >= from) {            res = min(res, value[(to - (to and -to)) / (to and -to)])            to -= to and -to        }        return res    }} class MaxSegmentTree(val treeFrom: Int, treeTo: Int) {    val value: LongArray    val length: Int     init {        var e = 0        while (1 shl e < treeTo - treeFrom + 1) {            e++        }        value = LongArray(1 shl (e + 1))        length = 1 shl e    }     operator fun set(index: Int, delta: Long) {        var node = index - treeFrom + length        value[node] = delta        node = node shr 1        while (node > 0) {            value[node] = max(value[node shl 1], value[(node shl 1) + 1])            node = node shr 1        }    }     operator fun get(index: Int) = value[index - treeFrom + length]     operator fun get(fromIndex: Int, toIndex: Int): Long {        if (toIndex < fromIndex) {            return Long.MIN_VALUE        }        var from = fromIndex + length - treeFrom        var to = toIndex + length - treeFrom + 1        var res: Long = Long.MIN_VALUE        while (from + (from and -from) <= to) {            res = max(res, value[from / (from and -from)])            from += from and -from        }        while (to - (to and -to) >= from) {            res = max(res, value[(to - (to and -to)) / (to and -to)])            to -= to and -to        }        return res    }}","data structures,dp,greedy"
"/** * Accomplished using the EduTools plugin by JetBrains https://plugins.jetbrains.com/plugin/10081-edutools */import java.io.BufferedInputStreamimport java.io.BufferedReaderimport java.io.InputStreamReaderimport java.io.PrintWriterimport kotlin.math.minimport kotlin.math.maximport kotlin.reflect.KProperty0import kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){	val t = measureTimeMillis(){		f()	}	println(t)} class FastScanner {	private val BS = 1 shl 16	private val NC = 0.toChar()	private val buf = ByteArray(BS)	private var bId = 0	private var size = 0	private var c = NC	private var `in`: BufferedInputStream? = null 	constructor() {		`in` = BufferedInputStream(System.`in`, BS)	} 	private val char: Char		get() {			while (bId == size) {				size = try {					`in`!!.read(buf)				} catch (e: Exception) {					return NC				}				if (size == -1) return NC				bId = 0			}			return buf[bId++].toChar()		} 	fun nextInt(): Int {		var neg = false		if (c == NC) c = char		while (c < '0' || c > '9') {			if (c == '-') neg = true			c = char		}		var res = 0		while (c >= '0' && c <= '9') {			res = (res shl 3) + (res shl 1) + (c - '0')			c = char		}		return if (neg) -res else res	}	fun nextLong(): Long {		var neg = false		if (c == NC) c = char		while (c < '0' || c > '9') {			if (c == '-') neg = true			c = char		}		var res = 0L		while (c >= '0' && c <= '9') {			res = (res shl 3) + (res shl 1) + (c - '0')			c = char		}		return if (neg) -res else res	}	fun nextString():String{		if (c == NC) c = char		val ret = StringBuilder()		while (true){			c = char			if(!isWhitespace(c)){ break}		}		ret.appendCodePoint(c.toInt())		while (true){			c = char			if(isWhitespace(c)){ break}			ret.appendCodePoint(c.toInt()); 		}		return ret.toString()	}	fun isWhitespace(c:Char):Boolean{		return c == ' ' || c == '\n' || c == '\r' || c == '\t'	}}class reading{	companion object{		var jin = FastScanner()		var pw = PrintWriter(System.out)	}}fun put(aa:Any){ reading.pw.println(aa)}fun done(){ reading.pw.close() } fun getint():Int{ return reading.jin.nextInt() }fun getlong():Long{ return reading.jin.nextLong() }fun getline(n:Int):List<Int>{ return (1..n).map{reading.jin.nextInt()} }fun getlineL(n:Int):List<Long>{return (1..n).map{reading.jin.nextLong()} }fun getstr():String{ return reading.jin.nextString() }fun MutableList<Int>.streamint(n:Int){ repeat(n){this.add(getint())}}fun MutableList<Long>.streamlong(n:Int){ repeat(n){this.add(getlong())}}inline fun cases(ask:()->Unit){ val t = getint();repeat(t){ ask() }} val List<Char>.ret:String	get() = this.joinToString("""")infix fun Any.dei(a:Any){	//does not stand for anything it is just easy to type	var str = """"	if(this is String){ str = this	}else if(this is Int){ str = this.toString()	}else if(this is Long){ str = this.toString()	}	if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")	}else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")	}else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")	}else{ println(""$str : $a"")	}}val just = "" "" // usage: just dei x , where x is the debug variablefun prefixSumL(arr:List<Long>):MutableList<Long>{	val ret = mutableListOf<Long>() 	var previous = 0L	for(a in arr){		previous += a		ret.add(previous)	}	return ret}class rMINq(val arr:List<Long>){	val n = arr.size	val store = mutableListOf<LongArray>()	fun preprocess(){		var s = 1		var olds = 0		while(s <= n){			if(s == 1){				val new = arr.toLongArray()				store.add(new)			}else{				val size = n-s+1				val old = store.last()				val new = LongArray(size)				for(i in 0 until size){					new[i] = minOf(old[i],old[i+olds])				}				store.add(new)			}			olds = s			s = s shl 1		}	}	fun minQuery(l:Int,r:Int):Long{		val d = r - l + 1		val i = 31 - d.countLeadingZeroBits()		val s = 1 shl i		val a1 = l		val a2 = r - s + 1		val ret1 = store[i][a1]		val ret2 = store[i][a2]		return minOf(ret1,ret2)	}	init {		preprocess()	}}class rMAXq(val arr:List<Long>){	val n = arr.size	val store = mutableListOf<LongArray>()	fun preprocess(){		var s = 1		var olds = 0		while(s <= n){			if(s == 1){				val new = arr.toLongArray()				store.add(new)			}else{				val size = n-s+1				val old = store.last()				val new = LongArray(size)				for(i in 0 until size){					new[i] = maxOf(old[i],old[i+olds])				}				store.add(new)			}			olds = s			s = s shl 1		}	}	fun maxQuery(l:Int,r:Int):Long{		val d = r - l + 1		val i = 31 - d.countLeadingZeroBits()		val s = 1 shl i		val a1 = l		val a2 = r - s + 1		val ret1 = store[i][a1]		val ret2 = store[i][a2]		return maxOf(ret1,ret2)	}	init {		preprocess()	}}  fun main() {	val n = getint()	val q = getint()	 val A = getlineL(n)	val B = getlineL(n) 	val score = MutableList(n){0L}	for(i in 0 until n){		score[i] = B[i] - A[i]	}//	just dei score	val Asum = prefixSumL(score) 	val MIN = rMINq(Asum)	val MAX = rMAXq(Asum) 	repeat(q) {		val a = getint() - 1		val b = getint() - 1		val presum = Asum.getOrNull(a - 1) ?: 0L		val min = MIN.minQuery(a, b)		if(min < presum) {			put(-1)		} else if(Asum[b] != presum){			put(-1)		}else{			val max = MAX.maxQuery(a,b)			put(max - presum)		}	}	done()       // Write your solution here}","data structures,dp,greedy"
"import java.io.BufferedReaderimport kotlin.math.absoluteValue fun main() {    val br = System.`in`.bufferedReader()    val sb = StringBuilder()    val n = br.readInt()    val q = br.readInt()    val a = IntArray(n) { -br.readInt() }    repeat(n) { idx ->        a[idx] += br.readInt()    }    val prefix = LongArray(n + 1)    val suffix = LongArray(n + 1)    for (x in 1..n) {        suffix[n - x] = suffix[n - x + 1] + a[n - x]        prefix[x] = prefix[x - 1] + a[x - 1]    }//    val sparseAbs = SparseMaxAbsTable(a)    val sparsePrefixMin = SparseMinTable(prefix)    val sparsePrefixMax = SparseMaxTable(prefix) //    val sparseSuffix = SparseMaxTable(suffix)    repeat(q) {        val l = br.readInt() - 1        val r = br.readInt() - 1        val ans = if (prefix[r + 1] != prefix[l]) {            -1        } else if (prefix[sparsePrefixMin.getMinRange(l + 1, r + 1)] - prefix[l] < 0) {            -1        } else {            prefix[sparsePrefixMax.getMaxRange(l + 1, r + 1)] - prefix[l]        }        sb.appendLine(ans)    }     print(sb)} private class SparseMinTable(val nums: LongArray) {    val n = nums.size    val table = Array(        Integer.numberOfTrailingZeros(Integer.highestOneBit((n shl 2) - 1))    ) { IntArray(n) }     init {        for (x in 0 until n) {            table[0][x] = x        }        for (bit in 1 until table.size) {            val pow = 1 shl bit            for (x in 0..n - pow) {                val a = table[bit - 1][x]                val b = table[bit - 1][x + (pow shr 1)]                if (nums[a] <= nums[b]) {                    table[bit][x] = a                } else {                    table[bit][x] = b                }            }        }    }     fun getMinRange(start: Int, end: Int): Int {        return if (start <= end) {            val dif = end - start + 1            val high = Integer.highestOneBit(dif)            val bit = Integer.numberOfTrailingZeros(high)            if (high == dif) {                table[bit][start]            } else {                val a = table[bit][start]                val b = table[bit][end - high + 1]                if (nums[a] <= nums[b]) {                    a                } else {                    b                }            }        } else {            -1        }    }} private class SparseMaxTable(val nums: LongArray) {    val n = nums.size    val table = Array(        Integer.numberOfTrailingZeros(Integer.highestOneBit((n shl 2) - 1))    ) { IntArray(n) }     init {        for (x in 0 until n) {            table[0][x] = x        }        for (bit in 1 until table.size) {            val pow = 1 shl bit            for (x in 0..n - pow) {                val a = table[bit - 1][x]                val b = table[bit - 1][x + (pow shr 1)]                if (nums[a] >= nums[b]) {                    table[bit][x] = a                } else {                    table[bit][x] = b                }            }        }    }     fun getMaxRange(start: Int, end: Int): Int {        return if (start <= end) {            val dif = end - start + 1            val high = Integer.highestOneBit(dif)            val bit = Integer.numberOfTrailingZeros(high)            if (high == dif) {                table[bit][start]            } else {                val a = table[bit][start]                val b = table[bit][end - high + 1]                if (nums[a] >= nums[b]) {                    a                } else {                    b                }            }        } else {            -1        }    }} private class SparseMaxAbsTable(val nums: IntArray) {    val n = nums.size    val table = Array(        Integer.numberOfTrailingZeros(Integer.highestOneBit((n shl 2) - 1))    ) { IntArray(n) }     init {        for (x in 0 until n) {            table[0][x] = x        }        for (bit in 1 until table.size) {            val pow = 1 shl bit            for (x in 0..n - pow) {                val a = table[bit - 1][x]                val b = table[bit - 1][x + (pow shr 1)]                if (nums[a].absoluteValue >= nums[b].absoluteValue) {                    table[bit][x] = a                } else {                    table[bit][x] = b                }            }        }    }     fun getMaxRange(start: Int, end: Int): Int {        return if (start <= end) {            val dif = end - start + 1            val high = Integer.highestOneBit(dif)            val bit = Integer.numberOfTrailingZeros(high)            if (high == dif) {                table[bit][start]            } else {                val a = table[bit][start]                val b = table[bit][end - high + 1]                if (nums[a].absoluteValue >= nums[b].absoluteValue) {                    a                } else {                    b                }            }        } else {            -1        }    }} private const val SPACE_INT = ' '.toInt()private const val ZERO_INT = '0'.toInt()private const val NL_INT = '\n'.toInt() private fun BufferedReader.readInt(): Int {    var ret = read()    while (ret <= SPACE_INT) {        ret = read()    }    val neg = ret == '-'.toInt()    if (neg) {        ret = read()    }    ret -= ZERO_INT    var read = read()    while (read >= ZERO_INT) {        ret *= 10        ret += read - ZERO_INT        read = read()    }     while (read <= SPACE_INT && read != -1 && read != NL_INT) {        mark(1)        read = read()    }    if (read > SPACE_INT) {        reset()    }    return if (neg) -ret else ret}","data structures,dp,greedy"
"fun main() {    val out = StringBuilder()    repeat(readLine()!!.toInt()) {        val (n, m) = readLine()!!.split("" "").map { it.toInt() }        val p = listOf(0) + readLine()!!.split("" "").map { it.toInt() }        val correct = IntArray(n)        for (k in 1..n) {            correct[(k - p[k] + n) % n]++        }        val answer = mutableListOf<Int>()        for (shift in (0 until n).filter { correct[it] >= n - (2 * m) }) {            var required = n            val seen = BooleanArray(n + 1)            for (r in 1..n) {                if (!seen[r]) {                    var k = r                    while (!seen[k]) {                        seen[k] = true                        k = (k + shift) % n                        if (k == 0) {                            k = n                        }                        k = p[k]                    }                    required--                }            }            //println(""shift = $shift, required = $required"")            if (required <= m) {                answer.add(shift)            }        }        out.appendln(answer.size)        out.appendln(answer.joinToString("" ""))    }    print(out)}","brute force,combinatorics,constructive algorithms,dfs and similar,dsu,graphs,math"
"import java.io.BufferedReader fun main() {    val br = System.`in`.bufferedReader()    val sb = StringBuilder()    val t = br.readInt()    repeat(t) {        val n = br.readInt()        val m = br.readInt()        val perm = IntArray(n) { br.readInt() - 1 }        val score = IntArray(n)        for (x in 0 until n) {            score[(x - perm[x] + n) % n]++        }        val answers = mutableListOf<Int>()        for (shift in 0 until n) {            if (score[shift] >= n - (m shl 1)) {                val dupe = IntArray(n) { idx -> perm[idx] }                var swaps = 0                var temp: Int                 for (y in 0 until n) {                    while (dupe[y] != (y - shift + n) % n) {                        temp = dupe[y]                        dupe[y] = dupe[(temp + shift) % n]                        dupe[(temp + shift) % n] = temp                        swaps++                    }                }                if (swaps <= m) {                    answers += shift                }            }        }        sb.appendLine(""${answers.size} ${answers.joinToString("" "")}"")    }    print(sb)} private const val SPACE_INT = ' '.toInt()private const val ZERO_INT = '0'.toInt()private const val NL_INT = '\n'.toInt() private fun BufferedReader.readInt(): Int {    var ret = read()    while (ret <= SPACE_INT) {        ret = read()    }    val neg = ret == '-'.toInt()    if (neg) {        ret = read()    }    ret -= ZERO_INT    var read = read()    while (read >= ZERO_INT) {        ret *= 10        ret += read - ZERO_INT        read = read()    }     while (read <= SPACE_INT && read != -1 && read != NL_INT) {        mark(1)        read = read()    }    if (read > SPACE_INT) {        reset()    }    return if (neg) -ret else ret}","brute force,combinatorics,constructive algorithms,dfs and similar,dsu,graphs,math"
"import java.io.BufferedReader val bin = System.`in`.bufferedReader()fun BufferedReader.readInt() = this.readLine()!!.toInt()fun BufferedReader.readInts() = this.readLine()!!.split(' ').map { it.toInt() }.toIntArray() fun main() {    repeat(bin.readInt()) {        val (_, m) = bin.readInts()        val vs = bin.readInts().map { it-1 }.toIntArray()        val res = solve(vs, m)        if (res.isEmpty()) {            println(""0"")        } else {            println(""${res.size} "" + res.joinToString(separator="" ""))        }    }} fun solve(vs: IntArray, m: Int): List<Int> {    val n = vs.size    val good = IntArray(n)     for ((idx, v) in vs.withIndex()) {        good[Math.floorMod(idx-v, n)]++    }     val res = mutableListOf<Int>()    for (k in 0 until n) {        if (n - good[k] <= 2*m) {            val shifted = (n-k until n).toList() + (0 until n-k)            val p = Permutation(vs).compose(Permutation(shifted.toIntArray()).inverse())            val tr = p.countTranspositions()            if (tr <= m) res.add(k)        }    }    return res} data class Permutation(val p: IntArray) {    private val n = p.size     fun inverse(): Permutation {        val q = IntArray(n)        for ((idx, v) in p.withIndex()) {            q[v] = idx        }        return Permutation(q)    }     fun compose(q: Permutation): Permutation {        val res = IntArray(n)        for (idx in 0 until n) {            res[idx] = q.p[p[idx]]        }        return Permutation(res)    }     fun countTranspositions(): Int {        val visited = BooleanArray(p.size) { false }        var transpositions = 0         for (idx in p.indices) {            if (visited[idx]) continue            var cycleSize = 0            var i = idx            while (!visited[i]) {                visited[i] = true                i = p[i]                cycleSize++            }            transpositions += cycleSize-1        }         return transpositions    }     override fun equals(other: Any?): Boolean {        if (this === other) return true        if (javaClass != other?.javaClass) return false         other as Permutation         if (!p.contentEquals(other.p)) return false         return true    }     override fun hashCode(): Int {        return p.contentHashCode()    }}","brute force,combinatorics,constructive algorithms,dfs and similar,dsu,graphs,math"
"import java.io.BufferedReader val bin = System.`in`.bufferedReader()fun BufferedReader.readInt() = this.readLine()!!.toInt()fun BufferedReader.readInts() = this.readLine()!!.split(' ').map { it.toInt() }.toIntArray() fun main() {    repeat(bin.readInt()) {        val (_, m) = bin.readInts()        val vs = bin.readInts().map { it-1 }.toIntArray()        val res = solve(vs, m)        if (res.isEmpty()) {            println(""0"")        } else {            println(""${res.size} "" + res.joinToString(separator="" ""))        }    }} fun solve(vs: IntArray, m: Int): List<Int> {    val n = vs.size    val good = IntArray(n)     for ((idx, v) in vs.withIndex()) {        good[Math.floorMod(idx-v, n)]++    }     val res = mutableListOf<Int>()    for (k in 0 until n) {        if (n - good[k] <= 2*m) {            val shifted = Permutation.ofList((n-k until n).toList() + (0 until n-k))            val tr = Permutation.countTranspositionsFromTo(shifted, Permutation(vs))            if (tr <= m) res.add(k)        }    }    return res} data class Permutation(val p: IntArray) {    companion object {        fun countTranspositionsFromTo(p: Permutation, q: Permutation): Int =            q.compose(p.inverse()).countTranspositions()         fun ofList(p: List<Int>): Permutation = Permutation(p.toIntArray())    }    private val n = p.size     fun inverse(): Permutation {        val q = IntArray(n)        for ((idx, v) in p.withIndex()) {            q[v] = idx        }        return Permutation(q)    }     fun compose(q: Permutation): Permutation {        val res = IntArray(n)        for (idx in 0 until n) {            res[idx] = q.p[p[idx]]        }        return Permutation(res)    }     fun countTranspositions(): Int {        val visited = BooleanArray(p.size) { false }        var transpositions = 0         for (idx in p.indices) {            if (visited[idx]) continue            var cycleSize = 0            var i = idx            while (!visited[i]) {                visited[i] = true                i = p[i]                cycleSize++            }            transpositions += cycleSize-1        }         return transpositions    }     override fun equals(other: Any?): Boolean {        if (this === other) return true        if (javaClass != other?.javaClass) return false         other as Permutation         if (!p.contentEquals(other.p)) return false         return true    }     override fun hashCode(): Int {        return p.contentHashCode()    }}","brute force,combinatorics,constructive algorithms,dfs and similar,dsu,graphs,math"
"fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()        val xs = readLine()!!.split("" "").map { it.toInt() }        var answer = ""NO""        fun recur(j: Int, sum: Int, nonzero: Boolean) {            if (j == n) {                if (nonzero && sum == 0) {                    answer = ""YES""                }            } else {                recur(j + 1, sum - xs[j], true)                recur(j + 1, sum, nonzero)                recur(j + 1, sum + xs[j], true)            }        }        recur(0, 0, false)        println(answer)    }}","bitmasks,brute force,constructive algorithms,dfs and similar,dp,graphs,math"
"import kotlin.math.* fun main() {    val t = readLine()!!.toInt()    repeat(t) {        val maxVal = 100005        val n = readLine()!!.toInt()        val a = readLine()!!.split(' ').map { it.toInt() }.toIntArray()         val maxChoice = 3.toDouble().pow(n).toInt()        var done = false        for(i in 1 until maxChoice)        {            var which = 0            var s = 0            var x: Int = i            while(x > 0)            {                if(x%3 == 1)                    s += a[which]                else if(x%3 == 2)                    s -= a[which]                x/=3                which++            }            if(s == 0) {                done = true                break            }        }        if(!done)            println(""NO"")        else println(""YES"")    }}","bitmasks,brute force,constructive algorithms,dfs and similar,dp,graphs,math"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.io.PrintWriterimport java.util.* val inf = BufferedReader(InputStreamReader(System.`in`))val ouf = PrintWriter(System.out) fun readInts() = inf.readLine()!!.split(' ').map(String::toInt)fun readLongs() = inf.readLine()!!.split(' ').map(String::toLong)fun readString() = inf.readLine()!!fun readInt() = readInts()[0] fun main() {    for (t in 0 until readInt()) {        solve()    }    ouf.close()} fun solve() {    val n = readInt()    val a = readInts().toIntArray()    fun rek(i: Int, q: Int, s1: Int, s2: Int): Boolean {        if (q == n) return a[i] == s1 + s2        if (q == i) return rek(i, q + 1, s1, s2)        if (rek(i, q + 1, s1, s2)) return true        if (rek(i, q + 1, s1 + a[q], s2)) return true        if (rek(i, q + 1, s1, s2 - a[q])) return true        return false    }    for (i in 0 until n) {        if (rek(i, 0, 0, 0)) {            println(""YES"")            return        }    }    println(""NO"")}","bitmasks,brute force,constructive algorithms,dfs and similar,dp,graphs,math"
"import java.io.BufferedReaderimport kotlin.math.abs val bin = System.`in`.bufferedReader()fun BufferedReader.readInt() = this.readLine()!!.toInt()fun BufferedReader.readInts() = this.readLine()!!.split(' ').map { it.toInt() }.toIntArray() fun main() {    repeat(bin.readInt()) {        bin.readInt()        val vs = bin.readInts().map { abs(it) }        println(if (solve(vs)) ""YES"" else ""NO"")    }} fun solve(vs: List<Int>): Boolean {    if (0 in vs) return true    val ts = vs.mapIndexed { idx, v -> v to idx }.toMap()    if (ts.size != vs.size) return true     val n = vs.size    fun compute(mask_in: Int, submask: Int): Int {        var res = 0        var mask = mask_in        while (mask > 0) {            val b = mask.takeHighestOneBit()            val p = b.countTrailingZeroBits()            res += vs[p] * if (b and submask != 0) 1 else -1            mask -= b        }        return res    }     for (m in 0 until (1 shl n)) {        var s = m        while (s > 0) {            if (m != m.takeHighestOneBit()) {                val v = compute(m, s)                val idx = ts[v]                if (idx != null && m and (1 shl idx) == 0) return true            }            s = (s-1) and m        }    }     return false}","bitmasks,brute force,constructive algorithms,dfs and similar,dp,graphs,math"
"import kotlin.math.abs fun main(args: Array<String>) {     repeat(readLine()!!.toInt()){        val (a,b) = readLine()!!.split(' ').map {it.toLong()}        println(if(a == b){""0 0""}else{            val x = abs(a - b)            ""$x ${minOf(a % x, x - a%x)}""            }        )    } }","greedy,math,number theory"
"import kotlin.math.minimport kotlin.math.abs fun main(){    var t = readLine()!!.toInt()    while(t-->0){        val (a,b) = readLine()!!.split("" "").map{it.toLong()}        if(a == b)            println(""0 0"")        else{            val temp = abs(a - b)            println(""$temp ${min(a%temp, temp - a%temp)}"")        }    }}","greedy,math,number theory"
"private fun nl() = readLine()!! fun main() {    val t=nl().toInt()    repeat(t) {        var (a,b)=nl().split("" "").map{it.toLong()}        if (a<b) a=b.also{b=a}        if (a==b) {            println(""0 0"")        }        else {            var g=a-b            var s=minOf(a%g,g-a%g)            println(""$g $s"")        }    }}","greedy,math,number theory"
"import java.lang.Math.absimport java.lang.Math.minimport java.util.Scanner fun main() {    val scan = Scanner(System.`in`)    repeat(scan.nextInt()) {        val a = scan.next().toLong()        val b = scan.next().toLong()        if (a == b) println(""0 0"")        else {            val g = abs(a - b)            println(""$g ${min(a % g, g - a % g)}"")        }    }}","greedy,math,number theory"
"fun main() {	val n = readInt()	var bestSize = n + 1	var ans = listOf<CharArray>()	for (d in 1..n) {		val s = d * d		val other = n - s		if (other < 0 || other % 2 != 0) continue		val size = d + ((other / 2) + d - 1) / d		if (size < bestSize) {			bestSize = size			ans = List(size) { CharArray(size) { '.' } }			for (i in 0 until d) for (j in 0 until d) ans[i][j] = 'o'			for (i in 0 until other / 2) {				ans[d + i / d][i % d] = 'o'				ans[i % d][d + i / d] = 'o'			}		}	}	if (ans.isEmpty()) return println(-1)	println(ans.size)	for (s in ans.reversed()) println(s.concatToString())} private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","*special,constructive algorithms,dp"
"fun solve(nn: Int, k: Int, a: Array<BooleanArray>): Boolean {    for (diag in 0 until k) {        var n = nn        for (i in 0 until k) for (j in 0 until k) {            a[i][j] = i == k - 1 || j == 0 || (i >= k - 1 - diag && j <= diag)            if (a[i][j]) n--        }        if (n <= 0) return n == 0        if (n % 2 == 1) continue         var i = 1        while (i <= diag) {            for (j in 0 until (k - diag - 1)) {                a[k - diag - 2 - j][i] = true                a[k - 1 - i][diag + 1 + j] = true                n -= 2                if (n == 0) return true            }            i++        }    }     return false} fun main() {    val n = readLine()!!.toInt()    if (n == 2) return println(""-1"")     val ans = Array(20) { BooleanArray(20) }    var k = 1    while (k * k < n) k++    while (true) {        if (solve(n, k, ans)) {            println(k)            for (i in 0 until k) {                println(ans[i].take(k).joinToString("""") { if (it) ""o"" else ""."" })            }            break        }        k++    }}","*special,constructive algorithms,dp"
"import kotlin.math.sqrt private fun main() {    val n = readInt()    val squareSizeCandidate = sqrt(n.toDouble()).toInt()    val squareSize = if ((n + squareSizeCandidate * squareSizeCandidate) % 2 == 0) squareSizeCandidate    else squareSizeCandidate - 1    if (squareSize == 0) {        println(-1)        return    }    val maxSize = ((n + squareSize * squareSize) / 2 + squareSize - 1) / squareSize    println(maxSize)    for (row in build(squareSize, maxSize, n)) {        println(row)    }} private fun build(squareSize: Int, maxSize: Int, n: Int): Array<CharArray> {    var need = n    val result = Array(maxSize) { CharArray(maxSize) { '.' } }    // build square    for (i in (maxSize - squareSize) until maxSize) {        for (j in 0 until squareSize) {            result[i][j] = 'o'            need -= 1        }    }    for (j in 0 until squareSize) {        if (need == 0) {            break        }        for (i in 0 until maxSize - squareSize) {            if (need == 0) {                break            }            result[maxSize - squareSize - i - 1][j] = 'o'            result[maxSize - j - 1][squareSize + i] = 'o'            need -= 2        }    }    return result} /** * IO functions */private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readLong() = readLn().toLong()private fun readDouble() = readLn().toDouble()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }private fun readLongs() = readStrings().map { it.toLong() }private fun readDoubles() = readStrings().map { it.toDouble() }","*special,constructive algorithms,dp"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.io.PrintWriter val inf = BufferedReader(InputStreamReader(System.`in`))val ouf = PrintWriter(System.out) fun readInts() = inf.readLine()!!.split(' ').map(String::toInt)fun readLongs() = inf.readLine()!!.split(' ').map(String::toLong)fun readString() = inf.readLine()!!fun readInt() = readInts()[0] fun main() {    val n = readInt()    val sq = (1..100).first { (it + 1) * (it + 1) > n }    when (n) {        2 -> ouf.println(-1)        sq * sq -> {            ouf.println(sq)            for (i in 0 until sq) {                ouf.println(""o"".repeat(sq))            }        }        (sq + 1) * (sq + 1) - 2 -> {            ouf.println(sq + 2)            ouf.println(""o"".padEnd(sq + 2, '.'))            ouf.println(""o"".repeat(sq - 1).padEnd(sq + 2, '.'))            ouf.println(""o"".repeat(sq - 1).padEnd(sq + 2, '.'))            for (i in 3 until sq + 1) {                ouf.println(""o"".repeat(sq + 1).padEnd(sq + 2, '.'))            }            ouf.println(""o"".repeat(sq + 2))        }        (sq + 1) * (sq + 1) - 1 -> {            ouf.println(sq + 1)            ouf.println(""o"".repeat(sq).padEnd(sq + 1, '.'))            for (i in 1 until sq + 1) ouf.println(""o"".repeat(sq + 1))        }        else -> {            ouf.println(sq + 1)            ouf.println(""o"".repeat((n - sq * sq + 1) / 2).padEnd(sq + 1, '.'))            ouf.println(""o"".repeat(sq - if ((n - sq * sq) % 2 == 0) 0 else 1).padEnd(sq + 1, '.'))            for (i in sq - 2 downTo 0) {                ouf.println(""o"".repeat(sq + if (i < (n - sq * sq + 1) / 2) 1 else 0).padEnd(sq + 1, '.'))            }        }    }    ouf.close()}","*special,constructive algorithms,dp"
"private fun solve() {	val (hei, wid) = readInts()	val f = List(hei) { MutableList(wid) { 0 } }	for (i in 0..wid - 3) {		if (i % 2 == 0) {			f.first()[i] = 1			f.last()[i] = 1		}	}	f.first()[wid - 1] = 1	f.last()[wid - 1] = 1	for (i in 2..hei - 3) {		if (i % 2 == 0) {			f[i][0] = 1			f[i][wid - 1] = 1		}	}	for (i in 0 until hei) println(f[i].joinToString(""""))	println()} fun main() {	repeat(readInt()) { solve() }} private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","constructive algorithms,implementation"
"import java.io.Fileimport java.util.* fun main() {    val sc = Scanner(System.`in`)//    val sc = Scanner(File(""b.in""))    val t = sc.nextLine().toInt()    for (i in 1..t) solve(sc)} fun solve(sc: Scanner) {    val h = sc.nextInt()    val w = sc.nextInt()     val d = Array(h) { CharArray(w) { '0' } }    for (i in 0 until h - 2 step 2) {        d[i][0] = '1'        d[i][w - 1] = '1'    }    for (j in 0 until w - 2 step 2) {        d[0][j] = '1'        d[h - 1][j] = '1'    }    d[0][0] = '1'    d[0][w - 1] = '1'    d[h - 1][0] = '1'    d[h - 1][w - 1] = '1'     for (i in 0 until h) {        for (j in 0 until w) {            print(d[i][j])        }        println()    }    println()}","constructive algorithms,implementation"
"/** * Accomplished using the EduTools plugin by JetBrains https://plugins.jetbrains.com/plugin/10081-edutools */ fun main() {    repeat(readLine()!!.toInt()) {        val (h, w) = readLine()!!.split("" "").map { it.toInt() }        val grid = MutableList(h) { MutableList(w) { 0 } }        grid[0][0] = 1        grid[0][w-1] = 1        grid[h-1][0] = 1        grid[h-1][w-1] = 1        for(i in 2..(w-3) step 2) {            grid[0][i] = 1            grid[h-1][i] = 1        }        for(i in 2..(h-3) step 2) {            grid[i][0] = 1            grid[i][w-1] = 1        }        for( r in grid) {            for( e in r) {                print(e)            }            println()        }    }}","constructive algorithms,implementation"
"import java.io.* fun main() {    val br = BufferedReader(InputStreamReader(System.`in`))    val bw = BufferedWriter(OutputStreamWriter(System.out))     repeat(br.readLine().toInt()) {        val (h, w) = br.readLine().split("" "").map { it.toInt() }         val ans = Array(h){Array(w){0}}        for (i in 2 until h - 2 step 2) {            ans[i][0] = 1            ans[i][w - 1] = 1        }         for (i in 0 until w step 2) {            ans[0][i] = 1            ans[h - 1][i] = 1        }         for (i in 0 until h) {            for (j in 0 until w) {                bw.write(""${ans[i][j]}"")            }            bw.newLine()        }         bw.newLine()    }     bw.flush()    bw.close()}","constructive algorithms,implementation"
"fun main() {    val n = readLine()!!.toInt()    val p = readLine()!!.split("" "").map { it.toInt() }    val grid = Array(n) { IntArray(it + 1) }    for (k in 0 until n) {        var y = k        var x = k        for (j in 1..p[k]) {            grid[y][x] = p[k]            if (x > 0 && grid[y][x - 1] == 0) {                x--            } else {                y++            }        }    }    val out = StringBuilder()    grid.forEach { out.appendln(it.joinToString("" "")) }    print(out)}","constructive algorithms,dfs and similar,greedy,implementation"
"import java.util.*import kotlin.collections.ArrayDeque fun main() {    val n = readLine()!!.trim().toInt()    val permutation = readLine()!!.trim().split(' ').map(String::toInt)    val result = Array(n){IntArray(it + 1)}    val position = permutation.indices.sortedBy(permutation::get)    val exist = mutableListOf<Int>()    for (d in (0 until n).reversed()) {        exist.add(d)        exist.sortBy(position::get)        for ((i, v) in exist.withIndex()){            result[i + d][i] = v + 1        }    }    println(result.joinToString(""\n""){it.joinToString("" "")})}","constructive algorithms,dfs and similar,greedy,implementation"
"fun main(args: Array<String>) {     val count = readLine()!!.toInt()     val p = readLine()!!.split("" "").map { it.toInt() }     val b = Array(count) { Array(count) {0} }     for (n in 0 until count) {        b[n][n] = p[n]    }     for (n in 0 until count) {        fill(n, p, b)    }      printRes(count, b)} fun fill(n: Int, pp: List<Int>, b: Array<Array<Int>>) {    val p = pp[n]    var i = n    var j = n     for (k in 1 until p) {        if (j > 0 && b[i][j - 1] == 0) {            j -= 1        }        else {            i += 1        }         b[i][j] = p    }}  private fun printRes(count: Int, b: Array<Array<Int>>) {    for (i in 0 until count) {        for (j in 0 until i + 1) {            print(""${b[i][j]} "")        }         println()    }}","constructive algorithms,dfs and similar,greedy,implementation"
"fun main() {    fun readInt() = readLine()!!.toInt()    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val size = readInt()    val board = Array(size) { IntArray(size) }    val diagonal = readInts()    for (row in 0 until size) {        board[row][row] = diagonal[row]    }    for (row in 0 until size) {        val num = board[row][row]        var times = num - 1        var x = row        var y = row        while (times > 0) {            if (x > 0 && board[y][x-1] == 0) {                x--                board[y][x] = num                times--            } else if (y < size - 1 && board[y + 1][x] == 0) {                y++                board[y][x] = num                times--            } else {                return print(-1)            }        }    }     for (row in 0 until size) {        println(board[row].take(row + 1).joinToString("" ""))    }}","constructive algorithms,dfs and similar,greedy,implementation"
"fun main() {    for (c in 1..readLine()!!.toInt()) {        val (a, b, c) = readLine()!!.split("" "").map { it.toInt() }        var x = 1        for (j in 2..c) {            x *= 10        }        var y = x        while (x.toString().length < a) {            x *= 3        }        while (y.toString().length < b) {            y *= 7        }        println(""$x $y"")    }}","constructive algorithms,math,number theory"
"import java.io.*import java.util.*import kotlin.math.* fun main(){	val f = BufferedReader(InputStreamReader(System.`in`)) 	val pow10 = LongArray(12){0L}	pow10[0] = 1L	for(k in 1 until 12){		pow10[k] = pow10[k-1]*10L	} 	for(q in 1..f.readLine().toInt()){		val (a,b,c) = f.readLine().split("" "").map{it.toInt()} 		val a1 = pow10[a-1]		val a2 = pow10[b-1] + pow10[c-1] 		println(""$a1 $a2"")	}}","constructive algorithms,math,number theory"
"import kotlin.math.pow fun main() {    repeat(readLine()!!.toInt()) {        val (a,b,c) = readLine()!!.split("" "").map { it.toInt() }        val x = 10.0.pow(minOf(a, b) -1).toInt()        val y = 10.0.pow(maxOf(a, b)- 1).toInt() + if (c < minOf(a,b)) 10.0.pow(c-1).toInt() else 0         if(a <= b) {            println(minOf(x,y))            println(maxOf(x,y))        } else {            println(maxOf(x,y))            println(minOf(x,y))        }      }}","constructive algorithms,math,number theory"
"fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main() {    repeat(readInt()) {        val (a, b, c) = readInts()        val l = 10L.pow(a-1)        val r = ""1"".repeat(b-c) + 10L.pow(c-1)        println(""$l $r"")    }} // exponentiation in O(log n)fun Long.pow(n_in: Int): Long {    if (n_in == 0) return 1L    var n = n_in    var x = this    var res = 1L    while (n > 0L) {        if (n % 2L == 1L) res *= x        x *= x        n /= 2    }    return res}","constructive algorithms,math,number theory"
"fun main() {    val (h, w) = readLine()!!.split(' ').map { it.toInt() }    val cake = List(h) { readLine()!!.map { it == '*' } }    var i = 0    var j = 0    var ans = 0    while (i + 1 < h || j + 1 < w){        ans += if (cake[i][j]) 1 else 0        if (i + 1 == h) {            j++        } else {            if (j + 1 == w) {                i++            } else {                if (cake[i + 1][j]) i++ else j++            }        }    }    println(ans + if (cake[i][j]) 1 else 0)}","*special,greedy,implementation,shortest paths"
"fun main(args: Array<String>) {    val (R,C) =  readLine()!!.split("" "").map(String::toInt)    val A = (0 until R).map { readLine()!! }    var r = 0    var c = 0    var ans = if (A[0][0] == '*') 1 else 0    while (r != R-1 || c != C-1) {        if (r == R-1) {            c++        } else if (c == C-1) {            r++        } else if (A[r][c+1] == '*') {            c++        } else if (A[r+1][c] == '*') {            r++        } else {            c++        }        if (A[r][c] == '*') ans++    }     println(ans)}","*special,greedy,implementation,shortest paths"
"fun main() {    val (n, m) = readLine()!!.split("" "").map(String::toInt)    val a = List(n) { readLine()!! }    var x = 0    var y = 0    var ans = 0    while (true) {        if (a[x][y] == '*') ans++        if (x == n - 1 && y == m - 1) break         var down = Int.MAX_VALUE        for (i in (x + 1) until n) {            if (a[i][y] == '*') { down = i - x; break }        }        var right = Int.MAX_VALUE        for (j in (y + 1) until m) {            if (a[x][j] == '*') { right = j - y; break }        }         if (x < n - 1 && (down < right || y == m - 1)) x++ else y++    }    println(ans)}","*special,greedy,implementation,shortest paths"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.io.PrintWriter val inf = BufferedReader(InputStreamReader(System.`in`))val ouf = PrintWriter(System.out) fun readInts() = inf.readLine()!!.split(' ').map(String::toInt)fun readLongs() = inf.readLine()!!.split(' ').map(String::toLong)fun readString() = inf.readLine()!! fun main() {    val (h, w) = readInts()    val a = Array(h) {        readString().map { it == '*' }.toBooleanArray()    }    var x = 0    var y = 0    var ans = if (a[0][0]) 1 else 0    while (x < h - 1 || y < w - 1) {        when {            y < w - 1 && a[x][y + 1] -> y++            x < h - 1 && a[x + 1][y] -> x++            y < w - 1 -> y++            else -> x++        }        if (a[x][y]) ans++    }    println(ans)}","*special,greedy,implementation,shortest paths"
"fun main(){    val t= readLine()!!.toInt()    repeat(t) {        val (n, k) = readLine()!!.split(' ').map { it.toLong() }        if (n%2==1L){            println(""1 ${n/2} ${n/2}"")        }else{            if (n%4==0L){                println(""${n/2} ${n/4} ${n/4}"")            }else{                println(""2 ${(n/4)*2} ${(n/4)*2}"")            }         }     }}","constructive algorithms,math"
"fun main() {    val t = readLine()!!.toInt()    for (q in 1..t) {        val (n, _) = readLine()!!.split("" "").map { it.toInt() }        val m = n / 2        if (n % 2 == 1) {            println(""$m $m 1"")        } else {            if (m % 2 == 0) {                println(""$m ${m / 2} ${m / 2}"")            } else {                println(""${m - 1} ${m - 1} 2"")            }        }    }}","constructive algorithms,math"
"fun main() {  repeat(readLine()!!.toInt()) {     val(n,k) = readLine()!!.split("" "").map { it.toInt() }      val added = solve3(n-k+3)      for (i in 0 until k) {          print(""${if(i<3) added[i] else 1} "")      }      println()   }} fun solve3(n: Int): List<Int> {    if(n%2==1) return listOf(1,n/2,n/2)    if(n%4==0) return listOf(n/2,n/4,n/4)    if(n%2==0) return listOf(2, n/2-1,n/2-1)    return emptyList()}     ","constructive algorithms,math"
"//https://codeforces.com/problemset/problem/1497/C1fun main() {    val t = readLine()!!.toInt()    for (i in 0 until t) {        val (n, k) = readLine()!!.split("" "").stream().mapToLong(String::toLong).toArray()        if (n == 4L) {            println(""2 1 1"")            continue        }        val d = when ((n % 4).toInt()) {            0 -> n / 2            2 -> 2            else -> 1        }        val v = (n - d) / 2        println(""$d $v $v"")    }}","constructive algorithms,math"
"// buffer input?// overflow? fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main() {    repeat(readInt()) {        readInt()        val vs = readInts()        println(solve(vs))    }} fun solve(vs: List<Int>): Int {    val freq = mutableMapOf<Int, Int>()    for (v in vs) {        freq.merge(v, 1, Int::plus)    }     // how many to remove for c-beautiful    fun score(c : Int): Int =        freq.values.map { f ->            when {                f > c -> f-c                f < c -> f                else -> /* f==c */ 0            }        }.sum()     return freq.values.toSet().map { score(it) }.min()!!}","binary search,data structures,greedy,math,sortings"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.*import kotlin.math.min fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    for (c in 1..jin.readLine().toInt()) {        val n = jin.readLine().toInt()        val freqMap = mutableMapOf<Int, Int>()        val tokenizer = StringTokenizer(jin.readLine())        for (j in 1..n) {            val k = tokenizer.nextToken().toInt()            freqMap[k] = (freqMap[k] ?: 0) + 1        }        val freqs = freqMap.values.sorted()        var answer = Int.MAX_VALUE        for ((j, f) in freqs.withIndex()) {            answer = min(answer, n - ((freqs.size - j) * f))        }        println(answer)    }}","binary search,data structures,greedy,math,sortings"
"//// Created by zeronosu77108 on 2021/02/24.//import kotlin.collections.*import kotlin.math.* @kotlin.ExperimentalStdlibApifun main() {    val t = readLine()!!.toInt()    for (i in 0 until t) solveF()} fun solveF() {    val n = readLine()!!.toInt()    val a = readLine()!!.split("" "").map { it.toLong() }     val cnt = a.groupingBy { it }.eachCount().values.groupingBy { it }.eachCount()    var rsum = cnt.map { (k,v) -> k*v }.sum()    var lsum = 0L    var cn = cnt.values.sum()     val keys = cnt.keys.sorted()    var ans = n.toLong()    for (k in keys) {        rsum -= k * cnt[k]!!                ans = minOf(ans, lsum + rsum - k * (cn - cnt[k]!!))         lsum += k * cnt[k]!!        cn -= cnt[k]!!    }    println(ans)}","binary search,data structures,greedy,math,sortings"
"//// Created by zeronosu77108 on 2021/02/24.//import kotlin.collections.*import kotlin.math.* @kotlin.ExperimentalStdlibApifun main() {    val t = readLine()!!.toInt()    for (i in 0 until t) solveF()} fun solveF() {    val n = readLine()!!.toInt()    val a = readLine()!!.split("" "").map { it.toLong() }     val cnt = a.groupingBy { it }.eachCount().values.groupingBy { it }.eachCount()    var rsum = cnt.map { (k,v) -> k*v }.sum()    var lsum = 0L //    println(cnt)    var cn = cnt.values.sum()     val keys = cnt.keys.sorted()    var ans = n.toLong()    for (k in keys) {        rsum -= k * cnt[k]!!        ans = minOf(ans, lsum + rsum - k * (cn - cnt[k]!!))//        println(""${lsum} + ${rsum - k * (cn - cnt[k]!!)}"")        lsum += k * cnt[k]!!        cn -= cnt[k]!!    }    println(ans)}","binary search,data structures,greedy,math,sortings"
"fun readInt() = readLine()!!.toInt() fun main() {    repeat(readInt()) {        val n = readInt()        val s = readLine()!!         val l_nat = IntArray(n+1) { 0 }        val l_rev = IntArray(n+1) { 0 }        for (i in 1..n) {            l_nat[i] = if (s[i-1] == 'L') l_rev[i-1]+1 else 0            l_rev[i] = if (s[i-1] == 'R') l_nat[i-1]+1 else 0        }         val r_nat = IntArray(n+1) { 0 }        val r_rev = IntArray(n+1) { 0 }        for (i in n-1 downTo 0) {            r_nat[i] = if (s[i] == 'R') r_rev[i+1]+1 else 0            r_rev[i] = if (s[i] == 'L') r_nat[i+1]+1 else 0        }         val res = (0..n).map { 1 + l_nat[it] + r_nat[it] }        println(res.joinToString(separator="" ""))    }}","dfs and similar,dp,dsu,implementation"
"private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of ints fun main(args: Array<String>) {    var  t  = readInt()    for (i in 0.. t-1){        var n = readInt()        var s = readLn()        var R= Array<Int>(n+2) {i->0}        var L=Array<Int>(n+2) {i->0}          for (i in n-2 downTo 0 )             if (!s[i].equals(s[i+1]))                R[i] = R[i+1] +1         for (i in 1..n-1)            if (!s[i].equals(s[i-1]))                L[i] = L[i-1]+1         var res = 0         for ( i in 0..n) {            res = 0            if (i < n)                if (s[i].equals('R'))                     res +=R[i]+1             if ( i>0)                if (s[i-1].equals('L'))                    res += L[i-1]+1             res +=1            print(""$res "")        }        println ()    }}","dfs and similar,dp,dsu,implementation"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport kotlin.math.max fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val out = StringBuilder()    for (c in 1..jin.readLine().toInt()) {        val n = jin.readLine().toInt()        val s = jin.readLine()        var last = if (s[0] == 'L') 'R' else 'L'        var curr = 0        val answer = IntArray(n + 1) { 1 }        for (j in 0 until n) {            curr++            val dir = s[j]            if (dir == last) {                if (dir == 'L') {                    answer[j] = curr                }                for (k in j - 1 downTo 0) {                    if (s[k] == 'R') {                        answer[k] = max(answer[k], curr)                    }                    if (k == 0 || s[k - 1] == s[k]) {                        break                    }                }                curr = 1            } else {                last = dir            }        }        curr++        if (last == 'L') {            answer[n] = curr        }        for (k in n - 1 downTo 0) {            if (s[k] == 'R') {                answer[k] = max(answer[k], curr)            }            if (k == 0 || s[k - 1] == s[k]) {                break            }        }        out.appendln(answer.joinToString("" ""))    }    print(out)}","dfs and similar,dp,dsu,implementation"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.*import java.lang.AssertionErrorimport kotlin.math.* val input = BufferedReader(InputStreamReader(System.`in`))val output = StringBuilder() fun main() {    var tt = int()    while (tt-- > 0) {        var n = int()        var s = string()        var a = IntArray(n)        for (i in 0..n - 1) {            if ((s[i] == 'L') == (i % 2 == 0)) {                a[i] = 1            }        }        var b = IntArray(n)        b[0] = 1        for (i in 1..n - 1) {            if (a[i] == a[i - 1]) {                b[i] = b[i - 1] + 1            } else {                b[i] = 1            }        }        var c = IntArray(n)        c[n - 1] = 1        for (i in n - 2 downTo 0) {            if (a[i] == a[i + 1]) {                c[i] = c[i + 1] + 1            } else {                c[i] = 1            }        }        var ans = IntArray(n + 1)        for (i in 0..n) {            if (i != 0) {                if (s[i - 1] == 'L') {                    ans[i] += b[i - 1]                }            }            if (i != n) {                if (s[i] == 'R') {                    ans[i] += c[i]                }            }            ans[i]++        }        cout(ans)    }    print(output)} fun string() = input.readLine()fun int() = string().toInt()fun long() = string().toLong()fun strings() = ArrayList(string().split("" ""))fun ints() = ArrayList(strings().map { it.toInt() })fun longs() = ArrayList(strings().map { it.toLong() })fun cout(s: String) = output.appendLine(s)fun <T> cout(s: T) = output.appendLine(s.toString())fun cout(s: IntArray) = output.appendLine(s.joinToString("" ""))fun cout(s: LongArray) = output.appendLine(s.joinToString("" ""))fun <T> cout(s: Array<T>) = output.appendLine(s.joinToString("" ""))fun <T> cout(s: Iterable<T>) = output.appendLine(s.joinToString("" ""))fun assert(x: Boolean) {    if (!x) throw AssertionError()}","dfs and similar,dp,dsu,implementation"
"import java.io.BufferedReaderimport java.io.InputStreamReader fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val out = StringBuilder()    val needed = IntArray(1000001)    val toUnset = mutableListOf<Int>()    cases@for (c in 1..jin.readLine().toInt()) {        jin.readLine()        val ay = jin.readLine().split("" "").map { it.toInt() }.toMutableList()        ay.sortDescending()        for (j in 1 until ay.size) {            val operations = mutableListOf<Pair<Int, Int>>()            var prev = ay[0] + ay[j]            for (a in ay) {                if (needed[a] > 0) {                    needed[a]--                } else {                    needed[prev - a]++                    operations.add(Pair(a, prev - a))                    toUnset.add(prev - a)                    prev = a                }            }            var works = true            for (a in toUnset) {                if (needed[a] != 0) {                    works = false                    needed[a] = 0                }            }            toUnset.clear()            if (works) {                out.appendln(""YES"")                out.appendln(ay[0] + ay[j])                for ((a, b) in operations) {                    out.appendln(""$a $b"")                }                continue@cases            }        }        out.appendln(""NO"")    }    print(out)}","brute force,constructive algorithms,data structures,greedy,implementation,sortings"
"import kotlin.math.max val count = Array(1_000_000 + 12) { 0 } fun main() {     val t = readLine()!!.toInt()    repeat(t) {        val n = readLine()!!.toInt()        val a = readLine()!!.split("" "").map { it.toInt() }.sorted()         var success = false         for (i in 0 until a.lastIndex) {            a.forEach { count[it]++ }             var j = a.lastIndex            var x = a[i] + a[j]             val removal = mutableListOf<Int>()             for (op in 0 until n) {                while (j > 0 && count[a[j]] == 0) {                    j--                }                 removal.add(a[j])                removal.add(x - a[j])                 count[a[j]]--                count[x - a[j]]--                 if (count[a[j]] < 0 || count[x - a[j]] < 0) {                    count[a[j]] = 0;                    count[x - a[j]] = 0;                    break;                }                 x = max(x - a[j], a[j]);                if (op + 1 == n)                    success = true;            }             a.forEach { count[it] = 0 }            if (success) {                println(""YES"")                println(removal[0] + removal[1])                for (k in 0 until removal.size step 2) {                    println(""${removal[k]} ${removal[k + 1]}"")                }                 break            }        }         if (!success) {            println(""NO"")        }        a.forEach { count[it] = 0 }    } }","brute force,constructive algorithms,data structures,greedy,implementation,sortings"
"import java.io.*import java.util.*import kotlin.math.* fun main(){	val f = BufferedReader(InputStreamReader(System.`in`)) 	for(q in 1..f.readLine().toInt()){		val n = f.readLine().toInt()*2		val array = f.readLine().split("" "").map{it.toInt()}.sorted() 		val freqs = HashMap<Int,Int>()		for(k in 0 until n){			if(freqs.containsKey(array[k])){				freqs.put(array[k],freqs[array[k]]!!+1)			} else {				freqs.put(array[k],1)			}		} 		//pick second number, out of 0 to n-1		var found = false		for(k in 0 until n-1){			val curfreqs = HashMap<Int,Int>()			for((key,value) in freqs){				curfreqs.put(key,0)			}			//array[k] is the 2nd number			val answer = mutableListOf<Pair<Int,Int>>()			answer.add(Pair(array[k],array[n-1]))			curfreqs.put(array[k],curfreqs[array[k]]!!+1)			curfreqs.put(array[n-1],curfreqs[array[n-1]]!!+1) 			var cur = array[n-1]			for(j in n-2 downTo 0){				if(curfreqs[array[j]]!! < freqs[array[j]]!!){					curfreqs.put(array[j],curfreqs[array[j]]!!+1)					if(curfreqs.containsKey(cur-array[j]) && curfreqs[cur-array[j]]!! < freqs[cur-array[j]]!!){						curfreqs.put(cur-array[j],curfreqs[cur-array[j]]!!+1)						answer.add(Pair(array[j],cur-array[j]))						cur = array[j]					} else {						break					}				}			} 			if(answer.size == n/2){				found = true				println(""YES"")				println(answer[0].first+answer[0].second)				val sj = StringJoiner(""\n"")				for(i in 0 until answer.size){					sj.add(""${answer[i].first} ${answer[i].second}"")				}				println(sj.toString())				break			}		}		if(!found){			println(""NO"")		}	}}","brute force,constructive algorithms,data structures,greedy,implementation,sortings"
"fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main() {    repeat(readInt()) {        readInt()        val vs = readInts().sorted()        val s = solve(vs)        if (s == null) {            println(""NO"")        } else {            val (l, r) = s.first()            println(""YES"")            println(""${l+r}"")            println(s.joinToString(separator = ""\n"") { (l, r) -> ""$l $r"" })        }    }} fun solve(vs: List<Int>): List<Pair<Int, Int>>? {    val last = vs.last()    val rest = vs.dropLast(1)     for (i in rest.indices) {        val s = solveWith(last, i, rest)        if (s != null) {            return listOf(Pair(rest[i], last)) + s        }    }     return null} fun solveWith(sum_in: Int, dead_idx: Int, vs: List<Int>): List<Pair<Int, Int>>? {    var sum = sum_in    val res = mutableListOf<Pair<Int, Int>>()     val m = MultisetInt(listOf())    var idx = vs.indices.last    repeat(vs.size-1) {        if (idx == dead_idx) idx--        val elt = vs[idx]        if (m.contains(elt)) {            m.remove(elt)        } else {            val p = sum-elt            res.add(Pair(p, elt))            m.add(p)            sum = elt        }        idx--    }     return if (m.isEmpty()) res else null} /** * Multiset of int values. */class MultisetInt(initial: Collection<Int>) {    // value -> # of copies    val vs = mutableMapOf<Int, Int>()     init {        initial.forEach { add(it) }    }     fun add(elt: Int) {        vs.merge(elt, 1, Int::plus)    }     fun remove(elt: Int) {        vs[elt] = vs[elt]!! - 1        if (vs[elt] == 0) {            vs.remove(elt)        }    }     fun contains(i: Int): Boolean = vs.containsKey(i)     fun isEmpty(): Boolean = vs.isEmpty()}","brute force,constructive algorithms,data structures,greedy,implementation,sortings"
"fun main() {    repeat(readLine()!!.toInt()) {        val a = readLine()!!.toCharArray()        println(if(a.size % 2 == 0 && a.first() != ')' && a.last() != '(') ""YES"" else ""NO"")    }}","constructive algorithms,greedy"
"fun main() {    fun readInt() = readLine()!!.toInt()     repeat(readInt()) {        val s = readLine()!!        println(if (s.length and 1 == 1 || s.startsWith(')') || s.endsWith('(')) ""NO"" else ""YES"")    }}","constructive algorithms,greedy"
"fun main() {    var t = readLine()!!.toInt()    while (t-- > 0) {        val s = readLine()!!        if (s.length % 2 != 0 || s[0] == ')' || s[s.length - 1] == '(') println(""NO"")        else println(""YES"")    }}","constructive algorithms,greedy"
"fun readInt() = readLine()!!.toInt() fun main() {    repeat(readInt()) {        val s = readLine()!!        val ok = s.length % 2 == 0 && s.first() != ')' && s.last() != '('        println(if (ok) ""YES"" else ""NO"")    }}","constructive algorithms,greedy"
"fun main() {    val MOD = 1_000_000_000L + 7L    val P = 60     val t = readLine()!!.toInt()    repeat(t) {        val n = readLine()!!.toInt()        val x = readLine()!!.split("" "").map { it.toLong() }         val cnt = Array(P) { 0L }        x.forEach {            for (i in 0 until P) {                cnt[i] += (it shr i) and 1            }        }         var ans = 0L        for (i in 0 until n) {            var exp_and = 0L            var exp_or = 0L             for (j in 0 until P) {                if (((x[i] shr j) and 1) > 0) {                    exp_or += (1L shl j) % MOD * n                    exp_and += (1L shl j) % MOD * cnt[j]                } else {                    exp_or += (1L shl j) % MOD * cnt[j]                }            }             exp_and %= MOD            exp_or %= MOD;            ans = (ans + 1L * exp_or * exp_and) % MOD        }         println(ans)    }}","bitmasks,brute force,math"
"import java.io.BufferedReaderimport java.io.InputStreamReader const val MOD = 1000000007L fun main() {    val pow2 = LongArray(60) { (1L shl it) % MOD }    val jin = BufferedReader(InputStreamReader(System.`in`))    for (c in 1..jin.readLine().toInt()) {        val n = jin.readLine().toLong()        val xs = jin.readLine().split("" "").map { it.toLong() }        val freq = LongArray(60)        for (x in xs) {            for (e in 0..59) {                if ((x shr e) and 1L == 1L) {                    freq[e]++                }            }        }        var answer = 0L        for (x in xs) {            var left = 0L            var right = 0L            for (e in 0..59) {                if ((x shr e) and 1L == 1L) {                    left += freq[e] * pow2[e]                    left %= MOD                    right += n * pow2[e]                    right %= MOD                } else {                    right += freq[e] * pow2[e]                    right %= MOD                }            }            answer += left * right            answer %= MOD        }        println(answer)    }}","bitmasks,brute force,math"
"private fun readInt() = readLine()!!.toInt()private fun readInts() = readLine()!!.split("" "").map { it.toInt() }.toIntArray()private fun readLongs() = readLine()!!.split("" "").map { it.toLong() }.toLongArray() fun main() {    val mod = 1_000_000_007L    repeat(readInt()) {        val n = readInt()        val x = readLongs()         val bits = LongArray(60)        for (i in bits.indices) {            bits[i] = (1L shl i) % mod        }         val bitx = IntArray(60)        for (i in x.indices) {            val v = x[i]            for (bi in bitx.indices) {                if (v and (1L shl bi) != 0L) bitx[bi]++            }        }         var ans = 0L        for (i in x) {            var andSum = 0L            var orSum = 0L            for (bi in bitx.indices) {                andSum = (andSum + bits[bi] * (if (i and (1L shl bi) != 0L) bitx[bi] else 0)) % mod                orSum = (orSum + bits[bi] * (if (i and (1L shl bi) != 0L) n else bitx[bi])) % mod            }            val mul = andSum * orSum            ans = (ans + mul) % mod        }        println(ans)    }}   ","bitmasks,brute force,math"
"fun main(){    val T =readLine()!!.toInt()    val LASTANS=LongArray(T)    val mod=1000000007    val BEKI=LongArray(60)    val BEKI2=LongArray(60)     var now=1.toLong()     for (i in 0..59){        BEKI[i]=now        BEKI2[i]=now%mod        now=now*2    }     for (tests in 0..T-1) {        val n=readLine()!!.toInt()        var A = readLine()!!.split(' ').map { it.toLong() }         val BIT=IntArray(60)        for (a in A){            for (i in 0..59){                if ((a and BEKI[i]) != 0.toLong()){                    BIT[i]+=1                }            }        }         var ANS=0.toLong()         for (a in A){            var AND=0.toLong()            var OR=0.toLong()             for (i in 0..59){                if ((a and BEKI[i]) != 0.toLong()){                    AND=(AND+BIT[i]*BEKI2[i])%mod                    OR=(OR+n*BEKI2[i])%mod                }                else{                    OR =(OR+BIT[i]*BEKI2[i])%mod                }             }            ANS=(ANS+AND*OR)%mod        }         LASTANS[tests]=ANS      }    println(LASTANS.joinToString(separator = ""\n""))}","bitmasks,brute force,math"
"val mod = 998244353 fun main() {    repeat(readLine()!!.toInt()) {        val (n, k) = readLine()!!.split("" "").map { it.toInt() }        val a = readLine()!!.split("" "").map { it.toInt() }        val b = readLine()!!.split("" "").map { it.toInt() }         val index = Array(n + 1) { -2 }        for (i in 0 until n) index[a[i]] = i         val restrict = mutableSetOf<Int>().apply { addAll(b) }         var ans = 1L        for (x in b) {            restrict.remove(x)             val i = index[x]            var ways = 0            if (i - 1 in a.indices && !restrict.contains(a[i - 1])) ways++            if (i + 1 in a.indices && !restrict.contains(a[i + 1])) ways++             ans = (ans * ways) % mod        }         println(ans)    }}","combinatorics,data structures,dsu,greedy,implementation"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.* const val MOD = 998244353L fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val out = StringBuilder()    for (c in 1..jin.readLine().toInt()) {        val (n, k) = jin.readLine().split("" "").map { it.toInt() }        val ay = jin.readLine().split("" "").map { it.toInt() }        val time = IntArray(n + 1)        val tokenizer = StringTokenizer(jin.readLine())        for (j in 1..k) {            time[tokenizer.nextToken().toInt()] = j        }        var answer = 1L        for (j in 0 until n) {            if (time[ay[j]] != 0) {                var pos = 0L                if (j > 0 && time[ay[j - 1]] < time[ay[j]]) {                    pos++                }                if (j < n - 1 && time[ay[j + 1]] < time[ay[j]]) {                    pos++                }                answer *= pos                answer %= MOD            }        }        out.appendln(answer)    }    print(out)}","combinatorics,data structures,dsu,greedy,implementation"
"private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of ints fun main(args: Array<String>) {    var t = readInt ()    val MOD = 998244353    for (x in 0..t-1){        val (n,m) = readInts()        var a = readInts()        var b = readInts()         var originalPos = Array(n+1){i->0}        var marking = Array(n+1){i->0}        for (i in b)            marking[i]=-1        for (i in 0..a.size-1)            originalPos[a[i]] = i         var time =0        var res =1        for (i in  0..b.size-1 ){            time = 0            if (originalPos[b[i]]+1 < n && marking[a[originalPos[b[i]]+1]] != -1)                time +=1            if (originalPos[b[i]]-1 >= 0 && marking[a[originalPos[b[i]]-1]] != -1)                time +=1            marking[b[i]] = 1            res = (res *time)%MOD        }        println (res)    }}","combinatorics,data structures,dsu,greedy,implementation"
"fun main(){    var O:StringBuilder = StringBuilder()    var t = readInt()    while (t-->0)    {        var (n,k) = readInts()        var a = readInts()        var b = readInts()        var pos = IntArray(n+1)        var exist:BooleanArray = BooleanArray(n+1)        var ans = 1;        val modulo = 998244353        for(i in 0 until n){            pos[a[i]] = i        }        for(i in 0 until k){            exist[b[i]] = true        }        for(i in 0 until k){            var p = pos[b[i]]            exist[b[i]] = false            var flag1 = true            var flag2 = true             if (p<n-1){                flag1 = exist[a[p+1]]            }            if(p>0){                flag2 = exist[a[p-1]]            }            if(flag1&&flag2){                ans = 0                break            }else if (!flag1&&!flag2){                ans *= 2                ans %= modulo            }         }        O.append(""$ans\n"")    }    print(O)}  private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "");private fun readInts() = readStrings().map { it.toInt() }","combinatorics,data structures,dsu,greedy,implementation"
"fun main() {    val n = readLine()!!.toInt()    val a = readLine()!!.split("" "").map { it.toInt() }     val res = count(a)    val reversed = count(a.reversed()).map { n - 1 - it.second to n - 1 - it.first }    res.addAll(reversed)     println(res.size)} private fun count(a: List<Int>): MutableSet<Pair<Int, Int>> {    val n = a.size    val res = mutableSetOf<Pair<Int, Int>>()    for (l in 0 until n) {        var sum = 0        val limit = Integer.highestOneBit(a[l]) * 2        for (r in l + 2..n - 1) {            sum += a[r - 1]            if (sum >= limit) break             if (sum == a[l] xor a[r]) res.add(l to r)        }    }    return res}","binary search,bitmasks,brute force,constructive algorithms,divide and conquer,two pointers"
"import java.io.BufferedReaderimport java.io.InputStreamReader fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val n = jin.readLine().toInt()    val ay = jin.readLine().split("" "").map { it.toLong() }    var answer = 0    for (j in 0 until n) {        var sum = 0L        for (k in j - 2 downTo 0) {            sum += ay[k + 1]            if (sum > 2L * ay[j]) {                break            }            if (ay[j] >= ay[k] && ay[j] xor ay[k] == sum) {                answer++            }        }        sum = 0L        for (k in j + 2 until n) {            sum += ay[k - 1]            if (sum > 2L * ay[j]) {                break            }            if (ay[j] > ay[k] && ay[j] xor ay[k] == sum) {                answer++            }        }    }    println(answer)}","binary search,bitmasks,brute force,constructive algorithms,divide and conquer,two pointers"
"import java.io.FileInputStream fun main() {//    changeStandardInput()    val n = readIntLn()    val a = readInts()     val ans = HashSet<IntPair>()    for (l in 0 until n - 2) {        val maxSum = maxBit(a[l])        var sum = a[l + 1]        for (r in l + 2 until n) {            if (a[l] xor a[r] == sum) {                ans.add(IntPair(l, r))            }             sum += a[r]            if (sum >= maxSum) break        }    }     for (r in n - 1 downTo 2) {        val maxSum = maxBit(a[r])        var sum = a[r - 1]        for (l in r - 2 downTo 0) {            if (a[l] xor a[r] == sum) {                ans.add(IntPair(l, r))            }             sum += a[l]            if (sum >= maxSum) break        }    }     println(ans.size)} fun maxBit(n: Int): Int {    var cnt = 0    var nn = n    var ans = 1    while (nn > 0) {        nn = nn ushr 1        ans *= 2    }    return ans}  private data class IntPair(    val f: Int,    val s: Int) : Comparable<IntPair> {    override fun compareTo(other: IntPair): Int {        val cmp = f.compareTo(other.f)        return if (cmp == 0) s.compareTo(other.s) else cmp    }}  private fun readLn() = readLine()!!private fun readIntLn() = readLn().toInt()private fun readLongLn() = readLn().toLong()private fun readDoubleLn() = readLn().toDouble()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }private fun readLongs() = readStrings().map { it.toLong() }  private fun changeStandardInput() {    System.setIn(FileInputStream(""input.txt""))}","binary search,bitmasks,brute force,constructive algorithms,divide and conquer,two pointers"
"import java.io.BufferedReaderimport java.io.InputStreamReader fun main() {    val fs = BufferedReader(InputStreamReader(System.`in`))    val out = StringBuilder()    var t = fs.readLine()!!.toInt()    for(tt in 1..t){        var n = fs.readLine().toInt()        var a = fs.readLine()!!.split("" "").map{ it.toInt()}        var v = 0        var ans = 1        var cnt = 0        for(i in 1 until a.size){            if(a[i] < a[i-1]){                if(v==0){                    v=cnt-1                    ans++                }                else{                    v--                }            }            else cnt++        }        out.appendln(ans)    }    print(out)}","graphs,greedy,shortest paths,trees"
"fun readInt() = readLine()!!.toInt()fun read() = readLine()!!.split("" "").map { it.toInt() }fun main() = repeat(readInt()) {    val n = readInt()    val a = read()    val seg = emptyList<Pair<Int, Int>>().toMutableList()    var l = 1    while (l < n) {        var r = l        while (r + 1 < n && a[r + 1] > a[r])            r++        seg.add(l to r)        l = r + 1    }    var (res, cur, k, nxt) = intArrayOf(1, 1, 0, 0)    for (i in 0 until seg.size) {        k++        nxt += seg[i].second - seg[i].first + 1        if (k == cur) {            k = 0            cur = nxt            nxt = 0            if (i < seg.size - 1)                res++        }    }    println(res)}","graphs,greedy,shortest paths,trees"
"fun main() {    val t = readInt()     repeat(t) {        val n = readInt()        val a = readInts()        val depth = mutableMapOf<Int, Int>()        val queue = ArrayDeque<Int>()        queue.addFirst(1)        depth[1] = 0        var currParent = queue.removeFirst()        for (i in 1 until n) {            if (a[i] < a[i - 1]) {                currParent = queue.removeFirst()            }            depth[a[i]] = depth[currParent]!! + 1            queue.addLast(a[i])        }        println(depth.values.maxOrNull())    }} // Input Readerprivate fun readLn() = readLine()!! private fun readStrings() = readLn().trim().split("" "")private fun readInt() = readLn().toInt()private fun readInts() = readStrings().map { it.toInt() }","graphs,greedy,shortest paths,trees"
import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.* fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    for (c in 1..jin.readLine().toInt()) {        val n = jin.readLine().toInt()        var answer = 1        var here = 1        var next = 0        var last = 0        val tokenizer = StringTokenizer(jin.readLine())        tokenizer.nextToken()        for (j in 2..n) {            val k = tokenizer.nextToken().toInt()            if (k < last) {                if (here == 1) {                    answer++                    here = next                    next = 0                } else {                    here--                }            }            next++            last = k        }        println(answer)    }},"graphs,greedy,shortest paths,trees"
"import java.util.*import kotlin.math.* fun readln() = readLine()!!fun readint() = readln().toInt()fun readlong() = readln().toLong()fun readdouble() = readln().toDouble()fun readstrings() = ArrayList(readln().split("" ""))fun readints() = ArrayList(readstrings().map { it.toInt() })fun readlongs() = ArrayList(readstrings().map { it.toLong() })fun readdoubles() = ArrayList(readstrings().map { it.toDouble() }) fun main() {    var (h,w,k)=readints()    var inf=1e8.toInt()    var dp=IntArray(k){-inf}    dp[0]=0    for(i in 0..h-1){        var a=readints()        var c=IntArray(5000){inf}        c[0]=0        for(l in a){            for(j in 4900 downTo 0){                c[j+l]=minOf(c[j+l],c[j]+1)            }        }        var t=IntArray(k,{-inf})        for(j in 0..4900){            if(c[j]*2<=w){                t[j%k]=j            }        }        var ndp=dp.copyOf()        for(j in 0..k-1){            for(l in 0..k-1){                if(t[l]<0){                    continue                }                ndp[(j+l)%k]=maxOf(ndp[(j+l)%k],dp[j]+t[l])            }        }        dp=ndp.copyOf()    }    println(""${dp[0]}"")}",dp
"fun main() {    val (n, m, k) = readInts()    val possibleSums = Array(n) { IntArray(m) }    for (i in 0 until n) {        val got = BooleanArray(k)        possibleSums[i] = findPossibleSums(readIntArray(), m / 2).reversed().filter {            weight -> !got[weight % k].also { got[weight % k] = true }        }.toIntArray()    }    val allPossibleSums = IntArray(possibleSums.sumBy { it.max()!! } + 1) { n }    allPossibleSums[0] = -1    for (i in possibleSums.indices) {        for (x in possibleSums[i]) {            for (w in x until allPossibleSums.size) {                if (allPossibleSums[w - x] < i && allPossibleSums[w] > i) allPossibleSums[w] = i            }        }    }    println(allPossibleSums.indices.filter { allPossibleSums[it] < n }.filter { it % k == 0 }.max()!!)} fun findPossibleSums(a: IntArray, maxOps: Int): IntArray {    val result = IntArray(a.sum() + 1) { if (it == 0) 0 else a.size }    for (x in a) {        for (i in (x until result.size).reversed()) {            result[i] = minOf(result[i], result[i - x] + 1)        }    }    return result.indices.filter { result[it] <= maxOps }.toIntArray()} fun readLong() = readLine()!!.toLong()fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() }fun readIntArray() = readInts().toIntArray()",dp
"fun main() {    val (n, m, k) = readInts()    val possibleSums = Array(n) { IntArray(m) }    for (i in 0 until n) {        val got = BooleanArray(k)        possibleSums[i] = findPossibleSums(readIntArray(), m / 2).reversed().filter {            val achieved = got[it % k]            got[it % k] = true            !achieved        }.toIntArray()    }    val allPossibleSums = IntArray(possibleSums.sumBy { it.max()!! } + 1) { n }    allPossibleSums[0] = -1    for (i in possibleSums.indices) {        for (x in possibleSums[i]) {            for (w in x until allPossibleSums.size) {                if (allPossibleSums[w - x] < i && allPossibleSums[w] > i) allPossibleSums[w] = i            }        }    }    println(allPossibleSums.indices.filter { allPossibleSums[it] < n }.filter { it % k == 0 }.max()!!)} fun findPossibleSums(a: IntArray, maxOps: Int): IntArray {    val result = IntArray(a.sum() + 1) { if (it == 0) 0 else a.size }    for (x in a) {        for (i in (x until result.size).reversed()) {            result[i] = minOf(result[i], result[i - x] + 1)        }    }    return result.indices.filter { result[it] <= maxOps }.toIntArray()} fun readLong() = readLine()!!.toLong()fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() }fun readIntArray() = readInts().toIntArray()",dp
"import kotlin.math.max fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main() {    val (n, m, k) = readInts()    val vs = (1..n).map { readInts() }     var options = IntArray(k) { Integer.MIN_VALUE }    options[0] = 0     for (row in vs) {        val rowOptions = pick(row, m/2, k)         val newOptions = IntArray(k) { Integer.MIN_VALUE }        for (i in 0 until k) {            if (options[i] == Integer.MIN_VALUE) continue            for (j in 0 until k) {                if (rowOptions[j] == Integer.MIN_VALUE) continue                newOptions[(i + j) % k] = max(newOptions[(i + j) % k], options[i] + rowOptions[j])            }        }        options = newOptions    }     println(options[0])} fun pick(vs: List<Int>, n: Int, k: Int): IntArray {    // dp_[i][r] = x where:    // x is the largest number that can be obtained in 'i' steps from numbers from 'vs' and x % k == r     val dp = Array(n+1) { IntArray(k) { Integer.MIN_VALUE }}    dp[0][0] = 0     // 70*70*70 = 343,000    for (v in vs) {        for (i in n-1 downTo 0) {            for (r in 0 until k) {                if (dp[i][r] != Integer.MIN_VALUE) {                    dp[i+1][(r + v) % k] = max(dp[i+1][(r + v) % k], dp[i][r] + v)                }            }        }    }     val res = IntArray(k) { Integer.MIN_VALUE }    for (r in 0 until k) {        for (i in 0..n) {            res[r] = max(res[r], dp[i][r])        }    }    return res}",dp
"fun main() {	val MOD = 998244353		fun add(x : Int, y : Int) : Int {		return x + y - if (x + y < MOD) 0 else MOD		}		fun mul(x : Int, y : Int) : Int {		return (1L * x * y % MOD).toInt()	}		val inv = IntArray(60) { 0 }.also { it[0] = 1; it[1] = (MOD + 1) / 2 }	for (i in 2 until 60) {		inv[i] = mul(inv[i - 1], inv[1])	}		val n = readLine()!!.toInt()	val a =	readLine()!!.split("" "").map { it.toLong() }	val target = a.fold(0.toLong()) { res, it -> res xor it }	val dp = Array(n) { Array(2) { IntArray(2) { 0 } } }		var ans = 0		val m = 1 shl (n - 1)	for (mask in 0 until m) {		val cur = Array(n - 1) { longArrayOf(a[it], a[it + 1]) }		val used = BooleanArray(n - 1) { false }				for (pw in 59 downTo 0) {			for (i in 0 until n)				for (cnt in 0 until 2)					for (fl in 0 until 2)						dp[i][cnt][fl] = 0			dp[0][0][0] = 1			for (i in 0 until n - 1) {				for (cnt in 0 until 2) {					for (fl in 0 until 2) {						if (dp[i][cnt][fl] == 0)							continue						val (l, r) = cur[i]						if ((l shr pw) == (r shr pw)) {							if (!used[i] && ((mask shr i) and 1) == 1)								continue							val c = (l shr pw).toInt()							val len = (cur[i][1] - cur[i][0] + 1)							dp[i + 1][cnt xor c][fl] = add(dp[i + 1][cnt xor c][fl], mul((len % MOD).toInt(), dp[i][cnt][fl]))						} else for (c in 0 until 2) {							if (!used[i] && (c != (mask shr i) and 1))								continue							val nl = if (c == 1) 0L else l							var nr = if (c == 1) r - (1L shl pw) else (1L shl pw) - 1							val len = nr - nl + 1							val nfl = if (len == (1L shl pw) && (c != ((mask shr i) and 1))) 1 else 0							dp[i + 1][cnt xor c][fl or nfl] = add(dp[i + 1][cnt xor c][fl or nfl], mul((len % MOD).toInt(), dp[i][cnt][fl]))						}					}				}			}						var cnt = ((target shr pw) and 1).toInt()			ans = add(ans, mul(dp[n - 1][cnt][1], inv[pw]))			if (pw == 0) 				ans = add(ans, dp[n - 1][cnt][0])						for (i in 0 until n - 1) {				val (l, r) = cur[i]				if ((l shr pw) == (r shr pw)) {					val c = (l shr pw)					cnt = cnt xor c.toInt()					cur[i][0] -= c shl pw					cur[i][1] -= c shl pw				} else {					used[i] = true					val c = (mask shr i) and 1					cnt = cnt xor c.toInt()					cur[i][0] = if (c == 1) 0 else cur[i][0]					cur[i][1] = if (c == 1) cur[i][1] - (1L shl pw) else (1L shl pw) - 1				}			}						if (cnt != 0)				break		}	}		println(ans)}	  	  			 	   	 	  			   	 	  	","*special,dp"
"fun main() {	val MOD = 998244353		fun add(x : Int, y : Int) : Int {		return x + y - if (x + y < MOD) 0 else MOD		}		fun mul(x : Int, y : Int) : Int {		return (1L * x * y % MOD).toInt()	}		val inv = IntArray(60) { 0 }.also { it[0] = 1; it[1] = (MOD + 1) / 2 }	for (i in 2 until 60) {		inv[i] = mul(inv[i - 1], inv[1])	}		val n = readLine()!!.toInt()	val a =	readLine()!!.split("" "").map { it.toLong() }	val target = a.fold(0.toLong()) { res, it -> res xor it }	val dp = Array(n) { Array(2) { IntArray(2) { 0 } } }		var ans = 0		val m = 1 shl (n - 1)	for (mask in 0 until m) {		val cur = Array(n - 1) { longArrayOf(a[it], a[it + 1]) }		val used = BooleanArray(n - 1) { false }				for (pw in 59 downTo 0) {			for (i in 0 until n)				for (cnt in 0 until 2)					for (fl in 0 until 2)						dp[i][cnt][fl] = 0			dp[0][0][0] = 1			for (i in 0 until n - 1) {				for (cnt in 0 until 2) {					for (fl in 0 until 2) {						if (dp[i][cnt][fl] == 0)							continue						val (l, r) = cur[i]						if ((l shr pw) == (r shr pw)) {							if (!used[i] && ((mask shr i) and 1) == 1)								continue							val c = (l shr pw).toInt()							val len = (cur[i][1] - cur[i][0] + 1)							dp[i + 1][cnt xor c][fl] = add(dp[i + 1][cnt xor c][fl], mul((len % MOD).toInt(), dp[i][cnt][fl]))						} else for (c in 0 until 2) {							if (!used[i] && (c != (mask shr i) and 1))								continue							val nl = if (c == 1) 0L else l							var nr = if (c == 1) r - (1L shl pw) else (1L shl pw) - 1							val len = nr - nl + 1							val nfl = if (len == (1L shl pw) && (c != ((mask shr i) and 1))) 1 else 0							dp[i + 1][cnt xor c][fl or nfl] = add(dp[i + 1][cnt xor c][fl or nfl], mul((len % MOD).toInt(), dp[i][cnt][fl]))						}					}				}			}						var cnt = ((target shr pw) and 1).toInt()			ans = add(ans, mul(dp[n - 1][cnt][1], inv[pw]))			if (pw == 0) 				ans = add(ans, dp[n - 1][cnt][0])						for (i in 0 until n - 1) {				val (l, r) = cur[i]				if ((l shr pw) == (r shr pw)) {					val c = (l shr pw)					cnt = cnt xor c.toInt()					cur[i][0] -= c shl pw					cur[i][1] -= c shl pw				} else {					used[i] = true					val c = (mask shr i) and 1					cnt = cnt xor c.toInt()					cur[i][0] = if (c == 1) 0 else cur[i][0]					cur[i][1] = if (c == 1) cur[i][1] - (1L shl pw) else (1L shl pw) - 1				}			}						if (cnt != 0)				break		}	}		println(ans)}////	  	  			  			 	 	 					    	 	","*special,dp"
"fun main() { val MOD = 998244353  fun add(x : Int, y : Int) : Int {  return x + y - if (x + y < MOD) 0 else MOD  }  fun mul(x : Int, y : Int) : Int {  return (1L * x * y % MOD).toInt() }  val inv = IntArray(60) { 0 }.also { it[0] = 1; it[1] = (MOD + 1) / 2 } for (i in 2 until 60) {  inv[i] = mul(inv[i - 1], inv[1]) }  val n = readLine()!!.toInt() val a = readLine()!!.split("" "").map { it.toLong() } val target = a.fold(0.toLong()) { res, it -> res xor it } val dp = Array(n) { Array(2) { IntArray(2) { 0 } } }  var ans = 0  val m = 1 shl (n - 1) for (mask in 0 until m) {  val cur = Array(n - 1) { longArrayOf(a[it], a[it + 1]) }  val used = BooleanArray(n - 1) { false }    for (pw in 59 downTo 0) {   for (i in 0 until n)    for (cnt in 0 until 2)     for (fl in 0 until 2)      dp[i][cnt][fl] = 0   dp[0][0][0] = 1   for (i in 0 until n - 1) {    for (cnt in 0 until 2) {     for (fl in 0 until 2) {      if (dp[i][cnt][fl] == 0)       continue      val (l, r) = cur[i]      if ((l shr pw) == (r shr pw)) {       if (!used[i] && ((mask shr i) and 1) == 1)        continue       val c = (l shr pw).toInt()       val len = (cur[i][1] - cur[i][0] + 1)       dp[i + 1][cnt xor c][fl] = add(dp[i + 1][cnt xor c][fl], mul((len % MOD).toInt(), dp[i][cnt][fl]))      } else for (c in 0 until 2) {       if (!used[i] && (c != (mask shr i) and 1))        continue       val nl = if (c == 1) 0L else l       var nr = if (c == 1) r - (1L shl pw) else (1L shl pw) - 1       val len = nr - nl + 1       val nfl = if (len == (1L shl pw) && (c != ((mask shr i) and 1))) 1 else 0       dp[i + 1][cnt xor c][fl or nfl] = add(dp[i + 1][cnt xor c][fl or nfl], mul((len % MOD).toInt(), dp[i][cnt][fl]))      }     }    }   }      var cnt = ((target shr pw) and 1).toInt()   ans = add(ans, mul(dp[n - 1][cnt][1], inv[pw]))   if (pw == 0)     ans = add(ans, dp[n - 1][cnt][0])      for (i in 0 until n - 1) {    val (l, r) = cur[i]    if ((l shr pw) == (r shr pw)) {     val c = (l shr pw)     cnt = cnt xor c.toInt()     cur[i][0] -= c shl pw     cur[i][1] -= c shl pw    } else {     used[i] = true     val c = (mask shr i) and 1     cnt = cnt xor c.toInt()     cur[i][0] = if (c == 1) 0 else cur[i][0]     cur[i][1] = if (c == 1) cur[i][1] - (1L shl pw) else (1L shl pw) - 1    }   }      if (cnt != 0)    break  } }  println(ans)}","*special,dp"
"fun main() {	val MOD = 998244353		fun add(x : Int, y : Int) : Int {		return x + y - if (x + y < MOD) 0 else MOD		}		fun mul(x : Int, y : Int) : Int {		return (1L * x * y % MOD).toInt()	}		val inv = IntArray(60) { 0 }.also { it[0] = 1; it[1] = (MOD + 1) / 2 }	for (i in 2 until 60) {		inv[i] = mul(inv[i - 1], inv[1])	}		val n = readLine()!!.toInt()	val a =	readLine()!!.split("" "").map { it.toLong() }	val target = a.fold(0.toLong()) { res, it -> res xor it }	val dp = Array(n) { Array(2) { IntArray(2) { 0 } } }		var ans = 0		val m = 1 shl (n - 1)	for (mask in 0 until m) {		val cur = Array(n - 1) { longArrayOf(a[it], a[it + 1]) }		val used = BooleanArray(n - 1) { false }				for (pw in 59 downTo 0) {			for (i in 0 until n)				for (cnt in 0 until 2)					for (fl in 0 until 2)						dp[i][cnt][fl] = 0			dp[0][0][0] = 1			for (i in 0 until n - 1) {				for (cnt in 0 until 2) {					for (fl in 0 until 2) {						if (dp[i][cnt][fl] == 0)							continue						val (l, r) = cur[i]						if ((l shr pw) == (r shr pw)) {							if (!used[i] && ((mask shr i) and 1) == 1)								continue							val c = (l shr pw).toInt()							val len = (cur[i][1] - cur[i][0] + 1)							dp[i + 1][cnt xor c][fl] = add(dp[i + 1][cnt xor c][fl], mul((len % MOD).toInt(), dp[i][cnt][fl]))						} else for (c in 0 until 2) {							if (!used[i] && (c != (mask shr i) and 1))								continue							val nl = if (c == 1) 0L else l							var nr = if (c == 1) r - (1L shl pw) else (1L shl pw) - 1							val len = nr - nl + 1							val nfl = if (len == (1L shl pw) && (c != ((mask shr i) and 1))) 1 else 0							dp[i + 1][cnt xor c][fl or nfl] = add(dp[i + 1][cnt xor c][fl or nfl], mul((len % MOD).toInt(), dp[i][cnt][fl]))						}					}				}			}						var cnt = ((target shr pw) and 1).toInt()			ans = add(ans, mul(dp[n - 1][cnt][1], inv[pw]))			if (pw == 0) 				ans = add(ans, dp[n - 1][cnt][0])						for (i in 0 until n - 1) {				val (l, r) = cur[i]				if ((l shr pw) == (r shr pw)) {					val c = (l shr pw)					cnt = cnt xor c.toInt()					cur[i][0] -= c shl pw					cur[i][1] -= c shl pw				} else {					used[i] = true					val c = (mask shr i) and 1					cnt = cnt xor c.toInt()					cur[i][0] = if (c == 1) 0 else cur[i][0]					cur[i][1] = if (c == 1) cur[i][1] - (1L shl pw) else (1L shl pw) - 1				}			}						if (cnt != 0)				break		}	}		println(ans)}","*special,dp"
"import java.lang.Long.maxfun main() {val (N, M, K) = readLine()!!.split(' ').map { it.toInt() };val A = readLine()!!.split(' ').map { it.toLong() };val B = readLine()!!.split(' ').map { it.toLong() }    val C = (0 until N).map { readLine()!!.split(' ').map { it.toLong() } };val AOpen = (0 until N).map { i -> A[i] to (0 until B.count { it <= A[i] }).map { j -> C[i][j] }.max()!!}    val BOpen = (0 until M).map { i -> B[i] to (0 until A.count { it <= B[i] }).map { j -> C[j][i] }.max()!!};val open = (AOpen + BOpen).sortedBy { it.first }    val ans = (0 until N+M).map { i -> var ans = 0L;var cur = 0L;var mx = open[0].second + (if (i == 0) K else 0)        (1 until N+M).forEach {val missing = (open[it].first - cur + mx - 1) / mx;cur += missing * mx;ans += missing;var self = open[it].second + (if (i == it) K else 0);mx = max(mx, self)}        ans}.min();println(ans)}","*special,brute force,greedy,two pointers"
"import java.lang.Long.maxfun main() {val (N, M, K) = readLine()!!.split(' ').map { it.toInt() };val A = readLine()!!.split(' ').map { it.toLong() };val B = readLine()!!.split(' ').map { it.toLong() }    val C = (0 until N).map { readLine()!!.split(' ').map { it.toLong() } };val AOpen = (0 until N).map { i -> A[i] to (0 until B.count { it <= A[i] }).map { j -> C[i][j] }.max()!!}    val BOpen = (0 until M).map { i -> B[i] to (0 until A.count { it <= B[i] }).map { j -> C[j][i] }.max()!!};val open = (AOpen + BOpen).sortedBy { it.first }    val ans = (0 until N+M).map { i -> var ans = 0L;var cur = 0L;var mx = open[0].second + (if (i == 0) K else 0)        (1 until N+M).forEach {val missing = (open[it].first - cur + mx - 1) / mx;cur += missing * mx;ans += missing;var self = open[it].second + (if (i == it) K else 0);mx = max(mx, self)}        ans}.min();println(ans)}","*special,brute force,greedy,two pointers"
"import java.lang.Long.maxfun main() {val (N, M, K) = readLine()!!.split(' ').map { it.toInt() };val A = readLine()!!.split(' ').map { it.toLong() };val B = readLine()!!.split(' ').map { it.toLong() }    val C = (0 until N).map { readLine()!!.split(' ').map { it.toLong() } };val AOpen = (0 until N).map { i -> A[i] to (0 until B.count { it <= A[i] }).map { j -> C[i][j] }.max()!!}    val BOpen = (0 until M).map { i -> B[i] to (0 until A.count { it <= B[i] }).map { j -> C[j][i] }.max()!!};val open = (AOpen + BOpen).sortedBy { it.first }    val ans = (0 until N+M).map { i -> var ans = 0L;var cur = 0L;var mx = open[0].second + (if (i == 0) K else 0)        (1 until N+M).forEach {val missing = (open[it].first - cur + mx - 1) / mx;cur += missing * mx;ans += missing;var self = open[it].second + (if (i == it) K else 0);mx = max(mx, self)}        ans}.min();println(ans)}","*special,brute force,greedy,two pointers"
"import java.lang.Long.maxfun main() {val (N, M, K) = readLine()!!.split(' ').map { it.toInt() };val A = readLine()!!.split(' ').map { it.toLong() };val B = readLine()!!.split(' ').map { it.toLong() }    val C = (0 until N).map { readLine()!!.split(' ').map { it.toLong() } };val AOpen = (0 until N).map { i -> A[i] to (0 until B.count { it <= A[i] }).map { j -> C[i][j] }.max()!!}    val BOpen = (0 until M).map { i -> B[i] to (0 until A.count { it <= B[i] }).map { j -> C[j][i] }.max()!!};val open = (AOpen + BOpen).sortedBy { it.first }    val ans = (0 until N+M).map { i -> var ans = 0L;var cur = 0L;var mx = open[0].second + (if (i == 0) K else 0)        (1 until N+M).forEach {val missing = (open[it].first - cur + mx - 1) / mx;cur += missing * mx;ans += missing;var self = open[it].second + (if (i == it) K else 0);mx = max(mx, self)}        ans}.min();println(ans)}","*special,brute force,greedy,two pointers"
"fun read() = readLine()!!.split("" "").map { it.toLong() }fun main() = repeat(readLine()!!.toInt()) {    val (n, k) = read().map { it.toInt() }    val a = read().toMutableList()    a.sortDescending()    for (i in 1 until minOf(n, k + 1))        a[0] += a[i]    println(a[0])}","greedy,implementation,sortings"
"fun main(args: Array<String>) {    val t = getInt()    repeat(t) {        val (n, k) = getInts()        val a = getLongs().sortedDescending()        val s = a.take(Math.min(k + 1, a.size)).sum()        println(s)    }} fun getInt() = readLine()!!.toInt()fun getInts() = readLine()!!.split("" "").map { it.toInt() }fun getLong() = readLine()!!.toLong()fun getLongs() = readLine()!!.split("" "").map { it.toLong() }","greedy,implementation,sortings"
"fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() }fun readLongs() = readLine()!!.split(' ').map { it.toLong() } fun main() {    repeat(readInt()) {        val (n, k) = readInts()        val vs = readLongs().sortedDescending()         if (k == 0) {            println(vs.first() - vs.last())        } else {            println(vs.take(k+1).sum())        }    }}","greedy,implementation,sortings"
"/** * Accomplished using the EduTools plugin by JetBrains https://plugins.jetbrains.com/plugin/10081-edutools */ fun main() {    repeat(readLine()!!.toInt()) {        val (n,k) = readLine()!!.split("" "").map { it.toInt() }        val a = readLine()!!.split("" "").map { it.toLong() }.sortedDescending()         var ans:Long = a[0]         for (i in 1..k) {            ans+=a[i]        }         println(ans)    }}","greedy,implementation,sortings"
"import java.util.Scanner fun main(){	val sc = Scanner(System.`in`)	val n = sc.nextInt()	var (a,b) = listOf(Array(n,{sc.nextInt()}),Array(n,{0}))	var (k,cnt) = listOf(0,0)	a.sort()	for(i in 1..n-1 step 2) b[i] = a[k++]	for(i in 0..n-1 step 2) b[i] = a[k++]	for(i in 1..n-2) if(b[i] < b[i-1] && b[i] < b[i+1]) cnt++	println(cnt)	for(i in 0..n-1) print(""${b[i]} "")}","binary search,brute force,constructive algorithms,greedy,sortings,two pointers"
"fun main() {    val n = readLine()!!.toInt()    val a = readLine()!!.split(' ').map(String::toInt).sorted()    val result = MutableList(n) { 0 }    var l = 0    var r = n / 2    var i = 0    while (i < n) {        if (i % 2 == 0) {            result[i++] = a[r++]        } else {            result[i++] = a[l++]        }    }    var sum = 0    for (j in 1..(n - 2)) {        if (result[j] < result[j - 1] && result[j] < result[j + 1]) sum++    }    println(sum)    println(result.joinToString("" ""))}","binary search,brute force,constructive algorithms,greedy,sortings,two pointers"
"import java.util.*import kotlin.collections.ArrayList fun main() {    val scanner = Scanner(System.`in`)//    val scanner = Scanner(File(""input.txt""))     val n = scanner.nextInt()    val a = IntArray(n)    for (i in 0 until n) {        a[i] = scanner.nextInt()    }     a.sort()    val mid = n / 2     val result = ArrayList<Int>(n)    for (i in 0..mid) {        if (mid + i < n) {            result += a[mid + i]        }        if (i < mid) {            result += a[i]        }    }     var count = 0    for (i in 1 until (n - 1)) {        if (result[i] < result[i - 1] && result[i] < result[i + 1]) {            count++        }    }     println(count)    println(result.joinToString("" ""))}","binary search,brute force,constructive algorithms,greedy,sortings,two pointers"
"import java.util.*  fun main() {    val debug = true    val sc = Scanner(System.`in`)    //val sc = Scanner(File(""input.txt""))     val T = 1      repeat(T) {        val n = sc.nextInt()        val a = LongArray(n) { sc.nextLong() }         a.sort()         val result = LongArray(n)         var j = 0         for(i in 0 until (n / 2)) {            result[j++] = a[i + n / 2]            result[j++] = a[i]        }         if(n % 2 == 1)            result[j] = a[n-1]         var count = 0        for(i in 1 until n - 1) {            if(result[i] < result[i - 1] && result[i] < result[i + 1]) {                count++            }        }         println(count)        for(v in result) {            print(""$v "")        }    }}  // nice stair size -> 1 3 7 15// ni = n(i - 1) * 2 + 1  ","binary search,brute force,constructive algorithms,greedy,sortings,two pointers"
"fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()        val graph = Array<MutableList<Int>>(n) { mutableListOf() }        for (edge in 1 until n) {            val (x, y) = readLine()!!.split(' ').map { it.toInt() - 1 }            graph[x].add(y)            graph[y].add(x)        }        val root = graph.indices.find { graph[it].size == 1 }!!        val size = IntArray(n) { 1 }        fun dfs(cur: Int, prev: Int): Int {            for (next in graph[cur]) if (prev != next) size[cur] += dfs(next, cur)            return size[cur]        }        dfs(root, root)        fun findCentroid(cur: Int, prev: Int): Int {            val maxChild = graph[cur].filter { it != prev }.maxBy { size[it] }!!            if (size[maxChild] * 2 >= n) return findCentroid(maxChild, cur)            return cur        }        val centroid = findCentroid(root, root)        if (size[centroid] * 2 > n) {            println(""${root + 1} ${graph[root][0] + 1}\n${root + 1} ${graph[root][0] + 1}"")        } else {            println(""${root + 1} ${graph[root][0] + 1}\n${root + 1} ${centroid + 1}"")        }    }}","constructive algorithms,dfs and similar,graphs,trees"
"import java.io.*import java.util.*import kotlin.math.* fun main(){	val f = BufferedReader(InputStreamReader(System.`in`)) 	for(q in 1..f.readLine().toInt()){		val n = f.readLine().toInt() 		val adj = Array(n+1){mutableListOf<Int>()}		for(k in 0 until n-1){			val (a,b) = f.readLine().split("" "").map{it.toInt()}			adj[a].add(b)			adj[b].add(a)		} 		if(n%2 == 1){			println(""1 ${adj[1][0]}"")			println(""1 ${adj[1][0]}"")			continue		} 		val subsums = IntArray(n+1){0}		val parents = IntArray(n+1){0}		fun dfs(v : Int,p : Int){			subsums[v] = 1			parents[v] = p			for(nei in adj[v]){				if(nei == p) continue				dfs(nei,v)				subsums[v] += subsums[nei]			}		} 		dfs(1,-1) 		//get centroids		var c1 = -1		var c2 = -1   		for(k in 2..n){			if(subsums[k] == n/2){				c1 = k				c2 = parents[k]				continue			} 		} 		if(c2 == -1){			//already unique centroid			println(""1 ${adj[1][0]}"")			println(""1 ${adj[1][0]}"")		} else { 			//dfs from c1 and find a leaf			var leaf = -1			fun dfs2(v : Int, p : Int){				if(adj[v].size == 1){					leaf = v					return				} 				for(nei in adj[v]){					if(nei == p) continue					dfs2(nei,v)				}			} 			dfs2(c1,parents[c1]) 			println(""$leaf ${adj[leaf][0]}"")			println(""$leaf $c2"")		}  	}}","constructive algorithms,dfs and similar,graphs,trees"
"import kotlin.math.max fun main() {    val t = readLine()!!.toInt()    repeat(t) {        val n = readLine()!!.toInt()        val edges = List(n + 1) { mutableListOf<Int>() }//        val maxComponent = MutableList(n + 1) { 0 }//        val size = MutableList(n + 1) { 0 }        var minX = Int.MAX_VALUE        var minV = mutableListOf<Int>()         repeat(n - 1) {            val (i, j) = readLine()!!.split(' ').map(String::toInt)            edges[i].add(j)            edges[j].add(i)        }         fun dfs(parent: Int, x: Int): Int {            var result = 0            var sum = 1            for (child in edges[x]) {                if (child != parent) {                    val childValue = dfs(x, child)                    sum += childValue                    result = max(result, childValue)                }            }            result = max(result, n - sum)            if (result == minX) {                minV.add(x)            } else if (result < minX) {                minX = result                minV = mutableListOf(x)            } //            maxComponent[x] = result//            size[x] = sum            return sum        }         dfs(-1, 1)//        println(maxComponent)//        println(size)         if (minV.size == 1) {            val x = minV.first()            val other = edges[x].first()            println(""$x $other"")            println(""$x $other"")        } else {            val x = minV[0]            val y = minV[1]            val other = edges[x].first { it != y }            println(""$x $other"")            println(""$y $other"")        }    }}","constructive algorithms,dfs and similar,graphs,trees"
"import kotlin.math.*import java.io.* private fun BufferedReader.readLn() = readLine()!! // string lineprivate fun BufferedReader.readInt() = readLn().toInt() // single intprivate fun BufferedReader.readStrings() = readLn().split("" "") // list of stringsprivate fun BufferedReader.readInts() = readStrings().map { it.toInt()}.toMutableList() // list of ints fun centroid (graph: Array<MutableList<Int>>, n: Int): MutableList<Int>{	val result = mutableListOf<Int>() 	val size = IntArray(n){0} 	fun dfs(u: Int, p: Int){		size[u] = 1 		var isCentroid = true		for (v in graph[u]){			if (v != p){				dfs(v,u)				size[u] += size[v]				if (size[v] > n/2){					isCentroid = false				}			}		} 		if (n - size[u] > n/2) isCentroid = false		if (isCentroid){			result.add(u)		}	} 	dfs(0, -1) 	return result} fun main(){    val rd = BufferedReader(InputStreamReader(System.`in`))     val numCase = rd.readInt()     repeat(numCase){    	val n = rd.readInt()     	val graph = Array<MutableList<Int>>(n){mutableListOf<Int>()}     	repeat(n - 1){    		val l = rd.readInts()     		graph[l[0] - 1].add(l[1] - 1)    		graph[l[1] - 1].add(l[0] - 1)    	}     	val centroids = centroid(graph, n)     	if (centroids.size == 1){    		println(""${centroids[0] + 1} ${graph[centroids[0]][0] + 1}"")    		println(""${centroids[0] + 1} ${graph[centroids[0]][0] + 1}"")    	}    	else{    		val A = centroids[0]    		val B = centroids[1]     		var v = 0     		for (u in graph[A]){    			if (u != B){    				v = u    				break    			}    		}     		println(""${A + 1} ${v + 1}"")    		println(""${B + 1} ${v + 1}"")    	}    } }","constructive algorithms,dfs and similar,graphs,trees"
"import kotlin.math.absimport kotlin.math.min fun main() {    val n = readLine()!!.toInt()    val a = readLine()!!.split(' ').map(String::toLong).sorted()     fun solve(): Long {        var result = a.sumOf { it - 1L }        var c = 2L        while (true) {            var r = 0L            var x = 1L            for (i in 0 until n) {                r += abs(a[i] - x)                x *= c                if (r > result) return result            }            result = min(result, r)            c++        }    }     println(solve())}","brute force,math,number theory,sortings"
"fun main() {    val n = readLine()!!.toInt()    val a = readLine()!!.split("" "").map { it.toInt() }.sorted()     var cost: Long = 0     if(n==2) {        cost+=Math.abs(a[0] - 1)        println(cost)        return    }     for (i in 0 until n) {        cost += Math.abs(a[i] - 1)    }     for (i in 2..31623) {        var temp: Long = 0        var x : Long = 1        var j = 0        while(j < n && temp < cost) {            temp +=Math.abs(a[j] - x)            x *=i            j++        }        cost = minOf(temp, cost)    }     println(cost) }  ","brute force,math,number theory,sortings"
import kotlin.math.abs fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main() {    readInt()    val vs = readInts().sorted()    println(solve(vs))} fun solve(vs: List<Int>): Long {    var best: Long? = null    var c = 1L    while (true) {        var pow = 1L        var res = 0L        for (v in vs) {            res += abs(pow - v)            if (pow.toDouble() * pow.toDouble() >= 9000000000000000000) return best!!            pow *= c        }         if (best == null || res <= best) {            best = res        } else if (abs(pow/c - vs.last()) >= best) {            break        }        c++    }    return best!!},"brute force,math,number theory,sortings"
fun main() {    val n = readLine()!!.toInt()    if (n <= 2) {        println(readLine()!!.split(' ').map { it.toInt() }.take(1).sum() - 1)        return    }    if (n > 32){        println(readLine()!!.split(' ').map { it.toLong() }.sum() - n)        return    }    val a = readLine()!!.split(' ').map { it.toLong() }.toLongArray()    a.sort()    var prev = a.sum()    for (c in 1..1_000_000_000) {        val powers = LongArray(n) { 1 }        for (p in 1 until n) powers[p] = powers[p - 1] * c        val ans = a.zip(powers).map { kotlin.math.abs(it.first - it.second) }.sum()        if (ans > prev){            println(prev)            return        } else {            prev = ans        }    }},"brute force,math,number theory,sortings"
"fun main() {    val out = StringBuilder()    for (c in 1..readLine()!!.toInt()) {        val (n, m) = readLine()!!.split("" "").map { it.toInt() }        val belt = Array(n) { readLine()!! }        out.appendln((0..m - 2).count { belt[n - 1][it] == 'D' } + (0..n - 2).count { belt[it][m - 1] == 'R' })    }    print(out)}","brute force,greedy,implementation"
"fun main() {    fun readInt() = readLine()!!.toInt()    fun readInts() = readLine()!!.split("" "").map(String::toInt)     repeat(readInt()) {        val (numRows, _) = readInts()        var sol = 0        for (row in 0 until numRows - 1) if(readLine()!!.last() == 'R') sol++        for (cell in readLine()!!) if (cell == 'D') sol++        println(sol)    }}","brute force,greedy,implementation"
import java.lang.Math.maximport java.util.*  fun main(args: Array<String>): Unit = with(Scanner(System.`in`)) {    repeat(nextInt()) {        val n = nextInt()        val m = nextInt()        val f = (0 until n - 1).map { next() }.count { it[it.length - 1] != 'D' }        val cc = next().count { it != 'R' } - 1        println(f + cc)      }}  ,"brute force,greedy,implementation"
"import java.io.BufferedReaderimport java.io.InputStreamReader fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val out = StringBuilder()    for (c in 1..jin.readLine().toInt()) {        val (n, m) = jin.readLine().split("" "").map { it.toInt() }        val belt = Array(n) { jin.readLine() }        out.appendln((0..m - 2).count { belt[n - 1][it] == 'D' } + (0..n - 2).count { belt[it][m - 1] == 'R' })    }    print(out)}","brute force,greedy,implementation"
"fun main() {    fun readInt() = readLine()!!.toInt()     for (testCase in 0 until readInt()) println((1..readInt()).joinToString("" ""))}","constructive algorithms,math"
"fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()        for (i in 1..n) print(""$i "")        println()    }}","constructive algorithms,math"
"fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()         println((1..n).joinToString(separator = "" ""))    }}","constructive algorithms,math"
"fun main() {    val t = readLine()!!.toInt()    repeat(t) {        val n = readLine()!!.toInt()        val ans = 1..n        println(ans.joinToString("" ""))    }}  ","constructive algorithms,math"
"fun main() {    val t = readLine()!!.toInt()    for (i in 1..t) {        val n = readLine()!!.toInt()        val a = readLine()!!.split("" "").map { it.toInt() }.toIntArray()        var pos = n - 1        while (pos > 0 && a[pos - 1] >= a[pos]) --pos        while (pos > 0 && a[pos - 1] <= a[pos]) --pos        println(pos)    }}",greedy
"fun main() {    fun readInt() = readLine()!!.toInt()    fun readInts() = readLine()!!.split("" "").map(String::toInt)     repeat(readInt()) {        readLine()        val arr = readInts()        var pos = arr.lastIndex        while (pos > 0 && arr[pos] <= arr[pos - 1]) pos--        while (pos > 0 && arr[pos] >= arr[pos - 1]) pos--        println(pos)    }}",greedy
"fun main() {    val r = System.`in`.bufferedReader()    repeat(r.readLine()!!.toInt()) {        val size = r.readLine()!!.toInt()        val arr = r.readLine()!!.split("" "").map { it.toInt() }.toIntArray()        var index = size - 1        while (index > 0 && arr[index] <= arr[index - 1]) index -= 1        while (index > 0 && arr[index] >= arr[index - 1]) index -= 1        println(index)    }}",greedy
"fun solve(){    val n = readLine()!!.toInt()    var arr = readLine()!!.split("" "").map{it.toInt()}    arr = arr.reversed()    var i = 0    while(i+1 < arr.size && arr[i] <= arr[i+1])        i++    while(i+1 < arr.size && arr[i] >= arr[i+1])        i++    print(""${arr.size - i-1}\n"")}  fun main(){    var q = readLine()!!.toInt()    while(q-- > 0)    {        solve()    }}",greedy
"fun main() {    repeat(readLine()!!.toInt()) {        readLine()        readLine()!!.split("" "").toSet().forEach { print(""$it "") }        println()    }}",greedy
"fun main() {    val r = System.`in`.bufferedReader()    repeat(r.readLine()!!.toInt()) {        r.readLine()        val set = r.readLine()!!.split("" "").map { it.toInt() }.toSet()        println(set.joinToString("" ""))    }}",greedy
"import java.util.* fun main() {     val scanner = Scanner(System.`in`)     (0 until scanner.nextInt()).forEach {         println((0 until 2 * scanner.nextInt()).map { scanner.nextInt() }.distinct().joinToString(separator = "" ""))     } }",greedy
"fun main() {    val r = System.`in`.bufferedReader()    repeat(r.readLine()!!.toInt()) {        val length = r.readLine()!!.toInt()        val set = r.readLine()!!.split("" "").map { it.toInt() }.toSet()        println(set.joinToString("" ""))    }}",greedy
"fun main() {    val t = readLine()!!.toInt()    repeat(t) {        val n = readLine()!!.toInt()        val a = readLine()!!.split("" "").map(String::toLong)        val resultList = a.dropWhile { it == 1L }        if (((n - resultList.size) % 2 == 0) xor resultList.isEmpty()) {            println(""First"")        } else {            println(""Second"")        }    }}","dp,games"
"fun main() {    val cases = readLine()!!.toInt()    for (i in 1..cases) {        val n = readLine()!!.toInt()        val a = readLine()!!.split(' ').map { it.toInt() }        var count : Int? = null        for (j in 0 until n) {            if (a[j] != 1) {                count = j                break            }        }        println(if (if (count == null) n % 2 == 1 else count % 2 == 0) ""First"" else ""Second"")    }}","dp,games"
"val read = { readLine()!!.split("" "").mapNotNull { it.toIntOrNull() } }fun main() {    val (t) = read()    repeat(t) {        val (n) = read()        val list = read()        var firstWin = true        for(i in list.lastIndex-1 downTo 0) {            if(firstWin)                firstWin = list[i] > 1            else {                firstWin = true            }        }        println(if(firstWin) ""First"" else ""Second"")    }}","dp,games"
"import java.util.*import kotlin.math.ceilimport kotlin.math.max  fun main(args: Array<String>): Unit = with(Scanner(System.`in`)) {  repeat(nextInt()) {    val n = nextInt()     val a = (0 until n).map { nextInt() }.toList()    var r = true    for (i in (0 until n - 1)) {      if (a[i] == 1) {        r = !r      } else {        break      }    }     if (r) {      println(""First"")    } else {      println(""Second"")    }    }}","dp,games"
"import java.io.BufferedReaderimport java.io.InputStreamReader fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val (n, m) = jin.readLine().split("" "").map { it.toInt() }    val places = jin.readLine().split("" "").map { it.toInt() }.toIntArray()    val towers = Array(m + 1) { mutableListOf<Int>() }    val union = IntArray(m + 1) { it }    for (k in 0 until n) {        towers[places[k]].add(k)    }    fun getUnion(u: Int): Int {        if (union[union[u]] != union[u]) {            union[u] = getUnion(union[u])        }        return union[u]    }    var curr = (1 until n).count { places[it - 1] != places[it] }    val out = StringBuilder()    out.appendln(curr)    for (j in 1 until m) {        var (a, b) = jin.readLine().split("" "").map { it.toInt() }        a = getUnion(a)        b = getUnion(b)        if (towers[a].size > towers[b].size) {            val c = a            a = b            b = c        }        for (k in towers[a]) {            if (k > 0 && getUnion(places[k - 1]) == b) {                curr--            }            if (k < n - 1 && getUnion(places[k + 1]) == b) {                curr--            }            towers[b].add(k)        }        union[a] = b        out.appendln(curr)    }    print(out)}","data structures,dsu,implementation,trees"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.*import kotlin.system.measureTimeMillis fun BufferedReader.readInts() = this.readLine()!!.split(' ').map { it.toInt() } fun main() {    val bin = BufferedReader(InputStreamReader(System.`in`))    val (n, m) = bin.readInts()    val ti = bin.readInts()    val moves = (1 until m).map { val (p1, p2) = bin.readInts(); p1 to p2 }.toList()    solve(n, m, ti, moves)} fun solve(n: Int, m: Int, ti: List<Int>, moves: List<Pair<Int, Int>>) {    val piles : Array<MutableList<Int>> = Array(m+1) { LinkedList<Int>() }    val where = IntArray(n+1)     var cost = n-1    for (i in 1..n) {        val p = ti[i-1]         where[i] = p        if (i > 1 && where[i-1] == p) cost--        piles[p].add(i)    }     println(cost)     val out = StringBuilder()    for (q in 1 until m) {        val (a, b) = moves[q-1]        val (small_i, big_i) = if (piles[a].size < piles[b].size) listOf(a, b) else listOf(b, a)        val (small_p, big_p) = listOf(piles[small_i], piles[big_i])         val targetP = where[big_p.first()]        for (i in small_p) {            if (i > 1 && where[i-1] == targetP) cost--            if (i < n && where[i+1] == targetP) cost--        }        for (i in small_p) where[i] = targetP        big_p.addAll(small_p)         piles[a] = big_p         out.append(cost)        out.appendln()    }    print(out)}","data structures,dsu,implementation,trees"
"import java.io.*import java.util.*import kotlin.math.* fun main(){	val f = BufferedReader(InputStreamReader(System.`in`)) 	val (n,m) = f.readLine().split("" "").map{it.toInt()}	val starting = f.readLine().split("" "").map{it.toInt()} 	val sets = Array(m+1){HashSet<Int>()} 	for(k in 0 until n){		sets[starting[k]].add(k+1)	} 	val answer = mutableListOf<Int>() 	var count = 0	for(k in 1..m){		for(i in sets[k]){			if(!sets[k].contains(i-1)) count++		}	} 	answer.add(count) 	fun combine(x : Int, y : Int){ 		var prev = answer[answer.size-1] 		if(sets[x].size >= sets[y].size){			//add y to x 			//how many of y contributes to answer			var cont = 0			for(i in sets[y]){				if(!sets[y].contains(i-1)) cont++			} 			prev-=cont 			for(i in sets[y]){				if(sets[x].contains(i-1) && sets[x].contains(i+1)) prev--				else if(!sets[x].contains(i-1) && !sets[x].contains(i+1)) prev++				sets[x].add(i)			} 		} else {			//add x to y, then move pointers 			//how many of x contributes to answer			var cont = 0			for(i in sets[x]){				if(!sets[x].contains(i-1)) cont++			} 			prev-=cont 			for(i in sets[x]){				if(sets[y].contains(i-1) && sets[y].contains(i+1)) prev--				else if(!sets[y].contains(i-1) && !sets[y].contains(i+1)) prev++				sets[y].add(i)			} 			sets[x] = sets[y]			sets[y] = HashSet<Int>() 		} 		answer.add(prev)	} 	for(q in 1 until m){		val (x,y) = f.readLine().split("" "").map{it.toInt()} 		combine(x,y)	} 	val sb = StringBuilder()	for(k in 0 until m){		sb.appendln(answer[k]-1)	} 	println(sb)}","data structures,dsu,implementation,trees"
"import java.io.BufferedReaderimport java.io.InputStreamReader fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val (n, m) = jin.readLine().split("" "").map { it.toInt() }    val places = jin.readLine().split("" "").map { it.toInt() }    var union = IntArray(n + 1) { it }    val parent = Array(19) { IntArray(n + m) }    val empty = IntArray(0)    val children = Array(n + m) { empty }    for (j in n + 1 until n + m) {        val (a, b) = jin.readLine().split("" "").map { it.toInt() }        val x = union[a]        val y = union[b]        union[a] = j        parent[0][x] = j        parent[0][y] = j        children[j] = intArrayOf(x, y)    }    val depth = IntArray(n + m)    for (a in n + m - 1 downTo 1) {        depth[a] = depth[parent[0][a]] + 1        for (e in 1..18) {            parent[e][a] = parent[e - 1][parent[e - 1][a]]        }    }    var curr = (1 until n).count { places[it - 1] != places[it] }    val deltas = IntArray(m)    for (j in 1 until n) {        var a = places[j - 1]        var b = places[j]        if (a != b) {            if (depth[a] > depth[b]) {                val c = a                a = b                b = c            }            for (e in 18 downTo 0) {                if (depth[b] - depth[a] >= 1 shl e) {                    b = parent[e][b]                }            }            for (e in 18 downTo 0) {                if (parent[e][a] != parent[e][b]) {                    a = parent[e][a]                    b = parent[e][b]                }            }            deltas[parent[0][a] - n]--        }    }    val out = StringBuilder()    out.appendln(curr)    for (j in 1 until m) {        curr += deltas[j]        out.appendln(curr)    }    print(out)}","data structures,dsu,implementation,trees"
"import java.io.BufferedReader fun main() {    val br = System.`in`.bufferedReader()    val sb = StringBuilder()    val t = br.readInt()    repeat(t) {        val n = br.readInt()        val a = IntArray(n) { br.readInt() }        val steps = mutableListOf<Int>()         fun doMoves(idx: Int) {            steps += idx + 1            val tmp = a[idx]            a[idx] = a[idx + 2]            a[idx + 2] = a[idx + 1]            a[idx + 1] = tmp        }         val sorted = a.sorted()        var prev = sorted.first()        var repeatLeft = 0        var repeatRight = 2        for (x in 1 until sorted.size) {            if (sorted[x] == prev) {                if (x != 1) {                    repeatLeft = x - 2                    repeatRight = x                }            }            prev = sorted[x]        }        for (x in 0 until repeatLeft) {            val num = sorted[x]            var curIdx = -1            for (y in n - 1 downTo 0) {                if (a[y] == num) {                    curIdx = y                    break                }            }            while (curIdx >= x + 2) {                doMoves(curIdx - 2)                curIdx -= 2            }            if (curIdx == x + 1) {                doMoves(x)                doMoves(x)            }        }        for (x in n - 1 downTo repeatRight + 1) {            val num = sorted[x]            var curIdx = -1            for (y in repeatLeft until n) {                if (a[y] == num) {                    curIdx = y                    break                }            }            while (curIdx < x - 1) {                doMoves(curIdx)                curIdx++            }            if (curIdx == x - 1) {                doMoves(x - 2)            }        }        var good = false        for (x in 0 until 3) {            if (a[repeatLeft] <= a[repeatLeft + 1] && a[repeatLeft + 1] <= a[repeatRight]) {                sb.append(steps.size).append('\n').append(steps.joinToString("" "")).append('\n')                good = true                break            }            doMoves(repeatLeft)        }        if (!good) {            sb.append(""-1\n"")        }    }    print(sb)} private const val SPACE_INT = ' '.toInt()private const val ZERO_INT = '0'.toInt()private const val NL_INT = '\n'.toInt() private fun BufferedReader.readInt(): Int {    var ret = read()    while (ret <= SPACE_INT) {        ret = read()    }    val neg = ret == '-'.toInt()    if (neg) {        ret = read()    }    ret -= ZERO_INT    var read = read()    while (read >= ZERO_INT) {        ret *= 10        ret += read - ZERO_INT        read = read()    }     while (read <= SPACE_INT && read != -1 && read != NL_INT) {        mark(1)        read = read()    }    if (read > SPACE_INT) {        reset()    }    return if (neg) -ret else ret}","brute force,constructive algorithms,implementation,sortings"
"import java.io.BufferedReader fun main() {    val br = System.`in`.bufferedReader()    val sb = StringBuilder()    val t = br.readInt()    repeat(t) {        val n = br.readInt()        val a = IntArray(n) { br.readInt() }        val steps = mutableListOf<Int>()         fun doMoves(idx: Int) {            steps += idx + 1            val tmp = a[idx]            a[idx] = a[idx + 2]            a[idx + 2] = a[idx + 1]            a[idx + 1] = tmp        }         val sorted = a.sorted()        var prev = sorted.first()        var repeatLeft = 0        var repeatRight = 2        for (x in 1 until sorted.size) {            if (sorted[x] == prev) {                if (x != 1) {                    repeatLeft = x - 2                    repeatRight = x                }            }            prev = sorted[x]        }        for (x in 0 until repeatLeft) {            val num = sorted[x]            var curIdx = -1            for (y in n - 1 downTo 0) {                if (a[y] == num) {                    curIdx = y                    break                }            }            while (curIdx >= x + 2) {                doMoves(curIdx - 2)                curIdx -= 2            }            if (curIdx == x + 1) {                doMoves(x)                doMoves(x)            }        }        for (x in n - 1 downTo repeatRight + 1) {            val num = sorted[x]            var curIdx = -1            for (y in repeatLeft until n) {                if (a[y] == num) {                    curIdx = y                    break                }            }            while (curIdx < x - 1) {                doMoves(curIdx)                curIdx++            }            if (curIdx == x - 1) {                doMoves(x - 2)            }        }        var good = false        for (x in 0 until 3) {            if (a[repeatLeft] <= a[repeatLeft + 1] && a[repeatLeft + 1] <= a[repeatRight]) {                sb.append(steps.size).append('\n').append(steps.joinToString("" "")).append('\n')                good = true                break            }            doMoves(repeatLeft)        }        if (!good) {            sb.append(""-1\n"")        }    }    print(sb)} private const val SPACE_INT = ' '.toInt()private const val ZERO_INT = '0'.toInt()private const val NL_INT = '\n'.toInt() private fun BufferedReader.readInt(): Int {    var ret = read()    while (ret <= SPACE_INT) {        ret = read()    }    val neg = ret == '-'.toInt()    if (neg) {        ret = read()    }    ret -= ZERO_INT    var read = read()    while (read >= ZERO_INT) {        ret *= 10        ret += read - ZERO_INT        read = read()    }     while (read <= SPACE_INT && read != -1 && read != NL_INT) {        mark(1)        read = read()    }    if (read > SPACE_INT) {        reset()    }    return if (neg) -ret else ret}","brute force,constructive algorithms,implementation,sortings"
"private fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main() = repeat(readLine()!!.toInt()) {    val k = readInts()[1]    readInts()        .map { it % k }        .filter { it != 0 }        .groupingBy { it }        .eachCount()        .maxWith(compareBy({ it.value }, { -it.key }))        .let { println(if (it == null) 0 else it.value.toLong() * k - it.key + 1) }}","math,sortings,two pointers"
"private fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main() = repeat(readLine()!!.toInt()) {    val k = readInts()[1]    readInts()        .map { it % k }        .filter { it != 0 }        .groupingBy { it }        .eachCount()        .maxWith(compareBy({ it.value }, { -it.key }))        .let { println(if (it == null) 0 else it.value.toLong() * k - it.key + 1) }}","math,sortings,two pointers"
"fun main() = repeat(readLine()!!.toInt()) {	val (_, k) = rls()	val map = rls().asSequence().map { k - it%k }.filter { it != k }.groupingBy { it }.eachCount()	if (map.isEmpty()) { println(0); return@repeat }	val max = map.entries.maxWith(compareBy<Map.Entry<Long, Int>> {it.value}.thenBy{it.key})!!	println(1 + k*(max.value-1) + max.key)} fun rls() = readLine()!!.split("" "").map { it.toLong() }","math,sortings,two pointers"
"fun main() {    repeat(readLine()!!.toInt()) {        val (n, k) = readLine()!!.split("" "").map { it.toLong() }        val a = readLine()!!.split("" "").map { it.toLong() }.filter { it % k != 0L }         if (a.isEmpty()) {            println(0)            return@repeat        }         val t = a.map { (k - it % k) % k }         val z = t.groupBy { it }.flatMap { (key, value) ->            value.mapIndexed { index, v -> key + index * k }        }.max()!!         println(z + 1)    }}","math,sortings,two pointers"
"fun main() = repeat(readLine()!!.toInt()) {    readLine()!!    var ans = 0    readLine()!!.toCharArray().fold(0) { acc, b -> (acc + if (b == '(') 1 else -1).also { ans = Math.min(ans, it) }}    println(-ans)}","greedy,strings"
fun main() = repeat(readLine()!!.toInt()) {	readLine()	val s = readLine()!!	var open = 0	var count = 0	s.forEach {		when (it) {			'(' -> open++			')' -> if (open == 0) count++ else open--		}	}	println(count)},"greedy,strings"
"fun main()= repeat(readLine()!!.toInt()){    var (a:Int,b:kotlin.Int,c:kotlin.Int)= listOf(readLine()!!.toInt(),0,0)    var z:String= readLine()!!.toString()    while (""()"" in z)    {        z=z.replace(""()"","""")    }    println(z.length.div(2))}","greedy,strings"
fun main() = repeat(ri()) {	val n = ri()	val s = readLine()!!.toCharArray()	var open = 0	var count = 0	for (c in s) {		when (c) {			'(' -> open++			')' -> {				if (open == 0) count++				else open--			}		}	}	println(count)} private fun ri() = readLine()!!.toInt(),"greedy,strings"
"fun main()= repeat(readLine()!!.toInt()){    var x= readLine()!!.toInt()    println(if (x%4==0) ""YES"" else ""NO"")}","geometry,math"
"fun main() {    repeat(readLine()!!.toInt()) {        println(if (readLine()!!.toInt() % 4 == 0) ""Yes"" else ""NO"")    }}","geometry,math"
"fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()        println(if(n % 4 == 0) ""YES"" else ""NO"")    }}","geometry,math"
"fun main(args: Array<String>) {    repeat (readLine()!!.toInt()) {        println(if (readLine()!!.toLong() % 4 == 0L) ""YES"" else ""NO"")    }}","geometry,math"
"fun main() {  repeat(readLine()!!.toInt()) {    val n = readLine()!!.toInt()    val a = readLine()!!.split(' ').map { it.toInt() }    val bad = intArrayOf(0, 0)    for (i in a.indices) {      if (a[i] % 2 != i % 2) {        bad[i % 2]++      }    }    if (bad[0] != bad[1]) {      println(-1)    } else {      println(bad[0])    }  }}","greedy,math"
fun main() {    val t = readInt();    for(i in 1..t) solve()} fun solve(){    val n = readInt()    val a = readInts()    if(a.count{it % 2 == 1} == n/2)        println((0 until n).count{a[it] % 2 == 1 && it % 2 == 0})    else println(-1)} fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readInts() = readLn().split(' ').map(String::toInt),"greedy,math"
"fun main() {    var t = readLine()!!.toInt()    for(k in 1..t) {        readLine()        var evens = 0        var odds = 0        readLine()!!.split("" "").map{ it.toInt() }.forEachIndexed{ i, x ->            if(i%2 == 0 && x%2 == 1) evens++            if(i%2 == 1 && x%2 == 0) odds++        }        if(evens != odds) println(-1)        else println(evens)    }}","greedy,math"
"fun main() {    val t = readLine()!!.toInt()    repeat(t){        val n = readLine()!!        val data = readLine()!!.split("" "")            .map { it.toInt() }        val e1 = data.filterIndexed { i, x -> i and 1 != x and 1 && i and 1 == 1 }.count()        val e2 = data.filterIndexed { i, x -> i and 1 != x and 1 && i and 1 == 0 }.count()        println(if (e1 == e2) e1 else -1)    }}","greedy,math"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.io.PrintWriterimport java.util.* fun PrintWriter.solve(sc: FastScanner) {    val n = sc.nextInt()    val m = sc.nextInt()    val k = sc.nextInt()    val adj = Array(n) { mutableSetOf<Int>() }    for (i in 0 until m) {        val u = sc.nextInt() - 1        val v = sc.nextInt() - 1        if (u < k && v < k) {            adj[u].add(v)            adj[v].add(u)        }    }    visited = Array(k) { false }    finished = Array(k) { false }    color = Array(k) { 0 }    for (i in 0 until k) {        if (!finished[i] && start == -1) {            dfs(adj, i, -1)        }    }    if (start == -1) {        println(1)        val lst0 = mutableListOf<Int>()        val lst1 = mutableListOf<Int>()        for (i in 0 until k) {            if (color[i] == 0) {                lst0.add(i + 1)            } else {                lst1.add(i + 1)            }        }        if (lst0.count() > lst1.count()) {            println(lst0.take((k + 1) / 2).joinToString("" ""))        } else {            println(lst1.take((k + 1) / 2).joinToString("" ""))        }    } else {        println(2)        val cycle = mutableListOf<Int>()        while (hist.count() > 0) {            val t = hist.peek()            cycle.add(t + 1)            hist.pop()            if (t == start) break        }        println(cycle.count())        println(cycle.joinToString("" ""))    }} var start = -1var visited = Array(1) { false }var finished = Array(1) { false }var hist = Stack<Int>()var color = Array(1) { 0 } fun dfs(adj:Array<MutableSet<Int>>, v: Int, p: Int) {    hist.push(v)    if (p != -1) {        color[v] = (color[p] + 1) % 2    }    for (w in adj[v]) {        if (w == p) continue        if (finished[w]) continue        if (visited[w] && !finished[w]) {            //サイクル検出            start = w            return        }        visited[w] = true        dfs(adj, w, v)        if (start != -1) return    }    hist.pop()    finished[v] = true} fun main() {    val writer = PrintWriter(System.out, false)    writer.solve(FastScanner(System.`in`))    writer.flush()} class FastScanner(s: InputStream) {    private var st = StringTokenizer("""")    private val br = BufferedReader(InputStreamReader(s))     fun next(): String {        while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun nextInt() = next().toInt()    fun nextLong() = next().toLong()    fun nextLine() = br.readLine()    fun nextDouble() = next().toDouble()    fun ready() = br.ready()}","constructive algorithms,dfs and similar,graphs,greedy,implementation,trees"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.* fun BufferedReader.readInts() = this.readLine()!!.split(' ').map { it.toInt() } fun main() {    val bin = BufferedReader(InputStreamReader(System.`in`))    val (n, m, k) = bin.readInts()     val edges = Array(n) { mutableSetOf<Int>() }    repeat(m) {        val (u, v) = bin.readInts()        edges[u-1].add(v-1)        edges[v-1].add(u-1)    }     solve(edges.map { it.toSet() }.toTypedArray(), k)} fun shortenCycle(cycle: List<Int>, edges: Array<Set<Int>>): List<Int>? {    val n = cycle.size    val seen = mutableSetOf<Int>()    for (i in 0 until n) {        val v = cycle[i]        seen.add(v)        for (u in edges[v]) {            // Shorter cycle?            if (seen.contains(u) &&                    (i > 0 && u != cycle[i - 1]) &&                    (i != n - 1 || u != cycle[0])) {                 val p = cycle.indexOf(u)                val c1 = cycle.subList(p, i + 1)                val c2 = cycle.subList(0, p + 1) + cycle.subList(i, cycle.size)                return if (c1.size < c2.size) c1 else c2            }        }    }    return null} fun solve(edges: Array<Set<Int>>, k: Int) {    val fc = FindCycle(edges)    fun present(vs: List<Int>) = vs.map { it+1 }.joinToString(separator="" "")    val minIndependent = (k + 1) / 2     if (fc.cycle != null) {        var cycle: List<Int> = fc.cycle        while (true) cycle = shortenCycle(cycle, edges) ?: break         if (cycle.size <= k) {            println(2)            println(cycle.size)            println(present(cycle))        } else {            println(1)            println(present(cycle.filterIndexed { idx, _ -> idx % 2 == 0 }.take(minIndependent)))        }    } else {        fun getNodes(color: Boolean) = edges.indices.filter { fc.visited[it] == color }         val nodes = listOf(getNodes(true), getNodes(false)).maxBy { it.size }!!        println(1)        println(present(nodes.take(minIndependent)))    }} class FindCycle(private val edges: Array<Set<Int>>) {    val root = 0    val noNode = -1    val n = edges.size     val visited: Array<Boolean?> = Array(n) { null }    val s = Stack<Int>()    val cycle: List<Int>? = dfs(root, noNode, true)     private fun dfs(u: Int, p: Int, color: Boolean): List<Int>? {        visited[u] = color        s.push(u)         for (v in edges[u]) {            when {                v == p -> {}                visited[v] != null -> return s.toList().dropWhile { it != v }                else -> {                    val c = dfs(v, u, !color)                    if (c != null) return c                }            }        }         s.pop()        return null    }}","constructive algorithms,dfs and similar,graphs,greedy,implementation,trees"
"import java.io.PrintWriterimport java.lang.StringBuilderimport java.util.*import kotlin.math.* fun findCycle(adj: Array<MutableSet<Int>>): List<Int> {    val n = adj.count()    val seen = BooleanArray(n) { false }    val finished = BooleanArray(n) { false }    var pos = -1    val hist = Stack<Int>()    fun dfs(v: Int, p: Int) {        seen[v] = true        hist.push(v)        for (w in adj[v]) {            if (w == p) continue            if (finished[w]) continue            if (seen[w] && !finished[w]) {                pos = w                return            }            dfs(w, v)            if (pos != -1) return        }        hist.pop()        finished[v] = true    }    for (i in 0 until n) {        if (!finished[i]) {            dfs(i, -1)            if (pos != -1) break        }    }     val cycle = mutableListOf<Int>()    while (hist.isNotEmpty()) {        val t = hist.pop()        cycle.add(t)        if (t == pos) break    }    return cycle} fun PrintWriter.solve() {    val n = nextInt()    val m = nextInt()    val k = nextInt()    val adj = Array(k) { mutableSetOf<Int>() }    for (i in 0 until m) {        val u = nextInt() - 1        val v = nextInt() - 1        if (u < k && v < k) {            adj[u].add(v)            adj[v].add(u)        }    }    val cycle = findCycle(adj)    if (cycle.count() == 0) {        val color = BooleanArray(k) { false }        val visited = BooleanArray(k) { false }        fun dfs(v: Int, p: Int) {            visited[v] = true            if (p != -1) {                color[v] = !color[p]            }            for (w in adj[v]) {                if (w != p) {                    dfs(w, v)                }            }        }        for (i in 0 until k) {            if (!visited[i]) {                dfs(i, -1)            }        }         println(1)        val lst0 = mutableListOf<Int>()        val lst1 = mutableListOf<Int>()        for (i in 0 until k) {            if (color[i]) {                lst0.add(i + 1)            } else {                lst1.add(i + 1)            }        }        if (lst0.count() > lst1.count()) {            println(lst0.take((k + 1) / 2).joinToString("" ""))        } else {            println(lst1.take((k + 1) / 2).joinToString("" ""))        }    } else {        println(2)        println(cycle.count())        println(cycle.map { it + 1 }.joinToString("" ""))    }} fun main() {    val writer = PrintWriter(System.out, false)    writer.solve()    writer.flush()} // region Scannerprivate var st = StringTokenizer("""")private val br = System.`in`.bufferedReader() fun next(): String {    while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())    return st.nextToken()} fun nextInt() = next().toInt()fun nextLong() = next().toLong()fun nextLine() = br.readLine()fun nextDouble() = next().toDouble()// endregion","constructive algorithms,dfs and similar,graphs,greedy,implementation,trees"
"private val reader = System.`in`.bufferedReader()private fun readLn() = reader.readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readLong() = readLn().toLong()private fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of intsprivate fun readLongs() = readStrings().map { it.toLong() } private const val INF = 1e18.toLong() @ExperimentalStdlibApifun main() {    val (n, m, k) = readInts()    val adj = Array<MutableList<Int>>(n) { mutableListOf() }    repeat(m) {        val (u, v) = readInts().map { it - 1 }        adj[u].add(v)        adj[v].add(u)    }     // try find cycle    val color = IntArray(n) { -1 }    val parent = IntArray(n) { -1 }    val depth = IntArray(n) { -1 }    val color2 = IntArray(n) { -1 }    val minCycle = Array(n) { -1 to -1 } // cycleLen, cycleTo    parent[0] = 0    depth[0] = 0    color2[0] = 0     fun dfs(root: Int) {        color[root] = 1        for (next in adj[root]) {            if (parent[next] == -1) {                parent[next] = root                depth[next] = depth[root] + 1                color2[next] = 1 - color2[root]                dfs(next)            } else if (parent[root] != next && color[next] == 1) {                if (minCycle[next].first == -1 || depth[root] - depth[next] + 1 < minCycle[next].first) {                    minCycle[next] = depth[root] - depth[next] + 1 to root                }            }        }        color[root] = 2    }    dfs(0)     var cycleFrom = -1    var cycleTo = -1    var cycleLen = -1    for (i in 0 until n) {        if (minCycle[i].first != -1) {            cycleFrom = i            cycleTo = minCycle[i].second            cycleLen = minCycle[i].first            if (minCycle[i].first <= k) {                break            }        }    }    if (cycleLen != -1) { // cycle found        if (cycleLen <= k) {            println(2)            println(cycleLen)            var node = cycleTo            while (node != cycleFrom) {                print(node + 1)                print(' ')                node = parent[node]            }            println(cycleFrom + 1)        } else {            println(1)            var node = cycleTo            val needed = (k + 1) / 2            var cnt = 0            for (i in 0 until cycleLen) {                if (i % 2 == 0) {                    print(node + 1)                    if (++cnt >= needed) {                        break                    } else {                        print(' ')                    }                }                node = parent[node]            }            println()        }    } else { // it's a tree        println(1)        var cnt = 0        val needed = (k + 1) / 2        val colorNeeded = if (color2.count { it == 0 } >= needed) 0 else 1        for (i in 0 until n) {            if (color2[i] == colorNeeded) {                print(i + 1)                if (++cnt >= needed) {                    break                } else {                    print(' ')                }            }        }        println()    }} @ExperimentalStdlibApiprivate fun LongArray.prefs() = scan(0L, { acc, item -> acc + item }).toLongArray()private fun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)","constructive algorithms,dfs and similar,graphs,greedy,implementation,trees"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport kotlin.math.min fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val n = jin.readLine().toInt()    val adj = Array(n + 1) { mutableSetOf<Int>() }    val initial = IntArray(n + 1)    val goal = IntArray(n + 1)    val cost = LongArray(n + 1)    for (j in 1..n) {        val (a, b, c) = jin.readLine().split("" "").map { it.toInt() }        initial[j] = b        goal[j] = c        cost[j] = a.toLong()    }    for (j in 2..n) {        val (a, b) = jin.readLine().split("" "").map { it.toInt() }        adj[a].add(b)        adj[b].add(a)    }    var answer = 0L    fun recur(a: Int): Long {        var rem0 = 0L        var rem1 = 0L        if (initial[a] != goal[a]) {            when (initial[a]) {                0 -> rem0++                1 -> rem1++            }        }        for (b in adj[a]) {            adj[b].remove(a)            cost[b] = min(cost[b], cost[a])            val d = recur(b)            if (d < 0) {                rem0 += -d            } else {                rem1 += d            }        }        answer += 2L * min(rem0, rem1) * cost[a]        return rem1 - rem0    }    if (recur(1) == 0L) {        println(answer)    } else {        println(-1)    }}","dfs and similar,dp,greedy,trees"
"import kotlin.math.absimport kotlin.math.min fun main() {    val n = readLine()!!.toInt()     val cost = IntArray(n + 1)    val demand = IntArray(n + 1)     for (i in 1..n) {        val (a, b, c) = readLine()!!.split("" "").map { it.toInt() }        cost[i] = a        demand[i] = b - c    }     val tree = Array<MutableList<Int>>(n + 1) { ArrayList() }     for (i in 0.until(n - 1)) {        val (u, v) = readLine()!!.split("" "").map { it.toInt() }         tree[u].add(v)        tree[v].add(u)    }     var result = 0L     fun compute(n: Int, p: Int, minCost: Int): Int {        val nextMinCost = min(cost[n], minCost)         var negDemand = 0        var posDemand = 0         when {            demand[n] < 0 -> negDemand += demand[n]            demand[n] > 0 -> posDemand += demand[n]        }         for (v in tree[n]) {            if (v == p)                continue             val childDemand = compute(v, n, nextMinCost)             when {                childDemand < 0 -> negDemand += childDemand                childDemand > 0 -> posDemand += childDemand            }        }         result += 2L * min(abs(negDemand), abs(posDemand)).toLong() * nextMinCost.toLong()         return negDemand + posDemand    }     when (compute(1, 0, Int.MAX_VALUE)) {        0 -> println(result)        else -> println(-1)    }}","dfs and similar,dp,greedy,trees"
"import kotlin.math.min fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() } data class Node(val a: Int, val b: Int, val c: Int) {    companion object {        fun read(): Node {            val (a, b, c) = readInts()            return Node(a, b, c)        }    }} fun main() {    val n = readInt()    val nodes = (1..n).map { Node.read() }.toTypedArray()     val edges = Array(n) { mutableSetOf<Int>() }    repeat(n-1) {        val (u, v) = readInts()        edges[u-1].add(v-1)        edges[v-1].add(u-1)    }    val es = edges.map { it.toSet() }.toTypedArray()     val t = Tree(es, nodes)    println(if (t.config.num01 == 0 && t.config.num10 == 0) t.config.cost else -1)} data class Config(val num01: Int, val num10: Int, val cost: Long) {    operator fun plus(c: Config): Config = Config(num01 + c.num01, num10 + c.num10, cost + c.cost)} class Tree(private val edges: Array<Set<Int>>, val nodes: Array<Node>) {    val n = edges.size    val root = 0    val noNode = -1     val parent = IntArray(n)    val config: Config     init {        config = dfs(root, noNode, nodes[root].a.toLong())    }     private fun dfs(u: Int, p: Int, cost: Long): Config {        val n = nodes[u]        parent[u] = p        val num01 = if (n.b == 0 && n.c == 1) 1 else 0        val num10 = if (n.b == 1 && n.c == 0) 1 else 0         var config = Config(num01, num10, 0)        for (v in edges[u]) {            if (v != p) {                config += dfs(v, u, min(cost, nodes[v].a.toLong()))            }        }         val fix = min(config.num01, config.num10)        return Config(config.num01 - fix, config.num10 - fix, config.cost + 2*cost*fix)    }}","dfs and similar,dp,greedy,trees"
"import java.io.*import java.util.*import kotlin.math.* fun main(){	val f = BufferedReader(InputStreamReader(System.`in`)) 	val n = f.readLine().toInt()	val values = LongArray(n+1)	val start = IntArray(n+1)	val end = IntArray(n+1) 	for(k in 1..n){		val line = f.readLine().split("" "")		values[k] = line[0].toLong()		start[k] = line[1].toInt()		end[k] = line[2].toInt()	} 	val adj = Array(n+1){mutableListOf<Int>()}	for(k in 2..n){		val (a,b) = f.readLine().split("" "").map{it.toInt()}		adj[a].add(b)		adj[b].add(a)	} 	val count10 = LongArray(n+1)	val count01 = LongArray(n+1)	val parent = IntArray(n+1) 	fun dfs(v : Int, p : Int){		parent[v] = p		if(start[v] == 0 && end[v] == 1) count01[v]++		if(start[v] == 1 && end[v] == 0) count10[v]++		for(nei in adj[v]){			if(nei == p) continue			dfs(nei,v)			count01[v] += count01[nei]			count10[v] += count10[nei]		}	} 	dfs(1,-1) 	if(count01[1] != count10[1]){		println(-1)		return	} 	val excess01 = LongArray(n+1)	val excess10 = LongArray(n+1) 	val seen = HashSet<Int>() 	val pq = PriorityQueue<Int>(compareBy({values[it]}))	for(k in 1..n) pq.add(k) 	fun dfs2(v : Int, p : Int){		if(start[v] == 0 && end[v] == 1) excess01[v]++		if(start[v] == 1 && end[v] == 0) excess10[v]++		seen.add(v)		for(nei in adj[v]){			if(nei == p) continue			if(!seen.contains(nei)){				dfs2(nei,v)			}			excess01[v] += excess01[nei]			excess10[v] += excess10[nei]		} 	} 	var answer = 0L	while(!pq.isEmpty()){		val v = pq.poll()		if(seen.contains(v)) continue 		dfs2(v,parent[v]) 		//println(""$v ${excess01[v]} ${excess10[v]}"")   		val min = min(excess01[v],excess10[v])		excess01[v]-=min		excess10[v]-=min 		answer += min*2L*values[v] 	} 	println(answer) }","dfs and similar,dp,greedy,trees"
"fun main(){    repeat(readLine()!!.toInt()){        val n = readLine()!!.toInt()        val a = readLine()!!.split(' ').map(String::toInt).sorted()        var ok = a.count{it % 2 == 0} % 2 == 0        for(i in 1 until n)            if(a[i] == a[i - 1] + 1)                ok = true        println(if(ok)""YES"" else ""NO"")    }}","constructive algorithms,graph matchings,greedy,sortings"
"fun main() {    val t = readLine()!!.toInt()    repeat( t ) {        val n = readLine()!!.toInt()        val x = readLine()!!.split( ' ' ).map { it.toInt() }.sorted()        val m = x.zipWithNext { u, v -> v - u }.count { it == 1 }        val k = x.count { (it and 1) > 0 }        println( if ( m > 0 || (k and 1) == 0 ) ""Yes"" else ""No"" )    }}","constructive algorithms,graph matchings,greedy,sortings"
"fun main() {    val t = readLine()!!.toInt()    repeat(t) {        readLine()        val a = readLine()!!.split("" "").map { it.toInt() }.sorted()        if (a.count { it % 2 == 0 } % 2 == 0) {            println(""YES"")        } else if (a.zipWithNext().map { it.second - it.first }.find { it == 1 } != null) {            println(""YES"")        } else {            println(""NO"")        }    }}","constructive algorithms,graph matchings,greedy,sortings"
"import java.util.* fun main(){	for(q in 1..readLine()!!.toInt()){		val n = readLine()!!.toInt()		val array = readLine()!!.split("" "").map{it.toInt()}.sorted()		var evensum = 0		var has1 = false		for(k in 0 until n){			if(array[k]%2 == 0) evensum ++			if(k > 0 && array[k] == array[k-1]+1) has1 = true		} 		if(evensum % 2 == 0 || has1){			println(""YES"")		} else {			println(""NO"")		} 	}}","constructive algorithms,graph matchings,greedy,sortings"
"import kotlin.math.min fun main() {    fun readInt() = readLine()!!.toInt()     repeat(readInt()) {        var min = Int.MAX_VALUE        val s = readLine()!!        val lasts = intArrayOf(-3 * s.length, -2*s.length, -s.length)        for ((pos, c) in s.withIndex()) {            lasts[c - '1'] = pos            min = min(min, lasts.maxOrNull()!! - lasts.minOrNull()!! + 1)        }        println(if (min > s.length) 0 else min)    }}","binary search,dp,implementation,two pointers"
"fun main() {    var tt = readLine()!!.toInt()   for(t in 0 until tt){       var s = readLine()!!.toString()     var n=s.length     var a=-1;var b=-1;var c=-1     var ans = n     for(i in 0 until n){      if(s[i]=='1')        a=i      else if (s[i]=='2')        b=i;      else c=i            if(a!=-1&&b!=-1&&c!=-1)        ans = minOf(ans, i-minOf(a, b, c)+1)     }      if(a==-1||b==-1||c==-1)      println(0)     else println(ans)    }}","binary search,dp,implementation,two pointers"
"import kotlin.math.min fun main() {    repeat(readLine()!!.toInt()) {        val input = readLine()!!.map { (it - '1') }        val last = IntArray(3) { -1 }        var shortest = Int.MAX_VALUE        for (i in input.indices) {            val x = input[i]            last[x] = i            if (last.all { it != -1 }) {                shortest = min(shortest, last[x] - last.min()!! + 1)            }        }        if (last.any { it == -1 }) println(0)        else println(shortest)    }}","binary search,dp,implementation,two pointers"
"import kotlin.math.min fun main() {    repeat(readLine()!!.toInt()) {        val input = readLine()!!.map { (it - '1') }        val last = IntArray(3) { -1 }        var shortest = Int.MAX_VALUE        for (i in input.indices) {            val x = input[i]            last[x] = i            if (last.all { it != -1 }) {                shortest = min(shortest, last[x] - last.min()!! + 1)            }        }        if (last.any { it == -1 }) println(0)        else println(shortest)    }}","binary search,dp,implementation,two pointers"
"fun main() {    val r = System.`in`.bufferedReader()    val s = StringBuilder()    val n = r.readLine()!!.toInt()    val v = r.readLine()!!.split("" "").map { it.toLong() }    val pre = v.toLongArray()    val suf = v.toLongArray()    pre[1] = v[0]    suf[n - 2] = v[n - 1]    (2..n - 1).forEach { pre[it] = gcd(pre[it - 1], v[it - 1]) }    (n - 3 downTo 0).forEach { suf[it] = gcd(suf[it + 1], v[it + 1]) }    var lcm = lcm(pre[n - 1], suf[0])    val asn = (1..n - 2).fold(lcm) { l, i -> lcm(l, gcd(pre[i], suf[i])) }    println(asn)} tailrec fun gcd(a: Long, b: Long): Long = if (b == 0L) a else gcd(b, a % b)fun lcm(a: Long, b: Long) = a * b / gcd(a, b)fun f(long: Long) = long * (long - 1) / 2","data structures,math,number theory"
"import java.io.BufferedReaderimport java.io.InputStreamReader fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val n = jin.readLine().toInt()    val array = jin.readLine().split("" "").map { it.toLong() }    val prefixes = LongArray(n + 1)    for (j in 1..n) {        prefixes[j] = gcd(array[j - 1], prefixes[j - 1])    }    val suffixes = LongArray(n + 1)    for (j in n - 1 downTo 0) {        suffixes[j] = gcd(array[j], suffixes[j + 1])    }    var answer = 1L    for (j in 1..n) {        answer = lcm(answer, gcd(prefixes[j - 1], suffixes[j]))    }    println(answer)} fun gcd(a: Long, b: Long): Long = if (b == 0L) a else gcd(b, a % b)fun lcm(a: Long, b: Long) = (a * b) / gcd(a, b)","data structures,math,number theory"
"import java.util.*     fun main(args: Array<String>) {        val sc = Scanner(System.`in`)        val n = sc.nextInt()        val strt = LongArray(n + 1)        val end = LongArray(n + 2)        val a = LongArray(n + 1)        for (i in 1..n) {            a[i] = sc.nextLong()        }        strt[0] = 1        strt[1] = a[1]        end[n + 1] = 1        end[n] = a[n]        for (i in 2..n) strt[i] = gcd(strt[i - 1], a[i])        for (i in n - 1 downTo 1) end[i] = gcd(end[i + 1], a[i])        var g: Long = 0        var k: Long = 0        for (i in 1..n) {            k = if (i == 1) end[i + 1] else if (i == n) strt[i - 1] else gcd(strt[i - 1], end[i + 1])            g = gcd(g, a[i] * k)        }        println(g / strt[n])    }     fun gcd(a: Long, b: Long): Long {        return if (b == 0L) a else gcd(b, a % b)    }","data structures,math,number theory"
"fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main() {    val n = readInt()    val vs = readInts()    val fs = mutableMapOf<Int, MutableList<Int>>()     for (v in vs) {        for ((q, p) in factorize(v)) {            fs.putIfAbsent(q, mutableListOf())            fs[q]!!.add(p)        }    }     var res = 1L    for ((q, pows) in fs.entries) {        res *= q.toLong().pow(secondMin(n, pows))    }    println(res)} fun secondMin(n: Int, pows: List<Int>): Int {    return when (pows.size) {        n -> {            val mnI = pows.indexOf(pows.min()!!)            pows.filterIndexed { index, _ -> index != mnI }.min()!!        }        n-1 -> pows.min()!!        else -> 0    }} fun factorize(n_in: Int): List<Pair<Int, Int>> {    val factors = mutableListOf<Pair<Int, Int>>()    var n = n_in    var d = 2    while (d * d <= n) {        var c = 0        while (n % d == 0) {            n /= d            c++        }        if (c > 0) factors.add(Pair(d, c))        d++    }    if (n > 1) {        factors.add(Pair(n, 1))    }    // println(""factors(${n_in}) = $factors"")    return factors} // exponentiation in O(log n)fun Long.pow(n_in: Int): Long {    if (n_in == 0) return 1L    var n = n_in    var x = this    var res = 1L    while (n > 0L) {        if (n % 2L == 1L) res *= x        x *= x        n /= 2    }    return res}","data structures,math,number theory"
"import kotlin.math.min fun main() = repeat(readLine()!!.toInt()) { val (n, k, x, y) = ril() val arr = ril().sortedDescending() val sums = arr.runningFold(0, Long::plus) val toDrop = sums.indexOfFirst { sums.last() - it <= n*k } println(toDrop*x + min(arr.drop(toDrop).takeWhile { it > k }.count() * x, y))} private fun ril() = readLine()!!.split("" "").map { it.toLong() }","*special,greedy,sortings"
"import kotlin.math.min fun main() = repeat(readLine()!!.toInt()) { val (n, k, x, y) = ril() val arr = ril().sortedDescending() val sums = arr.runningFold(0, Long::plus) val toDrop = sums.indexOfFirst { sums.last() - it <= n*k } println(toDrop*x + min(arr.drop(toDrop).takeWhile { it > k }.count() * x, y))} private fun ril() = readLine()!!.split("" "").map { it.toLong() }","*special,greedy,sortings"
"import kotlin.math.min fun main() = repeat(readLine()!!.toInt()) {	val (n, k, x, y) = ril()	val arr = ril().sortedDescending()	val sums = arr.runningFold(0, Long::plus)	val toDrop = sums.indexOfFirst { sums.last() - it <= n*k }	println(toDrop*x + min(arr.drop(toDrop).takeWhile { it > k }.count() * x, y))} private fun ril() = readLine()!!.split("" "").map { it.toLong() }","*special,greedy,sortings"
"import kotlin.math.min fun main() = repeat(readLine()!!.toInt()) {	val (n, k, x, y) = ril()	val arr = ril().sortedDescending()	val sums = arr.runningFold(0, Long::plus)	val toDrop = sums.indexOfFirst { sums.last() - it <= n*k }	println(toDrop*x + min(arr.drop(toDrop).takeWhile { it > k }.count() * x, y))} private fun ril() = readLine()!!.split("" "").map { it.toLong() }","*special,greedy,sortings"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport kotlin.math.max val MOD = 998244353L fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val s = jin.readLine()    val t = jin.readLine()    var dp = LongArray(t.length + 1)    for (j in 0 until t.length) {        if (t[j] == s[0]) {            dp[j] = 2L        }    }    dp[t.length] = 2L    var dpAlt = LongArray(t.length + 1)    var answer = 0L    if (t.length == 1) {        answer += dp[0]    }    for (j in 1 until s.length) {        dpAlt.fill(0L)        for (k in 0 until t.length) {            if (t[k] == s[j]) {                if (k >= j) {                    dpAlt[k - j] += dp[k - j]                    dpAlt[k - j] %= MOD                }                dpAlt[k] += dp[k + 1]                dpAlt[k] %= MOD            }        }        for (k in max(t.length - j, 0)..t.length) {            dpAlt[k] += dp[k]            dpAlt[k] %= MOD        }        dpAlt[t.length] += dp[t.length]        dpAlt[t.length] %= MOD        val temp = dp        dp = dpAlt        dpAlt = temp        if (j + 1 >= t.length) {            answer += dp[0]            answer %= MOD        }    }    println(answer)}","dp,strings"
"private const val MOD = 998244353L fun main() {    val br = System.`in`.bufferedReader()    val s = br.readLine()    val t = br.readLine()    val m = t.length    val dpA = Array(s.length) {        LongArray(t.length + 1) { -1L }    }    val dpB = Array(t.length) {        LongArray(t.length) { -1L }    }     fun solveA(sID: Int, tID: Int): Long {        if (sID == s.length) {            return if (tID == m) 1L else 0L        }        if (dpA[sID][tID] == -1L) {            var ways = 0L            if (tID == m) {                ways++            } else if (s[sID] == t[m - 1 - tID]) {                ways += solveA(sID + 1, tID + 1)            }            ways += solveA(sID + 1, tID)            if (tID == 0) {                ways += solveA(sID + 1, tID)            }             dpA[sID][tID] = ways % MOD        }        return dpA[sID][tID]    }     fun solveB(start: Int, end: Int): Long {        if (dpB[start][end] == -1L) {            val sID = end - start + 1            var ways = 0L            if (end == m - 1) {                ways = solveA(sID, sID)            } else {                if (start != 0 && s[sID] == t[start - 1]) {                    ways += solveB(start - 1, end)                }                if (s[sID] == t[end + 1]) {                    ways += solveB(start, end + 1)                }            }            dpB[start][end] = ways % MOD        }        return dpB[start][end]    }     var ways = 0L    for (i in t.indices) {        if (t[i] == s[0]) {            ways += solveB(i, i) shl 1            ways %= MOD        }    }     ways += solveA(1, 0) shl 1    print(ways % MOD)}","dp,strings"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.io.PrintWriterimport java.util.* fun PrintWriter.solve(sc: FastScanner) {    val s = sc.nextLine()    var t = sc.nextLine()    val n = s.length    val m = t.length    t += ""."".repeat(n - m)    val mod = 998244353L    // dp[i][j]:Tのi番目からj文字を取り出したものがSの接頭辞になっているような個数    val dp = Array(n + 1) { Array(n + 1) { 0L } }    for (i in 0..n) {        dp[i][0] = 1    }    for (j in 0 until n) {        for (i in 0..n) {            val r = i + j            //右に追加            if (r < n && (s[j] == t[r] || t[r] == '.')) {                dp[i][j + 1] += dp[i][j]                dp[i][j + 1] %= mod            }            //左に追加            if (i > 0 && (s[j] == t[i - 1] || t[i - 1] == '.')) {                dp[i - 1][j + 1] += dp[i][j]                dp[i - 1][j + 1] %= mod            }        }    }    var ans = 0L    for (i in m..n) {        ans += dp[0][i]        ans %= mod    }    println(ans)} fun main(args: Array<String>) {    val writer = PrintWriter(System.out, false)    writer.solve(FastScanner(System.`in`))    writer.flush()} class FastScanner(s: InputStream) {    private var st = StringTokenizer("""")    private val br = BufferedReader(InputStreamReader(s))     fun next(): String {        while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun nextInt() = next().toInt()    fun nextLong() = next().toLong()    fun nextLine() = br.readLine()    fun nextDouble() = next().toDouble()    fun ready() = br.ready()}","dp,strings"
"fun main() {    val s = readLine()!!    val t = readLine()!!    val map = mutableMapOf<Char, MutableList<Int>>()    val list = MutableList(t.length + 2) { 0L }    val list2 = MutableList(t.length) { 0L }    t.forEachIndexed { index, c -> map.getOrPut(c, { mutableListOf() }).add(index + 1) }    if (s[0] !in map) {        list[t.length + 1] = 1        for (i in 1 until s.length) {            val it = s[i]            map[it]?.forEach { it2 ->                list[it2] += list[it2 + 1]                list[it2] %= 998244353L            }            list[0] += list[1]            list[0] %= 998244353L            list[t.length + 1] *= 2L            list[t.length + 1] %= 998244353L        }        list[0] *= 2L        list[0] %= 998244353L        println(list[0])    } else {        list[t.length + 1] = 1        map[s[0]]!!.forEach { list2[it - 1] = 1 }        list[t.length] = list2[t.length - 1]        list2[t.length - 1] = 0        list[0] += list[1]        list[0] %= 998244353L        for (i in 1 until s.length) {            val it = s[i]            if (i <= t.length) {                for (j in t.length - 2 downTo 0) {                    if (t[j + 1] == it) {                        list2[j + 1] += list2[j]                        list2[j + 1] %= 998244353L                    }                    if (j - i < 0 || t[j - i] != it) list2[j] = 0L                }            }            map[it]?.forEach { it2 ->                list[it2] += list[it2 + 1]                list[it2] %= 998244353L            }            if (t.length - i >= 0) {                list[t.length - i] += list2[t.length - 1]                list[t.length - i] %= 998244353L                list2[t.length - 1] = 0            }            list[0] += list[1]            list[0] %= 998244353L            list[t.length + 1] *= 2L            list[t.length + 1] %= 998244353L        }        list[0] *= 2L        list[0] %= 998244353L        println(list[0])    }}","dp,strings"
"import java.util.*import java.math.* fun readLn()=readLine()!!fun readInt()=readLn().toInt()fun readInts()=readLn().split("" "").map{it.toInt()}fun readLong()=readLn().toLong()fun readLongs()=readLn().split("" "").map{it.toLong()} val out=mutableListOf<String>()fun printLine(s: String){out.add(s)}fun output(){println(out.joinToString(""\n""))} fun main(){    val t=readInt()    for(tc in 1..t){        val (n,m)=readInts()        val col=Array(n){readLn().toCharArray()}        val dir=Array(n){readLn().toCharArray()}        val go=Array(n*m){IntArray(21){-1}}        for(i in 0 until n)            for(j in 0 until m){                val A = i*m+j                when(dir[i][j]) {                    'L' -> go[A][0]=A-1                    'R' -> go[A][0]=A+1                    'D' -> go[A][0]=A+m                    'U' -> go[A][0]=A-m                }            }        for(l in 1..20)            for(i in 0 until n*m)                go[i][l]=go[go[i][l-1]][l-1]        val cnt=IntArray(n*m){0}        val blk=IntArray(n*m){0}        for(i in 0 until n*m) {            cnt[go[i][20]]++            if(col[i/m][i%m]=='0')                blk[go[i][20]]++        }        var ans=0        var blc=0        for(i in 0 until n*m){            if(cnt[i]>0)ans++            if(blk[i]>0)blc++        }        printLine(""$ans $blc"")    }    output()}","data structures,dfs and similar,dsu,graphs,greedy,matrices"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.* fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val out = StringBuilder()    for (c in 1..jin.readLine().toInt()) {        val tokenizer = StringTokenizer(jin.readLine())        val n = tokenizer.nextToken().toInt()        val m = tokenizer.nextToken().toInt()        val grid = Array(n) { jin.readLine() }        val directions = Array(n) { jin.readLine() }        var next = Array(n) { y -> Array(m) { x -> when (directions[y][x]) {            'U' -> Pair(y - 1, x)            'D' -> Pair(y + 1, x)            'L' -> Pair(y, x - 1)            else -> Pair(y, x + 1)        } } }        var nextAlt = Array(n) { Array(m) { Pair(0, 0) } }        for (e in 1..21) {            for (y in 0 until n) {                for (x in 0 until m) {                    nextAlt[y][x] = next[next[y][x].first][next[y][x].second]                }            }            val temp = next            next = nextAlt            nextAlt = temp        }        val seen = Array(n) { IntArray(m) }        var answer1 = 0        var answer2 = 0        for (y in 0 until n) {            for (x in 0 until m) {                val b = next[y][x].first                val a = next[y][x].second                if (seen[b][a] == 0) {                    seen[b][a] = 1                    answer1++                }                if (grid[y][x] == '0' && seen[b][a] == 1) {                    seen[b][a] = 2                    answer2++                }            }        }        out.append(answer1).append(' ').appendln(answer2)    }    print(out)}","data structures,dfs and similar,dsu,graphs,greedy,matrices"
"import java.io.BufferedReader val bin = System.`in`.bufferedReader()fun BufferedReader.readInt() = this.readLine()!!.toInt()fun BufferedReader.readInts() = this.readLine()!!.split(' ').map { it.toInt() }.toIntArray() fun main() {    repeat(bin.readInt()) {        val (n, m) = bin.readInts()        val cs = (1..n).map { bin.readLine()!! }        val ds = (1..n).map { bin.readLine()!! }        val (rs, bs) = solve(n, m, cs, ds)        println(""$rs $bs"")    }} fun solve(n: Int, m: Int, cs: List<String>, ds: List<String>): Pair<Int, Int> {    var b = 0    var steps = 1    while (steps <= n * m) {        steps *= 2        b++    }     fun cellId(r: Int, c: Int): Int = r * m + c     fun move(r: Int, c: Int): Int {        val (nr, nc) = when (ds[r][c]) {            'U' -> Pair(r-1, c)            'D' -> Pair(r+1, c)            'L' -> Pair(r, c-1)            'R' -> Pair(r, c+1)            else -> error(""Unknown direction"")        }        return cellId(nr, nc)    }     val dest = Array(b) { IntArray(n * m) }    for (r in 0 until n) {        for (c in 0 until m) {            dest[0][cellId(r, c)] = move(r, c)        }    }    for (i in 1 until b) {        for (r in 0 until n) {            for (c in 0 until m) {                val mid = dest[i-1][cellId(r, c)]                val target = dest[i-1][mid]                dest[i][cellId(r, c)] = target            }        }    }     // returns cellId of the cell reachable from (r, c) after [steps] steps.    fun go(r: Int, c: Int, steps: Int): Int {        var cell = cellId(r, c)        var s = steps        for (i in b-1 downTo 0) {            if (1 shl i <= s) {                cell = dest[i][cell]                s -= 1 shl i            }        }        return cell    }     val used = mutableSetOf<Int>()    val black = mutableSetOf<Int>()     var rs = 0    var bs = 0    for (r in 0 until n) {        for (c in 0 until m) {            val t = go(r, c, n * m)            val isBlack = cs[r][c] == '0'             if (t !in used) {                rs++                used.add(t)            }            if (isBlack && t !in black) {                bs++                black.add(t)            }        }    }     return Pair(rs, bs)}","data structures,dfs and similar,dsu,graphs,greedy,matrices"
"import java.util.*import java.io.* fun main() {	Thread(null, Main(), ""whatever"", 1 shl 28).start()} class Main : Runnable {		override fun run()	{		val inputStream = System.`in`		val outputStream = System.out		val `in` = InputReader(inputStream)		val out = PrintWriter(outputStream)		val solver = TaskD()		var test = 1		test = `in`.nextInt()		for (t in 1..test)		{			solver.solve(t, `in`, out)		}		out.close()	} 	internal class TaskD {		fun solve(testNumber: Int, `in`: InputReader, out: PrintWriter) {			val INF = 1000000000			val dx = intArrayOf(-1, 1, 0, 0)			val dy = intArrayOf(0, 0, -1, 1) 			var n = `in`.nextInt()			var m = `in`.nextInt()			var c = Array<String>(n, {`in`.next()})			var g = Array<String>(n, {`in`.next()})			var u = Array<IntArray>(n, {IntArray(m)})			var tox = Array<IntArray>(n, {IntArray(m)})			var toy = Array<IntArray>(n, {IntArray(m)}) 			for (i in 0..n-1)				for (j in 0..m-1)				{					var x = i					var y = j					if (g[x][y] == 'U') x -= 1					else if (g[x][y] == 'D') x += 1					else if (g[x][y] == 'L') y -= 1					else if (g[x][y] == 'R') y += 1					tox[i][j] = x					toy[i][j] = y				} 			var res = 0			var cnt = 0			for (i in 0..n-1)			{				for (j in 0..m-1)				{					if (u[i][j] != 0) continue 					var stamp = 1					var x = i					var y = j					u[x][y] = stamp					while (true)					{						var tx = x						var ty = y						x = tox[tx][ty]						y = toy[tx][ty]						stamp += 1						if (u[x][y] != 0) break						u[x][y] = stamp					}					var len = stamp-u[x][y]										var pile = IntArray(len)					fun go(x: Int, y: Int, z: Int): Unit					{						u[x][y] = -1						if (c[x][y] == '0') pile[z] = 1						for (k in 0..3)						{							var tx = x+dx[k]							var ty = y+dy[k]							if (0 <= tx && tx < n && 0 <= ty && ty < m && tox[tx][ty] == x && toy[tx][ty] == y && u[tx][ty] != -1)							{								go(tx, ty, (z+1)%len)							}						}						return					} 					go(x, y, 0)										res += len					for (k in 0..len-1) cnt += pile[k]				}			}			out.println(""$res $cnt"")		} 	} 	internal class InputReader(stream: InputStream) {		var reader: BufferedReader		var tokenizer: StringTokenizer? = null 		init {			reader = BufferedReader(InputStreamReader(stream), 32768)			tokenizer = null		} 		operator fun next(): String {			while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {				try {					tokenizer = StringTokenizer(reader.readLine())				} catch (e: IOException) {					throw RuntimeException(e)				} 			}			return tokenizer!!.nextToken()		} 		fun nextInt(): Int {			return Integer.parseInt(next())		}				fun nextLong(): Long {		    return next().toLong()		} 	}}","data structures,dfs and similar,dsu,graphs,greedy,matrices"
"import java.util.*import java.math.*import kotlin.math.abs fun readLn()=readLine()!!fun readInt()=readLn().toInt()fun readInts()=readLn().split("" "").map{it.toInt()}fun readLong()=readLn().toLong()fun readLongs()=readLn().split("" "").map{it.toLong()} val out=mutableListOf<String>()fun printLine(s:String){out.add(s)}fun output(){println(out.joinToString(""\n""))} val mod=998244353Lfun main(){    var D=readLong()    var i=2L    var fs=ArrayList<Long>()    while(i*i<=D){        if(D%i==0L){            fs.add(i)            while(D%i==0L)D/=i        }        i++    }    if(D>1L)fs.add(D)    var inv=LongArray(1000){0}    inv[1]=1    for(i in 2 until 1000)inv[i]=((mod-mod/i)*inv[(mod%i).toInt()])%mod    var q=readInt()    for(qq in 1..q){        var (x,y)=readLongs()        var lo=0;var hi=0        var dv=ArrayList<Int>()        for(i in fs){            var bl=0            while(x%i==0L) {                bl++                x /= i            }            while(y%i==0L){                bl--                y/=i            }            if(bl>0)hi+=bl            else lo-=bl            dv.add(abs(bl))        }        var ans=1L        for(i in 1..lo)ans=ans*i%mod        for(i in 1..hi)ans=ans*i%mod        for(j in dv)for(i in 1..j)ans=ans*inv[i]%mod        printLine(""$ans"")    }    output()}","combinatorics,graphs,greedy,math,number theory"
"import java.io.BufferedReaderimport java.io.InputStreamReader val MOD = 998244353L fun main() {    val factorial = LongArray(50) { it.toLong() }    factorial[0] = 1L    for (j in 1..49) {        factorial[j] *= factorial[j - 1]        factorial[j] %= MOD    }    val factorialInv = LongArray(50) { factorial[it] pow -1 }    val jin = BufferedReader(InputStreamReader(System.`in`))    val d = jin.readLine().toLong()    val primeFactors = mutableListOf<Long>()    var dt = d    if (dt % 2L == 0L) {        primeFactors.add(2L)        while (dt % 2L == 0L) {            dt /= 2L        }    }    var f = 3L    while (f <= 31622776L) {        if (dt % f == 0L) {            primeFactors.add(f)            while (dt % f == 0L) {                dt /= f            }        }        f += 2L    }    if (dt != 1L) {        primeFactors.add(dt)    }    fun calc(u: Long): Long {        var u = u        var res = 1L        var total = 0        for (p in primeFactors) {            var e = 0            while (u % p == 0L) {                u /= p                e++            }            total += e            res *= factorialInv[e]            res %= MOD        }        res *= factorial[total]        res %= MOD        return res    }    val out = StringBuilder()    for (j in 1..jin.readLine().toInt()) {        val line = jin.readLine()        val six = line.indexOf(' ')        var u = line.substring(0, six).toLong()        var v = line.substring(six + 1).toLong()        val g = gcd(u, v)        u /= g        v /= g        val answer = (calc(u) * calc(v)) % MOD        out.appendln(answer)    }    print(out)} fun gcd(a: Long, b: Long): Long {    var a = a    var b = b    while (b != 0L) {        a %= b        val c = a        a = b        b = c    }    return a} val MOD_TOTIENT = (MOD - 1).toInt() infix fun Long.pow(power: Int): Long {    var e = power    e %= MOD_TOTIENT    if (e < 0) {        e += MOD_TOTIENT    }    if (e == 0 && this == 0L) {        return this    }    var b = this % MOD    var res = 1L    while (e > 0) {        if (e and 1 != 0) {            res *= b            res %= MOD        }        b *= b        b %= MOD        e = e shr 1    }    return res}","combinatorics,graphs,greedy,math,number theory"
"import java.util.*import java.io.* fun gcd(a: Long, b: Long): Long{	if (b == 0L) return a	return gcd(b, a%b)} fun power(a: Long, b: Long, p: Long): Long{	if (b == 0L) return 1L	var t = power(a, b/2, p)	t = t*t%p	if (b%2 == 1L) t = t*a%p	return t} fun main() {	Thread(null, Main(), ""whatever"", 1 shl 28).start()} class Main : Runnable { 	override fun run()	{		val inputStream = System.`in`		val outputStream = System.out		val `in` = InputReader(inputStream)		val out = PrintWriter(outputStream)		val solver = TaskD()		var test = 1		//test = `in`.nextInt()		for (t in 1..test)		{			solver.solve(t, `in`, out)		}		out.close()	} 	internal class TaskD {		fun solve(testNumber: Int, `in`: InputReader, out: PrintWriter) {			val INF = 1000000000			val MOD = 998244353L			val dx = intArrayOf(-1, 1, 0, 0)			val dy = intArrayOf(0, 0, -1, 1) 			var D = `in`.nextLong()			var primes = ArrayList<Long>()			for (i in 2..10000000)			{				if (D%i == 0L)				{					primes.add(i.toLong())					while (D%i == 0L) D /= i					if (D == 1L) break				}			}			if (D > 1) primes.add(D)			var len = primes.size 			var fact = LongArray(60+1)			var rfact = LongArray(60+1)			fact[0] = 1L			for (i in 1..60) fact[i] = fact[i-1]*i%MOD			for (i in 0..60) rfact[i] = power(fact[i], MOD-2, MOD) 			fun getTable(x: Long): IntArray			{				var n = x				var res = IntArray(len, {0})				for (i in 0..len-1)				{					while (n%primes[i] == 0L)					{						n /= primes[i]						res[i] += 1					}				}				return res			} 			fun calc(a: IntArray): Long			{				var res = 1L				for (x in a) res *= x+1				return res			} 			fun solve(a: IntArray, b: IntArray): Long			{				var res = 1L				var cnt = 0				for (i in 0..len-1)				{					var tmp = a[i]-b[i]					cnt += tmp					res = res*rfact[tmp]%MOD				}				res = res*fact[cnt]%MOD				return res			} 			var tests = `in`.nextInt()			for (test in 1..tests)			{				var x = `in`.nextLong()				var y = `in`.nextLong()				if (x > y)				{					var tmp = x					x = y					y = tmp				}				if (x == y)				{					out.println(1)					continue				}				var d = gcd(x, y)				var m = x/d*y				var xt = getTable(x)				var yt = getTable(y)				var dt = getTable(d)				var mt = getTable(m)				var xc = calc(xt)				var yc = calc(yt)				var dc = calc(dt)				var mc = calc(mt)				var res = 0L				if (xc-dc+yc-dc <= mc-xc+mc-yc)				{					var tmp1 = solve(xt, dt)					var tmp2 = solve(yt, dt)					res = (res+tmp1*tmp2)%MOD				}				if (xc-dc+yc-dc >= mc-xc+mc-yc && m != y)				{					var tmp1 = solve(mt, xt)					var tmp2 = solve(mt, yt)					res = (res+tmp1*tmp2)%MOD				}				out.println(res)			}		} 	} 	internal class InputReader(stream: InputStream) {		var reader: BufferedReader		var tokenizer: StringTokenizer? = null 		init {			reader = BufferedReader(InputStreamReader(stream), 32768)			tokenizer = null		} 		operator fun next(): String {			while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {				try {					tokenizer = StringTokenizer(reader.readLine())				} catch (e: IOException) {					throw RuntimeException(e)				} 			}			return tokenizer!!.nextToken()		} 		fun nextInt(): Int {			return Integer.parseInt(next())		} 		fun nextLong(): Long {		    return next().toLong()		} 	}}","combinatorics,graphs,greedy,math,number theory"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.io.PrintWriterimport java.lang.StringBuilderimport java.util.*  class ModInt(x: Long) {     companion object {        const val MOD = 998244353L    }     val x = (x % MOD + MOD) % MOD     operator fun plus(other: ModInt): ModInt {        return ModInt(x + other.x)    }     operator fun minus(other: ModInt): ModInt {        return ModInt(x - other.x)    }     operator fun times(other: ModInt): ModInt {        return ModInt(x * other.x)    }     operator fun div(other: ModInt): ModInt {        return this * other.inv()    }     fun pow(exp: Long): ModInt {        if (exp == 0L) return ModInt(1L)        var a = pow(exp shr 1)        a *= a        if (exp and 1L == 0L) return a        return this * a    }     fun inv(): ModInt {        return this.pow(MOD - 2)    }     override fun equals(other: Any?): Boolean {        if (this === other) return true        if (javaClass != other?.javaClass) return false         other as ModInt         if (x != other.x) return false         return true    }     override fun hashCode(): Int {        return x.hashCode()    }     override fun toString(): String {        return ""$x""    } } val fac = mutableListOf<ModInt>()val facinv = mutableListOf<ModInt>() fun fact(n: Long): ModInt {    if (fac.count() == 0) fac.add(ModInt(1))    while (fac.count() <= n) {        fac.add(fac.last() * ModInt(fac.count().toLong()))    }    return fac[n.toInt()]} fun comb(n: Long, k: Long): ModInt {    return fact(n) / fact(k) / fact(n - k)} fun comb2(n: Long, k: Long): ModInt {    var ans = ModInt(1)    for (i in 0 until k) {        ans = ans * ModInt(n - i) / ModInt(k - i)    }    return ans} fun gcd(a:Long, b:Long):Long {    val c = a % b    if (c == 0L) return b    return gcd(b, c)} fun calc(n:Long, pf:Set<Long>):ModInt {    val lst = mutableListOf<Long>()    var m = n    var sum = 0L    for (p in pf) {        var count = 0L        while (m % p == 0L) {            m /= p            count++        }        if (count > 0) {            lst.add(count)            sum += count        }    }    var ret = fac[sum.toInt()]    for (r in lst) {        ret *= facinv[r.toInt()]    }    return ret} fun PrintWriter.solve(sc: FastScanner) {    fac.add(ModInt(1))    while (fac.count() <= 1000) {        fac.add(fac.last() * ModInt(fac.count().toLong()))    }    for (v in fac) {        facinv.add(ModInt(1) / v)    }     val d = sc.nextLong()    val pf = mutableSetOf<Long>()    var p = 2L    var m = d    while (p * p <= m) {        var count = 0        while (m % p == 0L) {            count++            m /= p        }        if (count > 0) {            pf.add(p)        }        p++    }    if (m != 1L) {        pf.add(m)    }    val q = sc.nextInt()    for (_i in 0 until q) {        val u = sc.nextLong()        val v = sc.nextLong()        val n = gcd(u, v)        val a = u / n        val b = v / n        println(calc(a, pf) * calc(b, pf))    }} fun main(args: Array<String>) {    val writer = PrintWriter(System.out, false)    writer.solve(FastScanner(System.`in`))    writer.flush()} class FastScanner(s: InputStream) {    private var st = StringTokenizer("""")    private val br = BufferedReader(InputStreamReader(s))     fun next(): String {        while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun nextInt() = next().toInt()    fun nextLong() = next().toLong()    fun nextLine() = br.readLine()    fun nextDouble() = next().toDouble()    fun ready() = br.ready()}","combinatorics,graphs,greedy,math,number theory"
fun main(){    var a = readLine()!!.toInt()    while(a > 1){        for(i in 2..a) if(a % i == 0){            print(i)            a /= i        }    }},"*special,math,number theory"
fun main() {    val n = readLine()!!.toInt()    for (p in 2..n) {        if (n % p == 0) {            print(p)            println(n / p)            return        }    }},"*special,math,number theory"
fun main() {    var x = readLine()!!.toInt()    var i = 2    while (x > 1) {        if (x % i == 0) {            print(i.toString())            x /= i        } else i++    }    println()},"*special,math,number theory"
"fun main(args: Array<String>) {    val input = readLine()!!     val n = input.toInt()    (2..n/2).forEach {        if (n % it == 0) {            print(""$it${n/it}"")            return        }    }}","*special,math,number theory"
"import java.util.* fun main() {    val out = StringBuilder()    repeat(readLine()!!.toInt()) {        val s = readLine()!!        val rem = TreeSet<Int>()        rem.addAll(1..s.length)        val bit = BinaryIndexTree(1, s.length)        for (k in 1..s.length) {            bit.update(k, 1)        }        val removals = mutableListOf<Pair<Int, Int>>()        val disp = TreeSet<Int>()        disp.addAll((1 until s.length).filter { k -> s[k - 1] == s[k] })        val dispBy = Array(26) { ArrayDeque<Int>() }        val freq = IntArray(26)        for (k in disp) {            dispBy[s[k] - 'a'].push(k)            freq[s[k] - 'a']++        }        fun remove(from: Int, to: Int) {            removals.add(Pair(bit.query(from) + 1, bit.query(to)))            while (rem.floor(to) ?: 0 > from) {                bit.update(rem.floor(to)!!, -1)                rem.remove(rem.floor(to)!!)            }            disp.remove(from)            disp.remove(to)            disp.lower(from)?.let { l -> dispBy[s[l] - 'a'].add(l) }            disp.higher(to)?.let { l -> dispBy[s[l] - 'a'].add(l) }            if (from > 0) {                freq[s[from] - 'a']--            }            if (to < s.length) {                freq[s[to] - 'a']--            }        }        while (true) {            val letter = ('a'..'z').maxBy { freq[it - 'a'] }!!            var found = false            while (dispBy[letter - 'a'].isNotEmpty()) {                val k = dispBy[letter - 'a'].pop()                if (k in disp) {                    var j = disp.lower(k)                    if (j != null && s[j] != s[k]) {                        remove(j, k)                        found = true                        break                    }                    j = disp.higher(k)                    if (j != null && s[j] != s[k]) {                        remove(k, j)                        found = true                        break                    }                }            }            if (!found) {                break            }        }        for (k in disp.toList()) {            remove(0, k)        }        remove(0, s.length)        out.appendln(removals.size)        removals.forEach { (from, to) -> out.appendln(""$from $to"") }    }    print(out)} class BinaryIndexTree(val treeFrom: Int, treeTo: Int) {    val value = IntArray(treeTo - treeFrom + 2)     fun update(index: Int, delta: Int) {        var i = index + 1 - treeFrom        while (i < value.size) {            value[i] += delta            i += i and -i        }    }     fun query(to: Int): Int {        var res = 0        var i = to + 1 - treeFrom        while (i > 0) {            res += value[i]            i -= i and -i        }        return res    }     operator fun get(from: Int, to: Int) = if (to < from) 0 else query(to) - query(from - 1)}","constructive algorithms,data structures"
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport java.lang.IndexOutOfBoundsExceptionimport java.util.*import kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        val S = fakein.toString()        println(""New Case "")        println(S.take(80))        println(""..."")        fakein.clear()        IN = BufferedInputStream(S.byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} val getint:Int get() = IO.nextInt()val getlong:Long get() = IO.nextLong()val getstr:String get() = IO.nextString()fun getline(n:Int):IntArray{    return IntArray(n){getint}}fun getlineL(n:Int):LongArray{    return LongArray(n){getlong}}fun getbinary(n:Int, asTrue:Char):BooleanArray{    val str = getstr    return BooleanArray(n){str[it] == asTrue}} val List<Char>.ret:Stringget() = this.joinToString("""")var dmark = -1infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    dmark++    var str = ""<${dmark}>   ""    debug()    if(this is String){ str += this    }else if(this is Int){ str += this.toString()    }else if(this is Long){ str += this.toString()    }else{ str += this.toString()}    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is BooleanArray){ println(""$str :${a.map{if(it)'1' else '0'}.joinToString("" "")}"")    }else if(a is Array<*>){        println(""$str : "")        for(c in a){if(c is IntArray){println(c.joinToString("" ""))}        else if(c is LongArray){println(c.joinToString("" ""))}        else if(c is BooleanArray){println(c.map { if(it) '1' else '0' }.joinToString(""""))        }         }        println()    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){    throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){        throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    fun cases(onecase:()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint} else if(mode == solveMode.tc){1 } else randCount        //safety checks        if(pI != 998_244_353 && pI != 1_000_000_007){            throw Exception(""Modding a wrong prime!"")        }        if(withBruteForce){            println(""Brute force is active"")        }         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            onecase()        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }}inline fun<T> T.alsoBrute(cal:() -> T){    if(!withBruteForce) return    val also = cal()    if(this != also){        println(""Checking failed: Got ${this} Brute ${also}"")        crash()    }}// 1. Moddedconst val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}infix fun Int.modM(b:Int):Int{ return ((this * 1L * b) % pI).toInt() }infix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }// 2. DP initial valuesconst val plarge = 1_000_000_727const val nlarge = -plargeconst val phuge = 2_727_000_000_000_000_000Lconst val nhuge = -phuge// 3. conveniecen conversionsval Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionval Char.code :Int get() = this.toInt() -  'a'.toInt()//3. hard to write stufffun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val mint:MutableList<Int> get() = mutableListOf<Int>()val mong:MutableList<Long> get() = mutableListOf<Long>()//4. more outputsfun List<Char>.conca():String = this.joinToString("""")val CharArray.conca :String get() = this.joinToString("""")val IntArray.conca :String get() = this.joinToString("" "")@JvmName(""concaInt"")fun List<Int>.conca():String = this.joinToString("" "")val LongArray.conca:String get() = this.joinToString("" "")@JvmName(""concaLong"")fun List<Long>.conca():String = this.joinToString("" "")//5. Pair of intsconst val longmask = (1L shl 32) - 1fun makepair(a:Int, b:Int):Long = (a.toLong() shl 32) xor (longmask and b.toLong()) // remember positev sonlyval Long.first get() = (this ushr 32).toInt()val Long.second get() = this.toInt()//6. stringsval String.size get() = this.lengthconst val randCount = 100  fun String.sliceTo(right:Boolean,i:Int):Int {    var end = i    while(true){        val next = if(right) end + 1 else end - 1        if(next < 0 || next >= this.size){            break        }        if(this[next] == this[end]){            if(right){                end++            } else {                end--            }        }else{            break        }    }    return end}fun debug(){}const val withBruteForce = falseconst val singleCase = false class item(var l:Int, var r:Int, val c:Char):Comparable<item>{    override fun compareTo(other:item):Int {         return this.l.compareTo(other.l)    }     val able = BooleanArray(2)     fun dies(){        if(able[0] or able[1]){            allable[c.code].remove(this)        }     }    fun setable(i:Int,new:Boolean ){        val olda = able[0] or able[1]        able[i] = new        val newa = able[0] or able[1]        if(olda != newa){            if(newa){                allable[c.code].add(this)            }else{                allable[c.code].remove(this)            }        }    }      fun update(){        val left = all.lower(this)        val useleft = left != null && left.c != this.c        val right = all.higher(this)        val useright = right != null && right.c != this.c        setable(0,useleft)        setable(1,useright)    }     var len:Int = r - l + 1}class simpleSegTree (nSuggest  :Int){    //Items lenght must be a power of 2     val n = (maxOf((nSuggest - 1).takeHighestOneBit(),2)) shl 1    val levels = (31 - n.countLeadingZeroBits()) // (Levels) amount of levels then a layer of leaf    val arr = IntArray(n * 2 + 1 )    val arrSize = n * 2 + 1     constructor(withArray:IntArray):this(withArray.size){        for(i in withArray.indices){            arr[i+n] = withArray[i]        }         updateAll()    }     private fun updateNode(i:Int){        arr[i] = arr[i shl 1 ] + arr[(i shl 1) + 1]    }    private fun updatePath(i:Int){        // i is the endpoint, typically (n+i)        // bottom up, recalculate        var here = i        while(here > 1){            here = here shr 1            updateNode(here)        }    }    fun updateAll(){        for(i in n-1 downTo 1){            updateNode(i)        }    }    fun setValue(i:Int,value:Int){        arr[n+i] = value        updatePath(n+i)    }    fun addValue(i:Int, inc:Int){        arr[n+i] += inc        updatePath(n+i)    }     val firstIndex = n    val lastIndex = (n shl 1 ) - 1    val indices = firstIndex..lastIndex      fun primitiveIndex(a:Int) = a + n    inline fun segmentOrder(act:(here:Int, left:Int,right:Int)->Unit ){        //iterate over all segments bottom up, probably to rebuild tree        for(i in (n-1) downTo 1){            act(i, (i shl 1 ), (i shl 1) + 1)        }    }    inline fun primitiveOrder(act:(here:Int,primitiveIndex:Int)->Unit){        //iterate over all the leaf nodes        for(i in 0 until n){            act(i+n,i)        }    }      fun query(l:Int,r:Int): Int {        var ret:Int = 0        var left = l + n        var right = r + n+1        while(left < right){            if(left and 1 != 0){                ret += arr[left]                left += 1            }            if(right and 1 != 0){                right -= 1                ret += arr[right]            }            left = left shr 1            right = right shr 1        }        return ret    }    inline fun segDivision(l:Int, r:Int, act:(index:Int,level:Int)->Unit){        var left = l + n        var right = r + n + 1        var level = 0        while(left < right){            if(left and 1 != 0){                 act(left,level)                left += 1            }            if(right and 1 != 0){                right -= 1                act(right,level)            }            left = left shr 1            right = right shr 1            level ++        }    }     fun queryFunctional(l:Int,r:Int):Int{        var ret = 0        segDivision(l,r){i, _ ->            ret += arr[i]        }        return ret    }    fun indexOf(req:Int):Int{        // -1 if not enough        val req = req + 1        if(req > arr[1]){            throw IndexOutOfBoundsException()        }else if(req <= 0 ){            return -1        }        var i = 1        var rightPoint = -1        var cur = 0        for(l in 1..levels){            i = i shl 1            if(cur + arr[i] < req){                rightPoint += 1 shl (levels - l)                cur += arr[i]                i += 1            }        }        return rightPoint +1    }      val Int.leftNode:Int get(){        // assert(this <= n )        return this shl 1    }    val Int.rightNode:Int get(){        // assert(this <= n)        return (this shl 1) + 1    }    val Int.endpoints:Pair<Int,Int> get(){        val offSet = this - this.takeHighestOneBit()        val widthLevel = levels - (31 - this.countLeadingZeroBits())        return Pair(offSet shl widthLevel, (offSet shl widthLevel) + (1 shl widthLevel) - 1)    }       //like set    fun contains(a:Int): Boolean {        return arr[a+n] == 1    }    fun add(a:Int){        if(!contains(a)){            addValue(a,1)        }    }    fun remove(a:Int){        if(contains(a)){            addValue(a,-1)        }    }    fun numberInRange(l:Int, r:Int):Int{        return query(l,r)    }    val size:Int get() = this.arr[1]    operator fun get(a:Int):Int{        return indexOf(a)    }    fun first():Int{        return get(0)    }    fun last():Int{        return get(size - 1)    }} val allable = List(26){TreeSet<item>()}val all = TreeSet<item>()fun main(){    val choice = listOf('a','b','c')    solve.tc {        share(List(200000){choice.random()}.conca())    }//    solve.usetc()//    solve.userand()    solve.cases{        all.clear()        for(a in allable){            a.clear()        }		val str = getstr        val n = str.length         val here = TreeSet<Int>()        val st = simpleSegTree(IntArray(n){1})         for(i in 0 until n){            here.add(i)        }        fun firstIn(l:Int, r:Int):Int{            val ret = here.ceiling(l)!!            assert(ret <= r)            return ret        }        fun lastIn(l:Int, r:Int):Int{            val ret = here.floor(r)!!            assert(ret >= l)            return ret        }        fun delete(l:Int, r:Int){            while(true){                val next = here.ceiling(l) ?: return                if(next <= r){                    here.remove(next)                    st.remove(next)                }else{                    return                }            }        }         val ret = mutableListOf<Pair<Int,Int>>()        fun give(l:Int, r:Int){            val ll = st.query(0,l-1)            val rr = st.query(0,r) - 1            assert(ll <= rr)            ret.add(Pair(ll,rr))        }         val aaaaa = all        var left = 0        val maxtypes = IntArray(26)        while(left < n){            val right = str.sliceTo(true,left)            val new = item(left,right,str[left])            if(new.len != 1) all.add(new)            maxtypes[new.c.code] += new.len - 1            left = right +  1        }        for(a in all){            a.update()        }          while(true){//            assert(all.all { it.len != 1 })            val m = maxtypes.maxOrNull()!!            if(m == 0 ) break            val c = maxtypes.indexOf(m)            if(allable[c].isEmpty()){                break            }            val taking = allable[c].first()             val goright = taking.able[1]            val consider = (if(goright) all.higher(taking) else all.lower(taking))!!             val l :Int            val r:Int//            val l = if(goright) taking.r else consider.r//            val r = if(goright) consider.l else taking.l             if(goright){                l = lastIn(taking.l,taking.r)                r = firstIn(consider.l,consider.r)            }else{                l = lastIn(consider.l, consider.r)                r = firstIn(taking.l,taking.r)            }            consider.len --            taking.len --            if(consider.len == 1){                all.remove(consider)                consider.dies()                all.higher(consider)?.update()                all.lower(consider)?.update()            }            if(taking.len == 1){                all.remove(taking)                taking.dies()                all.higher(taking)?.update()                all.lower(taking)?.update()            }            maxtypes[consider.c.code] --            maxtypes[taking.c.code] --            give(l,r)            delete(l,r)        }        for(a in all){            repeat(a.len - 1){                val f = firstIn(a.l,a.r)                give(f,f)                delete(f,f)            }        }        give(0,n-1)         put(ret.size)        for((a,b) in ret){            put(""${a+1} ${b+1}"")        }          }    done()}/*abbcbba1aaabbb 1aaaaaabccbbacccccaba */   ","constructive algorithms,data structures"
"const val ALL = (1 shl 18) - 1val DUMMY = Edge(-1, -1) fun main() {    val n = readLine()!!.toInt()    val ages = listOf(0) + readLine()!!.split("" "").map { it.toInt() }.sorted()    var answer = 0L    for (age in ages) {        answer -= age.toLong()    }    val components = (0..n).toMutableSet()    val union = IntArray(ages.size) { it }    val members = Array(ages.size) { mutableListOf(it) }    val dp = Array(2) { IntArray(1 shl 18) }    while (components.size > 1) {        val componentList = components.toList()        val edges = Array(componentList.size) { DUMMY }        dp.forEach { it.fill(-1) }        for (k in 0..n) {            if (k > dp[0][ages[k]]) {                if (dp[0][ages[k]] != -1 && union[dp[0][ages[k]]] != union[k]) {                    dp[1][ages[k]] = dp[0][ages[k]]                }                dp[0][ages[k]] = k            } else if (union[k] != union[dp[0][ages[k]]] && k > dp[1][ages[k]]) {                dp[1][ages[k]] = k            }        }        for (mask in 0..ALL) {            for (e in 0..17) {                if ((mask shr e) and 1 != 0) {                    var pos = dp[0][mask - (1 shl e)]                    if (pos > dp[0][mask]) {                        if (dp[0][mask] != -1 && union[dp[0][mask]] != union[pos]) {                            dp[1][mask] = dp[0][mask]                        }                        dp[0][mask] = pos                    } else if (pos > dp[1][mask] && union[pos] != union[dp[0][mask]]) {                        dp[1][mask] = pos                    }                    pos = dp[1][mask - (1 shl e)]                    if (pos > dp[1][mask] && union[pos] != union[dp[0][mask]]) {                        dp[1][mask] = pos                    }                }            }        }        for (j in componentList.indices) {            for (k in members[componentList[j]]) {                var k2 = dp[0][ALL - ages[k]]                if (k2 != -1 && union[k2] == union[k]) {                    k2 = dp[1][ALL - ages[k]]                }                if (k2 != -1 && (edges[j].a == -1 || ages[k] + ages[k2] > ages[edges[j].a] + ages[edges[j].b])) {                    edges[j] = Edge(k, k2)                }            }        }        edges.sortByDescending { if (it.a == -1) -1 else ages[it.a] + ages[it.b] }        for (edge in edges) {            if (edge.a != -1) {                val u = union[edge.a]                val v = union[edge.b]                if (u != v) {                    answer += (ages[edge.a] + ages[edge.b]).toLong()                    if (members[u].size > members[v].size) {                        members[v].forEach { union[it] = u }                        members[u].addAll(members[v])                        components.remove(v)                    } else {                        members[u].forEach { union[it] = v }                        members[v].addAll(members[u])                        components.remove(u)                    }                }            }        }    }    println(answer)} data class Edge(val a: Int, val b: Int)","bitmasks,brute force,dp,dsu,graphs"
,
"import kotlin.math.abs fun main(){    fun readInt() = readLine()!!.toInt()    repeat(readInt()){        val n = readInt()        val a = readLine()!!.split(' ').map(String::toInt)        val b = mutableListOf<Int>()        for(i in 0 until n) if(a[i] == -1){            if(i > 0 && a[i - 1] != -1) b.add(a[i - 1])            if(i + 1 < n && a[i + 1] != -1) b.add(a[i + 1])        }        val k = if(b.isEmpty()) 0 else (b.max()!! + b.min()!!) / 2        val c = a.map{if(it == -1) k else it}        println(""${(1 until n).map{abs(c[it] - c[it - 1])}.max()} $k"")    }}","binary search,greedy,ternary search"
"fun abs(x: Int) = if (x < 0) -x else x fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main(unused: Array<String>) {    for (t in 1..readInt()) {        val n = readInt()        val a = readInts()         val (lowPart, highPart) = (0 until n)            .filter { i -> a[i] != -1 && ((i > 0 && a[i - 1] == -1) || (i < n - 1 && a[i + 1] == -1)) }            .map { i -> a[i] }            .let { (it.min() ?: 0) to (it.max() ?: 0) }        val constPart = (0 until n - 1)            .filter { i -> a[i] != -1 && a[i + 1] != -1 }            .map { i -> abs(a[i] - a[i + 1]) }            .max() ?: 0         val k = (lowPart + highPart) / 2         println(""${maxOf(constPart, abs(lowPart - k), abs(highPart - k))} $k"")    }}","binary search,greedy,ternary search"
"import kotlin.math.absimport kotlin.math.max fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main() {    repeat(readInt()) {        val n = readInt()        val vs = readInts()        val diff = (1 until n).map {            val l = vs[it-1]            val r = vs[it]            if (l != -1 && r != -1) abs(l-r) else 0        }.max() ?: 0        val nums = (1 until n).mapNotNull {            val l = vs[it-1]            val r = vs[it]            when {                l == -1 && r != -1 -> r                r == -1 && l != -1 -> l                else -> null            }        }        val mn = nums.min() ?: 0        val mx = nums.max() ?: 0        val k = (mx + mn) / 2        val m = max(diff, max(k - mn, mx - k))        println(""$m $k"")    }}","binary search,greedy,ternary search"
"import kotlin.math.absimport kotlin.math.maximport kotlin.math.min fun main() {    val t = readLine()!!.toInt()    repeat(t) {        val n = readLine()!!.toInt()        val a = readLine()!!.split(' ').map(String::toLong)        var maxx = Long.MIN_VALUE        var minx = Long.MAX_VALUE        var maxd = Long.MIN_VALUE        for (i in 0..(n - 2)) {            when {                a[i] == -1L && a[i + 1] != -1L -> {                    maxx = max(maxx, a[i + 1])                    minx = min(minx, a[i + 1])                }                a[i] != -1L && a[i + 1] == -1L -> {                    maxx = max(maxx, a[i])                    minx = min(minx, a[i])                }                a[i] != -1L && a[i + 1] != -1L -> {                    maxd = max(maxd, abs(a[i] - a[i + 1]))                }            }        }        if (minx == Long.MAX_VALUE) {            println(""0 0"")        } else {            val m = (minx + maxx) / 2            val k = max(maxd, max(maxx - m, m - minx))            println(""$k $m"")        }    }}","binary search,greedy,ternary search"
"class Tree(){    var min = 0L    private var add = 0L    private var l = 0    private var r = 0    var left : Tree? = null    var right : Tree? = null    constructor(l : Int, r : Int) : this() {        this.l = l        this.r = r        if(l < r){            val m = (l + r) / 2            left = Tree(l, m)            right = Tree(m + 1, r)        }    }    private fun add(v : Long){        add += v        min += v    }    private fun pushDown(){        if(l < r){            left!!.add(add)            right!!.add(add)        }        add = 0L    }    fun add(L : Int, R : Int, v : Long){        if((l >= L) and (r <= R)) add(v)        else{            pushDown()            val m = (l + r) / 2            if(L <= m) left!!.add(L, R, v)            if(R > m) right!!.add(L, R, v)            min = minOf(left!!.min, right!!.min)        }    }}fun main(){    val n = readLine()!!.toInt()    val p = readLine()!!.split(' ').map{it.toInt() - 1}    val a = readLine()!!.split(' ').map{it.toLong()}    val root = Tree(0, n)    for(i in 0 until n) root.add(p[i] + 1, n, a[i])    var ans = a[0]    for(i in 0 until p.lastIndex){        root.add(p[i] + 1, n, -a[i])        root.add(0, p[i], a[i])        ans = minOf(ans, root.min)    }    println(ans)}","data structures,divide and conquer"
" private fun ri() = readLine()!!.split(' ').map { it.toInt() }private fun rl() = readLine()!!.split(' ').map { it.toLong() } const val N = 2e5.toInt()var b = LongArray(N + 3) data class Seg(var l: Int, var r: Int, var mi: Long, var tag: Long = 0) val t = Array(N shl 2) { Seg(0, 0, 0) } fun build(p: Int, l: Int, r: Int) {    t[p].l = l    t[p].r = r    if (l == r) {        t[p].mi = b[l]        return    }    val mid = (l + r) shr 1    build(p shl 1, l, mid)    build(p shl 1 or 1, mid + 1, r)    t[p].mi = minOf(t[p shl 1].mi, t[p shl 1 or 1].mi)} fun pushdown(p: Int) {    if (t[p].tag != 0L) {        t[p shl 1].mi += t[p].tag        t[p shl 1 or 1].mi += t[p].tag        t[p shl 1].tag += t[p].tag        t[p shl 1 or 1].tag += t[p].tag        t[p].tag = 0    }} fun update(p: Int, l: Int, r: Int, x: Int) {    if (r < l) return    if (t[p].l >= l && t[p].r <= r) {        t[p].mi += x        t[p].tag += x        return    }    pushdown(p)    val mid = t[p].l + t[p].r shr 1    if (l <= mid) update(p shl 1, l, r, x)    if (r > mid) update(p shl 1 or 1, l, r, x)    t[p].mi = minOf(t[p shl 1].mi, t[p shl 1 or 1].mi)} fun query(p: Int, l: Int, r: Int) : Long{//    println(""l r p tl tr :: $l $r $p"")    if (t[p].l >= l && t[p].r <= r) {        return t[p].mi    }    pushdown(p)    val mid = t[p].l + t[p].r shr 1    var res = Long.MAX_VALUE    if (l <= mid) res = minOf(res, query(p shl 1, l, r))    if (r > mid) res = minOf(res, query(p shl 1 or 1, l, r))    return res} fun main() {     val (n) = ri()    val p = ri()    val a = ri()//    println(""${t::class.simpleName}"")    val id = IntArray(n + 1)    for ((i, x) in a.withIndex()) {        b[i + 1] = b[i] + x        id[p[i]] = i + 1    }    build(1, 1, n - 1)    var ans = query(1, 1, n - 1)     for (i in 1..n) {        update(1, 1, id[i] - 1, a[id[i] - 1])        update(1, id[i], n - 1, -a[id[i] - 1])         ans = minOf(ans, query(1, 1, n - 1))    }    println(ans)}","data structures,divide and conquer"
"import java.util.*import kotlin.math.min fun main() {    val n = readLine()!!.toInt()    val p = IntArray(n + 1)    val pos = IntArray(n + 1)    var tokenizer = StringTokenizer(readLine()!!)    for (j in 1..n) {        p[j] = tokenizer.nextToken().toInt()        pos[p[j]] = j    }    tokenizer = StringTokenizer(readLine()!!)    val a = LongArray(n + 1)    for (j in 1..n) {        a[p[j]] = tokenizer.nextToken().toLong()    }    val segTree = LazySegmentTree(0, n)    for (j in 1..n) {        segTree.update(pos[j], n, a[j])    }    var answer = segTree.query(1, n - 1)    for (j in 1..n) {        segTree.update(pos[j], n, -a[j])        segTree.update(0, pos[j] - 1, a[j])        answer = min(answer, segTree.query(1, n - 1))    }    println(answer)} class LazySegmentTree(val treeFrom: Int, val treeTo: Int) {    val `val`: LongArray    val lazy: LongArray    fun combine(a: Long, b: Long): Long {        return min(a, b)    }     fun propagate(node: Int) {        `val`[node] += lazy[node]        if (node shl 1 < `val`.size) {            lazy[node shl 1] += lazy[node]            lazy[(node shl 1) + 1] += lazy[node]        }        lazy[node] = 0    }     fun eval(node: Int): Long {        return `val`[node] + lazy[node]    }     fun update(from: Int, to: Int, delta: Long) {        update(1, treeFrom, treeTo, from, to, delta)    }     fun update(node: Int, segFrom: Int, segTo: Int, from: Int, to: Int, delta: Long) {        if (segTo < from || segFrom > to) return        if (segFrom >= from && segTo <= to) {            lazy[node] += delta            return        }        propagate(node)        val mid = segFrom + segTo shr 1        update(node shl 1, segFrom, mid, from, to, delta)        update((node shl 1) + 1, mid + 1, segTo, from, to, delta)        `val`[node] = combine(eval(node shl 1), eval((node shl 1) + 1))    }     fun query(from: Int, to: Int): Long {        return query(1, treeFrom, treeTo, from, to)    }     fun query(node: Int, segFrom: Int, segTo: Int, from: Int, to: Int): Long {        if (segTo < from || segFrom > to) return IDENTITY        if (segFrom >= from && segTo <= to) {            return eval(node)        }        propagate(node)        val mid = segFrom + segTo shr 1        val res = combine(                query(node shl 1, segFrom, mid, from, to),                query((node shl 1) + 1, mid + 1, segTo, from, to)        )        `val`[node] = combine(eval(node shl 1), eval((node shl 1) + 1))        return res    }     companion object {        const val IDENTITY = Long.MAX_VALUE    }     init {        val length = treeTo - treeFrom + 1        var l: Int        l = 0        while (1 shl l < length) {            l++        }        `val` = LongArray(1 shl l + 1)        lazy = LongArray(1 shl l + 1)    }}","data structures,divide and conquer"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"") import java.io.PrintWriterimport java.util.StringTokenizerimport kotlin.math.*import kotlin.random.*import kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {    val n = readInt()    val P = IntArray(n) { readInt() - 1 }    val A = readIntArray(n)     val Q = IntArray(n)    for(i in 0 until n) { Q[P[i]] = i }     val t = PropagatingSegmentTree(n-1).apply {        var acc = 0L        build {            acc += A[it]            acc        }    }     var ans = t.query(0, n-2)    for(i in 0 until n) {        val q = Q[i]        t.update(q, n-2, -A[q].toLong())        t.update(0, q-1, A[q].toLong())         ans = min(ans, t.query(0, n-2))    }     println(ans)} class PropagatingSegmentTree(    val size: Int) {    inline fun combiner(a: Long, b: Long): Long = min(a, b)    inline fun updateCombiner(a: Long, b: Long): Long = a + b    inline fun updater(t: Long, u: Long): Long = t + u     private inline fun treeSize() = if(size == 0) 0 else Integer.highestOneBit(size.shl(2) - 1)     private val tree = LongArray(treeSize()) { Long.MAX_VALUE }    private val lazy = LongArray(tree.size)     fun build(list: LongArray) {        if(size == 0) return        build(list, 1, 0, size-1)    }     fun build(generator: (Int) -> Long) { build(LongArray(size, generator)) }     private inline fun mid(low: Int, high: Int) = (low + high) shr 1    private fun build(list: LongArray, node: Int, a: Int, b: Int) {        if(a == b) {            tree[node] = list[a]            return        }         build(list, node shl 1, a, mid(a, b))        build(list, node shl 1 or 1, 1 + mid(a, b), b)        updateNode(node)    }     private inline fun updateNode(i: Int) {        tree[i] = combiner(tree[i shl 1], tree[i shl 1 or 1])    }     fun update(first: Int, last: Int, value: Long) {        update(1, 0, size-1, first, last, value)    }    fun update(range: IntRange, value: Long) {        update(range.first, range.last, value)    }     private inline fun updateLazy(i: Int, u: Long) {        lazy[i] = updateCombiner(lazy[i], u)    }     private fun propagate(node: Int, a: Int, b: Int) {        tree[node] = updater(tree[node], lazy[node])        if(a != b) {            updateLazy(node shl 1, lazy[node])            updateLazy(node shl 1 or 1, lazy[node])        }        lazy[node] = 0L    }     private fun update(node: Int, a: Int, b: Int, i: Int, j: Int, u: Long) {        if(lazy[node] != 0L) {            propagate(node, a, b)        }         if(a > b || a > j || b < i) return         if(a >= i && b <= j) {            lazy[node] = u            propagate(node, a, b)            return        }         update(node shl 1, a, mid(a, b), i, j, u)        update(node shl 1 or 1, 1 + mid(a, b), b, i, j, u)         updateNode(node)    }     fun query(first: Int, last: Int) =        query(1, 0, size-1, first, last)    fun query(range: IntRange) =        query(range.first, range.last)     private fun query(node: Int, a: Int, b: Int, i: Int, j: Int): Long {        if(a > b || a > j || b < i) return Long.MAX_VALUE        if(lazy[node] != 0L) {            propagate(node, a, b)        }         if(a >= i && b <= j) {            return tree[node]        }         val l = query(node shl 1, a, mid(a, b), i, j)        val r = query(node shl 1 or 1, 1 + mid(a, b), b, i, j)         return combiner(l, r)    }} /** IO code start *///@JvmField val INPUT = File(""input.txt"").inputStream()//@JvmField val OUTPUT = File(""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out @JvmField val _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /** shuffles and sort overrides to avoid quicksort attacks */private inline fun <T> _shuffle(rnd: Random, get: (Int) -> T, set: (Int, T) -> Unit, size: Int) {    // Fisher-Yates shuffle algorithm    for (i in size - 1 downTo 1) {        val j = rnd.nextInt(i + 1)        val temp = get(i)        set(i, get(j))        set(j, temp)    }} @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } fun IntArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)fun IntArray.sort() { shuffle(); _sort() }fun IntArray.sortDescending() { shuffle(); _sortDescending() } fun LongArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)fun LongArray.sort() { shuffle(); _sort() }fun LongArray.sortDescending() { shuffle(); _sortDescending() } fun DoubleArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)fun DoubleArray.sort() { shuffle(); _sort() }fun DoubleArray.sortDescending() { shuffle(); _sortDescending() } fun CharArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T: Comparable<T>> Array<out T>.sort() = _sort()inline fun <T: Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T: Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T: Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() fun `please stop removing these imports IntelliJ`() {    iprintln(max(1, 2))}","data structures,divide and conquer"
"//package codeforces.round614 fun main() {	readLn()	val a = readInts()	val aCount = a.groupBy { it }.mapValues { it.value.size }	var b = aCount.keys.toList()	val (primes, factPrimes) = List(2) { MutableList(2) { listOf<Int>() } }	for (i in 2..b.max()!!) {		val j = (2..i).first { i % it == 0 }		primes.add(primes[i / j].plus(j))		factPrimes.add(factPrimes[i - 1].plus(primes[i]).sortedDescending())	}	var ans = aCount.map { factPrimes[it.key].size * 1L * it.value }.sum()	for (x in factPrimes.last().indices) {		val groups = b.groupBy { factPrimes[it].getOrNull(x) }		val win = groups.mapValues { entry -> 2 * entry.value.sumBy { aCount.getValue(it) } - a.size }		val p = win.entries.firstOrNull { it.value > 0 }?.key ?: break		ans -= win.getValue(p)		b = groups.getValue(p)	}	println(ans)} private fun readLn() = readLine()!!private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","dp,graphs,greedy,math,number theory,trees"
"//package codeforces.round614 fun main() {	readLn()	val data = readInts()	val aCount = data.groupBy { it }.mapValues { it.value.size }	val m = aCount.keys.max()!!	val (primes, factPrimes) = List(2) { MutableList(2) { listOf<Int>() } }	for (i in 2..m) {		val j = (2..i).first { i % it == 0 }		primes.add(primes[i / j].plus(j))		factPrimes.add(factPrimes[i - 1].plus(primes[i]).sortedDescending())	}	var ans = aCount.map { factPrimes[it.key].size * 1L * it.value }.sum()	var b = aCount.keys.toList()	for (x in factPrimes.last().indices) {		val count = mutableMapOf<Int, Int>().withDefault { 0 }		for (v in b) {			val p = factPrimes[v].getOrNull(x) ?: continue			count[p] = count.getValue(p) + aCount.getValue(v)		}		val p = count.keys.firstOrNull { p -> 2 * count[p]!! > data.size } ?: break		ans -= 2 * count[p]!! - data.size		b = b.filter { v -> factPrimes[v].getOrNull(x) == p }	}	println(ans)} private fun readLn() = readLine()!!private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","dp,graphs,greedy,math,number theory,trees"
"//package codeforces.round614 fun main() {	readLn()	val data = readInts()	val aCount = data.groupBy { it }.mapValues { it.value.size }	val m = aCount.keys.max()!!	val (primes, factPrimes) = List(2) { MutableList(2) { listOf<Int>() } }	for (i in 2..m) {		val j = (2..i).first { i % it == 0 }		primes.add(primes[i / j].plus(j))		factPrimes.add(factPrimes[i - 1].plus(primes[i]).sortedDescending())	}	var ans = aCount.keys.map { factPrimes[it].size * 1L * aCount.getValue(it) }.sum()	var x = 0	var b = aCount.keys.toList()	while (true) {		val count = mutableMapOf<Int, Int>()		for (v in b) {			val f = factPrimes[v]			if (x >= f.size) continue			val p = f[x]			count[p] = count.getOrDefault(p, 0) + aCount[v]!!		}		val p = count.keys.firstOrNull { p -> count[p]!! * 2 > data.size } ?: break		val c = count[p]!!		ans += data.size - 2 * c		b = b.filter { v ->			val f = factPrimes[v]			x < f.size && f[x] == p		}		x++	}	println(ans)} private fun readLn() = readLine()!!private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","dp,graphs,greedy,math,number theory,trees"
"fun main() {	readLn()	val data = readInts()	val aCount = mutableMapOf<Int, Int>()	for (v in data) {		aCount[v] = aCount.getOrDefault(v, 0) + 1	}	val m = aCount.keys.max()!!//	val isPrime = (0..m).map { i -> (i >= 2) && (2 until i).all { j -> i % j != 0 } }	val myPrimes = MutableList(m + 1) { listOf<Int>() }	val factPrimes = MutableList(m + 1) { listOf<Int>() }	for (i in 2..m) {		val j = (2..i).first { j -> i % j == 0 }		myPrimes[i] = myPrimes[i / j].plus(j)		factPrimes[i] = factPrimes[i - 1].plus(myPrimes[i]).sortedDescending()	}	var ans = 0L	for (x in aCount.keys) {		ans += factPrimes[x].size * 1L * aCount[x]!!	}	var x = 0	var b = aCount.keys.toList()	while (true) {		val count = mutableMapOf<Int, Int>()		for (v in b) {			val f = factPrimes[v]			if (x >= f.size) continue			val p = f[x]			count[p] = count.getOrDefault(p, 0) + aCount[v]!!		}		val p = count.keys.firstOrNull { p -> count[p]!! * 2 > data.size } ?: break		val c = count[p]!!		ans += data.size - 2 * c		b = b.filter { v ->			val f = factPrimes[v]			x < f.size && f[x] == p		}		x++	}	println(ans)} private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","dp,graphs,greedy,math,number theory,trees"
"//package codeforces.round614 import kotlin.math.abs fun main() {	val (x0, y0, ax, ay, bx, by) = readLongs()	val (xs, ys, t) = readLongs()	val points = mutableListOf(x0 to y0)	while (true) {		val (x, y) = ax * points.last().first + bx to ay * points.last().second + by		if (xs + ys + t < x + y) break		points.add(x to y)	}	val best = points.indices.mapNotNull { i ->		points.indices.mapNotNull { j ->			(abs(j - i) + 1).takeIf { dist(xs to ys, points[i]) + dist(points[i], points[j]) <= t }		}.max()	}.max() ?: 0	println(best)} fun dist(a: Pair<Long, Long>, b: Pair<Long, Long>): Long {	return abs(a.first - b.first) + abs(a.second - b.second)} private operator fun <E> List<E>.component6(): E = get(5)private fun readLn() = readLine()!!private fun readStrings() = readLn().split("" "")private fun readLongs() = readStrings().map { it.toLong() }","brute force,constructive algorithms,geometry,greedy,implementation"
"import java.util.*import kotlin.math.absimport kotlin.math.max fun main() {    val jin = Scanner(System.`in`)    val x = LongArray(100)    val y = LongArray(100)    x[0] = jin.nextLong()    y[0] = jin.nextLong()    val ax = jin.nextLong()    val ay = jin.nextLong()    val bx = jin.nextLong()    val by = jin.nextLong()    val xs = jin.nextLong()    val ys = jin.nextLong()    val t = jin.nextLong()    var j = 1    while (true) {        x[j] = (ax * x[j - 1]) + bx        y[j] = (ay * y[j - 1]) + by        if (x[j] + y[j] >= 30000000000000000) {            break        }        j++    }    var answer = 0    for (k1 in 0..j) {        for (k2 in 0..j) {            val d = (abs(xs - x[k1]) + abs(ys - y[k1])) + (abs(x[k2] - x[k1]) + abs(y[k2] - y[k1]))            if (d <= t) {                answer = max(answer, abs(k1 - k2) + 1)            }        }    }    println(answer)}","brute force,constructive algorithms,geometry,greedy,implementation"
"import kotlin.math.abs fun main() {	val (x0, y0, ax, ay, bx, by) = readLongs()	val (xs, ys, t) = readLongs()	val points = mutableListOf(x0 to y0)	while (true) {		val last = points.last()		val (xt, yt) = ax * last.first + bx to ay * last.second + by		if (xs + ys + t < xt + yt) break		points.add(xt to yt)	}	var best = 0	for (i in points.indices) {		for (j in i until points.size) {			val dist = minOf(dist(xs to ys, points[i]), dist(xs to ys, points[j])) + dist(points[i], points[j])			if (dist <= t) best = maxOf(best, j - i + 1)		}	}	println(best)} fun dist(a: Pair<Long, Long>, b: Pair<Long, Long>): Long {	return abs(a.first - b.first) + abs(a.second - b.second)} private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readLongs() = readStrings().map { it.toLong() }private operator fun <E> List<E>.component6(): E {	return this[5]}","brute force,constructive algorithms,geometry,greedy,implementation"
"import java.util.*import kotlin.math.absimport kotlin.math.max  fun main() {    val sc = Scanner(System.`in`)    val dots = mutableListOf(Pair(sc.nextLong(), sc.nextLong()))    val ax = sc.nextLong()    val ay = sc.nextLong()    val bx = sc.nextLong()    val by = sc.nextLong()    val xs = sc.nextLong()    val ys = sc.nextLong()    val t = sc.nextLong()    var devices = 0     val LIMIT = (1L shl 62) - 1    while ((LIMIT - bx) / ax >= dots.last().first && (LIMIT - by) / ay >= dots.last().second) {        dots.add(Pair(ax * dots.last().first + bx, ay * dots.last().second + by))    }     val xsYsDot = Pair(xs, ys)     for (i in 0 until dots.size) {        for (j in i until dots.size) {            val length: Long = distanceDots(dots[i], dots[j])            val left = distanceDots(xsYsDot, dots[i])            val right = distanceDots(xsYsDot, dots[j])            if (length <= t - left || length <= t - right)                devices = max(devices, j - i + 1)        }    }    println(devices)} fun distanceDots(pair: Pair<Long, Long>, nextDot: Pair<Long, Long>) =    abs(pair.first - nextDot.first) + abs(pair.second - nextDot.second) ","brute force,constructive algorithms,geometry,greedy,implementation"
"//package codeforces.round616 fun solve(k: Int, toSwitch: List<Int>, where: List<List<Int>>): List<Int> {	val p = MutableList(k) { it }	val odd = MutableList(k) { 0 }	val d = List(k) { mutableListOf(0, 1) }	fun get(x: Int): Int {		if (p[x] == x) return x		val par = p[x]		p[x] = get(par)		odd[x] = odd[x] xor odd[par]		return p[x]	}	fun spend(x: Int): Int {		if (where[x].isEmpty()) return 0		if (where[x].size == 1) {			val (a) = where[x]			val aa = get(a)			val old = d[aa].min()!!			d[aa][odd[a] xor toSwitch[x] xor 1] = k + 1			return d[aa].min()!! - old		}		val (a, b) = where[x].let { if ((x + it.hashCode()) % 2 == 0) it else it.reversed() }		val (aa, bb) = get(a) to get(b)		if (aa == bb) return 0		p[aa] = bb		odd[aa] = odd[a] xor odd[b] xor toSwitch[x]		val old = d[aa].min()!! + d[bb].min()!!		for (i in 0..1) {			d[bb][i] = minOf(d[bb][i] + d[aa][i xor odd[aa]], k + 1)		}		return d[bb].min()!! - old	}	var ans = 0	return toSwitch.indices.map { ans += spend(it); ans }} fun main() {	val (_, k) = readInts()	val toSwitch = readLn().map { '1' - it }	val where = List(toSwitch.size) { mutableListOf<Int>() }	repeat(k) { i ->		readLn()		readInts().forEach { where[it - 1].add(i) }	}	println(solve(k, toSwitch, where).joinToString(""\n""))} private fun readLn() = readLine()!!private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","dfs and similar,dsu,graphs"
"//package codeforces.round616 fun solve(k: Int, toSwitch: List<Int>, where: List<List<Int>>): List<Int> {	val p = MutableList(k) { it }	val odd = MutableList(k) { 0 }	val d = List(k) { mutableListOf(0, 1) }	fun get(x: Int): Int {		val ps = mutableListOf(x)		while (p[ps.last()] != ps.last()) {			ps.add(p[ps.last()])		}		for (i in ps.size - 2 downTo 0) {			p[ps[i]] = ps.last()			odd[ps[i]] = odd[ps[i]] xor odd[ps[i + 1]]		}		return p[x]//		if (p[x] == x) return x//		val par = p[x]//		p[x] = get(par)//		odd[x] = odd[x] xor odd[par]//		return p[x]	}	fun addition(x: Int): Int {		if (where[x].isEmpty()) return 0		if (where[x].size == 1) {			val (a) = where[x]			val aa = get(a)			val old = d[aa].min()!!			d[aa][odd[a] xor toSwitch[x] xor 1] = k + 1			return d[aa].min()!! - old		}		val (a, b) = where[x].let { if ((x + it.hashCode()) % 2 == 0) it else it.reversed() }		val (aa, bb) = get(a) to get(b)		if (aa == bb) return 0		p[aa] = bb		odd[aa] = odd[a] xor odd[b] xor toSwitch[x]		val old = d[aa].min()!! + d[bb].min()!!		for (i in 0..1) {			d[bb][i] = minOf(d[bb][i] + d[aa][i xor odd[aa]], k + 1)		}		return d[bb].min()!! - old	}	var ans = 0	return toSwitch.indices.map { ans += addition(it); ans }} fun main() {	val (_, k) = readInts()	val toSwitch = readLn().map { '1' - it }	val where = List(toSwitch.size) { mutableListOf<Int>() }	repeat(k) { i ->		readLn()		readInts().forEach { where[it - 1].add(i) }	}	println(solve(k, toSwitch, where).joinToString(""\n""))} private fun readLn() = readLine()!!private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","dfs and similar,dsu,graphs"
"//package codeforces.round616 fun solve(k: Int, toSwitch: List<Int>, where: List<List<Int>>): List<Int> {	val p = MutableList(k) { it }	val odd = MutableList(k) { 0 }	val d0 = MutableList(k) { 0 }	val d1 = MutableList(k) { 1 }	fun get(x: Int): Int {		val ps = mutableListOf(x)		while (p[ps.last()] != ps.last()) {			ps.add(p[ps.last()])		}		for (i in ps.size - 2 downTo 0) {			p[ps[i]] = ps.last()			odd[ps[i]] = odd[ps[i]] xor odd[ps[i + 1]]		}		return p[x]//		if (p[x] == x) return x//		val par = p[x]//		p[x] = get(par)//		odd[x] = odd[x] xor odd[par]//		return p[x]	}	fun addition(x: Int): Int {		if (where[x].isEmpty()) return 0		if (where[x].size == 1) {			val (c) = where[x]			val cc = get(c)			val xor = odd[c] xor toSwitch[x]			val old = minOf(d0[cc], d1[cc])			if (xor == 1) {				d0[cc] = k + 1			} else {				d1[cc] = k + 1			}			val new = minOf(d0[cc], d1[cc])			return new - old		}		val (c, d) = if (x % 7 < 3) where[x] else where[x].reversed()		val cc = get(c)		val dd = get(d)		if (cc == dd) return 0		val xor = odd[c] xor odd[d] xor toSwitch[x]		p[cc] = dd		odd[cc] = xor		val old = minOf(d0[cc], d1[cc]) + minOf(d0[dd], d1[dd])		if (xor == 1) {			d0[dd] = d0[dd] + d1[cc]			d1[dd] = d1[dd] + d0[cc]		} else {			d0[dd] = d0[dd] + d0[cc]			d1[dd] = d1[dd] + d1[cc]		}		d0[dd] = minOf(d0[dd], k + 1)		d1[dd] = minOf(d1[dd], k + 1)		val new = minOf(d0[dd], d1[dd])		return new - old	}	var ans = 0	return toSwitch.indices.map { ans += addition(it); ans }} fun main() {	val (_, k) = readInts()	val toSwitch = readLn().map { '1' - it }	val where = List(toSwitch.size) { mutableListOf<Int>() }	repeat(k) { i ->		readLn()		readInts().forEach { where[it - 1].add(i) }	}	println(solve(k, toSwitch, where).joinToString(""\n""))} private fun readLn() = readLine()!!private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","dfs and similar,dsu,graphs"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.*import kotlin.math.min fun mind(a: Int, b: Int): Int {    if (a == -1) {        return b    }    if (b == -1) {        return a    }    return min(a, b)} fun comb(a: Int, b: Int): Int {    if (a == -1 || b == -1) {        return -1    }    return a + b} fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    var tokenizer = StringTokenizer(jin.readLine())    val n = tokenizer.nextToken().toInt()    val k = tokenizer.nextToken().toInt()    val s = jin.readLine()    val initial = IntArray(n + 1) { if (it == 0) 0 else ('1' - s[it - 1]) }    val subset1 = IntArray(n + 1)    val subset2 = IntArray(n + 1)    for (j in 1..k) {        val c = jin.readLine().toInt()        tokenizer = StringTokenizer(jin.readLine())        for (g in 1..c) {            val x = tokenizer.nextToken().toInt()            if (subset1[x] == 0) {                subset1[x] = j            } else {                subset2[x] = j            }        }    }    val needed = Array(2) { b -> IntArray(k + 1) { b } }    val union = IntArray(k + 1) { it }    val unionBit = IntArray(k + 1)    fun getUnion(j: Int): Int {        if (union[j] != union[union[j]]) {            val prev = union[j]            union[j] = getUnion(union[j])            unionBit[j] = unionBit[j] xor unionBit[prev]        }        return union[j]    }    val out = StringBuilder()    var curr = 0    for (j in 1..n) {        if (subset2[j] != 0) {            val a = getUnion(subset1[j])            val b = getUnion(subset2[j])            if (a != b) {                curr -= mind(needed[0][a], needed[1][a])                curr -= mind(needed[0][b], needed[1][b])                unionBit[a] = unionBit[subset1[j]] xor unionBit[subset2[j]] xor initial[j]                needed[0][b] = comb(needed[0][b], needed[unionBit[a]][a])                needed[1][b] = comb(needed[1][b], needed[1 - unionBit[a]][a])                union[a] = b                curr += mind(needed[0][b], needed[1][b])            }        } else if (subset1[j] != 0) {            val a =  getUnion(subset1[j])            curr -= mind(needed[0][a], needed[1][a])            needed[unionBit[subset1[j]] xor initial[j] xor 1][a] = -1            curr += mind(needed[0][a], needed[1][a])        }        out.appendln(curr)    }    print(out)}","dfs and similar,dsu,graphs"
"//package codeforces.round616 private fun solve(): Int {	val (n, mIn, kIn) = readInts()	val m = mIn - 1	val k = minOf(kIn, m)	val a = readInts()	val b = List(m + 1) { maxOf(a[it], a[it + n - 1 - m]) }	return List(k + 1) { b.drop(it).take(m + 1 - k).min()!! }.max()!!} fun main() = repeat(readInt()) { println(solve()) } private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","brute force,data structures,implementation"
"//package codeforces.round616 private fun solve(): Int {	val (n, mIn, kIn) = readInts()	val m = mIn - 1	val k = minOf(kIn, m)	val a = readInts()	val b = List(m + 1) { maxOf(a[it], a[it + n - 1 - m]) }	return List(k + 1) { b.subList(it, b.size - k + it).min()!! }.max()!!} fun main() = repeat(readInt()) { println(solve()) } private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","brute force,data structures,implementation"
"private fun solve() {	val (n, mIn, kIn) = readInts()	val m = mIn - 1	val k = minOf(kIn, m)	val a = readInts()	val b = mutableListOf<Int>()	for (i in 0..m) {		b.add(maxOf(a[i], a[i + n - 1 - m]))	}	var ans = a.min()!!	for (i in 0..k) {		ans = maxOf(ans, b.subList(i, b.size - k + i).min()!!)	}	println(ans)} fun main() = repeat(readInt()) { solve() } private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","brute force,data structures,implementation"
"import kotlin.math.maximport kotlin.math.min fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main() {    repeat(readInt()) {        val (n, m, k) = readInts()        val vs = readInts()         val meR = min(k, m-1)        val heR = m-1 - meR         var best = 0        for (me in 0..meR) {            val l1 = me            val r1 = n - (meR-me)             var next = Integer.MAX_VALUE            for (he in 0..heR) {                val l2 = l1 + he                val r2 = r1 - (heR-he)                next = min(next, max(vs[l2], vs[r2-1]))            }             best = max(best, next)        }         println(best)    }}","brute force,data structures,implementation"
"fun main(args: Array<String>) {    val (n, M) = readLine()!!.split("" "").map { it.toInt() }     val fact = LongArray(n + 1) { 1 }    (2..n).forEach { fact[it] = fact[it - 1] * it % M }    var out = 0L    (1..n).forEach {        out += (n - it + 1) * (fact[it] * fact[n - it + 1] % M)        out %= M    }    println(out)}","combinatorics,math"
import java.util.* fun main() {    val inp = Scanner(System.`in`)    val n = inp.nextInt()    val m = inp.nextLong()    var gg: Long = 0    val fact = LongArray(n + 1)    fact[0] = 1    for (i in 1..n) fact[i] = (fact[i - 1] * i)%m;    for (i in 1..n) {        gg += (n - i + 1) * (fact[i] * fact[n - i + 1] % m)        gg %= m    }    println(gg)},"combinatorics,math"
"import java.util.*import java.math.* fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readInts()  = readLn().split("" "").map{it.toInt()}fun readLong() = readLn().toLong()fun readLongs()  = readLn().split("" "").map{it.toLong()} val INF=1000000000 fun QPowMod(x:Long, y:Long, mod:Long):Long {	var res =1L	var a=x	var b=y	while(b>0) {		if(b%2==1L) {			res=res*a%mod		}		a=a*a%mod		b/=2	}	return res} fun RevMod(x:Long, mod:Long) = QPowMod(x,mod-2, mod)   fun main(args: Array<String>) {	var (n,m) = readInts()	var fact = LongArray(n+1)	fact[0]=1	for(i in 1..n)		fact[i]=fact[i-1]*i%m		var res = 0L	for(i in 1..n) {		res+=(n.toLong()-i+1)*(n.toLong()-i+1)%m*fact[i]%m*fact[n-i]%m		res%=m	}	println(res)}","combinatorics,math"
"private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readLong() = readLn().toLong() // single intprivate fun readDouble() = readLn().toDouble() //single doubleprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of intsprivate fun readDoubles() = readStrings().map { it.toDouble() } // list of Doublesprivate fun readLongs() = readStrings().map { it.toLong() } // list of longsconst val N = 250000 + 5 var fact = ArrayList<Long>() fun init(m: Long){    (0 until N).forEach { fact.add(0) }    fact[0] = 1    for (i in 1 until N)    {        fact[i] = fact[i - 1] * i.toLong()        fact[i] %= m    }} fun solve(){    var (n,m) = readLongs()    init(m)    var ans:Long = 0    for (i in 1..n.toInt())    {        var tmp:Long =  fact[i] * fact[n.toInt()-i+1]        tmp%=m;        tmp*=(n-i.toLong()+1.toLong())        tmp%=m;        ans+=tmp;        ans%=m;    }    println(ans)  } fun main(){    var t = 1    //t = readInt()    while (t-- > 0)    {        solve()    }} ","combinatorics,math"
"import kotlin.math.min fun main() {    var t = readLine()!!.toInt()    while (t-- > 0) {        var (n, k) = readLine()!!.split(' ').map(String::toInt)        var ans = n / k * k        n -= n / k * k        ans += min(n, k / 2)        println(ans)    }}",math
"fun main(args: Array<String>){    val t = readLine()!!.toInt()    for (i in 0..t-1){        val (n, k) = readLine()!!.split("" "").map{it.toInt()}        var ans : Int = n/k*k        var res : Int = n%k        ans += if(res > k/2) k/2 else res        println(ans)    }}",math
"import kotlin.math.* fun main() {    val t = readLine()!!.toInt()        val res = (1..t).map {        val (n, k) = readLine()!!.split("" "").map { it.toInt() }        val a = (n / k) * k        val b = min(n - a, k / 2)        a + b    }    println(res.joinToString(""\n""))}",math
"import kotlin.math.min fun main() {    for (c in 1..readLine()!!.toInt()) {        val line = readLine()!!        val six = line.indexOf(' ')        val n = line.substring(0, six).toInt()        val k = line.substring(six + 1).toInt()        println(min(n, (k * (n / k)) + (k / 2)))    }}",math
"import java.util.* fun main() {    val jin = Scanner(System.`in`)    val builder = StringBuilder()    for (c in 1..jin.nextInt()) {        val n = jin.nextInt()        val s = jin.next()        val t = jin.next()        val sSort = s.map { it }.sorted()        val tSort = t.map { it }.sorted()        if (sSort != tSort) {            builder.append(""NO\n"")            continue        }        val set = sSort.toSet()        if (set.size < n) {            builder.append(""YES\n"")            continue        }        val freqS = IntArray(26)        val freqT = IntArray(26)        var parityS = 0        var parityT = 0        for (j in 0 until n) {            for (c in 0 until s[j] - 'a') {                parityS = parityS xor freqS[c]            }            for (c in 0 until t[j] - 'a') { // wow tj                parityT = parityT xor freqT[c]            }            freqS[s[j] - 'a']++            freqT[t[j] - 'a']++        }        builder.append(if ((parityS xor parityT) % 2 == 0) ""YES\n"" else ""NO\n"")    }    print(builder)}","constructive algorithms,sortings,strings"
"fun main(args: Array<String>?): Unit {    val sCount = IntArray(26){0}    val tCount = IntArray(26){0}    out@repeat(readLine()!!.trim().toInt()) {        val n = readLine()!!.trim().toInt()        val s = readLine()!!.trim()        val t = readLine()!!.trim()        for (i in 0 until 26) {            sCount[i] = 0            tCount[i] = 0        }        for (c in s){            sCount[c - 'a']++        }        for (c in t) {            tCount[c - 'a']++        }        if ((0 until 26).any{sCount[it] != tCount[it]}) {            println(""NO"")        }else if (sCount.any{it > 1}) {            println(""YES"")        }else {            val sBit = Bit(26)            val tBit = Bit(26)            var sParity = 0            var tParity = 0            for (c in s) {                sParity += sBit[c - 'a']                sParity %= 2                sBit.increment(c - 'a')            }            for (c in t) {                tParity += tBit[c - 'a']                tParity %= 2                tBit.increment(c - 'a')            }            println(if (sParity == tParity) ""YES"" else ""NO"")        }     }}class Bit(val size: Int) {    val array = IntArray(size){0}    tailrec fun increment(position: Int): Unit {        if (position < size){            array[position] += 1            increment(position + (position.inv() and (position + 1)))        }    }    operator fun get(position: Int): Int {        return when{            position >= 0 -> array[position] + get(position - (position.inv() and (position + 1)))            else -> 0        }    }}","constructive algorithms,sortings,strings"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.io.PrintWriterimport java.util.* fun PrintWriter.solve(sc: FastScanner) {    val t = sc.nextInt()    for (_i in 0 until t) {        val n = sc.nextInt()        val s = sc.nextLine()        val t = sc.nextLine()        val count1 = Array(26) { 0 }        val count2 = Array(26) { 0 }        for (i in 0 until n) {            count1[s[i] - 'a']++            count2[t[i] - 'a']++        }        if ((0 until 26).any { count1[it] != count2[it] }) {            println(""NO"")        } else if (count1.any { it >= 2 }) {            println(""YES"")        } else {            var v1 = 0            var v2 = 0            for (i in 0 until n) {                for (j in i + 1 until n) {                    if (s[i] > s[j]) {                        v1++                    }                    if (t[i] > t[j]) {                        v2++                    }                }            }            println(if (v1 % 2 == v2 % 2) ""YES"" else ""NO"")        }    }} fun main() {    val writer = PrintWriter(System.out, false)    writer.solve(FastScanner(System.`in`))    writer.flush()} class FastScanner(s: InputStream) {    private var st = StringTokenizer("""")    private val br = BufferedReader(InputStreamReader(s))     fun next(): String {        while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun nextInt() = next().toInt()    fun nextLong() = next().toLong()    fun nextLine() = br.readLine()    fun nextDouble() = next().toDouble()    fun ready() = br.ready()}","constructive algorithms,sortings,strings"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"") import java.io.PrintWriterimport java.util.StringTokenizerimport kotlin.math.*import kotlin.random.*import kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() {    output {        val Q = readInt()         repeat(Q) {            val n = readInt()            val s = readLn()            val t = readLn()             val ans = run ans@{                val sCnt = s.charCount()                 if (sCnt.contentEquals(t.charCount()).not()) return@ans false                if (sCnt.any { it > 1 }) return@ans true                 s.parity() == t.parity()            }             println(if(ans) ""YES"" else ""NO"")        }    }} fun String.charCount(): IntArray {    val res = IntArray(26)    for(c in this) {        res[c - 'a']++    }    return res} fun String.parity(): Int {    var res = 0    for(i in 1..lastIndex) {        for(j in 0 until i) {            if(this[j] > this[i]) {                res = res xor 1            }        }    }     return res} /** IO code start *///@JvmField val INPUT = File(""input.txt"").inputStream()//@JvmField val OUTPUT = File(""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out @JvmField val _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false)inline fun output(block: PrintWriter.() -> Unit) { _writer.apply(block).flush() } /** shuffles and sort overrides to avoid quicksort attacks */private inline fun <R, V> R._shuffle(rnd: Random, get: R.(Int) -> V, set: R.(Int, V) -> Unit, size: Int) {    // Fisher-Yates shuffle algorithm    for (i in size - 1 downTo 1) {        val j = rnd.nextInt(i + 1)        val temp = get(i)        set(i, get(j))        set(j, temp)    }} @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } fun IntArray.shuffle(rnd: Random = random) = _shuffle(rnd, IntArray::get, IntArray::set, size)fun IntArray.sort() { shuffle(); _sort() }fun IntArray.sortDescending() { shuffle(); _sortDescending() } fun LongArray.shuffle(rnd: Random = random) = _shuffle(rnd, LongArray::get, LongArray::set, size)fun LongArray.sort() { shuffle(); _sort() }fun LongArray.sortDescending() { shuffle(); _sortDescending() } fun DoubleArray.shuffle(rnd: Random = random) = _shuffle(rnd, DoubleArray::get, DoubleArray::set, size)fun DoubleArray.sort() { shuffle(); _sort() }fun DoubleArray.sortDescending() { shuffle(); _sortDescending() } fun CharArray.shuffle(rnd: Random = random) = _shuffle(rnd, CharArray::get, CharArray::set, size)inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T: Comparable<T>> Array<out T>.sort() = _sort()inline fun <T: Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T: Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T: Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() fun `please stop removing these imports IntelliJ`() {    iprintln(max(1, 2))}","constructive algorithms,sortings,strings"
"fun main(args: Array<String>?): Unit {    repeat(readLine()!!.toInt()) {        readLine()        val permutation = readLine()!!.trim().split(' ').map(String::toInt).toIntArray()        takeMinPermutation(permutation, 0)        println(permutation.joinToString("" ""))    }}fun takeMinPermutation(list: IntArray, left: Int): Unit {    if (left == list.size) return    val right = (left until list.size).minBy{list[it]}!!    for (i in (left until right).reversed()) {        val temp = list[i + 1]        list[i + 1] = list[i]        list[i] = temp    }    return takeMinPermutation(list, maxOf(left + 1, right))}",greedy
"import java.lang.Integer.min fun main(){    val q = readLine()!!.toInt()    repeat(q) {        val n = readLine()!!.toInt()        val list = readLine()!!.split(' ').map { it.toInt() }.toMutableList()        var p = 0        while (p != n - 1) {            var m = Pair(n + 1, -1)            for (i in p until n) {                if (list[i] < m.first)                    m = Pair(list[i], i)            }            list.removeAt(m.second)            list.add(p, m.first)            //println(list)            if (p == m.second)                m = m.copy(second = m.second + 1)            p = m.second        }        list.forEach {            print(""$it "")        }        println()    }}",greedy
"import java.util.* fun main(args: Array<String>) {    val q = readLine()!!.toInt()    for (_i in 0 until q) {        val n = readLine()!!.toInt()        val p = readLine()!!.split(' ').map { it.toInt() }.toMutableList()        var used = Array(n - 1) { false }        for (c in 1..n) {            var index = (0 until n).first { p[it] == c }            while (index > 0) {                if (!used[index - 1] && p[index - 1] > p[index]) {                    used[index - 1] = true                    val tmp = p[index]                    p[index] = p[index - 1]                    p[index - 1] = tmp                } else {                    break                }                index--            }        }        println(p.joinToString("" ""))    }}",greedy
"fun main(args: Array<String>) {    val t = readLine()!!.toInt()    (1..t).forEach {        val n = readLine()!!.toInt()        var x = readLine()!!.split("" "").map { it.toInt() }.toIntArray()        var y = IntArray(n)        var cur = n + 1        var curPos = n        (0..n-1).reversed().forEach {            if (x[it] < cur) {                cur = x[it]                curPos = it            }            y[it] = curPos        }        cur = 0        while (cur < n-1) {            val nxt = y[cur+1]            if (x[cur] > x[nxt]) {                val tmp = x[nxt]                (cur..nxt - 1).reversed().forEach { x[it + 1] = x[it] }                x[cur] = tmp                cur = nxt            }            else cur++        }        println( x.joinToString("" "") )    }}",greedy
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.random.Randomimport kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(t)} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        if (c == NC) c = char        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            System.err.println(""Not accepting inputs!"")            warningActive = false        }        IN = BufferedInputStream(fakein.toString().byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    } //    init {//        IN = BufferedInputStream(System.`in`, BS)//    }}//class reading{//    companion object{//        var jin = FastScanner()//        var pw = PrintWriter(System.out)//    }//}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} fun getint():Int{ return IO.nextInt() }fun getlong():Long{ return IO.nextLong() }fun getline(n:Int):List<Int>{ return (1..n).map{IO.nextInt()} }fun getlineL(n:Int):List<Long>{return (1..n).map{IO.nextLong()} }fun getstr():String{ return IO.nextString() }fun MutableList<Int>.streamint(n:Int){ repeat(n){this.add(getint())}}fun MutableList<Long>.streamlong(n:Int){ repeat(n){this.add(getlong())}}inline fun cases(ask:()->Unit){ val t = getint();repeat(t){ ask() }} const val HighestBit = 30inline fun Int.eachBits(act:(Int)->Unit){    for(i in HighestBit - 1 downTo 0){        if(this and (1 shl i) != 0){            act(1 shl i)        }    }}inline fun Int.eachBitIndex(act:(Int)->Unit){    for(i in HighestBit -1  downTo 0){        if(this and (1 shl i) != 0){            act(i)        }    }}inline fun Int.submask(act:(Int)->Unit){    var here = this    while (here > 0) {        act(here)        here = (here - 1) and this    }    act(here)}inline fun Int.eachDown1(act:(Int)->Unit){    for(i in 0 until HighestBit){        if(this and (1 shl i) != 0){            act(this - (1 shl i))        }    }}inline fun Int.eachUp1(act:(Int)->Unit){    for(i in 0 until HighestBit){        if(this and (1 shl i) == 0){            act(this + (1 shl i))        }    }}fun Int.hasElement(a:Int):Boolean{    return (this and ( 1 shl a)) != 0} val List<Char>.ret:Stringget() = this.joinToString("""")infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    var str = """"    if(this is String){ str = this    }else if(this is Int){ str = this.toString()    }else if(this is Long){ str = this.toString()    }    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){if(!a){    throw Exception(""Failed Assertion"")}}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    inline fun cases(a:solve.()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint()} else if(mode == solveMode.tc){1 } else randCount        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            currentAnswer = null            currentBruteAnswer = null            a()        }        if(withBruteForce){            put(""Checked ${answersChecked}"")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    inline fun brute(a:()->Unit){        if(withBruteForce){            a()        }    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }      var currentAnswer:String? = null    var currentBruteAnswer:String? = null    fun answer(a:Any){        currentAnswer = a.toString()        if(currentBruteAnswer != null){            checkAnswer()        }    }    fun put2(a:Any){answer(a);put(a) }     fun bruteAnswer(a:Any){        currentBruteAnswer = a.toString()        if(currentAnswer != null){            checkAnswer()        }    }    fun checkAnswer(){        if(currentAnswer != currentBruteAnswer){            throw Exception(""Failed Test: BF $currentBruteAnswer Current $currentAnswer"")        }        answersChecked ++    }}fun Int2(a:Int,b:Int) = List(a){IntArray(b)}fun Int3(a:Int,b:Int,c:Int) = List(a){List(b){IntArray(c)}}const val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() } const val singleCase = falseconst val withBruteForce = falseconst val randCount = 100fun Int.allexceptlast(a:Int):Int{    val mask = (1 shl a) - 1    return (this and (mask).inv())}inline fun Int.breakrun(act:(Int,Int)->Unit){    for(k in 30 downTo 0){        if(!this.hasElement(k)) continue        act(allexceptlast(k + 1),k)    }} fun main(){     val powerOf3 = LongArray(35)    for(i in 0 until powerOf3.size){        if(i == 0) powerOf3[0] = 1L        else powerOf3[i] = powerOf3[i-1] * 3    }     val preorder = List(32){LongArray(32)}    for(i in 0 until 32){        for(j in 0 until 32){            val m = minOf(i,j)            val dif = maxOf(i,j) - m            preorder[i][j] = powerOf3[m] * (1L shl dif)        }    }    fun brute(a:Int,b:Int):Long{        var ret = 0L        for(i in a..b){            for(j in a..b ){                if(i and j == 0){                    ret ++                }            }        }        return ret//        put(ret)    }    fun brutezero(a:Int,b:Int):Long{        var ret = 0L        for(i in 0 until a ){            for(j in 0 until b  ){                if(i and j == 0){                    ret ++                }            }        }        return ret//        put(ret)    }       fun fullquery(a:Int,b:Int):Long {        var ret = 0L        val a = a + 1        val b = b + 1        a.breakrun { v,i ->            b.breakrun { w,j ->                if( v and w > 0 ){                 }else{                    val swap = i > j                    var v = v                    var w = w                    var i = i                    var j = j                    if(swap){                        i = j.also { j = i  }                        v = w.also{ w = v}                    }                     val free = minOf(i,j)                    val mask = ( 1 shl j) - (1 shl i)                    val availble = (j -i ) -  (v and mask).countOneBits()                     val count = powerOf3[free] * (1L shl availble)//                    var BFcount = 0L //                    for(x in 0 until (1 shl i) ){//                        for(y in 0 until (1 shl j)){//                            val xx = x + v//                            val yy = y + w//                            if(xx and yy == 0) BFcount ++//                        }//                    }//                    assert(BFcount == count)                     ret += count                }            }        }//        val bs = brutezero(a,b)//        assert(ret == bs)        return ret    }    fun symmetricQuery(a:Int,b:Int):Long{        return fullquery(b,b) - 2 * fullquery(a-1,b) + fullquery(a-1,a-1)    }////    println(brute(1,2))//    println(brute(1,4))//    println(brute(2,4))      solve.cases{        val a = getint()        val b = getint()        put(symmetricQuery(a,b))//        println(brute(a,b))     }    done()}/* mistake: not translational invarianthave to be digit DP but annoying  */","bitmasks,brute force,combinatorics,dp"
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.random.Randomimport kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(t)} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        if (c == NC) c = char        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            System.err.println(""Not accepting inputs!"")            warningActive = false        }        IN = BufferedInputStream(fakein.toString().byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    } //    init {//        IN = BufferedInputStream(System.`in`, BS)//    }}//class reading{//    companion object{//        var jin = FastScanner()//        var pw = PrintWriter(System.out)//    }//}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} fun getint():Int{ return IO.nextInt() }fun getlong():Long{ return IO.nextLong() }fun getline(n:Int):List<Int>{ return (1..n).map{IO.nextInt()} }fun getlineL(n:Int):List<Long>{return (1..n).map{IO.nextLong()} }fun getstr():String{ return IO.nextString() }fun MutableList<Int>.streamint(n:Int){ repeat(n){this.add(getint())}}fun MutableList<Long>.streamlong(n:Int){ repeat(n){this.add(getlong())}}inline fun cases(ask:()->Unit){ val t = getint();repeat(t){ ask() }} const val HighestBit = 30inline fun Int.eachBits(act:(Int)->Unit){    for(i in HighestBit - 1 downTo 0){        if(this and (1 shl i) != 0){            act(1 shl i)        }    }}inline fun Int.eachBitIndex(act:(Int)->Unit){    for(i in HighestBit -1  downTo 0){        if(this and (1 shl i) != 0){            act(i)        }    }}inline fun Int.submask(act:(Int)->Unit){    var here = this    while (here > 0) {        act(here)        here = (here - 1) and this    }    act(here)}inline fun Int.eachDown1(act:(Int)->Unit){    for(i in 0 until HighestBit){        if(this and (1 shl i) != 0){            act(this - (1 shl i))        }    }}inline fun Int.eachUp1(act:(Int)->Unit){    for(i in 0 until HighestBit){        if(this and (1 shl i) == 0){            act(this + (1 shl i))        }    }}fun Int.hasElement(a:Int):Boolean{    return (this and ( 1 shl a)) != 0} val List<Char>.ret:Stringget() = this.joinToString("""")infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    var str = """"    if(this is String){ str = this    }else if(this is Int){ str = this.toString()    }else if(this is Long){ str = this.toString()    }    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){if(!a){    throw Exception(""Failed Assertion"")}}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    inline fun cases(a:solve.()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint()} else if(mode == solveMode.tc){1 } else randCount        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            currentAnswer = null            currentBruteAnswer = null            a()        }        if(withBruteForce){            put(""Checked ${answersChecked}"")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    inline fun brute(a:()->Unit){        if(withBruteForce){            a()        }    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }      var currentAnswer:String? = null    var currentBruteAnswer:String? = null    fun answer(a:Any){        currentAnswer = a.toString()        if(currentBruteAnswer != null){            checkAnswer()        }    }    fun put2(a:Any){answer(a);put(a) }     fun bruteAnswer(a:Any){        currentBruteAnswer = a.toString()        if(currentAnswer != null){            checkAnswer()        }    }    fun checkAnswer(){        if(currentAnswer != currentBruteAnswer){            throw Exception(""Failed Test: BF $currentBruteAnswer Current $currentAnswer"")        }        answersChecked ++    }}fun Int2(a:Int,b:Int) = List(a){IntArray(b)}fun Int3(a:Int,b:Int,c:Int) = List(a){List(b){IntArray(c)}}const val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() } const val singleCase = falseconst val withBruteForce = falseconst val randCount = 100fun Int.allexceptlast(a:Int):Int{    val mask = (1 shl a) - 1    return (this and (mask).inv())}inline fun Int.breakrun(act:(Int,Int)->Unit){    for(k in 30 downTo 0){        if(!this.hasElement(k)) continue        act(allexceptlast(k + 1),k)    }}data class br(val start:Int,val i:Int){// binary rangeinit{    kotlin.assert(start and ((1 shl i) - 1) == 0)}    fun print(){        println(""[$start, ${start + (1 shl i) - 1 }]"")    }}fun rangeIntervalBreaks(left:Int,right:Int):MutableList<br> {    val ret = mutableListOf<br>()    var left = left    val right = right + 1    for(k in 0 until HighestBit){        if(left.hasElement(k) && left + (1 shl k) <= right){            ret.add(br(left,k))            left += 1 shl k        }    }    for(k in HighestBit -1 downTo 0 ){        if(right.hasElement(k) && !left.hasElement(k)){            ret.add(br(left,k))            left += 1 shl k        }    }    return ret} fun main(){     val powerOf3 = LongArray(35)    for(i in 0 until powerOf3.size){        if(i == 0) powerOf3[0] = 1L        else powerOf3[i] = powerOf3[i-1] * 3    }     val preorder = List(32){LongArray(32)}    for(i in 0 until 32){        for(j in 0 until 32){            val m = minOf(i,j)            val dif = maxOf(i,j) - m            preorder[i][j] = powerOf3[m] * (1L shl dif)        }    }    fun brute(a:Int,b:Int):Long{        var ret = 0L        for(i in a..b){            for(j in a..b ){                if(i and j == 0){                    ret ++                }            }        }        return ret//        put(ret)    }    fun brutezero(a:Int,b:Int):Long{        var ret = 0L        for(i in 0 until a ){            for(j in 0 until b  ){                if(i and j == 0){                    ret ++                }            }        }        return ret//        put(ret)    }       fun fullquery(a:Int,b:Int):Long {        var ret = 0L        for(x in rangeIntervalBreaks(a,b)){            for(y in rangeIntervalBreaks(a,b)){                val v = x.start                val w = y.start                val i = x.i                val j = y.i                if( v and w > 0 ){                 }else{                    val swap = i > j                    var v = v                    var w = w                    var i = i                    var j = j                    if(swap){                        i = j.also { j = i  }                        v = w.also{ w = v}                    }                     val free = minOf(i,j)                    val mask = ( 1 shl j) - (1 shl i)                    val availble = (j -i ) -  (v and mask).countOneBits()                     val count = powerOf3[free] * (1L shl availble)//                    var BFcount = 0L //                    for(x in 0 until (1 shl i) ){//                        for(y in 0 until (1 shl j)){//                            val xx = x + v//                            val yy = y + w//                            if(xx and yy == 0) BFcount ++//                        }//                    }//                    assert(BFcount == count)                     ret += count                }            }        }//        val bs = brutezero(a,b)//        assert(ret == bs)        return ret    }//    fun symmetricQuery(a:Int,b:Int):Long{//        return fullquery(b,b) - 2 * fullquery(a-1,b) + fullquery(a-1,a-1)//    }////    println(brute(1,2))//    println(brute(1,4))//    println(brute(2,4))      solve.cases{        val a = getint()        val b = getint()        put(fullquery(a,b))//        println(brute(a,b))     }    done()}/* mistake: not translational invarianthave to be digit DP but annoying  */","bitmasks,brute force,combinatorics,dp"
"fun main(args: Array<String>) {    repeat(readLine()!!.toInt()) {        solve()    }} fun solve() {    val (a, b, c, d, k) = readLine()!!.split("" "").map { it.toInt() }     val x = (a + c -1) / c    val y = (b + d - 1) / d    if (x + y > k) {        println(-1)    } else {        println(""$x $y"")    }}",math
"import java.util.* fun main(s: Array<String>) {    val t = readLine()!!.toInt()    for (_i in 0 until t) {        val (a, b, c, d, k) = readLine()!!.split(' ').map { it.toInt() }        val x = (a + c - 1) / c        val y = (b + d - 1) / d        if (x + y > k) println(-1)        else println(""%d %d"".format(x, y))    }}",math
"fun main( args: Array<String> ) {    val t = readLine()!!.toInt()    (1..t).forEach {        val (a, b, c, d, k) = readLine()!!.split("" "").map { it.toInt() }        fun cnt(x: Int, y: Int) = (x - 1) / y + 1        val x = cnt( a, c )        val y = cnt( b, d )        if ( x + y > k ) println( -1 ) else println(""$x $y"")     }}",math
"fun main() {    var n = readLine()!!.toInt()     repeat(n){        var (a, b, c ,d, k) = readLine()!!.split("" "").map { it.toInt() }         var x = if (a % c == 0) a / c else (a /c) + 1        var y = if (b % d == 0) b / d else (b /d) + 1          if (x + y<= k){            println(""$x $y"")        }        else println(-1)    }}",math
fun main() {	var mode = 0	repeat(readInt()) {		val x = readInt()		if (x % 2 == 0) {			println(x / 2)		} else {			println((x - 1) / 2 + mode)			mode = 1 - mode		}	}} private fun readLn() = readLine()!!private fun readInt() = readLn().toInt(),"implementation,math"
import kotlin.math.floor fun main() {	var mode = 0	repeat(readInt()) {		val x = readInt()		if (x % 2 == 0) {			println(x / 2)		} else {			println(floor(x / 2.0).toInt() + mode)			mode = 1 - mode		}	}} private fun readLn() = readLine()!!private fun readInt() = readLn().toInt(),"implementation,math"
import java.util.* fun main() {    val jin = Scanner(System.`in`)    val n = jin.nextInt()    var b = 1    for (k in 1..n) {        val a = jin.nextInt()        if (a % 2 == 0) {            println(a / 2)        } else {            println((a + b) / 2)            b *= -1        }    }},"implementation,math"
"import java.io.BufferedReaderimport java.io.InputStreamReader fun main() {    val br = BufferedReader(InputStreamReader(System.`in`))    val n = br.readLine().toInt()    val a = List(n){br.readLine().toInt()}    val ans = a.fold(ArrayList<Int>() to 1){(acc, delta), a_i ->        if (a_i % 2 == 0) acc.apply { add(a_i/2) } to delta        else acc.apply { add((a_i + delta)/2) } to -delta    }.first    println(ans.joinToString(""\n""))}","implementation,math"
"fun main() {  val tests = readLine()!!.toInt()  repeat(tests) {    val vertices = readLine()!!.toInt()    val tree = Array(vertices) { arrayListOf<Pair<Int, Int>>() }    repeat(vertices - 1) {      val (v, u) = readLine()!!.split(' ').map { it.toInt() - 1 }      tree[v].add(u to it)      tree[u].add(v to it)    }    val answer = IntArray(vertices - 1)    val dp = IntArray(vertices)     fun paint(limit: Int): Boolean {      answer.fill(-1)      dp.fill(0)      var nextColor = 1       fun paint(vertex: Int, parent: Int, color: Int) {        for ((child, index) in tree[vertex]) if (child != parent) {          if (answer[index] == -1) {            answer[index] = color            paint(child, vertex, color)          }        }      }       fun dfs(vertex: Int, parent: Int = -1): Boolean {        val knapsack = IntArray(limit + 1) { -1 }        knapsack[0] = 0        var total = 0        for ((index, edge) in tree[vertex].withIndex()) if (edge.first != parent) {          val child = edge.first          if (!dfs(child, vertex)) {            return false          }          total += dp[child] + 1          for (w in limit - (dp[child] + 1) downTo 0) {            if (knapsack[w] >= 0 && knapsack[w + dp[child] + 1] < 0) {              knapsack[w + dp[child] + 1] = index            }          }        }        for (w in limit downTo 0) {          if (knapsack[w] >= 0) {            var cur = w            while (cur > 0) {              val (child, index) = tree[vertex][knapsack[cur]]              answer[index] = nextColor              paint(child, vertex, nextColor)              cur -= dp[child] + 1            }            dp[vertex] = total - w            if (w > 0) nextColor++            break          }        }        return dp[vertex] <= limit      }       if (dfs(0)) {        paint(0, -1, nextColor)        return true      }      return false    }     var left = 0    var right = vertices    while (right - left > 1) {      val test = (right + left) ushr 1      if (paint(test)) {        right = test      } else {        left = test      }    }     assert(paint(right))    println(right)    println(answer.joinToString("" ""))  }}","*special,binary search,dp,trees"
"import kotlin.math.minimport kotlin.math.maximport java.util.* private fun readLn()=readLine()!!private fun readInt()=readLn().toInt()private fun readLong()=readLn().toLong()private fun readStrings()=readLn().split("" "")private fun readInts()=readStrings().map {it.toInt()}.toMutableList()private fun readLongs()=readStrings().map {it.toLong()}.toMutableList() private val N=3005private var v=MutableList(N,{mutableListOf<Pair<Int,Int>>()})private var best=MutableList(N,{-1})private var h=MutableList(N,{MutableList(N,{0})})private var res=MutableList(N,{0})private var x=MutableList(N,{false})private var c=0private var cnow=2 private fun dfs(a:Int,p:Int=0):Unit{    best[a]=-1    for(i in 1..c) h[a][i]=0    var sum=0    var up=(if(p!=0) 1 else 0)    for((to,id) in v[a])    {        if(to==p) continue        dfs(to,a)        if(best[to]==-1) return        for(i in c downTo best[to]) if(h[a][i]==0&&h[a][i-best[to]]!=0) h[a][i]=to        sum+=best[to]    }    var mx=0    for(i in 1..c) if(h[a][i]!=0) mx=i    best[a]=sum-mx+up    if(best[a]>c) best[a]=-1} private fun color(a:Int,p:Int=0,col:Int=1):Unit{    var mx=0    for(i in 1..c) if(h[a][i]!=0) mx=i    while(mx>0)    {        x[h[a][mx]]=true        mx-=best[h[a][mx]]    }    var cnxt=cnow++    for((to,id) in v[a])    {        if(to==p) continue        var tmp=(if(x[to]==false) col else cnxt)        res[id]=tmp        color(to,a,tmp)    }} fun main(){    var t=readInt()    while((t--)>0)    {        var n=readInt()        for(i in 1..n-1)        {            var (a,b)=readInts()            v[a].add(Pair(b,i))            v[b].add(Pair(a,i))        }        for(i in 1..n) h[i][0]=-1        var l=0        var r=n        while(l<r-1)        {            var m=(l+r)/2            c=m            dfs(1)            if(best[1]!=-1) r=m            else l=m        }        c=r        dfs(1)        color(1)        print(""$r\n"")        for(i in 1..n-1) print(""${res[i]} "")        print(""\n"")        for(i in 1..n)        {            v[i].clear()            x[i]=false        }        cnow=2    }}","*special,binary search,dp,trees"
"private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of ints data class edge(val to : Int, val lab : Int); fun solve() {    var n=readInt()    var g=Array(n+1,{ArrayList<edge>()})    var flip=IntArray(n+1)    for (i in 0..n-2) {        var (u,v)=readInts()        g[u].add(edge(v,i))        g[v].add(edge(u,i))    }    fun check(t:Int):Boolean {        var dp=IntArray(n+1);        for (i in 1..n) {            flip[i]=0        }        fun dfs(u:Int, f:Int) {            var ss=ArrayList<Int>()            for (p in g[u]) {                var v=p.to                if (v==f) continue                dfs(v,u)                ss.add(v)            }            var sz=ss.size            var pd=Array(sz+1,{BooleanArray(t+1)})            pd[0][0]=true            var keys=0            for (i in 0..sz-1) {                var key=dp[ss[i]]+1                keys+=key                for (j in 0..t)                    pd[i+1][j]=pd[i][j]                for (j in key..t)                    pd[i+1][j]=pd[i+1][j] or pd[i][j-key]            }            var maxv=0            for (j in 0..t) if (pd[sz][j]) maxv=j            dp[u]=keys-maxv            while (sz>0) {                sz-=1                if (pd[sz][maxv]) continue                flip[ss[sz]]=1                maxv-=dp[ss[sz]]+1            }        }        dfs(1,0)        return dp[1]<=t    }    var l=0    var r=n    while (l+1<r) {        var md=(l+r)/2        if (check(md)) r=md        else l=md    }    check(r)    var ans=IntArray(n-1)    var lab=1    fun dfs2(u:Int,f:Int,clab:Int) {        var flab=lab+1        lab+=1        for (p in g[u]) {            var v=p.to            if (v==f) continue            if (flip[v]==0) {                ans[p.lab]=clab                dfs2(v,u,clab)            } else {                ans[p.lab]=flab                dfs2(v,u,flab)            }        }           }    dfs2(1,0,1)    println(r)    println(ans.map({it.toString()}).joinToString("" ""))} fun main() {    val t=readInt()    for (tc in 0..t-1) {        solve()    }}","*special,binary search,dp,trees"
"fun main() {  val tests = readLine()!!.toInt()  repeat(tests) {    val vertices = readLine()!!.toInt()    val tree = Array(vertices) { arrayListOf<Pair<Int, Int>>() }    repeat(vertices - 1) {      val (v, u) = readLine()!!.split(' ').map { it.toInt() - 1 }      tree[v].add(u to it)      tree[u].add(v to it)    }    val answer = IntArray(vertices - 1)    val dp = IntArray(vertices)     fun paint(limit: Int): Boolean {      answer.fill(-1)      dp.fill(0)      var nextColor = 1       fun paint(vertex: Int, parent: Int, color: Int) {        for ((child, index) in tree[vertex]) if (child != parent) {          if (answer[index] == -1) {            answer[index] = color            paint(child, vertex, color)          }        }      }       fun dfs(vertex: Int, parent: Int = -1): Boolean {        val knapsack = IntArray(limit + 1) { -1 }        knapsack[0] = 0        var total = 0        for ((index, edge) in tree[vertex].withIndex()) if (edge.first != parent) {          val child = edge.first          if (!dfs(child, vertex)) {            return false          }          total += dp[child] + 1          for (w in limit - (dp[child] + 1) downTo 0) {            if (knapsack[w] >= 0 && knapsack[w + dp[child] + 1] < 0) {              knapsack[w + dp[child] + 1] = index            }          }        }        for (w in limit downTo 0) {          if (knapsack[w] >= 0) {            var cur = w            while (cur > 0) {              val (child, index) = tree[vertex][knapsack[cur]]              answer[index] = nextColor              paint(child, vertex, nextColor)              cur -= dp[child] + 1            }            dp[vertex] = total - w            if (w > 0) nextColor++            break          }        }        return dp[vertex] <= limit      }       if (dfs(0)) {        paint(0, -1, nextColor)        return true      }      return false    }     var left = 0    var right = vertices    while (right - left > 1) {      val test = (right + left) ushr 1      if (paint(test)) {        right = test      } else {        left = test      }    }     assert(paint(right))    println(right)    println(answer.joinToString("" ""))  }}","*special,binary search,dp,trees"
"private fun solve() {	val (n, m) = readInts()	val a = List(n) { readInts() }	val b = List(m) { i -> a.map { it[i] } }.sortedByDescending { it.max() }.take(n)	println(solve(b, 1, b[0]))} private fun solve(b: List<List<Int>>, x: Int, best: List<Int>): Int {	val bestInit = best.sum()	if (x == b.size) return bestInit	return best.indices.mapNotNull { i ->		val newBest = List(best.size) { maxOf(best[it], b[x][(it + i) % best.size]) }		if (newBest.sum() > bestInit) solve(b, x + 1, newBest) else null	}.max() ?: solve(b, x + 1, best)} fun main() = repeat(readInt()) { solve() } private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","bitmasks,brute force,dp,greedy,sortings"
"private fun solve() {	val (n, m) = readInts()	val a = List(n) { readInts() }	val b = List(m) { i -> a.map { it[i] } }.sortedByDescending { it.max() }.take(n)	println(solve(b, 1, b[0]))} private fun solve(b: List<List<Int>>, x: Int, best: List<Int>): Int {	val bestInit = best.sum()	if (x == b.size) return bestInit	val rotated = b[x]	val bestFound = best.indices.map { i ->		val nb = List(best.size) { maxOf(best[it], rotated[(it + i) % best.size]) }		if (nb.sum() <= bestInit) 0 else solve(b, x + 1, nb)	}.max()!!	return if (bestFound > 0) bestFound else solve(b, x + 1, best)} fun main() = repeat(readInt()) { solve() } private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","bitmasks,brute force,dp,greedy,sortings"
"private fun solve() {	val (n, m) = readInts()	val a = List(n) { readInts() }	val b = List(m) { i -> a.map { it[i] } }.sortedByDescending { it.max() }.take(n)	println(solve(b, 1, b[0]))} private fun solve(b: List<List<Int>>, x: Int, best: List<Int>): Int {	val bestInit = best.sum()	if (x == b.size) return bestInit	val rotated = b[x]	val n = rotated.size	var bestFound = 0	for (i in 0 until n) {		val nb = List(n) { maxOf(best[it], rotated[(it + i) % n]) }		if (nb.sum() <= bestInit) continue		bestFound = maxOf(bestFound, solve(b, x + 1, nb))	}	return if (bestFound > 0) bestFound else solve(b, x + 1, best)} fun main() = repeat(readInt()) { solve() } private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","bitmasks,brute force,dp,greedy,sortings"
"private fun solve() {	val (n, m) = readInts()	val a = List(n) { readInts() }	val b = (0 until m).map { i -> a.map { it[i] } }.sortedByDescending { it.max() }.take(n)	println(solve(b, 1, b[0]))} fun solve(b: List<List<Int>>, x: Int, best: List<Int>): Int {	val bestInit = best.sum()	if (x == b.size) return bestInit	val rotated = b[x]	val n = rotated.size	val nb = best.toMutableList()	var tried = false	var bestFound = bestInit	for (i in 0 until n) {		for (j in 0 until n) {			nb[j] = maxOf(best[j], rotated[(i + j) % n])		}		if (nb.sum() <= bestInit) continue		bestFound = maxOf(bestFound, solve(b, x + 1, nb))		tried = true	}	if (tried) return bestFound	return solve(b, x + 1, best)} fun main() = repeat(readInt()) { solve() } private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","bitmasks,brute force,dp,greedy,sortings"
"fun main() {    val n = readInt()     val W = readStrings()     val ans = buildString {        for(w in W) {            append(w.subSequence(overlap(w), w.length))        }    }     println(ans)} fun CharSequence.overlap(b: CharSequence): Int {    val c = StringBuilder().also {        if (length > b.length) it.append(b).append('$').append(subSequence(length - b.length, length))        else it.append(b.subSequence(0, length)).append('$').append(this)    }     return c.kmpTail().coerceAtLeast(0)} fun CharSequence.kmpTail() = run {    val T = IntArray(length + 1)     var pos = 1    var cnd = 0     T[0] = -1     while(pos < length) {        if(this[pos] == this[cnd]) T[pos] = T[cnd]        else {            T[pos] = cnd            cnd = T[cnd]            while(cnd >= 0 && this[pos] != this[cnd]) {                cnd = T[cnd]            }        }        pos++        cnd++    }     cnd} fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readDouble() = readLn().toDouble()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readStringSeq() = readLn().splitToSequence(' ')fun readInts() = readStrings().map { it.toInt() }fun readIntSeq() = readStringSeq().map { it.toInt() }fun readDoubles() = readStrings().map { it.toDouble() }fun readDoubleSeq() = readStringSeq().map { it.toDouble() }fun readLongs() = readStrings().map { it.toLong() }fun readLongSeq() = readStringSeq().map { it.toLong() } class Output {    private val sb = StringBuilder()    fun print(o: Any?) { sb.append(o) }    fun println() { sb.append('\n') }    fun println(o: Any?) { sb.append(o).append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(sb) }}inline fun output(block: Output.()->Unit) { Output().apply(block).nowPrint() }","brute force,hashing,implementation,string suffix structures,strings"
"import java.math.BigInteger fun main() {    val n = readInt()     val W = readStrings()     val ans = buildString {        for(w in W) {            append(w.subSequence(overlap(w), w.length))        }    }     println(ans)} val rnd = java.util.Random()val b1 = BigInteger.probablePrime(9, rnd).toInt()val b2 = BigInteger.probablePrime(10, rnd).toInt()val m1 = BigInteger.probablePrime(30, rnd).toInt()val m2 = BigInteger.probablePrime(31, rnd).toInt() data class Hash(var h1: Long, var h2: Long) fun CharSequence.overlap(b: CharSequence): Int {    val ah = Hash(0, 0)    val bh = Hash(0, 0)    var b1e = 1L    var b2e = 1L     var res = 0     for(i in 0 until minOf(length, b.length)) {        val ac = this[lastIndex - i].toInt()        val bc = b[i].toInt()          ah.h1 = (ac * b1e + ah.h1) % m1        ah.h2 = (ac * b2e + ah.h2) % m2         bh.h1 = (bh.h1 * b1 + bc) % m1        bh.h2 = (bh.h2 * b2 + bc) % m2         if(ah == bh) res = i + 1         b1e = (b1e * b1) % m1        b2e = (b2e * b2) % m2    }     return res}  fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readDouble() = readLn().toDouble()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readStringSeq() = readLn().splitToSequence(' ')fun readInts() = readStrings().map { it.toInt() }fun readIntSeq() = readStringSeq().map { it.toInt() }fun readDoubles() = readStrings().map { it.toDouble() }fun readDoubleSeq() = readStringSeq().map { it.toDouble() }fun readLongs() = readStrings().map { it.toLong() }fun readLongSeq() = readStringSeq().map { it.toLong() } class Output {    private val sb = StringBuilder()    fun print(o: Any?) { sb.append(o) }    fun println() { sb.append('\n') }    fun println(o: Any?) { sb.append(o).append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(sb) }}inline fun output(block: Output.()->Unit) { Output().apply(block).nowPrint() }","brute force,hashing,implementation,string suffix structures,strings"
"import java.math.BigIntegerimport java.security.SecureRandom fun main() {    val n = readInt()     val W = readStrings()     val ans = buildString {        for(w in W) {            append(w.subSequence(overlap(w), w.length))        }    }     println(ans)} val rnd = SecureRandom()val b1 = BigInteger.probablePrime(8, rnd).toInt()val b2 = BigInteger.probablePrime(9, rnd).toInt()val m1 = BigInteger.probablePrime(31, rnd).toInt()val m2 = BigInteger.probablePrime(31, rnd).toInt() data class Hash(var h1: Long, var h2: Long) fun CharSequence.overlap(b: CharSequence): Int {    val ah = Hash(0, 0)    val bh = Hash(0, 0)    var b1e = 1L    var b2e = 1L     var res = 0     for(i in 0 until minOf(length, b.length)) {        val ac = this[lastIndex - i].toInt()        val bc = b[i].toInt()          ah.h1 = (ac * b1e + ah.h1) % m1        ah.h2 = (ac * b2e + ah.h2) % m2         bh.h1 = (bh.h1 * b1 + bc) % m1        bh.h2 = (bh.h2 * b2 + bc) % m2         if(ah == bh) res = i + 1         b1e = (b1e * b1) % m1        b2e = (b2e * b2) % m2    }     return res}  fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readDouble() = readLn().toDouble()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readStringSeq() = readLn().splitToSequence(' ')fun readInts() = readStrings().map { it.toInt() }fun readIntSeq() = readStringSeq().map { it.toInt() }fun readDoubles() = readStrings().map { it.toDouble() }fun readDoubleSeq() = readStringSeq().map { it.toDouble() }fun readLongs() = readStrings().map { it.toLong() }fun readLongSeq() = readStringSeq().map { it.toLong() } class Output {    private val sb = StringBuilder()    fun print(o: Any?) { sb.append(o) }    fun println() { sb.append('\n') }    fun println(o: Any?) { sb.append(o).append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(sb) }}inline fun output(block: Output.()->Unit) { Output().apply(block).nowPrint() }","brute force,hashing,implementation,string suffix structures,strings"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.lang.StringBuilderimport java.util.*import kotlin.math.* fun gcd(a: Long, b: Long): Long {    var aa = a    var bb = b    while (bb != 0L) {        val t = bb        bb = aa % bb        aa = t    }    return aa}  fun main() {    val sc = Scanner.sysIn     val p = 100000969    val m = 100003573    val pow = LongArray(1000100)    pow[0] = 1    for (i in 1 until pow.size) {        pow[i] = pow[i - 1] * p % m    }     val n = sc.nextInt()     val ans = StringBuilder()    val h = LongArray(1000100) { 0 }    var cs = 0    for (t in 1..n) {        val cur = sc.next()        //println(cur[0].toInt())        val ch = LongArray(cur.length) { 0 }         ch[0] = cur[0].toInt().toLong()        for (i in 1 until cur.length) {            ch[i] = (ch[i - 1] + cur[i].toInt().toLong() * pow[i] % m) % m        }         var p = -1        for (i in 0 until min(cur.length, cs)) {            val l = if (cs - i - 2 < 0) 0 else h[cs - i - 2]            if (ch[i] * pow[cs - i - 1] % m == (h[cs - 1] + m - l) % m)                p = i        }        //println(cur + "" "" + p)        if (p == -1) {            ans.append(cur)            for (i in cs until cs + cur.length) {                if (i == 0)                    h[i] = cur[i - cs].toInt().toLong()                else                    h[i] = (h[i - 1] + cur[i - cs].toInt().toLong() * pow[i] % m) % m            }            cs += cur.length        } else {            for (i in cs until cs + cur.length - p - 1) {                ans.append(cur[i - cs + p + 1])                //println(cur[i - cs + p + 1])                h[i] = (h[i - 1] + cur[i - cs + p + 1].toInt().toLong() * pow[i] % m) % m            }            cs += cur.length - p - 1        }    }     println(ans)} class Scanner(s: InputStream) {    var st: StringTokenizer? = null    val br: BufferedReader = BufferedReader(InputStreamReader(s))     operator fun next(): String {        while (st == null || !st!!.hasMoreTokens())            st = StringTokenizer(br.readLine())        return st!!.nextToken()    }     fun nextInt(): Int {        return Integer.parseInt(next())    }     fun nextLong(): Long {        return java.lang.Long.parseLong(next())    }     fun nextLine(): String {        return br.readLine()    }     fun nextDouble(): Double {        return java.lang.Double.parseDouble(next())    }     companion object {        val sysIn = Scanner(System.`in`)    } } val rnd = Random()fun IntArray.sort() {    val n = this.size    for (i in 0 until n - 1) {        val randomPos = i + rnd.nextInt(n - i - 1) + 1        this[i] = this[i] xor this[randomPos]        this[randomPos] = this[randomPos] xor this[i]        this[i] = this[i] xor this[randomPos]    }    Arrays.sort(this)} fun LongArray.sort() {    val n = this.size    for (i in 0 until n - 1) {        val randomPos = i + rnd.nextInt(n - i - 1) + 1        this[i] = this[i] xor this[randomPos]        this[randomPos] = this[randomPos] xor this[i]        this[i] = this[i] xor this[randomPos]    }    Arrays.sort(this)}","brute force,hashing,implementation,string suffix structures,strings"
"import java.util.*import kotlin.math.maximport kotlin.math.min  fun main() {    val scan = Scanner(System.`in`)    val q = scan.nextInt()     for (i in 1..q) {        var yMax = -100000        var yMin = 100000        var xMin = -100000        var xMax = 100000         val n = scan.nextInt()         for (k in 1..n) {            val x = scan.nextInt()            val y = scan.nextInt()              val f1 = scan.nextInt() == 0            val f2 = scan.nextInt() == 0            val f3 = scan.nextInt() == 0            val f4 = scan.nextInt() == 0             if (f1) xMin = max(xMin, x)            if (f2) yMin = min(yMin, y)            if (f3) xMax = min(xMax, x)            if (f4) yMax = max(yMax, y)        }         if (xMin > xMax || yMax > yMin) println(0)        else println(""1 $xMin $yMax"")    }}",implementation
"import java.util.*import kotlin.math.maximport kotlin.math.min  fun main() {    solve()} fun solve() {    val scan = Scanner(System.`in`)    val q = scan.nextInt()     for (i in 1..q) {        var yMax = -100000        var yMin = 100000        var xMin = -100000        var xMax = 100000         val n = scan.nextInt()         for (k in 1..n) {            val x = scan.nextInt()            val y = scan.nextInt()              val f1 = scan.nextInt() == 0            val f2 = scan.nextInt() == 0            val f3 = scan.nextInt() == 0            val f4 = scan.nextInt() == 0             if (f1) xMin = max(xMin, x)            if (f2) yMin = min(yMin, y)            if (f3) xMax = min(xMax, x)            if (f4) yMax = max(yMax, y)        }         if (xMin > xMax || yMax > yMin) println(0)        else println(""1 $xMin $yMax"")    }}",implementation
"import java.util.*import kotlin.math.maximport kotlin.math.min  fun main() {    solve()} fun solve() {    val scan = Scanner(System.`in`)    val q = scan.nextInt()     for (i in 1..q) {        var yMin = -100000        var yMax = 100000        var xMin = -100000        var xMax = 100000         val n = scan.nextInt()         for (k in 1..n) {            val x = scan.nextInt()            val y = scan.nextInt()              val f1 = scan.nextInt() == 0            val f2 = scan.nextInt() == 0            val f3 = scan.nextInt() == 0            val f4 = scan.nextInt() == 0             if (f1) xMin = max(xMin, x)            if (f2) yMax = min(yMax, y)            if (f3) xMax = min(xMax, x)            if (f4) yMin = max(yMin, y)        }         if (xMin > xMax || yMin > yMax) println(0)        else println(""1 $xMin $yMax"")    }}",implementation
"import java.util.*import kotlin.math.maximport kotlin.math.min  fun main() {    solve()} fun solve() {    val scan = Scanner(System.`in`)    val q = scan.nextInt()     for (i in 1..q) {        var xMax = 100000        var yMax = 100000        var xMin = -100000        var yMin = -100000         val n = scan.nextInt()         for (j in 1..n) {            val x = scan.nextInt()            val y = scan.nextInt()              val f1 = scan.nextInt() == 0            val f2 = scan.nextInt() == 0            val f3 = scan.nextInt() == 0            val f4 = scan.nextInt() == 0             if (f1) xMin = max(xMin, x)            if (f2) yMax = min(yMax, y)            if (f3) xMax = min(xMax, x)            if (f4) yMin = max(yMin, y)        }         if (xMin > xMax || yMin > yMax) println(0)        else println(""1 $xMin $yMin"")    }}",implementation
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.random.Randomimport kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        IN = BufferedInputStream(fakein.toString().byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} fun getint():Int{ return IO.nextInt() }fun getlong():Long{ return IO.nextLong() }fun getline(n:Int):IntArray{    val ret = IntArray(n);repeat(n){ret[it] = getint()};return ret}fun getlineL(n:Int):LongArray{    val ret = LongArray(n);repeat(n){ret[it] = getlong()};return ret}fun getstr():String{ return IO.nextString() }fun MutableList<Int>.streamint(n:Int){ repeat(n){this.add(getint())}}fun MutableList<Long>.streamlong(n:Int){ repeat(n){this.add(getlong())}}inline fun cases(ask:()->Unit){ val t = getint();repeat(t){ ask() }} val List<Char>.ret:Stringget() = this.joinToString("""")infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    var str = """"    if(this is String){ str = this    }else if(this is Int){ str = this.toString()    }else if(this is Long){ str = this.toString()    }    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    inline fun cases(a:solve.()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint()} else if(mode == solveMode.tc){1 } else randCount        //safety checks        if(pI != 998_244_353 && pI != 1_000_000_007){            throw Exception(""Modding a wrong prime!"")        }         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            currentAnswer = null            currentBruteAnswer = null            a()        }        if(withBruteForce){            put(""Checked ${answersChecked}"")        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    inline fun brute(a:()->Unit){        if(withBruteForce){            a()        }    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }      var currentAnswer:String? = null    var currentBruteAnswer:String? = null    fun answer(a:Any){        currentAnswer = a.toString()        if(currentBruteAnswer != null){            checkAnswer()        }    }    fun put2(a:Any){answer(a);put(a) }     fun bruteAnswer(a:Any){        currentBruteAnswer = a.toString()        if(currentAnswer != null){            checkAnswer()        }    }    fun checkAnswer(){        if(currentAnswer != currentBruteAnswer){            throw Exception(""Failed Test: BF $currentBruteAnswer Current $currentAnswer"")        }        answersChecked ++    }}// 1. Moddedconst val p = 998_244_353Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}infix fun Int.modM(b:Int):Int{ return ((this * 1L * b) % pI).toInt() }infix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }fun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val Boolean.chi:Int get() = if(this) 1 else 0 //characteristic function// 2. DP initial valuesconst val plarge = 1_000_000_727const val nlarge = -plargeconst val phuge = 2_727_000_000_000_000_000Lconst val nhuge = -phugeval Char.code :Int get() = this.toInt() -  'a'.toInt()  fun largemod(s:String):Int {    var ret = 0    for(c in s){        val d = c.toInt() - '0'.toInt()        ret = ret modM 10        ret += d    }    return ret}fun solve(s:String,x:Int, y:Int,musthavex:IntArray, musthavey:IntArray):Int{    // top, has x, has y     val shift = 15    val shiftdouble = 2 * shift + 1 //    ""original"" dei ""$x $y""    val must = musthavex.size    val MUST = 1 shl must     val xAdded = IntArray(10)    val yAdded = IntArray(10)    for((i,v) in musthavex.withIndex()){        xAdded[v] = 1 shl i    }    for((i,v) in musthavey.withIndex()){        yAdded[v] = 1 shl i    }    var DP = Array(2){Array(1 shl must){Array(1 shl must){IntArray(shiftdouble)}}}    DP[1][0][0][shift] = 1    for(c in s){        val next = Array(2){Array(1 shl must){Array(1 shl must){IntArray(shiftdouble)}}}        val d =c.toInt() - '0'.toInt()        for(top in 0 until 2){            for(xmask in 0 until MUST){                for(ymask in 0 until MUST){                    for(dif_shifted in 0 until shiftdouble){                        val dif = dif_shifted - shift                        val maxx = if(top == 1) d else 9                        val here = DP[top][xmask][ymask][dif_shifted]                        for(newx in 0..maxx){                            for(newy in 0 until 10){                                val newdif = dif * 10 + (newx * y) - (newy * x)                                if(newdif < -shift || newdif > shift) continue                                val newhasx = xmask or xAdded[newx]                                val newhasy = ymask or yAdded[newy]                                val newstate = if(top == 0) 0 else{if(newx == maxx) 1 else 0}                                next[newstate][newhasx][newhasy].put(newdif + shift,here)                            }                        }                    }                }            }        }        DP = next    }    val maxmask = (1 shl must) - 1    return DP[0][maxmask][maxmask][shift] modPlus DP[1][maxmask][maxmask][shift]}fun check(s:String,x:Int, y:Int):Int {    val n = s.toInt()    var ret = 0//    ""NEW"" dei ""$s $x $y""    for(i in 1..n){        if((i * y) %x == 0){            val other = (i * y )/x            if(i.toString().contains(('0'.toInt() + x).toChar())){                if(other.toString().contains(('0'.toInt() +y).toChar())){                    ret ++//                    all.remove(Pair(i,other))//                    all.add(Pair(other,i))//                    just dei ""$i $other""                }            }         }    }    return ret}fun totalCheck(n:Int):Int {    var ret = 0    for(A in 1..n){        here@for(B in 1..n){            for(x in 1..9){                for(y in 1..9){                    if(y * A != x * B) continue                    if(A.toString().contains(""$x""[0])){                        if(B.toString().contains(""$y""[0])){//                            all.add(Pair(A,B))                             ret++                            continue@here                        }                    }                }            }        }    }    return ret}  const val withBruteForce = falseconst val randCount = 100fun main(){    solve.cases{        val str = getstr()        var ret = largemod(str)        val all = mutableMapOf<Pair<Int,Int>, MutableList<Pair<Int,Int>>>()        for(y in 1..9) {            here@ for(x in (y + 1)..9) {                for((e, v) in all.entries) {                    if(e.first * y == e.second * x) {                        v.add(Pair(x, y))                        continue@here                    }                }                all[Pair(x,y)] = mutableListOf(Pair(x,y))            }        }         for((p,v) in all.entries){            for(mask in 1 until (1 shl v.size)){                val parity = if(mask.countOneBits() % 2 == 1) 1 else (pI - 1)                val (x,y) = p                val first = mutableListOf<Int>()                val second = mutableListOf<Int>()                for(i in 0 until v.size){                    if(mask and (1 shl i) != 0){                        first.add(v[i].first)                        second.add(v[i].second)                    }                }                ret = ret modPlus ( parity modM 2 modM solve(str,x,y, first.toIntArray(), second.toIntArray()))            }        }         put(ret)    }    done()}const val singleCase = true /* a single untli killed wrong place of x , y */",dp
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.random.Randomimport kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        IN = BufferedInputStream(fakein.toString().byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} fun getint():Int{ return IO.nextInt() }fun getlong():Long{ return IO.nextLong() }fun getline(n:Int):IntArray{    val ret = IntArray(n);repeat(n){ret[it] = getint()};return ret}fun getlineL(n:Int):LongArray{    val ret = LongArray(n);repeat(n){ret[it] = getlong()};return ret}fun getstr():String{ return IO.nextString() }fun MutableList<Int>.streamint(n:Int){ repeat(n){this.add(getint())}}fun MutableList<Long>.streamlong(n:Int){ repeat(n){this.add(getlong())}}inline fun cases(ask:()->Unit){ val t = getint();repeat(t){ ask() }} val List<Char>.ret:Stringget() = this.joinToString("""")infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    var str = """"    if(this is String){ str = this    }else if(this is Int){ str = this.toString()    }else if(this is Long){ str = this.toString()    }    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    inline fun cases(a:solve.()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint()} else if(mode == solveMode.tc){1 } else randCount        //safety checks        if(pI != 998_244_353 && pI != 1_000_000_007){            throw Exception(""Modding a wrong prime!"")        }         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            currentAnswer = null            currentBruteAnswer = null            a()        }        if(withBruteForce){            put(""Checked ${answersChecked}"")        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    inline fun brute(a:()->Unit){        if(withBruteForce){            a()        }    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }      var currentAnswer:String? = null    var currentBruteAnswer:String? = null    fun answer(a:Any){        currentAnswer = a.toString()        if(currentBruteAnswer != null){            checkAnswer()        }    }    fun put2(a:Any){answer(a);put(a) }     fun bruteAnswer(a:Any){        currentBruteAnswer = a.toString()        if(currentAnswer != null){            checkAnswer()        }    }    fun checkAnswer(){        if(currentAnswer != currentBruteAnswer){            throw Exception(""Failed Test: BF $currentBruteAnswer Current $currentAnswer"")        }        answersChecked ++    }}// 1. Moddedconst val p = 998_244_353Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}infix fun Int.modM(b:Int):Int{ return ((this * 1L * b) % pI).toInt() }infix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }fun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val Boolean.chi:Int get() = if(this) 1 else 0 //characteristic function// 2. DP initial valuesconst val plarge = 1_000_000_727const val nlarge = -plargeconst val phuge = 2_727_000_000_000_000_000Lconst val nhuge = -phugeval Char.code :Int get() = this.toInt() -  'a'.toInt()  fun largemod(s:String):Int {    var ret = 0    for(c in s){        val d = c.toInt() - '0'.toInt()        ret = ret modM 10        ret += d    }    return ret}var total = 0fun solve(s:String,x:Int, y:Int,musthavex:IntArray, musthavey:IntArray):Int{    // top, has x, has y     val shift = 10    val shiftdouble = 2 * shift + 1   //    ""original"" dei ""$x $y""    val must = musthavex.size    val MUST = 1 shl must     total += (1 shl (2 * must))     val xAdded = IntArray(10)    val yAdded = IntArray(10)    for((i,v) in musthavex.withIndex()){        xAdded[v] = 1 shl i    }    for((i,v) in musthavey.withIndex()){        yAdded[v] = 1 shl i    }    var DP = Array(2){Array(1 shl must){Array(1 shl must){IntArray(shiftdouble)}}}    DP[1][0][0][shift] = 1    for(c in s){        val next = Array(2){Array(1 shl must){Array(1 shl must){IntArray(shiftdouble)}}}        val d =c.toInt() - '0'.toInt()        for(top in 0 until 2){            for(xmask in 0 until MUST){                for(ymask in 0 until MUST){                    for(dif_shifted in 0 until shiftdouble){                        val dif = dif_shifted - shift                        val maxx = if(top == 1) d else 9                        val here = DP[top][xmask][ymask][dif_shifted]                        for(newx in 0..maxx){                            for(newy in 0 until 10){                                val newdif = dif * 10 + (newx * y) - (newy * x)                                if(newdif < -shift || newdif > shift) continue                                val newhasx = xmask or xAdded[newx]                                val newhasy = ymask or yAdded[newy]                                val newstate = if(top == 0) 0 else{if(newx == maxx) 1 else 0}                                next[newstate][newhasx][newhasy].put(newdif + shift,here)                            }                        }                    }                }            }        }        DP = next    }    val maxmask = (1 shl must) - 1    return DP[0][maxmask][maxmask][shift] modPlus DP[1][maxmask][maxmask][shift]}fun check(s:String,x:Int, y:Int):Int {    val n = s.toInt()    var ret = 0//    ""NEW"" dei ""$s $x $y""    for(i in 1..n){        if((i * y) %x == 0){            val other = (i * y )/x            if(i.toString().contains(('0'.toInt() + x).toChar())){                if(other.toString().contains(('0'.toInt() +y).toChar())){                    ret ++//                    all.remove(Pair(i,other))//                    all.add(Pair(other,i))//                    just dei ""$i $other""                }            }         }    }    return ret}fun totalCheck(n:Int):Int {    var ret = 0    for(A in 1..n){        here@for(B in 1..n){            for(x in 1..9){                for(y in 1..9){                    if(y * A != x * B) continue                    if(A.toString().contains(""$x""[0])){                        if(B.toString().contains(""$y""[0])){//                            all.add(Pair(A,B))                             ret++                            continue@here                        }                    }                }            }        }    }    return ret}  const val withBruteForce = falseconst val randCount = 100fun main(){    solve.cases{        val str = getstr()        var ret = largemod(str)        val all = mutableMapOf<Pair<Int,Int>, MutableList<Pair<Int,Int>>>()        for(y in 1..9) {            here@ for(x in (y + 1)..9) {                for((e, v) in all.entries) {                    if(e.first * y == e.second * x) {                        v.add(Pair(x, y))                        continue@here                    }                }                all[Pair(x,y)] = mutableListOf(Pair(x,y))            }        }         for((p,v) in all.entries){            for(mask in 1 until (1 shl v.size)){                val parity = if(mask.countOneBits() % 2 == 1) 1 else (pI - 1)                val (x,y) = p                val first = mutableListOf<Int>()                val second = mutableListOf<Int>()                for(i in 0 until v.size){                    if(mask and (1 shl i) != 0){                        first.add(v[i].first)                        second.add(v[i].second)                    }                }                ret = ret modPlus ( parity modM 2 modM solve(str,x,y, first.toIntArray(), second.toIntArray()))            }        }         put(ret)//        put(total)    }    done()}const val singleCase = true /* a single untli killed wrong place of x , y */",dp
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.random.Randomimport kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        IN = BufferedInputStream(fakein.toString().byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} fun getint():Int{ return IO.nextInt() }fun getlong():Long{ return IO.nextLong() }fun getline(n:Int):IntArray{    val ret = IntArray(n);repeat(n){ret[it] = getint()};return ret}fun getlineL(n:Int):LongArray{    val ret = LongArray(n);repeat(n){ret[it] = getlong()};return ret}fun getstr():String{ return IO.nextString() }fun MutableList<Int>.streamint(n:Int){ repeat(n){this.add(getint())}}fun MutableList<Long>.streamlong(n:Int){ repeat(n){this.add(getlong())}}inline fun cases(ask:()->Unit){ val t = getint();repeat(t){ ask() }} val List<Char>.ret:Stringget() = this.joinToString("""")infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    var str = """"    if(this is String){ str = this    }else if(this is Int){ str = this.toString()    }else if(this is Long){ str = this.toString()    }    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    inline fun cases(a:solve.()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint()} else if(mode == solveMode.tc){1 } else randCount        //safety checks        if(pI != 998_244_353 && pI != 1_000_000_007){            throw Exception(""Modding a wrong prime!"")        }         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            currentAnswer = null            currentBruteAnswer = null            a()        }        if(withBruteForce){            put(""Checked ${answersChecked}"")        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    inline fun brute(a:()->Unit){        if(withBruteForce){            a()        }    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }      var currentAnswer:String? = null    var currentBruteAnswer:String? = null    fun answer(a:Any){        currentAnswer = a.toString()        if(currentBruteAnswer != null){            checkAnswer()        }    }    fun put2(a:Any){answer(a);put(a) }     fun bruteAnswer(a:Any){        currentBruteAnswer = a.toString()        if(currentAnswer != null){            checkAnswer()        }    }    fun checkAnswer(){        if(currentAnswer != currentBruteAnswer){            throw Exception(""Failed Test: BF $currentBruteAnswer Current $currentAnswer"")        }        answersChecked ++    }}// 1. Moddedconst val p = 998_244_353Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}infix fun Int.modM(b:Int):Int{ return ((this * 1L * b) % pI).toInt() }infix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }fun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val Boolean.chi:Int get() = if(this) 1 else 0 //characteristic function// 2. DP initial valuesconst val plarge = 1_000_000_727const val nlarge = -plargeconst val phuge = 2_727_000_000_000_000_000Lconst val nhuge = -phugeval Char.code :Int get() = this.toInt() -  'a'.toInt()  fun largemod(s:String):Int {    var ret = 0    for(c in s){        val d = c.toInt() - '0'.toInt()        ret = ret modM 10        ret += d    }    return ret}var total = 0fun solve(s:String,x:Int, y:Int,musthavex:IntArray, musthavey:IntArray):Int{    // top, has x, has y     val shift = 10    val shiftdouble = 2 * shift + 1   //    ""original"" dei ""$x $y""    val must = musthavex.size    val MUST = 1 shl must     total += (1 shl (2 * must))     val xAdded = IntArray(10)    val yAdded = IntArray(10)    for((i,v) in musthavex.withIndex()){        xAdded[v] = 1 shl i    }    for((i,v) in musthavey.withIndex()){        yAdded[v] = 1 shl i    }    var DP = Array(2){Array(1 shl must){Array(1 shl must){IntArray(shiftdouble)}}}    DP[1][0][0][shift] = 1    for(c in s){        val next = Array(2){Array(1 shl must){Array(1 shl must){IntArray(shiftdouble)}}}        val d =c.toInt() - '0'.toInt()        for(top in 0 until 2){            for(xmask in 0 until MUST){                for(ymask in 0 until MUST){                    for(dif_shifted in 0 until shiftdouble){                        val dif = dif_shifted - shift                        val maxx = if(top == 1) d else 9                        val here = DP[top][xmask][ymask][dif_shifted]                        for(newx in 0..maxx){                            for(newy in 0 until 10){                                val newdif = dif * 10 + (newx * y) - (newy * x)                                if(newdif < -shift || newdif > shift) continue                                val newhasx = xmask or xAdded[newx]                                val newhasy = ymask or yAdded[newy]                                val newstate = if(top == 0) 0 else{if(newx == maxx) 1 else 0}                                next[newstate][newhasx][newhasy].put(newdif + shift,here)                            }                        }                    }                }            }        }        DP = next    }    val maxmask = (1 shl must) - 1    return DP[0][maxmask][maxmask][shift] modPlus DP[1][maxmask][maxmask][shift]}fun check(s:String,x:Int, y:Int):Int {    val n = s.toInt()    var ret = 0//    ""NEW"" dei ""$s $x $y""    for(i in 1..n){        if((i * y) %x == 0){            val other = (i * y )/x            if(i.toString().contains(('0'.toInt() + x).toChar())){                if(other.toString().contains(('0'.toInt() +y).toChar())){                    ret ++//                    all.remove(Pair(i,other))//                    all.add(Pair(other,i))//                    just dei ""$i $other""                }            }         }    }    return ret}fun totalCheck(n:Int):Int {    var ret = 0    for(A in 1..n){        here@for(B in 1..n){            for(x in 1..9){                for(y in 1..9){                    if(y * A != x * B) continue                    if(A.toString().contains(""$x""[0])){                        if(B.toString().contains(""$y""[0])){//                            all.add(Pair(A,B))                             ret++                            continue@here                        }                    }                }            }        }    }    return ret}  const val withBruteForce = falseconst val randCount = 100fun main(){    solve.cases{        val str = getstr()        var ret = largemod(str)        val all = mutableMapOf<Pair<Int,Int>, MutableList<Pair<Int,Int>>>()        for(y in 1..9) {            here@ for(x in (y + 1)..9) {                for((e, v) in all.entries) {                    if(e.first * y == e.second * x) {                        v.add(Pair(x, y))                        continue@here                    }                }                all[Pair(x,y)] = mutableListOf(Pair(x,y))            }        }         for((p,v) in all.entries){            for(mask in 1 until (1 shl v.size)){                val parity = if(mask.countOneBits() % 2 == 1) 1 else (pI - 1)                val (x,y) = p                val first = mutableListOf<Int>()                val second = mutableListOf<Int>()                for(i in 0 until v.size){                    if(mask and (1 shl i) != 0){                        first.add(v[i].first)                        second.add(v[i].second)                    }                }                ret = ret modPlus ( parity modM 2 modM solve(str,x,y, first.toIntArray(), second.toIntArray()))            }        }         put(ret)//        put(total)    }    done()}const val singleCase = true /* a single untli killed wrong place of x , y */",dp
"fun main() {    val (a, b,c ) = readLine()!!.split("" "").sorted()     fun shuntsu(a: String, b: String, d: Int = 1): Boolean {        val a0 = a[0].toInt()        val a1 = a[1]        val b0 = b[0].toInt()        val b1 = b[1]        return a1 == b1 && a0 + d == b0    }     val r = when {        a == b && b == c -> 0        shuntsu(a, b) && shuntsu(b, c) -> 0        a == b || b == c || a == c -> 1        shuntsu(a, b) || shuntsu(b, c) || shuntsu(a, c) || shuntsu(a, b, 2) || shuntsu(b, c, 2) || shuntsu(a, c, 2) -> 1        else -> 2    }    println(r)}","brute force,implementation"
"val sb = StringBuilder()val r = System.`in`.bufferedReader()private fun readInt() = r.readLine().toInt()private fun readLong() = r.readLine().toLong()private fun readInts() = r.readLine().split("" "").map { it.toInt() }private fun readLongs() = r.readLine().split("" "").map { it.toLong() } fun main() {    val (a, b, c) = r.readLine().split("" "").map { it.reversed() }.sorted()    sb.appendln(        when {            a == c -> 0            a == b || b == c -> 1            a[0] == c[0] && b[1] - a[1] == 1 && c[1] - b[1] == 1 -> 0            (a[0] == b[0] && (b[1] - a[1] == 1 || b[1] - a[1] == 2)) || (b[0] == c[0] && (c[1] - b[1] == 1||c[1] - b[1] == 2)) || (a[0] == c[0] && (c[1] - a[1] == 1||c[1] - a[1] == 2)) -> 1            else -> 2        }    )    print(sb)}","brute force,implementation"
"fun main() {    val tiles = readLine()!!.split("" "").toSet()    print(when (tiles.size) {        1 -> 0        2 -> 1        else -> {            var sol = 2            loop@for (suit in listOf('m', 'p', 's')) {                for (num in 1..7) {                    if ("""" + num + suit in tiles) {                        if ("""" + (num + 1) + suit in tiles && """" + (num + 2) + suit in tiles) {                            sol = 0                            break@loop                        }                        if ("""" + (num + 1) + suit in tiles || """" + (num + 2) + suit in tiles)                            sol = 1                    }                }                if (""8$suit"" in tiles && ""9$suit"" in tiles) sol = 1            }            sol        }    })}","brute force,implementation"
"private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() } fun main() {    val tiles = readStrings()    var min = 3    val base = '0'.toInt()    for (tile in tiles) {        val toKoutsu = 3 - tiles.count { s -> s == tile }        min = kotlin.math.min(toKoutsu, min)        var toShuntsu = 2        val next = (tile[0].toInt() -base + 1).toString() + tile[1]        if (tiles.contains(next)) {            toShuntsu--        }        val nextNext = (tile[0].toInt() - base + 2).toString() + tile[1]        if (tiles.contains(nextNext)) {            toShuntsu--        }        min = kotlin.math.min(toShuntsu, min)    }    println(min)}","brute force,implementation"
import java.util.* fun main() {    val scanner = Scanner(System.`in`)    val n = scanner.nextLong()    val m = scanner.nextInt()    val k = scanner.nextLong()    var delta = 0    var ans = 0    val a = Array(m) { scanner.nextLong() - 1 }    var i = 0    while (i < m) {        val which = (a[i] - delta) / k        var j = i + 1        while (j < m && (a[j] - delta) / k == which) j++        delta += j - i        i = j        ans++    }    println(ans)},"implementation,two pointers"
import java.util.* fun main(args: Array<String>) {    val inp = Scanner(System.`in`)    val n: Long = inp.nextLong()    val m: Int = inp.nextInt()    val k: Long = inp.nextLong()    val p = LongArray(m)    for (i in 0 until m) {        p[i] = inp.nextLong()    }    var steps: Long = 0    var pageNumber: Long    var i = 0    while (i < m) {        pageNumber = (p[i] - i - 1) / k + 1        val z = pageNumber * k + i        while (i < m && p[i] <= z) {            i++        }        steps++    }    println(steps)},"implementation,two pointers"
import java.io.PrintWriterimport java.util.* fun main(args: Array<String>) {    val inp = Scanner(System.`in`)    val out = PrintWriter(System.out)    val n: Long = inp.nextLong()    val m: Int = inp.nextInt()    val k: Long = inp.nextLong()    val p = LongArray(m)    for (i in 0 until m) {        p[i] = inp.nextLong()    }    var steps: Long = 0    var pageNumber: Long    var i = 0    while (i < m) {        pageNumber = (p[i] - i - 1) / k + 1        val z = pageNumber * k + i        while (i < m && p[i] <= z) {            i++        }        steps++    }    out.println(steps)    out.close()},"implementation,two pointers"
"private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }private fun readLongs() = readStrings().map { it.toLong() } fun main() {    val (total, delete, page) = readLongs()    val chosen = readLongs()    var ind = 0    var steps = 0    var count = 0     while (ind < chosen.size) {        val threshold = ((chosen[ind] - count - 1) / page + 1) * page + count        while (ind < chosen.size && chosen[ind] <= threshold) {            ind++            count++        }        steps++    }    println(steps)}","implementation,two pointers"
import kotlin.math.ceilimport kotlin.math.floor fun main(args: Array<String>) {    val n = readLine()!!.toInt()    val a = mutableListOf<Double>()    repeat(n) {        a.add(readLine()!!.toDouble())    }    val f = a.map { floor(it).toInt() }    var sum = f.sum()    for (i in f.indices) {        if (sum < 0 && !a[i].isInt()) {            sum++            println(f[i] + 1)        } else {            println(f[i])        }    } } private fun Double.isInt(): Boolean {    return floor(this) == ceil(this)},"constructive algorithms,greedy,math"
"import java.util.*import kotlin.math.ceilimport kotlin.math.floor //2019-06-28fun main(args: Array<String>) = with(Scanner(System.`in`)) {  val n = nextInt()  nextLine()  val numbers = (0 until n).map { nextLine().toDouble() }  val loweredNumbers = numbers.map { floor(it).toInt() }  var sum = loweredNumbers.sum()  loweredNumbers.forEachIndexed { index, d ->    if (sum < 0 && !numbers[index].isInt()) {      sum++      println(d + 1)    } else {      println(d)    }  }} private fun Double.isInt(): Boolean {  return floor(this) == ceil(this)}","constructive algorithms,greedy,math"
fun main(){    val n = readLine()!!.toInt()    var sum = 0    val a = IntArray(n)    val arr = IntArray(n)    for (i in 0 until n){        val b = readLine()!!.toDouble()        if (b.compareTo(b.toInt())==0){            arr[i]=1            a[i]=b.toInt()        }else{            if (b>0){                a[i]=b.toInt()            }else{                a[i]=b.toInt()-1            }        }        sum+=a[i]    }    for (i in 0 until n){        if (sum<0 && arr[i]!=1){            println(a[i]+1)            sum++        }else{            println(a[i])        }    }},"constructive algorithms,greedy,math"
"import kotlin.math.ceilimport kotlin.math.floor fun solve() {    val n = readLine()!!.toInt()     val a = LongArray(n)    val b = BooleanArray(n) {false}     for (i in 0 until n) {        val tmp = readLine()!!.toDouble()        if(ceil(tmp) == floor(tmp)) b[i] = true        a[i] = floor(tmp).toLong()    }     var s = a.fold(0L) {acc, ele -> acc + ele}     repeat (n) {        var ele = a[it]        if (s != 0L && !b[it]) {            ele += 1            s += 1        }        println(ele)    }} fun main(args: Array<String>) {    val t = 1    for (i in 1..t) solve()}","constructive algorithms,greedy,math"
"/** * @author Jaeguk Cho */ fun main() = repeat(readLine()!!.toInt()) {    println(        if ((readLine()!! matches readLine()!!.replace(""+"", """"""(\+|--)"""""").toRegex())) ""YES""        else ""NO""    )}","*special,implementation,strings"
"fun main() {    var k = readLine()!!.toInt()    for (i in 1..k) {        var s = readLine()        var t = readLine()        println(if (Regex(t!!.replace(""+"", ""(\\+|--)"")).matches(s.toString())) ""YES"" else ""NO"")    }}","*special,implementation,strings"
"fun main() {    var k = readLine()!!.toInt()    for (i in 1..k) {        var s = readLine()        var t = readLine()        println(if (Regex(t!!.replace(""+"", ""(\\+|--)"")).matches(s.toString())) ""YES"" else ""NO"")    }}","*special,implementation,strings"
"fun main() {    var k = readLine()!!.toInt()    for (i in 1..k) {        var s = readLine()        var t = readLine()        println(if (Regex(t!!.replace(""+"", ""(\\+|--)"")).matches(s.toString())) ""YES"" else ""NO"")    }}","*special,implementation,strings"
"private fun readString() = readLine()!!private fun readInt() = readString().toInt()private fun readLongs() = readString().split("" "").map { it.toLong() } fun main() {	val t = readInt()		repeat(t) {		val n = readInt()		val d = readLongs().toSortedSet()		val d2 = sortedSetOf<Long>()		val x = d.first() * d.last()		var i = 2L				while (i * i <= x) {			if (x % i == 0L) {				d2.add(i)								val i2 = x / i								if (i != i2) d2.add(i2)			}						i++		}				println(if (d == d2) x else -1)	}}","math,number theory"
"fun main(args: Array<String>) {    var t = readLine()!!.toInt()    while (t > 0) {        t--        val n = readLine()!!.toInt()        var d = readLine()!!.split(' ').map { it.toLong() }.toMutableList()        d.sort()        val can = d[0] * d[d.size-1]        if (ok(d, can)) {            println(can)        } else {            println(-1)        }    }} fun ok(arr : List<Long>, can: Long): Boolean {    var cur = 2L    val set = arr.toSet()    val set2 = mutableSetOf<Long>()    while (cur * cur <= can) {        if (can % cur == 0L) {            set2.add(cur)            set2.add(can / cur)        }        cur++    }    set2.forEach {        if (!set.contains(it)) {            return false        }    }     return set.size == set2.size}","math,number theory"
fun main(){    var n = readLine()!!.toInt()    repeat(n){        var m = readLine()!!.toLong()        var a = readLine()!!.split(' ').map(String::toLong).sorted()        var answ : Long = a[0] * a[a.size - 1]        var v = ArrayList <Long>()        for (i : Long in 2 ..answ - 1){            if (i * i > answ){                break            }            if (answ % i == 0L){                v.add(i)                if (i != answ / i){                    v.add(answ / i)                }            }        }        v.sort()        if (a.size != v.size) {            answ = -1        } else {            for (i in 0 .. a.size - 1)                if (a[i] != v[i]) {                    answ = -1                    break                }        }        println(answ)    }},"math,number theory"
import kotlin.math.sqrt fun foo(x: Long): Int {    val sqrt = sqrt(x.toDouble())    var i = 1L    var ans = 0     while (i < sqrt) {        if (x % i == 0L) {            ans++        }         i++    }     return if (i * i == x) 2 * ans + 1 else 2 * ans} fun main() {    val t = readLine()!!.toInt()     for (i in 1..t) {        readLine()        val numbers = readLine()!!.split(' ').map { it.toLong() }.sorted()        val x = numbers.first() * numbers.last()        var flag = true         for (j in 0..numbers.size/2) {            if (numbers[j] * numbers[numbers.lastIndex - j] != x) {                flag = false                break            }        }         if (!flag || (foo(x) - 2 != numbers.size))            println(-1)        else            println(x)    }},"math,number theory"
"import java.io.* fun main() = bufferOut { readSolveWrite() } private const val MOD = 1000_000_007 private val dp = IntArray(2001 * 2001 * 2) { -1 } fun compute(b: Int, r: Int, u: Int): Int {    if (b < 0 || b > r || r == 0) return 0    val index = (b * 2001 + r) * 2 + u    dp[index].let { if (it >= 0) return it }    var res = (compute(b + 1, r - 1, 0) + compute(b - 1, r - 1, 0)) % MOD    if (u == 0) {        if (b < r)            res =  modMax(res, (1 + compute(b + 1, r - 1, 1) + compute(b - 1, r - 1, 0)) % MOD)        if (b > 0)            res = modMax(res, (1 + compute(b + 1, r - 1, 0) + compute(b - 1, r - 1, 1)) % MOD)    }    dp[index] = res    return res} fun modMax(a: Int, b: Int): Int =    if ((a - b + MOD) % MOD < MOD / 2) a else b private fun PrintWriter.readSolveWrite() {    val n = readLine()!!.toInt()    println(compute(0, 2 * n, 0))} private fun bufferOut(block: PrintWriter.() -> Unit) = PrintWriter(System.out).use { block(it) }","dp,greedy,trees"
"import java.util.* fun main(args: Array<String>) {    val (row, col) = readLine()!!.split("" "").map { it.toInt() }     val list = ArrayList<List<Int>>()    repeat(row) {        list.add(                readLine()!!.split("" "").map { it.toInt() }        )    }     val out = IntArray(row) { 0 }    if (xor(list, out) == 0) {        outer@ for (r in 0 until row) {            for (c in 1 until col) {                if (list[r][0] != list[r][c]) {                    out[r] = c                    break@outer                }            }        }    }     if (xor(list, out) == 0) {        println(""NIE"")    } else {        println(""TAK"")        println(out.map { it + 1 } .joinToString (separator = "" ""))    }} fun xor(list: ArrayList<List<Int>>, out: IntArray): Int {    var r = 0    repeat(list.size) { row ->        val col = out[row]        r = r xor list[row][col]    }    return r}","bitmasks,brute force,constructive algorithms,dp"
"fun main() {    var t: Throwable? = null    Thread(null, ::div2_553b, ""solve"", 128 * 1024 * 1024)        .apply { setUncaughtExceptionHandler { _, t1 -> t = t1 } }        .apply { start() }.join()    t?.let { throw it }} @OptIn(ExperimentalStdlibApi::class)fun div2_553b() {    val (n, m) = readLine()!!.split("" "").map { it.toInt() }    val matrix = Array(n) { readLine()!!.split("" "").map { it.toInt() }.toIntArray() }     var takConfirmed = false    var confirmedRow = -1    var xorSum = 0     for ((i, row) in matrix.withIndex()) {        val distinct = row.distinct()         if (!takConfirmed && distinct.size >= 2) {            takConfirmed = true            confirmedRow = i        } else {            xorSum = xorSum xor distinct.first()        }    }     if (!takConfirmed) {        return when (xorSum) {            0 -> println(""NIE"")            else -> {                println(""TAK"")                println((1..n).map { 1 }.joinToString("" ""))            }        }    }     println(""TAK"")     val answers = mutableListOf<Int>()     for (y in 0 until n) {        answers.add(when (y) {            confirmedRow -> matrix[confirmedRow].indexOfFirst { it xor xorSum != 0 } + 1            else -> 1        })    }     val answer = answers.joinToString("" "")     println(answer)}","bitmasks,brute force,constructive algorithms,dp"
"private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private val regSpace = ""\\s+"".toRegex() private fun readSomeInts(): List<Int> {    val line = readLn().trim()    val strlst = line.split(regSpace)    return strlst.map { it.toInt() }} fun main() {    val (n, m) = readSomeInts()     val mtrx: MutableList<List<Int>> = mutableListOf()     for (i in 1..n) {        val row = readSomeInts()        mtrx.add(row)         if (row.size != m)            throw Error(""Illegal argument: m != row.size"")    }     val kurz = mtrx.map { r ->        r.withIndex().sortedBy { it.value }.distinctBy { it.value }.toMutableList()    }.toMutableList()     if (kurz.all { it.size == 1 }) {        val xorProduct = kurz.map { it.first().value }.reduce { acc, b -> acc xor b }        if (xorProduct <= 0) {            println(""NIE"")        } else {            println(""TAK"")            val resultstr = kurz.map { it.first().index + 1 }.joinToString(separator="" "")            println(resultstr)        }    } else {        val xorForFirsts = kurz.map { it.first().value }.reduce { acc, b -> acc xor b }        if (xorForFirsts == 0) {            for (i in 0 until kurz.size) {                if (kurz[i].size > 1) {                    kurz[i].removeAt(0)                    break                }            }        }        println(""TAK"")        val resultstr = kurz.map { it.first().index + 1 }.joinToString(separator="" "")        println(resultstr)    } }","bitmasks,brute force,constructive algorithms,dp"
"import java.util.* fun main() {    val (n, q) = readInts()    val word = readLn()     val arbiter = Arbiter(word)     output {        repeat(q) {            val t = readStrings()            when(t[0]) {                ""+"" -> arbiter.append(t[1].toInt(), t[2].first())                ""-"" -> arbiter.removeLast(t[1].toInt())            }            println(if(arbiter.isGood) ""YES"" else ""NO"")        }    }} const val MAX_RELIGION_LENGTH = 250 class Arbiter(val word: String) {     private val religions = Array(3) { ArrayList<Char>(MAX_RELIGION_LENGTH) }     private inline fun religion(index: Int) = religions[index - 1]     private val N =        Array(26) {            val c = 'a' + it            var acc = word.length            IntArray(word.length).apply {                for(i in word.lastIndex downTo 0) {                    if(word[i] == c) acc = i                    this[i] = acc                }            }        }     private inline fun firstAfter(char: Char, position: Int) =        if(position >= word.length) word.length else N[char - 'a'][position]     private val D = Array(MAX_RELIGION_LENGTH+1) {        Array(MAX_RELIGION_LENGTH+1) {            IntArray(MAX_RELIGION_LENGTH+1)        }    }.also { it[0][0][0] = -1 }     private inline fun updateD(n1: Int, n2: Int, n3: Int) {        D[n1][n2][n3] = minOf(            if(n1 > 0) firstAfter(religion(1)[n1-1], D[n1-1][n2][n3] + 1) else word.length,            if(n2 > 0) firstAfter(religion(2)[n2-1], D[n1][n2-1][n3] + 1) else word.length,            if(n3 > 0) firstAfter(religion(3)[n3-1], D[n1][n2][n3-1] + 1) else word.length        )    }       fun append(religion: Int, char: Char) {        religion(religion).add(char)        when(religion) {            1 -> {                for(x in 0..religion(2).size) {                    for(y in 0..religion(3).size) {                        updateD(religion(1).size, x, y)                    }                }            }            2 -> {                for(x in 0..religion(1).size) {                    for(y in 0..religion(3).size) {                        updateD(x, religion(2).size, y)                    }                }            }            3 -> {                for(x in 0..religion(1).size) {                    for(y in 0..religion(2).size) {                        updateD(x, y, religion(3).size)                    }                }            }        }    }     fun removeLast(religion: Int) {        religion(religion).run { removeAt(lastIndex) }    }     val isGood: Boolean get() = D[religion(1).size][religion(2).size][religion(3).size] < word.length} fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readDouble() = readLn().toDouble()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readInts() = readStrings().map { it.toInt() }fun readDoubles() = readStrings().map { it.toDouble() }fun readLongs() = readStrings().map { it.toLong() } class Output {    private val sb = StringBuilder()    fun print(o: Any?) { sb.append(o) }    fun println() { sb.append('\n') }    fun println(o: Any?) { sb.append(o).append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(sb) }}inline fun output(block: Output.()->Unit)    { Output().apply(block).nowPrint() }","dp,implementation,strings"
"import java.util.* fun main() {    val (n, q) = readInts()    val word = readLn()     val arbiter = Arbiter(word)     output {        repeat(q) {            val t = readStrings()            when(t[0]) {                ""+"" -> arbiter.append(t[1].toInt(), t[2].first())                ""-"" -> arbiter.removeLast(t[1].toInt())            }            println(if(arbiter.isGood) ""YES"" else ""NO"")        }    }} const val MAX_RELIGION_LENGTH = 250 class Arbiter(val word: String) {     private val religions = Array(3) { CharArray(MAX_RELIGION_LENGTH) }    private val religionSizes = IntArray(3)     private val N =        Array(26) {            val c = 'a' + it            var acc = word.length            IntArray(word.length).apply {                for(i in word.lastIndex downTo 0) {                    if(word[i] == c) acc = i                    this[i] = acc                }            }        }     private inline fun firstAfter(char: Char, position: Int) =        if(position >= word.length) word.length else N[char - 'a'][position]     private val D = Array(MAX_RELIGION_LENGTH+1) {        Array(MAX_RELIGION_LENGTH+1) {            IntArray(MAX_RELIGION_LENGTH+1)        }    }.also { it[0][0][0] = -1 }     private inline fun updateD(n1: Int, n2: Int, n3: Int) {        D[n1][n2][n3] = minOf(            if(n1 > 0) firstAfter(religions[0][n1-1], D[n1-1][n2][n3] + 1) else word.length,            if(n2 > 0) firstAfter(religions[1][n2-1], D[n1][n2-1][n3] + 1) else word.length,            if(n3 > 0) firstAfter(religions[2][n3-1], D[n1][n2][n3-1] + 1) else word.length        )    }       fun append(religion: Int, char: Char) {        val i = religion - 1        religions[i][religionSizes[i]] = char        religionSizes[i]++        when(i) {            0 -> {                for(x in 0..religionSizes[1]) {                    for(y in 0..religionSizes[2]) {                        updateD(religionSizes[0], x, y)                    }                }            }            1 -> {                for(x in 0..religionSizes[0]) {                    for(y in 0..religionSizes[2]) {                        updateD(x, religionSizes[1], y)                    }                }            }            2 -> {                for(x in 0..religionSizes[0]) {                    for(y in 0..religionSizes[1]) {                        updateD(x, y, religionSizes[2])                    }                }            }        }    }     fun removeLast(religion: Int) {        religionSizes[religion-1] --    }     val isGood: Boolean get() = D[religionSizes[0]][religionSizes[1]][religionSizes[2]] < word.length} fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readDouble() = readLn().toDouble()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readInts() = readStrings().map { it.toInt() }fun readDoubles() = readStrings().map { it.toDouble() }fun readLongs() = readStrings().map { it.toLong() } class Output {    private val sb = StringBuilder()    fun print(o: Any?) { sb.append(o) }    fun println() { sb.append('\n') }    fun println(o: Any?) { sb.append(o).append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(sb) }}inline fun output(block: Output.()->Unit)    { Output().apply(block).nowPrint() }","dp,implementation,strings"
"import java.util.* fun main() {    val (n, q) = readInts()    val word = readLn()     val arbiter = Arbiter(word)     output {        repeat(q) {            val t = readStrings()            when(t[0]) {                ""+"" -> arbiter.append(t[1].toInt(), t[2].first())                ""-"" -> arbiter.removeLast(t[1].toInt())            }            println(if(arbiter.isGood) ""YES"" else ""NO"")        }    }} const val MAX_RELIGION_LENGTH = 250 class Arbiter(val word: String) {     private val religions = Array(3) { CharArray(MAX_RELIGION_LENGTH) }    private val religionSizes = IntArray(3)     //private inline fun religion(index: Int) = religions[index - 1]     private val N =        Array(26) {            val c = 'a' + it            var acc = word.length            IntArray(word.length).apply {                for(i in word.lastIndex downTo 0) {                    if(word[i] == c) acc = i                    this[i] = acc                }            }        }     private inline fun firstAfter(char: Char, position: Int) =        if(position >= word.length) word.length else N[char - 'a'][position]     private val D = Array(MAX_RELIGION_LENGTH+1) {        Array(MAX_RELIGION_LENGTH+1) {            IntArray(MAX_RELIGION_LENGTH+1)        }    }.also { it[0][0][0] = -1 }     private inline fun updateD(n1: Int, n2: Int, n3: Int) {        D[n1][n2][n3] = minOf(            if(n1 > 0) firstAfter(religions[0][n1-1], D[n1-1][n2][n3] + 1) else word.length,            if(n2 > 0) firstAfter(religions[1][n2-1], D[n1][n2-1][n3] + 1) else word.length,            if(n3 > 0) firstAfter(religions[2][n3-1], D[n1][n2][n3-1] + 1) else word.length        )    }       fun append(religion: Int, char: Char) {        val i = religion - 1        religions[i][religionSizes[i]] = char        religionSizes[i]++        when(i) {            0 -> {                for(x in 0..religionSizes[1]) {                    for(y in 0..religionSizes[2]) {                        updateD(religionSizes[0], x, y)                    }                }            }            1 -> {                for(x in 0..religionSizes[0]) {                    for(y in 0..religionSizes[2]) {                        updateD(x, religionSizes[1], y)                    }                }            }            2 -> {                for(x in 0..religionSizes[0]) {                    for(y in 0..religionSizes[1]) {                        updateD(x, y, religionSizes[2])                    }                }            }        }    }     fun removeLast(religion: Int) {        religionSizes[religion-1] --    }     val isGood: Boolean get() = D[religionSizes[0]][religionSizes[1]][religionSizes[2]] < word.length} fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readDouble() = readLn().toDouble()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readInts() = readStrings().map { it.toInt() }fun readDoubles() = readStrings().map { it.toDouble() }fun readLongs() = readStrings().map { it.toLong() } class Output {    private val sb = StringBuilder()    fun print(o: Any?) { sb.append(o) }    fun println() { sb.append('\n') }    fun println(o: Any?) { sb.append(o).append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(sb) }}inline fun output(block: Output.()->Unit)    { Output().apply(block).nowPrint() }","dp,implementation,strings"
"import java.util.* fun main() {    val (n, q) = readInts()    val word = readLn()     val arbiter = Arbiter(word)     output {        repeat(q) {            val t = readStrings()            when(t[0]) {                ""+"" -> arbiter.append(t[1].toInt(), t[2].first())                ""-"" -> arbiter.removeLast(t[1].toInt())            }            println(if(arbiter.isGood) ""YES"" else ""NO"")        }    }} const val MAX_RELIGION_LENGTH = 250 class Arbiter(val word: String) {     val wordLength = word.length     private val religions = Array(3) { CharArray(MAX_RELIGION_LENGTH) }    private val religionSizes = IntArray(3)     private val N =        Array(26) {            val c = 'a' + it            var acc = wordLength            IntArray(wordLength).apply {                for(i in wordLength-1 downTo 0) {                    if(word[i] == c) acc = i                    this[i] = acc                }            }        }     private inline fun firstAfter(char: Char, position: Int) =        if(position >= wordLength) wordLength else N[char - 'a'][position]     private val D = Array(MAX_RELIGION_LENGTH+1) {        Array(MAX_RELIGION_LENGTH+1) {            IntArray(MAX_RELIGION_LENGTH+1)        }    }.also { it[0][0][0] = -1 }     private inline fun updateD(n1: Int, n2: Int, n3: Int) {        D[n1][n2][n3] = minOf(            if(n1 > 0) firstAfter(religions[0][n1-1], D[n1-1][n2][n3] + 1) else wordLength,            if(n2 > 0) firstAfter(religions[1][n2-1], D[n1][n2-1][n3] + 1) else wordLength,            if(n3 > 0) firstAfter(religions[2][n3-1], D[n1][n2][n3-1] + 1) else wordLength        )    }       fun append(religion: Int, char: Char) {        val i = religion - 1        religions[i][religionSizes[i]] = char        religionSizes[i]++        when(i) {            0 -> {                for(x in 0..religionSizes[1]) {                    for(y in 0..religionSizes[2]) {                        updateD(religionSizes[0], x, y)                    }                }            }            1 -> {                for(x in 0..religionSizes[0]) {                    for(y in 0..religionSizes[2]) {                        updateD(x, religionSizes[1], y)                    }                }            }            2 -> {                for(x in 0..religionSizes[0]) {                    for(y in 0..religionSizes[1]) {                        updateD(x, y, religionSizes[2])                    }                }            }        }    }     fun removeLast(religion: Int) {        religionSizes[religion-1] --    }     val isGood: Boolean get() = D[religionSizes[0]][religionSizes[1]][religionSizes[2]] < wordLength}  fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readInts() = readStrings().map { it.toInt() }fun readDoubles() = readStrings().map { it.toDouble() }fun readLongs() = readStrings().map { it.toLong() } // helper for competitive programming; faster at printing many lines than repeated println callsclass Output {    private val sb = StringBuilder()    fun print(o: Any?) { sb.append(o) }    fun println(o: Any?) { sb.append(o).append('\n') }    fun println() { sb.append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(sb) }}inline fun output(block: Output.()->Unit) { Output().apply(block).nowPrint() }","dp,implementation,strings"
"import kotlin.math.*import java.io.* fun main() {    val reader = System.`in`.bufferedReader()    val writer = PrintWriter(System.out, false)     val (health, n) = reader.readLine().split("" "").map { it.toLong() }    val damage = reader.readLine().split("" "").map {it.toLong() }     val sum = -damage.sum()    var ans = Long.MAX_VALUE    var prefix = 0L     for (i in 0 until n) {        if (health + prefix <= 0) {            ans = min(ans, i)        } else if (sum > 0) {            ans = min(ans, (health + prefix + sum - 1) / sum * n + i)        }        prefix += damage[i.toInt()]    }     writer.println(if (ans == Long.MAX_VALUE) -1 else ans)     writer.close()}",math
"private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of ints fun main(args: Array<String>) {    var z = readStrings()    var h: Long = z[0].toLong()    var n = z[1].toInt()    var a = readInts()     var res:Long = Long.MAX_VALUE    var sum = Array<Long>(n+1) { i->0}     for (i in 0..n-1)    {        sum[i+1] = sum[i]+a[i]        if ((sum[i+1]+h)<=0){            res = (i+1).toLong()            break;        }    }      if (res.equals(Long.MAX_VALUE)) {        if (sum[n] >= 0 )            println (-1)        else {            for (i in 1..n){                 if (((h+sum[i])%sum[n]).toInt() != 0)                    res = Math.min (res, (Math.abs((h+ sum[i])/sum[n])+1)*n + i)                else res  = Math.min (res,  (Math.abs((h+ sum[i])/sum[n]))*n + i)            }            println (res)        }    }    else println (res )}",math
"import java.io.PrintWriterimport kotlin.math.* fun main(args: Array<String>) {    io.apply {         val (h, n) = long to int        val d = ints(n)        val delta = d.fold(0L, Long::plus)        var curH = h.toLong()        val ans = d.mapIndexed { ix, v ->            curH += v            when {                curH <= 0 -> ix.toLong() + 1                delta < 0 -> ix + n * (((curH - 1) / -delta) + 1) + 1                else -> null            }        }.mapNotNull { it }.min() ?: -1        cout .. ans .. nl     }.cout.flush()} // @formatter:offprivate val io = object {    private val `in` = System.`in`    private fun ll(): Long {        var x: Int; var q = false; var n = 0L; do x = `in`.read() while (x < 33); if (x == 45) { q = true; x = `in`.read() }        do { n = n * 10 - x + 48; x = `in`.read() } while (x > 32); return if (q) n else -n    }    val int get() = ll().toInt(); val long get() = ll()    fun ints(n: Int = int): IntArray { return IntArray(n) { int } }    fun ints1(n: Int = int): IntArray { return IntArray(n) { int - 1 } }    val cout = PrintWriter(System.out); val nl = ""\n""    operator fun PrintWriter.rangeTo(a: Int): PrintWriter { print(a); print("" ""); return this }    operator fun PrintWriter.rangeTo(a: Long): PrintWriter { print(a); print("" ""); return this }    operator fun PrintWriter.rangeTo(a: IntArray): PrintWriter { a.forEach { print(it); print("" "") }; return this }    operator fun PrintWriter.rangeTo(a: String): PrintWriter { write(a); return this }} // @formatter:on /* ----------- */ ",math
"import java.util.* fun main() {    val (Hstr, nstr) = readStrings()    val H = Hstr.toLong()    val n = nstr.toInt()     val d = readIntArray(n)     var minPs = 0L    val ps = run {        var sum = 0L        LongArray(n) {            sum += d[it]            if(sum < minPs) minPs = sum            sum        }    }     val cyc = ps.last()     val ans = run {        if(H > -minPs && cyc >= 0) return@run -1L        val numRounds = if(H <= -minPs) 0L else (H + minPs - 1) / -cyc + 1        val roundH = H + cyc * numRounds         numRounds * n + ps.indices.first { -ps[it] >= roundH } + 1    }     println(ans)} fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readDouble() = readLn().toDouble()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readStringSeq() = readLn().splitToSequence(' ')fun readInts() = readStrings().map { it.toInt() }fun readIntSeq() = readStringSeq().map { it.toInt() }fun readIntArray(size: Int) = readIntSeq().iterator().let { i -> IntArray(size) { i.next() } }fun readDoubles() = readStrings().map { it.toDouble() }fun readDoubleSeq() = readStringSeq().map { it.toDouble() }fun readDoubleArray(size: Int) = readDoubleSeq().iterator().let { i -> DoubleArray(size) { i.next() } }fun readLongs() = readStrings().map { it.toLong() }fun readLongSeq() = readStringSeq().map { it.toLong() }fun readLongArray(size: Int) = readLongSeq().iterator().let { i -> LongArray(size) { i.next() } } class Output {    private val sb = StringBuilder()    fun print(o: Any?) { sb.append(o) }    fun println() { sb.append('\n') }    fun println(o: Any?) { sb.append(o).append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(sb) }}inline fun output(block: Output.()->Unit) { Output().apply(block).nowPrint() }",math
"import java.util.* typealias Pii = Pair<Int, Int>typealias Pll = Pair<Long, Long> var seg = Array(1200005) { mutableListOf<Pii>() }; fun update(i: Int, s: Int, e: Int, x: Int, y: Int, v: Pii) {    if (e < x || y < s) return;    if (x <= s && e <= y) {        seg[i].add(v);        return;    }    var m = (s + e) / 2;    update(i * 2, s, m, x, y, v);    update(i * 2 + 1, m + 1, e, x, y, v);} val off = 300005;var par = Array(600010) { 0 };var sz1 = Array(600010) { 0 };var sz2 = Array(600010) { 0 };var ans: Long = 0; fun find(x: Int): Int {    var x = x;    while (par[x] != 0) x = par[x];    return x;} var rev = mutableListOf<Int>();fun merge(x: Int, y: Int) {    var x = find(x);    var y = find(y);    if (x == y) return;    if (sz1[x] + sz2[x] < sz1[y] + sz2[y]) {        var t = x;        x = y;        y = t;    }    rev.add(y);    par[y] = x;    ans -= sz1[x].toLong() * sz2[x];    ans -= sz1[y].toLong() * sz2[y];    sz1[x] += sz1[y];    sz2[x] += sz2[y];    ans += sz1[x].toLong() * sz2[x];} fun remove() {    var y = rev[rev.size - 1];    rev.removeAt(rev.size - 1);    var x = par[y];    par[y] = 0;    ans -= sz1[x].toLong() * sz2[x];    sz1[x] -= sz1[y];    sz2[x] -= sz2[y];    ans += sz1[x].toLong() * sz2[x];    ans += sz1[y].toLong() * sz2[y];} fun answer(i: Int, s: Int, e: Int) {    var psz = rev.size;    for (j in seg[i]) {        merge(j.first, j.second + off);    }    if (s < e) {        var m = (s + e) / 2;        answer(i * 2, s, m);        answer(i * 2 + 1, m + 1, e);    }    else print(""$ans "");    while (rev.size > psz) remove();} fun main(args: Array<String>) = with(Scanner(System.`in`)) {    for (i in 0 until off) sz1[i] = 1;    for (i in off until off * 2) sz2[i] = 1;    var q = nextInt();    var mp = mutableMapOf<Pii, Int>();    for (i in 1..q) {        var x = nextInt();        var y = nextInt();        if (mp.containsKey(Pii(x, y))) {            update(1, 1, q, mp.get(Pii(x, y)) ?: 0, i - 1, Pii(x, y));            mp.remove(Pii(x, y));        }        else {            mp.put(Pii(x, y), i);        }    }    for (i in mp.keys) {        update(1, 1, q, mp.get(i) ?: 0, q, i);    }    answer(1, 1, q);}","data structures,divide and conquer,dsu"
"import java.util.* typealias Pii = Pair<Int, Int>typealias Pll = Pair<Long, Long> fun main(args: Array<String>) = with(Scanner(System.`in`)) {    var n = nextInt();    var k = nextInt();    var a = Array(n) { Pair(nextInt(), nextInt()) };    a.sortByDescending { it.second };    var q = PriorityQueue<Int>();    var sum: Long = 0;    var ans: Long = 0;    for (i in 0 until n) {        q.add(a[i].first);        sum += a[i].first;        if (q.size > k) {            sum -= q.poll();        }        if (ans < sum * a[i].second) ans = sum * a[i].second;    }    println(""$ans"");}","brute force,data structures,sortings"
"import java.lang.Long.maximport java.util.* fun main() {    val (count, limit) = readLine()!!.split(' ').map { it.toInt() }    val songs = Array(count) { readSong() }    songs.sortByDescending { it.beauty }    val queue = PriorityQueue<Int>(limit)    var sumInQueue = 0L    var answer = 0L    for (song in songs) {        if (queue.size < limit) {            queue.add(song.length)            sumInQueue += song.length        } else if (queue.peek() < song.length) {            sumInQueue -= queue.poll()            queue.add(song.length)            sumInQueue += song.length        }        answer = max(answer, sumInQueue * song.beauty)    }    println(answer)} data class Song(val length: Int, val beauty: Int) fun readSong(): Song {    val (length, beauty) = readLine()!!.split(' ').map { it.toInt() }    return Song(length, beauty)}","brute force,data structures,sortings"
"import java.io.PrintWriterimport java.lang.StringBuilderimport java.util.PriorityQueueimport java.util.StringTokenizerimport kotlin.math.* fun main() {    output {        val n = readInt()        val k = readInt()         val songs = MutableList(n) {            Song(readInt(), readInt())        }         songs.sortByDescending { it.beauty }         val pq = PriorityQueue<Song>(k+1, compareBy { it.length })        var lensum = 0L        var ans = 0L         for(song in songs) {            pq.add(song)            lensum += song.length            if(pq.size > k) {                lensum -= pq.remove().length            }            ans = max(ans, song.beauty * lensum)        }         println(ans)    }} data class Song(val length: Int, val beauty: Int) /** IO code start */@JvmField val _reader = System.`in`.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readInts(n: Int) = List(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() } @JvmField val _writer = PrintWriter(System.out, false)inline fun output(block: PrintWriter.()->Unit) { _writer.apply(block).flush() }fun iprintln(o: Any?) { println(o) } // immediate println for interactive, bypasses output{} blocks","brute force,data structures,sortings"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport kotlin.math.max fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val n = jin.readLine().toInt()    var dp = IntArray(26)    val present = BooleanArray(26)    for (j in 1..n) {        val new = IntArray(26) { if (present[it]) 1 else 0 }        val s = jin.readLine().map { it - 'a' }        var last = -1        var curr = 0        for (chara in s) {            if (chara == last) {                curr++            } else {                last = chara                curr = 1            }            new[chara] = max(new[chara], curr)        }        if (s.all { it == s[0] }) {            new[s[0]] = max(new[s[0]], ((dp[s[0]] + 1) * (s.size + 1)) - 1)        } else {            var k1 = 0            while (s[k1] == s[0]) {                k1++            }            var k2 = s.size - 1            while (s[k2] == s.last()) {                k2--            }            if (s[0] == s.last()) {                if (present[s[0]]) {                    new[s[0]] = max(new[s[0]], k1 + s.size - k2)                }            } else {                if (present[s[0]]) {                    new[s[0]] = max(new[s[0]], k1 + 1)                }                if (present[s.last()]) {                    new[s.last()] = max(new[s.last()], s.size - k2)                }            }        }        for (chara in s) {            present[chara] = true        }        dp = new    }    println(dp.max())}","dp,greedy,strings"
"import kotlin.math.max fun main() {    val (w1, h1, w2, h2) = readLine()!!.split(' ').map { s -> s.toInt() }    println(2*(h1 + h2) + 2*max(w1, w2) + 4)}",math
"import java.lang.Math.abs fun main() {    val (w1, h1, w2, h2) = readLine()!!.split(' ').map(String::toInt)    print(w1 + w2 + 4 + 2 * (h1 + h2) + abs(w1 - w2))}",math
"import kotlin.math.max fun main(args: Array<String>) {    val (w1, h1, w2, h2) = readLine()!!.split("" "").map(String::toInt)    val answer = 2 * (h1 + h2) + 2 * max(w1, w2) + 4    println(answer)}",math
"fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val (w1, h1, w2, h2) = readInts()    var sol = w1 + 2    sol += 2 * h1    sol += w1 + 2 - w2    sol += 2 * (h2 - 1)    sol += w2 + 2    print(sol)}",math
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.* fun main() {    val tokenizer = BufferedReader(InputStreamReader(System.`in`)).use { StringTokenizer(it.readText()) }    val n = tokenizer.nextInt()    val m = tokenizer.nextInt()    val a = Array(n) { tokenizer.nextInt() }.apply {        sort()        reverse()    }    if (a.sum() < m)        println(""-1"")    else {        var l = 1        var r = n        while (l < r) {            val mid = (l + r) / 2            if (check(a, m, mid))                r = mid            else                l = mid + 1        }        println(l)    }} fun check(a: Array<Int>, m: Int, d: Int): Boolean {    var sum = 0    for (i in 0 until a.size) {        val debuff = i / d        if (a[i] <= debuff)            break        sum += a[i] - debuff        if (sum >= m) return true    }    return sum >= m} fun StringTokenizer.nextInt() = nextToken().toInt()fun StringTokenizer.nextLong() = nextToken().toLong()","binary search,greedy"
"import java.io.Fileimport java.util.* fun main() {//    val scanner = Scanner(File(""input.txt""))    val scanner = Scanner(System.`in`)     val numberOfCups = scanner.nextInt()    val numberOfPages = scanner.nextInt()    val caffeineInput = Array(numberOfCups) { 0L }    for (i in 0 until numberOfCups) {        caffeineInput[i] = scanner.nextLong()    }    val caffeine = caffeineInput.sortedDescending().toTypedArray()     if (!canWriteInNumberOfDays(numberOfCups, numberOfCups, numberOfPages, caffeine)) {        println(-1)        return    }     var left = 1    var right = numberOfCups    while (right != left) {        val middle = (right + left) / 2        if (canWriteInNumberOfDays(middle, numberOfCups, numberOfPages, caffeine)) {            right = middle        } else {            left = middle + 1        }    }    println(left)} fun canWriteInNumberOfDays(    numberOfDays: Int,    numberOfCups: Int,    targetNumberOfPages: Int,    caffeine: Array<Long> // Sorted by descending): Boolean {    val maxNumberOfPages = calculateMaxNumberOfPages(numberOfDays, numberOfCups, caffeine)    return maxNumberOfPages >= targetNumberOfPages} fun calculateMaxNumberOfPages(    numberOfDays: Int,    numberOfCups: Int,    caffeine: Array<Long>): Long {    var orderOfCup = 0L    var numberOfPages = 0L    for (i in 0 until numberOfCups) {        numberOfPages += maxOf(caffeine[i] - orderOfCup, 0L)        if (i % numberOfDays == numberOfDays - 1) ++orderOfCup    }    return numberOfPages}","binary search,greedy"
"import java.io.*import java.util.* fun main() {    solve(System.`in`, System.out)} val MAX_N = (1e6 + 10).toInt()val INF = (1e9 + 7).toInt()val MOD = (1e9 + 7).toInt() fun solve(input: InputStream, output: OutputStream) {    val reader = InputReader(BufferedInputStream(input))    val writer = PrintWriter(BufferedOutputStream(output))     solve(reader, writer)    writer.close()} fun solve(reader: InputReader, writer: PrintWriter) {    val n = reader.nextInt()    val m = reader.nextLong()    val a = reader.nextArrayLong(n).sortedArrayDescending()    writer.println(search(1, n, n, m, a))} fun search(l: Int, r: Int, n: Int, m: Long, a: LongArray): Int {    if (l > r) {        return -1    }    val x = (l + r) / 2    if (check(x, n, m, a)) {        val t = search(l, x - 1, n, m, a)        return if (t != -1) t else x    }    return search(x + 1, r, n, m, a)} fun check(x: Int, n: Int, m: Long, a: LongArray): Boolean {    val a1 = a.filterIndexed { i, v -> v >= i / x }    val n1 = a1.size    val k1 = n1 / x    val r1 = n1 % x    val count = a1.sum() - x * k1 * (k1 - 1) / 2 - k1 * r1    return count >= m}  class InputReader(stream: InputStream) {    private val reader = BufferedReader(InputStreamReader(stream), 32768)    private var tokenizer: StringTokenizer? = null     operator fun next(): String {        while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {            try {                tokenizer = StringTokenizer(reader.readLine())            } catch (e: IOException) {                throw RuntimeException(e)            }         }        return tokenizer!!.nextToken()    }     fun nextInt(): Int {        return Integer.parseInt(next())    }     fun nextLong(): Long {        return java.lang.Long.parseLong(next())    }     fun nextArrayInt(count: Int): IntArray {        return nextArrayInt(0, count)    }     fun nextArrayInt(start: Int, count: Int): IntArray {        val a = IntArray(start + count)        for (i in start until start + count) {            a[i] = nextInt()        }        return a    }     fun nextArrayLong(count: Int): LongArray {        val a = LongArray(count)        repeat(count) { a[it] = nextLong() }        return a    }}","binary search,greedy"
"import java.io.*import java.util.* fun solve() {    val n = readInt()    val m = readLong()    val a = readLongs()    Arrays.sort(a)    a.reverse()     fun check(w : Int): Boolean {        var ww = w        var count = 0L        var ind = 1        var nn = 0        for (i in 0 until w)            count += a[i]        while (ww < n) {            count += if (a[ww] - ind < 0) 0 else a[ww] - ind            ww++            nn++            if (nn == w) {                nn = 0                ind++            }        }        return count >= m    }     var left = 0    var right = n    while (right - left > 1) {        var mid = (right + left) shr 1        if (check(mid))            right = mid        else            left = mid    }     out.println(if (check(right)) right else -1)} fun binmult(a : Long, b : Long, m : Long) : Long {    if (a == 0L)        return 0     if (a % 2 == 1L) {        val prev = binmult(a - 1, b, m)        return (prev + b) % m    } else {        val half = binmult(a / 2, b, m)        return (half + half) % m    }} fun binpow(a: Long, n: Long, mod: Long): Long {    var a = a    var n = n    var res: Long = 1    while (n > 0) {        if (n and 1 == 1L) {            res = binmult(res, a, mod)            res %= mod            n--        } else {            a = binmult(a, a, mod)            a %= mod            n = n shr 1        }    }    return res % mod} inline fun phi(n: Int): Int {    var n = n    var result = n    var i = 2    while (i * i <= n) {        if (n % i == 0) {            while (n % i == 0)                n /= i;            result -= result / i        }        ++i    }    if (n > 1)        result -= result / n    return result} var out = PrintWriter(System.out)var br = BufferedReader(InputStreamReader(System.`in`))var st = StringTokenizer("""") fun main(args: Array<String>) {    solve()    out.close()} inline fun readString(): String {    if (!st.hasMoreTokens())        st = StringTokenizer(br.readLine())    return st.nextToken()} inline fun readLine() = br.readLine()inline fun readInt() = readString().toInt()inline fun readLong() = readString().toLong()inline fun readDouble() = readString().toDouble()inline fun readBool() = readString().toBoolean()inline fun readFloat() = readString().toFloat() inline fun readInts() = readLine().split(' ').map(String::toInt).toIntArray()inline fun readLongs() = readLine().split(' ').map(String::toLong).toLongArray()","binary search,greedy"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.io.PrintWriter fun main( args: Array<String> ) {    val br = BufferedReader( InputStreamReader( System.`in` ) )    val out = PrintWriter( System.out )    val s = br.readLine()    val r = Array<String>( 3, { """" } )    run {        var period = 1        for ( i in 0 .. 2 ) {            val c = CharArray( s.length )            var cur = 0            var l = 'a'            loop@while ( true ) {                for ( j in 1 .. period ) {                    c[cur] = l                    cur ++                    if ( cur >= c.size ) break@loop                }                l ++                if ( l > 'z' ) l = 'a'            }            out.println( ""? ${String( c )}"" )            out.flush()            r[i] = br.readLine()            period *= 26        }    }     val letters = Array( 3, { Array( 26, { ArrayList<Int>() } ) } )    for ( i in 0 .. 2 ) {        for ( j in r[i].indices ) {            letters[i][( r[i][j] - 'a' ).toInt()].add( j )        }    }     val p = IntArray( s.length )    for ( i in s.indices ) {        val l3 = i / ( 26 * 26 )        val l2 = i / 26 % 26        val l1 = i % 26        var p1 = 0        var p2 = 0        var p3 = 0        var let1 = letters[0][l1]        var let2 = letters[1][l2]        var let3 = letters[2][l3]        if ( let1.size == 0 ) {            let1 = if ( let2.size > 0 ) let2 else let3        }        if ( let2.size == 0 ) {            let2 = if ( let1.size > 0 ) let1 else let3        }        if ( let3.size == 0 ) {            let3 = if ( let1.size > 0 ) let1 else let2        }        while ( true ) {            if ( let1[p1] == let2[p2] && let1[p1] == let3[p3] ) {                p[i] = let1[p1]                break            }            if ( let1[p1] <= let2[p2] && let1[p1] <= let3[p3] ) {                p1 ++                continue            }            if ( let2[p2] <= let1[p1] && let2[p2] <= let3[p3] ) {                p2 ++                continue            }            p3 ++        }    }     val res = CharArray( s.length )    for ( i in s.indices ) {        res[i] = s[p[i]]    }    out.println( ""! ${String(res)}"")    out.close()}","bitmasks,chinese remainder theorem,constructive algorithms,interactive,math"
"import java.lang.StringBuilder fun main(args: Array<String>) {    readLine()    val girlyanda = readLine()!!    val aga = setOf('R', 'G', 'B')    val builder = StringBuilder(girlyanda.length)    builder.append(girlyanda.first())    var r = 0    for (i in 1 until girlyanda.length) {        if (builder.last() != girlyanda[i]) {            builder.append(girlyanda[i])        } else {            val toAppend = aga.minus(arrayOf(builder.last(), if (i + 1 < girlyanda.length) girlyanda[i + 1] else builder.last())).first()            r++            builder.append(toAppend)        }    }    println(r)    println(builder.toString())}","constructive algorithms,dp,greedy"
"// https://codeforces.com/problemset/problem/1108/D fun main() {    readLine() // read input size    val colors = readLine()!!.toCharArray()    var i = 0    var numChanges = 0    while (i < colors.lastIndex) {        if (colors[i] == colors[i+1]) {            numChanges++            if (i + 2 >= colors.size) {                colors[i+1] = color(colors[i])            } else {                colors[i+1] = color(colors[i], colors[i+2])            }        }        i += 1    }    println(numChanges)    println(colors.joinToString(""""))} val rgb = listOf<Char>('R', 'G', 'B') private fun color(vararg except: Char): Char {    return rgb.minus(except.asList()).random()}","constructive algorithms,dp,greedy"
"import kotlin.math.min fun readInts(separator: Char = ' ') = readLine()?.split(separator)?.map(String::toInt)fun readLongs(separator: Char = ' ') = readLine()?.split(separator)?.map(String::toLong)   fun main() {    val colors = ""RGB""    var count = 0     val (n) = readInts()!!    val s = readLine()!!.toCharArray()    for(i in 1 until n){        if (s[i-1]==s[i]){            for(color in colors){                if (color != s[i-1] && (i+1==n || color != s[i+1])){                    s[i] = color                    count++                    break                }            }        }    }     println(count)    print(s.joinToString(separator = """"))}","constructive algorithms,dp,greedy"
"fun main() {    val n = readLine()!!.toInt()    val garland = readLine()!!.toCharArray()     val values = mutableListOf('R', 'G', 'B')     var sol = 0     for(i in 1 until n)        if(garland[i] == garland[i-1]) {            sol++            for(j in 0..2) {                if(i < n - 1) {                    if (values[j] != garland[i - 1] && values[j] != garland[i + 1]) {                        garland[i] = values[j]                        break                    }                } else {                    if (values[j] != garland[i - 1]) {                        garland[i] = values[j]                        break                    }                }            }        }     println(sol)    println(garland)}","constructive algorithms,dp,greedy"
"import kotlin.math.abs fun main(args: Array<String>) {    val n = readLine()?.toIntOrNull() ?: return    val rotations = IntArray(n) { readLine()?.toIntOrNull() ?: return }    var deg = 0     repeat(1 shl n) { i ->        repeat(n) { j ->            deg += if (i and (1 shl j) == 0) rotations[j] else -rotations[j]        }        if (abs(deg) % 360 == 0) return print(""YES"")        else deg = 0    }    println(""NO"")} 		  	 		 				     			     				","bitmasks,brute force,dp"
"fun main() {    //println((4 or 6)xor(4 or 5))    val r = System.`in`.bufferedReader()    val s = StringBuilder()    //val n = r.readLine()!!.toInt()    var v = mutableListOf<Int>(0)    repeat(r.readLine()!!.toInt()) {        val n = r.readLine()!!.toInt()        val newList = mutableListOf<Int>()        v.forEach {            newList += it+n            newList += it-n        }        v = newList    }    val ans = v.any { it%360==0 }    println(if (ans) ""YES"" else ""NO"")}","bitmasks,brute force,dp"
"import kotlin.math.* fun main(arg: Array<String>){	var N = readLine()!!.toInt()	val NN = N	val M = 2.0.pow(N.toDouble()).toInt()	val L = mutableListOf<Int>()	var S = 0	while(N > 0){		L.add(readLine()!!.toInt())		N--	}	L.forEach(){		S += it	}	for(i in 0..M-1){		val opts = i.toString(2).padStart(NN,'0')		//println(opts)		var Sum = 0		for (i in 1..opts.length){			if(opts[i-1] == '0'){				Sum -= L[i-1]			}else{				Sum += L[i-1]			}		}		if(Sum.rem(360) == 0){			//println(""OGON: $opts $Sum"")			println(""YES"")			return		} 	}	println(""NO"")}","bitmasks,brute force,dp"
"// https://codeforces.com/problemset/problem/1097/B fun main() {    val n = readLine()!!.toInt()    val rotations = (1..n).map { readLine()!!.toInt() }    val isPossible: Boolean = evalRotations(rotations)    val ans: String = if (isPossible) ""YES"" else ""NO""    println(ans)} fun evalRotations(rotations: List<Int>, index: Int = 0, sum: Int = 0): Boolean {    if (index == rotations.size) {        return sum % 360 == 0    }    if (evalRotations(rotations, index + 1, sum + rotations[index])) {        return true    } else {        return evalRotations(rotations, index + 1, sum - rotations[index])    }}","bitmasks,brute force,dp"
"fun main() {    val table = readLine()!!    val hand = readLine()!!    if (hand.contains(table[0]) || hand.contains(table[1])) print(""YES"") else print(""NO"")}","brute force,implementation"
"fun main() {    val table = readLine()!!    val hand = readLine()!!     val ans = if (hand.contains(table[0]) || hand.contains(table[1])) ""yes"" else ""no""    println(ans)}","brute force,implementation"
"fun main() {    val c = readLine()!!    val a = readLine()!!.split("" "")    if (a.map { it[0] }.contains(c[0]) || a.map { it[1] }.contains(c[1])) println(""yes"") else println(""no"")}","brute force,implementation"
"import java.lang.StringBuilder fun main() {     val hand = readLine()!!    val table = readLine()!!     print(if (table.contains(Regex(""[${hand[0]}${hand[1]}]""))) ""YES"" else ""NO"")}","brute force,implementation"
"data class Edge(val u: Int, val v: Int, val w: Long) fun main() {    var (n, m) = readLine()!!.split(' ').map { it.toInt() }    var a = readLine()!!.split(' ').map { it.toLong() }    var min_pos = a.indexOf(a.min())    var e = (Array(n) {        Edge(min_pos, it, a[min_pos] + a[it])    } + Array(m) {        val (u, v, w) = readLine()!!.split(' ').map { it.toLong() }        Edge(u.toInt() - 1, v.toInt() - 1, w)    }).sortedBy { it.w }    val fa = Array(n) { it }    var ans = 0L    fun find(x: Int): Int {        if (fa[x] == x) return x        fa[x] = find(fa[x])        return fa[x]    }    for ((u, v, w) in e) {        val fu = find(u)        val fv = find(v)        if (fu != fv)            ans += w        fa[fu] = fv    }    println(ans)}","dsu,graphs,greedy"
"data class Edge(val from: Int, val to: Int, val cost: Long) fun main() {	val (n, m) = readLine()!!.split("" "").map { it.toInt() }	val a = readLine()!!.split("" "").map { it.toLong() } 	var mindex = 0	for (i in 0 until n)		if (a[i] < a[mindex])			mindex = i	val edges = mutableListOf<Edge>();	repeat(m) {		val line = readLine()!!.split("" "")		val from = line[0].toInt()		val to = line[1].toInt()		val cost = line[2].toLong()		edges.add(Edge(from - 1, to - 1, cost))	} 	for (i in 0 until n)		edges.add(Edge(i, mindex, a[mindex] + a[i]));	edges.sortBy { it.cost }	val dj = DJS(n)	var ans = 0L	edges.forEach {		if (dj.join(it.from, it.to))			ans += it.cost	}	println(ans)} class DJS(n: Int) {	private var par: MutableList<Int> = MutableList<Int>(n) {-1}	fun find(i: Int): Int {		if (par[i] < 0) {			return i;		} else {			par[i] = find(par[i])			return par[i]		}	}	fun join(ii: Int, jj: Int): Boolean {		val i = find(ii)		val j = find(jj)		if (i == j)			return false		if (par[i] == par[j])			par[i]--		if (par[i] <= par[j])			par[j] = i		else			par[i] = j		return true	}}","dsu,graphs,greedy"
"const val MAXN = 200005const val INF : Long = (9e18).toLong() class DS (val N: Int) {    private val p = IntArray(N)    private val r = IntArray(N)    init {        for (i in p.indices) {p[i] = i; r[i] = 0;}    }        public fun find (x: Int) : Int {        if (p[x] == x) return x;        p[x] = find(p[x]);        return p[x];    }        public fun join (a: Int, b: Int) : Boolean {        var (x,y) = arrayOf(find(a),find(b));        if (x == y) return false;        if (r[x] > r[y]) y = x.also {x = y}        p[x] = y; if (r[x] == r[y]) r[y]++;        return true;    }} data class Edge(var u: Int, var v: Int, var w: Long) var edges = ArrayList<Edge>()var MST = DS(MAXN) fun main() {    val (n,m) = readLine()!!.split("" "").map {it.toInt();}    val arr = readLine()!!.split("" "").map {it.toLong();}    for (i in 0..m-1) {        val (u,v,w) = readLine()!!.split("" "").map {it.toLong();}        edges.add(Edge(u.toInt()-1,v.toInt()-1,w));    }        var mini : Long = INF; var ind = -1;    for (i in 0..n-1) if (arr[i] < mini) {mini = arr[i]; ind = i;}    for (i in 0..n-1) if (i != ind) edges.add(Edge(ind,i,arr[i]+arr[ind]));            edges.sortBy{it.w};            var r : Long = 0;    for (i in edges) if (MST.join(i.u,i.v)) r += i.w;        print(""$r"");}","dsu,graphs,greedy"
"private fun readLn() = readLine()!!private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }private fun readLongs() = readStrings().map { it.toLong() } data class Edge(val u: Int, val v: Int, val w: Long) fun main() {    val (n, m) = readInts()    val a = readLongs().toLongArray()    val edges = ArrayList<Edge>()    repeat(m) {        var (u, v, w) = readStrings()        edges.add(Edge(u.toInt(), v.toInt(), w.toLong()))    }    val pos = a.indexOf(a.min()!!)    for (i in 0 until n) {        if (i == pos) continue        edges.add(Edge(i + 1, pos + 1, a[i] + a[pos]))    }    edges.sortBy { it.w }    val d = DSU(n + 1)    var ans = 0L    for ((u, v, w) in edges) {        if (d.get(u) == d.get(v)) continue        d.unite(u, v)        ans += w    }    println(ans)} class DSU {    var p: IntArray     constructor(n: Int) {        p = IntArray(n)        for (i in 0 until n)            p[i] = i    }     fun get(x: Int): Int {        if (p[x] == x)            return x        p[x] = get(p[x])        return p[x]    }     fun unite(_x: Int, _y: Int) {        val x = get(_x)        val y = get(_y)        if ((0..1).random() == 1) {            p[x] = y        } else {            p[y] = x        }    }}","dsu,graphs,greedy"
"import java.util.* private fun readLn()=readLine()!!private fun readInt()=readLn().toInt()private fun readLong()=readLn().toLong()private fun readStrings()=readLn().split("" "").toMutableList()private fun readInts()=readStrings().map {it.toInt()}.toMutableList()private fun readLongs()=readStrings().map {it.toLong()}.toMutableList() fun main(){    var (n,m)=readInts()    var v=MutableList(n+1,{mutableListOf<Int>()})    for(i in 1..m)    {        var (a,b)=readInts()        v[a].add(b)        v[b].add(a)    }    var d=MutableList(n+1,{-1})    var p=MutableList(n+1,{-1})    var vis=MutableList(n+1,{false})    fun bfs(src:Int,clean:Boolean):Triple<Int,Int,Int> //last,mid,dist    {        var q=mutableListOf(src)        var idx=0        d[src]=1        p[src]=0        var r=src        while(idx<q.size)        {            r=q[idx++]            for(to in v[r])            {                if(d[to]==-1)                {                    d[to]=d[r]+1                    p[to]=r                    q.add(to)                }            }        }        var m=r        for(i in 1..d[r]/2) m=p[m]        var dist=d[r]        if(clean)        {            for(a in q)            {                d[a]=-1                p[a]=-1            }        }        return Triple(r,m,dist)    }    fun go(src:Int):Pair<Int,Int> //center,diameter    {        var t=bfs(src,true).first        var (a,m,diam)=bfs(t,false)        return Pair(m,diam)    }    var e=mutableListOf<Pair<Int,Int>>()    for(i in 1..n) if(d[i]==-1) e.add(go(i))    e.sortByDescending{it.second}    var diam=e[0].second    for(i in 1..e.size-1) diam=maxOf(diam,(diam+2)/2+(e[i].second+2)/2)    print(""${diam-1}\n"")    for(i in 1..e.size-1) print(""${e[0].first} ${e[i].first}\n"")}","constructive algorithms,dfs and similar,greedy,trees"
"import java.io.BufferedReaderimport java.io.Fileimport java.util.*import kotlin.system.measureTimeMillis fun solve(input: BufferedReader) {    val (n, m) = input.readLine().split("" "").map {it.toInt()}.toTypedArray()    val g = Array(n) {ArrayList<Int>()}    for (i in 0 until m) {        val s = input.readLine().split("" "")        val a = s[0].toInt() - 1        val b = s[1].toInt() - 1        g[a].add(b)        g[b].add(a)    }     val used = Array(n) {0}    val parent = Array(n) {-1}    fun dfs(v: Int, color: Int, p: Int = -1): Pair<Int, Int> {        if (used[v] != color)            return Pair(-1, -1)        used[v] = color + 1        parent[v] = p        var max = Pair(0, v)        for (x in g[v]) {            val tmp = dfs(x, color, v)            if (tmp.first > max.first)                max = tmp        }        return Pair(max.first + 1, max.second)    }    val paths = ArrayList<ArrayList<Int>>()    for (i in 0 until n)        if (used[i] == 0) {            val path = ArrayList<Int>()            var end = dfs(dfs(i, 0).second, 1).second            while (end != -1) {                path.add(end)                end = parent[end]            }            paths.add(path)        }    if (paths.size == 1) {        println(paths[0].size - 1)        return    }     paths.sortBy {-it.size}//    println(paths)    fun half(i: Int) = paths[i].size / 2 + 1    val x0 = half(0)    val x1 = half(1)    val x2 = if (paths.size > 2) half(2) else -1    println(maxOf(paths[0].size, x0 + x1, x1 + x2 + 1) - 1)    fun center(i: Int) = paths[i][paths[i].size / 2]    for (i in 1 until paths.size)        println(""${center(0) + 1} ${center(i) + 1}"")} fun main(args: Array<String>) {    System.err.println(""time = ${measureTimeMillis {        solve(System.`in`.bufferedReader())//        solve(File(""a.out"").`bufferedReader())    }}ms"")}","constructive algorithms,dfs and similar,greedy,trees"
"import kotlin.math.* fun main(args: Array<String>){	val t=readLine()!!.toInt()	repeat(t)	{		val k=readLine()!!.toInt()		var w=readLine()!!.split("" "").map{ it.toInt() }.toMutableList()		var acc=0		for(d in w)		{		    acc+=d;    		}		var kte=(k-1)/acc*7;		var Mn=1000000003;		for(l in 1..7)		{		    var jk=(k-1)%acc+1;		    var r=l;		    while(jk>0)		    {		        r+=1;		        jk-=w[r%7];		    }		    Mn=min(Mn,r-l);		}		println(kte+Mn);	}}",math
"import kotlin.math.* private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() } fun main() {  var tt = readInt()  while (tt-- > 0) {    val k = readInt()    var a = readInts()    var s = a.sum()     var result = 7 * ((k + s - 1) / s)    for (i in 0..6) {      var t = k      var days = 0      var j = i      while (t > 0 && j < 7) {        t -= a[j++]        ++days      }      if (t > s) {        val extra = (if (t % s == 0) 1 else 0)        days += (t / s - extra) * 7        t -= (t / s - extra) * s      }      j = 0      while (t > 0) {        t -= a[j++]        ++days      }       result = min(result, days)    }    println(result)  }}",math
"import java.io.BufferedReaderimport kotlin.system.measureTimeMillis fun solve(input: BufferedReader) {    var t = input.readLine()!!.toInt()    while (t-- > 0) {        val k = input.readLine()!!.toInt()        val a = input.readLine()!!.split("" "").map {it.toInt()}        val s = a.sum()        val rest = (k - 1) % s + 1        val alwaysNeed = (k - 1) / s * 7        var ans = Int.MAX_VALUE        for (i in 0 until 7) {            var days = alwaysNeed            var i1 = i            var rest1 = rest            while (rest1 > 0) {                days++                if (a[i1] == 1)                    rest1--                i1 = (i1 + 1) % 7            }            ans = minOf(ans, days)        }        println(ans)    }}fun main(args: Array<String>) {    System.err.println(""time = %dms"".format(measureTimeMillis {        solve(System.`in`.bufferedReader())//        solve(File(""a.out"").bufferedReader())    }))}",math
"import java.io.*import java.util.* class G {     fun tryStartWithDay(needStudy : Long, startDay : Int, schedule : List<Boolean>) : Long {        var remaining = needStudy        var currentWeekDay = startDay        var overallDays = 0L        while (remaining > 0 && currentWeekDay < 7) {            if (schedule[currentWeekDay]) {                remaining--            }            overallDays++            currentWeekDay++        }        if (remaining == 0L) {            return overallDays        }         val studyDaysInWeek = schedule.stream()                .filter { it }                .count()         val remainder = remaining % studyDaysInWeek        if (remainder == 0L) {            overallDays += 7 * (remaining / studyDaysInWeek - 1)            remaining = studyDaysInWeek        } else {            overallDays += 7 * (remaining / studyDaysInWeek)            remaining = remainder        }         return overallDays + tryStartWithDay(remaining, 0, schedule)//        if (remainder == 0L) {//            return overallDays + 7 * (remaining / studyDaysInWeek - 1) + tryStartWithDay(studyDaysInWeek, 0, schedule)//        } else {//            return overallDays + 7 * remaining / studyDaysInWeek + tryStartWithDay(remainder, 0, schedule)//        }         return 0    }     fun solve(k : Long, schedule : List<Boolean>) : Long {        return (0..6)                .map { tryStartWithDay(k, it, schedule) }                .min()!!    }     fun solve(input : InputStream, output : OutputStream) {        val reader = InputReader(BufferedInputStream(input))        val writer = PrintWriter(BufferedOutputStream(output))         val t = reader.nextInt()        for (test in 0 until t) {            val k = reader.nextLong()            val schedule = (0..6)                    .map { reader.nextInt() == 1 }            val result = solve(k, schedule)            writer.println(result)        }         writer.close()    }     private class InputReader(stream: InputStream) {        var reader: BufferedReader = BufferedReader(InputStreamReader(stream), 32768)        var tokenizer: StringTokenizer? = null         operator fun next(): String {            while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {                try {                    tokenizer = StringTokenizer(reader.readLine())                } catch (e: IOException) {                    throw RuntimeException(e)                }             }            return tokenizer!!.nextToken()        }         fun nextInt(): Int {            return Integer.parseInt(next())        }         fun nextLong(): Long {            return java.lang.Long.parseLong(next())        }    }} fun main(args : Array<String>) {    G().solve(System.`in`, System.out)}",math
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport java.lang.IndexOutOfBoundsExceptionimport kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        val S = fakein.toString()        println(""New Case "")        println(S.take(80))        println(""..."")        fakein.clear()        IN = BufferedInputStream(S.byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} val getint:Int get() = IO.nextInt()val getlong:Long get() = IO.nextLong()val getstr:String get() = IO.nextString()fun getline(n:Int):IntArray{    return IntArray(n){getint}}fun getlineL(n:Int):LongArray{    return LongArray(n){getlong}}fun getbinary(n:Int):BooleanArray{    val str = getstr    return BooleanArray(n){str[it] == '1'}} val List<Char>.ret:Stringget() = this.joinToString("""")infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    var str = """"    if(this is String){ str = this    }else if(this is Int){ str = this.toString()    }else if(this is Long){ str = this.toString()    }    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is Array<*>){        println(""$str : "")        for(c in a){if(c is IntArray){println(c.joinToString("" ""))}        else if(c is LongArray){println(c.joinToString("" ""))}        else if(c is BooleanArray){println(c.map { if(it) '1' else '0' }.joinToString(""""))        }         }        println()    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){    throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){        throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}const val withBruteForce = falseconst val randCount = 100object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    fun cases(onecase:()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint} else if(mode == solveMode.tc){1 } else randCount        //safety checks        if(pI != 998_244_353 && pI != 1_000_000_007){            throw Exception(""Modding a wrong prime!"")        }         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            currentAnswer = null            currentBruteAnswer = null            onecase()        }        if(withBruteForce){            put(""Checked ${answersChecked}"")        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    inline fun brute(a:()->Unit){        if(withBruteForce){            a()        }    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }      var currentAnswer:String? = null    var currentBruteAnswer:String? = null    fun answer(a:Any){        currentAnswer = a.toString()        if(currentBruteAnswer != null){            checkAnswer()        }    }    fun put2(a:Any){answer(a);put(a) }     fun bruteAnswer(a:Any){        currentBruteAnswer = a.toString()        if(currentAnswer != null){            checkAnswer()        }    }    fun checkAnswer(){        if(currentAnswer != currentBruteAnswer){            throw Exception(""Failed Test: BF $currentBruteAnswer Current $currentAnswer"")        }        answersChecked ++    }}// 1. Moddedconst val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}infix fun Int.modM(b:Int):Int{ return ((this * 1L * b) % pI).toInt() }infix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }// 2. DP initial valuesconst val plarge = 1_000_000_727const val nlarge = -plargeconst val phuge = 2_727_000_000_000_000_000Lconst val nhuge = -phuge// 3. conveniecen conversionsval Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionval Char.code :Int get() = this.toInt() -  'a'.toInt()//3. hard to write stufffun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val mint:MutableList<Int> get() = mutableListOf<Int>()val mong:MutableList<Long> get() = mutableListOf<Long>()//4. more outputsfun List<Char>.conca():String = this.joinToString("""")val CharArray.conca :String get() = this.joinToString("""")val IntArray.conca :String get() = this.joinToString("" "")@JvmName(""concaInt"")fun List<Int>.conca():String = this.joinToString("" "")val LongArray.conca:String get() = this.joinToString("" "")@JvmName(""concaLong"")fun List<Long>.conca():String = this.joinToString("" "")//5. Pair of intsfun makepair(a:Int, b:Int):Long = (a.toLong() shl 32) xor b.toLong()val Long.first get() = (this shr 32).toInt()val Long.second get() = this.toInt() class simpleSegTree (nSuggest  :Int){	//Items lenght must be a power of 2 	val n = (maxOf((nSuggest - 1).takeHighestOneBit(),2)) shl 1	val levels = (31 - n.countLeadingZeroBits()) // (Levels) amount of levels then a layer of leaf	val arr = IntArray(n * 2 + 1 )	val arrSize = n * 2 + 1 	constructor(withArray:IntArray):this(withArray.size){		for(i in withArray.indices){			arr[i+n] = withArray[i]		} 		updateAll()	} 	private fun updateNode(i:Int){		arr[i] = arr[i shl 1 ] + arr[(i shl 1) + 1]	}	private fun updatePath(i:Int){		// i is the endpoint, typically (n+i)		// bottom up, recalculate		var here = i		while(here > 1){			here = here shr 1			updateNode(here)		}	}	fun updateAll(){		for(i in n-1 downTo 1){			updateNode(i)		}	}	fun setValue(i:Int,value:Int){		arr[n+i] = value		updatePath(n+i)	}	fun addValue(i:Int, inc:Int){		arr[n+i] += inc		updatePath(n+i)	} 	val firstIndex = n	val lastIndex = (n shl 1 ) - 1	val indices = firstIndex..lastIndex  	fun primitiveIndex(a:Int) = a + n	inline fun segmentOrder(act:(here:Int, left:Int,right:Int)->Unit ){		//iterate over all segments bottom up, probably to rebuild tree		for(i in (n-1) downTo 1){			act(i, (i shl 1 ), (i shl 1) + 1)		}	}	inline fun primitiveOrder(act:(here:Int,primitiveIndex:Int)->Unit){		//iterate over all the leaf nodes		for(i in 0 until n){			act(i+n,i)		}	}  	fun query(l:Int,r:Int): Int {		var ret:Int = 0		var left = l + n		var right = r + n+1		while(left < right){			if(left and 1 != 0){				ret += arr[left]				left += 1			}			if(right and 1 != 0){				right -= 1				ret += arr[right]			}			left = left shr 1			right = right shr 1		}		return ret	}	inline fun segDivision(l:Int, r:Int, act:(index:Int,level:Int)->Unit){		var left = l + n		var right = r + n + 1		var level = 0		while(left < right){			if(left and 1 != 0){ 				act(left,level)				left += 1			}			if(right and 1 != 0){				right -= 1				act(right,level)			}			left = left shr 1			right = right shr 1			level ++		}	} 	fun queryFunctional(l:Int,r:Int):Int{		var ret = 0		segDivision(l,r){i, _ ->			ret += arr[i]		}		return ret	}	fun indexOf(req:Int):Int{		// -1 if not enough		val req = req + 1		if(req > arr[1]){			throw IndexOutOfBoundsException()		}else if(req <= 0 ){			return -1		}		var i = 1		var rightPoint = -1		var cur = 0		for(l in 1..levels){			i = i shl 1			if(cur + arr[i] < req){				rightPoint += 1 shl (levels - l)				cur += arr[i]				i += 1			}		}		return rightPoint +1	}  	val Int.leftNode:Int get(){		// assert(this <= n )		return this shl 1	}	val Int.rightNode:Int get(){		// assert(this <= n)		return (this shl 1) + 1	}	val Int.endpoints:Pair<Int,Int> get(){		val offSet = this - this.takeHighestOneBit()		val widthLevel = levels - (31 - this.countLeadingZeroBits())		return Pair(offSet shl widthLevel, (offSet shl widthLevel) + (1 shl widthLevel) - 1)	}  	//like set	fun contains(a:Int): Boolean {		return arr[a+n] == 1	}	fun add(a:Int){		if(!contains(a)){			addValue(a,1)		}	}	fun remove(a:Int){		if(contains(a)){			addValue(a,-1)		}	}	fun numberInRange(l:Int, r:Int):Int{		return query(l,r)	}	val size:Int get() = this.arr[1]	operator fun get(a:Int):Int{		return indexOf(a)	}	fun first():Int{		return get(0)	}	fun last():Int{		return get(size - 1)	}	fun safeFirst():Int{		return if(size == 0)  n+1 else first()	}	fun safeLast():Int{		return if(size == 0)  - 1 else last()	}} fun code(a:Char):Int{	return when(a){		'R' -> 0		'P' -> 1		'S' -> 2		else -> 727	}} fun Int.next():Int{	return (this + 1 ) % 3}fun Int.last():Int{	return when(this){		1 -> 0		2 -> 1		0 -> 2		else -> -1	}}val except:Array<IntArray> = arrayOf(intArrayOf(1,2), intArrayOf(0,2), intArrayOf(0,1))const val singleCase = truefun main(){    solve.cases{		val n = getint		val q = getint		val str = getstr 		val types = Array(3){simpleSegTree(n)}		val now = IntArray(n) 		for((i,v) in str.withIndex()){			val c = code(v)			types[c].add(i)			now[i] = c		}		fun calculate(){			val startColour = now[0]			val (a,b) = except[startColour]			if(except[startColour].all { types[it].size == 0 }){				put(n)				return			}			var ret =0			val realstart = minOf(types[a].safeFirst(), types[b].safeFirst()) 			val endColour = now[n-1]			val (a2,b2) = except[endColour]			val realend = maxOf(types[a2].safeLast(), types[b2].safeLast())			if(types[startColour.last()].size != 0 )				ret += realstart 			if(types[endColour.last()].size != 0 )				ret += (n - 1 - realend) 			for(i in 0 until 3){				val first = types[i].safeFirst()				val last = types[i].safeLast()				val next = (i+1) % 3				ret += types[next].numberInRange(maxOf(first,realstart), minOf(last,realend))			}			put(ret)		}		calculate()		repeat(q){			val i = getint -1			val c = code(getstr[0])			val was = now[i]			types[was].remove(i)			types[c].add(i)			now[i] = c			calculate()		}        }    done()}    ",
"fun main(){    val nk = readLine()!!.split("" "").map{it.toInt()}    val n = nk.first()    val k = nk.last()    var greaterDivisor = k-1    while (n%greaterDivisor!=0 && greaterDivisor>0) greaterDivisor--    println(n/greaterDivisor*k+greaterDivisor)}",math
"// modPart is the value of ""x % k"" that minimizes ""x""fun main() {    fun readLongs() = readLine()!!.split("" "").map(String::toLong)     val (n, k) = readLongs()    var modPart = k - 1    while (n % modPart != 0L) modPart--    print((n / modPart * k) + modPart)}",math
"import java.lang.Integer.min fun main(args: Array<String>) {//    var n = readLine()!!.toInt()//    var arr2 = readLine()!!.split("" "").map { x -> x.toInt() }    var arr = readLine()!!.split("" "").map { x -> x.toInt() }     var n = arr[0]    var k = arr[1]     var k2 = min(k-1, n)     var x = n/k2*k+k2//    x = 0    while ((x/k) * (x%k) != n) {        k2--        x = n/k2*k+k2    }    print(x) }",math
"fun main(args: Array<String>) {    val s = readLine()!!.split("" "").map { it.toInt() }     val l = mutableListOf<Int>()     val n = s[0]    val k = s[1]    var d = n    while (d >= 1) {        val dx = d * k        val mx = n / d        val x = dx + mx        if ((x / k) * (x % k) == n)            l.add(x)        if (d == 1) break        d -= 1    }     println(l.min())} fun findNextDiv(x: Int): Int {    if (x == 1) return 1    var d = 2    while (x % d != 0) d++    return d}",math
fun main(args: Array<String>) {    readLine()!!    val ar = readLine()!!.split(' ').map{it.toInt()}.toIntArray()    var c=0    for (i in ar.indices)        if (ar[i]==0 &&  i>0 && i<ar.lastIndex && ar[i-1]==1 && ar[i+1]==1) {  ar[i+1]=0; c++ }    println(c)},greedy
"fun main() {    readLine()    val lights = readLine()!!.split("" "").map { it == ""1"" }.toMutableList()     var k = 0    for (i in 1 until lights.size - 1) {        if (lights.disturbed(i)) {            lights[i + 1] = false            k++        }    }     println (k)} fun List<Boolean>.disturbed(i: Int) = this[i - 1] && !this[i] && this[i + 1]",greedy
fun main() {    readLine()!!    var list = readLine()!!.split(' ').map { it.toInt() }.toMutableList()    var count = 0    var i = 1    while (i<list.size-1){        if (list[i]==0){            if (list[i-1]==1 && list[i+1]==1){                count++                list[i+1] = 0                i++            }        }        i++    }     println(count)},greedy
"fun main() {    fun readInt() = readLine()!!.toInt()    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val numFlats = readInt()    val arr = readInts().toIntArray()    var sol = 0    for (pos in 1 until numFlats - 1) {        if (arr[pos] == 0 && arr[pos - 1] == 1 && arr[pos + 1] == 1) {            sol++            arr[pos + 1] = 0        }    }    print(sol)}",greedy
"import java.io.PrintWriterimport java.util.* fun PrintWriter.solve() {    val n = nextInt()    val adj = Array(n) { mutableListOf<Int>() }    for (i in 0 until n - 1) {        val v1 = nextInt() - 1        val v2 = nextInt() - 1        adj[v1].add(v2)        adj[v2].add(v1)    }    val q = nextInt()    val v = IntArray(q) { 0 }    val d = IntArray(q) { 0 }    val x = LongArray(q) { 0 }    val queries = mutableMapOf<Int, MutableList<Int>>()    for (i in 0 until q) {        v[i] = nextInt() - 1        d[i] = nextInt()        x[i] = nextLong()        if (!queries.containsKey(v[i])) {            queries[v[i]] = mutableListOf()        }        queries[v[i]]?.add(i)    }    val counter = LongArray(n) { 0 }    val diff = mutableMapOf<Int, Long>()    fun dfs(now: Int, par: Int, depth: Int, value: Long) {        var sum = 0L        for (i in queries[now] ?: mutableListOf()) {            sum += x[i]            diff[depth + d[i] + 1] = (diff[depth + d[i] + 1] ?: 0) - x[i]        }        counter[now] = value + sum + (diff[depth] ?: 0)        for (next in adj[now]) {            if (next != par) {                dfs(next, now, depth + 1, counter[now])            }        }        for (i in queries[now] ?: mutableListOf()) {            diff[depth + d[i] + 1] = (diff[depth + d[i] + 1] ?: 0) + x[i]        }    }    dfs(0, -1, 0, 0)    println(counter.joinToString("" ""))} fun main() {    val writer = PrintWriter(System.out, false)    writer.solve()    writer.flush()} // region Scannerprivate var st = StringTokenizer("""")private val br = System.`in`.bufferedReader() fun next(): String {    while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())    return st.nextToken()} fun nextInt() = next().toInt()fun nextLong() = next().toLong()fun nextLine() = br.readLine()!!fun nextDouble() = next().toDouble()// endregion","data structures,trees"
"import java.io.*import java.lang.Math.absimport java.util.*import kotlin.collections.HashSet fun solve(cin: FastReader, out: PrintWriter) {    val tc = cin.int()     repeat(tc) re@{        val n = cin.int()        val c = cin.double()        val t = cin.double()        val dp = Array<DoubleArray>(10 * n + 1) {DoubleArray(n + 1) {1e100}}        dp[0][0] = 0.0        val can = BooleanArray(10 * n + 1) {false}        can[0] = true        val pw = DoubleArray(n + 1)        pw[0] = 1.0        for (i in 1 until pw.size)            pw[i] = pw[i - 1] * 0.9         val ps = Array(n) { val a = cin.int(); val b = cin.int(); Pair(a, b)}         ps.sortWith(compareBy({it.first}, {it.second}))        ps.reverse()         val tm = IntArray(n) {ps[it].first}        val rev = IntArray(n) {ps[it].second}         for (i in 0 until n) {            for (sum in (0 until dp.size).reversed())                if (can[sum]) {                    for (j in 0..i)                        if (dp[sum][j] < 1e80) {                            dp[sum + rev[i]][j + 1] = Math.min(dp[sum + rev[i]][j + 1], dp[sum][j] + tm[i] / pw[j + 1])                            can[sum + rev[i]] = true                        }                }        }        for (i in (0..(10 * n)).reversed()) {            if (can[i])                for (j in 0..n)                    if (dp[i][j] < 1e80) {                        val lost = t - 10.0 * j                        if (lost <= 0)                            continue                        if (dp[i][j] <= lost) {                            out.println(i)                            return@re                        }                         /*val l = 0                        val r = lost                        repeat(100) {                            val m1 = l + (r - l) / 3.0                            val m2 = l + 2.0 * (r - l) / 3.0                             if ()                        }*/                        val sum = dp[i][j]                         val x = (c * lost - 1.0) / (2 * c)                         if (x < 0 || x >= lost)                            continue                         if ((1 + c * x) >= sum / (lost - x)) {                            out.println(i)                            return@re                        }                    }        }    }}   class FastReader(input: InputStream) {    private val br = BufferedReader(InputStreamReader(input))    private var st = StringTokenizer("""")     fun next(): String {        while (!st.hasMoreTokens())            st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun int(): Int {        return next().toInt()    }     fun double(): Double {        return next().toDouble()    }     fun long(): Long {        return next().toLong()    }     /**     * Warning! Use carefully!     */    fun nextLine(): String {        return br.readLine()    }} fun main(args: Array<String>) {    val cin = FastReader(System.`in`)    val out = PrintWriter(BufferedOutputStream(System.out))    /*val cin = Scanner(System.`in`)    val out = PrintWriter(System.out)*/    solve(cin, out)    out.flush()}","binary search,dp,math"
"import java.io.*import java.lang.Math.absimport java.util.*import kotlin.collections.HashSet fun solve(cin: FastReader, out: PrintWriter) {    val tc = cin.int()     repeat(tc) re@{        val n = cin.int()        val c = cin.double()        val t = cin.double()        val dp = Array<DoubleArray>(10 * n + 1) {DoubleArray(n + 1) {1e100}}        dp[0][0] = 0.0        val can = BooleanArray(10 * n + 1) {false}        can[0] = true        val pw = DoubleArray(n + 1)        pw[0] = 1.0        for (i in 1 until pw.size)            pw[i] = pw[i - 1] * 0.9         for (i in 0..1000000) {            val list = listOf(1, 2, 3, 4, 5)        }         val ps = Array(n) { val a = cin.int(); val b = cin.int(); Pair(a, b)}         ps.sortWith(compareBy({it.first}, {it.second}))        ps.reverse()         val tm = IntArray(n) {ps[it].first}        val rev = IntArray(n) {ps[it].second}         for (i in 0 until n) {            for (sum in (0 until dp.size).reversed())                if (can[sum]) {                    for (j in 0..i)                        if (dp[sum][j] < 1e80) {                            dp[sum + rev[i]][j + 1] = Math.min(dp[sum + rev[i]][j + 1], dp[sum][j] + tm[i] / pw[j + 1])                            can[sum + rev[i]] = true                        }                }        }        for (i in (0..(10 * n)).reversed()) {            if (can[i])                for (j in 0..n)                    if (dp[i][j] < 1e80) {                        val lost = t - 10.0 * j                        if (lost <= 0)                            continue                        if (dp[i][j] <= lost) {                            out.println(i)                            return@re                        }                         /*val l = 0                        val r = lost                        repeat(100) {                            val m1 = l + (r - l) / 3.0                            val m2 = l + 2.0 * (r - l) / 3.0                             if ()                        }*/                        val sum = dp[i][j]                         val x = (c * lost - 1.0) / (2 * c)                         if (x < 0 || x >= lost)                            continue                         if ((1 + c * x) >= sum / (lost - x)) {                            out.println(i)                            return@re                        }                    }        }    }}   class FastReader(input: InputStream) {    private val br = BufferedReader(InputStreamReader(input))    private var st = StringTokenizer("""")     fun next(): String {        while (!st.hasMoreTokens())            st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun int(): Int {        return next().toInt()    }     fun double(): Double {        return next().toDouble()    }     fun long(): Long {        return next().toLong()    }     /**     * Warning! Use carefully!     */    fun nextLine(): String {        return br.readLine()    }} fun main(args: Array<String>) {    val cin = FastReader(System.`in`)    val out = PrintWriter(BufferedOutputStream(System.out))    /*val cin = Scanner(System.`in`)    val out = PrintWriter(System.out)*/    solve(cin, out)    out.flush()}","binary search,dp,math"
"import java.io.*import java.lang.Math.absimport java.util.*import kotlin.collections.HashSet class cmpr() : kotlin.Comparator<Pair<Int, Int>> {    override fun compare(p1: Pair<Int, Int>?, p2: Pair<Int, Int>?): Int {        if (p1!!.first == p2!!.first && p1.second == p2.second)            return 0        return if (p1.first < p2.first || (p1.first == p2.first && p1.second > p2.second)) -1 else 1    }} fun solve(cin: FastReader, out: PrintWriter) {    val tc = cin.int()     repeat(tc) re@{        val n = cin.int()        val c = cin.double()        val t = cin.double()        val dp = Array<DoubleArray>(10 * n + 1) {DoubleArray(n + 1) {1e100}}        dp[0][0] = 0.0        val can = BooleanArray(10 * n + 1) {false}        can[0] = true        val pw = DoubleArray(n + 1)        pw[0] = 1.0        for (i in 1 until pw.size)            pw[i] = pw[i - 1] * 0.9         val ps = Array(n) { val a = cin.int(); val b = cin.int(); Pair(a, b)}         ps.sortWith(cmpr())        ps.reverse()         val tm = IntArray(n) {ps[it].first}        val rev = IntArray(n) {ps[it].second}         for (i in 0 until n) {            for (sum in (0 until dp.size).reversed())                if (true) {                    for (j in 0..i)                        if (dp[sum][j] < 1e80) {                            dp[sum + rev[i]][j + 1] = Math.min(dp[sum + rev[i]][j + 1], dp[sum][j] + tm[i] / pw[j + 1])                            can[sum + rev[i]] = true                        }                }        }        for (i in (0..(10 * n)).reversed()) {            if (true)            for (j in 0..n)                if (dp[i][j] < 1e80) {                    val lost = t - 10.0 * j                    if (lost <= 0)                        continue                    if (dp[i][j] <= lost) {                        out.println(i)                        return@re                    }                     /*val l = 0                    val r = lost                    repeat(100) {                        val m1 = l + (r - l) / 3.0                        val m2 = l + 2.0 * (r - l) / 3.0                         if ()                    }*/                    val sum = dp[i][j]                     val x = (c * lost - 1.0) / (2 * c)                     if (x < 0 || x >= lost)                        continue                     if ((1 + c * x) >= sum / (lost - x)) {                        out.println(i)                        return@re                    }                }        }    }}   class FastReader(input: InputStream) {    private val br = BufferedReader(InputStreamReader(input))    private var st = StringTokenizer("""")     fun next(): String {        while (!st.hasMoreTokens())            st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun int(): Int {        return next().toInt()    }     fun double(): Double {        return next().toDouble()    }     fun long(): Long {        return next().toLong()    }     /**     * Warning! Use carefully!     */    fun nextLine(): String {        return br.readLine()    }} fun main(args: Array<String>) {    val cin = FastReader(System.`in`)    val out = PrintWriter(BufferedOutputStream(System.out))    /*val cin = Scanner(System.`in`)    val out = PrintWriter(System.out)*/    solve(cin, out)    out.flush()}","binary search,dp,math"
"import java.io.*import java.lang.Math.absimport java.util.*import kotlin.collections.HashSet class cmpr() : kotlin.Comparator<Pair<Int, Int>> {    override fun compare(p1: Pair<Int, Int>?, p2: Pair<Int, Int>?): Int {        if (p1!!.first == p2!!.first && p1.second == p2.second)            return 0        return if (p1.first < p2.first || (p1.first == p2.first && p1.second > p2.second)) -1 else 1    }} fun solve(cin: FastReader, out: PrintWriter) {    val tc = cin.int()     repeat(tc) re@{        val n = cin.int()        val c = cin.double()        val t = cin.double()        val dp = Array<DoubleArray>(10 * n + 1) {DoubleArray(n + 1) {1e100}}        dp[0][0] = 0.0        val can = BooleanArray(10 * n + 1) {false}        can[0] = true        val pw = DoubleArray(n + 1)        pw[0] = 1.0        for (i in 1 until pw.size)            pw[i] = pw[i - 1] * 0.9         val ps = Array(n) { val a = cin.int(); val b = cin.int(); Pair(a, b)}         ps.sortWith(cmpr())        ps.reverse()         val tm = IntArray(n) {ps[it].first}        val rev = IntArray(n) {ps[it].second}         for (i in 0 until n) {            for (sum in (0 until dp.size).reversed())                if (can[sum]) {                    for (j in 0..i)                        if (dp[sum][j] < 1e80) {                            dp[sum + rev[i]][j + 1] = Math.min(dp[sum + rev[i]][j + 1], dp[sum][j] + tm[i] / pw[j + 1])                            can[sum + rev[i]] = true                        }                }        }        for (i in (0..(10 * n)).reversed()) {            if (can[i])            for (j in 0..n)                if (dp[i][j] < 1e80) {                    val lost = t - 10.0 * j                    if (lost <= 0)                        continue                    if (dp[i][j] <= lost) {                        out.println(i)                        return@re                    }                     /*val l = 0                    val r = lost                    repeat(100) {                        val m1 = l + (r - l) / 3.0                        val m2 = l + 2.0 * (r - l) / 3.0                         if ()                    }*/                    val sum = dp[i][j]                     val x = (c * lost - 1.0) / (2 * c)                     if (x < 0 || x >= lost)                        continue                     if ((1 + c * x) >= sum / (lost - x)) {                        out.println(i)                        return@re                    }                }        }    }}   class FastReader(input: InputStream) {    private val br = BufferedReader(InputStreamReader(input))    private var st = StringTokenizer("""")     fun next(): String {        while (!st.hasMoreTokens())            st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun int(): Int {        return next().toInt()    }     fun double(): Double {        return next().toDouble()    }     fun long(): Long {        return next().toLong()    }     /**     * Warning! Use carefully!     */    fun nextLine(): String {        return br.readLine()    }} fun main(args: Array<String>) {    val cin = FastReader(System.`in`)    val out = PrintWriter(BufferedOutputStream(System.out))    /*val cin = Scanner(System.`in`)    val out = PrintWriter(System.out)*/    solve(cin, out)    out.flush()} ","binary search,dp,math"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.io.PrintWriter val inf = BufferedReader(InputStreamReader(System.`in`))val ouf = PrintWriter(System.out) fun main(args: Array<String>) {    val n = inf.readLine()!!.toInt()    val w = Array(n) {        inf.readLine()!!    }    val ww = Array(n) {        inf.readLine()!!    }    var k = -1    var p1 = """"    var p2 = """"    var pl = """"    var pr = """"    for (i in w.indices) {        if (w[i] != ww[i]) {            var l = 0            while (w[i][l] == ww[i][l]) l++            var r = w[i].length - 1            while (w[i][r] == ww[i][r]) r--            if (k == -1) {                k = r - l + 1                p1 = w[i].substring(l, r + 1)                p2 = ww[i].substring(l, r + 1)                pl = w[i].substring(0, l)                pr = w[i].substring(r + 1)            }            if (k != r - l + 1 || p1 != w[i].substring(l, r + 1) || p2 != ww[i].substring(l, r + 1)) {                ouf.println(""NO"")                ouf.close()                return            }            for (j in l - 1 downTo -1) {                if (j == -1 || pl.length - (l - 1) + j - 1 < 0 || pl[pl.length - (l - 1) + j - 1] != w[i][j]) {                    pl = pl.substring(pl.length - (l - 1) + j)                    break                }            }            for (j in r + 1..w[i].length) {                if (j == w[i].length || j - (r + 1) >= pr.length || pr[j - (r + 1)] != w[i][j]) {                    pr = pr.substring(0, j - (r + 1))                    break                }            }        }    }    val p = pl + p1 + pr    val s = pl + p2 + pr    if (w.zip(ww).any {            val f = it.first.indexOf(p)            f != -1 && it.first[f + pl.length] == it.second[f + pl.length]        }) {        ouf.println(""NO"")    } else {        ouf.println(""YES"")        ouf.println(p)        ouf.println(s)     }    ouf.close()} fun prefix(t: String): IntArray {    val pr = IntArray(t.length)    pr[0] = -1    for (i in 1 until t.length) {        var j = pr[i - 1]        while (j >= 0 && t[j + 1] != t[i]) j = pr[j]        pr[i] = if (t[j + 1] == t[i]) j + 1 else j    }    return pr} fun String.indexOf(t: String, pr: IntArray = prefix(t)): Int {    val s = this    var j = -1    for (i in 0 until s.length) {        while (j >= 0 && t[j + 1] != s[i]) j = pr[j]        if (t[j + 1] == s[i]) j++        if (j == t.length - 1) {            return i - t.length + 1        }    }    return -1}","greedy,implementation,strings"
"import java.io.*import java.util.* fun gcd(a: Int, b: Int): Int {    if (a == 0)        return b    return gcd(b % a, a)} val p1: Long = 41val p2: Long = 37val mod1 = 1000000007val mod2 = 1000000009 fun solve(cin: FastReader, out: PrintWriter) {    var n = cin.nextInt()    var was = Array(n) { cin.nextLine() }    var new = Array(n) { cin.nextLine() }     var pos = IntArray(n) { 0 }    var lpos = IntArray(n) { 0 }     var fromm: String = """"    var too: String = """"     for (i in 0 until n) {        if (was[i] != new[i]) {            var fst = -1            var lst = -1            for (j in 0 until was[i].length)                if (was[i][j] != new[i][j]) {                    if (fst == -1)                        fst = j                    lst = j                }             pos[i] = fst            lpos[i] = lst             var from = was[i].substring(fst, lst + 1)             var to = new[i].substring(fst, lst + 1)            if (fromm.length != 0 && (from != fromm || too != to)) {                out.print(""NO"")                return            }            fromm = from            too = to        }    }     var initialized = false    var str = """"    for (i in 0 until n) {        if (was[i] != new[i]) {            if (!initialized) {                str = was[i].substring(0, pos[i])                initialized = true            } else {                val strr = was[i].substring(0, pos[i])                var fin = Math.min(str.length, strr.length)                for (j in 0 until Math.min(str.length, strr.length)) {                    if (str[str.length - 1 - j] != strr[strr.length - 1 - j]) {                        fin = j                        break                    }                }                str = str.substring(str.length - fin, str.length)            }        }    }     for (i in 0 until n)        pos[i] = pos[i] - str.length     fromm = str + fromm    too = str + too     initialized = false    str = """"    for (i in 0 until n) {        if (was[i] != new[i]) {            if (!initialized) {                str = was[i].substring(lpos[i] + 1, was[i].length)                initialized = true            } else {                val strr = was[i].substring(lpos[i] + 1, was[i].length)                var fin = Math.min(str.length, strr.length)                for (j in 0 until Math.min(str.length, strr.length)) {                    if (str[j] != strr[j]) {                        fin = j                        break                    }                }                str = str.substring(0, fin)            }        }    }     fromm = fromm + str    too = too + str     var h1from = 0    var h2from = 0    var pp1: Long = 1    var pp2: Long = 1     for (c in fromm) {        h1from = ((h1from * p1 + c.toInt() - 'a'.toInt()) % mod1).toInt()        h2from = ((h2from * p2 + c.toInt() - 'a'.toInt()) % mod2).toInt()        pp1 = ((pp1 * p1) % mod1)        pp2 = ((pp2 * p2) % mod2)    }      for (i in 0 until n) {        if (was[i] != new[i]) {             var h1 = 0            var h2 = 0             for (j in 0 until fromm.length) {                h1 = ((h1 * p1 + was[i][j].toInt() - 'a'.toInt()) % mod1).toInt()                h2 = ((h2 * p2 + was[i][j].toInt() - 'a'.toInt()) % mod2).toInt()            }             for (j in 0 until pos[i]) {                if (h1 == h1from && h2 == h2from) {                    if (was[i].substring(j, j + fromm.length) == fromm) {                        out.print(""NO"")                        return                    }                }                 if (j + fromm.length >= was[i].length)                    break                 h1 = ((h1 * p1 + was[i][j + fromm.length].toInt() - 'a'.toInt()) % mod1).toInt()                h2 = ((h2 * p2 + was[i][j + fromm.length].toInt() - 'a'.toInt()) % mod2).toInt()                h1 = ((h1 - pp1 * (was[i][j].toInt() - 'a'.toInt())) % mod1).toInt()                h2 = ((h2 - pp2 * (was[i][j].toInt() - 'a'.toInt())) % mod2).toInt()                 if (h1 < 0)                    h1 += mod1                if (h2 < 0)                    h2 += mod2            }        }         if (was[i] == new[i]) {             if (was[i].length < fromm.length)                continue             var h1 = 0            var h2 = 0             for (j in 0 until fromm.length) {                h1 = ((h1 * p1 + was[i][j].toInt() - 'a'.toInt()) % mod1).toInt()                h2 = ((h2 * p2 + was[i][j].toInt() - 'a'.toInt()) % mod2).toInt()            }             for (j in 0 until was[i].length) {                if (h1 == h1from && h2 == h2from) {                    if (was[i].substring(j, j + fromm.length) == fromm) {                        out.print(""NO"")                        return                    }                }                 if (j + fromm.length >= was[i].length)                    break                 h1 = ((h1 * p1 + was[i][j + fromm.length].toInt() - 'a'.toInt()) % mod1).toInt()                h2 = ((h2 * p2 + was[i][j + fromm.length].toInt() - 'a'.toInt()) % mod2).toInt()                h1 = ((h1 - pp1 * (was[i][j].toInt() - 'a'.toInt())) % mod1).toInt()                h2 = ((h2 - pp2 * (was[i][j].toInt() - 'a'.toInt())) % mod2).toInt()                 if (h1 < 0)                    h1 += mod1                if (h2 < 0)                    h2 += mod2            }        }    }      out.println(""YES"")    out.println(fromm)    out.println(too)}    class FastReader(input: InputStream) {    private val br = BufferedReader(InputStreamReader(input))    private var st = StringTokenizer("""")     fun next(): String {        while (!st.hasMoreTokens())            st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun nextInt(): Int {        return next().toInt()    }     fun nextDouble(): Double {        return next().toDouble()    }     fun nextLong(): Long {        return next().toLong()    }     /**     * Warning! Use carefully!     */    fun nextLine(): String {        return br.readLine()    }} fun main(args: Array<String>) {    val cin = FastReader(System.`in`)    val out = PrintWriter(BufferedOutputStream(System.out))    solve(cin, out)    out.close()}","greedy,implementation,strings"
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.random.Randomimport kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        val S = fakein.toString()        println(""New Case "")        println(S.take(80))        println(""..."")        fakein.clear()        IN = BufferedInputStream(S.byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} val getint:Int get() = IO.nextInt()val getlong:Long get() = IO.nextLong()val getstr:String get() = IO.nextString()fun getline(n:Int):IntArray{    return IntArray(n){getint}}fun getlineL(n:Int):LongArray{    return LongArray(n){getlong}}fun getbinary(n:Int):BooleanArray{    val str = getstr    return BooleanArray(n){str[it] == '1'}} val List<Char>.ret:Stringget() = this.joinToString("""")infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    var str = """"    if(this is String){ str = this    }else if(this is Int){ str = this.toString()    }else if(this is Long){ str = this.toString()    }    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is Array<*>){        println(""$str : "")        for(c in a){if(c is IntArray){println(c.joinToString("" ""))}        else if(c is LongArray){println(c.joinToString("" ""))}        else if(c is BooleanArray){println(c.map { if(it) '1' else '0' }.joinToString(""""))        }         }        println()    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){    throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){        throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}const val withBruteForce = falseconst val randCount = 100object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    fun cases(onecase:()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint} else if(mode == solveMode.tc){1 } else randCount        //safety checks        if(pI != 998_244_353 && pI != 1_000_000_007){            throw Exception(""Modding a wrong prime!"")        }         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            currentAnswer = null            currentBruteAnswer = null            onecase()        }        if(withBruteForce){            put(""Checked ${answersChecked}"")        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    inline fun brute(a:()->Unit){        if(withBruteForce){            a()        }    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }      var currentAnswer:String? = null    var currentBruteAnswer:String? = null    fun answer(a:Any){        currentAnswer = a.toString()        if(currentBruteAnswer != null){            checkAnswer()        }    }    fun put2(a:Any){answer(a);put(a) }     fun bruteAnswer(a:Any){        currentBruteAnswer = a.toString()        if(currentAnswer != null){            checkAnswer()        }    }    fun checkAnswer(){        if(currentAnswer != currentBruteAnswer){            throw Exception(""Failed Test: BF $currentBruteAnswer Current $currentAnswer"")        }        answersChecked ++    }}// 1. Moddedconst val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}infix fun Int.modM(b:Int):Int{ return ((this * 1L * b) % pI).toInt() }infix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }// 2. DP initial valuesconst val plarge = 1_000_000_727const val nlarge = -plargeconst val phuge = 2_727_000_000_000_000_000Lconst val nhuge = -phuge// 3. conveniecen conversionsval Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionval Char.code :Int get() = this.toInt() -  'a'.toInt()//3. hard to write stufffun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val mint:MutableList<Int> get() = mutableListOf<Int>()val mong:MutableList<Long> get() = mutableListOf<Long>()//4. more outputsfun List<Char>.conca():String = this.joinToString("""")val CharArray.conca :String get() = this.joinToString("""")val IntArray.conca :String get() = this.joinToString("" "")@JvmName(""concaInt"")fun List<Int>.conca():String = this.joinToString("" "")val LongArray.conca:String get() = this.joinToString("" "")@JvmName(""concaLong"")fun List<Long>.conca():String = this.joinToString("" "")//5. Pair of intsfun makepair(a:Int, b:Int):Long = (a.toLong() shl 32) xor b.toLong()val Long.first get() = (this shr 32).toInt()val Long.second get() = this.toInt()  fun search(text: String, pattern: String):IntArray{    val concat = ""$pattern$$text""    val l = concat.length    val Z = IntArray(l)     getZarr(concat, Z)     return Z.copyOfRange(pattern.length + 1 , Z.size)} fun calculateZarray(str:String): IntArray {    val ret = IntArray(str.length)     getZarr(str,ret)    return ret}// Fills Z array for given string str[]private fun getZarr(str: String, Z: IntArray) {    val n = str.length     var L = 0    var R = 0    for (i in 1 until n) {         if (i > R) {            R = i            L = R             while (R < n && str[R - L] == str[R]) R++            Z[i] = R - L            R--        } else {             val k = i - L             if (Z[k] < R - i + 1) Z[i] = Z[k] else {                  // else start from R and check manually                L = i                while (R < n && str[R - L] == str[R]) R++                Z[i] = R - L                R--            }        }    }}fun String.contains(other:String): Int? {    val search = ""$other#$this""    val A = calculateZarray(search)    return ((other.length + 1 until search.length).firstOrNull { A[it] >= other.length })?.minus(other.length + 1)} const val singleCase = truefun main(){    val chars = (0 until 26).map{('a'.toInt() + it ).toChar()}    solve.tc {        val a = List(3000){chars.random() }.conca()        val b = a.replaceRange(1500..1500,""b"")        share(3000)            repeat(3000){                share(a)            }            repeat(3000){                share(b)            }    }//    solve.usetc()    solve.cases{        val all = mutableListOf<String>()         val from = mutableListOf<String>()        val to = mutableListOf<String>()        val cannotchange = mutableListOf<String>()         val readn = getint        repeat(2 * readn){            all.add(getstr)        }        repeat(readn){            val start = all[it]            val end = all[it+readn]            if(start == end){                cannotchange.add(start)            }else{                from.add(start)                to.add(end)            }        }        val n = from.size        val firstDif = IntArray(n)        val lastDif = IntArray(n)         var startString:String? = null        var endString:String? = null        for(i in 0 until n) {            val from = from[i]            val to = to[i]            val a = from.indices.first { from[it] != to[it] }            val b = from.indices.last { from[it] != to[it] }            val needA = from.slice(a..b)            val needB = to.slice(a..b)             firstDif[i] = a            lastDif[i] = b             if(startString != null && (startString != needA || endString!! != needB)) {                put(""NO"")                return@cases            }            if(startString == null) {                startString = needA                endString = needB            }        }        fun agree(i:Int,right:Boolean):Boolean {            var schar:Char? = null            var echar:Char? = null            for(s in 0 until n){                val newi = if(right){                    lastDif[s] + i                }else                    firstDif[s] + i                if(newi !in from[s].indices){                    return false                }                val sc = from[s][newi]                val ec = to[s][newi]                if(schar != null && (sc != schar || ec != echar!!)){                    return false                }                if(schar == null){                    schar = sc                    echar = ec                }            }            return true        }        var lefteat = 0        var righteat = 0        while(agree(lefteat - 1,false)){            lefteat--        }        while(agree(righteat +1, true)){            righteat ++        }        val sp = firstDif[0] + lefteat        val ep = lastDif[0] + righteat        val retS = from[0].slice(sp..ep)        val retT = to[0].slice(sp..ep)          if((0 until n).any { from[it].contains(retS) != firstDif[it] + lefteat}){            put(""NO"")            return@cases        }        if(cannotchange.any { it.contains(retS) != null  }){            put(""NO"")            return@cases        }        put(""YES"")        put(retS)        put(retT)     }    done()}    /* bad boolean relations < mostly legacy spaghettis> legacy spaghetti  think about + or - overall */","greedy,implementation,strings"
"import kotlin.math.abs fun main(args: Array<String>) {    val xyzt1t2t3 = readLine()!!.split("" "").map{it.toInt()}    val (x,y,z) = xyzt1t2t3.subList(0, 3)    val (t1,t2,t3) = xyzt1t2t3.subList(3,6)    println(if (abs(x-y)*t1 < abs(x-z)*t2+3*t3+abs(x-y)*t2) ""NO"" else ""YES"")}",implementation
"import java.lang.Math.abs fun main(args: Array<String>) {    val temp = readLine()!!.split("" "").map { it.toInt() }    val (x, y, z, t1, t2) = temp    val t3 = temp[5]     if (3*t3 + (abs(x - y) + abs(x - z))*t2 <= abs(x - y) * t1) {        println(""YES"")    } else {        println(""NO"")    }}",implementation
"import kotlin.math.abs operator fun <T> List<T>.component6() = this[5] fun main(args: Array<String>) {    val (x, y, z, t1, t2, t3) = readLine()!!.split(' ').map(String::toInt)    val le = t1 * abs(x - y)    val li = t2 * abs(x - z) + 2 * t3 + t2 * abs(x - y) + t3    println(if (li <= le) ""YES"" else ""NO"")}",implementation
"import kotlin.math.abs fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readStrings() = readLn().split("" "")fun readInts() = readStrings().map { it.toInt() } fun main(args: Array<String>) {    var a = readInts()    var st = abs(a[0] - a[1]) * a[3]    var el = (abs(a[0] - a[1]) + abs(a[0] - a[2])) * a[4] + (3 * a[5])    if (el > st) print(""NO"") else print(""YES"")}",implementation
fun main(args: Array<String>) { 	var Xarr = readLine()!!.split(' ').map { it.toInt() }.toIntArray()	var answer = 0	for(i in 0 until Xarr[2]){	answer += 2*(Xarr[0] - 4*i + Xarr[1] - 4*i)-4	}	println(answer)},"implementation,math"
"fun main(args: Array<String>) {    var (w, h, k) = readLine()!!.split("" "").map {it -> it.toInt()}    var ans = 0    for (i in 1..k) {        ans += (w + h) * 2 - 4        w -= 4        h -= 4    }    println(ans)}","implementation,math"
"fun main(args: Array<String>) {    var (w, h, k) = readLine()!!.split(' ').map(String::toInt)    var sum = 0     for (i in 1..k)    {        sum += 2*w + 2*h - 4        w -= 4        h -= 4    }     print(sum)}","implementation,math"
import java.util.* fun main(args: Array<String>){    val s = Scanner(System.`in`)    val m = s.nextInt()    val n = s.nextInt()-2    val k = s.nextInt()-1    val mn = 2*m+2*n    var c = 0    for (i in 0..k) c+=mn-(16*(i))    print(c)},"implementation,math"
"import kotlin.math.sign fun main() {    val n = readLine()!!.toInt()    fun query(k: Int): Int {        println(""? $k"")        val a = readLine()!!.toInt()        println(""? ${k + (n / 2)}"")        val b = readLine()!!.toInt()        return a - b    }    val init = query(1)    if (init and 1 == 1) {        println(""! -1"")    } else if (init == 0) {        println(""! 1"")    } else {        var s = init.sign        var lower = 1        var upper = (n / 2) + 1        while (true) {            val mid = (lower + upper) / 2            val d = query(mid)            if (d == 0) {                println(""! $mid"")                return            } else if (d.sign == s) {                lower = mid + 1            } else {                upper = mid - 1            }        }    }}","binary search,interactive"
"import kotlin.math.* data class Res(val i: Int, val r: Int) {    override fun equals(other: Any?): Boolean = other is Res && other.r == r} fun ask(i: Int): Res {    println(""? $i"")    return Res(i, readLine()!!.toInt())} fun main(args: Array<String>) {    val n = readLine()!!.toInt()    val r = solveInt(n, ::ask)    println(""! $r"")} fun solveInt(n: Int, ask: (Int) -> Res): Int {    if (n % 4 != 0) return -1    var a = ask(1)    var b = ask(1 + n / 2)    if (a.r == b.r) return a.i    var da = a.r - b.r    var db = -da    while (true) {        val u = ask((a.i + b.i) / 2)        val v = ask(u.i + n / 2)        if (u.r == v.r) return u.i        val du = u.r - v.r        if (du < 0 && da > 0 || du > 0 && da < 0) {            b = u            db = du        } else {            a = u            da = du        }    }}","binary search,interactive"
"import java.util.Scanner fun main(args: Array<String>) {    val scanner = Scanner(System.`in`)    val n = scanner.nextInt()     if (n % 4 != 0) {        println(""! -1"")        return    }     val larger = BooleanArray(n / 2)        fun check(i: Int) {        println(""? ${i + 1}"")        System.out.flush()        val a = scanner.nextInt()        println(""? ${i + n / 2 + 1}"")        System.out.flush()        val b = scanner.nextInt()         if (a == b) {            println(""! ${i + 1}"")            throw RuntimeException()        }         larger[i] = a > b    }     var l = 0    var r = n / 2 - 1     try {        check(l)        check(r)        while (true) {            assert(r - l >= 2)            val m = (l + r) / 2            check(m)            if (larger[l] != larger[m])                r = m            else                l = m        }    } catch (e: RuntimeException) {        // do nothing    }}","binary search,interactive"
"import java.io.BufferedInputStreamimport java.util.* fun main(args: Array<String>) {    val scanner = Scanner(BufferedInputStream(System.`in`))     val n = scanner.nextInt() // even integer. the total number of students.    if (n % 4 != 0) {        println(""! -1"")        return    }     val a = Array<Int?>(n + 1) { null }    println(""? 1"")    a[1] = scanner.nextInt()    println(""? ${1 + n / 2}"")    a[1 + n / 2] = scanner.nextInt()    val b1 = a[1 + n / 2]!! - a[1]!!    if (b1 == 0) {        println(""! 1"")        return    }    if (b1 % 2 != 0) {        println(""! -1"")        return    }     var left = 2    var right = n / 2    val isLeftNegative = b1 < 0    while (left < right) {        val mid = left + (right - left) / 2        println(""? ${mid}"")        a[mid] = scanner.nextInt()        println(""? ${mid + n / 2}"")        a[mid + n / 2] = scanner.nextInt()        val bMid = a[mid + n / 2]!! - a[mid]!!         if (bMid == 0) {            println(""! ${mid}"")            return        }         if (bMid < 0) {            if (isLeftNegative) {                left = mid + 1            } else {                right = mid - 1            }        } else {            if (isLeftNegative) {                right = mid - 1            } else {                left = mid + 1            }        }    }    println(""! ${left}"")}","binary search,interactive"
"import java.io.BufferedReaderimport java.io.IOExceptionimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.* fun main(args: Array<String>) {    val inputStream = System.`in`    val inputReader = InputReader(inputStream)     val count = inputReader.nextInt()    val list = arrayOfNulls<Node>(count)     for (i in 0 until count) {        val type = inputReader.next()        val node = list[i] ?: Node(i)        node.type = type        list[i] = node         when (type) {            ""AND"", ""OR"", ""XOR"" -> {                val leftIndex = inputReader.nextInt() - 1                val rightIndex = inputReader.nextInt() - 1                 if (list[leftIndex] == null) {                    list[leftIndex] = Node(leftIndex)                }                node.left = list[leftIndex]                node.left?.parent = node                 if (list[rightIndex] == null) {                    list[rightIndex] = Node(rightIndex)                }                node.right = list[rightIndex]                node.right?.parent = node            }            ""NOT"" -> {                val leftIndex = inputReader.nextInt() - 1                 if (list[leftIndex] == null) {                    list[leftIndex] = Node(leftIndex)                }                node.left = list[leftIndex]                node.left?.parent = node            }            ""IN"" -> node.value = inputReader.nextInt()        }    }     val queue = LinkedList<Node>()    val stack = LinkedList<Node>()     val root = list[0]    if (root != null) {        stack.add(root)         while (stack.isNotEmpty()) {            val node = stack.removeLast()            queue.add(node)            val left = node.left            val right = node.right            if (left != null && left.type != ""IN"") {                stack.add(left)            }            if (right != null && right.type != ""IN"") {                stack.add(right)            }        }         while (queue.isNotEmpty()) {            val node = queue.removeLast()            when (node.type) {                ""AND"" -> add(node)                ""OR"" -> or(node)                ""XOR"" -> xor(node)                ""NOT"" -> not(node)            }        }         root.dp[0] = 0        root.dp[1] = 1         judge(root)    }     for (node in list) {        if (node != null && node.type == ""IN"") {            if (node.value == 0) {                print(node.dp[1])            } else {                print(node.dp[0])            }        }    }} fun judge(node: Node) {    val left = node.left    val right = node.right     when (node.type) {        ""AND"" -> {            if (left != null && right != null) {                left.dp[0] = node.dp[0]                left.dp[1] = node.dp[right.value]                right.dp[0] = node.dp[0]                right.dp[1] = node.dp[left.value]                judge(left)                judge(right)            }        }        ""OR"" -> {            if (left != null && right != null) {                left.dp[0] = node.dp[right.value]                left.dp[1] = node.dp[1]                right.dp[0] = node.dp[left.value]                right.dp[1] = node.dp[1]                judge(left)                judge(right)            }        }        ""XOR"" -> {            if (left != null && right != null) {                left.dp[0] = node.dp[right.value]                left.dp[1] = node.dp[if (right.value == 0) 1 else 0]                right.dp[0] = node.dp[left.value]                right.dp[1] = node.dp[if (left.value == 0) 1 else 0]                judge(left)                judge(right)            }        }        ""NOT"" -> {            if (left != null) {                left.dp[0] = node.dp[1]                left.dp[1] = node.dp[0]                judge(left)            }        }    }} fun add(node: Node) {    val left = node.left    val right = node.right     if (left != null && right != null) {        node.value = left.value and right.value    }} fun or(node: Node) {    val left = node.left    val right = node.right     if (left != null && right != null) {        node.value = left.value or right.value    }} fun xor(node: Node) {    val left = node.left    val right = node.right     if (left != null && right != null) {        node.value = left.value xor right.value    }} fun not(node: Node) {    val left = node.left     if (left != null) {        node.value = if (left.value == 0) 1 else 0    }} class Node(val index: Int) {    var type: String = """"     var parent: Node? = null    var left: Node? = null    var right: Node? = null     var value = 0    val dp = IntArray(2)} class InputReader(stream: InputStream) {    private var reader: BufferedReader = BufferedReader(InputStreamReader(stream))    private var tokenizer = StringTokenizer("""")     /** get next word  */    @Throws(IOException::class)    operator fun next(): String {        while (!tokenizer.hasMoreTokens()) {            tokenizer = StringTokenizer(                reader.readLine()            )        }        return tokenizer.nextToken()    }     fun nextLong() = next().toLong()    fun nextInt() = next().toInt()    fun nextDouble() = next().toDouble()    fun nextFloat() = next().toFloat()}	    	    		  		  	   		  					","dfs and similar,graphs,implementation,trees"
"import java.io.BufferedReaderimport java.io.IOExceptionimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.* fun main(args: Array<String>) {    val inputStream = System.`in`    val inputReader = InputReader(inputStream)     val count = inputReader.nextInt()    val list = arrayOfNulls<Node>(count)     for (i in 0 until count) {        val type = inputReader.next()        val node = list[i] ?: Node(i)        node.type = type        list[i] = node         when (type) {            ""AND"", ""OR"", ""XOR"" -> {                val leftIndex = inputReader.nextInt() - 1                val rightIndex = inputReader.nextInt() - 1                 if (list[leftIndex] == null) {                    list[leftIndex] = Node(leftIndex)                }                node.left = list[leftIndex]                node.left?.parent = node                 if (list[rightIndex] == null) {                    list[rightIndex] = Node(rightIndex)                }                node.right = list[rightIndex]                node.right?.parent = node            }            ""NOT"" -> {                val leftIndex = inputReader.nextInt() - 1                 if (list[leftIndex] == null) {                    list[leftIndex] = Node(leftIndex)                }                node.left = list[leftIndex]                node.left?.parent = node            }            ""IN"" -> node.value = inputReader.nextInt()        }    }     val queue = LinkedList<Node>()    val stack = LinkedList<Node>()     val root = list[0]    if (root != null) {        stack.add(root)         while (stack.isNotEmpty()) {            val node = stack.removeLast()            queue.add(node)            val left = node.left            val right = node.right            if (left != null && left.type != ""IN"") {                stack.add(left)            }            if (right != null && right.type != ""IN"") {                stack.add(right)            }        }         while (queue.isNotEmpty()) {            val node = queue.removeLast()            when (node.type) {                ""AND"" -> add(node)                ""OR"" -> or(node)                ""XOR"" -> xor(node)                ""NOT"" -> not(node)            }        }         root.dp[0] = 0        root.dp[1] = 1         judge(root)    }     for (node in list) {        if (node != null && node.type == ""IN"") {            if (node.value == 0) {                print(node.dp[1])            } else {                print(node.dp[0])            }        }    }} fun judge(node: Node) {    val left = node.left    val right = node.right     when (node.type) {        ""AND"" -> {            if (left != null && right != null) {                left.dp[0] = node.dp[0]                left.dp[1] = node.dp[right.value]                right.dp[0] = node.dp[0]                right.dp[1] = node.dp[left.value]                judge(left)                judge(right)            }        }        ""OR"" -> {            if (left != null && right != null) {                left.dp[0] = node.dp[right.value]                left.dp[1] = node.dp[1]                right.dp[0] = node.dp[left.value]                right.dp[1] = node.dp[1]                judge(left)                judge(right)            }        }        ""XOR"" -> {            if (left != null && right != null) {                left.dp[0] = node.dp[right.value]                left.dp[1] = node.dp[if (right.value == 0) 1 else 0]                right.dp[0] = node.dp[left.value]                right.dp[1] = node.dp[if (left.value == 0) 1 else 0]                judge(left)                judge(right)            }        }        ""NOT"" -> {            if (left != null) {                left.dp[0] = node.dp[1]                left.dp[1] = node.dp[0]                judge(left)            }        }    }} fun add(node: Node) {    val left = node.left    val right = node.right     if (left != null && right != null) {        node.value = left.value and right.value    }} fun or(node: Node) {    val left = node.left    val right = node.right     if (left != null && right != null) {        node.value = left.value or right.value    }} fun xor(node: Node) {    val left = node.left    val right = node.right     if (left != null && right != null) {        node.value = left.value xor right.value    }} fun not(node: Node) {    val left = node.left     if (left != null) {        node.value = if (left.value == 0) 1 else 0    }} class Node(val index: Int) {    var type: String = """"     var parent: Node? = null    var left: Node? = null    var right: Node? = null     var value = 0    val dp = IntArray(2)} class InputReader(stream: InputStream) {    private var reader: BufferedReader = BufferedReader(InputStreamReader(stream))    private var tokenizer = StringTokenizer("""")     /** get next word  */    @Throws(IOException::class)    operator fun next(): String {        while (!tokenizer.hasMoreTokens()) {            tokenizer = StringTokenizer(                reader.readLine()            )        }        return tokenizer.nextToken()    }     fun nextLong() = next().toLong()    fun nextInt() = next().toInt()    fun nextDouble() = next().toDouble()    fun nextFloat() = next().toFloat()}","dfs and similar,graphs,implementation,trees"
"fun main() {    val n = readInt()    val m = readInt()     val a = readInts()    val b = readInts()    if (a.any { it == 1 } || b.any { it == 1 }) {        println(-1)        return    }     var z = (0).toDouble()    var y: Double    for (i in n - 1 downTo 0) {        val landing = b[(i + 1) % n]        y = (z * landing + m)/(landing - 1)        z = (y * a[i] + m)/(a[i] - 1)    }    println(z)} // Input Readerprivate fun readLn() = readLine()!! private fun readStrings() = readLn().trim().split("" "")private fun readInt() = readLn().toInt()private fun readInts() = readStrings().map { it.toInt() }","binary search,math"
"import java.util.* fun main(args: Array<String>) {     val sc = Scanner(System.`in`)     var n = sc.nextLine().toInt()    var mass = sc.nextLine().toInt()     var l1 = sc.nextLine().split("" "")    var l2 = sc.nextLine().split("" "")     if(l1[0].toInt() == 1 || l2[0].toInt() == 1) {        print(-1)        return    }     var m:Double = mass(l2[0].toInt(),mass.toDouble())     for( i in 0 until n-1){        if(l1[n-i-1].toInt() == 1 || l2[n-i-1].toInt() == 1) {            print(-1)            return        }        m = mass(l1[n-i-1].toInt(),m)        m = mass(l2[n-i-1].toInt(),m)    }      m = mass(l1[0].toInt(),m)    print(m-mass) } fun mass( a:Int, m:Double) : Double {   return (a * m) / (a - 1)}","binary search,math"
import java.io.BufferedInputStreamimport java.util.* fun main(args: Array<String>) {    val scanner = Scanner(BufferedInputStream(System.`in`))     val n = scanner.nextInt()    val m = scanner.nextInt()     val a = IntArray(n)    repeat(n) {        a[it] = scanner.nextInt()    }    val b = IntArray(n)    repeat(n) {        b[it] = scanner.nextInt()    }    val fuelArray = List(n * 2) {        when {            it == n * 2 - 1 -> b[0]            it % 2 == 0 -> a[it / 2]            else -> b[it / 2 + 1]        }    }     var remaining = m.toDouble()    for (i in (n * 2 - 1) downTo 0) {        val weightPerTon = fuelArray[i]        val extra = remaining / (weightPerTon - 1)        if (weightPerTon <= 1) {            println(-1)            return        }        remaining += extra    }    println(remaining - m)},"binary search,math"
"import java.util.*  fun main(args: Array<String>) {    val sc = Scanner(System.`in`)    val planets = sc.nextInt()    val cargoWeight = sc.nextInt()    val oilCnsTakeoff = LongArray(planets, {sc.nextLong()})    val oilCnsLanding = LongArray(planets, {sc.nextLong()})     val lim = oilCnsTakeoff.reduce({a, b -> a + b}) + oilCnsLanding.reduce({a, b -> a + b})     fun go(fuel: Double) : Double {        var weight: Double = fuel + cargoWeight        for (i in 1 until planets) {            val f = weight / oilCnsTakeoff[i - 1]            weight -= f            if (weight < 0)                return -1.0            val f2 = weight / oilCnsLanding[i]            weight -= f2            if (weight < 0)                return -1.0        }        val f = weight / oilCnsTakeoff[planets - 1]        weight -= f        val f2 = weight / oilCnsLanding[0]        weight -= f2        return weight - cargoWeight    }     var f = 1.0    var t = 100000000000000.0    for (i in 1..10000) {        val m = (t + f) / 2         val mm = go(m)         if (-0.000001 < mm && mm < 0.000001) {            println(m)            return        }         when {            mm > 0 -> t = m            mm < 0 -> f = m            else -> {                println(m)                return            }        }    }     println(-1)       return}","binary search,math"
"fun main(args: Array<String>) {  val (N, K) = readLine()!!.split("" "").map{ it.toInt() }  val A = (""0 "" + readLine()!!).split("" "").map{ it.toLong() }  val S = run {    var i = 0    generateSequence(A[0], { A[++i] + it }).take(N+1).toList()  }   var ans = 0L  for(bit in 60 downTo 0) {    val cand = ans or (1L shl bit)     val tb = List(K+1) { BooleanArray(N+1) { false } }    tb[0][0] = true    for(k in 1..K) for(i in 1..N) {      tb[k][i] = (0 until i).any{ j -> (S[i] - S[j]) and cand == cand && tb[k-1][j] }    }     if(tb[K][N]) {      ans = cand    }  }   println(ans)}","bitmasks,dp,greedy"
"import java.io.*import java.util.*import kotlin.math.*//semi-tfun main(){	val f = BufferedReader(InputStreamReader(System.`in`)) 	val (n,m) = f.readLine().split("" "").map{it.toInt()}	val array = f.readLine().split("" "").map{it.toLong()} 	fun check(pcheck : Long) : Boolean{		val dp = Array(n){BooleanArray(m+1)} 		//initial		var sum = 0L		for(k in 0 until n){			sum += array[k]			if(pcheck and sum >= pcheck){				dp[k][1] = true			}		} 		for(k in 0 until n-1){			for(j in 0 until m){				if(!dp[k][j]) continue				sum = 0L				for(h in k+1 until n){					sum += array[h]					if(pcheck and sum >= pcheck){						dp[h][j+1] = true					}				}			}		} 		return dp[n-1][m] 	} 	var answer : Long = 0L	for(i in 60 downTo 0){		val pcheck : Long = answer + (1L shl i) 		//check if it is possible		if(check(pcheck)){			answer += (1L shl i)		}	} 	println(answer)   }","bitmasks,dp,greedy"
"import java.io.*import java.util.*import kotlin.math.*//semi-tfun main(){	val f = BufferedReader(InputStreamReader(System.`in`)) 	val (n,m) = f.readLine().split("" "").map{it.toInt()}	val array = f.readLine().split("" "").map{it.toLong()} 	fun check(pcheck : Long) : Boolean{		val dp = Array(n){BooleanArray(m+1){false}} 		//initial		var sum = 0L		for(k in 0 until n){			sum += array[k]			if(pcheck and sum >= pcheck){				dp[k][1] = true			}		} 		for(k in 0 until n-1){			for(j in 0 until m){				if(!dp[k][j]) continue				sum = 0L				for(h in k+1 until n){					sum += array[h]					if(pcheck and sum >= pcheck){						dp[h][j+1] = true					}				}			}		} 		return dp[n-1][m] 	} 	var answer : Long = 0L	for(i in 60 downTo 0){		val pcheck : Long = answer + (1L shl i) 		//check if it is possible		if(check(pcheck)){			answer += (1L shl i)		}	} 	println(answer)   }","bitmasks,dp,greedy"
"import java.io.*import java.lang.StringBuilderimport java.util.*import kotlin.math.* class InputReader(stream: InputStream) {    var reader: BufferedReader = BufferedReader(InputStreamReader(stream))    var tokenizer = StringTokenizer("""")    /** get next word  */    @Throws(IOException::class)    operator fun next(): String {        while (!tokenizer.hasMoreTokens()) {            //TODO add check for eof if necessary            tokenizer = StringTokenizer(                    reader.readLine()            )        }        return tokenizer.nextToken()    }    fun nextLong() = next().toLong()    fun nextInt() = next().toInt()    fun nextDouble() = next().toDouble()    fun nextFloat() = next().toFloat()} fun check(n: Int, K: Int, ret: Long, pre: LongArray): Boolean {    val f = Array(n + 5) {        IntArray(n + 5)    }    for (i in 1 .. n) {        f[i].fill(0)    }    f[0][0] = 1    for (j in 1 .. K) {        for (i in 1 .. n) {            for (k in 1 .. i) {                f[i][j] = f[i][j] or (f[k - 1][j - 1] and if (((pre[i] - pre[k - 1]) and ret) >= ret) 1 else 0)            }        }    }    return (f[n][K] >= 1)} fun main(args: Array<String>) {    val cin = InputReader(System.`in`)    val cout = PrintWriter(System.out)    val n = cin.nextInt()    val k = cin.nextInt()    val pre = LongArray(n + 10)    for (i in 1 .. n) {        pre[i] = cin.nextLong()        pre[i] += pre[i - 1]    }    var ans = 0L    for (i in 60 downTo 0) {        if (check(n, k, ans + 1L.shl(i), pre)) {            ans += 1L.shl(i)        }    }    cout.println(ans)    cout.flush()}	 				 	 		 			   									 	 	","bitmasks,dp,greedy"
"fun main(args: Array<String>) {    readLine()    val keys=readLine()?.trim()?.split(Regex(""[^x]+""))?.map {if (it.length<2) {0} else{it.length- 2} }?.sum()!!    println(keys)}","greedy,strings"
"fun main() {    var n = readLine()!!.toInt()    var str = readLine()!!    var count = 0    for (i in 0..n-3) if (str.substring(i,i+3) == ""xxx"") count++    print(count)}","greedy,strings"
"fun main(){    readLine()!!.toInt()    var str = readLine()!!;    var qty = 0;    while(str.contains(""xxx"")){        qty++        str = str.replaceFirst(""xxx"",""xx"")    }    println(qty)}","greedy,strings"
"fun main() {  var n: Int = readLine()!!.toInt();  var s: String = readLine()!!;  var answer = 0;  for (i in 0 until n - 2) {    if (s.substring(i, i + 3) == ""xxx"") answer++;  }  println(answer);}","greedy,strings"
"fun main() {    var (n, k) = readLine()!!.split(' ').map { it.toInt() }    repeat(k) {        if (n % 10 == 0) n/=10 else n--    }    println(n)}",implementation
fun main(a:Array<String>)=with(java.util.Scanner(System.`in`)){fun Int.s()=if(this%10==0)this/10 else this-1var n=nextInt();repeat(nextInt()){n=n.s()};println(n)},implementation
"fun main(args: Array<String>) {    var (n, k) = readLine()!!.split(' ').map{it.toInt()}    for (i in 1..k) n = if (n % 10 == 0) n / 10 else n - 1    println(n)}",implementation
"fun main(args: Array<String>) {	var (n, k) = readLine()!!.split(' ').map(String::toInt)	for (i in 1..k)	{		if (n%10 == 0) n /= 10 else n--	}	println(n)}",implementation
" fun main(args: Array<String>) {    val (k, n, s, p) = readLine()!!.split("" "").map { a -> a.toDouble() }    println(Math.ceil(Math.ceil(n / s) * k / p).toLong()) }",math
"fun main(args: Array<String>) {    val (k, n, s, p) = readLine()!!.split(' ').map { it.toLong() }     val sheets = (n + if (n % s == 0L) 0 else s) / s    println((k * sheets + if ((k * sheets) % p == 0L) 0 else p ) / p)}",math
"import kotlin.math.*fun main(args: Array<String>){	val (k, n, s, p) = readLine().toString().split("" "").map{it.toInt()}	val sheetspp = ceil(n.toFloat()/s.toFloat())	//val sol = ((n * k)/s)/p	println(ceil(k.toFloat() * sheetspp/p.toFloat()).toInt())}",math
"fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val (numPeople, numPlanesEach, numPlanesPerSheet, numSheetsPerPack) = readInts()    val sheetsPerPerson = numPlanesEach / numPlanesPerSheet + if (numPlanesEach % numPlanesPerSheet == 0) 0 else 1    val totalSheets = sheetsPerPerson * numPeople    print(totalSheets / numSheetsPerPack  + if (totalSheets % numSheetsPerPack == 0) 0 else 1)}",math
"fun main() {    val line = readLine()!!    val six = line.indexOf(' ')    val r = line.substring(0, six).toInt()    val b = line.substring(six + 1).toInt()    println(if (r == b) ""YES"" else ""NO"")}","brute force,geometry,greedy,math"
"import java.util.*import kotlin.math.* fun ceildiv(a: Int, b: Int) = a / b + if (a % b != 0) 1 else 0 fun main(args : Array<String>) {    Scanner(System.`in`.buffered()).use {        val hh = it.nextInt()        val mm = it.nextInt()        val h = it.nextInt()        val d = it.nextInt()        val c = it.nextInt()        val n = it.nextInt()                var ans: Double = (ceildiv(h, n) * c).toDouble()                val dawnTime = max(0, 19 * 60 - ((hh - 1) * 60 + mm))        ans = min(ans, ceildiv(h + dawnTime * d, n) * c * 0.8)                println(String.format(""%.10f"", ans))    }}","greedy,math"
"import kotlin.math.maximport kotlin.math.min fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val (hours, minutes) = readInts()    val (hunger, hungerPerMinute, cost, decreaseHunger) = readInts()    val now = (hunger / decreaseHunger + if(hunger % decreaseHunger == 0) 0 else 1) * cost    var minutesToEight = max(0, 20 * 60 - (hours * 60 + minutes))    if (minutesToEight < 0) minutesToEight += 24 * 60    val hungerAtEight = hunger + minutesToEight * hungerPerMinute    val later = (hungerAtEight / decreaseHunger + if(hungerAtEight % decreaseHunger == 0) 0 else 1) * 0.8 * cost    print(min(now.toDouble(), later))}","greedy,math"
"import kotlin.math.*fun main(arg: Array<String>){	val (hours, mins)  = readLine().toString().split("" "").map {x -> x.toInt()}	val (H, delta, cost, N)  = readLine().toString().split("" "").map {x -> x.toDouble()}	val currMins = hours * 60 + mins	val deltaMins = 1200 - currMins	if (deltaMins <= 0){		println(buyNow(H, cost * 0.8, N))	}else{		val resSale = buyNow(H + (deltaMins * delta), cost * 0.8, N)		val resNow = buyNow(H, cost, N)		val res = if(resSale < resNow) resSale else resNow		println(res)	}} fun buyNow(H: Double, cost: Double, N: Double): Double{	val bulkiDef: Double = H / N	var bulki: Int = if (abs(bulkiDef - bulkiDef.toInt()) > 0.00001) ceil(bulkiDef).toInt() else bulkiDef.toInt()	return (bulki * cost).toDouble()}","greedy,math"
"import java.util.* fun main(args: Array<String>) {    val s = readLine()!!.split("" "").map { it.toInt() }    val hh = s[0] // 19    val mm = s[1] // 05    val t = readLine()!!.split("" "").map { it.toInt() }    var catHunger = t[0]    val catHungerInc = t[1]    val cost = t[2]    val decreaseHunger = t[3]      var price = if (hh < 20) {        var bunNeeded = catHunger / decreaseHunger        if (catHunger % decreaseHunger != 0) bunNeeded++        (cost * bunNeeded).toDouble()    } else {        var bunNeeded = catHunger / decreaseHunger        if (catHunger % decreaseHunger != 0) bunNeeded++        (cost * bunNeeded) * 0.8    }        if (hh < 20) {        val minsToDiscount = (20 * 60) - (hh * 60) - mm        catHunger += (catHungerInc * minsToDiscount)        var bunNeeded = catHunger / decreaseHunger        if (catHunger % decreaseHunger != 0) bunNeeded++        val discountPrice = (cost * bunNeeded) * 0.8        if (discountPrice < price) {            price = discountPrice        }    }        println(String.format(""%.4f"", price))} 			  		   		  		  	  		  	 	","greedy,math"
"import kotlin.math.*import java.util.*import java.math.* fun main(args : Array<String>) = with(Scanner(System.`in`)) {	var n = nextInt()	var cnt1 = 0	var cnt2 = 0	for (i in 1..n){		var s = next()		var t = next()		if(t == ""soft"") cnt1++		else cnt2++	}	if(cnt1 > cnt2){		cnt1 = cnt2.also{			cnt2 = cnt1		}	}	for(i in 1..100){		if((i * i) / 2 >= cnt1 && (i*i+1) / 2 >= cnt2){			println(i)			return		}	}}",
"import kotlin.math.*import java.util.*import java.math.* fun main(args : Array<String>) = with(Scanner(System.`in`)) {	println(""Even"")}  	   					 		      			   		 				   	 	  ",probabilities
"import kotlin.random.Random fun main() {    val attempt = 1    println(if(Random.nextBoolean()) ""red"" else ""black"")}  fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readDouble() = readLn().toDouble()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readStringSeq() = readLn().splitToSequence(' ')fun readInts() = readStrings().map { it.toInt() }fun readIntSeq() = readStringSeq().map { it.toInt() }fun readDoubles() = readStrings().map { it.toDouble() }fun readDoubleSeq() = readStringSeq().map { it.toDouble() }fun readLongs() = readStrings().map { it.toLong() }fun readLongSeq() = readStringSeq().map { it.toLong() } class Output {    val outputSb = StringBuilder()    fun print(o: Any?) { outputSb.append(o) }    fun println() { outputSb.append('\n') }    fun println(o: Any?) { outputSb.append(o).append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(outputSb) }}inline fun output(block: Output.()->Unit) { Output().apply(block).nowPrint() }		    	 				 	 				    				 		 		       ",probabilities
"import java.io.BufferedReaderimport java.io.IOExceptionimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.* fun main(args : Array<String>) {    Thread { run() }.start()}val sc = Scanner(System.`in`)fun run() {  var t = sc.nextInt()  while(t-- > 0){    var x = sc.nextInt()    var ok = false    for(i in 1 until 31700){      var o = x + i * i      var o1 = Math.sqrt(o.toDouble()).toInt()      var o2 = o1 / i      if((o1 * o1 != o) or (o1 / o2 != i))        continue      ok = true      println(""${o1} ${o2}"")      break    }    if(!ok)      println(-1)  }} class Scanner(s: InputStream) {    var st: StringTokenizer? = null    var br: BufferedReader = BufferedReader(InputStreamReader(s))    @Throws(IOException::class)    operator fun next(): String {        while (st == null || !st!!.hasMoreTokens())            st = StringTokenizer(br.readLine())        return st!!.nextToken()    }    @Throws(IOException::class)    fun nextInt(): Int {        return Integer.parseInt(next())    }    @Throws(IOException::class)    fun nextLong(): Long {        return java.lang.Long.parseLong(next())    }    @Throws(IOException::class)    fun nextLine(): String {        return br.readLine()    }    @Throws(IOException::class)    fun nextDouble(): Double {        return java.lang.Double.parseDouble(next())    }    @Throws(IOException::class)    fun ready(): Boolean {        return br.ready()    }}fun IntArray.print() {    println(Arrays.toString(this))}fun Array<IntArray>.print() {    for (i in this)        i.print()}fun LongArray.print() {    println(Arrays.toString(this))}fun Array<LongArray>.print() {    for (i in this)        i.print()}fun BooleanArray.print() {    println(Arrays.toString(this))}fun nod(a: Long, b: Long): Long {    var a1 = a    var b1 = b    while (a1 != 0L && b1 != 0L) {        if (a1 < b1)            b1 %= a1        else            a1 %= b1    }    return a1 + b1}fun nok(a: Long, b: Long): Long = a * b / nod(a, b)","binary search,brute force,constructive algorithms"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.lang.AssertionErrorimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.minimport kotlin.math.sqrt val MOD = 1_000_000_007 fun divisors(x: Long): MutableList<Long> {  val res = mutableListOf<Long>()  val post = mutableListOf<Long>()  var d = 1L  while (d * d <= x) {    if (x % d == 0L) {      res += d      if (d * d != x) post += x / d    }    ++d  }  for (i in post.size - 1 downTo 0) {    res += post[i]  }  return res} /** * a, bがマイナスでもうまいこと動く */private inline fun floor_div(a: Long, b: Long): Long {  val sign = java.lang.Long.signum(b)  val x = a*sign  val y = b*sign  return if (x > 0) x/y else -((-x+y-1)/y)} private inline fun ceil_div(a: Long, b: Long): Long {  val sign = java.lang.Long.signum(b)  val x = a*sign  val y = b*sign  return if (x > 0) (x+y-1)/y else x/y} /** * x < a/b を満たす整数xの最大 */private inline fun div_lt(a: Long, b: Long) = ceil_div(a, b) - 1 /** * x <= a/b を満たす整数xの最大 */private inline fun div_le(a: Long, b: Long) = floor_div(a, b) /** * x > a/b を満たす整数xの最小 */private inline fun div_gt(a: Long, b: Long) = floor_div(a, b) + 1 /** * x >= a/b を満たす整数xの最小 */private inline fun div_ge(a: Long, b: Long) = ceil_div(a, b) class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  private val reader = BufferedReader(InputStreamReader(stream), 32768)   fun solve() {    for (t in 0 until ni()) {      val X = nl()      if (X == 0L) {        out.println(""1 1"")        continue      }      var ok = false      for (a in divisors(X)) {        val b = X/a        if ((a + b) % 2 != 0L) continue        val n = (a + b)/2        val zeros = n*n-X        if (zeros <= 0) continue         val c = sqrt(zeros.toDouble()).toLong()        if (c*c != zeros) continue         // n/(c+1) < m <= n/c        val l = div_gt(n, c + 1)        val r = div_le(n, c)        debug{""$l:$r c:$c""}        if (l > r) continue         out.println(""$n $l"")        ok = true        break      }      if (!ok) out.println(-1)    }  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return IntArray(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   /**   * コーナーケースでエラー出たりするので、debug(dp[1])のように添え字付きの場合はdebug{}をつかうこと   */  private inline fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: BooleanArray) {    debug { toString(a) }  }   private inline fun toString(a: BooleanArray) = run{a.map { if (it) 1 else 0 }.joinToString("""")}   private inline fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<BooleanArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }   private inline fun assert(b: Boolean) = run{if (!b) throw AssertionError()}  private inline fun assert(b: Boolean, f: () -> String) = run{if (!b) throw AssertionError(f())}} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","binary search,brute force,constructive algorithms"
"fun main(args: Array<String>) {    val n = readLine()!!    val a = readLine()!!.split("" "").map(String::toInt)    val e = (a.filter { it % 2 == 0 }.size)    val o = (a.filter { it % 2 == 1 }.size)    val x = 0    if (o <= e) {	println(o)	return    }    println(e + (o-e)/3)}",
"fun main(args: Array<String>) {    val n = readLine()!!.toInt()    val a = readLine()!!.split("" "").map(String::toInt)    val even = a.filter { it % 2 == 0 }.size    val odd = a.filter { it % 2 != 0}.size    if (even >= odd) {        println(odd)    } else {        println(even + (odd - even) / 3)    }}",
"fun main(args: Array<String>) {    val n = readLine()!!.toInt()    val arr = readLine()!!.split("" "").map { it.toInt() }     val cnt0 = arr.filter{it % 2 == 0}.count()    val cnt1 = arr.count() - cnt0     if (cnt0 >= cnt1) {        println(cnt1)    } else {        println(cnt0 + (cnt1 - cnt0) / 3)    }}",
"fun main(args: Array<String>) {    val n = readLine()!!.toInt()    val a = readLine()!!.split("" "").map(String::toInt)    val even = a.filter { it % 2 == 0 }.size    val odd = a.filter { it % 2 != 0}.size    if (even >= odd) {        println(odd)    } else {        println(even + (odd - even) / 3)    }}",
fun main() {    val n = readLine()!!.toInt()    var i = 0    var x = 0    while(i < n){        x++        if (isSum10(x)) i++    }    println(x)} fun isSum10(x: Int): Boolean{    var t = x    var sum = 0    while(t > 0) {        sum += t%10        t /= 10    }    return sum == 10},"binary search,brute force,dp,implementation,number theory"
fun main(args: Array<String>) {    fun z (a:Int) :Int {        var b = a        var c = 0        while (b > 0) {            c+=b%10            b/=10        }        return c    }     val a = generateSequence (1){it+1}.filter { z(it)==10}.take(10000).toList().toIntArray()    println(a[readLine()!!.toInt()-1])},"binary search,brute force,dp,implementation,number theory"
import java.util.* fun main() {    val sc = Scanner(System.`in`)     var k = sc.nextInt()     var num = 19    k--    while (k != 0) {        num += 9        if (isSumOfNumsEquals10(num)) k--    }     println(num)} fun isSumOfNumsEquals10(num: Int): Boolean {    val sum = num.toString().toList().map { it.toString().toInt() }.sum()    return sum == 10},"binary search,brute force,dp,implementation,number theory"
"import java.io.* fun main() {    val br = BufferedReader(InputStreamReader(System.`in`))    val bw = BufferedWriter(OutputStreamWriter(System.out))     val pn = mutableListOf<Int>()    var i = 0     while (true) {         if (pn.size > 10000) break         if (i.toString().sumBy { it - '0' } == 10) pn.add(i)         i++     }     bw.write(""${pn[br.readLine().toInt() - 1]}"")     bw.flush()    bw.close()}","binary search,brute force,dp,implementation,number theory"
"import java.util.* fun main(args: Array<String>) = with(Scanner(System.`in`)) {    val res = IntArray(3, { nextInt() }).sortedArray().meetsConditions()    print(res)} fun IntArray.meetsConditions(): String {    return when {        this[0] == 1 -> ""YES""        this[0] == 2 && this[1] == 2 -> ""YES""        this[0] == 2 && this[1] == 4 && this[2] == 4 -> ""YES""        this[0] == 3 && this[2] == 3 -> ""YES""        else -> ""NO""    }} ","brute force,constructive algorithms"
"import java.util.* fun main(args: Array<String>): Unit = with(Scanner(System.`in`)) {    val array: Array<Int> = arrayOf(nextInt(), nextInt(), nextInt())    array.sort()    when {        (array[0] == 1).toInt() + (array[1] == 1).toInt() + (array[2] == 1).toInt() >= 1 -> println(""YES"")        (array[0] == 2).toInt() + (array[1] == 2).toInt() + (array[2] == 2).toInt() >= 2 -> println(""YES"")        (array[0] == 3).toInt() + (array[1] == 3).toInt() + (array[2] == 3).toInt() == 3 -> println(""YES"")        array[0] ==  2 && array[1] == 4 && array[2] == 4 -> println(""YES"")        else -> println(""NO"")     }} fun Boolean.toInt() = if (this) 1 else 0","brute force,constructive algorithms"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.* fun ix(chara: Char): Int {    return when (chara) {        in 'a'..'z' -> chara - 'a'        in '0'..'9' -> chara - '0' + 26        else -> chara - 'A' + 36    }} fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val line = jin.readLine().split("" "")    val n = line[0].toInt()    val m = line[1].toInt()    val s = jin.readLine()    val treeSets = Array(62) { TreeSet<Int>() }    for (j in 1..n) {        treeSets[ix(s[j - 1])].add(j)    }    val bit = BinaryIndexTree(1, n)    for (j in 1..n) {        bit.update(j, 1)    }    fun findPos(x: Int): Int {        var upper = n        var lower = 1        while (upper > lower) {            val mid = (upper + lower) / 2            if (bit[1, mid] >= x) {                upper = mid            } else {                lower = mid + 1            }        }        return upper    }    for (j in 1..m) {        val line = jin.readLine().split("" "")        val l = line[0].toInt()        val r = line[1].toInt()        val k = ix(line[2][0])        val a = findPos(l)        val b = findPos(r)        var ceil = treeSets[k].ceiling(a)        while (ceil != null && ceil <= b) {            treeSets[k].remove(ceil)            bit.update(ceil, -1)            ceil = treeSets[k].ceiling(a)        }    }    val out = StringBuilder()    for (j in 1..n) {        if (bit[j, j] == 1) {            out.append(s[j - 1])        }    }    println(out)} class BinaryIndexTree(val treeFrom: Int, treeTo: Int) {    val value = IntArray(treeTo - treeFrom + 2)     fun update(index: Int, delta: Int) {        var i = index + 1 - treeFrom        while (i < value.size) {            value[i] += delta            i += i and -i        }    }     fun query(to: Int): Int {        var res = 0        var i = to + 1 - treeFrom        while (i > 0) {            res += value[i]            i -= i and -i        }        return res    }     operator fun get(from: Int, to: Int) = if (to < from) 0 else query(to) - query(from - 1)}","data structures,strings"
"fun main() {    val (k, p) = readLine()!!.split("" "").map(String::toLong)    var result = 0L    for (i in 1..k) {        result += (i.toString() + i.toString().reversed()).toLong()        result %= p    }    print(result)}",brute force
"fun main() {    val n = readLine()!!.toInt()    var spectator = 3    for (j in 1..n) {        var winner = readLine()!!.toInt()        if (winner == spectator) {            println(""NO"")            return        }        spectator = 6 - spectator - winner    }    println(""YES"")}",implementation
"fun main() {    fun readInt() = readLine()!!.toInt()     val numGames = readInt()    val playing = booleanArrayOf(true, true, false)    repeat(numGames) {        val winner = readInt() - 1        if (!playing[winner]) return print(""NO"")        for (player in 0..2)            if (player != winner)                playing[player] = !playing[player]    }    print(""YES"")}",implementation
"import java.util.* fun main(args: Array<String>) = with(Scanner(System.`in`)) {    val n = nextInt()    var (p1, p2, s1) = arrayOf(1, 2, 3)    var ok = true    for(i in 0 until n) {        val x = nextInt()        if(x == s1)            ok = false        else if(x == p1) {            val aux = p2            p2 = s1            s1 = aux        } else if(x == p2) {            val aux = p1            p1 = s1            s1 = aux        }    }    if(ok == true) println(""YES"")    else println(""NO"")}",implementation
"val sb = StringBuilder()val r = System.`in`.bufferedReader()private fun readInt() = r.readLine().toInt()private fun readLong() = r.readLine().toLong()private fun readInts() = r.readLine().split("" "").map { it.toInt() }private fun readLongs() = r.readLine().split("" "").map { it.toLong() } fun main() {    var ok = true    var set = mutableSetOf(1, 2)    repeat(readInt()) {        val n = readInt()        if (n !in set) ok = false        val add = when {            1 !in set -> 1            2 !in set -> 2            else -> 3        }        set = mutableSetOf(n, add)    }    sb.appendln(if ( ok) ""YES"" else ""NO"")    print(sb)} ",implementation
"fun main() {    val r = System.`in`.bufferedReader()    val sb = StringBuilder()    val (n, m) = r.readLine().split("" "").map { it.toLong()}    val v = r.readLine().split("" "").map { it.toInt() }    var pow = v[0]    var cnt = 0L    for (i in 1 until n.toInt()){        if (pow>v[i]){            cnt++            if (cnt==m){                break            }        }else{            pow = v[i]            cnt=1        }    }    sb.appendln(pow)    print(sb)}","data structures,implementation"
"import kotlin.math.max fun main() {    val (numPlayers, requiredWins) = readLine()!!.split("" "").map(String::toLong)    val powers = readLine()!!.split("" "").map(String::toInt)    var numWins = 1L    var winnerPower = max(powers[0], powers[1])    var pos = 2 % numPlayers.toInt()    while (numWins < requiredWins) {        if (winnerPower == powers[pos])            break        if (winnerPower > powers[pos])            numWins++        else {            winnerPower = powers[pos]            numWins = 1L        }        pos = (pos + 1) % numPlayers.toInt()    }    print(winnerPower)}","data structures,implementation"
"var _debug = false;fun <T> debug(vararg vals: T): Unit {    if (!_debug) { return }    for (v in vals) { System.err.print(v); System.err.print("" "") }    System.err.println()} fun main(args: Array<String>) {    if (args.size > 0 && args[0] == ""-d"") {        _debug = true;    }     val (num_ppl, num_wins) = readLine()!!.split(' ').map(String::toLong)    val powers = readLine()!!.split(' ').map(String::toLong) // distinct     var cnt = 0L    var prev = 0L    for ((i,p) in powers.withIndex()) {        if (i == 0) { prev = p; continue }         if (prev > p) {            cnt += 1        } else {            cnt = 1            prev = p        }         if (cnt >= num_wins) {            break        }    }    println(prev)}","data structures,implementation"
"import java.lang.Integer.maximport java.lang.Integer.minimport java.util.*import kotlin.math.min fun main(args: Array<String>) {    val cin = Scanner(System.`in`)    val n = cin.nextInt()    val k = cin.nextLong()    val a = ArrayList<Int>(n + 10)    for (i in 1 .. n) {        a.add(cin.nextInt())    }    val take = IntArray(n + 10)    var tot = 0    while (true) {        if (tot >= min(5000L, k)) break        if (a[0] > a[1]) {            val tmp = a[1]            a.removeAt(1)            a.add(tmp)            take[a[0]] ++            tot = take[a[0]]        } else {            val tmp = a[0]            a.removeAt(0)            a.add(tmp)            take[a[0]] ++            tot = take[a[0]]        }    }    System.out.println(a[0])} fun ff() {    val tmp = PriorityQueue<Int>()}    	 		  		 	 	 			 		    	 		","data structures,implementation"
"fun main() {    val (a, b, f, k) = readLine()!!.split("" "").map { it.toInt() }    var x = 0    var y = b    var ans = 0    if (b < f || b < a - f) {        print(-1)        return    }    repeat(k - 1) {        when {            k > 2 && x == a && 2 * f > b -> {                print(-1)                return            }            k > 1 && x == 0 && 2 * (a - f) > b -> {                print(-1)                return            }            x == 0 && a + a - f > y -> {                x = a                y = b - (x - f)                ans++            }            x == 0 -> {                x = a                y -= a            }            x == a && a + f > y -> {                x = 0                y = b - f                ans++            }            x == a -> {                x = 0                y -= a            }        }    }    if (y < a) ans++    print(ans)}","greedy,implementation,math"
import java.util.* fun main() {     val scanner = Scanner(System.`in`)     val destPoint = scanner.nextInt()    val maxLitersCount = scanner.nextInt()    val stationCoordinate = scanner.nextInt()    val ridesCount = scanner.nextInt()     var ans = 0     var currentFuel = maxLitersCount    var distanceToRide: Int     if (maxLitersCount < stationCoordinate) {        println(-1)        return    } else {        currentFuel -= stationCoordinate    }     for (currentRideNumber in 0 until ridesCount) {        distanceToRide = if (currentRideNumber.rem(2) == 0) {            destPoint - stationCoordinate        } else {            stationCoordinate        }        if (currentRideNumber < ridesCount - 1) {            distanceToRide *= 2        }        if (maxLitersCount < distanceToRide) {            println(-1)            return        } else if (currentFuel < distanceToRide) {            ans++            currentFuel = maxLitersCount        }         currentFuel -= distanceToRide    }     println(ans)  },"greedy,implementation,math"
import kotlin.system.exitProcess fun main(){    var s = readLine()!!.split(' ').map{it.toInt()}    var a = s[0]    var b = s[1]    var f = s[2]    var k = s[3]    var g = b    var ans = 0    for(i in 1..k){        if(i % 2 == 1){            if(g < f){                print(-1)                exitProcess(0)            }            g -= f            if(g < a - f){                ans += 1                g = b            }            if(g < a - f){                print(-1)                exitProcess(0)            }            if(i == k)break            if(g < 2 * (a - f)){                ans += 1                g = b            }            g -= a - f        }        else{            if(g < a - f){                print(-1)                exitProcess(0)            }            g -= a - f            if(g < f){                ans += 1                g = b            }            if(g < f){                print(-1)                exitProcess(0)            }            if(i == k)break            if(g < 2 * f){                ans += 1                g = b            }            g -= f        }    }    print(ans)},"greedy,implementation,math"
"import kotlin.math.min val sc = java.util.Scanner(System.`in`) data class Interval(val L: Int, val R: Int) : Comparable<Interval> {	override fun compareTo(other: Interval): Int {		return compareValuesBy(this, other, Interval::L, Interval::R)	}} fun main(args: Array<String>) {	val n = sc.nextInt()	val a = Array(n) { sc.nextInt() }	var cnt = 0	for (i in 0 until n)		if (a[i] == 0)			cnt++	var ans = cnt	for (i in 0 until n) {		when (a[i]) {			0 -> cnt--			1 -> cnt++		}		ans = min(ans, cnt)	}	println(n - ans)}","brute force,implementation"
"fun main(args: Array<String>) {    readLine()    val data = readLine()!!.split("" "").map { it.toInt() }    val res = solveA(data)    println(res)} fun solveA(data: List<Int>): Int {    val zeros = data.takeWhile { it == 0 }.size    val ones = data.takeLastWhile { it == 1 }.size    val middle = data.size - zeros - ones    val maxMiddleCount = if (middle == 0) 0 else (0 until middle).map {        var i = 0        var sum = 0        var countZeroes = i != it        while (i < middle) {            val isZero = data[i + zeros] == 0            if (isZero == countZeroes) {                sum++            }            if (sum == it) {                countZeroes = false            }            i++        }        sum    }.max()!!    return zeros + ones + maxMiddleCount} ","brute force,implementation"
"import java.lang.AssertionErrorimport java.util.* private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readLong() = readLn().toLong() // single longprivate fun readDouble() = readLn().toDouble() // single doubleprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of intsprivate fun readLongs() = readStrings().map { it.toLong() } // list of longsprivate fun readDoubles() = readStrings().map { it.toDouble() } // list of doubles private fun myAssert(x: Boolean) {    if (!x) {        throw AssertionError()    }} fun main(args: Array<String>) {  var n = readInt()  var lst = readInts()  var one = 0  var zero = 0  for (i in 0 until n) {    if (lst[i] == 1) {      one = maxOf(one + 1, zero + 1)    } else {      zero++    }  }  println(maxOf(one, zero))}","brute force,implementation"
"import java.io.*import java.util.*  fun solve() {    val n = nextInt()    val a = nextArray(n)    var cnt = a.count { it == 1 }    var s = 0    var z = 0    var ans = Math.max(cnt,n - cnt)    for(i in a.indices) {        if(a[i] == 0) {            s++            ans = Math.max(ans,s + cnt - z)        }        else z++    }    pw.println(ans)} fun hasNext() : Boolean {        while (!st.hasMoreTokens())            st = StringTokenizer(br.readLine() ?: return false)    return true} fun next() = if(hasNext()) st.nextToken()!! else throw RuntimeException(""No tokens"") fun nextInt() = next().toInt() fun nextLong() = next().toLong() fun nextLine() = if(hasNext()) st.nextToken(""\n"")!! else throw RuntimeException(""No tokens"") fun nextArray(n : Int) = IntArray(n,{nextInt()}) val ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null val br = when(ONLINE_JUDGE) {    true -> BufferedReader(InputStreamReader(System.`in`))    else -> BufferedReader(FileReader(""in.txt""))} val pw = when(ONLINE_JUDGE) {    true -> PrintWriter(BufferedWriter(OutputStreamWriter(System.out)))    else -> PrintWriter(BufferedWriter(FileWriter(""out.txt"")))} var st = StringTokenizer("""") fun main(args: Array<String>) {    var start = System.currentTimeMillis()    solve()    pw.close()    br.close()    if(!ONLINE_JUDGE)        System.err.println(""${System.currentTimeMillis() - start} ms"")}","brute force,implementation"
"import java.util.* var possiblie = 50001val rand = Random()val checked = mutableSetOf<Int>()val sc = Scanner(System.`in`) var mostX = Pair(-1, -1) fun main(args: Array<String>) {    val n = sc.nextInt()    val start = sc.nextInt()    val x = sc.nextInt()     val ASK_RAND_LIMIT = 1000    val ASK_TOTAL = 1999     var ans = ask(start)    if (ans.first > x) {        answer(ans.first)        return    } else {        var askFlag = false        loop@ do {            if (askFlag) {                if (checked.size == n) {                    break@loop                }                var next: Int                do {                    next = rand.nextInt(n) + 1                } while (checked.contains(next))                ans = ask(next)            }            when {                ans.first in (mostX.first + 1)..x -> {                    mostX = ans                    if (ans.first == x)                        break@loop                }                ans.first in (x + 1)..possiblie -> {                    possiblie = ans.first                }            }            askFlag = true        } while (checked.size < ASK_RAND_LIMIT)    }     while (checked.size < ASK_TOTAL && mostX.first < x) {        if (mostX.second == -1){            answer(-1)            return        }        mostX = ask(mostX.second)     }     answer(if (mostX.first < x) possiblie else mostX.first)} private fun answer(ans: Int) {    print(""! $ans"")    System.out.flush()} fun ask(x: Int): Pair<Int, Int> {    println(""? $x"")    val value = sc.nextInt()    val next = sc.nextInt()    checked.add(x)    return Pair(value, next)}","brute force,interactive,probabilities"
"import kotlin.system.exitProcess fun main() {    val (n, s, x) = readInts()     val Q = MutableList(n) { it + 1 }    Q[0] = s    Q[s-1] = 1    Q.subList(1, n).shuffle()     val nodes = mutableListOf<Node>()     for(i in 0 until minOf(n, 999)) {        val node = ask(Q[i])        nodes.add(node)    }     var node = nodes.asSequence().filter { it.value <= x }.maxBy { it.value } ?: nodes[0]     while(node.value < x && node.next != -1) {        node = ask(node.next)    }     val ans = node.value.takeIf { it >= x } ?: -1     println(""! $ans"")} data class Node(val value: Int, val next: Int) fun ask(i: Int) = run {    println(""? $i"")    val (v, n) = readInts()    if(v == -1) exitProcess(0)    Node(v, n)}  fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readDouble() = readLn().toDouble()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readStringSeq() = readLn().splitToSequence(' ')fun readInts() = readStrings().map { it.toInt() }fun readIntSeq() = readStringSeq().map { it.toInt() }fun readDoubles() = readStrings().map { it.toDouble() }fun readDoubleSeq() = readStringSeq().map { it.toDouble() }fun readLongs() = readStrings().map { it.toLong() }fun readLongSeq() = readStringSeq().map { it.toLong() } class Output {    val outputSb = StringBuilder()    fun print(o: Any?) { outputSb.append(o) }    fun println() { outputSb.append('\n') }    fun println(o: Any?) { outputSb.append(o).append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(outputSb) }}inline fun output(block: Output.()->Unit) { Output().apply(block).nowPrint() }","brute force,interactive,probabilities"
"import java.util.TreeMapimport kotlin.system.exitProcess fun main() {    val (n, s, x) = readInts()     val Q = MutableList(n) { it + 1 }    Q[0] = s    Q[s-1] = 1    Q.subList(1, n).shuffle()     // value -> node    val nodes = TreeMap<Int, Node>()     for(i in 0 until minOf(n, 999)) {        val node = ask(Q[i])        nodes[node.value] = node    }     var node = (nodes.floorEntry(x) ?: nodes.firstEntry()).value     while(node.value < x && node.next != -1) {        node = ask(node.next)    }     val ans = node.value.takeIf { it >= x } ?: -1     println(""! $ans"")} data class Node(val value: Int, val next: Int) fun ask(i: Int) = run {    println(""? $i"")    val (v, n) = readInts()    if(v == -1) exitProcess(0)    Node(v, n)}  fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readDouble() = readLn().toDouble()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readStringSeq() = readLn().splitToSequence(' ')fun readInts() = readStrings().map { it.toInt() }fun readIntSeq() = readStringSeq().map { it.toInt() }fun readDoubles() = readStrings().map { it.toDouble() }fun readDoubleSeq() = readStringSeq().map { it.toDouble() }fun readLongs() = readStrings().map { it.toLong() }fun readLongSeq() = readStringSeq().map { it.toLong() } class Output {    val outputSb = StringBuilder()    fun print(o: Any?) { outputSb.append(o) }    fun println() { outputSb.append('\n') }    fun println(o: Any?) { outputSb.append(o).append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(outputSb) }}inline fun output(block: Output.()->Unit) { Output().apply(block).nowPrint() }","brute force,interactive,probabilities"
"import java.util.*import kotlin.system.exitProcess val MAX_Q = 1999 val random = Random()val sc = Scanner( System.`in` )var requestsLeft = MAX_Qval posToValue = HashMap<Int, Int>()val next = HashMap<Int, Int>()  fun main(args: Array<String> ) {//    prepare()  //    val n = N    val n = sc.nextInt()//    val start = start_    val start = sc.nextInt()//    val x = x_    val x = sc.nextInt()     if ( n <= MAX_Q ) {        for ( i in 1 .. n ) {            request( i )        }    } else {        for (i in 1 .. MAX_Q / 2) {            var p = -1            do {                p = random.nextInt(n) + 1            } while (posToValue.containsKey(p))             request(p)        }         val t = posToValue.entries.sortedBy { it.value }.findLast { it.value < x }        var s = t?.key ?: start        while ( requestsLeft > 0 && s > 0 ) {            request( s )            s = next[s]!!        }    }     val r = posToValue.values.sorted().find { it >= x }    println( ""! ${ r ?: -1 }"" ) //    check( r )} //val N = 50000//var start_ = -1//var x_ = -1//var a = IntArray( 0 )//val next_ = IntArray( N )////fun prepare() {//    a = IntArray( N, { random.nextInt( 1000000001 ) } )//    val p = Array( N, { it } )//    p.sortBy { a[it] }//    for ( i in a.indices ) {//        next_[p[i]] = if ( i + 1 >= N ) -1 else p[i + 1]//    }//    start_ = p[0]//    x_ = random.nextInt( 1000000001 )//}////fun check( r: Int? ) {//    val ans = a.filter { it >= x_ }.min()//    println( r == ans )//    println( ans )//} fun request( p: Int ) {    if ( posToValue.containsKey( p ) ) return    requestsLeft --    println( ""? $p"" )    System.out.flush()    posToValue[p] = sc.nextInt()    next[p] = sc.nextInt()//    posToValue[p] = a[p]//    next[p] = next_[p]    if ( posToValue[p] == -1 && next[p] == -1 ) exitProcess( 0 )}","brute force,interactive,probabilities"
"fun main() {    val n = readLine()!!.toInt()    val edges = List(n) { mutableListOf<Int>() }    repeat(n - 1) {        val (u, v) = readLine()!!.split(' ').map { it.toInt() - 1 }        edges[u] += v        edges[v] += u    }    var result = 0.0     fun dfs(u: Int, parent: Int, h: Int, p: Double) {        val children = edges[u].count { it != parent }        if (children == 0) {            result += h * p        }        for (v in edges[u]) {            if (v != parent) {                dfs(v, u, h + 1, p / children)            }        }    }    dfs(0, -1, 0, 1.0)    println(result)}","dfs and similar,dp,graphs,probabilities,trees"
"import kotlin.math.sqrt fun main() {    val r = System.`in`.bufferedReader()    val sb = StringBuilder()    val n = r.readLine().toInt()    val adj = List(n) { mutableListOf<Int>() }    repeat(n - 1) {        val (a, b) = r.readLine().split("" "").map { it.toInt() - 1 }        adj[a].add(b)        adj[b].add(a)    }    val see = BooleanArray(n) { false }    fun dfs(i: Int): Double {        see[i] = true        var res = 0.0        for (neighbor in adj[i]) {            if (!see[neighbor]) {                res += dfs(neighbor)            }        }        //println(""i is $i, res is $res"")        return when {            i == 0 -> res / adj[i].size            adj[i].size == 1 -> 1.0            else -> res / (adj[i].size - 1) + 1        }    }    if (n == 1) sb.appendln(0.0) else sb.appendln(dfs(0))    print(sb)}","dfs and similar,dp,graphs,probabilities,trees"
"import java.util.*import kotlin.collections.ArrayListvar g = ArrayList<ArrayList<Int>>()var used = IntArray( 100001 )var d = DoubleArray( 100001 ) fun dfs( v: Int, s : Int = -1 ){    used[v] = 1    for( p in g[v] )        if( used[p] == 0 ){            dfs( p, s + 1 )            d[v] += d[p]        }    if( g[v].size == 1 ){        d[v] = s.toDouble()    }else{        d[v] = d[v] / ( g[v].size - 1 )    }}fun main(args: Array<String>){    //val ( n, m ) = readLine()!!.split(' ').map( String::toInt )    val n = readLine()!!.toInt()    for( i in 1 .. n + 1 ) g.add( ArrayList())    for( i in 1 .. n - 1 ){        var ( x, y ) = readLine()!!.split(' ').map( String::toInt )        g[x].add( y )        g[y].add( x )    }    g[0].add( 1 )    g[1].add( 0 )    dfs( 0 )    print( d[1] )}","dfs and similar,dp,graphs,probabilities,trees"
"import java.util.*import kotlin.collections.ArrayListvar g = ArrayList<ArrayList<Int>>()var used = IntArray( 100001 )var d = DoubleArray( 100001 ) fun dfs( v: Int, s : Int = -1 ){    used[v] = 1    for( p in g[v] )        if( used[p] == 0 ){            dfs( p, s + 1 )            d[v] += d[p]        }    if( g[v].size == 1 ){        d[v] = s.toDouble()    }else{        d[v] = d[v] / ( g[v].size - 1 )    }}fun main(args: Array<String>){    //val ( n, m ) = readLine()!!.split(' ').map( String::toInt )    val n = readLine()!!.toInt()    for( i in 1 .. n + 1 ) g.add( ArrayList())    for( i in 1 .. n - 1 ){        var ( x, y ) = readLine()!!.split(' ').map( String::toInt )        g[x].add( y )        g[y].add( x )    }    g[0].add( 1 )    g[1].add( 0 )    dfs( 0 )    print( d[1] )}","dfs and similar,dp,graphs,probabilities,trees"
"val divisors = Array(1000001) { 1 } fun main(args: Array<String>) {    val n = readLine()!!.toInt()     for (j in 2..1000000) {        if (divisors[j] != 1) continue        for (d in j..1000000 step j) {            divisors[d] = j        }    }     val sb = StringBuilder()     for (i in 1..n) {        val line = readLine()!!.split("" "")        val a = line[0].toInt()        val b = line[1].toInt()         sb.append(solve(a, b))    }    println(sb)} fun solve(a: Int, b: Int): String {    val x3 = a.toDouble() * b    var x = Math.round(Math.pow(x3, 1.0 / 3)).toInt()     if (x.toLong() * x * x != a.toLong() * b) {        return ""No\n""    }     while (x != 1) {        val p = divisors[x]        while (x % p == 0) x /= p         val ap = count(a, p)        val bp = count(b, p)        if (ap * 3 < ap + bp || bp * 3 < ap + bp) {            return ""No\n""        }    }    return ""Yes\n""} fun count(a: Int, p: Int): Int {    var x = a    var count = 0    while (x % p == 0) {        x /= p        count += 1    }    return count} ","math,number theory"
"val divisors = Array(1000001) { 1 }fun main(args: Array<String>) {    val n = readLine()!!.toInt()     for (j in 2..1000000) {        if (divisors[j] != 1) continue        for (d in j..1000000 step j) {            divisors[d] = j        }    }     val sb = StringBuilder()    all@    for (i in 1..n) {        val line = readLine()!!.split("" "")        val a = line[0].toInt()        val b = line[1].toInt()         val x3 = a.toDouble() * b        var x = Math.round(Math.pow(x3, 1.0 / 3)).toInt()         if (x.toLong() * x * x != a.toLong() * b) {            sb.append(""No\n"")            continue@all        }         while (x != 1) {            val p = divisors[x]            while (x % p == 0) x /= p             val ap = count(a, p)            val bp = count(b, p)            if (ap * 3 < ap + bp || bp * 3 < ap + bp) {                sb.append(""No\n"")                continue@all            }        }        sb.append(""Yes\n"")    }    println(sb)} fun count(a: Int, p: Int): Int {    var x = a    var count = 0    while (x % p == 0) {        x /= p        count += 1    }    return count} ","math,number theory"
"import java.io.BufferedOutputStreamimport java.io.InputStreamimport java.io.PrintWriter private val input = FastScanner() fun main(args: Array<String>) = input.run {    val n = nextInt()     val pow3 = LongArray(1000001) { it.toLong() * it * it }     val out = PrintWriter(BufferedOutputStream(System.out), false)     repeat(n) {        val a = nextInt()        val b = nextInt()        val d = gcd(a, b)        if (a * b == 1 || d % (a / d) == 0 && d % (b / d) == 0 && pow3.binarySearch(a.toLong() * b) >= 0) {            out.println(""Yes"")        } else {            out.println(""No"")        }    }     out.flush()} class FastScanner(private val input: InputStream = System.`in`) {    private val sb = StringBuilder()    private val buffer = ByteArray(4096)    private var pos = 0    private var size = 0     fun nextLong(): Long {        var c = skipWhitespace()         val sign = if (c == '-'.toInt()) {            c = read()            -1        } else 1         var ans = 0L         while (c > ' '.toInt()) {            ans = ans * 10 + c - '0'.toInt()            c = read()        }         return sign * ans    }     fun nextInt() = nextLong().toInt()     private fun skipWhitespace(): Int {        while (true) {            val c = read()            if (c > ' '.toInt() || c < 0) return c        }    }     private fun read(): Int {        while (pos >= size) {            if (size < 0) return -1            size = input.read(buffer, 0, buffer.size)            pos = 0        }        return buffer[pos++].toInt()    }} tailrec fun gcd(p: Int, q: Int): Int = if (q == 0) Math.abs(p) else gcd(q, p % q)","math,number theory"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.lang.AssertionErrorimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007 class Factorize(N: Int) {  val prime = IntArray(N)  val factor = IntArray(N + 1)  var p = 0   init {    for (i in 2..N) {      if (factor[i] == 0) {        factor[i] = i        prime[p++] = i      }       var j = 0      while((j < p) and (prime[j] * i <= N)) {        factor[prime[j] * i] = prime[j]//        if (prime[j] == i) break // いらなくない？        j++      }    }  }   tailrec fun factorize(x: Int, fn: (Int) -> Unit) {    if (x > 1) {      val f = factor[x]      fn(f)      factorize(x / f, fn)    }  }   /**   * 因数分解の結果を p1*p1*p2 -> primes:[p1, p2] primeCnt:[2, 1], lst: 2   * で受けとって、perm で使う因数の個数を管理しながら約数を生成する   */  private inline fun nextDivisor(primes: IntArray, primeCnt: IntArray, lst: Int, perm: IntArray): Int {    var res = 1    perm[0]++    for (i in 0 until lst) {      if (perm[i] > primeCnt[i]) {        perm[i] = 0        perm[i + 1]++      }      for (j in 0 until perm[i]) {        res *= primes[i]      }    }    return res  }} class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  private val reader = BufferedReader(InputStreamReader(stream), 32768)   val fac = Factorize(1_000_000 + 100)  fun solve() {    for (t in 0 until ni()) {      out.println(if (solve2()) ""Yes"" else ""No"")    }  }   private val cnt = IntArray(1_000_000 + 100)   fun solve2(): Boolean {    val A = nl()    val B = nl()    val S = A*B    fun cbrt(): Int? {      val pi_k_base = Math.cbrt(S.toDouble()).toLong()      for (i in -1 .. 1) {        val cb = pi_k_base + i        if (cb*cb*cb == S) {          return cb.toInt()        }      }      return null    }     val pi_k = cbrt()    if (pi_k == null) return false    debug{""pi_k:$pi_k""}     val used = mutableListOf<Int>()    fac.factorize(pi_k) { f ->      cnt[f]++      used += f    }     fun cntFactors(X: Long, p: Int): Int {      var res = 0      var x = X      while(true) {        if (x % p != 0L) break        x /= p        res++      }      return res    }     for (p in used.distinct()) {      val a = cntFactors(A, p)      val b = cntFactors(B, p)      if ((a + b) % 3 != 0) return false      val n = (a + b)/3      if (a !in n .. 2*n) return false // aを調べると、bも調べたことになる      cnt[p] = 0    }     return true  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return IntArray(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   /**   * コーナーケースでエラー出たりするので、debug(dp[1])のように添え字付きの場合はdebug{}をつかうこと   */  private inline fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: BooleanArray) {    debug { toString(a) }  }   private inline fun toString(a: BooleanArray) = run{a.map { if (it) 1 else 0 }.joinToString("""")}   private inline fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<BooleanArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }   private inline fun assert(b: Boolean) = run{if (!b) throw AssertionError()}} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","math,number theory"
"fun main(arg: Array<String>) {         fun calculate(field: Array<Array<Boolean>>, nrows: Int, width: Int): Int {            fun getRange(row: Array<Boolean>): Pair<Int, Int>? {                val blacks = row.mapIndexed { i, v -> if (v) i else null }.filterNotNull()                if (blacks.isEmpty()) return null                return Pair(blacks.min()!!, blacks.max()!!)            }             val blacksCount = field.map { it.count { it } }.sum()            if (blacksCount == 0) return 1             val ranges = field.map { getRange(it) }             val minY = ranges.indexOfFirst { it != null }            val maxY = ranges.indexOfLast { it != null }             val notNullRanges = ranges.filterNotNull()             val minX = notNullRanges.minBy { it.first }?.first ?: return -1            val maxX = notNullRanges.maxBy { it.second }!!.second             val yRange = maxY - minY + 1            val xRange = maxX - minX + 1             if (yRange > xRange) {                // add columns                val delta = yRange - xRange                 if (delta <= width - xRange) return yRange * yRange - blacksCount            }             if (yRange < xRange) {                // add rows                val delta = xRange - yRange                 if (delta <= nrows - yRange) return xRange * xRange - blacksCount            }             if (yRange == xRange) {                return xRange * yRange - blacksCount            }             return -1        }         val numbers = readLine()!!.split("" "").map { it.toInt() }        val nrows = numbers[0]        val width = numbers[1]         val field: Array<Array<Boolean>> = Array(nrows, { i ->            readLine()!!.toCharArray().map { (it == 'B') }.toTypedArray()        })         println(calculate(field, nrows, width))      }",implementation
"import java.io.InputStream val input = FastScanner() fun main(args: Array<String>) = input.run {    val m = nextInt()    val b = nextInt()     var ans = 0L     (0..b).forEach { y ->        val x = (b - y) * m        var acc = 0L        (0..y).forEach { yy ->            acc += (x + 1) * yy.toLong() + x * (x + 1L) / 2        }        ans = ans.coerceAtLeast(acc)    }     println(ans)} class FastScanner(private val input: InputStream = System.`in`) {    private val sb = StringBuilder()    private val buffer = ByteArray(4096)    private var pos = 0    private var size = 0     fun nextLong(): Long {        var c = skipWhitespace()         val sign = if (c == '-'.toInt()) {            c = read()            -1        } else 1         var ans = 0L         while (c > ' '.toInt()) {            ans = ans * 10 + c - '0'.toInt()            c = read()        }         return sign * ans    }     fun nextInt() = nextLong().toInt()     private fun skipWhitespace(): Int {        while (true) {            val c = read()            if (c > ' '.toInt() || c < 0) return c        }    }     private fun read(): Int {        while (pos >= size) {            if (size < 0) return -1            size = input.read(buffer, 0, buffer.size)            pos = 0        }        return buffer[pos++].toInt()    }}","brute force,math"
"import java.io.*import java.util.*import kotlin.comparisons.compareByimport kotlin.comparisons.thenByimport kotlin.comparisons.thenByDescending val LOCAL_MODE = true fun main(args: Array<String>) {  val input: InputReader  val output: PrintWriter  if (false) {    input = InputReader(FileInputStream(""input.txt""))    output = PrintWriter(FileOutputStream(""output.txt""))  } else {    input = InputReader(System.`in`)    output = PrintWriter(System.out)  }  Solver(input, output).run()  input.close()  output.close()} fun debug(x: Any) {  if (LOCAL_MODE) {    System.err.println(x)  }} class Solver(val input: InputReader, val output: PrintWriter) {   companion object {  }   fun run() {    if (true) {      read()//      output.println(solve())    } else {      for (stress in generateSequence({ 1 }, { it + 1 })) {        debug(""Stress #$stress"")        generateStress()        printStress()//        val my = solve()//        val slow = slow()//        require(my == slow, { ""$my != $slow"" })      }    }   }   private fun printStress() {  }   private fun generateStress() {  }   private fun read() {    val m = input.nextLong()    val b = input.nextLong()    var y = b    var x = 0L    var ans = getSum(y)    while (y > 0) {      y--      x += m      val s = getSum(x)      val cur = (y + 1) * s + (x + 1) * getSum(y)      ans = Math.max(ans, cur)    }    output.println(ans)  }   private fun getSum(s: Long): Long {    return s * (s + 1) / 2  }   private fun read2() {    val n = input.nextInt()    val a = Array(n, { IntArray(n) })    for (i in 0..n - 1) {      for (j in 0..n - 1) {        a[i][j] = input.nextInt()      }    }    for (i in 0..n - 1) {      for (j in 0..n - 1) {        if (a[i][j] != 1) {          var ok = false          for (s in 0..n - 1) {            for (k in 0..n - 1) {              if (a[i][j] == a[i][s] + a[k][j]) {                ok = true              }            }          }          if (!ok) {            output.println(""No"")            return          }        }      }    }    output.println(""Yes"")  }  }  class InputReader(val stream: InputStream) : Closeable {   var reader: BufferedReader = BufferedReader(InputStreamReader(stream), 32768)   var tokenizer: StringTokenizer? = null   override fun close() {    stream.close()  }   operator fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      try {        tokenizer = StringTokenizer(reader.readLine())      } catch (e: IOException) {        throw RuntimeException(e)      }     }    return tokenizer!!.nextToken()  }   fun nextInt(): Int = next().toInt()   fun nextLong(): Long = next().toLong()   fun nextDouble(): Double = next().toDouble() }","brute force,math"
"import java.util.* fun main(vararg args: String) {    with(Scanner(System.`in`)) {        val n = nextInt()        val a = IntArray(n) { nextInt() }        val b = IntArray(n) { nextInt() }        val da = a.groupBy { it }.values.maxBy { it.size }!![0]        val ma = (1..n).minus(a.asIterable()).first()        val i = a.indices.firstOrNull { a[it] == da && a[it] != b[it] && b[it] == ma }                ?: a.indices.first { a[it] == da && a[it] != b[it] }        a[i] = ma        println(a.joinToString("" ""))    }}",constructive algorithms
"import java.util.* fun main(args: Array<String>) {     val out = Scanner(System.`in`)    val aLen = out.nextInt()     var a = Array(aLen, { out.nextInt() })    var b = Array(aLen, { out.nextInt() })    var c = IntArray(aLen + 1)    var d = IntArray(aLen + 1)    var num1 = -1    var num2 = -1    var pos1 = -1    var pos2 = -1    for (i in 0..aLen - 1) {        if (c[a[i]] == 1) {            pos1 = a[i]        } else {            c[a[i]] = 1        }        if (d[b[i]] == 1) {            pos2 = b[i]        } else {            d[b[i]] = 1        }         if (a[i] != b[i]) {            if (num1 == -1) {                num1 = i            } else num2 = i         }    }    if (num2 == -1){        num2 = num1    }    var disa = -1    var disb = -1    for (i in 0..aLen) {        if (c[i] != 1) {            disa = i        }        if (d[i] != 1) {            disb = i        }    }     if (a[num1] == pos1 && b[num1] == disa) {        a[num1] = disa    }else{        a[num2] = disa    }    for (i in 0..aLen - 1) {        if (i > 0)            print("" "" + a[i])        else            print(a[i])    }    println()}",constructive algorithms
"import java.util.* fun generatePerms(set: Set<Int>, result: List<Int> = listOf()): List<List<Int>> {    if (set.isEmpty()) {        return listOf(result)    }    return set.flatMap { generatePerms(set.minus(it), result.plus(it)) }} fun solve() {    val sc = Scanner(System.`in`)    val n = sc.nextInt()    val a = arrayOfNulls<Int>(n)    val b = arrayOfNulls<Int>(n)    val result = arrayOfNulls<Int>(n)    (0 until n).forEach { a[it] = sc.nextInt() }    (0 until n).forEach { b[it] = sc.nextInt() }     val notAssigned = mutableSetOf<Int>()    val notAssignedIndexes = arrayListOf<Int>()    (1..n).forEach { notAssigned.add(it) }    (0 until n).forEach {        if (a[it] == b[it]) {            result[it] = a[it]            notAssigned.remove(a[it])        } else {            notAssignedIndexes.add(it)        }    }     generatePerms(notAssigned).forEach { perm ->         val aMatches = (0 until notAssignedIndexes.size).filter { i -> a[notAssignedIndexes[i]] != perm[i] }.count()        val bMatches = (0 until notAssignedIndexes.size).filter { i -> b[notAssignedIndexes[i]] != perm[i] }.count()        if(aMatches == 1 && bMatches == 1) {            (0 until notAssignedIndexes.size).forEach{result[notAssignedIndexes[it]] = perm[it]}            result.forEach { print(it); print("" "") }            System.exit(0)        }    } }  fun main(args: Array<String>) {    solve()//    generatePerms(setOf(1, 2, 3)).forEach { println(it) }}",constructive algorithms
"import java.io.Fileimport java.io.InputStreamimport java.util.* fun solve(inp: InputReader) {    val n = inp.nextInt()    val seqA = inp.nextLine().split("" "").map(String::toInt)    val seqB = inp.nextLine().split("" "").map(String::toInt)     val notIncluded = (1..n).toHashSet()    notIncluded.removeAll(seqA)    notIncluded.removeAll(seqB)     val res = seqA.toMutableList()    val differentIndices = (0..n - 1).filter { i -> seqA[i] != seqB[i]}    if (notIncluded.size == 0) {        val differentIndex = differentIndices.first { i -> seqB[i] !in seqA && (seqA[i] in seqB || seqA.count { x -> x == seqA[i] } == 2)}        res[differentIndex] = seqB[differentIndex]    } else {        res[differentIndices.first()] = notIncluded.first()    }     println(res.joinToString("" ""))}  fun main(args: Array<String>) = solve(initIO(""Mine"" in args)) fun initIO(isLocal: Boolean) = when (isLocal) {    true -> InputReader(File(""input.txt"").inputStream())    false -> InputReader(System.`in`)} class InputReader(inputStream: InputStream) {    val reader = inputStream.bufferedReader()    var tokenizer = StringTokenizer("""")     fun nextLine(): String = when {        tokenizer.hasMoreTokens() -> tokenizer.nextToken("""")!!        else -> reader.readLine()!!    }     fun nextWord(): String {        while (!tokenizer.hasMoreTokens()) {            tokenizer = StringTokenizer(nextLine())        }        return tokenizer.nextToken()!!    }     fun nextInt() = nextWord().toInt()     fun nextLong() = nextWord().toLong()} ",constructive algorithms
"import java.io.*import java.util.* fun main(args: Array<String>) {  val input: InputReader  val output: PrintWriter  if (false) {    input = InputReader(FileInputStream(""input.txt""))    output = PrintWriter(FileOutputStream(""output.txt""))  } else {    input = InputReader(System.`in`)    output = PrintWriter(System.out)  }  solve(input, output)  input.close()  output.close()} fun winPlaces(s: Int): Set<Int> {  val places = hashSetOf<Int>()  var i = (s / 50) % 475  for (j in 1..25) {    i = (i * 96 + 42) % 475    places.add(26 + i)  }  require(places.size == 25)  return places} fun solve(input: InputReader, output: PrintWriter) {  val p = input.nextInt()  val x = input.nextInt()  val y = input.nextInt()   var losed = x  while (losed >= y) {    if (winPlaces(losed).contains(p)) {      output.print(0)      return    }    losed -= 50  }    var successfulBreaks = 1  while (true) {    val noFails = x + successfulBreaks * 100    val oneFail = x + successfulBreaks * 100 - 50    if (winPlaces(noFails).contains(p) || winPlaces(oneFail).contains(p)) {      output.print(successfulBreaks)      return    }    successfulBreaks += 1  }} class InputReader(val stream: InputStream) : Closeable {   var reader: BufferedReader = BufferedReader(InputStreamReader(stream), 32768)   var tokenizer: StringTokenizer? = null   override fun close() {    stream.close()  }   operator fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      try {        tokenizer = StringTokenizer(reader.readLine())      } catch (e: IOException) {        throw RuntimeException(e)      }     }    return tokenizer!!.nextToken()  }   fun nextInt(): Int = Integer.parseInt(next()) }","brute force,implementation"
"import java.io.InputStreamimport java.math.BigDecimalimport java.math.BigInteger fun main(args: Array<String>) = input.run {    val p = nextInt()    var x = nextInt()    val y = nextInt()    var z = x    while (z >= y) {        if (ok(z, p)) {            println(0)            return        }        z -= 50    }     var ans = 1    x += 100    while (true) {        if (ok(x, p) || x - 50 >= y && ok(x - 50, p)) {            println(ans)            return        }        x += 100        ans++    }} fun ok(s: Int, p: Int): Boolean {    var i = (s / 50) % 475    repeat(25) {        i = (i * 96 + 42) % 475        if (26 + i == p) {            return true        }    }    return false} val input = FastScanner() fun String.toBigInteger() = BigInteger(this)fun String.toBigDecimal() = BigDecimal(this) class FastScanner(private val input: InputStream = System.`in`) {    private val sb = StringBuilder()    private val buffer = ByteArray(4096)    private var pos = 0    private var size = 0     fun nextString(): String? {        var c = skipWhitespace()        if (c < 0) return null         return sb.run {            setLength(0)             do {                append(c.toChar())                c = read()            } while (c > ' '.toInt())             toString()        }    }     fun nextLine(): String? {        var c = read()        if (c < 0) return null         return sb.run {            setLength(0)             while (c >= 0 && c != '\n'.toInt()) {                append(c.toChar())                c = read()            }             toString()        }    }     fun nextLong(): Long {        var c = skipWhitespace()         val sign = if (c == '-'.toInt()) {            c = read()            -1        } else 1         var ans = 0L         while (c > ' '.toInt()) {            ans = ans * 10 + c - '0'.toInt()            c = read()        }         return sign * ans    }     fun nextInt() = nextLong().toInt()    fun nextDouble() = nextString()?.toDouble() ?: 0.0    fun nextBigInteger(): BigInteger = nextString()?.toBigInteger() ?: BigInteger.ZERO    fun nextBigDecimal(): BigDecimal = nextString()?.toBigDecimal() ?: BigDecimal.ZERO     fun nextStrings(n: Int) = Array<String>(n) { nextString() ?: """" }    fun nextInts(n: Int) = IntArray(n) { nextInt() }    fun nextLongs(n: Int) = LongArray(n) { nextLong() }    fun nextDoubles(n: Int) = DoubleArray(n) { nextDouble() }    fun nextBigIntegers(n: Int) = Array<BigInteger>(n) { nextBigInteger() }    fun nextBigDecimals(n: Int) = Array<BigDecimal>(n) { nextBigDecimal() }     fun nextStrings(n: Int, m: Int) = Array(n) { nextStrings(m) }    fun nextInts(n: Int, m: Int) = Array(n) { nextInts(m) }    fun nextLongs(n: Int, m: Int) = Array(n) { nextLongs(m) }    fun nextDoubles(n: Int, m: Int) = Array(n) { nextDoubles(m) }    fun nextBigIntegers(n: Int, m: Int) = Array(n) { nextBigIntegers(m) }    fun nextBigDecimals(n: Int, m: Int) = Array(n) { nextBigDecimals(m) }     private fun skipWhitespace(): Int {        while (true) {            val c = read()            if (c > ' '.toInt() || c < 0) return c        }    }     private fun read(): Int {        while (pos >= size) {            if (size < 0) return -1            size = input.read(buffer, 0, buffer.size)            pos = 0        }        return buffer[pos++].toInt()    }}","brute force,implementation"
"fun readLongs() = readLine()!!.split("" "").map({it.toLong()})fun readInts() = readLine()!!.split("" "").map({it.toInt()})fun readInt() = readLine()!!.toInt()fun readString() = readLine()!! fun bisquito() {  val s = readString()  val arrS = s.toCharArray()//  var res = arrS.sorted().joinToString("""")   val lenS = s.length//  println(""$lenS: $s"")    var arrT = CharArray(lenS)  var arrU = CharArray(lenS)   var posS = 0  var lenT = 0  var lenU = 0    for (c in 'a'..'z'){    while (true){ // while (last of t == c) -> copy c from t to u      if (lenT < 1) break            val lastT = arrT[lenT-1]      if (lastT > c) break            arrU[lenU] = lastT      lenU++      lenT--    }      val startPos = posS    val lastPos = lenS-1    for (p in startPos..lastPos){ // for all chars left in s      if (arrS[p] == c){ // if found c -> copy start part of s to t, then c to u, continue        for (i in posS..(p-1)){           arrT[lenT] = arrS[i]          lenT++        }        arrU[lenU] = c         lenU++                posS = p + 1       }    }  }    while (lenT > 0){ // copy rest of t to u    arrU[lenU] = arrT[lenT-1]    lenU++    lenT--  }/*    if (lenT > 0){    print(""arrT($lenT) = "")    println(arrT)  }  print(""arrU($lenU) = "")  println(arrU)*/  //  return arrU.joinToString("""")  println(arrU)} fun main(args: Array<String>){//  val t = readInt()//  repeat(t){    bisquito()//  }}","data structures,greedy,strings"
import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.lang.StringBuilderimport java.util.* object MinimalString{     fun findMinString(str: String): String{        var a_ascii = 97        var currentMin = 26        val letters = IntArray(26)        val s = LinkedList<Int>()        val t = Stack<Int>()        val u = StringBuilder()         for (i in str){            val intValue = i.toInt() - a_ascii            letters[intValue]++            s.add(intValue)            currentMin = if (intValue < currentMin) intValue else currentMin        }         while (s.isNotEmpty()){            val c = s.pop()            letters[c]--            if (c != currentMin){                t.push(c)            }else{                while (t.isNotEmpty() && t.peek() <= c){                    u.append((t.pop() + a_ascii).toChar())                }                u.append((c + a_ascii).toChar())            }            var minChanged = false            if(letters[currentMin] == 0){                for(i in currentMin + 1 until 26){                    if(letters[i] != 0){                        currentMin = i                        minChanged = true                        break                    }                }            }            if (minChanged){                while (t.isNotEmpty() && t.peek() <= currentMin){                    u.append((t.pop() + a_ascii).toChar())                }            }        }        while(t.isNotEmpty()) {            u.append((t.pop() + a_ascii).toChar())        }        return u.toString()    }} fun main(args: Array<String>) {    val br = BufferedReader(InputStreamReader(System.`in`))    val s = br.readLine()    println(MinimalString.findMinString(s))},"data structures,greedy,strings"
import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.lang.StringBuilderimport java.util.* object MinimalString{     fun findMinString(str: String): String{        var a_ascii = 97        var currentMin = 26        val letters = IntArray(26)        val s = LinkedList<Int>()        val t = Stack<Int>()        val u = StringBuilder()         for (i in str){            val intValue = i.toInt() - a_ascii            letters[intValue]++            s.add(intValue)            currentMin = if (intValue < currentMin) intValue else currentMin        }         while (s.isNotEmpty()){            val c = s.pop()            letters[c]--            if (c != currentMin){                t.push(c)            }else{                while (t.isNotEmpty() && t.peek() <= c){                    u.append((t.pop() + a_ascii).toChar())                }                u.append((c + a_ascii).toChar())            }            var minChanged = false            if(letters[currentMin] == 0){                for(i in currentMin + 1 until 26){                    if(letters[i] != 0){                        currentMin = i                        minChanged = true                        break                    }                }            }            if (minChanged){                while (t.isNotEmpty() && t.peek() <= currentMin){                    u.append((t.pop() + a_ascii).toChar())                }            }        }        while(t.isNotEmpty()) {            u.append((t.pop() + a_ascii).toChar())        }        return u.toString()    }} fun main(args: Array<String>) {    val br = BufferedReader(InputStreamReader(System.`in`))    val s = br.readLine()    println(MinimalString.findMinString(s))},"data structures,greedy,strings"
import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.lang.StringBuilderimport java.util.* object MinimalString{     fun findMinString(str: String): String{        var a_ascii = 97        var currentMin = 26        val letters = IntArray(26)        val s = LinkedList<Int>()        val t = Stack<Int>()        val u = StringBuilder()         for (i in str){            val intValue = i.toInt() - a_ascii            letters[intValue]++            s.add(intValue)            currentMin = if (intValue < currentMin) intValue else currentMin        }         while (s.isNotEmpty()){            val c = s.pop()            letters[c]--            if (c != currentMin){                t.push(c)            }else{                while (t.isNotEmpty() && t.peek() <= c){                    u.append((t.pop() + a_ascii).toChar())                }                u.append((c + a_ascii).toChar())            }            var minChanged = false            if(letters[currentMin] == 0){                for(i in currentMin + 1 until 26){                    if(letters[i] != 0){                        currentMin = i                        minChanged = true                        break                    }                }            }            if (minChanged){                while (t.isNotEmpty() && t.peek() <= currentMin){                    u.append((t.pop() + a_ascii).toChar())                }            }        }        while(t.isNotEmpty()) {            u.append((t.pop() + a_ascii).toChar())        }        return u.toString()    }} fun main(args: Array<String>) {    val br = BufferedReader(InputStreamReader(System.`in`))    val s = br.readLine()    println(MinimalString.findMinString(s))},"data structures,greedy,strings"
"fun main() {    val (_, _, numSwaps) = readLine()!!.split("" "").map(String::toInt)    val holes = readLine()!!.split("" "").map(String::toInt).toSet()    var pos = 1    for (swap in 1..numSwaps) {        if (pos in holes) break        val (from, to) = readLine()!!.split("" "").map(String::toInt)        if (from == pos)            pos = to        else if (to == pos)            pos = from    }    print(pos)}",implementation
"fun main(){var (n,m,k)=readLine()!!.split(' ').map(String::toInt)var a = readLine()!!.split(' ').map(String::toInt)    var b = IntArray(n + 1) { 0 }    for(i in 0..m-1){    b[a[i]]=1    }    var x:Int    var y:Int    var c:Int    var l:Int    c=1    while(k-->0){    var(x,y)=readLine()!!.split(' ').map(String::toInt)    l=b[c]    if(l>0){    print(c)    return    }    if(c==x) c=y    else if(c==y) c=x    }    print(c)}",implementation
"fun main(args: Array<String>) {    val (n, m, k) = readLine()!!.split("" "").map(String::toInt)    val h = readLine()!!.split("" "").map(String::toInt).toSet()     var ans = 1        for (i in 0..k - 1) {        val (u, v) = readLine()!!.split("" "").map(String::toInt)                if (h.contains(ans)) {            continue        }                if (ans == u) {            ans = v        } else if (ans == v) {            ans = u        }    }        println(ans)}",implementation
"import jdk.nashorn.internal.runtime.JSType.toLongimport sun.security.jgss.GSSToken.readIntimport java.util.*import kotlin.math.sqrt fun main(args : Array<String>){   var i=0    var n:Int    var o=Scanner(System.`in`)     n=o.nextInt()    var m=o.nextInt()    var k=o.nextInt()    var a=Array(n+1,{i->i*0})    var b:Int    for(i in 0..(m-1)){       b =o.nextInt()        a[b]=1;    }    var x:Int=0    var y:Int=0    var flag:Int=0    var w=1    var ans:Int=1;   for(i in 1..k) {       x = o.nextInt()       y = o.nextInt()      if(ans==x){          if(a[x]!=1){              ans=y          }      }else{          if(ans==y){              if(a[y]!=1){                  ans=x;              }          }      }   } print((""$ans"")) }",implementation
"import kotlin.math.maximport kotlin.math.min fun main() {    val n = readLine()!!.toInt()    val (nStartLater, nEndSooner) = f(n)    val m = readLine()!!.toInt()    val (mStartLater, mEndSooner) = f(m)    print(max(0, max(nStartLater - mEndSooner, mStartLater - nEndSooner)))} fun f(n: Int): Pair<Int, Int> {    var nStartLater = 0    var nEndSooner = Int.MAX_VALUE    for (i in 1..n) {        val (start, end) = readLine()!!.split("" "").map { it.toInt() }        nStartLater = max(nStartLater, start)        nEndSooner = min(nEndSooner, end)    }    return Pair(nStartLater, nEndSooner)}","greedy,sortings"
"fun main(args: Array<String>) {    val readPairs = { i: Int ->        val (l, r) = readLine()!!.split("" "").map(String::toInt)        Pair(l, r)    }     val n = readLine()!!.toInt()    val a = Array(n, readPairs)     val m = readLine()!!.toInt()    val b = Array(m, readPairs)     val minA = a.map { it.second }.min()!!    val maxB = b.map { it.first }.max()!!     val minB = b.map { it.second }.min()!!    val maxA = a.map { it.first }.max()!!     val ans1 = Math.max(0, maxB - minA)    val ans2 = Math.max(0, maxA - minB)     val ans = Math.max(ans1, ans2)    println(ans)}","greedy,sortings"
"import kotlin.math.abs fun main() {    val r = System.`in`.bufferedReader()    val sb = StringBuilder()    val n = r.readLine().toInt()    val v = List(n) {        val (a, b) = r.readLine().split("" "").map { it.toInt() }        Pair(a, b)    }.sortedBy { it.first }     val m = r.readLine().toInt()    val l = List(m) {        val (a, b) = r.readLine().split("" "").map { it.toInt() }        Pair(a, b)    }.sortedBy { it.second }     var min = maxOf(0, v.last().first-l.first().second)     val x = v.sortedBy { it.second }    val y = l.sortedBy { it.first }     min = maxOf(min, y.last().first-x.first().second)    sb.appendln(min)    print(sb)}","greedy,sortings"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.* object input {    val reader = BufferedReader(InputStreamReader(System.`in`))    var tokenizer = StringTokenizer("""")     fun next(): String {        while (!tokenizer.hasMoreTokens()) {            val nextLine = reader.readLine() ?: throw IllegalStateException()            tokenizer = StringTokenizer(nextLine)        }        return tokenizer.nextToken()    }     fun nextInt(): Int {        return next().toInt()    }} data class T(val l: Long, val r: Long) fun main(array: Array<String>) {     var a = Array(input.nextInt(), { T(input.nextInt().toLong(), input.nextInt().toLong()) })    var b = Array(input.nextInt(), { T(input.nextInt().toLong(), input.nextInt().toLong()) })     var maxA = 0L    var maxB = 0L    var minA = 1e10.toLong()    var minB = 1e10.toLong()     a.forEach { if (maxA < it.l) maxA = it.l; if (minA > it.r) minA = it.r }    b.forEach { if (maxB < it.l) maxB = it.l; if (minB > it.r) minB = it.r }     println(Math.max(0, Math.max(maxA - minB, maxB - minA)))}","greedy,sortings"
"fun main() {    val n = readLine()!!.toInt()    val solution = IntArray(n + 2) { 1 }    for (i in 2..solution.lastIndex) {        if (solution[i] == 1) {            for (j in i + i..solution.lastIndex step i)                solution[j] = 2        }    }    if (n < 3) println(1) else println(2)    print(solution.slice(2..solution.lastIndex).joinToString("" ""))}","constructive algorithms,number theory"
"import kotlin.math.sqrt fun main() {    val r = System.`in`.bufferedReader()    val sb = StringBuilder()    val n = r.readLine().toInt()+2    val num = List(n) { it }    // primr -> 1    val color = MutableList(n) { 1 }    for (i in 2 until sqrt(n.toDouble()).toInt()+1) {        if (color[i]==1) {            //println(i)            for (j in i+i until n step i){                color[j] = 2            }        }    }    sb.appendln(if (color.contains(2)) 2 else 1)    print(sb)    //println(color)    print(color.subList(2, n).joinToString("" ""))}  ","constructive algorithms,number theory"
"import java.util.*import java.io.*import java.lang.Math.*  private fun exit(msg: String) {    println(msg)    System.exit(0)}private fun exit(msg: Int) = exit(""""+msg) private fun eratosthenes(n: Int): BooleanArray {    val res = BooleanArray(n + 1, { true })     res[0] = false    res[1] = false     var s = 2    while (s * s <= n) {        if (!res[s]) {            s++            continue        }        var i = s * s        while (i <= n) {            res[i] = false            i += s        }        s++    }    return res} fun main(args: Array<String>) {    val scan = object {        private val reader = BufferedReader(InputStreamReader(System.`in`))        private var tokenizer: StringTokenizer? = null            internal operator fun next(): String {            var t = tokenizer            while (t == null || !t.hasMoreTokens()) {                t = StringTokenizer(line())            }            return t.nextToken().apply { tokenizer = t }        }            internal fun int(): Int = next().toInt()        internal fun long(): Long = next().toLong()        internal fun double() = next().toDouble()            internal fun line() = reader.readLine()        }        val n = scan.int()    if (n <= 2) {        println(""1"")        print(""1"")        if (n == 2) println("" 1"")    } else {        println(""2"")        val a = eratosthenes(n+1)        for (i in 2..a.lastIndex) {            if (a[i]) print(""1 "")            else print(""2 "")        }    }}     ","constructive algorithms,number theory"
"/*     Author: Aman Patel    Date: 08-08-2021*/ import java.io.PrintWriterimport java.util.StringTokenizerimport java.io.File private val checkOnlineJudge = System.getProperty(""ONLINE_JUDGE"") == nullprivate val INPUT = if (checkOnlineJudge) File(""src/input.txt"").inputStream() else System.`in`private val OUTPUT = if (checkOnlineJudge) File(""src/output.txt"").outputStream() else System.out private val bufferedReader = INPUT.bufferedReader()private val out = PrintWriter(OUTPUT, false)private fun readLn() = bufferedReader.readLine()!! private fun readList() = readLn().split(' ')private var tokenizer = StringTokenizer("""")private fun read(): String {    while (tokenizer.hasMoreTokens().not()) tokenizer = StringTokenizer(readLn(), "" "")    return tokenizer.nextToken()} private fun readInt() = read().toInt()private fun readLong() = read().toLong()private fun readDouble() = read().toDouble() private fun readIntList() = readList().map { it.toInt() }private fun readLongList() = readList().map { it.toLong() }private fun readDoubleList() = readList().map { it.toDouble() } private fun readIntArray(n: Int = 0) =    if (n == 0) readList().run { IntArray(size) { get(it).toInt() } } else IntArray(n) { readInt() } private fun readLongArray(n: Int = 0) =    if (n == 0) readList().run { LongArray(size) { get(it).toLong() } } else LongArray(n) { readLong() } private fun readDoubleArray(n: Int = 0) =    if (n == 0) readList().run { DoubleArray(size) { get(it).toDouble() } } else DoubleArray(n) { readDouble() } private const val iMax = 1e9.toInt() private class SherlockAndHisGirlfriend {    fun solveTestCase() {        //TODO: Solve the question         var n = readInt()        n += 1         // SOE        val primes = Array(n + 1) { true }        for (i in 2 until iMax) {            if (i * i > n)                break             if (primes[i]) {                var j = i * i                while (j <= n) {                    primes[j] = false                    j += i                }            }        }         if (n >= 4) out.println(""2"") else out.println(""1"")        for (i in 2..n)            if (primes[i]) out.print(""1 "") else out.print(""2 "")    }} fun main(args: Array<String>) {     var t = 1    //t = readInt()    repeat(t) {        //TODO: Read in each Test Case         SherlockAndHisGirlfriend()            .solveTestCase()    }     out.flush()}","constructive algorithms,number theory"
"import java.io.*import java.util.*  fun DataReader.solve(out: PrintWriter) {    val n = nextInt()    val p = nextInt()     val a1 = arrayListOf<Long>()    val b = arrayListOf<Long>()     repeat(n) {        a1 += nextLong()        b += nextLong()    }     if (a1.sum() <= p) {        out.println(-1)        return    }     val a = a1.map { it.toDouble() }     var l = 0.0    var r = 1e18     repeat(150) {        val m = (l + r) / 2.0         var aq = 0L        var bq = 0L         a.indices.forEach { index ->            if (a[index] * m < b[index]) return@forEach             aq += a1[index]            bq += b[index]        }         var need = aq.toDouble() * m - bq         if (need > m * p) {            r = m        }        else {            l = m        }    }     out.println(l)} fun Boolean.toYesNo() = if (this) ""YES"" else ""NO"" class DataReader(private val reader: BufferedReader) {    var st : StringTokenizer? = null    companion object {        fun createFromFile(name: String) = DataReader(BufferedReader(FileReader(name)))    }     fun next() : String? {        while (st == null || !st!!.hasMoreTokens()) {            val s = reader.readLine() ?: return null            st = StringTokenizer(s)        }         return st?.nextToken()    }     fun nextToken() = next()!!     fun nextInt() = nextToken().toInt()    fun nextLong() = nextToken().toLong()    fun readIntArray(n: Int) : IntArray {        val result = IntArray(n)        result.indices.forEach { i -> result[i] = nextInt() }        return result    }     fun readLongArray(n: Int) : LongArray {        val result = LongArray(n)        result.indices.forEach { i -> result[i] = nextLong() }        return result    }     fun nextLine() = reader.readLine()} fun main(args: Array<String>) {    val r: Reader    val out: PrintWriter    if (System.getProperty(""ONLINE_JUDGE"") == null) {        r = FileReader(""input.txt"")        out = PrintWriter(""output.txt"")    } else {        r = InputStreamReader(System.`in`)        out = PrintWriter(System.out)    }     DataReader(BufferedReader(r)).solve(out)    out.flush()}","binary search,math"
"import java.io.PrintWriterimport java.util.*import kotlin.collections.ArrayListimport kotlin.collections.HashSetimport kotlin.math.ceil val CONST1: Long = 998244353fun main() {    var t = 1//    t = readInt()    output {        repeat(t) {            solve(it, this)        }    }}fun solve(it: Int, out: PrintWriter) {    var (n,k,x)=readInts()    var arr=readInts()    var freq=IntArray(1024)    for (i in arr){        freq[i]++    }    repeat(k){        var tempfreq=freq.clone()        var newfreq=IntArray(1024)        var sofar=0        for((ind,i) in tempfreq.withIndex()){            if(sofar%2==0){                newfreq[ind]+=i/2                newfreq[ind xor x]+=ceil(i/2.0).toInt()            }            else{                newfreq[ind]+=ceil(i/2.0).toInt()                newfreq[ind xor x]+=i/2            }            sofar+=i        }        freq=newfreq.clone()    }    var min=-1    var max=0    for((ind,i) in freq.withIndex()){        if(i>=1 && min==-1){            min=ind        }        if(i>=1)        max=ind    }    println(""$max $min"") } class Quaraple<T1,T2,T3,T4>(var first:Int,var second:Int,var third:Int,var forth:Int) @JvmFieldval INPUT = System.`in` @JvmFieldval OUTPUT = System.out @JvmFieldval _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!! @JvmFieldvar _tokenizer: StringTokenizer = StringTokenizer("""") @JvmFieldval _writer = PrintWriter(OUTPUT, false)inline fun output(block: PrintWriter.() -> Unit) {    _writer.apply(block).flush()} fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()} private fun readInt() = readLn().toInt() // single intprivate fun readLong() = readLn().toLong()  // single longprivate fun readDouble() = readLn().toDouble() // single doubleprivate fun readStrings() = readLn().trim().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } as ArrayList<Int>// list of intsprivate fun readLongs() = readStrings().map { it.toLong() } as ArrayList<Long>// list of longsprivate fun readDoubles() = readStrings().map { it.toDouble() } as ArrayList<Double> // list of doubles","brute force,dp,implementation,sortings"
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.system.measureTimeMillisobject IO{	private const val BS = 1 shl 16	private const val NC = 0.toChar()	private val buf = ByteArray(BS)	private var bId = 0	private var size = 0	private var c = NC 	var warningActive = true	var fakein = StringBuilder() 	private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)	val OUT: PrintWriter = PrintWriter(System.out) 	private val char: Char		get() {			while (bId == size) {				size = IN.read(buf) // no need for checked exceptions				if (size == -1) return NC				bId = 0			}			return buf[bId++].toChar()		} 	fun nextInt(): Int {		var neg = false		if (c == NC) c = char		while (c < '0' || c > '9') {			if (c == '-') neg = true			c = char		}		var res = 0		while (c in '0'..'9') {			res = (res shl 3) + (res shl 1) + (c - '0')			c = char		}		return if (neg) -res else res	}	fun nextLong(): Long {		var neg = false		if (c == NC) c = char		while (c < '0' || c > '9') {			if (c == '-') neg = true			c = char		}		var res = 0L		while (c in '0'..'9') {			res = (res shl 3) + (res shl 1) + (c - '0')			c = char		}		return if (neg) -res else res	}	fun nextString():String{		val ret = StringBuilder()		while (true){			c = char			if(!isWhitespace(c)){ break}		}		ret.append(c)		while (true){			c = char			if(isWhitespace(c)){ break}			ret.append(c)		}		return ret.toString()	}	fun isWhitespace(c:Char):Boolean{		return c == ' ' || c == '\n' || c == '\r' || c == '\t'	}}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }val getint:Int get() = IO.nextInt()val getlong:Long get() = IO.nextLong()val getstr:String get() = IO.nextString()fun getline(n:Int):IntArray{	return IntArray(n){getint}}fun getlineL(n:Int):LongArray{	return LongArray(n){getlong}}fun main(){	repeat(1){ _ ->		val n = getint		val k = getint		val x = getint		val L = getline(n)		var all = IntArray(1024)		for(a in L){			all[a] ++		}		repeat(k){			val new = IntArray(1024)			var now = 0			for(i in 0 until 1024){				val here = (all[i] + if(now %2 == 0) 1 else 0 ) / 2				new[i xor x] += here				new[i] += (all[i] - here)				now += all[i]			}			all = new		}		var last = all.indexOfLast { it > 0 }		var first = all.indexOfFirst { it > 0 }		put(last)		put(first)   	}	done()}","brute force,dp,implementation,sortings"
"//Kotlin is also fun!!import java.util.*fun main(args: Array<String>) = with(Scanner(System.`in`)){    val (n,m)=readLine()!!.split("" "").map{it.toInt()}    val x = HashSet<String>()    val y = HashSet<String>()    for(i in 1..n)        x.add(readLine()!!)    for(i in 1..m)        y.add(readLine()!!)    var ct1=0    var ct2=0    for(i in x)    {        if(!y.contains(i))            ++ct1    }    for(i in y)    {        if(!x.contains(i))            ++ct2    }    var diff=n-ct1    while(true)    {        if(diff>0)            --diff        else if(ct1>0)            --ct1        else        {            println(""NO"")            break        }        if(diff>0)            --diff        else if(ct2>0)            --ct2        else        {            println(""YES"")            break        }    }}","binary search,data structures,games,greedy,sortings,strings"
"fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val (numWordsPoland, numWordsEnemy) = readInts()    val polandWords = mutableSetOf<String>()    val enemyWords = mutableSetOf<String>()    val commonWords = mutableSetOf<String>()    for (numWord in 0 until numWordsPoland) polandWords.add(readLine()!!)    for (numWord in 0 until numWordsEnemy) {        val word = readLine()!!        if (word in polandWords) {            polandWords.remove(word)            commonWords.add(word)        } else enemyWords.add(word)    }    val polandStarts = commonWords.size and 1 == 0    val uniquePolandWords = polandWords.size    val uniqueEnemyWords = enemyWords.size    print(when {        polandStarts && uniquePolandWords > uniqueEnemyWords -> ""YES""        polandStarts -> ""NO""        uniqueEnemyWords > uniquePolandWords -> ""NO""        else -> ""YES""    })}","binary search,data structures,games,greedy,sortings,strings"
"import java.io.*import java.util.* fun main(args : Array<String>) {  //====== Input preparations ========================================================//  val fin = BufferedReader(FileReader(""b.in""))  val fin = BufferedReader(InputStreamReader(System.`in`))  val fout = PrintWriter (System.out)  var tokenizer = StringTokenizer("""")  fun next() : String {    while (!tokenizer.hasMoreTokens())      tokenizer = StringTokenizer(fin.readLine())    return tokenizer.nextToken()  }  fun nextInt() = next().toInt()  fun nextPair() = nextInt() to nextInt()  fun nextPairDec() = nextInt()-1 to nextInt()-1  //====== Solution below ============================================================  var (n,m) = nextPair()  val fst = Array(n, {next()}).toSet()  val snd = Array(m, {next()}).toSet()  val com = fst.intersect(snd).size  n -= com  m -= com  val fm = com % 2 == 0  if (fm && n > m || !fm && n >= m)    fout.print(""YES"")  else    fout.print(""NO"")  fout.close()  fin.close()} ","binary search,data structures,games,greedy,sortings,strings"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.io.PrintWriterimport java.util.* fun PrintWriter.solve(sc: FastScanner) {    val n = sc.nextInt()    val m = sc.nextInt()    val set = mutableSetOf<String>()    for (i in 0 until n + m) {        set.add(sc.nextLine())    }    val common = n + m - set.count()    val pb = n - common + (common + 1) / 2    val eb = m - common + common / 2    println(if (pb > eb) ""YES"" else ""NO"")} fun main() {    val writer = PrintWriter(System.out, false)    writer.solve(FastScanner(System.`in`))    writer.flush()} class FastScanner(s: InputStream) {    private var st = StringTokenizer("""")    private val br = BufferedReader(InputStreamReader(s))     fun next(): String {        while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun nextInt() = next().toInt()    fun nextLong() = next().toLong()    fun nextLine() = br.readLine()    fun nextDouble() = next().toDouble()    fun ready() = br.ready()}","binary search,data structures,games,greedy,sortings,strings"
"import java.io.*import java.util.* fun DataReader.solve(out: PrintWriter) {    var nonExisting = 0    while (true) {        out.writeAndFlush((1..4).map { nonExisting })        if (readPair() == (0 to 0)) break        nonExisting++    }     val result = mutableListOf<Int>()     val variants = (0..9).filter { it != nonExisting }     for (i in 0..3) {        for (d in variants) {            out.writeAndFlush((0 until i).map { nonExisting } + d + (i + 1..3).map { nonExisting })            if (readPair().first != 0) {                result += d                break            }        }    }     out.writeAndFlush(result)    assert(readPair() == (4 to 0))} fun PrintWriter.writeAndFlush(s: Collection<Int>) {    this.println(s.map { it.toChar() + '0'.toInt() }.joinToString(""""))    flush()} fun DataReader.readPair() = nextInt() to nextInt() fun Boolean.toYesNo() = if (this) ""YES"" else ""NO"" fun Int.log2Upper(): Int {    var k = 0    while (1 shl k <= this) k++    return k} class DataReader(private val reader: BufferedReader) {    var st : StringTokenizer? = null    companion object {        fun createFromFile(name: String) = DataReader(BufferedReader(FileReader(name)))    }     fun next() : String? {        while (st == null || !st!!.hasMoreTokens()) {            val s = reader.readLine() ?: return null            st = StringTokenizer(s)        }         return st?.nextToken()    }     fun nextToken() = next()!!     fun nextInt() = nextToken().toInt()    fun nextLong() = nextToken().toLong()    fun readIntArray(n: Int) : IntArray {        val result = IntArray(n)        result.indices.forEach { i -> result[i] = nextInt() }        return result    }     fun nextLine() = reader.readLine()} fun main(args: Array<String>) {    val r: Reader    val out: PrintWriter    if (System.getProperty(""ONLINE_JUDGE"") == null && false) {        r = FileReader(""input.txt"")        out = PrintWriter(""output.txt"")    } else {        r = InputStreamReader(System.`in`)        out = PrintWriter(System.out)    }     DataReader(BufferedReader(r)).solve(out)    out.flush()}","brute force,constructive algorithms,implementation"
"import java.io.*import java.util.* data class Item(val s: String, val b: Int) {    val r = s.reversed()     val isPalindrome = r == s} fun DataReader.solve(out: PrintWriter) {    val k = nextInt()    nextInt() // n     val items = (1..k).map {        val s = nextToken()        Item(s, nextInt())    }     val groups = hashMapOf<String, Pair<MutableList<Item>, MutableList<Item>>>()     val palindromes = hashMapOf<String, MutableList<Item>>()     for (item in items) {        if (item.isPalindrome) {            palindromes.getOrPut(item.s) { mutableListOf() }.add(item)            continue        }         if (groups.containsKey(item.s)) {            groups[item.s]!!.first.add(item)            continue        }         if (groups.containsKey(item.r)) {            groups[item.r]!!.second.add(item)            continue        }         groups[item.s] = mutableListOf(item) to mutableListOf()    }     var result = 0     groups.values.forEach {        val (s, r) = it        s.sortBy(Item::b)        r.sortBy(Item::b)         while (s.isNotEmpty() && r.isNotEmpty()) {            val m1 = Math.min(s.last().b, r.last().b)            val m2 = Math.max(s.last().b, r.last().b)             if (m2 + m1 > 0) {                s.pop()                r.pop()                result += m2 + m1            }            else {                break            }        }    }     palindromes.values.forEach {        it.sortBy(Item::b)         while (it.size >= 2) {            val m1 = it[it.lastIndex - 1].b            val m2 = it.last().b             if (m1 > 0) {                it.pop()                it.pop()                result += m1 + m2            }            else {                break            }        }    }     val l: List<Pair<Int, Int>> = palindromes.values.mapNotNull {        if (!it.isPositiveTop()) return@mapNotNull null        val m1 = it.getOrNull(it.lastIndex - 1)?.b        val m2 = it.last().b         m2 to (m1?.let { if (m1 + m2 > 0) m1 + m2 else 0 } ?: 0)    }     val sum = l.sumBy { it.second }     result += (l.map { sum - it.second + it.first } + sum).max()!!     out.println(result)} private fun MutableList<Item>.isPositiveTop() = lastOrNull()?.b ?: -1 >= 0 private fun MutableList<Item>.pop() {    removeAt(lastIndex)} fun Boolean.toYesNo() = if (this) ""YES"" else ""NO"" class DataReader(private val reader: BufferedReader) {    var st : StringTokenizer? = null    companion object {        fun createFromFile(name: String) = DataReader(BufferedReader(FileReader(name)))    }     fun next() : String? {        while (st == null || !st!!.hasMoreTokens()) {            val s = reader.readLine() ?: return null            st = StringTokenizer(s)        }         return st?.nextToken()    }     fun nextToken() = next()!!     fun nextInt() = nextToken().toInt()    fun nextLong() = nextToken().toLong()    fun readIntArray(n: Int) : IntArray {        val result = IntArray(n)        result.indices.forEach { i -> result[i] = nextInt() }        return result    }     fun nextLine() = reader.readLine()} fun main(args: Array<String>) {    val r: Reader    val out: PrintWriter    if (System.getProperty(""ONLINE_JUDGE"") == null) {        r = FileReader(""input.txt"")        out = PrintWriter(""output.txt"")    } else {        r = InputStreamReader(System.`in`)        out = PrintWriter(System.out)    }     DataReader(BufferedReader(r)).solve(out)    out.flush()}","constructive algorithms,data structures,greedy"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"")@file:OptIn(ExperimentalUnsignedTypes::class, ExperimentalStdlibApi::class) import java.io.PrintWriterimport kotlin.math.*import kotlin.random.Randomimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {//    val startTime = System.nanoTime()     val numCases = 1//readInt()     case@ for(case in 1..numCases) {        //    print(""Case #$case: "")         val n = readInt()        val k = readInt()        val nn = n+n         val H = LongIntMap(nn)         val rev = IntArray(nn) { -1 }        val A = Array(nn) { IntList() }         var ans = 0        var bestMid = 0         repeat(n) {            val s = read()            val a = readInt()             val u = H.reg(s)            val v = H.reg(s.reversed())            rev[u] = v            rev[v] = u            A[u].add(a)        }         for(i in 0 until H.size) A[i].sort()        for(u in 0 until H.size) {            val v = rev[u]            if(v != u) {                for (x in 0 until min(A[u].size, A[v].size)) {                    val a = A[u].pop() + A[v].pop()                    if(a < 0) break                    ans += a                }            } else {                while (A[u].isNotEmpty()) {                    val a = A[u].pop()                    val b = if(A[u].isEmpty()) -inf else A[u].pop()                     when {                        b >= 0 -> ans += a + b                        b != -inf && a + b > 0 -> {                            ans += a + b                            bestMid = max(bestMid, -b)                        }                        else -> bestMid = max(bestMid, a)                    }                    if(b < 0) break                }             }        }         ans += bestMid        println(ans)    } //    iprintln(""Time: ${(System.nanoTime() - startTime) / 1000000} ms"")} const val inf = Int.MAX_VALUE class IntList(initialCapacity: Int = 12) {    private var arr = IntArray(initialCapacity)    val _arr get() = arr    private val capacity get() = arr.size    var size = 0        private set    inline val lastIndex get() = size - 1    inline val indices get() = 0 until size     constructor(copyFrom: IntArray): this(copyFrom.size) { copyFrom.copyInto(arr); size = copyFrom.size }    constructor(copyFrom: Collection<Int>): this(copyFrom.size) { arr = copyFrom.toIntArray(); size = copyFrom.size }     fun contentEquals(other: IntList): Boolean {        return this === other || size == other.size && indices.all { this[it] == other[it] }    }     private fun grow(minCapacity: Int = 8) {        val newCapacity = maxOf(minCapacity, capacity + (capacity shr 1))        arr = arr.copyOf(newCapacity)    }     fun ensureCapacity(minCapacity: Int) { if(capacity < minCapacity) grow(minCapacity) }     operator fun get(index: Int): Int {        require(index in 0 until size)        return arr[index]    }     operator fun set(index: Int, value: Int) {        require(index in 0 until size)        arr[index] = value    }     fun add(value: Int) {        if(size == capacity) grow()        arr[size++] = value    }     fun addAll(list: IntList) {        ensureCapacity(size + list.size)        list.arr.copyInto(arr, size, 0, list.size)        size += list.size    }     fun add(index: Int, element: Int) {        if(size == capacity) grow()        arr.copyInto(arr, index + 1, index, size)        size++        set(index, element)    }     fun clear() { size = 0 }     fun removeAt(index: Int): Int {        val e = get(index)        arr.copyInto(arr, index, index + 1, size)        size--        return e    }     fun indexOf(e: Int): Int {        for(i in 0 until size) if(this[i] == e) return i        return -1    }     fun remove(e: Int): Boolean {        val i = indexOf(e)        if(i == -1) return false        removeAt(i)        return true    }     operator fun iterator() = object: IntIterator() {        private var pos = 0        override fun hasNext() = pos < size        override fun nextInt() = get(pos++)    }     inline fun isEmpty() = size == 0    inline fun isNotEmpty() = size != 0     fun pop() = arr[--size]     fun popToSize(s: Int) {        require(s >= 0)        if(s < size) size = s    }     fun swap(i: Int, j: Int) { val t = this[i]; this[i] = this[j]; this[j] = t }    fun reverse() {        for(i in 0 until size / 2) swap(i, lastIndex - i)    }     fun shuffle(rnd: Random = random) { for(i in lastIndex downTo 1) swap(i, rnd.nextInt(i+1)) }     inline fun sortWith(cmp: (Int, Int) -> Int) { _mergeSort(_arr, size, IntArray(size), IntArray::get, IntArray::set, cmp) }    inline fun <T: Comparable<T>> sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }    inline fun <T: Comparable<T>> sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }    fun sort() { sortBy { it } }    fun sortDescending() { sortByDescending { it } }     fun joinToString(separator: CharSequence) = if(size == 0) """" else let {        buildString {            append(it[0])            for (i in 1 until size) {                append(separator).append(it[i])            }        }    }     override fun toString() = ""["" + joinToString("", "") + ""]""     fun toIntArray() = arr.copyOf(size)    fun toList() = List(size, ::get)     inline fun first() = get(0)    inline fun last() = get(lastIndex)} inline fun IntList(size: Int, init: (Int) -> Int) = IntList(size).apply {    for(i in 0 until size) { add(init(i)) }}inline fun IntArray.toIntList() = IntList(this)inline fun Collection<Int>.toIntList() = IntList(this)inline fun intListOf(vararg values: Int) = IntList(values) fun IntList.max() = (1 until size).fold(this[0]) { acc, i -> max(acc, this[i]) }fun IntList.min() = (1 until size).fold(this[0]) { acc, i -> min(acc, this[i]) }fun IntList.getOrNull(i: Int) = if(i in indices) get(i) else nullinline fun IntList.count(predicate: (Int) -> Boolean) = indices.count { predicate(this[it]) }fun IntList.copyOf() = IntList(size, ::get) fun splitmix64(seed: Long): Long {    var x = seed // * -7046029254386353131    x = (x xor (x ushr 30)) * -4658895280553007687    x = (x xor (x ushr 27)) * -7723592293110705685    return (x xor (x ushr 31))}@JvmField val nonce64 = random.nextLong()@JvmField val gamma64 = random.nextLong() or 1fun Long.hash() = splitmix64((nonce64 xor this) * gamma64) fun hash(a: Long, b: Long) = a.hash().xor(b).hash()/** UUID for strings, uncomment final hash for avalanche **/fun String.hash(): Long {    var res = length.toLong()    for(i in indices) {        if(i and 7 == 0) res = res.hash()        res = res xor get(i).toLong().shl(i.and(7) * 8)    }     return res.hash()} typealias LongIntMap = _Ez_Long__Int_HashMapinline operator fun LongIntMap.set(key: Long, value: Int) { put(key, value) }inline operator fun LongIntMap.contains(key: Long) = containsKey(key) class _Ez_Long__Int_HashMap(capacity: Int = DEFAULT_CAPACITY, val nullValue: Int = 0) :    _Ez_Long__Int_Map {    companion object {        private const val DEFAULT_CAPACITY = 8        // There are three invariants for size, removedCount and arraysLength:// 1. size + removedCount <= 1/2 arraysLength// 2. size > 1/8 arraysLength// 3. size >= removedCount// arraysLength can be only multiplied by 2 and divided by 2.// Also, if it becomes >= 32, it can't become less anymore.        private const val REBUILD_LENGTH_THRESHOLD = 32        private const val HASHCODE_INITIAL_VALUE = -0x7ee3623b        private const val HASHCODE_MULTIPLIER = 0x01000193        private const val FREE: Byte = 0        private const val REMOVED: Byte = 1        private const val FILLED: Byte = 2//        private val hashSeed = random.nextLong()//        private val gamma = random.nextLong() or 1    }     private lateinit   var keys: LongArray    private lateinit   var values: IntArray    private lateinit var status: ByteArray    override var size = 0        private set    private var removedCount = 0    private var mask = 0     constructor(map: _Ez_Long__Int_Map) : this(map.size) {        val it = map.iterator()        while (it.hasNext()) {            put(it.key, it.value)            it.next()        }    }     constructor(javaMap: Map<Long, Int>) : this(javaMap.size) {        for ((key, value) in javaMap) {            put(key, value)        }    }     private fun getStartPos(h: Long): Int {//        var x = (h xor hashSeed) * gamma//        x = (x xor (x ushr 30)) * -4658895280553007687//        x = (x xor (x ushr 27)) * -7723592293110705685//        return (x xor (x ushr 31)).toInt() and mask        return h.toInt() and mask    }     override fun isEmpty(): Boolean = size == 0     override fun containsKey(        key: Long    ): Boolean {        var pos = getStartPos(key)        while (status[pos] != FREE) {            if (status[pos] == FILLED && keys[pos] == key) {                return true            }            pos = pos + 1 and mask        }        return false    }     override fun  get(        key: Long    ): Int {        var pos = getStartPos(key)        while (status[pos] != FREE) {            if (status[pos] == FILLED && keys[pos] == key) {                return values[pos]            }            pos = pos + 1 and mask        }        return nullValue    }     override fun  put(        key: Long,        value: Int    ): Int {        var pos = getStartPos(key)        while (status[pos] == FILLED) {            if (keys[pos] == key) {                val   oldValue = values[pos]                values[pos] = value                return oldValue            }            pos = pos + 1 and mask        }        if (status[pos] == FREE) {            status[pos] = FILLED            keys[pos] = key            values[pos] = value            size++            if ((size + removedCount) * 2 > keys.size) {                rebuild(keys.size * 2) // enlarge the table            }            return nullValue        }        val removedPos = pos        pos = pos + 1 and mask        while (status[pos] != FREE) {            if (status[pos] == FILLED && keys[pos] == key) {                val   oldValue = values[pos]                values[pos] = value                return oldValue            }            pos = pos + 1 and mask        }        status[removedPos] = FILLED        keys[removedPos] = key        values[removedPos] = value        size++        removedCount--        return nullValue    }     fun reg(str: String): Int {        val key = str.hash()        var pos = getStartPos(key)        while (status[pos] == FILLED) {            if (keys[pos] == key) {                return values[pos]            }            pos = pos + 1 and mask        }        if (status[pos] == FREE) {            status[pos] = FILLED            keys[pos] = key            values[pos] = size            size++            if ((size + removedCount) * 2 > keys.size) {                rebuild(keys.size * 2) // enlarge the table            }            return size-1        }        val removedPos = pos        pos = pos + 1 and mask        while (status[pos] != FREE) {            if (status[pos] == FILLED && keys[pos] == key) {                return values[pos]            }            pos = pos + 1 and mask        }        status[removedPos] = FILLED        keys[removedPos] = key        values[removedPos] = size        size++        removedCount--        return size-1    }     override fun  remove(        key: Long    ): Int {        var pos = getStartPos(key)        while (status[pos] != FREE) {            if (status[pos] == FILLED && keys[pos] == key) {                val   removedValue = values[pos]                status[pos] = REMOVED                size--                removedCount++                if (keys.size > REBUILD_LENGTH_THRESHOLD) {                    if (8 * size <= keys.size) {                        rebuild(keys.size / 2) // compress the table                    } else if (size < removedCount) {                        rebuild(keys.size) // just rebuild the table                    }                }                return removedValue            }            pos = pos + 1 and mask        }        return nullValue    }     override fun clear() {        if (keys.size > REBUILD_LENGTH_THRESHOLD) {            initEmptyTable(REBUILD_LENGTH_THRESHOLD)        } else {            status.fill(FREE)            size = 0            removedCount = 0        }    }     override fun keys(): LongArray {        val result = LongArray(size)        var i = 0        var j = 0        while (i < keys.size) {            if (status[i] == FILLED) {                result[j++] = keys[i]            }            i++        }        return result    }     override fun values(): IntArray {        val result = IntArray(size)        var i = 0        var j = 0        while (i < values.size) {            if (status[i] == FILLED) {                result[j++] = values[i]            }            i++        }        return result    }     override fun iterator(): _Ez_Long__Int_MapIterator {        return _Ez_Long__Int_HashMapIterator()    }     private fun rebuild(newLength: Int) {        val oldKeys = keys         val oldValues = values        val oldStatus = status        initEmptyTable(newLength)        for (i in oldKeys.indices) {            if (oldStatus[i] == FILLED) {                put(oldKeys[i], oldValues[i])            }        }    }     private fun initEmptyTable(length: Int) {        keys = LongArray(length)        values = IntArray(length)        status = ByteArray(length)        size = 0        removedCount = 0        mask = length - 1    }     fun contentEquals(that: _Ez_Long__Int_HashMap): Boolean {        if (size != that.size) {            return false        }        for (i in keys.indices) {            if (status[i] == FILLED) {                val   thatValue = that[keys[i]]                if (thatValue != values[i]) {                    return false                }            }        }        return true    }     override fun toString(): String {        val sb = StringBuilder()        sb.append('{')        for (i in keys.indices) {            if (status[i] == FILLED) {                if (sb.length > 1) {                    sb.append("", "")                }                sb.append(keys[i])                sb.append('=')                sb.append(values[i])            }        }        sb.append('}')        return sb.toString()    }     private inner class _Ez_Long__Int_HashMapIterator : _Ez_Long__Int_MapIterator {        private var curIndex = 0        override fun hasNext(): Boolean {            return curIndex < status.size        }          override val key: Long             get() {                if (curIndex == keys.size) {                    throw NoSuchElementException(""Iterator doesn't have more entries"")                }                return keys[curIndex]            }          override val value: Int             get() {                if (curIndex == values.size) {                    throw NoSuchElementException(""Iterator doesn't have more entries"")                }                return values[curIndex]            }         override fun next() {            if (curIndex == status.size) {                return            }            curIndex++            while (curIndex < status.size && status[curIndex] != FILLED) {                curIndex++            }        }         init {            while (curIndex < status.size && status[curIndex] != FILLED) {                curIndex++            }        }    }     init {        require(capacity >= 0) { ""Capacity must be non-negative"" }        val length = Integer.highestOneBit(4 * max(1, capacity) - 1)        // Length is a power of 2 now        initEmptyTable(length)    }} interface _Ez_Long__Int_Map {     val size: Int     fun isEmpty(): Boolean     fun containsKey(        key: Long    ): Boolean     operator fun  get(        key: Long    ): Int     fun  put(        key: Long,        value: Int    ): Int     fun  remove(        key: Long    ): Int     fun clear()     fun keys(): LongArray     fun values(): IntArray     operator fun iterator(): _Ez_Long__Int_MapIterator     override fun toString(): String} interface _Ez_Long__Int_MapIterator {    operator fun hasNext(): Boolean     val key: Long     val value: Int     operator fun next()} inline fun LongIntMap.forEach(act: (key: Long, value: Int) -> Unit) {    val ite = iterator()    while(ite.hasNext()) {        act(ite.key, ite.value)        ite.next()    }} /** IO *///@JvmField val ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null//const val PATH = ""src/main/resources/""//@JvmField val INPUT = File(PATH + ""input.txt"").inputStream()//@JvmField val OUTPUT = File(PATH + ""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar() else c    }} /** @param skipNext Whether to skip the next character (usually whitespace), defaults to true */fun readCharArray(n: Int, skipNext: Boolean = true): CharArray {    val res = CharArray(n) { readChar() }    if(skipNext) readChar()    return res} fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(c != '\n' && c != Char.MIN_VALUE) {            append(c)            c = readChar()        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /**  sort overrides to avoid quicksort attacks */ @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } inline fun <A, T> _mergeSort(a0: A, n: Int, tmp0: A, get: A.(Int) -> T, set: A.(Int, T) -> Unit, cmp: (T, T) -> Int) {    var a = a0    var tmp = tmp0    var len = 1    while(len < n) {        var l = 0        while(true) {            val m = l + len            if(m >= n) break            val r = min(n, m + len)            var i = l            var j = m            for(k in l until r) {                if(i != m && (j == r || cmp(a.get(i), a.get(j)) <= 0)) {                    tmp.set(k, a.get(i++))                } else tmp.set(k, a.get(j++))            }            l = r        }        for(i in l until n) tmp.set(i, a.get(i))        val t = a; a = tmp; tmp = t        len += len    }    if(a !== a0) for(i in 0 until n) a0.set(i, tmp0.get(i))} inline fun IntArray.sortWith(cmp: (Int, Int) -> Int) { _mergeSort(this, size, IntArray(size), IntArray::get, IntArray::set, cmp) }inline fun <T: Comparable<T>> IntArray.sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> IntArray.sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun IntArray.sort() { sortBy { it } }fun IntArray.sortDescending() { sortByDescending { it } } inline fun LongArray.sortWith(cmp: (Long, Long) -> Int) { _mergeSort(this, size, LongArray(size), LongArray::get, LongArray::set, cmp) }inline fun <T: Comparable<T>> LongArray.sortBy(func: (Long) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> LongArray.sortByDescending(func: (Long) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun LongArray.sort() { sortBy { it } }fun LongArray.sortDescending() { sortByDescending { it } } inline fun DoubleArray.sortWith(cmp: (Double, Double) -> Int) { _mergeSort(this, size, DoubleArray(size), DoubleArray::get, DoubleArray::set, cmp) }inline fun <T: Comparable<T>> DoubleArray.sortBy(func: (Double) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> DoubleArray.sortByDescending(func: (Double) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun DoubleArray.sort() { sortBy { it } }fun DoubleArray.sortDescending() { sortByDescending { it } } inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T : Comparable<T>> Array<out T>.sort() = _sort()inline fun <T : Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T : Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T : Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() // import preserving junk function@Suppress(""NonAsciiCharacters"") fun 雪花飄飄北風嘯嘯天地一片蒼茫() { iprintln(max(1, 2)) } fun IntArray.sumLong() = sumOf { it.toLong() } fun IntArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun IntArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun LongArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun LongArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun DoubleArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun DoubleArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> Array<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> Array<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> List<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> List<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) } // max/min Kotlin 1.6 -> 1.4 shimfun IntArray.max() = maxOf { it }fun IntArray.min() = minOf { it }fun LongArray.max() = maxOf { it }fun LongArray.min() = minOf { it }fun CharArray.max() = maxOf { it }fun CharArray.min() = minOf { it }fun <T : Comparable<T>> Iterable<T>.max() = maxOf { it }fun <T : Comparable<T>> Iterable<T>.min() = minOf { it }fun <T : Comparable<T>> Sequence<T>.max() = maxOf { it }fun <T : Comparable<T>> Sequence<T>.min() = minOf { it }","constructive algorithms,data structures,greedy"
"fun main(vararg args: String) {    val n = readLine()!!.toInt()    val crush = readLine()!!.split(' ').map { it.toInt() }    val visited = Array<Boolean>(n) { false }    val circles = mutableListOf<Int>()    for (i in 0 until n) {        var count = 0        var p = i        while (!visited[p]) {            visited[p] = true            p = crush[p] - 1            ++count        }        if (p == i) {            if (count > 1) circles += count        } else {            println(-1)            return        }    }     fun nod(a: Int, b: Int): Int = if (b == 0) a else nod(b, a % b)    fun nok(a: Int, b: Int) = a / nod(a, b) * b     var r = when (circles.size) {        0 -> 1        1 -> circles[0]        else -> circles.reduce(::nok)    }    if (r % 2 == 0) r /= 2    println(r)}","dfs and similar,math"
"import java.io.*import java.util.* fun <T : Comparable<T>> max(a: T, b: T): T = if (b > a) b else afun <T : Comparable<T>> min(a: T, b: T): T = if (b < a) b else afun Number.isEven(): Boolean = if (this.toInt() and 1 == 0) true else falsefun Number.isOdd(): Boolean = !this.isEven() tailrec fun gcd(a: Int, b: Int): Int {    if (a == 0) return b    else return gcd(b % a, a)} fun lcm(a: Int, b: Int): Int {    return (a / gcd(a, b)) * b} fun main(args: Array<String>) {    if (args.isNotEmpty()) System.setIn(FileInputStream(args[0]))    val br = BufferedReader(InputStreamReader(System.`in`))    val bw = BufferedWriter(OutputStreamWriter(System.out))     var st = StringTokenizer(br.readLine())    val n = st.nextToken().toInt()    val arr = IntArray(n + 1)    st = StringTokenizer(br.readLine())    for (i in 1..n) {        arr[i] = st.nextToken().toInt()    }    var answer = 1    for (i in 1..n) {        var loop = false        val a = i        var b = a        for (j in 1..n) {            b = arr[b]            if (b == a) {                loop = true                if (j.isEven()) answer = lcm(answer, j/2)                else answer = lcm(answer, j)                break            }        }        if (!loop) {            answer = -1            break        }    }    bw.write(""$answer"")    bw.newLine()    bw.flush()}","dfs and similar,math"
"import java.io.*import java.util.* fun DataReader.solve(out: PrintWriter) {    val n = nextInt()    val next = readIntArray(n).map { it - 1 }    val cycles = mutableListOf<Long>()     val visited = BooleanArray(n)     for (i in 0 until n) {        if (visited[i]) continue        var k = next[i]        var l = 1        while (k != i && !visited[k]) {            visited[k] = true            k = next[k]            l++        }         if (k != i) {            out.println(-1)            return        }         val q = if (l % 2 == 0) l / 2 else l        cycles.add(q.toLong())    }     out.println(cycles.fold(1L, ::lcm))} fun lcm(x: Long, y: Long) = x * y / gcd(x, y) tailrec fun gcd(x: Long, y: Long): Long {    if (x == 0L || y == 0L) return x + y     return if (x > y) gcd(x % y, y) else gcd(y % x, x)} fun Boolean.toYesNo() = if (this) ""YES"" else ""NO"" class DataReader(private val reader: BufferedReader) {    var st : StringTokenizer? = null    companion object {        fun createFromFile(name: String) = DataReader(BufferedReader(FileReader(name)))    }     fun next() : String? {        while (st == null || !st!!.hasMoreTokens()) {            val s = reader.readLine() ?: return null            st = StringTokenizer(s)        }         return st?.nextToken()    }     fun nextToken() = next()!!     fun nextInt() = nextToken().toInt()    fun nextLong() = nextToken().toLong()    fun readIntArray(n: Int) : IntArray {        val result = IntArray(n)        result.indices.forEach { i -> result[i] = nextInt() }        return result    }     fun nextLine() = reader.readLine()} fun main(args: Array<String>) {    val r: Reader    val out: PrintWriter    if (System.getProperty(""ONLINE_JUDGE"") == null) {        r = FileReader(""input.txt"")        out = PrintWriter(""output.txt"")    } else {        r = InputStreamReader(System.`in`)        out = PrintWriter(System.out)    }     DataReader(BufferedReader(r)).solve(out)    out.flush()}","dfs and similar,math"
"import java.io.*import java.util.*import java.lang.Math.*import java.util.stream.IntStream class Task {    internal var `in`: FastScanner = FastScanner(System.`in`)    internal var out: PrintWriter = PrintWriter(System.out)     internal fun solve() {        val n = `in`.nextInt()        val m = `in`.nextInt()        val p = IntArray(n)        for (i in 0..n - 1)            p[i] = `in`.nextInt()        val s = IntArray(m)        for (i in 0..m - 1)            s[i] = `in`.nextInt()         val sortedS = IntStream.range(0, m).mapToObj({ i -> i }).sorted({ a, b -> Integer.compare(s[a], s[b]) }).mapToInt { i -> i }.toArray()         val map = TreeMap<Int, TreeSet<Int>>()        for (i in 0..n - 1) {            val list : TreeSet<Int>            if (map.containsKey(p[i]))                list = map.get(p[i])!!            else                list = TreeSet<Int>()            list.add(i)            map.put(p[i], list)        }         val ansP = IntArray(n)        val ansS = IntArray(m)        var c = 0        var u = 0         for (index in sortedS) {            var `val` = s[index]            var del = 0            while (true) {                if (map.containsKey(`val`)) {                    val set = map.get(`val`)                    val cur = set!!.first()                    ansP[cur] = index!! + 1                    ansS[index] = del                    u += del                    c++                    set.remove(cur)                    if (set.isEmpty())                        map.remove(`val`)                    else                        map.put(`val`, set)                    break                }                del++                if (`val` == 1)                    break                `val` = (`val` + 1) / 2            }        }         out.println("""" + c + "" "" + u)        for (it in ansS)            out.print("""" + it + "" "")        out.println()        for (it in ansP)            out.print("""" + it + "" "")    }     fun run() {        solve()        out.close()    }     internal inner class FastScanner(`is`: InputStream) {        var br: BufferedReader        var st: StringTokenizer? = null         init {            br = BufferedReader(InputStreamReader(`is`))        }         operator fun next(): String {            while (st == null || !st!!.hasMoreTokens()) {                try {                    st = StringTokenizer(br.readLine())                } catch (e: IOException) {                    e.printStackTrace()                }             }            return st!!.nextToken()        }         fun nextLine(): String? {            st = null            try {                return br.readLine()            } catch (e: IOException) {                e.printStackTrace()                return null            }         }         fun nextInt(): Int {            return Integer.parseInt(next())        }         fun nextLong(): Long {            return java.lang.Long.parseLong(next())        }         fun nextDouble(): Double {            return java.lang.Double.parseDouble(next())        }         fun nextFloat(): Float {            return java.lang.Float.parseFloat(next())        }    }     companion object {        internal val FILE = """"    } } fun main(args: Array<String>) {    Task().run()}","greedy,sortings"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007L fun lowerBound(A: Array<PC>, s: Int, x: Int): Int {  var l = s - 1  var h = A.size  while(h - l > 1) {    val m = (h + l) / 2    if (A[m].v >= x) h = m    else l = m  }  return h}data class PC(val id: Int, val v: Int) : Comparable<PC> {  override fun compareTo(other: PC): Int = run{Integer.compare(v, other.v)}}data class Adapted(var v: Int, val socketNum: Int)data class Ans(val socket: Int, val pc: Int, val adapters: Int)class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  fun solve() {    val N = ni()    val M = ni()    val P = Array(N){PC(it, ni())}    P.sort()    val S = na(M)     var cur = mutableListOf<Adapted>()    var next = mutableListOf<Adapted>()    for (i in 0 until M) {      cur.add(Adapted(S[i], i))    }     val ans = mutableListOf<Ans>()    val used = IntArray(N)     for (cnt in 0 until 32) {      next.clear()      for (i in 0 until cur.size) {        val j = lowerBound(P, 0, cur[i].v)        if (j < N && j + used[j] < N && cur[i].v == P[j + used[j]].v) {          ans += Ans(cur[i].socketNum, P[j + used[j]++].id, cnt)        } else {          cur[i].v = (cur[i].v + 1) / 2          next.add(cur[i])        }      }      val tmp = cur      cur = next      next = tmp    }     out.println(""${ans.size} ${ans.map{it.adapters.toLong()}.sum()}"")    val A = IntArray(M)    val B = IntArray(N)    for (i in ans) {      A[i.socket] = i.adapters      B[i.pc] = i.socket + 1    }     out.println(A.joinToString("" ""))    out.println(B.joinToString("" ""))  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private val reader = BufferedReader(InputStreamReader(stream), 32768)  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return map(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun map(n: Int, f: (Int) -> Int): IntArray {    val res = IntArray(n)    for (i in 0 until n) {      res[i] = f(i)    }    return res  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: BooleanArray) {    debug { a.map { if (it) 1 else 0 }.joinToString("""") }  }   private fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","greedy,sortings"
"fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     readLine()    var activeCoupon = false    for (pizzas in readInts())        if (pizzas == 0 && activeCoupon) return print(""NO"")        else if (pizzas and 1 == 1) activeCoupon = !activeCoupon    print(if (activeCoupon) ""NO"" else ""YES"")}","constructive algorithms,greedy"
"fun main(vararg args: String) {    val n = readLine()!!.toInt()    val aa = readLine()!!.split(' ').map { it.toInt() }    val a = aa.toMutableList().apply { add(0) }.toIntArray()    assert(n == a.size)    var d = 0    var r = true    for (v in a) {        val o = v - d        if (o < 0) { r = false; break }        d = o and 1    }    println(if (r) ""YES"" else ""NO"")}","constructive algorithms,greedy"
"import kotlin.math.min private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() }// list of ints fun square(a: Int) : Int{    return a*a} fun main() {    var n : Int = readInt()    var a : IntArray = readInts().toIntArray()    for (i in 0..(n-1)){        a[i]%=2        if (a[i]!=0)        {            if (i!=n-1&&a[i+1]>0) a[i+1]-=1            else            {                print(""NO"")                return            }        }    }    print(""YES"") }","constructive algorithms,greedy"
"import java.io.BufferedReaderimport java.io.Fileimport java.io.PrintWriter fun main(args: Array<String>) {    val onlineJudge = System.getProperty(""ONLINE_JUDGE"") == ""true""    val input = if (onlineJudge) System.`in`.bufferedReader() else File(""input.txt"").bufferedReader()    val output = if (onlineJudge) PrintWriter(System.out.writer(), true) else PrintWriter(File(""output.txt""))     solve(input, output)     output.flush()    output.close()} private fun String.words() = split("" "") private fun String.toInts() = split("" "").map { it.toInt() }private fun String.toLongs() = split("" "").map { it.toLong() } private fun solve(input: BufferedReader, output: PrintWriter) {    val n = input.readLine().toInt()    val xs = input.readLine().toInts().take(n)     var minTickets = 0    var maxTickets = 0    for (x in xs) {        if (x < minTickets) {            output.println(""NO"")            return        }        val rx = x - minTickets        minTickets = rx % 2    }     if (minTickets > 0) {        output.println(""NO"")        return    }     output.println(""YES"")}","constructive algorithms,greedy"
"import java.io.*import java.math.*import java.util.* fun incrementLastDigit ( num : ArrayList<Char>, _isDecimal : Boolean ) : ArrayList<Char> { 	var i = num.size-1	var isDecimal = _isDecimal 	while ( i >= 0 && ( num[i] == '9' || num[i] == '.' ) )	{		if ( num[i] == '.' ) {			num.removeAt(i--)			isDecimal = false		}		else {			if (isDecimal) num.removeAt(i) //remove last			else num[i] = '0'			i--		}	} 	if ( i == -1 )		num.add(++i, '0')	num[i]++ 	return num} fun doFirstRounding ( num : String ) : ArrayList<Char> {	var isDecimal = false	for ( i in num.indexOf('.')-1..num.length-2 ) {		if ( num[i] == '.' ) {			isDecimal = true			continue		}		val nextDigit = if ( num[i+1] == '.' ) num[i+2] else num[i+1]		if ( nextDigit >= '5' )			return incrementLastDigit(ArrayList<Char>(num.substring(0..i).toList()), isDecimal)	}	return  ArrayList<Char>(num.toList())} fun main ( args : Array<String> ) {	val reader = BufferedReader( InputStreamReader(System.`in`) )	val writer = PrintWriter ( System.out ) 	while ( true ) {		val line1 = reader.readLine() ?: break		val t = line1.split("" "")[1].toInt()-1 		val ans = doFirstRounding(reader.readLine())		if (ans.indexOf('.') != -1) {			var i = ans.size - 1			for (counter in 1..t) {				if (i == 0 || ans[i] != '5')					break; 				ans.removeAt(i--)				if (ans[i] == '.') {					ans.removeAt(i--)					while ( i >= 0 && ans[i] == '9' ) ans[i--] = '0'					if ( i == -1 ) ans.add(++i, '0')					ans[i]++					break				}				ans[i]++			}		} 		writer.write(ans.joinToString("""") { it.toString() })		writer.write(""\n"")	}	reader.close()	writer.close()}","dp,implementation,math"
"fun main() {    val (n, t) = readInts()    val num = readLn().split(""."")    val whole = num[0].map { it - '0' }.toMutableList()    val decimal = num[1].map { it - '0' }.toMutableList()     val steps = IntArray(decimal.size)    for (i in decimal.size - 2 downTo 0) {        if (decimal[i + 1] >= 5) steps[i] = 1        else if (decimal[i + 1] == 4 && steps[i + 1] > 0) steps[i] = 1 + steps[i + 1]    }     val d = if (decimal[0] >= 5) 1 else if (decimal[0] == 4 && steps[0] > 0) (1 + steps[0]) else 0     if (d in 1..t) {        var newVal = whole[whole.size - 1] + 1        whole[whole.size - 1] = newVal % 10        var rem = newVal / 10         for (i in whole.size - 2 downTo 0) {            newVal = (whole[i] + rem)            whole[i] = newVal % 10            rem = newVal / 10            if (rem == 0) break        }        if (rem > 0) println(""$rem${whole.joinToString("""")}"")        else println(whole.joinToString(""""))    } else {        var toIncrease = decimal.size        for (i in steps.indices) {            if (steps[i] in 1..t) {                toIncrease = i                break            }        }        if (toIncrease == decimal.size) println(""${whole.joinToString("""")}.${decimal.joinToString("""")}"")        else {            var newVal = decimal[toIncrease] + 1            decimal[toIncrease] = newVal % 10            var rem = newVal / 10            for (i in toIncrease - 1 downTo 0) {                newVal = (decimal[i] + rem)                decimal[i] = newVal % 10                rem = newVal / 10                if (rem == 0) break            }            if (rem > 0) {                for (i in whole.size - 1 downTo 0) {                    newVal = (whole[i] + rem)                    whole[i] = newVal % 10                    rem = newVal / 10                    if (rem == 0) break                }            }            if (rem > 0) println(""$rem${whole.joinToString("""")}.${decimal.subList(0, toIncrease + 1).joinToString("""")}"")            else println(""${whole.joinToString("""")}.${decimal.subList(0, toIncrease + 1).joinToString("""")}"")        }    }} // Input Readerprivate fun readLn() = readLine()!! private fun readStrings() = readLn().trim().split("" "")private fun readInts() = readStrings().map { it.toInt() }","dp,implementation,math"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.lang.AssertionErrorimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007 class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  private val reader = BufferedReader(InputStreamReader(stream), 32768)   fun solve() {    val (N, T) = na(2)    val S = ns()    val p = S.indexOf('.')    val inf = 1e9.toInt() + 100    val dp = IntArray(N + 1){inf}    for (i in N - 1 downTo p + 1) {      dp[i] = if (S[i]-'0' >= 5) {        1      }      else {        if (S[i]-'0' == 4 && dp[i + 1] != inf) dp[i + 1] + 1 else inf      }    }     var digits: IntArray? = null    fun incr(digits: IntArray) {      var i = digits.size - 1      digits[i]++      while (digits[i] == 10) {        digits[i] = 0        digits[i - 1]++        i--      }    }    fun makeDigits(i: Int) {      digits = (""0""+S.substring(0, i)).filterNot { it == '.' }.map{it-'0'}.toIntArray()    }    fun digitsStr(): String {      val str = digits!!.joinToString("""")      return if (str.startsWith(""0"")) str.drop(1) else str    }     var j = 0 // 小数点部分が何個あるか    for (i in p + 1 until N) {      if (dp[i] != inf && T >= dp[i]) {        makeDigits(i)        incr(digits!!)        break      }      else {        j++      }    }    if (digits == null) makeDigits(N)     val ans = if (j == 0) {      digitsStr()    }    else {      val d = digitsStr()      d.dropLast(j) + ""."" + d.takeLast(j)    }     out.println(ans)  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return IntArray(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private inline fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: BooleanArray) {    debug { toString(a) }  }   private inline fun toString(a: BooleanArray) = run{a.map { if (it) 1 else 0 }.joinToString("""")}   private inline fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<BooleanArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }   private inline fun assert(b: Boolean) = run{if (!b) throw AssertionError()}} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","dp,implementation,math"
"fun main() {    fun readLongs() = readLine()!!.split("" "").map(String::toLong)     val (_, delay) = readLongs()    val seconds = readLongs()    var sol = 1    for (pos in 1 until seconds.size)        sol = if (seconds[pos] - seconds[pos - 1] > delay) 1 else sol + 1    print(sol)}",implementation
"fun main() {    fun readLongs() = readLine()!!.split("" "").map(String::toLong)     val (_, delay) = readLongs()    val seconds = readLongs()    var sol = 1    for (pos in 1 until seconds.size)        if (seconds[pos] - seconds[pos - 1] > delay)            sol = 1        else sol++    print(sol)}",implementation
"import kotlin.math.max fun main(){    var (k,c)= readLine()!!.split("" "")    var str=readLine()!!.split("" "")    var mx:Long =1    for(i in k.toInt()-2 downTo 0){        //print(i)        if(str[i+1].toLong()-str[i].toLong()<=c.toInt()){            mx+=1        }else break    }    print(mx)    return }",implementation
"fun main() {    val r = System.`in`.bufferedReader()    val s = StringBuilder()    //val n = r.readLine()!!.toInt()    val (n, c) = r.readLine()!!.split("" "").map { it.toInt() }    val v = r.readLine()!!.split("" "").map { it.toInt() }    var ans = 1    (1..v.size-1).forEach {        if (v[it]-v[it-1]>c) ans=1        else ans++    }    println(ans)}",implementation
"import java.io.*;import java.util.*; class Edge(val u: Int, val v: Int, var w: Long, val opt: Boolean) { }  fun main(args : Array<String>) {//  var fin = Scanner(File(""b.in""))  var fin = Scanner(System.`in`)  val fout = System.out  val n = fin.nextInt()  val m = fin.nextInt()  val len = fin.nextLong()  val s = fin.nextInt()  val t = fin.nextInt()   val e = Array(n, {mutableListOf<Edge>()})  val list = mutableListOf<Edge>()   for (i in 0..m-1) {    val x = fin.nextInt()    val y = fin.nextInt()    val w = fin.nextLong()    val edge = Edge(x, y, Math.max(w, 1), w == 0L)    e[x].add(edge)    e[y].add(edge)    list.add(edge)  }   fun dejkstra(needOpt : Boolean) : Pair<List<Edge>, Long>? {    val prev = Array<Edge?>(n, {null})    val inf = 1e12.toLong()    val d = Array(n, {inf})    val q = PriorityQueue<Int>({x,y -> d[x].compareTo(d[y])})    d[s] = 0    for (i in d.indices)      q.add(i)    while (!q.isEmpty()) {      val u = q.remove()      for (edge in e[u]) {        if (!needOpt && edge.opt)          continue        val v = edge.u + edge.v - u        if (d[v] <= d[u] + edge.w)          continue        q.remove(v)        d[v] = d[u] + edge.w        prev[v] = edge        q.add(v)      }    }    if (needOpt && d[t] > len || !needOpt && d[t] >= len)      return null    val path = mutableListOf<Edge>()    var cur = t    while (cur != s) {      val edge = prev[cur]!!      path.add(edge)      cur = edge.u + edge.v - cur    }    return Pair(path, d[t])  }   if (dejkstra(false) != null) {    fout.println(""NO"")    fout.close()    return  }   val pair = dejkstra(true)  if (pair == null) {    fout.println(""NO"")    fout.close()    return  }   fout.println(""YES"")   val (path, num) = pair  for (e in list)    if (e.opt)      e.w = 1000*1000*1001  for (e in path)    if (e.opt)      e.w = 1  for (e in path)    if (e.opt) {      e.w = (len - num + 1).toLong()      break    }   while (true) {    val pair = dejkstra(true)!!    val (path, num) = pair    if (num == len)      break    for (e in path)      if (e.opt) {        e.w = (len - num + 1).toLong()        break      }  }  for (e in list)    fout.format(""%d %d %d\n"", e.u, e.v, e.w)  fin.close()}","binary search,constructive algorithms,graphs,shortest paths"
"fun main(args: Array<String>) {    val n = readLine()!!.toInt()    (readLine()!! + "" 0"").split(' ').map(String::toInt).reduce { last, it ->        print(""${last + it} "")        it    }}","implementation,math"
"fun main(args: Array<String>) {    val n = readLine()!!.toInt()    (readLine()!! + "" 0"").split(' ').map(String::toInt).reduce { last, it ->        print(""${last + it} "")        it    }}","implementation,math"
"fun main() {    val r = System.`in`.bufferedReader()    val sb = StringBuilder()    val n = r.readLine().toInt()    val v = r.readLine().split("" "").map { it.toLong() }    val q = List(n-1){v[it]+v[it+1]}    sb.appendln((q+v[n-1]).joinToString("" ""))    print(sb)}","implementation,math"
"import java.io.BufferedReaderimport java.io.InputStreamReader fun main() {    val iin = BufferedReader(InputStreamReader(System.`in`))    val n = iin.readLine().toInt()    val a = iin.readLine().split("" "").map{it.toLong()} + listOf(0L)    val ans = LongArray(n){a[it] + a[it + 1]}    println(ans.joinToString("" ""))}","implementation,math"
"fun main() {    val (n, m) = readLine()!!.split("" "").map(String::toInt)    val colors = (1..n).any { i ->        readLine()!!.split("" "").count { it in setOf (""C"", ""M"", ""Y"") } > 0    }    print(if (colors) ""#Color"" else ""#Black&White"")}",implementation
"//package tasks fun main() {    val (n, _) = readLine()!!.split(' ').map { it.toInt() }    repeat(n) {        if (readLine()!!.any { it in ""CYM"" }) {            println(""#Color"")            return        }    }    println(""#Black&White"")}",implementation
"fun main() {    val (n, _) = readLine()!!.split("" "").map { it.toInt() }    var ans = 0    repeat(n) {        val a = readLine()!!.split("" "")        if (""C"" in a || ""M"" in a || ""Y"" in a) ans++    }    println(if (ans > 0) ""#Color"" else ""#Black&White"")}",implementation
"fun main(args: Array<String>) {    val n = readLine()!!.split("" "").map(String::toInt)    var f=true     for (i in 1..n[0]) {        if (!readLine()!!.split("" "").all { c -> c ==""W""||c==""B"" || c==""G"" }) f=false    }     if (f) print(""#Black&White"")    else print(""#Color"")}",implementation
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min /** * @param n 個数 最大値じゃないぞ。 * iの範囲は[0, n - 1] * * AがIntやLongのときは埋め込んでしまおう * type A = Int */class RangeUpdateTree(n: Int) {  private val N =    if (Integer.highestOneBit(n) == n) n    else Integer.highestOneBit(n) shl 1   private val zero = 0  private inline fun f(a: Int, b: Int) = a xor b   private val dat = IntArray(2 * N){zero}   //  private inline fun f(a: Int, b: Int) = a + b   /**   * [l, r)   */  fun add(l: Int, r: Int, a: Int) {    var left = l + N    var right = r - 1 + N     while(left <= right) {      if ((left and 1) == 1) dat[left] = f(dat[left], a)      if ((right and 1) == 0) dat[right] = f(dat[right], a)      left = (left + 1) shr  1 // 右の子供なら右の親に移動      right = (right - 1) shr 1 // 左の子供なら左の親に移動    }  }   fun query(i: Int): Int {    var ix = N + i    var res: Int = zero     while(ix >= 1) {      res = f(res, dat[ix])      ix = ix shr 1    }     return res  }} data class Query(val id: Int, val l: Int, val r: Int)class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  fun solve() {    val N = ni()    val A = na(N)    val Q = Array(ni()){Query(it, ni() - 1, ni() - 1)}    val xor = RangeUpdateTree(N)    val unq = RangeUpdateTree(N)    val qByR = Array(N){ mutableListOf<Query>()}    for (q in Q) {      qByR[q.r].add(q)    }     val ans = IntArray(Q.size)    val lst = mutableMapOf<Int, Int>()    for (i in 0 until N) {      val j = (lst[A[i]] ?: -1) + 1      unq.add(j, i + 1, A[i])      xor.add(0, i + 1, A[i])       val qs = qByR[i]      for (k in qs.indices) {        val q = qs[k]        ans[q.id] = xor.query(q.l) xor unq.query(q.l)      }       lst[A[i]] = i    }     for (a in ans) {      out.println(a)    }  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private val reader = BufferedReader(InputStreamReader(stream), 32768)  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return map(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun map(n: Int, f: (Int) -> Int): IntArray {    val res = IntArray(n)    for (i in 0 until n) {      res[i] = f(i)    }    return res  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: BooleanArray) {    debug { a.map { if (it) 1 else 0 }.joinToString("""") }  }   private fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}",data structures
"import java.io.BufferedReaderimport java.io.BufferedWriterimport java.io.InputStreamReaderimport java.io.OutputStreamWriterimport kotlin.math.absimport kotlin.math.maximport kotlin.math.min val reader = BufferedReader(InputStreamReader(System.`in`))val writer = BufferedWriter(OutputStreamWriter(System.`out`)) fun readLine() = reader.readLine()fun readIntList() = reader.readLine().split(' ').map(String::toInt)fun readLongList() = reader.readLine().split(' ').map(String::toLong)fun readStringList() = reader.readLine().split(' ')fun readInt() = reader.readLine().toInt()fun readLong() = reader.readLine().toLong()fun readDouble() = reader.readLine().toDouble() fun main(args: Array<String>) { //    val t = readInt()//    (1..t).forEach {//        solve()//    }    solve() } fun solve() {    val (n, m) = readIntList()    val a = readIntList()    val b = readIntList()     var aIndex = 0    var bIndex = 0    b.forEachIndexed { index, elem ->        if (abs(elem - a[0]) <= abs(a[0] - b[bIndex]))            bIndex = index    }     var max = 0    while (aIndex < n){        while (bIndex + 1 < m && abs(a[aIndex] - b[bIndex]) >= abs(a[aIndex] - b[bIndex + 1]))            bIndex ++         max = max(max , abs(a[aIndex] - b[bIndex]))         aIndex ++    }  //    println(""$aIndex $bIndex"")    println(max)}","binary search,implementation,two pointers"
"fun main() {    val (start, interval, desired) = readLine()!!.split("" "").map(String::toLong)    if (desired < start) return print(""NO"")    if (desired == start) return print(""YES"")    print(if ((desired - (start + interval)) % interval in setOf(0L, 1L)) ""YES"" else ""NO"")}","implementation,math"
"fun main() {    val r = System.`in`.bufferedReader()    val sb = StringBuilder()    var (t, s, x) = r.readLine().split("" "").map { it.toInt() }    x -= t    sb.appendln(if (x==0||(x>=s&&(x%s==0||x%s==1))) ""YES"" else ""NO"")    print(sb)} /*// Hakiobo's code for faster reading inputprivate const val SPACE_INT = ' '.toInt()private const val ZERO_INT = '0'.toInt()private const val NL_INT = '\n'.toInt() private fun BufferedReader.readInt(): Int {    var ret = read()    while (ret <= SPACE_INT) {        ret = read()    }    val neg = ret == '-'.toInt()    if (neg) {        ret = read()    }    ret -= ZERO_INT    var read = read()    while (read >= ZERO_INT) {        ret *= 10        ret += read - ZERO_INT        read = read()    }     while (read <= SPACE_INT && read != -1 && read != NL_INT) {        mark(1)        read = read()    }    if (read > SPACE_INT) {        reset()    }    return if (neg) -ret else ret}*/","implementation,math"
"import kotlin.math.* fun main() {    val (t, s, x) = readInts()     if ((x-t)%s == 0) {        when {            t > x -> println(""NO"")            else -> println(""YES"")        }    } else if ((x-t-1)%s == 0) {        when {            t > x -> println(""NO"")            x - t - 1 == 0 -> println(""NO"")            else -> println(""YES"")        }    } else {        println(""NO"")    }} private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readLong() = readLn().toLong() // single longprivate fun readDouble() = readLn().toDouble() // single doubleprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of intsprivate fun readLongs() = readStrings().map { it.toLong() } // list of longsprivate fun readDoubles() = readStrings().map { it.toDouble() } // list of doublesprivate fun Long.pow(x: Long): Long {    var res = 1L    var a = this    var b = x    while(b > 0) {        if (b%2 == 1L) {            res *= a        }        a *= a        b = b shr 1    }    return res}private fun Long.powMod(x: Long, mod: Long): Long {    var res = 1L    var a = this%mod    var b = x    while(b > 0) {        if (b%2 == 1L) {            res = res*a % mod        }        a = a * a % mod        b = b shr 1    }    return res}private fun Long.factors(): List<Long> {    var q = listOf<Long>()    for (i in 1..sqrt(this.toDouble()).toLong()) {        if (this%i == 0L) {            q += i            q += this/i        }    }    return q}private fun gcd(first: Long, second: Long): Long {    var q = first    var p = second    while(q != 0L) {        p = q.apply { q = p%q } // swap function    }    return p}private fun Long.isCoPrime(x: Long): Boolean {    return gcd(this, x) == 1L}private fun String.sortString(): String {    val arr = this.toCharArray()    return arr.sorted().joinToString("""")}private fun unique(list: List<Long>): List<Long> {    var x = list.toSet()    return x.toList()}","implementation,math"
"fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val (numRows, _) = readInts()    for (i in 1 until numRows) readLine()    var sol = 0    var block = false    for (c in readLine()!!) {        if (c == 'B' && !block) {            block = true            sol++        }        else if (c == '.' && block) block = false    }    print(sol)}",
"import kotlin.math.max fun main() {    fun readLongs() = readLine()!!.split("" "").map(String::toLong)     val (_, gramsPowder) = readLongs()    val recipeGrams = readLongs()    val availableGrams = readLongs()    val maxCookies = (availableGrams.sum() + gramsPowder) / recipeGrams.sum()    var left = 0L    var right = maxCookies    var middle: Long    loop@ while (left < right) {        middle = (left + right) / 2        val requiredPowder =            availableGrams.asSequence().mapIndexed { index, avGrams -> max(0, recipeGrams[index] * middle - avGrams) }                .sum()        when {            requiredPowder == gramsPowder -> {                left = middle                break@loop            }            requiredPowder > gramsPowder -> right = middle - 1            else -> left = middle + 1        }    }    if (availableGrams.asSequence().mapIndexed { index, avGrams -> max(0, recipeGrams[index] * left - avGrams) }            .sum() <= gramsPowder || left == 0L) print(left) else print(left - 1)}","binary search,brute force,implementation"
"/*     Author: Aman Patel    Date: 07-09-2021*/ import java.io.PrintWriterimport java.util.StringTokenizerimport java.io.File private val checkOnlineJudge = System.getProperty(""ONLINE_JUDGE"") == nullprivate val INPUT = if (checkOnlineJudge) File(""src/input.txt"").inputStream() else System.`in`private val OUTPUT = if (checkOnlineJudge) File(""src/output.txt"").outputStream() else System.out private val bufferedReader = INPUT.bufferedReader()private val out = PrintWriter(OUTPUT, false)private fun readLn() = bufferedReader.readLine()!! private fun readList() = readLn().split(' ')private var tokenizer = StringTokenizer("""")private fun read(): String {    while (tokenizer.hasMoreTokens().not()) tokenizer = StringTokenizer(readLn(), "" "")    return tokenizer.nextToken()} private fun readInt() = read().toInt()private fun readLong() = read().toLong()private fun readDouble() = read().toDouble() private fun readIntList() = readList().map { it.toInt() }private fun readLongList() = readList().map { it.toLong() }private fun readDoubleList() = readList().map { it.toDouble() } private fun readIntArray(n: Int = 0) =    if (n == 0) readList().run { IntArray(size) { get(it).toInt() } } else IntArray(n) { readInt() } private fun readLongArray(n: Int = 0) =    if (n == 0) readList().run { LongArray(size) { get(it).toLong() } } else LongArray(n) { readLong() } private fun readDoubleArray(n: Int = 0) =    if (n == 0) readList().run { DoubleArray(size) { get(it).toDouble() } } else DoubleArray(n) { readDouble() } private class MagicPowder1 {    fun solveTestCase() {        //TODO: Solve the question         val (n, k) = readIntList()        val required = readIntArray(n)        val available = readIntArray(n)         fun check(cookies: Int): Boolean {            val tempAva = available.clone()            var tempK = k            var madeSoFar = 0            var flag = true            while (flag) {                 for (i in 0 until n) {                    if (tempAva[i] >= required[i]) {                        tempAva[i] -= required[i]                    } else {                        val x = required[i] - tempAva[i]                        if (tempK >= x) {                            tempAva[i] = 0                            tempK -= x                        } else {                            flag = false                            break                        }                    }                }                 if (!flag)                    break                 madeSoFar += 1            }             return (madeSoFar >= cookies)        }         var (l, r) = listOf(0, 2005)        while (r - l > 1) {            val mid = l + ((r - l) / 2)            if (check(mid))                l = mid            else                r = mid        }         val result = if (check(r)) r else l        out.println(result)    }} fun main(args: Array<String>) {     var t = 1    //t = readInt()    repeat(t) {        //TODO: Read in each Test Case         MagicPowder1()            .solveTestCase()    }     out.flush()}","binary search,brute force,implementation"
"import java.io.*import java.util.*import kotlin.math.* val INPUT = System.`in`!!val OUTPUT = System.out!!const val mod : Long = 998_244_353const val mini = Int.MIN_VALUEconst val maxi = Int.MAX_VALUEval reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun line() = reader.readLine()!!var tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (tokenizer.hasMoreTokens().not()) tokenizer = StringTokenizer(reader.readLine() ?: return """", "" "")    return tokenizer.nextToken()}fun sort(a: IntArray) {    val l = ArrayList<Int>()    for (value in a) {        l.add(value)    }    l.sort()    for (i in l.indices) a[i] = l[i]}fun sort(a: LongArray) {    val l = ArrayList<Long>()    for (value in a) {        l.add(value)    }    l.sort()    for (i in l.indices) a[i] = l[i]}fun int() = read().toInt()fun double() = read().toDouble()fun long() = read().toLong()fun strings(n: Int) = List(n) { read() }fun lines(n: Int) = List(n) { line() }fun ints(n: Int) = List(n) { read().toInt() }fun intArray(n: Int) = IntArray(n) { read().toInt() }fun doubles(n: Int) = List(n) { read().toDouble() }fun doubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun longs(n: Int) = List(n) { read().toLong() }fun longArray(n: Int) = LongArray(n) { read().toLong() }val writer = PrintWriter(OUTPUT, true)fun main() { writer.solve(); writer.flush() }fun gcd(a : Int, b : Int) : Int {    if(b == 0) return a    return gcd(b, a % b)}fun ceil(a : Long, b : Long) : Long {    return if (a % b == 0L) a / b else (a / b) + 1}class Pair(var a : Int, var b : Int) {    override fun toString(): String {        return ""Pair(a=$a, b=$b)""    }}fun PrintWriter.solve() {    // var tt = int()    var tt = 1    while(tt-- > 0) {        var (n, k) = ints(2)        val arr = intArray(n)        val brr = intArray(n)        val comp = Comparator<Pair> {a, b ->            when {                else -> (a.a - b.a)            }        }        val pq = PriorityQueue(comp)        for(i in 0 until n) {            pq.add(Pair(brr[i] / arr[i], i))        }        val rem = IntArray(n)        for(i in 0 until n) {            rem[i] = brr[i] % arr[i]        }        //println(rem.contentToString())        //println(pq)        while(k > 0) {            val p = pq.poll()            val x = arr[p.b] - rem[p.b]            //println(""$k $x $p"")            if(k >= x) {                k -= x                p.a++                rem[p.b] = 0            }            else {                pq.add(p)                break            }            pq.add(p)        }        println(pq.poll().a)    }}","binary search,brute force,implementation"
"import java.io.*import java.util.*import kotlin.math.* val INPUT = System.`in`!!val OUTPUT = System.out!!const val minl = Long.MIN_VALUEconst val maxl = Long.MAX_VALUEval reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun line() = reader.readLine()!!var st: StringTokenizer = StringTokenizer("""")fun read(): String {    while (st.hasMoreTokens().not())        st = StringTokenizer(reader.readLine() ?: return """", "" "")    return st.nextToken()}fun int() = read().toInt()fun ints(n: Int) = List(n) { read().toInt() }fun intArray(n: Int) = IntArray(n) { read().toInt() }fun long() = read().toLong()fun longs(n: Int) = List(n) { read().toLong() }fun longArray(n: Int) = LongArray(n) { read().toLong() }val writer = PrintWriter(OUTPUT, false)fun main() { writer.solve(); writer.flush() }var k = 0Lfun calc(arr : LongArray, brr : LongArray, x : Long) : Long {    var count = 0L    for(i in arr.indices) {        count += max(0, x * arr[i] - brr[i])        if(count > k) return maxl    }    return count}fun PrintWriter.solve() {    var tt = 1    //tt = int()    while (tt-- > 0) {        val n = int()        k = long()        val arr = longArray(n)        val brr = longArray(n)        var l = 0L; var h = 2_000_000_000L        var ans = 0L        while(l <= h) {            val mid = (l + h) / 2            val needed = calc(arr, brr, mid)            if(needed <= k) {                ans = mid                l = mid + 1            }            else h = mid - 1            //println(""$needed $l $h"")        }        println(ans)     }}","binary search,brute force,implementation"
"private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of ints fun main() {    val s = readLn().toCharArray()    for (i in 1 until s.size) {        if (s[i] == s[i - 1]) {            for (c in 'a'..'z') {                if (s[i - 1] != c && (i < s.size - 1 && s[i + 1] != c || i == s.size - 1)) {                    s[i] = c                }            }        }    }    val x = s.joinToString(separator = """")    println(x)} ","dp,greedy,strings"
"fun main(args: Array<String>) {    val s = readLine()!!.toCharArray()    var ans = s    var alf = ""abcdefghijklmnopqrstuvwxyz"".toCharArray()    fun replaceFree(index: Int) {        for (r in alf) {            if (r != s[index] && r != s[index+1] && r != s[index-1]) {                ans[index] = r                break            }        }    }    if (s.size == 1) {        println(s[0])        return    }    if (s.size == 2) {        if (s[0] == s[1]) {            for (r in alf) {                if (r != s[0]) {                    s[1] = r                    break                }            }        }        println(""${s[0]}${s[1]}"")        return    }    for (i in 2 until s.size) {        val a = s[i-2]        val b = s[i-1]        val c = s[i]        if (a == b && b != c) {            replaceFree(i-1)        }        if (a == c && b != c) {            //replaceFree(i-1)        }        if (a == c && b == c) {            replaceFree(i-1)        }        if (a != c && b == c) {            if (i < s.size - 1)                replaceFree(i)            else {                replaceFree(i-1)            }        }    }    ans.joinToString { it -> it.toString() }    println(ans)}","dp,greedy,strings"
"import com.sun.xml.internal.fastinfoset.util.StringArrayimport java.io.*import java.math.BigIntegerimport java.util.*import kotlin.collections.ArrayListimport kotlin.math.maximport kotlin.math.min class InputReader(stream: InputStream) {    var reader: BufferedReader = BufferedReader(InputStreamReader(stream))    var tokenizer = StringTokenizer("""")    /** get next word  */    @Throws(IOException::class)    operator fun next(): String {        while (!tokenizer.hasMoreTokens()) {            //TODO add check for eof if necessary            tokenizer = StringTokenizer(                reader.readLine()            )        }        return tokenizer.nextToken()    }    fun nextLong() = next().toLong()    fun nextInt() = next().toInt()    fun nextDouble() = next().toDouble()    fun nextFloat() = next().toFloat()} fun main() {    val cin = InputReader(System.`in`)    var str = cin.next()    val n = str.length    str = str + ""#""    val res = str.toCharArray()    for (i in 1 until n) {        if (res[i] == res[i - 1]) {            for (j in 0 until 26) {                val c = 'a' + j                if (c != res[i - 1] && res[i + 1] != c ) {                    res[i] = c                    break;                }            }         }    }    val printWriter = PrintWriter(System.out)    for (i in 0 until n) {        printWriter.print(res[i])    }    printWriter.flush()} 				  	 	   	   	  	   			 			","dp,greedy,strings"
"import java.io.*import java.util.* fun main() {    solve(System.`in`, System.out)} fun solve(input: InputStream, output: OutputStream) {    val reader = Reader(input) //Reader(FileInputStream(File(""portals.in"")))    val writer = PrintWriter(BufferedOutputStream(output)) //PrintWriter(FileOutputStream(File(""output.txt"")))     solve(reader, writer)    writer.close()} fun solve(ir : Reader, pw : PrintWriter) {     val n = ir.next().toCharArray()     for (i in 1 until (n.size - 1)) {        var c = n[i]        if (c == n[i - 1] && c == n[i + 1]) {            val c1 = n[i - 1]            val c2 = n[i + 1]            c = 'a'            while (c == c2 && c == c1)                c += 1        }        n[i] = c    }     for (i in 1 until n.size) {        var c = n[i]        if (c == n[i - 1]) {            val c1 = n[i - 1]            val c2 = if (i < n.size - 1)                n[i + 1]            else                c            c = 'a'            while (c == c2 || c == c1)                c += 1        }        n[i] = c    }     pw.print(String(n)) } class Reader(stream: InputStream) {    private val reader: BufferedReader = BufferedReader(InputStreamReader(stream), 32768)    private var tokenizer: StringTokenizer? = null     init {        tokenizer = null    }     operator fun next(): String {        while (tokenizer == null || !tokenizer!!.hasMoreTokens())            try {                tokenizer = StringTokenizer(reader.readLine())            } catch (e: IOException) {                throw RuntimeException(e)            }         return tokenizer!!.nextToken()    }     fun nextLine(): String? {        val fullLine: String        while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {            try {                fullLine = reader.readLine()            } catch (e: IOException) {                throw RuntimeException(e)            }             return fullLine        }        return null    }     fun toArray(): Array<String> {        return nextLine()!!.split("" "".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()    }     fun nextInt(): Int {        return Integer.parseInt(next())    }     fun nextDouble(): Double {        return java.lang.Double.parseDouble(next())    }     fun nextLong(): Long {        return java.lang.Long.parseLong(next())    } }","dp,greedy,strings"
"fun main() {    val line = readLine()!!    var parts = ""(\\?|\\+|-|=|\\d+)"".toRegex().findAll(line).map { it.value }.toMutableList()    val n = parts.last().toInt()    val nums = parts.count { it == ""?"" }    val negs = parts.count { it == ""-"" }    val poss = nums - negs    val max = poss * n - negs    val min = poss - n * negs    if (n !in min..max) {        println(""Impossible"")    } else {        println(""Possible"")        parts = parts.map { if (it == ""?"") ""1"" else it }.toMutableList()        var dist = n + negs - poss        var i = 0        while (dist != 0 && i < parts.size - 2) {            if (dist < 0 && i > 0 && parts[i - 1] == ""-"") {                val d = maxOf(-n + 1, dist)                dist -= d                parts[i] = (parts[i].toInt() - d).toString()            } else if (dist>0 && (i == 0 || parts[i-1] == ""+"")){                val d = minOf(n - 1, dist)                dist -= d                parts[i] = (parts[i].toInt() + d).toString()            }            i += 2        }        println(parts.joinToString("" ""))    }}","constructive algorithms,expression parsing,greedy,math"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.lang.AssertionErrorimport java.lang.StringBuilderimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min import javax.script.ScriptEngineManager    val MOD = 1_000_000_007 class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  private val reader = BufferedReader(InputStreamReader(stream), 32768)   fun solve() {    val S = readLine()!!    val N = S.drop(S.indexOf('=') + 1).trim().toInt()    var lstSign = '+'    var plusCnt = 0    var minusCnt = 0    for (i in S.indices) {      when(S[i]) {        '+', '-' -> lstSign = S[i]        '?' -> if (lstSign == '+') plusCnt++ else minusCnt++        else -> {}      }    }    var need = N - (plusCnt - minusCnt)     lstSign = '+'    val str = StringBuilder()    for (c in S) {      when(c) {        '+', '-' -> {          lstSign = c          str.append(c)        }        '?' -> {          if (lstSign == '+') {            val add = max(0, min(need, N - 1))            need -= add            str.append(1 + add)          }          else {            val minus = max(0, min(-need, N - 1))            need += minus            str.append(1 + minus)          }        }        else -> str.append(c)      }    }     val ans = str.toString()    debug{""N:$N ans:$ans""}    if (eval(ans.take(ans.indexOf('='))) != N.toLong()) {      out.println(""Impossible"")    }    else {      out.println(""Possible"")      out.println(str)    }  }   fun eval(equation: String): Long {    val mgr = ScriptEngineManager()    val engine = mgr.getEngineByName(""JavaScript"")    return engine.eval(equation).toString().toLong()  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return IntArray(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private inline fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: BooleanArray) {    debug { toString(a) }  }   private inline fun toString(a: BooleanArray) = run{a.map { if (it) 1 else 0 }.joinToString("""")}   private inline fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<BooleanArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }   private inline fun assert(b: Boolean) = run{if (!b) throw AssertionError()}} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","constructive algorithms,expression parsing,greedy,math"
"import java.io.*import java.util.* fun <T : Comparable<T>> max(a: T, b: T): T = if (b > a) b else afun <T : Comparable<T>> min(a: T, b: T): T = if (b < a) b else afun Number.isEven(): Boolean = this.toInt() and 1 == 0fun Number.isOdd (): Boolean = this.toInt() and 1 == 1 class OutputWriter(val stream: OutputStream) {    val buf = ByteArray(65535)    var curPos: Int = 0     fun write(c: Char) {        if (buf.size - curPos < 1) flush()        buf[curPos++] = c.toByte()    }     fun write(s: String) {        if (buf.size - curPos < s.length) flush()        var idx = 0        var remaining = s.length        while (remaining > buf.size) {            while (curPos < buf.size) buf[curPos++] = s[idx++].toByte()            flush()            remaining -= buf.size        }        while (idx < s.length) buf[curPos++] = s[idx++].toByte()    }     fun flush() {        stream.write(buf, 0, curPos)        curPos = 0    }} class InputReader(val stream: InputStream) {    val buf = ByteArray(1024)    var curChar: Int = 0    var numChars: Int = 0     fun read(): Int {        if (numChars == -1)            throw InputMismatchException()        if (curChar >= numChars) {            curChar = 0            try {                numChars = stream.read(buf)            } catch (e: IOException) {                throw InputMismatchException()            }            if (numChars <= 0)                return -1        }        return buf[curChar++].toInt()    }     fun nextInt(): Int {        var c = read()        while (isSpaceChar(c))            c = read()        var sgn = 1        if (c == 45) {            sgn = -1            c = read()        }        var res = 0        do {            if (c < 48 || c > 57)                throw InputMismatchException()            res *= 10            res += c and 15            c = read()        } while (!isSpaceChar(c))        return res * sgn    }     fun nextLong(): Long {        var c = read()        while (isSpaceChar(c))            c = read()        var sgn = 1        if (c == 45) {            sgn = -1            c = read()        }        var res: Long = 0        do {            if (c < 48 || c > 57)                throw InputMismatchException()            res *= 10            res += c and 15            c = read()        } while (!isSpaceChar(c))        return res * sgn    }     fun nextToken(): String {        var c = read()        while (isSpaceChar(c))            c = read()        val res = StringBuilder()        do {            res.appendCodePoint(c)            c = read()        } while (!isSpaceChar(c))        return res.toString()    }     fun isSpaceChar(c: Int): Boolean {        return c == 32 || c == 10 || c == 13 || c == 9 || c == -1    }} fun main(args: Array<String>) {    if (args.isNotEmpty()) System.setIn(FileInputStream(args[0]))    val ir = InputReader(System.`in`)    val ow = OutputWriter(System.out)     val n = ir.nextInt()    val m = ir.nextInt()    val q = ir.nextInt()    val arr = Array(n) { IntArray(m) }    val ops = Array(q) { IntArray(4) }    for (i in ops.indices) {        ops[i][0] = ir.nextInt()        if (ops[i][0] < 3) {            ops[i][1] = ir.nextInt()        } else {            ops[i][1] = ir.nextInt()            ops[i][2] = ir.nextInt()            ops[i][3] = ir.nextInt()        }    }     for (i in ops.indices.reversed()) {        if (ops[i][0] == 3)            arr[ops[i][1] - 1][ops[i][2] - 1] = ops[i][3]        else if (ops[i][0] == 1) {            val tmp = arr[ops[i][1] - 1][m - 1]            for (j in m-1 downTo 1) arr[ops[i][1] - 1][j] = arr[ops[i][1] - 1][j - 1]            arr[ops[i][1] - 1][0] = tmp        } else {            val tmp = arr[n - 1][ops[i][1] - 1]            for (j in n-1 downTo 1) arr[j][ops[i][1] - 1] = arr[j - 1][ops[i][1] - 1]            arr[0][ops[i][1] - 1] = tmp        }    }     for (i in arr.indices) {        for (j in arr[0].indices) {            ow.write(""${arr[i][j]} "")        }        ow.write('\n')    }    ow.flush()}",implementation
"import kotlin.math.absimport kotlin.math.min fun main() {    val (n, m) = readLine()!!.split("" "").map { it.toInt() }    val pancakes = readLine()!!.split("" "").map { it.toInt() }.reversed()    val dp = Array(n + 1) { Array(m + 1) { IntArray((4 * m) + 1) { 2 * n * m } } }    dp[0][0][2 * m] = 0    for (j in 1..n) {        val stack = pancakes[j - 1]        for (k in 0..m) {            for (d in 0..4 * m) {                val nd = d + (stack - k)                if (nd in 0..4 * m) {                    dp[j][k][nd] = dp[j - 1][k][d]                }            }        }        for (k in 0 until m) {            for (d in 1..4 * m) {                dp[j][k + 1][d - 1] = min(dp[j][k + 1][d - 1], dp[j][k][d])            }        }        for (k in 0..m) {            for (d in 0..4 * m) {                dp[j][k][d] += abs(d - (2 * m))            }        }    }    println(dp[n].map { it[2 * m] }.min()!!)}",dp
"// 2022-05-5, Thu, 22:35import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.math.absoluteValueimport kotlin.system.measureTimeMillis // 1. Moddedconst val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}infix fun Int.modM(b:Int):Int{ return ((this.toLong() * b) % pI).toInt() }infix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }fun intPow(x:Int,e:Int,m:Int):Int{    var X = x ; var E =e ; var Y = 1    while(E > 0){        if(E and 1 == 0){            X = ((1L * X * X) % m).toInt()            E = E shr 1        }else{            Y = ((1L * X * Y) % m).toInt()            E -= 1        }    }    return Y}// 2. DP initial valuesconst val plarge = 1_000_000_727const val nlarge = -plargeconst val phuge = 2_727_000_000_000_000_000Lconst val nhuge = -phuge// 3. conveniecen conversionsval Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionval Char.code :Int get() = this.toInt() -  'a'.toInt()//3. hard to write stufffun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val mint:MutableList<Int> get() = mutableListOf<Int>()val mong:MutableList<Long> get() = mutableListOf<Long>()//4. more outputsfun List<Char>.conca():String = this.joinToString("""")val CharArray.conca :String get() = this.joinToString("""")val IntArray.conca :String get() = this.joinToString("" "")@JvmName(""concaInt"")fun List<Int>.conca():String = this.joinToString("" "")val LongArray.conca:String get() = this.joinToString("" "")@JvmName(""concaLong"")fun List<Long>.conca():String = this.joinToString("" "")//5. Pair of intsconst val longmask = (1L shl 32) - 1fun makepair(a:Int, b:Int):Long = (a.toLong() shl 32) xor (longmask and b.toLong()) // remember positev sonlyval Long.first get() = (this ushr 32).toInt()val Long.second get() = this.toInt()//6. stringsval String.size get() = this.lengthconst val randCount = 100//7. bitsfun Int.has(i:Int):Boolean = (this and (1 shl i) != 0)//8 TIMEinline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")}object Reader{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""Custom test enabled"")            println(""Custom test enabled"")            warningActive = false        }        val S = fakein.toString()        println(""New Case "")        println(S.take(80))        println(""..."")        fakein.clear()        IN = BufferedInputStream(S.byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ Reader.OUT.println(aa)}fun done(){ Reader.OUT.close() }fun share(aa:Any){    if(aa is IntArray){Reader.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){Reader.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){Reader.fakein.append(aa.toString())}    else{Reader.fakein.append(aa.toString())}    Reader.fakein.append(""\n"")} val getintfast:Int get() = Reader.nextInt()val getint:Int get(){ val ans = getlong ; if(ans > Int.MAX_VALUE) IntArray(1000000000); return ans.toInt() }val getlong:Long get() = Reader.nextLong()val getstr:String get() = Reader.nextString()fun getline(n:Int):IntArray{    return IntArray(n){getint}}fun getlineL(n:Int):LongArray{    return LongArray(n){getlong}}var dmark = -1infix fun Any.dei(a:Any){    dmark++    var str = ""<${dmark}>   ""    debug()    if(this is String){ str += this    }else if(this is Int){ str += this.toString()    }else if(this is Long){ str += this.toString()    }else{ str += this.toString()}    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is BooleanArray){ println(""$str :${a.map{if(it)'1' else '0'}.joinToString("" "")}"")    }else if(a is Array<*>){        println(""$str : "")        for(c in a){if(c is IntArray){println(c.joinToString("" ""))}        else if(c is LongArray){println(c.joinToString("" ""))}        else if(c is BooleanArray){println(c.map { if(it) '1' else '0' }.joinToString(""""))        }        }        println()    }else{ println(""$str : $a"")    }}val just = "" ""fun crash(){    throw Exception(""Bad programme"")}fun assert(a:Boolean){    if(!a){        throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var tn:Long = 0    fun cases(onecase:()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint} else if(mode == solveMode.tc){1 } else randCount        if(pI != 998_244_353 && pI != 1_000_000_007){            throw Exception(""Not usual primes!"")        }        if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                Reader.rerouteInput()            }else if(mode == solveMode.rand){                rand()                Reader.rerouteInput()            }            onecase()        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }}class rsq(val arr:List<Int>) {    val ps = LongArray(arr.size + 1)    init{        for(i in 0 until arr.size){            ps[i+1] = ps[i] + arr[i]        }    }    fun sumQuery(l:Int,r:Int):Long{        val ll = maxOf(l,0)        val rr = minOf(arr.lastIndex,r) + 1        return ps[rr] - ps[ll]    }}class rsqArr(val arr:IntArray) {    val ps = LongArray(arr.size + 1)    init{        for(i in 0 until arr.size){            ps[i+1] = ps[i] + arr[i]        }    }    fun sumQuery(l:Int,r:Int):Long{        val ll = maxOf(l,0)        val rr = minOf(arr.lastIndex,r) + 1        return ps[rr] - ps[ll]    }}fun IntArray.torsq(): rsqArr {    return rsqArr(this)}fun List<Int>.torsq():rsq{    return rsq(this)}fun debug(){}const val singleCase = truefun main(){    solve.cases{        val n = getint        val m = getint        val L = getline(n)        L.reverse()        //last, total        var DP = Array(m+1){IntArray(m+1){plarge} }        DP[0][0] = 0        var snow = 0        for(a in L) {            snow += a            val new = Array(m+1){IntArray(m+1){plarge} }            for(last in 0..m){                for(total in 0..m){                    val here = DP[last][total]                    val v = last                    if(total + v > m) continue                    val cost = here + (total + v - snow).absoluteValue                    new[last][total + v ] = minOf(new[last][total + v ], cost)                    if(last < m) {                        DP[last + 1][total] = minOf(DP[last + 1][total], here)                    }                }            }            DP = new        }        var ret = plarge        for(last in 0..m){            ret = minOf(ret, DP[last][m])        }        put(ret)        }    done()}   ",dp
"import java.io.BufferedReaderimport java.io.InputStreamReader fun binExp(a: Long, n: Long): Long{    tailrec fun go(a: Long, n: Long, a1: Long): Long{        if (n == 0.toLong()) return 1        if (n == 1.toLong()) return a * a1         if (n % 2 == 0.toLong()) return go(a * a, n/2, a1)        else return go(a * a, (n - 1)/2, a * a1)    }    return go(a, n, 1)} fun main(args: Array<String>) {    val br = BufferedReader(InputStreamReader(System.`in`))    val n = br.readLine().toInt()    val x1 = 4*3* binExp(4, (n - 3).toLong())*2    val x2 = if (n > 3) 4*3*3* binExp(4, (n - 4).toLong())*(n - 3) else 0    println(x1 + x2)}","combinatorics,math"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.lang.AssertionErrorimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007 class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  private val reader = BufferedReader(InputStreamReader(stream), 32768)   private val N = nl()  fun solve() {    var ans = 0L    val all = 2*N - 2    if (N > 3) {      var v = 4L*3*3      for (i in 0 until all-N-2) {        v *= 4      }      ans += v*(all-N-1)    }     var v = 4L*3    for (i in 0 until all-N-1) {      v *= 4    }    ans += v*2    out.println(ans)  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return IntArray(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private inline fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: BooleanArray) {    debug { toString(a) }  }   private inline fun toString(a: BooleanArray) = run{a.map { if (it) 1 else 0 }.joinToString("""")}   private inline fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<BooleanArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }   private inline fun assert(b: Boolean) = run{if (!b) throw AssertionError()}} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","combinatorics,math"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.lang.AssertionErrorimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007 class SegmentTreeL(n: Int, val zero: Long) {  /**   * 3e5回以上呼ばれるようだとinlineしたほうがいいかも   * Long::plusは結構遅い   *///  private val zero = 0L  private inline fun f(a: Long, b: Long) = a + b  private val N =    if (Integer.highestOneBit(n) == n) n    else Integer.highestOneBit(n) shl 1   private val dat = LongArray(2 * N){zero}   fun update(i: Int, a: Long) {    var ix = i + N    dat[ix] = a    while(ix > 1) {      dat[ix shr 1] = f(dat[ix], dat[ix xor 1])      ix = ix shr 1    }  }   /**   * [a, b)   */  fun query(a: Int, b: Int): Long {    var res: Long = zero    var left = a + N    var right = b - 1 + N     while(left <= right) {      if ((left and 1) == 1) res = f(res, dat[left])      if ((right and 1) == 0) res = f(res, dat[right])      left = (left + 1) shr 1 // 右の子供なら右の親に移動      right = (right - 1) shr 1 // 左の子供なら左の親に移動    }     return res  }   // 条件を満たすか。maxなら '>' minなら '<' が使える  private inline fun contains(a: Long, x: Long): Boolean = a < x  /**   * @param x 左右どちらからか最初に a < x になる場所を探す   * @param [a, b) 調べる範囲   * @param LR 左から調べるか   * @return この範囲に見つからなかったら -1   **/  fun find(x: Long, a: Int = 0, b: Int = N, LR: Boolean = true, k: Int = 1, l: Int = 0, r: Int = N): Int {    if (a >= r || l >= b) return -1// ノードが範囲からはずれてる    if (!contains(dat[k], x)) return -1    if (l + 1 == r) return l // 0-indexed     val m = (l + r) / 2    val lft = k * 2    val rgt = lft + 1     if (LR) {      val ans = find(x, a, b, LR, lft, l, m)      if (ans != -1) return ans      return find(x, a, b, LR, rgt, m, r)    } else {      val ans = find(x, a, b, LR, rgt, m, r)      if (ans != -1) return ans      return find(x, a, b, LR, lft, l, m)    }  }}class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  private val reader = BufferedReader(InputStreamReader(stream), 32768)   private val N = ni()  private val K = ni()  private val A = nl()  private val B = nl()  private val Q = ni()  fun solve() {    val segA = SegmentTreeL(N, 0)    val segB = SegmentTreeL(N, 0)    for (q in 0 until Q) {      val type = ni()      when(type) {        1 -> {          val d = ni() - 1          val a = nl()          val curA = segA.query(d, d + 1)          val curB = segB.query(d, d + 1)          if (curA < A) segA.update(d, min(A, curA + a))          if (curB < B) segB.update(d, min(B, curB + a))        }        else -> {          val l = ni() - 1          val r = min(N, l + K)          val ans = segB.query(0, l) + segA.query(r, N)          out.println(ans)        }      }    }  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return IntArray(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private inline fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: BooleanArray) {    debug { toString(a) }  }   private inline fun toString(a: BooleanArray) = run{a.map { if (it) 1 else 0 }.joinToString("""")}   private inline fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<BooleanArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }   private inline fun assert(b: Boolean) = run{if (!b) throw AssertionError()}} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}",data structures
"fun main() {    data class R(var t: Long, var m: Int, var f: Boolean)    readLine()    readLine()!!.split("" "").fold(R(1, 1, true)) { acc, i ->        if (i == ""1"") {            if (!acc.f) acc.t *= acc.m            acc.m = 1            acc.f = false        } else {            acc.m++        }        acc    }.run { print(if (f) 0 else t) }}",combinatorics
"fun main() {    val r = System.`in`.bufferedReader()    val sb = StringBuilder()    val n = r.readLine().toInt()    val v = r.readLine().split("" "").map { it.toInt() }    val left = v.indexOfFirst { it == 1 }    val right = v.indexOfLast { it == 1 }    var cnt = 1L    var res = 1L    for (i in left..right) {        if (i==-1) {            res = 0            break        }        when (v[i]) {            1 -> {                res *= cnt                cnt = 1            }            0 -> {                cnt++            }        }    }    sb.appendln( res)    print(sb)}",combinatorics
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min  class C617B(stream: InputStream, private val out: java.io.PrintWriter) {     fun binarySearch(arr: ArrayList<Int>, target: Int): Int {        var start = 0        var end = arr.size - 1        while (start <= end) {            val mid = (start + end) / 2            if (target > arr[mid]) start = mid + 1 else if (target < arr[mid]) end = mid - 1 else {                start = mid + 1            }        }        return start    }     fun solve() {        var a  = ni();        var  b = IntArray(a);        var end = 0;        for(q in 0  until a) {            var c  = ni();            if(c == 1) {                end = q;            }            b[q] = c;        }        var start = 0;        var count1= 0;        for(q in 0  until a) {            if(b[q] == 1) {                start = q;                count1++;                break;            }        }        var mult = 1L;        var count = 1;        var qa = 0L;      //  out.println(start+1 );        //out.println(end)         for(q in start+1  until end) {            if(b[q] == 0) {                count++;            }else {                qa = mult*count;                mult = qa;             //   out.println(mult)                count = 1;            }        }        if(count > 1) {            qa = qa*count;        }        if(count1 == 0) {            System.out.println(0)        }else        if(qa == 0L) {            System.out.println(1)        }else {            System.out.println(qa)        }     }     private val isDebug = try {        System.getenv(""MY_DEBUG"") != null    } catch (t: Throwable) {        false    }     private var tokenizer: StringTokenizer? = null    private val reader = BufferedReader(InputStreamReader(stream), 32768)    private fun next(): String {        while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {            tokenizer = StringTokenizer(reader.readLine())        }        return tokenizer!!.nextToken()    }     private fun ni() = next().toInt()    private fun nl() = next().toLong()    private fun ns() = next()    private fun na(n: Int, offset: Int = 0): IntArray {        return map(n) { ni() + offset }    }    private fun nal(n: Int, offset: Int = 0): LongArray {        val res = LongArray(n)        for (i in 0 until n) {            res[i] = nl() + offset        }        return res    }     private fun na2(n: Int, offset: Int = 0): Array<IntArray> {        val a  = Array(2){IntArray(n)}        for (i in 0 until n) {            for (e in a) {                e[i] = ni() + offset            }        }        return a    }     private inline fun map(n: Int, f: (Int) -> Int): IntArray {        val res = IntArray(n)        for (i in 0 until n) {            res[i] = f(i)        }        return res    }     private inline fun debug(msg: () -> String) {        if (isDebug) System.err.println(msg())    }     private fun debug(a: LongArray) {        debug { a.joinToString("" "") }    }     private fun debug(a: IntArray) {        debug { a.joinToString("" "") }    }     private fun debug(a: BooleanArray) {        debug { a.map { if (it) 1 else 0 }.joinToString("""") }    }     private fun debugDim(A: Array<LongArray>) {        if (isDebug) {            for (a in A) {                debug(a)            }        }    }    private fun debugDim(A: Array<IntArray>) {        if (isDebug) {            for (a in A) {                debug(a)            }        }    }     private fun hoge() {        min(1, 2)        max(1, 2)        abs(-10)    }} fun main() {    val out = java.io.PrintWriter(System.out)    C617B(System.`in`, out).solve()    out.flush()}",combinatorics
"import java.io.PrintWriterimport java.util.* val INPUT = System.`in`!!val OUTPUT = System.out!!const val mod : Long = 998_244_353val reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun line() = reader.readLine()!!var tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (tokenizer.hasMoreTokens().not()) tokenizer = StringTokenizer(reader.readLine() ?: return """", "" "")    return tokenizer.nextToken()}fun sort(a: IntArray) {    val l = ArrayList<Int>()    for (value in a) {        l.add(value)    }    l.sort()    for (i in l.indices) a[i] = l[i]}fun int() = read().toInt()fun double() = read().toDouble()fun long() = read().toLong()fun strings(n: Int) = List(n) { read() }fun lines(n: Int) = List(n) { line() }fun ints(n: Int) = List(n) { read().toInt() }fun intArray(n: Int) = IntArray(n) { read().toInt() }fun doubles(n: Int) = List(n) { read().toDouble() }fun doubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun longs(n: Int) = List(n) { read().toLong() }fun longArray(n: Int) = LongArray(n) { read().toLong() }val writer = PrintWriter(OUTPUT, false)fun main() { writer.solve(); writer.flush() }fun gcd(a : Int, b : Int) : Int {    if(b == 0) return a    return gcd(b, a % b)}class Pair(a : Int, b : Int)fun PrintWriter.solve() {    // val t = int()    val t = 1;    repeat(t) {        val n = int()        val arr = intArray(n)         var p = -1        var res : Long = 1        for(i in 0 until n) {            if(arr[i] == 1) {                if(p != -1) res *= (i - p)                p = i            }        }        println(if (p == -1) 0 else res)    }}",combinatorics
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.lang.AssertionErrorimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007L class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  fun solve() {    val K = nl()    // ax - b = K    val prev = mutableListOf<Pair<Long, Long>>()    for (n in 1 .. K) {      val a = n * (n + 1) / 2      val sum = n * (n - 1) / 2      val sqsum = n*(n - 1)*(2*n - 1) / 6      val b = n*sum -sqsum      val m = (K + b) / a      debug{""$n $a $b $m""}      if (n > m) break      if (a*m - b == K) prev += Pair(n, m)    }     val ans = mutableListOf<Pair<Long, Long>>()    for (i in prev) {      ans += Pair(i.first, i.second)      if (i.first != i.second) ans += Pair(i.second, i.first)    }     ans.sortWith(compareBy({it.first},{it.second}))     out.println(ans.size)    for (i in ans) {      out.println(""${i.first} ${i.second}"")    }  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private val reader = BufferedReader(InputStreamReader(stream), 32768)  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return map(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun map(n: Int, f: (Int) -> Int): IntArray {    val res = IntArray(n)    for (i in 0 until n) {      res[i] = f(i)    }    return res  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private inline fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: BooleanArray) {    debug { a.map { if (it) 1 else 0 }.joinToString("""") }  }   private inline fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }   private inline fun assert(b: Boolean) = run{if (!b) throw AssertionError()}} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","brute force,math"
"fun main() {    val (n, k, x) = readLine()!!.split("" "").map { it.toInt() }    val pow = (""1"" + ""0"".repeat(k)).toLong(x)    val ay = listOf(0L) + readLine()!!.split("" "").map { it.toLong() }    val prefixes = LongArray(n + 1)    for (j in 1..n) {        prefixes[j] = prefixes[j - 1] or ay[j]    }    val suffixes = LongArray(n + 2)    for (j in n downTo 1) {        suffixes[j] = ay[j] or suffixes[j + 1]    }    println((1..n).map { j -> prefixes[j - 1] or (pow * ay[j]) or suffixes[j + 1] }.max())}","brute force,greedy"
"import java.io.*import java.util.* fun <T : Comparable<T>> max(a: T, b: T): T = if (b > a) b else afun <T : Comparable<T>> min(a: T, b: T): T = if (b < a) b else afun Number.isEven(): Boolean = if (this.toInt() and 1 == 0) true else falsefun Number.isOdd (): Boolean = !this.isEven() fun ipow(base: Long, exp: Int): Long {    var base = base    var exp = exp    var result = 1L    while (exp > 0) {        if (exp and 1 == 1) result *= base        exp = exp ushr 1        base *= base    }    return result;} fun main(args: Array<String>) {    if (args.isNotEmpty()) System.setIn(FileInputStream(args[0]))    val br = BufferedReader(InputStreamReader(System.`in`))    val bw = BufferedWriter(OutputStreamWriter(System.out))     var st = StringTokenizer(br.readLine())    val n = st.nextToken().toInt()    val k = st.nextToken().toInt()    val x = st.nextToken().toInt()    val arr = IntArray(n+1)    val pre = IntArray(n+1)    val suf = IntArray(n+2)    st = StringTokenizer(br.readLine())    for (i in 1..n) {        arr[i] = st.nextToken().toInt()        pre[i] = pre[i-1] or arr[i]    }    for (i in n downTo 1) {        suf[i] = suf[i+1] or arr[i]    }    var maxval = 0L    for (i in 1..n) {        val a: Long = arr[i] * ipow(x.toLong(), k)        maxval = max(maxval, pre[i-1].toLong() or a or suf[i+1].toLong())    }    bw.write(""$maxval\n"")    bw.close()}","brute force,greedy"
"import java.io.*import java.util.* fun <T : Comparable<T>> max(a: T, b: T): T = if (b > a) b else afun <T : Comparable<T>> min(a: T, b: T): T = if (b < a) b else afun Number.isEven(): Boolean = if (this.toInt() and 1 == 0) true else falsefun Number.isOdd (): Boolean = !this.isEven() fun ipow(base: Long, exp: Int): Long {    var base = base    var exp = exp    var result = 1L    while (exp > 0) {        if (exp and 1 == 1) result *= base        exp = exp ushr 1        base *= base    }    return result;} class CumBit<in T : Number>(a: T) {    private val _irep: IntArray    init {        _irep = when (a) {            is Byte -> IntArray(8)            is Short -> IntArray(16)            is Int -> IntArray(32)            is Long -> IntArray(64)            else -> throw IllegalArgumentException(""CumBit unsupported type"")        }        val _a = a.toLong()        var mask = 1L        for (i in _irep.indices) {            _irep[i] = if (_a and mask != 0L) 1 else 0            mask = mask shl 1        }    }    fun toLong(): Long {        var result = 0L        var mask = 1L        for (i in 0.._irep.lastIndex-1) {            if (_irep[i] > 0) result += mask            mask = mask shl 1        }        if (_irep[_irep.lastIndex] > 0) result = -result        return result    }    fun toInt(): Int {        return this.toLong().toInt()    }    operator fun plusAssign(b: T) {        val _b = b.toLong()        var mask = 1L        for (i in _irep.indices) {            if (_b and mask != 0L) ++_irep[i]            mask = mask shl 1        }    }    operator fun minusAssign(b: T) {        val _b = b.toLong()        var mask = 1L        for (i in _irep.indices) {            if (_b and mask != 0L) --_irep[i]            mask = mask shl 1        }    }} fun main(args: Array<String>) {    if (args.isNotEmpty()) System.setIn(FileInputStream(args[0]))    val br = BufferedReader(InputStreamReader(System.`in`))    val bw = BufferedWriter(OutputStreamWriter(System.out))     var st = StringTokenizer(br.readLine())    val n = st.nextToken().toInt()    val k = st.nextToken().toInt()    val x = st.nextToken().toInt()    val arr = IntArray(n)    val cumbit = CumBit<Long>(0)    st = StringTokenizer(br.readLine())    for (i in arr.indices) {        arr[i] = st.nextToken().toInt()        cumbit += arr[i].toLong()    }    var maxval = 0L    for (i in arr.indices) {        cumbit -= arr[i].toLong()        val a = arr[i] * ipow(x.toLong(), k)        cumbit += a        maxval = max(maxval, cumbit.toLong())        cumbit -= a        cumbit += arr[i].toLong()    }    bw.write(""$maxval\n"")    bw.close()}","brute force,greedy"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007L class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  fun solve() {    val N = ni()    val K = ni()    val X0 = nl()    val A = nal(N)    var x = 1L    for (i in 0 until K) {      x *= X0    }     val LR = LongArray(N + 2)    val RL = LongArray(N + 2)    for (i in 0 until N) {      LR[i + 1] = LR[i] or A[i]    }    for (i in N - 1 downTo 0) {      RL[i + 1] = RL[i + 2] or A[i]    }    debug(LR)    debug(RL)     var ans = 0L    for (i in 0 until N) {      ans = max(ans, A[i] * x  or LR[i] or RL[i + 2])    }     out.println(ans)  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private val reader = BufferedReader(InputStreamReader(stream), 32768)  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return map(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun map(n: Int, f: (Int) -> Int): IntArray {    val res = IntArray(n)    for (i in 0 until n) {      res[i] = f(i)    }    return res  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: BooleanArray) {    debug { a.map { if (it) 1 else 0 }.joinToString("""") }  }   private fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","brute force,greedy"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.lang.AssertionErrorimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007 class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  private val reader = BufferedReader(InputStreamReader(stream), 32768)   fun solve() {    out.println(2001)    for (x in 1 until 1000) {      out.println(""$x 1 $x 2"")    }    out.println(""999 1 999 2"")    out.println(""1 1 1 2"")    for (x in 1 until 1000) {      out.println(""$x 1 $x 2"")    }    out.println(""999 1 999 2"")  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return IntArray(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private inline fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: BooleanArray) {    debug { toString(a) }  }   private inline fun toString(a: BooleanArray) = run{a.map { if (it) 1 else 0 }.joinToString("""")}   private inline fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<BooleanArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }   private inline fun assert(b: Boolean) = run{if (!b) throw AssertionError()}} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","constructive algorithms,implementation"
"fun main() {    val (numCandidates, numCities) = readLine()!!.split("" "").map { it.toInt() }    val citiesWon = IntArray(numCandidates) { 0 }    for (i in 1 .. numCities) {        citiesWon[readLine()!!.split("" "").map { it.toInt() }.toIntArray().firstMax()]++    }    print(citiesWon.firstMax() + 1)} fun IntArray.firstMax(): Int {    var maxValue = this[0]    var maxPos = 0    for (i in 1 until size) {        if (this[i] > maxValue) {            maxPos = i            maxValue = this[i]        }    }    return maxPos}",implementation
"import java.util.* fun main(args: Array<String>){    val ( n, m ) = readLine()!!.split(' ').map(String::toInt)    val cnt = IntArray(n + 1)    for( k in 1 .. m){        var id = 1        var max = 0        var i = 1        for( j in readLine()!!.split(' ').map(String::toInt) ){            if( j > max ){                max = j                id = i            }            i++        }        cnt[id]++    }    var id = 1    var max = 0    for( i in 1 .. n ){        if( cnt[i] > max ){            max = cnt[i]            id = i        }    }    print( id )}",implementation
"import java.util.* fun main(args: Array<String>){    val ( n, m ) = readLine()!!.split(' ').map(String::toInt)    val cnt = IntArray(n + 1)    for( k in 1 .. m){        var id = 1        var max = 0        var i = 1        for( j in readLine()!!.split(' ').map(String::toInt) ){            if( j > max ){                max = j                id = i            }            i++        }        cnt[id]++    }    var id = 1    var max = 0    for( i in 1 .. n ){        if( cnt[i] > max ){            max = cnt[i]            id = i        }    }    print( id )}",implementation
"import java.util.* fun main(args: Array<String>){    val ( n, m ) = readLine()!!.split(' ').map(String::toInt)    val cnt = IntArray(n + 1)    for( k in 1 .. m){        var id = 1        var max = 0        var i = 1        for( j in readLine()!!.split(' ').map(String::toInt) ){            if( j > max ){                max = j                id = i            }            i++        }        cnt[id]++    }    var id = 1    var max = 0    for( i in 1 .. n ){        if( cnt[i] > max ){            max = cnt[i]            id = i        }    }    print( id )} ",implementation
"import java.io.* class Node(        var first: Node? = null,        var last: Node? = null,        var size:Int = 1,        var next: Node? = null) class NodeGroups(n: Int) {    val nodeArr: Array<Node> = Array(n){Node()}     fun addNode(node: Node, index: Int){        nodeArr[index] = node    }     fun union(x: Int, y: Int) {        if(nodeArr[x].first != nodeArr[y].first) {            val mrFirst = if(nodeArr[x].first!!.size > nodeArr[y].first!!.size) nodeArr[x].first else nodeArr[y].first            val slFirst = if(nodeArr[x].first!!.size > nodeArr[y].first!!.size) nodeArr[y].first else nodeArr[x].first            val slLast = slFirst?.last!!            val mrLast = mrFirst?.last!!            mrLast.next = slFirst            mrFirst.last = slLast             mrFirst.size = mrFirst.size + slFirst.size             var curr: Node? = slFirst            while(curr != null) {                curr.first = mrFirst                curr = curr.next            }        }    }} fun main(args: Array<String>) {    val sc = BufferedReader(InputStreamReader(System.`in`))    val out = PrintWriter(BufferedOutputStream(System.out))    val (n, q) = sc.readLine()!!.split("" "").map(String::toInt)    val indexes = Array(n){it+1}    val nodeGroups = NodeGroups(n)    for(i in 0 until n) {        val node = Node()        node.first = node        node.last = node        nodeGroups.addNode(node, i)    }    for(i in 0 until q) {        val (type, x, y) = sc.readLine().split("" "").map(String::toInt)        when(type) {            1 -> {                nodeGroups.union(x-1, y-1)            }            2 -> {                var j = x-1                while(j<y-1 && j<n) {                    nodeGroups.union(j, y-1)                    val prj = j                    j = indexes[j]                    indexes[prj] = y-1                }            }            3 -> {                if(nodeGroups.nodeArr[x-1].first == nodeGroups.nodeArr[y-1].first) out.println(""YES"")                else out.println(""NO"")            }        }    }    out.close()}","data structures,dsu"
"import java.io.BufferedReader val bin = System.`in`.bufferedReader()fun BufferedReader.readInt() = this.readLine()!!.toInt()fun BufferedReader.readInts() = this.readLine()!!.split(' ').map { it.toInt() }.toIntArray()fun BufferedReader.readLong() = this.readLine()!!.toLong()fun BufferedReader.readLongs() = this.readLine()!!.split(' ').map { it.toLong() }.toLongArray() fun main() {    val (n, q) = bin.readInts()    val fu = FindUnion(n)    val mergers = sortedSetOf<Int>()    mergers.addAll((0 until n).toList())     val out = StringBuilder()    repeat(q) {        val (t, x, y) = bin.readInts().map { it-1 }        when (t) {            0 -> fu.union(x, y)            1 -> {                var p = x                while (true) {                    val next = mergers.higher(p)                    if (next == null || next > y) {                        break                    } else {                        fu.union(p, next)                        mergers.remove(next)                        p = next                    }                }            }            2 -> out.appendLine(if (fu.find(x) == fu.find(y)) ""YES"" else ""NO"")            else -> error(""Unknown command: $t, $x, $y"")        }    }    println(out)} data class FindUnion(val n: Int) {    val parent = IntArray(n) { it }    val max = IntArray(n) { it }    val size = IntArray(n) { 1 }     fun find(el: Int): Int {        var root = el        while (parent[root] != root) {            root = parent[root]        }         var x = el        while (parent[x] != root) {            val p = parent[x]            parent[x] = root            x = p        }        return root    }     fun union(x: Int, y: Int): Int {        var left = find(x)        var right = find(y)         if (left == right) return left         if (size[left] < size[right]) {            val tmp = left            left = right            right = tmp        }         // merge right into left        parent[right] = left        size[left] += size[right]        max[left] = kotlin.math.max(max[left], max[right])        return left    }     /**     * Returns maximal element belonging to the same set as [x].     */    fun max(x: Int) =        max[find(x)]     /**     * Returns the size of the set [x] belongs to.     */    fun size(x: Int): Int =        size[find(x)]}","data structures,dsu"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.lang.AssertionErrorimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007L class UnionFind(n: Int) {  private val par = IntArray(n){it}  private val rank = IntArray(n){1} // 集合の要素数  private val visits = IntArray(n) // 訪れた場所をfind毎に用意するのがもったいないのでつかいまわす   fun find(x: Int): Int {    var ptr = 0    var i = x    while(par[i] != i) {      visits[ptr++] = i      i = par[i]    }     for (j in 0 until ptr) {      par[visits[j]] = i    }    return i  }   private fun merge(node: Int, rt: Int): Int {    par[node] = rt    rank[rt] += rank[node]    return rt  }  fun unite(x: Int, y: Int): Int {    val x1 = find(x)    val y1 = find(y)    return if (x1 == y1) x1    else {      return if (rank[x1] < rank[y1])        merge(x1, y1)      else        merge(y1, x1)    }  }   fun isSame(x: Int, y: Int) = find(x) == find(y)   fun isRoot(x: Int) = par[x] == x   /**   * xを解決する必要がないときは直にrankをみる   */  fun cntNodes(x: Int): Int = rank[find(x)]  fun inspect() = run{par}}/** * @param merge ツリーを↑に上がっていくときのマージ関数 todo merge(a, a) = a でない場合要素数いるんじゃない？ * @param plus addでノードを更新する関数 (昔の値, 要素数, 引数) */class DelayMergeTree(n: Int) {  private val N =    if (Integer.highestOneBit(n) == n) n    else Integer.highestOneBit(n) shl 1   private val value = IntArray(N * 2){-1}  private val delay = IntArray(N * 2){-1}  private val elms = IntArray(N * 2)  private val uf = UnionFind(N)  init {    elms[1] = N    for (i in 1 until N) {      elms[2 * i] = elms[i] / 2      elms[2 * i + 1] = elms[i] / 2    }     for (i in 0 until N) {      value[i + N] = i    }  }   private inline fun push(k: Int) {    if (k < N && delay[k] != -1) {      value[k * 2] = delay[k]      value[k * 2 + 1] = delay[k]      delay[k * 2] = delay[k]      delay[k * 2 + 1] = delay[k]      delay[k] = -1    }  }   private inline fun unite(a: Int, b: Int): Int {    if (a == -1) return b    if (b == -1) return a    return uf.unite(a, b)  }   /**   * [a, b)   */  fun set(a: Int, b: Int, x: Int, k: Int = 1, l: Int = 0, r: Int = N) {    if (a >= r || l >= b) return // ノードが範囲からはずれてる    if (a <= l && r <= b) { // ノードが完全に範囲に含まれる      value[k] = x      delay[k] = x      return    }     push(k)    val m = (l + r) / 2    val lft = k * 2    val rgt = lft + 1    set(a, b, x, lft, l, m)    set(a, b, x, rgt, m, r)    value[k] = if (value[lft] == value[rgt]) value[lft] else -1  }   /**   * [a, b)   * @return -1 if 範囲から外れている   */  fun merge(a: Int, b: Int, k: Int = 1, l: Int = 0, r: Int = N): Int {    if (a >= r || l >= b) return -1 // ノードが範囲からはずれてる    if (a <= l && r <= b && value[k] != -1) { // ノードが完全に範囲に含まれる and merge済み      return value[k]    }     push(k)    val m = (l + r) / 2    val lft = k * 2    val rgt = lft + 1     return unite(merge(a, b, lft, l, m), merge(a, b, rgt, m, r))  }   fun eval(i: Int): Int {    _eval(N + i)    return value[N + i]  }   fun inspect() = run { Pair(value, delay) }   fun uf() = run{uf}   fun _eval(k: Int) {    if (k > 1) {      _eval(k / 2)    }    push(k)  }}class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  fun solve() {    val N = ni()    val seg = DelayMergeTree(N)    val uf = seg.uf()    fun inspect() {      debug{seg.inspect().first.joinToString("" "")}      debug{seg.inspect().second.joinToString("" "")}      debug{uf.inspect().joinToString("" "")}    }    if (isDebug) inspect()    for (q in 0 until ni()) {      val type = ni()      val x = ni() - 1      val y = ni() - 1      when(type) {        1 -> {          val id = uf.unite(x, y)          seg.set(x, x + 1, id)          seg.set(y, y + 1, id)          debug{""$type $x $y $id""}          if (isDebug) inspect()        }        2 -> {          val id = seg.merge(x, y + 1)          debug{""$type $x $y $id""}          seg.set(x, y + 1, id)          if (isDebug) inspect()        }        else -> {          out.println(if (uf.isSame(x, y)) ""YES"" else ""NO"")        }      }    }  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private val reader = BufferedReader(InputStreamReader(stream), 32768)  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return map(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun map(n: Int, f: (Int) -> Int): IntArray {    val res = IntArray(n)    for (i in 0 until n) {      res[i] = f(i)    }    return res  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private inline fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: BooleanArray) {    debug { a.map { if (it) 1 else 0 }.joinToString("""") }  }   private inline fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }   private inline fun assert(b: Boolean) = run{if (!b) throw AssertionError()}} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","data structures,dsu"
"fun main() {    val numTrees = readLine()!!.toInt()    var numPositives = 0    var numNegatives = 0    val trees = mutableListOf<Pair<Int, Int>>()    for (i in 1..numTrees) {        val (pos, apples) = readLine()!!.split("" "").map { it.toInt() }        if (pos > 0) numPositives++ else numNegatives++        trees.add(pos to apples)    }    trees.sortBy { it.first }    when {        numNegatives == numPositives -> print(trees.sumBy { it.second })        numNegatives > numPositives -> print(trees.slice(numNegatives - numPositives - 1 until numTrees).sumBy { it.second })        else -> print(trees.slice(0..numTrees - numPositives + numNegatives).sumBy { it.second })    }}","brute force,implementation,sortings"
"import java.io.*import java.util.*import kotlin.collections.ArrayListimport kotlin.collections.HashSet fun main() {    solve(System.`in`, System.out)} fun solve(input: InputStream, output: OutputStream) {    val reader = Reader(input) //Reader(FileInputStream(File(""portals.in"")))    val writer = PrintWriter(BufferedOutputStream(output)) //PrintWriter(FileOutputStream(File(""output.txt"")))     solve(reader, writer)    writer.close()} fun solve(ir : Reader, pw : PrintWriter) {     val n = ir.nextInt()    val x = IntArray(n)    val a = IntArray(n)    var countPos = 0    var total = 0     for (i in 0 until n) {        x[i] = ir.nextInt()        a[i] = ir.nextInt()        if (x[i] > 0)            countPos++    }     val countNeg = n - countPos     sort(x, a, 0, n - 1)     if (countNeg == n) {        for (i in (n - 1) downTo 0) {            if (x[i] < 0) {                total = a[i]                break            }        }    } else if (countPos == n) {        for (i in 0 until n) {            if (x[i] > 0) {                total = a[i]                break            }        }    } else if (countNeg > countPos) {        for (i in 0 until n) {            if (x[i] > 0) {                for (j in i until n) {                    total += a[j]                }                for (j in (i - 1) downTo (i - countPos - 1)) {                    total += a[j]                }                break            }        }    } else if (countNeg < countPos) {        for (i in 0 until n) {            if (x[i] > 0) {                for (j in (i - 1) downTo 0)                    total += a[j]                for (j in i until (i + countNeg + 1))                    total += a[j]                break            }        }    } else {        for (i in 0 until n) {            if (x[i] < 0) {                for (j in i downTo 0) {                    total += a[j]                }                for (j in (i + 1) until n) {                    total += a[j]                }                break            }        }    }    pw.print(total) } private fun sort(array: IntArray, barray: IntArray, low: Int, high: Int) {     var i = low    var j = high    val x = array[low + (high - low) / 2]     do {        while (array[i] < x) ++i        while (array[j] > x) --j        if (i <= j) {            val tmp = array[i]            array[i] = array[j]            array[j] = tmp             val pmt = barray[i]            barray[i] = barray[j]            barray[j] = pmt             i++            j--        }    } while (i <= j)     if (low < j) sort(array, barray, low, j)    if (i < high) sort(array, barray, i, high) } class Reader(stream: InputStream) {    private val reader: BufferedReader = BufferedReader(InputStreamReader(stream), 32768)    private var tokenizer: StringTokenizer? = null     init {        tokenizer = null    }     operator fun next(): String {        while (tokenizer == null || !tokenizer!!.hasMoreTokens())            try {                tokenizer = StringTokenizer(reader.readLine())            } catch (e: IOException) {                throw RuntimeException(e)            }         return tokenizer!!.nextToken()    }     fun nextLine(): String? {        val fullLine: String        while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {            try {                fullLine = reader.readLine()            } catch (e: IOException) {                throw RuntimeException(e)            }             return fullLine        }        return null    }     fun toArray(): Array<String> {        return nextLine()!!.split("" "".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()    }     fun nextInt(): Int {        return Integer.parseInt(next())    }     fun nextDouble(): Double {        return java.lang.Double.parseDouble(next())    }     fun nextLong(): Long {        return java.lang.Long.parseLong(next())    } }","brute force,implementation,sortings"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min  class C617C(stream: InputStream, private val out: java.io.PrintWriter) {     fun binarySearch(arr: ArrayList<Int>, target: Int): Int {        var start = 0        var end = arr.size - 1        while (start <= end) {            val mid = (start + end) / 2            if (target > arr[mid]) start = mid + 1 else if (target < arr[mid]) end = mid - 1 else {                start = mid + 1            }        }        return start    }     fun solve() {        var a  = ni();        var pos = TreeMap<Int,Int>()        var neg = TreeMap<Int,Int>()        var total = 0L;        var posi = 0L;        var negi = 0L;        var act = 0L;        for(j in 0 until a) {            var q = ni();            var s = ni();            if(q < 0) {                neg.put(q*-1,s )                negi+=s            }else {                pos.put(q,s )                posi+=s            }            total +=s;        }        if(pos.size  == neg.size) {            act  = total;        }else if(pos.size > neg.size) {            var count =0;            act+=negi;            for ((key, value)  in pos) {                if(count < neg.size + 1) {                    act+=value;                }else {                    break;                }                count++;            }        }else {            var count =0;            act+=posi;            for ((key, value)  in neg) {                if(count < pos.size + 1) {                    act+=value;                }else {                    break;                }                count++;            }        }         out.println(act);    }     private val isDebug = try {        System.getenv(""MY_DEBUG"") != null    } catch (t: Throwable) {        false    }     private var tokenizer: StringTokenizer? = null    private val reader = BufferedReader(InputStreamReader(stream), 32768)    private fun next(): String {        while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {            tokenizer = StringTokenizer(reader.readLine())        }        return tokenizer!!.nextToken()    }     private fun ni() = next().toInt()    private fun nl() = next().toLong()    private fun ns() = next()    private fun na(n: Int, offset: Int = 0): IntArray {        return map(n) { ni() + offset }    }    private fun nal(n: Int, offset: Int = 0): LongArray {        val res = LongArray(n)        for (i in 0 until n) {            res[i] = nl() + offset        }        return res    }     private fun na2(n: Int, offset: Int = 0): Array<IntArray> {        val a  = Array(2){IntArray(n)}        for (i in 0 until n) {            for (e in a) {                e[i] = ni() + offset            }        }        return a    }     private inline fun map(n: Int, f: (Int) -> Int): IntArray {        val res = IntArray(n)        for (i in 0 until n) {            res[i] = f(i)        }        return res    }     private inline fun debug(msg: () -> String) {        if (isDebug) System.err.println(msg())    }     private fun debug(a: LongArray) {        debug { a.joinToString("" "") }    }     private fun debug(a: IntArray) {        debug { a.joinToString("" "") }    }     private fun debug(a: BooleanArray) {        debug { a.map { if (it) 1 else 0 }.joinToString("""") }    }     private fun debugDim(A: Array<LongArray>) {        if (isDebug) {            for (a in A) {                debug(a)            }        }    }    private fun debugDim(A: Array<IntArray>) {        if (isDebug) {            for (a in A) {                debug(a)            }        }    }     private fun hoge() {        min(1, 2)        max(1, 2)        abs(-10)    }} fun main() {    val out = java.io.PrintWriter(System.out)    C617C(System.`in`, out).solve()    out.flush()}","brute force,implementation,sortings"
import kotlin.math.abs fun main(args: Array<String>) {    readLine()    readLine()!!.let { it.length - 2 * it.count{it == '0'} }.let { println(abs(it)) }},greedy
"//package tasks fun main() {    readLine()    val count = readLine()!!.fold(0) { acc, c -> acc + if (c == '1') 1 else -1 }    println(kotlin.math.abs(count))}",greedy
"import kotlin.math.min fun main() {    val n = readLine()!!.toInt()    val ones = readLine()!!.filter { digit -> digit == '1' }.length    println(n - 2*min(ones, n - ones))}",greedy
"import kotlin.math.abs fun main(args:Array<String>) {val x= readLine()!!.toInt()var y= readLine()!!y=y.replace(""0"","""") var zero=x-y.length    println(abs(y.length-zero))}",greedy
"import java.util.*import kotlin.math.max fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)    fun BitSet.countConsecutive(): Int {        var output = 0        var count = 0        for (pos in 0 until this.size()) {            if (this[pos]) count++ else count = 0            output = max(output, count)        }        return output    }     val (numRows, numCols, numRounds) = readInts()    val grid = Array(numRows) { BitSet(numCols) }    val sums = IntArray(numRows)    val sols = IntArray(numRounds)    for (numRow in 0 until numRows) {        val row = readInts()        for (numColumn in 0 until numCols)            if (row[numColumn] == 1) grid[numRow].set(numColumn)        sums[numRow] = grid[numRow].countConsecutive()    }    for (numRound in 0 until numRounds) {        val (i, j) = readLine()!!.split("" "").map { it.toInt() - 1 }        grid[i].flip(j)        sums[i] = grid[i].countConsecutive()        sols[numRound] = sums.max()!!    }    print(sols.joinToString(System.lineSeparator()))}","brute force,dp,greedy,implementation"
"fun main() {    val nmq = readIntArray()    val bears = Array<IntArray>(nmq[0]) {intArrayOf()}    val maxLen = IntArray(nmq[0]) {0}    for (row in bears.indices) {        bears[row] = readIntArray()        maxLen[row] = findMaxLen(bears[row])}    var score = maxLen.max()!!    val results = IntArray(nmq[2]) {score}    for (round in 0 until nmq[2]) {        val ij = readInts()        val i = ij[0]-1        val j = ij[1]-1        bears[i][j] = if (bears[i][j] == 1) 0 else 1        val rowScore = findMaxLen(bears[i])        if (rowScore >= score) {            score = rowScore            maxLen[i] = rowScore        } else if (maxLen[i] == score) {            maxLen[i] = rowScore            score = maxLen.max()!!        } else {            maxLen[i] = rowScore        }        results[round] = score    }    for (result in results) println(result)} private fun readIntArray(): IntArray = readInts().toIntArray() private fun readInts(): List<Int> = readLine()!!.split("" "").map{it.toInt()} private fun findMaxLen(row: IntArray): Int {    var maxLen = 0    var tempLen = 0    for (i in row.indices) {        if (row[i]==1) tempLen++        else {            if (tempLen>maxLen) maxLen = tempLen            tempLen = 0 }}    return if (maxLen>tempLen) maxLen else tempLen}","brute force,dp,greedy,implementation"
" fun main(args: Array<String>) { val n = readInt() val arr = ArrayList<Pair< Int, Int>>()for(z in 0 until n){    val (treePosition, height) = readInts()    arr.add(Pair(treePosition,height)) } var output = if(arr.size >1){ 2 } else{ 1 }for (l in  1 until n-1 ){if(arr[l].first-arr[l].second > arr[l-1].first){output++}else if(arr[l].first+arr[l].second< arr[l+1].first){output++arr[l] = arr[l].copy(arr[l].first+arr[l].second,arr[l].second)}}println(output)   } fun readInts() = readLine()!!.split("" "").map(String::toInt)fun readInt() = readLine()!!.toInt()","dp,greedy"
"fun main() {    fun readInt() = readLine()!!.toInt()    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val numTrees = readInt()    val positions = IntArray(numTrees)    val heights = IntArray(numTrees)    for (pos in 0 until numTrees) {        val (treePosition, height) = readInts()        positions[pos] = treePosition        heights[pos] = height    }    var sol = if (numTrees == 1) 1 else 2    for (pos in 1 until numTrees - 1)        if (positions[pos] - heights[pos] > positions[pos - 1]) sol++        else if (positions[pos] + heights[pos] < positions[pos + 1]) {            sol++            positions[pos] += heights[pos]        }    print(sol)}","dp,greedy"
"import java.io.BufferedReaderimport java.io.InputStreamReader fun main() {    val br = BufferedReader(InputStreamReader(System.`in`))    val n = br.readLine().toInt()    val trees = List(n){        val (x, h) = br.readLine().split("" "").map { it.toInt() }        x to h    }    var prevOcc = trees.first().first    var cnt = if (n == 1) 1 else 2     for (i in 1 until n - 1) {        val (x_i, h_i) = trees[i]        val (x_next, _) = trees[i + 1]        if (x_i - h_i > prevOcc) {            cnt++            prevOcc = x_i        } else if (x_i + h_i < x_next) {            cnt++            prevOcc = x_i + h_i        } else {            prevOcc = x_i        }    }     println(cnt)}","dp,greedy"
"import kotlin.math.max fun main() {    val n = readLine()!!.toInt()    val a = List(n) {        val (x, h) = readLine()!!.split(' ').map(String::toLong)        x to h    }    val r = List(n) { MutableList(2) { -1 } }    r[0][0] = 0    r[0][1] = 1    for (i in 1 until n) {        val d = a[i].first - a[i - 1].first        val h1 = a[i - 1].second        val h2 = a[i].second         r[i][0] = max(r[i - 1][0], r[i - 1][1])        if (d > h1) {            r[i][0] = max(r[i][0], r[i - 1][0] + 1)        }        if (d > h2) {            r[i][1] = max(r[i - 1][0], r[i - 1][1]) + 1            if (d > h1 + h2) {                r[i][1] = max(r[i][1], r[i - 1][0] + 2)            }        } else {            r[i][1] = -1        }    }    println(r[n - 1][0] + 1)}","dp,greedy"
"import java.io.*import java.util.* fun <T : Comparable<T>> max(a: T, b: T): T = if (b > a) b else afun <T : Comparable<T>> min(a: T, b: T): T = if (b < a) b else afun Number.isEven(): Boolean = if (this.toInt() and 1 == 0) true else falsefun Number.isOdd (): Boolean = !this.isEven() fun dfs(m: Array<CharArray>, r1: Int, c1: Int, r2: Int, c2: Int): Boolean {    if (r1 < 0 || r1 > m.lastIndex || c1 < 0 || c1 > m[r1].lastIndex) return false    if (r1 == r2 && c1 == c2 && m[r1][c1] == 'X') return true    if (m[r1][c1] == 'X') return false    m[r1][c1] = 'X'    return (dfs(m, r1, c1 + 1, r2, c2) ||            dfs(m, r1, c1 - 1, r2, c2) ||            dfs(m, r1 + 1, c1, r2, c2) ||            dfs(m, r1 - 1, c1, r2, c2))}  fun main(args: Array<String>) {    if (args.isNotEmpty()) System.setIn(FileInputStream(args[0]))    val br = BufferedReader(InputStreamReader(System.`in`))    val bw = BufferedWriter(OutputStreamWriter(System.out))     var st = StringTokenizer(br.readLine())    val n = st.nextToken().toInt()    val m = st.nextToken().toInt()    val arr = Array(n) { CharArray(0) }    for (i in arr.indices) {        st = StringTokenizer(br.readLine())        arr[i] = st.nextToken().toCharArray()    }    st = StringTokenizer(br.readLine())    val r1 = st.nextToken().toInt() - 1    val c1 = st.nextToken().toInt() - 1    st = StringTokenizer(br.readLine())    val r2 = st.nextToken().toInt() - 1    val c2 = st.nextToken().toInt() - 1     arr[r1][c1] = '.'    if (dfs(arr, r1, c1, r2, c2)) bw.write(""YES\n"")    else bw.write(""NO\n"")    bw.close()}",dfs and similar
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007 class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  fun solve() {    val N = ni()    val M = ni()    val g = Array(N){ns().map{it ==  '.'}} // 壊れていない    val (R1, C1) = na(2).map{it-1}    val (R2, C2) = na(2).map{it-1}     val D = arrayOf(Pair(-1, 0), Pair(0, 1), Pair(1, 0), Pair(0, -1))    val D1 = D.filter { d ->      val r = R2 + d.first      val c = C2 + d.second      (0 until N).contains(r) &&          (0 until M).contains(c) &&          g[r][c]    }     fun ok(): Boolean {      if (abs(R1 - R2) + abs(C1 - C2) == 0) {        return D1.isNotEmpty()      }       if (abs(R1 - R2) + abs(C1 - C2) == 1) {        return !g[R2][C2] || D1.isNotEmpty()      }       fun reaclable(sr: Int, sc: Int): Boolean {        val V = Array(N) { BooleanArray(M) }        val q = ArrayDeque<Pair<Int, Int>>()        q.add(Pair(R1, C1))        V[R1][C1] = true         while (q.isNotEmpty()) {          val (r, c) = q.poll()          for (d in D) {            val nr = r + d.first            val nc = c + d.second            if (!(0 until N).contains(nr) || !(0 until M).contains(nc)) continue            if (V[nr][nc]) continue             V[nr][nc] = true            if (g[nr][nc]) q.add(Pair(nr, nc))          }        }        debug { V.joinToString(""\n"") { it.map { if (it) 1 else 0 }.joinToString("""") } }        return V[sr][sc]      }       fun step(): Boolean {        if (D1.size < 2) return false         for (d in D1) {          val r = R2 + d.first          val c = C2 + d.second          if (reaclable(r, c)) return true        }         return false      }       return if (!g[R2][C2]) {        reaclable(R2, C2)      } else {        step()      }    }     if (ok()) out.println(""YES"")    else out.println(""NO"")  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private val reader = BufferedReader(InputStreamReader(stream), 32768)  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return map(n, offset) { ni() }  }   private inline fun map(n: Int, offset: Int = 0, f: (Int) -> Int): IntArray {    val res = IntArray(n)    for (i in 0 until n) {      res[i] = f(i) + offset    }    return res  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: BooleanArray) {    debug { a.map { if (it) 1 else 0 }.joinToString("""") }  }   private fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }} fun <A, B> pair(a: A, b: B) = RPair(a, b)data class RPair<A, B>(val _1: A, val _2: B) fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}",dfs and similar
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007L class SegmentTree(n: Int, val zero: Int, val f: (Int, Int) -> Int) {  private val N =    if (Integer.highestOneBit(n) == n) n    else Integer.highestOneBit(n) shl 1   private val dat = IntArray(2 * N){zero}   fun update(i: Int, a: Int) {    var ix = i + N    dat[ix] = a    while(ix > 1) {      dat[ix shr 1] = f(dat[ix], dat[ix xor 1])      ix = ix shr 1    }  }   /**    * [a, b)    */  fun query(a: Int, b: Int): Int {    var res: Int = zero    var left = a + N    var right = b - 1 + N     while(left <= right) {      if ((left and 1) == 1) res = f(res, dat[left])      if ((right and 1) == 0) res = f(res, dat[right])      left = (left + 1) shr 1 // 右の子供なら右の親に移動      right = (right - 1) shr 1 // 左の子供なら左の親に移動    }     return res  }   // 条件を満たすか。maxなら '>' minなら '<' が使える  private inline fun contains(a: Int, x: Int): Boolean = a <= x  /**   * @param x 左右どちらからか最初に a < x になる場所を探す   * @param [a, b) 調べる範囲   * @param LR 左から調べるか   * @return この範囲に見つからなかったら -1   **/  fun find(x: Int, a: Int = 0, b: Int = N, LR: Boolean = true, k: Int = 1, l: Int = 0, r: Int = N): Int {    if (a >= r || l >= b) return -1// ノードが範囲からはずれてる    if (!contains(dat[k], x)) return -1    if (l + 1 == r) return l // 0-indexed     val m = (l + r) / 2    val lft = k * 2    val rgt = lft + 1     if (LR) {      val ans = find(x, a, b, LR, lft, l, m)      if (ans != -1) return ans      return find(x, a, b, LR, rgt, m, r)    } else {      val ans = find(x, a, b, LR, rgt, m, r)      if (ans != -1) return ans      return find(x, a, b, LR, lft, l, m)    }  }}data class Entry(val x: Int, val w: Int)class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  fun solve() {    val N = ni()    val E = Array(N){Entry(ni(), ni())}    E.sortBy { it.x }     val INF = 2e9.toInt() + 10    val dp = SegmentTree(N + 10, INF, ::min)    dp.update(0, -INF)    for (i in E) {      val best = dp.find(i.x - i.w, LR = false)      debug{""$i $best""}      val prev = dp.query(best + 1, best + 2)      val next = i.x + i.w      if (next < prev) dp.update(best + 1, next)    }     val ans = dp.find(INF - 1, LR = false)    out.println(ans)  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private val reader = BufferedReader(InputStreamReader(stream), 32768)  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return map(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun map(n: Int, f: (Int) -> Int): IntArray {    val res = IntArray(n)    for (i in 0 until n) {      res[i] = f(i)    }    return res  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: BooleanArray) {    debug { a.map { if (it) 1 else 0 }.joinToString("""") }  }   private fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","data structures,dp,greedy,implementation,sortings"
"import java.io.*import java.util.*import kotlin.Comparator  class Solution : Runnable {    override fun run() {        solve()    }     fun start() {        Thread(null, Solution(), ""whatever"", (1 shl 27).toLong()).start()    }} fun main(args: Array<String>) {    Solution().start()}  class IO {    companion object {         private val reader: InputReader        private val writer: OutputWriter         init {            if (System.getProperty(""ONLINE_JUDGE"") == null) {                reader = InputReader(FileInputStream(""/Users/300041735/competitiveProgramming/src/codeforces/in.txt""))                writer = OutputWriter(FileOutputStream(""/Users/300041735/competitiveProgramming/src/codeforces/out.txt""))            } else {                reader = InputReader(System.`in`)                writer = OutputWriter(System.`out`)            }        }         private fun readMultipleInts(count: Int): List<Int> {            val map = mutableListOf<Int>()            repeat(count) {                map.add(reader.readInt())            }            return map        }         fun readInt() = reader.readInt()        fun readLong() = reader.readLong()        fun readTwoInts() = readMultipleInts(2)        fun readThreeInts() = readMultipleInts(3)        fun readFourInts() = readMultipleInts(4)        fun readFiveInts() = readMultipleInts(5)        fun readSixInts() = readMultipleInts(6)        fun readString() = reader.readString()        fun readTree(n: Int): MutableMap<Int, MutableList<Int>> {            val graph = mutableMapOf<Int, MutableList<Int>>()            repeat(n - 1) {                val u = reader.readInt()                val v = reader.readInt()                if (!graph.containsKey(u)) graph[u] = mutableListOf()                graph[u]!!.add(v)            }            return graph        }         fun readIntArray(n: Int): IntArray {            return IntArray(n) { readInt() }        }         fun readLongArray(n: Int): Array<Long> {            return Array(n) { readLong() }        }         fun write(obj: Any) {            writer.printLine(obj)        }         fun flushOutput() {            writer.flush()        }         fun closeOutput() {            writer.close()        }    }}  class MATH {    companion object {         val mod = 998244353        var ispre = false         val factMod = Array(300002) { 1 }         fun pre() {            for (i in 2 until 300001) {                factMod[i] = ((factMod[i - 1] * i.toLong()) % MATH.mod).toInt()            }        }         fun gcd(a: Int, b: Int): Int {            if (b == 0)                return a            return gcd(b, a % b)        }         fun gcd(a: Long, b: Long): Long {            if (b == 0L)                return a            return gcd(b, a % b)        }         fun inverseMod(a: Int): Int {            return powMod(a, mod - 2)        }         fun powMod(a: Int, b: Int): Int {            //calculate a to the power b mod m            if (b == 0) return 1            return if (b % 2 == 1) {                prodMod(a, powMod(a, b - 1))            } else {                val p = powMod(a, b / 2)                prodMod(p, p)            }        }         fun ncr(n: Int, r: Int): Int {            if (!ispre) pre(); ispre = true            return ((factMod[n].toLong() * inverseMod(((factMod[r].toLong() * factMod[n - r]) % mod).toInt())) % mod).toInt()        }         fun prodMod(val1: Int, val2: Int): Int {            return ((val1.toLong() * val2) % mod).toInt()        }     }} fun solve() {     val n = IO.readInt()    if (n%2 == 0){        IO.write(""white"")        IO.write(""1 2"")    }else{        IO.write(""black"")    }     IO.flushOutput()    IO.closeOutput()}  class SuffixArray(val input : String){    //time complexity is n(log(n))^2     fun sa() : IntArray{        val n = input.length        var cur = IntArray(n) { i -> input[i] -'a' } //will store the current sort order        for (i in 1 until 20){            val newCur = IntArray(n) { 0 }            val newlist = mutableListOf<Triple<Int, Int, Int>>()            for (j in 0 until n) {                newlist.add(Triple(j, cur[j], if ( j+ power(2, i) < n) cur[j + power(2, i)] else -1))            }            newlist.sortWith(comparator())            //after sorting            for (j in 0 until n){                newCur[newlist[j].first] = if (j > 0 && newlist[j].second == newlist[j - 1].second && newlist[j].third == newlist[j - 1].third) newCur[newlist[j - 1].first] else j            }            cur =  newCur         }        return cur    }     internal class comparator : Comparator<Triple<Int, Int, Int>>{        override fun compare(o1: Triple<Int, Int, Int>?, o2: Triple<Int, Int, Int>?): Int {            if (o1!!.second != o2!!.second){                return o1.second.compareTo(o2.second)            }else{                //both are equal what to do now                return o1.third.compareTo(o2.third)            }        }    }  }   class Primes{    val limit = 1000    val composites = IntArray(limit + 1) { 0 }    val factors= IntArray(limit + 1) { 0 }    val preFactors = IntArray(limit + 1) { 0 }    val primes  = mutableListOf<Int>()     init {        sieve()        calcFactors()    }     fun sieve(){        for (i in 2 until limit + 1){            if (composites[i] == 0){                primes.add(i)                var cur = 1                while (cur*i <= limit){                    composites[cur*i] = i                    cur++                }            }        }    }     fun calcFactors(){        for (i in 2 until limit + 1){            var num = i            while (num != 1){                factors[i]++                num /= composites[num]            }        }        for (i in 2 until limit + 1){            preFactors[i]= preFactors[i - 1] + factors[i]        }    }}   fun isBitSet(num: Int, i: Int): Boolean {    return (num.and(1.shl(i)) > 0)} fun power(i: Int, j: Int): Int {    if (j == 0) return 1    return i * power(i, j - 1)} class MinSegmentTree(        input: Array<Int>) {    private val tree: Array<Int>    private val lazy: Array<Int>     constructor(size: Int) : this(Array(size) { Int.MAX_VALUE })     init {        val size = nextPowerOfTwo(input.size)        tree = Array(2 * size) { Int.MAX_VALUE }        lazy = Array(2 * size) { Int.MAX_VALUE }        for (i in 0 until input.size) {            tree[i + size] = input[i]        }        for (i in (size - 1) downTo 1) {            tree[i] = Math.min(tree[leftChild(i)], tree[rightChild(i)])        }    }     private fun updateTree(lowerRange: Int, upperRange: Int, lowerBound: Int, upperBound: Int, index: Int, value: Int) {        updateLazyNode(index, lowerBound, upperBound, lazy[index])        if (noOverlap(lowerRange, upperRange, lowerBound, upperBound)) return        else if (completeOverlap(lowerRange, upperRange, lowerBound, upperBound)) updateLazyNode(index, lowerBound, upperBound, value)        else {            updateTree(lowerRange, upperRange, lowerBound, midIndex(lowerBound, upperBound), leftChild(index), value)            updateTree(lowerRange, upperRange, midIndex(lowerBound, upperBound) + 1, upperBound, rightChild(index), value)            tree[index] = Math.min(tree[leftChild(index)], tree[rightChild(index)])        }    }     private fun queryTree(lowerRange: Int, upperRange: Int, lowerBound: Int, upperBound: Int, index: Int): Int {        updateLazyNode(index, lowerBound, upperBound, lazy[index])        if (noOverlap(lowerRange, upperRange, lowerBound, upperBound)) return Int.MAX_VALUE        else if (completeOverlap(lowerRange, upperRange, lowerBound, upperBound)) return tree[index]        else {            return Math.min(queryTree(lowerRange, upperRange, lowerBound, midIndex(lowerBound, upperBound), leftChild(index)),                    queryTree(lowerRange, upperRange, midIndex(lowerBound, upperBound) + 1, upperBound, rightChild(index)))        }    }     private fun updateLazyNode(index: Int, lowerBound: Int, upperBound: Int, delta: Int) {        tree[index] += delta        if (lowerBound != upperBound) {            lazy[leftChild(index)] += delta            lazy[rightChild(index)] += delta        }        lazy[index] = 0    }     fun getElements(N: Int): List<Int> {        return tree.copyOfRange(tree.size / 2, tree.size / 2 + N).asList()    }     fun update(lowerRange: Int, upperRange: Int, value: Int) {        updateTree(lowerRange, upperRange, 1, lazy.size / 2, 1, value)    }     fun query(lowerRange: Int, upperRange: Int): Int {        return queryTree(lowerRange, upperRange, 1, lazy.size / 2, 1)    }     private fun noOverlap(l: Int, u: Int, lb: Int, ub: Int): Boolean = (lb > u || ub < l)     private fun completeOverlap(l: Int, u: Int, lb: Int, ub: Int): Boolean = (lb >= l && ub <= u)      private fun nextPowerOfTwo(num: Int): Int {        var exponent = 2        while (true) {            if (exponent >= num) {                return exponent            }            exponent *= 2        }    }     private fun midIndex(l: Int, r: Int) = (l + r) / 2    private fun parent(i: Int) = i / 2    private fun leftChild(i: Int) = 2 * i    private fun rightChild(i: Int) = 2 * i + 1 } class InputReader(private val stream: InputStream) {    private val buf = ByteArray(1024)    private var curChar: Int = 0    private var numChars: Int = 0    private val filter: SpaceCharFilter? = null     fun read(): Int {        if (numChars == -1)            throw InputMismatchException()        if (curChar >= numChars) {            curChar = 0            try {                numChars = stream.read(buf)            } catch (e: IOException) {                throw InputMismatchException()            }             if (numChars <= 0)                return -1        }        return buf[curChar++].toInt()    }     fun readInt(): Int {        var c = read()        while (isSpaceChar(c))            c = read()        var sgn = 1        if (c == '-'.toInt()) {            sgn = -1            c = read()        }        var res = 0        do {            if (c < '0'.toInt() || c > '9'.toInt())                throw InputMismatchException()            res *= 10            res += c - '0'.toInt()            c = read()        } while (!isSpaceChar(c))        return res * sgn    }     fun readLong(): Long {        var c = read()        while (isSpaceChar(c)) {            c = read()        }        var sgn: Long = 1        if (c == '-'.toInt()) {            sgn = -1            c = read()        }        var number: Long = 0        do {            number *= 10L            number += (c - '0'.toInt()).toLong()            c = read()        } while (!isSpaceChar(c))        return number * sgn    }     fun readString(): String {        var c = read()        while (isSpaceChar(c))            c = read()        val res = StringBuilder()        do {            res.appendCodePoint(c)            c = read()        } while (!isSpaceChar(c))        return res.toString()    }     fun isSpaceChar(c: Int): Boolean {        return filter?.isSpaceChar(c)                ?: (c == ' '.toInt() || c == '\n'.toInt() || c == '\r'.toInt() || c == '\t'.toInt() || c == -1)    }     operator fun next(): String {        return readString()    }     interface SpaceCharFilter {        fun isSpaceChar(ch: Int): Boolean    }} class OutputWriter {    private val writer: PrintWriter     constructor(outputStream: OutputStream) {        writer = PrintWriter(BufferedWriter(OutputStreamWriter(outputStream)))    }     constructor(writer: Writer) {        this.writer = PrintWriter(writer)    }     fun print(vararg objects: Any) {        for (i in objects.indices) {            if (i != 0)                writer.print(' ')            writer.print(objects[i])        }    }     fun printLine(vararg objects: Any) {        print(*objects)        writer.println()    }     fun close() {        writer.close()    }     fun flush() {        writer.flush()    } } class DinitzMaxFlowSolver(val n: Int, val s: Int, val t: Int, val graph: MutableMap<Int, MutableList<Edge>>, val edgeMap: MutableMap<Pair<Int, Int>, Edge>) {     private val level = IntArray(n + 1) { -1 }  //storing levels of each vertex in level graph    var maxFlow = 0L     init {        solve()    }     fun solve() {        val next = IntArray(n + 1) { 0 }        while (bfs()) {            Arrays.fill(next, 0)            var flow = 0L            do {                maxFlow += flow                flow = dfs(s, next, Long.MAX_VALUE)            } while (flow != 0L)        }    }     private fun dfs(at: Int, next: IntArray, flow: Long): Long {        if (at == t) return flow        var size = 0        if (graph.containsKey(at)) size = graph[at]!!.size        while (next[at] < size) {            val edge = graph[at]!!.get(next[at])            if (edge.remainingCapacity() > 0 && level[edge.to] == level[at] + 1) {                val bottleNeck = dfs(edge.to, next, Math.min(flow, edge.remainingCapacity()))                if (bottleNeck > 0) {                    edgeMap[Pair(edge.from, edge.to)]!!.flow += bottleNeck                    edgeMap[Pair(edge.to, edge.from)]!!.flow -= bottleNeck                    return bottleNeck                }            }            next[at]++        }        return 0    }     private fun bfs(): Boolean {        Arrays.fill(level, -1)        val curLevel = ArrayDeque<Int>()        curLevel.add(s)        level[s] = 0         while (curLevel.isNotEmpty()) {            val top = curLevel.poll()            if (graph.containsKey(top)) {                graph[top]!!.forEach {                    if (it.remainingCapacity() > 0 && level[it.to] == -1) {                        level[it.to] = level[top] + 1                        curLevel.offer(it.to)                    }                }            }        }        return level[t] != -1    }  } class Edge(val from: Int, val to: Int, val capacity: Long) {    var flow = 0L    fun remainingCapacity(): Long {        return capacity - flow    }}  class ConnectedComponents(val g : Graph, val price : IntArray){     private val visited = HashSet<Int>()    private val stack = Stack<Int>()    private val revertedGraph = revertGraph()    private val component = mutableListOf<Int>()    var ways= 1L    var min = 0L    val mod = 1000000007     init {        getConnectedComponents()    }      fun getConnectedComponents() {        g.vertices.forEach {            if (!visited.contains(it)){                visited.add(it)                dfs(it)            }        }         visited.clear()        while (stack.isNotEmpty()){            val node = stack.pop()            if (!visited.contains(node)){                visited.add(node)                dfs2(node)                var take = Int.MAX_VALUE                for (i in 0 until component.size){                    if (price[component[i] - 1] < take){                        take = price[component[i] - 1]                    }                }                min+= take                ways= (ways*component.filter { price[it - 1] == take }.count())%mod                component.clear()            }        }    }     fun dfs(node : Int){        if (g.edges.containsKey(node)){            g.edges[node]!!.forEach {                if (!visited.contains(it)){                    visited.add(it)                    dfs(it)                }            }        }        stack.push(node)    }     fun dfs2(node : Int){        component.add(node)        if (revertedGraph.edges.containsKey(node)){            revertedGraph.edges[node]!!.forEach {                if (!visited.contains(it)){                    visited.add(it)                    dfs2(it)                }            }        }    }     fun revertGraph() : Graph {        val newEdges= mutableMapOf<Int, MutableList<Int>>()        g.edges.forEach {            val u = it.key            val vs = it.value            vs.forEach { v ->                if (!newEdges.containsKey(v)){                    newEdges[v]= mutableListOf()                }                newEdges[v]!!.add(u)            }        }        return Graph(g.vertices, newEdges)    }} data class Graph(val vertices: MutableList<Int>, val edges : MutableMap<Int, MutableList<Int>>)","constructive algorithms,games,math"
"private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of ints fun process (c1:Int,c2:Int,x:Int,y:Int,a:Long):Boolean {    var xy =a/(x*y)    var x1  = (a/x) -xy    var y1  = (a/y) -xy    var rest= a - xy - x1 - y1    var cnt1 = c1.toLong()    var cnt2 = c2.toLong()     cnt1 = cnt1- y1    if (cnt1 > 0)        rest -= cnt1     cnt2 = cnt2 -x1    if (cnt2 >0)        rest -= cnt2     if (rest >= 0 )        return true     return false}fun BinarySearch (l:Long,r:Long,c1:Int,c2:Int,x:Int,y:Int,):Long{    var l1 = l; var r1 = r; var res =-1L    while (l1 <= r1) {        var mid = (l1+r1)/2        var res1= process(c1,c2,x,y,mid)        if (res1){            res = mid            r1 = mid-1        }        else l1 = mid+1    }    return res}fun main(args: Array<String>) {    var (cnt1,cnt2,x,y) = readInts()    var res = BinarySearch(1,Long.MAX_VALUE,cnt1,cnt2,x,y)    println(res)}","binary search,math"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007 class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  fun solve() {    val cnt1 = nl()    val cnt2 = nl()    val X = nl()    val Y = nl()     val MAX = if (isDebug) 10 else Long.MAX_VALUE / 2 // 2e18ぐらいでok    val ans = findMin(1L, MAX) { a ->      val x = a / X      val y = a / Y      val xy = a / (X * Y)      val notX = a - x      val notY = a - y      val notXy = a - (x + y - xy)      val need1 = max(0, cnt1 - notX + notXy)      val need2 = max(0, cnt2 - notY + notXy)      debug{""$a $notX $notY $notXy $need1 $need2""}      notXy >= need1 + need2    }    out.print(ans)  }   /**   * [l, r]   */  fun findMin(l: Long, r: Long, f: (Long) -> Boolean): Long {    // (l, h]    var low = l - 1    var high = r    while(high - low > 1) {      val m = (low + high) / 2      if (f(m)) high = m      else low = m    }    return high  }                                              private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private val reader = BufferedReader(InputStreamReader(stream), 32768)  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return map(n, offset) { ni() }  }   private inline fun map(n: Int, offset: Int = 0, f: (Int) -> Int): IntArray {    val res = IntArray(n)    for (i in 0 until n) {      res[i] = f(i + offset)    }    return res  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: BooleanArray) {    debug { a.map { if (it) 1 else 0 }.joinToString("""") }  }   private fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }} fun <A, B> pair(a: A, b: B) = RPair(a, b)data class RPair<A, B>(val _1: A, val _2: B) fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","binary search,math"
"fun main() {    val r = System.`in`.bufferedReader()    val sb = StringBuilder()    var (a, b, c) = r.readLine().split("" "").map { it.toLong() }.sorted()    val res1 = minOf(b - a, (c - b) / 2)    b -= res1    c -= 2 * res1    val res2 = minOf(a + b, (a + b + c) / 3)    print(res1+res2)}",greedy
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport kotlin.math.max fun main() {    val input = BufferedReader(InputStreamReader(System.`in`))    val rgb = input.readLine().split(' ').map { it.toLong() }.sortedDescending().toLongArray()     val leftovers = max(0, rgb[0] - rgb[1] * 2 - rgb[2] * 2)    val result = (rgb.sum() - leftovers) / 3     println(result)}",greedy
"import java.util.Scannerimport kotlin.math.*import kotlin.system.exitProcessfun readln() = readLine()!!fun readint() = readln().toInt()fun readlong() = readln().toLong()fun readdouble() = readln().toDouble()fun readstrings() = ArrayList(readln().split("" ""))fun readints() = ArrayList(readstrings().map { it.toInt() })fun readlongs() = ArrayList(readstrings().map { it.toLong() })fun readdoubles() = ArrayList(readstrings().map { it.toDouble() }) data class Pair(val x: Int, val y: Int)  fun main(){    var reader = Scanner(System.`in`)    //var tt = reader.nextInt()    var tt = 1    while(tt > 0){        var v = mutableListOf<Char>();        var r = reader.nextLong()        var g = reader.nextLong()        var b = reader.nextLong()        if(maxOf(r,g,b) >= 2L*(r+b+g-maxOf(r,g,b))){            println(r+b+g-maxOf(r,g,b))        }else {            println((r+g+b)/3L)        }        tt--    }}",greedy
"//io in outimport java.io.*import java.util.*import java.lang.Math.* class fs (stream : InputStream = System.`in`) {	val DEFAULT_BUFF = 1024	val EOF : Byte = -1	val INT_MIN = 48	val INT_MAX = 57	val NEG : Byte = 45	var ints = ByteArray(58,{i : Int -> ( if(i>=48) i-48 else 0 ).toByte()} )	val stream = stream	var buff = ByteArray(DEFAULT_BUFF)	var buffPtr = -1	fun nextInt () : Int {		var vl = 0		var sign = readNonDigits()		while(isDigit(buff[buffPtr]) && buff[buffPtr] != EOF){			vl = vl.shl(3) + vl.shl(1) + ints[buff[buffPtr].toInt()].toInt()			buffPtr++			if(buffPtr == buff.size) updateBuff()  		}		return vl*sign	}	fun nextLong () : Long {		var vl : Long = 0		var sign = readNonDigits()		while(isDigit(buff[buffPtr]) && buff[buffPtr] != EOF){			vl = (vl.shl(3) + vl.shl(1)).toLong() + ints[buff[buffPtr].toInt()].toLong()			buffPtr++			if(buffPtr == buff.size) updateBuff()  		}		return vl*sign	}	fun readNonDigits() : Byte {		if(buffPtr == -1 || buffPtr == buff.size) updateBuff()		var signByte : Byte = -1		while(isDigit(buff[buffPtr]) == false){			signByte = buff[buffPtr]			buffPtr++			if(buffPtr >= buff.size) updateBuff()		}		return if(signByte == NEG) -1 else 1	}	fun close() = stream.close()	fun isDigit(b : Byte) : Boolean { return b >= INT_MIN && b <= INT_MAX }	fun updateBuff() { buffPtr = 0 ; stream.read(buff) } } fun main(){	val sc = fs()	var a = LongArray(3,{sc.nextLong()})	a.sort()	a[2] = min(a[2],2*(a[1]+a[0]))	println((a[0]+a[1]+a[2])/3)}",greedy
"import kotlin.math.maximport kotlin.math.min fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val (p, q, l, r) = readInts()    val ps = Array(p) { 0 to 0 }    val qs = Array(q) { 0 to 0 }    for (i in 0 until p) {        val (start, end) = readInts()        ps[i] = start to end    }    for (i in 0 until q) {        val (start, end) = readInts()        qs[i] = start to end    }    val sols = mutableSetOf<Int>()    for (cp in ps)        for (cq in qs) {            val left = max(cp.first - cq.second, l)            val right = min(cp.second - cq.first, r)            for (i in left..right) sols.add(i)        }    print(sols.size)}",implementation
"fun main() {    val r = System.`in`.bufferedReader()    val sb = StringBuilder()    val (p, q, le, ri) = r.readLine().split("" "").map { it.toInt() }    val g = BooleanArray(1001) { false }    repeat(p) {        val (a, c) = r.readLine().split("" "").map { it.toInt() }        (a..c).forEach { g[it] = true }    }    val v = List(q) {        val (a, c) = r.readLine().split("" "").map { it.toInt() }        Pair(a, c)    }    var cnt = 0    loop@for (shift in le..ri) {        for ((x, y) in v) {            for (num in x..y) {                if (num+shift<=1000&&g[num+shift]) {                    cnt++                    continue@loop                }            }        }    }    print(cnt)}",implementation
"import java.io.BufferedReaderimport java.io.InputStreamReader fun intersects (p1: Pair<Int, Int>, p2: Pair<Int, Int>): Boolean =    (p1.first >= p2.first && p1.first <= p2.second) || (p2.first >= p1.first && p2.first <= p1.second) fun main() {    val br = BufferedReader(InputStreamReader(System.`in`))    val (p, q, l, r) = br.readLine().split("" "").map { it.toInt() }    val littleX = List(p){        val (a, b) = br.readLine().split("" "").map { it.toInt() }        a to b    }    val littleZ = List(q){        val (c, d) = br.readLine().split("" "").map {it.toInt()}        c to d    }     var cnt = 0    for (i in l .. r) {        val validRanges = littleZ.map { (a, b) -> a + i to b + i }        val validMoment = validRanges.any { p ->            littleX.any { intersects(p, it) }        }        cnt += if (validMoment) 1 else 0    }     println(cnt)}",implementation
"import java.util.* fun main() {    val read = Scanner(System.`in`)     val p = read.nextInt() // z    val q = read.nextInt() // x    val l = read.nextInt() // x    val r = read.nextInt() // x    read.nextLine()     val a = IntArray(p) // z    val b = IntArray(p) // z     for (i in 0 until p) {        a[i] = read.nextInt()        b[i] = read.nextInt()        read.nextLine()    }     val c = IntArray(q) // x    val d = IntArray(q) // x     for (i in 0 until q) {        c[i] = read.nextInt()        d[i] = read.nextInt()        read.nextLine()    }     var count = 0     for (k in l..r) {        loop@        for (i in 0 until p) {            for (j in 0 until q) {                if (isIntersects(a[i], b[i], c[j] + k, d[j] + k)) {                    count++                    break@loop                }            }        }    }     println(count)} private fun isIntersects(a: Int, b: Int, c: Int, d: Int): Boolean {    if (a <= c) {        if (c <= b) return true    } else {        if (a <= d) return true    }     return false}",implementation
"import kotlin.math.max fun main() {    val (n, m, k) = readLine()!!.split(' ').map(String::toInt)    val a = readLine()!!.split(' ').map(String::toLong)    val s = LongArray(n + 1)    for (i in 1..n) {        s[i] = s[i - 1] + a[i - 1]    }    var prev: LongArray    var cur = LongArray(n + 1)    for (j in 1..k) {        prev = cur        cur = LongArray(n + 1)        for (i in (j * m)..n) {            cur[i] = max(cur[i - 1], prev[i - m] + s[i] - s[i - m])        }    }    println(cur[n])}","dp,implementation"
"import kotlin.math.abs fun main() {    val r = System.`in`.bufferedReader()    val sb = StringBuilder()    val (n, len, pair) = r.readLine().split("" "").map { it.toInt() }    val v = r.readLine().split("" "").map { it.toLong() }     val sum = MutableList(n) { 0L }    sum[0] = v[0]    (1 until n).forEach { sum[it] = sum[it - 1] + v[it] }    fun getSum(i: Int, j: Int) = if (i == 0) sum[j] else sum[j] - sum[i - 1]     // point -> choose or not -> choosed max sum for each pair cnt    val dp = List(n) { List(2) { MutableList(pair + 1) { 0L } } }     for (i in 0 until n) {        // Not enough lens        if (i < len - 1) continue         // 0 -> skip this        loop2@ for (j in 0 until 2) {             // how many pair until know after choose this            //for (k in 0 until pair + 1) {            //println(""range ${pair - (n - i + 1) / len} .. ${(i + 1) / len}"")            for (k in maxOf(0, pair - (n - i + 1) / len) until minOf(pair+1, (i + 1) / len+1)) {                //println(""k is $k"")                when {                    // use previous one value                    j == 0 -> {                        if (i != 0) dp[i][j][k] = maxOf(dp[i - 1][0][k], dp[i - 1][1][k])                    }                    // choose this, k should minus one                    // this k is bigger than 0                    j == 1 -> {                        if (k != 0 && i != len - 1) dp[i][1][k] = maxOf(dp[i - len][0][k - 1], dp[i - len][1][k - 1]) + getSum(i - len + 1, i)                        if (k != 0 && i == len - 1) dp[i][1][1] = getSum(0, len - 1)                    }                }            }        }    }    sb.appendln(maxOf(dp[n - 1][0][pair], dp[n - 1][1][pair]))    println(sb)}","dp,implementation"
"import java.io.PrintWriterimport java.util.* lateinit var sieve: Array<Int>  var CONST: Long = 1000000007lateinit var dpp: Array<Array<Array<Boolean?>>>var CONST1: Long = 998244353var ans = 0lateinit var dp: Array<LongArray>lateinit var dp1: Array<BooleanArray>lateinit var visitedAns: Array<BooleanArray>lateinit var dpAns: Array<BooleanArray>lateinit var state: Array<IntArray>lateinit var fac:LongArrayvar un2 = 0var un1 = 0lateinit var prefix:LongArrayfun main() {    var (n,m,k)=readInts()    var arr=readLongs()    dp=Array(n+1){LongArray(k+1){-1} }    prefix=LongArray(n+1){0}    for ((ind,i) in arr.withIndex()){        var l=ind        if(l+m-1<arr.size){            while(l<=ind+m-1){                prefix[ind]+=arr[l]                l++            }        }    }    println(dp(0,k,arr,m))} fun dp(ind:Int,k:Int,arr:ArrayList<Long>,m:Int):Long{     if(k==0){        return 0    }    if(ind>=arr.size){        return Int.MIN_VALUE.toLong()    }    if(dp[ind][k]!=-1L){        return dp[ind][k]    }    dp[ind][k]=maxOf(prefix[ind]+dp(ind+m,k-1,arr,m),dp(ind+1,k,arr,m))    return dp[ind][k]} class Quadraple<T1, T2, T3, T4>(var first: T1, var second: T2, var third: T2, var fourth: T4) @JvmFieldval INPUT = System.`in` @JvmFieldval OUTPUT = System.out @JvmFieldval _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!! @JvmFieldvar _tokenizer: StringTokenizer = StringTokenizer("""") @JvmFieldval _writer = PrintWriter(OUTPUT, false)inline fun output(block: PrintWriter.() -> Unit) {    _writer.apply(block).flush()} fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()} private fun readInt() = readLn().toInt() // single intprivate fun readLong() = readLn().toLong()  // single longprivate fun readDouble() = readLn().toDouble() // single doubleprivate fun readStrings() = readLn().trim().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } as ArrayList<Int>// list of intsprivate fun readLongs() = readStrings().map { it.toLong() } as ArrayList<Long>// list of longsprivate fun readDoubles() = readStrings().map { it.toDouble() } as ArrayList<Double> // list of doubles","dp,implementation"
"import java.io.*import java.util.* class Solution : Runnable {    override fun run() {        solve()    }     fun start() {        Thread(null, Solution(), ""whatever"", (1 shl 27).toLong()).start()    }} fun main(args: Array<String>) {    Solution().start()}  class IO {    companion object {         private val reader: InputReader        private val writer: OutputWriter         init {            if (System.getProperty(""ONLINE_JUDGE"") == null  ) {                reader = InputReader(FileInputStream(""/Users/300041735/competitiveProgramming/src/codeforces/in.txt""))                writer = OutputWriter(FileOutputStream(""/Users/300041735/competitiveProgramming/src/codeforces/out.txt""))            } else {                reader = InputReader(System.`in`)                writer = OutputWriter(System.`out`)            }        }         private fun readMultipleInts(count: Int): List<Int> {            val map = mutableListOf<Int>()            repeat(count) {                map.add(reader.readInt())            }            return map        }         fun readInt() = reader.readInt()        fun readLong() = reader.readLong()        fun readTwoInts() = readMultipleInts(2)        fun readThreeInts() = readMultipleInts(3)        fun readFourInts() = readMultipleInts(4)        fun readFiveInts() = readMultipleInts(5)        fun readSixInts() = readMultipleInts(6)        fun readString() = reader.readString()        fun readTree(n: Int): MutableMap<Int, MutableList<Int>> {            val graph = mutableMapOf<Int, MutableList<Int>>()            repeat(n - 1) {                val u = reader.readInt()                val v = reader.readInt()                if (!graph.containsKey(u)) graph[u] = mutableListOf()                if (!graph.containsKey(v)) graph[v] = mutableListOf()                graph[u]!!.add(v)                graph[v]!!.add(u)            }            return graph        }         fun readIntArray(n: Int): IntArray {            return IntArray(n) { readInt() }        }         fun readLongArray(n: Int): Array<Long> {            return Array(n) { readLong() }        }         fun write(obj: Any) {            writer.printLine(obj)        }         fun flushOutput() {            writer.flush()        }         fun closeOutput() {            writer.close()        }    }}  class MATH {    companion object {         val mod = 1000000007        var ispre = false         val factMod = Array(300002) { 1 }         fun pre() {            for (i in 2 until 300001) {                factMod[i] = ((factMod[i - 1] * i.toLong()) % MATH.mod).toInt()            }        }         fun gcd(a: Int, b: Int): Int {            if (b == 0)                return a            return gcd(b, a % b)        }         fun gcd(a: Long, b: Long): Long {            if (b == 0L)                return a            return gcd(b, a % b)        }         fun inverseMod(a: Int): Int {            return powMod(a, mod - 2)        }         fun powMod(a: Int, b: Int): Int {            //calculate a to the power b mod m            if (b == 0) return 1            return if (b % 2 == 1) {                prodMod(a, powMod(a, b - 1))            } else {                val p = powMod(a, b / 2)                prodMod(p, p)            }        }         fun ncr(n: Int, r: Int): Int {            if (!ispre) pre(); ispre = true            return ((factMod[n].toLong() * inverseMod(((factMod[r].toLong() * factMod[n - r]) % mod).toInt())) % mod).toInt()        }         fun prodMod(val1: Int, val2: Int): Int {            return ((val1.toLong() * val2) % mod).toInt()        }     }} fun solve() {     val (n, m , k) = IO.readThreeInts()    val p = IO.readIntArray(n)    val pp = LongArray(n + 1) { 0L }    for (i in 1 until n + 1){        pp[i] = pp[i - 1] + p[i - 1]    }     val dp = DP(n, m, k , pp)    IO.write(dp.dp(1,  0))     IO.flushOutput()    IO.closeOutput()} class DP(val n : Int, val m : Int, val k : Int, val p : LongArray){     val map = Array<LongArray>(n + 1) { LongArray(k + 1) { -1L }}    fun dp(pos : Int, done : Int) : Long{        //pos represents which index we are one and done represents how many we have already choosen        if (done == k) return 0L        if (pos == n + 1) return Long.MIN_VALUE        if (map[pos][done] != -1L) return map[pos][done]        var best = Long.MIN_VALUE        if (pos + m - 1 <= n){            //it is possible            val ans1 = dp(pos + m, done + 1)            if (ans1 != Long.MIN_VALUE){                best = Math.max(best, ans1 + p[pos + m - 1] - p[pos - 1])            }        }        //or we can simply move forward        val ans2= dp(pos + 1, done)        if (ans2 != Long.MIN_VALUE){            best = Math.max(best, ans2)        }        map[pos][done] = best        return best    }}  data class Graph(val edges: MutableMap<Int, MutableList<Int>>)  class MinSegmentTree(        input: Array<Int>) {    private val tree: Array<Int>    private val lazy: Array<Int>     constructor(size: Int) : this(Array(size) { Int.MAX_VALUE })     init {        val size = nextPowerOfTwo(input.size)        tree = Array(2 * size) { Int.MAX_VALUE }        lazy = Array(2 * size) { Int.MAX_VALUE }        for (i in 0 until input.size) {            tree[i + size] = input[i]        }        for (i in (size - 1) downTo 1) {            tree[i] = Math.min(tree[leftChild(i)], tree[rightChild(i)])        }    }     private fun updateTree(lowerRange: Int, upperRange: Int, lowerBound: Int, upperBound: Int, index: Int, value: Int) {        updateLazyNode(index, lowerBound, upperBound, lazy[index])        if (noOverlap(lowerRange, upperRange, lowerBound, upperBound)) return        else if (completeOverlap(lowerRange, upperRange, lowerBound, upperBound)) updateLazyNode(index, lowerBound, upperBound, value)        else {            updateTree(lowerRange, upperRange, lowerBound, midIndex(lowerBound, upperBound), leftChild(index), value)            updateTree(lowerRange, upperRange, midIndex(lowerBound, upperBound) + 1, upperBound, rightChild(index), value)            tree[index] = Math.min(tree[leftChild(index)], tree[rightChild(index)])        }    }     private fun queryTree(lowerRange: Int, upperRange: Int, lowerBound: Int, upperBound: Int, index: Int): Int {        updateLazyNode(index, lowerBound, upperBound, lazy[index])        if (noOverlap(lowerRange, upperRange, lowerBound, upperBound)) return Int.MAX_VALUE        else if (completeOverlap(lowerRange, upperRange, lowerBound, upperBound)) return tree[index]        else {            return Math.min(queryTree(lowerRange, upperRange, lowerBound, midIndex(lowerBound, upperBound), leftChild(index)),                    queryTree(lowerRange, upperRange, midIndex(lowerBound, upperBound) + 1, upperBound, rightChild(index)))        }    }     private fun updateLazyNode(index: Int, lowerBound: Int, upperBound: Int, delta: Int) {        tree[index] += delta        if (lowerBound != upperBound) {            lazy[leftChild(index)] += delta            lazy[rightChild(index)] += delta        }        lazy[index] = 0    }     fun getElements(N: Int): List<Int> {        return tree.copyOfRange(tree.size / 2, tree.size / 2 + N).asList()    }     fun update(lowerRange: Int, upperRange: Int, value: Int) {        updateTree(lowerRange, upperRange, 1, lazy.size / 2, 1, value)    }     fun query(lowerRange: Int, upperRange: Int): Int {        return queryTree(lowerRange, upperRange, 1, lazy.size / 2, 1)    }     private fun noOverlap(l: Int, u: Int, lb: Int, ub: Int): Boolean = (lb > u || ub < l)     private fun completeOverlap(l: Int, u: Int, lb: Int, ub: Int): Boolean = (lb >= l && ub <= u)      private fun nextPowerOfTwo(num: Int): Int {        var exponent = 2        while (true) {            if (exponent >= num) {                return exponent            }            exponent *= 2        }    }     private fun midIndex(l: Int, r: Int) = (l + r) / 2    private fun parent(i: Int) = i / 2    private fun leftChild(i: Int) = 2 * i    private fun rightChild(i: Int) = 2 * i + 1 } class InputReader(private val stream: InputStream) {    private val buf = ByteArray(1024)    private var curChar: Int = 0    private var numChars: Int = 0    private val filter: SpaceCharFilter? = null     fun read(): Int {        if (numChars == -1)            throw InputMismatchException()        if (curChar >= numChars) {            curChar = 0            try {                numChars = stream.read(buf)            } catch (e: IOException) {                throw InputMismatchException()            }             if (numChars <= 0)                return -1        }        return buf[curChar++].toInt()    }     fun readInt(): Int {        var c = read()        while (isSpaceChar(c))            c = read()        var sgn = 1        if (c == '-'.toInt()) {            sgn = -1            c = read()        }        var res = 0        do {            if (c < '0'.toInt() || c > '9'.toInt())                throw InputMismatchException()            res *= 10            res += c - '0'.toInt()            c = read()        } while (!isSpaceChar(c))        return res * sgn    }     fun readLong(): Long {        var c = read()        while (isSpaceChar(c)) {            c = read()        }        var sgn: Long = 1        if (c == '-'.toInt()) {            sgn = -1            c = read()        }        var number: Long = 0        do {            number *= 10L            number += (c - '0'.toInt()).toLong()            c = read()        } while (!isSpaceChar(c))        return number * sgn    }     fun readString(): String {        var c = read()        while (isSpaceChar(c))            c = read()        val res = StringBuilder()        do {            res.appendCodePoint(c)            c = read()        } while (!isSpaceChar(c))        return res.toString()    }     fun isSpaceChar(c: Int): Boolean {        return filter?.isSpaceChar(c)                ?: (c == ' '.toInt() || c == '\n'.toInt() || c == '\r'.toInt() || c == '\t'.toInt() || c == -1)    }     operator fun next(): String {        return readString()    }     interface SpaceCharFilter {        fun isSpaceChar(ch: Int): Boolean    }} class OutputWriter {    private val writer: PrintWriter     constructor(outputStream: OutputStream) {        writer = PrintWriter(BufferedWriter(OutputStreamWriter(outputStream)))    }     constructor(writer: Writer) {        this.writer = PrintWriter(writer)    }     fun print(vararg objects: Any) {        for (i in objects.indices) {            if (i != 0)                writer.print(' ')            writer.print(objects[i])        }    }     fun printLine(vararg objects: Any) {        print(*objects)        writer.println()    }     fun close() {        writer.close()    }     fun flush() {        writer.flush()    } } class DinitzMaxFlowSolver(val n: Int, val s: Int, val t: Int, val graph: MutableMap<Int, MutableList<Edge>>, val edgeMap: MutableMap<Pair<Int, Int>, Edge>) {     private val level = IntArray(n + 1) { -1 }  //storing levels of each vertex in level graph    var maxFlow = 0L     init {        solve()    }     fun solve() {        val next = IntArray(n + 1) { 0 }        while (bfs()) {            Arrays.fill(next, 0)            var flow = 0L            do {                maxFlow += flow                flow = dfs(s, next, Long.MAX_VALUE)            } while (flow != 0L)        }    }     private fun dfs(at: Int, next: IntArray, flow: Long): Long {        if (at == t) return flow        var size = 0        if (graph.containsKey(at)) size = graph[at]!!.size        while (next[at] < size) {            val edge = graph[at]!!.get(next[at])            if (edge.remainingCapacity() > 0 && level[edge.to] == level[at] + 1) {                val bottleNeck = dfs(edge.to, next, Math.min(flow, edge.remainingCapacity()))                if (bottleNeck > 0) {                    edgeMap[Pair(edge.from, edge.to)]!!.flow += bottleNeck                    edgeMap[Pair(edge.to, edge.from)]!!.flow -= bottleNeck                    return bottleNeck                }            }            next[at]++        }        return 0    }     private fun bfs(): Boolean {        Arrays.fill(level, -1)        val curLevel = ArrayDeque<Int>()        curLevel.add(s)        level[s] = 0         while (curLevel.isNotEmpty()) {            val top = curLevel.poll()            if (graph.containsKey(top)) {                graph[top]!!.forEach {                    if (it.remainingCapacity() > 0 && level[it.to] == -1) {                        level[it.to] = level[top] + 1                        curLevel.offer(it.to)                    }                }            }        }        return level[t] != -1    }  } class Edge(val from: Int, val to: Int, val capacity: Long) {    var flow = 0L    fun remainingCapacity(): Long {        return capacity - flow    }}","dp,implementation"
"import kotlin.math.pow fun main() {    val (m, n) = readLine()!!.split("" "").map { it.toInt() }    var answer = m.toDouble()    for (k in 0 until m) {        answer -= (k.toDouble() / m.toDouble()).pow(n)    }    println(answer)}",probabilities
"import kotlin.math.pow fun main() {    val (m, n) = readLine()!!.split(' ').map { it.toInt() }     var ans: Double = 0.0     val probabilities: MutableList<Double> = MutableList(m + 2) { 0.0 }    for (face in m downTo 1) {//        print(""1"")        val probHere = prob(face, m, n)        probabilities[face] = probHere    } //    println(probabilities)    for(face in m downTo 1) {        ans += face * (probabilities[face] - probabilities[face + 1])    }     println(ans) } fun prob(face: Int, m: Int, n: Int): Double {    val temp = (face - 1.0) / (m.toDouble())//    print(temp)    return 1 - temp.pow(n.toDouble())}",probabilities
"import java.io.PrintWriterimport java.util.StringTokenizerimport kotlin.math.floorimport kotlin.math.powimport kotlin.math.roundToInt //private val INPUT = File(""input.txt"").inputStream()//private val OUTPUT = File(""output.txt"").outputStream()private val INPUT = System.`in`private val OUTPUT = System.out private val bufferedReader = INPUT.bufferedReader()private val outputWriter = PrintWriter(OUTPUT, false)private fun readLn() = bufferedReader.readLine()!! private fun readList() = readLn().split(' ')private var tokenizer = StringTokenizer("""")private fun read(): String {    while (tokenizer.hasMoreTokens().not()) tokenizer = StringTokenizer(readLn(), "" "")    return tokenizer.nextToken()} private fun readInt() = read().toInt()private fun readLong() = read().toLong()private fun readDouble() = read().toDouble() private fun readIntList() = readList().map { it.toInt() }private fun readLongList() = readList().map { it.toLong() }private fun readDoubleList() = readList().map { it.toDouble() } private fun readIntArray(n: Int = 0) =    if (n == 0) readList().run { IntArray(size) { get(it).toInt() } } else IntArray(n) { readInt() } private fun readLongArray(n: Int = 0) =    if (n == 0) readList().run { LongArray(size) { get(it).toLong() } } else LongArray(n) { readLong() } private fun readDoubleArray(n: Int = 0) =    if (n == 0) readList().run { DoubleArray(size) { get(it).toDouble() } } else DoubleArray(n) { readDouble() }  private fun Int.modPositive(other: Int): Int = if (this % other < 0) ((this % other) + other) else (this % other)  private class LIttePonyAndExpectedMaximun {     fun solveTestCase(m: Int, n: Int): Double {        //TODO: Solve the question        var ans: Double = m.toDouble()        for(i in 1 until m) {            var temp = i.toDouble() / m.toDouble()            ans -= temp.pow(n)        }        return ans    }} fun main(args: Array<String>) {    var m = readInt()    var n = readInt()    outputWriter.println(        LIttePonyAndExpectedMaximun()            .solveTestCase(m,n)    )     outputWriter.flush()}",probabilities
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"")@file:OptIn(ExperimentalStdlibApi::class) import java.io.PrintWriterimport kotlin.math.*import kotlin.random.Randomimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {//    val startTime = System.nanoTime()     val numCases = 1//readInt()    case@ for(case in 1..numCases) {//        print(""Case #$case: "")         val m = readInt()        val n = readInt()         var ans = 0.0        var pr = 0.0        for(i0 in 1..m) {            val i = i0.toDouble()            val p = (i / m).pow(n)            ans += i * (p - pr)            pr = p        }         println(ans)    } //    iprintln(""Time: ${(System.nanoTime() - startTime) / 1000000} ms"")} /** IO *///const val PATH = ""src/main/resources/""//@JvmField val INPUT = File(PATH + ""input.txt"").inputStream()//@JvmField val OUTPUT = File(PATH + ""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar()        else c    }} /** @param skipNext Whether to skip the next character (usually whitespace), defaults to true */fun readCharArray(n: Int, skipNext: Boolean = true): CharArray {    val res = CharArray(n) { readChar() }    if(skipNext) readChar()    return res} fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(c != '\n' && c != Char.MIN_VALUE) {            append(c)            c = readChar()        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /**  sort overrides to avoid quicksort attacks */ @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } fun IntArray.sort() { shuffle(random); _sort() }fun IntArray.sortDescending() { shuffle(random); _sortDescending() } fun LongArray.sort() { shuffle(random); _sort() }fun LongArray.sortDescending() { shuffle(random); _sortDescending() } fun DoubleArray.sort() { shuffle(random); _sort() }fun DoubleArray.sortDescending() { shuffle(random); _sortDescending() } inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T : Comparable<T>> Array<out T>.sort() = _sort()inline fun <T : Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T : Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T : Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() // import preserving junk function@Suppress(""NonAsciiCharacters"") fun 雪花飄飄北風嘯嘯天地一片蒼茫() { iprintln(max(1, 2)) } fun IntArray.sumLong() = sumOf { it.toLong() } // max/min Kotlin 1.6 -> 1.4 shimfun IntArray.max() = maxOf { it }fun IntArray.min() = minOf { it }fun LongArray.max() = maxOf { it }fun LongArray.min() = minOf { it }fun CharArray.max() = maxOf { it }fun CharArray.min() = minOf { it }fun <T : Comparable<T>> Iterable<T>.max() = maxOf { it }fun <T : Comparable<T>> Iterable<T>.min() = minOf { it }fun <T : Comparable<T>> Sequence<T>.max() = maxOf { it }fun <T : Comparable<T>> Sequence<T>.min() = minOf { it }",probabilities
"const val M = 1000000007fun main(args: Array<String>) {    val (x,y) = readLine()!!.split(' ').take(2).map{it.toLong()}    val n = readLine()!!.toLong()    val nums= arrayOf((x-y)%M,x,y)    val (div,mod)=(n/3L) to (n%3L)    val sign = -1L*((div%2L)*2L-1L)    val ans = nums[mod.toInt()]*sign    println(if (ans<0) M+ans else ans) }","implementation,math"
"fun main(args: Array<String>) {    val r = System.`in`.bufferedReader()    val (x, y) = r.readLine()!!.split("" "").map { it.toLong() }    val n = r.readLine()!!.toInt()    var ans = when (n % 6) {        2 -> y        3 -> y - x        4 -> -x        5 -> -y        0 -> x - y        else -> x    }    while (ans<0) ans+=1000000007    println(ans%1000000007) }","implementation,math"
"fun main() {    val r = System.`in`.bufferedReader()    val s = StringBuilder()    var (x, y) = r.readLine()!!.split("" "").map { it.toLong() }    val n = r.readLine()!!.toInt()    var ans = when (n % 6) {        2 -> y        3 -> y - x        4 -> -x        5 -> -y        0 -> x - y        else -> x    }    while (ans<0) ans+=1000000007    println(ans%1000000007)}","implementation,math"
"fun main() {    val (a, b) = rla()    val t = ri()    val mod = 1000000007    val s = longArrayOf(a, b, b - a, -a, -b, a - b)    val ans = (s[(t - 1) % 6] % mod + mod) % mod    println(ans)} private fun rla() = r().split("" "").map { it.toLong() }private fun ri() = r().toInt()private fun r() = readLine()!!private fun prYN(ok: Boolean) = if (ok) println(""YES"")else println(""NO"")","implementation,math"
"import java.io.PrintWriterimport java.util.* val CONST1: Long = 998244353lateinit var sieve: IntArraylateinit var primes: ArrayList<Int>fun main() {    var t = 1    //t = readInt()    output {        repeat(t) {            solve(it, this)        }    }} fun solve(it: Int, out: PrintWriter) {    var n = readInt()    var arr = readDoubles()    arr.sort()    arr.reverse()    var ans = arr.last()    var cans:Double = 0.0    var prod:Double = 1.0    for (i in arr.indices) {        cans *= (1 - arr[i])        cans += (arr[i]) * prod        prod *= (1 - arr[i])        ans = maxOf(ans, cans)    }    println(ans)} @JvmFieldval INPUT = System.`in` @JvmFieldval OUTPUT = System.out @JvmFieldval _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!! @JvmFieldvar _tokenizer: StringTokenizer = StringTokenizer("""") @JvmFieldval _writer = PrintWriter(OUTPUT, false)inline fun output(block: PrintWriter.() -> Unit) {    _writer.apply(block).flush()} fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()} private fun readInt() = readLn().toInt() // single intprivate fun readLong() = readLn().toLong()  // single longprivate fun readDouble() = readLn().toDouble() // single doubleprivate fun readStrings() = readLn().trim().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } as ArrayList<Int>// list of intsprivate fun readLongs() = readStrings().map { it.toLong() } as ArrayList<Long>// list of longsprivate fun readDoubles() = readStrings().map { it.toDouble() } as ArrayList<Double> // list of doubles","greedy,math,probabilities"
"/** * Description: Kotlin tips for dummies * Source: https://codeforces.com/blog/entry/71089, Spheniscine, Benq */ // episode 1: https://codeforces.com/contest/1170// episode 2: https://codeforces.com/contest/1211/* comparing pairs	val pq = PriorityQueue<Pair<Long,Int>>({x,y -> x.first.compareTo(y.first)})										~ (compareBy {it.first})	val A = arrayListOf(Pair(1,3),Pair(3,2),Pair(2,3))	val B = A.sortedWith(Comparator<Pair<Int,Int>>{x,y -> x.first.compareTo(y.first)})	sortBy *//* hashmap	val h = HashMap<String,Int>()	for (i in 0..n-2) {		val w = s.substring(i,i+2)		val c = h.getOrElse(w){0}		h.put(w,c+1)	} *//* basically switch, can be used as expression	when (x) {		0,1 -> print(""x <= 1"")		2 -> print(""x == 2"")		else -> { // Note the block			print(""x is neither 1 nor 2"")		}	}*/// swap : a = b.also { b = a }// arraylist remove element at index: removeAt, not remove ...// lower bound: use .binarySearch() @file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"") import java.io.PrintWriterimport java.util.StringTokenizerimport java.util.TreeMapimport java.util.PriorityQueueimport kotlin.math.*import kotlin.random.*import kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln   fun PrintWriter.solve() {    var n = readInt()    var p = readDoubleArray(n)     p.sort()    if (p[n - 1] == 1.0) {        println(1.0)        return    }    var sum = 0.0    var product = 1.0    for (i in n - 1 downTo 0) {        if (sum < 1) {            sum += p[i] / (1 - p[i])            product *= 1 - p[i]        } else {            break        }    }    println(sum * product)} fun main() {    var t = 1    // t = readInt()    for (i in 1..t) {        _writer.solve()        _writer.flush()    }} /** IO code start *///@JvmField val INPUT = File(""input.txt"").inputStream()//@JvmField val OUTPUT = File(""output.txt"").outputStream()@JvmFieldval INPUT = System.`in` @JvmFieldval OUTPUT = System.out @JvmFieldval _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!! @JvmFieldvar _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(        _reader.readLine()            ?: return """", "" ""    )    return _tokenizer.nextToken()} fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmFieldval _writer = PrintWriter(OUTPUT, false) /** shuffles and sort overrides to avoid quicksort attacks */private inline fun <T> _shuffle(rnd: Random, get: (Int) -> T, set: (Int, T) -> Unit, size: Int) {    // Fisher-Yates shuffle algorithm    for (i in size - 1 downTo 1) {        val j = rnd.nextInt(i + 1)        val temp = get(i)        set(i, get(j))        set(j, temp)    }} @JvmFieldvar _random: Random? = nullval random    get() = _random        ?: Random(0x564E235C123 * System.nanoTime()).also { _random = it } fun IntArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)fun IntArray.sort() {    shuffle(); _sort()} fun IntArray.sortDescending() {    shuffle(); _sortDescending()} fun LongArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)fun LongArray.sort() {    shuffle(); _sort()} fun LongArray.sortDescending() {    shuffle(); _sortDescending()} fun DoubleArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)fun DoubleArray.sort() {    shuffle(); _sort()} fun DoubleArray.sortDescending() {    shuffle(); _sortDescending()} fun CharArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)inline fun CharArray.sort() {    _sort()} inline fun CharArray.sortDescending() {    _sortDescending()} inline fun <T : Comparable<T>> Array<out T>.sort() = _sort()inline fun <T : Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T : Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T : Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() fun `please stop removing these imports IntelliJ`() {    (max(1, 2))} val MOD = (1e9 + 7).toInt()val INF = (1e18).toLong() fun add(a: Int, b: Int) = (a + b) % MOD // from tourist :ofun sub(a: Int, b: Int) = (a - b + MOD) % MODfun mul(a: Int, b: Int) = ((a.toLong() * b) % MOD).toInt()fun YN(b: Boolean): String {    return if (b) ""YES"" else ""NO""}","greedy,math,probabilities"
"import kotlin.math.min val ones = ArrayList<Long>() fun lowerBound(n: Long): Int{    var(lo, hi) = 0 to ones.size - 1    while(lo < hi){        val mid = (lo + hi) / 2 + (lo + hi) % 2        if(ones[mid] < n)            lo = mid        else            hi = mid - 1    }    return lo} val memo = HashMap<Long, Long>() fun rec(n: Long): Long{    if(n in memo)        return memo[n]!!    val bs = lowerBound(n)    if(ones[bs + 1] == n){        memo[n] = (bs + 2).toLong()        return (bs + 2).toLong()    }    var ans = Long.MAX_VALUE    if(n - ones[bs] < n)        ans = min(ans, rec(n - ones[bs]) + bs + 1)    if(ones[bs + 1] - n < n)        ans = min(ans, rec(ones[bs + 1] - n) + bs + 2)    memo[n] = ans    return ans} fun main() {    val n = readLine()!!.toLong()    for(i in 1..16)        ones.add(""1"".repeat(i).toLong())    memo[0L] = 0L    for(i in 1L..6L)        memo[i] = i    for(i in 7L..11L)        memo[i] = 13-i    println(rec(n))}","brute force,dfs and similar,divide and conquer"
"import java.io.PrintWriterimport java.util.StringTokenizer fun main() {    val n0 = readLong()     val M = LongArray(17)    for(i in 1 until M.size) M[i] = M[i-1] * 10 + 1     var D = hashMapOf(n0 to 0)     for(k in M.size-2 downTo 1) {        if(M[k] > n0) continue         val Dk = HashMap<Long, Int>()         for((n, c) in D) {            Dk.checkMin(n % M[k], c + (n / M[k] * k).toInt())            val n1 = M[k+1] - n            Dk.checkMin(n1 % M[k], c + k + 1 + (n1 / M[k] * k).toInt())        }         D = Dk    }     val ans = D[0]     println(ans)} fun <K> HashMap<K, Int>.checkMin(k: K, v: Int) { if(!containsKey(k) || v < get(k)!!) put(k, v) } /** IO code start */@JvmField val _reader = System.`in`.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readInts(n: Int) = List(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() } @JvmField val _writer = PrintWriter(System.out, false)inline fun output(block: PrintWriter.()->Unit) { _writer.apply(block).flush() }fun iprintln(o: Any?) { println(o) } // immediate println for interactive, bypasses output{} blocks","brute force,dfs and similar,divide and conquer"
"import java.io.PrintWriterimport java.util.StringTokenizer fun main() {    val n0 = readLong()     val M = LongArray(17)    for(i in 1 until M.size) M[i] = M[i-1] * 10 + 1     var D = hashMapOf(n0 to 0)     for(k in M.size-2 downTo 1) {        if(M[k] > n0) continue         val Dk = HashMap<Long, Int>()         for((n, c) in D) {            Dk.checkMin(n % M[k], c + (n / M[k] * k).toInt())            val n1 = M[k+1] - n            Dk.checkMin(n1 % M[k], c + k + 1 + (n1 / M[k] * k).toInt())        }         D = Dk    }     val ans = D[0]     println(ans)} fun <K> HashMap<K, Int>.checkMin(k: K, v: Int) { if(v < getOrDefault(k, Int.MAX_VALUE)) put(k, v) } /** IO code start */@JvmField val _reader = System.`in`.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readInts(n: Int) = List(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() } @JvmField val _writer = PrintWriter(System.out, false)inline fun output(block: PrintWriter.()->Unit) { _writer.apply(block).flush() }fun iprintln(o: Any?) { println(o) } // immediate println for interactive, bypasses output{} blocks","brute force,dfs and similar,divide and conquer"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007 class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  fun solve() {    val N = nl()     fun digits(x: Long): Int {      var a = abs(x)      var k = 0      while(a > 0) {        a /= 10        k++      }      return k    }     val memo = mutableMapOf<Long, Int>()    fun dfs(x: Long, isAlt: Boolean = false): Int {      debug{""x:$x""}      if (x == 0L) return 0      if (memo.containsKey(x)) return memo[x]!!       var a = x      var k = 1      var pow10 = 1L      var sum = 1L      while(a / 10 != 0L) {        a /= 10        k++        pow10 *= 10        sum += pow10      }       var res = 1e9.toInt()      for (i in 1 .. 9) {        for (sig in arrayOf(-1, 1)) {          val next = x + sum * i * sig          if (digits(next) < k) res = min(res, dfs(next) + k * i)        }      }       if (!isAlt) {        for (sig in arrayOf(-1, 1)) {          val sum2 = sum + pow10 * 10          val alt = x + sum2 * sig          debug{""x:$x alt$alt""}          if (digits(alt) <= k) res = min(res, dfs(alt, true) + k + 1)        }      }       memo[x] = res      return res    }    out.println(dfs(N))  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private val reader = BufferedReader(InputStreamReader(stream), 32768)  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return map(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl()    }    return res  }   private inline fun map(n: Int, f: (Int) -> Int): IntArray {    val res = IntArray(n)    for (i in 0 until n) {      res[i] = f(i)    }    return res  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: BooleanArray) {    debug { a.map { if (it) 1 else 0 }.joinToString("""") }  }   private fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","brute force,dfs and similar,divide and conquer"
"fun main() {    val valids = setOf('A', 'H', 'I', 'M', 'O', 'T', 'U', 'V', 'W', 'X', 'Y')    val s = readLine()!!    for (c in s) if (c !in valids) return print(""NO"")    if (s != s.reversed()) return print(""NO"")    print(""YES"")}",implementation
"import java.util.* //ABCDEFGHIJKLMNPQRSTUVWXYZ //AHIMTUVWXY fun main() {    val scanner = Scanner(System.`in`)    val letter = scanner.next()    val mirroredLitters = ""AHIMTUVWXYO""     for (i in letter.indices) {        val first = letter[i]        val last = letter[letter.lastIndex - i]         if (first != last || !mirroredLitters.contains(first)) {            println(""NO"")            return        }    }     println(""YES"")}",implementation
"fun main() {    var n = readLine()!!.toInt()    var max = 1000000001    var min = -max    while (n>0) {        n--        val sxa = readLine()!!.split("" "")        val x = sxa[1].toInt()        when (sxa[0]) {            "">"" -> {                if (sxa[2] == ""Y"") { if (x >= min) min = x + 1}                else if (x < max) { max = x }}            "">="" -> {                if (sxa[2] == ""Y"") { if (x > min) min = x}                else if (x <= max) { max = x - 1 }}            ""<="" -> {                if (sxa[2] == ""N"") { if (x >= min) min = x + 1}                else if (x < max) { max = x }}            else -> {                if (sxa[2] == ""N"") { if (x > min) min = x}                else if (x <= max) { max = x - 1 }}        }    }    print(if (max>=min) max else ""Impossible"")}","greedy,implementation,two pointers"
"fun main(args: Array<String>) {    cfa()} private fun cfa() = with(System.`in`) {    val interval = Interval(-2000_000_000, 2000_000_000)     val n = readLine()!!.toInt()    for (i in 0 until n) {        val (signs, xs, answer) = readLine()!!.split("" "")         val x = xs.toInt()        val sign = if (answer == ""Y"") signs else reverseSign(signs)         interval.update(sign, x)         if (!interval.isValid()) break    }     if (interval.isValid())        println(interval.left)    else        println(""Impossible"")} fun reverseSign(sign: String): String =        when (sign) {            ""<"" -> "">=""            ""<="" -> "">""            "">="" -> ""<""            "">"" -> ""<=""            else -> throw Exception(""Unexpected sign: $sign."")        } class Interval(var left: Int, var right: Int) {    fun update(sign: String, x: Int) {        when (sign) {            ""<"" -> if (right >= x) right = x - 1            ""<="" -> if (right > x) right = x            "">"" -> if (left <= x) left = x + 1            "">="" -> if (left < x) left = x        }    }     fun isValid(): Boolean = left <= right     fun contains(x: Int): Boolean = x >= left && x <= right}","greedy,implementation,two pointers"
"fun main() {    val s = readLine()!!    println(            if (s.length >= 5 &&                    s.contains(Regex(""[a-z]"")) &&                    s.contains(Regex(""[A-Z]"")) &&                    s.contains(Regex(""[0-9]""))) ""Correct"" else ""Too weak"")}","*special,implementation"
"fun main(){    var input = readLine()!!;    passwordCheck(input);} fun passwordCheck(input: String){    var mai = false;    var min = false;    var num = false;    var len = input.length;    if(len < 5){        print(""Too weak"");        return;    }    for(char in input){        if(char.isDigit()){            num = true;        } else if(char.isLowerCase()){            min = true;        } else if(char.isUpperCase()){            mai = true;        }    }    if(mai && min && num) print(""Correct"") else print(""Too weak"")} 			 	  		     		  	 		  	   		","*special,implementation"
"import java.io.*import java.util.* fun <T : Comparable<T>> max(a: T, b: T): T = if (b > a) b else afun <T : Comparable<T>> min(a: T, b: T): T = if (b < a) b else afun Number.isEven(): Boolean = if (this.toInt() and 1 == 0) true else falsefun Number.isOdd(): Boolean = !this.isEven() fun main(args: Array<String>) {    if (args.isNotEmpty()) System.setIn(FileInputStream(args[0]))    val br = BufferedReader(InputStreamReader(System.`in`))    val bw = BufferedWriter(OutputStreamWriter(System.out))     var st = StringTokenizer(br.readLine())    val str = st.nextToken()    var hasDigit = false; var hasLower = false; var hasUpper = false    for (c in str) {        if (c >= '0' && c <= '9') hasDigit = true        else if (c >= 'a' && c <= 'z') hasLower = true        else if (c >= 'A' && c <= 'Z') hasUpper = true    }    if (str.length >= 5 && hasDigit && hasLower && hasUpper) bw.write(""Correct"")    else bw.write(""Too weak"")    bw.newLine()    bw.flush()}","*special,implementation"
"import java.lang.String.formatimport java.util.*import kotlin.math.*import kotlin.system.exitProcess private fun readLn()=readLine()!! // string lineprivate fun readInt()=readLn().toInt() // single intprivate fun readLong()=readLn().toLong() // single longprivate fun readDouble()=readLn().toDouble() // single doubleprivate fun readStrings()=readLn().split("" "") // list of stringsprivate fun readInts()=readStrings().map { it.toInt() } // list of intsprivate fun readLongs()=readStrings().map { it.toLong() } // list of longsprivate fun readDoubles()=readStrings().map { it.toDouble() } // list of doublesfun main(){    val reader=Scanner(System.`in`)    var s=readLn()    var d=0    var e=0    var f=0    for(i in 0 until s.length){        if(s[i]>='0'&&s[i]<='9'){            d=1        }        if(s[i]>='a'&&s[i]<='z'){            e=1        }        if(s[i]>='A'&&s[i]<='Z'){            f=1        }    }    if(d+e+f==3&&s.length>=5){        print(""Correct"")    }    else{        print(""Too weak"")    }}","*special,implementation"
"import kotlin.math.absimport kotlin.math.sign fun main() {    repeat(readLine()!!.toInt()) {        readLine()        val xs = readLine()!!.split("" "").map { it.toInt() }        val abs = xs.map { abs(it) }        val signs = xs.map { it.sign }.sorted()        val shouldBeSorted = abs.zip(signs, Int::times)        println(if (shouldBeSorted == shouldBeSorted.sorted()) ""yEs"" else ""nO"")    }}","greedy,sortings"
"import java.util.*import kotlin.math.abs @JvmFieldval INPUT = System.`in` @JvmFieldval OUTPUT = System.out @JvmFieldval _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!! @JvmFieldvar _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()} fun main() {    val n = read().toInt()     repeat(n) {        solve()    }} fun solve() {    val n = read().toInt()    val a = readLine()!!.split("" "").map { it.toInt() }    var c = a.count { it < 0 }    var p = -Int.MAX_VALUE    var t: Int    a.forEach {        t = abs(it)        if (c > 0) {            if (-t < p) return println(""NO"")            p = -t            c--        } else {            if (t < p) return println(""NO"")            p = t        }    }    println(""YES"")}","greedy,sortings"
"import java.io.*import java.util.*import kotlin.math.* val INPUT = System.`in`!!val OUTPUT = System.out!!fun sort(a: IntArray) {    val l = ArrayList<Int>()    for (value in a) l.add(value)    l.sort()    for (i in l.indices) a[i] = l[i]}const val yes = ""YES""const val no = ""NO""val reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun line() = reader.readLine()!!var st: StringTokenizer = StringTokenizer("""")fun read(): String {    while (st.hasMoreTokens().not())        st = StringTokenizer(reader.readLine() ?: return """", "" "")    return st.nextToken()}fun int() = read().toInt()fun ints(n: Int) = List(n) { read().toInt() }fun intArray(n: Int) = IntArray(n) { read().toInt() }val writer = PrintWriter(OUTPUT, false)fun main() { writer.solve(); writer.flush() }fun PrintWriter.solve() {    var tt = 1    tt = int()    while (tt-- > 0) {        val n = int()        val arr = intArray(n)        var count = 0        for(i in arr) if(i < 0) count++        for(i in arr.indices) {            arr[i] = abs(arr[i])            if(count > 0) {                arr[i] = -arr[i]                count--            }        }        val temp = arr.copyOf()        sort(temp)        if(temp.contentEquals(arr)) println(yes)        else println(no)    }}","greedy,sortings"
"import java.io.BufferedWriterimport java.io.OutputStreamWriterimport java.io.PrintWriterimport java.util.StringTokenizerimport kotlin.math.*import kotlin.random.*import kotlin.collections.* private val INPUT = System.`in`private val OUTPUT = System.out private val bufferedReader = INPUT.bufferedReader()private val outputWriter = BufferedWriter( OutputStreamWriter(OUTPUT));private  fun readLn() = bufferedReader.readLine()!! private fun readList() = readLn().split(' ')private var tokenizer = StringTokenizer("""")private fun read(): String {    while(tokenizer.hasMoreTokens().not()) tokenizer = StringTokenizer(readLn(), "" "")    return tokenizer.nextToken()} private fun readInt() = read().toInt()private fun readLong() = read().toLong()private fun readDouble() = read().toDouble() private fun readIntList() = readList().map { it.toInt() }private fun readLongList() = readList().map { it.toLong() }private fun readDoubleList() = readList().map { it.toDouble() } private fun readIntArray(n: Int = 0) =    if (n == 0) readList().run { IntArray(size) { get(it).toInt() } } else IntArray(n) { readInt() } private fun readLongArray(n: Int = 0) =    if (n == 0) readList().run { LongArray(size) { get(it).toLong() } } else LongArray(n) { readLong() } private fun readDoubleArray(n: Int = 0) =    if (n == 0) readList().run { DoubleArray(size) { get(it).toDouble() } } else DoubleArray(n) { readDouble() }  private fun Int.modPositive(other: Int): Int = if (this % other < 0) ((this % other) + other) else (this % other)   fun main() {    var cases = readInt()    repeat(cases) {        var size = readInt()        var nums = readIntArray(size)         var cando = true        var minuscount = 0        for(i in 0 until size) {            if(nums[i] < 0) {                minuscount++            }            nums[i] = abs(nums[i])         }            for(i in 0 until size) {            if(minuscount > 0) {                nums[i] = -nums[i]                minuscount--            }        }        for(i in 1 until size) {            if(nums[i] < nums[i-1]) {                cando = false                break            }        }          if(cando) {            outputWriter.write(""YES\n"")        } else {            outputWriter.write(""NO\n"")        }     }    outputWriter.close()} ","greedy,sortings"
"import kotlin.math.max fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val (numDays, numKilos) = readInts()    val prices = readInts()    var best = 0    for (day in 0 until numDays - 1)        best = max(best, prices[day] - prices[day + 1] - numKilos)    print(best)}","brute force,greedy,implementation"
"fun main() {    val r = System.`in`.bufferedReader()    val s1 = StringBuilder()    //val n = r.readLine()!!.toInt()    //var (n, m) = r.readLine()!!.split("" "").map { it.toInt() }    val (day, ret) = r.readLine()!!.split("" "").map { it.toInt() }    val v = r.readLine()!!.split("" "").map { it.toInt() }    var get = 0    for (i in 1..day-1){        val profit = (v[i-1]-v[i])-ret        get = maxOf(get, profit)    }    println(get)}","brute force,greedy,implementation"
"import kotlin.math.absimport kotlin.math.max fun main() {    val (r1, c1, r2, c2) = readLine()!!.split("" "").map { it.toLong() }    println(""${if (r1 == r2 || c1 == c2) 1 else 2} ${when {        (c1+r1)%2 != (c2+r2)%2 -> 0        abs(c1-c2) == abs(r1-r2) -> 1        else -> 2}} ${max(abs(r1-r2), abs(c1-c2))}"")}","graphs,math,shortest paths"
"import kotlin.math.absimport kotlin.math.max fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val (r1, c1, r2, c2) = readInts()    print(if (r1 == r2 || c1 == c2) ""1 "" else ""2 "")    val deltaRows = abs(r1 - r2)    val deltaCols = abs(c1 - c2)    print(when {        deltaRows == deltaCols -> ""1 ""        deltaRows and 1 == deltaCols and 1 -> ""2 ""        else -> ""0 ""    })    print(max(deltaRows, deltaCols))}","graphs,math,shortest paths"
"import java.io.*import java.util.* fun <T : Comparable<T>> max(a: T, b: T): T = if (b > a) b else afun <T : Comparable<T>> min(a: T, b: T): T = if (b < a) b else afun Number.isEven(): Boolean = if (this.toInt() and 1 == 0) true else falsefun Number.isOdd (): Boolean = !this.isEven() fun main(args: Array<String>) {    if (args.isNotEmpty()) System.setIn(FileInputStream(args[0]))    val br = BufferedReader(InputStreamReader(System.`in`))    val bw = BufferedWriter(OutputStreamWriter(System.out))     val (r1, c1, r2, c2) = br.readLine().split(' ').map(String::toInt)    val rook :Int; val bishop :Int; val king :Int     if (r1 == r2 && c1 == c2) rook = 0    else if (r1 == r2 || c1 == c2) rook = 1    else rook = 2     if (r1 == r2 && c1 == c2) bishop = 0    else if ((Math.abs(r1-r2).isOdd() && Math.abs(c1-c2).isEven())            || (Math.abs(r1-r2).isEven() && Math.abs(c1-c2).isOdd())) bishop = 0    else if (Math.abs(r1-r2) == Math.abs(c1-c2)) bishop = 1    else bishop = 2     if (r1 == r2 && c1 == c2) king = 0    else king = max(Math.abs(r1-r2), Math.abs(c1-c2))     bw.write(""$rook $bishop $king\n"")    bw.close()}","graphs,math,shortest paths"
"import java.io.*import java.util.* fun main() {    solve(System.`in`, System.out)} fun solve(input: InputStream, output: OutputStream) {    val reader = InputReader(BufferedInputStream(input))    val writer = PrintWriter(BufferedOutputStream(output))     solve(reader, writer)    writer.close()} fun solve(ir : InputReader, pw : PrintWriter) {     val r1 : Int = ir.nextInt()    val c1 : Int = ir.nextInt()    val r2 : Int = ir.nextInt()    val c2 : Int = ir.nextInt()    val dis1 : Int = Math.abs(r1 - r2)    val dis2 : Int = Math.abs(c1 - c2)    val rest : Int = Math.abs(dis1 - dis2)     if (r1 != r2 && c1 != c2)        pw.print(""2 "")    else        pw.print(""1 "")     if (dis1 % 2 == dis2 % 2) {        when {            dis1 != dis2 -> pw.print(""2 "")            else -> pw.print(""1 "")        }    } else        pw.print(""0 "")     if (dis1 >= dis2)        pw.print(""${dis2 + rest}"")    else        pw.print(""${dis1 + rest}"") } class InputReader(stream: InputStream) {    private val reader: BufferedReader = BufferedReader(InputStreamReader(stream), 32768)    private var tokenizer: StringTokenizer? = null     init {        tokenizer = null    }     operator fun next(): String {        while (tokenizer == null || !tokenizer!!.hasMoreTokens())            try {                tokenizer = StringTokenizer(reader.readLine())            } catch (e: IOException) {                throw RuntimeException(e)            }         return tokenizer!!.nextToken()    }     fun nextLine(): String? {        val fullLine: String        while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {            try {                fullLine = reader.readLine()            } catch (e: IOException) {                throw RuntimeException(e)            }             return fullLine        }        return null    }     fun toArray(): Array<String> {        return nextLine()!!.split("" "".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()    }     fun nextInt(): Int {        return Integer.parseInt(next())    }     fun nextDouble(): Double {        return java.lang.Double.parseDouble(next())    }     fun nextLong(): Long {        return java.lang.Long.parseLong(next())    } }","graphs,math,shortest paths"
"fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val (numStairs, numDirtyStairs) = readInts()    if (numDirtyStairs == 0) return print(""YES"")    val dirty = readInts().sorted()    if (dirty[0] == 1) return print(""NO"")    if (dirty.last() == numStairs) return print(""NO"")    for (pos in 2 until dirty.size)        if (dirty[pos - 2] == dirty[pos] - 2) return print(""NO"")    print(""YES"")}","implementation,sortings"
"fun main() {    var data = readLine()!!.split("" "").map { it -> it.toInt() }    var n = data[0]    var m = data[1]     if (m == 0) {        println(""YES"")        return    }     var array = readLine()!!.split("" "").map { it -> it.toInt() }.sorted()     if (array[0] == 1 || array[m - 1] == n) {        println(""NO"")        return    }     for (i in 1 until m - 1) {        if (array[i] - array[i - 1] == 1 && array[i + 1] - array[i] == 1) {            println(""NO"")            return        }     }     println(""YES"")}","implementation,sortings"
"fun main() {    var data = readLine()!!.split("" "").map { it -> it.toInt() }    var n = data[0]    var m = data[1]     if (m == 0) {        println(""YES"")        return    }     var array = readLine()!!.split("" "").map { it -> it.toInt() }.sorted()     if (array[0] == 1 || array[m - 1] == n) {        println(""NO"")        return    }     for (i in 1 until m - 1) {        if (array[i] - array[i - 1] == 1 && array[i + 1] - array[i] == 1) {            println(""NO"")            return        }     }     println(""YES"")}","implementation,sortings"
"fun main() {    val r = System.`in`.bufferedReader()    val sb = StringBuilder()    val (n, m) = r.readLine().split("" "").map { it.toInt() }    val v = if (m != 0) r.readLine().split("" "").map { it.toInt() }.sorted() else listOf()    when {        m == 0 -> sb.appendln(""YES"")        v[0] == 1 || v.last() == n -> sb.appendln(""NO"")        else -> {            var ok = true            for (i in 1 until m - 1) {                if (v[i] - v[i - 1] == 1 && v[i + 1] - v[i] == 1) ok = false            }            sb.appendln(if (ok) ""YES"" else ""NO"")        }    }    print(sb)}","implementation,sortings"
"import java.util.* fun main(args: Array<String>) {    var sc = Scanner(System.`in`)    var n = sc.nextInt()    var k = sc.nextInt()        var tab = IntArray(n*2+1)    for ( i in 1 ..tab.size-1){        tab[i]=  i    }//    for each k added one to the sum        for (i in 1 ..k){        var temp = tab[2*i]            tab[2*i]=tab[2*i-1]        tab[2*i-1]=temp    }    for (i in 1 ..tab.size-1){        print(""""+tab[i] + "" "")    } }","constructive algorithms,dp,math"
"fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val (numDigits, sumResult) = readInts()    if (sumResult == 0 && numDigits > 1) return print(""No solution"")    val sb = StringBuilder()    sb.append(sumResult)    for (i in 1 until numDigits) sb.append('9')    print(sb.toString())}","constructive algorithms,implementation"
"import java.util.* /** * Created by Hamza on 20/11/2017. */fun main(args: Array<String>) {    var sc = Scanner(System.`in`)    var k = sc.nextInt()-1    var d = sc.nextInt()    if (k > 0 && d == 0 )println(""No solution"")    else {        print(d)        while (k-->0){            print(0)        }    }}","constructive algorithms,implementation"
"import kotlin.math.absimport kotlin.math.sqrt fun main() {    val r = System.`in`.bufferedReader()    val sb = StringBuilder()    val n = r.readLine().toInt()    val v = r.readLine().split("" "").map { it.toInt() - 1 }    val adj = List(100000) { mutableListOf<Int>() }    val b = StringBuilder()    var cnt = 0    for (i in 0 until n) {        adj[v[i]] += i    }    for (i in 0 until 100000) {        when {            adj[i].size == 1 -> {                cnt++                b.appendln(""${i + 1} 0"")            }            adj[i].size > 1 && (0 until adj[i].size - 1).all { adj[i][it + 1] - adj[i][it] == adj[i][1] - adj[i][0] } -> {                cnt++                b.appendln(""${i+1} ${adj[i][1] - adj[i][0]}"")            }        }    }    sb.appendln(cnt)    sb.appendln(b)    print(sb)}","implementation,sortings"
"import java.util.* fun main() {    fun readInt() = readLine()!!.toInt()    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val n = readInt()    val arr = readInts()    val discarded = mutableSetOf<Int>()    val last = mutableMapOf<Int, Int>()    val delta = TreeMap<Int, Int>().withDefault { Int.MIN_VALUE }    for ((pos, a) in arr.withIndex())        if (a !in discarded)            when (delta.getValue(a)) {                Int.MIN_VALUE -> {                    last[a] = pos                    delta[a] = 0                }                0 -> delta[a] = pos - last[a]!!                else -> {                    if (arr[pos - delta[a]!!] != a) {                        discarded.add(a)                        last.remove(a)                        delta.remove(a)                    }                }            }    println(delta.size)    print(delta.entries.joinToString(separator = System.lineSeparator()) { ""${it.key} ${it.value}"" })}","implementation,sortings"
"import java.util.* fun main () {    val scanner = Scanner(System.`in`)    val queue = PriorityQueue<Pair>()    val i = scanner.nextLine().toInt()     repeat(i) {        queue.add(Pair(scanner.nextInt(), it))    }     var count = 1    var prev : Pair? = null    var prevDiff : Int? = -1    var isOk = true    var answers = 0     val builder = StringBuilder()    while (!queue.isEmpty()) {        val current = queue.poll()        //println(current)         if (current.a != prev?.a) {            if (prev != null) {                if (isOk) {                    val total = if (count == 1) {                        0                    } else {                        prevDiff                    }                    builder.append(""${prev.a} $total\n"")                    answers++                }                count = 1                prevDiff = -1                isOk = true            }        } else if (count == 1) {            prevDiff = current.b - prev.b            count++        } else if (current.b - prev.b == prevDiff) {            count++        } else {            isOk = false        }         prev = current    }     if (isOk) {        val total = if (count == 1) {            0        } else {            prevDiff        }         builder.append(""${prev?.a} $total\n"")        answers++    }     println(answers)    if (answers > 0)        println(builder)} class Pair(val a: Int, val b: Int) : Comparable<Pair> {    override fun compareTo(other: Pair): Int {        val first = a.compareTo(other.a)        if (first != 0) {            return first        }        return b.compareTo(other.b)    }     override fun toString(): String {        return ""[$a, $b]""    }}","implementation,sortings"
"import java.io.PrintWriterimport java.util.* fun getProgressionDiff (xs: List<Int>): Int {    return if (xs.size == 1) 0    else {        val diffs = xs.zipWithNext().map { (x, y) -> y - x }        val diff = diffs.first()        val allEq = diffs.all { it == diff }        if (allEq) diff else -1    }} fun PrintWriter.solve () {    val n = readInt()    val a = readInts(n)    val withPositions = a.zip(1..n)    val groupsOfPositions = withPositions.groupBy { it.first }            .mapValues { (num, positions) ->                positions.unzip().second            }    val progressionDiffs = groupsOfPositions            .mapValues { (num, xs) -> getProgressionDiff(xs)}            .filter { (num, p) -> p != -1 }      println(progressionDiffs.size)    for (num in progressionDiffs.keys.sorted()) {        if (num in progressionDiffs)            println(""$num ${progressionDiffs[num]}"")    }} fun main () {    _writer.solve()    _writer.flush()} /** * IO based on submission 69915961 by LightYagami674 */@JvmFieldval input = System.`in`@JvmFieldval output = System.out@JvmFieldval _reader = input.bufferedReader()@JvmFieldvar _tokenizer = StringTokenizer("""") // Readingfun readLine (): String? = _reader.readLine()fun readLn () = _reader.readLine()!!fun read (): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()} fun readInt () = read().toInt()fun readDouble () = read().toDouble()fun readLong () = read().toLong()fun readStrings (n: Int) = List(n) { read() }fun readLines (n: Int) = List(n) { readLn() }fun readInts (n: Int) = IntArray(n) { readInt() }fun readDoubles (n: Int) = DoubleArray(n) { readDouble() }fun readLongs (n: Int) = LongArray(n) { readLong() } // Writing@JvmFieldval _writer = PrintWriter(output, false)","implementation,sortings"
"fun main() {    readLine()    val nums = readLine()!!.split("" "")    var fives = nums.count{ it == ""5"" }    val zeros = nums.count{ it == ""0"" }    fives -= fives % 9    if(zeros > 0) {        if(fives > 0)            println(""5"".repeat(fives) + ""0"".repeat(zeros))        else            println(0)    }    else {        println(-1)    }}","brute force,implementation,math"
"fun main() {    val r = System.`in`.bufferedReader()    val s = StringBuilder()    val n = r.readLine()!!.toInt()    val five = r.readLine()!!.split("" "").map { it.toInt() }.count { it == 5 }    val zero = n - five    when {        zero == 0 -> println(-1)        five < 9 -> println(0)        else -> println((List(five / 9 * 9) { 5 } + List(zero) { 0 }).joinToString(""""))    }}","brute force,implementation,math"
"fun main() {    val a = readLine()!!.toInt()    val arr = readLine()!!.split("" "").map { it.toInt() }    var c =0    var z = 0    for (i in arr) {        if (i==5) {            c++        }        if (i==0){            z++        }    }    if (c>=9 && z>0) {        repeat((c/9)*9) {            print(""5"")        }        repeat(z) {            print(""0"")        }    } else if (z>0) {        print(""0"")    } else {        print(""-1"")    }}","brute force,implementation,math"
"fun main (){    readInt()    var list = readInts()    var five = 0    var zero = 0    list.forEach{        if (it==5){            five++        }else{            zero++        }    }    if (five>=9 && zero>0){        for (i in 0 until five/9) print(""555555555"")        for (i in 0 until zero) print(""0"")    }else if (zero==0){        println(-1)    }else{        println(0)    }} private fun readInts(): List<Int> = readLine()!!.split(' ').map { it.toInt() }private fun readLongs(): List<Long> = readLine()!!.split(' ').map { it.toLong() }private fun readInt(): Int = readLine()!!.toInt()private fun readLong(): Long = readLine()!!.toLong()private fun readStr(): String? = readLine()!!","brute force,implementation,math"
"import java.io.BufferedReaderimport java.io.InputStreamReader fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val n = jin.readLine().toInt()    val xs = jin.readLine().split("" "").map { it.toLong() }.sorted()    var numerator = 0L    for (j in 0 until n) {        numerator += (3L + (4L * j.toLong()) - (2L * n.toLong())) * xs[j]    }    val g = gcd(numerator, n.toLong())    println(""${numerator / g} ${n.toLong() / g}"")} fun gcd(a: Long, b: Long): Long = if (b == 0L) a else gcd(b, a % b)","combinatorics,implementation,math"
