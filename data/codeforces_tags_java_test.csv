"// package c1661;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStreamReader;\nimport java.lang.invoke.MethodHandles;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\n//\n// Educational Codeforces Round 126 (Rated for Div. 2) 2022-04-09 07:35\n// E. Narrow Components\n// https://codeforces.com/contest/1661/problem/E\n// time limit per test 2 seconds; memory limit per test 256 megabytes\n// public class Pseudo for 'Source should satisfy regex [^{}]*public\s+(final)?\s*class\s+(\w+).*'\n//\n// You are given a matrix a, consisting of 3 rows and n columns. Each cell of the matrix is either\n// free or taken.\n//\n// A free cell y is reachable from a free cell x if at least one of these conditions hold:\n//  * x and y share a side;\n//  * there exists a free cell z such that z is reachable from x and y is reachable from z.\n//\n// A connected component is a set of free cells of the matrix such that all cells in it are\n// reachable from one another, but adding any other free cell to the set violates this rule.\n//\n// You are asked q queries about the matrix. Each query is the following:\n//  * l r-- count the number of connected components of the matrix, consisting of columns from l to\n//    r of the matrix a, inclusive.\n//\n// Print the answers to all queries.\n//\n// Input\n//\n// The first line contains an integer n (1 <= n <= 5 * 10^5)-- the number of columns of matrix a.\n//\n// The i-th of the next three lines contains a description of the i-th row of the matrix a-- a\n// string, consisting of n characters. Each character is either 1 (denoting a free cell) or 0\n// (denoting a taken cell).\n//\n// The next line contains an integer q (1 <= q <= 3 * 10^5)-- the number of queries.\n//\n// The j-th of the next q lines contains two integers l_j and r_j (1 <= l_j <= r_j <= n)-- the\n// description of the j-th query.\n//\n// Output\n//\n// Print q integers-- the j-th value should be equal to the number of the connected components of\n// the matrix, consisting of columns from l_j to r_j of the matrix a, inclusive.\n//\n// Example\n/*\ninput:\n12\n100101011101\n110110010110\n010001011101\n8\n1 12\n1 1\n1 2\n9 9\n8 11\n9 12\n11 12\n4 6\n\noutput:\n7\n1\n1\n2\n1\n3\n3\n3\n*/\n//\npublic class C1661E {\n  static final int MOD = 998244353;\n  static final Random RAND = new Random();\n\n  // Wrong answer on test 18\n  // wrong answer 16853rd numbers differ - expected: '3', found: '2'\n  static int[] solve(int[][] a, int[][] queries) {\n    trace(a);\n    int n = a[0].length;\n    int q = queries.length;\n    int[] ans = new int[q];\n\n    int id = detectGroups(a, n);\n\n    int[] la = detectLeftMeetArray(a, n);\n\n    int[] ra = detectRightMeetArray(a, n);\n\n    int[] precnt = computePrecnt(a, n, id);\n\n    for (int i = 0; i < q; i++) {\n      int l = queries[i][0];\n      int r = queries[i][1];\n      // unique groups observed in [l,r]\n      ans[i] = precnt[r] - (l == 0 ? 0 : precnt[l-1]);\n      if (test) System.out.format(""  ans[i]:%d\n"", ans[i]);\n\n      // count unique group cross the left boundary, at most 2\n      Set<Integer> ids = new HashSet<>();\n      if (l > 0) {\n        for (int h = 0; h < 3; h++) {\n          if (a[h][l] == a[h][l-1] && a[h][l] != 0) {\n            if (test) System.out.format(""  group %d across left\n"", a[h][l]);\n            ids.add(a[h][l]);\n          }\n        }\n        ans[i] += ids.size();\n      }\n\n      boolean isl = isSplit(a, l);\n      boolean isr = isSplit(a, r);\n\n      if (!isl && !isr) {\n        //  x.......x\n        //  0.......0\n        //  z.......w\n        //  ^       ^\n        //  l       r\n      } else if (!isl && isr) {\n        //  x........y\n        //  0........0\n        //  z........y\n        if (la[r] < l) {\n          ans[i]++;\n        }\n      } else if (isl && !isr) {\n        //  x........x      x.......y\n        //  0........0  OR  0.......0\n        //  x........y      x.......z\n        if (ra[l] > r) {\n          ans[i]++;\n        }\n      } else {\n        myAssert(isl && isr);\n        // 0220302022\n        // 0022002202\n        // 2222222222\n        //  ^      ^\n        //  l      r\n        if (a[0][l] == a[0][r]) {\n          if (l == r) {\n            // x\n            // 0\n            // x\n            ans[i] += 1;\n          }\n          // xxxxxx  xxxxxxx    xxxxxxx    xxxxxxxx\n          // 000x00  0000000 or 0000000 or 00x00000\n          // xxxxxx  xxxxxxx    x0...0x    xxx0000x\n          //   +0      +1          +2         +1\n          else if (ra[l] == n) {\n            if (la[r] == -1) {\n              // xx00000xx\n              // x0000000x like\n              // xxxxxxxxx\n              //  ^     ^\n              //  l     r\n              ans[i] += 2;\n            } else if (la[r] < l) {\n              //  xxxxxxxxx\n              //  x00000000 like\n              //  xxxxxxxxx\n              //   ^     ^\n              //   l     r\n              ans[i] += 1;\n            } else {\n              //  xx000xxxx\n              //  x0000x00x like\n              //  xxxxxxxxx\n              //   ^     ^\n              //   l     r\n              ans[i] += 1;\n            }\n          } else if (ra[l] > r) {\n            if (la[r] == -1) {\n              //  xxxxxxxxx\n              //  00000000x\n              //  xxxxxxxxx\n              //   ^     ^\n              //   l     r\n              ans[i] += 1;\n            } else if (la[r] < l) {\n              //  xxxxxxxxx\n              //  x0000000x like\n              //  xxxxxxxxx\n              //   ^     ^\n              //   l     r\n              ans[i] += 1;\n            } else {\n              myAssert(false);\n            }\n          } else {\n            if (la[r] == -1) {\n              //  xxxx00x\n              //  000x000\n              //  xxxxxxx\n              //  ^     ^\n              //  l     r\n              ans[i] += 1;\n            } else if (la[r] < l) {\n              myAssert(false);\n            } else {\n              //  xxxxxxx\n              //  000x000\n              //  xxxxxxx\n              //  ^     ^\n              //  l     r;\n            }\n          }\n        } else {\n          if (ra[l] > r) {\n            ans[i]++;\n          }\n          if (la[r] < l) {\n            ans[i]++;\n          }\n        }\n      }\n      if (test) {\n        System.out.format(""  i:%2d [%2d,%2d] isl:%d isr:%d ra:%2d la:%2d %d -> %d\n"",\n            i, l, r, isl ? 1 : 0, isr ? 1 : 0, ra[l], la[r], ids.size(), ans[i]);\n      }\n\n    }\n    return ans;\n  }\n\n  private static int[] computePrecnt(int[][] a, int n, int id) {\n    int[] precnt = new int[n];\n    boolean[] seen = new boolean[id];\n    seen[0] = true;\n    for (int j = 0; j < n; j++) {\n      precnt[j] = j == 0 ? 0 : precnt[j-1];\n      for (int i = 0; i < 3; i++) {\n        if (!seen[a[i][j]]) {\n          precnt[j]++;\n          seen[a[i][j]] = true;\n        }\n      }\n    }\n    if (test) {\n      System.out.format(""  pcnt:%s\n"", trace(precnt));\n    }\n    return precnt;\n  }\n\n  private static int[] detectRightMeetArray(int[][] a, int n) {\n    int[] ra = new int[n];\n    Arrays.fill(ra, n);\n    for (int j = n-1; j >= 0; j--) {\n      if (a[0][j] != a[2][j] || a[0][j] == 0) {\n        continue;\n      }\n      // top and bottom belongs to the same group\n      int gid = a[0][j];\n      if (a[1][j] == gid) {\n        // they meet at middle of column j\n        ra[j] = j;\n      } else if (j < n - 1) {\n        if (a[0][j+1] == gid && a[2][j+1] == gid) {\n          ra[j] = ra[j+1];\n        } else {\n          // 23\n          // 0*\n          // 22\n          // they don't meet to the right\n        }\n      }\n    }\n    if (test) {\n      System.out.format(""    ra:%s\n"", trace(ra));\n    }\n    return ra;\n  }\n\n  private static int[] detectLeftMeetArray(int[][] a, int n) {\n    // la[j] is the nearest left column <= j first and third row meet\n    int[] la = new int[n];\n    Arrays.fill(la, -1);\n    for (int j = 0; j < n; j++) {\n      if (a[0][j] != a[2][j] || a[0][j] == 0) {\n        continue;\n      }\n      // top and bottom belongs to the same group\n      int gid = a[0][j];\n      if (a[1][j] == gid) {\n        // they meet at middle of column j\n        la[j] = j;\n      } else if (j > 0) {\n        if (a[0][j-1] == gid && a[2][j-1] == gid) {\n          la[j] = la[j-1];\n        } else {\n          // 32\n          // *0\n          // 22\n          // they don't meet to the left\n        }\n      }\n    }\n    if (test) {\n      System.out.format(""    la:%s\n"", trace(la));\n    }\n    return la;\n  }\n\n  private static int detectGroups(int[][] a, int n) {\n    int id = 2;\n    Queue<int[]> queue = new LinkedList<>();\n    final int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}};\n    for (int j = 0; j < n; j++) {\n      for (int i = 0; i < 3; i++) {\n        // 1 denotes free cell\n        if (a[i][j] != 1) {\n          continue;\n        }\n        a[i][j] = id;\n        queue.add(new int[] {i,j});\n        while (!queue.isEmpty()) {\n          int[] v = queue.poll();\n          for (int[] dir : dirs) {\n            int r = v[0] + dir[0];\n            int c = v[1] + dir[1];\n            if (r >= 0 && r < 3 && c >= 0 && c < n && a[r][c] == 1) {\n              a[r][c] = id;\n              queue.add(new int[] {r,c});\n            }\n          }\n        }\n        id++;\n      }\n    }\n\n    trace(a);\n    return id;\n  }\n\n  static boolean isSplit(int[][] a, int j) {\n    return a[0][j] == a[2][j] && a[0][j] != 0 && a[1][j] == 0;\n  }\n\n  static void trace(int[][] a) {\n    if (test) {\n      for (int i = 0; i < 3; i++) {\n        System.out.format(""  %s\n"", trace(a[i]));\n      }\n    }\n  }\n\n  static int[] solveNaiveInvalid(int[][] a, int[][] queries) {\n    int n = a[0].length;\n    int q = queries.length;\n    int[][] incr = {\n      //          000 001 010 011 100 101 110 111\n      /* 000 */  {  0,  1,  1,  1,  1,  2,  1,  1},\n      /* 001 */  {  0,  0,  1,  0,  1,  1,  1,  0},\n      /* 010 */  {  1,  1,  0,  0,  1,  2,  0,  0},\n      /* 011 */  {  0,  0,  0,  0,  1,  1,  0,  0},\n      /* 100 */  {  0,  1,  1,  1,  0,  1,  0,  0},\n      /* 101 */  {  0,  0,  1,  0,  0,  0,  0,  0},\n      /* 110 */  {  0,  1,  0,  0,  0,  1,  0,  0},\n      /* 111 */  {  0,  0,  0,  0,  0,  0,  0,  0}\n    };\n\n    // dp[i][j] is number of unique groups within columns [i,j]\n    int[][] dp = new int[n][n];\n    for (int i = 0; i < n; i++) {\n      dp[i][i] = a[1][i] == 1 ? 1 : a[0][i] + a[2][i];\n      for (int j = i + 1; j < n; j++) {\n        int k1 = a[0][j-1] + a[1][j-1] * 2 + a[2][j-1] * 4;\n        int k2 = a[0][j] + a[1][j] * 2 + a[2][j] * 4;\n        dp[i][j] = dp[i][j-1] + incr[k1][k2];\n      }\n    }\n\n    int[] ans = new int[q];\n    for (int i = 0; i < q; i++) {\n      ans[i] = dp[queries[i][0]][queries[i][1]];\n    }\n    return ans;\n  }\n\n  static int[] solveNaive(int[][] a, int[][] queries) {\n    int n = a[0].length;\n    int q = queries.length;\n\n    int[] ans = new int[q];\n    for (int i = 0; i < q; i++) {\n      int l = queries[i][0];\n      int r = queries[i][1];\n      ans[i] = detectGroups(a, l, r);\n    }\n    return ans;\n  }\n\n  private static int detectGroups(int[][] a, int l, int r) {\n    int id = 2;\n    Queue<int[]> queue = new LinkedList<>();\n    final int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}};\n    for (int j = l; j <= r; j++) {\n      for (int i = 0; i < 3; i++) {\n        // 1 denotes free cell\n        if (a[i][j] != 1) {\n          continue;\n        }\n        a[i][j] = id;\n        queue.add(new int[] {i,j});\n        while (!queue.isEmpty()) {\n          int[] v = queue.poll();\n          for (int[] dir : dirs) {\n            int x = v[0] + dir[0];\n            int y = v[1] + dir[1];\n            if (x >= 0 && x < 3 && y >= l && y <= r && a[x][y] == 1) {\n              a[x][y] = id;\n              queue.add(new int[] {x,y});\n            }\n          }\n        }\n        id++;\n      }\n    }\n\n    for (int j = l; j <= r; j++) {\n      for (int i = 0; i < 3; i++) {\n        if (a[i][j] > 1) {\n          a[i][j] = 1;\n        }\n      }\n    }\n    return id - 2;\n  }\n\n  static void test(int[][] a, int[][] queries) {\n    int n = a[0].length;\n    int q = queries.length;\n    int[] exp = solveNaive(a, queries);\n\n    int[][] b = new int[3][n];\n    for (int i = 0; i < 3; i++) {\n      System.arraycopy(a[i], 0, b[i], 0, n);\n    }\n\n    int[] ans = solve(b, queries);\n    for (int i = 0; i < q; i++) {\n      if (ans[i] != exp[i]) {\n        System.out.format(""  i:%4d [%d,%d] ans:%d exp:%d\n"", i, queries[i][0], queries[i][1], ans[i], exp[i]);\n        showAsBits(a);\n        showAsBits(a, queries[i][0], queries[i][1]);\n      }\n      myAssert(ans[i] == exp[i]);\n    }\n  }\n\n  static int[][] getArrFromS(String[] s) {\n    myAssert(s.length == 3);\n    int n = s[0].length();\n    int[][] a = new int[3][n];\n    for (int i = 0; i < 3; i++) {\n      for (int j = 0; j < n; j++) {\n        a[i][j] = s[i].charAt(j) - '0';\n      }\n    }\n    return a;\n  }\n\n  static boolean test = false;\n  static void doTest() {\n    if (!test) {\n      return;\n    }\n    long t0 = System.currentTimeMillis();\n    {\n      String[] s = {\n          ""011101110101101111100011"",\n          ""010010011000000101110101"",\n          ""011100010001100110110111""};\n      int[][] a = getArrFromS(s);\n      int[][] queries = {{2,2}};\n      test(a, queries);\n    }\n    {\n      String[] s = {\n          ""000111011011111011101011111010"",\n          ""011111000111111011010000101100"",\n          ""010101001011010010011101011110""};\n      int[][] a = getArrFromS(s);\n      int[][] queries = {{25,25}};\n      test(a, queries);\n    }\n    {\n      int[][] a = {\n          {0,1,1,0,1,0,1,0,1,1},\n          {0,0,1,1,0,0,1,1,0,1},\n          {1,1,1,1,1,1,1,1,1,1}};\n      int[][] queries = {{1,8}};\n      test(a, queries);\n    }\n\n    for (int t = 0; t < 20; t++) {\n      int n = 1 + RAND.nextInt(99);\n      int[][] a = new int[3][n];\n      for (int i = 0; i < n; i++) {\n        a[0][i] = RAND.nextInt(2);\n        a[1][i] = RAND.nextInt(2);\n        a[2][i] = RAND.nextInt(2);\n      }\n      int q = Math.min(400, n * n / 2);\n      int[][] queries = new int[q][2];\n      for (int i = 0; i < q; i++) {\n        int v1 = RAND.nextInt(n);\n        int v2 = RAND.nextInt(n);\n        queries[i][0] = Math.min(v1, v2);\n        queries[i][1] = Math.max(v1, v2);\n      }\n      test(a, queries);\n    }\n\n    System.out.format(""%d msec\n"", System.currentTimeMillis() - t0);\n    System.exit(0);\n  }\n\n  static void showAsBits(int[][] a) {\n    int n = a[0].length;\n    showAsBits(a, 0, n-1);\n  }\n\n  static void showAsBits(int[][] a, int l, int r) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < 3; i++) {\n      sb.setLength(0);\n      for (int j = l; j <= r; j++) {\n        sb.append((char)('0' + a[i][j]));\n      }\n      System.out.format(""  %s\n"", sb.toString());\n    }\n    char[] ca = new char[r-l+1];\n    for (int j = l; j <= r; j++) {\n      ca[j-l] = j % 10 == 0 ? '*' : ' ';\n    }\n    System.out.format(""  %s\n"", new String(ca));\n  }\n\n  static String trace(int[] a) {\n    StringBuilder sb = new StringBuilder();\n    sb.append('{');\n    int n = a.length;\n    final int h = 16;\n    for (int i = 0; i < a.length; i++) {\n      if (i > h && i < n-h) {\n        continue;\n      }\n      if (sb.length() > 1) {\n        sb.append(',');\n      }\n      if (i == h && n >= h * 2) {\n        sb.append(""..."");\n      } else {\n        sb.append(a[i]);\n      }\n    }\n    sb.append('}');\n    return sb.toString();\n  }\n\n  public static void main(String[] args) {\n    doTest();\n    MyScanner in = new MyScanner();\n    int n = in.nextInt();\n    int[][] a = new int[3][n];\n    for (int i = 0; i < 3; i++) {\n      String s = in.next();\n      for (int j = 0; j < n; j++) {\n        a[i][j] = s.charAt(j) - '0';\n      }\n    }\n    int q = in.nextInt();\n    int[][] queries = new int[q][2];\n    for (int i = 0; i < q; i++) {\n      queries[i][0] = in.nextInt() - 1;\n      queries[i][1] = in.nextInt() - 1;\n    }\n    int[] ans = solve(a, queries);\n    output(ans);\n  }\n\n  static void output(int[] a) {\n    StringBuilder sb = new StringBuilder();\n    for (int v : a) {\n      sb.append(v);\n      sb.append('\n');\n      if (sb.length() > 500) {\n        System.out.print(sb.toString());\n        sb.setLength(0);\n      }\n    }\n    System.out.print(sb.toString());\n  }\n\n  static void myAssert(boolean cond) {\n    if (!cond) {\n      throw new RuntimeException(""Unexpected"");\n    }\n  }\n\n  static class MyScanner {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public MyScanner() {\n      try {\n        final String USERDIR = System.getProperty(""user.dir"");\n        String cname = MethodHandles.lookup().lookupClass().getCanonicalName().replace("".MyScanner"", """");\n        cname = cname.lastIndexOf('.') > 0 ? cname.substring(cname.lastIndexOf('.') + 1) : cname;\n        final File fin = new File(USERDIR + ""/io/c"" + cname.substring(1,5) + ""/"" + cname + "".in"");\n        br = new BufferedReader(new InputStreamReader(fin.exists()\n            ? new FileInputStream(fin) : System.in));\n      } catch (Exception e) {\n        br = new BufferedReader(new InputStreamReader(System.in));\n      }\n    }\n\n    public String next() {\n      try {\n        while (st == null || !st.hasMoreElements()) {\n          st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n  }\n}\n","brute force,data structures,dp,dsu,math,trees"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) {\n        QuickReader cin = new QuickReader(System.in);\n        int n = cin.nextInt();\n        String[] a = new String[3];\n        for (int i = 0; i < 3; i++) {\n            a[i] = cin.next();\n        }\n        Solution solution = new Solution(a, n);\n        int q = cin.nextInt();\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < q; i++) {\n            sb.append(solution.func(cin.nextInt() - 1, cin.nextInt() - 1));\n            sb.append(""\n"");\n        }\n        System.out.println(sb);\n    }\n}\n\nclass Solution {\n    int[] arr;\n    int[][] d;\n    int[] sums;\n\n    public Solution(String[] a, int n) {\n        arr = new int[n + 1];\n        d = new int[2][n + 1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 3; j++) {\n                arr[i + 1] += (a[j].charAt(i) - '0') << j;\n            }\n        }\n        sums = new int[n + 1];\n        boolean c = false;\n        for (int i = 0; i < n; i++) {\n            sums[i + 1] = sums[i];\n            int b = arr[i + 1];\n            int b1 = arr[i];\n            if (b == 1 || b == 2 || b == 3 || b == 4 || b == 6) {\n                if ((b & b1) == 0) {\n                    sums[i + 1]++;\n                }\n            } else if (b == 5) {\n                if (b1 == 0 || b1 == 2) {\n                    sums[i + 1] += 2;\n                    c = false;\n                } else if (b1 == 1 || b1 == 3 || b1 == 4 || b1 == 6) {\n                    sums[i + 1]++;\n                    c = false;\n                }\n            } else if (b == 7) {\n                if (b1 == 0) {\n                    sums[i + 1]++;\n                } else if (b1 == 5 && !c) {\n                    sums[i + 1]--;\n                }\n                c = true;\n            }\n        }\n        int p = 0;\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] == 7) {\n                p = i;\n            } else if (arr[i] == 5) {\n                d[0][i] = p;\n            } else {\n                p = 0;\n            }\n        }\n        p = 0;\n        for (int i = arr.length - 1; i >= 1; i--) {\n            if (arr[i] == 7) {\n                p = i;\n            } else if (arr[i] == 5) {\n                d[1][i] = p;\n            } else {\n                p = 0;\n            }\n        }\n    }\n\n    public int func(int l, int r) {\n        int b = arr[l + 1];\n        int b1 = arr[l];\n        if (l == r) {\n            if (b == 5) {\n                return 2;\n            } else if (b == 0) {\n                return 0;\n            }\n            return 1;\n        }\n        int c = sums[r + 1] - sums[l];\n        if (b == 1 || b == 2 || b == 3 || b == 4 || b == 6) {\n            if ((b & b1) != 0) {\n                c++;\n            }\n        } else if (b == 7) {\n            if (b1 != 0 && b1 != 5) {\n                c++;\n            } else if (b1 == 5 && d[0][l] == 0) {\n                c += 2;\n            } else if (b1 == 5) {\n                c++;\n            }\n        } else if (b == 5) {\n            if (b1 == 5 || b1 == 7) {\n                c += 2;\n                if (d[1][l + 1] != 0 && d[1][l + 1] <= r + 1 && d[0][l + 1] != 0) {\n                    c--;\n                }\n            } else if (b1 == 1 || b1 == 3 || b1 == 4 || b1 == 6) {\n                c++;\n            }\n        }\n        return c;\n    }\n}\n\nclass QuickReader {\n    BufferedReader in;\n    StringTokenizer token;\n\n    public QuickReader(InputStream ins) {\n        in = new BufferedReader(new InputStreamReader(ins));\n        token = new StringTokenizer("""");\n    }\n\n    public boolean hasNext() {\n        while (!token.hasMoreTokens()) {\n            try {\n                String s = in.readLine();\n                if (s == null) {\n                    return false;\n                }\n                token = new StringTokenizer(s);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n        }\n        return true;\n    }\n\n    public String next() {\n        hasNext();\n        return token.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public int[] nextInts(int n) {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nextInt();\n        }\n        return res;\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public long[] nextLongs(int n) {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nextLong();\n        }\n        return res;\n    }\n}","brute force,data structures,dp,dsu,math,trees"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner cin = new Scanner(System.in);\n        int n = cin.nextInt();\n        String[] a = new String[3];\n        for (int i = 0; i < 3; i++) {\n            a[i] = cin.next();\n        }\n        Solution solution = new Solution(a, n);\n        int q = cin.nextInt();\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < q; i++) {\n            sb.append(solution.func(cin.nextInt() - 1, cin.nextInt() - 1));\n            sb.append(""\n"");\n        }\n        System.out.println(sb);\n    }\n}\n\nclass Solution {\n    int[] arr;\n    int[][] d;\n    int[] sums;\n\n    public Solution(String[] a, int n) {\n        arr = new int[n + 1];\n        d = new int[2][n + 1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 3; j++) {\n                arr[i + 1] += (a[j].charAt(i) - '0') << j;\n            }\n        }\n        sums = new int[n + 1];\n        boolean c = false;\n        for (int i = 0; i < n; i++) {\n            sums[i + 1] = sums[i];\n            int b = arr[i + 1];\n            int b1 = arr[i];\n            if (b == 1 || b == 2 || b == 3 || b == 4 || b == 6) {\n                if ((b & b1) == 0) {\n                    sums[i + 1]++;\n                }\n            } else if (b == 5) {\n                if (b1 == 0 || b1 == 2) {\n                    sums[i + 1] += 2;\n                    c = false;\n                } else if (b1 == 1 || b1 == 3 || b1 == 4 || b1 == 6) {\n                    sums[i + 1]++;\n                    c = false;\n                }\n            } else if (b == 7) {\n                if (b1 == 0) {\n                    sums[i + 1]++;\n                } else if (b1 == 5 && !c) {\n                    sums[i + 1]--;\n                }\n                c = true;\n            }\n        }\n        int p = 0;\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] == 7) {\n                p = i;\n            } else if (arr[i] == 5) {\n                d[0][i] = p;\n            } else {\n                p = 0;\n            }\n        }\n        p = 0;\n        for (int i = arr.length - 1; i >= 1; i--) {\n            if (arr[i] == 7) {\n                p = i;\n            } else if (arr[i] == 5) {\n                d[1][i] = p;\n            } else {\n                p = 0;\n            }\n        }\n    }\n\n    public int func(int l, int r) {\n        int b = arr[l + 1];\n        int b1 = arr[l];\n        if (l == r) {\n            if (b == 5) {\n                return 2;\n            } else if (b == 0) {\n                return 0;\n            }\n            return 1;\n        }\n        int c = sums[r + 1] - sums[l];\n        if (b == 1 || b == 2 || b == 3 || b == 4 || b == 6) {\n            if ((b & b1) != 0) {\n                c++;\n            }\n        } else if (b == 7) {\n            if (b1 != 0 && b1 != 5) {\n                c++;\n            } else if (b1 == 5 && d[0][l] == 0) {\n                c += 2;\n            } else if (b1 == 5) {\n                c++;\n            }\n        } else if (b == 5) {\n            if (b1 == 5 || b1 == 7) {\n                c += 2;\n                if (d[1][l + 1] != 0 && d[1][l + 1] <= r + 1 && d[0][l + 1] != 0) {\n                    c--;\n                }\n            } else if (b1 == 1 || b1 == 3 || b1 == 4 || b1 == 6) {\n                c++;\n            }\n        }\n        return c;\n    }\n}\n\nclass QuickReader {\n    BufferedReader in;\n    StringTokenizer token;\n\n    public QuickReader(InputStream ins) {\n        in = new BufferedReader(new InputStreamReader(ins));\n        token = new StringTokenizer("""");\n    }\n\n    public boolean hasNext() {\n        while (!token.hasMoreTokens()) {\n            try {\n                String s = in.readLine();\n                if (s == null) {\n                    return false;\n                }\n                token = new StringTokenizer(s);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n        }\n        return true;\n    }\n\n    public String next() {\n        hasNext();\n        return token.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public int[] nextInts(int n) {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nextInt();\n        }\n        return res;\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public long[] nextLongs(int n) {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nextLong();\n        }\n        return res;\n    }\n}","brute force,data structures,dp,dsu,math,trees"
"import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String args[]) {new Main().run();}\n\n    FastReader in = new FastReader();\n    PrintWriter out = new PrintWriter(System.out);\n    void run() {\n        work();\n        out.flush();\n    }\n    long mod=1000000007;\n    long gcd(long a,long b) {\n        return a==0?b:gcd(b%a,a);\n    }\n    long inf=Long.MAX_VALUE/3;\n    void work() {\n        int n=ni();\n        int[][] A=new int[3][n];\n        for(int i=0;i<3;i++){\n            char[] chs=ns().toCharArray();\n            for(int j=0;j<n;j++){\n                A[i][j]=(chs[j]-'0')^1;\n            }\n        }\n        int sum=0;\n        int[][] dir=new int[][]{{0,1},{1,0},{-1,0},{0,-1}};\n        int[][] color=new int[3][n];\n        int[] L1=new int[n];\n        int[] R1=new int[n];\n        for(int j=0;j<n;j++){\n            for(int i=0;i<3;i++){\n                if(A[i][j]==0&&color[i][j]==0){\n                    int min=99999999,max=0;\n                    sum++;\n                    LinkedList<int[]> queue=new LinkedList<>();\n                    queue.add(new int[]{i,j});\n                    color[i][j]=sum;\n                    while(queue.size()>0){\n                        int[] q = queue.poll();\n                        int x=q[0],y=q[1];\n                        min=Math.min(min,y);\n                        max=Math.max(max,y);\n                        for(int p=0;p<4;p++){\n                            int nx=x+dir[p][0],ny=y+dir[p][1];\n                            if(nx>=0&&nx<3&&ny>=0&&ny<n&&color[nx][ny]==0&&A[nx][ny]==0){\n                                queue.add(new int[]{nx,ny});\n                                color[nx][ny]=sum;\n                            }\n                        }\n                    }\n                    L1[max]++;\n                    R1[min]++;\n                }\n            }\n        }\n        for(int i=0;i<n;i++){\n            L1[i]+=i==0?0:L1[i-1];\n        }\n        for(int i=n-1;i>=0;i--){\n            R1[i]+=i==n-1?0:R1[i+1];\n        }\n        int[] L=new int[n];\n        int[] R=new int[n];\n        int[] U=new int[n];\n        int[] D=new int[n];\n        Arrays.fill(L,-1);\n        Arrays.fill(R,n);\n        for(int i=0;i<n;i++){\n            if(A[1][i]==0){\n                L[i]=i;\n            }else if(i>0){\n                L[i]=L[i-1];\n            }\n        }\n        for(int i=n-1;i>=0;i--){\n            if(A[1][i]==0){\n                R[i]=i;\n            }else if(i<n-1){\n                R[i]=R[i+1];\n            }\n        }\n        for(int i=0,j=0;i<n;i++){\n            if(A[0][i]==0){\n                if(i==0||A[0][i-1]==1){\n                    U[i]=++j;\n                }else{\n                    U[i]=j;\n                }\n            }\n        }\n        for(int i=0,j=0;i<n;i++){\n            if(A[2][i]==0){\n                if(i==0||A[2][i-1]==1){\n                    D[i]=++j;\n                }else{\n                    D[i]=j;\n                }\n            }\n        }\n        HashMap<Long,List<Integer>> map=new HashMap<>();\n        for(int j=0;j<n;j++){\n            if(A[1][j]==0&&A[0][j]==0&&A[2][j]==0){\n                int k1=U[j],k2=D[j];\n                long key=(long)k1<<32|k2;\n                if(map.get(key)==null)map.put(key,new ArrayList<>());\n                map.get(key).add(j);\n            }\n        }\n        for(int q=ni();q>0;q--){\n            int l=ni()-1,r=ni()-1;\n            long ret=sum;\n            if(l>0)ret-=L1[l-1];\n            if(r<n-1)ret-=R1[r+1];\n            boolean f1=false,f2=false;\n            int k1=-1,k2=-1,k3=-1,k4=-1;\n            if(A[0][l]==0&&A[2][l]==0){\n                k1=U[l];k2=D[l];\n                long key=(long)k1<<32|k2;\n                List<Integer> list = map.get(key);\n                if(list!=null){\n                    if(list.get(list.size()-1)<l){\n                        f1=true;\n                    }\n                }\n            }\n            if(A[0][r]==0&&A[2][r]==0){\n                k3=U[r];k4=D[r];\n                long key=(long)k3<<32|k4;\n                List<Integer> list = map.get(key);\n                if(list!=null){\n                    if(list.get(0)>r){\n                        f2=true;\n                    }\n                }\n            }\n            if(k1==k3&&k2==k4&&k1!=-1){\n                if(color[0][l]!=color[2][l]){\n                }else if(R[l]>r&&R[l]!=n){\n                    ret++;\n                }\n            }else{\n                if(f1)ret++;\n                if(f2)ret++;\n            }\n            out.println(ret);\n        }\n    }\n\n    @SuppressWarnings(""unused"")\n    private ArrayList<Integer>[] ng(int n, int m) {\n        ArrayList<Integer>[] graph=(ArrayList<Integer>[])new ArrayList[n];\n        for(int i=0;i<n;i++) {\n            graph[i]=new ArrayList<>();\n        }\n        for(int i=1;i<=m;i++) {\n            int s=in.nextInt()-1,e=in.nextInt()-1;\n            graph[s].add(e);\n            graph[e].add(s);\n        }\n        return graph;\n    }\n\n    private ArrayList<long[]>[] ngw(int n, int m) {\n        ArrayList<long[]>[] graph=(ArrayList<long[]>[])new ArrayList[n];\n        for(int i=0;i<n;i++) {\n            graph[i]=new ArrayList<>();\n        }\n        for(int i=1;i<=m;i++) {\n            long s=in.nextLong()-1,e=in.nextLong()-1,w=in.nextLong();\n            graph[(int)s].add(new long[] {e,w});\n            graph[(int)e].add(new long[] {s,w});\n        }\n        return graph;\n    }\n\n    private int ni() {\n        return in.nextInt();\n    }\n\n    private long nl() {\n        return in.nextLong();\n    }\n    private double nd() {\n        return in.nextDouble();\n    }\n    private String ns() {\n        return in.next();\n    }\n\n    private long[] na(int n) {\n        long[] A=new long[n];\n        for(int i=0;i<n;i++) {\n            A[i]=in.nextLong();\n        }\n        return A;\n    }\n\n    private int[] nia(int n) {\n        int[] A=new int[n];\n        for(int i=0;i<n;i++) {\n            A[i]=in.nextInt();\n        }\n        return A;\n    }\n}\n\nclass FastReader\n{\n    BufferedReader br;\n    StringTokenizer st;\n    InputStreamReader input;//no buffer\n    public FastReader()\n    {\n        br=new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    public FastReader(boolean isBuffer)\n    {\n        if(!isBuffer){\n            input=new InputStreamReader(System.in);\n        }else{\n            br=new BufferedReader(new InputStreamReader(System.in));\n        }\n    }\n\n    public boolean hasNext(){\n        try{\n            String s=br.readLine();\n            if(s==null){\n                return  false;\n            }\n            st=new StringTokenizer(s);\n        }catch(IOException e){\n            e.printStackTrace();\n        }\n        return true;\n    }\n\n    public String next()\n    {\n        if(input!=null){\n            try {\n                StringBuilder sb=new StringBuilder();\n                int ch=input.read();\n                while(ch=='\n'||ch=='\r'||ch==32){\n                    ch=input.read();\n                }\n                while(ch!='\n'&&ch!='\r'&&ch!=32){\n                    sb.append((char)ch);\n                    ch=input.read();\n                }\n                return sb.toString();\n            }catch (Exception e){\n                e.printStackTrace();\n            }\n        }\n        while(st==null || !st.hasMoreElements())//回车，空行情况\n        {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n\n    public int nextInt()\n    {\n        return (int)nextLong();\n    }\n\n    public long nextLong() {\n        try {\n            if(input!=null){\n                long ret=0;\n                int b=input.read();\n                while(b<'0'||b>'9'){\n                    b=input.read();\n                }\n                while(b>='0'&&b<='9'){\n                    ret=ret*10+(b-'0');\n                    b=input.read();\n                }\n                return ret;\n            }\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble()\n    {\n        return Double.parseDouble(next());\n    }\n}","brute force,data structures,dp,dsu,math,trees"
"import java.util.*;\npublic class dhet {\n	public static void main(String[] args){\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0) {\n			int n=sc.nextInt();\n			int arr[]=new int[n];\n			long sum=0;\n			for(int i=0;i<n;i++) {\n				arr[i]=sc.nextInt();\n			}\n			Arrays.parallelSort(arr);\n			int num=arr[n-1];\n			long res=(long)Math.pow(10, 18);\n			for(int h=num;h<=num+3;++h) {\n				long two=0;\n				long one=0;\n				for(int i=0;i<n;i++) {\n					two+=(h-arr[i])/2;\n					one+=(h-arr[i])%2;\n				}\n				long all=one+two*2;\n				long day=all/3*2;\n				if(all%3==1) {\n					day++;\n				}\n				if(all%3==2) {\n					day+=2;\n				}\n				res=Math.min(res,Math.max(one*2-1, day));\n			}\n			System.out.println(res);\n		}\n	}\n}\n","binary search,greedy,math"
"import java.io.*;\nimport java.util.*;\n\npublic class Educational126 {\n	public static void main(String[] args)   throws IOException\n	{\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter pw=new PrintWriter(System.out);\n		int t=Integer.parseInt(br.readLine());\n		while(t-->0)\n		{\n			StringTokenizer st=new StringTokenizer(br.readLine());\n			int n=Integer.parseInt(st.nextToken());\n			st=new StringTokenizer(br.readLine());\n			long h[]=new long[n];\n			long max=0;\n			for(int i=0;i<n;i++)\n			{\n				h[i]=Long.parseLong(st.nextToken());\n				if(h[i]>max)\n					max=h[i];\n			}\n			long ans=Long.MAX_VALUE;\n			for(long i=max;i<=max+3;i++)\n			{\n				long e=0,o=0;\n				for(int j=0;j<n;j++)\n				{\n					e+=(i-h[j])/2;\n					o+=(i-h[j])%2;\n				}\n				long val=o+e*2;\n				long tempans=val/3*2;\n				tempans+=val%3;\n				ans=Math.min(ans, Math.max(o*2-1, tempans));\n			}\n			pw.println(ans);\n			pw.flush();\n		}\n	}\n\n}\n","binary search,greedy,math"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1661C extends PrintWriter {\n	CF1661C() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1661C o = new CF1661C(); o.main(); o.flush();\n	}\n\n	long solve(int[] aa, int n) {\n		long odd = 0, even = 0;\n		for (int i = 0; i < n; i++) {\n			even += aa[i] / 2;\n			odd += aa[i] % 2;\n		}\n		if (even > odd + 1) {\n			// even - k <= odd + 1 + k * 2\n			// even - odd - 1 <= k * 3\n			long k = (even - odd - 1 + 2) / 3;\n			even -= k;\n			odd += k * 2;\n		}\n		// even <= odd + 1\n		return even >= odd ? even * 2 : odd * 2 - 1;\n	}\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int[] aa = new int[n];\n			int a = 0;\n			for (int i = 0; i < n; i++) {\n				aa[i] = sc.nextInt();\n				a = Math.max(a, aa[i]);\n			}\n			for (int i = 0; i < n; i++)\n				aa[i] = a - aa[i];\n			long d0 = solve(aa, n);\n			for (int i = 0; i < n; i++)\n				aa[i]++;\n			long d1 = solve(aa, n);\n			println(Math.min(d0, d1));\n		}\n	}\n}\n","binary search,greedy,math"
"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class C {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n\n        int t = in.nextInt();\n        for (int i = 0; i < t; i++) {\n            int n = in.nextInt();\n            long[] h = new long[n];\n\n            long max=-1;\n\n            for (int k = 0; k < n; k++) {\n                h[k] = in.nextInt();\n                max=Math.max(h[k],max);\n            }\n\n\n            long A = numberOfSteps(max, h);\n            long B = numberOfSteps(max + 1, h);\n            long better = Math.min(A, B);\n            System.out.println(better);\n        }\n\n        return;\n    }\n\n    static long numberOfSteps(long level, long[] h) {\n        int n = h.length;\n        long par = 0;\n        long impar = 0;\n\n        for (int i = 0; i < n; i++) {\n            long diff = level - h[i];\n            impar += diff % 2;\n\n            par += (diff - (diff % 2)) / 2;\n\n        }\n\n        if (impar < par) {\n            long days = 2 * impar;\n            par = par - impar;\n\n            days += ((par * 2) / 3) * 2;\n\n            if ((par * 2) % 3 == 1) {\n                days += 1;\n            }\n\n            if ((par * 2) % 3 == 2) {\n                days += 2;\n            }\n            return days;\n        }\n\n        if (impar == par) {\n            return 2 * impar;\n        }\n\n        return 2 * impar - 1;\n    }\n}","binary search,greedy,math"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\n/*\n\n2 4 2 4\n1 1 0\n+ + \n+ +\n  +\n0 1 1\n  \n  \n  \n3 5\n\n1110\n+++\n+++\n+++\n0111\n\n\nSwap in a 0 or a 1, 0 -> stay the same forever, 1-> continue to get smaller\n\n3 => for 3 turns, subtract 1 from the next 3\n\nlast element:\n0 or 1 if initially a 0\nelse n\n\n\nWe can count the number of 1s in total:\n#1s = sum/n\n\nlast is a 1, 3 1s in total\n2 4 2 4\n  + + +\n\nlast is ? 2 1s in total\n2 3 1 This is what it looked like before\n\n\n1\n4\n2 4 2 4\n */\npublic class D {\n\n	\n	public static void main(String[] args) {\n		FastScanner fs=new FastScanner();\n		PrintWriter out=new PrintWriter(System.out);\n		int T=fs.nextInt();\n		for (int tt=0; tt<T; tt++) {\n			int n=fs.nextInt();\n			BIT deltas=new BIT(n);\n			int[] a=fs.readArray(n);\n			long sum=0;\n			for (int i:a) sum+=i;\n			if (sum%n!=0) throw null;\n			int nOnes=(int) (sum/n);\n			for (int i=0; i<n; i++) {\n				int prev=i==0?0:a[i-1];\n				int delta=a[i]-prev;\n				deltas.update(i, delta);\n			}\n			int[] ans=new int[n];\n			for (int i=n-1; i>0; i--) {\n				int last=deltas.query(0, i);\n				//remove the last query\n				int nZeros=i+1-nOnes;\n				deltas.update(nZeros, -1);\n				if (last==i+1) {\n					//ends in a 1\n					ans[i]=1;\n					nOnes--;\n				}\n				else {\n					ans[i]=0;\n				}\n			}\n			ans[0]=nOnes;\n			for (int i=0; i<n; i++) out.print(ans[i]+"" "");\n			out.println();\n		}\n		out.close();\n	}\n	\n\n	//range update point query\n	//bit stores delta\n	static class BIT {\n		int n, tree[];\n		\n		public BIT(int N) {\n			n = N;  tree = new int[N + 1];\n		}\n	\n		void update(int i, int val) {\n			for (i++; i <= n; i += i & -i) tree[i] += val;\n		}\n		\n		int read(int i) {\n			int sum = 0;\n			for (i++; i > 0; i -= i & -i) sum += tree[i];\n			return sum;\n		}\n		\n		// query sum of [l, r] inclusive\n		int query(int l, int r) { return read(r) - read(l - 1); }\n		\n		// if the BIT is a freq array, returns the index of the\n		// kth item (0-indexed), or n if there are <= k items.\n		int getKth(int k) {\n			if (k < 0) return -1;\n			int i = 0;\n			for (int pw = Integer.highestOneBit(n); pw > 0; pw >>= 1)\n				if (i + pw <= n && tree[i + pw] <= k) k -= tree[i += pw];\n			return i;\n		}\n	}\n	\n	static final Random random=new Random();\n	static final int mod=1_000_000_007;\n	\n	static void ruffleSort(int[] a) {\n		int n=a.length;//shuffle, then sort \n		for (int i=0; i<n; i++) {\n			int oi=random.nextInt(n), temp=a[oi];\n			a[oi]=a[i]; a[i]=temp;\n		}\n		Arrays.sort(a);\n	}\n	static long add(long a, long b) {\n		return (a+b)%mod;\n	}\n	static long sub(long a, long b) {\n		return ((a-b)%mod+mod)%mod;\n	}\n	static long mul(long a, long b) {\n		return (a*b)%mod;\n	}\n	static long exp(long base, long exp) {\n		if (exp==0) return 1;\n		long half=exp(base, exp/2);\n		if (exp%2==0) return mul(half, half);\n		return mul(half, mul(half, base));\n	}\n	static long[] factorials=new long[2_000_001];\n	static long[] invFactorials=new long[2_000_001];\n	static void precompFacts() {\n		factorials[0]=invFactorials[0]=1;\n		for (int i=1; i<factorials.length; i++) factorials[i]=mul(factorials[i-1], i);\n		invFactorials[factorials.length-1]=exp(factorials[factorials.length-1], mod-2);\n		for (int i=invFactorials.length-2; i>=0; i--)\n			invFactorials[i]=mul(invFactorials[i+1], i+1);\n	}\n	\n	static long nCk(int n, int k) {\n		return mul(factorials[n], mul(invFactorials[k], invFactorials[n-k]));\n	}\n	\n	static void sort(int[] a) {\n		ArrayList<Integer> l=new ArrayList<>();\n		for (int i:a) l.add(i);\n		Collections.sort(l);\n		for (int i=0; i<a.length; i++) a[i]=l.get(i);\n	}\n	\n	\n	static class FastScanner {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n		String next() {\n			while (!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		int[] readArray(int n) {\n			int[] a=new int[n];\n			for (int i=0; i<n; i++) a[i]=nextInt();\n			return a;\n		}\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n	}\n\n	\n}\n","constructive algorithms,data structures,two pointers"
"import java.util.*;\nimport java.io.*;\n\npublic class E1651 {\n    static int[][] adjList;\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        n = sc.nextInt();\n        adjList = new int[2 * n][2];\n        for (int[] x : adjList)\n            Arrays.fill(x, -1);\n        for (int i = 0; i < 2 * n; i++) {\n            int u = sc.nextInt() - 1;\n            int v = sc.nextInt() - 1;\n            if (adjList[u][0] == -1) {\n                adjList[u][0] = v;\n            } else {\n                adjList[u][1] = v;\n            }\n            if (adjList[v][0] == -1) {\n                adjList[v][0] = u;\n            } else {\n                adjList[v][1] = u;\n            }\n        }\n        int[] nxt = new int[2 * n];\n        boolean[] viss = new boolean[2 * n];\n        long ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (viss[i]) {\n                continue;\n            }\n            int cur = i;\n            ArrayList<Integer> al = new ArrayList<>();\n            while (!viss[cur]) {\n                al.add(cur);\n                viss[cur] = true;\n                if (cur == adjList[i][1]) {\n                    nxt[cur] = i;\n                } else {\n                    nxt[cur] = viss[adjList[cur][0]] ? adjList[cur][1] : adjList[cur][0];\n                }\n                cur = nxt[cur];\n            }\n//            System.out.println(al);\n            for (int j = 0; j < al.size(); j++) {\n                int[][] range = {{(int) 1e9, -(int) 1e9}, {(int) 1e9, -(int) 1e9}};\n\n                addToRange(al.get(j), range);\n                for (int k = (j + 1) % al.size(); k != j; k = (k + 1) % al.size()) {\n                    int me = al.get(k);\n                    addToRange(me, range);\n                    int next = al.get((k + 1) % al.size());\n                    int prev = al.get((j - 1 + al.size()) % al.size());\n                    long inc = solve(range, prev, next) * (((k - j + 1 + al.size()) % al.size()) / 2);\n//                    System.out.println(j + "" "" + k + "" "" + Arrays.deepToString(range) + "" "" + inc + "" "" + prev + "" "" + next);\n                    ans += inc;\n                }\n                if (j == 0) {\n                    ans += solve(range, -10, -10) * (al.size() / 2);\n                }\n            }\n        }\n        pw.println(ans);\n        pw.close();\n    }\n\n    public static boolean between(int[] r, int m) {\n        return between(r[0], m, r[1]);\n    }\n\n    public static boolean between(int l, int m, int r) {\n        return l <= m && m <= r;\n    }\n\n    public static int getBef(int l, int r, int x, int y) {\n        int bef;\n        if (between(l, x, r) && between(l, y, r)) {\n            bef = r - Math.max(x, y);\n        } else if (between(l, x, r)) {\n            bef = r - x;\n        } else if (between(l, y, r)) {\n            bef = r - y;\n        } else {\n            bef = r - l + 1;\n        }\n        return bef;\n    }\n\n    public static int getAft(int l, int r, int x, int y) {\n        int aft;\n        if (between(l, x, r) && between(l, y, r)) {\n            aft = Math.min(x, y) - l;\n        } else if (between(l, x, r)) {\n            aft = x - l;\n        } else if (between(l, y, r)) {\n            aft = y - l;\n        } else {\n            aft = r - l + 1;\n        }\n        return aft;\n    }\n\n\n    public static long solve(int[][] range, int prev, int next) {\n        if (between(range[0], prev) || between(range[1], prev))\n            return 0;\n        if (between(range[0], next) || between(range[1], next))\n            return 0;\n        int bef1 = getBef(0, range[0][0], prev, next);\n        int bef2 = getBef(n, range[1][0], prev, next);\n        int aft1 = getAft(range[0][1], n - 1, prev, next);\n        int aft2 = getAft(range[1][1], 2 * n - 1, prev, next);\n//        System.out.println(bef1 + "" "" + bef2 + "" "" + aft1 + "" "" + aft2);\n        return 1l * bef1 * bef2 * aft1 * aft2;\n    }\n\n    static int n;\n\n    static void addToRange(int x, int[][] range) {\n        if (x < n) {\n            range[0][0] = Math.min(range[0][0], x);\n            range[0][1] = Math.max(range[0][1], x);\n        } else {\n            range[1][0] = Math.min(range[1][0], x);\n            range[1][1] = Math.max(range[1][1], x);\n        }\n    }\n\n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public Scanner(FileReader f) {\n            br = new BufferedReader(f);\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArr(int n) throws IOException {\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = Integer.parseInt(next());\n            }\n            return arr;\n        }\n\n    }\n}\n    ","brute force,combinatorics,constructive algorithms,dfs and similar,graph matchings,greedy,math"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1650D extends PrintWriter {\n	CF1650D() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1650D o = new CF1650D(); o.main(); o.flush();\n	}\n\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int[] aa = new int[n];\n			int[] bb = new int[n];\n			for (int i = 0; i < n; i++)\n				aa[i] = sc.nextInt() - 1;\n			int[] dd = new int[n];\n			for (int i = n - 1; i >= 0; i--) {\n				if (aa[i] == i)\n					continue;\n				int j = i;\n				while (aa[j] != i)\n					j--;\n				dd[i] = j + 1;\n				for (int h = 0; h <= i; h++)\n					bb[(h + i - j) % (i + 1)] = aa[h];\n				for (int h = 0; h <= i; h++)\n					aa[h] = bb[h];\n			}\n			for (int i = 0; i < n; i++)\n				print(dd[i] + "" "");\n			println();\n		}\n	}\n}\n","brute force,constructive algorithms,implementation,math"
"import java.util.*;\npublic class Main{\n	public static void main(String[]args){\n		Scanner at = new Scanner(System.in);\n		int t = at.nextInt();\n		while(t-->0){\n			int n = at.nextInt();\n			int[]arr =  new int[n+1];\n			for(int i = 1;i<n+1;i++){\n				arr[at.nextInt()] = i;\n			}\n			int tt = n;\n			int []ans = new int[n+1];\n			for(int i = n;i>=1;i--){\n				if(arr[i] == i){\n					continue;\n				}\n				int shifts = (arr[i]);\n				// System.out.println(shifts);\n				ans[i] = shifts;\n				for(int j = 1;j<=i;j++){\n					int temp  = arr[j];\n					if(arr[j] < arr[i]){\n						int dist = arr[i]-arr[j];\n						arr[j] = i-dist;\n					}\n					else if(arr[j] > arr[i]){\n						arr[j] -= shifts;\n					}\n				}\n\n\n			}\n\n			for(int i  =1;i<=n;i++){\n				System.out.print(ans[i]+"" "");\n			}\n			System.out.println();\n\n\n\n\n		}\n	}\n}","brute force,constructive algorithms,implementation,math"
"import java.util.*;\nimport java.io.*;\npublic class Ex extends PrintWriter {\n	Ex() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		Ex o = new Ex(); o.main(); o.flush();\n	}\n	void main() {\n		int t = sc.nextInt();\n		while(t-->0) {\n			int n = sc.nextInt();\n			int[] arr = new int[n];\n			int[] copy = new int[n];\n			int[] count = new int[n];\n			for(int i=0;i<n;i++) {arr[i] = sc.nextInt()-1;copy[i]=arr[i];}\n			for(int i=n-1;i>0;i--) {\n				if(i!=arr[i]) {\n					int j;\n					for(j=i-1;j>=0;j--) {\n						if(arr[j]==i) break;\n					}\n					count[i]+=(j+1);\n					for(int k=i;k>=0;k--) {\n						if(k>j) arr[k-j-1]=copy[k];\n						else arr[i-(j-k)]=copy[k];\n					}\n					copy=Arrays.copyOf(arr, copy.length);\n				}\n			}\n			for(int i:count) print(i+"" "");\n			println();\n		}\n	 }\n}","brute force,constructive algorithms,implementation,math"
"import java.util.*;\n\npublic class PermutaionTwist {\n\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		int t = s.nextInt();\n		while(t-- > 0) {\n			int n = s.nextInt();\n			int[] a = new int[n];\n			int[] ans = new int[n];\n			Map<Integer, Integer> map = new HashMap<>();\n			for(int i = 0; i < n ;i++) {\n				a[i] = s.nextInt();\n				map.put(a[i], i+1);\n			}\n			for(int i = n; i>=1; i--) {\n				int idx = map.get(i);\n				if(idx == i) {\n					continue;\n				}\n				int d = i - idx;\n				ans[i-1] = map.get(i);\n				for(Map.Entry<Integer,Integer> e:map.entrySet()) {\n					\n					if(e.getKey() > i) {\n						continue;\n					}\n					\n					if(e.getValue() <= idx) {\n						map.put(e.getKey(), e.getValue() + (d));\n					}\n					else {\n						map.put(e.getKey(), e.getValue() - (idx));\n					}\n				}\n				\n				\n			}\n			for(int aa:ans) {\n				System.out.print(aa + "" "");\n			}\n			System.out.println();\n			\n			\n		}\n \n	}\n}\n\n\n","brute force,constructive algorithms,implementation,math"
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n	PrintWriter out = new PrintWriter(System.out);\n	BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer tok = new StringTokenizer("""");\n    String next() throws IOException {\n        if (!tok.hasMoreTokens()) { tok = new StringTokenizer(in.readLine()); }\n        return tok.nextToken();\n    }\n    int ni() throws IOException { return Integer.parseInt(next()); }\n    long nl() throws IOException { return Long.parseLong(next()); }\n    int[] na(int n) throws IOException { int[]A=new int[n]; for (int i=0;i<n;i++) A[i]=ni(); return A; }\n    \n    long mod=998244353;\n    \n    void solve() throws IOException {\n        long[]F=new long[200001];\n        F[0]=1;\n        for (int i=1;i<=200000;i++) F[i]=(F[i-1]*i)%mod;\n        \n        int n=ni(),m=ni();\n        int[]A=na(n);\n        int[]B=na(m);\n        \n        Arrays.sort(A);\n        ArrayList<Integer>[]D=new ArrayList[200001];\n        for (int i=1;i<=200000;i++) D[i]=new ArrayList();\n        for (int i=0;i<n;i++) D[A[i]].add(i);\n        \n        bt Z=new bt(0,n-1);\n        \n        long comb=F[n];\n        for (int i=1;i<=200000;i++) {\n            if (D[i].size()<2) continue;\n            comb=(comb*mp(F[D[i].size()],mod-2))%mod;\n        }\n        //out.println(comb);\n        int[]S=new int[200001];\n        int p=0;\n        for (int i=1;i<=200000;i++) {\n            S[i]=p;\n            p+=D[i].size();\n        }\n        \n        long ans=0;\n        int left=n;\n        \n        for (int i=0;i<m;i++) {\n            if (left==0) { ans++; break; }\n            \n            comb=(comb*mp(left,mod-2))%mod;\n            ans=(ans+comb*Z.query(S[B[i]]))%mod;\n            //out.println(S[B[i]]+"" ""+Z.query(S[B[i]]));\n            //out.println(comb+"" ""+ans);\n            if (D[B[i]].size()==0) break;\n            \n            \n            comb=(comb*D[B[i]].size())%mod;\n            int last=D[B[i]].size()-1;\n            Z.update(D[B[i]].get(last));\n            D[B[i]].remove(last);\n            left--;\n            \n        }\n        \n        out.println(ans%mod);\n        out.flush();\n    }\n    \n    class bt {\n        int lt,rt,ct;\n        bt lc,rc;\n        \n        bt(int p,int q) {\n            lt=p;\n            rt=q;\n            ct=q-p+1;\n            if (lt<rt) {\n                lc=new bt(p,(p+q)/2);\n                rc=new bt((p+q)/2+1,q);\n            }\n        }\n        \n        void update(int u) {\n            ct--;\n            if (lt==rt) return;\n            if (u<=lc.rt) lc.update(u);\n            else rc.update(u);\n        }\n        \n        int query(int u) {\n            if (u<=lt) return 0;\n            if (u>rt) return ct;\n            return lc.query(u)+rc.query(u);\n        }\n    }\n    \n    int gcd(int a,int b) { return(b==0?a:gcd(b,a%b)); }\n    long gcd(long a,long b) { return(b==0?a:gcd(b,a%b)); }\n    long mp(long a,long p) { long r=1; while(p>0) { if ((p&1)==1) r=(r*a)%mod; p>>=1; a=(a*a)%mod; } return r; }\n    \n    public static void main(String[] args) throws IOException {\n        new Main().solve();\n    }\n}","combinatorics,data structures,implementation"
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n\n        Task solver = new Task();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Task {\n\n    int mod = 998244353;\n    long[] fac, inv;\n\n    public void solve(InputReader in, PrintWriter out) throws Exception {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int C = 2000000;\n        init(C);\n        FenwickTree ft = new FenwickTree(C);\n        int[] cnt = new int[C + 1];\n        for (int i = 0; i < n; i++) {\n            int x = in.nextInt();\n            cnt[x]++;\n            ft.update(x, 1);\n        }\n        int[] t = new int[m];\n        for (int i = 0; i < m; i++) {\n            t[i] = in.nextInt();\n        }\n        long ans = 0, tmp = 1;\n        boolean ok = true;\n        for (int i = 0; i < Math.min(n, m); i++) {\n            ans += ft.get(t[i] - 1) * tmp % mod * fac[n - i - 1] % mod;\n            ans %= mod;\n\n            long c = ft.get(t[i]) - ft.get(t[i] - 1);\n            if (c == 0) {\n                ok = false;\n                break;\n            }\n            ft.update(t[i], -1);\n            tmp = tmp * c % mod;\n//            out.println(ans + "" "" + tmp);\n        }\n        if (ok && n < m) {\n            ans = (ans + tmp) % mod;\n        }\n        for (int i = 1; i <= C; i++) if (cnt[i] > 0) {\n            ans = ans * inv[cnt[i]] % mod;\n        }\n        out.println(ans);\n    }\n\n    private void init(int n) {\n        fac = new long[n + 1];\n        inv = new long[n + 1];\n        fac[0] = inv[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fac[i] = fac[i - 1] * i % mod;\n            inv[i] = inv[i - 1] * powmod(i, mod - 2) % mod;\n        }\n    }\n\n    private long powmod(int a, int b) {\n        long ans = 1, d = a;\n        while (b > 0) {\n            if (b % 2 == 1) ans = ans * d % mod;\n            b >>= 1;\n            d = d * d % mod;\n        }\n        return ans;\n    }\n\n    class FenwickTree {\n        int n;\n        int[] a;\n\n        public FenwickTree(int n) {\n            this.n = n;\n            a = new int[n + 1];\n        }\n\n        public void update(int x, int c) {\n            for (int i = x; i <= n; i += i & -i) {\n                a[i] += c;\n            }\n        }\n\n        public int get(int x) {\n            int ans = 0;\n            for (int i = x; i > 0; i -= i & -i) {\n                ans += a[i];\n            }\n            return ans;\n        }\n    }\n\n}\n\nclass InputReader {\n\n    private final BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String nextLine() {\n        try {\n            return reader.readLine();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(nextLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n}","combinatorics,data structures,implementation"
"import java.util.*;\nimport java.io.*;\n\npublic class C1648 {\n    static final int mod = 998244353;\n\n    static long modPow(long a, long e) {\n        if (e == 0)\n            return 1;\n        long prev = modPow(a, e / 2);\n        long ans = prev * prev % mod;\n        if (e % 2 == 1) {\n            ans = ans * a % mod;\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        final int MAX = (int) 2e5 + 5;\n        long[] fac = new long[MAX];\n        long[] facInv = new long[MAX];\n        fac[0] = 1;\n        for (int i = 1; i < fac.length; i++) {\n            fac[i] = fac[i - 1] * i % mod;\n        }\n        facInv[facInv.length - 1] = modPow(fac[facInv.length - 1], mod - 2);\n        for (int i = facInv.length - 2; i >= 0; i--) {\n            facInv[i] = facInv[i + 1] * (i + 1) % mod;\n        }\n        long[] modInv = new long[MAX];\n        for (int i = 1; i < MAX; i++) {\n            modInv[i] = facInv[i] * fac[i - 1] % mod;\n        }\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int[] s = sc.nextIntArr(n);\n        int[] t = sc.nextIntArr(m);\n        FenwickTree ft = new FenwickTree(MAX);\n        for (int x : s) ft.point_update(x, 1);\n        long all = fac[n];\n        for (int i = 1; i < MAX; i++) {\n            int cnt = (int) ft.rsq(i, i);\n            all = all * facInv[cnt] % mod;\n        }\n        long ans = 0;\n        boolean good = true;\n        for (int i = 0; i < Math.min(m, n); i++) {\n            long less = ft.rsq(t[i] - 1);\n//            System.out.println(all + "" "" + less);\n            ans += all * less % mod * modInv[n - i] % mod;\n            ans %= mod;\n            int curCnt = (int) ft.rsq(t[i], t[i]);\n            if (curCnt == 0) {\n                good = false;\n                break;\n            }\n            all = all * facInv[n - i] % mod * fac[n - i - 1] % mod;\n            all = all * fac[curCnt] % mod * facInv[curCnt - 1] % mod;\n            curCnt--;\n            ft.point_update(t[i], -1);\n           \n        }\n        if (good && s.length < t.length) {\n            ans = (ans + 1) % mod;\n        }\n        pw.println(ans);\n        pw.close();\n    }\n\n    static class FenwickTree { // one-based DS\n\n        int n;\n        long[] ft;\n\n        FenwickTree(int size) {\n            n = size;\n            ft = new long[n + 1];\n        }\n\n        long rsq(int b) // O(log n)\n        {\n            long sum = 0;\n            while (b > 0) {\n                sum += ft[b];\n                b -= b & -b;\n            } // min?\n            return sum;\n        }\n\n        long rsq(int a, int b) {\n            return rsq(b) - rsq(a - 1);\n        }\n\n        void point_update(int k, long val) // O(log n), update = increment\n        {\n            while (k <= n) {\n                ft[k] += val;\n                k += k & -k;\n            } // min?\n        }\n    }\n\n\n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public Scanner(FileReader f) {\n            br = new BufferedReader(f);\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArr(int n) throws IOException {\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = Integer.parseInt(next());\n            }\n            return arr;\n        }\n\n    }\n}\n    ","combinatorics,data structures,implementation"
"import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class C {\n\n	static final int P = 998244353;\n	static final int B = 200_000;\n\n	static int[] inv = new int[B + 1];\n	static int[] fact = new int[B + 1];\n	static int[] invFact = new int[B + 1];\n	static {\n		inv[1] = 1;\n		for (int x = 2; x < inv.length; x++) {\n			inv[x] = P - (int) ((long) (P / x) * inv[P % x] % P);\n		}\n		\n		fact[0] = 1;\n		for (int i = 1; i <= B; i++) {\n			fact[i] = (int) ((long) i * fact[i - 1] % P);\n		}\n\n		invFact[0] = 1;\n		for (int i = 1; i <= B; i++) {\n			invFact[i] = (int) ((long) invFact[i - 1] * inv[i] % P);\n		}\n	}\n\n	void add(int[] fen, int where, int delta) {\n		for (int i = where; i < fen.length; i |= i + 1) {\n			fen[i] += delta;\n		}\n	}\n\n	int get(int[] fen, int where) {\n		int ret = 0;\n		for (int i = where; i >= 0; i = (i & (i + 1)) - 1) {\n			ret += fen[i];\n		}\n		return ret;\n	}\n\n	void submit() {\n		int n = nextInt();\n		int m = nextInt();\n\n		int[] f = new int[B];\n		int[] b = new int[m];\n\n		for (int i = 0; i < n; i++) {\n			f[nextInt() - 1]++;\n		}\n		for (int i = 0; i < m; i++) {\n			b[i] = nextInt() - 1;\n		}\n\n		long tot = 0;\n		long curP = 1;\n		long multWays = fact[n];\n\n		int[] fen = new int[B];\n		for (int i = 0; i < B; i++) {\n			add(fen, i, f[i]);\n			multWays = multWays * invFact[f[i]] % P;\n		}\n\n		for (int i = 0; i < m && i < n; i++) {\n			int cntLess = get(fen, b[i] - 1);\n			tot += curP * cntLess % P * inv[n - i] % P;\n			if (tot >= P) {\n				tot -= P;\n			}\n			\n			if (f[b[i]] > 0) {\n				curP = curP * f[b[i]] % P * inv[n - i] % P;\n				f[b[i]]--;\n				add(fen, b[i], -1);\n			} else {\n				out.println(tot * multWays % P);\n				return;\n			}\n		}\n		\n		tot = tot * multWays % P;\n		\n		// we are prefix of b, add 1\n		if (n < m) {\n			tot++;\n			if (tot >= P) {\n				tot -= P;\n			}\n		}\n		out.println(tot);\n	}\n\n	void test() {\n\n	}\n\n	void stress() {\n		for (int tst = 0;; tst++) {\n			if (false) {\n				throw new AssertionError();\n			}\n			System.err.println(tst);\n		}\n	}\n\n	C() throws IOException {\n		is = System.in;\n		out = new PrintWriter(System.out);\n		submit();\n		// stress();\n		// test();\n		out.close();\n	}\n\n	static final Random rng = new Random();\n	static final int C = 5;\n\n	static int rand(int l, int r) {\n		return l + rng.nextInt(r - l + 1);\n	}\n\n	public static void main(String[] args) throws IOException {\n		new C();\n	}\n\n	private InputStream is;\n	PrintWriter out;\n\n	private byte[] buf = new byte[1 << 14];\n	private int bufSz = 0, bufPtr = 0;\n\n	private int readByte() {\n		if (bufSz == -1)\n			throw new RuntimeException(""Reading past EOF"");\n		if (bufPtr >= bufSz) {\n			bufPtr = 0;\n			try {\n				bufSz = is.read(buf);\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n			if (bufSz <= 0)\n				return -1;\n		}\n		return buf[bufPtr++];\n	}\n\n	private boolean isTrash(int c) {\n		return c < 33 || c > 126;\n	}\n\n	private int skip() {\n		int b;\n		while ((b = readByte()) != -1 && isTrash(b))\n			;\n		return b;\n	}\n\n	String nextToken() {\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b)) {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	String nextString() {\n		int b = readByte();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b) || b == ' ') {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	double nextDouble() {\n		return Double.parseDouble(nextToken());\n	}\n\n	char nextChar() {\n		return (char) skip();\n	}\n\n	int nextInt() {\n		int ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n\n	long nextLong() {\n		long ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n}","combinatorics,data structures,implementation"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1637D extends PrintWriter {\n	CF1637D() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1637D o = new CF1637D(); o.main(); o.flush();\n	}\n\n	static final int X = 10000, INF = 0x3f3f3f3f;\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int[] aa = new int[n];\n			int[] bb = new int[n];\n			for (int i = 0; i < n; i++)\n				aa[i] = sc.nextInt();\n			for (int i = 0; i < n; i++)\n				bb[i] = sc.nextInt();\n			int[] dp = new int[X + 1]; Arrays.fill(dp, INF); dp[0] = 0;\n			int[] dq = new int[X + 1];\n			int s = 0;\n			for (int i = 0; i < n; i++) {\n				int a = aa[i];\n				int b = bb[i];\n				Arrays.fill(dq, INF);\n				for (int x = 0; x <= X; x++)\n					if (dp[x] != INF) {\n						int y = s - x;\n						if (x + a <= X)\n							dq[x + a] = Math.min(dq[x + a], dp[x] + x * a + y * b);\n						if (x + b <= X)\n							dq[x + b] = Math.min(dq[x + b], dp[x] + x * b + y * a);\n					}\n				s += a + b;\n				int[] tmp = dp; dp = dq; dq = tmp;\n			}\n			int ans = INF;\n			for (int x = 0; x <= X; x++)\n				ans = Math.min(ans, dp[x]);\n			ans *= 2;\n			for (int i = 0; i < n; i++)\n				for (int j = i + 1; j < n; j++)\n					ans += aa[i] * aa[i] + aa[j] * aa[j] + bb[i] * bb[i] + bb[j] * bb[j];\n			println(ans);\n		}\n	}\n}\n","dp,greedy,math"
"import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n    private static Scanner scanner = new Scanner(System.in);\n\n    int n;\n    Set<Integer> dp;\n    int sum;\n    long result;\n\n    void read() {\n        n = scanner.nextInt();\n\n        sum = 0;\n        result = 0;\n\n        dp = new HashSet<>();\n        dp.add(0);\n\n        int[] a = new int[n], b = new int[n];\n        for (int i=0; i<n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        for (int i=0; i<n; i++) {\n            b[i] = scanner.nextInt();\n        }\n\n        for (int i=0; i<n;i++) {\n\n            Set<Integer> tmp = new HashSet<>();\n            for (int j : dp) {\n                tmp.add(j + a[i]);\n                tmp.add(j + b[i]);\n            }\n            dp = tmp;\n\n            sum += a[i] + b[i];\n            result += a[i]*a[i] + b[i]*b[i];\n        }\n        result *= n-2;\n    }\n\n    long cal(long sum_a) {\n        long sum_b = sum - sum_a;\n        return sum_a * sum_a + sum_b * sum_b;\n    }\n\n    void work() {\n        for (int i=sum/2; i<=sum; i++) {\n            if (dp.contains(i)) {\n                System.out.println(result + cal(i));\n                return ;\n            }\n        }\n    }\n\n    public static void main(String [] args) {\n        int t = scanner.nextInt();\n        Main work = new Main();\n        while (t-- > 0) {\n            work.read();\n            work.work();\n        }\n    }\n}\n","dp,greedy,math"
"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class D {\n\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int inputs = in.nextInt();\n		while(inputs-->0) {\n			int n = in.nextInt();\n			int[] a = new int[n];\n			int[] b = new int[n];\n			int[] sum = new int[n+1];\n			for(int i = 0; i < n; i++) {\n				a[i] = in.nextInt();\n			}\n			for(int i = 0; i < n; i++) {\n				b[i] = in.nextInt();\n			}\n			for(int i = 1; i <= n; i++) {\n				sum[i] += a[i-1]+b[i-1];\n				sum[i] += sum[i-1];\n			}\n			long[][] dp = new long[n+1][100*100+1];\n			for(long[] l : dp)\n				Arrays.fill(l, Integer.MAX_VALUE);\n			boolean[][] pos = new boolean[n+1][100*100+1];\n			pos[0][0] = true;\n			dp[0][0] = 0;\n			for(int i = 1; i <= n; i++) {\n				for(int s = 0; s < dp[i].length; s++) {\n					if(pos[i-1][s]) {\n//						System.out.println(dp[i-1][s] + "" "" + a[i-1] + "" "" + b[i-1] + "" "" + 2*s*a[i-1] + "" "" + 2*(sum[i-1]-s)*b[i-1]);\n						dp[i][s+a[i-1]] = Math.min(dp[i][s+a[i-1]], dp[i-1][s]\n								+2*s*a[i-1]+2*(sum[i-1]-s)*b[i-1]);\n						pos[i][s+a[i-1]] = true;\n						\n						dp[i][s+b[i-1]] = Math.min(dp[i][s+b[i-1]], dp[i-1][s]\n								+2*s*b[i-1]+2*(sum[i-1]-s)*a[i-1]);\n						pos[i][s+b[i-1]] = true;\n					}\n				}\n			}\n			long best = Integer.MAX_VALUE;\n			for(int i = 0; i < dp[0].length; i++) {\n				best = Math.min(best, dp[n][i]);\n			}\n			for(int i = 0; i < n; i++) {\n				best += a[i]*a[i]*(n-1) + b[i]*b[i]*(n-1);\n			}\n			System.out.println(best);\n		}\n		in.close();\n	}\n\n}\n","dp,greedy,math"
"import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class D_Min {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int tasks = in.nextInt();\n\n        while (tasks-- > 0) {\n            int count = in.nextInt();\n            long totalSum = 0;\n            long totalCost = 0;\n\n            int[] first = new int[count];\n            for (int i = 0; i < count; i++) {\n                int num = in.nextInt();\n                first[i] = num;\n                totalSum += num;\n                totalCost += (long) (count - 2) * num * num;\n            }\n\n            int[] second = new int[count];\n            for (int i = 0; i < count; i++) {\n                int num = in.nextInt();\n                second[i] = num;\n                totalSum += num;\n                totalCost += (long) (count - 2) * num * num;\n            }\n\n            Set<Long> sumVariants = Set.of(0L);\n            for (int i = 0; i < count; i++) {\n                Set<Long> newVariants = new HashSet<>();\n                for (Long variant : sumVariants) {\n                    newVariants.add(variant + first[i]);\n                    newVariants.add(variant + second[i]);\n                }\n                sumVariants = newVariants;\n            }\n\n            long min = Long.MAX_VALUE;\n            for (Long firstSum : sumVariants) {\n                long secondSum = totalSum - firstSum;\n                min = Math.min(min, firstSum * firstSum + secondSum * secondSum);\n            }\n\n            totalCost += min;\n\n            System.out.println(totalCost);\n        }\n    }\n}\n","dp,greedy,math"
\nimport java.util.*;\npublic class sol {\n	\npublic static void main(String arg[])\n{\n	Scanner sc=new Scanner(System.in);\n	int t=sc.nextInt();\n	while(t-->0)\n	{\n	\n		int n =sc.nextInt();\n		long a[] = new long[n];\n		for(int i=0;i<n;i++) {\n			a[i]=sc.nextInt();\n		}\n		if(n==3 &&a[1]%2!=0)System.out.println(-1);\n		else {\n			boolean impossible = true;\n			long sum = 0;\n			for(int i=1;i<n-1;i++) {\n				if(a[i]!=1)impossible = false;\n				sum += (a[i]+1)/2;\n			}\n			if(impossible)System.out.println(-1);\n			else {\n				System.out.println(sum);\n			}\n		}\n		\n	}\n}\n}\n,"greedy,implementation"
import java.util.Scanner;\n\npublic class mex {\npublic static void main(String[] args) {\n	Scanner scan =new Scanner(System.in);\n	int t =scan.nextInt();\n	while(t-->0) {\n		int n =scan.nextInt();\n		long a[] = new long[n];\n		for(int i=0;i<n;i++) {\n			a[i]=scan.nextInt();\n		}\n		if(n==3 &&a[1]%2!=0)System.out.println(-1);\n		else {\n			boolean impossible = true;\n			long sum = 0;\n			for(int i=1;i<n-1;i++) {\n				if(a[i]!=1)impossible = false;\n				sum += (a[i]+1)/2;\n			}\n			if(impossible)System.out.println(-1);\n			else {\n				System.out.println(sum);\n			}\n		}\n		\n	}\n}\n}\n,"greedy,implementation"
import java.util.*;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while(t-->0) {\n			int n = sc.nextInt();\n			int a[] = new int[n];\n			long sum = 0;\n			int odd = 0;\n			boolean b = false;\n			a[0]=sc.nextInt();\n			for(int i=1;i<n-1;i++) {\n				a[i]=sc.nextInt();\n				sum+=a[i]/2;\n				if(a[i]%2==1)\n					odd++;\n				if(a[i]>1)\n					b=true;\n			}\n			a[n-1]=sc.nextInt();\n			if(!b || (odd==n-2 && n==3)) {\n				System.out.println(-1);\n			}else {\n				System.out.println(sum+odd);\n			}			\n		}\n	}\n}\n,"greedy,implementation"
import java.util.*;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while(t-->0) {\n			int n = sc.nextInt();\n			int a[] = new int[n];\n			long sum = 0;\n			int odd = 0;\n			boolean b = false;\n			a[0]=sc.nextInt();\n			for(int i=1;i<n-1;i++) {\n				a[i]=sc.nextInt();\n				sum+=a[i]/2;\n				if(a[i]%2==1)\n					odd++;\n				if(a[i]>1)\n					b=true;\n			}\n			a[n-1]=sc.nextInt();\n			if(!b || (odd==n-2 && n==3)) {\n				System.out.println(-1);\n			}else {\n				System.out.println(sum+odd);\n			}			\n		}\n	}\n}\n,"greedy,implementation"
"// coached by rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1635E extends PrintWriter {\n	CF1635E() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1635E o = new CF1635E(); o.main(); o.flush();\n	}\n\n	int[] eo; int[][] ej, et;\n	void append(int i, int j, int t) {\n		int o = eo[i]++;\n		if (o >= 2 && (o & o - 1) == 0) {\n			ej[i] = Arrays.copyOf(ej[i], o << 1);\n			et[i] = Arrays.copyOf(et[i], o << 1);\n		}\n		ej[i][o] = j;\n		et[i][o] = t;\n	}\n	boolean[] visited;\n	int[] qu, dd, ii; int k;\n	char[] ori; int[] xx;\n	boolean dfs(int i, char lr) {\n		if (ori[i] != 0)\n			return ori[i] == lr;\n		ii[k++] = i;\n		ori[i] = lr;\n		lr = lr == 'L' ? 'R' : 'L';\n		for (int o = eo[i]; o-- > 0; ) {\n			int j = ej[i][o];\n			if (!dfs(j, lr))\n				return false;\n		}\n		return true;\n	}\n	int x;\n	boolean topo() {\n		int head = 0, cnt = 0;\n		for (int h = 0; h < k; h++) {\n			int i = ii[h];\n			for (int o = eo[i]; o-- > 0; ) {\n				int t = et[i][o];\n				if (ori[i] == 'R' && t == 1 || ori[i] == 'L' && t == 2)\n					dd[i]++;\n			}\n			if (dd[i] == 0)\n				qu[cnt++] = i;\n		}\n		while (cnt-- > 0) {\n			int i = qu[head++];\n			for (int o = eo[i]; o-- > 0; ) {\n				int j = ej[i][o];\n				int t = et[i][o];\n				if (ori[i] == 'R' && t == 2 || ori[i] == 'L' && t == 1)\n					if (--dd[j] == 0)\n						qu[head + cnt++] = j;\n			}\n		}\n		if (head != k)\n			return false;\n		for (int h = 0; h < k; h++) {\n			int i = qu[h];\n			xx[i] = x++;\n		}\n		return true;\n	}\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		eo = new int[n]; ej = new int[n][2]; et = new int[n][2];\n		while (m-- > 0) {\n			int t = sc.nextInt();\n			int i = sc.nextInt() - 1;\n			int j = sc.nextInt() - 1;\n			append(i, j, t);\n			append(j, i, t);\n		}\n		qu = new int[n];\n		dd = new int[n];\n		ii = new int[n];\n		ori = new char[n]; xx = new int[n];\n		for (int i = 0; i < n; i++) {\n			k = 0;\n			if (ori[i] == 0)\n				if (!dfs(i, 'R') || !topo()) {\n					println(""NO"");\n					return;\n				}\n		}\n		println(""YES"");\n		for (int i = 0; i < n; i++)\n			println(ori[i] + "" "" + xx[i]);\n	}\n}\n","2-sat,constructive algorithms,dfs and similar,dsu,graphs,greedy,sortings"
"import java.io.*;\nimport java.util.*;\n\npublic class Cars {\n    //io\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter out = new PrintWriter(System.out);\n    static boolean debug = false;\n\n    //param\n    static int N;\n    static int M;\n    static Restriction[] restrictions;\n\n    //coloring\n    static ArrayList<Integer>[] adjList;\n    static int[] orientation;\n    static boolean impossible = false;\n\n    //top sort\n    static ArrayList<Integer>[] toRight;\n    static boolean[] visited;\n    static ArrayList<Integer> sort = new ArrayList<>();\n\n    public static void main(String[] args) throws IOException {\n        //parse input\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        N = Integer.parseInt(st.nextToken());\n        M = Integer.parseInt(st.nextToken());\n        restrictions = new Restriction[M];\n        for (int i=0;i<M;i++){\n            st = new StringTokenizer(br.readLine());\n            restrictions[i] = new Restriction(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()));\n        }\n\n        //part 1: assign coloring (if cant, NO) 1:left facing, 2:right facing\n        adjList = new ArrayList[N+1];\n        orientation = new int[N+1];\n        for (int i=1;i<=N;i++){\n            adjList[i] = new ArrayList<>();\n        }\n        for (Restriction r : restrictions){\n            adjList[r.u].add(r.v);\n            adjList[r.v].add(r.u);\n        }\n        for (int i=1;i<=N;i++){\n            if (orientation[i]==0){\n                orientation[i]=1;\n                dfs(i);\n            }\n        }\n        if (debug) System.out.println(Arrays.toString(orientation));\n        if (debug) System.out.println(Arrays.toString(adjList));\n        if (impossible) {\n            out.println(""NO"");\n            out.close();\n            return;\n        }\n\n        //part 2: create directed graph. arrow signifies the child car is to its right\n        toRight = new ArrayList[N+1];\n        for (int i=1;i<=N;i++){\n            toRight[i] = new ArrayList<>();\n        }\n        for (Restriction r : restrictions){\n            if ((orientation[r.u]==1&&r.type==1)||(orientation[r.u]==2&&r.type==2)){\n                toRight[r.u].add(r.v);\n            }\n            else {\n                toRight[r.v].add(r.u);\n            }\n        }\n        if (debug) System.out.println(Arrays.toString(toRight));\n\n        //part 3: top sort the directed graph. if its not DAG, print impossible\n        visited = new boolean[N+1];\n        for (int i=1;i<=N;i++){\n            topSort(i);\n        }\n        Collections.reverse(sort);\n        if (debug) System.out.println(sort);\n\n        int[] depth = new int[N+1];\n        for (int i=0;i<sort.size();i++){\n            depth[sort.get(i)]=i;\n        }\n        if (debug) System.out.println(Arrays.toString(depth));\n        for (int u=1;u<=N;u++){\n            for (int v : toRight[u]){\n                if (depth[u]>depth[v]) {\n                    out.println(""NO"");\n                    out.close();\n                    return;\n                }\n            }\n        }\n        //turn in answer\n        out.println(""YES"");\n        for (int i=1;i<=N;i++){\n            if (orientation[i]==1) out.print(""L "");\n            else out.print(""R "");\n            out.print(depth[i]);\n            out.println();\n        }\n        out.close();\n    }\n    public static void topSort(int node){\n        if (visited[node]) return;\n        visited[node] = true;\n        for (int child : toRight[node]){\n            topSort(child);\n        }\n        sort.add(node);\n    }\n    public static void dfs(int node){\n        for (int child : adjList[node]){\n            if (orientation[child]!=0){\n                if (orientation[child]==orientation[node]) impossible=true;\n            }\n            else {\n                orientation[child]=3-orientation[node];\n                dfs(child);\n            }\n        }\n    }\n    private static class Restriction {\n        int type;\n        int u;\n        int v;\n        public Restriction(int t, int u, int v){\n            type=t;\n            this.u=u;\n            this.v=v;\n        }\n    }\n}\n","2-sat,constructive algorithms,dfs and similar,dsu,graphs,greedy,sortings"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class E {\n    public static FastScanner s = new FastScanner();\n    public static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        solve(s.nextInt(), s.nextInt());\n\n        out.close();\n    }\n\n\n\n    public static void solve(int c, int r) {\n        int[][] res = new int[r][3];\n        for (int i = 0; i < r; i++) res[i] = s.readArray(3);\n\n        LinkedList<int[]>[] nodes = new LinkedList[c];\n        for (int i = 0; i < c; i++) nodes[i] = new LinkedList<>();\n        for (int i = 0; i < r; i++) {\n            nodes[res[i][1]].add(new int[]{res[i][2], res[i][0] + 1});\n            nodes[res[i][2]].add(new int[]{res[i][1], res[i][0] + 1});\n        }\n\n        int[] ori = new int[c];\n        LinkedList<Integer> updates = new LinkedList<>();\n        int t;\n        for (int i = 0; i < c; i++) {\n            if (ori[i] != 0) continue;\n            updates.add(i);\n            ori[i] = 1;\n            while (updates.size() != 0) {\n                t = updates.pollLast();\n                for (int[] e: nodes[t]) {\n                    if (ori[e[0]] == 0) {\n                        ori[e[0]] = 3 ^ ori[t];\n                        updates.add(e[0]);\n                    } else {\n                        if ((ori[e[0]] ^ ori[t]) != 3) {\n                            out.println(""NO"");\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i < c; i++) {\n            for (int[] e: nodes[i]) {\n                e[1] = (e[1] ^ ori[i]) - 1;\n            }\n        }\n\n        TreeSet<int[]>[] setNodes = new TreeSet[c];\n        for (int i = 0; i < c; i++) {\n            setNodes[i] = new TreeSet<>((x, y) -> x[1] == y[1] ? y[0] - x[0] : y[1] - x[1]);\n            for (int[] e: nodes[i]) {\n                setNodes[i].add(e);\n            }\n        }\n\n        LinkedList<Integer> order = new LinkedList<>();\n        LinkedList<Integer> upd = new LinkedList<>();\n        boolean[] done = new boolean[c];\n        for (int i = 0; i < c; i++) upd.add(i);\n        while (upd.size() > 0) {\n            t = upd.pollLast();\n            if (done[t]) continue;\n            if (setNodes[t].size() == 0) {\n                order.add(t);\n                done[t] = true;\n                for (int[] e: setNodes[t]) {\n                    upd.add(e[0]);\n                    setNodes[e[0]].remove(new int[]{t, 1 - e[1]});\n                }\n                continue;\n            }\n            if (setNodes[t].first()[1] < 0) {\n                order.add(t);\n                done[t] = true;\n                for (int[] e: setNodes[t]) {\n                    upd.add(e[0]);\n                    setNodes[e[0]].remove(new int[]{t, 1 - e[1]});\n                }\n            }\n        }\n\n\n        TreeMap<Integer, String> sout = new TreeMap<>();\n        int i = 0;\n        if (order.size() != c) {\n            System.out.println(""NO"");\n        } else {\n            System.out.println(""YES"");\n            for (int z: order) {\n                sout.put(z, (ori[z] == 1 ? ""L"" : ""R"") + "" "" + i++);\n            }\n            for (Map.Entry<Integer, String> e: sout.entrySet()) out.println(e.getValue());\n        }\n    }\n\n\n\n    static class FastScanner {//copied from secondthread\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer("""");\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i<n; i++) a[i]=nextInt()-1;\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n","2-sat,constructive algorithms,dfs and similar,dsu,graphs,greedy,sortings"
"import java.io.*;\nimport java.util.*;\n\npublic class Cars {\n    public static void main(String[] args) {\n        InputReader reader = new InputReader(System.in);\n        PrintWriter writer = new PrintWriter(System.out, false);\n        int N = reader.nextInt();\n        int M = reader.nextInt();\n        int[][] edges = new int[M][3];\n        for (int i = 0; i < M; i++) {\n            int type = reader.nextInt();\n            int u = reader.nextInt() - 1;\n            int v = reader.nextInt() - 1;\n            edges[i] = new int[]{type, u, v};\n        }\n        List<List<Integer>> G = new ArrayList<>(N);\n        for (int i = 0; i < N; i++) {\n            G.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            G.get(edge[1]).add(edge[2]);\n            G.get(edge[2]).add(edge[1]);\n        }\n        int[] color = new int[N];\n        Arrays.fill(color, -1);\n        for (int i = 0; i < N; i++) {\n            if (color[i] != -1) continue;\n            color[i] = 0;\n            Queue<Integer> queue = new LinkedList<>();\n            queue.add(i);\n            while (!queue.isEmpty()) {\n                int u = queue.remove();\n                for (int v : G.get(u)) {\n                    if (color[v] == -1) {\n                        color[v] = color[u] ^ 1;\n                        queue.add(v);\n                    } else if (color[v] == color[u]) {\n                        writer.println(""NO"");\n                        writer.close();\n                        System.exit(0);\n                    }\n                }\n            }\n        }\n        G = new ArrayList<>(N);\n        for (int i = 0; i < N; i++) {\n            G.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            int type = edge[0];\n            int u = edge[1];\n            int v = edge[2];\n            if (color[u] == 1) {\n                int tmp = u;\n                u = v;\n                v = tmp;\n            }\n            if (type == 1) {\n                G.get(u).add(v);\n            } else {\n                G.get(v).add(u);\n            }\n        }\n        int[] inDegree = new int[N];\n        for (int i = 0; i < N; i++) {\n            for (int j : G.get(i)) {\n                inDegree[j]++;\n            }\n        }\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < N; i++) {\n            if (inDegree[i] == 0) {\n                queue.add(i);\n            }\n        }\n        int[] top = new int[N];\n        int order = 0;\n        while (!queue.isEmpty()) {\n            int u = queue.remove();\n            top[u] = order++;\n            for (int v : G.get(u)) {\n                if (--inDegree[v] == 0) {\n                    queue.add(v);\n                }\n            }\n        }\n        if (order != N) {\n            writer.println(""NO"");\n            writer.close();\n            System.exit(0);\n        }\n        writer.println(""YES"");\n        for (int i = 0; i < N; i++) {\n            writer.println((color[i] == 0 ? 'L' : 'R') + "" "" + top[i]);\n        }\n        writer.close();\n        System.exit(0);\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        public String nextLine() {\n            String str = """";\n            try {\n                str = reader.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}","2-sat,constructive algorithms,dfs and similar,dsu,graphs,greedy,sortings"
"import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int x=0; //上一个除的结果\n        int l=1;\n        int r=n;\n        int sum=0;\n        while (l+1<r){\n            int mid=(l+r)/2;\n            System.out.println(""+ ""+(n-mid));\n            sum+=(n-mid);\n            int i = sc.nextInt();\n            if(i!=x){\n                l=mid;\n                x=i;\n            }else r=mid;\n            l=(l+n-mid)%n;\n            r=(r+n-mid)%n;\n            if(r==0) r=n;\n        }\n        System.out.println(""! ""+(l+x*n));\n        System.out.flush();\n    }\n}\n","binary search,constructive algorithms,interactive"
"import java.util.Scanner;\nimport java.util.Stack;\n\npublic class solF {\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int x=0; //上一个除的结果\n        int l=1;\n        int r=n;\n        int sum=0;\n        while (l+1<r){\n            int mid=(l+r)/2;\n            System.out.println(""+ ""+(n-mid));\n            sum+=(n-mid);\n            int i = sc.nextInt();\n            if(i!=x){\n                l=mid;\n                x=i;\n            }else r=mid;\n            l=(l+n-mid)%n;\n            r=(r+n-mid)%n;\n            if(r==0) r=n;\n        }\n        System.out.println(""! ""+(l+x*n));\n        System.out.flush();\n    }\n}\n","binary search,constructive algorithms,interactive"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1624F extends PrintWriter {\n	CF1624F() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1624F o = new CF1624F(); o.main(); o.flush();\n	}\n\n	int query(int c) {\n		println(""+ "" + c);\n		return sc.nextInt();\n	}\n	void main() {\n		int n = sc.nextInt();\n		int a = 0;\n		int x = 0;\n		int lower = 0, upper = n;\n		while (upper - lower > 1) {\n			int r = (upper + lower) / 2;\n			int c = (r / n + 1) * n - r;\n			int b = query(c);\n			if (a == b)\n				upper = r;\n			else {\n				lower = r;\n				a = b;\n			}\n			x = a * n;\n			lower = (lower + c) % n;\n			upper = (upper + c) % n;\n			if (lower > upper)\n				upper += n;\n		}\n		println(""! "" + (x + lower));\n	}\n}\n","binary search,constructive algorithms,interactive"
import java.io.PrintWriter;\nimport java.util.Scanner;\n \npublic class InteracdiveProblem {\n	\n	static Scanner sc = new Scanner(System.in);\n	static PrintWriter pw = new PrintWriter(System.out);\n	\n	public static void main(String[] args) {\n		\n		int N = sc.nextInt();\n		int xl = 1;\n		int xr = N-1;\n		int prev = 0;\n		while( xl < xr ) {\n			int mid = (xl+xr+1)/2;\n			int c = N-mid%N;\n			int res = query(c);\n			if( res > prev ) xl = mid;\n			else xr = mid-1;\n			xl += c;\n			xr += c;\n			prev = res;\n		}\n		\n		answer_query(xl);\n		\n	}\n	\n	static void answer_query(int ans) {\n		\n		pw.print('!');\n		pw.print(' ');\n		pw.println(ans);\n		pw.flush();\n		\n	}\n	\n	static int query(int c) {\n		\n		pw.print('+');\n		pw.print(' ');\n		pw.println(c);\n		pw.flush();\n		\n		return sc.nextInt();\n		\n	}\n	\n}\n,"binary search,constructive algorithms,interactive"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1615E extends PrintWriter {\n	CF1615E() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1615E o = new CF1615E(); o.main(); o.flush();\n	}\n\n	int[] eo; int[][] ej;\n	void append(int i, int j) {\n		int o = eo[i]++;\n		if (o >= 2 && (o & o - 1) == 0)\n			ej[i] = Arrays.copyOf(ej[i], o << 1);\n		ej[i][o] = j;\n	}\n	boolean[] used; int[] pp, dd, xx;\n	int dfs(int p, int i, int d) {\n		pp[i] = p;\n		dd[i] = d;\n		int x = i;\n		for (int o = eo[i]; o-- > 0; ) {\n			int j = ej[i][o];\n			if (j != p) {\n				int y = dfs(i, j, d + 1);\n				if (dd[x] < dd[y])\n					x = y;\n			}\n		}\n		return xx[i] = x;\n	}\n	int[] pq, iq; int cnt;\n	boolean lt(int i, int j) {\n		return dd[xx[i]] - dd[i] > dd[xx[j]] - dd[j];\n	}\n	int p2(int p) {\n		return (p *= 2) > cnt ? 0 : p < cnt && lt(iq[p + 1], iq[p]) ? p + 1 : p;\n	}\n	void pq_up(int i) {\n		int j, p, q;\n		for (p = pq[i]; (q = p / 2) > 0 && lt(i, j = iq[q]); p = q)\n			iq[pq[j] = p] = j;\n		iq[pq[i] = p] = i;\n	}\n	void pq_dn(int i) {\n		int j, p, q;\n		for (p = pq[i]; (q = p2(p)) > 0 && lt(j = iq[q], i); p = q)\n			iq[pq[j] = p] = j;\n		iq[pq[i] = p] = i;\n	}\n	void pq_add(int i) {\n		pq[i] = ++cnt; pq_up(i);\n	}\n	int pq_remove_first() {\n		int i = iq[1], j = iq[cnt--];\n		if (j != i) {\n			pq[j] = 1; pq_dn(j);\n		}\n		pq[i] = 0;\n		return i;\n	}\n	long solve(int u, int v) {\n		if (u >= v)\n			return (long) u * v;\n		int a = (u + v) / 2;\n		return (long) a * (u + v - a);\n	}\n	long solve(int r, int w, int wb) {\n		if (r >= wb)\n			return (long) w * (r - wb);\n		return -solve(w, wb - r);\n	}\n	void main() {\n		int n = sc.nextInt();\n		int k = sc.nextInt();\n		eo = new int[n]; ej = new int[n][2];\n		for (int h = 0; h < n - 1; h++) {\n			int i = sc.nextInt() - 1;\n			int j = sc.nextInt() - 1;\n			append(i, j);\n			append(j, i);\n		}\n		used = new boolean[n]; pp = new int[n]; dd = new int[n]; xx = new int[n];\n		dfs(-1, 0, 0);\n		int w = 0, r = 0;\n		long ans = solve(r, w, n - r - w);\n		pq = new int[n]; iq = new int[n + 1];\n		pq_add(0);\n		while (cnt > 0 && r < k) {\n			int i = pq_remove_first();\n			int x = xx[i];\n			w += dd[x] - dd[i]; r++;\n			ans = Math.max(ans, solve(r, w, n - r - w));\n			used[x] = true;\n			for (i = pp[x]; i != -1 && !used[i]; i = pp[x = i]) {\n				used[i] = true;\n				for (int o = eo[i]; o-- > 0; ) {\n					int j = ej[i][o];\n					if (j != x && j != pp[i])\n						pq_add(j);\n				}\n			}\n		}\n		if (r < k)	// r + w == n\n			if (r + r < n) {\n				if (k + k < n)\n					r = k;\n				else\n					r = n / 2;\n				w = n - r;\n				ans = Math.max(ans, (long) w * r);\n			}\n		println(ans);\n	}\n}\n","data structures,dfs and similar,games,graphs,greedy,math,sortings,trees"
"import java.util.*;\nimport java.io.*;\npublic class Global18E{\n	static int[] parent;\n	static int[][] subnodes;\n	static int[] subnodescopy;\n	static HashMap<Integer, HashSet<Integer>> edges;\n	static HashSet<Integer> leaves;\n	static HashSet<Integer> noBlue;\n	public static void main(String[] main) throws Exception{\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		PrintWriter out = new PrintWriter(System.out);\n		int n = Integer.parseInt(st.nextToken());\n		int k = Integer.parseInt(st.nextToken());\n		edges = new HashMap<Integer, HashSet<Integer>>();\n		for(int i = 0; i < n-1; i++) {\n			st = new StringTokenizer(br.readLine());\n			int a = Integer.parseInt(st.nextToken())-1;\n			int b = Integer.parseInt(st.nextToken())-1;\n			if(!edges.keySet().contains(a))\n				edges.put(a, new HashSet<Integer>());\n			if(!edges.keySet().contains(b))\n				edges.put(b, new HashSet<Integer>());\n			edges.get(a).add(b);\n			edges.get(b).add(a);\n		}\n		leaves = new HashSet<Integer>();\n		parent = new int[n];\n		parent[0] = -1;\n		subnodes = new int[n][2];\n		subnodescopy = new int[n];\n		recur(0);\n		if(k >= leaves.size()) {\n			if(k <= n/2) {\n				long ans = k;\n				ans *= n-k;\n				out.println(ans);\n			}\n			else {\n				if(leaves.size() <= n/2) {\n					long ans = n/2;\n					ans *= n-n/2;\n					out.println(ans);\n				}\n				else{\n					long ans = leaves.size();\n					ans *= n-leaves.size();\n					out.println(ans);\n				}\n			}\n		}\n		else {\n			Arrays.sort(subnodes, new Comparator<int[]>() {\n				public int compare(int[] a, int[] b) {\n					return b[1] - a[1];\n				}\n			});\n			noBlue = new HashSet<Integer>();\n			long red = 0;\n			for(int[] a: subnodes) {\n				if(!noBlue.contains(a[0])) {\n					int next = a[0];\n					noBlue.add(a[0]);\n					while(!leaves.contains(next)) {\n						int max = 0;\n						int index = 0;\n						for(int i: edges.get(next)) {\n							if(subnodescopy[i] > max) {\n								max = subnodescopy[i];\n								index = i;\n							}\n						}\n						next = index;\n						noBlue.add(next);\n					}\n					red += 1;\n				}\n				if(red == k)\n					break;\n			}\n			long blue = 0;\n			for(int[] a: subnodes) {\n				if(!noBlue.contains(a[0])) {\n					recur1(a[0]);\n					blue += a[1];\n				}\n			}\n			long ans = n - red - blue;\n			ans *= red - blue;\n			if(blue - red >= n - red - blue) {\n				ans = red - n/2;\n				ans *= n - n/2 - red;\n			}\n			out.println(ans);\n		}\n		out.close();\n	}\n	public static void recur(int next) {\n		int[] temp = new int[2];\n		temp[0] = next;\n		temp[1] = 1;\n		subnodes[next] = temp;\n		subnodescopy[next] = 1;\n		if(edges.get(next).size() == 0) {\n			leaves.add(next);\n		}\n		else {\n			for(int i: edges.get(next)) {\n				parent[i] = next;\n				edges.get(i).remove(next);\n				recur(i);\n				subnodes[next][1] += subnodes[i][1];\n				subnodescopy[next] += subnodes[i][1];\n			}\n		}\n	}\n	public static void recur1(int next) {\n		noBlue.add(next);\n		for(int i: edges.get(next))\n			recur1(i);\n	}\n}","data structures,dfs and similar,games,graphs,greedy,math,sortings,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class E {\n\n    static ArrayList<Integer>[] adjList;\n    static int[] in, out, par, map, dist;\n    static int counter;\n\n    static void dfs(int u, int p) {\n        in[u] = ++counter;\n        map[in[u]] = u;\n        par[u] = p;\n        dist[u] = 1 + (p == -1 ? 0 : dist[p]);\n        for (int x : adjList[u]) {\n            if (x != p) {\n                dfs(x, u);\n            }\n        }\n        out[u] = counter;\n    }\n\n    static final long INF = (long) 1e18;\n\n    public static void print(SegmentTree sg) {\n        for (int i = 1; i <= sg.N; i++) {\n            System.out.print(Arrays.toString(sg.query(i, i)) + "" "");\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        SegmentTree sg = new SegmentTree(n);\n        adjList = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            adjList[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < n - 1; i++) {\n            int u = sc.nextInt() - 1;\n            int v = sc.nextInt() - 1;\n            adjList[u].add(v);\n            adjList[v].add(u);\n        }\n        in = new int[n];\n        out = new int[n];\n        par = new int[n];\n        map = new int[n + 1];\n        dist = new int[n + 1];\n        dfs(0, -1);\n        for (int i = 0; i < n; i++) {\n            sg.update_range(in[i], in[i], dist[i]);\n        }\n//        System.out.println(Arrays.deepToString(sg.sTree));\n        boolean[] taken = new boolean[n];\n        int numTaken = 0;\n        int reqToTakeAll = 0;\n        for (int i = 0; i < k && numTaken < n; i++) {\n            reqToTakeAll++;\n            int[] max = sg.query(1, n);\n//            System.out.println(Arrays.toString(max));\n            int cur = map[max[1]];\n//            System.out.println(cur + ""AA"");\n            while (cur != -1 && !taken[cur]) {\n//                System.out.println(cur + "" DDDD"");\n                taken[cur] = true;\n                numTaken++;\n                sg.update_range(in[cur], out[cur], -1);\n                cur = par[cur];\n            }\n//            print(sg);\n        }\n//        System.out.println(Arrays.toString(taken));\n//        System.out.println(numTaken);\n        if (numTaken == n) {\n            long ans = -INF;\n            for (int i = reqToTakeAll; i <= k; i++) {\n                ans = Math.max(ans, 1l * i * (n - i));\n            }\n            pw.println(ans);\n        } else if ((n - numTaken) <= k) {\n//            System.out.println(""B"");\n            long ans = 1l * (numTaken - k) * (k - (n - numTaken));\n            pw.println(ans);\n        } else {\n            long ans = INF;\n            int red = k;\n            int forSureW = numTaken - red;\n            int canBeBOrW = n - red - forSureW;\n            for (int i = 0; i <= canBeBOrW; i++) {\n                ans = Math.min(ans, 1l * (forSureW + (canBeBOrW - i)) * (red - i));\n            }\n            pw.println(ans);\n        }\n        pw.close();\n    }\n\n    static class SegmentTree {        // 1-based DS, OOP\n\n        int N;            //the number of elements in the array as a power of 2 (i.e. after padding)\n        int[][] sTree;\n        int[] lazy;\n\n        SegmentTree(int n) {\n            N = 1;\n            while (N < n) N <<= 1;\n\n            sTree = new int[N << 1][2];        //no. of nodes = 2*N - 1, we add one to cross out index zero\n            for (int i = N; i < N << 1; i++) {\n                sTree[i][1] = i - N + 1;\n            }\n            lazy = new int[N << 1];\n        }\n\n        void max(int[] c, int[] a, int[] b) {\n            if (a[0] > b[0]) {\n                c[0] = a[0];\n                c[1] = a[1];\n            } else {\n                c[0] = b[0];\n                c[1] = b[1];\n            }\n        }\n\n        int[] max(int[] a, int[] b) {\n            if (a[0] > b[0]) {\n                return a;\n            } else {\n                return b;\n            }\n        }\n\n        void update_range(int i, int j, int val)        // O(log n)\n        {\n            update_range(1, 1, N, i, j, val);\n        }\n\n        void update_range(int node, int b, int e, int i, int j, int val) {\n            if (i > e || j < b)\n                return;\n            if (b >= i && e <= j) {\n                sTree[node][0] += val;\n                lazy[node] += val;\n            } else {\n                int mid = b + e >> 1;\n                propagate(node, b, mid, e);\n                update_range(node << 1, b, mid, i, j, val);\n                update_range(node << 1 | 1, mid + 1, e, i, j, val);\n                max(sTree[node], sTree[node << 1], sTree[node << 1 | 1]);\n            }\n        }\n\n        void propagate(int node, int b, int mid, int e) {\n            lazy[node << 1] += lazy[node];\n            lazy[node << 1 | 1] += lazy[node];\n            sTree[node << 1][0] += lazy[node];\n            sTree[node << 1 | 1][0] += lazy[node];\n            lazy[node] = 0;\n        }\n\n        int[] query(int i, int j) {\n            return query(1, 1, N, i, j);\n        }\n\n        int[] query(int node, int b, int e, int i, int j)    // O(log n)\n        {\n            if (i > e || j < b)\n                return new int[]{-1, -1};\n            if (b >= i && e <= j)\n                return sTree[node];\n            int mid = b + e >> 1;\n            propagate(node, b, mid, e);\n            int[] q1 = query(node << 1, b, mid, i, j);\n            int[] q2 = query(node << 1 | 1, mid + 1, e, i, j);\n            return max(q1, q2);\n        }\n\n    }\n\n\n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n    }\n\n}","data structures,dfs and similar,games,graphs,greedy,math,sortings,trees"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author lucasr\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		MyScanner in = new MyScanner(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		EPurpleCrayon solver = new EPurpleCrayon();\n		solver.solve(1, in, out);\n		out.close();\n	}\n\n	static class EPurpleCrayon {\n		public static MyScanner sc;\n		public static PrintWriter out;\n		int n;\n		IntArray[] adj;\n		int[] left;\n		int[] right;\n		int[] parent;\n		boolean[] chosen;\n		int index;\n		LazyMaxAddSegmentTree st;\n		IntArray leaves;\n\n		public void solve(int testNumber, MyScanner sc, PrintWriter out) {\n			EPurpleCrayon.sc = sc;\n			EPurpleCrayon.out = out;\n\n			n = sc.nextInt();\n			int k = sc.nextInt();\n			adj = new IntArray[n];\n			for (int i = 0; i < n; i++) {\n				adj[i] = new IntArray();\n			}\n			for (int i = 0; i < n - 1; i++) {\n				int tmp1 = sc.nextInt() - 1;\n				int tmp2 = sc.nextInt() - 1;\n				adj[tmp1].add(tmp2);\n				adj[tmp2].add(tmp1);\n			}\n			left = new int[n];\n			right = new int[n];\n			parent = new int[n];\n			chosen = new boolean[n];\n			leaves = new IntArray();\n			index = 0;\n			st = new LazyMaxAddSegmentTree(n);\n			dfs(0, -1, 1);\n			int mayChose = 0, red = 0;\n			for (int i = 0; i < k; i++) {\n				long[] maxAndPos = st.getMaxAndPos(0, index);\n				long max = maxAndPos[0];\n				int pos = (int) maxAndPos[1];\n				if (max <= 0) break;\n				mayChose += max;\n				red++;\n				int node = leaves.get(pos);\n				while (node != -1 && !chosen[node]) {\n					chosen[node] = true;\n					st.add(left[node], right[node], -1);\n					node = parent[node];\n				}\n			}\n			if (red == leaves.size()) {\n				long optimus = Math.max(red, Math.min(k, n / 2));\n				out.println(optimus * (n - optimus));\n				return;\n			}\n			int possibleBlue = n - mayChose;\n			long w = n - red - possibleBlue;\n			if (possibleBlue <= red) {\n				out.println(w * (red - possibleBlue));\n				return;\n			}\n			long nTotal = n - 2L * red;\n			possibleBlue -= red;\n			long optimus = Math.min(possibleBlue, nTotal / 2);\n			out.println(-optimus * (nTotal - optimus));\n		}\n\n		void dfs(int node, int par, int depth) {\n			parent[node] = par;\n			left[node] = index;\n			boolean leaf = true;\n			for (int i = 0; i < adj[node].size(); i++) {\n				int next = adj[node].get(i);\n				if (next != par) {\n					leaf = false;\n					dfs(next, node, depth + 1);\n				}\n			}\n			if (leaf) {\n				st.add(index, index + 1, depth);\n				leaves.add(node);\n				index++;\n			}\n			right[node] = index;\n		}\n\n	}\n\n	static class IntArray {\n		int[] arr;\n		int size;\n\n		public IntArray() {\n			arr = new int[4];\n		}\n\n		public void add(int val) {\n			if (size == arr.length) {\n				arr = Arrays.copyOf(arr, 2 * arr.length);\n			}\n			arr[size++] = val;\n		}\n\n		public int get(int pos) {\n			return arr[pos];\n		}\n\n		public int size() {\n			return size;\n		}\n\n		public int[] toArray() {\n			return Arrays.copyOf(arr, size);\n		}\n\n		public String toString() {\n			return ""IntArray "" + Arrays.toString(toArray());\n		}\n\n	}\n\n	static class LazyMaxAddSegmentTree {\n		public int size;\n		public long[] values;\n		public int[] maxPosition;\n		public long[] lazyAdd;\n\n		public LazyMaxAddSegmentTree(int capacity) {\n			size = 1;\n			while (size < capacity) size *= 2;\n			values = new long[2 * size];\n			maxPosition = new int[2 * size];\n			init(1, 0, size);\n			lazyAdd = new long[size];\n		}\n\n		private void init(int idx, int idxFrom, int idxTo) {\n			if (idxFrom + 1 == idxTo) {\n				maxPosition[idx] = idxFrom;\n				return;\n			}\n			int med = (idxFrom + idxTo) / 2;\n			init(2 * idx, idxFrom, med);\n			init(2 * idx + 1, med, idxTo);\n		}\n\n		private void propagateToChildren(int idx) {\n			if (lazyAdd[idx] == 0) return;\n			propagateToChild(idx, 2 * idx);\n			propagateToChild(idx, 2 * idx + 1);\n			lazyAdd[idx] = 0;\n		}\n\n		private void propagateToChild(int idx, int childIdx) {\n			if (childIdx < size) { // child really exists\n				lazyAdd[childIdx] += lazyAdd[idx];\n			}\n			values[childIdx] += lazyAdd[idx];\n		}\n\n		public void add(int fromInclusive, int toExclusive, long value) {\n			add(fromInclusive, toExclusive, 1, 0, size, value);\n		}\n\n		private void add(int fromInclusive, int toExclusive, int idx, int idxFrom, int idxTo, long value) {\n			if (idxTo <= fromInclusive || toExclusive <= idxFrom) return;\n			if (fromInclusive <= idxFrom && idxTo <= toExclusive) {\n				if (idx < size) {\n					lazyAdd[idx] += value;\n				}\n				values[idx] += value;\n				return;\n			}\n			int med = (idxFrom + idxTo) / 2;\n			propagateToChildren(idx);\n			add(fromInclusive, toExclusive, 2 * idx, idxFrom, med, value);\n			add(fromInclusive, toExclusive, 2 * idx + 1, med, idxTo, value);\n			values[idx] = Math.max(values[2 * idx], values[2 * idx + 1]);\n			if (values[idx] == values[2 * idx]) {\n				maxPosition[idx] = maxPosition[2 * idx];\n			} else {\n				maxPosition[idx] = maxPosition[2 * idx + 1];\n			}\n		}\n\n		public long[] getMaxAndPos(int fromInclusive, int toExclusive) {\n			int maxIdx = getMaxIdx(fromInclusive, toExclusive, 1, 0, size);\n			return new long[]{values[maxIdx], maxPosition[maxIdx]};\n		}\n\n		private int getMaxIdx(int fromInclusive, int toExclusive, int idx, int idxFrom, int idxTo) {\n			if (idxTo <= fromInclusive || toExclusive <= idxFrom) return -1;\n			if (fromInclusive <= idxFrom && idxTo <= toExclusive) {\n				return idx;\n			}\n			// Previous conditions => not a leaf\n			int med = (idxFrom + idxTo) / 2;\n			propagateToChildren(idx);\n			int ret1 = getMaxIdx(fromInclusive, toExclusive, 2 * idx, idxFrom, med);\n			int ret2 = getMaxIdx(fromInclusive, toExclusive, 2 * idx + 1, med, idxTo);\n			if (ret2 == -1 || ret1 != -1 && values[ret1] >= values[ret2]) return ret1;\n			return ret2;\n		}\n\n	}\n\n	static class MyScanner {\n		private BufferedReader br;\n		private StringTokenizer tokenizer;\n\n		public MyScanner(InputStream is) {\n			br = new BufferedReader(new InputStreamReader(is));\n		}\n\n		public String next() {\n			while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n				try {\n					tokenizer = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n			return tokenizer.nextToken();\n		}\n\n		public int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n	}\n}\n\n","data structures,dfs and similar,games,graphs,greedy,math,sortings,trees"
"import java.util.*;\nimport java.io.*;\npublic class Main{\n	public static void main (String[] args){\n	    Scanner in=new Scanner(System.in);\n	    int t=in.nextInt(),n,m,l,r;\n	    long or,MOD=(long)(1e9)+7,pow[]=new long[(int)2e5];\n	    pow[0]=1l;\n	    for(int i=1;i<2e5;i++) pow[i]=(pow[i-1]*2l+MOD)%MOD;\n	    while(t--!=0){\n	        n=in.nextInt();m=in.nextInt();or=0l;\n	        for(int i=0;i<m;i++){\n	            l=in.nextInt();r=in.nextInt();\n	            or|=(in.nextLong());\n	        }\n	        System.out.println((or*pow[n-1]+MOD)%MOD);\n	    }\n	}\n}","bitmasks,combinatorics,constructive algorithms,dp,math"
import java.util.*;\n\npublic class Divan_And_Bitwise_Operation {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while(t-->0) {\n			int n = sc.nextInt();\n			int m = sc.nextInt();\n			int or = 0;\n			while(m-->0) {\n				int l = sc.nextInt();\n				int r = sc.nextInt();\n				int rr = sc.nextInt();\n				or |= rr;\n			}\n			int mod = 1_000_000_007;\n			long pow = 1;\n			while(n-->1) {\n				pow = (pow*2)%mod;\n			}\n			long ans = ((pow)*or)%mod;\n			System.out.println(ans);\n		}\n	}\n\n}\n,"bitmasks,combinatorics,constructive algorithms,dp,math"
// garbage problem\n// https://www.geeksforgeeks.org/sum-xor-possible-subsets/\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1614C extends PrintWriter {\n	CF1614C() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1614C o = new CF1614C(); o.main(); o.flush();\n	}\n\n	static final int MD = 1000000007;\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int m = sc.nextInt();\n			int x = 0;\n			for (int h = 0; h < m; h++) {\n				sc.nextInt();\n				sc.nextInt();\n				x |= sc.nextInt();\n			}\n			x %= MD;\n			for (int i = 1; i < n; i++)\n				x = x * 2 % MD;\n			println(x);\n		}\n	}\n}\n,"bitmasks,combinatorics,constructive algorithms,dp,math"
"import  java.util.*;\n\npublic class myjava{\n    public static void main(String args[]){\n        Scanner input = new Scanner(System.in);\n        int t = input.nextInt();\n\n        long mod = (long)1e9 + 7;\n        while(t>0) {\n            int n = input.nextInt(), m = input.nextInt();\n            long XOR = 0;\n            for(int i=0; i<m; i++) {\n                int l, r, x;\n                l = input.nextInt(); r = input.nextInt(); x = input.nextInt();\n                XOR |= x;\n            }\n            long [] pw = new long[n+10];\n            pw [0] = 1;\n            for(int i=1; i<n; i++)  pw[i] = (pw[i-1]*2) %mod;\n            System.out.println((XOR*pw[n-1])%mod);\n            t--;\n        }\n    }\n}","bitmasks,combinatorics,constructive algorithms,dp,math"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        GMaxSumArray solver = new GMaxSumArray();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class GMaxSumArray {\n        static final int MAXC = 1000010;\n        static final int OFFSET_ODD = MAXC - 11;\n        static final int OFFSET_EVEN = MAXC - 10;\n        MOD mod = new MOD();\n        static final long modulo = 1000000007;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int m = in.nextInt();\n            int[] c = in.readIntArray(m);\n\n            int[] odds = new int[MAXC];\n            int[] evens = new int[MAXC];\n            int[] factorial = new int[MAXC];\n            factorial[0] = 1;\n            for (int i = 1; i < MAXC; i++) {\n                factorial[i] = mod.multiply(factorial[i - 1], i);\n            }\n            for (int i = 0; i < m; i++) {\n                int C = c[i];\n                if (C % 2 == 0) {\n                    odds[(-(C - 1) + OFFSET_ODD) / 2]++;\n                    odds[(C - 1 + OFFSET_ODD + 2) / 2]--;\n                } else {\n                    evens[(-(C - 1) + OFFSET_EVEN) / 2]++;\n                    evens[(C - 1 + OFFSET_EVEN + 2) / 2]--;\n                }\n            }\n\n\n            for (int i = 1; i < MAXC; i++) {\n                odds[i] += odds[i - 1];\n                evens[i] += evens[i - 1];\n            }\n\n            int i = 0, j = 0;\n            long k = 0;\n            long sum = 0;\n            int ways = 1;\n            while (i < MAXC || j < MAXC) {\n                if (j == MAXC || (i < MAXC && 2 * i - OFFSET_ODD < 2 * j - OFFSET_EVEN)) {\n                    int C = odds[i++];\n                    ways = mod.multiply(ways, factorial[C]);\n                    sum += (((k + C) * (k + C - 1) - k * (k - 1)) / 2) % modulo * (2 * i - OFFSET_ODD - 2);\n                    sum %= modulo;\n                    k += C;\n                } else {\n                    int C = evens[j++];\n                    ways = mod.multiply(ways, factorial[C]);\n                    sum += (((k + C) * (k + C - 1) - k * (k - 1)) / 2) % modulo * (2 * j - OFFSET_EVEN - 2);\n                    sum %= modulo;\n                    k += C;\n                }\n            }\n            out.println(sum + "" "" + ways);\n        }\n\n    }\n\n    static class MOD {\n        static final int modulo = 1000000007;\n\n        public int multiply(int x, int y) {\n            return (int) ((x * 1L * y) % modulo);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readInt();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void println(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n            writer.print('\n');\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n\n","combinatorics,constructive algorithms,greedy,sortings"
"//package ecr117;\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Queue;\n\npublic class G {\n	InputStream is;\n	FastWriter out;\n	String INPUT = """";\n	\n	void solve()\n	{\n		int m = ni();\n		int[] c = na(m);\n		final int mod = 1000000007;\n		int[] f = new int[1000001];\n		long s = 0;\n		for(int v : c){\n			f[v]++;\n			s += v;\n		}\n		long ans = 0;\n		long num = 1;\n		long p = 0;\n		int[][] fif = enumFIF(600000, mod);\n		for(int i = 1000000;i >= 1;i--){\n			// ((s-p-1)+(s-p-2)+...+(s-p-f))*(i-1)\n			// (-p-(p+1)-..-(p+f-1))*-(i-1)\n			if(i == 1){\n				num = num * fif[0][f[i]] % mod;\n			}else {\n				num = num * fif[0][f[i]] % mod * fif[0][f[i]] % mod;\n				ans += (s1(s-p-1, mod) - s1(s-p-f[i]-1, mod)) * (i-1);\n				ans += -(s1(p+f[i]-1, mod) - s1(p-1, mod)) * (i-1);\n				ans %= mod;\n				p += f[i];\n			}\n\n			if(i >= 2)f[i-2] += f[i];\n		}\n		if(ans < 0)ans += mod;\n		out.println(ans + "" "" + num);\n	}\n\n	public static long s1(long n, int mod)\n	{\n		if(n % 2 == 0){\n			return (n/2%mod)*((n+1)%mod)%mod;\n		}else{\n			return (n%mod)*((n+1)/2%mod)%mod;\n		}\n	}\n\n\n	public static int[][] enumFIF(int n, int mod) {\n		int[] f = new int[n + 1];\n		int[] invf = new int[n + 1];\n		f[0] = 1;\n		for (int i = 1; i <= n; i++) {\n			f[i] = (int) ((long) f[i - 1] * i % mod);\n		}\n		long a = f[n];\n		long b = mod;\n		long p = 1, q = 0;\n		while (b > 0) {\n			long c = a / b;\n			long d;\n			d = a;\n			a = b;\n			b = d % b;\n			d = p;\n			p = q;\n			q = d - c * q;\n		}\n		invf[n] = (int) (p < 0 ? p + mod : p);\n		for (int i = n - 1; i >= 0; i--) {\n			invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n		}\n		return new int[][]{f, invf};\n	}\n\n\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new FastWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new G().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n\n	private long[] nal(int n)\n	{\n		long[] a = new long[n];\n		for(int i = 0;i < n;i++)a[i] = nl();\n		return a;\n	}\n\n	private char[][] nm(int n, int m) {\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n\n	private int[][] nmi(int n, int m) {\n		int[][] map = new int[n][];\n		for(int i = 0;i < n;i++)map[i] = na(m);\n		return map;\n	}\n\n	private int ni() { return (int)nl(); }\n\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n\n	public static class FastWriter\n	{\n		private static final int BUF_SIZE = 1<<13;\n		private final byte[] buf = new byte[BUF_SIZE];\n		private final OutputStream out;\n		private int ptr = 0;\n\n		private FastWriter(){out = null;}\n\n		public FastWriter(OutputStream os)\n		{\n			this.out = os;\n		}\n\n		public FastWriter(String path)\n		{\n			try {\n				this.out = new FileOutputStream(path);\n			} catch (FileNotFoundException e) {\n				throw new RuntimeException(""FastWriter"");\n			}\n		}\n\n		public FastWriter write(byte b)\n		{\n			buf[ptr++] = b;\n			if(ptr == BUF_SIZE)innerflush();\n			return this;\n		}\n\n		public FastWriter write(char c)\n		{\n			return write((byte)c);\n		}\n\n		public FastWriter write(char[] s)\n		{\n			for(char c : s){\n				buf[ptr++] = (byte)c;\n				if(ptr == BUF_SIZE)innerflush();\n			}\n			return this;\n		}\n\n		public FastWriter write(String s)\n		{\n			s.chars().forEach(c -> {\n				buf[ptr++] = (byte)c;\n				if(ptr == BUF_SIZE)innerflush();\n			});\n			return this;\n		}\n\n		private static int countDigits(int l) {\n			if (l >= 1000000000) return 10;\n			if (l >= 100000000) return 9;\n			if (l >= 10000000) return 8;\n			if (l >= 1000000) return 7;\n			if (l >= 100000) return 6;\n			if (l >= 10000) return 5;\n			if (l >= 1000) return 4;\n			if (l >= 100) return 3;\n			if (l >= 10) return 2;\n			return 1;\n		}\n\n		public FastWriter write(int x)\n		{\n			if(x == Integer.MIN_VALUE){\n				return write((long)x);\n			}\n			if(ptr + 12 >= BUF_SIZE)innerflush();\n			if(x < 0){\n				write((byte)'-');\n				x = -x;\n			}\n			int d = countDigits(x);\n			for(int i = ptr + d - 1;i >= ptr;i--){\n				buf[i] = (byte)('0'+x%10);\n				x /= 10;\n			}\n			ptr += d;\n			return this;\n		}\n\n		private static int countDigits(long l) {\n			if (l >= 1000000000000000000L) return 19;\n			if (l >= 100000000000000000L) return 18;\n			if (l >= 10000000000000000L) return 17;\n			if (l >= 1000000000000000L) return 16;\n			if (l >= 100000000000000L) return 15;\n			if (l >= 10000000000000L) return 14;\n			if (l >= 1000000000000L) return 13;\n			if (l >= 100000000000L) return 12;\n			if (l >= 10000000000L) return 11;\n			if (l >= 1000000000L) return 10;\n			if (l >= 100000000L) return 9;\n			if (l >= 10000000L) return 8;\n			if (l >= 1000000L) return 7;\n			if (l >= 100000L) return 6;\n			if (l >= 10000L) return 5;\n			if (l >= 1000L) return 4;\n			if (l >= 100L) return 3;\n			if (l >= 10L) return 2;\n			return 1;\n		}\n\n		public FastWriter write(long x)\n		{\n			if(x == Long.MIN_VALUE){\n				return write("""" + x);\n			}\n			if(ptr + 21 >= BUF_SIZE)innerflush();\n			if(x < 0){\n				write((byte)'-');\n				x = -x;\n			}\n			int d = countDigits(x);\n			for(int i = ptr + d - 1;i >= ptr;i--){\n				buf[i] = (byte)('0'+x%10);\n				x /= 10;\n			}\n			ptr += d;\n			return this;\n		}\n\n		public FastWriter write(double x, int precision)\n		{\n			if(x < 0){\n				write('-');\n				x = -x;\n			}\n			x += Math.pow(10, -precision)/2;\n			//		if(x < 0){ x = 0; }\n			write((long)x).write(""."");\n			x -= (long)x;\n			for(int i = 0;i < precision;i++){\n				x *= 10;\n				write((char)('0'+(int)x));\n				x -= (int)x;\n			}\n			return this;\n		}\n\n		public FastWriter writeln(char c){\n			return write(c).writeln();\n		}\n\n		public FastWriter writeln(int x){\n			return write(x).writeln();\n		}\n\n		public FastWriter writeln(long x){\n			return write(x).writeln();\n		}\n\n		public FastWriter writeln(double x, int precision){\n			return write(x, precision).writeln();\n		}\n\n		public FastWriter write(int... xs)\n		{\n			boolean first = true;\n			for(int x : xs) {\n				if (!first) write(' ');\n				first = false;\n				write(x);\n			}\n			return this;\n		}\n\n		public FastWriter write(long... xs)\n		{\n			boolean first = true;\n			for(long x : xs) {\n				if (!first) write(' ');\n				first = false;\n				write(x);\n			}\n			return this;\n		}\n\n		public FastWriter writeln()\n		{\n			return write((byte)'\n');\n		}\n\n		public FastWriter writeln(int... xs)\n		{\n			return write(xs).writeln();\n		}\n\n		public FastWriter writeln(long... xs)\n		{\n			return write(xs).writeln();\n		}\n\n		public FastWriter writeln(char[] line)\n		{\n			return write(line).writeln();\n		}\n\n		public FastWriter writeln(char[]... map)\n		{\n			for(char[] line : map)write(line).writeln();\n			return this;\n		}\n\n		public FastWriter writeln(String s)\n		{\n			return write(s).writeln();\n		}\n\n		private void innerflush()\n		{\n			try {\n				out.write(buf, 0, ptr);\n				ptr = 0;\n			} catch (IOException e) {\n				throw new RuntimeException(""innerflush"");\n			}\n		}\n\n		public void flush()\n		{\n			innerflush();\n			try {\n				out.flush();\n			} catch (IOException e) {\n				throw new RuntimeException(""flush"");\n			}\n		}\n\n		public FastWriter print(byte b) { return write(b); }\n		public FastWriter print(char c) { return write(c); }\n		public FastWriter print(char[] s) { return write(s); }\n		public FastWriter print(String s) { return write(s); }\n		public FastWriter print(int x) { return write(x); }\n		public FastWriter print(long x) { return write(x); }\n		public FastWriter print(double x, int precision) { return write(x, precision); }\n		public FastWriter println(char c){ return writeln(c); }\n		public FastWriter println(int x){ return writeln(x); }\n		public FastWriter println(long x){ return writeln(x); }\n		public FastWriter println(double x, int precision){ return writeln(x, precision); }\n		public FastWriter print(int... xs) { return write(xs); }\n		public FastWriter print(long... xs) { return write(xs); }\n		public FastWriter println(int... xs) { return writeln(xs); }\n		public FastWriter println(long... xs) { return writeln(xs); }\n		public FastWriter println(char[] line) { return writeln(line); }\n		public FastWriter println(char[]... map) { return writeln(map); }\n		public FastWriter println(String s) { return writeln(s); }\n		public FastWriter println() { return writeln(); }\n	}\n\n	public void trnz(int... o)\n	{\n		for(int i = 0;i < o.length;i++)if(o[i] != 0)System.out.print(i+"":""+o[i]+"" "");\n		System.out.println();\n	}\n\n	// print ids which are 1\n	public void trt(long... o)\n	{\n		Queue<Integer> stands = new ArrayDeque<>();\n		for(int i = 0;i < o.length;i++){\n			for(long x = o[i];x != 0;x &= x-1)stands.add(i<<6|Long.numberOfTrailingZeros(x));\n		}\n		System.out.println(stands);\n	}\n\n	public void tf(boolean... r)\n	{\n		for(boolean x : r)System.out.print(x?'#':'.');\n		System.out.println();\n	}\n\n	public void tf(boolean[]... b)\n	{\n		for(boolean[] r : b) {\n			for(boolean x : r)System.out.print(x?'#':'.');\n			System.out.println();\n		}\n		System.out.println();\n	}\n\n	public void tf(long[]... b)\n	{\n		if(INPUT.length() != 0) {\n			for (long[] r : b) {\n				for (long x : r) {\n					for (int i = 0; i < 64; i++) {\n						System.out.print(x << ~i < 0 ? '#' : '.');\n					}\n				}\n				System.out.println();\n			}\n			System.out.println();\n		}\n	}\n\n	public void tf(long... b)\n	{\n		if(INPUT.length() != 0) {\n			for (long x : b) {\n				for (int i = 0; i < 64; i++) {\n					System.out.print(x << ~i < 0 ? '#' : '.');\n				}\n			}\n			System.out.println();\n		}\n	}\n\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","combinatorics,constructive algorithms,greedy,sortings"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1611E2 extends PrintWriter {\n	CF1611E2() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1611E2 o = new CF1611E2(); o.main(); o.flush();\n	}\n\n	static final int INF = 0x3f3f3f3f;\n	boolean[] used, used2;\n	int[] eo; int[][] ej;\n	void append(int i, int j) {\n		int o = eo[i]++;\n		if (o >= 2 && (o & o - 1) == 0)\n			ej[i] = Arrays.copyOf(ej[i], o << 1);\n		ej[i][o] = j;\n	}\n	int dfs1(int p, int i, int di) {\n		int d_ = used[i] ? (di + 1) / 2 : INF;\n		for (int o = eo[i]; o-- > 0; ) {\n			int j = ej[i][o];\n			if (j != p) {\n				int d = dfs1(i, j, di + 1);\n				d_ = Math.min(d_, d);\n			}\n		}\n		if (d_ == di)\n			used2[i] = true;\n		return d_;\n	}\n	int dfs2(int p, int i) {\n		if (used2[i])\n			return 1;\n		int sum = 0;\n		for (int o = eo[i]; o-- > 0; ) {\n			int j = ej[i][o];\n			if (j != p) {\n				int k = dfs2(i, j);\n				if (k == 0)\n					return 0;\n				sum += k;\n			}\n		}\n		return sum;\n	}\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int k = sc.nextInt();\n			used = new boolean[n];\n			used2 = new boolean[n];\n			for (int h = 0; h < k; h++) {\n				int i = sc.nextInt() - 1;\n				used[i] = true;\n			}\n			eo = new int[n]; ej = new int[n][2];\n			for (int h = 0; h < n - 1; h++) {\n				int i = sc.nextInt() - 1;\n				int j = sc.nextInt() - 1;\n				append(i, j);\n				append(j, i);\n			}\n			dfs1(-1, 0, 0);\n			int ans = dfs2(-1, 0);\n			if (ans == 0)\n				ans = -1;\n			println(ans);\n		}\n	}\n}\n","dfs and similar,dp,greedy,shortest paths,trees"
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class Main\n{\n    static ArrayList<Integer> adj[];\n    static int min[];\n    static boolean ans;\n    static int fans;\n    static int dfs1(int s,boolean v[],Set<Integer> set){\n        v[s]=true;\n        int ret=10000000;\n        for(int i:adj[s]){\n            if(!v[i]){\n                ret=Math.min(dfs1(i,v,set),ret);\n            }\n        }\n        if(set.contains(s))ret=0;\n        min[s]=ret;\n       // System.out.println(s+"" ""+min[s]);\n        return min[s]+1;\n    }\n    static void dfs2(int s,boolean v[],int p){\n        v[s]=true;\n        if(adj[s].size()==1&&min[s]>p&&s!=0)ans=true;\n        else if(min[s]<=p&&s!=0)fans++;\n         for(int i:adj[s]){\n             if(v[i])continue;\n            if(min[i]>(p+1)){\n                dfs2(i,v,p+1);\n            }\n            else{\n                fans++;\n            }\n        }\n    }\n	public static void main (String[] args) throws java.lang.Exception\n	{\n	    Scanner sc=new Scanner(System.in);\n	    int t=1;\n	    t=sc.nextInt();\n	    while(--t>=0){\n	        int n=sc.nextInt();\n	        int k=sc.nextInt();\n	        adj=new ArrayList[n];\n	        min=new int[n];\n	        for(int i=0;i<n;i++)adj[i]=new ArrayList<>();\n	        Arrays.fill(min,10000000);\n	        ans=false;\n	        fans=0;\n	        Set<Integer> set=new HashSet<>();\n	        for(int i=0;i<k;i++)set.add(sc.nextInt()-1);\n	       // System.out.println(set);\n	        for(int i=0;i<n-1;i++){\n	            int u=sc.nextInt()-1;\n	            int v=sc.nextInt()-1;\n	            adj[u].add(v);\n	            adj[v].add(u);\n	        }\n	        boolean v[]=new boolean[n];\n	        \n	        dfs1(0,v,set);\n	        v=new boolean[n];\n	        dfs2(0,v,0);\n	        if(!ans){\n	           System.out.println(fans);\n	        }\n	        else System.out.println(-1);\n	    }\n	    \n	}\n}","dfs and similar,dp,greedy,shortest paths,trees"
"import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class E2 {\n    public static void main(String args[]) {\n        Scanner in = new Scanner(System.in);\n        int t = in.nextInt();\n        for (int i = 0; i < t; i++) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            int[] x = new int[k];\n            int[] u = new int[n];\n            int[] v = new int[n];\n\n            for (int j = 0; j < k; j++) {\n                x[j] = in.nextInt() - 1;\n            }\n\n            for (int j = 0; j < n - 1; j++) {\n                u[j] = in.nextInt() - 1;\n                v[j] = in.nextInt() - 1;\n            }\n            System.out.println(solve(n, k, x, u, v));\n        }\n    }\n\n    private static int solve(int n, int k, int[] x, int[] u, int[] v) {\n        Graph g = new Graph(n, u, v);\n        int nearest[] = new int[n];\n        Arrays.fill(nearest, n);\n        for (int i = 0; i < k; i++) {\n            nearest[x[i]] = 0;\n        }\n\n        return g.count(0, 0, -1, nearest);\n    }\n}\n\nclass Graph {\n    private ArrayList<ArrayList<Integer>> adj = new ArrayList<>();\n\n    Graph(int n, int[] u, int[] v) {\n        for (int i = 0; i < n; i++) {\n            adj.add(new ArrayList<Integer>());\n        }\n        for (int i = 0; i < n - 1; i++) {\n            adj.get(u[i]).add(v[i]);\n            adj.get(v[i]).add(u[i]);\n        }\n    }\n\n    public int count(int currVertex, int dist, int parent, int nearest[]) {\n        boolean children = true;\n        int cc = 0;\n        for (int nextVertex : adj.get(currVertex)) {\n            if (parent == nextVertex)\n                continue;\n            int c = count(nextVertex, dist + 1, currVertex, nearest);\n            if (c < 0)\n                children = false;\n            nearest[currVertex] = Math.min(nearest[currVertex], nearest[nextVertex] + 1);\n            cc += c;\n        }\n        if (nearest[currVertex] <= dist)\n            return 1;\n        if (cc == 0 || !children)\n            return -1;\n        return cc;\n    }\n}\n","dfs and similar,dp,greedy,shortest paths,trees"
"import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class E{\n	\n	static int[] dist;\n	static int n, k;\n	static List<Integer>[] adj;\n	static boolean works = false;\n	static int dfs(int i, int p, int t) {\n		int ans = 0;\n		int shit = 0;\n		for (int x: adj[i]) {\n			if (x==p) continue;\n			shit++;\n		}\n		if (shit == 0 && dist[i] > t) works = true; \n		if (dist[i] <= t) return 1;\n\n		for (int x: adj[i]) {\n			if (x==p) continue;\n			ans+=dfs(x,i,t+1);\n		}\n		\n		return ans;\n	}\n	\n	public static void main(String[] args) throws IOException{\n		// br = new BufferedReader(new FileReader("".in""));\n		// out = new PrintWriter(new FileWriter("".out""));\n		// new Thread(null, new (), ""fisa balls"", 1<<28).start();\n		\n		int t= readInt();\n		outer: while(t-->0) {\n			br.readLine();\n			n =readInt();\n			k=readInt();\n			works = false;\n			adj = new List[n];\n			for (int i = 0 ;i  <n; i++) adj[i] = new ArrayList<Integer>();\n			dist = new int[n];\n			Arrays.fill(dist, n+30);\n			for (int i = 0; i < k; i++) {\n				dist[readInt()-1]=0;\n			}\n			for (int i = 0; i < n-1; i++) {\n				int u =readInt()-1,v=readInt()-1;\n				adj[u].add(v);\n				adj[v].add(u);\n			}\n			ArrayDeque<Integer> q = new ArrayDeque<Integer>();\n			for (int i = 0; i< n; i++) if (dist[i]==0) q.add(i);\n			while(!q.isEmpty()) {\n				int i = q.poll();\n				for (int x: adj[i]) {\n					if (dist[i] + 1 < dist[x]) {\n						dist[x] = dist[i]+1;\n						q.add(x);\n					}\n				}\n			}\n			int ans = dfs(0,0,0);\n			out.println(works?-1:ans);\n		}\n		\n		out.close();\n	}\n	\n	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n	static StringTokenizer st = new StringTokenizer("""");\n	static String read() throws IOException{\n		while (!st.hasMoreElements()) st = new StringTokenizer(br.readLine());\n		return st.nextToken();\n	}\n	public static int readInt() throws IOException{return Integer.parseInt(read());}\n	public static long readLong() throws IOException{return Long.parseLong(read());}\n}","dfs and similar,dp,greedy,shortest paths,trees"
"import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int k = input.nextInt();\n        Set<Integer> set = new HashSet<>();\n        while(k-- != 0){\n            int n = input.nextInt();\n            int[][] map_a = new int[n][2];      // value -> index\n            int[][] map_b = new int[n][2];\n            for (int i = 0; i < n; i++) {\n                map_a[i][0] = input.nextInt();\n                map_a[i][1] = i;\n            }\n            for (int i = 0; i < n; i++) {\n                map_b[i][0] = input.nextInt();\n                map_b[i][1] = i;\n            }\n            boolean[] ans = new boolean[n];\n            Arrays.sort(map_a,(o1,o2) -> o1[0] - o2[0]);\n            Arrays.sort(map_b,(o1,o2) -> o1[0] - o2[0]);\n            for (int i = n-1; i >= 0; i--) {\n                set.add(map_a[i][1]);\n                set.add(map_b[i][1]);\n                if(set.size() == n - i) break;\n            }\n            for (Integer integer : set) {\n                ans[integer] = true;\n            }\n            set.clear();\n            for (int i = 0; i < n; i++) {\n                if(ans[i]) System.out.print('1');\n                else System.out.print('0');\n            }\n            System.out.println();\n        }\n    }\n}","data structures,dfs and similar,dp,graphs,greedy,two pointers"
"import java.text.DecimalFormat;\nimport java.util.Scanner;\nimport java.util.*;\npublic class Test1 {\n\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n//            测试次数\n        int testnum = in.nextInt();\n        for (int k = 0; k <testnum; k++) {\n            int n = in.nextInt();\n            int[][] a = new int[n][2];\n            int[][] b = new int[n][2];\n            int[][] rank = new int[n][2];\n            for (int i = 0; i <n ; i++) {\n                a[i][0] = in.nextInt();\n                a[i][1] = i;\n            }\n            for (int i = 0; i < n; i++) {\n                b[i][0] = in.nextInt();\n                b[i][1] = i;\n            }\n            Arrays.sort(a,(x,y)->y[0]-x[0]);\n            Arrays.sort(b,(x,y)->y[0]-x[0]);\n            for (int i = 0; i < n; i++) {\n                rank[a[i][1]][0] = i;\n                rank[b[i][1]][1] = i;\n            }\n            int[] dp = new int[n];\n            dp[0] = 1;\n            int[] right = new int[n];\n            int min = rank[a[n - 1][1]][1];\n            for (int i = n-1; i >=0; i--) {\n                right[i] = Math.min(min, rank[a[i][1]][1]);\n                min = right[i];\n            }\n            int max = rank[a[0][1]][1];\n            int[] left = new int[n];\n            for (int i = 1; i < n; i++) {\n                left[i] = Math.max(max, rank[a[i-1][1]][1]);\n                max = left[i];\n                if(right[i]<left[i]){\n                    dp[i] = 1;\n                }else{\n                    break;\n                }\n            }\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < n; i++) {\n                sb.append(dp[rank[i][0]]);\n            }\n            System.out.println(sb);\n\n        }\n    }\n}\n","data structures,dfs and similar,dp,graphs,greedy,two pointers"
"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int T = in.nextInt();\n        StringBuilder sb = new StringBuilder();\n        for(int t = 0; t < T; ++t) {\n            int n = in.nextInt();\n            int[] ans = new int[n];\n            Arrays.fill(ans, 0);\n            int[][] a = new int[n][2];\n            int[][] b = new int[n][2];\n            for(int i = 0; i < n; ++i) a[i] = new int[] {in.nextInt(), i};\n            for(int i = 0; i < n; ++i) b[i] = new int[] {in.nextInt(), i};\n            Arrays.sort(a, (int[] x, int[] y) -> {\n                if(x[0] > y[0]) return -1;\n                else return 1;\n            });\n            Arrays.sort(b, (int[] x, int[] y) -> {\n                if(x[0] > y[0]) return -1;\n                else return 1;\n            });\n            Set<Integer> s = new HashSet<>();\n            int[] freq = new int[n];\n            for(int i = 0; i < n; ++i) {\n                int ind1 = a[i][1];\n                freq[ind1] += 1;\n                s.add(ind1);\n                int ind2 = b[i][1];\n                freq[ind2] -= 1;\n                s.add(ind2);\n                if(freq[ind1] == 0) s.remove(ind1);\n                if(freq[ind2] == 0) s.remove(ind2);\n                if(s.isEmpty()) {\n                    for(int j = 0; j <= i; ++j) {\n                        ans[a[j][1]] = 1;\n                    }\n                    break;\n                }\n            }\n            for(int i = 0; i < n; ++i) {\n                sb.append(ans[i]);\n            }\n            sb.append(""\n"");\n        }\n        System.out.print(sb.toString());\n    }\n    private static void populate(int[] arr, StringBuilder sb) {\n        for(int ele : arr) {\n            sb.append(ele + "" "");\n        }\n        sb.append(""\n"");\n    }\n}\n","data structures,dfs and similar,dp,graphs,greedy,two pointers"
"import java.util.*;\nimport java.io.*;\n \npublic class C {\n	\n		static FastScanner fs = new FastScanner();\n		static PrintWriter pw = new PrintWriter(System.out);\n		static StringBuilder sb = new StringBuilder("""");\n\n		public static void main(String[] args) {\n			int t = fs.nextInt();\n			for (int tt = 0; tt < t; tt++) {\n				int n = fs.nextInt();\n				P[] a = new P[n+1];\n				P[] b = new P[n+1];\n				for (int i = 0; i < n+1; i++) {\n					a[i] = new P(0, 0);\n					b[i] = new P(0, 0);\n				}\n				int[] c = new int[n+1];\n				int[] d = new int[n+1];\n				for (int i = 1; i <= n; i++) {\n					a[i].fi = fs.nextInt();\n					a[i].se = i;\n				}\n				for (int i = 1; i <= n; i++) {\n					b[i].fi = fs.nextInt();\n					b[i].se = i;\n				}\n				Arrays.sort(a);\n				Arrays.sort(b);\n				for (int i = 1; i <= n; i++) c[b[i].se] = i;\n				int min = n + 1;\n				for (int i = n; i >= 1; i--) {\n					min = Math.min(min, c[a[i].se]);\n					d[a[i].se] = 1;\n					if (min == i) {\n						for (int j = 1; j <= n; j++) sb.append(d[j]);\n						sb.append(""\n"");\n						break;\n					}\n				}\n			}\n			pw.print(sb.toString());\n			pw.close();\n		}\n		\n	static class P implements Comparable<P> {\n		int fi, se;\n		public P(int fi, int se) {\n			this.fi = fi;\n			this.se = se;\n		}\n		\n		public int compareTo(P o) {\n			return Integer.compare(fi, o.fi);\n		}\n	}\n \n	static class FastScanner {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer("""");\n		String next() {while (!st.hasMoreTokens())try {st = new StringTokenizer(br.readLine());} catch (IOException e) {}return st.nextToken();}\n		int nextInt() {return Integer.parseInt(next());}\n		long nextLong() {return Long.parseLong(next());}\n		double nextDouble() {return Double.parseDouble(next());}\n		int[] readArray(int n) { int[] a = new int[n]; for (int i = 0; i < n; i++) {a[i] = nextInt();} return a;}\n	}\n}","data structures,dfs and similar,dp,graphs,greedy,two pointers"
import java.util.Scanner;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int t = in.nextInt();\n		for(int j=0;j<t;j++) {\n			long x = in.nextLong();\n			long n = in.nextLong();\n			for(long i=(n-(n%4)+1);i<=n;i++) {\n				if(x%2==0) {\n					x-=i;\n				}\n				else x+=i;\n			}\n			System.out.println(x);\n		}\n	}\n \n},math
import java.util.Scanner;\n \npublic class Main {\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int t = in.nextInt();\n		for(int j=0;j<t;j++) {\n			long x = in.nextLong();\n			long n = in.nextLong();\n			for(long i=(n-(n%4)+1);i<=n;i++) {\n				if(x%2==0) {\n					x-=i;\n				}\n				else x+=i;\n			}\n			System.out.println(x);\n		}\n	}\n \n},math
import java.util.Scanner;\npublic class Main {\n \n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int t = in.nextInt();\n		for(int j=0;j<t;j++) {\n			long x = in.nextLong();\n			long n = in.nextLong();\n			for(long i=(n-(n%4)+1);i<=n;i++) {\n				if(x%2==0) {\n					x-=i;\n				}\n				else x+=i;\n			}\n			System.out.println(x);\n		}\n	}\n \n},math
import java.util.Scanner;\n \npublic class Main {\n \n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int t = in.nextInt();\n		for(int j=0;j<t;j++) {\n			long x = in.nextLong();\n			long n = in.nextLong();\n			for(long i=(n-(n%4)+1);i<=n;i++) {\n				if(x%2==0) {\n					x-=i;\n				}\n				else x+=i;\n			}\n			System.out.println(x);\n		}\n	}\n \n},math
"// practice with kaiboy, coached by rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1602D extends PrintWriter {\n	CF1602D() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1602D o = new CF1602D(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int[] aa = new int[n + 1];\n		for (int i = 1; i <= n; i++)\n			aa[i] = sc.nextInt();\n		int[] bb = new int[n + 1];\n		for (int i = 1; i <= n; i++)\n			bb[i] = sc.nextInt();\n		int[] ii = new int[n + 1];\n		int[] jj = new int[n + 1];\n		int[] qu = new int[n]; int head = 0, cnt = 0;\n		ii[n] = n; qu[head + cnt++] = n;\n		int m = n;\n		while (cnt-- > 0) {\n			int i = qu[head++];\n			int m_ = i - aa[i];\n			if (m_ >= m)\n				continue;\n			if (m_ == 0) {\n				cnt = 0;\n				qu[cnt++] = 0;\n				while (i < n) {\n					qu[cnt++] = jj[i];\n					i = ii[i];\n				}\n				println(cnt);\n				while (cnt-- > 0)\n					print(qu[cnt] + "" "");\n				println();\n				return;\n			}\n			for (int j = m_; j < m; j++) {\n				int k = j + bb[j];\n				if (ii[k] == 0) {\n					ii[k] = i;\n					jj[k] = j;\n					qu[head + cnt++] = k;\n				}\n			}\n			m = m_;\n		}\n		println(-1);\n	}\n}\n","data structures,dfs and similar,dp,graphs,shortest paths,two pointers"
"import java.io.*;\nimport java.util.*;\n\npublic class Div21601B {\n\n	static int[] a, b, p, dis, vis;\n	\n	public static void main(String[] args) throws IOException {\n\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		\n		int n = Integer.parseInt(br.readLine());\n		\n		dis = new int[n+1];\n		a = new int[n+1];\n		b = new int[n+1];\n		p = new int[n+1];\n		vis = new int[n+1];\n		\n		StringTokenizer st = new StringTokenizer(br.readLine());\n\n		for(int i = 0; i < n; i++)\n			a[i+1] = Integer.parseInt(st.nextToken());\n		\n		st = new StringTokenizer(br.readLine());\n		\n		for(int i = 0; i < n; i++)\n			b[i+1] = Integer.parseInt(st.nextToken());\n				\n		Queue<Pair> que = new LinkedList<Pair>();\n		boolean found = false;\n		\n		que.add(new Pair(n, 0));\n		vis[n] = 3;\n		\n		while(que.size() > 0) {\n			\n			Pair cp = que.poll();\n			\n			if(cp.n - a[cp.n] <= 0) {\n				\n				p[0] = cp.n - cp.j;\n				found = true;\n				break;\n				\n			}\n			\n			for(int i = a[cp.n]; i >= 0; i--) {\n				\n				int ni = (cp.n - i) + b[cp.n - i];\n				\n				if((vis[ni] & 2) != 2 && (vis[cp.n-i] & 1) != 1) {\n					\n					vis[ni] |= 2;\n					dis[ni] = dis[cp.n]+1;\n					p[ni - b[cp.n - i]] = cp.n - cp.j;\n					que.add(new Pair(ni, b[cp.n - i]));\n					\n				}else if((vis[cp.n-i] & 1) == 1)\n					break;\n				\n				vis[cp.n-i] |= 1;\n				\n			}\n			\n		}		\n		\n		if(!found)\n			pw.println(""-1"");\n		else {\n			\n			ArrayList<Integer> moves = new ArrayList<Integer>();\n			int ind = 0;\n			int cnt = 0;\n			\n			while(ind != n) {\n				\n				moves.add(ind);\n				ind = p[ind];\n				\n			}\n				\n			Collections.reverse(moves);\n			\n			pw.println(moves.size());\n			moves.forEach(i -> pw.print(i+"" ""));			\n			\n		}\n			\n		pw.close();\n		\n	}\n	\n	static class Pair{\n		\n		int n, j;\n		\n		public Pair(int n, int j) {\n			\n			this.n = n;\n			this.j = j;\n			\n		}\n		\n	}\n\n}\n","data structures,dfs and similar,dp,graphs,shortest paths,two pointers"
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n	PrintWriter out = new PrintWriter(System.out);\n	BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer tok = new StringTokenizer("""");\n    String next() throws IOException {\n        if (!tok.hasMoreTokens()) { tok = new StringTokenizer(in.readLine()); }\n        return tok.nextToken();\n    }\n    int ni() throws IOException { return Integer.parseInt(next()); }\n    long nl() throws IOException { return Long.parseLong(next()); }\n    \n    long mod=1000000007;\n    \n    void solve() throws IOException {\n        int n=ni();\n        int[]A=new int[n+1];\n        for (int i=1;i<=n;i++) A[i]=ni();\n        int[]B=new int[n+1];\n        for (int i=1;i<=n;i++) B[i]=ni();\n        int min=n-A[n];\n        int prev=n;\n        if (min<=0) { out.println(1); out.println(0); out.flush(); return; }\n        ArrayList<Integer>C=new ArrayList();\n        boolean f=true;\n        \n        while (true) {\n            int newmin=min;\n            int tar=-1;\n            for (int i=prev-1;i>=min;i--) {\n                int u=i+B[i];\n                if (u-A[u]<newmin) { newmin=u-A[u]; tar=i; }\n            }\n            \n            C.add(tar);\n            if (tar==-1) { f=false; break; }\n            if (newmin==0) { C.add(0); break; }\n            \n            prev=min;\n            min=newmin;\n        }\n        \n        if (f) {\n            out.println(C.size());\n            for (int v:C) out.print(v+"" "");\n            out.println();\n        }\n        else out.println(-1);\n        \n        out.flush();\n    }\n    \n    int gcd(int a,int b) { return(b==0?a:gcd(b,a%b)); }\n    long gcd(long a,long b) { return(b==0?a:gcd(b,a%b)); }\n    long mp(long a,long p) { long r=1; while(p>0) { if ((p&1)==1) r=(r*a)%mod; p>>=1; a=(a*a)%mod; } return r; }\n    \n    public static void main(String[] args) throws IOException {\n        new Main().solve();\n    }\n}","data structures,dfs and similar,dp,graphs,shortest paths,two pointers"
"import java.io.*;\n\nimport java.util.*;\n/*\n\n\n\n\n*/\n\n \n public class D{\n	static FastReader sc=null;\n	\n	public static void main(String[] args) {\n		sc=new FastReader();\n		\n		PrintWriter out=new PrintWriter(System.out);\n		\n		int n=sc.nextInt();\n		int a[]=sc.readArray(n),b[]=sc.readArray(n);\n		\n		int nxt[]=new int[n],to[]=new int[n];\n		for(int i=0;i<n;i++) {\n			nxt[i]=i+b[i];\n			to[nxt[i]]=Math.max(to[nxt[i]], i);\n		}\n		\n		int dist[]=new int[n],from[]=new int[n];\n		Arrays.fill(dist, -1);\n		\n		ArrayDeque<Integer> bfs=new ArrayDeque<>();\n		bfs.add(n-1);\n		dist[n-1]=0;\n		\n		int curr=n-1;\n		\n		int ans=-1,start=-1;\n		while(!bfs.isEmpty()) {\n			int q=bfs.remove();\n			\n			int end=q-a[q];\n			\n			if(end<0) {\n				start=q;\n				ans=dist[q]+1;\n				break;\n			}\n			while(curr>=end) {\n				int r=nxt[curr];\n				if(dist[r]==-1) {\n					dist[r]=dist[q]+1;\n					from[r]=q;\n					bfs.add(r);\n				}\n				curr--;\n			}\n		}\n		\n		ArrayList<Integer> path=new ArrayList<>();\n		\n		if(ans!=-1) {\n			path.add(-1);\n			while(start!=n-1) {\n				path.add(to[start]);\n				start=from[start];\n			}\n		}\n		\n		Collections.reverse(path);\n		out.println(ans);\n		for(int e:path)out.print((e+1)+"" "");\n		out.println();\n		\n		out.close();\n	}\n	\n	static int[] ruffleSort(int a[]) {\n		ArrayList<Integer> al=new ArrayList<>();\n		for(int i:a)al.add(i);\n		Collections.sort(al);\n		for(int i=0;i<a.length;i++)a[i]=al.get(i);\n		return a;\n	}\n	\n	static void print(int a[]) {\n		for(int e:a) {\n			System.out.print(e+"" "");\n		}\n		System.out.println();\n	}\n	\n	static class FastReader{\n		\n		StringTokenizer st=new StringTokenizer("""");\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		\n		String next() {\n			while(!st.hasMoreTokens()) \n				try {\n					st=new StringTokenizer(br.readLine());\n				}\n			   catch(IOException e){\n				   e.printStackTrace();\n			   }\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n		\n		int[] readArray(int n) {\n			int a[]=new int[n];\n			for(int i=0;i<n;i++)a[i]=sc.nextInt();\n			return a;\n		}\n	}\n	\n	\n}\n","data structures,dfs and similar,dp,graphs,shortest paths,two pointers"
"\nimport java.util.*;\npublic class Min {\n\n	public static void main(String[] args) {\n		\n	Scanner sc = new Scanner(System.in);\n int t = sc.nextInt();\n while(t-->0) {\n	 int n =sc.nextInt();\n	 String s1= sc.next();\n	 String s2 =sc.next();\nString res= ""YES"";\nfor(int i =1;i<n-1;i++)\n		 if (s1.charAt(i)=='1' && '1'==s2.charAt(i))\n			 res= ""NO"";\nSystem.out.println(res);\n	 }\n	}\n}\n","brute force,dfs and similar,dp,implementation"
"import java.util.*;\npublic class A{\n  static Scanner sc;\n  public static void solve(){\n    int n=sc.nextInt();\n    String x=sc.next();\n    String y=sc.next();\n    int c=0;\n    for(int i=0;i<n;i++){\n      if(x.charAt(i)=='1' && y.charAt(i)=='1'){System.out.println(""NO""); return;}\n    }\n    System.out.println(""YES"");\n  }\n  public static void main(String args[]){\n      sc=new Scanner(System.in);\n      int t=sc.nextInt();\n      while(t-->0) solve();\n  }\n}\n","brute force,dfs and similar,dp,implementation"
"import java.util.*;\npublic class pariNa {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0) {\n			int n=sc.nextInt();\n			String a=sc.next();\n			String b=sc.next();\n			int count=0;\n			for(int i=0;i<n;i++) {\n				if(a.charAt(i)=='1' && b.charAt(i)=='1') {\n					count++;\n				}\n			}\n			if(count==0) {\n				System.out.println(""YES"");\n			}\n			else {\n				System.out.println(""NO"");\n			}\n		}\n	}\n	\n}\n","brute force,dfs and similar,dp,implementation"
"import java.util.Scanner;\n\npublic class MAIN {\n	static Scanner sc = new Scanner(System.in);\n	\n	public static void main(String[] args) {\n	\n		\n\n		int n = sc.nextInt();\n		for(int i = 0;i<n;i++) solve();\n		\n	}\n	\n	static void solve() {\n		int n = sc.nextInt();\n		String s1 = sc.next();\n		String s2 = sc.next();\n		boolean bad = false;\n		for(int i = 0;i<n;i++) bad = bad || (s1.charAt(i) == '1' && s2.charAt(i) == '1');\n		\n		System.out.println(bad ? ""NO"" : ""YES"");\n	}\n}\n","brute force,dfs and similar,dp,implementation"
"import java.util.*;\npublic class savemoremice{\n	public static void main(String ...asd){\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0){\n		Long n=sc.nextLong();\n		Long c=0l,l=0l;\n		int k=sc.nextInt();\n		Long []a=new Long[k];\n		for(int i=0;i<k;i++)\n			a[i]=sc.nextLong();\n\n		Arrays.sort(a);\n		int i=k-1;\n		while(i>=0 && l<a[i]){\n             l+=n-a[i--];\n             c++;\n		}\n		System.out.println(c);\n	}\n	}\n}","binary search,greedy,greedy"
"import java.util.*;\npublic class savemoremice{\n	public static void main(String ...asd){\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0){\n		Long n=sc.nextLong();\n		Long c=0l,l=0l;\n		int k=sc.nextInt();\n		Long []a=new Long[k];\n		for(int i=0;i<k;i++)\n			a[i]=sc.nextLong();\n \n		Arrays.sort(a);\n		int i=k-1;\n		while(i>=0 && l<a[i]){\n             l+=n-a[i--];\n             c++;\n		}\n		System.out.println(c);\n	}\n	}\n}","binary search,greedy,greedy"
"import java.util.*;\n\npublic class solution {\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		for (int i = 0; i < t; i++) {\n			long n = sc.nextLong();\n			int k = sc.nextInt();\n			long res=0,cat = 0;\n			Integer[] arr = new Integer[k];\n			for (int j = 0; j < k; j++) {\n				arr[j]= sc.nextInt();\n			}\n			Arrays.sort(arr);\n			int point = k-1;\n			while(point>=0 && cat<arr[point] ) {\n				cat += n-arr[point--];\n				res++;\n			}\n			System.out.println(res);\n		}\n	}\n\n}\n","binary search,greedy,greedy"
"import java.util.*;;\npublic class class313 {\n	\npublic static void main(String arg[])\n{\n	Scanner sc=new Scanner(System.in);\n	int t=sc.nextInt();\n	while(t-->0)\n	{\n	int n=sc.nextInt();\n	int k=sc.nextInt();\n	int i;\n	PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\n	for(i=1;i<=k;i++)\n	{\n		int x=sc.nextInt();\n		pq.add(x);\n	}\n	int c=0,ind=0;\n    for(i=k;i>=1;i--)\n	{\n		int val=pq.poll();\n		if(ind>=val)\n		{\n			break;\n		}\n	int mov=n-val;\n	ind+=mov;\n	c++;\n	\n	}\n	System.out.println(c);\n	}\n	sc.close();\n}\n}\n","binary search,greedy,greedy"
"\nimport java.lang.Math;\nimport java.util.*;\nimport java.util.Iterator;\n\npublic class Main {\n    public static void main(String[] args) {\n        //val positions = Array(k) { LongArray(m) { jin.nextInt().toLong() } }\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        String inp[] = new String[n];\n        Boolean arr[][] = new Boolean[n + 1][m + 1];\n        for (int i = 0; i <= n; i++) Arrays.fill(arr[i], false);\n        for (int i = 0; i < n; i++) {\n            inp[i] = sc.next();\n            for (int j = 0; j < m; j++) {\n                arr[i][j] = (inp[i].charAt(j) == 'B');\n            }\n        }\n        Boolean dum[][] = new Boolean[n][m];\n        int cntr = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                dum[i][j] = ((arr[i][j] ^ arr[i + 1][j]) ^ (arr[i][j + 1] ^ arr[i + 1][j + 1]));\n                if(dum[i][j]) {\n                    cntr++;\n                }\n            }\n        }\n        //System.out.println(cntr);\n        Boolean fine = false;\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < m - 1; j++) {\n                if (dum[i][j] && dum[n - 1][j] && dum[i][m - 1] && dum[n - 1][m - 1]) {\n                    fine = true;\n                }\n            }\n        }\n        if (fine) {\n            cntr--;\n        }\n        System.out.println(cntr);\n    }\n}","constructive algorithms,greedy"
"import java.io.*;\nimport java.util.*;\n \npublic class Main {\n	static PrintWriter out;\n	static Reader in;\n	public static void main(String[] args) throws Exception {\n		input_output();\n		Main solver = new Main();\n		solver.solve();\n		out.close();\n \n		out.flush();\n	} \n \n	static int INF = (int)1e9;\n	static int MAXN = (int)2e6 + 5;\n	static int q, t, n, m, k;\n\n	void solve() throws Exception {\n		n = in.nextInt();\n		m = in.nextInt();\n\n		int[][] arr = new int[n+1][m+1];\n		for (int i = 0; i < n; i++) {\n			String s = in.next();\n			for (int j = 0; j < m; j++) {\n				if (s.charAt(j) == 'B') arr[i][j] = 1;\n			}\n		}\n\n		int[][] a = new int[n][m];\n		int cntOne = 0;\n		for (int i = n-1; i >= 0; i--) {\n			for (int j = m-1; j >= 0; j--) {\n				a[i][j] = (arr[i+1][j+1]+arr[i+1][j]+arr[i][j+1]+arr[i][j])%2;\n				cntOne += a[i][j];\n			}\n		}\n\n		boolean findThree = false;\n		for (int i = 1; i < n; i++) {\n			for (int j = 1; j < m; j++) {\n				if (a[i-1][j-1] == 1 && a[i-1][m-1] == 1 && a[n-1][j-1] == 1 && a[n-1][m-1] == 1)\n					findThree = true;\n			}\n		}\n\n		if (findThree) cntOne--;\n		out.println(cntOne);\n	}\n\n	static class Reader {\n		private InputStream mIs;\n		private byte[] buf = new byte[1024];\n		private int curChar;\n		private int numChars;\n \n		public Reader() {\n			this(System.in);\n		}\n \n		public Reader(InputStream is) {\n			mIs = is;\n		}\n \n		public int read() {\n			if (numChars == -1) {\n				throw new InputMismatchException();\n \n			}\n			if (curChar >= numChars) {\n				curChar = 0;\n				try {\n					numChars = mIs.read(buf);\n				} catch (IOException e) {\n					throw new InputMismatchException();\n				}\n				if (numChars <= 0) {\n					return -1;\n				}\n			}\n			return buf[curChar++];\n		}\n \n		public String nextLine() {\n			int c = read();\n			while (isSpaceChar(c)) {\n				c = read();\n			}\n			StringBuilder res = new StringBuilder();\n			do {\n				res.appendCodePoint(c);\n				c = read();\n			} while (!isEndOfLine(c));\n			return res.toString();\n		}\n \n		public String next() {\n			int c = read();\n			while (isSpaceChar(c)) {\n				c = read();\n			}\n			StringBuilder res = new StringBuilder();\n			do {\n				res.appendCodePoint(c);\n				c = read();\n			} while (!isSpaceChar(c));\n			return res.toString();\n		}\n \n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n \n		public long nextLong() {\n			int c = read();\n			while (isSpaceChar(c)) {\n				c = read();\n			}\n			int sgn = 1;\n			if (c == '-') {\n				sgn = -1;\n				c = read();\n			}\n			long res = 0;\n			do {\n				if (c < '0' || c > '9') {\n					throw new InputMismatchException();\n				}\n				res *= 10;\n				res += c - '0';\n				c = read();\n			} while (!isSpaceChar(c));\n			return res * sgn;\n		}\n \n		public int nextInt() {\n			int c = read();\n			while (isSpaceChar(c)) {\n				c = read();\n			}\n			int sgn = 1;\n			if (c == '-') {\n				sgn = -1;\n				c = read();\n			}\n			int res = 0;\n			do {\n				if (c < '0' || c > '9') {\n					throw new InputMismatchException();\n				}\n				res *= 10;\n				res += c - '0';\n				c = read();\n			} while (!isSpaceChar(c));\n			return res * sgn;\n		}\n \n		public boolean isSpaceChar(int c) {\n			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n		}\n \n		public boolean isEndOfLine(int c) {\n			return c == '\n' || c == '\r' || c == -1;\n		}\n \n	}\n	static void input_output() throws IOException {\n		File f = new File(""in.txt"");\n		if (f.exists() && !f.isDirectory()) {\n			in = new Reader(new FileInputStream(""in.txt""));\n		} else in = new Reader();\n		f = new File(""out.txt"");\n		if (f.exists() && !f.isDirectory()) {\n			out = new PrintWriter(new File(""out.txt""));\n		} else out = new PrintWriter(System.out);\n	}\n}\n","constructive algorithms,greedy"
"import java.io.*;\nimport java.util.*;\n \npublic class Solution extends PrintWriter {\n\n    void solve() {\n        int t = sc.nextInt();\n        for(int i = 1; i <= t; i++) {\n            test_case();\n        }\n    }\n    \n    \n    void test_case() {\n        int n = sc.nextInt();\n        long[] a = new long[n];\n        for(int i = 0; i < n; i++) a[i] = sc.nextLong();\n        TreeMap<Long, Integer> cnt = new TreeMap<>();\n        long offset = 0L;\n        long ans = 0L;\n        for(int i = 0; i < n; i++) {\n            cnt.put(-offset, cnt.getOrDefault(-offset, 0) + 1);\n            offset += (i%2==0?1L:-1L) * a[i];\n            if(i%2 == 0) {\n                while(true){\n                    Long first = cnt.firstKey();\n                    if(first+offset < 0) cnt.remove(first);\n                    else break;\n                }\n            } else {\n                while(true){\n                    Long last = cnt.lastKey();\n                    if(last+offset > 0) cnt.remove(last);\n                    else break;\n                }\n            }\n            ans += cnt.getOrDefault(-offset, 0);\n        }\n        println(ans);\n    }\n    \n//  Main() throws FileNotFoundException { super(new File(""output.txt"")); }\n//  InputReader sc = new InputReader(new FileInputStream(""test_input.txt""));\n  Solution() { super(System.out); }\n  InputReader sc = new InputReader(System.in);\n  static class InputReader {\n      InputReader(InputStream in) { this.in = in; } InputStream in;\n      \n      private byte[] buf = new byte[16384];\n      private int    curChar;\n      private int    numChars;\n      \n \n      public int read() {\n          if (numChars == -1)\n              throw new InputMismatchException();\n          if (curChar >= numChars) {\n              curChar = 0;\n              try {\n                  numChars = in.read(buf);\n              } catch (IOException e) {\n                  throw new InputMismatchException();\n              }\n              if (numChars <= 0)\n                  return -1;\n          }\n          return buf[curChar++];\n      }\n /*\n      private String nextLine() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          StringBuilder res = new StringBuilder();\n          do {\n              res.appendCodePoint(c);\n              c = read();\n          } while (!isEndOfLine(c));\n          return res.toString();\n      }*/\n \n      public String nextString() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          StringBuilder res = new StringBuilder();\n          do {\n              res.appendCodePoint(c);\n              c = read();\n          } while (!isSpaceChar(c));\n          return res.toString();\n      }\n \n      public long nextLong() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = read();\n          }\n          long res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = read();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      public int nextInt() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = read();\n          }\n          int res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = read();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      private boolean isSpaceChar(int c) {\n          return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n      }\n \n      private boolean isEndOfLine(int c) {\n          return c == '\n' || c == '\r' || c == -1;\n      }\n  }\n \n    public static void main(String[] $) {\n        new Thread(null, new Runnable() {\n            public void run() {\n                long start = System.nanoTime();\n                try {Solution solution = new Solution(); solution.solve(); solution.flush();} \n                catch (Exception e) {e.printStackTrace(); System.exit(1);}\n                System.err.println((System.nanoTime()-start)/1E9);\n            }\n        }, ""1"", 1 << 27).start();\n \n    }\n}","binary search,data structures,games,greedy"
"import java.io.*;\nimport java.util.*;\n \npublic class Solution extends PrintWriter {\n\n    void solve() {\n        int t = sc.nextInt();\n        for(int i = 1; i <= t; i++) {\n            test_case();\n        }\n    }\n    \n    \n    void test_case() {\n        int n = sc.nextInt();\n        long[] a = new long[n];\n        for(int i = 0; i < n; i++) a[i] = sc.nextLong();\n        TreeMap<Long, Integer> cnt = new TreeMap<>();\n        long offset = 0L;\n        long ans = 0L;\n        for(int i = 0; i < n; i++) {\n            cnt.put(-offset, cnt.getOrDefault(-offset, 0) + 1);\n            if(i%2 == 0) {\n                offset += a[i];\n                while(true){\n                    Long first = cnt.firstKey();\n                    if(first+offset < 0) cnt.remove(first);\n                    else break;\n                }\n            } else {\n                offset -= a[i];\n                while(true){\n                    Long last = cnt.lastKey();\n                    if(last+offset > 0) cnt.remove(last);\n                    else break;\n                }\n            }\n            ans += cnt.getOrDefault(-offset, 0);\n        }\n        println(ans);\n    }\n    \n//  Main() throws FileNotFoundException { super(new File(""output.txt"")); }\n//  InputReader sc = new InputReader(new FileInputStream(""test_input.txt""));\n  Solution() { super(System.out); }\n  InputReader sc = new InputReader(System.in);\n  static class InputReader {\n      InputReader(InputStream in) { this.in = in; } InputStream in;\n      \n      private byte[] buf = new byte[16384];\n      private int    curChar;\n      private int    numChars;\n      \n \n      public int read() {\n          if (numChars == -1)\n              throw new InputMismatchException();\n          if (curChar >= numChars) {\n              curChar = 0;\n              try {\n                  numChars = in.read(buf);\n              } catch (IOException e) {\n                  throw new InputMismatchException();\n              }\n              if (numChars <= 0)\n                  return -1;\n          }\n          return buf[curChar++];\n      }\n /*\n      private String nextLine() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          StringBuilder res = new StringBuilder();\n          do {\n              res.appendCodePoint(c);\n              c = read();\n          } while (!isEndOfLine(c));\n          return res.toString();\n      }*/\n \n      public String nextString() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          StringBuilder res = new StringBuilder();\n          do {\n              res.appendCodePoint(c);\n              c = read();\n          } while (!isSpaceChar(c));\n          return res.toString();\n      }\n \n      public long nextLong() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = read();\n          }\n          long res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = read();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      public int nextInt() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = read();\n          }\n          int res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = read();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      private boolean isSpaceChar(int c) {\n          return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n      }\n \n      private boolean isEndOfLine(int c) {\n          return c == '\n' || c == '\r' || c == -1;\n      }\n  }\n \n    public static void main(String[] $) {\n        new Thread(null, new Runnable() {\n            public void run() {\n                long start = System.nanoTime();\n                try {Solution solution = new Solution(); solution.solve(); solution.flush();} \n                catch (Exception e) {e.printStackTrace(); System.exit(1);}\n                System.err.println((System.nanoTime()-start)/1E9);\n            }\n        }, ""1"", 1 << 27).start();\n \n    }\n}","binary search,data structures,games,greedy"
"import java.io.*;\nimport java.util.*;\n \npublic class Solution extends PrintWriter {\n\n    void solve() {\n        int t = sc.nextInt();\n        for(int i = 1; i <= t; i++) {\n            test_case();\n        }\n    }\n    \n    \n    void test_case() {\n        int n = sc.nextInt();\n        long[] a = new long[n];\n        for(int i = 0; i < n; i++) a[i] = sc.nextLong();\n        TreeMap<Long, Integer> cnt = new TreeMap<>();\n        long offset = 0L;\n        long ans = 0L;\n        for(int i = 0; i < n; i++) {\n            cnt.put(-offset, cnt.getOrDefault(-offset, 0) + 1);\n            offset += (i%2==0?1L:-1L) * a[i];\n            if(i%2 == 0) {\n                while(!cnt.isEmpty()){\n                    Long first = cnt.firstKey();\n                    if(first+offset < 0) cnt.remove(first);\n                    else break;\n                }\n            } else {\n                while(!cnt.isEmpty()){\n                    Long last = cnt.lastKey();\n                    if(last+offset > 0) cnt.remove(last);\n                    else break;\n                }\n            }\n            ans += cnt.getOrDefault(-offset, 0);\n        }\n        println(ans);\n    }\n    \n//  Main() throws FileNotFoundException { super(new File(""output.txt"")); }\n//  InputReader sc = new InputReader(new FileInputStream(""test_input.txt""));\n  Solution() { super(System.out); }\n  InputReader sc = new InputReader(System.in);\n  static class InputReader {\n      InputReader(InputStream in) { this.in = in; } InputStream in;\n      \n      private byte[] buf = new byte[16384];\n      private int    curChar;\n      private int    numChars;\n      \n \n      public int read() {\n          if (numChars == -1)\n              throw new InputMismatchException();\n          if (curChar >= numChars) {\n              curChar = 0;\n              try {\n                  numChars = in.read(buf);\n              } catch (IOException e) {\n                  throw new InputMismatchException();\n              }\n              if (numChars <= 0)\n                  return -1;\n          }\n          return buf[curChar++];\n      }\n /*\n      private String nextLine() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          StringBuilder res = new StringBuilder();\n          do {\n              res.appendCodePoint(c);\n              c = read();\n          } while (!isEndOfLine(c));\n          return res.toString();\n      }*/\n \n      public String nextString() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          StringBuilder res = new StringBuilder();\n          do {\n              res.appendCodePoint(c);\n              c = read();\n          } while (!isSpaceChar(c));\n          return res.toString();\n      }\n \n      public long nextLong() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = read();\n          }\n          long res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = read();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      public int nextInt() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = read();\n          }\n          int res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = read();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      private boolean isSpaceChar(int c) {\n          return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n      }\n \n      private boolean isEndOfLine(int c) {\n          return c == '\n' || c == '\r' || c == -1;\n      }\n  }\n \n    public static void main(String[] $) {\n        new Thread(null, new Runnable() {\n            public void run() {\n                long start = System.nanoTime();\n                try {Solution solution = new Solution(); solution.solve(); solution.flush();} \n                catch (Exception e) {e.printStackTrace(); System.exit(1);}\n                System.err.println((System.nanoTime()-start)/1E9);\n            }\n        }, ""1"", 1 << 27).start();\n \n    }\n}","binary search,data structures,games,greedy"
"import java.io.*;\nimport java.util.*;\n \npublic class Solution extends PrintWriter {\n\n    void solve() {\n        int t = sc.nextInt();\n        for(int i = 1; i <= t; i++) {\n            test_case();\n        }\n    }\n    \n    long test(long[] x) {\n        int n = x.length;\n        long ans = 0L;\n        for(int i = 0; i < n; i++) {\n            for(int j = i; j < n; j++) {\n                long cur = 0L;\n                boolean good = true;\n                for(int k = i; k <= j; k++) {\n                    cur = x[k] - cur;\n                    if(cur < 0) {\n                        good = false;\n                        break;\n                    }\n                }\n                if(good && cur == 0) ans++;\n            }\n        }\n        return ans;\n    }\n    \n    \n    void test_case() {\n        int n = sc.nextInt();\n        long[] a = new long[n];\n        for(int i = 0; i < n; i++) a[i] = (i%2==0?1L:-1L) * sc.nextLong();\n        TreeMap<Long, Integer>[] cnt = new TreeMap[2];\n        for(int i = 0; i < 2; i++) cnt[i] = new TreeMap<>();\n        long[] offset = new long[2];\n        long ans = 0L;\n        for(int i = 0; i < n; i++) {\n            for(int m = 0; m < 2; m++) {\n                if(a[i] == 0) ans++;\n                ans += cnt[m].getOrDefault(-a[i] - offset[m], 0);\n                offset[m] += a[i];\n                long val = a[i] - offset[m];\n                cnt[m].put(val, cnt[m].getOrDefault(val, 0) + 1);\n\n                if(i%2 == 0) {\n                    while(!cnt[m].isEmpty()){\n                        Long first = cnt[m].firstKey();\n                        if(first+offset[m] < 0) cnt[m].remove(first);\n                        else break;\n                    }\n                } else {\n                    while(!cnt[m].isEmpty()){\n                        Long last = cnt[m].lastKey();\n                        if(last+offset[m] > 0) cnt[m].remove(last);\n                        else break;\n                    }\n                }\n            }\n        }\n        println(ans/2L);\n    }\n    \n//  Main() throws FileNotFoundException { super(new File(""output.txt"")); }\n//  InputReader sc = new InputReader(new FileInputStream(""test_input.txt""));\n  Solution() { super(System.out); }\n  InputReader sc = new InputReader(System.in);\n  static class InputReader {\n      InputReader(InputStream in) { this.in = in; } InputStream in;\n      \n      private byte[] buf = new byte[16384];\n      private int    curChar;\n      private int    numChars;\n      \n \n      public int read() {\n          if (numChars == -1)\n              throw new InputMismatchException();\n          if (curChar >= numChars) {\n              curChar = 0;\n              try {\n                  numChars = in.read(buf);\n              } catch (IOException e) {\n                  throw new InputMismatchException();\n              }\n              if (numChars <= 0)\n                  return -1;\n          }\n          return buf[curChar++];\n      }\n /*\n      private String nextLine() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          StringBuilder res = new StringBuilder();\n          do {\n              res.appendCodePoint(c);\n              c = read();\n          } while (!isEndOfLine(c));\n          return res.toString();\n      }*/\n \n      public String nextString() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          StringBuilder res = new StringBuilder();\n          do {\n              res.appendCodePoint(c);\n              c = read();\n          } while (!isSpaceChar(c));\n          return res.toString();\n      }\n \n      public long nextLong() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = read();\n          }\n          long res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = read();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      public int nextInt() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = read();\n          }\n          int res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = read();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      private boolean isSpaceChar(int c) {\n          return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n      }\n \n      private boolean isEndOfLine(int c) {\n          return c == '\n' || c == '\r' || c == -1;\n      }\n  }\n \n    public static void main(String[] $) {\n        new Thread(null, new Runnable() {\n            public void run() {\n                long start = System.nanoTime();\n                try {Solution solution = new Solution(); solution.solve(); solution.flush();} \n                catch (Exception e) {e.printStackTrace(); System.exit(1);}\n                System.err.println((System.nanoTime()-start)/1E9);\n            }\n        }, ""1"", 1 << 27).start();\n \n    }\n}","binary search,data structures,games,greedy"
"import java.util.*;\npublic class TwoArrays {\n	public static void main(String[] args) {\n	Scanner sc=new Scanner(System.in);\n     int t=sc.nextInt();\n     while(t-->0) {\n    	 int n=sc.nextInt();\n    	 int[] a=new int[n];\n    	 int[] b=new int[n];\n    	 for(int i=0;i<n;i++) {\n    		 a[i]=sc.nextInt();\n    	 }\n    	 for(int i=0;i<n;i++) {\n    		 b[i]=sc.nextInt();\n    	 }\n    	 Arrays.sort(a);\n    	 Arrays.sort(b);\n    	 boolean ans=true;\n    	 for(int i=0;i<n;i++) {\n    		if(a[i]!=b[i] && a[i]!=b[i]-1) {\n    			ans=false;\n    		}\n    	 }\n    	 System.out.println(ans?""YES"":""NO"");\n     }\n	}\n}\n","greedy,math,sortings"
"\nimport java.util.*;\n\npublic class ddz {\n	public static void main(String[] args) {\n		System.out.println();\n		Scanner sc = new Scanner(System.in);\n		int x= sc.nextInt();\n		while(x-->0) {\n			int n=sc.nextInt();\n			int[] a=new int[n];\n			int[] b=new int[n];\n			for(int i=0;i<n;i++){\n				a[i]=sc.nextInt();\n			}\n			for(int i=0;i<n;i++){\n				b[i]=sc.nextInt();\n			}\n			Arrays.sort(a);\n			Arrays.sort(b);\n			boolean flag=true;\n			for(int i=0;i<n;i++){\n				if(a[i]+1==b[i] || a[i]==b[i])\n					continue;\n				flag=false;\n			}\n			if(flag)\n				System.out.println(""YES"");\n			else\n				System.out.println(""NO"");\n		}\n		sc.close();\n	}\n	\n}","greedy,math,sortings"
"import java.util.*;\npublic class Main {\n	public static void main(String[] args){\n		Scanner sc = new Scanner(System.in);\n\n		// long mod = 1_000_000_007L;\n		// long mod = 998_244_353L;\n\n		int t = sc.nextInt();\n\n		for ( int zzz=0; zzz<t; zzz++ ) {\n\n			int n = sc.nextInt();\n\n			int[] a = new int[n];\n			int[] b = new int[n];\n\n			for ( int i=0; i<n; i++ ) {\n				a[i] = sc.nextInt();\n			}\n			Arrays.sort(a);\n			for ( int i=0; i<n; i++ ) {\n				b[i] = sc.nextInt();\n			}\n			Arrays.sort(b);\n\n			String ans = ""Yes"";\n			for ( int i=0; i<n; i++ ) {\n				if ( b[i]-a[i]==0 || b[i]-a[i]==1 ) {\n					continue;\n				} else {\n					ans = ""No"";\n					break;\n				}\n			}\n\n			System.out.println(ans);\n		}\n	}\n}\n","greedy,math,sortings"
"import java.util.*;\npublic class Main {\n	public static void main(String[] args){\n		Scanner sc = new Scanner(System.in);\n\n		// long mod = 1_000_000_007L;\n		// long mod = 998_244_353L;\n\n		int t = sc.nextInt();\n\n		for ( int zzz=0; zzz<t; zzz++ ) {\n\n			int n = sc.nextInt();\n\n			int[] a = new int[n];\n			int[] b = new int[n];\n\n			for ( int i=0; i<n; i++ ) {\n				a[i] = sc.nextInt();\n			}\n			Arrays.sort(a);\n			for ( int i=0; i<n; i++ ) {\n				b[i] = sc.nextInt();\n			}\n			Arrays.sort(b);\n\n			String ans = ""Yes"";\n			for ( int i=0; i<n; i++ ) {\n				if ( b[i]-a[i]==0 || b[i]-a[i]==1 ) {\n					continue;\n				} else {\n					ans = ""No"";\n					break;\n				}\n			}\n\n			System.out.println(ans);\n		}\n	}\n}\n","greedy,math,sortings"
"import java.util.*;\npublic class P1579E1 {\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		int t = s.nextInt();\n		while(t-->0) {\n			int n = s.nextInt();\n			LinkedList<Integer> a = new LinkedList<>();			\n			for(int i = 0; i<n; i++) {\n				int x = s.nextInt();\n				if(a.isEmpty()||a.peekFirst()>x) {\n					a.addFirst(x);\n				} else {\n					a.addLast(x);\n				}\n			}\n			for(int i : a)\n				System.out.print(i+"" "");\n			System.out.println();\n		}\n	}\n}\n","constructive algorithms,greedy,math"
"import java.util.*;\n\n\npublic class Solution {\n	\n	public static void main(String args[]) {\n	   Scanner sc=new Scanner(System.in);\n	   int t=sc.nextInt();\n	   while(t-->0) {\n		  int n=sc.nextInt();\n		  Deque<Integer> q=new LinkedList<>();\n		  \n		  for(int i=0;i<n;i++) {\n			  int x=sc.nextInt();\n			  if(q.isEmpty()) q.add(x);\n			  else {\n				  if(q.peekFirst()>=x) q.addFirst(x);\n				  else q.add(x);\n			  }\n			  \n		  }\n		  for(int x:q) System.out.print(x+"" "");\n		  System.out.println();\n		  \n	   }\n\n}\n	}","constructive algorithms,greedy,math"
"import java.util.*;\npublic class Main\n{\n	public static void main(String[] args) {\n		Scanner scn = new Scanner(System.in);\n		int t = scn.nextInt();\n		\n		while(t-->0){\n		    \n		    int n = scn.nextInt();\n		    \n		    LinkedList<Integer> dq = new LinkedList<Integer>();			\n			for(int i = 0; i<n; i++) {\n				int x = scn.nextInt();\n				if(dq.isEmpty()||dq.peekFirst()>x) {\n					dq.addFirst(x);\n				} else {\n					dq.addLast(x);\n				}\n			}\n			for(int i : dq)\n				System.out.print(i+"" "");\n			System.out.println();\n		}\n	}\n}","constructive algorithms,greedy,math"
"import java.util.*;\n\npublic class Main {\n	static Scanner sc = new Scanner(System.in);\n	\n	public static void main(String[] args) {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			solve();\n		}\n	}\n	\n	static void solve() {\n		int n = sc.nextInt();\n		LinkedList<Integer> list = new LinkedList<>();\n		int x;\n		for (int i = 0; i < n; i++) {\n			x = sc.nextInt();\n			if (list.isEmpty() || list.peekFirst() > x) list.addFirst(x);\n			else list.addLast(x);\n		}\n		\n		for (int i : list) System.out.print(i + "" "");\n		System.out.println();\n	}\n	\n}\n","constructive algorithms,greedy,math"
"import java.util.*;\nimport java.io.*;\n\npublic class codeforces {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int mod = (int) (1e9 + 7);\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		String[][] s = new String[n][2];\n		for (int i = 1; i <= n; i++) {\n			s[i - 1] = new String[] { sc.next(), i + """" };\n		}\n		Arrays.sort(s, new Comparator<String[]>() {\n			public int compare(String[] s1, String[] s2) {\n				String tmp1 = s1[0];\n				String tmp2 = s2[0];\n				for (int i = 0; i < m; i++) {\n					if (tmp1.charAt(i) != tmp2.charAt(i)) {\n						if (i % 2 == 0) {\n							return tmp1.compareTo(tmp2);\n						} else {\n							return tmp2.compareTo(tmp1);\n						}\n					}\n				}\n				return 0;\n			}\n		});\n		for (int i = 0; i < n; i++) {\n			System.out.print(s[i][1] + "" "");\n		}\n		sc.close();\n		return;\n	}\n}\n","data structures,sortings,strings"
"/*package whatever //do not write package name here */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class GFG {\n	public static void main (String[] args) {\n	    Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt(), m = sc.nextInt();\n		ArrayList<String> s = new ArrayList<>();\n		HashMap<String,Integer> map = new HashMap<>();\n		for(int i=0;i<n;i++){\n		    String x = sc.next();s.add(x);map.put(x,i+1);}\n		\n		Collections.sort(s,new Comparator<String>(){\n		    @Override\n		    public int compare(String s1, String s2){\n		        char[] c1 = s1.toCharArray();\n		        char[] c2 = s2.toCharArray();\n		        for(int i=0;i<m;i++){\n		            if(c1[i]!=c2[i]){\n		                int x = c1[i]-c2[i];\n		                if((i+1)%2==0)return (-1)*x;\n		                else return x;\n		            }\n		        }return 0;\n		    }\n		});\n		for(int i=0;i<n;i++){System.out.print(map.get(s.get(i))+"" "");}\n	}\n}","data structures,sortings,strings"
"import java.util.*;\npublic class Main\n{\n	public static void main(String[] args) {\n	Scanner sc = new Scanner(System.in);\n	int t = sc.nextInt();\n	int l = sc.nextInt();\n	String[] arr = new String[t];\n	HashMap<String,Integer> hm = new HashMap<>();\n	for(int i =0 ;i <t;i++){\n	    arr[i]=sc.next();\n	}\n	String a = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";\n	for(int i=0; i<t; i++)\n        {\n            StringBuilder sb = new StringBuilder(arr[i]);\n            for(int j=1; j<l; j+=2)\n            {\n                int val = sb.charAt(j);\n                sb.setCharAt(j, a.charAt(25-val%65));\n            }\n            hm.put(sb.toString(),i);\n            arr[i] = sb.toString();\n        \n            \n        }\n        Arrays.sort(arr);\n \n        int[] ans = new int[t];\n        for(int i=0; i<t; i++)\n        {\n            if(hm.containsKey(arr[i])) ans[i] = hm.get(arr[i])+1;\n        }\n        for(int i=0; i<t; i++)\n            System.out.print(ans[i] + "" "");\n	}\n}","data structures,sortings,strings"
"/* package codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be ""Main"" only if the class is public. */\npublic class Codeforces\n{\n	public static void main (String[] args) throws java.lang.Exception\n	{\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int m=sc.nextInt();\n		sc.nextLine();\n		Pair p[]=new Pair[n];\n		for(int i=0;i<n;i++){ \n		    String str=sc.nextLine();\n		    String var="""";\n		    for(int j=0;j<m;j++){ \n		        if(j%2==0){ \n		            var+=str.charAt(j);\n		        }else{ \n		            var+=('Z'-(str.charAt(j)-'A'));\n		        }\n		    }\n		    p[i]=new Pair(i+1,var);\n		    \n		}\n		Arrays.sort(p,(a,b)->a.str.compareTo(b.str));\n		for(int i=0;i<n;i++){ \n		    System.out.print(p[i].pos+"" "");\n		}\n	}\n	public static class Pair{ \n	    int pos;\n	    String str;\n	    Pair(int p,String st){ \n	        pos=p;\n	        str=st;\n	    }\n	}\n	\n	\n}\n","data structures,sortings,strings"
"import java.util.Scanner;\n\n\n\npublic class idd {\n		public static void main(String[] a) {\n		Scanner b=new Scanner(System.in);\n		for(int x=b.nextInt();x>0;x--) {\n			int[] c= {b.nextInt(),b.nextInt()};\n			System.out.println(Math.min(c[1]-c[0], (c[1]-1)/2));\n		}\n	}\n}\n","greedy,math"
"import java.util.Scanner;\n\n\n\npublic class idd {\n		public static void main(String[] a) {\n		Scanner b=new Scanner(System.in);\n		for(int x=b.nextInt();x>0;x--) {\n			int[] c= {b.nextInt(),b.nextInt()};\n			System.out.println(Math.min(c[1]-c[0], (c[1]-1)/2));\n		}\n	}\n}\n","greedy,math"
"import java.util.*;\npublic class yoo\n{\n	public static void main(String[] args)\n	{\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while(t-->0) \n		{\n			int l = sc.nextInt();\n			int r = sc.nextInt();\n			System.out.println(r%(Math.max(l, r/2+1)));\n			\n		}\n \n	}\n}","greedy,math"
"import java.util.*;\npublic class yoo\n{\n	public static void main(String[] args)\n	{\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while(t-->0) \n		{\n			int l = sc.nextInt();\n			int r = sc.nextInt();\n			System.out.println(r%(Math.max(l, r/2+1)));\n			\n		}\n\n	}\n}\n","greedy,math"
"import java.util.*;\npublic class M{public static void main(String[]args){Scanner s=new Scanner(System.in);int t=s.nextInt();while(t-->0){int n=s.nextInt(),ans=s.nextInt();for(int i=0;i<n-1;i++)ans&=s.nextInt();System.out.println(ans);}}}","bitmasks,constructive algorithms,math"
import java.util.*;\npublic class _1559A\n{\n	public static void main(String[] args)\n	{\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0)\n		{\n			int n=sc.nextInt();\n			int ans=sc.nextInt();\n			\n			for(int i=1;i<n;i++)\n			ans=ans&sc.nextInt();\n			\n			System.out.println(ans);\n		}\n	}\n},"bitmasks,constructive algorithms,math"
import java.util.*;\npublic class _1559A\n{\n	public static void main(String[] args)\n	{\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0)\n		{\n			int n=sc.nextInt();\n			int ans=sc.nextInt();\n			\n			for(int i=1;i<n;i++)\n			ans=ans&sc.nextInt();\n			\n			System.out.println(ans);\n		}\n	}\n},"bitmasks,constructive algorithms,math"
import java.util.*;\npublic class MochaAndMath {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0) {\n			int n=sc.nextInt();\n			int ans=sc.nextInt();\n			for(int i=1;i<n;i++) {\n				ans&=sc.nextInt();\n			}\n			System.out.println(ans);\n		}\n\n	}\n\n}\n,"bitmasks,constructive algorithms,math"
"import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Math.max;\nimport static java.lang.System.arraycopy;\nimport static java.lang.System.exit;\nimport static java.util.Arrays.copyOf;\nimport static java.util.Arrays.fill;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.util.StringTokenizer;\n\npublic class E {\n\n	static class IntList {\n\n		int data[] = new int[3];\n		int size = 0;\n\n		boolean isEmpty() {\n			return size == 0;\n		}\n\n		int size() {\n			return size;\n		}\n\n		int get(int index) {\n			if (index < 0 || index >= size) {\n				throw new IndexOutOfBoundsException();\n			}\n			return data[index];\n		}\n\n		void clear() {\n			size = 0;\n		}\n\n		void set(int index, int value) {\n			if (index < 0 || index >= size) {\n				throw new IndexOutOfBoundsException();\n			}\n			data[index] = value;\n		}\n\n		void expand() {\n			if (size >= data.length) {\n				data = copyOf(data, (data.length << 1) + 1);\n			}\n		}\n\n		void insert(int index, int value) {\n			if (index < 0 || index > size) {\n				throw new IndexOutOfBoundsException();\n			}\n			expand();\n			arraycopy(data, index, data, index + 1, size++ - index);\n			data[index] = value;\n		}\n\n		int delete(int index) {\n			if (index < 0 || index >= size) {\n				throw new IndexOutOfBoundsException();\n			}\n			int value = data[index];\n			arraycopy(data, index + 1, data, index, --size - index);\n			return value;\n		}\n\n		void push(int value) {\n			expand();\n			data[size++] = value;\n		}\n\n		int pop() {\n			if (size == 0) {\n				throw new NoSuchElementException();\n			}\n			return data[--size];\n		}\n\n		void unshift(int value) {\n			expand();\n			arraycopy(data, 0, data, 1, size++);\n			data[0] = value;\n		}\n\n		int shift() {\n			if (size == 0) {\n				throw new NoSuchElementException();\n			}\n			int value = data[0];\n			arraycopy(data, 1, data, 0, --size);\n			return value;\n		}\n	}\n\n	static void solve() throws Exception {\n		int tests = scanInt();\n		for (int test = 0; test < tests; test++) {\n			int n = scanInt(), m = scanInt(), a[] = new int[n], b[] = new int[n], maxA = 0;\n			for (int i = 1; i < n; i++) {\n				a[i] = scanInt();\n				maxA = max(maxA, a[i]);\n			}\n			for (int i = 1; i < n; i++) {\n				b[i] = scanInt();\n			}\n			IntList edges[] = new IntList[n];\n			for (int i = 0; i < n; i++) {\n				edges[i] = new IntList();\n			}\n			for (int i = 0; i < m; i++) {\n				int u = scanInt() - 1, v = scanInt() - 1;\n				edges[u].push(v);\n				edges[v].push(u);\n			}\n			int status[] = new int[n];\n			long strength[] = new long[n];\n			int stack[] = new int[n];\n			int l = 1, r = maxA;\n			bs: while (l < r) {\n				int mid = (l + r + 1) >> 1;\n				long str = mid;\n				status[0] = -2;\n				fill(status, 1, n, -1);\n				int left = n - 1;\n				while (left > 0) {\n					int stackSize = 0;\n					int b1, b2;\n					bb: {\n						for (int cur = 0; cur < n; cur++) {\n							if (status[cur] == -2) {\n								IntList e = edges[cur];\n								for (int i = 0; i < e.size; i++) {\n									int next = e.data[i];\n									if (a[next] >= str) {\n										continue;\n									}\n									if (status[next] == -1) {\n										status[next] = cur;\n										strength[next] = str + b[next];\n										stack[stackSize++] = next;\n									} else if (status[next] >= 0) {\n										b1 = next;\n										b2 = cur;\n										break bb;\n									}\n								}\n							}\n						}\n						while (stackSize > 0) {\n							int cur = stack[--stackSize];\n							int prev = status[cur];\n							long cstr = strength[cur];\n							IntList e = edges[cur];\n							for (int i = 0; i < e.size; i++) {\n								int next = e.data[i];\n								if (next == prev || a[next] >= cstr) {\n									continue;\n								}\n								if (status[next] == -1) {\n									status[next] = cur;\n									strength[next] = cstr + b[next];\n									stack[stackSize++] = next;\n								} else {\n									b1 = next;\n									b2 = cur;\n									break bb;\n								}\n							}\n						}\n						l = mid;\n						continue bs;\n					}\n					while (status[b1] >= 0) {\n						str += b[b1];\n						int nb1 = status[b1];\n						status[b1] = -2;\n						--left;\n						b1 = nb1;\n					}\n					while (status[b2] >= 0) {\n						str += b[b2];\n						int nb2 = status[b2];\n						status[b2] = -2;\n						--left;\n						b2 = nb2;\n					}\n					for (int i = 0; i < n; i++) {\n						if (status[i] != -2) {\n							status[i] = -1;\n						}\n					}\n				}\n				r = mid - 1;\n			}\n			out.println(l + 1);\n		}\n	}\n\n	static int scanInt() throws IOException {\n		return parseInt(scanString());\n	}\n\n	static long scanLong() throws IOException {\n		return parseLong(scanString());\n	}\n\n	static String scanString() throws IOException {\n		while (tok == null || !tok.hasMoreTokens()) {\n			tok = new StringTokenizer(in.readLine());\n		}\n		return tok.nextToken();\n	}\n\n	static BufferedReader in;\n	static PrintWriter out;\n	static StringTokenizer tok;\n\n	public static void main(String[] args) {\n		try {\n			in = new BufferedReader(new InputStreamReader(System.in));\n			out = new PrintWriter(System.out);\n			solve();\n			in.close();\n			out.close();\n		} catch (Throwable e) {\n			e.printStackTrace();\n			exit(1);\n		}\n	}\n}","binary search,dfs and similar,graphs,greedy,meet-in-the-middle,shortest paths"
"import java.util.*;\n \npublic class Solution {\n	\n	private static Scanner in = new Scanner(System.in);\n	\n	public static void main(String[] args) {\n		\n		int t = in.nextInt();\n		while(t-- > 0)\n			solve();\n    }\n	\n	private static void solve() {\n		int n = in.nextInt();\n		int k = in.nextInt();\n		int a[][] = new int[n][2];\n		for(int i=0;i<n;i++) {\n			a[i][0] = in.nextInt();\n			a[i][1] = i;\n		}\n		\n		Arrays.sort(a, (x,y)->x[0]-y[0]);\n		\n		int hills = 1;\n		\n		for(int i=0;i<n-1;i++)\n		{\n			if(a[i][1]+1!=a[i+1][1]) hills++;\n		}\n\n		\n		System.out.println(hills<=k?""YES"":""NO"");\n	}		\n}","greedy,sortings"
"import java.util.*;\npublic class Yoo\n{\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0) {\n			int k=sc.nextInt();\n			int n=sc.nextInt();\n			int arr[]=new int[k];\n			int c=1;\n			TreeSet<Integer> set=new TreeSet<>();\n			for(int i=0;i<k;i++) {\n				arr[i]=sc.nextInt();\n				set.add(arr[i]);\n			}\n			for(int i=0;i<k-1;i++){\n				if(arr[i]>arr[i+1]) {\n					c++;\n				}\n				else if(set.higher(arr[i])!=arr[i+1]){\n					c++;\n				}\n			}\n			if(c>n) {\n				System.out.println(""NO"");\n			}\n			else {\n				System.out.println(""YES"");\n			}\n		}\n	}\n\n}\n","greedy,sortings"
"import java.util.*;\npublic class MoamenAndKSubarrays {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0) {\n			int k=sc.nextInt();\n			int n=sc.nextInt();\n			int arr[]=new int[k];\n			int c=1;\n			TreeSet<Integer> set=new TreeSet<>();\n			for(int i=0;i<k;i++) {\n				arr[i]=sc.nextInt();\n				set.add(arr[i]);\n			}\n			for(int i=0;i<k-1;i++){\n				if(arr[i]>arr[i+1]) {\n					c++;\n				}\n				else if(set.higher(arr[i])!=arr[i+1]){\n					c++;\n				}\n			}\n			if(c>n) {\n				System.out.println(""NO"");\n			}\n			else {\n				System.out.println(""YES"");\n			}\n		}\n	}\n\n}\n","greedy,sortings"
"import java.util.*;\n\npublic class CBR79B {\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n\n		int t=s.nextInt();\n		\n		while(t-->0) {\n			int n=s.nextInt();\n			int k=s.nextInt();\n			\n			int[] a=new int[n];\n			\n			int[] b=new int[n];\n			\n			for(int i=0;i<n;i++) {\n				a[i]=s.nextInt();\n				b[i]=a[i];\n			}\n			Arrays.sort(b);\n			int c=0;\n			\n			for(int i=1;i<n;i++) {\n				if(a[i-1]>a[i]) {\n					c++;\n				}\n				else {\n					int j=Arrays.binarySearch(b,a[i-1]);\n					if(j==n-1 || b[j+1]!=a[i]) {\n						c++;\n					}\n				}\n			}\n				if(c>k-1) {\n					System.out.println(""No"");\n				}\n				else {\n					System.out.println(""Yes"");\n				}\n			}\n		}\n	}\n\n","greedy,sortings"
"// upsolve with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1556E extends PrintWriter {\n	CF1556E() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1556E o = new CF1556E(); o.main(); o.flush();\n	}\n\n	static final long INF = 0x3f3f3f3f3f3f3f3fL;\n	long[] aa, tmax, tmin; int n;\n	void build() {\n		tmax = new long[n * 2];\n		tmin = new long[n * 2];\n		for (int i = 0; i < n; i++)\n			tmax[n + i] = tmin[n + i] = aa[i];\n		for (int i = n - 1; i > 0; i--) {\n			tmax[i] = Math.max(tmax[i << 1], tmax[i << 1 | 1]);\n			tmin[i] = Math.min(tmin[i << 1], tmin[i << 1 | 1]);\n		}\n	}\n	long qmax(int l, int r) {\n		long ans = -INF;\n		for (l += n, r += n; l <= r; l >>= 1, r >>= 1) {\n			if ((l & 1) == 1)\n				ans = Math.max(ans, tmax[l++]);\n			if ((r & 1) == 0)\n				ans = Math.max(ans, tmax[r--]);\n		}\n		return ans;\n	}\n	long qmin(int l, int r) {\n		long ans = INF;\n		for (l += n, r += n; l <= r; l >>= 1, r >>= 1) {\n			if ((l & 1) == 1)\n				ans = Math.min(ans, tmin[l++]);\n			if ((r & 1) == 0)\n				ans = Math.min(ans, tmin[r--]);\n		}\n		return ans;\n	}\n	void main() {\n		n = sc.nextInt();\n		int q = sc.nextInt();\n		aa = new long[n];\n		for (int i = 0; i < n; i++)\n			aa[i] = -sc.nextInt();\n		for (int i = 0; i < n; i++)\n			aa[i] += sc.nextInt();\n		for (int i = 1; i < n; i++)\n			aa[i] += aa[i - 1];\n		build();\n		while (q-- > 0) {\n			int l = sc.nextInt() - 1;\n			int r = sc.nextInt() - 1;\n			long a = l == 0 ? 0 : aa[l - 1];\n			long b = aa[r];\n			println(a != b || qmin(l, r) != a ? -1 : qmax(l, r) - a);\n		}\n	}\n}\n","data structures,dp,greedy"
"import java.io.*;\nimport java.util.*;\n\npublic class Codeforces\n{\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb=new StringBuilder();\n        String s[]=bu.readLine().split("" "");\n        int n=Integer.parseInt(s[0]),q=Integer.parseInt(s[1]);\n\n        int a[]=new int[n],b[]=new int[n],i;\n        s=bu.readLine().split("" "");\n        for(i=0;i<n;i++) a[i]=Integer.parseInt(s[i]);\n        s=bu.readLine().split("" "");\n        for(i=0;i<n;i++) b[i]=Integer.parseInt(s[i]);\n\n        long pre[]=new long[n+1],min[]=new long[4*n+10],max[]=new long[4*n+10];\n        Arrays.fill(min,Long.MAX_VALUE);\n        for(i=1;i<=n;i++)\n        {\n            pre[i]=b[i-1]-a[i-1];\n            pre[i]+=pre[i-1];\n            update(min,0,n,i,pre[i],0,true);\n            update(max,0,n,i,pre[i],0,false);\n        }\n\n        while(q-->0)\n        {\n            s=bu.readLine().split("" "");\n            int l=Integer.parseInt(s[0]),r=Integer.parseInt(s[1]);\n            long rsum=pre[r]-pre[l-1],mx=query(max,0,n,l,r,0,false),mn=query(min,0,n,l,r,0,true);\n            if(rsum==0 && mn-pre[l-1]>=0) sb.append(mx-pre[l-1]+""\n"");\n            else sb.append(""-1\n"");\n        }\n        System.out.print(sb);\n    }\n\n    static void update(long st[],int ss,int se,int i,long v,int n,boolean min)\n    {\n        if(ss>se) return;\n        if(ss==se)\n        {\n            st[n]=v;\n            return;\n        }\n\n        int m=(ss+se)>>1;\n        if(i<=m) update(st,ss,m,i,v,2*n+1,min);\n        else update(st,m+1,se,i,v,2*n+2,min);\n        if(min) st[n]=Math.min(st[2*n+1],st[2*n+2]);\n        else st[n]=Math.max(st[2*n+1],st[2*n+2]);\n    }\n\n    static long query(long st[],int ss,int se,int qs,int qe,int n,boolean min)\n    {\n        if(ss>se || qs>se || qe<ss) return min?Long.MAX_VALUE:Long.MIN_VALUE;\n        if(qs<=ss && qe>=se) return st[n];\n\n        int m=(ss+se)>>1;\n        return min?\n                Math.min(query(st,ss,m,qs,qe,2*n+1,min),query(st,m+1,se,qs,qe,2*n+2,min)):\n                Math.max(query(st,ss,m,qs,qe,2*n+1,min),query(st,m+1,se,qs,qe,2*n+2,min));\n    }\n}","data structures,dp,greedy"
"import java.util.*;\nimport java.io.*;\npublic class E {\n\n	public static void main(String[] args) {\n		FastScanner sc = new FastScanner();\n		int n = sc.nextInt();\n		int q = sc.nextInt();\n		int[] arr = new int[n];\n		int[] brr = new int[n];\n		for(int i = 0; i < n; i++) {\n			arr[i] = sc.nextInt();\n		}\n		for(int i = 0; i < n; i++) {\n			brr[i] = sc.nextInt();\n		}\n		int[] crr = new int[n];\n		for(int i = 0; i < n; i++) {\n			crr[i] = brr[i] - arr[i];\n		}\n		long[] acc = new long[n+1];\n		for(int i = 1; i <= n; i++) {\n			acc[i] = acc[i-1] + crr[i-1];\n		}\n		Node st = new Node(0, n, acc);\n		StringBuilder sb = new StringBuilder();\n		while(q-- > 0) {\n			int L = sc.nextInt()-1;\n			int R = sc.nextInt()-1;\n			if(acc[R+1] == acc[L] && st.querymin(L, R+1) == acc[L]) {\n				long r = st.querymax(L, R+1) - acc[L];\n				sb.append(r+""\n"");\n			}\n			else {\n				sb.append(""-1\n"");\n			}\n		}\n		PrintWriter pw = new PrintWriter(System.out);\n		pw.println(sb.toString().trim());\n		pw.flush();\n	}\n	\n	static class Node{\n		int L, R;\n		long min, max, sum;\n		Node left, right;\n		public Node(int L, int R, long[] arr){\n			this.L = L; this.R = R;\n			if(L == R) {\n				sum = max = min = arr[L];\n			}\n			else {\n				left = new Node(L, (L+R)/2, arr);\n				right = new Node((L+R)/2+1, R, arr);\n				min = Math.min(left.min, right.min);\n				max = Math.max(left.max, right.max);\n				sum = left.sum + right.sum;\n			}\n		}\n		public long querysum(int qL, int qR) {\n			if(qR < L || R < qL) return 0;\n			else if(qL <= L && R <= qR) return sum;\n			else {\n				long x = left.querysum(qL, qR);\n				long y = right.querysum(qL, qR);\n				return x + y;\n			}\n		}\n		public long querymax(int qL, int qR) {\n			if(qR < L || R < qL) return Long.MIN_VALUE;\n			else if(qL <= L && R <= qR) return max;\n			else {\n				long x = left.querymax(qL, qR);\n				long y = right.querymax(qL, qR);\n				return Math.max(x, y);\n			}\n		}\n		public long querymin(int qL, int qR) {\n			if(qR < L || R < qL) return Long.MAX_VALUE;\n			else if(qL <= L && R <= qR) return min;\n			else {\n				long x = left.querymin(qL, qR);\n				long y = right.querymin(qL, qR);\n				return Math.min(x, y);\n			}\n		}\n	}\n	\n	static class FastScanner {\n		public BufferedReader reader;\n		public StringTokenizer tokenizer;\n		public FastScanner() {\n			reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n			tokenizer = null;\n		}\n		public String next() {\n			while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n				try {\n					tokenizer = new StringTokenizer(reader.readLine());\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n			return tokenizer.nextToken();\n		}\n		public int nextInt() {\n			return Integer.parseInt(next());\n		}\n		public long nextLong() {\n			return Long.parseLong(next());\n		}\n		public double nextDouble() {\n			return Double.parseDouble(next());\n		}\n		public String nextLine() {\n			try {\n				return reader.readLine();\n			} catch(IOException e) {\n				throw new RuntimeException(e);\n			}\n		}\n	}\n\n}\n","data structures,dp,greedy"
"import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.System.arraycopy;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class E {\n\n	static class LongMaxTree {\n\n		final int n;\n		final long t[];\n\n		LongMaxTree(int n) {\n			this.n = n;\n			t = new long[2 * n - 1];\n		}\n\n		long get(int i) {\n			return t[i + n - 1];\n		}\n\n		long getMax(int l, int r) {\n			long v = Long.MIN_VALUE;\n			for (l += n, r += n; l != r; l >>>= 1, r >>>= 1) {\n				if ((l & 1) != 0) {\n					v = max(v, t[l++ - 1]);\n				}\n				if ((r & 1) != 0) {\n					v = max(v, t[--r - 1]);\n				}\n			}\n			return v;\n		}\n\n		void set(int i, long v) {\n			t[(i += n) - 1] = v;\n			for (i >>= 1; i != 0; i >>= 1) {\n				t[i - 1] = max(t[(i << 1) - 1], t[i << 1]);\n			}\n		}\n	}\n\n	static class LongMinTree {\n\n		final int n;\n		final long t[];\n\n		LongMinTree(int n) {\n			this.n = n;\n			t = new long[2 * n - 1];\n		}\n\n		long get(int i) {\n			return t[i + n - 1];\n		}\n\n		long getMin(int l, int r) {\n			long v = Long.MAX_VALUE;\n			for (l += n, r += n; l != r; l >>>= 1, r >>>= 1) {\n				if ((l & 1) != 0) {\n					v = min(v, t[l++ - 1]);\n				}\n				if ((r & 1) != 0) {\n					v = min(v, t[--r - 1]);\n				}\n			}\n			return v;\n		}\n\n		void set(int i, long v) {\n			t[(i += n) - 1] = v;\n			for (i >>= 1; i != 0; i >>= 1) {\n				t[i - 1] = min(t[(i << 1) - 1], t[i << 1]);\n			}\n		}\n	}\n\n	static void solve() throws Exception {\n		int n = scanInt(), q = scanInt();\n		LongMinTree minTree = new LongMinTree(n + 1);\n		LongMaxTree maxTree = new LongMaxTree(n + 1);\n		for (int i = 0; i < n; i++) {\n			minTree.t[n + i] = -scanInt();\n		}\n		for (int i = 0; i < n; i++) {\n			minTree.t[n + i] += scanInt();\n		}\n		long sum = 0;\n		for (int i = 0; i < n; i++) {\n			long v = minTree.t[n + i];\n			minTree.t[n + i] = sum;\n			sum += v;\n		}\n		minTree.t[n + n] = sum;\n		arraycopy(minTree.t, n, maxTree.t, n, n + 1);\n		for (int i = n; i != 0; i--) {\n			minTree.t[i - 1] = min(minTree.t[(i << 1) - 1], minTree.t[i << 1]);\n			maxTree.t[i - 1] = max(maxTree.t[(i << 1) - 1], maxTree.t[i << 1]);\n		}\n		for (int qq = 0; qq < q; qq++) {\n			int l = scanInt() - 1, r = scanInt();\n			long s = minTree.get(l);\n			out.println(minTree.get(r) != s || minTree.getMin(l, r + 1) != s ? -1 : maxTree.getMax(l, r + 1) - s);\n		}\n	}\n\n	static int scanInt() throws IOException {\n		return parseInt(scanString());\n	}\n\n	static long scanLong() throws IOException {\n		return parseLong(scanString());\n	}\n\n	static String scanString() throws IOException {\n		while (tok == null || !tok.hasMoreTokens()) {\n			tok = new StringTokenizer(in.readLine());\n		}\n		return tok.nextToken();\n	}\n\n	static BufferedReader in;\n	static PrintWriter out;\n	static StringTokenizer tok;\n\n	public static void main(String[] args) {\n		try {\n			in = new BufferedReader(new InputStreamReader(System.in));\n			out = new PrintWriter(System.out);\n			solve();\n			in.close();\n			out.close();\n		} catch (Throwable e) {\n			e.printStackTrace();\n			exit(1);\n		}\n	}\n}","data structures,dp,greedy"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1555E extends PrintWriter {\n	CF1555E() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1555E o = new CF1555E(); o.main(); o.flush();\n	}\n\n	int[] st; boolean[] covered; int n_;\n	void pul(int i) {\n		covered[i] = st[i] > 0 || i < n_ && covered[i << 1] && covered[i << 1 | 1];\n	}\n	void init(int n) {\n		n_ = 1;\n		while (n_ < n)\n			n_ <<= 1;\n		st = new int[n_ * 2];\n		covered = new boolean[n_ * 2];\n		for (int i = n_ + n; i < n_ + n_; i++) {\n			st[i] = 1;\n			covered[i] = true;\n		}\n		for (int i = n_; i >= 1; i--)\n			pul(i);\n	}\n	void update(int i, int x) {\n		st[i] += x;\n		pul(i);\n		while (i > 1 && covered[i >> 1] != covered[i])\n			pul(i >>= 1);\n	}\n	void update(int l, int r, int x) {\n		for (l += n_, r += n_; l <= r; l >>= 1, r >>= 1) {\n			if ((l & 1) == 1)\n				update(l++, x);\n			if ((r & 1) == 0)\n				update(r--, x);\n		}\n	}\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt() - 1;\n		int[] ll = new int[n];\n		int[] rr = new int[n];\n		int[] ww = new int[n];\n		Integer[] ii = new Integer[n];\n		for (int i = 0; i < n; i++) {\n			ll[i] = sc.nextInt() - 1;\n			rr[i] = sc.nextInt() - 1 - 1;\n			ww[i] = sc.nextInt();\n			ii[i] = i;\n		}\n		init(m);\n		Arrays.sort(ii, (i, j) -> ww[i] - ww[j]);\n		int ans = ww[ii[n - 1]] - ww[ii[0]];\n		for (int i = 0, j = 0; i < n; i++) {\n			while (j < n && !covered[1]) {\n				update(ll[ii[j]], rr[ii[j]], 1);\n				j++;\n			}\n			if (!covered[1])\n				break;\n			ans = Math.min(ans, ww[ii[j - 1]] - ww[ii[i]]);\n			update(ll[ii[i]], rr[ii[i]], -1);\n		}\n		println(ans);\n	}\n}\n","data structures,sortings,trees,two pointers"
"import java.util.*;\n\npublic class MyClass {\n    static Scanner in= new Scanner(System.in);\n    public static void main(String args[]) {\n      int n= in.nextInt(), m= in.nextInt()-1;\n      List<Triple> a= new ArrayList<>();\n      for(int i=0;i<n;i++){\n          int x,y,z;\n          y= in.nextInt(); z= in.nextInt()-1; x= in.nextInt();\n          a.add(new Triple(x,y,z));\n      }\n      Collections.sort(a);\n      SEG seg= new SEG();\n      int L=0;\n      int ans= Integer.MAX_VALUE;\n      for(int R=0;R<n;R++) {\n          seg.update(1,1,m,a.get(R).y,a.get(R).z,1);\n          while(true) {\n            seg.update(1, 1, m, a.get(L).y, a.get(L).z, -1);\n            if (seg.tree[1] > 0) {\n                L++;\n                continue;\n            }\n            seg.update(1, 1, m, a.get(L).y, a.get(L).z, 1);\n            break;\n          }\n          if(seg.tree[1]>0) ans= Math.min(ans, a.get(R).x-a.get(L).x);\n      }\n      System.out.println(ans);\n    }\n    \n}\n\nclass Triple implements Comparable<Triple>{\n    public int x;\n    public int y;\n    public int z;\n    public Triple(int x, int y, int z){\n        this.x = x;this.y = y;this.z = z;\n    }\n    public int compareTo(Triple o){\n        return this.x-o.x;\n        \n    }\n}\n\nclass SEG {\n    int MAXN= 1000100;\n    public int[] tree= new int[4*MAXN], lazy= new int[4*MAXN];\n    void push(int i, int L, int R){\n        if(lazy[i]==0) return;\n         tree[i] += lazy[i];\n        if (L != R) {\n            lazy[i << 1] += lazy[i];\n            lazy[i << 1 | 1] += lazy[i];\n        }\n        lazy[i] = 0;\n    }\n    //update a[i]+= val for all i in [u,v]\n    public void update(int i, int L, int R, int u, int v, int val) {\n        push(i,L,R);\n        if(L>v || R<u) return;\n        if(L>=u && R<=v) {\n            lazy[i] = val;\n            push(i,L,R);\n            return;\n        }\n        int mid= (L+R)>>1;\n        update(i << 1, L, mid, u, v, val);\n        update(i << 1 | 1, mid + 1, R, u, v, val);\n        tree[i] = Math.min(tree[i << 1], tree[i << 1 | 1]);\n    }\n}","data structures,sortings,trees,two pointers"
"import java.util.*;\n\npublic class MyClass {\n    static Scanner in= new Scanner(System.in);\n    public static void main(String args[]) {\n      int n= in.nextInt(), m= in.nextInt()-1;\n      List<Triple> a= new ArrayList<>();\n      for(int i=0;i<n;i++){\n          int x,y,z;\n          y= in.nextInt(); z= in.nextInt()-1; x= in.nextInt();\n          a.add(new Triple(x,y,z));\n      }\n      Collections.sort(a);\n      SEG seg= new SEG();\n      int L=0;\n      int ans= Integer.MAX_VALUE;\n      for(int R=0;R<n;R++) {\n          seg.update(1,1,m,a.get(R).y,a.get(R).z,1);\n          while(true) {\n            seg.update(1, 1, m, a.get(L).y, a.get(L).z, -1);\n            if (seg.tree[1] > 0) {\n                L++;\n                continue;\n            }\n            seg.update(1, 1, m, a.get(L).y, a.get(L).z, 1);\n            break;\n          }\n          if(seg.tree[1]>0) ans= Math.min(ans, a.get(R).x-a.get(L).x);\n      }\n      System.out.println(ans);\n    }\n    \n}\n\nclass Triple implements Comparable<Triple>{\n    public int x;\n    public int y;\n    public int z;\n    public Triple(int x, int y, int z){\n        this.x = x;this.y = y;this.z = z;\n    }\n    public int compareTo(Triple o){\n        if(this.x!=o.x) return this.x-o.x;\n        if(this.y!=o.y) return this.y-o.y;\n        return this.z-o.z;\n    }\n}\n\nclass SEG {\n    int MAXN= 1000100;\n    public int[] tree= new int[4*MAXN], lazy= new int[4*MAXN];\n    void push(int i, int L, int R){\n        if(lazy[i]==0) return;\n         tree[i] += lazy[i];\n        if (L != R) {\n            lazy[i << 1] += lazy[i];\n            lazy[i << 1 | 1] += lazy[i];\n        }\n        lazy[i] = 0;\n    }\n    //update a[i]+= val for all i in [u,v]\n    public void update(int i, int L, int R, int u, int v, int val) {\n        push(i,L,R);\n        if(L>v || R<u) return;\n        if(L>=u && R<=v) {\n            lazy[i] = val;\n            push(i,L,R);\n            return;\n        }\n        int mid= (L+R)>>1;\n        update(i << 1, L, mid, u, v, val);\n        update(i << 1 | 1, mid + 1, R, u, v, val);\n        tree[i] = Math.min(tree[i << 1], tree[i << 1 | 1]);\n    }\n}","data structures,sortings,trees,two pointers"
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    final static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static StringTokenizer st;\n\n    static int readInt() throws IOException {\n        while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n        return Integer.parseInt(st.nextToken());\n    }\n\n    static class Segment implements Comparable<Segment> {\n        int L, R, w;\n\n        Segment(int L, int R, int w) {\n            this.L = L;\n            this.R = R;\n            this.w = w;\n        }\n\n        public int compareTo(Segment other) {\n            return this.w - other.w;\n        }\n    }\n\n    static int t[], lz[];\n\n    static void update(int qL, int qR, int val, int L, int R, int v) {\n        if (qL <= L && R <= qR) {\n            t[v] = Math.max(t[v], val);\n            lz[v] = Math.max(lz[v], val);\n        } else if (qL <= R && L <= qR) {\n            int M = (L + R) >> 1, v2 = v << 1, v21 = v2 | 1;\n            if (lz[v] != 0) {\n                t[v2] = Math.max(t[v2], lz[v]);\n                lz[v2] = Math.max(lz[v2], lz[v]);\n                t[v21] = Math.max(t[v21], lz[v]);\n                lz[v21] = Math.max(lz[v21], lz[v]);\n                lz[v] = 0;\n            }\n            update(qL, qR, val, L, M, v2);\n            update(qL, qR, val, M + 1, R, v21);\n            t[v] = Math.min(t[v2], t[v21]);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        final int n = readInt(), m = readInt();\n        final Segment seg[] = new Segment[n + 1];\n        for (int i = 1; i <= n; ++i) {\n            seg[i] = new Segment(readInt(), readInt(), readInt());\n            if (seg[i].L != 1) ++seg[i].L;\n        }\n        Arrays.sort(seg, 1, n + 1);\n        t = new int[m << 2];\n        lz = new int[m << 2];\n        int res = Integer.MAX_VALUE;\n        for (int i = 1; i <= n; ++i) {\n            update(seg[i].L, seg[i].R, seg[i].w, 1, m, 1);\n            if (t[1] >= 1) res = Math.min(res, seg[i].w - t[1]);\n        }\n        final PrintWriter pr = new PrintWriter(new OutputStreamWriter(System.out));\n        pr.println(res);\n        pr.close();\n    }\n}","data structures,sortings,trees,two pointers"
"import java.util.*;\npublic class Main{\n	public static void main(String args[]) {\n		Scanner s=new Scanner(System.in);\n		int t=s.nextInt();\n		while(t-->0) {\n			int n=s.nextInt();\n			System.out.println(""2 ""+(n-1));\n		}\n	}\n}\n","math,number theory"
"import java.util.Scanner;\npublic class Main{\n		\n	public static void main(String[] args) {\n		Scanner x = new Scanner(System.in);\n		int T = x.nextInt();\n		while(T-->0) {\n			int P = x.nextInt();\n			System.out.println(""2 ""+(P-1));\n		}\n	}\n}","math,number theory"
"import java.util.Scanner;\n\npublic class Main {\n    public static void main(String args[]) {\nScanner sc=new Scanner(System.in);\nint t=sc.nextInt();\nwhile(t-->0)\n{\n    int P=sc.nextInt();\n    System.out.println(2+"" ""+(P-1));\n}\n\n    }\n}","math,number theory"
"import java.util.*;\n\npublic class A1549{\n	public static void main(String args[]){\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		for(int a0=0; a0<t; a0++){\n			int n=sc.nextInt();\n			System.out.println(""2 "" +(n-1));\n		}\n	}\n}","math,number theory"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.nio.charset.StandardCharsets;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            EGregorAndTheTwoPainters solver = new EGregorAndTheTwoPainters();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class EGregorAndTheTwoPainters {\n        Debug debug = new Debug(false);\n        int inf = (int) 3e5;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.ri();\n            int m = in.ri();\n            int x = in.ri();\n            int[] a = in.ri(n);\n            int[] b = in.ri(m);\n            int[] na = na(a);\n            int[] nb = na(b);\n\n            debug.debugArray(""na"", na);\n            debug.debugArray(""nb"", nb);\n            Item[] aItems = new Item[n];\n            Item[] bItems = new Item[m];\n            for (int i = 0; i < n; i++) {\n                aItems[i] = new Item(na[i], a[i], 0);\n            }\n            for (int i = 0; i < m; i++) {\n                bItems[i] = new Item(nb[i], b[i], 1);\n            }\n            Item[] mix = new Item[n + m];\n            System.arraycopy(aItems, 0, mix, 0, n);\n            System.arraycopy(bItems, 0, mix, n, m);\n            Arrays.sort(mix, Comparator.<Item>comparingInt(y -> y.na - y.a).reversed());\n            IntegerBIT[] bit = new IntegerBIT[2];\n            for (int i = 0; i < 2; i++) {\n                bit[i] = new IntegerBIT(inf);\n            }\n            long ans = 0;\n            for (Item item : mix) {\n                int L = x - item.na + 1;\n                int R = x - item.a;\n                L = Math.max(1, L);\n                if (L <= R) {\n                    ans += bit[item.type ^ 1].query(L, R);\n                }\n                bit[item.type].update(item.a, 1);\n            }\n            out.println(ans);\n        }\n\n        public int[] na(int[] a) {\n            int n = a.length;\n            IntegerDeque dq = new IntegerDequeImpl(n);\n            int[] left = new int[n];\n            int[] right = new int[n];\n            for (int i = 0; i < n; i++) {\n                while (!dq.isEmpty() && a[dq.peekLast()] > a[i]) {\n                    dq.removeLast();\n                }\n                left[i] = dq.isEmpty() ? -1 : dq.peekLast();\n                dq.addLast(i);\n            }\n            dq.clear();\n            for (int i = n - 1; i >= 0; i--) {\n                while (!dq.isEmpty() && a[dq.peekLast()] >= a[i]) {\n                    dq.removeLast();\n                }\n                right[i] = dq.isEmpty() ? n : dq.peekLast();\n                dq.addLast(i);\n            }\n            RMQBeta rmq = new RMQBeta(n, (i, j) -> -Integer.compare(a[i], a[j]));\n            int[] ans = new int[n];\n            for (int i = 0; i < n; i++) {\n                ans[i] = inf;\n                if (left[i] >= 0) {\n                    ans[i] = Math.min(ans[i], a[rmq.query(left[i] + 1, i)]);\n                }\n                if (right[i] < n) {\n                    ans[i] = Math.min(ans[i], a[rmq.query(i, right[i] - 1)]);\n                }\n            }\n            return ans;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 32 << 10;\n        private OutputStream writer;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n        private static Field stringBuilderValueField;\n        private char[] charBuf = new char[THRESHOLD * 2];\n        private byte[] byteBuf = new byte[THRESHOLD * 2];\n\n        static {\n            try {\n                stringBuilderValueField = StringBuilder.class.getSuperclass().getDeclaredField(""value"");\n                stringBuilderValueField.setAccessible(true);\n            } catch (Exception e) {\n                stringBuilderValueField = null;\n            }\n            stringBuilderValueField = null;\n        }\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n\n        public FastOutput(OutputStream writer) {\n            this.writer = writer;\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(long c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput println(long c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            return append('\n');\n        }\n\n        public FastOutput flush() {\n            try {\n                if (stringBuilderValueField != null) {\n                    try {\n                        byte[] value = (byte[]) stringBuilderValueField.get(cache);\n                        writer.write(value, 0, cache.length());\n                    } catch (Exception e) {\n                        stringBuilderValueField = null;\n                    }\n                }\n                if (stringBuilderValueField == null) {\n                    int n = cache.length();\n                    if (n > byteBuf.length) {\n                        //slow\n                        writer.write(cache.toString().getBytes(StandardCharsets.UTF_8));\n//                writer.append(cache);\n                    } else {\n                        cache.getChars(0, n, charBuf, 0);\n                        for (int i = 0; i < n; i++) {\n                            byteBuf[i] = (byte) charBuf[i];\n                        }\n                        writer.write(byteBuf, 0, n);\n                    }\n                }\n                writer.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                writer.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static interface IntToIntegerFunction {\n        int apply(int x);\n\n    }\n\n    static class IntegerDequeImpl implements IntegerDeque {\n        private int[] data;\n        private int bpos;\n        private int epos;\n        private static final int[] EMPTY = new int[0];\n        private int n;\n\n        public IntegerDequeImpl(int cap) {\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n            bpos = 0;\n            epos = 0;\n            n = cap;\n        }\n\n        private void expandSpace(int len) {\n            while (n < len) {\n                n = Math.max(n + 10, n * 2);\n            }\n            int[] newData = new int[n];\n            if (bpos <= epos) {\n                if (bpos < epos) {\n                    System.arraycopy(data, bpos, newData, 0, epos - bpos);\n                }\n            } else {\n                System.arraycopy(data, bpos, newData, 0, data.length - bpos);\n                System.arraycopy(data, 0, newData, data.length - bpos, epos);\n            }\n            epos = size();\n            bpos = 0;\n            data = newData;\n        }\n\n        public IntegerIterator iterator() {\n            return new IntegerIterator() {\n                int index = bpos;\n\n\n                public boolean hasNext() {\n                    return index != epos;\n                }\n\n\n                public int next() {\n                    int ans = data[index];\n                    index = IntegerDequeImpl.this.next(index);\n                    return ans;\n                }\n            };\n        }\n\n        public int removeLast() {\n            int ans = data[last(epos)];\n            epos = last(epos);\n            return ans;\n        }\n\n        public void addLast(int x) {\n            ensureMore();\n            data[epos] = x;\n            epos = next(epos);\n        }\n\n        public int peekLast() {\n            return data[last(epos)];\n        }\n\n        public void clear() {\n            bpos = epos = 0;\n        }\n\n        private int last(int x) {\n            return (x == 0 ? n : x) - 1;\n        }\n\n        private int next(int x) {\n            return x + 1 >= n ? 0 : x + 1;\n        }\n\n        private void ensureMore() {\n            if (next(epos) == bpos) {\n                expandSpace(n + 1);\n            }\n        }\n\n        public int size() {\n            int ans = epos - bpos;\n            if (ans < 0) {\n                ans += data.length;\n            }\n            return ans;\n        }\n\n        public boolean isEmpty() {\n            return bpos == epos;\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (IntegerIterator iterator = iterator(); iterator.hasNext(); ) {\n                builder.append(iterator.next()).append(' ');\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static int floorDiv(int a, int b) {\n            return a < 0 ? -ceilDiv(-a, b) : a / b;\n        }\n\n        public static int ceilDiv(int a, int b) {\n            if (a < 0) {\n                return -floorDiv(-a, b);\n            }\n            int c = a / b;\n            if (c * b < a) {\n                return c + 1;\n            }\n            return c;\n        }\n\n    }\n\n    static interface IntegerDeque extends IntegerStack {\n    }\n\n    static interface IntegerIterator {\n        boolean hasNext();\n\n        int next();\n\n    }\n\n    static interface IntegerComparator {\n        public int compare(int a, int b);\n\n    }\n\n    static interface IntegerStack {\n        void addLast(int x);\n\n        int removeLast();\n\n        int peekLast();\n\n        boolean isEmpty();\n\n        void clear();\n\n    }\n\n    static class IntegerSparseTable {\n        private int[][] st;\n        private IntegerBinaryFunction merger;\n        int m;\n\n        public void init(int length, IntToIntegerFunction function, IntegerBinaryFunction merger) {\n            this.merger = merger;\n            for (int i = 0; i < length; i++) {\n                st[0][i] = function.apply(i);\n            }\n            for (int i = 0; i < m; i++) {\n                int interval = 1 << i;\n                for (int j = 0; j < length; j++) {\n                    if (j + interval < length) {\n                        st[i + 1][j] = merge(st[i][j], st[i][j + interval]);\n                    } else {\n                        st[i + 1][j] = st[i][j];\n                    }\n                }\n            }\n        }\n\n        public IntegerSparseTable(int length) {\n            m = Log2.floorLog(length);\n            st = new int[m + 1][length];\n        }\n\n        public IntegerSparseTable(int length, IntToIntegerFunction function, IntegerBinaryFunction merger) {\n            this(length);\n            init(length, function, merger);\n        }\n\n        private int merge(int a, int b) {\n            return merger.apply(a, b);\n        }\n\n        public int query(int left, int right) {\n            int queryLen = right - left + 1;\n            int bit = Log2.floorLog(queryLen);\n            // x + 2^bit == right + 1\n            // So x should be right + 1 - 2^bit - left=queryLen - 2^bit\n            return merge(st[bit][left], st[bit][right + 1 - (1 << bit)]);\n        }\n\n        public String toString() {\n            return Arrays.toString(st[0]);\n        }\n\n    }\n\n    static class Log2 {\n        public static int floorLog(int x) {\n            if (x <= 0) {\n                throw new IllegalArgumentException();\n            }\n            return 31 - Integer.numberOfLeadingZeros(x);\n        }\n\n    }\n\n    static interface IntegerBinaryFunction {\n        int apply(int a, int b);\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        public void populate(int[] data) {\n            for (int i = 0; i < data.length; i++) {\n                data[i] = readInt();\n            }\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int ri() {\n            return readInt();\n        }\n\n        public int[] ri(int n) {\n            int[] ans = new int[n];\n            populate(ans);\n            return ans;\n        }\n\n        public int readInt() {\n            boolean rev = false;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                rev = next == '-';\n                next = read();\n            }\n\n            int val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 - next + '0';\n                next = read();\n            }\n\n            return rev ? val : -val;\n        }\n\n    }\n\n    static class IntegerBIT {\n        private int[] data;\n        private int n;\n\n        public IntegerBIT(int n) {\n            this.n = n;\n            data = new int[n + 1];\n        }\n\n        public int query(int i) {\n            i = Math.min(i, n);\n            int sum = 0;\n            for (; i > 0; i -= i & -i) {\n                sum += data[i];\n            }\n            return sum;\n        }\n\n        public int query(int l, int r) {\n            return query(r) - query(l - 1);\n        }\n\n        public void update(int i, int mod) {\n            if (i <= 0) {\n                return;\n            }\n            for (; i <= n; i += i & -i) {\n                data[i] += mod;\n            }\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 1; i <= n; i++) {\n                builder.append(query(i) - query(i - 1)).append(' ');\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public Debug debugArray(String name, int[] matrix) {\n            if (offline) {\n                debug(name, Arrays.toString(matrix));\n            }\n            return this;\n        }\n\n        public Debug debug(String name, String x) {\n            if (offline) {\n                out.printf(""%s=%s"", name, x);\n                out.println();\n            }\n            return this;\n        }\n\n    }\n\n    static class Bits {\n        private Bits() {\n        }\n\n        public static int set(int x, int i) {\n            return x | (1 << i);\n        }\n\n        public static int clear(int x, int i) {\n            return x & (~(1 << i));\n        }\n\n        public static int highestOneBitOffset(int x) {\n            return 31 - Integer.numberOfLeadingZeros(x);\n        }\n\n        public static int tailIntMask(int n) {\n            if (n == 0) {\n                return 0;\n            }\n            return -1 << (32 - n);\n        }\n\n    }\n\n    static class RMQBeta {\n        int n;\n        IntegerComparator comp;\n        static int shift = 5;\n        static int blockSize = 1 << shift;\n        static int andMask = blockSize - 1;\n        int[] minIndices;\n        int[] toLeft;\n        IntegerSparseTable st;\n\n        private int min(int a, int b) {\n            return comp.compare(a, b) <= 0 ? a : b;\n        }\n\n        public void init(int n, IntegerComparator comp) {\n            this.comp = comp;\n            int considerPart = ((n - 1) >>> shift) + 1;\n            Arrays.fill(minIndices, 0, considerPart, -1);\n            for (int i = 0; i < n; i++) {\n                int to = i >>> shift;\n                if (minIndices[to] == -1 ||\n                        comp.compare(minIndices[to], i) > 0) {\n                    minIndices[to] = i;\n                }\n            }\n            st.init(considerPart, i -> minIndices[i], (a, b) -> comp.compare(a, b) <= 0 ? a : b);\n            int mask = 0;\n            for (int i = 0; i < n; i++) {\n                if ((i & andMask) == 0) {\n                    mask = 0;\n                }\n                int b = i >>> shift;\n                while (mask != 0) {\n                    int head = Bits.highestOneBitOffset(mask);\n                    if (comp.compare(i, (b << shift) | head) <= 0) {\n                        mask = Bits.clear(mask, head);\n                    } else {\n                        break;\n                    }\n                }\n                mask = Bits.set(mask, i & andMask);\n                toLeft[i] = mask;\n            }\n        }\n\n        public RMQBeta(int n, IntegerComparator comp) {\n            this(n);\n            init(n, comp);\n        }\n\n        public RMQBeta(int n) {\n            this.n = n;\n            minIndices = new int[DigitUtils.ceilDiv(n, blockSize)];\n            st = new IntegerSparseTable(minIndices.length);\n            toLeft = new int[n];\n        }\n\n        public int query(int l, int r) {\n            assert l <= r;\n            int bl = l >>> shift;\n            int br = r >>> shift;\n            int tl = l & andMask;\n//        int tr = r & andMask;\n            if (bl == br) {\n                return Integer.numberOfTrailingZeros(toLeft[r] & Bits.tailIntMask(32 - tl)) | (bl << shift);\n            }\n            int res1 = Integer.numberOfTrailingZeros(toLeft[(bl << shift) | andMask] & Bits.tailIntMask(32 - tl)) | (bl << shift);\n            int res2 = Integer.numberOfTrailingZeros(toLeft[r]) | (br << shift);\n            int best = min(res1, res2);\n            if (bl + 1 < br) {\n                best = min(best, st.query(bl + 1, br - 1));\n            }\n            return best;\n        }\n\n    }\n\n    static class Item {\n        int na;\n        int a;\n        int type;\n\n        public Item(int na, int a, int type) {\n            this.na = na;\n            this.a = a;\n            this.type = type;\n        }\n\n    }\n}\n\n","data structures,divide and conquer,graphs,greedy,math"
import java.io.*;\nimport java.util.*;\npublic class Solution {\n	public static void main(String[] args) throws  java.lang.Exception{\nScanner sc=new Scanner(System.in);\nint T=sc.nextInt();\nwhile(T-->0) {\n		int n=sc.nextInt();\n		int a[]=new int[n+1];\nfor(int i=1;i<=n;i++) {\n	a[i]=sc.nextInt();\n}\nlong c=0;\nfor(int i=1;i<n;i++) {\n	for(int j=a[i]-i;j<=n;j+=a[i]) {\n		if(j>=1) \n			if(((long)a[i]*a[j]==i+j)&&(i<j)) \n			c++;\n	}\n}\nSystem.out.println(c); \n}\n}\n},"brute force,implementation,math,number theory"
import java.io.*;\nimport java.util.*;\npublic class Solution {\n	public static void main(String[] args) throws  java.lang.Exception{\nScanner sc=new Scanner(System.in);\nint T=sc.nextInt();\nwhile(T-->0) {\n		int n=sc.nextInt();\n		int a[]=new int[n+1];\nfor(int i=1;i<=n;i++) {\n	a[i]=sc.nextInt();\n}\nlong c=0;\nfor(int i=1;i<n;i++) {\n	for(int j=a[i]-i;j<=n;j+=a[i]) {\n		if(j>=1) \n			if(((long)a[i]*a[j]==i+j)&&(i<j)) \n			c++;\n	}\n}\nSystem.out.println(c); \n}\n}\n},"brute force,implementation,math,number theory"
import java.io.*;\nimport java.util.*;\npublic class Solution {\n	public static void main(String[] args) throws  java.lang.Exception{\nScanner sc=new Scanner(System.in);\nint T=sc.nextInt();\nwhile(T-->0) {\n		int n=sc.nextInt();\n		int a[]=new int[n+1];\nfor(int i=1;i<=n;i++) {\n	a[i]=sc.nextInt();\n}\nlong c=0;\nfor(int i=1;i<n;i++) {\n	for(int j=a[i]-i;j<=n;j+=a[i]) {\n		if(j>=1) \n			if(((long)a[i]*a[j]==i+j)&&(i<j)) \n			c++;\n	}\n}\nSystem.out.println(c); \n}\n}\n},"brute force,implementation,math,number theory"
import java.io.*;\nimport java.util.*;\npublic class Solution {\n	public static void main(String[] args) throws  java.lang.Exception{\nScanner sc=new Scanner(System.in);\nint T=sc.nextInt();\nwhile(T-->0) {\n		int n=sc.nextInt();\n		int a[]=new int[n+1];\nfor(int i=1;i<=n;i++) {\n	a[i]=sc.nextInt();\n}\nlong c=0;\nfor(int i=1;i<n;i++) {\n	for(int j=a[i]-i;j<=n;j+=a[i]) {\n		if(j>=1) \n			if(((long)a[i]*a[j]==i+j)&&(i<j)) \n			c++;\n	}\n}\nSystem.out.println(c); \n}\n}\n},"brute force,implementation,math,number theory"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1537F extends PrintWriter {\n	CF1537F() { super(System.out); }\n	static class Scanner {\n		Scanner(InputStream in) { this.in = in; } InputStream in;\n		byte[] bb = new byte[1 << 15]; int i, n;\n		byte getc() {\n			if (i == n) {\n				i = n = 0;\n				try { n = in.read(bb); } catch (IOException e) {}\n			}\n			return i < n ? bb[i++] : 0;\n		}\n		int nextInt() {\n			byte c = 0; while (c <= ' ') c = getc();\n			boolean minus = c == '-'; if (minus) c = getc();\n			int a = 0; while (c > ' ') { a = a * 10 + c - '0'; c = getc(); }\n			return minus ? -a : a;\n		}\n	}\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1537F o = new CF1537F(); o.main(); o.flush();\n	}\n\n	int[] cc, eo; int[][] ej;\n	void append(int i, int j) {\n		int o = eo[i]++;\n		if (o >= 2 && (o & o - 1) == 0)\n			ej[i] = Arrays.copyOf(ej[i], o << 1);\n		ej[i][o] = j;\n	}\n	boolean dfs(int i, int c) {\n		if (cc[i] != 0)\n			return cc[i] == c;\n		cc[i] = c;\n		c = 3 - c;\n		for (int o = eo[i]; o-- > 0; ) {\n			int j = ej[i][o];\n			if (!dfs(j, c))\n				return false;\n		}\n		return true;\n	}\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int m = sc.nextInt();\n			int[] aa = new int[n];\n			for (int i = 0; i < n; i++)\n				aa[i] = sc.nextInt();\n			for (int i = 0; i < n; i++)\n				aa[i] -= sc.nextInt();\n			cc = new int[n];\n			eo = new int[n]; ej = new int[n][2];\n			for (int h = 0; h < m; h++) {\n				int i = sc.nextInt() - 1;\n				int j = sc.nextInt() - 1;\n				append(i, j);\n				append(j, i);\n			}\n			long a = 0;\n			if (!dfs(0, 1)) {\n				for (int i = 0; i < n; i++)\n					if (aa[i] % 2 != 0)\n						a ^= 1;\n			} else\n				for (int i = 0; i < n; i++)\n					a += cc[i] == 1 ? aa[i] : -aa[i];\n			println(a == 0 ? ""YES"" : ""NO"");\n		}\n	}\n}\n","constructive algorithms,dfs and similar,dsu,graphs,greedy,math"
"import java.util.*;\nimport java.io.*;\n\npublic class F726FigureFixing{\n		\n	void print(Object line){System.out.print(line);}\n	void println(){System.out.println();}\n	void println(Object line){System.out.println(line);}\n	int abs(int a){ return Math.abs(a);}\n	\n	static Scanner sc;\n	List<Integer> adj[];\n	int color[];\n	\n	boolean bipartite(int n){\n		\n		Arrays.fill(color, -1);\n		Queue<Integer> q = new LinkedList<>();\n		boolean bip = true;\n		\n		for(int i=0; i<n; i++){\n			if( color[i] != -1 ) continue;\n			q.add(i);\n			color[i] = 0;\n			\n			while(!q.isEmpty()){\n				int u = q.poll();\n				for(int v: adj[u]){\n					if( color[v] == -1){\n						color[v] = color[u] ^ 1;\n						q.add(v);\n					}\n					else bip &= color[u] != color[v];\n				}\n			}\n		}\n		return bip;\n	}\n	\n	@SuppressWarnings(""unchecked"")\n	void solve(){\n		int n = sc.nextInt(), m = sc.nextInt();\n		adj = new ArrayList[n];\n		for(int i=0; i<n; i++) adj[i] = new ArrayList<>();\n		\n		color = new int[n];\n		int v[] = new int[n];\n		int t[] = new int[n];\n		for(int i=0; i<n; i++) v[i] = sc.nextInt();\n		for(int i=0; i<n; i++) t[i] = sc.nextInt();\n		\n		long sum1 = 0, sum2 = 0;\n		for(int x: v) sum1 = (sum1+abs(x)) % 2;\n		for(int x: t) sum2 = (sum2+abs(x)) % 2;\n	\n		// add edges\n		for(int i=0; i<m; i++){\n			int x = sc.nextInt() - 1;\n			int y = sc.nextInt() - 1;\n			adj[x].add(y);\n			adj[y].add(x);\n		}\n		\n		if(sum1 != sum2) {\n			println(""NO"");\n			return;\n		}\n		\n		if( !bipartite(n) ){\n			println(""YES"");\n		}\n		else{\n			long arr[] = new long[2];\n			for(int i=0; i<n; i++){\n				arr[color[i]] += v[i] - t[i];\n			}\n			\n			if(arr[0] == arr[1]) println(""YES"");\n			else println(""NO"");\n		}\n	}\n	\n	public static void main(String args[])throws IOException{\n		sc = new Scanner(System.in);\n		\n		int tests = sc.nextInt();\n		F726FigureFixing f = new F726FigureFixing();\n		while( tests --> 0 ){\n			f.solve();\n		}\n	}\n}","constructive algorithms,dfs and similar,dsu,graphs,greedy,math"
"import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class CFPractice {\n\n	static long mod = 998244353; \n	\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		PrintWriter out = new PrintWriter(System.out);\n		int t = sc.nextInt();\n		for(int j = 0; j < t; j++) {\n			int n = sc.nextInt();\n			int m = sc.nextInt();\n			ArrayList<Node> nodes = new ArrayList<Node>();\n			\n			for(int i = 0; i < n; i++) {\n				Node no = new Node(i);\n				no.val = -sc.nextLong();\n				nodes.add(no);\n			}\n			long sum = 0;\n			for(int i = 0; i < n; i++) {\n				nodes.get(i).val += sc.nextLong();\n				sum += nodes.get(i).val;\n			}\n			\n			\n			\n			long[] sums = new long[2];\n				\n			for(int i = 0; i < m; i++) {\n				int u = sc.nextInt();\n				int v = sc.nextInt();\n				nodes.get(u-1).neighbors.add(nodes.get(v-1));\n				nodes.get(v-1).neighbors.add(nodes.get(u-1));\n		\n			}\n			if(Math.abs(sum) % 2 == 1) {\n				out.println(""NO"");\n			}\n			else {\n				\n				Deque<Node> dfs = new LinkedList<Node>();\n				dfs.add(nodes.get(0));\n				nodes.get(0).visited = true;\n				nodes.get(0).group = 0;\n				boolean bipartte = true;\n				while(! dfs.isEmpty()) {\n					Node next = dfs.pollFirst();\n					sums[next.group] += next.val;\n					for(Node node : next.neighbors) {\n						if(node.visited && node.group == next.group) {\n							bipartte = false;\n							dfs.clear();\n							break;\n						}\n						else if(!node.visited){\n							node.visited = true;\n							node.group = (next.group + 1)%2;\n							dfs.addLast(node);\n							\n						}\n					}\n				}\n				if(!bipartte) {\n					out.println(""YES"");\n				}\n				else if(sums[0] == sums[1]) {\n					out.println(""YES"");\n				}\n				else {\n					out.println(""NO"");\n				}\n			\n			}\n		\n		}\n		out.flush();\n		\n		\n	}\n	\n	\n	static class Node{\n		int id;\n		\n		ArrayList<Node> neighbors;\n		long val;\n		int group;\n		boolean visited;\n		\n		public Node(int id) {\n			this.id = id;\n			visited = false;\n			neighbors = new ArrayList<Node>();\n		}\n		\n		\n	}\n\n\n	\n			\n}\n	\n	\n	\n	\n	\n	\n	\n		\n		\n		\n		\n		\n		\n		\n		\n		\n		\n		\n		\n	\n	\n	\n	\n	\n	\n	\n		\n		\n		\n	\n	\n	\n	\n	\n\n	\n\n","constructive algorithms,dfs and similar,dsu,graphs,greedy,math"
"import java.io.*;\nimport java.util.*;\n\npublic class F{\n	static int n;\n	static List<Integer>[] adj;\n	static long[] v;\n	// If not bipartite, then just need to check if total sum is even.\n	// Else, if it is bipartite, check if bipartite sums are equal.\n	static int[] vis;\n	static boolean isBip;\n	\n	static void dfs(int i, int b) {\n		if (vis[i] != -1) {\n			if (b != vis[i]) isBip = false;\n			return;\n		}\n		vis[i] = b;\n		for (int x: adj[i]) {\n			dfs(x,(b+1)%2);\n		}\n	}\n	\n	public static void main(String[] args) throws IOException {\n		// br = new BufferedReader(new FileReader("".in""));\n		// out = new PrintWriter(new FileWriter("".out""));\n		//new Thread(null, new (), ""peepee"", 1<<28).start();\n		int t= readInt();\n		while(t-->0) {\n			// Resulting sums gonna match on the bipartite graph.\n			n =readInt();\n			int m = readInt();\n			adj = new List[n];\n			for (int i= 0 ; i < n; i++) adj[i] =new ArrayList<Integer>();\n			v = new long[n];\n			long sum = 0;\n			for (int i = 0; i < n; i++) {\n				v[i] =readLong();\n			}\n			for (int i = 0; i < n; i++) {\n				v[i] = readLong()-v[i];\n				sum += v[i];\n			}\n			for (int i = 0; i < m; i++) {\n				int x =readInt()-1;\n				int y =readInt()-1;\n				adj[x].add(y);\n				adj[y].add(x);\n			}\n			\n			if (sum % 2 != 0) out.println(""NO"");\n			else {\n				vis = new int[n];\n				Arrays.fill(vis, -1);\n				isBip = true;\n				dfs(0,0);\n				//System.out.println(isBip);\n				if (isBip) {\n					long s1 = 0, s2 = 0;\n					for (int i = 0; i < n; i++) {\n						if (vis[i] == 1) s1 += v[i];\n						else s2 += v[i];\n					}\n					//System.out.println(s1 + "" "" + s2);\n					out.println(s1==s2?""YES"":""NO"");\n				}\n				else {\n					// If t here is no cycle, there is no pipe.\n					// But if its not bipartite, MUST be an odd cycle somewhere.\n					out.println(""YES"");\n				}\n			}\n		}\n		out.close();\n	}\n	\n	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n	static StringTokenizer st = new StringTokenizer("""");\n	static String read() throws IOException{return st.hasMoreTokens() ? st.nextToken():(st = new StringTokenizer(br.readLine())).nextToken();}\n	static int readInt() throws IOException{return Integer.parseInt(read());}\n	static long readLong() throws IOException{return Long.parseLong(read());}\n	static double readDouble() throws IOException{return Double.parseDouble(read());}\n	\n}","constructive algorithms,dfs and similar,dsu,graphs,greedy,math"
"import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Math.max;\nimport static java.lang.System.arraycopy;\nimport static java.lang.System.exit;\nimport static java.util.Arrays.copyOf;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.util.StringTokenizer;\n\npublic class H {\n\n	static class IntList {\n\n		int data[] = new int[3];\n		int size = 0;\n\n		boolean isEmpty() {\n			return size == 0;\n		}\n\n		int size() {\n			return size;\n		}\n\n		int get(int index) {\n			if (index < 0 || index >= size) {\n				throw new IndexOutOfBoundsException();\n			}\n			return data[index];\n		}\n\n		void clear() {\n			size = 0;\n		}\n\n		void set(int index, int value) {\n			if (index < 0 || index >= size) {\n				throw new IndexOutOfBoundsException();\n			}\n			data[index] = value;\n		}\n\n		void expand() {\n			if (size >= data.length) {\n				data = copyOf(data, (data.length << 1) + 1);\n			}\n		}\n\n		void insert(int index, int value) {\n			if (index < 0 || index > size) {\n				throw new IndexOutOfBoundsException();\n			}\n			expand();\n			arraycopy(data, index, data, index + 1, size++ - index);\n			data[index] = value;\n		}\n\n		int delete(int index) {\n			if (index < 0 || index >= size) {\n				throw new IndexOutOfBoundsException();\n			}\n			int value = data[index];\n			arraycopy(data, index + 1, data, index, --size - index);\n			return value;\n		}\n\n		void push(int value) {\n			expand();\n			data[size++] = value;\n		}\n\n		int pop() {\n			if (size == 0) {\n				throw new NoSuchElementException();\n			}\n			return data[--size];\n		}\n\n		void unshift(int value) {\n			expand();\n			arraycopy(data, 0, data, 1, size++);\n			data[0] = value;\n		}\n\n		int shift() {\n			if (size == 0) {\n				throw new NoSuchElementException();\n			}\n			int value = data[0];\n			arraycopy(data, 1, data, 0, --size);\n			return value;\n		}\n	}\n\n	static void sort(int a[], int b[], int n) {\n		if (n == 0) {\n			return;\n		}\n		for (int i = 1; i < n; i++) {\n			int j = i;\n			int ca = a[i], cb = b[i];\n			do {\n				int nj = (j - 1) >> 1;\n				int na = a[nj];\n				if (ca >= na) {\n					break;\n				}\n				a[j] = na;\n				b[j] = b[nj];\n				j = nj;\n			} while (j != 0);\n			a[j] = ca;\n			b[j] = cb;\n		}\n		int ca = a[0], cb = b[0];\n		for (int i = n - 1; i > 0; i--) {\n			int j = 0;\n			while ((j << 1) + 2 + Integer.MIN_VALUE < i + Integer.MIN_VALUE) {\n				j <<= 1;\n				j += (a[j + 2] < a[j + 1]) ? 2 : 1;\n			}\n			if ((j << 1) + 2 == i) {\n				j = (j << 1) + 1;\n			}\n			int na = a[i], nb = b[i];\n			a[i] = ca;\n			b[i] = cb;\n			ca = na;\n			cb = nb;\n			while (j != 0 && a[j] > ca) {\n				j = (j - 1) >> 1;\n			}\n			while (j != 0) {\n				na = a[j];\n				nb = b[j];\n				a[j] = ca;\n				b[j] = cb;\n				ca = na;\n				cb = nb;\n				j = (j - 1) >> 1;\n			}\n		}\n		a[0] = ca;\n		b[0] = cb;\n	}\n\n	static IntList edges[];\n	static int dyn[][], ans;\n\n	static void solve() throws Exception {\n		int n = scanInt();\n		edges = new IntList[n];\n		for (int i = 0; i < n; i++) {\n			edges[i] = new IntList();\n		}\n		for (int i = 0; i < n - 1; i++) {\n			int a = scanInt() - 1, b = scanInt() - 1;\n			edges[a].push(b);\n			edges[b].push(a);\n		}\n		dyn = new int[n][];\n		dfs1(0, -1);\n		ans = 0;\n		dfs2(0, -1, 0);\n		out.println(ans);\n		out.flush();\n		int start = scanInt() - 1;\n		int ans[] = new int[2], ansPos = 0;\n		int s = start, spos = 0, startPos = 0, sprev = -1;\n		s: while (true) {\n			int see[] = edges[s].data, ses = edges[s].size;\n			while (true) {\n				if (spos >= ses) {\n					ans[ansPos++] = s;\n					if (ansPos == 2) {\n						break s;\n					}\n					s = start;\n					spos = startPos;\n					continue s;\n				}\n				int scur = see[spos];\n				++spos;\n				if (s == start) {\n					startPos = spos;\n				}\n				if (scur == sprev) {\n					continue;\n				}\n				int cur = scur, prev = s;\n				d: while (true) {\n					int cee[] = edges[cur].data, ces = edges[cur].size;\n					for (int j = 0;; j++) {\n						if (j >= ces) {\n							break d;\n						}\n						int next = cee[j];\n						if (next != prev) {\n							prev = cur;\n							cur = next;\n							break;\n						}\n					}\n				}\n				out.println(""? "" + (cur + 1));\n				out.flush();\n				int cres = scanInt() - 1;\n				if (cres == s) {\n					continue;\n				}\n				cur = scur;\n				prev = s;\n				while (true) {\n					if (cres == cur) {\n						s = cur;\n						sprev = prev;\n						spos = edges[s].data[0] == sprev ? 2 : 1;\n						continue s;\n					}\n					int cee[] = edges[cur].data, ces = edges[cur].size;\n					for (int j = 0;; j++) {\n						if (j >= ces) {\n							throw new AssertionError();\n						}\n						int next = cee[j];\n						if (next != prev) {\n							prev = cur;\n							cur = next;\n							break;\n						}\n					}\n				}\n			}\n		}\n		out.println(""! "" + (ans[0] + 1) + "" "" + (ans[1] + 1));\n	}\n\n	static int dfs1(int cur, int prev) {\n		IntList e = edges[cur];\n		int ee[] = e.data, es = e.size, d[] = dyn[cur] = new int[es];\n		for (int i = 0; i < es; i++) {\n			int next = ee[i];\n			d[i] = next == prev ? -1 : dfs1(next, cur);\n		}\n		sort(d, ee, es);\n		int res = 0;\n		if (prev < 0) {\n			for (int i = 0; i < es; i++) {\n				res = max(res, i + d[i]);\n			}\n		} else {\n			for (int i = 0; i < es - 1; i++) {\n				res = max(res, i + d[i]);\n			}\n		}\n		return res;\n	}\n\n	static void dfs2(int cur, int prev, int dv) {\n		IntList e = edges[cur];\n		int ee[] = e.data, es = e.size, d[] = dyn[cur];\n		if (prev >= 0) {\n			int i;\n			for (i = 0; i < es - 1 && d[i] > dv; i++) { }\n			arraycopy(ee, i, ee, i + 1, es - i - 1);\n			ee[i] = prev;\n			arraycopy(d, i, d, i + 1, es - i - 1);\n			d[i] = dv;\n		}\n		int pdyn[] = new int[es], sdyn[] = new int[es];\n		for (int i = 0; i < es - 1; i++) {\n			pdyn[i + 1] = max(pdyn[i], i + d[i]);\n		}\n		for (int i = es - 1; i > 0; i--) {\n			sdyn[i - 1] = max(sdyn[i], i + d[i] - 1);\n		}\n		for (int i = 0; i < es; i++) {\n			int next = ee[i];\n			if (next != prev) {\n				dfs2(next, cur, max(pdyn[i], sdyn[i]));\n			}\n		}\n		if (es > 0) {\n			ans = max(ans, es == 1 ? d[0] + 1 : d[0] + sdyn[0] + 2);\n		}\n	}\n\n	static int scanInt() throws IOException {\n		return parseInt(scanString());\n	}\n\n	static long scanLong() throws IOException {\n		return parseLong(scanString());\n	}\n\n	static String scanString() throws IOException {\n		while (tok == null || !tok.hasMoreTokens()) {\n			tok = new StringTokenizer(in.readLine());\n		}\n		return tok.nextToken();\n	}\n\n	static BufferedReader in;\n	static PrintWriter out;\n	static StringTokenizer tok;\n\n	public static void main(String[] args) {\n		try {\n			in = new BufferedReader(new InputStreamReader(System.in));\n			out = new PrintWriter(System.out);\n			solve();\n			in.close();\n			out.close();\n		} catch (Throwable e) {\n			e.printStackTrace();\n			exit(1);\n		}\n	}\n}","constructive algorithms,dp,graphs,interactive,sortings,trees"
"//package round723;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class F {\n	InputStream is;\n	FastWriter out;\n	String INPUT = """";\n\n	static boolean debug = false;\n//	Random gen = new Random(114521);\n//	public static int[] shuffle(int n, Random gen){ int[] a = new int[n]; for(int i = 0;i < n;i++)a[i] = i; for(int i = 0;i < n;i++){ int ind = gen.nextInt(n-i)+i; int d = a[i]; a[i] = a[ind]; a[ind] = d; } return a; }\n	public static int[] q;// = shuffle(20, gen);\n\n	int ct;\n\n	void solve()\n	{\n//		assert q[0] < q[1];\n		for(int T = ni();T > 0;T--){\n			go();\n			ni();\n		}\n	}\n\n	int get(int a, int b, int c)\n	{\n		if(debug){\n			int[] o = {Math.abs(q[a] - q[b]), Math.abs(q[b] - q[c]), Math.abs(q[c] - q[a])};\n			Arrays.sort(o);\n			if(++ct > 2*q.length+420){\n				assert false;\n			}\n			return o[1];\n		}\n\n		out.println(""? "" + (a+1) + "" "" + (b+1) + "" "" + (c+1));\n		out.flush();\n		return ni();\n	}\n\n	void go()\n	{\n		int n = ni();\n		int[] ds = new int[n];\n		for(int i = 2;i < n;i++){\n			ds[i] = get(0, 1, i);\n		}\n\n		int min = n+5;\n		int mf = 0;\n		int max = -1;\n		for(int i = 2;i < n;i++){\n			max = Math.max(max, ds[i]);\n			if(ds[i] < min){\n				min = ds[i];\n				mf = 1;\n			}else if(ds[i] == min){\n				mf++;\n			}\n		}\n		int cha;\n		if(min == 1){\n			assert 1 <= mf && mf <= 2;\n			if(mf == 2){\n				cha = 1;\n			}else if(max == n-3) {\n				cha = 1;\n			}else{\n				cha = 2;\n				// ABx..\n				// ..AxB..\n			}\n		}else {\n			cha = mf == 1 ? 2*min : 2 * min - 1;\n		}\n//		tr(cha, min, mf);\n\n		if(max >= cha + 2){\n			List<Integer> amax = new ArrayList<>();\n			List<Integer> amax2 = new ArrayList<>();\n			for(int i = 2;i < n;i++){\n				if(ds[i] == max){\n					amax.add(i);\n				}\n				if(ds[i] == max-1){\n					amax2.add(i);\n				}\n			}\n			if(amax.size() == 2){\n				assert amax2.size() == 2;\n				for(int i = 0;i < 2;i++){\n					for(int j = 0;j < 2;j++){\n						if(get(amax.get(i), amax2.get(j), 0) == (n-cha-1)/2-1){\n							// i:min, j:min+1\n							frommin(amax.get(i), amax2.get(j), n);\n							return;\n						}\n					}\n				}\n			}else if(amax2.size() == 2){\n				for(int j = 0;j < 2;j++){\n					if(get(amax.get(0), amax2.get(j), 0) == (n-cha-2)/2){\n						// i:min, j:min+1\n						frommin(amax.get(0), amax2.get(j), n);\n						return;\n					}\n				}\n				for(int j = 0;j < 2;j++){\n					if(get(amax.get(0), amax2.get(j), 1) == (n-cha-2)/2){\n						// i:max, j:max-1\n						frommax(amax.get(0), amax2.get(j), n);\n						return;\n					}\n				}\n			}\n			if(get(amax.get(0), amax2.get(0), 0) < get(amax.get(0), amax2.get(0), 1)){\n				frommin(amax.get(0), amax2.get(0), n);\n			}else{\n				frommax(amax.get(0), amax2.get(0), n);\n			}\n			return;\n		}\n\n		assert cha >= 4;\n		List<Integer> d1 = new ArrayList<>();\n		List<Integer> d2 = new ArrayList<>();\n		for(int i = 2;i < n;i++){\n			if(ds[i] == cha-1)d1.add(i);\n			if(ds[i] == cha-2)d2.add(i);\n		}\n		int nei = -1;\n		out:\n		for(int u : d1){\n			for(int v : d2){\n				if(get(u, v, 0) == 1){\n					// 0 u v\n					nei = u;\n					break out;\n				}\n			}\n		}\n//		tr(d1, d2, cha);\n		assert nei != -1;\n\n		int[][] bu = new int[n+1][2];\n		int[] bp = new int[n+1];\n		for(int i = 2;i < n;i++){\n			if(ds[i] < cha){\n				bu[ds[i]][bp[ds[i]]++] = i;\n			}\n		}\n		int[] from0 = new int[n];\n		Arrays.fill(from0, Integer.MIN_VALUE);\n		from0[0] = 0;\n		from0[1] = cha;\n		for(int i = 1;i < cha;i++){\n			if(bp[i] == 0)continue;\n			if(bp[i] == 1){\n				from0[bu[i][0]] = cha/2;\n			}else{\n				assert bp[i] == 2;\n				int g = nei == bu[i][0] ? 0 : get(0, nei, bu[i][0]);\n				from0[bu[i][0]] = g + 1;\n				from0[bu[i][1]] = cha - (g + 1);\n			}\n		}\n\n		int[] es = new int[n];\n		for(int i = 2;i < n;i++){\n			if(ds[i] >= cha){\n				es[i] = get(0, nei, i);\n				if(es[i] <= cha-1){\n					from0[i] = -es[i];\n				}else{\n					bu[es[i]][bp[es[i]]++] = i;\n				}\n			}\n		}\n		int nei2 = -1;\n		for(int i = 0;i < n;i++){\n			if(from0[i] == 2){\n				nei2 = i;\n			}\n		}\n		assert nei2 != -1;\n\n		int dir = 0;\n		for(int i = cha;i <= n;i++){\n			if(bp[i] == 0)continue;\n			if(dir == 1){\n				assert bp[i] == 1;\n				from0[bu[i][0]] = es[bu[i][0]] + 1;\n				continue;\n			}else if(dir == -1){\n				assert bp[i] == 1;\n				from0[bu[i][0]] = -es[bu[i][0]];\n				continue;\n			}\n			int g = get(nei, nei2, bu[i][0]);\n			if(g < es[bu[i][0]]){\n				from0[bu[i][0]] = es[bu[i][0]] + 1;\n				if(bp[i] == 2){\n					from0[bu[i][1]] = -es[bu[i][0]];\n				}else{\n					dir = 1;\n				}\n			}else{\n				from0[bu[i][0]] = -es[bu[i][0]];\n				if(bp[i] == 2){\n					from0[bu[i][1]] = es[bu[i][0]] + 1;\n				}else{\n					dir = -1;\n				}\n			}\n		}\n\n		int gmin = 0;\n		for(int v : from0){\n			gmin = Math.min(gmin, v);\n		}\n//		tr(from0);\n		assert gmin != Integer.MIN_VALUE;\n		out.print(""! "");\n		for(int i = 0;i < n;i++){\n			out.print(from0[i] - gmin + 1 + "" "");\n		}\n		out.println();\n		out.flush();\n	}\n\n\n	void frommin(int a, int b, int n)\n	{\n		int[] ans = new int[n];\n		ans[a] = 0;\n		ans[b] = 1;\n		for(int i = 0;i < n;i++){\n			if(i == a || i == b)continue;\n			ans[i] = get(a, b, i) + 1;\n		}\n		out.print(""! "");\n		for(int i = 0;i < n;i++){\n			out.print(ans[i] + 1 + "" "");\n		}\n		out.println();\n		out.flush();\n	}\n\n	void frommax(int a, int b, int n)\n	{\n		int[] ans = new int[n];\n		ans[a] = n-1;\n		ans[b] = n-2;\n		for(int i = 0;i < n;i++){\n			if(i == a || i == b)continue;\n			ans[i] = n-get(a, b, i) - 2;\n		}\n		out.print(""! "");\n		for(int i = 0;i < n;i++){\n			out.print(ans[i] + 1 + "" "");\n		}\n		out.println();\n		out.flush();\n	}\n\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new FastWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new F().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n\n	private long[] nal(int n)\n	{\n		long[] a = new long[n];\n		for(int i = 0;i < n;i++)a[i] = nl();\n		return a;\n	}\n\n	private char[][] nm(int n, int m) {\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n\n	private int[][] nmi(int n, int m) {\n		int[][] map = new int[n][];\n		for(int i = 0;i < n;i++)map[i] = na(m);\n		return map;\n	}\n\n	private int ni() { return (int)nl(); }\n\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n\n	public static class FastWriter\n	{\n		private static final int BUF_SIZE = 1<<13;\n		private final byte[] buf = new byte[BUF_SIZE];\n		private final OutputStream out;\n		private int ptr = 0;\n\n		private FastWriter(){out = null;}\n\n		public FastWriter(OutputStream os)\n		{\n			this.out = os;\n		}\n\n		public FastWriter(String path)\n		{\n			try {\n				this.out = new FileOutputStream(path);\n			} catch (FileNotFoundException e) {\n				throw new RuntimeException(""FastWriter"");\n			}\n		}\n\n		public FastWriter write(byte b)\n		{\n			buf[ptr++] = b;\n			if(ptr == BUF_SIZE)innerflush();\n			return this;\n		}\n\n		public FastWriter write(char c)\n		{\n			return write((byte)c);\n		}\n\n		public FastWriter write(char[] s)\n		{\n			for(char c : s){\n				buf[ptr++] = (byte)c;\n				if(ptr == BUF_SIZE)innerflush();\n			}\n			return this;\n		}\n\n		public FastWriter write(String s)\n		{\n			s.chars().forEach(c -> {\n				buf[ptr++] = (byte)c;\n				if(ptr == BUF_SIZE)innerflush();\n			});\n			return this;\n		}\n\n		private static int countDigits(int l) {\n			if (l >= 1000000000) return 10;\n			if (l >= 100000000) return 9;\n			if (l >= 10000000) return 8;\n			if (l >= 1000000) return 7;\n			if (l >= 100000) return 6;\n			if (l >= 10000) return 5;\n			if (l >= 1000) return 4;\n			if (l >= 100) return 3;\n			if (l >= 10) return 2;\n			return 1;\n		}\n\n		public FastWriter write(int x)\n		{\n			if(x == Integer.MIN_VALUE){\n				return write((long)x);\n			}\n			if(ptr + 12 >= BUF_SIZE)innerflush();\n			if(x < 0){\n				write((byte)'-');\n				x = -x;\n			}\n			int d = countDigits(x);\n			for(int i = ptr + d - 1;i >= ptr;i--){\n				buf[i] = (byte)('0'+x%10);\n				x /= 10;\n			}\n			ptr += d;\n			return this;\n		}\n\n		private static int countDigits(long l) {\n			if (l >= 1000000000000000000L) return 19;\n			if (l >= 100000000000000000L) return 18;\n			if (l >= 10000000000000000L) return 17;\n			if (l >= 1000000000000000L) return 16;\n			if (l >= 100000000000000L) return 15;\n			if (l >= 10000000000000L) return 14;\n			if (l >= 1000000000000L) return 13;\n			if (l >= 100000000000L) return 12;\n			if (l >= 10000000000L) return 11;\n			if (l >= 1000000000L) return 10;\n			if (l >= 100000000L) return 9;\n			if (l >= 10000000L) return 8;\n			if (l >= 1000000L) return 7;\n			if (l >= 100000L) return 6;\n			if (l >= 10000L) return 5;\n			if (l >= 1000L) return 4;\n			if (l >= 100L) return 3;\n			if (l >= 10L) return 2;\n			return 1;\n		}\n\n		public FastWriter write(long x)\n		{\n			if(x == Long.MIN_VALUE){\n				return write("""" + x);\n			}\n			if(ptr + 21 >= BUF_SIZE)innerflush();\n			if(x < 0){\n				write((byte)'-');\n				x = -x;\n			}\n			int d = countDigits(x);\n			for(int i = ptr + d - 1;i >= ptr;i--){\n				buf[i] = (byte)('0'+x%10);\n				x /= 10;\n			}\n			ptr += d;\n			return this;\n		}\n\n		public FastWriter write(double x, int precision)\n		{\n			if(x < 0){\n				write('-');\n				x = -x;\n			}\n			x += Math.pow(10, -precision)/2;\n			//		if(x < 0){ x = 0; }\n			write((long)x).write(""."");\n			x -= (long)x;\n			for(int i = 0;i < precision;i++){\n				x *= 10;\n				write((char)('0'+(int)x));\n				x -= (int)x;\n			}\n			return this;\n		}\n\n		public FastWriter writeln(char c){\n			return write(c).writeln();\n		}\n\n		public FastWriter writeln(int x){\n			return write(x).writeln();\n		}\n\n		public FastWriter writeln(long x){\n			return write(x).writeln();\n		}\n\n		public FastWriter writeln(double x, int precision){\n			return write(x, precision).writeln();\n		}\n\n		public FastWriter write(int... xs)\n		{\n			boolean first = true;\n			for(int x : xs) {\n				if (!first) write(' ');\n				first = false;\n				write(x);\n			}\n			return this;\n		}\n\n		public FastWriter write(long... xs)\n		{\n			boolean first = true;\n			for(long x : xs) {\n				if (!first) write(' ');\n				first = false;\n				write(x);\n			}\n			return this;\n		}\n\n		public FastWriter writeln()\n		{\n			return write((byte)'\n');\n		}\n\n		public FastWriter writeln(int... xs)\n		{\n			return write(xs).writeln();\n		}\n\n		public FastWriter writeln(long... xs)\n		{\n			return write(xs).writeln();\n		}\n\n		public FastWriter writeln(char[] line)\n		{\n			return write(line).writeln();\n		}\n\n		public FastWriter writeln(char[]... map)\n		{\n			for(char[] line : map)write(line).writeln();\n			return this;\n		}\n\n		public FastWriter writeln(String s)\n		{\n			return write(s).writeln();\n		}\n\n		private void innerflush()\n		{\n			try {\n				out.write(buf, 0, ptr);\n				ptr = 0;\n			} catch (IOException e) {\n				throw new RuntimeException(""innerflush"");\n			}\n		}\n\n		public void flush()\n		{\n			innerflush();\n			try {\n				out.flush();\n			} catch (IOException e) {\n				throw new RuntimeException(""flush"");\n			}\n		}\n\n		public FastWriter print(byte b) { return write(b); }\n		public FastWriter print(char c) { return write(c); }\n		public FastWriter print(char[] s) { return write(s); }\n		public FastWriter print(String s) { return write(s); }\n		public FastWriter print(int x) { return write(x); }\n		public FastWriter print(long x) { return write(x); }\n		public FastWriter print(double x, int precision) { return write(x, precision); }\n		public FastWriter println(char c){ return writeln(c); }\n		public FastWriter println(int x){ return writeln(x); }\n		public FastWriter println(long x){ return writeln(x); }\n		public FastWriter println(double x, int precision){ return writeln(x, precision); }\n		public FastWriter print(int... xs) { return write(xs); }\n		public FastWriter print(long... xs) { return write(xs); }\n		public FastWriter println(int... xs) { return writeln(xs); }\n		public FastWriter println(long... xs) { return writeln(xs); }\n		public FastWriter println(char[] line) { return writeln(line); }\n		public FastWriter println(char[]... map) { return writeln(map); }\n		public FastWriter println(String s) { return writeln(s); }\n		public FastWriter println() { return writeln(); }\n	}\n\n	public void trnz(int... o)\n	{\n		for(int i = 0;i < o.length;i++)if(o[i] != 0)System.out.print(i+"":""+o[i]+"" "");\n		System.out.println();\n	}\n\n	// print ids which are 1\n	public void trt(long... o)\n	{\n		Queue<Integer> stands = new ArrayDeque<>();\n		for(int i = 0;i < o.length;i++){\n			for(long x = o[i];x != 0;x &= x-1)stands.add(i<<6|Long.numberOfTrailingZeros(x));\n		}\n		System.out.println(stands);\n	}\n\n	public void tf(boolean... r)\n	{\n		for(boolean x : r)System.out.print(x?'#':'.');\n		System.out.println();\n	}\n\n	public void tf(boolean[]... b)\n	{\n		for(boolean[] r : b) {\n			for(boolean x : r)System.out.print(x?'#':'.');\n			System.out.println();\n		}\n		System.out.println();\n	}\n\n	public void tf(long[]... b)\n	{\n		if(INPUT.length() != 0) {\n			for (long[] r : b) {\n				for (long x : r) {\n					for (int i = 0; i < 64; i++) {\n						System.out.print(x << ~i < 0 ? '#' : '.');\n					}\n				}\n				System.out.println();\n			}\n			System.out.println();\n		}\n	}\n\n	public void tf(long... b)\n	{\n		if(INPUT.length() != 0) {\n			for (long x : b) {\n				for (int i = 0; i < 64; i++) {\n					System.out.print(x << ~i < 0 ? '#' : '.');\n				}\n			}\n			System.out.println();\n		}\n	}\n\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","constructive algorithms,interactive,probabilities"
"import java.io.*;\nimport java.util.*;\n \npublic class F {\n	InputStream is;\n	FastWriter out;\n	String INPUT = """";\n \n	static boolean debug = false;\n//	Random gen = new Random(114521);\n//	public static int[] shuffle(int n, Random gen){ int[] a = new int[n]; for(int i = 0;i < n;i++)a[i] = i; for(int i = 0;i < n;i++){ int ind = gen.nextInt(n-i)+i; int d = a[i]; a[i] = a[ind]; a[ind] = d; } return a; }\n	public static int[] q;// = shuffle(20, gen);\n \n	int ct;\n \n	void solve()\n	{\n//		assert q[0] < q[1];\n		for(int T = ni();T > 0;T--){\n			go();\n			ni();\n		}\n	}\n \n	int get(int a, int b, int c)\n	{\n		if(debug){\n			int[] o = {Math.abs(q[a] - q[b]), Math.abs(q[b] - q[c]), Math.abs(q[c] - q[a])};\n			Arrays.sort(o);\n			if(++ct > 2*q.length+420){\n				assert false;\n			}\n			return o[1];\n		}\n \n		out.println(""? "" + (a+1) + "" "" + (b+1) + "" "" + (c+1));\n		out.flush();\n		return ni();\n	}\n \n	void go()\n	{\n		int n = ni();\n		int[] ds = new int[n];\n		for(int i = 2;i < n;i++){\n			ds[i] = get(0, 1, i);\n		}\n \n		int min = n+5;\n		int mf = 0;\n		int max = -1;\n		for(int i = 2;i < n;i++){\n			max = Math.max(max, ds[i]);\n			if(ds[i] < min){\n				min = ds[i];\n				mf = 1;\n			}else if(ds[i] == min){\n				mf++;\n			}\n		}\n		int cha;\n		if(min == 1){\n			assert 1 <= mf && mf <= 2;\n			if(mf == 2){\n				cha = 1;\n			}else if(max == n-3) {\n				cha = 1;\n			}else{\n				cha = 2;\n				// ABx..\n				// ..AxB..\n			}\n		}else {\n			cha = mf == 1 ? 2*min : 2 * min - 1;\n		}\n//		tr(cha, min, mf);\n \n		if(max >= cha + 2){\n			List<Integer> amax = new ArrayList<>();\n			List<Integer> amax2 = new ArrayList<>();\n			for(int i = 2;i < n;i++){\n				if(ds[i] == max){\n					amax.add(i);\n				}\n				if(ds[i] == max-1){\n					amax2.add(i);\n				}\n			}\n			if(amax.size() == 2){\n				assert amax2.size() == 2;\n				for(int i = 0;i < 2;i++){\n					for(int j = 0;j < 2;j++){\n						if(get(amax.get(i), amax2.get(j), 0) == (n-cha-1)/2-1){\n							// i:min, j:min+1\n							frommin(amax.get(i), amax2.get(j), n);\n							return;\n						}\n					}\n				}\n			}else if(amax2.size() == 2){\n				for(int j = 0;j < 2;j++){\n					if(get(amax.get(0), amax2.get(j), 0) == (n-cha-2)/2){\n						// i:min, j:min+1\n						frommin(amax.get(0), amax2.get(j), n);\n						return;\n					}\n				}\n				for(int j = 0;j < 2;j++){\n					if(get(amax.get(0), amax2.get(j), 1) == (n-cha-2)/2){\n						// i:max, j:max-1\n						frommax(amax.get(0), amax2.get(j), n);\n						return;\n					}\n				}\n			}\n			if(get(amax.get(0), amax2.get(0), 0) < get(amax.get(0), amax2.get(0), 1)){\n				frommin(amax.get(0), amax2.get(0), n);\n			}else{\n				frommax(amax.get(0), amax2.get(0), n);\n			}\n			return;\n		}\n \n		assert cha >= 4;\n		List<Integer> d1 = new ArrayList<>();\n		List<Integer> d2 = new ArrayList<>();\n		for(int i = 2;i < n;i++){\n			if(ds[i] == cha-1)d1.add(i);\n			if(ds[i] == cha-2)d2.add(i);\n		}\n		int nei = -1;\n		out:\n		for(int u : d1){\n			for(int v : d2){\n				if(get(u, v, 0) == 1){\n					// 0 u v\n					nei = u;\n					break out;\n				}\n			}\n		}\n//		tr(d1, d2, cha);\n		assert nei != -1;\n \n		int[][] bu = new int[n+1][2];\n		int[] bp = new int[n+1];\n		for(int i = 2;i < n;i++){\n			if(ds[i] < cha){\n				bu[ds[i]][bp[ds[i]]++] = i;\n			}\n		}\n		int[] from0 = new int[n];\n		Arrays.fill(from0, Integer.MIN_VALUE);\n		from0[0] = 0;\n		from0[1] = cha;\n		for(int i = 1;i < cha;i++){\n			if(bp[i] == 0)continue;\n			if(bp[i] == 1){\n				from0[bu[i][0]] = cha/2;\n			}else{\n				assert bp[i] == 2;\n				int g = nei == bu[i][0] ? 0 : get(0, nei, bu[i][0]);\n				from0[bu[i][0]] = g + 1;\n				from0[bu[i][1]] = cha - (g + 1);\n			}\n		}\n \n		int[] es = new int[n];\n		for(int i = 2;i < n;i++){\n			if(ds[i] >= cha){\n				es[i] = get(0, nei, i);\n				if(es[i] <= cha-1){\n					from0[i] = -es[i];\n				}else{\n					bu[es[i]][bp[es[i]]++] = i;\n				}\n			}\n		}\n		int nei2 = -1;\n		for(int i = 0;i < n;i++){\n			if(from0[i] == 2){\n				nei2 = i;\n			}\n		}\n		assert nei2 != -1;\n \n		int dir = 0;\n		for(int i = cha;i <= n;i++){\n			if(bp[i] == 0)continue;\n			if(dir == 1){\n				assert bp[i] == 1;\n				from0[bu[i][0]] = es[bu[i][0]] + 1;\n				continue;\n			}else if(dir == -1){\n				assert bp[i] == 1;\n				from0[bu[i][0]] = -es[bu[i][0]];\n				continue;\n			}\n			int g = get(nei, nei2, bu[i][0]);\n			if(g < es[bu[i][0]]){\n				from0[bu[i][0]] = es[bu[i][0]] + 1;\n				if(bp[i] == 2){\n					from0[bu[i][1]] = -es[bu[i][0]];\n				}else{\n					dir = 1;\n				}\n			}else{\n				from0[bu[i][0]] = -es[bu[i][0]];\n				if(bp[i] == 2){\n					from0[bu[i][1]] = es[bu[i][0]] + 1;\n				}else{\n					dir = -1;\n				}\n			}\n		}\n \n		int gmin = 0;\n		for(int v : from0){\n			gmin = Math.min(gmin, v);\n		}\n//		tr(from0);\n		assert gmin != Integer.MIN_VALUE;\n		out.print(""! "");\n		for(int i = 0;i < n;i++){\n			out.print(from0[i] - gmin + 1 + "" "");\n		}\n		out.println();\n		out.flush();\n	}\n \n \n	void frommin(int a, int b, int n)\n	{\n		int[] ans = new int[n];\n		ans[a] = 0;\n		ans[b] = 1;\n		for(int i = 0;i < n;i++){\n			if(i == a || i == b)continue;\n			ans[i] = get(a, b, i) + 1;\n		}\n		out.print(""! "");\n		for(int i = 0;i < n;i++){\n			out.print(ans[i] + 1 + "" "");\n		}\n		out.println();\n		out.flush();\n	}\n \n	void frommax(int a, int b, int n)\n	{\n		int[] ans = new int[n];\n		ans[a] = n-1;\n		ans[b] = n-2;\n		for(int i = 0;i < n;i++){\n			if(i == a || i == b)continue;\n			ans[i] = n-get(a, b, i) - 2;\n		}\n		out.print(""! "");\n		for(int i = 0;i < n;i++){\n			out.print(ans[i] + 1 + "" "");\n		}\n		out.println();\n		out.flush();\n	}\n \n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new FastWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new F().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n \n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n \n	private long[] nal(int n)\n	{\n		long[] a = new long[n];\n		for(int i = 0;i < n;i++)a[i] = nl();\n		return a;\n	}\n \n	private char[][] nm(int n, int m) {\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n \n	private int[][] nmi(int n, int m) {\n		int[][] map = new int[n][];\n		for(int i = 0;i < n;i++)map[i] = na(m);\n		return map;\n	}\n \n	private int ni() { return (int)nl(); }\n \n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n \n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n \n	public static class FastWriter\n	{\n		private static final int BUF_SIZE = 1<<13;\n		private final byte[] buf = new byte[BUF_SIZE];\n		private final OutputStream out;\n		private int ptr = 0;\n \n		private FastWriter(){out = null;}\n \n		public FastWriter(OutputStream os)\n		{\n			this.out = os;\n		}\n \n		public FastWriter(String path)\n		{\n			try {\n				this.out = new FileOutputStream(path);\n			} catch (FileNotFoundException e) {\n				throw new RuntimeException(""FastWriter"");\n			}\n		}\n \n		public FastWriter write(byte b)\n		{\n			buf[ptr++] = b;\n			if(ptr == BUF_SIZE)innerflush();\n			return this;\n		}\n \n		public FastWriter write(char c)\n		{\n			return write((byte)c);\n		}\n \n		public FastWriter write(char[] s)\n		{\n			for(char c : s){\n				buf[ptr++] = (byte)c;\n				if(ptr == BUF_SIZE)innerflush();\n			}\n			return this;\n		}\n \n		public FastWriter write(String s)\n		{\n			s.chars().forEach(c -> {\n				buf[ptr++] = (byte)c;\n				if(ptr == BUF_SIZE)innerflush();\n			});\n			return this;\n		}\n \n		private static int countDigits(int l) {\n			if (l >= 1000000000) return 10;\n			if (l >= 100000000) return 9;\n			if (l >= 10000000) return 8;\n			if (l >= 1000000) return 7;\n			if (l >= 100000) return 6;\n			if (l >= 10000) return 5;\n			if (l >= 1000) return 4;\n			if (l >= 100) return 3;\n			if (l >= 10) return 2;\n			return 1;\n		}\n \n		public FastWriter write(int x)\n		{\n			if(x == Integer.MIN_VALUE){\n				return write((long)x);\n			}\n			if(ptr + 12 >= BUF_SIZE)innerflush();\n			if(x < 0){\n				write((byte)'-');\n				x = -x;\n			}\n			int d = countDigits(x);\n			for(int i = ptr + d - 1;i >= ptr;i--){\n				buf[i] = (byte)('0'+x%10);\n				x /= 10;\n			}\n			ptr += d;\n			return this;\n		}\n \n		private static int countDigits(long l) {\n			if (l >= 1000000000000000000L) return 19;\n			if (l >= 100000000000000000L) return 18;\n			if (l >= 10000000000000000L) return 17;\n			if (l >= 1000000000000000L) return 16;\n			if (l >= 100000000000000L) return 15;\n			if (l >= 10000000000000L) return 14;\n			if (l >= 1000000000000L) return 13;\n			if (l >= 100000000000L) return 12;\n			if (l >= 10000000000L) return 11;\n			if (l >= 1000000000L) return 10;\n			if (l >= 100000000L) return 9;\n			if (l >= 10000000L) return 8;\n			if (l >= 1000000L) return 7;\n			if (l >= 100000L) return 6;\n			if (l >= 10000L) return 5;\n			if (l >= 1000L) return 4;\n			if (l >= 100L) return 3;\n			if (l >= 10L) return 2;\n			return 1;\n		}\n \n		public FastWriter write(long x)\n		{\n			if(x == Long.MIN_VALUE){\n				return write("""" + x);\n			}\n			if(ptr + 21 >= BUF_SIZE)innerflush();\n			if(x < 0){\n				write((byte)'-');\n				x = -x;\n			}\n			int d = countDigits(x);\n			for(int i = ptr + d - 1;i >= ptr;i--){\n				buf[i] = (byte)('0'+x%10);\n				x /= 10;\n			}\n			ptr += d;\n			return this;\n		}\n \n		public FastWriter write(double x, int precision)\n		{\n			if(x < 0){\n				write('-');\n				x = -x;\n			}\n			x += Math.pow(10, -precision)/2;\n			//		if(x < 0){ x = 0; }\n			write((long)x).write(""."");\n			x -= (long)x;\n			for(int i = 0;i < precision;i++){\n				x *= 10;\n				write((char)('0'+(int)x));\n				x -= (int)x;\n			}\n			return this;\n		}\n \n		public FastWriter writeln(char c){\n			return write(c).writeln();\n		}\n \n		public FastWriter writeln(int x){\n			return write(x).writeln();\n		}\n \n		public FastWriter writeln(long x){\n			return write(x).writeln();\n		}\n \n		public FastWriter writeln(double x, int precision){\n			return write(x, precision).writeln();\n		}\n \n		public FastWriter write(int... xs)\n		{\n			boolean first = true;\n			for(int x : xs) {\n				if (!first) write(' ');\n				first = false;\n				write(x);\n			}\n			return this;\n		}\n \n		public FastWriter write(long... xs)\n		{\n			boolean first = true;\n			for(long x : xs) {\n				if (!first) write(' ');\n				first = false;\n				write(x);\n			}\n			return this;\n		}\n \n		public FastWriter writeln()\n		{\n			return write((byte)'\n');\n		}\n \n		public FastWriter writeln(int... xs)\n		{\n			return write(xs).writeln();\n		}\n \n		public FastWriter writeln(long... xs)\n		{\n			return write(xs).writeln();\n		}\n \n		public FastWriter writeln(char[] line)\n		{\n			return write(line).writeln();\n		}\n \n		public FastWriter writeln(char[]... map)\n		{\n			for(char[] line : map)write(line).writeln();\n			return this;\n		}\n \n		public FastWriter writeln(String s)\n		{\n			return write(s).writeln();\n		}\n \n		private void innerflush()\n		{\n			try {\n				out.write(buf, 0, ptr);\n				ptr = 0;\n			} catch (IOException e) {\n				throw new RuntimeException(""innerflush"");\n			}\n		}\n \n		public void flush()\n		{\n			innerflush();\n			try {\n				out.flush();\n			} catch (IOException e) {\n				throw new RuntimeException(""flush"");\n			}\n		}\n \n		public FastWriter print(byte b) { return write(b); }\n		public FastWriter print(char c) { return write(c); }\n		public FastWriter print(char[] s) { return write(s); }\n		public FastWriter print(String s) { return write(s); }\n		public FastWriter print(int x) { return write(x); }\n		public FastWriter print(long x) { return write(x); }\n		public FastWriter print(double x, int precision) { return write(x, precision); }\n		public FastWriter println(char c){ return writeln(c); }\n		public FastWriter println(int x){ return writeln(x); }\n		public FastWriter println(long x){ return writeln(x); }\n		public FastWriter println(double x, int precision){ return writeln(x, precision); }\n		public FastWriter print(int... xs) { return write(xs); }\n		public FastWriter print(long... xs) { return write(xs); }\n		public FastWriter println(int... xs) { return writeln(xs); }\n		public FastWriter println(long... xs) { return writeln(xs); }\n		public FastWriter println(char[] line) { return writeln(line); }\n		public FastWriter println(char[]... map) { return writeln(map); }\n		public FastWriter println(String s) { return writeln(s); }\n		public FastWriter println() { return writeln(); }\n	}\n \n	public void trnz(int... o)\n	{\n		for(int i = 0;i < o.length;i++)if(o[i] != 0)System.out.print(i+"":""+o[i]+"" "");\n		System.out.println();\n	}\n \n	// print ids which are 1\n	public void trt(long... o)\n	{\n		Queue<Integer> stands = new ArrayDeque<>();\n		for(int i = 0;i < o.length;i++){\n			for(long x = o[i];x != 0;x &= x-1)stands.add(i<<6|Long.numberOfTrailingZeros(x));\n		}\n		System.out.println(stands);\n	}\n \n	public void tf(boolean... r)\n	{\n		for(boolean x : r)System.out.print(x?'#':'.');\n		System.out.println();\n	}\n \n	public void tf(boolean[]... b)\n	{\n		for(boolean[] r : b) {\n			for(boolean x : r)System.out.print(x?'#':'.');\n			System.out.println();\n		}\n		System.out.println();\n	}\n \n	public void tf(long[]... b)\n	{\n		if(INPUT.length() != 0) {\n			for (long[] r : b) {\n				for (long x : r) {\n					for (int i = 0; i < 64; i++) {\n						System.out.print(x << ~i < 0 ? '#' : '.');\n					}\n				}\n				System.out.println();\n			}\n			System.out.println();\n		}\n	}\n \n	public void tf(long... b)\n	{\n		if(INPUT.length() != 0) {\n			for (long x : b) {\n				for (int i = 0; i < 64; i++) {\n					System.out.print(x << ~i < 0 ? '#' : '.');\n				}\n			}\n			System.out.println();\n		}\n	}\n \n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}","constructive algorithms,interactive,probabilities"
"import java.io.*;\nimport java.util.*;\n\npublic class ButtonLock {\n    static List<Character> path;\n    static List<Integer> nodes;\n    static boolean[] marked;\n    static int[] parent;\n    static List<List<Integer>> G;\n    public static boolean dfs(int cur) {\n        for (int nxt : G.get(cur)) {\n            if (!marked[nxt]) {\n                marked[nxt] = true;\n                if (parent[nxt] == -1 || dfs(parent[nxt])) {\n                    parent[nxt] = cur;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    public static void sort(int[] A) {\n        List<Integer> list = new ArrayList<>();\n        for (int ele : A) list.add(ele);\n        list.sort((a, b) -> Integer.bitCount(b) - Integer.bitCount(a));\n        for (int i = 0; i < A.length; i++) {\n            A[i] = list.get(i);\n        }\n    }\n    public static void solve(int u, int D, int[] A) {\n        if (parent[u] == -1) {\n            int mask = A[u];\n            for (int i = 0; i < D; i++) {\n                if ((mask & (1 << i)) != 0) {\n                    path.add((char)('0' + i));\n                }\n            }\n        } else {\n            solve(parent[u], D, A);\n            int mask = A[u] ^ A[parent[u]];\n            for (int i = 0; i < D; i++) {\n                if ((mask & (1 << i)) != 0) {\n                    path.add((char)('0' + i));\n                }\n            }\n        }\n    }\n    public static void main(String[] args) {\n        InputReader reader = new InputReader(System.in);\n        PrintWriter writer = new PrintWriter(System.out, false);\n        int D = reader.nextInt();\n        int N = reader.nextInt();\n        String[] S = new String[N];\n        for (int i = 0; i < N; i++) {\n            S[i] = reader.next();\n        }\n        int[] adj = new int[N];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < D; j++) {\n                if (S[i].charAt(j) == '1') {\n                    adj[i] |= 1 << j;\n                }\n            }\n        }\n        G = new ArrayList<>(N);\n        for (int i = 0; i < N; i++) {\n            G.add(new ArrayList<>());\n        }\n        sort(adj);\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < i; j++) {\n                if ((adj[i] & adj[j]) == adj[i]) {\n                    G.get(i).add(j);\n                }\n            }\n        }\n        parent = new int[N];\n        Arrays.fill(parent, -1);\n        nodes = new ArrayList<>();\n        int answer = 0;\n        for (int i = 0; i < N; i++) {\n            marked = new boolean[N];\n            if (!dfs(i)) {\n                nodes.add(i);\n                answer += Integer.bitCount(adj[i]) + 1;\n            }\n        }\n        writer.println(answer - 1);\n        path = new ArrayList<>();\n        for (int i = 0; i < nodes.size(); i++) {\n            if (i > 0) path.add('R');\n            solve(nodes.get(i), D, adj);\n        }\n        for (char ch : path) writer.print(ch + "" "");\n        writer.close();\n        System.exit(0);\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        public String nextLine() {\n            String str = """";\n            try {\n                str = reader.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}","flows,graph matchings,graphs"
"import java.util.*;\nimport java.io.*;\n\npublic class B1510 {\n	static int[][] adjMatrix;\n	static final int INF = (int) 1e9;\n	static int V, s, t; // s != t\n	static int[][] res; // instead of res, you can use c[][], f[][] so as not to destroy the graph\n	static int[][] cost;\n	static int[] p, d, nodes; // res (residual) = c (capacity) - f (flow)\n	static ArrayList<Integer>[] adjList;\n\n	static void addEdge(int u, int v, int c) {\n		res[u][v] = 1;\n		cost[u][v] = c;\n		cost[v][u] = -c;\n		adjMatrix[u][v] = 1;\n		adjList[u].add(v);\n		adjList[v].add(u);\n	}\n\n	static int edmondsKarp() // O(min(VE^2, flow * E)) for adjList, O(V^3E)\n	{\n		int mf = 0;\n		while (true) {\n			PriorityQueue<int[]> q = new PriorityQueue<int[]>((u, v) -> (u[1] - v[1]));\n			p = new int[V];\n			d = new int[V];\n			Arrays.fill(p, -1);\n			Arrays.fill(d, (int) 1e9);\n			q.add(new int[] { s, 0 });\n			p[s] = s;\n			d[s] = 0;\n			while (!q.isEmpty()) {\n				int[] u = q.remove();\n				if (u[0] == t)\n					break;\n				for (int v : adjList[u[0]]) {\n					if (res[u[0]][v] > 0 && u[1] + cost[u[0]][v] < d[v]) {\n						d[v] = u[1] + cost[u[0]][v];\n						p[v] = u[0];\n						q.add(new int[] { v, u[1] + cost[u[0]][v] });\n					}\n				}\n			}\n			if (p[t] == -1)\n				break;\n			mf += augment(t, INF);\n		}\n		return mf;\n	}\n\n	static int augment(int v, int flow) {\n		if (v == s)\n			return flow;\n		flow = augment(p[v], Math.min(flow, res[p[v]][v]));\n		res[p[v]][v] -= flow;\n		res[v][p[v]] += flow;\n		return flow;\n	}\n\n	static void add(int cur, int nxt, ArrayList<Integer> al) {\n		int idx = 1;\n		for (int i = 1; i < 1 << 10; i <<= 1) {\n			if ((i & cur) == 0 && (i & nxt) != 0) {\n				al.add(idx);\n			}\n			idx++;\n		}\n	}\n\n	static ArrayList<Integer> solve(int n) {\n		int[] match = new int[n];\n		int[] matchN = new int[n];\n		Arrays.fill(match, -1);\n		Arrays.fill(matchN, -1);\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < n; j++) {\n				if (adjMatrix[i << 1][j << 1 | 1] == 1 && res[i << 1][j << 1 | 1] == 0) {\n					match[j] = i;\n					matchN[i] = j;\n				}\n			}\n		}\n		ArrayList<Integer> ans = new ArrayList<Integer>();\n		for (int i = 0; i < n; i++) {\n			if (match[i] == -1) {\n				if (!ans.isEmpty()) {\n					ans.add(-1);\n				}\n				add(0, nodes[i], ans);\n				int cur = i;\n				while (true) {\n//					System.out.println(cur);\n					if (matchN[cur] == -1)\n						break;\n					add(nodes[cur], nodes[matchN[cur]], ans);\n					cur = matchN[cur];\n				}\n			}\n		}\n		return ans;\n	}\n\n	public static void main(String[] args) throws IOException {\n		Scanner sc = new Scanner(System.in);\n		PrintWriter pw = new PrintWriter(System.out);\n		int d = sc.nextInt();\n		int n = sc.nextInt();\n		V = 2 * n + 2;\n		s = 2 * n;\n		t = 2 * n + 1;\n		res = new int[V][V];\n		cost = new int[V][V];\n		nodes = new int[n];\n		adjList = new ArrayList[V];\n		for (int i = 0; i < adjList.length; i++) {\n			adjList[i] = new ArrayList<Integer>();\n		}\n		for (int i = 0; i < nodes.length; i++) {\n			nodes[i] = Integer.parseInt(sc.next(), 2);\n		}\n		adjMatrix = new int[V][V];\n		for (int i = 0; i < n; i++) {\n			addEdge(s, i << 1, 0);\n			addEdge(i << 1 | 1, t, 0);\n			for (int j = i + 1; j < n; j++) {\n				if ((nodes[i] & nodes[j]) == nodes[i]) {\n					// i is submask -> edge from i to j\n					addEdge(i << 1, j << 1 | 1, Integer.bitCount(nodes[j] ^ nodes[i]));\n				} else if ((nodes[i] & nodes[j]) == nodes[j]) {\n					addEdge(j << 1, i << 1 | 1, Integer.bitCount(nodes[j] ^ nodes[i]));\n				}\n			}\n		}\n		edmondsKarp();\n//		System.out.println(Arrays.toString(match));\n//		System.out.println(Arrays.toString(matchN));\n		ArrayList<Integer> sol = solve(n);\n		pw.println(sol.size());\n		for (int x : sol) {\n			if (x == -1) {\n				pw.print(""R "");\n			} else {\n				pw.print((d - x) + "" "");\n			}\n		}\n		pw.println();\n		pw.close();\n	}\n\n	static class Scanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		public Scanner(InputStream s) {\n			br = new BufferedReader(new InputStreamReader(s));\n		}\n\n		public Scanner(FileReader f) {\n			br = new BufferedReader(f);\n		}\n\n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n\n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n\n		public int[] nextIntArr(int n) throws IOException {\n			int[] arr = new int[n];\n			for (int i = 0; i < n; i++) {\n				arr[i] = Integer.parseInt(next());\n			}\n			return arr;\n		}\n\n	}\n\n}\n","flows,graph matchings,graphs"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.StringTokenizer;\n\npublic class b {\n	public static void main(String[] args) {\n		FastScanner scan=new FastScanner();\n		PrintWriter out=new PrintWriter(System.out);\n\n		/*\n		the cost of each path we take through the passwords\n		is equal to the number of bits in the last thing in the path, plus one\n		then we subtract 1 at the end since we don't reset after the last path.\n\n		in our standard path cover problem, we can do maximum bipartite matching\n		since each password at the end of a path corresponds to a node uncovered\n		on the left side, we wish to minimize the cost of these uncovered on the left\n		and therefore minimize the cost of paths we have to go down.\n\n		greedily add flow edges from high to low cost, and send flow through this way\n		 */\n\n		int d=scan.nextInt(), n=scan.nextInt();\n		int[] masks=new int[n];\n		for(int i=0;i<n;i++) {\n			char[] x=scan.next().toCharArray();\n			int val=0;\n			for(int j=0;j<d;j++) {\n				val<<=1;\n				if(x[j]=='1') val++;\n			}\n			masks[i]=val;\n		}\n		ArrayList<edge>[] edges=new ArrayList[d+1];\n		ArrayList<Dinic.Edge> fedges=new ArrayList<>();\n\n		for(int i=0;i<=d;i++) edges[i]=new ArrayList<>();\n\n		for(int i=0;i<n;i++) {\n			for(int j=0;j<n;j++) {\n				if(i==j) continue;\n				if((masks[i]&masks[j])==masks[j]) {\n					//j is submask of i (j-->i)\n					edges[Integer.bitCount(masks[j])].add(new edge(j,i));\n				}\n			}\n		}\n\n		/*\n		0-n-1 = set1\n		n-2n-1 = set2\n		2n = source\n		2n+1 = sink\n		node count: 2n+2\n		*/\n\n		Dinic flow=new Dinic(2*n);\n\n		for(int i=0;i<n;i++) flow.add(flow.s,i,1,0);\n		for(int i=n;i<2*n;i++) flow.add(i,flow.t,1,0);\n\n		for(int i=d;i>=0;i--) {\n			for(edge e:edges[i]) {\n				fedges.add(flow.add(e.i,e.j+n,1,0));\n			}\n			//go with the floww\n			flow.flow();\n		}\n\n		int[] prev=new int[n], nxt=new int[n];\n		Arrays.fill(prev,-1);\n		Arrays.fill(nxt,-1);\n		for(Dinic.Edge e:fedges) {\n			if(e.flow>0) {\n				int startpt=e.v1;\n				int endpt=e.v2-n;\n				//					System.out.println(startpt+"" ""+endpt);\n				prev[endpt]=startpt;\n				nxt[startpt]=endpt;\n			}\n		}\n		//		System.out.println(Arrays.toString(nxt));\n		ops=new ArrayDeque<>();\n		for(int i=0;i<n;i++) {\n			if(prev[i]==-1) {\n				int cur=i, p=0;\n				while(cur!=-1) {\n					calcpath(p,masks[cur],d);\n					//					System.out.println(cur+"" ""+nxtv);\n					p=masks[cur];\n					cur=nxt[cur];\n				}\n				ops.offer(-1);\n			}\n		}\n		ops.pollLast();\n		out.println(ops.size());\n		while(!ops.isEmpty()) {\n			int x=ops.pollFirst();\n			if(x==-1) out.print(""R "");\n			else out.print(x+"" "");\n		}\n		out.println();\n		out.close();\n	}\n	public static void calcpath(int x, int y, int d) {\n		for(int i=0;i<d;i++) {\n			if((x&(1<<i))==0&&(y&(1<<i))>0) {\n				ops.offer(d-i-1);\n			}\n		}\n	}\n	static ArrayDeque<Integer> ops;\n	static class edge {\n		int i,j;//indices\n		edge(int i, int j) {\n			this.i=i;\n			this.j=j;\n		}\n	}\n	static class Dinic {\n		static class Edge {  int v1, v2, cap, flow; Edge rev;\n		Edge(int V1, int V2, int Cap, int Flow) { v1 = V1; v2 = V2; cap = Cap; flow = Flow; }\n		}\n\n		ArrayDeque<Integer> q;  ArrayList<Edge>[] adj;\n		int n, s, t, mS, mT, oo = (int)1E9;\n		boolean[] blocked;  int[] dist;\n		public Dinic (int N) {\n			n = N; s = n++; t = n++; mS = n++; mT = n++; blocked = new boolean[n];\n			dist = new int[n];  q = new ArrayDeque<Integer>();\n			adj = new ArrayList[n];  for(int i = 0; i < n; ++i)  adj[i] = new ArrayList<Edge>();\n		}\n		// Specifying flow can represent minimum flow for circulation.\n		Edge add(int v1, int v2, int cap, int flow) {\n			Edge e = new Edge(v1, v2, cap, flow);  Edge rev = new Edge(v2, v1, 0, 0);\n			adj[v1].add(rev.rev = e);  adj[v2].add(e.rev = rev);\n			return e;\n		}\n\n		//#\n		// Only needed if you need remove function\n		void remove(int v1, int v2) {\n			Edge e;\n			for(int i = 0; i < adj[v1].size(); i++) {\n				e = adj[v1].get(i);\n				if(e.v2 == v2 && e.cap != 0)  adj[v1].remove(i--);\n			}\n\n			for(int i = 0; i < adj[v2].size(); i++) {\n				e = adj[v2].get(i);\n				if(e.v2 == v1 && e.cap == 0)  adj[v2].remove(i--);\n			}\n		}\n		//$\n\n		boolean bfs() {\n			q.clear();  Arrays.fill(dist, -1);  dist[t] = 0;  q.add(t);\n\n			while(!q.isEmpty()) {\n				int node = q.poll();\n				if(node == s)   return true;\n				for(Edge e : adj[node]) {\n					if(e.rev.cap > e.rev.flow && dist[e.v2] == -1) {\n						dist[e.v2] = dist[node] + 1;  q.add(e.v2);\n					}\n				}\n			}\n			return dist[s] != -1;\n		}\n\n		int dfs(int pos, int min) {\n			if(pos == t)  return min;\n			int flow = 0;\n			for(Edge e : adj[pos]) {\n				int cur = 0;\n				if(!blocked[e.v2] && dist[e.v2] == dist[pos]-1 && e.cap - e.flow > 0) {\n					cur = dfs(e.v2, Math.min(min-flow, e.cap - e.flow));\n					e.flow += cur;  e.rev.flow = -e.flow;  flow += cur;\n				}\n				if(flow == min)  return flow;\n			}\n			blocked[pos] = flow != min;\n			return flow;\n		}\n		int flow() {\n			int ret = 0;\n			while(bfs()) {  Arrays.fill(blocked, false);  ret += dfs(s, oo);  }\n			return ret;\n		}\n		void clear() {  for(ArrayList<Edge> edges : adj)  for(Edge e : edges)  e.flow = 0;  }\n		// Convert the given graph into a graph to test for circulation\n		boolean circulation() {\n			int[] delta = new int[n];\n			Dinic d = new Dinic(n);\n			for(int node = 0; node < n; ++node) {\n				for(Edge e : adj[node]) {\n					if(e.cap > 0 && e.flow >= 0) {\n						d.add(e.v1, e.v2, e.cap-e.flow, 0);\n						delta[e.v1] -= e.flow;  delta[e.v2] += e.flow;\n					}\n				}\n			}\n			ArrayList<Edge> satEdges = new ArrayList<Edge>();\n			for(int i = 0; i < n; ++i) {\n				if(delta[i] > 0)  satEdges.add(d.add(d.s, i, delta[i], 0));\n				else if(delta[i] < 0)  d.add(i, d.t, -delta[i], 0);	\n			}\n			Edge tylerEdge = d.add(t,s,oo,0);\n			int flow = d.flow();\n			boolean isSat = true;\n			for(Edge e : satEdges) isSat&=(e.cap==e.flow); 				\n			return isSat;\n		}\n\n		int maxFlowWithMinCap() {\n			Edge e = add(t,s,oo,0);\n			int lo = 0, hi = oo;\n			while(lo < hi) {\n				int mid = (lo+hi+1)/2;\n				e.flow = mid;\n				if(circulation()) lo = mid;\n				else hi = mid-1;\n			}\n			return lo;\n		}\n		int minFlowWithMinCap() {\n			Edge e1 = add(mS, s, 1, 0);\n			Edge e2 = add(t, mT, oo, 0);\n			add(s, t, oo, 0);\n			s = mS; t = mT;\n			int lo = 0, hi = oo;\n			while(lo < hi) {\n				int mid = (lo+hi)/2;\n				e1.cap = mid;\n				e2.flow = mid;\n				if(circulation()) hi = mid;\n				else lo = mid+1;\n			}\n			return lo;\n		}\n		/* Vertex cover on bipartite graph (L, R):\n		Find nodes in S side of S/T min cut (bfs(); dist[i] == -1)\n		L1 = L & S, L2 = L - S, R1 = R & S, R2 = R - S\n		Let B be the set of vertices in R2 that have neighbors in L1\n		C = L2 | R1 | B\n		Maximum independent set is the complement nodes \n		To get all nodes that can be in max independent set, get vertexCover()\n		then swap source/sink and bfs on saturated edges, then get next vc()\n		Nodes that DONT appear in BOTH can be part of max independent set*/\n		ArrayList<Integer> vertexCover() {\n			BitSet leftNodes = new BitSet();\n			BitSet rightNodes = new BitSet();\n			BitSet minCut = new BitSet();\n			for(Edge e : adj[s])\n				if(e.v1 == s)\n					leftNodes.set(e.v2);\n			for(Edge e : adj[t])\n				if(e.v1 == t)\n					rightNodes.set(e.v2);\n			bfs();\n			for(int i = 0; i < s; ++i)\n				if(dist[i] == -1)\n					minCut.set(i);\n\n			BitSet l1 = new BitSet(); l1.or(leftNodes); l1.and(minCut);\n			BitSet l2 = new BitSet(); l2.or(leftNodes); l2.andNot(minCut);\n			BitSet r1 = new BitSet(); r1.or(rightNodes); r1.and(minCut);\n			BitSet r2 = new BitSet(); r2.or(rightNodes); r2.andNot(minCut);\n\n			BitSet b = new BitSet();\n			for(int bit = r2.nextSetBit(0); bit >= 0; bit = r2.nextSetBit(bit+1)) {\n				for(Edge e : adj[bit]) {\n					if(e.v1 == bit && l1.get(e.v2)) {\n						b.set(bit);\n						break;\n					}\n				}\n			}\n\n			BitSet c = new BitSet(); c.or(l2); c.or(r1); c.or(b);\n			ArrayList<Integer> ret = new ArrayList<Integer>();\n			for(int bit = c.nextSetBit(0); bit >= 0; bit = c.nextSetBit(bit+1)) \n				ret.add(bit);\n			return ret;\n		}\n		/* Project selection: s->v with cap p if p > 0. v->t with -p if p < 0\n		if w is preReq of v, then v->w with cap INF. Revenue is sum of positive\n		revenues minus max flow. Projects taken is bfs() with dist[i] == -1\n		Image seg: s->i with cap = value of being on source side. i->t with value\n		of being on sink side. i<->j with penalty of i and j in separate groups\n		if s->i saturated, then i is on sink side and vice versa\n		bfs() with dist[i] == -1 means 'i' is on source side. Total value\n		is sum of values of both sides minus max flow\n		 */\n	}\n	static class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		public FastScanner() {\n			try	{\n				br = new BufferedReader(new InputStreamReader(System.in));\n				st = new StringTokenizer(br.readLine());\n			} catch (Exception e){e.printStackTrace();}\n		}\n\n		public String next() {\n			if (st.hasMoreTokens())	return st.nextToken();\n			try {st = new StringTokenizer(br.readLine());}\n			catch (Exception e) {e.printStackTrace();}\n			return st.nextToken();\n		}\n\n		public int nextInt() {return Integer.parseInt(next());}\n\n		public long nextLong() {return Long.parseLong(next());}\n\n		public double nextDouble() {return Double.parseDouble(next());}\n\n		public String nextLine() {\n			String line = """";\n			if(st.hasMoreTokens()) line = st.nextToken();\n			else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n			while(st.hasMoreTokens()) line += "" ""+st.nextToken();\n			return line;\n		}\n	}\n}","flows,graph matchings,graphs"
"import java.util.*;\npublic class Main {\n	static int n;\n	static int m;\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner in = new Scanner(System.in);\n		n = in.nextInt();\n		m = in.nextInt();\n		String s = Integer.toString(n, m);\n		for(int i=0;i<s.length();i++) {\n			for(int j=i+1;j<s.length();j++) {\n				if(s.charAt(i)==s.charAt(j)) {\n					System.out.println(""NO"");\n					return;\n				}\n			}\n		}\n		System.out.println(""YES"");\n	}\n}","*special,number theory"
"import java.io.*;\nimport java.util.ArrayList;\nimport java.util.HashSet;\n\npublic class xenodrome {\n\n	public static void main(String[] args)throws IOException {\n	\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		\n		String arr[]=br.readLine().split("" "");\n		\n		int n=Integer.parseInt(arr[0]);\n		int m=Integer.parseInt(arr[1]);\n		\n		ArrayList<Integer> li=new ArrayList<>();\n		\n		while(n>0)\n		{\n			li.add(n%m);\n			\n			n=n/m;\n		}\n      \n		\n		HashSet<Integer> set=new HashSet<>();\n		\n		for(int i=0;i<li.size();i++)\n		{\n			set.add(li.get(i));\n		}\n		\n		if(li.size()==set.size())\n			System.out.println(""YES"");\n		else\n			System.out.println(""NO"");\n	}\n\n}\n","*special,number theory"
"//https://codeforces.com/contest/1505/problem/D\n//D. Xenolith? Hippodrome?\nimport java.util.*;\nimport java.io.*;\npublic class CF_1505_D{\n\n	static boolean check(int n, int m){\n		boolean pres[] = new boolean[m];\n\n		while(n>0){\n			int temp = n%m;\n\n			if(pres[temp])\n				return false;\n			else\n				pres[temp] = true;\n\n			n = n/m;\n		}\n		return true;\n	}\n\n	public static void main(String[] args) throws Exception{\n		\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));\n		StringTokenizer st;\n\n		st = new StringTokenizer(br.readLine().trim());\n		int n = Integer.parseInt(st.nextToken());\n		int m = Integer.parseInt(st.nextToken());\n\n		boolean flag = check(n, m);\n\n		if(flag)\n			pw.print(""YES"");\n		else\n			pw.print(""NO"");\n\n		pw.flush();\n		pw.close();\n	}\n}","*special,number theory"
"import java.util.*;\nimport java.io.*;\n\npublic class Sol{\nstatic InputStream inputStream = System.in;\nstatic OutputStream outputStream = System.out;\nstatic FastReader in=new FastReader(inputStream);\nstatic PrintWriter out=new PrintWriter(outputStream);\n\nstatic class FastReader \n{ \n  BufferedReader br; \n  StringTokenizer st; \n \n  public FastReader(InputStream in) \n  { \n      br = new BufferedReader(new\n               InputStreamReader(System.in)); \n  } \n \n  public String next() \n  { \n      while (st == null || !st.hasMoreElements()) \n      { \n          try\n          { \n              st = new StringTokenizer(br.readLine()); \n          } \n          catch (IOException  e) \n          { \n              e.printStackTrace(); \n          } \n      } \n      return st.nextToken(); \n  } \n \n  public int nextInt() \n  { \n      return Integer.parseInt(next()); \n  } \n \n  public long nextLong() \n  { \n      return Long.parseLong(next()); \n  } \n \n public  double nextDouble() \n  { \n      return Double.parseDouble(next()); \n  } \n \n \n  String nextLine() \n  { \n      String str = """"; \n      try\n      { \n          str = br.readLine(); \n      } \n      catch (IOException e) \n      { \n          e.printStackTrace(); \n      } \n      return str; \n  } \n}\n\n\n\n//----------------------------------------------------------------------------------------------//\n\n//----------------S  T  A  R  T  ---------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------//\n\n/*linear sieve nlogn\nint n=(int)Math.pow(10,6)+100;\nlong mod=998244353;\nlong d[]=new long[n];\n\nfor(int i=1;i<n;i++){ for(int j=i; j<n; j+=i){ d[j] += 1; }}\n\nlong pre[]=new long[n];\n\npre[1]=1;d[1]=1;\nfor(int i=2;i<n;i++){d[i]+=pre[i-1]%mod;pre[i] += (pre[i-1]+d[i])%mod;}*/\n\nstatic class Pair {\n        int id;long val;\n        public Pair(int id,long val) {\n          \n          this.id=id;\n         this.val=val;\n        }\n       \n      }\n\n/*----------nCx---------------\nlong Comb[][]=new long[61][61];\n\nfor(int i=1;i<=60;i++){Comb[i][0]=1;}\nfor(int i=1;i<=60;i++){Comb[i][1]=i;Comb[i][i]=1;}\nfor(int i=2;i<=60;i++){for(int j=1;j<i;j++){Comb[i][j]=Comb[i-1][j]+Comb[i-1][j-1];}}\n----------nCx------------------\n*/\n\n/*----------DFS-------------\nstatic void DFS(int v,int p){\ndp[0][v]=0;dp[1][v]=0;\nfor(int u:adj[v]){\nif(u==p)continue;\nDFS(u,v);\ndp[0][v]+=Math.max(Math.abs(A[0][u]-A[0][v]) + dp[0][u], Math.abs(A[1][u]-A[0][v]) + dp[1][u] );\ndp[1][v]+=Math.max(Math.abs(A[0][u]-A[1][v]) + dp[0][u], Math.abs(A[1][u]-A[1][v]) + dp[1][u] );\n}\n\n}\n\nstatic int N=(int)Math.pow(10,5)+10;\nstatic ArrayList<Integer> adj[]=new ArrayList[N];\nstatic long dp[][]=new long[2][N];\nstatic long A[][]=new long[2][N];\n\n-----------DFS--------------\n*/\n/*static class Edge implements Comparable<Edge>{\nint destination;long cost;\nEdge(int destination,long cost){this.cost=cost;this.destination=destination;}\n\n@Override\n\n		public int compareTo(Edge o) {\n			return Long.compare(cost, o.cost);\n		}\n}\n\n*/\n\npublic static void main(String []args){\n\nint t=1;\n\nwhile(t-->0){\nint n=in.nextInt();int m=in.nextInt();\n\nHashSet<Integer> hs=new HashSet<Integer>();boolean ans=true;\nwhile(n>0){if(hs.contains(n%m)){ans=false;}else{hs.add(n%m);}n/=m;         }\nif(ans)out.println(""YES"");\nelse out.println(""NO"");\n }\n\nout.close();\n}}","*special,number theory"
"//package com.company;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport java.util.stream.Collectors;\n\npublic class C {\n    FastScanner in;\n    PrintWriter out;\n\n    public static void main(String[] args) {\n        new C().solve();\n    }\n\n    private void solve() {\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solveCase();\n\n        out.close();\n    }\n\n    private void solveCase() {\n        int n = in.nextInt(), m = in.nextInt();\n\n        int[][] a = new int[n][m];\n        int[][] b = new int[n][m];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n//                a.get(a.size() - 1).add(new Random().nextInt());\n                a[i][j] = in.nextInt();\n            }\n        }\n\n        Map<Integer, Integer> originalPositions = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            originalPositions.put(Arrays.hashCode(a[i]), i);\n        }\n\n        for (int i = 0; i < n; i++) {\n//            b.add(new ArrayList<>(a.get(i)));\n//            b.add(new ArrayList<>());\n            for (int j = 0; j < m; j++) {\n                b[i][j] = in.nextInt();\n            }\n        }\n\n        int[][] hashes = new int[2][n];\n        for (int i = 0; i < n; i++) {\n            int[] aList = new int[m];\n            if (m >= 0) System.arraycopy(a[i], 0, aList, 0, m);\n            hashes[0][i] = Arrays.hashCode(aList);\n\n            int[] bList = new int[m];\n            if (m >= 0) System.arraycopy(b[i], 0, bList, 0, m);\n            hashes[1][i] = Arrays.hashCode(bList);\n        }\n        for (int i = 0; i < 2; i++) {\n            Arrays.sort(hashes[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            if (hashes[0][i] != hashes[1][i]) {\n                out.println(Arrays.deepToString(hashes));\n                out.println(""fruta"");\n                out.println(-1);\n                return;\n            }\n        }\n\n        BitSet alreadyDifferentiated = new BitSet(n);\n        BitSet aliveColumns = new BitSet();\n        for (int i = 0; i < m; i++) {\n            aliveColumns.set(i);\n        }\n        BitSet[] upJumps = new BitSet[m];\n        BitSet[] downJumps = new BitSet[m];\n        for (int i = 0; i < m; i++) {\n            upJumps[i] = new BitSet();\n            downJumps[i] = new BitSet();\n        }\n\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = 0; j < m; j++) {\n                if (b[i][j] < b[i + 1][j]) upJumps[j].set(i);\n                if (b[i][j] > b[i + 1][j]) downJumps[j].set(i);\n            }\n        }\n\n        List<Integer> res = new ArrayList<>();\n\n        boolean keepGoing = true;\n        while (keepGoing) {\n            int column = -1;\n            for (int col = aliveColumns.nextSetBit(0); col != -1; col = aliveColumns.nextSetBit(col + 1)) {\n                if (downJumps[col].isEmpty()) {\n                    column = col;\n                }\n            }\n            if (column != -1) {\n                res.add(column + 1); //(1-indexed)\n                aliveColumns.clear(column);\n\n                BitSet uJ = upJumps[column];\n                for (int jump = uJ.nextSetBit(0); jump != -1; jump = uJ.nextSetBit(jump + 1)) {\n                    alreadyDifferentiated.set(jump);\n                    for (int col = aliveColumns.nextSetBit(0); col != -1; col = aliveColumns.nextSetBit(col + 1)) {\n                        downJumps[col].clear(jump);\n                        upJumps[col].clear(jump);\n                    }\n                }\n            } else {\n                keepGoing = false;\n            }\n        }\n\n        List<Integer> finalPositionToOriginalPosition = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            finalPositionToOriginalPosition.add(originalPositions.get(Arrays.hashCode(b[i])));\n        }\n\n        for (int i = 0; i < n - 1; i++) {\n            if (!alreadyDifferentiated.get(i) &&\n                    finalPositionToOriginalPosition.get(i) > finalPositionToOriginalPosition.get(i + 1)) {\n                out.println(-1);\n                return;\n            }\n        }\n\n        Collections.reverse(res);\n\n        out.println(res.size());\n        out.println(res.stream().map(String::valueOf).collect(Collectors.joining("" "")));\n    }\n\n    static class FastScanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n}\n","bitmasks,brute force,constructive algorithms,greedy,two pointers"
"//package round707;\nimport java.io.*;\nimport java.util.*;\n\npublic class C {\n	InputStream is;\n	FastWriter out;\n	String INPUT = """";\n\n	void solve()\n	{\n		int n = ni(), m = ni();\n		int[][] a = nmi(n, m);\n		int[][] b = nmi(n, m);\n		Map<Long, Deque<Integer>> as = new HashMap<>();\n		for(int i = 0;i < n;i++){\n			long h = 0;\n			for(int v : a[i]){\n				h = h * 1000000009 + v;\n			}\n			if(!as.containsKey(h)){\n				as.put(h, new ArrayDeque<>());\n			}\n			as.get(h).add(i);\n		}\n		int[] to = new int[n];\n		Arrays.fill(to, -1);\n		for(int i = 0;i < n;i++){\n			long h = 0;\n			for(int v : b[i]){\n				h = h * 1000000009 + v;\n			}\n			if(!as.containsKey(h) || as.get(h).isEmpty()){\n				out.println(-1);\n				return;\n			}\n			to[as.get(h).pollFirst()] = i;\n		}\n\n		int[] hasgap = new int[m];\n		for(int j = 0;j < m;j++){\n			for(int i = 0;i < n-1;i++){\n				if(b[i][j] > b[i+1][j]){\n					hasgap[j]++;\n				}\n			}\n		}\n		Queue<Integer> q = new ArrayDeque<>();\n		for(int i = 0;i < m;i++){\n			if(hasgap[i] == 0){\n				q.add(i);\n			}\n		}\n		boolean[] gap = new boolean[n-1]; // i,i+1s\n		int[] is = new int[m];\n		int p = 0;\n		while(!q.isEmpty()){\n			int cur = q.poll();\n			is[p++] = cur;\n			for(int i = 0;i < n-1;i++){\n				if(!gap[i] && b[i][cur] < b[i+1][cur]){\n					gap[i] = true;\n					for(int j = 0;j < m;j++){\n						if(b[i][j] > b[i+1][j]){\n							if(--hasgap[j] == 0){\n								q.add(j);\n							}\n						}\n					}\n				}\n			}\n		}\n		int[] ito = new int[n];\n		for(int i = 0;i < n;i++)ito[to[i]] = i;\n		for(int i = 0;i < n-1;i++){\n			if(!gap[i] && ito[i] > ito[i+1]){\n				out.println(-1);\n				return;\n			}\n		}\n		out.println(p);\n		for(int i = p-1;i >= 0;i--){\n			out.print(is[i]+1 + "" "");\n		}\n		out.println();\n	}\n	\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new FastWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new C().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n\n	private long[] nal(int n)\n	{\n		long[] a = new long[n];\n		for(int i = 0;i < n;i++)a[i] = nl();\n		return a;\n	}\n\n	private char[][] nm(int n, int m) {\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n\n	private int[][] nmi(int n, int m) {\n		int[][] map = new int[n][];\n		for(int i = 0;i < n;i++)map[i] = na(m);\n		return map;\n	}\n\n	private int ni() { return (int)nl(); }\n\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n\n	public static class FastWriter\n	{\n		private static final int BUF_SIZE = 1<<13;\n		private final byte[] buf = new byte[BUF_SIZE];\n		private final OutputStream out;\n		private int ptr = 0;\n\n		private FastWriter(){out = null;}\n\n		public FastWriter(OutputStream os)\n		{\n			this.out = os;\n		}\n\n		public FastWriter(String path)\n		{\n			try {\n				this.out = new FileOutputStream(path);\n			} catch (FileNotFoundException e) {\n				throw new RuntimeException(""FastWriter"");\n			}\n		}\n\n		public FastWriter write(byte b)\n		{\n			buf[ptr++] = b;\n			if(ptr == BUF_SIZE)innerflush();\n			return this;\n		}\n\n		public FastWriter write(char c)\n		{\n			return write((byte)c);\n		}\n\n		public FastWriter write(char[] s)\n		{\n			for(char c : s){\n				buf[ptr++] = (byte)c;\n				if(ptr == BUF_SIZE)innerflush();\n			}\n			return this;\n		}\n\n		public FastWriter write(String s)\n		{\n			s.chars().forEach(c -> {\n				buf[ptr++] = (byte)c;\n				if(ptr == BUF_SIZE)innerflush();\n			});\n			return this;\n		}\n\n		private static int countDigits(int l) {\n			if (l >= 1000000000) return 10;\n			if (l >= 100000000) return 9;\n			if (l >= 10000000) return 8;\n			if (l >= 1000000) return 7;\n			if (l >= 100000) return 6;\n			if (l >= 10000) return 5;\n			if (l >= 1000) return 4;\n			if (l >= 100) return 3;\n			if (l >= 10) return 2;\n			return 1;\n		}\n\n		public FastWriter write(int x)\n		{\n			if(x == Integer.MIN_VALUE){\n				return write((long)x);\n			}\n			if(ptr + 12 >= BUF_SIZE)innerflush();\n			if(x < 0){\n				write((byte)'-');\n				x = -x;\n			}\n			int d = countDigits(x);\n			for(int i = ptr + d - 1;i >= ptr;i--){\n				buf[i] = (byte)('0'+x%10);\n				x /= 10;\n			}\n			ptr += d;\n			return this;\n		}\n\n		private static int countDigits(long l) {\n			if (l >= 1000000000000000000L) return 19;\n			if (l >= 100000000000000000L) return 18;\n			if (l >= 10000000000000000L) return 17;\n			if (l >= 1000000000000000L) return 16;\n			if (l >= 100000000000000L) return 15;\n			if (l >= 10000000000000L) return 14;\n			if (l >= 1000000000000L) return 13;\n			if (l >= 100000000000L) return 12;\n			if (l >= 10000000000L) return 11;\n			if (l >= 1000000000L) return 10;\n			if (l >= 100000000L) return 9;\n			if (l >= 10000000L) return 8;\n			if (l >= 1000000L) return 7;\n			if (l >= 100000L) return 6;\n			if (l >= 10000L) return 5;\n			if (l >= 1000L) return 4;\n			if (l >= 100L) return 3;\n			if (l >= 10L) return 2;\n			return 1;\n		}\n\n		public FastWriter write(long x)\n		{\n			if(x == Long.MIN_VALUE){\n				return write("""" + x);\n			}\n			if(ptr + 21 >= BUF_SIZE)innerflush();\n			if(x < 0){\n				write((byte)'-');\n				x = -x;\n			}\n			int d = countDigits(x);\n			for(int i = ptr + d - 1;i >= ptr;i--){\n				buf[i] = (byte)('0'+x%10);\n				x /= 10;\n			}\n			ptr += d;\n			return this;\n		}\n\n		public FastWriter write(double x, int precision)\n		{\n			if(x < 0){\n				write('-');\n				x = -x;\n			}\n			x += Math.pow(10, -precision)/2;\n			//		if(x < 0){ x = 0; }\n			write((long)x).write(""."");\n			x -= (long)x;\n			for(int i = 0;i < precision;i++){\n				x *= 10;\n				write((char)('0'+(int)x));\n				x -= (int)x;\n			}\n			return this;\n		}\n\n		public FastWriter writeln(char c){\n			return write(c).writeln();\n		}\n\n		public FastWriter writeln(int x){\n			return write(x).writeln();\n		}\n\n		public FastWriter writeln(long x){\n			return write(x).writeln();\n		}\n\n		public FastWriter writeln(double x, int precision){\n			return write(x, precision).writeln();\n		}\n\n		public FastWriter write(int... xs)\n		{\n			boolean first = true;\n			for(int x : xs) {\n				if (!first) write(' ');\n				first = false;\n				write(x);\n			}\n			return this;\n		}\n\n		public FastWriter write(long... xs)\n		{\n			boolean first = true;\n			for(long x : xs) {\n				if (!first) write(' ');\n				first = false;\n				write(x);\n			}\n			return this;\n		}\n\n		public FastWriter writeln()\n		{\n			return write((byte)'\n');\n		}\n\n		public FastWriter writeln(int... xs)\n		{\n			return write(xs).writeln();\n		}\n\n		public FastWriter writeln(long... xs)\n		{\n			return write(xs).writeln();\n		}\n\n		public FastWriter writeln(char[] line)\n		{\n			return write(line).writeln();\n		}\n\n		public FastWriter writeln(char[]... map)\n		{\n			for(char[] line : map)write(line).writeln();\n			return this;\n		}\n\n		public FastWriter writeln(String s)\n		{\n			return write(s).writeln();\n		}\n\n		private void innerflush()\n		{\n			try {\n				out.write(buf, 0, ptr);\n				ptr = 0;\n			} catch (IOException e) {\n				throw new RuntimeException(""innerflush"");\n			}\n		}\n\n		public void flush()\n		{\n			innerflush();\n			try {\n				out.flush();\n			} catch (IOException e) {\n				throw new RuntimeException(""flush"");\n			}\n		}\n\n		public FastWriter print(byte b) { return write(b); }\n		public FastWriter print(char c) { return write(c); }\n		public FastWriter print(char[] s) { return write(s); }\n		public FastWriter print(String s) { return write(s); }\n		public FastWriter print(int x) { return write(x); }\n		public FastWriter print(long x) { return write(x); }\n		public FastWriter print(double x, int precision) { return write(x, precision); }\n		public FastWriter println(char c){ return writeln(c); }\n		public FastWriter println(int x){ return writeln(x); }\n		public FastWriter println(long x){ return writeln(x); }\n		public FastWriter println(double x, int precision){ return writeln(x, precision); }\n		public FastWriter print(int... xs) { return write(xs); }\n		public FastWriter print(long... xs) { return write(xs); }\n		public FastWriter println(int... xs) { return writeln(xs); }\n		public FastWriter println(long... xs) { return writeln(xs); }\n		public FastWriter println(char[] line) { return writeln(line); }\n		public FastWriter println(char[]... map) { return writeln(map); }\n		public FastWriter println(String s) { return writeln(s); }\n		public FastWriter println() { return writeln(); }\n	}\n\n	public void trnz(int... o)\n	{\n		for(int i = 0;i < o.length;i++)if(o[i] != 0)System.out.print(i+"":""+o[i]+"" "");\n		System.out.println();\n	}\n\n	// print ids which are 1\n	public void trt(long... o)\n	{\n		Queue<Integer> stands = new ArrayDeque<>();\n		for(int i = 0;i < o.length;i++){\n			for(long x = o[i];x != 0;x &= x-1)stands.add(i<<6|Long.numberOfTrailingZeros(x));\n		}\n		System.out.println(stands);\n	}\n\n	public void tf(boolean... r)\n	{\n		for(boolean x : r)System.out.print(x?'#':'.');\n		System.out.println();\n	}\n\n	public void tf(boolean[]... b)\n	{\n		for(boolean[] r : b) {\n			for(boolean x : r)System.out.print(x?'#':'.');\n			System.out.println();\n		}\n		System.out.println();\n	}\n\n	public void tf(long[]... b)\n	{\n		if(INPUT.length() != 0) {\n			for (long[] r : b) {\n				for (long x : r) {\n					for (int i = 0; i < 64; i++) {\n						System.out.print(x << ~i < 0 ? '#' : '.');\n					}\n				}\n				System.out.println();\n			}\n			System.out.println();\n		}\n	}\n\n	public void tf(long... b)\n	{\n		if(INPUT.length() != 0) {\n			for (long x : b) {\n				for (int i = 0; i < 64; i++) {\n					System.out.print(x << ~i < 0 ? '#' : '.');\n				}\n			}\n			System.out.println();\n		}\n	}\n\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","bitmasks,brute force,constructive algorithms,greedy,two pointers"
"//stan hu tao\n//join nct ridin by first year culture reps\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.Math.abs;\nimport static java.lang.System.out;\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class x1500C\n{\n    public static void main(String hi[]) throws Exception\n    {\n        BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(infile.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n        int[][] grid = new int[N][M];\n        for(int r=0; r < N; r++)\n            grid[r] = readArr(M, infile, st);\n        int[][] target = new int[N][M];\n        for(int r=0; r < N; r++)\n            target[r] = readArr(M, infile, st);\n        int[] cnt = new int[M];\n        for(int c=0; c < M; c++)\n            for(int r=1; r < N; r++)\n                if(target[r-1][c] > target[r][c])\n                    cnt[c]++;\n        boolean[] processed = new boolean[M];\n        Stack<Integer> stack = new Stack<Integer>();\n        for(int c=0; c < M; c++)\n            if(cnt[c] == 0)\n            {\n                stack.push(c);\n                processed[c] = true;\n            }\n        ArrayList<Integer> ls = new ArrayList<Integer>();\n        boolean[] cut = new boolean[N];\n        while(stack.size() > 0)\n        {\n            int curr = stack.pop();\n            ls.add(curr);\n            for(int r=1; r < N; r++)\n                if(target[r-1][curr] < target[r][curr] && !cut[r])\n                {\n                    cut[r] = true;\n                    for(int c=0; c < M; c++)\n                        if(!processed[c])\n                        {\n                            if(target[r-1][c] > target[r][c])\n                                cnt[c]--;\n                            if(cnt[c] == 0)\n                            {\n                                stack.push(c);\n                                processed[c] = true;\n                            }\n                        }\n                }\n        }\n        Collections.reverse(ls);\n        for(int k: ls)\n        {\n            ArrayList<Unit> sorting = new ArrayList<Unit>();\n            for(int r=0; r < N; r++)\n                sorting.add(new Unit(grid[r][k], r));\n            Collections.sort(sorting);\n            int[][] next = new int[N][];\n            for(int r=0; r < N; r++)\n                next[r] = grid[sorting.get(r).dex];\n            grid = next;\n        }\n        boolean works = true;\n        for(int r=0; r < N; r++)\n            for(int c=0; c < M; c++)\n                if(grid[r][c] != target[r][c])\n                    works = false;\n        if(works)\n        {\n            StringBuilder sb = new StringBuilder(ls.size()+""\n"");\n            for(int x: ls)\n                sb.append((x+1)+"" "");\n            System.out.println(sb);\n        }\n        else\n            System.out.println(-1);\n    }\n    public static int[] readArr(int N, BufferedReader infile, StringTokenizer st) throws Exception\n    {\n        int[] arr = new int[N];\n        st = new StringTokenizer(infile.readLine());\n        for(int i=0; i < N; i++)\n            arr[i] = Integer.parseInt(st.nextToken());\n        return arr;\n    }\n}\nclass Unit implements Comparable<Unit>\n{\n    public int val;\n    public int dex;\n\n    public Unit(int a, int b)\n    {\n        val = a;\n        dex = b;\n    }\n    public int compareTo(Unit oth)\n    {\n        if(val == oth.val)\n            return dex-oth.dex;\n        return val-oth.val;\n    }\n}","bitmasks,brute force,constructive algorithms,greedy,two pointers"
"//stan hu tao\n//join nct ridin by first year culture reps\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.Math.abs;\nimport static java.lang.System.out;\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class x1500C\n{\n    public static void main(String hi[]) throws Exception\n    {\n        FastScanner infile = new FastScanner();\n        int N = infile.nextInt();\n        int M = infile.nextInt();\n        int[][] grid = new int[N][M];\n        for(int r=0; r < N; r++)\n            grid[r] = infile.nextInts(M);\n        int[][] target = new int[N][M];\n        for(int r=0; r < N; r++)\n            target[r] = infile.nextInts(M);\n        int[] cnt = new int[M];\n        for(int c=0; c < M; c++)\n            for(int r=1; r < N; r++)\n                if(target[r-1][c] > target[r][c])\n                    cnt[c]++;\n        boolean[] processed = new boolean[M];\n        ArrayDeque<Integer> stack = new ArrayDeque<Integer>();\n        for(int c=0; c < M; c++)\n            if(cnt[c] == 0)\n            {\n                stack.push(c);\n                processed[c] = true;\n            }\n        ArrayList<Integer> ls = new ArrayList<Integer>();\n        boolean[] cut = new boolean[N];\n        while(stack.size() > 0)\n        {\n            int curr = stack.pop();\n            ls.add(curr);\n            for(int r=1; r < N; r++)\n                if(target[r-1][curr] < target[r][curr] && !cut[r])\n                {\n                    cut[r] = true;\n                    for(int c=0; c < M; c++)\n                        if(!processed[c])\n                        {\n                            if(target[r-1][c] > target[r][c])\n                                cnt[c]--;\n                            if(cnt[c] == 0)\n                            {\n                                stack.push(c);\n                                processed[c] = true;\n                            }\n                        }\n                }\n        }\n        Collections.reverse(ls);\n        for(int k: ls)\n        {\n            ArrayList<Unit> sorting = new ArrayList<Unit>();\n            for(int r=0; r < N; r++)\n                sorting.add(new Unit(grid[r][k], r));\n            Collections.sort(sorting);\n            int[][] next = new int[N][];\n            for(int r=0; r < N; r++)\n                next[r] = grid[sorting.get(r).dex];\n            grid = next;\n        }\n        boolean works = true;\n        for(int r=0; r < N; r++)\n            for(int c=0; c < M; c++)\n                if(grid[r][c] != target[r][c])\n                    works = false;\n        if(works)\n        {\n            StringBuilder sb = new StringBuilder(ls.size()+""\n"");\n            for(int x: ls)\n                sb.append((x+1)+"" "");\n            System.out.println(sb);\n        }\n        else\n            System.out.println(-1);\n    }\n    public static int[] readArr(int N, BufferedReader infile, StringTokenizer st) throws Exception\n    {\n        int[] arr = new int[N];\n        st = new StringTokenizer(infile.readLine());\n        for(int i=0; i < N; i++)\n            arr[i] = Integer.parseInt(st.nextToken());\n        return arr;\n    }\n}\nclass Unit implements Comparable<Unit>\n{\n    public int val;\n    public int dex;\n\n    public Unit(int a, int b)\n    {\n        val = a;\n        dex = b;\n    }\n    public int compareTo(Unit oth)\n    {\n        if(val == oth.val)\n            return dex-oth.dex;\n        return val-oth.val;\n    }\n}\nclass FastScanner\n{\n    private int BS = 1 << 16;\n    private char NC = (char) 0;\n    private byte[] buf = new byte[BS];\n    private int bId = 0, size = 0;\n    private char c = NC;\n    private double cnt = 1;\n    private BufferedInputStream in;\n\n    public FastScanner() {\n        in = new BufferedInputStream(System.in, BS);\n    }\n\n    public FastScanner(String s) {\n        try {\n            in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n        } catch (Exception e) {\n            in = new BufferedInputStream(System.in, BS);\n        }\n    }\n\n    private char getChar() {\n        while (bId == size) {\n            try {\n                size = in.read(buf);\n            } catch (Exception e) {\n                return NC;\n            }\n            if (size == -1) return NC;\n            bId = 0;\n        }\n        return (char) buf[bId++];\n    }\n\n    public int nextInt() {\n        return (int) nextLong();\n    }\n\n    public int[] nextInts(int N) {\n        int[] res = new int[N];\n        for (int i = 0; i < N; i++) {\n            res[i] = (int) nextLong();\n        }\n        return res;\n    }\n\n    public long[] nextLongs(int N) {\n        long[] res = new long[N];\n        for (int i = 0; i < N; i++) {\n            res[i] = nextLong();\n        }\n        return res;\n    }\n\n    public long nextLong() {\n        cnt = 1;\n        boolean neg = false;\n        if (c == NC) c = getChar();\n        for (; (c < '0' || c > '9'); c = getChar()) {\n            if (c == '-') neg = true;\n        }\n        long res = 0;\n        for (; c >= '0' && c <= '9'; c = getChar()) {\n            res = (res << 3) + (res << 1) + c - '0';\n            cnt *= 10;\n        }\n        return neg ? -res : res;\n    }\n\n    public double nextDouble() {\n        double cur = nextLong();\n        return c != '.' ? cur : cur + nextLong() / cnt;\n    }\n\n    public double[] nextDoubles(int N) {\n        double[] res = new double[N];\n        for (int i = 0; i < N; i++) {\n            res[i] = nextDouble();\n        }\n        return res;\n    }\n\n    public String next() {\n        StringBuilder res = new StringBuilder();\n        while (c <= 32) c = getChar();\n        while (c > 32) {\n            res.append(c);\n            c = getChar();\n        }\n        return res.toString();\n    }\n\n    public String nextLine() {\n        StringBuilder res = new StringBuilder();\n        while (c <= 32) c = getChar();\n        while (c != '\n') {\n            res.append(c);\n            c = getChar();\n        }\n        return res.toString();\n    }\n\n    public boolean hasNext() {\n        if (c > 32) return true;\n        while (true) {\n            c = getChar();\n            if (c == NC) return false;\n            else if (c > 32) return true;\n        }\n    }\n}","bitmasks,brute force,constructive algorithms,greedy,two pointers"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1498D extends PrintWriter {\n	CF1498D() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1498D o = new CF1498D(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		int[] tt = new int[n];\n		long[] xx = new long[n];\n		int[] yy = new int[n];\n		for (int i = 0; i < n; i++) {\n			tt[i] = sc.nextInt();\n			xx[i] = sc.nextLong();\n			yy[i] = sc.nextInt();\n		}\n		int[][] aa = new int[n][m + 1];\n		for (int i = 0; i < n; i++)\n			for (int j = 0; j <= m; j++)\n				aa[i][j] = m + 1;\n		aa[0][0] = 0;\n		for (int i = 0; i < n; i++) {\n			int t = tt[i];\n			long x = xx[i];\n			int y = yy[i];\n			for (int j = 0; j <= m; j++) {\n				int a = aa[i][j];\n				if (a == m + 1)\n					continue;\n				if (i + 1 < n)\n					aa[i + 1][j] = 0;\n				if (a == y)\n					continue;\n				if (t == 1) {\n					int j_ = (int) (j + (x + 99999) / 100000);\n					if (j_ <= m)\n						aa[i][j_] = Math.min(aa[i][j_], a + 1);\n				} else {\n					long j__ = (j * x + 99999) / 100000;\n					if (j__ <= m) {\n						int j_ = (int) j__;\n						aa[i][j_] = Math.min(aa[i][j_], a + 1);\n					}\n				}\n			}\n		}\n		for (int j = 1; j <= m; j++) {\n			int i = 0;\n			while (i < n && aa[i][j] == m + 1)\n				i++;\n			print((i < n ? i + 1 : -1) + "" "");\n		}\n		println();\n	}\n}\n","dfs and similar,dp,graphs,implementation"
"import java.io.*;\nimport java.util.*;\n\npublic class bananas_microwave {\n	public static void main(String[] args) throws IOException {\n		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer(in.readLine());\n		\n		int n = Integer.parseInt(st.nextToken());\n		\n		int m = Integer.parseInt(st.nextToken());\n		int[] ts = new int[n+1];\n		long[] xs = new long[n+1];\n		int[] ys = new int[n+1];\n		for (int i = 1; i <= n; i++) {\n			st = new StringTokenizer(in.readLine());\n			int t = Integer.parseInt(st.nextToken());\n			long x = Long.parseLong(st.nextToken());\n			int y = Integer.parseInt(st.nextToken());\n			ts[i]=t;\n			xs[i]=x;\n			ys[i]=y;\n		}\n		\n		int[][] dp = new int[n+1][m+1];\n		int[][] dp2 = new int[n+1][m+1];\n		for (int i = 0; i < dp.length; i++) {\n			Arrays.fill(dp[i], -1);\n		}\n		\n		dp[0][0]=0;\n		for (int i = 0; i <= n; i++) {\n			for (int j = 0; j <= m; j++) {\n				if(dp[i][j]==-1)\n					continue;\n				if(ts[i]==1) {\n					int xnot = (int)(xs[i]/100000L);\n					if(xnot*100000L!=xs[i])\n						xnot++;\n					int k = j+xnot;\n					if(k<=m && dp[i][k]==-1 && dp2[i][j]<ys[i]) {\n						dp[i][k]=i;\n						dp2[i][k]=dp2[i][j]+1;\n					}\n				}else {\n					long k = xs[i]*j/100000L;\n					if(k*100000!=xs[i]*j)\n						k++;\n					if(k<= m && dp[i][(int)k]==-1 && dp2[i][j]<ys[i]) {\n						dp[i][(int) k]=i;\n						dp2[i][(int)k]=dp2[i][j]+1;\n					}\n				}\n				if(i==n)\n					continue;\n				if(dp[i+1][j]==-1) \n					dp[i+1][j]=dp[i][j];\n			}\n		}\n		for (int i = 1; i < m; i++) {\n			System.out.print(dp[n][i]+"" "");\n		}\n		System.out.println(dp[n][m]);\n	}\n}\n","dfs and similar,dp,graphs,implementation"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class CF711Div2D {\n	public static void main(String[] args) throws IOException {\n		BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer(f.readLine());\n		int n = Integer.parseInt(st.nextToken());\n		int m = Integer.parseInt(st.nextToken());\n		int[] ts = new int[n+1];\n		long[] xs = new long[n+1];\n		int[] ys = new int[n+1];\n		for (int i = 1; i <= n; i++) {\n			st = new StringTokenizer(f.readLine());\n			int t = Integer.parseInt(st.nextToken());\n			long x = Long.parseLong(st.nextToken());\n			int y = Integer.parseInt(st.nextToken());\n			ts[i]=t;\n			xs[i]=x;\n			ys[i]=y;\n		}\n		\n		int[][] dp = new int[n+1][m+1];\n		int[][] dp2 = new int[n+1][m+1];\n		for (int i = 0; i < dp.length; i++) {\n			Arrays.fill(dp[i], -1);\n		}\n		dp[0][0]=0;\n		for (int i = 0; i <= n; i++) {\n			for (int j = 0; j <= m; j++) {\n				if(dp[i][j]==-1)\n					continue;\n				if(ts[i]==1) {\n					int xnot = (int)(xs[i]/100000L);\n					if(xnot*100000L!=xs[i])\n						xnot++;\n					int k = j+xnot;\n					if(k<=m && dp[i][k]==-1 && dp2[i][j]<ys[i]) {\n						dp[i][k]=i;\n						dp2[i][k]=dp2[i][j]+1;\n					}\n				}else {\n					long k = xs[i]*j/100000L;\n					if(k*100000!=xs[i]*j)\n						k++;\n					if(k<= m && dp[i][(int)k]==-1 && dp2[i][j]<ys[i]) {\n						dp[i][(int) k]=i;\n						dp2[i][(int)k]=dp2[i][j]+1;\n					}\n				}\n				if(i==n)\n					continue;\n				if(dp[i+1][j]==-1) \n					dp[i+1][j]=dp[i][j];\n			}\n		}\n		for (int i = 1; i < m; i++) {\n			System.out.print(dp[n][i]+"" "");\n		}\n		System.out.println(dp[n][m]);\n	}\n}\n","dfs and similar,dp,graphs,implementation"
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n	PrintWriter out = new PrintWriter(System.out);\n	BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer tok = new StringTokenizer("""");\n    String next() throws IOException {\n        if (!tok.hasMoreTokens()) { tok = new StringTokenizer(in.readLine()); }\n        return tok.nextToken();\n    }\n    int ni() throws IOException { return Integer.parseInt(next()); }\n    long nl() throws IOException { return Long.parseLong(next()); }\n    \n    long mod=1000000007;\n    \n    void solve() throws IOException {\n        int n=ni(),m=ni();\n        int[]A=new int[m+1];\n        //int[]C=new int[m+1];\n        Arrays.fill(A,-1);\n        A[0]=0;\n        \n        for (int i=1;i<=n;i++) {\n            int[]B=new int[m+1];\n            //HashSet<Integer>H=new HashSet();\n            int f=ni();\n            double x=nl();\n            int y=ni();\n            \n            for (int j=0;j<=m;j++) {\n                if (A[j]>-1) {\n                    long z=0;\n                    if (f==1) z=(long)Math.ceil(x/100000+j);\n                    else z=(long)Math.ceil((x*j)/100000);\n                    if (z<=m && A[(int)z]==-1) B[(int)z]=1;\n                    //out.println(i+"" ""+j+"" ""+z+"" ""+f);\n                }\n                else if (B[j]>0 && B[j]<y) {\n                    long z=0;\n                    if (f==1) z=(long)Math.ceil(x/100000+j);\n                    else z=(long)Math.ceil((x*j)/100000);\n                    if (z<=m && A[(int)z]==-1 && (B[(int)z]==0 || B[(int)z]>B[j]+1)) B[(int)z]=B[j]+1;\n                }\n            }\n            \n            for (int j=1;j<=m;j++) {\n                if (A[j]>-1) continue;\n                if (B[j]>0) A[j]=i;\n            }\n        }\n        \n        for (int i=1;i<=m;i++) {\n            if (A[i]<=n) out.print(A[i]+"" "");\n            else out.print(""-1 "");\n        }\n        out.println();\n        out.flush();\n    }\n    \n    int gcd(int a,int b) { return(b==0?a:gcd(b,a%b)); }\n    long gcd(long a,long b) { return(b==0?a:gcd(b,a%b)); }\n    long mp(long a,long p) { long r=1; while(p>0) { if ((p&1)==1) r=(r*a)%mod; p>>=1; a=(a*a)%mod; } return r; }\n    \n    public static void main(String[] args) throws IOException {\n        new Main().solve();\n    }\n}","dfs and similar,dp,graphs,implementation"
"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class _1497A {\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n\n		int T = sc.nextInt();\n		for (int t = 0; t < T; ++t) {\n			int n = sc.nextInt();\n			int[] a = new int[n];\n			for (int i = 0; i < n; i++) a[i] = sc.nextInt();\n			for (int i = 0; i < n; i++) {\n				int be = 0;\n				for (int j = 0; j < n; j++) {\n					if (a[j] == i) be = j;\n					if (a[be] != i && a[j] != 1000) be = j;\n				}\n				System.out.print(a[be] + "" "");\n				a[be] = 1000;\n			}\n			System.out.println();\n		}\n	}\n\n}\n","brute force,data structures,greedy,sortings"
"import java.util.Scanner;\n\npublic class Meximization {\n	public static void main(String[] args) {\n		int t,n,in;\n		Scanner sc = new Scanner(System.in);\n		t=sc.nextInt();\n		while(t-->0) {\n			n=sc.nextInt();\n			int[] nums = new int[101];\n			for(int i=0;i<n;i++) {\n				in = sc.nextInt();\n				nums[in]++;\n			}\n			while(n>0) {\n				for(int i=0;i<=100 && n>0;i++) {\n					if(nums[i]>0) {\n						System.out.print(i);\n						nums[i]--;\n						n--;\n						if(n>0) {\n							System.out.print("" "");\n						}\n					}\n				}\n			}\n			System.out.println();\n		}\n		sc.close();\n	}\n}\n","brute force,data structures,greedy,sortings"
"import java.util.*;\n\npublic class yo {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		for (int xx = 0; xx < t; xx++) {\n			int n = sc.nextInt();\n			TreeSet<Integer> arr = new TreeSet<>();\n			ArrayList<Integer> ar = new ArrayList<>();\n			for(int i=0;i<n;i++)\n			{\n				int a = sc.nextInt();\n				if(arr.contains(a))\n				{\n					ar.add(a);\n				}\n				else\n				{\n					arr.add(a);\n				}\n			}\n			for(int i:arr)\n				System.out.print(i+"" "");\n			for(int i:ar)\n				System.out.print(i+"" "");\n			System.out.println();\n		}\n	}\n}","brute force,data structures,greedy,sortings"
"import java.util.*;\n\npublic class MEX\n{\n	public static void main(String args[])\n	{\n		Scanner s= new Scanner(System.in);\n		\n		int t=s.nextInt();\n		while(t-->0)\n		{\n			int n=s.nextInt();\n			int[] arr = new int[n];\n			int[] b = new int[n];\n			for(int i=0;i<n;i++)\n			{\n				arr[i]=s.nextInt();\n			}\n			Arrays.sort(arr);\n			b[0]=arr[0];\n			int j=0;\n			for(int i=1;i<n;i++)\n			{\n				if(arr[i-1]==arr[i])\n				{\n					b[n-1-j]=arr[i];\n					j++;\n				}\n				else\n				{\n					b[i-j]=arr[i];\n				}\n			}\n			\n			for(int i=0;i<n;i++)\n			{\n				System.out.print(b[i]+"" "");\n			}\n			System.out.println();\n		}\n	}\n}","brute force,data structures,greedy,sortings"
"import java.util.*;\n\npublic class t2{\n	static Scanner sc = new Scanner(System.in);\n	static void solve() {\n		int n = sc.nextInt(), k = sc.nextInt();\n		Set<Integer> s = new HashSet<>();\n		int x = Integer.MIN_VALUE;\n		for(int i=0;i<n;i++) {\n			int t = sc.nextInt();\n			s.add(t);\n			x = Math.max(x, t);\n		}\n		int j = 0;\n		if(k==0) {\n			System.out.println(s.size());\n			return;\n		}\n		while(s.contains(j))\n			j++;\n		if(j==x+1)\n			System.out.println(s.size()+k);\n		else\n		{\n			int z = (int)Math.ceil((x+j)/2.0);\n			if(s.contains(z))\n				System.out.println(s.size());\n			else\n				System.out.println(s.size()+1);\n		}\n	}\n	public static void main(String[] args) {\n		int t = sc.nextInt();\n		for(int i=0;i<t;i++)\n			solve();\n	}\n}\n",math
"import java.util.*;\n\npublic class t2{\n	static Scanner sc = new Scanner(System.in);\n	static void solve() {\n		int n = sc.nextInt(), k = sc.nextInt();\n		Set<Integer> s = new HashSet<>();\n		int x = Integer.MIN_VALUE;\n		for(int i=0;i<n;i++) {\n			int t = sc.nextInt();\n			s.add(t);\n			x = Math.max(x, t);\n		}\n		int j = 0;\n		if(k==0) {\n			System.out.println(s.size());\n			return;\n		}\n		while(s.contains(j))\n			j++;\n		if(j==x+1)\n			System.out.println(s.size()+k);\n		else\n		{\n			int z = (int)Math.ceil((x+j)/2.0);\n			if(s.contains(z))\n				System.out.println(s.size());\n			else\n				System.out.println(s.size()+1);\n		}\n	}\n	public static void main(String[] args) {\n		int t = sc.nextInt();\n		for(int i=0;i<t;i++)\n			solve();\n	}\n}\n",math
"import java.util.*;\n\npublic class t2{\n	static Scanner sc = new Scanner(System.in);\n	static void solve() {\n		int n = sc.nextInt(), k = sc.nextInt();\n		Set<Integer> s = new HashSet<>();\n		int x = Integer.MIN_VALUE;\n		for(int i=0;i<n;i++) {\n			int t = sc.nextInt();\n			s.add(t);\n			x = Math.max(x, t);\n		}\n		int j = 0;\n		if(k==0) {\n			System.out.println(s.size());\n			return;\n		}\n		while(s.contains(j))\n			j++;\n		if(j==x+1)\n			System.out.println(s.size()+k);\n		else\n		{\n			int z = (int)Math.ceil((x+j)/2.0);\n			if(s.contains(z))\n				System.out.println(s.size());\n			else\n				System.out.println(s.size()+1);\n		}\n	}\n	public static void main(String[] args) {\n		int t = sc.nextInt();\n		for(int i=0;i<t;i++)\n			solve();\n	}\n}\n",math
"import java.util.*;\n\npublic class t2{\n	static Scanner sc = new Scanner(System.in);\n	static void solve() {\n		int n = sc.nextInt(), k = sc.nextInt();\n		Set<Integer> s = new HashSet<>();\n		int x = Integer.MIN_VALUE;\n		for(int i=0;i<n;i++) {\n			int t = sc.nextInt();\n			s.add(t);\n			x = Math.max(x, t);\n		}\n		int j = 0;\n		if(k==0) {\n			System.out.println(s.size());\n			return;\n		}\n		while(s.contains(j))\n			j++;\n		if(j==x+1)\n			System.out.println(s.size()+k);\n		else\n		{\n			int z = (int)Math.ceil((x+j)/2.0);\n			if(s.contains(z))\n				System.out.println(s.size());\n			else\n				System.out.println(s.size()+1);\n		}\n	}\n	public static void main(String[] args) {\n		int t = sc.nextInt();\n		for(int i=0;i<t;i++)\n			solve();\n	}\n}\n",math
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1494E extends PrintWriter {\n	CF1494E() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1494E o = new CF1494E(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		HashMap<Long, Character> mp = new HashMap<>();\n		int kab = 0, kaa = 0;\n		while (m-- > 0) {\n			char t = sc.next().charAt(0);\n			if (t == '?') {\n				int k = sc.nextInt();\n				println((k % 2 == 1 ? kaa + kab : kaa) > 0 ? ""YES"" : ""NO"");\n			} else {\n				int i = sc.nextInt() - 1;\n				int j = sc.nextInt() - 1;\n				long ij = (long) i * n + j;\n				long ji = (long) j * n + i;\n				char b = mp.getOrDefault(ji, ' ');\n				if (t == '+') {\n					char a = sc.next().charAt(0);\n					mp.put(ij, a);\n					if (b != ' ') {\n						if (a == b)\n							kaa++;\n						else\n							kab++;\n					}\n				} else {\n					char a = mp.get(ij);\n					mp.remove(ij);\n					if (b != ' ') {\n						if (a == b)\n							kaa--;\n						else\n							kab--;\n					}\n				}\n			}\n		}\n	}\n}\n","constructive algorithms,data structures,graphs,hashing"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1494E extends PrintWriter {\n	CF1494E() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1494E o = new CF1494E(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		HashMap<Long, Character> mp = new HashMap<>();\n		int kab = 0, kaa = 0;\n		while (m-- > 0) {\n			char t = sc.next().charAt(0);\n			if (t == '?') {\n				int k = sc.nextInt();\n				println((k % 2 == 1 ? kaa + kab : kaa) > 0 ? ""YES"" : ""NO"");\n			} else {\n				int i = sc.nextInt() - 1;\n				int j = sc.nextInt() - 1;\n				long ij = (long) i * n + j;\n				long ji = (long) j * n + i;\n				char b = mp.getOrDefault(ji, ' ');\n				if (t == '+') {\n					char a = sc.next().charAt(0);\n					mp.put(ij, a);\n					if (b != ' ') {\n						if (a == b)\n							kaa++;\n						else\n							kab++;\n					}\n				} else {\n					char a = mp.get(ij);\n					mp.remove(ij);\n					if (b != ' ') {\n						if (a == b)\n							kaa--;\n						else\n							kab--;\n					}\n				}\n			}\n		}\n	}\n}\n","constructive algorithms,data structures,graphs,hashing"
"import java.io.*;\nimport java.util.*;\n\npublic class Main extends PrintWriter {\n	Main() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		Main o = new Main(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		HashMap<Long,Character> map=new HashMap<>();\n        int kaa=0,kab=0;\n        while(m-->0){\n            char t=sc.next().charAt(0);\n            if(t=='?'){\n                int k=sc.nextInt();\n                println(((k%2==1)?kaa+kab:kaa)>0 ?""YES"":""NO"");\n\n            }else{\n                int i=sc.nextInt()-1;\n                int j=sc.nextInt()-1;\n\n                long ij=(long)i*n+j;\n                long ji=(long)j*n+i;\n\n                char b=map.getOrDefault(ji, ' ');\n                if(t=='+'){\n                    char a=sc.next().charAt(0);\n                    map.put(ij, a);\n                    if(b!=' '){\n                        if(a==b)kaa++;\n                        else kab++;\n                    }\n                }else{\n                    char a=map.get(ij);\n                    map.remove(ij);\n                    if(b!=' '){\n                        if(a==b)kaa--;\n                        else kab--;\n                    }\n\n                }\n            }\n        }\n	}\n}\n","constructive algorithms,data structures,graphs,hashing"
"import java.io.*; \nimport java.util.*;\nimport java.math.*; \n\npublic class Main {\n	\n	public static void main(String[] args) throws IOException \n	{ \n		FastScanner f = new FastScanner(); \n		int t=1;\n//		t=f.nextInt();\n		PrintWriter out=new PrintWriter(System.out);\n		while(t>0) {\n			t--;\n			int n=f.nextInt();\n			int m=f.nextInt();\n			HashMap<Integer,Integer>[] graph=new HashMap[n];\n			for(int i=0;i<n;i++) {\n				graph[i]=new HashMap<>();\n			}\n			int counta=0;\n			int countb=0;\n			for(int i=0;i<m;i++) {\n				char l=f.next().charAt(0);\n//				System.out.println(l);\n				if(l=='+') {\n					int u=f.nextInt()-1;\n					int v=f.nextInt()-1;\n					char lab=f.next().charAt(0);\n					int label=lab-'a';\n//					System.out.println(u+"" ""+v+"" ""+lab);\n					graph[u].put(v,label);\n					if(graph[v].containsKey(u)) {\n						counta+=2;\n					}\n					if(graph[v].containsKey(u) && graph[u].get(v)==graph[v].get(u)) {\n						countb+=2;\n					}\n				}\n				else if(l=='-') {\n					int u=f.nextInt()-1;\n					int v=f.nextInt()-1;\n					if(graph[v].containsKey(u)) {\n						counta-=2;\n					}\n					if(graph[v].containsKey(u) && graph[u].get(v)==graph[v].get(u)) {\n						countb-=2;\n					}\n					graph[u].remove(v);\n				}\n				else {\n					int k=f.nextInt();\n//					System.out.println(doub);\n//					System.out.println(same);\n					if(k%2==1) {\n						if(counta>0) {\n							System.out.println(""YES"");\n						}\n						else{\n							System.out.println(""NO"");\n						}\n					}\n					else {\n						if(countb>0) {\n							System.out.println(""YES"");\n						}\n						else{\n							System.out.println(""NO"");\n						}\n					}\n				}\n			}\n		}\n		out.close();\n	} \n	static void sort(int [] a) {\n        ArrayList<Integer> q = new ArrayList<>();\n        for (int i: a) q.add(i);\n        Collections.sort(q);\n        for (int i = 0; i < a.length; i++) a[i] = q.get(i);\n    }\n    \n	static class FastScanner {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n		String next() {\n			while (!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		int[] readArray(int n) {\n			int[] a=new int[n];\n			for (int i=0; i<n; i++) a[i]=nextInt();\n			return a;\n		}\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n		long[] readLongArray(int n) {\n			long[] a=new long[n];\n			for (int i=0; i<n; i++) a[i]=nextLong();\n			return a;\n		}\n	}\n} 	","constructive algorithms,data structures,graphs,hashing"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class BigXor {\n\n    static BufferedReader input;\n    static StringTokenizer stoken = new StringTokenizer("""");\n    static String nextString() throws IOException {\n        while (!stoken.hasMoreTokens()){\n            String st = input.readLine();\n            stoken = new StringTokenizer(st);\n        }\n        return stoken.nextToken();\n    }\n    public static void main(String[] args)  throws Exception{\n        input = new BufferedReader(\n                new InputStreamReader(System.in)\n        );\n        nextString();\n        String l = nextString();\n        String r = nextString();\n        if(""0"".equals(r)) {\n            System.out.println(""0"");\n            return;\n        }\n        int n = r.length();\n        if(l.charAt(0) == '0') {\n            char[] a = new char[n];\n            for(int i = 0; i<n; ++i) {\n                a[i] = '1';\n\n            }\n            System.out.println(new String(a));\n            return;\n        }\n        if(r.charAt(n-1) == '1') {\n            System.out.println(r);\n            return;\n        }\n        if(l.equals(r)) {\n            System.out.println(r);\n            return;\n        }\n\n        int t = l.lastIndexOf(""0"");\n        if(r.lastIndexOf(""1"") == t)\n        if(r.substring(0,t).equals(l.substring(0, t))) {\n            System.out.println(r);\n            return;\n        }\n\n        System.out.print(r.substring(0, n-1));\n        System.out.println(1);\n    }\n}\n","bitmasks,constructive algorithms,greedy,math,strings,two pointers"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class problemE {\n    static class Solution {\n        void solve() {\n            int n = fs.nextInt();\n            char[] L = fs.next().toCharArray();\n            char[] R = fs.next().toCharArray();\n\n            if (L[0] == '0' && R[0] == '1') {\n                for (int i = 0 ; i < n ; i ++ ) out.print('1');\n                out.println();\n                return;\n            }\n\n            if (R[n-1] == '1') {\n                out.println(new String(R));\n                return;\n            }\n\n            if (equal(L, R)) {\n                out.println(new String(R));\n                return;\n            }\n\n            inc(L);\n            if (equal(L, R)) {\n                out.println(new String(R));\n                return;\n            }\n\n            inc(R);\n            out.println(new String(R));\n        }\n\n        void inc(char[] L) {\n            int n = L.length;\n            for (int i = L.length-1, carry = 1; i >= 0 ; i --) {\n                int sum = (int)(L[i]-'0') + carry;\n                L[i] = (char)((sum&1) + '0');\n                carry = sum >> 1;\n            }\n        }\n\n        boolean equal(char[] L, char[] R) {\n            for (int i = L.length-1; i >= 0 ; i --) if (L[i] != R[i]) return false;\n            return true;\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        int T = 1;\n        Solution solution = new Solution();\n        for (int t = 0; t < T; t++) solution.solve();\n        out.close();\n    }\n\n    static void debug(Object... O) {\n        System.err.println(""DEBUG: "" + Arrays.deepToString(O));\n    }\n\n    private static FastScanner fs = new FastScanner();\n    private static PrintWriter out = new PrintWriter(System.out);\n\n    static class FastScanner { // Thanks SecondThread.\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer("""");\n\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        long[] readLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n\n        ArrayList<Integer> readArrayList(int n) {\n            ArrayList<Integer> a = new ArrayList<>(n);\n            for (int i = 0 ; i < n; i ++ ) a.add(fs.nextInt());\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextString() {\n            return next();\n        }\n    }\n}\n","bitmasks,constructive algorithms,greedy,math,strings,two pointers"
"//package round705;\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Queue;\n\npublic class E {\n	InputStream is;\n	FastWriter out;\n	String INPUT = """";\n\n	boolean compare(char[] a, char[] b)\n	{\n		for(int i = 0;i < a.length;i++){\n			if(a[i] < b[i])return true;\n			if(a[i] > b[i])return false;\n		}\n		return false;\n	}\n\n	void solve()\n	{\n		int n = ni();\n\n		char[] L = ns(n);\n		char[] R = ns(n);\n		char[] best = R;\n		for(int i = 0;i < n;i++){\n			if(L[i] != R[i]){\n				char[] can = new char[n];\n				for(int j = 0;j < n;j++){\n					can[j] = j < i ? '0' : '1';\n				}\n				if(compare(best, can)){\n					best = can;\n				}\n				break;\n			}\n		}\n\n		if(n >= 1){\n			char[] RR = Arrays.copyOf(R, n);\n			RR[n-1] = '0';\n			if(dec(RR) && compare(L, RR)){\n				RR = Arrays.copyOf(R, n);\n				RR[n-1] = '1';\n				if (compare(best, RR)) {\n					best = RR;\n				}\n			}\n		}\n\n		out.println(new String(best));\n	}\n\n	boolean dec(char[] RR)\n	{\n		for(int i = RR.length-1;i >= 0;i--){\n			if(RR[i] == '0'){\n				RR[i] = '1';\n			}else{\n				RR[i] = '0';\n				return true;\n			}\n		}\n		return false;\n	}\n	\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new FastWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new E().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n\n	private long[] nal(int n)\n	{\n		long[] a = new long[n];\n		for(int i = 0;i < n;i++)a[i] = nl();\n		return a;\n	}\n\n	private char[][] nm(int n, int m) {\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n\n	private int[][] nmi(int n, int m) {\n		int[][] map = new int[n][];\n		for(int i = 0;i < n;i++)map[i] = na(m);\n		return map;\n	}\n\n	private int ni() { return (int)nl(); }\n\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n\n	public static class FastWriter\n	{\n		private static final int BUF_SIZE = 1<<13;\n		private final byte[] buf = new byte[BUF_SIZE];\n		private final OutputStream out;\n		private int ptr = 0;\n\n		private FastWriter(){out = null;}\n\n		public FastWriter(OutputStream os)\n		{\n			this.out = os;\n		}\n\n		public FastWriter(String path)\n		{\n			try {\n				this.out = new FileOutputStream(path);\n			} catch (FileNotFoundException e) {\n				throw new RuntimeException(""FastWriter"");\n			}\n		}\n\n		public FastWriter write(byte b)\n		{\n			buf[ptr++] = b;\n			if(ptr == BUF_SIZE)innerflush();\n			return this;\n		}\n\n		public FastWriter write(char c)\n		{\n			return write((byte)c);\n		}\n\n		public FastWriter write(char[] s)\n		{\n			for(char c : s){\n				buf[ptr++] = (byte)c;\n				if(ptr == BUF_SIZE)innerflush();\n			}\n			return this;\n		}\n\n		public FastWriter write(String s)\n		{\n			s.chars().forEach(c -> {\n				buf[ptr++] = (byte)c;\n				if(ptr == BUF_SIZE)innerflush();\n			});\n			return this;\n		}\n\n		private static int countDigits(int l) {\n			if (l >= 1000000000) return 10;\n			if (l >= 100000000) return 9;\n			if (l >= 10000000) return 8;\n			if (l >= 1000000) return 7;\n			if (l >= 100000) return 6;\n			if (l >= 10000) return 5;\n			if (l >= 1000) return 4;\n			if (l >= 100) return 3;\n			if (l >= 10) return 2;\n			return 1;\n		}\n\n		public FastWriter write(int x)\n		{\n			if(x == Integer.MIN_VALUE){\n				return write((long)x);\n			}\n			if(ptr + 12 >= BUF_SIZE)innerflush();\n			if(x < 0){\n				write((byte)'-');\n				x = -x;\n			}\n			int d = countDigits(x);\n			for(int i = ptr + d - 1;i >= ptr;i--){\n				buf[i] = (byte)('0'+x%10);\n				x /= 10;\n			}\n			ptr += d;\n			return this;\n		}\n\n		private static int countDigits(long l) {\n			if (l >= 1000000000000000000L) return 19;\n			if (l >= 100000000000000000L) return 18;\n			if (l >= 10000000000000000L) return 17;\n			if (l >= 1000000000000000L) return 16;\n			if (l >= 100000000000000L) return 15;\n			if (l >= 10000000000000L) return 14;\n			if (l >= 1000000000000L) return 13;\n			if (l >= 100000000000L) return 12;\n			if (l >= 10000000000L) return 11;\n			if (l >= 1000000000L) return 10;\n			if (l >= 100000000L) return 9;\n			if (l >= 10000000L) return 8;\n			if (l >= 1000000L) return 7;\n			if (l >= 100000L) return 6;\n			if (l >= 10000L) return 5;\n			if (l >= 1000L) return 4;\n			if (l >= 100L) return 3;\n			if (l >= 10L) return 2;\n			return 1;\n		}\n\n		public FastWriter write(long x)\n		{\n			if(x == Long.MIN_VALUE){\n				return write("""" + x);\n			}\n			if(ptr + 21 >= BUF_SIZE)innerflush();\n			if(x < 0){\n				write((byte)'-');\n				x = -x;\n			}\n			int d = countDigits(x);\n			for(int i = ptr + d - 1;i >= ptr;i--){\n				buf[i] = (byte)('0'+x%10);\n				x /= 10;\n			}\n			ptr += d;\n			return this;\n		}\n\n		public FastWriter write(double x, int precision)\n		{\n			if(x < 0){\n				write('-');\n				x = -x;\n			}\n			x += Math.pow(10, -precision)/2;\n			//		if(x < 0){ x = 0; }\n			write((long)x).write(""."");\n			x -= (long)x;\n			for(int i = 0;i < precision;i++){\n				x *= 10;\n				write((char)('0'+(int)x));\n				x -= (int)x;\n			}\n			return this;\n		}\n\n		public FastWriter writeln(char c){\n			return write(c).writeln();\n		}\n\n		public FastWriter writeln(int x){\n			return write(x).writeln();\n		}\n\n		public FastWriter writeln(long x){\n			return write(x).writeln();\n		}\n\n		public FastWriter writeln(double x, int precision){\n			return write(x, precision).writeln();\n		}\n\n		public FastWriter write(int... xs)\n		{\n			boolean first = true;\n			for(int x : xs) {\n				if (!first) write(' ');\n				first = false;\n				write(x);\n			}\n			return this;\n		}\n\n		public FastWriter write(long... xs)\n		{\n			boolean first = true;\n			for(long x : xs) {\n				if (!first) write(' ');\n				first = false;\n				write(x);\n			}\n			return this;\n		}\n\n		public FastWriter writeln()\n		{\n			return write((byte)'\n');\n		}\n\n		public FastWriter writeln(int... xs)\n		{\n			return write(xs).writeln();\n		}\n\n		public FastWriter writeln(long... xs)\n		{\n			return write(xs).writeln();\n		}\n\n		public FastWriter writeln(char[] line)\n		{\n			return write(line).writeln();\n		}\n\n		public FastWriter writeln(char[]... map)\n		{\n			for(char[] line : map)write(line).writeln();\n			return this;\n		}\n\n		public FastWriter writeln(String s)\n		{\n			return write(s).writeln();\n		}\n\n		private void innerflush()\n		{\n			try {\n				out.write(buf, 0, ptr);\n				ptr = 0;\n			} catch (IOException e) {\n				throw new RuntimeException(""innerflush"");\n			}\n		}\n\n		public void flush()\n		{\n			innerflush();\n			try {\n				out.flush();\n			} catch (IOException e) {\n				throw new RuntimeException(""flush"");\n			}\n		}\n\n		public FastWriter print(byte b) { return write(b); }\n		public FastWriter print(char c) { return write(c); }\n		public FastWriter print(char[] s) { return write(s); }\n		public FastWriter print(String s) { return write(s); }\n		public FastWriter print(int x) { return write(x); }\n		public FastWriter print(long x) { return write(x); }\n		public FastWriter print(double x, int precision) { return write(x, precision); }\n		public FastWriter println(char c){ return writeln(c); }\n		public FastWriter println(int x){ return writeln(x); }\n		public FastWriter println(long x){ return writeln(x); }\n		public FastWriter println(double x, int precision){ return writeln(x, precision); }\n		public FastWriter print(int... xs) { return write(xs); }\n		public FastWriter print(long... xs) { return write(xs); }\n		public FastWriter println(int... xs) { return writeln(xs); }\n		public FastWriter println(long... xs) { return writeln(xs); }\n		public FastWriter println(char[] line) { return writeln(line); }\n		public FastWriter println(char[]... map) { return writeln(map); }\n		public FastWriter println(String s) { return writeln(s); }\n		public FastWriter println() { return writeln(); }\n	}\n\n	public void trnz(int... o)\n	{\n		for(int i = 0;i < o.length;i++)if(o[i] != 0)System.out.print(i+"":""+o[i]+"" "");\n		System.out.println();\n	}\n\n	// print ids which are 1\n	public void trt(long... o)\n	{\n		Queue<Integer> stands = new ArrayDeque<>();\n		for(int i = 0;i < o.length;i++){\n			for(long x = o[i];x != 0;x &= x-1)stands.add(i<<6|Long.numberOfTrailingZeros(x));\n		}\n		System.out.println(stands);\n	}\n\n	public void tf(boolean... r)\n	{\n		for(boolean x : r)System.out.print(x?'#':'.');\n		System.out.println();\n	}\n\n	public void tf(boolean[]... b)\n	{\n		for(boolean[] r : b) {\n			for(boolean x : r)System.out.print(x?'#':'.');\n			System.out.println();\n		}\n		System.out.println();\n	}\n\n	public void tf(long[]... b)\n	{\n		if(INPUT.length() != 0) {\n			for (long[] r : b) {\n				for (long x : r) {\n					for (int i = 0; i < 64; i++) {\n						System.out.print(x << ~i < 0 ? '#' : '.');\n					}\n				}\n				System.out.println();\n			}\n			System.out.println();\n		}\n	}\n\n	public void tf(long... b)\n	{\n		if(INPUT.length() != 0) {\n			for (long x : b) {\n				for (int i = 0; i < 64; i++) {\n					System.out.print(x << ~i < 0 ? '#' : '.');\n				}\n			}\n			System.out.println();\n		}\n	}\n\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","bitmasks,constructive algorithms,greedy,math,strings,two pointers"
"// No sorcery shall prevail. //           \nimport java.util.*;\nimport java.io.*;\npublic class _InVoker_ {\n	//Variables\n	static long mod = 1000000007;\n	static long mod2 = 998244353;\n	static FastReader inp= new FastReader();\n	static PrintWriter out= new PrintWriter(System.out);\n	public static void main(String args[]) {		    	\n	   	_InVoker_ g=new _InVoker_();\n	   	g.main();\n	   	out.close();\n	}\n	\n	char a[],b[],gg[],wp[];\n	int n;\n	\n	//Main\n	void main() {\n		\n		n=inp.nextInt();\n		a=new char[n];\n		b=new char[n];\n		gg=new char[n];\n		wp=new char[n];\n		a=inp.next().toCharArray();\n		b=inp.next().toCharArray();\n		for(int i=0;i<n;i++) gg[i]=b[i];\n		if(b[n-1]=='0' && !go()) gg[n-1]='1';\n		Arrays.fill(wp, '0');\n		for(int i=0;i<n;i++) {\n			if(a[i]!=b[i]) {\n				for(;i<n;i++) {\n					wp[i]='1';\n				}\n				break;\n			}\n		}\n		print(Arrays.compare(gg, wp)>0?gg:wp);\n	}\n	\n	void print(char a[]) {\n		for(int i=0;i<a.length;i++) out.print(a[i]);\n	}\n	\n	boolean go() {\n		for(int i=0;i<n;i++) {\n			if(a[i]!=b[i]) {\n				for(i++;i<n;i++) {\n					if(a[i]!='1' || b[i]!='0') return false;\n				}\n				return true;\n			}\n		}\n		return true;\n	}\n	\n	/*********************************************************************************************************************************************************************************************************\n	 * ti;.                               .:,:i:         :,;;itt;.        fDDEDDEEEEEEKEEEEEKEEEEEEEEEEEEEEEEE###WKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWWWWWWWW#WWWWWKKKKKEE      :,:.    f::::. .,ijLGDDDDDDDEEEEEEE*\n	 *ti;.                               .:,:i:          .:,;itt;:      GLDEEGEEEEEEEEEEEEEEEEEEDEEEEEEEEEEE#W#WEKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWWWWWWWWWWWKKKKKKG.     .::.      f:,...,ijLGDDDDDDDDEEEEEE *\n	 *ti;.                               .:,:i:            :,;;iti,    :fDDEEEEEEEEEEEEEEEKEEEEDEEEEEEEEEEEW##WEEEKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWWWWWWWWWWWWKKKKKKEG     .::.       .f,::,ijLGDDDDDDDDEEEEEE *\n	 *ti;.                               .:,:i:             .,,;iti;.  LDDEEEEEEEEEEKEEEEWEEEDDEEEEEEEEEEE#WWWEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWWWWWWWWKKKKKEDj    .::.        .:L;;ijfGDDDDDDDDDEEEEE *\n	 *ti;.                               .:,:i:              .:,;;iii:LLDEEEEEEEEEEEKEEEEEEEEDEEEEEEEEEEEW#WWEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKWWKWWWWWWWWWWWWWWKKKKKKKEL    .::.         .:;LijLGGDDDDDDDDEEEEE *\n	 *ti;.                               .:,:;:                :,;;ittfDEEEEEEEEEEEEEEEEKEEEGEEEEEEEEEEEKWWWEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWWWWKKKKKKKELj   .::.          :,;jffGGDDDDDDDDDEEEE *\n	 *ti;.                               .:,:i:                 .,;;tGGDEEEEEEEEEEEKEEEKEEEDEEEEEEEEEEEEWWWEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWKWWWWWWKKKKKKKEEL   .::.          .:;itDGGDDDDDDDDDEEEE *\n	 *ti;.                               .:::;:                   :;ifDEEEEEEEEEEEEKEEEKEEEEEEEEEEEEEEEWWWEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKW#WWWKKKKKKKKEEf   .::.           :,itfGEDDDDDDDDDDDEE *\n	 *ti;.                               .:::;:                    :GGEEEEEEEEEEEKEKEEKEEEEEEEEEEEEEEEEWWEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKW#WKKKKKKKKKEEDG  .::.           .,;jfLGKDLDDDDDDEEDD *\n	 *ti;.                               .:::;:                     fDEEEEEEKKKKKKKKKEKEEEEEEEEEEEEEEE#WEEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKW#KKKKKKKKKKEEf .:::.           .,;tfLGDEDDDDDDDDEEE *\n	 *ti;.                                :::;:                    fDEEEEEEKKKKKKKKKKWKEEEEEEEEEEEEEEEWKEEEEEEEEEEEEEEEEEEEEKEKKKKKKKKKKKKKKKKKKKKKKKKKKKKW##KKKKKKKKKEEft :::.           .,;tfLGDDDKDDDDDDDDD *\n	 *ti;.                                .::;:                    fDEEEEEEKKKKKKKWKKKKKEEEEEEEEEEEEE#WEEWEEEEEDEEDEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKW#WKKKKKKKKEEGG :,:.           .,;tfLGGDDDKDDDDDDDD *\n	 *ti;.                                .:.;:                   tGDEEEEKKKKKKKKKKKKKKKKKEEEEEEEEEEEWEEKWEEEEEEEDEEEEEEEEEEEEEEKEKKKKKKKKKKKKKKKKKKKKKKKKKKWWWKKKKKKKEEDf :::.           .,;tfLGGDDDDEDDDDDDD *\n	 *ti;.                                .::;:                   fDEEEEEKKKKKKKKKKKWKKKKKKKKEEEEEEEWWEEWEEEEEEEEEEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKW##KKKKKKKEEEft.::.           .,;tfLGGDDDDDDEDDDDD *\n	 *ti;.                                .:.;:                  tGDEEEKKKKKKKKKKKKKKKKKKKKKKEKEEEEE#EEWWEEEEEEEEEEEEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKW#WKKKKKKEEEGD:::.           .,;tfLGGDDDDDDDEDDDD *\n	 *ti;.                                .:.,.                  LDEEEEKKKKKKKKKKWKWKKKKKKKKKKKKEEEKWEKW#EEEEEEEEEEEEEEEEKEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKW##KKKKKKEEEEf,,:.           .,;tfLGGDDDDDDDDEDDD *\n	 *ti;.                               ..:.,.                 LGDEEEEKKKKKKKKKKWKKKKKKKKKKKKKKKKKWEEW#WEEEEEEEEEEEEEEEKEEEEEEEEEEEEEEEEEEEKEKKKKKKKKKKKKKKKK##KKKKKEEEEEfi;,.           .,;tfLGGDDDDDDDDDKDD *\n	 *tt;.                                .:.,:                 jDEEEEKKKKKKKKKKWWKKKKKKKKKKKKKKKKKWKE#WWEEEEEEEEEEEEEEWEEEEEEEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKWWKKKKEEEEDfG;,:           .,;tfLGGDDDDDDDDDDKD *\n	 *tii,.                               .:.,.                tGDEEEEKKKKKKKKKKWWWKKKKKKKKKKKKKKKWKKWWWKEEEEEEEEEEEEEKEEEEEEEEEEEEEEEEEEEEEEEEEEEEEKKKKKKKKKKKW#KKKKEEEEDGGi;,.          .,;tfLGGDDDDDDDDDDDE *\n	 *ti;;,:.                             .:.,:                fDEEEEKKKKKKKKKKKWKKKKKKKKKKKKKKKKKWEK#WWKEEEEEEEEEEEEDEEEEEEEEEEEEEEGEEEEEEEEEEEEEEEEEEEKKKKKKKWWKKEEEEEEDDf;;;,.         .,;tfLGGDDDDDDDDDDDD *\n	 *tii;,,:..                           ...,.               ;LEEEEEKKKKKKWKKKKWKKKKKKKKKKKKKKKKKEKKW#WEEEEEEEEEEEEEjEEEEEEEEEKEEEEGEEEEEEEEEKEEEEEEEEEEEEEEEEE#WKEEEEEEDDf;;;;,:        .,itfLGGDDDDDDDDDDDD *\n	 *ti;,,,,,:.                          ...,.               LDEEEEKKKKKKKKKKKWWWKKKKKKKKKKKKKKKWKK#W#WEEEEEEEEEEEDDLEEEEEEEEEWEEEEDEEEEEEEEEKEEEEEEEEEEEEEEEEEWWEEEEEEEDDfj,,,,,:.      .,itfGGGDDDDDDDDDDDD *\n	 *tii,,,,::::.                        ...,:              .fDEEEEKKKKKKWKKKKWWWKKKKKKKKKKKKKKKEKKW#WWEEEEEEEEEEEKiKEEKEEEEEEWEEEEDEEEEEEEEEEEEEEEEEEEEEEEEEEEWWEEEEEEEDDLD:::,,,:.     .,ijfGGGDDDDDDDDDDDD *\n	 *ti;:::::::::..                      .:.,:              LDEEEEKKKKKKKWKKKKWWKKKKKKKKKKKKKKKKtKKWWWWKEEEEEEEEEDiiDEEEEEEEEWWEEEEEEDEEEEEEEEEEEEEEEEEEEEEEEEEEWKEEEEEDDDGL:. .:,,,:    .,ijLGGGDDDDDDDDDDDD *\n	 *tt;. .::::::::..                    ...,:             :fDEEEKKKKKKKKKKKKWW#KKKKKKKKKKKKKKKKfKKWWWWKEEEEEEEEDti,DEKEEEEEEWWEEEDEEEEEEEEEKEEEEEEEEEEEEEDEEEEE#WEEEEEGGDGf:.  .:,;,:.  .,ijLGGDDDDDDDDDDDDD *\n	 *tt;.   .:::::::..                   ...,:             GDEEEKKKKKKKKWKKKKWWWKKKWKKKKKKKWWWKDEKLWWWWKKEEEEEEDEi,LDEEEEEEEEWWEEEEEEEEEEEEEEEEEEEEEEEEEDEDEEEEEW#EEEEDDDDGf,.    :,,,:...,ijLGGGDDDDDDDDDDDD *\n	 *tt;.    .....::::..                 ...,:             fDEEEKKKKKKKKWKKKKWWWWKKKWKKKKKKKKKKfWKiWWW#KKEEEEEEEi;.EDfEEEDEEiWWEEEEEEEEEEEEDGKEEEEEEEEEEDEEEEEEEWWEEEEDDDGGLi.     .,;,:::,ijLGGGDDDDDDDDDDDD *\n	 *tt;.      ....:::::.                ...,.            iDEEEEKKKKKKKKWKKWKWWWWWKKWWWKKKKKKKKtWKt#WWWKKEEEEEDji..DDKDDEDEGiWKEEEEEEEEEEDDEjEEEEEEEEEEEDEEEEEEEKWKEEDDDDGGff.      .:,;,,;ijLGGGDDDDDDDDDDDD *\n	 *tt;.        ....::::..              .:.,:           .LDEEEKKKKKKKKKKKKWWWWKWWWWWWWWWWKKKKWtKKiDWWWKKKEEEEKi:..DEDDDDDDiiWKEEEEEEEEEEDDEijDEEEEEKEEEEEEEEEEEEWWEEGDDDGGLG.       .:,;;iijLGGGDDDDDDDDDDDD *\n	 *tt;.          .....:::..            ...,.           .fEEEEKKKKKKKKWKKKKWWWWWWWWWWWWWWKWKKKiKDiLWWWWKEEEEEi,..fD:DDDDDti;WEEEEEEEEEEKDDi:iDDEEEEWEEEEEEEEEEEE#WEEGDDDDGGG.         :,iitjLGGGDDDDDDDDDDDD *\n	 *tti.            .....:::..          ...,.           GDEEEKKKKKKKKKWKKKWWW#WWWWWWWWWWWKWKKjiEjitWWWKKWEEEDi...DDLDDDDji;;WEEEEEEEEEEEDEj.iDDEEEEWEEEEEEEEEEEEWWEEDDDDDDGf.          .,;tjfLGGDDDDDDDDDDDD *\n	 *tti.              ....::::..        ...,.           fEEEKKKKKKKKKKKKKKKW#WWWWWWWWWWWWWWWWtiEiiiWWWKKEWKEi....D.EDDDEi;.fWEEEEEEEEEEDDfL.;EDDEEEWEEEEEEEEEEEEWWEEEDDDDDGf.           :;ijfLGGDDDDDDDDDDDD *\n	 *tti.                ....::::..      ...,.          LDEEEKKKKKKKKKKKKKKWWWWWWWWWWWWWWWW####WKiiiWWWKKKEEK,...:E:DDDEii..GWEEEEEEEEDWDDiL.,KDDEEEWEEEEEEEEEEEEWWKEEDDDDDGf:           .,itfLGGDDDDDDDDDDDD *\n	 *tti.                 .....:::..     ...,.          fDEEEKKKKKKKKKWKKKKWWWWWWWWWWWWW########WLiiWWWKKKEEjD...G,DDDDi;...EWEEEEEEEEDKDEii..LDDEEEWEEEEEEEEEEEEWWWEEDDDDDGfi           .,;tfLGGGDDDDDDDDDDD *\n	 *tti.                   .....:::..   ...,.         iGEEEKKKKKKKKKKWKKKKWWWWWWWWWWWW###########KiWWWKKEEE,.D..D.DDDii:...KKEEEEEEEEEDDj:...tEDEEEWEEEEEEEEEEEEWWWEEEDDDDDLL           .,;tjLLGGDDDDDDDDDDD *\n	 *tti.                     ....::::......:.         LEEEKKKKKKKKKKWWKKKWWW#KWWWWWWWW#####W####W##KWWKKEEL..:D.jjDDi;,....KKEEEEEEEDfDDi...:iKDEEEWKEEEEEEEEEEEWWWEEEEDDDDLG           .,;tjLLGGDDDDDDDDDDD *\n	 *tti.                        ...::::::..,.        :GEEEKKKKKKKKKKKKWWWWW##WWWWWWWWW##WKWK#W#W####WWKEEK.....G.DDti,.....KKEEEEEEDWGDf.,...iKDEEEWWEEEEEEEEEEEW#WEEEEEDDDGL           .,;tjLLGGDDDDDDDDDDD *\n	 *tti.                         ....::::::,.        GDEEKKKKKKKKKKKKKWWWW###WWWWWWWWWW#WWWK###W#####WKEKK.....jDDL;;......KKEEEEEEEEEDi.f...;KDEEEWWEEEEEEEEEEEWWWWEEEEEDDGf           .,;tjLLGGDDDDDDDDDDD *\n	 *tti.                           ....:::,,.       .LEEEKKKKKWKKKKKWWWWWW###WWWWWWWWWW#WWKW#WW##W#WWWKEKD:....:DD:;......;KEEEEEEEKiDD..f...,KKEEEWWEEEEEEEEEEEWWWWEEEEEDDDf           .:;tjLLGGGDDDDDDDDDD *\n	 *tti.                             ...::,,,:.     GDEEKKKKKKKKKKKKWWWWWWW#WWWWWWWWWWW#KjKWWWWWWWWWWWWEK.j,..;fD.;.......fKEEEEEDKG:Di..,....DKEEEWWEEEEEEKEKKKWWWWEEEEEEDDf           .:;tjLLGGDDDDDDDDDDD *\n	 *jti.                              ...::,,,,:.  .fEEEKKKKKWKKKKKKWWWWWWW#WWWWWWWWWWK#KKKWWWWWWWWWWWWWK..f:.:G.,:.......EKEEEEEKK;:E:.......fKEEEWWKEKEKKKKKKKW#WWEEEEEEDDf:          .,;tfLLGGDDDDDDDDDDD *\n	 *tti.                               ...:,,,;;,: iDEEKKKKKWKKKKKKKWWWWWWW#WWWWWWWWWWK#WDKWWKKWWWWWWWWWE..;G:G..,........KKEEEEEKi.Gi..:.....tKEEKWWWKKKKKKKKKKW##WKEEEEEEDfi          .,;tfLLGGGDDDDDDDDDD *\n	 *tti.                               ....::,,;;;,LEEKKKKKKWKKKKKWWWWWWW###WWWWWWWWWWKWWDKWEEEWKKWWWWWKKj.:LG..;.........EKEEEEKG;.G...;.....;KKEKWWWKKKKKKKKKKW##WWKEEEEEDfL          .,;tfLGGGDDDDDDDDDDD *\n	 *jti.                                ...::::,;ijDEEKKKKKWKKKKKKWKWWWWW##WWWWWWWWWWWKK#KKGDGDWEEWKKWKKGE,.i;.:.........:EKEEEKE;.:L...j.....,KWEKWWWKKKKKKKKKK####WKKEEEEDLG          .,;tfLGGGGDDDDDDDDDD *\n	 *jti.                                ...:...,,;GEEKKKKKWWKKKKKWWWWWWWW###WWWWWWWWWKKKWWKiLGGEDEDEKGKKiEG..;...........jKEEEKK;:.G....,.....:KKEWWWWKKKKKKKWKK####WKKKKEEEGL          .,;tfLGGGGDDDDDDDDDD *\n	 *jti.                                ...:.  .:,GEEKKKKKWKKKKKWWWWWWWW####WWWWWWWWWKKKWWKii;fDLGDK: EEi:E:.............EKEEKK;;..L...........KKKWWWWKKKKKKKWKK####WKKKWKEEDf          .,;tfGGGGDDDDDDDDDDD *\n	 *jti.                                ...:.    ,EEKKKKKWWKKKKKWWWWWWWWW###WWWWWWWWKKKKfWWLt;i,. fi  EG..D:.............EKEKK;;..t....:.......KWKWWWWKKKKKKKWKK####WKKKWEEEDf:.        .,;tfGGGGDDDDDDDDDDD *\n	 *jti.                                ...:.    GEEKKKKKWKKKKKWWWWWWWWW####WWWWWWWKKKKKt;KKEfff     .;t.................KKKKi;:..GtGGfG.......KWWWWWWKKKKKKKWKK###WWWKKKKEEEf,,:       .,;tfGGGGDDDDDDDDDDD *\n	 *jti.                                ...:.    GEKKKKKWWKKKKKWWWWWWWWWW##WWWWWWWKKKKKKt;EiKKKK,   ...t................jEKKG;;..,.....,LGi....KWWWWWWKKKKKKWKKKW####WKKKKKEEL,,,:.     .,;tfGGGDDDDDDDDDDDD *\n	 *jti.                                ...:.  .GEEKKKKKWKKKKKWWWWWWWWWW###WWWWWWWKKKKKKtiE::tGG........................EEEj;;...,.........:D..DKWWWWWWKKKKK#KKW###W#WKKKKKEEfj:,,,:.   .,;tfGGGDDDDDDDDDDDD *\n	 *jti.                                ...:.   DEKKKKKWWKKKKKWWWWWWWWW####WWWWWWWKKKKKKiiE:::.::.......................EEi;;...j.....f......:iDKWWWWWWKKKKK#WW######WKKKKKEELG :,,,,:. .,;tfGGGDDDDDDDDDDDD *\n	 *jti.                                ...:.  fEEKKKKWWKKKKWWWWWWWWWWW###WWWWWWWWKKKKKK;tE::..........................DD;.;,.::......;........EWWWWWWWKKKKW#WW#####WWKKKWKKELG  .:,,,:::,;tfGGGDDDDDDDDDDDD *\n	 *jti.                                ...:. .DEKEKKKWWKKKKWWWWWWWWWWW###WWWWWWWWKKKKKE,iD::..........................D..,;.,;tLffi...........DWDWWWW#KKKWWWWW#####W#KKKWKEEGL    .:,;,,,;tfGGGDDDDDDDDDDDD *\n	 *jti.                                ...:. ;EEKKKKWWKKKKKWWWWWW#WWWW####WWWWWWKKKKKEL:iD:..........................j ..;..;;:.....i,........DKtWWWWWKKWWWWWW#####WWWKKKEKEDf     .:,;;;itfGGGDDDDDDDDDDDD *\n	 *jti.                                ...:. DEKKKKKWWKKKKWWWWWWW#WWWW####WWWWWWKKKKKEj:iG...............................:....................GKiWWWWWKKWW#WWW######WWKKKKKEEf       .,;iitfGGGDDDDDDDDDDDD *\n	 *jti.                                ...:.:EKKKKKWWKKKKKWWWWWWW#WWW#####WWWWWKWKKKKEi:if:.................................iEKEKKKKKKDj......DKiWWWWWKWK##WW#######WWKKK:KEEL        .:;itfGGGDDDDDDDDDDDD *\n	 *jji.                                ...:,DEEKKKWWWKWKKWWWWWWWWWWWW#####WWWWWWWKKKKEi:it..................................j.  KKKKKKKKKKKf..DKiWWWWWKWW##WW#######WWKKK,KEEf         .,;tfGGGDDDDDDDDDDDD *\n	 *jji.                                ..L:iDEEKKKWWKKKKKWWWWWWWWWWWW#####WWWWWKWKKKKKi.i;..................................  . KKKWWWWWWWWK..DGiWWWWWKK##WWW#####W#WWKKKjEKEL,        .:;tfGGGDDDDDDDDDDDD *\n	 *jji.                               .f:::EEEKKKWWWKKKKKWWWWWWWWWWWW#####WWWWWKWKKKKK;.i,.................................::  KKEKWWWWWWfWK..EiiWWWWWKWW#WW##########KKKD,KELj        .:;tfGGDDDDDDDDDDDDD *\n	 *jji.                             .t::::,DEEKKKWWKKKKWWWWWWWWW#WWWW#####WWWWKKWKKKEK;.i:.................................GDDEEEKKKWWWWWtWWD.E;iWWWWWW###WW#########WWKKK.EEDG        .:;tfGGGDDDDDDDDDDDD *\n	 *jji.                          . j..::::EKEKKKWWWKKKKWWWWWWWWW#WWW######WWWWKKWKKKEK;.t:.................................ELLEDDEEEWWWWEtWK,.KiiWWWWWW###W##########WWKKK:EEEG     .;tjfLLGDDDDDDDDDDDDDDD *\n	 *jji.                          i.::::::,EEEKKWWWKKKKKWWWWWWWWW#WWW#####WWWWWKWKKKKEE,.t..................................DfiEGDDDEEKKKttKWG.KiiWWWWW##WWW##########WWKKK:fEEL  ,fGGGDDDDDDDDEEEDDDDDDDDDD *\n	 *jji.                        .;:..:::::DEEEKKWWWKKKKKWWWWWWWWW#WWWW####WWWWWWWKKKKED,.t..................................ifjDDGGEGDKK.ttKKE.DiWWWWW###WW##########WWWKKK:.KELiLGGGGDDDDDDDDDDDDEEEDDDDDDD *\n	 *jji.                       i.:.::::::,KEEKKWWWKKKKKKWWWWWWWWW#WWWW####WWWWWWWKKKKEL:.j..................................GGf,;ifLLED .iiKKi:fWWWWWW##W#W##########WWWKKK:.KKLGGDDDDDDDDDDDDDDDDEDDEEDDDDD *\n	 *jji.                     .j:.::::::::EEEKKKWWWKKKKKKWWWWWWWW##WWW#####WWWWWWWKKKKKf:.f..................................:EEfftf .,. ;iE,..jWWWWWWW###W############WWKKK,:KKGDDDDDDDDDDDDDDDDDDDDDDDEDDDD *\n	 *jji.                    .:.::::::::,,EEEKKWWWKKKKKKKWWWWWWWW##WWW#####WWWWWWWKKKKKt..G....................................EEELL;   .j....tKWWWWWWW################WWWKKtfGKGEDDDDDDDDDDDDDDDDDDDDDDDEEDD *\n	 *jji.                   :...:::::::,,jEEKKWWWWKKKKKKWWWWWWWWW##KWW#####KWWWWWWKKKKEi..D....................................:jEEE.........;KKWWWWWWWW#WW##W##########WWKKDLGKEKDDDDDDDDDDDDDDDDDDDDDDDDDED *\n	 *jji.                  i:.::::::::,,,EEEKKWWWWKKKKKWWWWWWWWWW##WWW#####WWWWWWWKKKKKi..D......................................:::::......,KKKWWWWWWWWW#####W########WWWKKKGGKKEGGGGGGGGDDDDDDDDDDDDDDDDDDE *\n	 *jji.                 i..:::::::::,,tEEKKWWWWKKKKKWWWWWWWWWWW##WW######WWWWWWWKKKKKi..D......................................::::......:EKKKWWWWWWWWWWW##WW########W#WKKWGGKKGGGGGGGGGGGGGGGDDDDDDDDDDDDD *\n	 *jji.                .:::::::::::,,,EEEKKWWWWKKKKKWWWWWWWWWWW##WW#####WWWWWWWWKKKKKi..D....................................:::::::::..tELii;KWWWWWWWWWW##WW######WWWWWWKWGGGKGGGGGGGGGGGGGGGGGGGGGGGGGGDG *\n	 *jjt.                :.::::::::,,,,fEEKKWWWWKKKKKKWWWWWWWWWW###WW####WWWWWWW#WKKKKKi..D....................................:::::::.:.,;;;;;;,KKWWWWWWWWW#WW########WWWKKWGGGKGGGGGGGGGGGGGGGGGGGGGGGGGGGG *\n	 *jji.               ;.::::::::,,,,;EEEKWWWWWKKKKKWWWWWWWWWWWW##WW###WKWWWWWK#WKKKKKi..G......................................:::::::,;;;;:...KKKWWWWWWWWWKWW#######WWWWKKGLGKDGGGGGGLLGGGGGGGGGGGGGGGGGGG *\n	 *jjt.              f.:::::::::,,,,fEEKKWWWWWKKKKKWWWWWWWWWWW###WW##WKKWWWWWW#WKKKKK;.jt........i.............................:::::::;j;;....:E.KKKWWWWWWWKWW#####W#WWWWKKLLGWEEGGGGGLGGGGGGGGGGGGGGGGGGGG *\n	 *jjt.             ...:::::::,,,,,;DEEKWWWWWKKKKKWWWWWWWWWWWW####WWWKKKWWWWWWWWKKKKK;.E;.........t.............................:::::ii;;.....D...KKWWWWWWWKWW#####WWEWWWKKGGGEKKGGGGGLGGGGGGGGGGGGGLGGGGGG *\n	 *fji.             ;.:::::::,,,,,;LEEKKWWWWWKKKKKWWWWWWWWWWWW####KWKKKKWWWWWWWWKKKKKi.D;..........j.............................:::tt;,.....:.....KKWWWWWWKWWWW##WWWGWWWKKGGGGKEGGGGGGGGGGGGGGGGGGGLLGGGGL *\n	 *fji.            t::::::::,,,,,,;EEEKWWWWWKKKKKKKWWWWWWWWWWW##WKWKKKKKWWWWWWWWKKKKKi:D;............j...........................::LL;,.............KKWWWWWKWWWWWWWWWGWWWKKGGGGKGGGGGGGGGGGGGGGGGGGGLLGGGGL *\n	 *fjt:            .:::::::,,,,,,,DEEKWWWWWWKKKKKKKWWWWWWWWWWWWKKWKKKKKKWWWWK#WWKKKKWitE;........... ............................:G;;:...............KKKWWKKWWWWWWWWWGWWWKKGGGGWGGGGGGGGGGGGGGGGGGGGGGGGGGL *\n	 *fjji;:.       .f:::::::,,,,,,,;EEEKWWWWWWKKKKKKWWWWWWWWWWWKKKKKKKKKKKWWKWWWWWKKKKWGKD;........................................L;;..................DKKWKKWWWWWWWWWGWWWKKDGGGKDGGGGGGGGGGGGGGGGGGGGGGGGGG *\n	 *fjjtii;,:.     :::::::,,,,,,,;EEEKWWWWWWKKKKKKWWWWWWWWWWKKKKKKKKKKKKWWWWWW#WWKKKKWiEj;......................................:i,;....,...............;KKEKWWWWWWWWWGKWWKKDDGGDEGGGDGGGGGDGGGGGGGGGGGGGGGG *\n	 *fjtiiiii;;:.  j::::::,,,,,,,;;EEEKWWWWW#KKKKKWWWWWWWWWKKKKKKWKKKKKKKWWWWWWWWWKKKKWtEL;:....................................;;;:...,;j................:KEEWWWWWWWWWDDWWKKDDDDDKDDDDDDDDDDDDDDDGGGGGGGGGGG *\n	 *fjti;;iiii;;,:::::::,,,,,,,,;EEEKWWWWWWWKKKKWWWWWWWWKKKKKKKWKKKKKKKWWWWWWW#W#KKKKWEEii;...................................f;:....,;L...................EEKWWWWWWWWDDWWKKDDDDDKEDDDDDDDDDDDDDDDDDDDDDGGGG *\n	 *fjt,,,;;;;ii;f::::::,,,,,,,;;EEKWWWWWWWKKKKKWWWKWWKKKKKKKKKKKKKKKKKWWWWWWW#W#KKKKWKEij;:...............................:G;,.....,;f....................:tKKWWWWWWWDDWWKKDDDDDKKDDDDDDDDDDDDDDDDDDDDDDDDD *\n	 *jjt. ..:,;;;;,::::,,,,,,,,;;GEEWWWWWWWWKKKKWKKWKKKKKKKKKKKKKKKKKKKKWWWWWWW#W#KKKKWEDi;j;............................,Li;L;;;..,;;f........................KKKKWWWKDDWWKKDDDGDKKGGGGGGGGDGDDDDDDDDDDDDDDD *\n	 *fjt.    .:,,,:::::,,,,,,,;;;EEKWWWWWWWKKKKKKWKKKKKKKKKKKKKKKKKKKKKWKKKWKW##W#KKKKWEti;;G;........................tEEEL;;;;;;;;;;L..........................DKKKKKEDDWWKEDGftiLE;;;;itjLGGGGGGDDDDDDDDDDD *\n	 *fjt.       .j::::,,,,,,,;;;DEEWWWWWWWWKKKKWKKKKKKKKKKKKKKKKKKKKKKKWKKWWWK##W#KKKKKEii;;;L;...................iDEEEEEEKKi;j;;;;jD.....:......................,KKKKDGGEKKE:::::;E::::::::::,tLGGDDDDDDDDDD *\n	 *fjt.       .;:::,,,,,,,;;;;EEKWWWWWWWWKWKKKKKKKKKKKKKKKWKKKKKKKKKKWKKWWWW#WW#KKKKKKii;;;;f;.............:tDEEEEEKKKKKKKKEti;;;L...............................EEKf;:iKKE::::::E::::::::::::::ifDDDDDDDDD *\n	 *fjt:        :::,,,,,,,,;;;DEEWWWWWWWWWEKKKKKKKKKKKKKKKKKKKKKKKKKKWWKKWWWW####KKKKKEiii;;;;f,.........iDEEEEKKKKKKKKKKKKKKKf;iG......i..........................fK::::KKE::::::E::::::::::::::::,tGGDDDDD *\n	 *fjt:       t:::,,,,,,;;;;iDEKWWWWWWKEKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWKKWWWW####WKKKKLiii;;;;;L,....,Li;EDEEEEKKKKKKKKKKKKKKKKiG......;:...........................:i:::KKE:::::,E,::::::::::::::::::iGDDDD *\n	 *jjt.       f::,,,,,,,;;;;GEEWWWWKEEKEKKKKKKKKKKKKKKKKWKKKKKKKKKKKWWKWWWWW###WWKKKKiii;;;;;;;G,;L;;iiEEEEEEEKKKKKKKKKKKKKWWKE......;t.........:....................j::KEE:,::,,D,,::::,,,,,,:::::::::tDDD *\n	 *fjt:.      ,::,,,,,,,;;;;EEWWKEEEEEEKKKKKKKKKKKKKKKKWKKKKKKKKKKKWWKKWWWWW#W#KKKKKKiiiiii;;;;;i;;iiiEEKEEKKWKKKKKKKWKKKKKWWWGi;...;t......,;;;;,....................:,EEE,,,,,,D,,,,,,,,,,,,,,,,::,::::tG *\n	 *fjt:.     ,::,,,,,,,;;;;DEKEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWW#W#KKKKKKiiiii;;i;;;;;iiiKKKEKKKKWWKWWWWWWKKKKWWWWW;;;:;L.....;;;;;;;;;....................,KEE,,,,,,E,,,,,,,,,,,,,,,,,,,,,,,,; *\n	 *fjt:.     f:,,,,,,,;;;;jEDEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWW#W##KKKKKKiiiiiiii;i;;iiiEKKKKKKKKWKWWWWWWWWKKKWWWWWKi;;i.....,jEEfGi;;;;;...................EED,,,,,,E,,,,,,,,,,,,,,,,,,,,,,,,, *\n	 *fjt:.    .f::,,,,,,;;jEEDEEEEEEEEEEKKKKKKKKKKKKKKKWKKKKKKKKKKKKKWWWKWWWWW###KKKKKLiiiiiiiiiiiiiiEEKKKKKKKKWWWWWWWWWWWWKWWWWWWGi;i;,..;jDDDKEGi;;;;;;:................EED,,,,,,D,,,,,,,,,,,,,,,,,,,,,,,,, *\n	 *fjt:.  .. ;::,,,,,;;EDDEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWKKW#WW####KWKKKiiiiiiiiiiiiijKKKKKKKKKKWWWWWWWWWWWWWWWWWWWWWt;i;;;;i;DDDDDDGi;;;;;;;;:.............EDf;,,,;,G;;;;;;;;;;;;;;;,,,,,,,,,, *\n	 *fjt:......:,,,,,,;LDDDEEEEEEEEEEEKKKKKKKKKKKKKKKKWKKKKKKKKKKKKKWWWWKWWWW####KKKKKiiiiiiiiiiijKEKKWKKKKKKKWWWWWWWWWWWWWWWWWWWWWWiLiii;i;DEEEEDDE;i;;;;;;;;;:..........EDi,;;;;;L;;;;;;;;;;;;;;;;;;,,,,,,, *\n	 *fjt:......:,,,,,;EDDDEEKEEEEEEEEEKKKKKKKKKKKKKKKWKKKKKKKKKKKKKKWWWWKKWWW##W#KWKKWEiiiiiijGKKKKKWWKKKKKKKKWWWWWWWWWWWWWWWWWWWWWWKi;iiiiDDEEEEEEDEi;;;;;;;;;;;;;,:.....ED;;;;;;;j;;;;;;;;;;;;;;;;;;;;;;;,, *\n	 *fjt:.....t,,,,,;DDDDEEEKEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWWKKKWWWW##WKWKKWKiiiKKKKKKKKKWWKKKKKKKKWWWWWWWWWWWWWWW#WWWWWWWWWiiiiifLEEEEEEEEDi;i;;;;;;;;;;;;.....DD;;;;;;;i;;;;;;;;;;;;;;;;;;;;;;;;; *\n	 *fjt:.....G,,,,,GDDDEEEEEEEEEEEEKKKKKKKKKKKKKKKKWKKKKKKKKKKKKKKKWWWKKKWWW###WKWKKWKitKKKKKKKKKWKKKKKKKKKKWWWWWWWWWWWWWW###WWWWWWWWEiiiiiiiEEEEEEEEDGiiii;;;;;;;;;.....GD;;;;;;;i;;;;;;;;;;;;;;;;;;;;;;;;; *\n	 *fjt:.....L,,,,;GDDDEEEEEEEEEEKEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWDGWWW###KKWWKWKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWW####WWWWWWWWWiiiiiiiiEEEEEEEEEEDi;i;;;;;;;;.....Lj;;;;;;i;iiiiii;;;;;;ii;;;;;;;;;;; *\n	 ***********************************************************************************************************************************************************************************************************/\n\n	void sort(int a[]) {\n		ArrayList<Integer> list=new ArrayList<>();\n		for(int x: a) list.add(x);\n		Collections.sort(list);\n		for(int i=0;i<a.length;i++) a[i]=list.get(i);\n	}\n	void sort(long a[]) {\n		ArrayList<Long> list=new ArrayList<>();\n		for(long x: a) list.add(x);\n		Collections.sort(list);\n		for(int i=0;i<a.length;i++) a[i]=list.get(i);\n	}\n	void ruffleSort(int a[]) {\n		Random rand=new Random();\n		int n=a.length;\n		for(int i=0;i<n;i++) {\n			int j=rand.nextInt(n);\n			int temp=a[i];\n			a[i]=a[j];\n			a[j]=temp;\n		}\n		Arrays.sort(a);\n	}\n	void ruffleSort(long a[]) {\n		Random rand=new Random();\n		int n=a.length;\n		for(int i=0;i<n;i++) {\n			int j=rand.nextInt(n);\n			long temp=a[i];\n			a[i]=a[j];\n			a[j]=temp;\n		}\n		Arrays.sort(a);\n	}\n	\n    static class FastReader { \n        BufferedReader br; \n        StringTokenizer st;\n        public FastReader() { \n            br = new BufferedReader(new InputStreamReader(System.in)); \n        } \n        String next() { \n            while (st==null || !st.hasMoreElements()) { \n                try { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n        int nextInt() { \n            return Integer.parseInt(next()); \n        } \n        long nextLong() { \n            return Long.parseLong(next()); \n        } \n        double nextDouble() { \n            return Double.parseDouble(next()); \n        } \n        String nextLine() { \n            String s=""""; \n            try { \n                s=br.readLine(); \n            } \n            catch (IOException e) { \n                e.printStackTrace(); \n            } \n            return s; \n        } \n    } \n    \n	long fact[];\n	long invFact[];\n	void init(int n) {\n		fact=new long[n+1];\n		invFact=new long[n+1];\n		fact[0]=1;\n		for(int i=1;i<=n;i++) {\n			fact[i]=mul(i,fact[i-1]);\n		}\n		invFact[n]=power(fact[n],mod-2);\n		for(int i=n-1;i>=0;i--) {\n			invFact[i]=mul(invFact[i+1],i+1);\n		}\n	}\n	long modInv(long x) {\n		return power(x,mod-2);\n	}\n	\n	long nCr(int n, int r) {\n		if(n<r || r<0) return 0;\n		return mul(fact[n],mul(invFact[r],invFact[n-r]));\n	}\n	\n	long mul(long a, long b) {\n		return a*b%mod;\n	}\n	long add(long a, long b) {\n		return (a+b)%mod;\n	}\n	\n	long power(long x, long y) {\n		long gg=1;\n		while(y>0) {\n			if(y%2==1) gg=mul(gg,x);\n			x=mul(x,x);\n			y/=2;\n		}\n		return gg;\n	}\n    \n    // Functions\n	static long gcd(long a, long b) { \n		return b==0?a:gcd(b,a%b);\n	}\n	static int gcd(int a, int b) { \n		return b==0?a:gcd(b,a%b);\n	}\n	\n	void print(int a[]) {\n		int n=a.length;\n		for(int i=0;i<n;i++) out.print(a[i]+"" "");\n		out.println();\n	}\n	\n	void print(long a[]) {\n		int n=a.length;\n		for(int i=0;i<n;i++) out.print(a[i]+"" "");\n		out.println();\n	}\n    \n    //Input Arrays\n    static void input(long a[], int n) {\n		for(int i=0;i<n;i++) {\n			a[i]=inp.nextLong();\n		}\n	}\n	static void input(int a[], int n) {\n		for(int i=0;i<n;i++) {\n			a[i]=inp.nextInt();\n		}\n	}	\n	static void input(String s[],int n) {\n		for(int i=0;i<n;i++) {\n			s[i]=inp.next();\n		}\n	}\n	static void input(int a[][], int n, int m) {\n		for(int i=0;i<n;i++) {\n			for(int j=0;j<m;j++) {\n				a[i][j]=inp.nextInt();\n			}\n		}\n	}\n	static void input(long a[][], int n, int m) {\n		for(int i=0;i<n;i++) {\n			for(int j=0;j<m;j++) {\n				a[i][j]=inp.nextLong();\n			}\n		}\n	}\n		\n}\n","bitmasks,constructive algorithms,greedy,math,strings,two pointers"
"// Don't place your source in a package\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\n\n\n\n\n\n\n\n\n// Please name your class Main\npublic class Main {\n    static FastScanner fs=new FastScanner();\n    static class FastScanner {//scanner from SecondThread\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer("""");\n        public String next() {\n            while (!st.hasMoreElements())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        int Int() {\n            return Integer.parseInt(next());\n        }\n\n        long Long() {\n            return Long.parseLong(next());\n        }\n\n        String Str(){\n            return next();\n        }\n    }\n\n\n    public static void main (String[] args) throws java.lang.Exception {\n\n\n        PrintWriter out = new PrintWriter(System.out);\n        int T=1;\n        for(int t=0;t<T;t++){\n            int n=Int();int m=Int();\n            int A[][]=new int[n][m];\n            for(int i=0;i<A.length;i++){\n                for(int j=0;j<A[0].length;j++){\n                    A[i][j]=Int();\n                }\n            }\n\n            Solution sol=new Solution();\n            sol.solution(out,A);\n        }\n        out.flush();\n\n    }\n\n    public static int Int(){\n        return fs.Int();\n    }\n    public static long Long(){\n        return fs.Long();\n    }\n    public static String Str(){\n        return fs.Str();\n    }\n\n}\n\n\n\nclass Solution{\n    public void solution(PrintWriter out,int A[][]){\n        boolean v=dfs(out,A,0);\n        if(v){\n            out.println(""YES"");\n            for(int i:A[0]){\n                out.print(i+"" "");\n            }\n        }\n        else{\n            out.println(""NO"");\n        }\n\n\n    }\n\n    public boolean dfs(PrintWriter out,int A[][],int cnt){\n        if(cnt>2)return false;\n\n        for(int i=1;i<A.length;i++){\n            List<Integer>list=new ArrayList<>();\n            for(int j=0;j<A[0].length;j++){\n                if(A[0][j]!=A[i][j]){\n                    list.add(j);\n                }\n            }\n            int size=list.size();\n\n            if(size>=5)return false;\n            if(size<=2)continue;\n            for(int index:list){\n                int old=A[0][index];\n                A[0][index]=A[i][index];\n                if(dfs(out,A,cnt+1))return true;\n                A[0][index]=old;\n            }\n            return false;\n        }\n\n        return true;\n    }\n\n\n\n\n\n\n    public void yes(PrintWriter out,int A[]){\n        out.println(""YES"");\n        for(int i:A){\n            out.print(i+"" "");\n        }\n        out.println();\n    }\n\n    public void no(PrintWriter out){\n        out.print(""NO"");\n    }\n\n\n}\n\n\n\n//1 2 3 1 1 1","brute force,constructive algorithms,dfs and similar,greedy,implementation"
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static int n, m;\n    static int[][] a;\n    static int ans[];\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner();\n        PrintWriter out = new PrintWriter(System.out);\n        n = sc.nextInt();\n        m = sc.nextInt();\n        a = new int[n][];\n        for (int i = 0; i < n; i++)\n            a[i] = sc.nextIntArray(m);\n        boolean can = solve(1, 2);\n        if (can) {\n            out.println(""Yes"");\n            for (int j = 0; j < m; j++)\n                out.print(ans[j] + "" "");\n        } else out.println(""No"");\n        out.flush();\n        out.close();\n    }\n\n    static boolean solve(int i, int rem) {\n        if (rem < 0) return false;\n        if (i == n) {\n            if (check()) {\n                ans = a[0].clone();\n                return true;\n            }\n            return false;\n        }\n        boolean can = false;\n        ArrayList<Integer> nomatch = new ArrayList<>();\n        for (int j = 0; j < m; j++)\n            if (a[0][j] != a[i][j]) nomatch.add(j);\n        if (nomatch.size() > 4) return false;\n        if (nomatch.size() <= 2) return solve(i + 1, rem);\n        if (nomatch.size() == 3) {\n            for (int idx = 0; idx < nomatch.size() && !can; idx++) {\n                int j = nomatch.get(idx);\n                int tmp = a[0][j];\n                a[0][j] = a[i][j];\n                can = solve(i + 1, rem - 1);\n                a[0][j] = tmp;\n            }\n        }\n        for (int idx = 0; idx < nomatch.size() && !can; idx++) {\n            int j = nomatch.get(idx);\n            int tmp = a[0][j];\n            a[0][j] = a[i][j];\n            for (int idx2 = idx + 1; idx2 < nomatch.size() && !can; idx2++) {\n                int k = nomatch.get(idx2);\n                int tmp2 = a[0][k];\n                a[0][k] = a[i][k];\n                can = solve(i + 1, rem - 2);\n                a[0][k] = tmp2;\n            }\n            a[0][j] = tmp;\n        }\n        return can;\n    }\n\n    static boolean check() {\n        for (int i = 1; i < n; i++) {\n            int cnt = 0;\n            for (int j = 0; j < m; j++)\n                if (a[0][j] != a[i][j]) {\n                    cnt++;\n                    if (cnt == 3)\n                        return false;\n                }\n        }\n        return true;\n    }\n\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public Scanner(String s) throws FileNotFoundException {\n            br = new BufferedReader(new FileReader(s));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public int[] nextIntArray(int n) throws IOException {\n            int[] ans = new int[n];\n            for (int i = 0; i < n; i++)\n                ans[i] = nextInt();\n            return ans;\n        }\n\n        public long[] nextLongArray(int n) throws IOException {\n            long[] ans = new long[n];\n            for (int i = 0; i < n; i++)\n                ans[i] = nextLong();\n            return ans;\n        }\n\n        public Integer[] nextIntegerArray(int n) throws IOException {\n            Integer[] ans = new Integer[n];\n            for (int i = 0; i < n; i++)\n                ans[i] = nextInt();\n            return ans;\n        }\n\n        public char nextChar() throws IOException {\n            return next().charAt(0);\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n\n    }\n}","brute force,constructive algorithms,dfs and similar,greedy,implementation"
"import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n\n	private static final String NO = ""NO"";\n	private static final String YES = ""YES"";\n	private static final String No = ""No"";\n	private static final String Yes = ""Yes"";\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n\n	private static long MOD = 1000000007;\n	private static final int MAXN = 100000;\n\n	void solve() {\n\n		int T = 1;// ni();\n		for (int i = 0; i < T; i++) {\n			solve(i);\n		}\n	}\n\n	int a[][];\n\n	int n;\n	int m;\n\n	void solve(int T) {\n		n = ni();\n		m = ni();\n		a = na(n, m);\n		if (go(0)) {\n			out.println(YES);\n			for (int j = 0; j < m; j++)\n				out.print(a[0][j]+"" "");\n			return;\n		}\n		out.println(NO);\n	}\n\n	boolean go(int dep) {\n		if (dep > 2)\n			return false;\n		for (int i = 1; i < n; i++) {\n			int k = 0;\n			for (int j = 0; j < m; j++)\n				k += a[0][j] != a[i][j] ? 1 : 0;\n			if (k > 4)\n				return false;\n			if (k > 2) {\n				for (int j = 0; j < m; j++)\n					if (a[0][j] != a[i][j]) {\n						int t = a[0][j];\n						a[0][j] = a[i][j];\n						if (go(dep + 1)) {\n							return true;\n						}\n						a[0][j] = t;\n					}\n				return false;\n			}\n		}\n		return true;\n	}\n\n	// a^b\n	long power(long a, long b) {\n		long x = 1, y = a;\n		while (b > 0) {\n			if (b % 2 != 0) {\n				x = (x * y) % MOD;\n			}\n			y = (y * y) % MOD;\n			b /= 2;\n		}\n		return x % MOD;\n	}\n\n	private long gcd(long a, long b) {\n		while (a != 0) {\n			long tmp = b % a;\n			b = a;\n			a = tmp;\n		}\n		return b;\n	}\n\n	void run() throws Exception {\n		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		if (!INPUT.isEmpty())\n			tr(System.currentTimeMillis() - s + ""ms"");\n	}\n\n	public static void main(String[] args) throws Exception {\n		new Main().run();\n	}\n\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n\n	private int readByte() {\n		if (lenbuf == -1)\n			throw new InputMismatchException();\n		if (ptrbuf >= lenbuf) {\n			ptrbuf = 0;\n			try {\n				lenbuf = is.read(inbuf);\n			} catch (IOException e) {\n				throw new InputMismatchException();\n			}\n			if (lenbuf <= 0)\n				return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n\n	private boolean isSpaceChar(int c) {\n		return !(c >= 33 && c <= 126);\n	}\n\n	private int skip() {\n		int b;\n		while ((b = readByte()) != -1 && isSpaceChar(b))\n			;\n		return b;\n	}\n\n	private double nd() {\n		return Double.parseDouble(ns());\n	}\n\n	private char nc() {\n		return (char) skip();\n	}\n\n	private String ns() {\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n									// ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	private char[] ns(int n) {\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while (p < n) {\n			if (!(isSpaceChar(b)))\n				buf[p++] = (char) b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n\n	private char[][] nm(int n, int m) {\n		char[][] map = new char[n][];\n		for (int i = 0; i < n; i++)\n			map[i] = ns(m);\n		return map;\n	}\n\n	private int[] na(int n) {\n		int[] a = new int[n];\n		for (int i = 0; i < n; i++)\n			a[i] = ni();\n		return a;\n	}\n\n	private Integer[] na2(int n) {\n		Integer[] a = new Integer[n];\n		for (int i = 0; i < n; i++)\n			a[i] = ni();\n		return a;\n	}\n\n	private int[][] na(int n, int m) {\n		int[][] a = new int[n][];\n		for (int i = 0; i < n; i++)\n			a[i] = na(m);\n		return a;\n	}\n\n	private int ni() {\n		int num = 0, b;\n		boolean minus = false;\n		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n			;\n		if (b == '-') {\n			minus = true;\n			b = readByte();\n		}\n\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				num = num * 10 + (b - '0');\n			} else {\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n\n	private long[] nl(int n) {\n		long[] a = new long[n];\n		for (int i = 0; i < n; i++)\n			a[i] = nl();\n		return a;\n	}\n\n	private long[][] nl(int n, int m) {\n		long[][] a = new long[n][];\n		for (int i = 0; i < n; i++)\n			a[i] = nl(m);\n		return a;\n	}\n\n	private long nl() {\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n			;\n		if (b == '-') {\n			minus = true;\n			b = readByte();\n		}\n\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				num = num * 10 + (b - '0');\n			} else {\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n\n	private static void tr(Object... o) {\n		System.out.println(Arrays.deepToString(o));\n	}\n\n}","brute force,constructive algorithms,dfs and similar,greedy,implementation"
"// Problem: E. Almost Fault-Tolerant Database\n// Contest: Codeforces - Codeforces Round #704 (Div. 2)\n// URL: http://codeforces.com/contest/1492/problem/E\n// Memory Limit: 512 MB\n// Time Limit: 2000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\nimport java.io.*;\nimport java.util.*;\n\npublic class CF {\n    private static PrintWriter pw = new PrintWriter(System.out);\n    private static InputReader sc = new InputReader();\n    private static final int intmax = Integer.MAX_VALUE, intmin = Integer.MIN_VALUE;\n\n    static class InputReader{\n        private static BufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n        private static StringTokenizer tk;\n\n        private void next()throws IOException{\n            while(tk == null || !tk.hasMoreTokens())   \n                tk = new StringTokenizer(r.readLine());\n        }\n\n        private int nextInt()throws IOException{\n            next();\n            return Integer.parseInt(tk.nextToken());\n        }\n    }\n\n    public static void main(String args[])throws IOException{\n        int t = 1;\n        while(t-->0)    solve();\n        pw.flush();\n        pw.close();\n    }\n    \n    private static void printyes(int res[]){\n        pw.println(""Yes"");\n        for(int j = 0; j < res.length; j++)\n            pw.print(+res[j]+"" "");\n    }\n    \n    private static boolean step4(int res[], int arr[][]){\n        int n = arr.length, m = arr[0].length;\n        \n        for(int i = 0; i < n; i++){\n            int count = 0;\n            for(int j = 0; j < m; j++){\n                \n                if(arr[i][j] != res[j])\n                    count++;\n            }\n            \n            if(count > 2)\n                return false;\n        }\n        \n        printyes(res);\n        return true;\n    }\n    \n    private static boolean step3(int res[], int arr[][], int pos){\n        int n = arr.length, m = arr[0].length;\n        \n        for(int i = 0; i < n; i++){\n            int count = 0;\n            \n            for(int j = 0; j < m; j++){\n                if(arr[i][j] != res[j] && j != pos)\n                    count++;\n            }\n            \n            if(count > 2)\n                return false;\n            else if(count == 2){\n                int tmp = res[pos];\n                \n                res[pos] = arr[i][pos];\n\n                boolean r = step4(res, arr);\n                    \n                res[pos] = tmp;\n\n                return r;\n            }\n        }\n        \n        printyes(res);\n        return true;\n    }\n    \n    private static boolean step2(int res[], int arr[][], int pos1, int pos2){\n        int n = arr.length, m = arr[0].length;\n        \n        for(int i = 0; i < n; i++){\n            int count = 0;\n            \n            for(int j = 0; j < m; j++){\n                \n                if(j != pos1 && j != pos2 && res[j] != arr[i][j])\n                    count++;\n            }\n            \n            if(count > 2)\n                return false;\n            else if(count == 2){\n                int temp1 = res[pos1], temp2 = res[pos2];\n                \n                res[pos1] = arr[i][pos1];\n                res[pos2] = arr[i][pos2];\n\n                boolean r = step4(res, arr);\n                \n                res[pos1] = temp1;\n                res[pos2] = temp2;\n\n                return r;\n            }\n            else if(count == 1){\n                int temp = res[pos1];\n                \n                res[pos1] = arr[i][pos1];\n\n                boolean r = step3(res, arr, pos2);\n\n                res[pos1] = temp;\n                \n                if(r)   return true;\n                \n                temp = res[pos2];\n                \n                res[pos2] = arr[i][pos2];\n\n                r = step3(res, arr, pos1);\n\n                res[pos2] = temp;\n\n                return r;\n            }\n        }\n        \n        printyes(res);\n        \n        return true;\n    }\n    \n    private static boolean step1(int res[], int arr[][]){\n        int n = arr.length, m = arr[0].length;\n        \n        for(int i = 0; i < n; i++){\n            ArrayList<Integer> list = new ArrayList<>();\n            \n            for(int j = 0; j < m; j++){\n                if(res[j] != arr[i][j])\n                    list.add(j);\n            }\n            \n            if(list.size() > 4)\n                return false;\n            else if(list.size() >= 3){\n                for(int p = 0; p + 1 < list.size(); p++){\n                    for(int q = p + 1; q < list.size(); q++){\n                        if(step2(res, arr, list.get(p), list.get(q)))\n                            return true;\n                    }\n                }\n                return false;\n            }\n        }\n        \n        printyes(res);\n        \n        return true;\n    }\n\n    private static void solve()throws IOException{\n        int n = sc.nextInt(), m = sc.nextInt(), arr[][] = new int[n][m], res[] = new int[m];\n        \n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < m; j++){\n                arr[i][j] = sc.nextInt();\n                \n                res[j] = arr[0][j];\n            }\n        }\n        \n        if(!step1(res, arr))\n            pw.println(""No"");\n    }\n}","brute force,constructive algorithms,dfs and similar,greedy,implementation"
"import java.util.Scanner;\n\npublic class Main {\n	static String somaCubos(long v){	\n		for(long a = 1; a < Math.cbrt(v); a++){\n			long b = (long) Math.cbrt(v-(a*a*a));\n			if((a*a*a) + (b*b*b) == v){\n				return ""YES"";\n			}\n		}	\n		return ""NO"";\n	}\n  	public static void main(String[] args) {\n		Scanner ler = new Scanner(System.in);\n\n		int t = ler.nextInt();\n		for(int i = 0; i<t; i++){\n			long v = ler.nextLong();\n			System.out.println(somaCubos(v));\n		}\n		ler.close();\n  }\n\n}","binary search,brute force,brute force,math"
"import java.util.*;\npublic class Main{\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		long[] x=new long[10001];\n		for(int i=1;i<=10000;i++) {\n			x[i]=(long)Math.pow(i, 3);\n		}\n		int t=sc.nextInt();\n		while(t-->0) {\n			long n=sc.nextLong();\n			boolean b=false;\n			for(int i=1;x[i]<n;i++) {\n				if(Arrays.binarySearch(x, n-x[i])>0) {\n					b=true;\n					break;\n				}\n			}\n			System.out.println((b?""YES"":""NO""));\n		}\n	}	\n}\n ","binary search,brute force,brute force,math"
"import java.util.*;\n \npublic class Cubes{\n	public static void main(String args[]){\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while(t-- > 0) {\n			long n = sc.nextLong();\n			int flag = 0;\n			for(long i= 1; i < Math.cbrt(n); i++) {\n				long val = (long)Math.cbrt(n - i*i*i);\n				if(Math.pow(val, 3) == n - Math.pow(i, 3)) {\n				    flag = 1;\n				    break;\n				}\n			}\n			System.out.println(flag != 0 ? ""YES"" : ""NO"");\n		}\n		sc.close();\n	}\n}","binary search,brute force,brute force,math"
"import java.util.*;\n \npublic class Cubes{\n	public static void main(String args[]){\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while(t-- > 0) {\n			long n = sc.nextLong();\n			int flag = 0;\n			for(long i= 1; i < Math.cbrt(n); i++) {\n				long val = (long)Math.cbrt(n - i*i*i);\n				if(Math.pow(val, 3) == n - Math.pow(i, 3)) {\n				    flag = 1;\n				    break;\n				}\n			}\n			System.out.println(flag != 0 ? ""YES"" : ""NO"");\n		}\n		sc.close();\n	}\n}","binary search,brute force,brute force,math"
"import java.util.Scanner;\n\npublic class C {\n    static Scanner in = new Scanner(System.in);\n\n    public static int query(int i){\n        System.out.println(""? "" + i);\n        System.out.flush();\n        return in.nextInt();\n    } \n    public static void main(String[] args){\n\n        int n = in.nextInt();\n\n        int l = 1;\n        int r = n;\n        while(l < r){\n            int m = (l+r)/2;\n            if(query(m) > query(m+1)){\n                l = m + 1;\n            }else{\n                r = m;\n            }\n        }\n        System.out.println(""! "" + l);\n        System.out.flush();\n    }\n}\n","binary search,interactive,ternary search"
"import java.util.Scanner;\n \npublic class Main {\n    static Scanner in = new Scanner(System.in);\n \n    public static int query(int i){\n        System.out.println(""? "" + i);\n        System.out.flush();\n        return in.nextInt();\n    } \n    public static void main(String[] args){\n \n        int n = in.nextInt();\n \n        int l = 1;\n        int r = n;\n        while(l < r){\n            int m = (l+r)/2;\n            if(query(m) > query(m+1)){\n                l = m + 1;\n            }else{\n                r = m;\n            }\n        }\n        System.out.println(""! "" + l);\n        System.out.flush();\n    }\n}\n","binary search,interactive,ternary search"
"import java.util.Scanner;\n\npublic class A_Searching_Local_Minimum {\n    static Scanner in = new Scanner(System.in);\n\n    public static int query(int i){\n        System.out.println(""? "" + i);\n        System.out.flush();\n        return in.nextInt();\n    } \n    public static void main(String[] args){\n\n        int n = in.nextInt();\n\n        int l = 1;\n        int r = n;\n        while(l < r){\n            int m = (l+r)/2;\n            if(query(m) > query(m+1)){\n                l = m + 1;\n            }else{\n                r = m;\n            }\n        }\n        System.out.println(""! "" + l);\n        System.out.flush();\n    }\n}\n","binary search,interactive,ternary search"
"import java.io.*;\nimport java.util.*;\n \npublic class Codeforces {\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		//int cases = Integer.parseInt(br.readLine());\n		//o:while(cases-- > 0) {\n			String[] str = br.readLine().split("" "");\n			int n = Integer.parseInt(str[0]);\n			int l = 1, r = n;\n			while(l < r) {\n				int m = l + (r-l)/2;\n				System.out.println(""? ""+m);\n				int am = Integer.parseInt(br.readLine());\n				System.out.println(""? ""+(m+1));\n				int amnext = Integer.parseInt(br.readLine());\n				if(am < amnext) {\n					r = m;\n				}else{\n					l = m+1;\n				}\n			}\n			System.out.println(""! ""+l);\n		//}\n	}\n}","binary search,interactive,ternary search"
"// coached by rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1476E extends PrintWriter {\n	CF1476E() { super(System.out); }\n	static class Scanner {\n		Scanner(InputStream in) { this.in = in; } InputStream in;\n		byte[] bb = new byte[1 << 15]; int i, n;\n		byte getc() {\n			if (i == n) {\n				i = n = 0;\n				try { n = in.read(bb); } catch (IOException e) {}\n			}\n			return i < n ? bb[i++] : 0;\n		}\n		int nextInt() {\n			byte c = 0; while (c <= ' ') c = getc();\n			int a = 0; while (c > ' ') { a = a * 10 + c - '0'; c = getc(); }\n			return a;\n		}\n		byte[] cc = new byte[1 << 7];\n		String next() {\n			byte c = 0; while (c <= ' ') c = getc();\n			int k = 0, l = cc.length;\n			while (c > ' ') {\n				if (k == l) cc = Arrays.copyOf(cc, l <<= 1);\n				cc[k++] = c; c = getc();\n			}\n			return new String(cc, 0, k);\n		}\n	}\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1476E o = new CF1476E(); o.main(); o.flush();\n	}\n\n	int[] dd, eo; int[][] ej;\n	void append(int i, int j) {\n		int o = eo[i]++;\n		if (o >= 2 && (o & o - 1) == 0)\n			ej[i] = Arrays.copyOf(ej[i], o << 1);\n		ej[i][o] = j;\n		dd[j]++;\n	}\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		int k = sc.nextInt();\n		HashMap<String, Integer> mp = new HashMap<>();\n		for (int i = 0; i < n; i++) {\n			String s = sc.next();\n			mp.put(s, i);\n		}\n		byte[] cc = new byte[k];\n		dd = new int[n]; eo = new int[n]; ej = new int[n][2];\n		while (m-- > 0) {\n			byte[] aa = sc.next().getBytes();\n			int i = sc.nextInt() - 1;\n			boolean found = false;\n			for (int x = 0; x < 1 << k; x++) {\n				for (int h = 0; h < k; h++)\n					cc[h] = (x & 1 << h) == 0 ? aa[h] : (byte) '_';\n				String s = new String(cc);\n				int j = mp.getOrDefault(s, -1);\n				if (j != -1) {\n					if (j == i)\n						found = true;\n					else\n						append(i, j);\n				}\n			}\n			if (!found) {\n				println(""NO"");\n				return;\n			}\n		}\n		int[] qu = new int[n]; int head = 0, cnt = 0;\n		for (int i = 0; i < n; i++)\n			if (dd[i] == 0)\n				qu[head + cnt++] = i;\n		while (cnt > 0) {\n			int i = qu[head++]; cnt--;\n			for (int o = eo[i]; o-- > 0; ) {\n				int j = ej[i][o];\n				if (--dd[j] == 0)\n					qu[head + cnt++] = j;\n			}\n		}\n		if (head != n) {\n			println(""NO"");\n			return;\n		}\n		println(""YES"");\n		for (int i = 0; i < n; i++)\n			print(qu[i] + 1 + "" "");\n		println();\n	}\n}\n","bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"
"import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main2 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int i, j, k;\n\n        int N = in.nextInt();\n        int M = in.nextInt();\n        int K = in.nextInt();\n        HashMap<String, Integer> map = new HashMap<>();\n        String[] P = new String[N];\n        for (i = 0; i < N; ++i) {\n            P[i] = in.next();\n            map.put(P[i], i);\n        }\n\n        int[] incomingCount = new int[N];\n        HashSet<Integer>[] outgoing = new HashSet[N];\n        for (i = 0; i < N; ++i) {\n            outgoing[i] = new HashSet<>();\n        }\n\n        for (i = 0; i < M; ++i) {\n            char[] S = in.next().toCharArray();\n            int idx = in.nextInt() - 1;\n\n            for (j = 0; j < K; ++j) {\n                if (P[idx].charAt(j) != '_' && P[idx].charAt(j) != S[j]) {\n                    System.out.println(""NO"");\n                    return;\n                }\n            }\n\n            for (k = 0; k < 1 << K; ++k) {\n                char[] tmp = S.clone();\n                for (j = 0; j < K; ++j)\n                    if ((k >> j) % 2 > 0) {\n                        tmp[j] = '_';\n                    }\n                String tmpS = new String(tmp);\n                Integer inciIdx = map.get(tmpS);\n                if (!tmpS.equals(P[idx]) && inciIdx != null && !outgoing[idx].contains(inciIdx)) {\n                    ++incomingCount[inciIdx];\n                    outgoing[idx].add(inciIdx);\n                }\n            }\n        }\n\n        Stack<Integer> deque = new Stack<>();\n        boolean[] taken = new boolean[N];\n        int[] ans = new int[N];\n        k = 0;\n        for (i = 0; i < N; ++i)\n            if (incomingCount[i] == 0) {\n                deque.add(i);\n                taken[i] = true;\n            }\n        while (!deque.isEmpty()) {\n            int leftMost = deque.pop();\n            ans[k++] = leftMost + 1;\n\n            for (int itr : outgoing[leftMost])\n                if (!taken[itr]) {\n                    if (--incomingCount[itr] == 0) {\n                        deque.add(itr);\n                        taken[itr] = true;\n                    }\n                }\n        }\n\n        if (k < N) {\n            System.out.println(""NO"");\n        } else {\n            System.out.println(""YES"");\n            StringBuilder orderSb = new StringBuilder();\n            for (int an : ans) {\n                orderSb.append(an).append(' ');\n            }\n            System.out.println(orderSb.toString().trim());\n        }\n    }\n}\n\n","bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"
"import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main2 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int i, j, k;\n\n        int N = in.nextInt();\n        int M = in.nextInt();\n        int K = in.nextInt();\n        HashMap<String, Integer> map = new HashMap<>();\n        String[] patterns = new String[N];\n        for (i = 0; i < N; ++i) {\n            patterns[i] = in.next();\n            map.put(patterns[i], i);\n        }\n\n        int[] incomingCount = new int[N];\n        HashSet<Integer>[] outgoing = new HashSet[N];\n        for (i = 0; i < N; ++i) {\n            outgoing[i] = new HashSet<>();\n        }\n\n        for (i = 0; i < M; ++i) {\n            char[] S = in.next().toCharArray();\n            int idx = in.nextInt() - 1;\n\n            for (j = 0; j < K; ++j) {\n                if (patterns[idx].charAt(j) != '_' && patterns[idx].charAt(j) != S[j]) {\n                    System.out.println(""NO"");\n                    return;\n                }\n            }\n\n            for (k = 0; k < 1 << K; ++k) {\n                char[] tmp = S.clone();\n                for (j = 0; j < K; ++j)\n                    if ((k >> j) % 2 > 0) {\n                        tmp[j] = '_';\n                    }\n                String tmpS = new String(tmp);\n                Integer inciIdx = map.get(tmpS);\n                if (!tmpS.equals(patterns[idx]) && inciIdx != null && !outgoing[idx].contains(inciIdx)) {\n                    ++incomingCount[inciIdx];\n                    outgoing[idx].add(inciIdx);\n                }\n            }\n        }\n\n        Stack<Integer> deque = new Stack<>();\n        boolean[] taken = new boolean[N];\n        int[] ans = new int[N];\n        k = 0;\n        for (i = 0; i < N; ++i) {\n            if (incomingCount[i] == 0) {\n                deque.add(i);\n                taken[i] = true;\n            }\n        }\n        while (!deque.isEmpty()) {\n            int leftMost = deque.pop();\n            ans[k++] = leftMost + 1;\n\n            for (int itr : outgoing[leftMost]) {\n                if (!taken[itr] && --incomingCount[itr] == 0) {\n                    deque.add(itr);\n                    taken[itr] = true;\n                }\n            }\n        }\n\n        if (k < N) {\n            System.out.println(""NO"");\n        } else {\n            System.out.println(""YES"");\n            StringBuilder orderSb = new StringBuilder();\n            for (int an : ans) {\n                orderSb.append(an).append(' ');\n            }\n            System.out.println(orderSb.toString().trim());\n        }\n    }\n}\n\n","bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"
"import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main2 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n\n        int N = in.nextInt();\n        int M = in.nextInt();\n        int K = in.nextInt();\n        HashMap<String, Integer> map = new HashMap<>();\n        String[] patterns = new String[N];\n        for (int i = 0; i < N; ++i) {\n            patterns[i] = in.next();\n            map.put(patterns[i], i);\n        }\n\n        int[] incomingCount = new int[N];\n        HashSet<Integer>[] outgoing = new HashSet[N];\n        for (int i = 0; i < N; ++i) {\n            outgoing[i] = new HashSet<>();\n        }\n\n        for (int i = 0; i < M; ++i) {\n            char[] S = in.next().toCharArray();\n            int idx = in.nextInt() - 1;\n\n            for (int j = 0; j < K; ++j) {\n                if (patterns[idx].charAt(j) != '_' && patterns[idx].charAt(j) != S[j]) {\n                    System.out.println(""NO"");\n                    return;\n                }\n            }\n\n            for (int k = 0; k < 1 << K; ++k) {\n                char[] tmp = S.clone();\n                for (int j = 0; j < K; ++j)\n                    if ((k >> j) % 2 > 0) {\n                        tmp[j] = '_';\n                    }\n                String tmpS = new String(tmp);\n                Integer inciIdx = map.get(tmpS);\n                if (!tmpS.equals(patterns[idx]) && inciIdx != null && !outgoing[idx].contains(inciIdx)) {\n                    ++incomingCount[inciIdx];\n                    outgoing[idx].add(inciIdx);\n                }\n            }\n        }\n\n        Stack<Integer> deque = new Stack<>();\n        boolean[] taken = new boolean[N];\n        int[] ans = new int[N];\n        int k = 0;\n        for (int i = 0; i < N; ++i) {\n            if (incomingCount[i] == 0) {\n                deque.add(i);\n                taken[i] = true;\n            }\n        }\n        while (!deque.isEmpty()) {\n            int leftMost = deque.pop();\n            ans[k++] = leftMost + 1;\n\n            for (int itr : outgoing[leftMost]) {\n                if (!taken[itr] && --incomingCount[itr] == 0) {\n                    deque.add(itr);\n                    taken[itr] = true;\n                }\n            }\n        }\n\n        if (k < N) {\n            System.out.println(""NO"");\n        } else {\n            System.out.println(""YES"");\n            StringBuilder orderSb = new StringBuilder();\n            for (int an : ans) {\n                orderSb.append(an).append(' ');\n            }\n            System.out.println(orderSb.toString().trim());\n        }\n    }\n}\n\n","bitmasks,data structures,dfs and similar,graphs,hashing,sortings,strings"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1473D extends PrintWriter {\n	CF1473D() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1473D o = new CF1473D(); o.main(); o.flush();\n	}\n\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int m = sc.nextInt();\n			byte[] cc = sc.next().getBytes();\n			int[] pp = new int[n + 1];\n			for (int z = 0, i = 1; i <= n; i++) {\n				if (cc[i - 1] == '+')\n					z++;\n				else\n					z--;\n				pp[i] = z;\n			}\n			int[] qq = new int[n + 1];\n			for (int z = 0, i = 1; i <= n; i++) {\n				if (cc[n - i] == '-')\n					z++;\n				else\n					z--;\n				qq[i] = z;\n			}\n			int[] pmin = new int[n + 1];\n			int[] pmax = new int[n + 1];\n			int[] qmin = new int[n + 1];\n			int[] qmax = new int[n + 1];\n			for (int i = 1; i <= n; i++) {\n				pmin[i] = Math.min(pmin[i - 1], pp[i]);\n				pmax[i] = Math.max(pmax[i - 1], pp[i]);\n				qmin[i] = Math.min(qmin[i - 1], qq[i]);\n				qmax[i] = Math.max(qmax[i - 1], qq[i]);\n			}\n			while (m-- > 0) {\n				int l = sc.nextInt();\n				int r = sc.nextInt();\n				l--; r = n - r;\n				int zmin = Math.min(pmin[l], pp[l] + qmin[r] - qq[r]);\n				int zmax = Math.max(pmax[l], pp[l] + qmax[r] - qq[r]);\n				println(zmax - zmin + 1);\n			}\n		}\n	}\n}\n","data structures,dp,implementation,strings"
"import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n\n        int t=sc.nextInt();\n\n        while (t-->0){\n\n            int n=sc.nextInt();\n            int m=sc.nextInt();\n\n            String s=sc.next();\n\n            int[] minl = new int[n+1];\n            int[] maxl = new int[n+1];\n            int[] vals = new int[n+1];\n            for (int i=0;i<n;i++) {\n                if (s.charAt(i) == '-') vals[i+1] = vals[i] - 1;\n                else vals[i+1] = vals[i] + 1;\n                minl[i+1] = Math.min(minl[i], vals[i+1]);\n                maxl[i+1] = Math.max(maxl[i], vals[i+1]);\n            }\n\n            int[] minr = new int[n+1];\n            int[] maxr = new int[n+1];\n            for (int i=n-1;i>=0;i--) {\n                int d = 0;\n                if (s.charAt(i) == '-') d--;\n                else d++;\n                minr[i] = Math.min(minr[i+1] + d, 0);\n                maxr[i] = Math.max(maxr[i+1] + d, 0);\n            }\n\n            for (int i=0;i<m;i++) {\n                int l = sc.nextInt(), r = sc.nextInt();\n                int mi = Math.min(minl[l-1], vals[l-1] + minr[r]);\n                int ma = Math.max(maxl[l-1], vals[l-1] + maxr[r]);\n                System.out.println(ma - mi + 1);\n            }\n\n            \n        }\n    }\n}\n\n\n","data structures,dp,implementation,strings"
"import java.util.*;\nimport java.io.*;\n \npublic class cc_march2020_long {\n	public static void main(String[] args) {\n		Scanner scn=new Scanner(System.in);\n		int t=scn.nextInt();\n		scn.nextLine();\n		while(t -- >0) {\n			int n=scn.nextInt();\n			int m=scn.nextInt();\n			scn.nextLine();\n			String str=scn.nextLine();\n			int[]minl=new int[n+1];\n			minl[0]=0;\n			int[]maxl=new int[n+1];\n			maxl[0]=0;\n			int[]minr=new int[n+1];\n			minr[0]=0;\n			int[]maxr=new int[n+1];\n			maxr[0]=0;\n			int[]sum=new int[n+1];\n			for(int i=0;i<n;i++) {\n				char ch=str.charAt(i);\n				if(ch=='+') {\n					sum[i+1]=sum[i]+1;\n				}else {\n					sum[i+1]=sum[i]-1;\n				}\n				minl[i+1]=Math.min(minl[i], sum[i+1]);\n				maxl[i+1]=Math.max(maxl[i], sum[i+1]);\n			}\n			for(int i=n-1;i>=0;i--) {\n				int summ=0;\n				char ch=str.charAt(i);\n				if(ch=='+') {\n					summ=1;\n				}else {\n					summ=-1;\n				}\n				if(i==n-1) {\n					minr[i+1]=Math.min(0, summ);\n					maxr[i+1]=Math.max(0, summ);\n					continue;\n				}\n				minr[i+1]=Math.min(0, minr[i+2]+summ);\n				maxr[i+1]=Math.max(0, maxr[i+2]+summ);\n			}\n			for(int i=0;i<m;i++) {\n				int l=scn.nextInt();\n				int r=scn.nextInt();\n				int minVal=Math.min(Math.min(0, minl[l-1]),(r+1<=n ? minr[r+1] : 0)+sum[l-1]);\n				int maxVal=Math.max(Math.max(0,maxl[l-1]),(r+1<=n ? maxr[r+1] : 0)+sum[l-1]);\n				System.out.println((maxVal-minVal+1));\n			}\n		}\n	}\n}","data structures,dp,implementation,strings"
"\nimport java.util.Scanner;\n\npublic class C1473_D {\n\n    static void solve(Scanner in) {\n        int n = in.nextInt(), m = in.nextInt();\n        String ops = in.next();\n        int[] mins_left = new int[n+1];\n        int[] maxs_left = new int[n+1];\n        int[] vals = new int[n+1];\n        for (int i=0;i<n;i++) {\n            if (ops.charAt(i) == '-') vals[i+1] = vals[i] - 1;\n            else vals[i+1] = vals[i] + 1;\n            mins_left[i+1] = Math.min(mins_left[i], vals[i+1]);\n            maxs_left[i+1] = Math.max(maxs_left[i], vals[i+1]);\n        }\n\n        int[] mins_right = new int[n+1];\n        int[] maxs_right = new int[n+1];\n        for (int i=n-1;i>=0;i--) {\n            int d = 0;\n            if (ops.charAt(i) == '-') d--;\n            else d++;\n            mins_right[i] = Math.min(mins_right[i+1] + d, 0);\n            maxs_right[i] = Math.max(maxs_right[i+1] + d, 0);\n        }\n\n        for (int i=0;i<m;i++) {\n            int l = in.nextInt(), r = in.nextInt();\n            int mi = Math.min(mins_left[l-1], vals[l-1] + mins_right[r]);\n            int ma = Math.max(maxs_left[l-1], vals[l-1] + maxs_right[r]);\n            System.out.println(ma - mi + 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int t = in.nextInt();\n        while (t-- > 0) {\n            solve(in);\n        }\n    }\n}\n","data structures,dp,implementation,strings"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1469D extends PrintWriter {\n	CF1469D() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1469D o = new CF1469D(); o.main(); o.flush();\n	}\n\n	static final int N = 200000;\n	int[] ii = new int[N + 5];\n	int[] jj = new int[N + 5];\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int m = 0;\n			while (n > 2) {\n				int r = (int) Math.sqrt(n);\n				if (r * r < n)\n					r++;\n				for (int i = r + 1; i < n; i++) {\n					ii[m] = i; jj[m] = n; m++;\n				}\n				ii[m] = n; jj[m] = r; m++;\n				ii[m] = n; jj[m] = r; m++;\n				n = r;\n			}\n			println(m);\n			for (int h = 0; h < m; h++)\n				println(ii[h] + "" "" + jj[h]);\n		}\n	}\n}\n","brute force,constructive algorithms,math,number theory"
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Scanner scn=new Scanner(System.in);\n        int t=scn.nextInt();\n        for(int i1=0;i1<t;i1++){\n            long n=scn.nextInt();\n            long val=n-1;\n            ArrayList<String> arr=new ArrayList<String>();\n            while(val>1){\n                if((val-1)*(val-1)<n){\n                    arr.add(n+"" ""+val);\n                    arr.add(n+"" ""+val);\n                    n=val;\n                    val=val-1;\n                    continue;\n                }\n                arr.add(val+"" ""+n);\n                val--;\n            }\n            System.out.println(arr.size());\n            for(String str:arr){\n                System.out.println(str);\n            }\n        }\n    }\n}\n","brute force,constructive algorithms,math,number theory"
"import java.util.Scanner;\n\npublic class E1496D {\n    public static void main(String[] args) {\n        Scanner scn = new Scanner(System.in);\n        int test = scn.nextInt();\n        while (test-- > 0) {\n            int n = scn.nextInt();\n            int prev = n;\n            StringBuilder sb = new StringBuilder();\n            int count=0;\n            for (int i = n - 1; i > 1; i--) {\n                if (1l * (i - 1) * (i - 1) < prev) {\n                    sb.append(prev + "" "" + i + ""\n"");\n                    sb.append(prev + "" "" + i + ""\n"");\n                    prev = i;\n                    count+=2;\n                } else {\n                    sb.append(i + "" "" + prev + ""\n"");\n                    count++;\n                }\n            }\n\n            System.out.println(count);\n            System.out.print(sb);\n\n        }\n    }\n}\n","brute force,constructive algorithms,math,number theory"
"import java.util.*;\n\npublic class Main{\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        \n        for(int i = 0; i < t; i++){\n            int n = sc.nextInt();\n            int n1 = n;\n            int count = 0;\n            \n            while((n1 = sqrt(n1)) > 2){\n                ++count;\n            }\n            \n            System.out.println(n - 1 + count);\n            compute(n);\n        }\n    }\n    \n    private static void compute(int n){\n        int sq = sqrt(n);\n\n        if(sq == n)\n            return;\n\n        for(int i = n - 1; i > sq && i > 2; i--){\n            System.out.println(i + "" "" + n);\n        }\n\n        System.out.println(n + "" "" + sq);\n        System.out.println(n + "" "" + sq);\n\n        compute(sq);\n    }\n    \n    private static int sqrt(int n){\n        return (int)Math.ceil(Math.sqrt(n));\n    }\n}","brute force,constructive algorithms,math,number theory"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1468J extends PrintWriter {\n	CF1468J() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1468J o = new CF1468J(); o.main(); o.flush();\n	}\n\n	static final int INF = 0x3f3f3f3f;\n	int[] ds;\n	int find(int i) {\n		return ds[i] < 0 ? i : (ds[i] = find(ds[i]));\n	}\n	boolean join(int i, int j) {\n		i = find(i);\n		j = find(j);\n		if (i == j)\n			return false;\n		if (ds[i] > ds[j])\n			ds[i] = j;\n		else {\n			if (ds[i] == ds[j])\n				ds[i]--;\n			ds[j] = i;\n		}\n		return true;\n	}\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int m = sc.nextInt();\n			int k = sc.nextInt();\n			ds = new int[n]; Arrays.fill(ds, -1);\n			int[] ii = new int[m];\n			int[] jj = new int[m];\n			int[] aa = new int[m]; int m_ = 0;\n			int a_ = INF, c = n;\n			while (m-- > 0) {\n				int i = sc.nextInt() - 1;\n				int j = sc.nextInt() - 1;\n				int a = sc.nextInt();\n				a_ = Math.min(a_, Math.abs(a - k));\n				if (a <= k) {\n					if (join(i, j))\n						c--;\n				} else {\n					ii[m_] = i;\n					jj[m_] = j;\n					aa[m_] = a - k;\n					m_++;\n				}\n			}\n			m = m_;\n			if (c == 1) {\n				println(a_);\n				continue;\n			}\n			Integer[] hh = new Integer[m];\n			for (int h = 0; h < m; h++)\n				hh[h] = h;\n			Arrays.sort(hh, (h1, h2) -> aa[h1] - aa[h2]);\n			long ans = 0;\n			for (int h = 0; h < m && c > 1; h++) {\n				int h_ = hh[h];\n				if (join(ii[h_], jj[h_])) {\n					c--;\n					ans += aa[h_];\n				}\n			}\n			println(ans);\n		}\n	}\n}\n","dsu,graphs,greedy"
"import java.io.*;\nimport java.util.*;\n\npublic class road_reform {\n	public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int t = in.nextInt();\n        for (int i = 0; i < t; i++) {\n            solve(in, out);\n        }\n        \n        out.close();\n    }\n    static void solve(Scanner in, PrintWriter out){\n        int n = in.nextInt(), m = in.nextInt(), k = in.nextInt();\n        int[][] arr = new int[m][];\n        Map<Integer, Map<Integer, Integer>> mp = new HashMap<>();\n        List<int[]> ls = new ArrayList<>();\n        List<int[]> hi = new ArrayList<>();\n        int close = Integer.MAX_VALUE / 2;\n        for (int i = 0; i < m; i++) {\n            arr[i] = new int[]{in.nextInt() - 1, in.nextInt() - 1, in.nextInt()};\n            if (arr[i][2] < k){\n                ls.add(arr[i]);\n            }else{\n                close = Math.min(close, arr[i][2] - k);\n                hi.add(arr[i]);\n            }\n        }\n        \n        int[] pars = new int[n + 1];\n        Collections.sort(ls, (a, b) -> (b[2] - a[2]));\n        Collections.sort(hi, (a, b) -> (a[2] - b[2]));\n        Arrays.fill(pars, -1);\n        int max = 0;\n        for(int[] ar : ls){\n            if (find(ar[0], pars) == find(ar[1], pars)) continue;\n            max = Math.max(max, ar[2]);\n            union(ar[0], ar[1], pars);\n        }\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (pars[i] < 0) cnt++;\n        }\n        if (cnt == 1){\n            out.println(Math.min(k - max, close));\n        }else{\n            long ans = 0;\n            for(int[] ar : hi){\n                if (find(ar[0], pars) == find(ar[1], pars)) continue;\n                ans += (ar[2] - k);\n                union(ar[0], ar[1], pars);\n            }\n            out.println(ans);\n        }\n \n    }\n    static int find(int i, int[] par){\n        if (par[i] < 0) return i;\n        return par[i] = find(par[i], par);\n    }\n    static boolean union(int i, int j, int[] par){\n        int pi = find(i, par);\n        int pj = find(j, par);\n        if (pi == pj) return false;\n        if (par[pi] < par[pj]){\n            par[pi] += par[pj];\n            par[pj] = pi;\n        }else{\n            par[pj] += par[pi];\n            par[pi] = pj;\n        }\n        return true;\n    }\n}\n","dsu,graphs,greedy"
"import java.io.PrintWriter;\nimport java.util.*;\n\npublic class Road_Reform {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int t = sc.nextInt();\n        for (int i = 0; i < t; i++) {\n            solve(sc, pw);\n        }\n        pw.close();\n    }\n    static void solve(Scanner in, PrintWriter out){\n        int n = in.nextInt(), m = in.nextInt(), k = in.nextInt();\n        int[][] arr = new int[m][];\n        Map<Integer, Map<Integer, Integer>> mp = new HashMap<>();\n        List<int[]> ls = new ArrayList<>();\n        List<int[]> hi = new ArrayList<>();\n        int close = Integer.MAX_VALUE / 2;\n        for (int i = 0; i < m; i++) {\n            arr[i] = new int[]{in.nextInt() - 1, in.nextInt() - 1, in.nextInt()};\n            if (arr[i][2] < k){\n                ls.add(arr[i]);\n            }else{\n                close = Math.min(close, arr[i][2] - k);\n                hi.add(arr[i]);\n            }\n        }\n        int[] pars = new int[n + 1];\n        Collections.sort(ls, (a, b) -> (b[2] - a[2]));\n        Collections.sort(hi, (a, b) -> (a[2] - b[2]));\n        Arrays.fill(pars, -1);\n        int max = 0;\n        for(int[] ar : ls){\n            if (find(ar[0], pars) == find(ar[1], pars)) continue;\n            max = Math.max(max, ar[2]);\n            union(ar[0], ar[1], pars);\n        }\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (pars[i] < 0) cnt++;\n        }\n        if (cnt == 1){\n            out.println(Math.min(k - max, close));\n        }else{\n            long ans = 0;\n            for(int[] ar : hi){\n                if (find(ar[0], pars) == find(ar[1], pars)) continue;\n                ans += (ar[2] - k);\n                union(ar[0], ar[1], pars);\n            }\n            out.println(ans);\n        }\n\n    }\n    static int find(int i, int[] par){\n        if (par[i] < 0) return i;\n        return par[i] = find(par[i], par);\n    }\n    static boolean union(int i, int j, int[] par){\n        int pi = find(i, par);\n        int pj = find(j, par);\n        if (pi == pj) return false;\n        if (par[pi] < par[pj]){\n            par[pi] += par[pj];\n            par[pj] = pi;\n        }else{\n            par[pj] += par[pi];\n            par[pi] = pj;\n        }\n        return true;\n    }\n}\n\n","dsu,graphs,greedy"
"import java.util.*;\nimport java.io.*;\n\npublic class _1468_J {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        int t = Integer.parseInt(in.readLine());\n        while(t-- > 0) {\n            StringTokenizer line = new StringTokenizer(in.readLine());\n            int n = Integer.parseInt(line.nextToken());\n            int m = Integer.parseInt(line.nextToken());\n            int k = Integer.parseInt(line.nextToken());\n            int[][] edges = new int[m][3];\n            ArrayList<Edge>[] graph = new ArrayList[n];\n            for(int i = 0; i < n; i++) graph[i] = new ArrayList<Edge>();\n            for(int i = 0; i < m; i++) {\n                line = new StringTokenizer(in.readLine());\n                int v1 = Integer.parseInt(line.nextToken()) - 1;\n                int v2 = Integer.parseInt(line.nextToken()) - 1;\n                int w = Integer.parseInt(line.nextToken());\n                edges[i] = new int[] {v1, v2, w};\n                int aw;\n                if(w <= k) aw = 0;\n                else aw = w - k;\n                graph[v1].add(new Edge(v2, aw));\n                graph[v2].add(new Edge(v1, aw));\n            }\n            long sum = MST(graph);\n            int min = Integer.MAX_VALUE;\n            for(int i = 0; i < m; i++) {\n                min = Math.min(min, Math.abs(k - edges[i][2]));\n            }\n            if(sum == 0) {\n                out.println(min);\n            }else {\n                out.println(sum);\n            }\n        }\n        in.close();\n        out.close();\n    }\n    static long MST(ArrayList<Edge>[] graph) {\n        long edgesum = 0;\n        PriorityQueue<Step> pq = new PriorityQueue<Step>();\n        HashSet<Integer> visited = new HashSet<Integer>();\n        pq.add(new Step(0, 0));\n        while(pq.size() > 0) {\n            Step cur = pq.poll();\n            if(visited.contains(cur.node)) {\n                continue;\n            }\n            visited.add(cur.node);\n            edgesum += cur.w;\n            for(Edge e : graph[cur.node]) {\n                pq.add(new Step(e.v, e.w));\n            }\n        }\n        return edgesum;\n    }\n    static class Edge {\n        int v, w;\n        Edge(int vv, int ww) {\n            v = vv;\n            w = ww;\n        }\n    }\n    static class Step implements Comparable<Step> {\n        int node, w;\n        Step(int n, int ww) {\n            node = n;\n            w = ww;\n        }\n        @Override\n        public int compareTo(Step o) {\n            return w - o.w;\n        }\n    }\n}\n","dsu,graphs,greedy"
"import java.util.*;\npublic class CF_ER_100_D2_A {\n\n	public static void main(String[] args) {\n		Scanner scan=new Scanner(System.in);\n		int t=scan.nextInt();\n		while(t-->0) {\n			int a=scan.nextInt(),b=scan.nextInt(),c=scan.nextInt();\n			long sum=a+b+c;\n			long l=sum/9;\n			if(sum%9==0&&(l<=a&&l<=b&&l<=c)) {\n				System.out.println(""Yes"");\n			}else {\n				System.out.println(""No"");\n			}\n		}\n	}\n}\n","binary search,math"
"import java.util.*;\npublic class yoo\n{\n\n	public static void main(String[] args)\n	{\n		Scanner scan=new Scanner(System.in);\n		int t=scan.nextInt();\n		while(t-->0) \n		{\n			int a=scan.nextInt(),b=scan.nextInt(),c=scan.nextInt();\n			long sum=a+b+c;\n			long l=sum/9;\n			if(sum%9==0&&(l<=a&&l<=b&&l<=c)) \n			{\n				System.out.println(""Yes"");\n			}else \n			{\n				System.out.println(""No"");\n			}\n		}\n	}\n}\n","binary search,math"
"import java.util.*;\npublic class Dungeon {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		outer:\n		while(t-->0) {\n			int a=sc.nextInt();\n			int b=sc.nextInt();\n			int c=sc.nextInt();\n			int k=(a+b+c)/9;\n			if((a+b+c)%9==0 && k<=a && k<=b && k<=c) {\n				System.out.println(""YES"");\n			}\n			else {\n				System.out.println(""NO"");\n			}\n		}\n	}\n\n}\n","binary search,math"
"import java.util.*;\npublic class Soution {\n		public static void main(String args[]) {\n			Scanner sc = new Scanner(System.in);\n			int t =sc.nextInt();\n			while(t-->0) {\n				int a = sc.nextInt();\n				int b = sc.nextInt();\n				int c = sc.nextInt();\n				\n				int sum = a+b+c;\n				if( sum%9== 0 && a>=sum/9 && b>=sum/9 && c>=sum/9) {\n					System.out.println(""YES"");\n				}\n				else System.out.println(""NO"");\n			}\n		}\n}\n","binary search,math"
"import java.util.*;\n\npublic class b{\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		int t = s.nextInt();\n		while(t-->0){\n			int n = s.nextInt();\n			int arr[] = new int[n];\n			long sum = 0;\n			long max = 0;\n			for(int i=0;i<n;i++){\n				arr[i] = s.nextInt();\n				sum+=arr[i];\n				max = Math.max(arr[i],max);\n			}\n			long req = Math.max(max*(n-1), ((long)Math.ceil((sum*1.0)/(n-1)))*(n-1));\n			System.out.println(req-sum);\n\n		}\n	}\n}","binary search,greedy,math,sortings"
"import java.util.*;\npublic class class362 {\npublic static void main(String arg[])\n{\n	Scanner sc=new Scanner(System.in);\n	int t=sc.nextInt();\n	while(t-->0)\n	{\n		long n=sc.nextLong();\n		long sum=0,max=0;\n		int i;\n		for(i=1;i<=n;i++)\n		{\n		long x=sc.nextLong();\n		if(x>max)\n		{\n			max=x;\n		}\n		sum+=x;\n		}\n		long div=0;\n		if(sum%(n-1)==0)\n		{\n		div=sum/(n-1);	\n		}\n		else\n		{\n			div=sum/(n-1)+1;\n		}\n		long r=Math.max(div,max);\n		long c=(n-1)*r-sum;\n		System.out.println(c);\n	}\n}\n}\n","binary search,greedy,math,sortings"
"\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class main{ \n	 public static void main(String args[])\n	    { \n		 	Scanner sc = new Scanner(System.in);\n		 	int t = sc.nextInt();\n		 	while(t-->0)\n		 	{\n		 		long n = sc.nextLong(),max=0;\n		 		long a[] = new long[(int)n],sum=0;\n		 		for(int i=0;i<n;i++)\n		 		{\n		 			a[i]=sc.nextLong();\n		 			sum += a[i];\n		 			if(max<a[i])max=a[i];\n		 		}\n		 		long required = Math.max(max*(n-1),(long)Math.ceil(sum*1.0/(n-1))*(n-1));\n			 	System.out.println(required-sum);\n		 	}\n	    }\n		 \n}","binary search,greedy,math,sortings"
"import java.util.*;\n\npublic class Codeforces {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while (t >= 1) {\n			t--;\n			int n = sc.nextInt();\n			int a[] = new int[n + 100];\n			long maxi = 0;\n			long sum = 0;\n			for (int i = 0; i < n; i++) {\n				int k = sc.nextInt();\n				sum += k;\n				maxi = Math.max(maxi, k);\n			}\n			long P = (sum + n - 1 - 1) / (n - 1) * (n - 1);\n			long Q = maxi * (n - 1);\n			if (P < Q) {\n				P = Q;\n			}\n			System.out.println(P - sum);\n		}\n		sc.close();\n	}\n}","binary search,greedy,math,sortings"
"public class p1451B{\n    public static void main(String[] args){\n        var sc=new java.util.Scanner(System.in);\n        for(int t=sc.nextInt();t-->0;) {\n            int n=sc.nextInt(),q=sc.nextInt();\n         L: for(char s[]=sc.next().toCharArray();q-->0;) {\n                int l=sc.nextInt()-1,r=sc.nextInt()-1;\n                for(int i=0;i<n;i++) \n                    if((s[l]==s[i] && i<l)||(s[r]==s[i] && i>r)){System.out.println(""YES""); continue L;}\n                System.out.println(""NO"");\n            }\n        }\n    }\n}","dp,greedy,implementation,strings"
"public class p1451B{\n    public static void main(String[] args){\n        var sc=new java.util.Scanner(System.in);\n        for(int t=sc.nextInt();t-->0;) {\n            int n=sc.nextInt(),q=sc.nextInt();\n         L: for(char s[]=sc.next().toCharArray();q-->0;) {\n                int l=sc.nextInt()-1,r=sc.nextInt()-1;\n                for(int i=0;i<n;i++) \n                    if((s[l]==s[i] && i<l)||(s[r]==s[i] && i>r)){System.out.println(""YES""); continue L;}\n                System.out.println(""NO"");\n            }\n        }\n    }\n}","dp,greedy,implementation,strings"
"public class p1451B{\n    public static void main(String[] args){\n        var sc=new java.util.Scanner(System.in);\n        for(int t=sc.nextInt();t-->0;) {\n            int n=sc.nextInt(),q=sc.nextInt();\n            for(char s[]=sc.next().toCharArray();q-->0;) {\n                int l=sc.nextInt()-1,r=sc.nextInt()-1;\n                boolean b=false;\n                for(int i=l-1;i>-1;i--) if(s[l]==s[i]) b=true;\n                for(int i=r+1;i<n;i++)  if(s[r]==s[i]) b=true;\n                System.out.println(b?""YES"":""NO"");\n            }\n        }\n    }\n}","dp,greedy,implementation,strings"
"import java.util.Scanner;\n\npublic class Main {\n\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		int tc = s.nextInt();\n		for(int t = 0;t < tc;t++) {\n			int n = s.nextInt();\n			int q = s.nextInt();\n			String str = s.next();\n			for(int Q = 0;Q < q;Q++) {\n				int l = s.nextInt() - 1;\n				int r = s.nextInt() - 1;\n				\n				if(str.substring(r + 1).contains(str.charAt(r) + """")) {\n					System.out.println(""YES"");\n				}\n				else if(str.substring(0, l).contains(str.charAt(l) + """")) {\n					System.out.println(""YES"");\n				}\n				else System.out.println(""NO"");\n			}\n		}\n	}\n\n}\n","dp,greedy,implementation,strings"
"import java.io.*;\nimport java.util.stream.IntStream;\n\npublic class Solution {\n  public static long[] f = new long[16]; // factorial\n  public static void solve(BufferedReader br) throws IOException {\n    String[] s = br.readLine().split("" "");\n    int n = Integer.parseInt(s[0]); // number of elements\n    int q = Integer.parseInt(s[1]); // number of queries\n    \n    // since 14! > 10^10, We can split array into (1, n-13) + (n-13, n)\n    int[] head;\n    int[] tail;\n    int[] tail_init;\n    long y = 0;\n    if (n > 15) {\n      head = IntStream.range(1, n-14).toArray();\n      tail = IntStream.range(n-14, n+1).toArray();\n      tail_init = IntStream.range(n-14, n+1).toArray();\n    } else {\n      head = new int[0]; \n      tail = IntStream.range(1, n+1).toArray();\n      tail_init = IntStream.range(1, n+1).toArray();\n    }\n\n    // prefix head\n    long[] prefix = new long[head.length+1];\n    for (int i=1; i<head.length+1; i++) {\n      prefix[i] = prefix[i-1] + head[i-1];\n    }\n\n    // read\n    while (q-- > 0) {\n      s = br.readLine().split("" "");\n      int op = Integer.parseInt(s[0]);\n      if (op == 1) {\n        int l = Integer.parseInt(s[1]);\n        int r = Integer.parseInt(s[2]);\n        long sum = 0;\n        // calculate sum of [l,r]\n        if (l <= head.length) {\n          // sum + head[l, min(r, head.length)]\n          int k = Math.min(r, head.length);\n          sum += prefix[k] - prefix[l-1];\n        }\n  \n        if (r > head.length) {\n          // sum += tail[max(l, head.length), r]\n          for (int i=Math.max(l, head.length+1); i<=r; i++) {\n            sum += tail[i-head.length-1];\n          }\n        }\n        System.out.println(sum);\n      } else {\n        // op == 2\n        int x = Integer.parseInt(s[1]);\n        y += x;\n        tail = permuteNext(tail_init, y);\n      }\n    }\n  }\n  public static int[] permuteNext(int[] arr, long x) {\n    // get next permutation for sorted array\n    int n = arr.length;\n    int[] res = new int[n];\n    boolean[] mark = new boolean[n];\n\n    long q;\n    long r=x;\n    for (int i=0; i<n; i++) {\n      q = r / f[n-1-i];\n      r = r - q * f[n-1-i];\n\n      // qth element will be selected\n      int k=0;\n      while (true) {\n        if (mark[k] == false) {\n          q--;\n          if (q<0) {\n            break;\n          }\n        }\n        k++;\n      }\n      res[i] = arr[k];\n      mark[k] = true;\n    }\n\n    return res;\n  }\n  public static void main(String[] args) throws IOException {\n    // precompute factorial\n    f[0] = 1;\n    for (int i=1; i<=15; i++) {\n      f[i] = i*f[i-1];\n    }\n    try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))){\n      solve(br);\n    }\n  }\n}","brute force,math,two pointers"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class Task5 {\n    long[] fact;\n\n    public static void main(String[] args) throws IOException {\n        new Task5().solve();\n    }\n\n    ArrayList<Integer> getLastOrder(ArrayDeque<Integer> lastElements, ArrayList<Integer> order, int pref, long skip) {\n        if (pref < 0) return order;\n\n        ArrayList<Integer> removed = new ArrayList<Integer>();\n        int curr = lastElements.removeFirst();\n        while (fact[pref] <= skip) {\n            skip -= fact[pref];\n            removed.add(curr);\n            curr = lastElements.removeFirst();\n        }\n\n        for (int i = removed.size() - 1; i >= 0; i--) {\n            lastElements.addFirst(removed.get(i));\n        }\n\n        order.add(curr);\n        getLastOrder(lastElements, order, pref - 1, skip);\n        return order;\n    }\n\n    private void solve() throws IOException {\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        StringTokenizer tokenizer = new StringTokenizer(f.readLine());\n        int n = Integer.parseInt(tokenizer.nextToken());\n        int q = Integer.parseInt(tokenizer.nextToken());\n\n        fact = new long[20];\n        fact[0] = 1;\n        for (int i = 1; i < 20; i++) {\n            fact[i] = fact[i - 1] * i;\n        }\n\n        ArrayDeque<Integer> lastElements = new ArrayDeque<Integer>();\n        for (int i = n; n - i < Math.min(15, n); i--) lastElements.addFirst(i);\n        long absChange = 0;\n        ArrayList<Integer> order = getLastOrder(lastElements.clone(), new ArrayList<Integer>(), lastElements.size() - 1, 0);\n        for (int q1 = 0; q1 < q; q1++) {\n            tokenizer = new StringTokenizer(f.readLine());\n            int command = Integer.parseInt(tokenizer.nextToken());\n            if (command == 1) {\n                int l = Integer.parseInt(tokenizer.nextToken());\n                int r = Integer.parseInt(tokenizer.nextToken());\n                long res = 0;\n                if (l > n - lastElements.size()) {\n                    l -= n - lastElements.size() + 1;\n                    r -= n - lastElements.size() + 1;\n                    for (int i = l; i <= r; i++) {\n                        res += order.get(i);\n                    }\n                } else {\n                    int mid = Math.min(r, n - lastElements.size());\n                    mid = Math.max(l - 1, mid);\n                    res += arithmeticProgression(l, mid);\n                    int in = r - mid;\n                    for (int i = 0; i < in; i++) res += order.get(i);\n                }\n\n                out.println(res);\n            } else {\n                int x = Integer.parseInt(tokenizer.nextToken());\n                absChange += x;\n                order = getLastOrder(lastElements.clone(), new ArrayList<Integer>(), lastElements.size() - 1, absChange);\n            }\n        }\n\n        out.close();\n    }\n\n    static long arithmeticProgression(int from, int to) {\n        if (to < from) return 0;\n        return (long) (from + to) * (to - from + 1) / 2;\n    }\n}\n","brute force,math,two pointers"
"import java.io.BufferedOutputStream;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.InputMismatchException;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	static class TaskAdapter implements Runnable {\n		@Override\n		public void run() {\n			long startTime = System.currentTimeMillis();\n			InputStream inputStream = System.in;\n			OutputStream outputStream = System.out;\n			FastReader in = new FastReader(inputStream);\n			Output out = new Output(outputStream);\n			ELongPermutation solver = new ELongPermutation();\n			solver.solve(1, in, out);\n			out.close();\n			System.err.println(System.currentTimeMillis()-startTime+""ms"");\n		}\n	}\n\n	public static void main(String[] args) throws Exception {\n		Thread thread = new Thread(null, new TaskAdapter(), """", 1<<28);\n		thread.start();\n		thread.join();\n	}\n\n	static class ELongPermutation {\n		long[] fact;\n		long[] psum;\n\n		public ELongPermutation() {\n			fact = new long[16];\n			fact[0] = 1;\n			for(int i = 1; i<=15; i++) {\n				fact[i] = fact[i-1]*i;\n			}\n			int mn = (int) 2e5;\n			psum = new long[mn+1];\n			for(int i = 1; i<=mn; i++) {\n				psum[i] = psum[i-1]+i;\n			}\n		}\n\n		public int[] solve(int n, long k) {\n			if(n==1) {\n				return new int[] {1};\n			}\n			int start = (int) (k/fact[n-1]+1);\n			int[] ret = new int[n];\n			ret[0] = start;\n			System.arraycopy(solve(n-1, k%fact[n-1]), 0, ret, 1, n-1);\n			for(int i = 1; i<n; i++) {\n				if(ret[i]>=start) {\n					ret[i]++;\n				}\n			}\n			return ret;\n		}\n\n		public void solve(int kase, InputReader in, Output pw) {\n			int n = in.nextInt(), q = in.nextInt();\n			int m = Math.min(16, n), start = n-m;\n			int[] arr = solve(m, 0);\n			long sum = 0;\n			while(q-->0) {\n				int type = in.nextInt();\n				if(type==1) {\n					int l = in.nextInt()-1, r = in.nextInt()-1;\n					long ans = 0;\n					if(r>=start) {\n						int al = Math.max(0, l-start), ar = r-start;\n						for(int i = al; i<=ar; i++) {\n							ans += arr[i]+start;\n						}\n					}\n					if(l<start) {\n						int al = l, ar = Math.min(start-1, r);\n						ans += psum[ar+1]-psum[al];\n					}\n					pw.println(ans);\n				}else {\n					arr = solve(m, sum += in.nextInt());\n				}\n			}\n		}\n\n	}\n\n	static class Output implements Closeable, Flushable {\n		public StringBuilder sb;\n		public OutputStream os;\n		public int BUFFER_SIZE;\n		public String lineSeparator;\n\n		public Output(OutputStream os) {\n			this(os, 1<<16);\n		}\n\n		public Output(OutputStream os, int bs) {\n			BUFFER_SIZE = bs;\n			sb = new StringBuilder(BUFFER_SIZE);\n			this.os = new BufferedOutputStream(os, 1<<17);\n			lineSeparator = System.lineSeparator();\n		}\n\n		public void println(long l) {\n			println(String.valueOf(l));\n		}\n\n		public void println(String s) {\n			sb.append(s);\n			println();\n		}\n\n		public void println() {\n			sb.append(lineSeparator);\n		}\n\n		private void flushToBuffer() {\n			try {\n				os.write(sb.toString().getBytes());\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n			sb = new StringBuilder(BUFFER_SIZE);\n		}\n\n		public void flush() {\n			try {\n				flushToBuffer();\n				os.flush();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n		public void close() {\n			flush();\n			try {\n				os.close();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n	}\n\n	static class FastReader implements InputReader {\n		final private int BUFFER_SIZE = 1<<16;\n		private DataInputStream din;\n		private byte[] buffer;\n		private int bufferPointer;\n		private int bytesRead;\n\n		public FastReader(InputStream is) {\n			din = new DataInputStream(is);\n			buffer = new byte[BUFFER_SIZE];\n			bufferPointer = bytesRead = 0;\n		}\n\n		public int nextInt() {\n			int ret = 0;\n			byte c = skipToDigit();\n			boolean neg = (c=='-');\n			if(neg) {\n				c = read();\n			}\n			do {\n				ret = ret*10+c-'0';\n			} while((c = read())>='0'&&c<='9');\n			if(neg) {\n				return -ret;\n			}\n			return ret;\n		}\n\n		private boolean isDigit(byte b) {\n			return b>='0'&&b<='9';\n		}\n\n		private byte skipToDigit() {\n			byte ret;\n			while(!isDigit(ret = read())&&ret!='-') ;\n			return ret;\n		}\n\n		private void fillBuffer() {\n			try {\n				bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n			}catch(IOException e) {\n				e.printStackTrace();\n				throw new InputMismatchException();\n			}\n			if(bytesRead==-1) {\n				buffer[0] = -1;\n			}\n		}\n\n		private byte read() {\n			if(bytesRead==-1) {\n				throw new InputMismatchException();\n			}else if(bufferPointer==bytesRead) {\n				fillBuffer();\n			}\n			return buffer[bufferPointer++];\n		}\n\n	}\n\n	static interface InputReader {\n		int nextInt();\n\n	}\n}\n\n","brute force,math,two pointers"
"import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\n	private static final String NO = ""NO"";\n	private static final String YES = ""YES"";\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n\n	private static final long MOD = 998244353;\n	static int MAXN = 100000;\n\n	void solve() {\n		int T = 1;// ni();\n		for (int i = 0; i < T; i++)\n			solve(i);\n	}\n\n	long n;\n\n	int a[] = new int[20];\n\n	void get(long cur, int n) {\n		if (!dirty)\n			return;\n		int i, j, k, tmp;\n		boolean used[] = new boolean[20];\n		for (i = 1; i <= n; i++) {\n			tmp = 1;\n			while (cur >= fac[n - i]) {\n				cur -= fac[n - i];\n				tmp++;\n			}\n			for (j = 1, k = 0; j <= n; j++) {\n				if (!used[j]) {\n					k++;\n				}\n				if (k == tmp) {\n					used[j] = true;\n					a[i] = j;\n					break;\n				}\n			}\n		}\n//		tr(a);\n		dirty = false;\n	}\n\n	long fac[] = new long[17];\n	boolean dirty = true;\n\n	void solve(int nth) {\n		n = ni();\n		int q = ni();\n		fac[0] = 1;\n		for (int i = 1; i <= 16; i++) {\n			fac[i] = fac[i - 1] * i;\n		}\n		long cur = 0;\n		while (q-- > 0) {\n			int op = ni();\n			if (op == 2) {\n				cur += nl();\n				dirty = true;\n			} else {\n				long l = ni();\n				long r = ni();\n				long res = 0;\n				if (n <= 16) {\n					get(cur, (int) n);\n					for (int i = (int) l; i <= r; i++) {\n						res += a[i];\n					}\n					out.println(res);\n				} else if (r <= n - 16) {\n					out.println((r * r + r - l * l + l) / 2);\n				} else {\n					get(cur, 16);\n					if (l <= n - 16) {\n						for (int i = 1; i <= r - (n - 15) + 1; i++) {\n							res += n - 16 + a[i];\n						}\n						out.println(((n - 16) * (n - 16) + (n - 16) - l * l + l) / 2 + res);\n					} else {\n						for (int i = (int) (l - (n - 15) + 1); i <= r - (n - 15) + 1; i++) {\n							res += n - 16 + a[i];\n						}\n						out.println(res);\n					}\n				}\n			}\n		}\n	}\n\n	// a^b\n	long power(long a, long b) {\n		long x = 1, y = a;\n		while (b > 0) {\n			if (b % 2 != 0) {\n				x = (x * y) % MOD;\n			}\n			y = (y * y) % MOD;\n			b /= 2;\n		}\n		return x % MOD;\n	}\n\n	private long gcd(long a, long b) {\n		while (a != 0) {\n			long tmp = b % a;\n			b = a;\n			a = tmp;\n		}\n		return b;\n	}\n\n	void run() throws Exception {\n		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		if (!INPUT.isEmpty())\n			tr(System.currentTimeMillis() - s + ""ms"");\n	}\n\n	public static void main(String[] args) throws Exception {\n		new Main().run();\n	}\n\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n\n	private int readByte() {\n		if (lenbuf == -1)\n			throw new InputMismatchException();\n		if (ptrbuf >= lenbuf) {\n			ptrbuf = 0;\n			try {\n				lenbuf = is.read(inbuf);\n			} catch (IOException e) {\n				throw new InputMismatchException();\n			}\n			if (lenbuf <= 0)\n				return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n\n	private boolean isSpaceChar(int c) {\n		return !(c >= 33 && c <= 126);\n	}\n\n	private int skip() {\n		int b;\n		while ((b = readByte()) != -1 && isSpaceChar(b))\n			;\n		return b;\n	}\n\n	private double nd() {\n		return Double.parseDouble(ns());\n	}\n\n	private char nc() {\n		return (char) skip();\n	}\n\n	private char[] nc(int n) {\n		char[] ret = new char[n];\n		for (int i = 0; i < n; i++)\n			ret[i] = nc();\n		return ret;\n	}\n\n	private String ns() {\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n									// ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	private char[] ns(int n) {\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while (p < n) {\n			if (!(isSpaceChar(b)))\n				buf[p++] = (char) b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n\n	private char[][] nm(int n, int m) {\n		char[][] map = new char[n][];\n		for (int i = 0; i < n; i++)\n			map[i] = ns(m);\n		return map;\n	}\n\n	private int[] na(int n) {\n		int[] a = new int[n];\n		for (int i = 0; i < n; i++)\n			a[i] = ni();\n		return a;\n	}\n\n	private Integer[] na2(int n) {\n		Integer[] a = new Integer[n];\n		for (int i = 0; i < n; i++)\n			a[i] = ni();\n		return a;\n	}\n\n	private int[][] na(int n, int m) {\n		int[][] a = new int[n][];\n		for (int i = 0; i < n; i++)\n			a[i] = na(m);\n		return a;\n	}\n\n	private int ni() {\n		int num = 0, b;\n		boolean minus = false;\n		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n			;\n		if (b == '-') {\n			minus = true;\n			b = readByte();\n		}\n\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				num = num * 10 + (b - '0');\n			} else {\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n\n	private Long[] nl2(int n) {\n		Long[] a = new Long[n];\n		for (int i = 0; i < n; i++)\n			a[i] = nl();\n		return a;\n	}\n\n	private long[] nl(int n) {\n		long[] a = new long[n];\n		for (int i = 0; i < n; i++)\n			a[i] = nl();\n		return a;\n	}\n\n	private long[][] nl(int n, int m) {\n		long[][] a = new long[n][];\n		for (int i = 0; i < n; i++)\n			a[i] = nl(m);\n		return a;\n	}\n\n	private long nl() {\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n			;\n		if (b == '-') {\n			minus = true;\n			b = readByte();\n		}\n\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				num = num * 10 + (b - '0');\n			} else {\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n\n	private static void tr(Object... o) {\n		System.out.println(Arrays.deepToString(o));\n	}\n\n}\n","brute force,math,two pointers"
"import java.util.*;\n\npublic class Answer {\n	public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n\n		while (t-->0)\n		{\n			int l = sc.nextInt(), r = sc.nextInt();\n			System.out.println(r < 2*l ? ""YES"" : ""NO"");\n		}\n		\n		\n		\n	}\n}","brute force,constructive algorithms,greedy,math"
"import java.util.*;\n\npublic class k {\n	public static void main(String args[]) {\n		Scanner in = new Scanner(System.in);\n		int t = in.nextInt();\n		for ( ; t > 0; t--) {\n			int l = in.nextInt();\n			int r = in.nextInt();\n			System.out.println(r >= 2 * l ? ""NO"" : ""YES"");\n		}\n	}\n}","brute force,constructive algorithms,greedy,math"
"import java.util.Scanner;\n\npublic class ECR97A {\n	public static void main(String[] args) {\n		\n		Scanner s=new Scanner(System.in);\n		\n		int t=s.nextInt();\n		while(t-->0) {\n			int l=s.nextInt();\n			int r=s.nextInt();\n			\n			System.out.println((2*l>r)?""YES"":""NO"");\n		}\n	}\n\n}\n","brute force,constructive algorithms,greedy,math"
"import java.util.*;\npublic class codeforces{\n	public static void main(String args[]){\n		Scanner sc = new Scanner(System.in);\n		int test=sc.nextInt();\n		while(test-->0){\n			long l=sc.nextLong();\n			long r=sc.nextLong();\n			String ans =""NO"";\n			ans=(2*l>r)?""YES"":""NO"";\n			System.out.println(ans);\n\n		}\n\n	}\n\n}\n","brute force,constructive algorithms,greedy,math"
"import java.util.*;\npublic class Solution{\n 	static Scanner sc = new Scanner(System.in);\n	public static void main(String args[]){\n		int t = sc.nextInt();\n		while(t-->0){\n			int n = sc.nextInt(),m = sc.nextInt();\n			boolean flag = false;\n			while(n-->0){\n				int a = sc.nextInt(),b = sc.nextInt(),c = sc.nextInt(),d = sc.nextInt();\n				if(b==c)\n					flag = true;\n			}\n			if(m%2==0&&flag)\n				System.out.println(""YES"");\n			else\n				System.out.println(""NO"");\n		}\n	}\n}",implementation
"import java.util.*;\npublic class Solution{\n 	static Scanner sc = new Scanner(System.in);\n	public static void main(String args[]){\n		int t = sc.nextInt();\n		while(t-->0){\n			int n = sc.nextInt(),m = sc.nextInt();\n			boolean flag = false;\n			while(n-->0){\n				int a = sc.nextInt(),b = sc.nextInt(),c = sc.nextInt(),d = sc.nextInt();\n				if(b==c)\n					flag = true;\n			}\n			if(m%2==0&&flag)\n				System.out.println(""YES"");\n			else\n				System.out.println(""NO"");\n		}\n	}\n}",implementation
"import java.util.*;\npublic class HelloWorld{\n 	static Scanner sc = new Scanner(System.in);\n	public static void main(String args[]){\n		int t = sc.nextInt();\n		while(t-->0){\n			int n = sc.nextInt(),m = sc.nextInt();\n			boolean flag = false;\n			while(n-->0){\n				int a = sc.nextInt(),b = sc.nextInt(),c = sc.nextInt(),d = sc.nextInt();\n				if(b==c)\n					flag = true;\n			}\n			if(m%2==0&&flag==true)\n				System.out.println(""YES"");\n			else\n				System.out.println(""NO"");\n		}\n	}\n}",implementation
"import java.util.*;\npublic class codeforces{\n	public static void main(String args[]){\n		Scanner sc = new Scanner(System.in);\n		int test=sc.nextInt();\n		\n		while(test-->0){\n			int n=sc.nextInt();\n			int m=sc.nextInt();\n\n			boolean flag=false;\n			for(int i=0;i<n;i++){\n				int a=sc.nextInt();\n				int b=sc.nextInt();\n				int c=sc.nextInt();\n				int d=sc.nextInt();\n				if(c==b)flag=true;\n			}\n			String ans =""YES"";\n			if(flag && m%2==0)ans=""YES"";\n			else ans=""NO"";\n			System.out.println(ans);\n		}\n\n	}\n\n}\n",implementation
"import java.io.*;\nimport java.util.*;\n\npublic class T5 extends PrintWriter {\n    public T5() {\n        super(System.out);\n    }\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        T5 main = new T5();\n        int n = 1;\n        while (n-- > 0) {\n            main.mainPrint(s);\n        }\n        main.flush();\n    }\n\n    String str;\n    boolean[] rem;\n    int[] count, index;\n    StringBuilder ans1;\n\n    private void mainPrint(Scanner s) {\n        str = s.nextLine();\n        if (str.length() == 1) {\n            println(1 + "" "" + str);\n            return;\n        }\n        rem = new boolean[str.length()];\n        char last = str.charAt(str.length() - 1) == str.charAt(str.length() - 2) ? 'a' - 1:str.charAt(str.length()-1);\n        char last1 = 'a' - 2;\n        for (int i1 = str.length() - 2; i1 >= 0; i1--) {\n            if (str.charAt(i1) == str.charAt(i1 + 1) && (str.charAt(i1) > last || (str.charAt(i1) == last && last > last1)) && !rem[i1 + 1]) {\n                rem[i1] = true;\n            }\n            if (i1 != 0 && str.charAt(i1 - 1) != str.charAt(i1) && !rem[i1]) {\n                if(str.charAt(i1) != last) last1 = last;\n                last = str.charAt(i1);\n            }\n//            println(last);\n        }\n//        println(Arrays.toString(rem));\n        count = new int[str.length()];\n\n        count[str.length() - 1] = 1;\n        count[str.length() - 2] = rem[str.length() - 2] ? 0 : 2;\n        for (int i = str.length() - 3; i >= 0; i--) {\n            count[i] = rem[i] ? count[i + 2] : count[i + 1] + 1;\n        }\n//        println(Arrays.toString(count));\n\n        ans1 = new StringBuilder();\n        for (int i = 0; i < str.length(); i++) {\n            if (!rem[i]) {\n                ans1.append(str.charAt(i));\n            } else {\n                i++;\n            }\n        }\n\n        index = new int[ans1.length()];\n\n        int p = 0;\n\n        for (int i = 0; i < str.length(); i++) {\n            help(i, p);\n            if (!rem[i] && (i == 0 || !rem[i - 1])) {\n                index[p++] = i;\n            }\n        }\n    }\n\n    private void help(int i, int p) {\n        StringBuilder ans = new StringBuilder();\n        if (i != 0 && rem[i - 1]) ans.append(str.charAt(i));\n\n\n        if (count[i] > 10) {\n            println(count[i] + "" "" + ans + (ans.length() == 1 ? ans1.substring(p, p + 4) : ans1.substring(p, p + 5)) + ""..."" + ans1.substring(ans1.length() - 2));\n        } else {\n            println(count[i] + "" "" + ans + ans1.substring(p));\n        }\n\n    }\n\n}","dp,greedy,implementation,strings"
"import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1422e2 {\n\n    public static void main(String[] args) throws IOException {\n        char[] s = rcha();\n        int n = s.length;\n        long p[] = new long[1 << 19], seed = 29;\n        p[0] = 1;\n        for (int i = 1; i < 1 << 19; ++i) {\n            p[i] = p[i - 1] * seed;\n        }\n        long hash[][] = new long[n << 1][18];\n        int next[][] = new int[n << 1][18], jump[] = new int[n + 1];\n        for (int i = 0; i <= n; ++i) {\n            jump[i] = i;\n        }\n        int len[] = new int[n + 1];\n        for (int i = n - 1; i >= 0; --i) {\n            int j = jump[i + 1];\n            len[i] = len[j] + 1;\n            hash[i][0] = s[i];\n            next[i][0] = j;\n            for (int k = 1; k < 18; ++k) {\n                next[i][k] = next[next[i][k - 1]][k - 1];\n                hash[i][k] = hash[i][k - 1] * p[1 << (k - 1)] + hash[next[i][k - 1]][k - 1];\n            }\n            if (i != n - 1 && s[i] == s[i + 1]) {\n                int a = jump[i], b = jump[i + 2];\n                for (int k = 17; k >= 0; --k) {\n                    if (hash[a][k] == hash[b][k]) {\n                        a = next[a][k];\n                        b = next[b][k];\n                    }\n                }\n                // prln(i, a, b);\n                if (a < n && (b == n || s[b] < s[a])) {\n                    // prln(i);\n                    jump[i] = jump[jump[i + 2]];\n                    len[i] = len[jump[i]];\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            pr(len[i]);\n            pr(' ');\n            int ind = jump[i];\n            for (int j = 0, end = len[i] > 10 ? 5 : len[i]; j < end; ++j) {\n                pr(s[ind]);\n                ind = next[ind][0];\n            }\n            if (len[i] > 10) {\n                pr(""..."");\n                int skip = len[i] - 7;\n                for (int j = 17; j >= 0; --j) {\n                    if ((1 << j) <= skip) {\n                        ind = next[ind][j];\n                        skip -= 1 << j;\n                    }\n                }\n                for (int j = 0; j < 2; ++j) {\n                    pr(s[ind]);\n                    ind = next[ind][0];\n                }\n            }\n            prln();\n            // flush();\n        }\n        close();\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int lcm(int a, int b) {return a * b / gcf(a, b);}\n    static long lcm(long a, long b) {return a * b / gcf(a, b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {prln(""yes"");}\n    static void pry() {prln(""Yes"");}\n    static void prY() {prln(""YES"");}\n    static void prno() {prln(""no"");}\n    static void prn() {prln(""No"");}\n    static void prN() {prln(""NO"");}\n    static boolean pryesno(boolean b) {prln(b ? ""yes"" : ""no""); return b;};\n    static boolean pryn(boolean b) {prln(b ? ""Yes"" : ""No""); return b;}\n    static boolean prYN(boolean b) {prln(b ? ""YES"" : ""NO""); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(""hlfd""); flush();}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}\n}","dp,greedy,implementation,strings"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class e {\n	public static void main(String[] args) {\n		FastScanner scan=new FastScanner();\n		PrintWriter out=new PrintWriter(System.out);\n\n		char[] b=scan.next().toCharArray();\n		int n=b.length;\n\n		ch[] a=new ch[n];\n		for(int i=0;i<n;i++) a[i]=new ch(b[i],i);\n\n		char[] stack=new char[n];\n		int[] ids=new int[n];\n		\n		int ptr=n-1;\n\n		String[] res=new String[n];\n		int[] nxtDifferent=new int[n];\n		Arrays.fill(nxtDifferent,-1);\n		\n		for(int i=n-1;i>=0;i--) {\n			StringBuilder x=new StringBuilder();\n			stack[ptr]=a[i].c;\n			ids[ptr]=a[i].id;\n\n			if(ptr+1<n) {\n				if(stack[ptr]!=stack[ptr+1]) nxtDifferent[ptr]=ptr+1;\n				else nxtDifferent[ptr]=nxtDifferent[ptr+1];\n			}\n			if(ptr<n-1&&stack[ptr]==stack[ptr+1]&&Math.abs(ids[ptr]-ids[ptr+1])==1) {\n				//should we remove this pair?\n				if(nxtDifferent[ptr]==-1||stack[nxtDifferent[ptr]]<stack[ptr]) {\n					ptr++;\n				}\n				else ptr--;\n			}\n			else ptr--;\n\n			int len=n-ptr-1;\n			x.append(len);\n			x.append("" "");\n\n			if(len>10) {\n				for(int j=ptr+1;j<ptr+6;j++) {\n					x.append(stack[j]);\n				}\n				x.append(""..."");\n				x.append(stack[n-2]);\n				x.append(stack[n-1]);\n			}\n			else {\n				for(int j=ptr+1;j<n;j++) {\n					x.append(stack[j]);\n				}\n			}\n			res[i]=x.toString();\n		}\n\n		for(String s:res) out.println(s);\n\n		out.close();\n	}\n	static class ch {\n		char c;\n		int id;\n\n		ch(char c, int id) {\n			this.c=c;\n			this.id=id;\n		}\n	}\n	static class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		public FastScanner() {\n			try	{\n				br = new BufferedReader(new InputStreamReader(System.in));\n				st = new StringTokenizer(br.readLine());\n			} catch (Exception e){e.printStackTrace();}\n		}\n\n		public String next() {\n			if (st.hasMoreTokens())	return st.nextToken();\n			try {st = new StringTokenizer(br.readLine());}\n			catch (Exception e) {e.printStackTrace();}\n			return st.nextToken();\n		}\n\n		public int nextInt() {return Integer.parseInt(next());}\n\n		public long nextLong() {return Long.parseLong(next());}\n\n		public double nextDouble() {return Double.parseDouble(next());}\n\n		public String nextLine() {\n			String line = """";\n			if(st.hasMoreTokens()) line = st.nextToken();\n			else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n			while(st.hasMoreTokens()) line += "" ""+st.nextToken();\n			return line;\n		}\n	}\n}","dp,greedy,implementation,strings"
"import java.io.*;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class E2 {\n\n	static long mod = 1000000007;\n	public static void main(String[] args) {\n		FastScanner sc = new FastScanner();\n		char[] s = (sc.next()+""$"").toCharArray();\n		int n = s.length-1;\n		boolean[] kill = new boolean[n+1];\n		for(int i = n-1; i >= 0; i--) {\n			if(s[i] == s[i+1] && !kill[i+1]) kill[i] = true;\n		}\n		LinkedList<Character> st = new LinkedList<>();\n		LinkedList<Character> stdif = new LinkedList<>();\n		st.add('$');\n		stdif.add('$');\n		StringBuilder[] sb = new StringBuilder[n];\n		int[] sizes = new int[n];\n		for(int i = n-1; i >= 0; i--) {\n			if(!kill[i]) {\n				st.addFirst(s[i]);\n				if(s[i] != stdif.getFirst()) stdif.addFirst(s[i]);\n			}\n			else {\n				if(st.get(1) < s[i]) {\n					st.removeFirst();\n					if(st.getFirst() != stdif.getFirst()) stdif.removeFirst();\n				}\n				else if(st.get(1) > s[i]) {\n					st.addFirst(s[i]);\n					if(s[i] != stdif.getFirst()) stdif.addFirst(s[i]);\n				}\n				else {\n					if(s[i] > stdif.get(1)) {\n						st.removeFirst();\n						if(st.getFirst() != stdif.getFirst()) stdif.removeFirst();\n					}\n					else {\n						st.addFirst(s[i]);\n						if(s[i] != stdif.getFirst()) stdif.addFirst(s[i]);\n					}\n				}\n			}\n			sizes[i] = st.size()-1;\n			if(sizes[i] <= 10) {\n				sb[i] = new StringBuilder();\n				for(char c: st) {\n					if(c != '$') {\n						sb[i].append(c+"""");\n					}\n				}\n			}\n			else {\n				char[] left = new char[5];\n				for(int k = 0; k < 5; k++) {\n					left[k] = st.removeFirst();\n				}\n				st.removeLast();\n				char right2 = st.removeLast(); \n				char right1 = st.removeLast();\n				sb[i] = new StringBuilder(new String(left)+""...""+right1+""""+right2);\n				st.addLast(right1);\n				st.addLast(right2);\n				st.addLast('$');\n				for(int k = 4; k >= 0; k--) {\n					st.addFirst(left[k]);\n				}\n			}\n		}\n		StringBuilder sbres = new StringBuilder();\n		for(int i = 0; i < n; i++) {\n			sbres.append(sizes[i]+"" ""+sb[i].toString()+""\n"");\n		}\n		PrintWriter pw = new PrintWriter(System.out);\n		pw.print(sbres.toString());\n		pw.flush();\n	}\n	\n	static class FastScanner {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n        	return Long.parseLong(next());\n        }\n        public double nextDouble() {\n        	return Double.parseDouble(next());\n        }\n        public String nextLine() {\n        	try {\n        		return reader.readLine();\n        	} catch(IOException e) {\n        		throw new RuntimeException(e);\n        	}\n        }\n    }\n\n}\n","dp,greedy,implementation,strings"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1407E extends PrintWriter {\n	CF1407E() { super(System.out, true); }\n	static class Scanner {\n		Scanner(InputStream in) { this.in = in; } InputStream in;\n		byte[] bb = new byte[1 << 15]; int i, n;\n		byte getc() {\n			if (i == n) {\n				i = n = 0;\n				try { n = in.read(bb); } catch (IOException e) {}\n			}\n			return i < n ? bb[i++] : 0;\n		}\n		int nextInt() {\n			byte c = 0; while (c <= ' ') c = getc();\n			int a = 0; while (c > ' ') { a = a * 10 + c - '0'; c = getc(); }\n			return a;\n		}\n	}\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1407E o = new CF1407E(); o.main(); o.flush();\n	}\n\n	int[] eo; int[][] ej, et;\n	void init(int n) {\n		eo = new int[n]; ej = new int[n][2]; et = new int[n][2];\n	}\n	void append(int i, int j, int t) {\n		int o = eo[i]++;\n		if (o >= 2 && (o & o - 1) == 0) {\n			ej[i] = Arrays.copyOf(ej[i], o << 1);\n			et[i] = Arrays.copyOf(et[i], o << 1);\n		}\n		ej[i][o] = j;\n		et[i][o] = t;\n	}\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		init(n);\n		for (int h = 0; h < m; h++) {\n			int i = sc.nextInt() - 1;\n			int j = sc.nextInt() - 1;\n			int t = 1 << sc.nextInt();\n			if (i != j)\n				append(j, i, t);\n		}\n		int[] tt = new int[n];\n		int[] dd = new int[n]; Arrays.fill(dd, n);\n		int[] qu = new int[n]; int head = 0, cnt = 0;\n		char[] cc = new char[n]; Arrays.fill(cc, '0');\n		tt[n - 1] = 3; dd[n - 1] = 0; qu[head + cnt++] = n - 1;\n		while (cnt > 0) {\n			int i = qu[head++]; cnt--;\n			int d = dd[i] + 1;\n			for (int o = 0; o < eo[i]; o++) {\n				int j = ej[i][o];\n				int t = et[i][o];\n				if ((tt[j] & t) == 0) {\n					if ((tt[j] |= t) == 3) {\n						dd[j] = d; qu[head + cnt++] = j;\n					} else\n						cc[j] = t == 1 ? '1' : '0';\n				}\n			}\n		}\n		println(dd[0] == n ? -1 : dd[0]);\n		println(cc);\n	}\n}\n","constructive algorithms,dfs and similar,dp,graphs,greedy,shortest paths"
"import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n  public static void solve(BufferedReader br) throws IOException {\n    String[] s = br.readLine().split("" "");\n    int N = Integer.parseInt(s[0]);  // number of vertices\n    int M = Integer.parseInt(s[1]);  // number of edges\n\n    List<Pair<Integer, Integer>>[] edges = new ArrayList[N+1];\n    for (int i=1; i<=N; i++) {\n      edges[i] = new ArrayList<>();\n    }\n    // read edges, we reverse edges\n    for (int i=1; i<=M; i++) {\n      s = br.readLine().split("" "");\n      int u = Integer.parseInt(s[0]);\n      int v = Integer.parseInt(s[1]);\n      int t = Integer.parseInt(s[2]);\n\n      Pair<Integer, Integer> pair = new Pair<>(u, t);\n      edges[v].add(pair);\n    }\n\n    // initialization\n    int[] color = new int[N+1]; // color of vertices, can be either 1 or 0\n    int[] dist = new int[N+1]; // shortest distance from N to i\n    Arrays.fill(color, -1);\n    Arrays.fill(dist, -1);\n    dist[N] = 0;\n    \n    boolean[] visited = new boolean[N+1]; // whether vertices have been visited\n\n    // bfs\n    Queue<Integer> queue = new ArrayDeque<>();\n    queue.add(N);\n    visited[N] = true;\n\n    while (queue.size() > 0) {\n      int v = queue.poll();\n      // iterate all inwards edges\n      for (Pair<Integer, Integer> pair : edges[v]) {\n        int u = pair.first;\n        int t = pair.second;\n        if (visited[u]) continue; // if visited we skip\n        if (color[u] == t) {\n          queue.add(u);\n          visited[u] = true; \n          dist[u] = dist[v] + 1;\n        } else {\n          color[u] = 1 - t; // assign an opposite color to the road's color\n        }\n      }\n    }\n\n\n    StringBuilder sb = new StringBuilder(dist[1]+""\n"");\n    for(int i=1; i <= N; i++) {\n        if(color[i] == -1) {\n           color[i] = 0;\n        }\n        sb.append(color[i]);\n    }\n    System.out.println(sb);\n  }\n  public static void main(String[] args) throws IOException {\n    try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))){\n      solve(br);\n    }\n  }\n}\n\nclass Pair<T1, T2> {\n  public T1 first;\n  public T2 second;\n  public Pair(T1 first, T2 second) {\n    this.first = first;\n    this.second = second;\n  }\n}","constructive algorithms,dfs and similar,dp,graphs,greedy,shortest paths"
"// testest\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n \npublic class E {\n \n	public static void main(String[] args) {\n		FastScanner fs=new FastScanner();\n		int n=fs.nextInt(), m=fs.nextInt();\n		Node[] nodes=new Node[n];\n		for (int i=0; i<n; i++) nodes[i]=new Node();\n		for (int i=0; i<m; i++) {\n			int a=fs.nextInt()-1, b=fs.nextInt()-1;\n			int c=fs.nextInt();\n			if (c==0) {\n				nodes[b].inRed.add(nodes[a]);\n			}\n			else {\n				nodes[b].inBlue.add(nodes[a]);\n			}\n		}\n		nodes[n-1].redHit=nodes[n-1].blueHit=true;\n		ArrayDeque<Node> bfs=new ArrayDeque<>();\n		nodes[n-1].dist=0;\n		bfs.add(nodes[n-1]);\n		while (!bfs.isEmpty()) {\n			Node next=bfs.removeFirst();\n			for (Node from:next.inRed) {\n				if (from.redHit) continue;\n				from.redHit=true;\n				\n				if (from.blueHit) {\n				    from.dist=next.dist+1;\n					bfs.add(from);\n					from.color=0;\n				}\n				else {\n					from.color=1;\n				}\n			}\n			\n			for (Node from:next.inBlue) {\n				if (from.blueHit) continue;\n				from.blueHit=true;\n				\n				if (from.redHit) {\n				    from.dist=next.dist+1;\n					bfs.add(from);\n					from.color=1;\n				}\n				else {\n					from.color=0;\n				}\n			}\n		}\n		PrintWriter out=new PrintWriter(System.out);\n		if (nodes[0].redHit && nodes[0].blueHit) {\n			out.println(nodes[0].dist);\n		}\n		else {\n			out.println(nodes[0].dist);\n		}\n		for (Node nn:nodes)\n			out.print(nn.color);\n		out.println();\n		out.close();\n	}\n \n	static class Node {\n		ArrayList<Node> inRed=new ArrayList<>(), inBlue=new ArrayList<>();\n		boolean redHit=false, blueHit=false;\n		int color=0;\n		int dist=-1;\n	}\n	\n	static final Random random=new Random();\n	\n	static void ruffleSort(int[] a) {\n		int n=a.length;//shuffle, then sort \n		for (int i=0; i<n; i++) {\n			int oi=random.nextInt(n), temp=a[oi];\n			a[oi]=a[i]; a[i]=temp;\n		}\n		Arrays.sort(a);\n	}\n	\n	static class FastScanner {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n		String next() {\n			while (!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		int[] readArray(int n) {\n			int[] a=new int[n];\n			for (int i=0; i<n; i++) a[i]=nextInt();\n			return a;\n		}\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n	}\n \n	\n}","constructive algorithms,dfs and similar,dp,graphs,greedy,shortest paths"
"//package round669;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Queue;\n\npublic class E {\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n	\n	void solve()\n	{\n		int n = ni(), m = ni();\n		int[] from = new int[m];\n		int[] to = new int[m];\n		int[] ws = new int[m];\n		for(int i = 0;i < m;i++) {\n			from[i] = ni()-1;\n			to[i] = ni()-1;\n			ws[i] = ni();\n		}\n		int[][][] g = packWD(n, to, from, ws);\n		int[][][] fg = packWD(n, from, to, ws);\n		int[] color = new int[n];\n		boolean[] ved = new boolean[n];\n		Arrays.fill(color, -1);\n		Queue<Integer> q = new ArrayDeque<>();\n		q.add(n-1);\n		color[n-1] = 0;\n		ved[n-1] = true;\n		while(!q.isEmpty()) {\n			int cur = q.poll();\n			for(int[] e : g[cur]) {\n				if(color[e[0]] == -1) {\n					color[e[0]] = e[1]^1;\n				}else if(color[e[0]] == e[1] && !ved[e[0]]) {\n					ved[e[0]] = true;\n					q.add(e[0]);\n				}\n			}\n		}\n		for(int i = 0;i < n;i++) {\n			if(color[i] == -1) {\n				color[i] = 0;\n			}\n		}\n		int route = bfs3(fg, color, 0, n-1);\n		out.println(route);\n		for(int v : color) {\n			out.print(v);\n		}\n		out.println();\n	}\n	\n	public static int bfs3(int[][][] g, int[] color, int s, int t)\n	{\n		int n = g.length;\n		Queue<Integer> q = new ArrayDeque<>();\n		int[] ds = new int[n];\n		Arrays.fill(ds, Integer.MAX_VALUE / 2);\n		q.add(s);\n		ds[s] = 0;\n		while(!q.isEmpty()){\n			int cur = q.poll();\n			for(int[] e : g[cur]){\n				if(ds[e[0]] > ds[cur] + 1 && color[cur] == e[1]){\n					ds[e[0]] = ds[cur] + 1;\n					q.add(e[0]);\n				}\n			}\n		}\n		return ds[t] >= Integer.MAX_VALUE / 3 ? -1 : ds[t];\n	}\n	\n	public static int[] bfs3(int[][] g, int s, int t)\n	{\n		int n = g.length;\n		Queue<Integer> q = new ArrayDeque<>();\n		int[] ds = new int[n];\n		Arrays.fill(ds, Integer.MAX_VALUE / 2);\n		q.add(s);\n		ds[s] = 0;\n		while(!q.isEmpty()){\n			int cur = q.poll();\n			for(int e : g[cur]){\n				if(ds[e] > ds[cur] + 1){\n					ds[e] = ds[cur] + 1;\n					q.add(e);\n				}\n			}\n		}\n		if(ds[t] >= Integer.MAX_VALUE / 3)return null;\n		int[] route = new int[ds[t]+1];\n		int cur = t;\n		outer:\n		while(true) {\n			route[ds[cur]] = cur;\n			if(cur == s)break;\n			for(int e : g[cur]) {\n				if(ds[e] == ds[cur] - 1) {\n					cur = e;\n					continue outer;\n				}\n			}\n			throw new RuntimeException();\n		}\n		return route;\n	}\n	\n	public static int[][][] packWD(int n, int[] from, int[] to, int[] w) {\n		int[][][] g = new int[n][][];\n		int[] p = new int[n];\n		for (int f : from)\n			p[f]++;\n		for (int i = 0; i < n; i++)\n			g[i] = new int[p[i]][2];\n		for (int i = 0; i < from.length; i++) {\n			--p[from[i]];\n			g[from[i]][p[from[i]]][0] = to[i];\n			g[from[i]][p[from[i]]][1] = w[i];\n		}\n		return g;\n	}\n\n	\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new E().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n	\n	private char[][] nm(int n, int m)\n	{\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n	\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n	\n	private int ni()\n	{\n		int num = 0, b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","constructive algorithms,dfs and similar,dp,graphs,greedy,shortest paths"
"import java.util.Scanner;\npublic class P1401A{\n	public static void main(String a[]){\n		Scanner ip = new Scanner(System.in);\n		int n,k,t=ip.nextInt();\n		while((t--)>0){\n			n=ip.nextInt();\n			k=ip.nextInt();\n			if(n>=k){\n				System.out.println((((n-k)%2==0)?0:1));\n			}\n			else{\n				System.out.println(k-n);\n			}\n		}\n	}\n}","constructive algorithms,math"
"import java.util.Scanner;\npublic class P1401A{\n	public static void main(String a[]){\n		Scanner ip = new Scanner(System.in);\n		int n,k,t=ip.nextInt();\n		while((t--)>0){\n			n=ip.nextInt();\n			k=ip.nextInt();\n			if(n>=k){\n				System.out.println((((n-k)%2==0)?0:1));\n			}\n			else{\n				System.out.println(k-n);\n			}\n		}\n	}\n}","constructive algorithms,math"
\nimport java.util.*;\npublic class CC{\n	public static void main(String[] args)\n	{\n		Scanner sc = new Scanner(System.in);\n		int t= sc.nextInt();\n		for(int i=0;i<t;i++)\n		{\n			int n=sc.nextInt();\n			int k=sc.nextInt();\n			if(k>=n)\n			{\n				System.out.println(k-n);\n			}\n			else\n			{\n				System.out.println((n-k)%2);\n			}\n			\n		}\n}\n},"constructive algorithms,math"
import java.util.Scanner;\npublic class Problem1401A {\n    public static void main(String args[]) {\n      Scanner sc = new Scanner(System.in);\n      int t = sc.nextInt();\n      while(t-->0){\n        int n = sc.nextInt();\n		int k = sc.nextInt();\n		if(n <= k) {\n			System.out.println(k-n);\n		}\n		else {\n			System.out.println((n-k)%2);\n		}\n      }\n    }\n},"constructive algorithms,math"
"import java.util.*;\nimport java.io.*;\n\npublic class F {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int[] a = new int[n + 1];\n        int[] b = new int[n + 1];\n        int[] c = new int[n + 1];\n        for(int i = 1; i <= n; i++) {\n            String[] tokens = br.readLine().split("" "");\n            a[i] = Integer.parseInt(tokens[0]);\n            b[i] = Integer.parseInt(tokens[1]);\n            c[i] = Integer.parseInt(tokens[2]);\n        }\n        Solution solution = new Solution(n, a, b, c);\n        solution.solve();\n        System.out.println(solution.getOutputString());\n    }\n}\n\nclass Solution {\n    public Solution(int n, int[] a, int[] b, int[] c) {\n        this.n = n;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n\n    public void solve() {\n        TreeMap<Integer, Integer> mpAB = new TreeMap<>();\n        for(int i = 1; i <= n; i++) {\n            mpAB.put(a[i], 0);\n            mpAB.put(b[i], 0);\n        }\n        int tmp = 0;\n        for(Map.Entry<Integer, Integer> entry : mpAB.entrySet()) {\n            tmp++;\n            entry.setValue(tmp);\n        }\n        for(int i = 1; i <= n; i++) {\n            a[i] = mpAB.get(a[i]);\n            b[i] = mpAB.get(b[i]);\n        }\n        ListInt[] lstB = new ListInt[mpAB.size() + 1];\n        for(int i = 1; i <= mpAB.size(); i++) {\n            lstB[i] = new ListInt();\n        }\n        for(int i = 1; i <= n; i++) {\n            lstB[b[i]].add(i);\n        }\n        SegmentTree segTreeF = new SegmentTree(0, mpAB.size());\n        SegmentTree segTreeG = new SegmentTree(0, mpAB.size());\n        for(int i = 1; i <= mpAB.size(); i++) {\n            for(int id : lstB[i]) {\n                if(c[id] == 1) {\n                    segTreeG.update(0, a[id] - 1, 1);\n                }\n                else {\n                    segTreeF.update(0, a[id] - 1, 1);\n                }\n            }\n            int f = segTreeG.query(0, i - 1);\n            int g = segTreeF.query(0, i - 1);\n            segTreeF.update(i, i, f);\n            segTreeG.update(i, i, g);\n        }\n        ans = Math.max(segTreeF.query(0, mpAB.size()), segTreeG.query(0, mpAB.size()));\n    }\n\n    public String getOutputString() {\n        return String.valueOf(ans);\n    }\n\n    private int n;\n    private int[] a;\n    private int[] b;\n    private int[] c;\n    private int ans;\n}\n\nclass ListInt extends ArrayList<Integer> {}\n\nclass SegmentTree {\n    public SegmentTree(int fst, int lst) {\n        this.fst = fst;\n        this.lst = lst;\n        int sz = 1;\n        while(sz <= lst - fst + 1) {\n            sz *= 2;\n        }\n        sz *= 2;\n        this.dt = new int[sz + 1];\n        this.lz = new int[sz + 1];\n    }\n\n    public void update(int l, int h, int val) {\n        recursiveUpdate(1, fst, lst, l, h, val);\n    }\n\n    public int query(int l, int h) {\n        return recursiveQuery(1, fst, lst, l, h);\n    }\n\n    private void recursiveUpdate(int x, int low, int high, int l, int h, int val) {\n        if(low > h || high < l) {\n            return;\n        }\n        if(low >= l && high <= h) {\n            dt[x] += val;\n            lz[x] += val;\n            return;\n        }\n        downLz(x);\n        int mid = (low + high) / 2;\n        recursiveUpdate(x * 2, low, mid, l, h, val);\n        recursiveUpdate(x * 2 + 1, mid + 1, high, l, h, val);\n        dt[x] = Math.max(dt[x * 2], dt[x * 2 + 1]);\n    }\n\n    private int recursiveQuery(int x, int low, int high, int l, int h) {\n        if(low > h || high < l) {\n            return 0;\n        }\n        if(low >= l && high <= h) {\n            return dt[x];\n        }\n        downLz(x);\n        int mid = (low + high) / 2;\n        return Math.max(recursiveQuery(x * 2, low, mid, l, h), recursiveQuery(x * 2 + 1, mid + 1, high, l, h));\n    }\n\n    private void downLz(int x) {\n        dt[x * 2] += lz[x];\n        lz[x * 2] += lz[x];\n        dt[x * 2 + 1] += lz[x];\n        lz[x * 2 + 1] += lz[x];\n        lz[x] = 0;\n    }\n\n    private int fst;\n    private int lst;\n    private int[] dt;\n    private int[] lz;\n}\n","data structures,dp,graph matchings,sortings"
"import java.util.*;\nimport java.io.*;\n\npublic class F {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int[] a = new int[n + 1];\n        int[] b = new int[n + 1];\n        int[] c = new int[n + 1];\n        for(int i = 1; i <= n; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            a[i] = Integer.parseInt(st.nextToken());\n            b[i] = Integer.parseInt(st.nextToken());\n            c[i] = Integer.parseInt(st.nextToken());\n        }\n        Solution solution = new Solution(n, a, b, c);\n        solution.solve();\n        System.out.println(solution.getOutputString());\n    }\n}\n\nclass Solution {\n    public Solution(int n, int[] a, int[] b, int[] c) {\n        this.n = n;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n\n    public void solve() {\n        TreeMap<Integer, Integer> mpAB = new TreeMap<>();\n        for(int i = 1; i <= n; i++) {\n            mpAB.put(a[i], 0);\n            mpAB.put(b[i], 0);\n        }\n        int tmp = 0;\n        for(Map.Entry<Integer, Integer> entry : mpAB.entrySet()) {\n            tmp++;\n            entry.setValue(tmp);\n        }\n        for(int i = 1; i <= n; i++) {\n            a[i] = mpAB.get(a[i]);\n            b[i] = mpAB.get(b[i]);\n        }\n        ListInt[] lstB = new ListInt[mpAB.size() + 1];\n        for(int i = 1; i <= mpAB.size(); i++) {\n            lstB[i] = new ListInt();\n        }\n        for(int i = 1; i <= n; i++) {\n            lstB[b[i]].add(i);\n        }\n        SegmentTree segTreeF = new SegmentTree(0, mpAB.size());\n        SegmentTree segTreeG = new SegmentTree(0, mpAB.size());\n        for(int i = 1; i <= mpAB.size(); i++) {\n            for(int id : lstB[i]) {\n                if(c[id] == 1) {\n                    segTreeG.update(0, a[id] - 1, 1);\n                }\n                else {\n                    segTreeF.update(0, a[id] - 1, 1);\n                }\n            }\n            int f = segTreeG.query(0, i - 1);\n            int g = segTreeF.query(0, i - 1);\n            segTreeF.update(i, i, f);\n            segTreeG.update(i, i, g);\n        }\n        ans = Math.max(segTreeF.query(0, mpAB.size()), segTreeG.query(0, mpAB.size()));\n    }\n\n    public String getOutputString() {\n        return String.valueOf(ans);\n    }\n\n    private int n;\n    private int[] a;\n    private int[] b;\n    private int[] c;\n    private int ans;\n}\n\nclass ListInt extends ArrayList<Integer> {}\n\nclass SegmentTree {\n    public SegmentTree(int fst, int lst) {\n        this.fst = fst;\n        this.lst = lst;\n        int sz = 1;\n        while(sz <= lst - fst + 1) {\n            sz *= 2;\n        }\n        sz *= 2;\n        this.dt = new int[sz + 1];\n        this.lz = new int[sz + 1];\n    }\n\n    public void update(int l, int h, int val) {\n        recursiveUpdate(1, fst, lst, l, h, val);\n    }\n\n    public int query(int l, int h) {\n        return recursiveQuery(1, fst, lst, l, h);\n    }\n\n    private void recursiveUpdate(int x, int low, int high, int l, int h, int val) {\n        if(low > h || high < l) {\n            return;\n        }\n        if(low >= l && high <= h) {\n            dt[x] += val;\n            lz[x] += val;\n            return;\n        }\n        downLz(x);\n        int mid = (low + high) / 2;\n        recursiveUpdate(x * 2, low, mid, l, h, val);\n        recursiveUpdate(x * 2 + 1, mid + 1, high, l, h, val);\n        dt[x] = Math.max(dt[x * 2], dt[x * 2 + 1]);\n    }\n\n    private int recursiveQuery(int x, int low, int high, int l, int h) {\n        if(low > h || high < l) {\n            return 0;\n        }\n        if(low >= l && high <= h) {\n            return dt[x];\n        }\n        downLz(x);\n        int mid = (low + high) / 2;\n        return Math.max(recursiveQuery(x * 2, low, mid, l, h), recursiveQuery(x * 2 + 1, mid + 1, high, l, h));\n    }\n\n    private void downLz(int x) {\n        dt[x * 2] += lz[x];\n        lz[x * 2] += lz[x];\n        dt[x * 2 + 1] += lz[x];\n        lz[x * 2 + 1] += lz[x];\n        lz[x] = 0;\n    }\n\n    private int fst;\n    private int lst;\n    private int[] dt;\n    private int[] lz;\n}\n","data structures,dp,graph matchings,sortings"
"import java.util.*;\nimport java.io.*;\n\npublic class F {\n    public static void main(String[] args) throws IOException {\n        byte[] buffer = new byte[8388608];\n        int len = System.in.read(buffer);\n        StringTokenizer st = new StringTokenizer(new String(buffer, 0, len));\n        int n = Integer.parseInt(st.nextToken());\n        int[] a = new int[n + 1];\n        int[] b = new int[n + 1];\n        int[] c = new int[n + 1];\n        for(int i = 1; i <= n; i++) {\n            a[i] = Integer.parseInt(st.nextToken());\n            b[i] = Integer.parseInt(st.nextToken());\n            c[i] = Integer.parseInt(st.nextToken());\n        }\n        Solution solution = new Solution(n, a, b, c);\n        solution.solve();\n        System.out.println(solution.getOutputString());\n    }\n}\n\nclass Solution {\n    public Solution(int n, int[] a, int[] b, int[] c) {\n        this.n = n;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n\n    public void solve() {\n        TreeMap<Integer, Integer> mpAB = new TreeMap<>();\n        for(int i = 1; i <= n; i++) {\n            mpAB.put(a[i], 0);\n            mpAB.put(b[i], 0);\n        }\n        int tmp = 0;\n        for(Map.Entry<Integer, Integer> entry : mpAB.entrySet()) {\n            tmp++;\n            entry.setValue(tmp);\n        }\n        for(int i = 1; i <= n; i++) {\n            a[i] = mpAB.get(a[i]);\n            b[i] = mpAB.get(b[i]);\n        }\n        ListInt[] lstB = new ListInt[mpAB.size() + 1];\n        for(int i = 1; i <= mpAB.size(); i++) {\n            lstB[i] = new ListInt();\n        }\n        for(int i = 1; i <= n; i++) {\n            lstB[b[i]].add(i);\n        }\n        SegmentTree segTreeF = new SegmentTree(0, mpAB.size());\n        SegmentTree segTreeG = new SegmentTree(0, mpAB.size());\n        for(int i = 1; i <= mpAB.size(); i++) {\n            for(int id : lstB[i]) {\n                if(c[id] == 1) {\n                    segTreeG.update(0, a[id] - 1, 1);\n                }\n                else {\n                    segTreeF.update(0, a[id] - 1, 1);\n                }\n            }\n            int f = segTreeG.query(0, i - 1);\n            int g = segTreeF.query(0, i - 1);\n            segTreeF.update(i, i, f);\n            segTreeG.update(i, i, g);\n        }\n        ans = Math.max(segTreeF.query(0, mpAB.size()), segTreeG.query(0, mpAB.size()));\n    }\n\n    public String getOutputString() {\n        return String.valueOf(ans);\n    }\n\n    private int n;\n    private int[] a;\n    private int[] b;\n    private int[] c;\n    private int ans;\n}\n\nclass ListInt extends ArrayList<Integer> {}\n\nclass SegmentTree {\n    public SegmentTree(int fst, int lst) {\n        this.fst = fst;\n        this.lst = lst;\n        int sz = 1;\n        while(sz <= lst - fst + 1) {\n            sz *= 2;\n        }\n        sz *= 2;\n        this.dt = new int[sz + 1];\n        this.lz = new int[sz + 1];\n    }\n\n    public void update(int l, int h, int val) {\n        recursiveUpdate(1, fst, lst, l, h, val);\n    }\n\n    public int query(int l, int h) {\n        return recursiveQuery(1, fst, lst, l, h);\n    }\n\n    private void recursiveUpdate(int x, int low, int high, int l, int h, int val) {\n        if(low > h || high < l) {\n            return;\n        }\n        if(low >= l && high <= h) {\n            dt[x] += val;\n            lz[x] += val;\n            return;\n        }\n        downLz(x);\n        int mid = (low + high) / 2;\n        recursiveUpdate(x * 2, low, mid, l, h, val);\n        recursiveUpdate(x * 2 + 1, mid + 1, high, l, h, val);\n        dt[x] = Math.max(dt[x * 2], dt[x * 2 + 1]);\n    }\n\n    private int recursiveQuery(int x, int low, int high, int l, int h) {\n        if(low > h || high < l) {\n            return 0;\n        }\n        if(low >= l && high <= h) {\n            return dt[x];\n        }\n        downLz(x);\n        int mid = (low + high) / 2;\n        return Math.max(recursiveQuery(x * 2, low, mid, l, h), recursiveQuery(x * 2 + 1, mid + 1, high, l, h));\n    }\n\n    private void downLz(int x) {\n        dt[x * 2] += lz[x];\n        lz[x * 2] += lz[x];\n        dt[x * 2 + 1] += lz[x];\n        lz[x * 2 + 1] += lz[x];\n        lz[x] = 0;\n    }\n\n    private int fst;\n    private int lst;\n    private int[] dt;\n    private int[] lz;\n}\n","data structures,dp,graph matchings,sortings"
"import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class F {\n    static final boolean RUN_TIMING = false;\n    static char[] inputBuffer = new char[1 << 20];\n    static PushbackReader in = new PushbackReader(new BufferedReader(new InputStreamReader(System.in)), 1 << 20);\n    static PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n    public void go() throws IOException {\n        // in = new PushbackReader(new BufferedReader(new FileReader(new File(""test.txt""))), 1 << 20);\n        // out = new PrintWriter(new FileWriter(new File(""output.txt"")));\n        int n = ipar();\n        PriorityQueue<int[]> front = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n        PriorityQueue<int[]> back1 = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        PriorityQueue<int[]> back2 = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        for (int i = 0; i < n; i++) {\n            int[] interval = {ipar(), ipar(), ipar()};\n            front.add(interval);\n        }\n        front.add(new int[]{2000000000, 2000000000, 1});\n        int match = 0;\n        while (!front.isEmpty()) {\n            int[] curr = front.remove();\n            while (!back1.isEmpty() && back1.peek()[1] < curr[0]) {\n                int[] end = back1.remove();\n                if (!back2.isEmpty()) {\n                    match++;\n                    back2.remove();\n                }\n            }\n            while (!back2.isEmpty() && back2.peek()[1] < curr[0]) {\n                int[] end = back2.remove();\n                if (!back1.isEmpty()) {\n                    match++;\n                    back1.remove();\n                }\n            }\n            if (curr[2] == 1) {\n                back1.add(curr);\n            } else {\n                back2.add(curr);\n            }\n            // out.print(""Front:"");\n            // for (int[] a : front) {\n            //     out.print("" "");\n            //     out.print(Arrays.toString(a));\n            // }\n            // out.println();\n            // out.print(""Back 1:"");\n            // for (int[] a : back1) {\n            //     out.print("" "");\n            //     out.print(Arrays.toString(a));\n            // }\n            // out.println();\n            // out.print(""Back 2:"");\n            // for (int[] a : back2) {\n            //     out.print("" "");\n            //     out.print(Arrays.toString(a));\n            // }\n            // out.println();\n            // out.println();\n        }\n        out.println(n - match);\n    }\n\n    public int ipar() throws IOException {\n        return Integer.parseInt(spar());\n    }\n\n    public int[] iapar(int n) throws IOException {\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = ipar();\n        }\n        return arr;\n    }\n\n    public long lpar() throws IOException {\n        return Long.parseLong(spar());\n    }\n\n    public long[] lapar(int n) throws IOException {\n        long[] arr = new long[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = lpar();\n        }\n        return arr;\n    }\n\n    public double dpar() throws IOException {\n        return Double.parseDouble(spar());\n    }\n\n    public String spar() throws IOException {\n        int len = 0;\n        int c;\n        do {\n            c = in.read();\n        } while (Character.isWhitespace(c) && c != -1);\n        if (c == -1) {\n            throw new NoSuchElementException(""Reached EOF"");\n        }\n        do {\n            inputBuffer[len] = (char)c;\n            len++;\n            c = in.read();\n        } while (!Character.isWhitespace(c) && c != -1);\n        while (c != '\n' && Character.isWhitespace(c) && c != -1) {\n            c = in.read();\n        }\n        if (c != -1 && c != '\n') {\n            in.unread(c);\n        }\n        return new String(inputBuffer, 0, len);\n    }\n\n    public String linepar() throws IOException {\n        int len = 0;\n        int c;\n        while ((c = in.read()) != '\n' && c != -1) {\n            if (c == '\r') {\n                continue;\n            }\n            inputBuffer[len] = (char)c;\n            len++;\n        }\n        return new String(inputBuffer, 0, len);\n    }\n\n    public boolean haspar() throws IOException {\n        String line = linepar();\n        if (line.isEmpty()) {\n            return false;\n        }\n        in.unread('\n');\n        in.unread(line.toCharArray());\n        return true;\n    }\n\n    public static void main(String[] args) throws IOException {\n        long time = 0;\n        time -= System.nanoTime();\n        new F().go();\n        time += System.nanoTime();\n        if (RUN_TIMING) {\n            System.out.printf(""%.3f ms%n"", time / 1000000.0);\n        }\n        out.flush();\n        in.close();\n    }\n}\n","data structures,dp,graph matchings,sortings"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1385F extends PrintWriter {\n	CF1385F() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1385F o = new CF1385F(); o.main(); o.flush();\n	}\n\n	int[] aa, kk, ll;\n	int k, ans;\n	void dfs(int i) {\n		ans += ll[i] / k;\n		ll[i] %= k;\n		if (ll[i] == 0 && kk[i] == 1) {\n			int j = aa[i];\n			aa[j] ^= i; kk[j]--; ll[j]++;\n			if (ll[j] >= k)\n				dfs(j);\n		}\n	}\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			k = sc.nextInt();\n			aa = new int[n];\n			kk = new int[n];\n			ll = new int[n];\n			for (int h = 0; h < n - 1; h++) {\n				int i = sc.nextInt() - 1;\n				int j = sc.nextInt() - 1;\n				aa[i] ^= j; kk[i]++;\n				aa[j] ^= i; kk[j]++;\n			}\n			if (k == 1) {\n				println(n - 1);\n				continue;\n			}\n			for (int i = 0; i < n; i++)\n				if (kk[i] == 1) {\n					int j = aa[i];\n					aa[j] ^= i; ll[j]++;\n				}\n			for (int i = 0; i < n; i++)\n				kk[i] -= ll[i];\n			ans = 0;\n			for (int i = 0; i < n; i++)\n				if (ll[i] >= k)\n					dfs(i);\n			println(ans);\n		}\n	}\n}\n","data structures,greedy,implementation,trees"
"//package com.company;\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner S = new Scanner(System.in);\n        int test = S.nextInt();\n        while(test-- > 0) {\n            int n, k;\n            n = S.nextInt();\n            k = S.nextInt();\n            ArrayList<ArrayList<Integer>> v = new ArrayList<ArrayList<Integer>>();\n            for (int i = 0; i <= n; ++i)\n                v.add(new ArrayList<Integer>());\n            for (int i = 1; i < n; ++i){\n                int a, b;\n                a = S.nextInt();\n                b = S.nextInt();\n                v.get(a).add(b);\n                v.get(b).add(a);\n            }\n            if (k == 1){\n                System.out.println(n-1);\n                continue;\n            }\n            int[] g = new int[n+1];\n            int[] g2 = new int[n+1];\n            boolean[] ok = new boolean[n+1];\n            int cnt = 0;\n            Arrays.fill(ok, false);\n            Queue<Integer> q = new LinkedList<Integer>();\n            for (int i = 1; i <= n; ++i){\n                g[i] = v.get(i).size();\n                if ((g[i]-1)%k == 0)\n                    ok[i] = true;\n                if (g[i] == 1)\n                    q.add(i);\n            }\n            while (q.size() > 0){\n                int node = q.remove();\n                for (Integer x : v.get(node)){\n                    --g[x];\n                    ++g2[x];\n                    if (g2[x]%k == 0)\n                        ++cnt;\n                    if (g[x] == 1 && ok[x])\n                        q.add(x);\n                }\n            }\n            System.out.println(cnt);\n        }\n    }\n}\n","data structures,greedy,implementation,trees"
"import java.util.*;\nimport java.io.*;\n\npublic class Leaves {\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n		int t = Integer.parseInt(br.readLine());\n\n		while (--t >= 0) {\n			String[] line = br.readLine().split("" "");\n			int n = Integer.parseInt(line[0]), k = Integer.parseInt(line[1]);\n			int[] from = new int[n-1], to = new int[n-1];\n			int[] sizes = new int[n];\n			for (int i = 0; i < n - 1; ++i) {\n				line = br.readLine().split("" "");\n				from[i] = Integer.parseInt(line[0]) - 1;\n				to[i] = Integer.parseInt(line[1]) - 1;\n				++sizes[from[i]];\n				++sizes[to[i]];\n			}\n\n			int res = n - 1;\n\n			if (k > 1) {\n				int[][] tree = new int[n][];\n				for (int i = 0; i < n; ++i) {\n					tree[i] = new int[sizes[i]];\n				}\n				for (int i = 0; i < n - 1; ++i) {\n					tree[from[i]][--sizes[from[i]]] = to[i];\n					tree[to[i]][--sizes[to[i]]] = from[i];\n				}\n\n				int[] neighbors = new int[n];\n				int[] leaves = new int[n];\n				Deque<Integer> queue = new ArrayDeque<>();\n\n				for (int i = 0; i < n; ++i) {\n					for (int neighbor: tree[i]) {\n						if (tree[neighbor].length == 1) {\n							++leaves[i];\n						}\n					}\n					if (leaves[i] >= k) {\n						queue.push(i);\n					}\n					neighbors[i] = tree[i].length;\n				}\n\n				res = 0;\n\n				while (!queue.isEmpty()) {\n					int i = queue.pop();\n					int operations = leaves[i] / k;\n					int removed = operations * k;\n					neighbors[i] -= removed;\n					leaves[i] -= removed;\n					res += operations;\n					if (leaves[i] == 0 && neighbors[i] == 1) {\n						for (int neighbor: tree[i]) {\n							++leaves[neighbor];\n							if (leaves[neighbor] == k) {\n								queue.push(neighbor);\n							}\n						}\n					}\n				}\n			}\n\n			bw.write(Integer.toString(res));\n			bw.newLine();\n		}\n\n		br.close();\n		bw.close();\n	}\n}","data structures,greedy,implementation,trees"
"import java.util.*;\nimport java.io.*;\n\npublic class Leaves {\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n		int t = Integer.parseInt(br.readLine());\n\n		while (--t >= 0) {\n			String[] line = br.readLine().split("" "");\n			int n = Integer.parseInt(line[0]), k = Integer.parseInt(line[1]);\n			int[] from = new int[n-1], to = new int[n-1];\n			int[] sizes = new int[n];\n			for (int i = 0; i < n - 1; ++i) {\n				line = br.readLine().split("" "");\n				from[i] = Integer.parseInt(line[0]) - 1;\n				to[i] = Integer.parseInt(line[1]) - 1;\n				++sizes[from[i]];\n				++sizes[to[i]];\n			}\n\n			int res = n - 1;\n\n			if (k > 1) {\n				int[][] tree = new int[n][];\n				for (int i = 0; i < n; ++i) {\n					tree[i] = new int[sizes[i]];\n				}\n				for (int i = 0; i < n - 1; ++i) {\n					tree[from[i]][--sizes[from[i]]] = to[i];\n					tree[to[i]][--sizes[to[i]]] = from[i];\n				}\n\n				int[] neighbors = new int[n];\n				int[] leaves = new int[n];\n				Deque<Integer> queue = new ArrayDeque<>();\n\n				for (int i = 0; i < n; ++i) {\n					for (int neighbor: tree[i]) {\n						if (tree[neighbor].length == 1) {\n							++leaves[i];\n						}\n					}\n					if (leaves[i] >= k) {\n						queue.add(i);\n					}\n					neighbors[i] = tree[i].length;\n				}\n\n				res = 0;\n\n				while (!queue.isEmpty()) {\n					int i = queue.remove();\n					int operations = leaves[i] / k;\n					int removed = operations * k;\n					neighbors[i] -= removed;\n					leaves[i] -= removed;\n					res += operations;\n					if (leaves[i] == 0 && neighbors[i] == 1) {\n						for (int neighbor: tree[i]) {\n							++leaves[neighbor];\n							if (leaves[neighbor] == k) {\n								queue.add(neighbor);\n							}\n						}\n					}\n				}\n			}\n\n			bw.write(Integer.toString(res));\n			bw.newLine();\n		}\n\n		br.close();\n		bw.close();\n	}\n}","data structures,greedy,implementation,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1384B2 extends PrintWriter {\n	CF1384B2() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1384B2 o = new CF1384B2(); o.main(); o.flush();\n	}\n\n	static final int INF = 0x3f3f3f3f;\n	void main() {\n		int t = sc.nextInt();\nout:\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int k = sc.nextInt();\n			int m = sc.nextInt();\n			int[] dd = new int[n];\n			for (int i = 0; i < n; i++)\n				dd[i] = sc.nextInt();\n			int[] ll = new int[n];\n			int[] rr = new int[n];\n			for (int i = 0; i < n; i++) {\n				if (dd[i] > m) {\n					println(""No"");\n					continue out;\n				}\n				if (dd[i] + k <= m)\n					ll[i] = rr[i] = INF;\n				else {\n					rr[i] = m - dd[i];\n					ll[i] = -rr[i];\n				}\n			}\n			for (int i = 1; i < n; i++) {\n				if (ll[i - 1] == INF || ll[i] == INF)\n					continue;\n				ll[i] = Math.max(ll[i - 1] + 1, ll[i]);\n				rr[i] = Math.min(rr[i - 1] + 1, rr[i]);\n				if (ll[i] > rr[i]) {\n					println(""No"");\n					continue out;\n				}\n			}\n			println(""Yes"");\n		}\n	}\n}\n","brute force,dp,greedy"
"import java.util.*;\nimport java.io.*;\n\npublic class QuestionB1 {\n\n	static Scanner sc = new Scanner(System.in);\n	public static void main(String[] args) {\n		int t = sc.nextInt();\n		while(t-->0) {\n			solve();\n		}\n	}\n	\n	public static void solve() {\n		int n = sc.nextInt();\n		int k = sc.nextInt();\n		int l = sc.nextInt();\n		\n		boolean flag = false;\n		\n		int[] depth = new int[n];\n		for(int i = 0;i < n;i++) {\n			int temp = sc.nextInt();\n			depth[i] = temp + k;\n			if(temp > l)flag = true;\n		}\n		\n		if(flag) {\n			System.out.println(""NO"");\n			return;\n		}\n		\n		int min = 0;\n		int max = 2*k;\n		\n		for(int i = 0;i < n;i++) {\n			\n			if(depth[i] <= l) {\n				min = 0;\n				max = 2*k;\n				\n			}\n			else {\n				\n				int tmin = depth[i] - l;\n				min = Math.max(tmin, min);\n				\n				int tmax = tmin + (k - tmin) * 2;\n				max = Math.min(tmax,max);\n				\n			}\n\n			if(max < min) {\n				flag = true; \n				break;\n			}\n			min++;\n			max++;\n		}\n		\n		if(flag) {\n			System.out.println(""NO"");\n			\n		}\n		else System.out.println(""YES"");\n		\n	}\n}\n","brute force,dp,greedy"
"import java.util.*;\nimport java.math.*;\npublic class Main{\n    public static void main(String []args){\n        Scanner sc = new Scanner(System.in);\n        int c = sc.nextInt();\n        while(c-- > 0){\n            int n = sc.nextInt();\n            int k = sc.nextInt();\n            int l = sc.nextInt();\n            int depth[] = new int[n];\n            boolean flag = true;\n            for(int i = 0 ; i < n ; i++){\n                depth[i] = sc.nextInt();\n                if(depth[i] > l)\n                    flag = false;\n            }\n            int prev = 0;\n            int mini = 0;\n            int maxi = 2*k;\n            if(flag)\n            for(int i = 0 ; i < n ; i++){\n                maxi = Math.min(k + (l - depth[i]),2*k);\n                if(maxi == 2*k){\n                    mini = 0;\n                }else{\n                    mini = Math.max(mini+1,k - (l - depth[i]));\n                }\n                if(mini > maxi){\n                    flag = false;\n                    break;\n                }\n                //System.out.println(mini+"" ""+maxi);\n            }\n            System.out.println(flag?""Yes"":""No"");\n        }\n    }\n}","brute force,dp,greedy"
"import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        while (t -- > 0) {\n            int n = sc.nextInt();\n            int k = sc.nextInt();\n            int l = sc.nextInt();\n            int[] a = new int[n+1];\n            ArrayList<Integer> safe = new ArrayList<>();\n            safe.add(0);\n            for (int i = 1; i <= n; i++) {\n                a[i] = sc.nextInt();\n                if (a[i] + k <= l) safe.add(i);\n            }\n            safe.add(n + 1);\n            boolean drown = false;\n            for (int i = 1; i < safe.size() && !drown; ++i)\n            {\n                int tide = k; boolean down = true;\n                for (int j = safe.get(i-1) + 1; j < safe.get(i); j++)\n                {\n                    tide += down ? -1 : +1;\n                    if (down) tide -= Math.max(0, a[j] + tide - l);\n                    if (tide < 0 || a[j] + tide > l) { drown = true; break; }\n                    if (tide == 0) down = false;\n                }\n            }\n\n\n            if (drown) System.out.println(""No"");\n            else System.out.println(""Yes"");\n        }\n    }\n\n}\n","brute force,dp,greedy"
"import java.util.*;\n\npublic class Main{\n	// public static \n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0){\n			int n=sc.nextInt();\n			String a=sc.next();\n			String b=sc.next();\n			ArrayList<Integer> list= new ArrayList<>();\n			boolean flip=false;\n			int ind=0;\n			for(int i=n-1;i>=0;i--){\n				if(flip ^ a.charAt(ind)==b.charAt(i)){\n					list.add(1);\n				}\n				list.add(i+1);\n				if(flip)ind-=i;\n				else ind+=i;\n				flip=!flip;\n			}\n			\n			System.out.print(list.size()+"" "");\n			\n			for(Integer k:list)\n			System.out.print(k+"" "");\n			System.out.println();\n		}\n	}\n}\n\n\n","constructive algorithms,data structures,implementation,strings,two pointers"
"import java.util.*;\n\npublic class Main{\n	// public static \n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0){\n			int n=sc.nextInt();\n			String a=sc.next();\n			String b=sc.next();\n			ArrayList<Integer> list= new ArrayList<>();\n			boolean flip=false;\n			int ind=0;\n			for(int i=n-1;i>=0;i--){\n				if(flip ^ a.charAt(ind)==b.charAt(i)){\n					list.add(1);\n				}\n				list.add(i+1);\n				if(flip)ind-=i;\n				else ind+=i;\n				flip=!flip;\n			}\n			\n			System.out.print(list.size()+"" "");\n			\n			for(Integer k:list)\n			System.out.print(k+"" "");\n			System.out.println();\n		}\n	}\n}\n\n\n","constructive algorithms,data structures,implementation,strings,two pointers"
"\nimport java.util.*;\n\npublic class codeforces {\n	static int count[];\n\n	public static void main(String[] args) {\n		Scanner scn = new Scanner(System.in);\n		int t = scn.nextInt();\n		StringBuilder sb = new StringBuilder();\n		while (t-- > 0) {\n			int n=scn.nextInt();\n			int ans=0;\n			StringBuilder tt=new StringBuilder();\n			char []a=scn.next().toCharArray();\n			char []b=scn.next().toCharArray();\n			int pos1=0;\n			int pos2=n-1;\n			int rev=0;\n			for(int i=n-1;i>=0;i--){\n				if(rev==0){\n					if(a[pos1]==b[i]){\n						ans++;\n						tt.append(1+"" "");\n					}\n					ans++;\n					tt.append((i+1)+"" "");\n					rev=1;\n					pos1++;\n				}\n				else{\n					if(a[pos2]!=b[i]){\n						ans++;\n						tt.append(1+"" "");\n					}\n					ans++;\n					tt.append((i+1)+"" "");\n					rev=0;\n					pos2--;	\n				}\n			}\n			sb.append(ans+"" ""+tt+""\n"");\n			\n		}\n		System.out.println(sb);\n	}\n\n}\n","constructive algorithms,data structures,implementation,strings,two pointers"
"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int _t = s.nextInt();\n        for (int t = 0; t < _t; t++) {\n            int n = s.nextInt();\n            String a = s.next() + ""0"", b = s.next() + ""0"";\n            ArrayList<Integer> aRes = new ArrayList<>();\n            ArrayList<Integer> bRes = new ArrayList<>();\n            for (int i = 1; i < n + 1; i++) {\n                if (a.charAt(i) != a.charAt(i - 1)) {\n                    aRes.add(i);\n                }\n                if (b.charAt(i) != b.charAt(i - 1)) {\n                    bRes.add(i);\n                }\n            }\n            Collections.reverse(bRes);\n            aRes.addAll(bRes);\n            System.out.print(aRes.size() + "" "");\n            for (Integer aRe : aRes)\n                System.out.print(aRe + "" "");\n            System.out.println();\n        }\n    }\n}","constructive algorithms,data structures,implementation,strings,two pointers"
import java.util.Scanner;\n\npublic class multiply_by_2_1374B{\n\n	public static void main(String[] args){\n		Scanner in = new Scanner(System.in);\n		int t = in.nextInt();\n\n		while(t > 0){\n			int n = in.nextInt();\n			int cnt;\n\n			for(cnt=0; n%3==0; cnt++){\n				n = (n%2 == 0) ? n/6 : n*2;\n			}\n			System.out.println(n==1 ? cnt : -1);\n\n			t--;\n		}\n	}\n},math
"import java.util.*;\npublic class cf653divB {\npublic static void main(String[] args) {\nScanner sc=new Scanner(System.in);\nint t=sc.nextInt();\nfor(int j=1;j<=t;j++)    \n{int n=sc.nextInt();\nint p2=0,p3=0;\nwhile(n%2==0)\n{n=n/2;p2++;}\nwhile(n%3==0)\n{n=n/3;p3++;}\nif(n>1 || p2>p3)\nSystem.out.println(-1);\nelse\nSystem.out.println(p3-p2+p3);}\nsc.close();}}",math
"import java.util.*;\npublic class cf653divB {\npublic static void main(String[] args) {\nScanner sc=new Scanner(System.in);\nint t=sc.nextInt();\nfor(int j=1;j<=t;j++)    \n{int n=sc.nextInt();\nint p2=0,p3=0;\nwhile(n%2==0)\n{n=n/2;p2++;}\nwhile(n%3==0)\n{n=n/3;p3++;}\nif(n>1 || p2>p3)\nSystem.out.println(-1);\nelse\nSystem.out.println(p3-p2+p3);}\nsc.close();}}",math
import java.util.Scanner;\n\npublic class multiply_by_2_1374B{\n\n	public static void main(String[] args){\n		Scanner in = new Scanner(System.in);\n		int t = in.nextInt();\n\n		while(t > 0){\n			int n = in.nextInt();\n			int cnt;\n\n			for(cnt=0; n%3==0; cnt++){\n				n = (n%2 == 0) ? n/6 : n*2;\n			}\n			System.out.println(n==1 ? cnt : -1);\n\n			t--;\n		}\n	}\n},math
"// upsolve with kaiboy, coached by rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1371E2 extends PrintWriter {\n	CF1371E2() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1371E2 o = new CF1371E2(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int md = sc.nextInt();\n		int[] aa = new int[n];\n		int a_ = 0;\n		for (int i = 0; i < n; i++)\n			a_ = Math.max(a_, aa[i] = sc.nextInt());\n		int[] kk = new int[n];\n		for (int i = 0; i < n; i++) {\n			int d = a_ - aa[i];\n			if (d < n)\n				kk[d]++;\n		}\n		boolean[] bad = new boolean[n];\n		int n_max = n, n_min = n, n_ = n;\n		for (int d_ = 1; d_ < n; d_++) {\n			n_ -= kk[d_ - 1];\n			n_max = Math.max(n_max - 1, n_);\n			n_min = Math.min(n_min - 1, n_);\n			if (n_min <= 0 || n_max >= md)\n				bad[d_] = true;\n		}\n		int cnt = 0;\n		for (int d_ = 1; d_ < n; d_++)\n			if (!bad[d_])\n				cnt++;\n		println(cnt);\n		for (int d_ = n - 1; d_ >= 1; d_--)\n			if (!bad[d_])\n				print(a_ - d_ + "" "");\n		println();\n	}\n}\n","binary search,combinatorics,dp,math,number theory,sortings"
"import java.io.*;\nimport java.util.*;\n \npublic class Main {\n  public static void main(String[] args) throws IOException {\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n \n    StringTokenizer st = new StringTokenizer(in.readLine());\n    int n = Integer.parseInt(st.nextToken());\n    int p = Integer.parseInt(st.nextToken());\n    int[] a = new int[n];\n \n    st = new StringTokenizer(in.readLine());\n    for (int i = 0; i < n; ++i) {\n      a[i] = Integer.parseInt(st.nextToken());\n    }\n \n    int[] result = solve(n, p, a);\n    System.out.println(Math.max(0, result[1] - result[0]));\n    for (int i = result[0]; i < result[1]; ++i) {\n      System.out.print(i + "" "");\n    }\n    System.out.println();\n \n    in.close();\n  }\n \n  private static int[] solve(int n, int p, int[] a) {\n    Arrays.sort(a);\n    return new int[] { getMin(n, p, a), getMax(n, p, a) };\n  }\n \n  private static int getMin(int n, int p, int[] a) {\n    int result = a[0];\n \n    for (int i = 0; i < n; ++i) {\n      result = Math.max(result, a[i] - i);\n    }\n \n    return result;\n  }\n \n  private static int getMax(int n, int p, int[] a) {\n    int max = Integer.MAX_VALUE;\n\n    for (int i = 0; p + i - 1 < n; ++i) {\n      int value = a[p + i - 1];\n      int index = binarySearch(a, value + 1);\n \n      if (index - 1 == p + i - 1) {\n        max = Math.min(max, value - i);\n      }\n    }\n \n    return max;\n  }\n \n  private static int binarySearch(int[] a, int value) {\n    int start = 0, end = a.length;\n \n    while (start < end) {\n      int mid = (start + end) / 2;\n \n      if (a[mid] >= value) {\n        end = mid;\n      } else {\n        start = mid + 1;\n      }\n    }\n \n    return start;\n  }\n}","binary search,combinatorics,dp,math,number theory,sortings"
"import java.io.*;\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\npublic class template {\n	public static void main(String[] args) throws Exception {\n		new template().run();\n	}\n	public void run() throws Exception {\n		FastScanner f = new FastScanner();\n		PrintWriter out = new PrintWriter(System.out);\n		///\n		int n = f.nextInt(), p = f.nextInt();\n		Integer[] arr = new Integer[n];\n		for(int i = 0; i < n; i++) arr[i] = f.nextInt();\n		Arrays.sort(arr);\n		int l = 0, max = 1000000001;\n		while(l < max) {\n			int m = (l+max)/2;\n			boolean ok = true;\n			int i = 0;\n			int c = 0;\n			int cur = m;\n			while(i < n) {\n				if(arr[i] <= cur) {\n					i++;\n					c++;\n				} else {\n					c -= arr[i]-cur;\n					cur = arr[i];\n					c++;\n					i++;\n				}\n				if(c <= 0) {\n					ok = true;\n					break;\n				}\n				ok &= c < p;\n			}\n			if(!ok) max = m;\n			else l = m+1;\n		}\n		l = 0; int min = 1000000001;\n		while(l < min) {\n			int m = (l+min)/2;\n			boolean ok = true;\n			int i = 0;\n			int c = 0;\n			int cur = m;\n			while(i < n) {\n				if(arr[i] <= cur) {\n					i++;\n					c++;\n				} else {\n					c -= arr[i]-cur;\n					cur = arr[i];\n					c++;\n					i++;\n				}\n				if(c <= 0) {\n					ok = false;\n					break;\n				}\n			}\n			if(ok) min = m;\n			else l = m+1;\n		}\n		out.println(Math.max(max-min, 0));\n		for(int i = min; i < max; i++)\n			out.print(i + "" "");\n		out.println();\n///\n		out.flush();\n	}\n///\n	static class FastScanner {\n		public BufferedReader reader;\n		public StringTokenizer tokenizer;\n		public FastScanner() {\n			reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n			tokenizer = null;\n		}\n		public String next() {\n			while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n				try {\n					tokenizer = new StringTokenizer(reader.readLine());\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n			return tokenizer.nextToken();\n		}\n		public int nextInt() {\n			return Integer.parseInt(next());\n		}\n		public long nextLong() {\n			return Long.parseLong(next());\n		}\n		public double nextDouble() {\n			return Double.parseDouble(next());\n		}\n		public String nextLine() {\n			try {\n				return reader.readLine();\n			} catch(IOException e) {\n				throw new RuntimeException(e);\n			}\n		}\n	}\n}\n","binary search,combinatorics,dp,math,number theory,sortings"
"\nimport java.io.*;\nimport java.util.*;\n\n\npublic class ProbE {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(in, out);\n        out.close();\n    }\n    // main solver\n    static class Task{\n        int cnt[] = new int[2001];\n        public void solve(InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int p = in.nextInt();\n            int a[] = new int[n];\n            int max = 0;\n            for (int i = 0; i < n; i++){\n                a[i] = in.nextInt();\n            }\n            Arrays.sort(a);\n            int start = 0, end = 1000000000;\n            for (int i=  n - 1; i >= 0; i--){\n                if (i + 1 >= p){\n                    end = Math.min(end, a[i] - i + p - 2);\n                }\n                start = Math.max(start, a[i] - i);\n            }\n            out.println(Math.max(0, end - start + 1));\n            for (int i = start; i <= end; i++){\n                out.print(i + "" "");\n            }\n        }\n    }\n    // fast input reader class;\n    static class InputReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public InputReader(InputStream stream) {\n            br = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                String line = null;\n                try {\n                    line = br.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (line == null) {\n                    return null;\n                }\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        public long nextLong(){\n            return Long.parseLong(nextToken());\n        }\n    }\n}","binary search,combinatorics,dp,math,number theory,sortings"
"import java.io.*;\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\npublic class template {\n	public static void main(String[] args) throws Exception {\n		new template().run();\n	}\n	public void run() throws Exception {\n		FastScanner f = new FastScanner();\n		PrintWriter out = new PrintWriter(System.out);\n		///\n		int asdf = f.nextInt();\n		while(asdf-->0) {\n			int n = f.nextInt();\n			adj = new ArrayList[n];\n			q = new ArrayList[n];\n			out.print(""? ""+n);\n			for(int i = 0; i < n; i++) {\n				adj[i] = new ArrayList<>();\n				out.print("" "" + (i+1));\n				q[i] = new ArrayList<>();\n			}\n			for(int i = 0; i < n-1; i++) {\n				int a = f.nextInt()-1, b = f.nextInt()-1;\n				adj[a].add(b); adj[b].add(a);\n			}\n			out.println();\n			out.flush();\n			int r = f.nextInt()-1, min = f.nextInt();\n			dists = new int[n];\n			dfs(r, -1, 0);\n			int lo = (min+1)/2, hi = min;\n			int ans = 0, ind = -1;\n			while(lo <= hi) {\n				int m = (lo+hi)/2;\n				if(q[m].size() == 0) {\n					hi = m-1;\n					continue;\n				}\n				out.print(""? "" + q[m].size());\n				for(int i : q[m]) out.print("" "" + (i+1));\n				out.println();\n				out.flush();\n				int a = f.nextInt();\n				if(f.nextInt() > min) hi = m-1;\n				else {\n					lo = m+1;\n					if(m > ind) {\n						ind = m;\n						ans = a-1;\n					}\n				}\n			}\n			for(ArrayList<Integer> a : q) a.clear();\n			dfs(ans, -1, 0);\n			out.print(""? "" + q[min].size());\n			for(int i : q[min]) out.print("" "" + (i+1));\n			out.println();\n			out.flush();\n			int b = f.nextInt();\n			f.next();\n			out.println(""! ""+ (ans+1) + "" "" + b);\n			out.flush();\n			if(!f.next().equals(""Correct"")) break;\n		}\n///\n		out.flush();\n	}\n	ArrayList<Integer>[] adj;\n	ArrayList<Integer>[] q;\n	int[] dists;\n	public void dfs(int i, int p, int v) {\n		dists[i] = v;\n		for(int j : adj[i]) if(j != p) dfs(j, i, v+1);\n		q[v].add(i);\n	}\n///\n	static class FastScanner {\n		public BufferedReader reader;\n		public StringTokenizer tokenizer;\n		public FastScanner() {\n			reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n			tokenizer = null;\n		}\n		public String next() {\n			while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n				try {\n					tokenizer = new StringTokenizer(reader.readLine());\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n			return tokenizer.nextToken();\n		}\n		public int nextInt() {\n			return Integer.parseInt(next());\n		}\n		public long nextLong() {\n			return Long.parseLong(next());\n		}\n		public double nextDouble() {\n			return Double.parseDouble(next());\n		}\n		public String nextLine() {\n			try {\n				return reader.readLine();\n			} catch(IOException e) {\n				throw new RuntimeException(e);\n			}\n		}\n	}\n}","binary search,dfs and similar,graphs,interactive,shortest paths,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class E {\n\n	static ArrayList<Integer>[] adj;\n\n	static int[] ask(ArrayList<Integer> query) throws IOException {\n		StringBuilder sb = new StringBuilder(""?"");\n		sb.append("" "" + query.size());\n		for (int x : query)\n			sb.append("" "" + x);\n		System.out.println(sb);\n		return new int[] { sc.nextInt(), sc.nextInt() };\n	}\n\n	static Scanner sc = new Scanner();\n\n	public static void main(String[] args) throws IOException {\n		int tc = sc.nextInt();\n		while (tc-- > 0) {\n			int n = sc.nextInt();\n			adj = new ArrayList[n + 1];\n			int[] queryAns;\n			ArrayList<Integer> query = new ArrayList<Integer>();\n			for (int i = 1; i <= n; i++) {\n				adj[i] = new ArrayList();\n				query.add(i);\n			}\n			for (int i = 1; i < n; i++) {\n				int u = sc.nextInt(), v = sc.nextInt();\n				adj[u].add(v);\n				adj[v].add(u);\n\n			}\n			queryAns = ask(query);\n			int root = queryAns[0], minDist = queryAns[1];\n			int lo = minDist + 1 >> 1, hi = minDist;\n			int[] ans = new int[2];\n			while (lo <= hi) {\n				int mid = lo + hi >> 1;\n				ArrayList<Integer> tmp = getNodes(root, mid);\n				if (tmp.size() == 0) {\n					hi = mid - 1;\n					continue;\n				}\n				queryAns = ask(getNodes(root, mid));\n				if (queryAns[1] == minDist) {\n					ans[0] = queryAns[0];\n					lo = mid + 1;\n				} else\n					hi = mid - 1;\n			}\n			ans[1] = ask(getNodes(ans[0], minDist))[0];\n			System.out.printf(""! %d %d\n"", ans[0], ans[1]);\n			sc.nextLine();\n		}\n	}\n\n	static ArrayList<Integer> ans;\n\n	private static ArrayList<Integer> getNodes(int root, int d) {\n		ans = new ArrayList<Integer>();\n		get(root, root, d);\n		return ans;\n	}\n\n	static void get(int u, int p, int d) {\n		if (d == 0)\n			ans.add(u);\n		else {\n			for (int v : adj[u])\n				if (v != p)\n					get(v, u, d - 1);\n		}\n	}\n\n	static class Scanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		Scanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		Scanner(String fileName) throws FileNotFoundException {\n			br = new BufferedReader(new FileReader(fileName));\n		}\n\n		String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() throws NumberFormatException, IOException {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() throws NumberFormatException, IOException {\n			return Double.parseDouble(next());\n		}\n\n		boolean ready() throws IOException {\n			return br.ready();\n		}\n\n		int[] nxtArr(int n) throws IOException {\n			int[] ans = new int[n];\n			for (int i = 0; i < n; i++)\n				ans[i] = nextInt();\n			return ans;\n		}\n\n	}\n\n	static void sort(int[] a) {\n		shuffle(a);\n		Arrays.sort(a);\n	}\n\n	static void shuffle(int[] a) {\n		int n = a.length;\n		Random rand = new Random();\n		for (int i = 0; i < n; i++) {\n			int tmpIdx = rand.nextInt(n);\n			int tmp = a[i];\n			a[i] = a[tmpIdx];\n			a[tmpIdx] = tmp;\n		}\n	}\n\n}","binary search,dfs and similar,graphs,interactive,shortest paths,trees"
"import java.util.*;\nimport java.io.*;\n\n@SuppressWarnings(""unchecked"")\npublic class hiddenpair {\n    static BufferedReader in;\n    int N, maxDepth, root, minDist;\n    int[] depth;\n    ArrayList<Integer>[] adj;\n\n    hiddenpair() throws IOException {\n        StringTokenizer st = new StringTokenizer(in.readLine());\n        N = Integer.parseInt(st.nextToken());\n        adj = new ArrayList[N];\n        for (int i = 0; i < N; i++) adj[i] = new ArrayList<>(2);\n        for (int i = 1; i < N; i++) {\n            st = new StringTokenizer(in.readLine());\n            int a = Integer.parseInt(st.nextToken()) - 1;\n            int b = Integer.parseInt(st.nextToken()) - 1;\n            adj[a].add(b);\n            adj[b].add(a);\n        }\n        depth = new int[N];\n        depth[0] = -1;\n        maxDepth = 0;\n        root = findCentroid();\n        // System.out.println(""centroid "" + root);\n        genTreeInfo(root, root);\n\n        // Find base depth\n        ArrayList<Integer> toQuery = new ArrayList<>(N);\n        for (int i = 0; i < N; i++) toQuery.add(i+1);\n        Pair result = query(toQuery);\n        minDist = result.d;\n\n        Pair correctResult = null;\n        // Binary search on depth\n        int low = 0, high = maxDepth;\n        while (low < high) {\n            int mid = (low + high + 1) / 2;\n            result = check(mid);\n            if (minDist == result.d) {\n                low = mid;\n                correctResult = result;\n            } else {\n                high = mid - 1;\n            }\n        }\n\n        // One of the nodes is found; find the other one\n        int firstNode = correctResult.n;\n        // System.out.println(""first node is "" + firstNode);\n        int secondNode = findSecondNode(firstNode);\n        System.out.printf(""! %d %d\n"", firstNode+1, secondNode+1);\n        System.out.flush();\n\n        if (in.readLine().equals(""Incorrect"")) System.exit(0);\n    }\n\n    ArrayList<Pair> nodesWithDist;\n    int findSecondNode(int firstNode) {\n        // Find nodes with right distance\n        nodesWithDist = new ArrayList<>();\n        findNodesWithDist(firstNode, firstNode, 0);\n\n        ArrayList<Integer> toQuery = new ArrayList<>();\n        for (Pair p : nodesWithDist) {\n            toQuery.add(p.d);\n        }\n        Pair res = query(toQuery);\n        for (Pair p : nodesWithDist) {\n            if (p.d-1 == res.n) return p.n;\n        }\n        return -1;\n    }\n\n    void findNodesWithDist(int n, int p, int d) {\n        if (d == minDist) {\n            nodesWithDist.add(new Pair(n, n+1));\n        }\n        for (int e : adj[n]) {\n            if (e != p) findNodesWithDist(e, n, d+1);\n        }\n    }\n\n    int findCentroid() {\n        stSize = new int[N];\n        genSTSizes(0, 0);\n        int n = 0, p = 0;\n        boolean moved = true;\n        while (moved) {\n            moved = false;\n            for (int e : adj[n]) {\n                if (e == p) continue;\n                if (stSize[e] > N / 2) {\n                    p = n;\n                    n = e;\n                    moved = true;\n                    break;\n                }\n            }\n        }\n        return n;\n    }\n\n    int[] stSize;\n    void genSTSizes(int n, int p) {\n        stSize[n] = 1;\n        for (int e : adj[n]) {\n            if (e != p) {\n                genSTSizes(e, n);\n                stSize[n] += stSize[e];\n            }\n        }\n    }\n\n    Pair check(int d) {\n        ArrayList<Integer> toQuery = new ArrayList<>(2);\n        for (int i = 0; i < N; i++) {\n            if (depth[i] >= d) toQuery.add(i+1);\n        }\n        return query(toQuery);\n    }\n\n    Pair query(ArrayList<Integer> toQuery) {\n        System.out.printf(""? %d"", toQuery.size());\n        for (int q : toQuery) System.out.printf("" %d"", q);\n        System.out.println();\n        System.out.flush();\n\n        try {\n            StringTokenizer st = new StringTokenizer(in.readLine());\n            return new Pair(Integer.parseInt(st.nextToken()) - 1, Integer.parseInt(st.nextToken()));\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    void genTreeInfo(int n, int p) {\n        depth[n] = depth[p] + 1;\n        maxDepth = Math.max(depth[n], maxDepth);\n        for (int e : adj[n]) {\n            if (e != p) genTreeInfo(e, n);\n        }\n    }\n\n    static class Pair {\n        int n, d;\n        Pair(int n, int d) {\n            this.n = n;\n            this.d = d;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        int T = Integer.parseInt(in.readLine());\n        for (int i = 0; i < T; i++) new hiddenpair();\n        in.close();\n    }\n}\n","binary search,dfs and similar,graphs,interactive,shortest paths,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static ArrayList<Integer>[]adj;\n    static int[]dis;\n    static void dfs(int u,int p){\n\n        for (int v:adj[u]){\n            if (v!=p){\n                dis[v]=1+dis[u];\n                dfs(v,u);\n            }\n        }\n    }\n    static int getmid(int u,int p,int cur,int target){\n        int ret =-1;\n        if (cur==target)\n            return u;\n        for (int v:adj[u]){\n            if (v==p)\n                continue;\n            int x = getmid(v,u,cur+1,target);\n            ret=Math.max(ret,x);\n            if (((cur==target/2)||(cur==(target+1)/2))&&x!=-1){\n                return u;\n            }\n        }\n        return ret;\n    }\n    static ArrayList<Integer>getdepth(int u){\n\n        ArrayList<Integer>re= new ArrayList<>();\n        for (int i =0;i<dis.length;i++){\n            if (dis[i]==u){\n                re.add(i+1);\n            }\n        }\n        return re;\n    }\n    static void Print (ArrayList<Integer>a){\n        System.out.print(""? ""+a.size());\n        for (int x:a)\n            System.out.print("" ""+x);\n        System.out.println();\n    }\n    public  static void main(String[]args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int t = sc.nextInt();\n        while (t-->0){\n            int n = sc.nextInt();\n            adj= new ArrayList[n];\n            dis= new int[n];\n            for (int i =0;i<n;i++)\n                adj[i]= new ArrayList<>();\n            for (int i =1;i<n;i++){\n                int u = sc.nextInt()-1;\n                int v= sc.nextInt()-1;\n                adj[u].add(v);\n                adj[v].add(u);\n            }\n            dfs(0,-1);\n            int root = 0;\n            for (int i =0;i<n;i++){\n                if (dis[i]>dis[root])\n                    root=i;\n            }\n            dis= new int[n];\n            dfs(root,-1);\n            int far= root;\n            for (int i =0;i<n;i++){\n                if (dis[i]>dis[far]){\n                    far=i;\n                }\n            }\n            int dia=dis[far];\n//            System.err.println(far+"" ""+root);\n            int nroot= getmid(root,-1,0,dis[far]);\n            dis= new int[n];            ;\n            dfs(nroot,-1);\n            ArrayList<Integer>q= new ArrayList<>();\n            for (int i =1;i<=n;i++)q.add(i);\n            Print(q);\n            int node= sc.nextInt()-1;\n            int d = sc.nextInt();\n            int low=dis[node];\n            int hi=(dia+1)/2;\n            int ans=node;\n\n            while (low<=hi){\n                int mid = low+hi>>1;\n                ArrayList<Integer> a = getdepth(mid);\n                if (a.size()==0){\n                    hi=mid-1;\n                    continue;\n                }\n                Print(a);\n                int x = sc.nextInt();\n                int y = sc.nextInt();\n                if (y>d){\n                    hi=mid-1;\n                }\n                else{\n                    low=mid+1;\n                    ans=x-1;\n                }\n            }\n//            System.err.println(ans);\n            dis= new int[n];\n            dfs(ans,-1);\n            Print(getdepth(d));\n            int x = sc.nextInt();\n            sc.nextInt();\n            ans++;\n            System.out.println(""! ""+x+"" ""+ans);\n            sc.next();\n        }\n        pw.flush();\n    }\n/*\n10\n9 6\n6 7\n2 8\n8 9\n4 3\n1 3\n6 10\n5 9\n10 2\n5 4\n */\n    static class Scanner\n    {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}\n\n        public String next() throws IOException\n        {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {return Integer.parseInt(next());}\n\n        public long nextLong() throws IOException {return Long.parseLong(next());}\n\n        public String nextLine() throws IOException {return br.readLine();}\n\n        public double nextDouble() throws IOException\n        {\n            String x = next();\n            StringBuilder sb = new StringBuilder(""0"");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if(x.charAt(0) == '-')\n            {\n                neg = true;\n                start++;\n            }\n            for(int i = start; i < x.length(); i++)\n                if(x.charAt(i) == '.')\n                {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(""0"");\n                    dec = true;\n                }\n                else\n                {\n                    sb.append(x.charAt(i));\n                    if(dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg?-1:1);\n        }\n\n        public boolean ready() throws IOException {return br.ready();}\n\n\n    }\n}\n","binary search,dfs and similar,graphs,interactive,shortest paths,trees"
import java.util.*;\npublic class Ta{\npublic static void main(String[] args) {Scanner sc=new Scanner(System.in); int t=sc.nextInt();\n while(t-->0){long n=sc.nextLong();System.out.println(n/2);} }},"greedy,implementation,math,number theory"
import java.util.*;\n \npublic class GCD {\n	public static void main(String[] args){\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		while(n>0){\n			n--;\n			System.out.println((sc.nextInt()/2));\n		}\n	}\n}\n,"greedy,implementation,math,number theory"
import java.util.*;\n\npublic class A1370 {\n	public static void main(String[] args){\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while(t>0){\n			t--;\n			System.out.println((sc.nextInt()/2));\n		}\n	}\n}\n,"greedy,implementation,math,number theory"
import java.util.*;\n\npublic class Main {\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int t=in.nextInt();\n		while(t-->0) {\n			int n=in.nextInt();\n			System.out.println(n/2);\n		}\n	}\n},"greedy,implementation,math,number theory"
"\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeSet;\nimport java.util.stream.IntStream;\n\npublic final class F {\n\n    public static void main(String[] args) {\n        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        final int t = Integer.parseInt(in.nextLine());\n        for (int x = 0; x < t; x++) {\n            final int n = Integer.parseInt(in.nextLine());\n            final int[] array = Arrays.stream(in.nextLine().split("" ""))\n                                      .mapToInt(Integer::parseInt)\n                                      .toArray();\n            final Integer[] spots = IntStream.range(0, n).boxed().toArray(Integer[]::new);\n            Arrays.sort(spots, (a, b) -> Integer.compare(array[b], array[a]));\n            final TreeSet<Integer> treeSet = new TreeSet<>();\n            int j = 0;\n            int largest = treeSet.size();\n            for (int k = -1; k < n; k++) {\n                if (k >= 0) {\n                    treeSet.remove(spots[k]);\n                }\n                j = compute(n, array, spots, treeSet, j);\n                largest = Math.max(largest, treeSet.size());\n            }\n            System.out.println(n - largest);\n        }\n    }\n\n    private static int compute(int n, int[] array, Integer[] spots, TreeSet<Integer> treeSet, int j) {\n        while (j < n) {\n            final Integer lower = treeSet.lower(spots[j]);\n            final Integer higher = treeSet.higher(spots[j]);\n            if ((lower != null && array[lower] > array[spots[j]]) ||\n                (higher != null && array[higher] < array[spots[j]])) {\n                break;\n            }\n            treeSet.add(spots[j]);\n            j++;\n        }\n        return j;\n    }\n}\n","binary search,data structures,dp,greedy,sortings,two pointers"
"\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeSet;\nimport java.util.stream.IntStream;\n\npublic final class F2 {\n\n    public static void main(String[] args) {\n        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        final int t = Integer.parseInt(in.nextLine());\n        for (int x = 0; x < t; x++) {\n            final int n = Integer.parseInt(in.nextLine());\n            final int[] array = Arrays.stream(in.nextLine().split("" ""))\n                                      .mapToInt(Integer::parseInt)\n                                      .toArray();\n            final Integer[] spots = IntStream.range(0, n).boxed().toArray(Integer[]::new);\n            Arrays.sort(spots, (a, b) -> Integer.compare(array[b], array[a]));\n            final TreeSet<Integer> treeSet = new TreeSet<>();\n            int j = 0;\n            j = compute(n, array, spots, treeSet, j);\n            int largest = treeSet.size();\n            for (int k = 0; k < n; k++) {\n                treeSet.remove(spots[k]);\n                j = compute(n, array, spots, treeSet, j);\n                largest = Math.max(largest, treeSet.size());\n            }\n            System.out.println(n - largest);\n        }\n    }\n\n    private static int compute(int n, int[] array, Integer[] spots, TreeSet<Integer> treeSet, int j) {\n        while (j < n) {\n            final Integer lower = treeSet.lower(spots[j]);\n            final Integer higher = treeSet.higher(spots[j]);\n            if ((lower != null && array[lower] > array[spots[j]]) ||\n                (higher != null && array[higher] < array[spots[j]])) {\n                break;\n            }\n            treeSet.add(spots[j]);\n            j++;\n        }\n        return j;\n    }\n}\n","binary search,data structures,dp,greedy,sortings,two pointers"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1367F2 extends PrintWriter {\n	CF1367F2() { super(System.out); }\n	static class Scanner {\n		Scanner(InputStream in) { this.in = in; } InputStream in;\n		int k, l; byte[] bb = new byte[1 << 15];\n		byte getc() {\n			if (k >= l) {\n				k = 0;\n				try { l = in.read(bb); } catch (IOException e) { l = 0; }\n				if (l <= 0) return -1;\n			}\n			return bb[k++];\n		}\n		int nextInt() {\n			byte c = 0; while (c <= 32) c = getc();\n			int a = 0; while (c > 32) { a = a * 10 + c - '0'; c = getc(); }\n			return a;\n		}\n	}\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1367F2 o = new CF1367F2(); o.main(); o.flush();\n	}\n\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int[] aa = new int[n];\n			Integer[] ii = new Integer[n];\n			for (int i = 0; i < n; i++) {\n				aa[i] = sc.nextInt();\n				ii[i] = i;\n			}\n			Arrays.sort(ii, (i, j) -> aa[i] != aa[j] ? aa[i] - aa[j] : i - j);\n			int m_ = 0;\n			for (int i = 0, j; i < n; i = j) {\n				j = i + 1;\n				while (j < n && ii[j] > ii[j - 1])\n					j++;\n				int m = j - i;\n				if (i > 0) {\n					int x = aa[ii[i - 1]];\n					int l = ii[i];\n					for (int h = i - 1; h >= 0 && aa[ii[h]] == x; h--)\n					 	if (ii[h] < l)\n							m++;\n				}\n				if (j < n) {\n					int x = aa[ii[j]];\n					int r = ii[j - 1];\n					for (int h = j; h < n && aa[ii[h]] == x; h++)\n						if (ii[h] > r)\n							m++;\n				}\n				m_ = Math.max(m_, m);\n			}\n			for (int i = 0, j; i < n; i = j) {\n				int a = aa[ii[i]];\n				j = i + 1;\n				while (j < n && aa[ii[j]] == a)\n					j++;\n				if (j < n) {\n					int i_ = j;\n					int a_ = aa[ii[i_]];\n					int j_ = i_ + 1;\n					while (j_ < n && aa[ii[j_]] == a_)\n						j_++;\n					for (int h = i; h < j; h++) {\n						while (i_ < j_ && ii[i_] < ii[h])\n							i_++;\n						m_ = Math.max(m_, h - i + 1 + j_ - i_);\n					}\n				}\n			}\n			println(n - m_);\n		}\n	}\n}\n","binary search,data structures,dp,greedy,sortings,two pointers"
"import java.io.*;\nimport java.util.*;\npublic class Sol{\n	public static void main(String[] args) throws IOException{\n		FastIO sc = new FastIO(System.in);\n		PrintWriter out = new PrintWriter(System.out);\n		int t = sc.nextInt();\n		while(t-->0) {\n			int n = sc.nextInt();\n			int arr[] = new int[n];\n			int unsort[] = new int[n];\n			TreeSet<Integer> st = new TreeSet<>();\n			TreeMap<Integer, Integer> mp = new TreeMap<>();\n			TreeMap<Integer, Integer> fir = new TreeMap<>();\n			TreeMap<Integer, Integer> cnt = new TreeMap<>();\n			TreeMap<Integer, Integer> num = new TreeMap<>();\n			for(int i=0; i<n; ++i) {\n				arr[i] =sc.nextInt();\n				if(!st.contains(arr[i])) {\n					fir.put(arr[i], i);\n				}\n				int count = num.containsKey(arr[i]) ? num.get(arr[i]) : 0;\n				num.put(arr[i], count + 1);\n				st.add(arr[i]);\n				mp.put(arr[i],-1);\n				unsort[i] = arr[i];\n			}\n			//Arrays.sort(arr);\n			int best = 0;\n			int dp[] = new int[n];\n			for(int i=0; i<n; ++i) {\n				dp[i] = 1;\n				Object k = st.lower(arr[i]);\n				if(k!=null&&fir.get(k)<i) {\n					if(cnt.get(k)==num.get(k)) {\n						dp[i] = Math.max(dp[i], dp[fir.get(k)]+cnt.get(k));\n					}else {\n						dp[i] = Math.max(dp[i], cnt.get(k)+1);\n					}\n				}\n				if(mp.get(arr[i])!=-1) {\n					dp[i] = Math.max(dp[i], dp[mp.get(arr[i])]+1);\n				}\n				best = Math.max(best,  dp[i]);\n				//System.out.println(i + "" "" + arr[i] + "" "" + dp[i]);\n				mp.put(arr[i], i);\n				int count = cnt.containsKey(arr[i]) ? cnt.get(arr[i]) : 0;\n				cnt.put(arr[i], count + 1);\n			}\n			System.out.println(n-best);\n		}\n		out.close();\n	}\n	static class FastIO {\n		InputStream dis;\n		byte[] buffer = new byte[1 << 17];\n		int pointer = 0;\n		public FastIO(String fileName) throws IOException {\n			dis = new FileInputStream(fileName);\n		}\n		public FastIO(InputStream is) throws IOException {\n			dis = is;\n		}\n		int nextInt() throws IOException {\n			int ret = 0;\n \n			byte b;\n			do {\n				b = nextByte();\n			} while (b <= ' ');\n			boolean negative = false;\n			if (b == '-') {\n				negative = true;\n				b = nextByte();\n			}\n			while (b >= '0' && b <= '9') {\n				ret = 10 * ret + b - '0';\n				b = nextByte();\n			}\n \n			return (negative) ? -ret : ret;\n		}\n		long nextLong() throws IOException {\n			long ret = 0;\n \n			byte b;\n			do {\n				b = nextByte();\n			} while (b <= ' ');\n			boolean negative = false;\n			if (b == '-') {\n				negative = true;\n				b = nextByte();\n			}\n			while (b >= '0' && b <= '9') {\n				ret = 10 * ret + b - '0';\n				b = nextByte();\n			}\n			return (negative) ? -ret : ret;\n		}\n		byte nextByte() throws IOException {\n			if (pointer == buffer.length) {\n				dis.read(buffer, 0, buffer.length);\n				pointer = 0;\n			}\n			return buffer[pointer++];\n		}\n		String next() throws IOException {\n			StringBuffer ret = new StringBuffer();\n \n			byte b;\n			do {\n				b = nextByte();\n			} while (b <= ' ');\n			while (b > ' ') {\n				ret.appendCodePoint(b);\n				b = nextByte();\n			}\n \n			return ret.toString();\n		}\n	}\n}","binary search,data structures,dp,greedy,sortings,two pointers"
"import java.io.*;\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\npublic class template {\n	public static void main(String[] args) throws Exception {\n		new template().run();\n	}\n	public void run() throws Exception {\n		FastScanner f = new FastScanner();\n		PrintWriter out = new PrintWriter(System.out);\n		int n = f.nextInt(), m = f.nextInt(), k = f.nextInt();\n		long[] dist = new long[n];\n		long MOD = 1_000_000_007;\n		int[] max1 = new int[n];\n		long[] max2 = new long[n];\n		Arrays.fill(dist, Long.MIN_VALUE);\n		Arrays.fill(max2, Long.MIN_VALUE);\n		dist[0] = 0;\n		ArrayList<Pair> al = new ArrayList<>();\n		for(int i = 0; i < m; i++) {\n			int	a = f.nextInt()-1, b = f.nextInt()-1;\n			int v = f.nextInt();\n			al.add(new Pair(a,b,v));\n			max1[a] = Math.max(max1[a],v);\n			max1[b] = Math.max(max1[b],v);\n		}\n		max2[0] = 0;\n		long ans = 0;\n		for(long it = 1; it < n; it++) {\n			long[] ndist = new long[n];\n			Arrays.fill(ndist, Long.MIN_VALUE);\n			for(Pair p : al) {\n				ndist[p.j] = Math.max(ndist[p.j], dist[p.i]+p.v);\n				ndist[p.i] = Math.max(ndist[p.i], dist[p.j]+p.v);\n			}\n			dist = ndist;\n			long max = 0;\n			for(int i = 0; i < n; i++) {\n				if(dist[i] > 0) max2[i] = Math.max(max2[i], dist[i]-it*max1[i]);\n				max = Math.max(max,dist[i]);\n			}\n			if(it < n-1) ans += max;\n		}\n		Line[] arr = new Line[n];\n		for(int i = 0; i < n; i++)\n			arr[i] = new Line(max1[i],max2[i]);\n		Arrays.sort(arr);\n		ArrayList<Line> ch = new ArrayList<>();\n		ArrayList<Double> inter = new ArrayList<>();\n		inter.add(0.0);\n		for(Line l : arr) {\n			if(l.b < Integer.MIN_VALUE) continue;\n			while(true) {\n				if(ch.size() >= 2 && computeInter(ch.get(ch.size()-2), l) <= inter.get(inter.size()-1) || ch.size() >= 1 && ch.get(ch.size()-1).m == l.m) {\n					if(ch.size() != 1) inter.remove(inter.size()-1);\n					ch.remove(ch.size()-1);\n				} else break;\n			}\n			if(!ch.isEmpty()) inter.add(computeInter(ch.get(ch.size()-1), l));\n			ch.add(l);\n		}\n		inter.add(1.0*k);\n		for(int i = 0; i < ch.size(); i++) {\n			long l =  Math.max((long) Math.floor(inter.get(i)), n-2);\n			long r = Math.min((long) Math.floor(inter.get(i+1)), k);\n			Line line = ch.get(i);\n			if(r <= l) continue;\n			ans = (ans + (r-l)*line.b%MOD)%MOD;\n			ans = (ans - (l*(l+1)/2)%MOD*line.m%MOD+MOD)%MOD;\n			ans = (ans + (r*(r+1)/2)%MOD*line.m%MOD+MOD)%MOD;\n		}\n		out.println(ans);\n///\n		out.flush();\n	}\n	public double computeInter(Line l1, Line l2) {\n		double x = l1.b - l2.b;\n		x /= l2.m - l1.m;\n		return x;\n	}\n	class Line implements Comparable<Line> {\n		long m, b;\n		public Line(long a, long c) {\n			this.m = a;\n			this.b = c;\n		}\n		public int compareTo(Line l) {\n			if(m == l.m) return Long.compare(b, l.b);\n			return Long.compare(m, l.m);\n		}\n		public String toString() {return ""(""+m +"",""+b+"")"";}\n	}\n	class Pair {\n		int i, j; long v;\n		public Pair(int a, int b, long c) {\n			i = a;\n			j = b;\n			v = c;\n		}\n	}\n///\n	static class FastScanner {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n        	return Long.parseLong(next());\n        }\n        public double nextDouble() {\n        	return Double.parseDouble(next());\n        }\n        public String nextLine() {\n        	try {\n        		return reader.readLine();\n        	} catch(IOException e) {\n        		throw new RuntimeException(e);\n        	}\n        }\n    }\n}\n","binary search,dp,geometry,graphs"
"//package ecr89;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class F {\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n	\n	void solve()\n	{\n		int n = ni(), m = ni(), Q = ni();\n		int[] from = new int[m];\n		int[] to = new int[m];\n		int[] ws = new int[m];\n		for(int i = 0;i < m;i++){\n			from[i] = ni()-1;\n			to[i] = ni()-1;\n			ws[i] = ni();\n		}\n		int[][][] g = packWU(n, from, to, ws);\n		\n		int mod = 1000000007;\n		long[] w = new long[n];\n		Arrays.fill(w, Long.MIN_VALUE);\n		w[0] = 0;\n		long asum = 0;\n		for(int i = 0;i < 4000 && i < Q;i++){\n			long[] nw = new long[n];\n			Arrays.fill(nw, Long.MIN_VALUE);\n			for(int j = 0;j < n;j++){\n				for(int[] e : g[j]){\n					nw[e[0]] = Math.max(nw[e[0]], w[j] + e[1]);\n				}\n			}\n			long lmax = 0;\n			for(int j = 0;j < n;j++){\n				lmax = Math.max(lmax, nw[j]);\n			}\n			asum += lmax;\n			asum %= mod;\n			w = nw;\n		}\n		if(Q <= 4000){\n			out.println(asum);\n		}else{\n			long[][] ss = new long[n][];\n			int p = 0;\n			for(int i = 0;i < n;i++){\n				if(w[i] < 0)continue;\n				int lmax = 0;\n				for(int[] e : g[i]){\n					lmax = Math.max(lmax, e[1]);\n				}\n				ss[p++] = new long[]{lmax, w[i]};\n			}\n			ss = Arrays.copyOf(ss, p);\n			Arrays.sort(ss, new Comparator<long[]>() {\n				public int compare(long[] a, long[] b) {\n					return Long.compare(a[0], b[0]);\n				}\n			});\n			EnvelopeLinear el = new EnvelopeLinear(n);\n			for(long[] s : ss){\n				el.add(-s[0], -s[1]);\n			}\n			long ans = asum;\n			for(int i = 0;i < el.p;i++){\n				long l = Math.max(el.xs[i], 1);\n				long r = Math.min(i+1 < el.p ? el.xs[i+1] : Long.MAX_VALUE, Q-4000+1);\n				if(l <= r){\n					ans += -el.slopes[i] * ((r*(r-1)/2 - l*(l-1)/2)%mod);\n					ans %= mod;\n					ans += -el.intercepts[i] * (r-l);\n					ans %= mod;\n				}\n			}\n			if(ans < 0)ans += mod;\n			out.println(ans);\n		}\n	}\n	\n	public static class EnvelopeLinear {\n		public static final long INF = Long.MIN_VALUE;\n		\n		public long[] xs;\n		public long[] intercepts, slopes;\n		public int p;\n		\n		public EnvelopeLinear(int n)\n		{\n			xs = new long[n];\n			intercepts = new long[n];\n			slopes = new long[n];\n			p = 0;\n		}\n		\n		public void clear()\n		{\n			p = 0;\n		}\n		\n		public void add(long slope, long intercept)\n		{\n			assert p == 0 || slopes[p-1] >= slope;\n			while(p > 0){\n				int i = p-1;\n				long anew = intercepts[i]+xs[i]*slopes[i];\n				long old = intercept+xs[i]*slope;\n				double danew = intercepts[i]+(double)xs[i]*slopes[i];\n				double dold = intercept+(double)xs[i]*slope;\n				\n				if(p > 1 && (danew - dold > 1e18 || anew - old >= 0)){ // x=xs[i]\n					p--;\n					continue;\n				}\n				if(slope == slopes[i]){\n					if(intercept >= intercepts[i]){\n						return;\n					}else{\n						p--;\n						continue;\n					}\n				}\n				// y=sx+i vs y=Sx+I\n				// sx+i=Sx+I\n				// x=(i-I)/(S-s)\n				long num = intercept-intercepts[i];\n				long den = slopes[i]-slope;\n				long nx = num < 0 ? num/den : (num+den-1)/den;\n				xs[p] = nx;\n				intercepts[p] = intercept;\n				slopes[p] = slope;\n				p++;\n				return;\n			}\n			\n			xs[p] = INF;\n			intercepts[p] = intercept;\n			slopes[p] = slope;\n			p++;\n		}\n		\n		public int argmin(int x)\n		{\n			if(p <= 0)return -1;\n			int ind = Arrays.binarySearch(xs, 0, p, x);\n			if(ind < 0)ind = -ind-2;\n			return ind;\n		}\n		\n		public long min(long x)\n		{\n			if(p <= 0)return Long.MIN_VALUE;\n			int ind = Arrays.binarySearch(xs, 0, p, x);\n			if(ind < 0)ind = -ind-2;\n			return slopes[ind]*x + intercepts[ind];\n		}\n	}\n\n	\n	public static int[][][] packWU(int n, int[] from, int[] to, int[] w) {\n		int[][][] g = new int[n][][];\n		int[] p = new int[n];\n		for (int f : from)\n			p[f]++;\n		for (int t : to)\n			p[t]++;\n		for (int i = 0; i < n; i++)\n			g[i] = new int[p[i]][2];\n		for (int i = 0; i < from.length; i++) {\n			--p[from[i]];\n			g[from[i]][p[from[i]]][0] = to[i];\n			g[from[i]][p[from[i]]][1] = w[i];\n			--p[to[i]];\n			g[to[i]][p[to[i]]][0] = from[i];\n			g[to[i]][p[to[i]]][1] = w[i];\n		}\n		return g;\n	}\n\n	\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new F().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n	\n	private char[][] nm(int n, int m)\n	{\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n	\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n	\n	private int ni()\n	{\n		int num = 0, b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","binary search,dp,geometry,graphs"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        static final int MOD = 1000000007;\n        static final long INF = 1L << 50;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt(), m = in.nextInt(), q = in.nextInt();\n            long[][] W = new long[n + 1][n];\n            for (int i = 0; i <= n; i++) Arrays.fill(W[i], -INF);\n            int[] a = new int[m], b = new int[m], w = new int[m];\n            int[] best = new int[n];\n\n            for (int i = 0; i < m; i++) {\n                a[i] = in.nextInt() - 1;\n                b[i] = in.nextInt() - 1;\n                w[i] = in.nextInt();\n                best[a[i]] = Integer.max(best[a[i]], w[i]);\n                best[b[i]] = Integer.max(best[b[i]], w[i]);\n            }\n\n            W[0][0] = 0;\n\n            TaskF.ConvexHullOptimization cht = new TaskF.ConvexHullOptimization();\n            long[] arr = new long[n];\n            Arrays.fill(arr, -INF);\n\n            arr[0] = 0;\n            long[] answers = new long[n + 1];\n\n            for (int l = 1; l <= n; l++) {\n                for (int i = 0; i < m; i++) {\n                    W[l][a[i]] = Long.max(W[l - 1][b[i]] + w[i], W[l][a[i]]);\n                    W[l][b[i]] = Long.max(W[l - 1][a[i]] + w[i], W[l][b[i]]);\n                }\n                for (int i = 0; i < n; i++) {\n                    arr[i] = Long.max(arr[i], W[l][i] - l * 1L * best[i]);\n                    answers[l] = Long.max(answers[l], W[l][i]);\n                }\n            }\n\n            int[] order = new int[n];\n            for (int i = 0; i < n; i++) order[i] = i;\n            for (int j = 0; j < n; j++) {\n                for (int i = 0; i + 1 < n; i++) {\n                    if (best[order[i]] > best[order[i + 1]]) {\n                        int temp = order[i];\n                        order[i] = order[i + 1];\n                        order[i + 1] = temp;\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) cht.addLine(best[order[i]], arr[order[i]]);\n            long ans = 0;\n            for (int i = 1; i <= Integer.min(n, q); i++) ans += answers[i];\n            ans %= MOD;\n            int pos = n + 1;\n            while (pos <= q) {\n                int curr = cht.minValue(pos);\n                int mx = cht.getMax(curr, pos, q);\n                ans += cht.get(curr, pos, mx);\n                pos = mx + 1;\n                ans %= MOD;\n            }\n            ans = (ans % MOD + MOD) % MOD;\n            out.println(ans);\n        }\n\n        static class ConvexHullOptimization {\n            long[] A = new long[100000];\n            long[] B = new long[100000];\n            int len;\n\n            public void addLine(long a, long b) {\n                a *= -1;\n                b *= -1;\n                // intersection of (A[len-2],B[len-2]) with (A[len-1],B[len-1]) must lie to the left of intersection of (A[len-1],B[len-1]) with (a,b)\n                while (len >= 2 && (B[len - 2] - B[len - 1]) * (a - A[len - 1]) >= (B[len - 1] - b) * (A[len - 1] - A[len - 2])) {\n                    --len;\n                }\n                A[len] = a;\n                B[len] = b;\n                ++len;\n            }\n\n            int minValue(long x) {\n                int lo = 0, hi = len - 1;\n                while (lo < hi) {\n                    int ptr = (lo + hi) / 2;\n                    if (A[ptr] * x + B[ptr] > A[ptr + 1] * x + B[ptr + 1]) lo = ptr + 1;\n                    else hi = ptr;\n                }\n                return lo;\n            }\n\n            long getSum(long x) {\n                return ((x * 1L * (x + 1)) / 2) % MOD;\n            }\n\n            long get(int ptr, int l, int r) {\n                long ret = (A[ptr] % MOD) * (getSum(r) - getSum(l - 1)) + (B[ptr] % MOD) * (r - l + 1);\n                ret *= -1;\n                return (ret % MOD + MOD) % MOD;\n            }\n\n            int getMax(int l, int mn, int q) {\n                int lo = mn, hi = q;\n                while (lo < hi) {\n                    int mid = (lo + hi + 1) / 2;\n                    int V = minValue(mid);\n                    if (minValue(mid) == l) lo = mid;\n                    else hi = mid - 1;\n                }\n                return lo;\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void println(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n            writer.print('\n');\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n","binary search,dp,geometry,graphs"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        static final int MOD = 1000000007;\n        static final long INF = 1L << 50;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt(), m = in.nextInt(), q = in.nextInt();\n            long[][] W = new long[n + 1][n];\n            for (int i = 0; i <= n; i++) Arrays.fill(W[i], -INF);\n            int[] a = new int[m], b = new int[m], w = new int[m];\n            int[] best = new int[n];\n\n\n            for (int i = 0; i < m; i++) {\n                a[i] = in.nextInt() - 1;\n                b[i] = in.nextInt() - 1;\n                w[i] = in.nextInt();\n                best[a[i]] = Integer.max(best[a[i]], w[i]);\n                best[b[i]] = Integer.max(best[b[i]], w[i]);\n            }\n\n            W[0][0] = 0;\n\n            TaskF.ConvexHullOptimization cht = new TaskF.ConvexHullOptimization();\n            long[] arr = new long[n];\n            Arrays.fill(arr, -INF);\n\n            arr[0] = 0;\n            long[] answers = new long[n + 1];\n\n            for (int l = 1; l <= n; l++) {\n                for (int i = 0; i < m; i++) {\n                    W[l][a[i]] = Long.max(W[l - 1][b[i]] + w[i], W[l][a[i]]);\n                    W[l][b[i]] = Long.max(W[l - 1][a[i]] + w[i], W[l][b[i]]);\n                }\n                for (int i = 0; i < n; i++) {\n                    arr[i] = Long.max(arr[i], W[l][i] - l * 1L * best[i]);\n                    answers[l] = Long.max(answers[l], W[l][i]);\n                }\n            }\n            int[] order = new int[n];\n            for (int i = 0; i < n; i++) order[i] = i;\n            for (int j = 0; j < n; j++) {\n                for (int i = 0; i + 1 < n; i++) {\n                    if (best[order[i]] > best[order[i + 1]]) {\n                        int temp = order[i];\n                        order[i] = order[i + 1];\n                        order[i + 1] = temp;\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) cht.addLine(best[order[i]], arr[order[i]]);\n//        System.out.println(Arrays.toString(answers));\n//        System.out.println(Arrays.toString(best));\n//        for(int i = n+1; i <= 2*n; i++) System.out.println(cht.minValue(i));\n            long ans = 0;\n            for (int i = 1; i <= Integer.min(n, q); i++) ans += answers[i];\n            ans %= MOD;\n            int pos = n + 1;\n            while (pos <= q) {\n                int curr = cht.minValue(pos);\n                int mx = cht.getMax(curr, pos, q);\n                ans += cht.get(curr, pos, mx);\n                pos = mx + 1;\n                ans %= MOD;\n            }\n            ans = (ans % MOD + MOD) % MOD;\n            out.println(ans);\n        }\n\n        static class ConvexHullOptimization {\n            long[] A = new long[100000];\n            long[] B = new long[100000];\n            int len;\n\n            public void addLine(long a, long b) {\n                a *= -1;\n                b *= -1;\n                // intersection of (A[len-2],B[len-2]) with (A[len-1],B[len-1]) must lie to the left of intersection of (A[len-1],B[len-1]) with (a,b)\n                while (len >= 2 && (B[len - 2] - B[len - 1]) * (a - A[len - 1]) >= (B[len - 1] - b) * (A[len - 1] - A[len - 2])) {\n                    --len;\n                }\n                A[len] = a;\n                B[len] = b;\n                ++len;\n            }\n\n            int minValue(long x) {\n                int lo = 0, hi = len - 1;\n                while (lo < hi) {\n                    int ptr = (lo + hi) / 2;\n                    if (A[ptr] * x + B[ptr] > A[ptr + 1] * x + B[ptr + 1]) lo = ptr + 1;\n                    else hi = ptr;\n                }\n                return lo;\n            }\n\n            long getSum(long x) {\n                return ((x * 1L * (x + 1)) / 2) % MOD;\n            }\n\n            long get(int ptr, int l, int r) {\n                long ret = (A[ptr] % MOD) * (getSum(r) - getSum(l - 1)) + (B[ptr] % MOD) * (r - l + 1);\n                ret *= -1;\n                return (ret % MOD + MOD) % MOD;\n            }\n\n            int getMax(int l, int mn, int q) {\n                int lo = mn, hi = q;\n                while (lo < hi) {\n                    int mid = (lo + hi + 1) / 2;\n                    int V = minValue(mid);\n                    if (minValue(mid) == l) lo = mid;\n                    else hi = mid - 1;\n                }\n                return lo;\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void println(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n            writer.print('\n');\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n","binary search,dp,geometry,graphs"
import java.util.*;\n\npublic class codeforces\n{\n	public static void main(String[] args) \n	{\n		Scanner s=new Scanner(System.in);\n		int t=s.nextInt();\n		while(t-->0)\n		{\n			long n=s.nextLong();\n			System.out.println(2*n-Long.bitCount(n));\n		}	\n	}\n},"bitmasks,greedy,math"
import java.util.*;\npublic class cf647divC {\npublic static void main(String[] args) {\nScanner sc=new Scanner(System.in);\nlong k=sc.nextLong();\nfor(int j=1;j<=k;j++)\n{long n=sc.nextLong();\nlong sum=0;\nwhile(n>0)\n{sum=sum+n;\nn=n/2;}\nSystem.out.println(sum);}sc.close();}},"bitmasks,greedy,math"
import java.util.*;\npublic class class258 {\npublic static void main(String arg[])\n{\n	Scanner sc=new Scanner(System.in);\n   int t=sc.nextInt();\n   while(t-->0)\n   {\n	 long n=sc.nextLong();\n	 long sum=0;\n	 while(n>0)\n	 {\n		 sum+=n;\n		 n=n/2;\n	 }\n	 System.out.println(sum);\n   }\n}\n}\n,"bitmasks,greedy,math"
import java.util.*;\n\npublic class Main{\n	public static void main(String[] args)\n	{\n		Scanner sc = new Scanner(System.in);\n		\n		int t = sc.nextInt();\n		while(t-->0) {\n		long n = sc.nextLong();\n		long ans=0;\n		while(n>0)\n		{\n			ans+=n;\n			n>>=1;\n			\n		}\n		System.out.println(ans);\n		}\n	}\n},"bitmasks,greedy,math"
import java.util.Scanner;\n\npublic class cf1360_Div3_F {\n	public static void main(String args[]) {\n		Scanner in = new Scanner(System.in);\n		int tc = in.nextInt();\n		for ( ; tc > 0; tc--) {\n			int n = in.nextInt();\n			int m = in.nextInt();\n			char[][] grid = new char[n][];\n			for (int i = 0; i < n; i++) {\n				grid[i] = in.next().toCharArray();\n			}\n			\n			boolean flag = true;\n			for (int i = 0; i < m; i++) {\n				char prev = grid[0][i];\n				for (char val = 'a'; val <= 'z'; val++) {\n					flag = true;\n					grid[0][i] = val;\n					for (int j = 1; j < n; j++) {\n						int c = 0;\n						for (int k = 0; k < m; k++) {\n							if (grid[j][k] != grid[0][k])\n								c++;\n						}\n						if (c > 1) {\n							flag = false;\n							break;\n						}\n					}\n					if (flag) {\n						System.out.println(grid[0]);\n						break;\n					}\n				}\n				if (flag) break;\n				grid[0][i] = prev;\n			}\n			\n			if (!flag) System.out.println(-1);\n			\n			\n		}\n	}\n},"bitmasks,brute force,constructive algorithms,dp,hashing,strings"
import java.util.Scanner;\n\npublic class cf1360_Div3_F {\n	public static void main(String args[]) {\n		Scanner in = new Scanner(System.in);\n		int tc = in.nextInt();\n		for ( ; tc > 0; tc--) {\n			int n = in.nextInt();\n			int m = in.nextInt();\n			char[][] grid = new char[n][];\n			for (int i = 0; i < n; i++) {\n				grid[i] = in.next().toCharArray();\n			}\n			\n			boolean flag = true;\n			for (int i = 0; i < m; i++) {\n				char prev = grid[0][i];\n				for (char val = 'a'; val <= 'z'; val++) {\n					flag = true;\n					grid[0][i] = val;\n					for (int j = 1; j < n; j++) {\n						int c = 0;\n						for (int k = 0; k < m; k++) {\n							if (grid[j][k] != grid[0][k])\n								c++;\n						}\n						if (c > 1) {\n							flag = false;\n							break;\n						}\n					}\n					if (flag) {\n						System.out.println(grid[0]);\n						break;\n					}\n				}\n				if (flag) break;\n				grid[0][i] = prev;\n			}\n			\n			if (!flag) System.out.println(-1);\n			\n			\n		}\n	}\n},"bitmasks,brute force,constructive algorithms,dp,hashing,strings"
import java.util.Scanner;\n\npublic class cf1360_Div3_F {\n	public static void main(String args[]) {\n		Scanner in = new Scanner(System.in);\n		int tc = in.nextInt();\n		for ( ; tc > 0; tc--) {\n			int n = in.nextInt();\n			int m = in.nextInt();\n			char[][] grid = new char[n][];\n			for (int i = 0; i < n; i++) {\n				grid[i] = in.next().toCharArray();\n			}\n			\n			boolean flag = true;\n			for (int i = 0; i < m; i++) {\n				char prev = grid[0][i];\n				for (char val = 'a'; val <= 'z'; val++) {\n					flag = true;\n					grid[0][i] = val;\n					for (int j = 1; j < n; j++) {\n						int c = 0;\n						for (int k = 0; k < m; k++) {\n							if (grid[j][k] != grid[0][k])\n								c++;\n						}\n						if (c > 1) {\n							flag = false;\n							break;\n						}\n					}\n					if (flag) {\n						System.out.println(grid[0]);\n						break;\n					}\n				}\n				if (flag) break;\n				grid[0][i] = prev;\n			}\n			\n			if (!flag) System.out.println(-1);\n			\n			\n		}\n	}\n}\n,"bitmasks,brute force,constructive algorithms,dp,hashing,strings"
"import java.util.*;\npublic class Main{\n	static String func(String[] arr, int k) {\n		String s = arr[0];\n		for(int i = 0; i < k; i++) {\n			char[] carr = s.toCharArray();\n			for(int j = 0; j < 26; j++) {\n				carr[i] = (char)('a' + j);\n				boolean go = true;\n				for(String str : arr) {\n					int find = 0;\n					for(int a = 0; a < k; a++) {\n						if(carr[a] != str.charAt(a)) find++;\n					}\n					if(find > 1) {\n						go = false;\n						break;\n					}\n				}\n				if(go) return new StringBuffer().append(carr).toString();\n			}\n		}\n		return ""-1"";\n	}\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int tc = sc.nextInt();\n        for(int t = 0; t < tc; t++){\n            int n = sc.nextInt(), k = sc.nextInt();\n            String[] arr = new String[n];\n            for(int i = 0; i < n; i++) arr[i] = sc.next();\n            String s = func(arr, k);\n            System.out.println(s);\n        }\n    }\n}","bitmasks,brute force,constructive algorithms,dp,hashing,strings"
import java.util.*;\nimport java.io.*;\npublic class GFG {\n    public static void main (String[] args) {\n		Scanner sc=new Scanner(System.in);\n		PrintWriter out=new PrintWriter(System.out);\n		int t1=sc.nextInt();\n		while (t1-->0){ \n		   long h=sc.nextLong();\n		   long c=sc.nextLong();\n		   long t=sc.nextLong();\n		   if(t<=(h+c)/2){\n		   System.out.println(2);continue;}\n		   long k=(h-t)/(2*t-h-c);\n		   long a=(long)Math.abs(k*(h+c)+h-t*(2*k+1));\n		   long b=(long)Math.abs((k+1)*(h+c)+h-t*(2*k+3));\n		   if(a*(2*k+3)<=b*(2*k+1)){\n		   System.out.println(2*k+1);continue;}\n		   System.out.println(2*k+3);\n		}\n    }\n},"binary search,math"
import java.util.*;\nimport java.io.*;\npublic class GFG {\n    public static void main (String[] args) {\n		Scanner sc=new Scanner(System.in);\n		PrintWriter out=new PrintWriter(System.out);\n		int t1=sc.nextInt();\n		while (t1-->0){ \n		   long h=sc.nextLong();\n		   long c=sc.nextLong();\n		   long t=sc.nextLong();\n		   if(t<=(h+c)/2){\n		   System.out.println(2);continue;}\n		   long k=(h-t)/(2*t-h-c);\n		   long a=(long)Math.abs(k*(h+c)+h-t*(2*k+1));\n		   long b=(long)Math.abs((k+1)*(h+c)+h-t*(2*k+3));\n		   if(a*(2*k+3)<=b*(2*k+1)){\n		   System.out.println(2*k+1);continue;}\n		   System.out.println(2*k+3);\n		}\n    }\n},"binary search,math"
import java.util.*;\nimport java.io.*;\npublic class GFG {\n    public static void main (String[] args) {\n		Scanner sc=new Scanner(System.in);\n		PrintWriter out=new PrintWriter(System.out);\n		int t1=sc.nextInt();\n		while (t1-->0){ \n		   long h=sc.nextLong();\n		   long c=sc.nextLong();\n		   long t=sc.nextLong();\n		   if(t<=(h+c)/2){\n		   System.out.println(2);continue;}\n		   long k=(h-t)/(2*t-h-c);\n		   long a=(long)Math.abs(k*(h+c)+h-t*(2*k+1));\n		   long b=(long)Math.abs((k+1)*(h+c)+h-t*(2*k+3));\n		   if(a*(2*k+3)<=b*(2*k+1)){\n		   System.out.println(2*k+1);continue;}\n		   System.out.println(2*k+3);\n		}\n    }\n},"binary search,math"
"//package cc;\nimport java.util.*;\npublic class Test {\nstatic int caly(int h,int c,int t)\n{\n	int ret;\n	ret=(h-t)/(2*t-h-c);\n	return ret;\n}\npublic static void main(String [] arsg)\n{\nScanner s=new Scanner(System.in);\nint t=s.nextInt();\n//Random r=new Random();\nwhile(t-->0)\n{\n	int h=s.nextInt();\n	int c=s.nextInt();\n	int temp=s.nextInt();\n	if(temp==(h+c)/2)\n	{\n		System.out.println(""2"");\n		continue;\n	}\n	\n	\n	int y=caly(h,c,temp);\n	if(y<0)\n	{System.out.println(""2"");\n	continue;\n	}int a=y;\n	int b=y+1;\n	if(Math.abs((y*(h+c)+h-temp*(2*y+1))*(2*y+3))<=Math.abs(((y+1)*(h+c)+h-temp*(2*y+3))*(2*y+1)))\n		System.out.println(2*y+1);\n	else\n		System.out.println(2*y+3);\n}\n\n}\n}\n","binary search,math"
"\nimport java.util.Scanner;\n\npublic class Main{\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();int n,m,a,b;\n		String s;\n		int ans=0;\n		while(t-->0) {\n			n=sc.nextInt();m=sc.nextInt();a=sc.nextInt();b=sc.nextInt();\n			ans=0;if(2*a<b)b=2*a;\n			for (int i =1; i <=n; i++) {\n				s=sc.next();\n				for (int j = 0; j <m; j++) {\n					if(s.charAt(j)=='.') {\n						if(j<m-1&&s.charAt(j+1)=='.') {\n							ans+=b;j++;\n						}else {\n							ans+=a;\n						}\n					}\n				}\n			}\n			System.out.println(ans);\n			\n		}\n	}\n}\n","brute force,dp,greedy,implementation,two pointers"
"\nimport java.util.Scanner;\n\npublic class Main{\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();int n,m,a,b;\n		String s;\n		int ans=0;\n		while(t-->0) {\n			n=sc.nextInt();m=sc.nextInt();a=sc.nextInt();b=sc.nextInt();\n			ans=0;if(2*a<b)b=2*a;\n			for (int i =1; i <=n; i++) {\n				s=sc.next();\n				for (int j = 0; j <m; j++) {\n					if(s.charAt(j)=='.') {\n						if(j<m-1&&s.charAt(j+1)=='.') {\n							ans+=b;j++;\n						}else {\n							ans+=a;\n						}\n					}\n				}\n			}\n			System.out.println(ans);\n			\n		}\n	}\n}\n","brute force,dp,greedy,implementation,two pointers"
"import java.util.*;\npublic class CF1359B{\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while(t-- != 0){\n			int n = sc.nextInt(),m = sc.nextInt(),x = sc.nextInt(),y=sc.nextInt();\n			int c=0;\n			for(int i=0;i<n;i++){\n				String s = sc.next();\n				for(int j=0;j<m;j++){\n					if(s.charAt(j)=='.'){\n						if(j+1<m && s.charAt(j+1)=='.'){\n							if(2*x<y){\n								c+=(2*x);\n							}else{\n								c+=y;\n							}\n							j++;\n						}else{\n							c+=x;\n						}\n					}\n				}\n			}\n			System.out.println(c);\n		}\n	}\n}","brute force,dp,greedy,implementation,two pointers"
//package cc;\nimport java.util.*;\npublic class Test {\n	\npublic static void main(String [] arsg)\n{\nScanner s=new Scanner(System.in);\nint t=s.nextInt();\n//Random r=new Random();\nwhile(t-->0)\n{\n	int n=s.nextInt();\n	int m=s.nextInt();\n	int x=s.nextInt();\n	int y=s.nextInt();\n	int sum=0;\n	if(2*x<y)\n		y=2*x;\n	for(int i=0;i<n;++i)\n	{\n		String c=s.next();\n		for(int j=0;j<m;++j)\n	  {  char tl=c.charAt(j);\n	     if(tl=='*')\n	    	 continue;\n	     int count=1;\n			while(j+1<m&&c.charAt(j+1)=='.')\n				{++count;++j;}\n			sum+=(count/2)*y+(count%2)*x;\n		}\n	}\n	System.out.println(sum);\n}\n\n}\n}\n,"brute force,dp,greedy,implementation,two pointers"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1353E extends PrintWriter {\n	CF1353E() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1353E o = new CF1353E(); o.main(); o.flush();\n	}\n\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int k = sc.nextInt();\n			byte[] cc = sc.next().getBytes();\n			int cnt1 = 0;\n			for (int i = 0; i < n; i++)\n				if (cc[i] == '1')\n					cnt1++;\n			int ans = cnt1;\n			for (int i = 0; i < k; i++) {\n				int x = 0, y = 0, z = 0;\n				for (int j = i; j < n; j += k) {\n					if (cc[j] == '0')\n						x++;\n					else\n						y++;\n					ans = Math.min(ans, x + z + cnt1 - y);\n					z = Math.min(z, y - x);\n				}\n			}\n			println(ans);\n		}\n	}\n}\n","brute force,dp,greedy"
"import java.util.*;\nimport java.io.*;\nimport java.math.*;\n // Compiler version JDK 11.0.2\n\n public class Dcoder\n {\n   \n   public static void main(String args[]) throws IOException\n   { \n    Scanner sc=new Scanner(System.in);\n    int t=sc.nextInt();\n    while(t-->0){\n      int n=sc.nextInt();\n      int k=sc.nextInt();\n    \n      String a=sc.next();\n      char c[]=a.toCharArray();\n      int count=0;\n      for(int i=0;i<n;i++){\n        if(c[i]=='1')\n        count++;\n      }\n      int ans=1000000000;\n      for(int i=0;i<k;i++){\n        int temp=0;\n        for(int j=i;j<n;j+=k){\n          if(c[j]=='1')\n          temp++;\n          else\n          temp--;\n          temp=Math.max(temp,0);\n          ans=Math.min(ans,count-temp);\n        }\n      }\n      System.out.println(ans);\n      }\n     \n   }\n   \n }\n    ","brute force,dp,greedy"
"import java.lang.*;\nimport java.util.*;\n\npublic class Z\n{\n	public static void main(String[] args)\n	{\n		Z ob=new Z();\n		Scanner sc=new Scanner(System.in);\n		int T=sc.nextInt();\n		String[] S=new String[T];\n		int[] K=new int[T];\n		int[] A=new int[T];\n		int N;\n		for(int i=0;i<T;i++)\n		{\n			N=sc.nextInt();\n			K[i]=sc.nextInt();\n			S[i]=new String(sc.next());\n			A[i]=ob.solve(S[i],K[i]);\n		}\n		for(int i=0;i<T;i++)\n			System.out.println(A[i]);\n	}\n	int solve(String S, int K)\n	{\n		int[] l=new int[S.length()];\n		int[] A=new int[S.length()];\n		int sum=0;\n		for(int i=0;i<S.length();i++)\n			l[i]=S.charAt(i)-'0';\n		int mx=0;\n		for(int i=0;i<A.length;i++)\n		{\n			sum=sum+l[i];\n			if(l[i]==1)\n				A[i]=1;\n			else\n				A[i]=-1;\n			if(K<=i)\n			{\n				A[i]=Math.max(A[i],A[i]+A[i-K]);\n			}\n			//System.out.println(""A[""+i+""] = ""+A[i]+"" l[""+i+""] = ""+l[i]);\n			mx=Math.max(mx,A[i]);\n		}\n		return sum-mx;\n	}\n}","brute force,dp,greedy"
"import java.util.Scanner;\n\npublic class Main{\n	public static int find(String s, int k)\n	{\n		int n = s.length();\n		int count[]=new int[n];\n		count[0] = ((s.charAt(0)=='1')?1:0);\n		for(int i=1;i<n;i++)\n			count[i] = count[i-1] + ((s.charAt(i)=='1')?1:0) ;\n		int min = Integer.MAX_VALUE;\n		int dp[]=new int[n];\n		for(int i=n-1;i>n-1-k;i--)\n		{\n			int curr = ((s.charAt(i)=='0')?1:0);\n			dp[i] = curr+count[n-1]-count[i];\n		}\n		for(int i=n-1-k;i>=0;i--)\n		{\n			int curr = ((s.charAt(i)=='0')?1:0);\n			dp[i] = Math.min(curr + count[n-1]-count[i], curr + dp[i+k] + count[i+k-1]-count[i]);\n		}\n		min = dp[0];\n		for (int i = 1;i<n;i++)\n		{\n			min =  Math.min(min, dp[i]+count[i-1]);\n		}\n		return Math.min(min, count[n-1]);\n	}\n	public static void main(String[] args) {\n		Scanner s= new Scanner(System.in);\n		int t=s.nextInt();\n		while(t-->0)\n		{\n			int n=s.nextInt();\n			int k=s.nextInt();\n			String input = s.next();\n			System.out.println(find(input, k));\n		}\n	}\n}\n\n","brute force,dp,greedy"
"import java.util.Scanner;\npublic class O\n{\n	public static void main(String[] args)\n	{\n		Scanner S=new Scanner(System.in);\n		int t,n,k;\n		t=S.nextInt();\n		while(t-->0)\n		{\n			n=S.nextInt();\n			k=S.nextInt();\n			if(n%2==k%2&&n>=k)\n			{\n				System.out.println(""YES"");\n				for(int i=1;i<k;i++)\n					System.out.print(1+"" "");\n				System.out.println(n-k+1);\n			}\n			else if(n%2==0&&n>=2*k)\n			{\n				System.out.println(""YES"");\n				for(int i=1;i<k;i++)\n					System.out.print(2+"" "");\n				System.out.println(n-2*k+2);\n			}\n			else\n				System.out.println(""NO"");\n		}\n	}\n}","constructive algorithms,math"
"import java.util.Scanner;\npublic class O\n{\n	public static void main(String[] args)\n	{\n		Scanner S=new Scanner(System.in);\n		int t,n,k;\n		t=S.nextInt();\n		while(t-->0)\n		{\n			n=S.nextInt();\n			k=S.nextInt();\n			if(n%2==k%2&&n>=k)\n			{\n				System.out.println(""YES"");\n				for(int i=1;i<k;i++)\n					System.out.print(1+"" "");\n				System.out.println(n-k+1);\n			}\n			else if(n%2==0&&n>=2*k)\n			{\n				System.out.println(""YES"");\n				for(int i=1;i<k;i++)\n					System.out.print(2+"" "");\n				System.out.println(n-2*k+2);\n			}\n			else\n				System.out.println(""NO"");\n		}\n	}\n}","constructive algorithms,math"
"import java.util.Scanner;\npublic class O\n{\n	public static void main(String[] args)\n	{\n		Scanner S=new Scanner(System.in);\n		int t,n,k;\n		t=S.nextInt();\n		while(t-->0)\n		{\n			n=S.nextInt();\n			k=S.nextInt();\n			if(n%2==k%2&&n>=k)\n			{\n				System.out.println(""YES"");\n				for(int i=1;i<k;i++)\n					System.out.print(1+"" "");\n				System.out.println(n-k+1);\n			}\n			else if(n%2==0&&n>=2*k)\n			{\n				System.out.println(""YES"");\n				for(int i=1;i<k;i++)\n					System.out.print(2+"" "");\n				System.out.println(n-2*k+2);\n			}\n			else\n				System.out.println(""NO"");\n		}\n	}\n}","constructive algorithms,math"
"import java.util.Scanner;\npublic class O\n{\n	public static void main(String[] args)\n	{\n		Scanner S=new Scanner(System.in);\n		int t,n,k;\n		t=S.nextInt();\n		while(t-->0)\n		{\n			n=S.nextInt();\n			k=S.nextInt();\n			if(n%2==k%2&&n>=k)\n			{\n				System.out.println(""YES"");\n				for(int i=1;i<k;i++)\n					System.out.print(1+"" "");\n				System.out.println(n-k+1);\n			}\n			else if(n%2==0&&n>=2*k)\n			{\n				System.out.println(""YES"");\n				for(int i=1;i<k;i++)\n					System.out.print(2+"" "");\n				System.out.println(n-2*k+2);\n			}\n			else\n				System.out.println(""NO"");\n		}\n	}\n}","constructive algorithms,math"
"import java.util.*;\npublic class PhoenixandScience {\n	public static void main (String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0)\n		{\n		    int n=sc.nextInt();\n		    ArrayList<Integer> al=new ArrayList<Integer>();\n		    for(int i=1;i<=n;i=i*2)\n		    {\n		        al.add(i);\n		        n-=i;\n		    }\n		    if(n>0)\n		    al.add(n);\n		    Collections.sort(al);\n		   System.out.println(al.size()-1);\n		   for(int i=1;i<al.size();i++)\n		   {\n		       System.out.print(al.get(i)-al.get(i-1)+"" "");\n		   }\n		   System.out.println();\n		}\n	}\n}","binary search,constructive algorithms,greedy,implementation,math"
"import java.util.*;\npublic class PhoenixandScience {\n	public static void main (String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0)\n		{\n		    int n=sc.nextInt();\n		    ArrayList<Integer> al=new ArrayList<Integer>();\n		    for(int i=1;i<=n;i=i*2)\n		    {\n		        al.add(i);\n		        n-=i;\n		    }\n		    if(n>0)\n		    al.add(n);\n		    Collections.sort(al);\n		   System.out.println(al.size()-1);\n		   for(int i=1;i<al.size();i++)\n		   {\n		       System.out.print(al.get(i)-al.get(i-1)+"" "");\n		   }\n		   System.out.println();\n		}\n	}\n}","binary search,constructive algorithms,greedy,implementation,math"
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n \npublic class Main {\n	public static void main (String[] args) {\n	Scanner sc = new Scanner(System.in);\n	int t = sc.nextInt();\n	while(t!=0){\n	     t--;\n	     int n = sc.nextInt();\n	    ArrayList<Integer> a = new ArrayList<Integer>();\n	    for(int i =1;i<=n;i*=2){\n	        a.add(i);\n	        n-=i;\n	    }\n	    if(n>0){a.add(n);\n	        Collections.sort(a);\n	        \n	    }\n	    System.out.println(a.size()-1);\n	    for(int i=1;i<a.size();i++){\n	        System.out.print((a.get(i)-a.get(i-1))+"" "");\n	    }\n	    System.out.println("""");\n	}\n	}\n}","binary search,constructive algorithms,greedy,implementation,math"
"// upsolve with kaiboy\n// https://codeforces.com/contest/1348/submission/78710413 (rainboy)\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1348D extends PrintWriter {\n	CF1348D() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1348D o = new CF1348D(); o.main(); o.flush();\n	}\n\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int d = 0;\n			while (1 << d + 1 <= n)\n				d++;\n			println(d);\n			int k = 1;\n			for (int i = 0; i < d; i++) {\n				n -= k;\n				int k_ = Math.min(k * 2, n / (d - i));\n				print(k_ - k + "" "");\n				k = k_;\n			}\n			println();\n		}\n	}\n}\n","binary search,constructive algorithms,greedy,implementation,math"
"import java.util.*;\n\npublic class Main{\n//public class P637C{\n	public static void main(String[] args){\n		Scanner scan = new Scanner(System.in);\n\n		int test = scan.nextInt();\n\n		while(test>0){\n			int n = scan.nextInt();\n\n			int[] a = new int[n];\n\n			a[0] = scan.nextInt();\n\n			boolean flag = false;\n\n			for(int i=1; i<n; i++){\n				a[i] = scan.nextInt();\n\n				if(a[i-1]<a[i] && a[i]!=(a[i-1]+1)){\n					//System.out.println(i);\n					flag = true;\n				}\n			}\n\n			if(flag)\n				System.out.println(""No"");\n			else\n				System.out.println(""Yes"");\n\n\n			test--;\n		}\n	}\n}","brute force,data structures,greedy,implementation"
"import java.math.*;\nimport java.io.*;\nimport java.util.*;\nimport java.awt.*;\n\npublic class Main  {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int t=sc.nextInt();\n        while(t-->0) {\n            int n=sc.nextInt();\n            int a=sc.nextInt();\n            boolean flag=true;\n            for(int i=1;i<n;i++) {\n                int b=sc.nextInt();\n                if(a<b && b-a>1)\n                flag=false;\n                a=b;\n            }\n            if(flag)\n            System.out.println(""Yes"");\n            else \n            System.out.println(""No"");\n        }\n        \n    }\n}\n","brute force,data structures,greedy,implementation"
"import java.util.*;\nimport java.io.*;\npublic class Codechef {\n    public static void main (String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        while(t-->0) {\n            int n = sc.nextInt();\n            int[] a = new int[n];\n            for(int i = 0; i<n; i++)\n                a[i] = sc.nextInt();\n            if(solve(a))\n                System.out.println(""Yes"");\n            else System.out.println(""No"");\n        }\n    }\n    static boolean solve(int[] a) {\n        for(int i = 1; i<a.length; i++) {\n            if(a[i-1]+1<a[i])\n                return false;\n        }\n        return true;\n    }\n}","brute force,data structures,greedy,implementation"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1340A extends PrintWriter {\n	CF1340A() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1340A o = new CF1340A(); o.main(); o.flush();\n	}\n\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int[] aa = new int[n];\n			for (int i = 0; i < n; i++)\n				aa[i] = sc.nextInt();\n			boolean yes = true;\n			int a = n + 1;\n			for (int i = 0, j; i < n; i = j) {\n				if (a < aa[i]) {\n					yes = false;\n					break;\n				}\n				a = aa[i];\n				j = i + 1;\n				while (j < n && aa[j] == aa[j - 1] + 1)\n					j++;\n			}\n			println(yes ? ""Yes"" : ""No"");\n		}\n	}\n}\n","brute force,data structures,greedy,implementation"
"import java.util.*;\nimport java.io.*;\n\npublic class C {\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		long t = in.nextInt();\n		long[] pw = new long[40], spw = new long[40];\n		pw[0] = 1;\n		spw[0] = 1;\n		for(int i = 1; i < 40; i++) {\n			pw[i] = pw[i - 1] * 4;\n			spw[i] = spw[i - 1] + pw[i];\n		}\n		for(int ti = 0; ti < t; ti++) {\n			long n = in.nextLong() + 2;\n			long n3 = n / 3, ni = n % 3;\n			int lb4 = (int)Math.floor(Math.log(n - 2) / Math.log(4));\n			if(lb4 != 0)\n				n3 += 2 * spw[lb4 - 1];\n\n			long tot = 0;\n			int i = 0;\n			while(n3 != 0) {\n				tot += (n3 % 4 == 0 ? 0 : (n3 % 4 + ni - 1) % 3 + 1) * pw[i];\n				n3 /= 4;\n				i++;\n			}\n\n			System.out.println(tot);\n		}\n	}\n}","bitmasks,brute force,constructive algorithms,divide and conquer,math"
"import java.util.*;\nimport java.io.*;\n\npublic class C {\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		long t = in.nextInt();\n		long[] pw = new long[40], spw = new long[40];\n		pw[0] = 1;\n		spw[0] = 1;\n		for(int i = 1; i < 40; i++) {\n			pw[i] = pw[i - 1] * 4;\n			spw[i] = spw[i - 1] + pw[i];\n		}\n		for(int ti = 0; ti < t; ti++) {\n			long n = in.nextLong() + 2;\n			long n3 = n / 3, ni = n % 3;\n			int lb4 = (int)Math.floor(Math.log(n - 2) / Math.log(4));\n			if(lb4 != 0)\n				n3 += 2 * spw[lb4 - 1];\n\n			long tot = 0;\n			int i = 0;\n			while(n3 != 0) {\n				tot += (n3 % 4 == 0 ? 0 : (n3 % 4 + ni - 1) % 3 + 1) * pw[i];\n				n3 /= 4;\n				i++;\n			}\n\n			System.out.println(tot);\n		}\n	}\n}","bitmasks,brute force,constructive algorithms,divide and conquer,math"
"\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n	static int cnt1,cnt2;\n	static void dfs(int u,int fa,int dep) {\n		if(a[u].size()==1) vis[u]=true;\n		depth[u]=dep;\n		\n		for(int i=0;i<a[u].size();i++) {\n			int x=(int)a[u].get(i);\n			if(x!=fa) dfs(x,u,dep+1);\n		}\n	}\n	static ArrayList[]a;\n	static int []depth;\n	static boolean []vis;\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		StringBuilder sb=new StringBuilder();\n		long []val= {0,2,3,1};\n		int t=sc.nextInt();\n		while(t-->0) {\n			long n=sc.nextLong();\n			if(n==1l) {\n				sb.append(""1\n"");\n				continue;\n			}\n			long pow2=1;\n			while(n>=pow2) pow2*=4;\n			pow2/=4;\n			long rem=(n-pow2)%3;\n			long div=(n-pow2)/3;\n			long ans1=pow2+div;\n			if(rem==0) {\n				sb.append(ans1).append(""\n"");\n				continue;\n			}\n			long ans=pow2*2;\n			pow2*=4;\n			while(div>0) {\n				while(div<pow2) pow2=pow2/4;\n				ans=ans+pow2*val[(int)(div/pow2)];\n				div=div%pow2;\n			}\n			if(rem%2==1) sb.append(ans).append(""\n"");\n			else sb.append(ans1^ans).append(""\n"");\n		}\n		System.out.println(sb);\n	}\n}","bitmasks,brute force,constructive algorithms,divide and conquer,math"
"import java.util.Scanner;\npublic class Solution {\n    static long solve1(long n)\n    {\n        long a=1;\n        while(n>=a)a*=4;\n        a/=4;\n        n-=a;\n        n/=3;\n        return a+n;\n    }\n    static long quad_search(long l,long r,long n)\n    {\n        if(l==r)return l;\n        long cnt=(r-l+1)/4;\n        long part=n/cnt;\n        if(part==0)return quad_search(l,l+cnt-1,n);\n        else if(part==3)return quad_search(l+cnt,l+2*cnt-1,n-part*cnt);\n        else if(part==1)return quad_search(l+2*cnt,l+3*cnt-1,n-part*cnt);\n        return quad_search(l+3*cnt,r,n-part*cnt);\n    }\n    static long solve2(long n)\n    {\n        long a=1;\n        while(n>=a)a*=4;\n        n-=a/4;\n        n/=3;\n        long l=a/2,r=a/2+a/4-1;\n        return quad_search(l,r,n);\n    }\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        long t=sc.nextLong();\n        while(t-->0)\n        {\n            long n=sc.nextLong();\n            if(n%3==1)System.out.println(solve1(n));\n            else if(n%3==2)System.out.println(solve2(n));\n            else System.out.println(solve1(n-2)^solve2(n-1));\n        }\n    }\n}\n","bitmasks,brute force,constructive algorithms,divide and conquer,math"
"import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1336d {\n\n    public static void main(String[] args) throws IOException {\n        int n = ri(), t = rni(), s = ni(), ds[] = new int[n], dt[] = new int[n], a[] = new int[n];\n        // int[] tryx = {2, 1, 3, 0, 2};\n        // t = calct(tryx);\n        // s = calcs(tryx);\n        for(int i = n - 1; i >= 0; --i) {\n            qry(i > 2 ? i : i % 2 + 1);\n            int nt = rni(), ns = ni();\n            // ++tryx[(i > 2 ? i : i % 2 + 1) - 1];\n            // int nt = calct(tryx), ns = calcs(tryx);\n            ds[i] = ns - s;\n            dt[i] = nt - t;\n            s = ns;\n            t = nt;\n        }\n        a[0] = floori(sqrt(dt[0] * 2));\n        a[2] = ds[0] - ds[2] - 1;\n        a[1] = ds[2] / (a[2] + 1);\n        a[3] = ds[1] / (a[2] + 1) - a[0] - 2;\n        for(int i = 4; i < n; ++i) {\n            a[i] = (ds[i - 1] - a[i - 4] * a[i - 3]) / (a[i - 1] + 1) - a[i - 3] - 1;\n        }\n        ++a[n - 1];\n        pr(""! "");\n        prln(a);\n        close();\n    }\n\n    static int calct(int[] a) {\n        int ans = 0;\n        for(int i : a) {\n            ans += i * (i - 1) * (i - 2) / 6;\n        }\n        return ans;\n    }\n\n    static int calcs(int[] a) {\n        int ans = 0;\n        for(int i = 0; i < a.length - 2; ++i) {\n            ans += a[i] * a[i + 1] * a[i + 2];\n        }\n        return ans;\n    }\n\n    static void qry(int i) {\n        pr(""+ "");\n        prln(i);\n        flush();\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e10\n    // LMAX ~= 9e18\n    \n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if(x.length == 1) return x[0]; if(x.length == 2) return min(x[0], x[1]); if(x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for(int i = 1; i < x.length; ++i) if(x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if(x.length == 1) return x[0]; if(x.length == 2) return min(x[0], x[1]); if(x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for(int i = 1; i < x.length; ++i) if(x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if(x.length == 1) return x[0]; if(x.length == 2) return max(x[0], x[1]); if(x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for(int i = 1; i < x.length; ++i) if(x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if(x.length == 1) return x[0]; if(x.length == 2) return max(x[0], x[1]); if(x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for(int i = 1; i < x.length; ++i) if(x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if(a == 0) return 0; int ans = 1; while(b > 0) {if((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if(a == 0) return 0; long ans = 1; while(b > 0) {if((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int floori(double d) {return (int)d;}\n    static int ceili(double d) {return (int)ceil(d);}\n    static long floorl(double d) {return (long)d;}\n    static long ceill(double d) {return (long)ceil(d);}\n    static int randInt(int min, int max) {return rand.nextInt(max - min + 1) + min;}\n    // array util\n    static void reverse(int[] a) {for(int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for(int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for(int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for(int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static <T> void reverse(T[] a) {for(int i = 0, n = a.length, half = n / 2; i < half; ++i) {T swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for(int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for(int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for(int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(char[] a) {int n = a.length - 1; for(int i = 0; i < n; ++i) {int ind = randInt(i, n); char swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static <T> void shuffle(T[] a) {int n = a.length - 1; for(int i = 0; i < n; ++i) {int ind = randInt(i, n); T swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static void rsort(char[] a) {shuffle(a); sort(a);}\n    static <T> void rsort(T[] a) {shuffle(a); sort(a);}\n    // graph util\n    static List<List<Integer>> graph(int n) {List<List<Integer>> g = new ArrayList<>(); for(int i = 0; i < n; ++i) g.add(new ArrayList<>()); return g;}\n    static void connect(List<List<Integer>> g, int u, int v) {g.get(u).add(v); g.get(v).add(u);}\n    static void connectDirected(List<List<Integer>> g, int u, int v) {g.get(u).add(v);};\n    // input\n    static void r() throws IOException {input = new StringTokenizer(__in.readLine());}\n    static int ri() throws IOException {return Integer.parseInt(__in.readLine());}\n    static long rl() throws IOException {return Long.parseLong(__in.readLine());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Integer.parseInt(input.nextToken()); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Integer.parseInt(input.nextToken()) - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Long.parseLong(input.nextToken()); return a;}\n    static char[] rcha() throws IOException {return __in.readLine().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static int rni() throws IOException {input = new StringTokenizer(__in.readLine()); return Integer.parseInt(input.nextToken());}\n    static int ni() {return Integer.parseInt(input.nextToken());}\n    static long rnl() throws IOException {input = new StringTokenizer(__in.readLine()); return Long.parseLong(input.nextToken());}\n    static long nl() {return Long.parseLong(input.nextToken());}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {__out.println(""yes"");}\n    static void pry() {__out.println(""Yes"");}\n    static void prY() {__out.println(""YES"");}\n    static void prno() {__out.println(""no"");}\n    static void prn() {__out.println(""No"");}\n    static void prN() {__out.println(""NO"");}\n    static void pryesno(boolean b) {__out.println(b ? ""yes"" : ""no"");};\n    static void pryn(boolean b) {__out.println(b ? ""Yes"" : ""No"");}\n    static void prYN(boolean b) {__out.println(b ? ""YES"" : ""NO"");}\n    static void prln(int... a) {for(int i = 0, len = a.length - 1; i < len; __out.print(a[i]), __out.print(' '), ++i); __out.println(a[a.length - 1]);}\n    static void prln(long... a) {for(int i = 0, len = a.length - 1; i < len; __out.print(a[i]), __out.print(' '), ++i); __out.println(a[a.length - 1]);}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for(int i = 0; i < n; __out.print(iter.next()), __out.print(' '), ++i); __out.println(iter.next());}\n    static void h() {__out.println(""hlfd"");}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}\n}","constructive algorithms,interactive"
"import java.io.*;\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\npublic class template {\n	public static void main(String[] args) throws Exception {\n		new template().run();\n	}\n	PrintWriter out;\n	FastScanner f;\n	int a, b, c, d;\n	public void run() throws Exception {\n		f = new FastScanner();\n		out = new PrintWriter(System.out);\n		int n = f.nextInt();\n		a = f.nextInt();\n		b = f.nextInt();\n		int[] arr = new int[n];\n		Stack<Integer> s = new Stack<>();\n		for(int i = n-2; i >= 2; i--) {\n			query(i);\n			s.add(d);\n		}\n		query(0);\n		int bc1 = d;\n		query(1);\n		int d2 = d;\n		query(0);\n		int b1c1 = d;\n		if(c == 0) {\n			arr[0] = 2+c;\n		} else {\n			arr[0] = (int) Math.ceil(Math.sqrt(c*2))+1;\n		}\n		arr[2] = b1c1-bc1;\n		arr[1] = b1c1/arr[2];\n		arr[0]--;\n		arr[1]--;\n		arr[3] = (d2-arr[0]*arr[2])/arr[2];\n		arr[0]--;\n		for(int i = 4; i < n; i++) {\n			d = s.pop();\n			arr[i] = (d-arr[i-4]*arr[i-3]-arr[i-3]*arr[i-1])/arr[i-1];\n			arr[i-2]--;\n		}\n		arr[n-2]--;\n		out.print(""!"");\n		for(int i = 0; i < n; i++)\n			out.print("" "" + arr[i]);\n		out.flush();\n	}\n	public void query(int i) {\n		out.println(""+ "" + (i+1));\n		out.flush();\n		int a = f.nextInt();\n		int b = f.nextInt();\n		c = a-this.a;\n		d = b-this.b;\n		this.a = a;\n		this.b = b;\n	}\n	class Pair implements Comparable<Pair> {\n		int a, b;\n		public Pair(int a, int b) {\n			this.a = a;\n			this.b = b;\n		}\n		public int compareTo(Pair p) {\n			return -Integer.compare(a, p.a);\n		}\n	}\n    static class FastScanner {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public FastScanner() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n        	return Long.parseLong(next());\n        }\n        public double nextDouble() {\n        	return Double.parseDouble(next());\n        }\n        public String nextLine() {\n        	try {\n        		return reader.readLine();\n        	} catch(IOException e) {\n        		throw new RuntimeException(e);\n        	}\n        }\n    }\n}","constructive algorithms,interactive"
"import java.io.*;\nimport java.util.*;\n\npublic class F\n{\n    PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer tok;\n\n    public void go() throws IOException\n    {\n        ntok();\n        int n = ipar();\n        ntok();\n        HashMap<Integer, Integer> invNc2 = new HashMap<>();\n        for (int i = 2; i < 1000; i++) {\n            invNc2.put(i*(i-1)/2, i);\n        }\n        int[][] state = new int[n+1][2];\n        int[] ans = new int[n+1];\n        Arrays.fill(ans, -1);\n        state[0][0] = ipar();\n        state[0][1] = ipar();\n        for (int i = n-1; i >= 3; i--) {\n            out.printf(""+ %d%n"", i);\n            out.flush();\n            ntok();\n            state[n-i][0] = ipar();\n            state[n-i][1] = ipar();\n        }\n        out.println(""+ 1"");\n        out.println(""+ 2"");\n        out.println(""+ 1"");\n        out.flush();\n        ntok();\n        state[n-2][0] = ipar();\n        state[n-2][1] = ipar();\n        ntok();\n        state[n-1][0] = ipar();\n        state[n-1][1] = ipar();\n        ntok();\n        state[n][0] = ipar();\n        state[n][1] = ipar();\n\n        if (state[n][0] - state[n-1][0] == 0) {\n            ans[1] = 0;\n        } else {\n            ans[1] = invNc2.get(state[n][0] - state[n-1][0])-1;\n        }\n        // System.out.println(ans[1]);\n        int prod1 = state[n-2][1] - state[n-3][1];\n        int prod2 = state[n][1] - state[n-1][1];\n        if (prod1 == 0) {\n            ans[2] = 0;\n        } else if (state[n-1][0] - state[n-2][0] == 0) {\n            ans[2] = 1;\n        } else {\n            ans[2] = invNc2.get(state[n-1][0] - state[n-2][0]);\n        }\n        // System.out.println(ans[2]);\n        ans[3] = (state[n][1] - state[n-1][1]) / (ans[2] + 1) - 1;\n        // System.out.println(ans[3]);\n        if (n == 4) {\n            ans[4] = (state[n-1][1] - state[n-2][1] - (ans[1]+1)*(ans[3]+1)) / (ans[3]+1);\n        } else {\n            ans[4] = (state[n-1][1] - state[n-2][1] - (ans[1]+1)*(ans[3]+1)) / (ans[3]+1) - 1;\n        }\n        // System.out.println(ans[4]);\n        for (int i = 5; i <= n; i++) {\n            int[] delta = {state[n-i+2][0] - state[n-i+1][0], state[n-i+2][1] - state[n-i+1][1]};\n            ans[i] = (delta[1] - ans[i-4]*ans[i-3] - ans[i-3]*(ans[i-1]+1)) / (ans[i-1]+1) - 1;\n            if (i == n) {\n                ans[i]++;\n            }\n            // System.out.println(ans[i]);\n        }\n        out.print(""!"");\n        for (int i = 1; i <= n; i++) {\n            out.printf("" %d"", ans[i]);\n        }\n        out.println();\n\n        out.flush();\n        in.close();\n    }\n\n    public void ntok() throws IOException\n    {\n        tok = new StringTokenizer(in.readLine());\n    }\n\n    public int ipar()\n    {\n        return Integer.parseInt(tok.nextToken());\n    }\n\n    public int[] iapar(int n)\n    {\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            arr[i] = ipar();\n        }\n        return arr;\n    }\n\n    public long lpar()\n    {\n        return Long.parseLong(tok.nextToken());\n    }\n\n    public long[] lapar(int n)\n    {\n        long[] arr = new long[n];\n        for (int i = 0; i < n; i++)\n        {\n            arr[i] = lpar();\n        }\n        return arr;\n    }\n\n    public double dpar()\n    {\n        return Double.parseDouble(tok.nextToken());\n    }\n\n    public String spar()\n    {\n        return tok.nextToken();\n    }\n\n    public static void main(String[] args) throws IOException\n    {\n        new F().go();\n    }\n}\n","constructive algorithms,interactive"
"import java.util.*;\npublic class cf633div2B {\npublic static void main(String[] args) {\nScanner sc=new Scanner(System.in);\nint t=sc.nextInt();\nfor(int j=1;j<=t;j++)\n{int n=sc.nextInt();\nint a[]=new int[n];\nfor(int i=0;i<n;i++)\na[i]=sc.nextInt();\nint b[]=new int[n];\nfor(int i=0;i<n;i++)\nb[i]=sc.nextInt();int pos=0,neg=0,f=0;\nfor(int i=0;i<n;i++)\n{if((b[i]>a[i] && pos==0)||(b[i]<a[i] && neg==0))\nf=1;\nif(a[i]==1)\npos=1;\nelse if(a[i]==-1)\nneg=1;}\nif(f==1)\nSystem.out.println(""no"");\nelse \nSystem.out.println(""yes"");}\nsc.close();\n}    \n}    \n","greedy,implementation"
"\nimport java.util.Scanner;\n\npublic class Main {\n\n	public static void main(String[] args) \n	{\n		Scanner scan = new Scanner(System.in);\n		int t = scan.nextInt();\n		while(t-->0)\n		{\n			int n = scan.nextInt();\n			int a[] = new int[n], b[] = new int[n];\n			for(int i=0;i<n;i++)a[i]=scan.nextInt();\n			boolean menos = false, mas = false,Si=true;;\n			for(int i=0;i<n;i++)\n			{\n				int aux = scan.nextInt();\n				if((aux<a[i] && !menos) || (aux>a[i] && !mas))Si = false;\n				if(a[i]==-1)menos= true;\n				if(a[i]==1) mas = true;\n			}\n			if(Si)System.out.println(""YES"");\n			else System.out.println(""NO"");\n		}\n	}\n\n}\n","greedy,implementation"
"import java.util.Scanner;\n\npublic class kind_anton {\n	public static void main(String args[]) {\n		Scanner input = new Scanner(System.in);\n		int t = input.nextInt();\n		while(t-- > 0) {\n			int n = input.nextInt(), p = 0, r = 1, neg = 0;\n			int ara[] = new int[n];\n			int num[] = new int[n];\n	 		for(int x = 0; x < n; x++) ara[x] = input.nextInt();\n	 		for(int x = 0; x < n; x++) {\n	 			num[x] = input.nextInt();\n	 			if(num[x] > ara[x] && p == 0) r = 0;\n	 			else if(num[x] < ara[x] && neg == 0) r = 0;\n	 			\n	 			if(ara[x] > 0) p = 1;\n	 			else if(ara[x] < 0) neg = 1;\n	 		}\n	 		if(r == 1) System.out.println(""YES\n"");\n	 		else System.out.println(""NO\n"");\n		}\n	}\n}\n","greedy,implementation"
"import java.util.HashSet;\nimport java.util.Scanner;\n\npublic class CR632B {\n	\n	public static void main(String args[]) {\n		Scanner in=new Scanner (System.in);\n		int t=in.nextInt();\n		while(--t>=0) {\n			HashSet<Integer> hset=new HashSet<>();\n			int n=in.nextInt();\n			int a[]=new int[n];\n			int b[]=new int[n];\n			for(int i=0;i<n;i++)\n				a[i]=in.nextInt();\n			for(int i=0;i<n;i++)\n				b[i]=in.nextInt();\n			\n			int flag=0;\n			for(int i=0;i<n;i++) {\n				if((a[i]>b[i] && !hset.contains(-1)) || (a[i]<b[i] && !hset.contains(1))) {\n					flag=1;\n					break;\n				}\n				hset.add(a[i]);\n			}\n			if(flag==1)\n				System.out.println(""NO"");\n			else\n				System.out.println(""YES"");\n		}\n	}\n	\n\n}\n","greedy,implementation"
"import java.util.*;\nimport java.io.*;\n \npublic class A {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while(t-->0) {\n			int a = sc.nextInt(), b = sc.nextInt(), c = sc.nextInt(), d = sc.nextInt();\n			int x = sc.nextInt(), y = sc.nextInt(), x1 = sc.nextInt(), y1 = sc.nextInt(), x2 = sc.nextInt(), y2 = sc.nextInt();\n			x += (-a+b);\n			y += (-c+d);\n			if(x>=x1 && x<=x2 && y>=y1 && y<=y2&&(x2>x1||a+b==0)&&(y2>y1 ||c+d==0)){\n				System.out.println(""Yes"");\n			} else{\n				System.out.println(""No"");\n			}\n		}\n	}\n}","greedy,implementation,math"
"import java.util.*;\npublic class Main{\n	public static void main(String args[]){\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while(t-- > 0){\n			int a = sc.nextInt(), b = sc.nextInt(), c = sc.nextInt(), d = sc.nextInt();\n			int x = sc.nextInt(), y = sc.nextInt(), x1 = sc.nextInt(), y1 = sc.nextInt();\n			int x2 = sc.nextInt(); int y2 = sc.nextInt();\n			if(a > (b+x-x1) || b > (a-x+x2) || c > (d+y-y1) || d > (c-y+y2) || (x1==x2 && (a>0||b>0)) || (y1==y2) && (d>0 || c>0))\n				System.out.println(""NO"");\n			else\n				System.out.println(""YES"");\n		}\n		// System.out.println("""");\n	}\n}","greedy,implementation,math"
"import java.util.*;\npublic class Main{\n    public static void main(String args[]){\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        while(t-- > 0){\n            int a = sc.nextInt(), b = sc.nextInt(), c = sc.nextInt(), d = sc.nextInt();\n            int x = sc.nextInt(), y = sc.nextInt(), x1 = sc.nextInt(), y1 = sc.nextInt();\n            int x2 = sc.nextInt(); int y2 = sc.nextInt();\n            System.out.println(a > (b+x-x1) || b > (a-x+x2) || c > (d+y-y1) || d > (c-y+y2) || (x1==x2 && (a>0||b>0)) || (y1==y2) && (d>0 || c>0)?""NO"":""YES"");\n          \n       }\n    }\n}\n","greedy,implementation,math"
"import java.util.Scanner;\n\npublic class temporary {\n    public static void main(String args[]){\n        Scanner sc=new Scanner(System.in);\n        int T =sc.nextInt();\n        for(int t=0;t<T;t++){\n            int a=sc.nextInt(),b=sc.nextInt(),c=sc.nextInt(),d=sc.nextInt();\n            int x=sc.nextInt(),y=sc.nextInt(),x1=sc.nextInt(),y1=sc.nextInt(),x2=sc.nextInt(),y2=sc.nextInt();\n            if(x-a+b>=x1 && x-a+b<=x2 && y-c+d>=y1 && y-c+d<=y2 && (x2>x1||a+b==0)&&(y2>y1||c+d==0))\n                System.out.println(""Yes"");\n            else\n                System.out.println(""No"");\n        }\n    }\n}\n","greedy,implementation,math"
"import java.io.*;\npublic class Chips\n{\n	public static void main(String args[])throws Exception\n	{\n		BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n		String s[]=bu.readLine().split("" "");\n		int n=Integer.parseInt(s[0]),m=Integer.parseInt(s[1]),k=Integer.parseInt(s[2]),i,j;\n		String st="""";\n		for(i=1;i<n;i++) st+=""U"";\n		for(i=1;i<m;i++) st+=""L"";\n		for(i=1;i<=m;i++)\n		{for(j=1;j<n;j++) \n		if(i%2==0) st+=""U"";\n		else st+=""D"";\n		st+=""R"";}\n		System.out.print(n-1+m-1+m*n+""\n""+st);\n	}\n}","constructive algorithms,implementation"
"import java.io.*;\npublic class Chips\n{\n	public static void main(String args[])throws Exception\n	{\n		BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n		String s[]=bu.readLine().split("" "");\n		int n=Integer.parseInt(s[0]),m=Integer.parseInt(s[1]),k=Integer.parseInt(s[2]),i,j;\n		String st="""";\n		for(i=1;i<n;i++) st+=""U"";\n		for(i=1;i<m;i++) st+=""L"";\n		for(i=1;i<=m;i++)\n		{for(j=1;j<n;j++) \n		if(i%2==0) st+=""U"";\n		else st+=""D"";\n		st+=""R"";}\n		System.out.print(n-1+m-1+m*n+""\n""+st);\n	}\n}","constructive algorithms,implementation"
"import java.io.*;\nimport java.util.*;\nimport java.lang.*;\n\npublic class Main\n{\n	public static void main(String[] args) {\n		Scanner input = new Scanner(System.in);\n		int n = input.nextInt();\n		int m = input.nextInt();\n		System.out.println(n - 1 + m - 1 + n * m);\n		for (int i = 1; i < n; i++) System.out.print(""U"");\n		for (int i = 1; i < m; i++) System.out.print(""L"");\n		for (int i = 0; i < n; i++) {\n		    if (i % 2 == 0) {\n		        for (int j = 0; j < m - 1; j++) System.out.print(""R"");\n		        System.out.print(""D"");\n		    } else {\n		        for (int j = 0; j < m - 1; j++) System.out.print(""L"");\n		        System.out.print(""D"");\n		    }\n		}\n	}\n}\n","constructive algorithms,implementation"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1327C extends PrintWriter {\n	CF1327C() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1327C o = new CF1327C(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		int k = (m - 1) + (n - 1) + n * m;\n		println(k);\n		char[] cc = new char[k];\n		k = 0;\n		for (int j = 0; j < m - 1; j++)\n			cc[k++] = 'L';\n		for (int i = 0; i < n - 1; i++)\n			cc[k++] = 'U';\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < m - 1; j++)\n				cc[k++] = i % 2 == 0 ? 'R' : 'L';\n			cc[k++] = 'D';\n		}\n		println(cc);\n	}\n}\n","constructive algorithms,implementation"
"import java.util.*;\npublic class java {\n \n	public static void main(String[] args) {\n		Scanner x = new Scanner(System.in);\n		int n=x.nextInt();\n		int bi=0;\n		StringBuilder s = new StringBuilder();\n		for (int i = 0; i < n; i++) {\n			int a=x.nextInt();\n			int sum=bi+a;\n			s.append(sum+"" "");\n			if(a>0)\n				bi=sum;\n		}\n		System.out.println(s);\n		}\n	}","implementation,math"
"import java.util.*;\npublic class java {\n \n	public static void main(String[] args) {\n		Scanner x = new Scanner(System.in);\n		int n=x.nextInt();\n		int bi=0;\n		StringBuilder s = new StringBuilder();\n		for (int i = 0; i < n; i++) {\n			int a=x.nextInt();\n			int sum=bi+a;\n			s.append(sum+"" "");\n			if(a>0)\n				bi=sum;\n		}\n		System.out.println(s);\n		}\n	}","implementation,math"
"import java.util.*;\npublic class Yo\n{\n \n	public static void main(String[] args)\n	{\n		Scanner x = new Scanner(System.in);\n		int n=x.nextInt();\n		int bi=0;\n		StringBuilder s = new StringBuilder();\n		for (int i = 0; i < n; i++)\n		{\n			int a=x.nextInt();\n			int sum=bi+a;\n			s.append(sum+"" "");\n			if(a>0)\n				bi=sum;\n		}\n		System.out.println(s);\n		}\n	}","implementation,math"
"import java.util.*;\npublic class Main {\n \n	public static void main(String[] args) {\n		Scanner x = new Scanner(System.in);\n		int n=x.nextInt();\n		int bi=0;\n		StringBuilder s = new StringBuilder();\n		for (int i = 0; i < n; i++) {\n			int a=x.nextInt();\n			int sum=bi+a;\n			s.append(sum+"" "");\n			if(a>0){\n			 bi=sum;\n			}\n		}\n		System.out.println(s);\n		}\n	}","implementation,math"
"import java.util.*;\npublic class Portions {\n	\n	public static int parts(int a, int b, int c) {\n		int count = 0;\n		if (a!=0) {\n			count++;a--;\n		}\n		if (c!=0) {\n			count++;c--;\n		}\n		if (b!=0) {\n			count++;b--;\n		}\n		if (a!=0 && b!=0) {\n			count++;\n			a--;b--;\n		}\n		if (a!=0 && c!=0) {\n			count++;\n			a--;c--;\n		}\n		if (c!=0 && b!=0) {\n			count++;\n			c--;b--;\n		}\n		\n		if (a!=0 && b!=0 && c!=0) {\n			count++;\n		}\n		return count;\n	}\n	\n	public static void main (String[] args) {\n		Scanner m = new Scanner(System.in);\n		int n = m.nextInt();\n		int[] arr = new int[3];\n		for (int i=0; i<n; i++) {\n			arr[0]= m.nextInt();;\n			arr[1]= m.nextInt();;\n			arr[2]= m.nextInt();;\n			Arrays.sort(arr);\n			System.out.println(parts(arr[2],arr[1],arr[0]));\n		}\n	}\n\n}\n","brute force,greedy,implementation"
"import java.util.*;\npublic class Portions {\n	\n	public static int parts(int a, int b, int c) {\n		int count = 0;\n		if (a!=0) {\n			count++;a--;\n		}\n		if (c!=0) {\n			count++;c--;\n		}\n		if (b!=0) {\n			count++;b--;\n		}\n		if (a!=0 && b!=0) {\n			count++;\n			a--;b--;\n		}\n		if (a!=0 && c!=0) {\n			count++;\n			a--;c--;\n		}\n		if (c!=0 && b!=0) {\n			count++;\n			c--;b--;\n		}\n		\n		if (a!=0 && b!=0 && c!=0) {\n			count++;\n		}\n		return count;\n	}\n	\n	public static void main (String[] args) {\n		Scanner m = new Scanner(System.in);\n		int n = m.nextInt();\n		int[] arr = new int[3];\n		for (int i=0; i<n; i++) {\n			arr[0]= m.nextInt();;\n			arr[1]= m.nextInt();;\n			arr[2]= m.nextInt();;\n			Arrays.sort(arr);\n			System.out.println(parts(arr[2],arr[1],arr[0]));\n		}\n	}\n\n}\n","brute force,greedy,implementation"
"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class CR622A {\n	public static int parts(int a, int b, int c) {\n		int count = 0;\n		if (a!=0) {\n			count++;a--;\n		}\n		if (c!=0) {\n			count++;c--;\n		}\n		if (b!=0) {\n			count++;b--;\n		}\n		if (a!=0 && b!=0) {\n			count++;\n			a--;b--;\n		}\n		if (a!=0 && c!=0) {\n			count++;\n			a--;c--;\n		}\n		if (c!=0 && b!=0) {\n			count++;\n			c--;b--;\n		}\n		\n		if (a!=0 && b!=0 && c!=0) {\n			count++;\n		}\n		return count;\n	}\n	\n	public static void main (String[] args) {\n		Scanner m = new Scanner(System.in);\n		int n = m.nextInt();\n		int[] arr = new int[3];\n		for (int i=0; i<n; i++) {\n			arr[0]= m.nextInt();;\n			arr[1]= m.nextInt();;\n			arr[2]= m.nextInt();;\n			Arrays.sort(arr);\n			System.out.println(parts(arr[2],arr[1],arr[0]));\n		}\n	}\n \n}\n","brute force,greedy,implementation"
"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class CR622A {\n	public static int parts(int a, int b, int c) {\n		int count = 0;\n		if (a!=0) {\n			count++;a--;\n		}\n		if (c!=0) {\n			count++;c--;\n		}\n		if (b!=0) {\n			count++;b--;\n		}\n		if (a!=0 && b!=0) {\n			count++;\n			a--;b--;\n		}\n		if (a!=0 && c!=0) {\n			count++;\n			a--;c--;\n		}\n		if (c!=0 && b!=0) {\n			count++;\n			c--;b--;\n		}\n		\n		if (a!=0 && b!=0 && c!=0) {\n			count++;\n		}\n		return count;\n	}\n	\n	public static void main (String[] args) {\n		Scanner m = new Scanner(System.in);\n		int n = m.nextInt();\n		int[] arr = new int[3];\n		for (int i=0; i<n; i++) {\n			arr[0]= m.nextInt();;\n			arr[1]= m.nextInt();;\n			arr[2]= m.nextInt();;\n			Arrays.sort(arr);\n			System.out.println(parts(arr[2],arr[1],arr[0]));\n		}\n	}\n \n}\n","brute force,greedy,implementation"
"import java.util.Scanner;\n\npublic class ayoubsFunction {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int T = sc.nextInt();\n		StringBuilder finAns = new StringBuilder();\n		while (--T >= 0) {\n			long n = sc.nextLong(), m = sc.nextLong();\n			long z = n - m;\n			long g = m + 1;\n			long k = z / g;\n			long ans = ((n * (n + 1)) / 2) - (((k * (k + 1)) / 2) * g) - ((k + 1) * (z % g));\n			finAns.append(ans + ""\n"");\n		}\n		System.out.println(finAns);\n		sc.close();\n	}\n}\n","binary search,combinatorics,greedy,math,strings"
import java.io.*;\nimport java.util.*;\n\npublic class CF1301C extends PrintWriter {\n	CF1301C() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1301C o = new CF1301C(); o.main(); o.flush();\n	}\n\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int m = sc.nextInt();\n			int q = (n - m) / (m + 1);\n			int r = (n - m) % (m + 1);\n			long ans = (long) n * (n + 1) / 2;\n			long a0 = (long) q * (q + 1) / 2;\n			long a1 = (long) (q + 1) * (q + 2) / 2;\n			ans -= (m + 1 - r) * a0 + r * a1;\n			println(ans);\n		}\n	}\n}\n,"binary search,combinatorics,greedy,math,strings"
"import java.util.*;\nimport java.io.*;\npublic class C {\n	public static void main(String[] args) throws NumberFormatException, IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter pw = new PrintWriter(System.out);\n		int t = Integer.parseInt(br.readLine());\n		while(t-->0) {\n			String[] inp = br.readLine().split("" "");\n			long n = Integer.parseInt(inp[0]);\n			long m = Integer.parseInt(inp[1]);\n			long q = m+1;\n			long zeros = (n-m)/q;\n			long rem = (n-m)%q;\n			long ans = n*(n+1)/2;\n			ans-=(zeros*(zeros+1)/2)*(q-rem);\n			ans-=((zeros+1)*(zeros+2)/2)*rem;\n			pw.println(ans);\n			\n		}\n		pw.flush();\n	}\n}\n","binary search,combinatorics,greedy,math,strings"
\nimport java.util.*;\nimport java.io.*;\n\npublic class AyoubFunction_div2_619 {\n\n	public static void main(String[] args) throws IOException {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter out=new PrintWriter(System.out);\n		\n		StringTokenizer st=new StringTokenizer(br.readLine());\n		int t=Integer.parseInt(st.nextToken());\n		while(t-->0) {\n			st=new StringTokenizer(br.readLine());\n			long n=Integer.parseInt(st.nextToken());\n			long m=Integer.parseInt(st.nextToken());\n			long g=m+1;\n			long z=n-m;\n			long pkka=z/g;\n			long addon=z%g;\n			long val=((n*(n+1))/2)-(((pkka*(pkka+1))/2)*g)-((pkka+1)*(addon));\n			out.println(val);\n		}\n		out.close();\n	}\n\n}\n,"binary search,combinatorics,greedy,math,strings"
"// Coached by rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1295F extends PrintWriter {\n	CF1295F() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1295F o = new CF1295F(); o.main(); o.flush();\n	}\n\n	static final int MD = 998244353;\n	int x_, y_;\n	void gcd_(int a, int b) {\n		if (b == 0) {\n			x_ = 1; y_ = 0;\n		} else {\n			gcd_(b, a % b);\n			int t = x_ - a / b * y_; x_ = y_; y_ = t;\n		}\n	}\n	int inv(int a) {\n		gcd_(a, MD);\n		if (x_ < 0)\n			x_ += MD;\n		return x_;\n	}\n	void main() {\n		int n = sc.nextInt();\n		int[] ll = new int[n], rr = new int[n], xx = new int[n * 2];\n		int[] vv = new int[n + 1]; long v = 1;\n		for (int i = 1; i <= n; i++)\n			vv[i] = inv(i);\n		for (int i = 0; i < n; i++) {\n			int l = sc.nextInt();\n			int r = sc.nextInt() + 1;\n			xx[i << 1    ] = ll[i] = l;\n			xx[i << 1 | 1] = rr[i] = r;\n			v = v * inv(r - l) % MD;\n		}\n		Arrays.sort(xx);\n		int m = 0;\n		for (int i = 0; i < n * 2; i++)\n			if (m == 0 || xx[m - 1] != xx[i])\n				xx[m++] = xx[i];\n		int[][] dp = new int[n + 1][m]; dp[0][m - 1] = 1;\n		for (int i = 0; i < n; i++)\n			for (int j = m - 1; j > 0; j--) {\n				int x = dp[i][j];\n				if (x == 0)\n					continue;\n				for (int j_ = j - 1; j_ >= 0; j_--) {\n					int l = xx[j_], r = xx[j_ + 1];\n					long c = 1;\n					for (int i_ = i; i_ < n && ll[i_] <= l && r <= rr[i_]; i_++) {\n						// i_ - i + 1 balls in r - l urns\n						// choose(i_ - i + 1 + r - l - 1, i_ - i + 1)\n						c = c * (i_ - i + r - l) % MD * vv[i_ - i + 1] % MD;\n						dp[i_ + 1][j_] = (int) ((dp[i_ + 1][j_] + x * c) % MD);\n					}\n				}\n			}\n		long ans = 0;\n		for (int j = 0; j < m - 1; j++)\n			ans += dp[n][j];\n		println(ans % MD * v % MD);\n	}\n}\n","combinatorics,dp,probabilities"
"\nimport java.util.*;\nimport java.io.*;\n\npublic class Good {\n    public static void main(String [] args) {\n        Solver s = new Solver();\n        s.solve();\n    }\n}\n\nclass Solver {\n    Reader in = new Reader ();\n    Writer out = new Writer ();\n    int l[], r[];\n    int n;\n    int b[], e[];\n    int range;\n    long invfac[];\n\n    final int inf = 1000000000;\n    final int mod = 998244353;\n\n    long power(long b, int e) {\n        if(e == 0) return 1;\n        if(e % 2 == 1) return (power(b, e - 1) * b) % mod;\n        long m = power(b, e >> 1);\n        return (m * m) % mod;\n    }\n\n    long nCr(int n, int k) {\n        long ans = invfac[k];\n        for(int i = n; i > n - k; i--) {\n            ans = (ans * i) % mod;\n        }\n        return ans;\n    }\n    class Data {\n        int value, type;\n        Data () {}\n        Data (int value, int type) {\n            this.value = value;\n            this.type = type;\n        }\n        boolean equalTo(Data t) {\n            return (value == t.value && type == t.type);\n        }\n    }\n    long mem[][];\n    long dp(int pos, int cur) {\n        if(pos == n + 1) return 1;\n        if(cur <= 0) return 0;\n        if(mem[pos][cur] != -1) return mem[pos][cur];\n        long ans = dp(pos, cur - 1);\n        for(int i = pos; i <= n; i++) {\n            int sz = (i - pos + 1);\n            if(l[i] <= b[cur] && e[cur] <= r[i]) {\n                ans += dp(i + 1, cur - 1) * nCr(e[cur] - b[cur] + sz, sz);\n                ans %= mod;\n            } else break;   \n        }\n        return mem[pos][cur] = ans;\n    }\n\n    void solve () {\n        n = in.nextInt();\n        l = new int [n + 1];\n        r = new int [n + 1];\n        b = new int [5 * n + 1];\n        e = new int [5 * n + 1];\n\n        ArrayList <Data> arr = new ArrayList <> ();\n        arr.add(new Data(-inf, 0));\n        arr.add(new Data(inf, 1));\n        for(int i = 1; i <= n; i++) {\n            l[i] = in.nextInt();\n            r[i] = in.nextInt();\n            arr.add(new Data(l[i], 0)); arr.add(new Data(l[i] - 1, 1));\n            arr.add(new Data(r[i], 1)); arr.add(new Data(r[i] + 1, 0));\n        }    \n        Collections.sort(arr, (p, q) ->  {if(p.value == q.value) return p.type - q.type;\n                                          else return p.value - q.value; });\n        ArrayList <Integer> unq = new ArrayList <> ();\n        for(int i = 0; i < arr.size(); i++) {\n            if(i > 0 && arr.get(i - 1).equalTo(arr.get(i))) continue;\n            unq.add(arr.get(i).value);\n        }\n        range = 0;\n        for(int i = 0; i < unq.size(); i += 2) {\n            b[++range] = unq.get(i);\n            e[range] = unq.get(i + 1);\n            // System.out.println(b[range] + "" "" + e[range]);\n        }\n        invfac = new long [n + 1];\n        long fac = 1;\n        invfac[0] = fac;\n        for(int i = 1; i <= n; i++) {\n            fac = (fac * i) % mod;\n            invfac[i] = power(fac, mod - 2);\n        }\n        mem = new long [n + 1][range + 1];\n        for(int i = 0; i <= n; i++) {\n            for(int j = 0; j <= range; j++) {\n                mem[i][j] = -1;\n            }\n        }\n        long res = dp(1, range);\n        for(int i = 1; i <= n; i++) {\n             res = (res * power(r[i] - l[i] + 1, mod - 2)) % mod;\n        }\n        System.out.println(res);\n    }   \n}\n\nclass Reader {\n    private StringTokenizer a;\n    private BufferedReader b;\n    Reader () {\n        a = null;\n        try {\n            b = new BufferedReader (new InputStreamReader (System.in)); // for file IO, replace this with new FileReader (""in.txt"")\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public String next () {\n        while(a == null || !a.hasMoreTokens()) {\n            try {\n                a = new StringTokenizer (b.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return a.nextToken();\n    }\n    public int nextInt() {\n        return Integer.parseInt(this.next());\n    }\n    public long nextLong () {\n        return Long.parseLong(this.next());\n    }\n    public double nextDouble () {\n        return Double.parseDouble(this.next());\n    }\n    public String nextLine() {\n        try {\n            return b.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return """";\n    }\n}\nclass Writer {\n    private PrintWriter a;\n    private StringBuffer b;\n    Writer () {\n        try {\n            a = new PrintWriter (System.out); // for file IO, replace this with new FileWriter (""out.txt"")\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        b = new StringBuffer ("""");\n    }\n    public void write (Object s) {\n        b.append(s);\n    }\n    public void writeln(Object s) {\n        b.append(s).append('\n');\n    }\n    public void flush () {\n        a.print(b);\n        a.flush();\n        a.close();\n    }\n}\n","combinatorics,dp,probabilities"
"//package com.company;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static class Task {\n\n        int mod = 998244353;\n        int add(int a, int b) {\n            int c = a + b;\n            if (c >= mod) return c - mod;\n            if (c < 0) return c + mod;\n            return c;\n        }\n\n        int mult(int a, int b) {\n            return (int) ((long) a * b % mod);\n        }\n\n        int pow(int a, int b) {\n            int r = 1;\n            while (b != 0) {\n                if (b % 2 == 1) r = mult(r, a);\n                a = mult(a, a);\n                b >>= 1;\n            }\n            return r;\n        }\n\n        private static final int N = 55;\n        private final int inv2 = pow(2, mod - 2);\n        int[] bernoli;\n        int[][] cnk;\n        int[] factorial;\n        int[] invfact;\n        void gen() {\n            bernoli = new int[N];\n            cnk = new int[N][N];\n            for (int i = 0; i < N; i++) {\n                cnk[i][0] = cnk[i][i] = 1;\n            }\n            for (int i = 2; i < N; i++) {\n                for (int j = 1; j < i; j++) {\n                    cnk[i][j] = add(cnk[i - 1][j - 1], cnk[i - 1][j]);\n                }\n            }\n            factorial = new int[N];\n            invfact = new int[N];\n            factorial[0] = 1;\n            for (int i = 1; i < N; i++) {\n                factorial[i] = mult(i, factorial[i - 1]);\n            }\n            for (int i = 0; i < N; i++) {\n                invfact[i] = pow(factorial[i], mod - 2);\n            }\n            bernoli[0] = 1;\n            for (int m = 1; m < N; m++) {\n                int tmp = 0;\n                for (int k = 0; k < m; k++) {\n                    int z = cnk[m][k];\n                    z = mult(z, bernoli[k]);\n                    z = mult(z, pow(m - k + 1, mod - 2));\n                    tmp = add(tmp, z);\n                }\n                bernoli[m] = add(1, -tmp);\n            }\n            if (bernoli[1] != inv2) throw new RuntimeException();\n        }\n\n        public class Polynomial {\n            int[] coef;\n            public Polynomial(int[] coef) {\n                this.coef = coef;\n                if (coef.length != N) throw new RuntimeException();\n            }\n            int evalAt(int x) {\n                int r = 0;\n                for (int i = 0; i < coef.length; i++) {\n                    r = add(r, mult(coef[i], pow(x, i)));\n                }\n                return r;\n            }\n            Polynomial integrate(int L) {\n                int[] newCoef = new int[N];\n                for (int m = 0; m < N; m++) {\n                    for (int k = 0; k <= m; k++) {\n                        if (m + 1 - k < N) {\n                            int co = mult(factorial[m], invfact[k]);\n                            co = mult(co, invfact[m + 1 - k]);\n                            co = mult(co, bernoli[k]);\n                            newCoef[m + 1 - k] = add(newCoef[m + 1 - k], mult(coef[m], co));\n                        }\n                    }\n                }\n                int invL = pow(L, mod - 2);\n                for (int i = 0; i < N; i++) {\n                    newCoef[i] = mult(newCoef[i], invL);\n                }\n                return new Polynomial(newCoef);\n            }\n            void addFrom(Polynomial p) {\n                for (int i = 0; i < coef.length; i++) {\n                    coef[i] = add(coef[i], p.coef[i]);\n                }\n            }\n        }\n\n        Polynomial uniform(int totalProb, int L) {\n            int[] coef = new int[N];\n            coef[1] = mult(totalProb, pow(L, mod - 2));\n            return new Polynomial(coef);\n        }\n\n        public class Segment {\n            int l, r;\n            Polynomial p;\n            public Segment(int l, int r, Polynomial p) {\n                this.l = l;\n                this.r = r;\n                this.p = p;\n            }\n        }\n\n        Segment[] get(List<Integer> breakDown) {\n            Segment[] probs = new Segment[breakDown.size() - 1];\n            for (int i = 0; i < breakDown.size() - 1; i++) {\n                probs[i] = new Segment(breakDown.get(i), breakDown.get(i + 1), new Polynomial(new int[N]));\n            }\n            return probs;\n        }\n\n        List<Integer> activeSegs(List<Integer> breakDown, int L, int R) {\n            List<Integer> ret = new ArrayList<>();\n            for (int i = 0; i < breakDown.size() - 1; i++) {\n                if (breakDown.get(i) >= L && breakDown.get(i + 1) <= R) {\n                    ret.add(i);\n                }\n            }\n            return ret;\n        }\n\n        void checkFind(int p) {\n            for (int i = 1; i < 2000; i++) {\n                for (int j = i; j < 2000; j++) {\n                    if (mult(i, pow(j, mod - 2)) == p) {\n                        System.err.println(""Found for "" + p + "": "" + i + ""/"" + j);\n                        return;\n                    }\n                }\n            }\n            System.err.println(""Not Found "" + p);\n        }\n\n        public void solve(Scanner sc, PrintWriter pw) throws IOException {\n//            checkFind(578894053);\n//            int p1 =  mult(917, pow(1296, mod - 2));\n//            int p2 = mult(mult(379, pow(1296, mod - 2)), mult(29, pow(408, mod - 2)));\n//            int p3 = add(578894053, -add(p1, p2));\n//            int mp3 = mult(95, pow(648, mod - 2));\n//            System.err.println(add(p1, add(p2, mp3)));\n//            checkFind(add(578894053, -p1));\n//            checkFind(p3);\n            gen();\n            int n = sc.nextInt();\n            int[][] lr=  new int[n][2];\n            TreeSet<Integer> critical = new TreeSet<>();\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < 2; j++) {\n                    lr[i][j] = sc.nextInt();\n                    if (j == 1) lr[i][j]++;\n                    critical.add(lr[i][j]);\n                }\n            }\n            List<Integer> breakDown = new ArrayList<>();\n            while (critical.size() > 0) {\n                breakDown.add(critical.first());\n                critical.pollFirst();\n            }\n            Segment[] segs = get(breakDown);\n            int tp = 0;\n            for (int i = 0; i < n; i++) {\n                List<Integer> active = activeSegs(breakDown, lr[i][0], lr[i][1]);\n                int LL = lr[i][1] - lr[i][0];\n                if (i == 0) {\n                    for (int s: active) {\n                        int sz = segs[s].r - segs[s].l;\n                        segs[s].p = uniform(mult(pow(LL, mod - 2), sz), sz);\n                    }\n                } else {\n                    Segment[] nextSegs = get(breakDown);\n                    for (Segment s: segs) {\n                        if (s.p.evalAt(1) == 0) continue;\n//                        System.err.println(s.l + "" "" + s.r);\n//                        int zrf = 0;\n                        for (int ss: active) {\n                            if (segs[ss].r == s.r) {\n                                Polynomial np = s.p.integrate(LL);\n//                                System.err.println(""adwdqwdqw"");\n//                                checkFind(np.evalAt(segs[ss].r - segs[ss].l));\n                                nextSegs[ss].p.addFrom(np);\n                            } else if (segs[ss].r < s.r) {\n                                int totalProb = s.p.evalAt(s.r - s.l);\n//                                System.err.println(s.l + "" "" + s.r + "" "" + segs[ss].l + "" "" + segs[ss].r);\n//                                checkFind(totalProb);\n                                // 917 / 1296 * (43 - 13) / (421 - 13)\n                                Polynomial np = uniform(mult(totalProb, mult(pow(LL, mod - 2), segs[ss].r - segs[ss].l)), segs[ss].r - segs[ss].l);\n//                                int ntf = np.evalAt(segs[ss].r - segs[ss].l);\n//                                zrf = add(zrf, ntf);\n                                nextSegs[ss].p.addFrom(np);\n                            }\n                        }\n//                        checkFind(zrf);\n                    }\n                    segs = nextSegs;\n                }\n                tp = 0;\n                for (Segment ss: segs) {\n                    tp = add(tp, ss.p.evalAt(ss.r - ss.l));\n                }\n//                System.err.println(tp);\n//                checkFind(tp);\n\n            }\n            pw.println(tp);\n        }\n    }\n\n    static long TIME_START, TIME_END;\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n//        Scanner sc = new Scanner(new FileInputStream(""input""));\n        PrintWriter pw = new PrintWriter(new BufferedOutputStream(System.out));\n//        PrintWriter pw = new PrintWriter(new FileOutputStream(""input""));\n\n        Runtime runtime = Runtime.getRuntime();\n        long usedMemoryBefore = runtime.totalMemory() - runtime.freeMemory();\n        TIME_START = System.currentTimeMillis();\n        Task t = new Task();\n        t.solve(sc, pw);\n        TIME_END = System.currentTimeMillis();\n        long usedMemoryAfter = runtime.totalMemory() - runtime.freeMemory();\n        pw.close();\n        System.err.println(""Memory increased: "" + (usedMemoryAfter - usedMemoryBefore) / 1000000);\n        System.err.println(""Time used: "" + (TIME_END - TIME_START) + ""."");\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public Scanner(FileReader s) throws FileNotFoundException {\n            br = new BufferedReader(s);\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n}","combinatorics,dp,probabilities"
"import java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class f {\n	long modinv(long x) { return modpow(x, mod - 2); }\n	long modpow(long b, long e) {\n		if(e == 0) return 1;\n		long r = modpow(b, e >> 1);\n		if((e & 1) == 0) return mult(r, r);\n		return mult(b, mult(r, r));\n	}\n	long add(long a, long b) { return a + b >= mod ? a + b - mod : a + b; }\n	long mult(long a, long b) { return a * b >= mod ? a * b % mod : a * b; }\n	boolean inrange(long[] r1, long[] r2) { // r1 in r2\n		return (r2[0] <= r1[0] && r1[0] <= r2[1]) || (r2[0] <= r1[1] && r1[1] <= r2[1]); \n	}\n	long go(int at1, int at2) {\n		if(at2 == m) return at1 == n ? 1 : 0;\n		if(at1 == n) return 1;\n		if(dp[at1][at2] != -1) return dp[at1][at2];\n		long res = go(at1, at2 + 1);\n		for(int i = 1 ; at1 + i <= n ; i++) {\n			if(!inrange(nranges[at2], ranges[at1 + i - 1])) break;\n			long t = go(at1 + i, at2 + 1);\n			res = add(res, mult(t, precmp[at2][i]));\n		}\n		return dp[at1][at2] = res;\n	}\n	final int mod = 998_244_353;\n	long[][] ranges, nranges, precmp, dp;\n	int n, m;\n	public f() {\n		long[] inv = new long[100];\n		inv[1] = 1;\n		for (int i = 2; i < inv.length; ++i)\n			inv[i] = (mod - (mod / i) * inv[mod % i] % mod) % mod;\n		FS scan = new FS();\n		n = scan.nextInt();\n		long[] bounds = new long[n * 2];\n		ranges = new long[n][2];\n		long all = 1;\n		for(int i = 0 ; i < n ; i++) {\n			ranges[i][0] = scan.nextLong();\n			ranges[i][1] = scan.nextLong();\n			bounds[i] = ranges[i][0];\n			bounds[i + n] = ranges[i][1] + 1;\n			all = mult(all, ranges[i][1] - ranges[i][0] + 1);\n		}\n		Arrays.sort(bounds);\n		List<long[]> newranges = new ArrayList<>();\n		for(int i = bounds.length - 1 ; i > 0 ; i--)\n			if(bounds[i] != bounds[i - 1])\n				newranges.add(new long[] {bounds[i - 1], bounds[i] - 1});\n		m = newranges.size();\n		nranges = new long[m][2];\n		precmp = new long[m][n + 1];\n		for(int i = 0 ; i < m ; i++) {\n			nranges[i] = newranges.get(i);\n			precmp[i][0] = 1;\n			for(int j = 1 ; j <= n ; j++)\n				precmp[i][j] = mult(mult(precmp[i][j - 1], nranges[i][1] - nranges[i][0] + 1 + j - 1), inv[j]);\n		}\n		dp = new long[n][m];\n		for(int i = 0 ; i < n ; i++)\n			Arrays.fill(dp[i], -1);\n		long valid = go(0, 0);\n		System.out.println(mult(valid, modinv(all)));\n	}\n	class FS {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer("""");\n		public String next() {\n			while(!st.hasMoreTokens()) {\n				try { st = new StringTokenizer(br.readLine()); }\n				catch(Exception e) { e.printStackTrace(); }\n			}\n			return st.nextToken();\n		}\n		public int nextInt() { return Integer.parseInt(next()); }\n		public long nextLong() { return Long.parseLong(next()); }\n		public double nextDouble() { return Double.parseDouble(next()); }\n	}\n	public static void main(String[] args) throws Exception { new f(); }\n}\n","combinatorics,dp,probabilities"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FDivideTheStudents solver = new FDivideTheStudents();\n            int testCount = Integer.parseInt(in.next());\n            for (int i = 1; i <= testCount; i++)\n                solver.solve(i, in, out);\n            out.close();\n        }\n    }\n\n    static class FDivideTheStudents {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int[] c1 = new int[4];\n            int[] c2 = new int[4];\n            for (int i = 1; i < 4; i++) {\n                c1[i] = in.readInt();\n            }\n            for (int i = 1; i < 4; i++) {\n                c2[i] = in.readInt();\n            }\n            int[] f = new int[8];\n            for (int i = 1; i < 8; i++) {\n                f[i] = in.readInt();\n            }\n\n            for (int i = 0; i <= f[2]; i++) {\n                for (int j = 0; j <= f[3]; j++) {\n                    for (int k = 0; k <= f[5]; k++) {\n                        int c11 = c1[1] - i - j;\n                        int c21 = c2[1] - f[2] - f[3] + i + j;\n                        int c12 = c1[2] - i - k;\n                        int c22 = c2[2] - f[2] - f[5] + i + k;\n                        int c13 = c1[3] - j - k;\n                        int c23 = c2[3] - f[3] - f[5] + j + k;\n                        if (c11 < 0 || c12 < 0 || c13 < 0 || c21 < 0 || c22 < 0 || c23 < 0) {\n                            continue;\n                        }\n                        int a1 = Math.min(Math.min(c11, c12), c13);\n                        int a2 = Math.min(Math.min(c21, c22), c23);\n                        if (a1 + a2 < f[1] || c11 + c21 - f[1] - f[4] < 0\n                                || c12 + c22 - f[1] - f[6] < 0\n                                || c13 + c23 - f[1] - f[7] < 0) {\n                            continue;\n                        }\n                        int g1 = Math.min(a1, f[1]);\n                        out.append(g1).append(' ');\n                        out.append(i).append(' ');\n                        out.append(j).append(' ');\n                        out.append(Math.min(f[4], c11 - g1)).append(' ');\n                        out.append(k).append(' ');\n                        out.append(Math.min(f[6], c12 - g1)).append(' ');\n                        out.append(Math.min(f[7], c13 - g1)).append(' ');\n                        out.println();\n                        return;\n                    }\n                }\n            }\n\n            out.println(-1);\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);\n        private byte[] buf = new byte[1 << 20];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n}\n\n",brute force
"import java.io.*;\nimport java.util.*;\n\npublic class P608E {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = br.readLine().split("" "");\n        long n = Long.parseLong(line[0]);\n        long k = Long.parseLong(line[1]);\n\n\n        long min = 1;\n        long max = n/2 + 1;\n\n        while(min != max) {\n            long mid = min + (max - min + 1)/2;\n\n            long paths = calcPaths(2*mid, n);\n\n            if(paths >= k) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n\n        long even = calcPaths(2*min, n);\n        long oddTwo = calcPaths(2*min+1, n);\n\n        if(oddTwo >= k)\n            System.out.println(2*min+1);\n        else if(even >= k)\n            System.out.println(2*min);\n        else\n            System.out.println(2*min-1);\n\n\n    }\n\n    public static long calcPaths(long val, long max) {\n        if(val == 1 || val == 2)\n            return max + 1 - val;\n        else {\n            long count = 0;\n            long oneWidth = (val & 1) == 1 ? 1 : 2;\n            long zeroWidth = val - oneWidth;\n            for(long cur = val; cur<=max;) {\n                if(cur - 1 + oneWidth > max) {\n                    count += max - cur + 1;\n                    cur = max + 1;\n                } else {\n                    count += oneWidth;\n                    cur += oneWidth + zeroWidth;\n                    oneWidth *= 2;\n                    zeroWidth *= 2;\n                }\n            }\n            return count;\n        }\n    }\n}\n","binary search,combinatorics,dp,math"
"import java.io.*;\nimport java.util.*;\npublic class Main {\n	static long N;\n	static long countprefix(long num) {\n	    int zero_bits = 0;\n	    long count=0;\n	    while (num<= N) {\n	        count += Math.min(N+1,num+(1L<<zero_bits))-num;\n	        num *= 2;\n	        zero_bits++;\n	    }\n	    return count;\n	}\n	static long countpaths(long n) {\n	    long count = countprefix(n);\n	    if (n%2==0)\n	        count+=countprefix(n+1);\n	    return count;\n	}\n	public static void main(String[] args) throws IOException \n	{ \n		FastScanner f = new FastScanner(); \n		int ttt=1;\n//		ttt=f.nextInt();\n		PrintWriter out=new PrintWriter(System.out);\n		for(int tt=0;tt<ttt;tt++) {\n			N=f.nextLong();\n			long k=f.nextLong();\n			long ans=0;\n			for (int bit = 59; bit >= 0; bit--)\n		        if (countpaths(ans+(1L<< bit))>=k)\n		        	ans += 1L<< bit;\n			System.out.println(ans);\n		}\n		out.close();\n	} \n	static void sort(int[] p) {\n        ArrayList<Integer> q = new ArrayList<>();\n        for (int i: p) q.add( i);\n        Collections.sort(q);\n        for (int i = 0; i < p.length; i++) p[i] = q.get(i);\n    }\n    \n	static class FastScanner {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n		String next() {\n			while (!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		int[] readArray(int n) {\n			int[] a=new int[n];\n			for (int i=0; i<n; i++) a[i]=nextInt();\n			return a;\n		}\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n		long[] readLongArray(int n) {\n			long[] a=new long[n];\n			for (int i=0; i<n; i++) a[i]=nextLong();\n			return a;\n		}\n	}\n} 	","binary search,combinatorics,dp,math"
"import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\npublic class P1271E\n{\n	public static void main(String[] args)\n	{\n		FastScanner scan = new FastScanner();\n		long n = scan.nextLong();\n		long k = scan.nextLong();\n		ArrayList<Long> cand = new ArrayList<>();\n		long curr = n;\n		while (curr > 0)\n		{\n			for (int i = 0; i < 4; i++)\n				cand.add(curr - i);\n			if (curr > 3)\n			{\n				cand.add(Long.highestOneBit(curr)-1);\n				cand.add(Long.highestOneBit(curr)-2);\n			}\n			curr /= 2;\n		}\n		int bits = numBits(n);\n		Collections.sort(cand, Collections.reverseOrder());\n		long max = 0;\n		for (int i = 0; i < cand.size(); i++)\n		{\n			long num = cand.get(i);\n			if (num > n || n < 1)\n				continue;\n			long occ = 0;\n			int candBits = numBits(num);\n			for (int j = candBits; j < bits; j++)\n			{\n				int diff = j-candBits;\n				occ += 1L << diff;\n				if (num % 2 == 0)\n					occ += 1L << diff;\n			}\n			int diff = bits-candBits;\n			long start = num << diff;\n			long end = num % 2 == 0 ? ((num+2) << diff) - 1 : ((num+1) << diff) - 1;\n			end = Math.min(end, n);\n			if (start <= end)\n				occ += end-start + 1;\n			if (occ >= k)\n			{\n				max = num;\n				break;\n			}\n		}\n		System.out.println(max);\n	}\n	private static int numBits(long num)\n	{\n		return Long.bitCount(Long.highestOneBit(num)-1)+1;\n	}\n	static class FastScanner\n	{\n		BufferedReader br;\n		StringTokenizer st;\n\n		public FastScanner()\n		{\n			try\n			{\n				br = new BufferedReader(new InputStreamReader(System.in));\n				st = new StringTokenizer(br.readLine());\n			} catch (Exception e)\n			{\n				e.printStackTrace();\n			}\n		}\n\n		public String next()\n		{\n			if (st.hasMoreTokens())\n				return st.nextToken();\n			try\n			{\n				st = new StringTokenizer(br.readLine());\n			} catch (Exception e)\n			{\n				e.printStackTrace();\n			}\n			return st.nextToken();\n		}\n\n		public int nextInt()\n		{\n			return Integer.parseInt(next());\n		}\n\n		public long nextLong()\n		{\n			return Long.parseLong(next());\n		}\n\n		public String nextLine()\n		{\n			String line = """";\n			try\n			{\n				line = br.readLine();\n			} catch (Exception e)\n			{\n				e.printStackTrace();\n			}\n			return line;\n		}\n	}\n}\n","binary search,combinatorics,dp,math"
"import java.io.*;\nimport java.util.*;\n\npublic class C {\n\n	static boolean occ(int x, int curr) {\n		while (curr > 0) {\n			if (curr == x)\n				return true;\n			if (curr % 2 == 1)\n				curr--;\n			else\n				curr >>= 1;\n		}\n		return false;\n\n	}\n\n	static long cnt(long x, long n, boolean even) {\n		if (x > n)\n			return 0;\n		long ans = 0;\n		for (long m = 1, times = even ? 2 : 1; m <= n / x; m <<= 1, times <<= 1) {\n			long currCnt = Math.min(times, n - m * x + 1);\n			ans += currCnt;\n		}\n		return ans;\n\n	}\n\n	static long bs(long lo, long hi, int add, long k, long n) {\n		long ans = 0;\n		while (lo <= hi) {\n			long mid = lo + hi >> 1;\n			long cnt = cnt(2 * mid + add, n, add == 0);\n			if (cnt >= k) {\n				ans = mid;\n				lo = mid + 1;\n			} else\n				hi = mid - 1;\n		}\n		return ans * 2 + add;\n	}\n\n	public static void main(String[] args) throws IOException {\n		Scanner sc = new Scanner();\n		PrintWriter out = new PrintWriter(System.out);\n		long n = sc.nextLong(), k = sc.nextLong();\n		long lo = 1, hi = n / 2;\n		long ans = bs(lo, hi, 0, k, n);\n//		long ans=0;\n		lo = 0;\n		ans = Math.max(ans, bs(lo, hi, 1, k, n));\n		out.println(ans);\n		out.close();\n\n	}\n\n	static class Scanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		Scanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		Scanner(String fileName) throws FileNotFoundException {\n			br = new BufferedReader(new FileReader(fileName));\n		}\n\n		String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() throws NumberFormatException, IOException {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() throws NumberFormatException, IOException {\n			return Double.parseDouble(next());\n		}\n\n		boolean ready() throws IOException {\n			return br.ready();\n		}\n\n	}\n\n	static void sort(int[] a) {\n		shuffle(a);\n		Arrays.sort(a);\n	}\n\n	static void shuffle(int[] a) {\n		int n = a.length;\n		Random rand = new Random();\n		for (int i = 0; i < n; i++) {\n			int tmpIdx = rand.nextInt(n);\n			int tmp = a[i];\n			a[i] = a[tmpIdx];\n			a[tmpIdx] = tmp;\n		}\n	}\n\n}","binary search,combinatorics,dp,math"
"import java.math.*;\nimport java.util.*;\n \npublic class Main {\n	public static BigDecimal[][] C = new BigDecimal[110][];\n	public static int[] a = new int[110];\n	public static BigDecimal[][] dp = new BigDecimal[110][];\n		\n	public static void main(String[] args) {\n		for (int i = 0; i < 110; i++) C[i] = new BigDecimal [110];\n		for (int i = 0; i < 110; i++) dp[i] = new BigDecimal [11000];\n		for (int i = 0; i < 110; i++) for (int j = 0; j < 110; j++) C[i][j] = BigDecimal.valueOf(0);\n		for (int i = 0; i < 110; i++) for (int j = 0; j < 11000; j++) dp[i][j] = BigDecimal.valueOf(0);\n		Scanner scanner = new Scanner(System.in);\n		for (int i = 0; i < 110; i++) {\n			for (int j = 0; j <= i; j++) {\n				if (j == 0) {\n					C[i][j] = BigDecimal.valueOf(1);\n					continue;\n				}\n				C[i][j] = C[i - 1][j - 1].add(C[i - 1][j]);\n			}\n		}\n		int n, x;\n		n = scanner.nextInt();\n		x = scanner.nextInt();\n		for (int i = 0; i < n; i++) a[i] = scanner.nextInt();\n		dp[0][0] = BigDecimal.valueOf(1);\n		for (int i = 0; i < n; i++) {\n			for (int j = n; j >= 0; j--) for (int k = 0; k <= 10000; k++) if (dp[j][k] != BigDecimal.valueOf(0)) {\n				dp[j + 1][k + a[i]] = dp[j + 1][k + a[i]].add(dp[j][k]);\n			}\n		}\n		BigDecimal ans = BigDecimal.valueOf(x);\n		for (int i = 2; i <= n; i++) {\n			int m = i - 1;\n			BigDecimal cur = BigDecimal.valueOf(0);\n			BigDecimal cnt = BigDecimal.valueOf(x * (2 * n - m)).divide(BigDecimal.valueOf(2 * (n - m)), 20, RoundingMode.UP);\n			for (int j = 0; j <= 10000; j++) {\n				BigDecimal now = BigDecimal.valueOf(j).divide(BigDecimal.valueOf(n + 1 - i), 20, RoundingMode.UP);\n				if (cnt.compareTo(now) < 0) now = cnt;\n				cur = cur.add(now.multiply(dp[n + 1 - i][j]));\n			}\n			cur = cur.divide(C[n][m], 20, RoundingMode.UP);\n			ans = ans.add(cur);\n		}\n		System.out.println(ans);\n		scanner.close();\n	}\n}","math,probabilities"
"import java.math.*;\nimport java.util.*;\n \npublic class Main {\n	public static BigDecimal[][] C = new BigDecimal[110][];\n	public static int[] a = new int[110];\n	public static BigDecimal[][] dp = new BigDecimal[110][];\n		\n	public static void main(String[] args) {\n		for (int i = 0; i < 110; i++) C[i] = new BigDecimal [110];\n		for (int i = 0; i < 110; i++) dp[i] = new BigDecimal [11000];\n		for (int i = 0; i < 110; i++) for (int j = 0; j < 110; j++) C[i][j] = BigDecimal.valueOf(0);\n		for (int i = 0; i < 110; i++) for (int j = 0; j < 11000; j++) dp[i][j] = BigDecimal.valueOf(0);\n		Scanner scanner = new Scanner(System.in);\n		for (int i = 0; i < 110; i++) {\n			for (int j = 0; j <= i; j++) {\n				if (j == 0) {\n					C[i][j] = BigDecimal.valueOf(1);\n					continue;\n				}\n				C[i][j] = C[i - 1][j - 1].add(C[i - 1][j]);\n			}\n		}\n		int n, x;\n		n = scanner.nextInt();\n		x = scanner.nextInt();\n		for (int i = 0; i < n; i++) a[i] = scanner.nextInt();\n		dp[0][0] = BigDecimal.valueOf(1);\n		for (int i = 0; i < n; i++) {\n			for (int j = n; j >= 0; j--) for (int k = 0; k <= 10000; k++) if (dp[j][k] != BigDecimal.valueOf(0)) {\n				dp[j + 1][k + a[i]] = dp[j + 1][k + a[i]].add(dp[j][k]);\n			}\n		}\n		BigDecimal ans = BigDecimal.valueOf(x);\n		for (int i = 2; i <= n; i++) {\n			int m = i - 1;\n			BigDecimal cur = BigDecimal.valueOf(0);\n			BigDecimal cnt = BigDecimal.valueOf(x * (2 * n - m)).divide(BigDecimal.valueOf(2 * (n - m)), 10, RoundingMode.UP);\n			for (int j = 0; j <= 10000; j++) {\n				BigDecimal now = BigDecimal.valueOf(j).divide(BigDecimal.valueOf(n + 1 - i), 10, RoundingMode.UP);\n				if (cnt.compareTo(now) < 0) now = cnt;\n				cur = cur.add(now.multiply(dp[n + 1 - i][j]));\n			}\n			cur = cur.divide(C[n][m], 10, RoundingMode.UP);\n			ans = ans.add(cur);\n		}\n		System.out.println(ans);\n		scanner.close();\n	}\n}","math,probabilities"
"import java.math.*;\nimport java.util.*;\n \npublic class Main {\n	public static BigDecimal[][] C = new BigDecimal[110][];\n	public static int[] a = new int[110];\n	public static BigDecimal[][] dp = new BigDecimal[110][];\n		\n	public static void main(String[] args) {\n		for (int i = 0; i < 110; i++) C[i] = new BigDecimal [110];\n		for (int i = 0; i < 110; i++) dp[i] = new BigDecimal [11000];\n		for (int i = 0; i < 110; i++) for (int j = 0; j < 110; j++) C[i][j] = BigDecimal.valueOf(0);\n		for (int i = 0; i < 110; i++) for (int j = 0; j < 11000; j++) dp[i][j] = BigDecimal.valueOf(0);\n		Scanner scanner = new Scanner(System.in);\n		for (int i = 0; i < 110; i++) {\n			for (int j = 0; j <= i; j++) {\n				if (j == 0) {\n					C[i][j] = BigDecimal.valueOf(1);\n					continue;\n				}\n				C[i][j] = C[i - 1][j - 1].add(C[i - 1][j]);\n			}\n		}\n		int n, x;\n		n = scanner.nextInt();\n		x = scanner.nextInt();\n		for (int i = 0; i < n; i++) a[i] = scanner.nextInt();\n		dp[0][0] = BigDecimal.valueOf(1);\n		for (int i = 0; i < n; i++) {\n			for (int j = n; j >= 0; j--) for (int k = 0; k <= 10000; k++) if (dp[j][k] != BigDecimal.valueOf(0)) {\n				dp[j + 1][k + a[i]] = dp[j + 1][k + a[i]].add(dp[j][k]);\n			}\n		}\n		BigDecimal ans = BigDecimal.valueOf(x);\n		for (int i = 2; i <= n; i++) {\n			int m = i - 1;\n			BigDecimal cur = BigDecimal.valueOf(0);\n			BigDecimal cnt = BigDecimal.valueOf(x * (2 * n - m)).divide(BigDecimal.valueOf(2 * (n - m)), 20, RoundingMode.UP);\n			for (int j = 0; j <= 10000; j++) {\n				BigDecimal now = BigDecimal.valueOf(j).divide(BigDecimal.valueOf(n + 1 - i), 20, RoundingMode.UP);\n				if (cnt.compareTo(now) < 0) now = cnt;\n				cur = cur.add(now.multiply(dp[n + 1 - i][j]));\n			}\n			cur = cur.divide(C[n][m], 20, RoundingMode.UP);\n			ans = ans.add(cur);\n		}\n		System.out.println(ans);\n		scanner.close();\n	}\n}\n","math,probabilities"
"import java.math.*;\nimport java.util.*;\n \npublic class Main {\n	public static BigDecimal[][] C = new BigDecimal[110][];\n	public static int[] a = new int[110];\n	public static BigDecimal[][] dp = new BigDecimal[110][];\n		\n	public static void main(String[] args) {\n		for (int i = 0; i < 110; i++) C[i] = new BigDecimal [110];\n		for (int i = 0; i < 110; i++) dp[i] = new BigDecimal [11000];\n		for (int i = 0; i < 110; i++) for (int j = 0; j < 110; j++) C[i][j] = BigDecimal.valueOf(0);\n		for (int i = 0; i < 110; i++) for (int j = 0; j < 11000; j++) dp[i][j] = BigDecimal.valueOf(0);\n		Scanner scanner = new Scanner(System.in);\n		for (int i = 0; i < 110; i++) {\n			for (int j = 0; j <= i; j++) {\n				if (j == 0) {\n					C[i][j] = BigDecimal.valueOf(1);\n					continue;\n				}\n				C[i][j] = C[i - 1][j - 1].add(C[i - 1][j]);\n			}\n		}\n		int n, x;\n		n = scanner.nextInt();\n		x = scanner.nextInt();\n		for (int i = 0; i < n; i++) a[i] = scanner.nextInt();\n		dp[0][0] = BigDecimal.valueOf(1);\n		for (int i = 0; i < n; i++) {\n			for (int j = n; j >= 0; j--) for (int k = 0; k <= 10000; k++) if (dp[j][k] != BigDecimal.valueOf(0)) {\n				dp[j + 1][k + a[i]] = dp[j + 1][k + a[i]].add(dp[j][k]);\n			}\n		}\n		BigDecimal ans = BigDecimal.valueOf(x);\n		for (int i = 2; i <= n; i++) {\n			int m = i - 1;\n			BigDecimal cur = BigDecimal.valueOf(0);\n			BigDecimal cnt = BigDecimal.valueOf(x * (2 * n - m)).divide(BigDecimal.valueOf(2 * (n - m)), 100, RoundingMode.UP);\n			for (int j = 0; j <= 10000; j++) {\n				BigDecimal now = BigDecimal.valueOf(j).divide(BigDecimal.valueOf(n + 1 - i), 100, RoundingMode.UP);\n				if (cnt.compareTo(now) < 0) now = cnt;\n				cur = cur.add(now.multiply(dp[n + 1 - i][j]));\n			}\n			cur = cur.divide(C[n][m], 100, RoundingMode.UP);\n			ans = ans.add(cur);\n		}\n		System.out.println(ans);\n		scanner.close();\n	}\n}","math,probabilities"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1265C extends PrintWriter {\n	CF1265C() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1265C o = new CF1265C(); o.main(); o.flush();\n	}\n\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int[] pp = new int[n];\n			for (int i = 0; i < n; i++)\n				pp[i] = sc.nextInt();\n			int b = n / 2 - 1;\n			int p = pp[b + 1];\n			while (b >= 0 && pp[b] == p)\n				b--;\n			int g = 0;\n			p = pp[g];\n			while (g + 1 < n && pp[g + 1] == p)\n				g++;\n			boolean yes = false;\n			if (g < b)\n				for (int s = g + 1; pp[s] > pp[b]; s++) {\n					p = pp[s];\n					while (s + 1 < b && pp[s + 1] == p)\n						s++;\n					if (g + 1 < s - g && g + 1 < b - s) {\n						yes = true;\n						println((g + 1) + "" "" + (s - g) + "" "" + (b - s));\n						break;\n					}\n				}\n			if (!yes)\n				println(""0 0 0"");\n		}\n	}\n}\n","greedy,implementation"
"import java.util.Scanner;\n\npublic class Solution {\n	public static void main(String[] args) {\n		Scanner scanner = new Scanner(System.in);\n\n		int T = scanner.nextInt();\n\n		for (int testCase = 0; testCase < T; testCase++) {\n			int n = scanner.nextInt();\n			int[] p = new int[n];\n\n			int maxAmountMedals = n / 2;\n			int gold = 0;\n			int silver = 0;\n			int bronze = 0;\n\n			for (int i = 0; i < n; i++) {\n				int pi = scanner.nextInt();\n				p[i] = pi;\n\n				if (i != 0 && gold == 0 && p[i] != p[i-1]) {\n					gold = i;\n				} else if (i != 0 && silver == 0 && p[i] != p[i-1] && i - gold > gold) {\n					silver = i - gold;\n				}\n			}\n\n			int bestNonMedal = p[maxAmountMedals];\n			for (int i = maxAmountMedals - 1; i >= 0; i--) {\n				if (p[i] != bestNonMedal) {\n					bronze = i - silver - gold + 1;\n					break;\n				}\n			}\n\n			if (gold == 0 || silver == 0 || bronze == 0 || gold >= silver || gold >= bronze || p[0] <= p[gold] || p[gold] < p[gold+silver]) {\n				System.out.println(""0 0 0"");\n			} else {\n				System.out.println(gold + "" "" + silver + "" "" + bronze);\n			}\n		}\n\n	}\n}","greedy,implementation"
"\nimport java.util.Scanner;\n\npublic class Main {\n	public static void main(String[] args) {\n		Scanner in=new Scanner(System.in);\n		while(in.hasNext()) {\n			int T=in.nextInt();\n			while(T-->0) {\n				int n=in.nextInt();\n				int[] a=new int[n];\n				\n				for(int i=0;i<n;i++) {\n					a[i]=in.nextInt();\n				}\n				int g=0,s=0,t=0,m=n/2;\n				int max=a[0],max2=a[0];\n				 if(n<10) {\n						System.out.println(""0 0 0"");\n						continue ;\n				}\n				else{\n					for(int i=0;i<n/2;i++) {\n						if(max==a[i]) {\n							g++;\n						}\n						if(max!=a[i]) {\n							max2=a[i];\n							s=1;\n							for(int j=i+1;j<n/2;j++) {\n								if(max2==a[j]) {\n									s++;\n								}else {\n									if(s<=g) {\n										max2=a[j];\n										s++;\n									}else {\n										break;\n									}\n								}\n							}\n							break;\n						}\n						\n					}\n					t=m-g-s;\n				}\n				for(int i=m-1;i>g+s;i--) {\n					if(a[i]==a[m]) {\n						t--;\n					}else {\n						break;\n					}\n				}\n				if(g<s&&g<t) {\n					System.out.println(g+"" ""+s+"" ""+t);\n				}else {\n					System.out.println(""0 0 0"");\n				}\n			}\n	}\n	}\n}\n","greedy,implementation"
"import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class CF604C {\n	public static void main(String[] args) throws Exception {\n		BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter out = new PrintWriter(System.out);\n		int tc = Integer.parseInt(bf.readLine());\n		while (tc-- > 0) {\n			int n = Integer.parseInt(bf.readLine());\n			int points[] = new int[n];\n			StringTokenizer st = new StringTokenizer(bf.readLine());\n			for (int i = 0; i < n; i++)\n				points[i] = Integer.parseInt(st.nextToken());\n			int gold, silver, bronze;\n			gold = silver = bronze = 0;\n			int ptr = 0;\n			int cur = points[ptr];\n			while (ptr < n / 2 && points[ptr++] == cur)\n				gold++;\n			if (ptr != n / 2)\n				ptr--;\n			while (gold >= silver && ptr < n / 2) {\n				cur = points[ptr];\n				while (ptr < n / 2 && points[ptr++] == cur)\n					silver++;\n				if (ptr != n / 2)\n					ptr--;\n			}\n			int m = n / 2;\n			while (m > 0 && m >= ptr && points[m] == points[m - 1])\n				m--;\n			bronze = m - ptr;\n			if (gold < silver && gold < bronze)\n				out.println(gold + "" "" + silver + "" "" + bronze);\n			else\n				out.println(""0 0 0"");\n		}\n		out.flush();\n		out.close();\n	}\n}\n","greedy,implementation"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1253F extends PrintWriter {\n	CF1253F() { super(System.out); }\n	static class Scanner {\n		Scanner(InputStream in) { this.in = in; } InputStream in;\n		int k, l; byte[] bb = new byte[1 << 15];\n		byte getc() {\n			if (k >= l) {\n				k = 0;\n				try { l = in.read(bb); } catch (IOException e) { l = 0; }\n				if (l <= 0) return -1;\n			}\n			return bb[k++];\n		}\n		int nextInt() {\n			byte c = 0; while (c <= 32) c = getc();\n			int a = 0;\n			while (c > 32) { a = a * 10 + c - '0'; c = getc(); }\n			return a;\n		}\n	}\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1253F o = new CF1253F(); o.main(); o.flush();\n	}\n\n	static final long INF = 0x3f3f3f3f3f3f3f3fL;\n	int[] oo, oh; int __ = 1;\n	int link(int o, int h) {\n		oo[__] = o; oh[__] = h;\n		return __++;\n	}\n	int[] ii, jj; long[] ww;\n	int[] ae, pp, dsu; long[] dd;\n	int[] pq, iq; int cnt;\n	int[][] pp_; long[][] ww_; int ln;\n	void init(int n, int m, int k) {\n		oo = new int[1 + m * 2]; oh = new int[1 + m * 2];\n		ii = new int[m]; jj = new int[m]; ww = new long[m];\n		ae = new int[n]; pp = new int[n];\n		dsu = new int[n]; Arrays.fill(dsu, -1);\n		dd = new long[n]; Arrays.fill(dd, INF);\n		pq = new int[1 + n]; iq = new int[n];\n		ln = 0;\n		while (1 << ln + 1 < n)\n			ln++;\n		pp_ = new int[ln + 1][k];\n		ww_ = new long[ln + 1][k];\n	}\n	boolean less(int u, int v) {\n		return dd[u] < dd[v];\n	}\n	int i2(int i) {\n		return (i *= 2) > cnt ? 0 : i < cnt && less(pq[i + 1], pq[i]) ? i + 1 : i;\n	}\n	void pq_up(int u) {\n		int i, j, v;\n		for (i = iq[u]; (j = i / 2) > 0 && less(u, v = pq[j]); i = j)\n			pq[iq[v] = i] = v;\n		pq[iq[u] = i] = u;\n	}\n	void pq_dn(int u) {\n		int i, j, v;\n		for (i = iq[u]; (j = i2(i)) > 0 && less(v = pq[j], u); i = j)\n			pq[iq[v] = i] = v;\n		pq[iq[u] = i] = u;\n	}\n	void pq_add_last(int u) {\n		pq[iq[u] = ++cnt] = u;\n	}\n	int pq_remove_first() {\n		int u = pq[1], v = pq[cnt--];\n		if (v != u) {\n			iq[v] = 1; pq_dn(v);\n		}\n		return u;\n	}\n	void dijkstra(int n, int k) {\n		for (int i = 0; i < k; i++) {\n			pp[i] = i;\n			dd[i] = 0;\n			pq_add_last(i);\n		}\n		while (cnt > 0) {\n			int i = pq_remove_first();\n			long d = dd[i];\n			for (int o = ae[i]; o != 0; o = oo[o]) {\n				int h = oh[o], j = i ^ ii[h] ^ jj[h]; long w = ww[h];\n				if (dd[j] > d + w) {\n					if (dd[j] == INF)\n						pq_add_last(j);\n					pp[j] = pp[i];\n					dd[j] = d + w;\n					pq_up(j);\n				}\n			}\n		}\n	}\n	int find(int i) {\n		return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));\n	}\n	boolean join(int i, int j) {\n		i = find(i);\n		j = find(j);\n		if (i == j)\n			return false;\n		if (dsu[i] > dsu[j])\n			dsu[i] = j;\n		else {\n			if (dsu[i] == dsu[j])\n				dsu[i]--;\n			dsu[j] = i;\n		}\n		return true;\n	}\n	void dfs_(int p, int i, int d, long w) {\n		dd[i] = d;\n		pp_[0][i] = p;\n		ww_[0][i] = w;\n		for (int h = 1; 1 << h <= d; h++) {\n			int q = pp_[h - 1][i];\n			pp_[h][i] = pp_[h - 1][q];\n			ww_[h][i] = Math.max(ww_[h - 1][i], ww_[h - 1][q]);\n		}\n		for (int o = ae[i]; o != 0; o = oo[o]) {\n			int h = oh[o], j = i ^ ii[h] ^ jj[h];\n			if (j != p)\n				dfs_(i, j, d + 1, ww[h]);\n		}\n	}\n	long query(int i, int j) {\n		if (dd[i] < dd[j]) {\n			int tmp = i; i = j; j = tmp;\n		}\n		long w = 0;\n		for (int h = ln; h >= 0; h--)\n			if (1 << h <= dd[i] - dd[j]) {\n				w = Math.max(w, ww_[h][i]);\n				i = pp_[h][i];\n			}\n		if (i == j)\n			return w;\n		for (int h = ln; h >= 0; h--)\n			if (1 << h <= dd[i] && pp_[h][i] != pp_[h][j]) {\n				w = Math.max(w, ww_[h][i]);\n				w = Math.max(w, ww_[h][j]);\n				i = pp_[h][i];\n				j = pp_[h][j];\n			}\n		w = Math.max(w, ww_[0][i]);\n		w = Math.max(w, ww_[0][j]);\n		return w;\n	}\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		int k = sc.nextInt();\n		int q = sc.nextInt();\n		init(n, m, k);\n		for (int h = 0; h < m; h++) {\n			int i = sc.nextInt() - 1;\n			int j = sc.nextInt() - 1;\n			int w = sc.nextInt();\n			ii[h] = i;\n			jj[h] = j;\n			ww[h] = w;\n			ae[i] = link(ae[i], h);\n			ae[j] = link(ae[j], h);\n		}\n		dijkstra(n, k);\n		int m_ = 0;\n		for (int h = 0; h < m; h++) {\n			int i = ii[h], j = jj[h];\n			if (pp[i] != pp[j]) {\n				ii[m_] = pp[i];\n				jj[m_] = pp[j];\n				ww[m_] = dd[i] + dd[j] + ww[h];\n				m_++;\n			}\n		}\n		Integer[] hh = new Integer[m_];\n		for (int h = 0; h < m_; h++)\n			hh[h] = h;\n		Arrays.sort(hh, (h1, h2) -> Long.signum(ww[h1] - ww[h2]));\n		Arrays.fill(ae, 0, k, 0); __ = 1;\n		for (int h = 0; h < m_; h++) {\n			int h_ = hh[h], i = ii[h_], j = jj[h_];\n			if (join(i, j)) {\n				ae[i] = link(ae[i], h_);\n				ae[j] = link(ae[j], h_);\n			}\n		}\n		dfs_(-1, 0, 0, 0);\n		while (q-- > 0) {\n			int i = sc.nextInt() - 1;\n			int j = sc.nextInt() - 1;\n			println(query(i, j));\n		}\n	}\n}\n","binary search,dsu,graphs,shortest paths,trees"
"import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Solver {\n    static int n;\n    static ArrayList<pair> gr[];\n    static int tr = 0;\n    static int tin[], tout[], p[][], h[];\n    static long mx[][];\n\n    static void dfs(int v, int pr, long pw) {\n        tin[v] = tr++;\n        mx[v][0] = pw;\n        h[v] = v == 0 ? 0 : (h[pr] + 1);\n        if (v != 0) {\n            p[v][0] = pr;\n            for (int i = 1; i < 30; i++) {\n                p[v][i] = p[p[v][i - 1]][i - 1];\n                mx[v][i] = max(mx[v][i - 1], mx[p[v][i - 1]][i - 1]);\n            }\n        }\n        for (pair to : gr[v]) {\n            if (to.u == pr) continue;\n            dfs(to.u, v, to.w);\n        }\n        tout[v] = tr++;\n    }\n\n    static long calc(int v, int u) {\n        if (batya(v,u)) return 0;\n        long max = 0;\n        for (int i = 29; i >= 0; i--) {\n            if (!batya(p[v][i], u)) {\n                max = max(max, mx[v][i]);\n                v = p[v][i];\n            }\n        }\n        return max(max, mx[v][0]);\n    }\n\n    static boolean batya(int v, int u) {\n        return tin[v] <= tin[u] && tout[v] >= tout[u];\n    }\n\n    public static void main(String[] args) throws IOException {\n        FastScanner in = new FastScanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        n = in.nextInt();\n        int m = in.nextInt();\n        int k = in.nextInt();\n        int q = in.nextInt();\n        ArrayList<pair> g[] = new ArrayList[n];\n        gr = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            g[i] = new ArrayList<>();\n            gr[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < m; i++) {\n            int v = in.nextInt() - 1;\n            int u = in.nextInt() - 1;\n            long w = in.nextLong();\n            g[v].add(new pair(u, w));\n            g[u].add(new pair(v, w));\n        }\n        long d[] = new long[n];\n        for (int i = 0; i < n; i++) {\n            d[i] = Long.MAX_VALUE / 4;\n        }\n        TreeSet<pair> verts = new TreeSet<>();\n        for (int i = 0; i < k; i++) {\n            d[i] = 0;\n            verts.add(new pair(i, 0));\n        }\n        while (!verts.isEmpty()) {\n            pair v = verts.pollFirst();\n            for (pair u : g[v.u]) {\n                if (d[u.u] > v.w + u.w) {\n                    verts.remove(new pair(u.u, d[u.u]));\n                    d[u.u] = v.w + u.w;\n                    verts.add(new pair(u.u, d[u.u]));\n                }\n            }\n        }\n        edge e[] = new edge[400000];\n        int ptr = 0;\n        for (int i = 0; i < n; i++) {\n            for (pair to : g[i]) {\n                if(to.u > i)continue;\n                e[ptr] = new edge(i, to.u, d[i] + d[to.u] + to.w);\n                ptr++;\n            }\n        }\n        for (int i = 0; i < 400000; i++) {\n            if(e[i] == null)e[i] = new edge(0,0,Long.MAX_VALUE);\n        }\n        sort(e);\n        dsu dsu = new dsu(n);\n        for (int i = 0; i < m; i++) {\n            if (!dsu.same(e[i].u, e[i].v)) {\n                dsu.merge(e[i].u, e[i].v);\n                gr[e[i].u].add(new pair(e[i].v, e[i].w));\n                gr[e[i].v].add(new pair(e[i].u, e[i].w));\n            }\n        }\n        p = new int[n][30];\n        mx = new long[n][30];\n        tin = new int[n];\n        tout = new int[n];\n        h = new int[n];\n\n        dfs(0, 0, 0);\n        while (q-- > 0) {\n            int v = in.nextInt() - 1;\n            int u = in.nextInt() - 1;\n            out.println(max(calc(u,v),calc(v,u)));\n        }\n        out.close();\n    }\n}\n\nclass pair implements Comparable<pair> {\n    int u;\n    long w;\n\n    public pair(int u, long w) {\n        this.u = u;\n        this.w = w;\n    }\n\n    @Override\n    public int compareTo(pair o) {\n        if (w != o.w) return Long.compare(w, o.w);\n        return Integer.compare(u, o.u);\n    }\n}\n\nclass edge implements Comparable<edge> {\n    int v, u;\n    long w;\n\n    public edge(int v, int u, long w) {\n        this.v = v;\n        this.u = u;\n        this.w = w;\n    }\n\n    @Override\n    public int compareTo(edge o) {\n        return Long.compare(w, o.w);\n    }\n}\n\nclass dsu {\n    int n;\n    int p[];\n\n    dsu(int n) {\n        this.n = n;\n        p = new int[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = i;\n        }\n    }\n\n    int find(int a) {\n        if (a == p[a]) return a;\n        return p[a] = find(p[a]);\n    }\n\n    void merge(int a, int b) {\n        p[find(a)] = find(b);\n    }\n\n    boolean same(int a, int b) {\n        return find(a) == find(b);\n    }\n}\n\nclass FastScanner {\n    BufferedReader br;\n    StringTokenizer st;\n\n    FastScanner(File f) throws FileNotFoundException {\n        br = new BufferedReader(new FileReader(f));\n    }\n\n    FastScanner(InputStream is) {\n        br = new BufferedReader(new InputStreamReader(is));\n    }\n\n    String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n}","binary search,dsu,graphs,shortest paths,trees"
"import java.io.*;\nimport java.util.*;\npublic class a{\n    public static FastScanner fs;\n    public static int n,m,k,q,rank[],par[],edgeends[][];\n    public static long edgeweights[],ans[];\n    public static ArrayList<Edge>g[];\n    public static HashSet<Integer>queryqueue[];\n    public static distclass dist[];\n    public static final long INF=Long.MAX_VALUE;\n    public static void main(String args[])\n    {\n        //excellent question hats off to the author\n        //got to understand dsu :)\n        fs=new FastScanner();\n        n=fs.nextInt();\n        m=fs.nextInt();\n        k=fs.nextInt();\n        q=fs.nextInt();\n        queryqueue=new HashSet[n+1];\n        g=new ArrayList[n+1];\n        rank=new int[n+1];\n        par=new int[n+1];\n        dist=new distclass[n+1];\n        edgeends=new int[m+1][2];\n        edgeweights=new long[m+1];\n        ans=new long[q+1];\n        for(int i=1;i<=n;i++)\n        {\n            rank[i]=0;\n            par[i]=i;\n            queryqueue[i]=new HashSet<>();\n            if(i<=k)\n            {\n                dist[i]=new distclass(i,0l);\n            }\n            else\n            {\n                dist[i]=new distclass(-1,INF);\n            }\n            g[i]=new ArrayList<>();\n        }\n        for(int i=1;i<=m;i++)\n        {\n            int u=fs.nextInt();\n            int v=fs.nextInt();\n            long w=fs.nextLong();\n            edgeends[i][0]=u;\n            edgeends[i][1]=v;\n            edgeweights[i]=w;\n            g[u].add(new Edge(v,w));\n            g[v].add(new Edge(u,w));\n        }\n        for(int i=1;i<=q;i++)\n        {\n            int a,b;\n            a=fs.nextInt();\n            b=fs.nextInt();\n            queryqueue[a].add(i);\n            queryqueue[b].add(i);\n        }\n        PriorityQueue<queueele> pq=new PriorityQueue<>(1,new Comparator<>(){\n            public int compare(queueele a,queueele b)\n            {\n                if(a.w<b.w)\n                    return -1;\n                else if(a.w>b.w)\n                    return 1;\n                else \n                    return 0;\n            }\n        });\n        for(int i=1;i<=k;i++)\n            pq.add(new queueele(dist[i].v,dist[i].w));\n        while(pq.peek()!=null)\n        {\n            queueele tp=pq.poll();\n            int u=tp.u;\n            long curdisttonode=tp.w;\n            if(dist[u].w != curdisttonode)\n                continue;\n            for(Edge it:g[u])\n            {\n                long w=it.w;\n                int v=it.v;\n                if(dist[v].w > (curdisttonode+w))\n                {\n                    dist[v].w=curdisttonode+w;\n                    dist[v].v=dist[u].v;\n                    pq.add(new queueele(v,dist[v].w));\n                }\n            }\n        }\n        ArrayList<Event>events=new ArrayList<>();\n        for(int i=1;i<=m;i++)\n        {\n            if(dist[edgeends[i][0]].v!=dist[edgeends[i][1]].v)\n            {\n                events.add(new Event(dist[edgeends[i][0]].v,dist[edgeends[i][1]].v,dist[edgeends[i][0]].w+dist[edgeends[i][1]].w+edgeweights[i]));\n            }\n        }\n        Collections.sort(events,new Comparator<>(){\n            public int compare(Event a,Event b)\n            {\n                if(a.w<b.w)\n                    return -1;\n                else if(a.w>b.w)\n                    return 1;\n                else \n                    return 0;\n            }\n        });\n        for(int i=0;i<events.size();i++)\n        {\n            merge(events.get(i).u,events.get(i).v,events.get(i).w);\n        }\n        StringBuilder Sb=new StringBuilder("""");\n        for(int i=1;i<=q;i++)\n        {\n            Sb.append(ans[i]+""\n"");\n        }\n        System.out.println(Sb);\n    }\n    public static void merge(int u,int v,long w)\n    {\n        u=f(u);\n        v=f(v);\n        if(u==v)\n            return;\n        if(rank[u]<rank[v])\n        {\n            par[u]=v;\n        }\n        else if(rank[u]>rank[v])\n        {\n            par[v]=u;\n        }\n        else\n        {\n            par[v]=u;\n            rank[u]++;\n        }\n        if(f(v)==v)\n        {\n            int temp=u;\n            u=v;\n            v=temp;\n        }\n        if(queryqueue[u].size()<queryqueue[v].size())//small to large technique\n        {\n            HashSet<Integer> temp=queryqueue[u];\n            queryqueue[u]=queryqueue[v];\n            queryqueue[v]=temp;\n        }\n        Iterator<Integer> it=queryqueue[v].iterator();\n        while(it.hasNext())\n        {\n            Integer val=it.next();\n            if(queryqueue[u].contains(val))\n            {\n                ans[val]=w;\n                queryqueue[u].remove(val);\n            }\n            else\n            {\n                queryqueue[u].add(val);\n            }\n        }\n    }\n    public static int f(int x)\n    {\n        if(par[x]==x)\n            return x;\n        return par[x]=f(par[x]);\n    }\n    static class Edge\n    {\n        int v;\n        long w;\n        Edge(int v,long w)\n        {\n            this.v=v;\n            this.w=w;\n        }\n    }\n    static class distclass\n    {\n        long w;\n        int v;\n        distclass(int v,long w)\n        {\n            this.v=v;\n            this.w=w;\n        }\n    }\n    static class queueele\n    {\n        long w;\n        int u;\n        queueele(int u,long w)\n        {\n            this.u=u;\n            this.w=w;\n        }\n    }\n    static class Event\n    {\n        long w;\n        int u,v;\n        Event(int u,int v,long w)\n        {\n            this.w=w;\n            this.u=u;\n            this.v=v;\n        }\n    }\n    static class FastScanner\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer("""");\n        String next()\n        {\n            while(!st.hasMoreTokens())\n            {\n                try{\n                    st=new StringTokenizer(br.readLine());\n                }\n                catch(Exception e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n}","binary search,dsu,graphs,shortest paths,trees"
"import java.io.*;\nimport java.util.*;\npublic class a{\n    public static FastScanner fs;\n    public static int n,m,k,q,rank[],par[],edgeends[][];\n    public static long edgeweights[],ans[];\n    public static ArrayList<Edge>g[];\n    public static HashSet<Integer>queryqueue[];\n    public static distclass dist[];\n    public static final long INF=Long.MAX_VALUE;\n    public static void main(String args[])\n    {\n        fs=new FastScanner();\n        n=fs.nextInt();\n        m=fs.nextInt();\n        k=fs.nextInt();\n        q=fs.nextInt();\n        queryqueue=new HashSet[n+1];\n        g=new ArrayList[n+1];\n        rank=new int[n+1];\n        par=new int[n+1];\n        dist=new distclass[n+1];\n        edgeends=new int[m+1][2];\n        edgeweights=new long[m+1];\n        ans=new long[q+1];\n        for(int i=1;i<=n;i++)\n        {\n            rank[i]=0;\n            par[i]=i;\n            queryqueue[i]=new HashSet<>();\n            if(i<=k)\n            {\n                dist[i]=new distclass(i,0l);\n            }\n            else\n            {\n                dist[i]=new distclass(-1,INF);\n            }\n            g[i]=new ArrayList<>();\n        }\n        for(int i=1;i<=m;i++)\n        {\n            int u=fs.nextInt();\n            int v=fs.nextInt();\n            long w=fs.nextLong();\n            edgeends[i][0]=u;\n            edgeends[i][1]=v;\n            edgeweights[i]=w;\n            g[u].add(new Edge(v,w));\n            g[v].add(new Edge(u,w));\n        }\n        for(int i=1;i<=q;i++)\n        {\n            int a,b;\n            a=fs.nextInt();\n            b=fs.nextInt();\n            queryqueue[a].add(i);\n            queryqueue[b].add(i);\n        }\n        PriorityQueue<queueele> pq=new PriorityQueue<>(1,new Comparator<>(){\n            public int compare(queueele a,queueele b)\n            {\n                if(a.w<b.w)\n                    return -1;\n                else if(a.w>b.w)\n                    return 1;\n                else \n                    return 0;\n            }\n        });\n        for(int i=1;i<=k;i++)\n            pq.add(new queueele(dist[i].v,dist[i].w));\n        while(pq.peek()!=null)\n        {\n            queueele tp=pq.poll();\n            int u=tp.u;\n            long curdisttonode=tp.w;\n            if(dist[u].w != curdisttonode)\n                continue;\n            for(Edge it:g[u])\n            {\n                long w=it.w;\n                int v=it.v;\n                if(dist[v].w > (curdisttonode+w))\n                {\n                    dist[v].w=curdisttonode+w;\n                    dist[v].v=dist[u].v;\n                    pq.add(new queueele(v,dist[v].w));\n                }\n            }\n        }\n        // for(int i=1;i<=n;i++)\n        // {\n        //     System.out.println(dist[i].w+"" ""+dist[i].v);\n        // }\n        ArrayList<Event>events=new ArrayList<>();\n        for(int i=1;i<=m;i++)\n        {\n            if(dist[edgeends[i][0]].v!=dist[edgeends[i][1]].v)\n            {\n                events.add(new Event(dist[edgeends[i][0]].v,dist[edgeends[i][1]].v,dist[edgeends[i][0]].w+dist[edgeends[i][1]].w+edgeweights[i]));\n            }\n        }\n        Collections.sort(events,new Comparator<>(){\n            public int compare(Event a,Event b)\n            {\n                if(a.w<b.w)\n                    return -1;\n                else if(a.w>b.w)\n                    return 1;\n                else \n                    return 0;\n            }\n        });\n        // for(int i=0;i<events.size();i++)\n        // {\n        //     System.out.println(events.get(i).w+"" ""+events.get(i).u+"" ""+events.get(i).v);\n        // }\n        for(int i=0;i<events.size();i++)\n        {\n            merge(events.get(i).u,events.get(i).v,events.get(i).w);\n        }\n        StringBuilder Sb=new StringBuilder("""");\n        for(int i=1;i<=q;i++)\n        {\n            Sb.append(ans[i]+""\n"");\n        }\n        System.out.println(Sb);\n    }\n    public static void merge(int u,int v,long w)\n    {\n        u=f(u);\n        v=f(v);\n        if(u==v)\n            return;\n        if(rank[u]<rank[v])\n        {\n            par[u]=v;\n        }\n        else if(rank[u]>rank[v])\n        {\n            par[v]=u;\n        }\n        else\n        {\n            par[v]=u;\n            rank[u]++;\n        }\n        if(f(v)==v)\n        {\n            int temp=u;\n            u=v;\n            v=temp;\n        }\n        if(queryqueue[u].size()<queryqueue[v].size())\n        {\n            HashSet<Integer> temp=queryqueue[u];\n            queryqueue[u]=queryqueue[v];\n            queryqueue[v]=temp;\n        }\n        // System.out.println(u+"" ""+v);\n        // System.out.println(queryqueue[u].size()+"" ""+queryqueue[v].size());\n        Iterator<Integer> it=queryqueue[v].iterator();\n        // while(it.hasNext())\n        // {\n        //     System.out.println(it.next());\n        // }\n        // it=queryqueue[v].iterator();\n        // while(it.hasNext())\n        // {\n        //     System.out.println(it.next());\n        // }\n        // it=queryqueue[v].iterator();\n        while(it.hasNext())\n        {\n            Integer val=it.next();\n            // System.out.println(val);\n            if(queryqueue[u].contains(val))\n            {\n                ans[val]=w;\n                queryqueue[u].remove(val);\n                // System.out.println(""inside"");\n            }\n            else\n            {\n                queryqueue[u].add(val);\n                // System.out.println(""not contains"");\n            }\n        }\n    }\n    public static int f(int x)\n    {\n        if(par[x]==x)\n            return x;\n        return par[x]=f(par[x]);\n    }\n    static class Edge\n    {\n        int v;\n        long w;\n        Edge(int v,long w)\n        {\n            this.v=v;\n            this.w=w;\n        }\n    }\n    static class distclass\n    {\n        long w;\n        int v;\n        distclass(int v,long w)\n        {\n            this.v=v;\n            this.w=w;\n        }\n    }\n    static class queueele\n    {\n        long w;\n        int u;\n        queueele(int u,long w)\n        {\n            this.u=u;\n            this.w=w;\n        }\n    }\n    static class Event\n    {\n        long w;\n        int u,v;\n        Event(int u,int v,long w)\n        {\n            this.w=w;\n            this.u=u;\n            this.v=v;\n        }\n    }\n    static class FastScanner\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer("""");\n        String next()\n        {\n            while(!st.hasMoreTokens())\n            {\n                try{\n                    st=new StringTokenizer(br.readLine());\n                }\n                catch(Exception e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n}","binary search,dsu,graphs,shortest paths,trees"
"import java.io.*;\nimport java.sql.Array;\nimport java.util.StringTokenizer;\n\npublic class D {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        task solver = new task();\n        solver.solve(in, out);\n        out.close();\n    }\n\n    static class task {\n        public void solve(InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            String s = in.next();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++){\n                a[i] = (s.charAt(i) == ')' ? -1 : 1);\n            }\n            int res = 0; int l = -1; int r = -1;\n            for (int i = 0; i < n; i++){\n                for (int j = 0; j < n; j++){\n                    int tmp = a[i];\n                    a[i] = a[j]; a[j] = tmp;\n                    int mn = n + 1;\n                    int cnt = 0; int cur = 0;\n                    for (int x : a){\n                        cur += x;\n                        if (cur < mn){\n                            mn = cur;\n                            cnt = 1;\n                        }\n                        else if (cur == mn){\n                            cnt++;\n                        }\n                    }\n                    if (cur != 0){\n                        out.println(0);\n                        out.println(1 + "" "" + 1);\n                        return;\n                    }\n                    if (cnt > res){\n                        res = cnt;\n                        l = i + 1; r = j + 1;\n                    }\n                    tmp = a[i];\n                    a[i] = a[j]; a[j] = tmp;\n                }\n            }\n            out.println(res);\n            out.println(l + "" "" + r);\n        }\n    }\n\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer st;\n\n        public InputReader(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s), 32768);\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n","brute force,dp,greedy,implementation"
"import java.io.*;\nimport java.util.*;\npublic class Main {\n	static int calc(char[] l) {\n		int num=0;\n		int sum=0;\n		for(int i=0;i<l.length;i++) {\n			if(l[i]=='(') {\n				sum++;\n			}\n			else {\n				sum--;\n			}\n			if(sum==0) {\n				num++;\n			}\n		}\n		return num;\n	}\n	static boolean check(char[] l) {\n		int sum=0;\n		for(int i=0;i<l.length;i++) {\n			if(l[i]=='(') {\n				sum++;\n			}\n			else {\n				sum--;\n			}\n			if(sum<0) {\n				return false;\n			}\n		}\n		return sum==0;\n	}\n	static int helper(char[] l) {\n		int n=l.length;\n		int[] sum=new int[n];\n		int mn=0;\n//		System.out.println(""Start"");\n//		System.out.println(l);\n		for(int i=0;i<l.length;i++) {\n			if(i>0) sum[i]=sum[i-1];\n			if(l[i]=='(') {\n				sum[i]++;\n			}\n			else {\n				sum[i]--;\n			}\n			mn=Math.min(mn, sum[i]);\n		}\n//		System.out.println(Arrays.toString(sum));\n		if(mn>0) return 0;\n		if(mn==0) {\n			if(check(l)) return calc(l);\n			return 0;\n		}\n		int ind=0;\n		int mn2=sum[n-1];\n		for(int i=n-2;i>-1;i--) {\n			if(sum[n-1]-sum[i]==-mn && mn2>=sum[i+1]) {\n				ind=i+1;\n			}\n			mn2=Math.min(mn2, sum[i]);\n		}\n		char[] changed=new char[n];\n		int curr=0;\n		for(int i=ind;i<n;i++) {\n			changed[curr++]=l[i];\n		}\n		for(int i=0;i<ind;i++) {\n			changed[curr++]=l[i];\n		}\n//		System.out.println(changed);\n		int ans=0;\n		if(check(changed)) {\n			ans=Math.max(ans,calc(changed));\n		}\n		return ans;\n	}\n	public static void main(String[] args) throws IOException \n	{ \n		FastScanner f = new FastScanner(); \n		int ttt=1;\n//		ttt=f.nextInt();\n		PrintWriter out=new PrintWriter(System.out);\n		outer:for(int tt=0;tt<ttt;tt++) {\n			int n=f.nextInt(); \n			char[] l=f.next().toCharArray();\n			int ans=helper(l);\n			int a=1;\n			int b=1;\n			for(int i=0;i<n;i++) {\n				for(int j=0;j<n;j++) {\n//					System.out.println(i+"" ""+j+"" ""+ans);\n					if(l[i]==l[j]) continue;\n					char temp=l[i];\n					l[i]=l[j];\n					l[j]=temp;\n					int curr=helper(l);\n					if(curr>ans) {\n						ans=curr;\n						a=i+1;\n						b=j+1;\n					}\n					temp=l[i];\n					l[i]=l[j];\n					l[j]=temp;\n				}\n			}\n			System.out.println(ans);\n			System.out.println(a+"" ""+b);\n		}\n		out.close();\n	} \n	static void sort(int[] p) {\n        ArrayList<Integer> q = new ArrayList<>();\n        for (int i: p) q.add( i);\n        Collections.sort(q);\n        for (int i = 0; i < p.length; i++) p[i] = q.get(i);\n    }\n	static class FastScanner {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n		String next() {\n			while (!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		int[] readArray(int n) {\n			int[] a=new int[n];\n			for (int i=0; i<n; i++) a[i]=nextInt();\n			return a;\n		}\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n		long[] readLongArray(int n) {\n			long[] a=new long[n];\n			for (int i=0; i<n; i++) a[i]=nextLong();\n			return a;\n		}\n	}\n}","brute force,dp,greedy,implementation"
"//package div3;\n\nimport java.io.*;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class board\n{\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = """";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    static void print(List<Integer> l){\n        for(int ele:l){\n            System.out.print(ele+"" "");\n        }\n        System.out.println();\n    }\n    static Integer[][][] dp;\n    static long mod = (int)(1e9+7);\n    static long add(long a,long b){\n        return (a%mod+b%mod)%mod;\n    }\n//    static int mul(int a,int b){\n//        return (a%mod * b%mod)%mod;\n//    }\n\n    static void swap(char[] ch,int i,int j){\n        char temp = ch[i];\n        ch[i] = ch[j];\n        ch[j] = temp;\n    }\n    static int compute(char[] ch){\n        int n = ch.length;\n        int[] pre = new int[n];\n        pre[0] = (ch[0] == '(')?1:-1;\n\n        int min = pre[0];\n        for(int i=1;i<n;i++){\n            pre[i] = pre[i-1]+((ch[i] == '(')?1:-1);\n            min = Math.min(min,pre[i]);\n        }\n        int count = 0;\n        for(int i=0;i<n;i++){\n            if(pre[i] == min){\n                count++;\n            }\n        }\n        return count;\n\n\n    }\n    /*\n\n    *  ()()(()())()\n    * */\n    public static void main(String[] args)\n    {\n        FastReader sc=new FastReader();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        //int t  = sc.nextInt();\n\n\n        int n = sc.nextInt();\n        char[] ch = sc.nextLine().toCharArray();\n        int c = 0;\n        for(int i=0;i<n;i++){\n            c += (ch[i] == '(')?1:-1;\n        }\n        if(c != 0){\n            System.out.println(0);\n            System.out.println(1+"" ""+1);\n        }\n        else {\n            char[] ch1 = new char[n];\n            int max = compute(ch);\n            int l = 1, r = 1;\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    swap(ch, i, j);\n                    int shifts = compute(ch);\n                    if (shifts > max) {\n                        max = shifts;\n                        l = i + 1;\n                        r = j + 1;\n                    }\n                    //max = Math.max(max,shifts);\n                    swap(ch, i, j);\n                }\n            }\n            //for(char c:ch1)System.out.print(c);\n            System.out.println(max);\n            System.out.println(l + "" "" + r);\n\n        }\n\n    }\n}","brute force,dp,greedy,implementation"
"import java.io.BufferedOutputStream;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.function.Function;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	static class TaskAdapter implements Runnable {\n		@Override\n		public void run() {\n			InputStream inputStream = System.in;\n			OutputStream outputStream = System.out;\n			FastReader in = new FastReader(inputStream);\n			Output out = new Output(outputStream);\n			D1TheWorldIsJustAProgrammingTaskEasyVersion solver = new D1TheWorldIsJustAProgrammingTaskEasyVersion();\n			solver.solve(1, in, out);\n			out.close();\n		}\n	}\n\n	public static void main(String[] args) throws Exception {\n		Thread thread = new Thread(null, new TaskAdapter(), """", 1<<28);\n		thread.start();\n		thread.join();\n	}\n	static class D1TheWorldIsJustAProgrammingTaskEasyVersion {\n		int n;\n\n		public D1TheWorldIsJustAProgrammingTaskEasyVersion() {\n		}\n\n		public int solve(int[] arr) {\n			int[] psum = new int[n+1];\n			for(int i = 0; i<n; i++) {\n				psum[i+1] = psum[i]+arr[i];\n			}\n			int[] smin = new int[n+1], emin = new int[n+1];\n			smin[0] = psum[0];\n			emin[n] = psum[n];\n			for(int i = 1; i<=n; i++) {\n				smin[i] = Math.min(smin[i-1], psum[i]);\n			}\n			for(int i = n-1; i>=0; i--) {\n				emin[i] = Math.min(emin[i+1], psum[i]);\n			}\n			if(emin[0]<0) {\n				for(int i = 0; i<=n; i++) {\n					if(i==n) {\n						return 0;\n					}\n					if(psum[n]-psum[i+1]+smin[i+1]>=0&&(i<n-1 ? emin[i+2] : 0)-psum[i+1]>=0) {\n						Utilities.leftShift(arr, i+1);\n						break;\n					}\n				}\n			}\n			int cnt = 0, sum = 0;\n			for(int i = 0; i<n; i++) {\n				if((sum += arr[i])==0) {\n					cnt++;\n				}\n			}\n			return cnt;\n		}\n\n		public void solve(int kase, InputReader in, Output pw) {\n			n = in.nextInt();\n			int[] arr = in.nextIntChar(o -> o=='(' ? 1 : -1);\n			int sum = 0;\n			for(int i = 0; i<n; i++) {\n				sum += arr[i];\n			}\n			if(sum!=0) {\n				pw.println(""0\n1 1"");\n				return;\n			}\n			int ans = solve(arr.clone()), l = 0, r = 0;\n			for(int i = 0; i<n; i++) {\n				for(int j = i+1; j<n; j++) {\n					Utilities.Debug.dbg(arr);\n					if(arr[i]!=arr[j]) {\n						Utilities.swap(arr, i, j);\n						int cnt = solve(arr.clone());\n						if(cnt>ans) {\n							ans = cnt;\n							l = i;\n							r = j;\n						}\n						Utilities.swap(arr, i, j);\n					}\n				}\n			}\n			pw.println(ans);\n			pw.println(l+1, r+1);\n		}\n\n	}\n\n	static class Utilities {\n		public static void swap(int[] arr, int i, int j) {\n			if(i!=j) {\n				arr[i] ^= arr[j];\n				arr[j] ^= arr[i];\n				arr[i] ^= arr[j];\n			}\n		}\n\n		public static void leftShift(int[] arr, int offSet) {\n			int[] tmp = new int[offSet];\n			System.arraycopy(arr, 0, tmp, 0, offSet);\n			System.arraycopy(arr, offSet, arr, 0, arr.length-offSet);\n			System.arraycopy(tmp, 0, arr, arr.length-offSet, offSet);\n		}\n\n		public static class Debug {\n			public static final boolean LOCAL = System.getProperty(""ONLINE_JUDGE"")==null;\n\n			private static <T> String ts(T t) {\n				if(t==null) {\n					return ""null"";\n				}\n				try {\n					return ts((Iterable) t);\n				}catch(ClassCastException e) {\n					if(t instanceof int[]) {\n						String s = Arrays.toString((int[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof long[]) {\n						String s = Arrays.toString((long[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof char[]) {\n						String s = Arrays.toString((char[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof double[]) {\n						String s = Arrays.toString((double[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof boolean[]) {\n						String s = Arrays.toString((boolean[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}\n					try {\n						return ts((Object[]) t);\n					}catch(ClassCastException e1) {\n						return t.toString();\n					}\n				}\n			}\n\n			private static <T> String ts(T[] arr) {\n				StringBuilder ret = new StringBuilder();\n				ret.append(""{"");\n				boolean first = true;\n				for(T t: arr) {\n					if(!first) {\n						ret.append("", "");\n					}\n					first = false;\n					ret.append(ts(t));\n				}\n				ret.append(""}"");\n				return ret.toString();\n			}\n\n			private static <T> String ts(Iterable<T> iter) {\n				StringBuilder ret = new StringBuilder();\n				ret.append(""{"");\n				boolean first = true;\n				for(T t: iter) {\n					if(!first) {\n						ret.append("", "");\n					}\n					first = false;\n					ret.append(ts(t));\n				}\n				ret.append(""}"");\n				return ret.toString();\n			}\n\n			public static void dbg(Object... o) {\n				if(LOCAL) {\n					System.err.print(""Line #""+Thread.currentThread().getStackTrace()[2].getLineNumber()+"": ["");\n					for(int i = 0; i<o.length; i++) {\n						if(i!=0) {\n							System.err.print("", "");\n						}\n						System.err.print(ts(o[i]));\n					}\n					System.err.println(""]"");\n				}\n			}\n\n		}\n\n	}\n\n	static class Output implements Closeable, Flushable {\n		public StringBuilder sb;\n		public OutputStream os;\n		public int BUFFER_SIZE;\n		public boolean autoFlush;\n		public String lineSeparator;\n\n		public Output(OutputStream os) {\n			this(os, 1<<16);\n		}\n\n		public Output(OutputStream os, int bs) {\n			BUFFER_SIZE = bs;\n			sb = new StringBuilder(BUFFER_SIZE);\n			this.os = new BufferedOutputStream(os, 1<<17);\n			autoFlush = false;\n			lineSeparator = System.lineSeparator();\n		}\n\n		public void print(String s) {\n			sb.append(s);\n			if(autoFlush) {\n				flush();\n			}else if(sb.length()>BUFFER_SIZE >> 1) {\n				flushToBuffer();\n			}\n		}\n\n		public void println(int i) {\n			println(String.valueOf(i));\n		}\n\n		public void println(Object... o) {\n			for(int i = 0; i<o.length; i++) {\n				if(i!=0) {\n					print("" "");\n				}\n				print(String.valueOf(o[i]));\n			}\n			println();\n		}\n\n		public void println(String s) {\n			sb.append(s);\n			println();\n			if(autoFlush) {\n				flush();\n			}else if(sb.length()>BUFFER_SIZE >> 1) {\n				flushToBuffer();\n			}\n		}\n\n		public void println() {\n			sb.append(lineSeparator);\n		}\n\n		private void flushToBuffer() {\n			try {\n				os.write(sb.toString().getBytes());\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n			sb = new StringBuilder(BUFFER_SIZE);\n		}\n\n		public void flush() {\n			try {\n				flushToBuffer();\n				os.flush();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n		public void close() {\n			flush();\n			try {\n				os.close();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n	}\n\n	static class FastReader implements InputReader {\n		final private int BUFFER_SIZE = 1<<16;\n		private DataInputStream din;\n		private byte[] buffer;\n		private int bufferPointer;\n		private int bytesRead;\n\n		public FastReader(InputStream is) {\n			din = new DataInputStream(is);\n			buffer = new byte[BUFFER_SIZE];\n			bufferPointer = bytesRead = 0;\n		}\n\n		public String next() {\n			StringBuilder ret = new StringBuilder(64);\n			byte c = skip();\n			while(c!=-1&&!isSpaceChar(c)) {\n				ret.appendCodePoint(c);\n				c = read();\n			}\n			return ret.toString();\n		}\n\n		public int nextInt() {\n			int ret = 0;\n			byte c = skipToDigit();\n			boolean neg = (c=='-');\n			if(neg) {\n				c = read();\n			}\n			do {\n				ret = ret*10+c-'0';\n			} while((c = read())>='0'&&c<='9');\n			if(neg) {\n				return -ret;\n			}\n			return ret;\n		}\n\n		private boolean isSpaceChar(byte b) {\n			return b==' '||b=='\r'||b=='\n'||b=='\t'||b=='\f';\n		}\n\n		private byte skip() {\n			byte ret;\n			while(isSpaceChar((ret = read()))) ;\n			return ret;\n		}\n\n		private boolean isDigit(byte b) {\n			return b>='0'&&b<='9';\n		}\n\n		private byte skipToDigit() {\n			byte ret;\n			while(!isDigit(ret = read())&&ret!='-') ;\n			return ret;\n		}\n\n		private void fillBuffer() {\n			try {\n				bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n			}catch(IOException e) {\n				e.printStackTrace();\n				throw new InputMismatchException();\n			}\n			if(bytesRead==-1) {\n				buffer[0] = -1;\n			}\n		}\n\n		private byte read() {\n			if(bytesRead==-1) {\n				throw new InputMismatchException();\n			}else if(bufferPointer==bytesRead) {\n				fillBuffer();\n			}\n			return buffer[bufferPointer++];\n		}\n\n	}\n\n	static interface InputReader {\n		String next();\n\n		int nextInt();\n\n		default int[] nextIntChar(Function<Character, Integer> f) {\n			String s = next();\n			int[] ret = new int[s.length()];\n			for(int i = 0; i<s.length(); i++) {\n				ret[i] = f.apply(s.charAt(i));\n			}\n			return ret;\n		}\n\n	}\n}\n\n\n","brute force,dp,greedy,implementation"
"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class P7 {\n\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int t=in.nextInt();\n		for(int h=0;h<t;h++) {\n			int n=in.nextInt();\n			long m=in.nextLong();\n			long []a=new long[n];\n			for(int i=0;i<n;i++) {\n				 a[i]=in.nextLong();\n			}\n			Arrays.sort(a);\n		    long k=n+2*a[n-1];\n		    int i=1;\n		    for( i=1;i<n;i++) {\n		    	if(k<=m) {\n		    		 k=k+a[i];\n		    	}\n		    	else\n		    		break;\n		    }\n			if(i==n) {\n				System.out.println(""Yes"");\n			}\n			else\n				System.out.println(""No"");\n			\n			\n		}\n		\n}}\n","greedy,math"
"import java.util.*;\n\npublic class chairs {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int t=sc.nextInt();\n        while(t-->0)\n        {\n            int n=sc.nextInt();\n            int m=sc.nextInt();\n            int[] a=new int[n];\n            for(int i=0;i<n;i++)\n            a[i]=sc.nextInt();\n\n            Arrays.sort(a);\n            long sum=0l;\n            for(int i=1;i<n-1;i++)\n                sum+=a[i];\n\n            sum+=a[n-1]*2+n;\n\n            if(sum<=m)\n            System.out.println(""YES"");\n            else\n            System.out.println(""NO"");\n        }\n        sc.close();\n    }\n}\n","greedy,math"
"\n\nimport java.util.*;\n\npublic class CodeForces {\n	\n	\n\n	public static void main(String[] args) {\n		try {\n			\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while( t -- > 0) {\n			int n = sc.nextInt();\n			int m = sc.nextInt();\n			int arr [] = new int[n];\n			for(int i = 0 ; i < n ; i++) {\n				arr[i] = sc.nextInt();\n			}\n			Arrays.sort(arr);\n			long sum = 0;\n			for(int i = 0 ; i < n - 1 ; i++) {\n				sum += Math.max(arr[i],arr[i + 1]);\n			}\n			sum += Math.max(arr[n-1],arr[0]);\n			sum += n;\n			if(sum <= m) {\n				System.out.println(""Yes"");\n			}else {\n				System.out.println(""No"");\n			}\n			\n			\n		}\n		 \n        \n		} catch(Exception e ) {\n			return ;\n		}\n		\n	}\n\n}\n","greedy,math"
"import java.util.*;\n\npublic class C_1_F {\n    public static void main(String[] args) {\n        Scanner input=new Scanner(System.in);\n        int t=input.nextInt();\n        while(t-->0){\n            int n=input.nextInt();\n            long m=input.nextLong();\n            long sum=0;\n            int max=0;\n            int min=Integer.MAX_VALUE;\n            for(int i=0;i<n;i++){\n                int x=input.nextInt();\n                sum+=x;\n                max=Math.max(x,max);\n                min=Math.min(min,x);\n            }\n            long res=sum+n+max-min;\n            if(res>m){\n                System.out.println(""NO"");\n            }else{\n                System.out.println(""YES"");\n            }\n        }\n    }\n}","greedy,math"
"import java.util.*;\npublic class c1668A {\n	public static void main (String[] args) {\n		Scanner in=new Scanner(System.in);\n		int tt=in.nextInt(), t=0;\n		while(t++<tt) {\n			int a=in.nextInt(),\n				b=in.nextInt(),\n				r;\n			if(a>b) { r=a; a=b; b=r; }\n			if(a==1 && b>2)\n				r=-1;\n			else\n				r=2*(b-1)-(b-a)%2;\n			System.out.println(r);\n		} in.close();\n	}\n}",math
"import java.util.*;\npublic class DC {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0) {\n			int n=sc.nextInt(),m=sc.nextInt(),ans=0;\n			if(n<m) {\n				n^=m;m^=n;n^=m;\n			}\n				ans=n+m-2;\n			if((n-m)>1 && m<2) {\n				ans=-1;\n			}else {\n				ans+=(n-m>>1)<<1;\n			}\n			System.out.println(ans);\n		}\n	}\n}",math
"import java.util.*;\n\npublic class s {\n	public static void main(String args[]) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n =sc.nextInt()-1;\n			int m =sc.nextInt()-1;\n			int res= Math.min(n, m)*2+1;\n			int diff =Math.abs(n-m)-1;\n			if(diff%2==0)\n			{\n				res+=diff*2;\n			}\n			else\n				res+=diff*2+1;\n			if(n==0||m==0)\n			{\n				if(Math.abs(n-m)>1)\n					res=-1;\n			}\n			System.out.println(res);\n			\n	}\n	\n}}",math
import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class P7 {\n\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int t=in.nextInt();\n		for(int h=0;h<t;h++) {\n			int n=in.nextInt();\n			int m=in.nextInt();\n			if(n>1&m>1)\n			System.out.println(n+m-2+((Math.abs(n-m)/2)*2));\n			else {\n				if(n==1&m==1) \n					System.out.println(0);\n				else {\n					if(n==2|m==2)\n						System.out.println(1);\n					else\n				System.out.println(-1);}}\n		}\n		\n}}\n,math
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1262D2 extends PrintWriter {\n	CF1262D2() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1262D2 o = new CF1262D2(); o.main(); o.flush();\n	}\n\n	int[] st; int n_;\n	void update(int i) {\n		for (i += n_; i > 0; i >>= 1)\n			st[i]++;\n	}\n	int query(int k) {\n		int i = 1;\n		while (i < n_) {\n			i <<= 1;\n			if (k > st[i]) {\n				k -= st[i];\n				i |= 1;\n			}\n		}\n		return i - n_;\n	}\n	void main() {\n		int n = sc.nextInt();\n		int[] aa = new int[n];\n		Integer[] ii = new Integer[n];\n		for (int i = 0; i < n; i++) {\n			aa[i] = sc.nextInt();\n			ii[i] = i;\n		}\n		Arrays.sort(ii, (i, j) -> aa[i] != aa[j] ? aa[j] - aa[i] : i - j);\n		int m = sc.nextInt();\n		int[] kk = new int[m];\n		int[] pp = new int[m];\n		int[] ans = new int[m];\n		Integer[] hh = new Integer[m];\n		for (int h = 0; h < m; h++) {\n			kk[h] = sc.nextInt();\n			pp[h] = sc.nextInt();\n			hh[h] = h;\n		}\n		Arrays.sort(hh, (u, v) -> kk[u] - kk[v]);\n		n_ = 1;\n		while (n_ < n)\n			n_ <<= 1;\n		st = new int[n_ << 1];\n		for (int k = 0, h = 0; h < m; h++) {\n			int h_ = hh[h], k_ = kk[h_], p_ = pp[h_];\n			while (k < k_)\n				update(ii[k++]);\n			ans[h_] = aa[query(p_)];\n		}\n		for (int h = 0; h < m; h++)\n			println(ans[h]);\n	}\n}\n","data structures,greedy"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1262D2 extends PrintWriter {\n	CF1262D2() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1262D2 o = new CF1262D2(); o.main(); o.flush();\n	}\n\n	int[] ft;\n	void update(int i, int n) {\n		while (i < n) {\n			ft[i]++;\n			i |= i + 1;\n		}\n	}\n	int query(int i) {\n		int sum = 0;\n		while (i >= 0) {\n			sum += ft[i];\n			i &= i + 1; i--;\n		}\n		return sum;\n	}\n	void main() {\n		int n = sc.nextInt();\n		int[] aa = new int[n];\n		Integer[] ii = new Integer[n];\n		for (int i = 0; i < n; i++) {\n			aa[i] = sc.nextInt();\n			ii[i] = i;\n		}\n		Arrays.sort(ii, (i, j) -> aa[i] != aa[j] ? aa[j] - aa[i] : i - j);\n		int m = sc.nextInt();\n		int[] kk = new int[m];\n		int[] pp = new int[m];\n		int[] ans = new int[m];\n		Integer[] hh = new Integer[m];\n		for (int h = 0; h < m; h++) {\n			kk[h] = sc.nextInt();\n			pp[h] = sc.nextInt();\n			hh[h] = h;\n		}\n		Arrays.sort(hh, (u, v) -> kk[u] - kk[v]);\n		ft = new int[n];\n		for (int k = 0, h = 0; h < m; h++) {\n			int h_ = hh[h], k_ = kk[h_], p_ = pp[h_];\n			while (k < k_)\n				update(ii[k++], n);\n			int lower = -1, upper = n - 1;\n			while (upper - lower > 1) {\n				int i = (lower + upper) / 2;\n				if (query(i) >= p_)\n					upper = i;\n				else\n					lower = i;\n			}\n			ans[h_] = aa[upper];\n		}\n		for (int h = 0; h < m; h++)\n			println(ans[h]);\n	}\n}\n","data structures,greedy"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1262D2 extends PrintWriter {\n	CF1262D2() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1262D2 o = new CF1262D2(); o.main(); o.flush();\n	}\n\n	Random rand = new Random();\n	int[] zz, ll, rr, xx, yy; int u_, l_, r_, $;\n	int[] st; int n_;\n	int node(int x) {\n		int u = ++$;\n		zz[u] = rand.nextInt();\n		xx[u] = x;\n		yy[u] = 1;\n		return u;\n	}\n	void pul(int u) {\n		yy[u] = 1 + yy[ll[u]] + yy[rr[u]];\n	}\n	void split(int u, int x) {\n		if (u == 0) {\n			u_ = l_ = r_ = 0;\n			return;\n		}\n		if (xx[u] < x) {\n			split(rr[u], x);\n			rr[u] = l_; l_ = u;\n		} else if (xx[u] > x) {\n			split(ll[u], x);\n			ll[u] = r_; r_ = u;\n		} else {\n			u_ = u; l_ = ll[u]; r_ = rr[u];\n			ll[u] = rr[u] = 0;\n		}\n		pul(u);\n	}\n	int merge(int u, int v) {\n		if (u == 0)\n			return v;\n		if (v == 0)\n			return u;\n		int w;\n		if (zz[u] <= zz[v]) {\n			rr[u] = merge(rr[u], v);\n			w = u;\n		} else {\n			ll[v] = merge(u, ll[v]);\n			w = v;\n		}\n		pul(w);\n		return w;\n	}\n	void update(int x) {\n		split(u_, x);\n		u_ = merge(l_, merge(node(x), r_));\n	}\n	int query(int k) {\n		for (int u = u_, v; ; u = v) {\n			v = ll[u];\n			int y = yy[v] + 1;\n			if (k == y)\n				return xx[u];\n			if (k > y) {\n				k -= y;\n				v = rr[u];\n			}\n		}\n	}\n	void main() {\n		int n = sc.nextInt();\n		int[] aa = new int[n];\n		Integer[] ii = new Integer[n];\n		for (int i = 0; i < n; i++) {\n			aa[i] = sc.nextInt();\n			ii[i] = i;\n		}\n		Arrays.sort(ii, (i, j) -> aa[i] != aa[j] ? aa[j] - aa[i] : i - j);\n		int m = sc.nextInt();\n		int[] kk = new int[m];\n		int[] pp = new int[m];\n		int[] ans = new int[m];\n		Integer[] hh = new Integer[m];\n		for (int h = 0; h < m; h++) {\n			kk[h] = sc.nextInt();\n			pp[h] = sc.nextInt();\n			hh[h] = h;\n		}\n		Arrays.sort(hh, (u, v) -> kk[u] - kk[v]);\n		zz = new int[1 + n]; ll = new int[1 + n]; rr = new int[1 + n];\n		xx = new int[1 + n]; yy = new int[1 + n];\n		for (int k = 0, h = 0; h < m; h++) {\n			int h_ = hh[h], k_ = kk[h_], p_ = pp[h_];\n			while (k < k_)\n				update(ii[k++]);\n			ans[h_] = aa[query(p_)];\n		}\n		for (int h = 0; h < m; h++)\n			println(ans[h]);\n	}\n}\n","data structures,greedy"
"import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class OptimalSubsequence {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int lengthSeq = scanner.nextInt();\n        int[] numbers = new int[lengthSeq + 1];\n        PriorityQueue<Integer[]> maxes = new PriorityQueue<>(new Comparator<Integer[]>() {\n            @Override\n            public int compare(Integer[] arr1, Integer[] arr2) {\n                return (!arr1[0].equals(arr2[0])) ? -arr1[0] + arr2[0] : arr1[1] - arr2[1];\n            }\n        });\n\n        for (int i = 1; i <= lengthSeq; i++) {\n            numbers[i] = scanner.nextInt();\n            maxes.add(new Integer[] {numbers[i], i});\n        }\n\n        int numQuery = scanner.nextInt();\n        int[] result = new int[numQuery];\n        int[][] queries = new int[numQuery][3];\n        for (int i = 0; i < numQuery; i++) {\n            queries[i][0] = scanner.nextInt();\n            queries[i][1] = scanner.nextInt();\n            queries[i][2] = i;\n        }\n        Arrays.sort(queries, (int[] r1, int[] r2) -> {\n            return (r1[0] != r2[0]) ? r1[0] - r2[0] : r1[1] - r2[1];\n        });\n\n        int[] appearance = new int[lengthSeq + 1];\n        int[] bit = new int[lengthSeq + 1];\n        int pointer = 0;\n        for (int i = 1; i <=  queries[queries.length - 1][0]; i++) {\n            Integer[] curr = maxes.poll();\n            assert curr != null;\n            appearance[curr[1]] = 1;\n            update(bit, curr[1]);\n            while (pointer < queries.length && queries[pointer][0] == i) {\n                int targetIndex = queries[pointer][1];\n                int left = 1;\n                int right = lengthSeq;\n                while (left < right) {\n                    int mid = (left + right) >> 1;\n                    if (query(bit, mid) >= targetIndex) right = mid; else left = mid + 1;\n                }\n                result[queries[pointer][2]] = numbers[left];\n                pointer++;\n            }\n\n        }\n        for (int out: result) System.out.println(out);\n    }\n\n    private static void update(int[] bit, int index) {\n        for (; index < bit.length; index += index & -index) bit[index]++;\n    }\n\n    private static int query(int[] bit, int index) {\n        int answer = 0;\n        for (; index > 0; index -= index & -index) answer += bit[index];\n        return answer;\n    }\n}\n\n","data structures,greedy"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1262C extends PrintWriter {\n	CF1262C() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1262C o = new CF1262C(); o.main(); o.flush();\n	}\n\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int k = sc.nextInt();\n			byte[] aa = sc.next().getBytes();\n			byte[] bb = new byte[n];\n			int h = n / 2 - (k - 1);\n			for (int i = 0; i < h; i++) {\n				bb[i] = '(';\n				bb[h + i] = ')';\n			}\n			for (int i = h * 2; i < n; i += 2) {\n				bb[i] = '(';\n				bb[i + 1] = ')';\n			}\n			println(n);\n			for (int i = 0; i < n; i++) {\n				int l = i, r = i;\n				while (aa[r] != bb[i])\n					r++;\n				println((l + 1) + "" "" + (r + 1));\n				while (l < r) {\n					byte tmp = aa[l]; aa[l] = aa[r]; aa[r] = tmp;\n					l++; r--;\n				}\n			}\n		}\n	}\n}\n",constructive algorithms
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n  public static void main(String[] args) throws IOException {\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n      PrintWriter wr = new PrintWriter(System.out);\n      StringBuilder sb = new StringBuilder();\n      \n      int t = Integer.parseInt(br.readLine());\n      while(t-->0){\n          String split[] = br.readLine().split("" "");\n          int n = Integer.parseInt(split[0]);\n          int k = Integer.parseInt(split[1]);\n          \n          // emotional damage !\n          char ch[] = br.readLine().toCharArray();\n          ArrayList<int[]> list = new ArrayList();\n          for(int i =0;i<n;i++){\n              int j = i;\n              if(i%2==0){\n                  while(ch[j]!='(') j++;\n              }else{\n                  while(ch[j]!=')') j++;\n              }\n              \n              if(i!=j){\n                  list.add(new int[]{i,j});\n                  char temp = ch[i];\n                  ch[i] = ch[j];\n                  ch[j] = temp;\n              }\n          }\n          \n          int ans = n/2; // balanced prefix obtained after converting to max epxression -> ()()()().......\n          int i = 1;\n          \n          while(ans!=k){\n            list.add(new int[]{i,i+1});\n            i+=2;\n            ans--;\n          }\n          \n          sb.append(list.size()).append(""\n"");\n          for(int arr[] : list){\n              sb.append(arr[0]+1).append("" "").append(arr[1]+1).append(""\n"");\n          }\n          \n      }\n      wr.println(sb);\n      wr.close();\n  }\n}",constructive algorithms
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Kraken7\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    Scanner in = new Scanner(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskC solver = new TaskC();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskC {\n\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n      int ts = in.nextInt();\n      while (ts-- > 0) {\n        int n = in.nextInt(), k = in.nextInt();\n        char[] s = in.next().toCharArray();\n        int left = n - (k - 1) * 2;\n        String sb = ""()"".repeat(Math.max(0, k - 1))\n          + ""("".repeat(Math.max(0, left / 2))\n          + "")"".repeat(Math.max(0, left / 2));\n        char[] t = sb.toCharArray();\n        ArrayList<Integer[]> res = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n          if (s[i] == t[i])\n            continue;\n          for (int j = i + 1; j < n; j++) {\n            if (s[j] == t[i]) {\n              res.add(new Integer[] { i + 1, j + 1 });\n              for (int x = i; x < j; x++, j--) {\n                char z = s[x];\n                s[x] = s[j];\n                s[j] = z;\n              }\n              break;\n            }\n          }\n        }\n        out.println(res.size());\n        for (Integer[] i : res)\n          out.println(i[0] + "" "" + i[1]);\n      }\n    }\n\n  }\n}\n\n",constructive algorithms
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n  public static void main(String[] args) throws IOException {\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n      PrintWriter wr = new PrintWriter(System.out);\n      StringBuilder sb = new StringBuilder();\n      \n      int t = Integer.parseInt(br.readLine());\n      while(t-->0){\n          String split[] = br.readLine().split("" "");\n          int n = Integer.parseInt(split[0]);\n          int k = Integer.parseInt(split[1]);\n          \n          char ch[] = br.readLine().toCharArray();\n          ArrayList<int[]> list = new ArrayList();\n          \n          for(int i=0;i<n;i++){\n              int j =i;\n              if(i%2==0){ // opening bracket required\n                  while(ch[j]!='(') j++;\n              }else{\n                  while(ch[j]!=')') j++;\n              }\n              \n              if(i!=j){\n                  // swapping works , ex : -> )((( -> reverse  ((()\n                  list.add(new int[]{i,j});\n                  char c = ch[i];\n                  ch[i] = ch[j];\n                  ch[j] = c;\n              }\n          }\n          \n          int ans = n/2;\n          int i = 1;\n          while(ans!=k){\n              list.add(new int[]{i,i+1});\n              i+=2;\n              ans--;\n          }\n          sb.append(list.size()).append(""\n"");\n          for(int arr[] : list){\n              int start = arr[0]+1;\n              int end = arr[1]+1;\n              \n              sb.append(start).append("" "").append(end).append(""\n"");\n          }\n          \n      }\n      wr.println(sb);\n      wr.close();\n  }\n}",constructive algorithms
"import java.util.*;\nimport java.math.*;\npublic class Solution {\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int t = in.nextInt();\n		for(int tt = 0; tt < t; tt++) {\n			int n = in.nextInt();\n			int[] seen = new int[n + 2];\n			int[] ans = new int[n];\n			int cur = 1;\n			int max = 0;\n			boolean flag = true;\n			for(int i = 0; i < n; i++) {\n				int gt = in.nextInt();\n				if(gt < max) {\n					flag = false;\n				}else {\n					max = gt;\n				}\n				if(seen[gt] == 0) {\n					ans[i] = gt;\n					seen[gt] = 1;\n				}else {\n					while(seen[cur] == 1) {\n					 	cur += 1;\n					}\n					if(cur >= max) {\n						flag = false;\n					}else {\n						ans[i] = cur;\n						seen[cur] = 1;\n						cur += 1;\n					}\n				}\n			}\n			if(flag == false) {\n				System.out.println(""-1"");\n				continue;\n			}\n			for(int i = 0; i < n; i++) {\n				if(i > 0) {\n					System.out.print("" "");\n				}\n				System.out.print(ans[i]);\n			}\n			System.out.print(""\n"");\n		}\n	}\n}",constructive algorithms
"import java.util.*;\npublic class MyClass {\n    public static void main(String args[]) {\n        Scanner sc=new Scanner(System.in);\n        int t=sc.nextInt();\n        while(t-->0){\n            int n=sc.nextInt();\n            int p[]=new int[n];\n            Set<Integer> set=new HashSet<>();\n            boolean permut=true;\n            int idx=1;\n            set.add(p[0]=sc.nextInt());\n            for(int i=1;i<n;i++){\n                int a=sc.nextInt();\n                if(!set.contains(a)){\n                    set.add(p[i]=a);\n                }\n                else{\n                    for(;idx<a;idx++){\n                        if(!set.contains(idx))break;\n                    }\n                    if(set.contains(idx))permut=false;\n                    else set.add(p[i]=idx);\n                }\n            }\n            if(permut){\n                for(Integer i:p)System.out.print(i+"" "");\n                System.out.println();\n            }\n            else\n                System.out.println(-1);\n        }\n    }\n}",constructive algorithms
"import java.util.*;\nimport java.io.*;\n\npublic class B {\n	public static void main(String ...args) {\n    Scanner input = new Scanner(System.in);\n    \n  	int t = input.nextInt();\n    \n    for (int i = 0; i < t; i++){\n    	int n = input.nextInt();\n      int[] q = new int[n];\n      TreeSet<Integer> set = new TreeSet<>();\n      \n      for (int j = 0; j < n; j++) {\n        q[j] = input.nextInt();\n        set.add(j + 1);\n      }\n      \n      int prev = -1;\n      StringBuilder answer = new StringBuilder();\n      \n      for (int j = 0; j < n; j++) {\n      	int cur = q[j];\n        \n        if (cur > prev) {\n					answer.append(cur).append("" "");\n          set.remove(cur);\n        } else {\n          Integer first = set.first();\n          \n          if (first >= cur) {\n            answer = new StringBuilder(""-1"");\n            break;\n          }\n        	\n          answer.append(first).append("" "");\n          set.remove(first);\n        }\n        \n        prev = cur;\n      }\n      \n      System.out.println(answer);\n    }\n  }\n}\n\n",constructive algorithms
"import java.util.*;\npublic class Main\n{\n	\n    public static void main(String args[]){\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        while(t-->0) {\n        	int l = sc.nextInt();\n        	int[] arr1 = new int[l];\n        	int[] arr2 = new int[l];\n        	for(int i=0; i<l; i++) {\n        		arr1[i] = sc.nextInt();\n        	}\n        	Queue<Integer> q = new LinkedList<>();\n        	int num = 0;\n        	arr2[0]=arr1[0];\n        	for(int j = 1; j< arr1[0]; j++)\n				q.add(j);\n        	for(int i=1; i<l; i++) {\n        		if(arr1[i]<i+1) {\n        			num=-1;\n        			break;\n        		}\n        		else if(arr1[i]>arr1[i-1]) {\n        			for(int j = arr1[i-1]+1; j< arr1[i]; j++)\n        				q.add(j);\n        		arr2[i] = arr1[i];\n        		}\n        		else {\n        			arr2[i] = q.remove();\n        		}\n        	}\n        	\n        	if(num==-1)\n        		System.out.print(""-1"");\n        	else\n        		for(int i=0; i<l; i++)\n        			System.out.print(arr2[i]+"" "");\n        	System.out.println();\n        }\n    }\n}",constructive algorithms
"import java.util.*;\npublic class Main{\npublic static void main(String [] args){  \n Scanner sc = new Scanner(System.in);\nint t = sc.nextInt(),cnt = 0;\nchar c[] = sc.next().toCharArray();\nfor(int i=0;i<t;i=i+2)\n{\nif(c[i]==c[i+1])\n{\ncnt++;\nc[i]='a';\nc[i+1]='b';\n\n}\n}\nSystem.out.println(cnt);\n System.out.println(c);\n}\n}",strings
"import java.util.*;\npublic class Main{\npublic static void main(String [] args){  \n Scanner sc = new Scanner(System.in);\nint t = sc.nextInt(),cnt = 0;\nchar c[] = sc.next().toCharArray();\nfor(int i=0;i<t;i=i+2)\n{\nif(c[i]==c[i+1])\n{\ncnt++;\nc[i]='a';\nc[i+1]='b';\n\n}\n}\nSystem.out.println(cnt);\n System.out.println(c);\n}\n}",strings
"import java.util.*;\npublic class Main{\npublic static void main(String [] args){  \n Scanner sc = new Scanner(System.in);\nint t = sc.nextInt(),cnt = 0;\nchar c[] = sc.next().toCharArray();\nfor(int i=0;i<t;i=i+2)\n{\nif(c[i]==c[i+1])\n{\ncnt++;\nc[i]='a';\nc[i+1]='b';\n \n}\n}\nSystem.out.println(cnt);\n System.out.println(c);\n}\n}",strings
"import java.util.*;\npublic class Main{\npublic static void main(String [] args){  \n Scanner sc = new Scanner(System.in);\nint t = sc.nextInt(),cnt=0;\n\nchar c[]=sc.next().toCharArray();\nfor(int i=0;i<t;i+=2)\n{\n    if(c[i]==c[i+1])\n    {\n        cnt++;\n        c[i]='a';\n        c[i+1]='b';\n    }\n}\n\nSystem.out.println(cnt);\nSystem.out.println(c);\n}\n}",strings
"import java.io.*;\nimport java.util.*;\n\npublic class HelloWorld{\n\n    public static void main(String []args)throws IOException{\n    \n        BufferedReader re = new BufferedReader(new InputStreamReader(System.in));\n        \n        int n = Integer.parseInt(re.readLine());\n        \n        ArrayList<ArrayList<Integer>> ls = new ArrayList<>();\n        \n        for(int i=0; i<20; i++) ls.add(new ArrayList<>());\n        \n        StringTokenizer tk = new StringTokenizer(re.readLine());\n        \n        for(int i=0; i<n; i++){\n            int input = Integer.parseInt(tk.nextToken())-1;\n            ls.get(input).add(i);\n        }\n        \n        long cnt[][] = new long[20][20];\n        \n        for(int i=0; i<20; i++){\n            for(int j=0; j<20; j++){\n                if(i != j){\n                    \n                    int ind1 = 0, ind2 = 0;\n                    cnt[i][j] = 0;\n                    \n                    ArrayList<Integer> ls1 = ls.get(i), ls2 = ls.get(j);\n                    while(ind1 < ls1.size()){\n                        \n                        while(ind2 < ls2.size() && ls2.get(ind2) < ls1.get(ind1))\n                            ind2++;\n            \n                        cnt[i][j] += ind2;\n                        \n                        ind1++;\n                    }\n                    \n                }\n            }\n        }\n        \n        long dp[] = new long[1<<20];\n        dp[0] = 0;\n        \n        for(int i=1; i<(1<<20); i++){\n            \n            dp[i] = Long.MAX_VALUE;\n            \n            if(Integer.bitCount(i) == 1)\n                dp[i] = 0;\n            else{\n                for(int j=0; j<20; j++){\n                    if((i&(1<<j)) > 0){\n                        \n                        long sum = dp[i^(1<<j)];\n                        \n                        for(int k=0; k<20; k++){\n                            if((i&(1<<k)) > 0 && j != k)\n                                sum += cnt[k][j];\n                        }\n                        \n                        dp[i] = Math.min(dp[i], sum);\n                    }\n                }\n            }\n        }\n        \n        System.out.println(+dp[(1<<20)-1]);\n    }\n}","bitmasks,dp"
"import java.io.*;\nimport java.util.*;\npublic class Sol{\n	final public static long MOD = 998244353;\n	public static void main(String[] args) throws IOException{\n		FastIO sc = new FastIO(System.in);\n		PrintWriter out = new PrintWriter(System.out);\n		int n = sc.nextInt();\n		ArrayList<Integer>[] pos = new ArrayList[20];\n		for(int i=0; i<20; ++i) {\n			pos[i] = new ArrayList<>();\n		}\n		for(int i=0; i<n; ++i) {\n			int a = sc.nextInt()-1;\n			pos[a].add(i);\n		}\n		long moves[][] = new long[20][20];\n		for(int i=0; i<20; ++i) {\n			for(int j=0; j<20; ++j) {\n				if(i==j) {\n					moves[i][j] = 0;\n					continue;\n				}\n				if(pos[i].size()==0||pos[j].size()==0) {\n					moves[i][j] = 0;\n					continue;\n				}\n				int idxi = 0;\n				int idxj = 0;\n				while(idxi<pos[i].size()) {\n					if(idxj==pos[j].size()) {\n						moves[i][j]+=idxj;\n						idxi++;\n					}else if(pos[j].get(idxj)<pos[i].get(idxi)) {\n						idxj++;\n					}else {\n						moves[i][j]+=idxj;\n						idxi++;\n					}\n				}\n			}\n		}\n		long dp[] = new long[1<<20];\n		Arrays.fill(dp, Long.MAX_VALUE);\n		dp[0] = 0;\n		for(int msk = 0; msk<(1<<20); msk++) {\n			if(dp[msk] == Long.MAX_VALUE) continue;\n			ArrayList<Integer> all = new ArrayList<>();\n			for(int i=0; i<20; ++i) {\n				if((msk&(1<<i))>0) {\n					all.add(i);\n				}\n			}\n			for(int i=0; i<20; ++i) {\n				if((msk&(1<<i))==0) {\n					int nextmsk = msk|(1<<i);\n					long best = 0;\n					for(int k:all) {\n						best+=moves[i][k];\n					}\n					dp[nextmsk] = Math.min(dp[msk] + best, dp[nextmsk]);\n				}\n			}\n		}\n		out.println(dp[(1<<20)-1]);\n		out.close();\n	}\n	static class FastIO {\n		 \n		// Is your Fast I/O being bad?\n \n		InputStream dis;\n		byte[] buffer = new byte[1 << 17];\n		int pointer = 0;\n \n		public FastIO(String fileName) throws IOException {\n			dis = new FileInputStream(fileName);\n		}\n \n		public FastIO(InputStream is) throws IOException {\n			dis = is;\n		}\n \n		int nextInt() throws IOException {\n			int ret = 0;\n \n			byte b;\n			do {\n				b = nextByte();\n			} while (b <= ' ');\n			boolean negative = false;\n			if (b == '-') {\n				negative = true;\n				b = nextByte();\n			}\n			while (b >= '0' && b <= '9') {\n				ret = 10 * ret + b - '0';\n				b = nextByte();\n			}\n \n			return (negative) ? -ret : ret;\n		}\n \n		long nextLong() throws IOException {\n			long ret = 0;\n \n			byte b;\n			do {\n				b = nextByte();\n			} while (b <= ' ');\n			boolean negative = false;\n			if (b == '-') {\n				negative = true;\n				b = nextByte();\n			}\n			while (b >= '0' && b <= '9') {\n				ret = 10 * ret + b - '0';\n				b = nextByte();\n			}\n \n			return (negative) ? -ret : ret;\n		}\n \n		byte nextByte() throws IOException {\n			if (pointer == buffer.length) {\n				dis.read(buffer, 0, buffer.length);\n				pointer = 0;\n			}\n			return buffer[pointer++];\n		}\n \n		String next() throws IOException {\n			StringBuffer ret = new StringBuffer();\n \n			byte b;\n			do {\n				b = nextByte();\n			} while (b <= ' ');\n			while (b > ' ') {\n				ret.appendCodePoint(b);\n				b = nextByte();\n			}\n \n			return ret.toString();\n		}\n \n	}\n}","bitmasks,dp"
"/*\n        ""Everything in the universe is balanced. Every disappointment\n                you face in life will be balanced by something good for you!\n                        Keep going, never give up.""\n\n                        Just have Patience + 1...\n\n*/\n\n\n\n\n\n\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n\npublic class Solution {\n\n    static long INF = (long) 1e18;\n    static int MAX = 21;\n    static long[] dp = new long[1 << MAX];\n    static long[][] swapOperations = new long[MAX][MAX];\n    static List<Integer>[] positions = new List[MAX];\n\n    public static void main(String[] args) throws java.lang.Exception {\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        sc = new FastReader();\n\n        int test = 1;\n        for (int t = 1; t <= test; t++) {\n            solve();\n        }\n        out.close();\n    }\n\n    private static void solve() {\n        int n = sc.nextInt();\n        for (int i = 0; i < 20; i++) {\n            positions[i] = new ArrayList<>();\n        }\n\n        for (int i = 0; i < n; i++) {\n            int x = sc.nextInt() - 1;\n            positions[x].add(i);\n        }\n\n        for (int i = 0; i < 20; i++) {\n            for (int j = 0; j < 20; j++) {\n                if (i == j) {\n                    continue;\n                }\n                if (positions[i].size() == 0 || positions[j].size() == 0) {\n                    continue;\n                }\n                int posJ = 0;\n                for (int posI = 0; posI < positions[i].size(); posI++) {\n                    while (true) {\n                        if (posJ == positions[j].size() - 1 || positions[j].get(posJ + 1) > positions[i].get(posI)) {\n                            break;\n                        }\n                        posJ++;\n                    }\n                    if (positions[i].get(posI) > positions[j].get(posJ)) {\n                        swapOperations[i][j] += posJ + 1;\n                    }\n                }\n            }\n        }\n\n        Arrays.fill(dp, INF);\n        dp[0] = 0;\n        for (int mask = 0; mask < (1 << 20); mask++) {\n            List<Integer> prevOrder = new ArrayList<>();\n            for (int i = 0; i < 20; i++) {\n                if ((mask & (1 << i)) >= 1) {\n                    prevOrder.add(i);\n                }\n            }\n\n            for (int i = 0; i < 20; i++) {\n                if ((mask & (1 << i)) >= 1) {\n                    continue;\n                }\n\n                long swapsNeeded = 0;\n                // place after j\n                for (int j = 0; j < prevOrder.size(); j++) {\n                    swapsNeeded += swapOperations[prevOrder.get(j)][i];\n                }\n\n                int newMask = mask | (1 << i);\n                dp[newMask] = Math.min(dp[newMask], dp[mask] + swapsNeeded);\n            }\n        }\n\n        out.println(dp[(1 << 20) - 1]);\n    }\n\n\n    public static FastReader sc;\n    public static PrintWriter out;\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer str;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (str == null || !str.hasMoreElements())\n            {\n                try\n                {\n                    str = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  lastMonthOfVacation)\n                {\n                    lastMonthOfVacation.printStackTrace();\n                }\n            }\n            return str.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = """";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException lastMonthOfVacation)\n            {\n                lastMonthOfVacation.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}","bitmasks,dp"
"/*\n        ""Everything in the universe is balanced. Every disappointment\n                you face in life will be balanced by something good for you!\n                        Keep going, never give up.""\n\n                        Just have Patience + 1...\n\n*/\n\n\n\n\n\n\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n\npublic class Solution {\n\n    static long INF = (long) 1e18;\n    static int MAX = 21;\n\n    // dp[mask] is the minimum number of operations needed to rearrange the marbles\n    // such that all marbles from the mask of colors forms exactly one contiguous segment.\n    static long[] dp = new long[1 << MAX];\n\n    // swapOperations[i][j] is the minimum number of swaps needed to place all marbles of color i before all marbles of color j.\n    static long[][] swapOperations = new long[MAX][MAX];\n\n    // stores all the positions of different colors.\n    static List<Integer>[] positions = new List[MAX];\n\n    public static void main(String[] args) throws java.lang.Exception {\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        sc = new FastReader();\n\n        int test = 1;\n        for (int t = 1; t <= test; t++) {\n            solve();\n        }\n        out.close();\n    }\n\n    private static void solve() {\n        int n = sc.nextInt();\n        for (int i = 0; i < 20; i++) {\n            positions[i] = new ArrayList<>();\n        }\n\n        for (int i = 0; i < n; i++) {\n            int x = sc.nextInt() - 1;\n            positions[x].add(i);\n        }\n\n        for (int i = 0; i < 20; i++) {\n            for (int j = 0; j < 20; j++) {\n                if (i == j) {\n                    continue;\n                }\n                if (positions[i].size() == 0 || positions[j].size() == 0) {\n                    continue;\n                }\n                int posJ = 0;\n                for (int posI = 0; posI < positions[i].size(); posI++) {\n                    while (true) {\n                        if (posJ == positions[j].size() - 1 || positions[j].get(posJ + 1) > positions[i].get(posI)) {\n                            break;\n                        }\n                        posJ++;\n                    }\n                    if (positions[i].get(posI) > positions[j].get(posJ)) {\n                        swapOperations[i][j] += posJ + 1;\n                    }\n                }\n            }\n        }\n\n        Arrays.fill(dp, INF);\n        dp[0] = 0;\n        for (int mask = 0; mask < (1 << 20); mask++) { // for each already correctly ordered mask of colors\n            List<Integer> prevOrder = new ArrayList<>();\n            for (int i = 0; i < 20; i++) {\n                if ((mask & (1 << i)) >= 1) {\n                    prevOrder.add(i);\n                }\n            }\n\n            for (int i = 0; i < 20; i++) {\n                if ((mask & (1 << i)) >= 1) {\n                    continue;\n                }\n\n                long swapsNeeded = 0;\n                // correctly order all marbles of color i after all marbles of color j.\n                for (int j = 0; j < prevOrder.size(); j++) {\n                    swapsNeeded += swapOperations[prevOrder.get(j)][i];\n                }\n\n                int newMask = mask | (1 << i);\n                dp[newMask] = Math.min(dp[newMask], dp[mask] + swapsNeeded);\n            }\n        }\n\n        out.println(dp[(1 << 20) - 1]);\n    }\n\n\n    public static FastReader sc;\n    public static PrintWriter out;\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer str;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (str == null || !str.hasMoreElements())\n            {\n                try\n                {\n                    str = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  lastMonthOfVacation)\n                {\n                    lastMonthOfVacation.printStackTrace();\n                }\n            }\n            return str.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = """";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException lastMonthOfVacation)\n            {\n                lastMonthOfVacation.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}","bitmasks,dp"
"import java.io.*;\nimport java.util.*;\npublic class GFG {\n	public static void main (String[] args) {\n	Scanner sc=new Scanner(System.in);\n	    int n=sc.nextInt();\n	    String s=sc.next();\n	    String t=sc.next();\n	    String arr[]={""abc"",""acb"",""bac"",""bca"",""cab"",""cba""};\n	    int f=0;\n	    for(int i=0;i<6;i++)\n	    {\n	        String w=arr[i];\n	        String tmp1=""""+w.charAt(2)+w.charAt(0);\n	        if(n>1&&w.indexOf(s)==-1&&w.indexOf(t)==-1&&tmp1.indexOf(s)==-1&&tmp1.indexOf(t)==-1)\n	        {\n	        System.out.println(""YES"");\n	        for(int j=0;j<n;j++)\n	        System.out.print(w);\n	        System.out.println();f=1;break;\n	        }\n	        if(n==1&&w.indexOf(s)==-1&&w.indexOf(t)==-1)\n	        {\n	            System.out.println(""YES"");\n	            System.out.println(w);f=1;break;\n	        }\n	       String tmp=""aakbblcc"";\n	       if(w.indexOf(s)==-1&&w.indexOf(t)==-1&&tmp.indexOf(s)==-1&&tmp.indexOf(t)==-1){\n	           System.out.println(""YES"");\n	        for(int j=0;j<n;j++)\n	        System.out.print(arr[i].charAt(0));\n	        for(int j=0;j<n;j++)\n	       System.out.print(arr[i].charAt(1));\n	         for(int j=0;j<n;j++)\n	        System.out.print(arr[i].charAt(2));f=1;break;}\n	   }\n	   if(f==0)\n	   System.out.println(""NO"");\n	}\n}","brute force,constructive algorithms"
"import java.io.*;\nimport java.util.*;\n\npublic class Codeforces\n{\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb=new StringBuilder();\n        int n=Integer.parseInt(bu.readLine());\n        String pos[]={""abc"",""acb"",""bca"",""bac"",""cab"",""cba""};\n        char a[]=bu.readLine().toCharArray();\n        char b[]=bu.readLine().toCharArray();\n        if(a[0]!=a[1] && b[0]!=b[1])\n        {\n            for(String s:pos)\n            {\n                if((s.charAt(0)==a[0] && s.charAt(1)==a[1]) || (s.charAt(1)==a[0] && s.charAt(2)==a[1])) continue;\n                if((s.charAt(0)==b[0] && s.charAt(1)==b[1]) || (s.charAt(1)==b[0] && s.charAt(2)==b[1])) continue;\n                int i;\n                sb.append(""YES\n"");\n                for(i=0;i<n;i++) sb.append(s.charAt(0));\n                for(i=0;i<n;i++) sb.append(s.charAt(1));\n                for(i=0;i<n;i++) sb.append(s.charAt(2));\n                sb.append(""\n"");\n                System.out.print(sb);\n                return;\n            }\n            return;     //will never execute\n        }\n\n        int i,j,k; char c[]=new char[3]; boolean found=false;\n        for(i=0;i<3 && !found;i++)\n        for(j=0;j<3 && !found;j++)\n        if(j!=i)\n        for(k=0;k<3 && !found;k++)\n        if(k!=i && k!=j)\n        {\n            char x=(char)('a'+i),y=(char)('a'+j),z=(char)('a'+k);\n            if((a[0]==x && a[1]==y) || (a[0]==y && a[1]==x) || (a[0]==y && a[1]==z) || (a[0]==z && a[1]==z)) continue;\n            if((b[0]==x && b[1]==y) || (b[0]==y && b[1]==x) || (b[0]==y && b[1]==z) || (b[0]==z && b[1]==z)) continue;\n            c[0]=x; c[1]=y; c[2]=z;\n            found=true;\n        }\n\n        sb.append(""YES\n"");\n        for(i=0;i<2*n;i++)\n        if(i%2==0) sb.append(c[0]);\n        else sb.append(c[1]);\n        for(i=0;i<n;i++) sb.append(c[2]);\n        sb.append(""\n"");\n        System.out.print(sb);\n    }\n}","brute force,constructive algorithms"
"	import java.io.*;\n	import java.util.*;\n	public class new1{\n		static long mod = 1000000007;\n		public static long gcd(long a, long b)\n	    {\n	        if (a == 0)\n	            return b;\n	        return gcd(b%a, a);\n	    }\n		\n	\n		public static void main(String[] args)  throws IOException{\n	\n			BufferedWriter output = new BufferedWriter(new OutputStreamWriter(System.out));\n			FastReader s = new FastReader();\n			int t = 1;//s.nextInt();\n			for(int z = 0; z < t; z++) {\n				int n = s.nextInt();\n				String str1 = s.next();\n				String str2 = s.next();\n				boolean over = false;\n				\n				for(int i = 0; i < 3; i++) {\n					for(int j = 0; j < 3; j++) {\n						for(int k = 0; k < 3; k++) {\n							if(i != j && j != k && k != i && !over) {\n								String ch1 = Character.toString((char) (i + 'a'));\n								String ch2 = Character.toString((char) (j + 'a'));\n								String ch3 = Character.toString((char) (k + 'a'));\n								String[] st = {ch1 + ch2, ch3 + ch3, ch2 + ch1};\n								int count = 0;\n								for(int l = 0; l < 3; l++) {\n									String st1 = st[l];\n									if(!st1.equals(str1) && !st1.equals(str2)) count++;\n								}\n								\n								if(count == 3) {\n									\n									String st1 = ch2 + ch3;\n									if(!over && !st1.equals(str1) && !st1.equals(str2)) {\n										output.write(""YES"" +""\n"");\n										over = true;\n										for(int l = 0; l < n; l++) output.write(ch1+ch2);\n										for(int l = 0; l < n; l++) output.write(ch3);\n									}\n									st1 = ch3 + ch1;\n									if(!over && !st1.equals(str1) && !st1.equals(str2)) {\n										output.write(""YES"" +""\n"");\n										over = true;\n										for(int l = 0; l < n; l++) output.write(ch3);\n										for(int l = 0; l < n; l++) output.write(ch1+ch2);\n									}\n									if(!over) {\n										output.write(""YES"" +""\n"");\n										over = true;\n										output.write(ch1);\n										for(int l = 0; l < n; l++) output.write(ch3);\n										output.write(ch2);\n										for(int l = 0; l < n - 1; l++) output.write(ch1+ch2);\n									}\n									\n								}\n								\n								\n								\n								\n								\n							}\n						}\n					}\n				}\n				if(!over) output.write(""NO"");\n				\n						\n				\n			}\n			output.flush();\n		  }\n	}\n	\n	\n	 \n	class FastReader {\n	    BufferedReader br;\n	    StringTokenizer st;\n	    public FastReader() {\n	        br = new BufferedReader(new InputStreamReader(System.in));\n	    }\n	    String next() {\n	        while (st == null || !st.hasMoreElements()) {\n	            try {\n	                st = new StringTokenizer(br.readLine());\n	            } catch (IOException e) {\n	                e.printStackTrace();\n	            }\n	        }\n	        return st.nextToken();\n	    }\n	 \n	    public int nextInt() {\n	        return Integer.parseInt(next());\n	    }\n	 \n	    long nextLong() {\n	        return Long.parseLong(next());\n	    }\n	 \n	    double nextDouble() {\n	        return Double.parseDouble(next());\n	    }\n	 \n	    String nextLine() {\n	        String str = """";\n	        try {\n	            str = br.readLine();\n	        } catch (IOException e) {\n	            e.printStackTrace();\n	        }\n	        return str;\n	}}","brute force,constructive algorithms"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class Task {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            String s = in.next();\n            String t = in.next();\n            ArrayList<String> pats = new ArrayList<>();\n            for (char c1 = 'a'; c1 <= 'c'; c1++) {\n                for (char c2 = 'a'; c2 <= 'c'; c2++) {\n                    for (char c3 = 'a'; c3 <= 'c'; c3++) {\n                        if (c1 == c2 || c1 == c3 || c2 == c3) continue;\n                        StringBuilder pat = new StringBuilder();\n                        for (int i = 0; i < n; i++) {\n                            pat.append(c1).append(c2).append(c3);\n                        }\n                        String p1 = pat.toString();\n                        if (!p1.contains(s) && !p1.contains(t)) {\n                            out.println(""YES"");\n                            out.println(p1);\n                            return;\n                        }\n                        pat = new StringBuilder();\n                        for (int i = 0; i < n; i++) {\n                            pat.append(c1);\n                        }\n                        for (int i = 0; i < n; i++) {\n                            pat.append(c2);\n                        }\n                        for (int i = 0; i < n; i++) {\n                            pat.append(c3);\n                        }\n                        String p2 = pat.toString();\n                        if (!p2.contains(s) && !p2.contains(t)) {\n                            out.println(""YES"");\n                            out.println(p2);\n                            return;\n                        }\n                    }\n                }\n            }\n            out.println(""NO"");\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer stt;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        public String next() {\n            while (stt == null || !stt.hasMoreTokens()) {\n                stt = new StringTokenizer(nextLine());\n            }\n            return stt.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n","brute force,constructive algorithms"
"\n\nimport java.io.*;\nimport java.util.Scanner;\nimport java.util.Vector;\n\npublic class Main {\n    static long cd[] = new long[100100],rd[] = new long[100100];\n    public static void main(String[] args) throws IOException{\n        Scanner cin=new Scanner(System.in);\n        PrintWriter cout = new PrintWriter(System.out);\n        int n = cin.nextInt(),m = cin.nextInt();\n        Vector []g = new Vector[100100];\n        for (int i = 1; i <= n; i++) {\n            g[i] = new Vector();\n        }\n        for (int i = 1; i <= m; i++) {\n            int u = cin.nextInt(),v = cin.nextInt();\n            if (u > v) {\n                int t = u;\n                u = v;\n                v = t;\n            }\n            rd[u]++; cd[v]++;\n            g[u].addElement(v);\n        }\n        long ans = 0;\n        for (int i = 1; i <= n; i++) ans += rd[i]*cd[i];\n        int q = cin.nextInt();\n        cout.print(ans+""\n"");\n        while (q-- != 0) {\n            int t = cin.nextInt();\n            ans -= rd[t]*cd[t];\n            for (int i = 0; i < g[t].size(); i++) {\n                int pos = (int) g[t].elementAt(i);\n                ans -= rd[pos]*cd[pos];\n                cd[pos]--; cd[t]++;\n                rd[pos]++; rd[t]--;\n                ans += rd[pos]*cd[pos];\n                g[pos].addElement(t);\n            }\n            g[t].clear();\n            cout.print(ans+""\n"");\n        }\n        cin.close(); cout.close();\n    }\n}\n",graphs
"import java.io.*;\nimport java.util.*;\n\npublic class A {\n    FastScanner in;\n    PrintWriter out;\n\n    void solve() {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[] cntLeft = new int[n];\n        List<Integer>[] goRight = new List[n];\n        for (int i = 0; i < goRight.length; i++) {\n            goRight[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < m; i++) {\n            int x = in.nextInt() - 1;\n            int y = in.nextInt() - 1;\n            int fr = Math.min(x, y), to = Math.max(x, y);\n            cntLeft[to]++;\n            goRight[fr].add(to);\n        }\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            res += (long) cntLeft[i] * goRight[i].size();\n        }\n        out.println(res);\n        int q = in.nextInt();\n        for (int it = 0; it < q; it++) {\n            int id = in.nextInt() - 1;\n            for (int to : goRight[id]) {\n                res -= cntLeft[id];\n                res -= goRight[to].size();\n                goRight[to].add(id);\n                cntLeft[to]--;\n                res += cntLeft[to];\n            }\n            cntLeft[id] += goRight[id].size();\n            goRight[id].clear();\n            out.println(res);\n        }\n    }\n\n    void run() {\n        try {\n            in = new FastScanner(new File(""A.in""));\n            out = new PrintWriter(new File(""A.out""));\n\n            solve();\n\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void runIO() {\n\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new A().runIO();\n    }\n}",graphs
"import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.arraycopy;\nimport static java.lang.System.exit;\nimport static java.util.Arrays.copyOf;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.util.StringTokenizer;\n\npublic class D {\n\n	static class IntList {\n\n		int data[] = new int[3];\n		int size = 0;\n\n		boolean isEmpty() {\n			return size == 0;\n		}\n\n		int size() {\n			return size;\n		}\n\n		int get(int index) {\n			if (index < 0 || index >= size) {\n				throw new IndexOutOfBoundsException();\n			}\n			return data[index];\n		}\n\n		void clear() {\n			size = 0;\n		}\n\n		void set(int index, int value) {\n			if (index < 0 || index >= size) {\n				throw new IndexOutOfBoundsException();\n			}\n			data[index] = value;\n		}\n\n		void expand() {\n			if (size >= data.length) {\n				data = copyOf(data, (data.length << 1) + 1);\n			}\n		}\n\n		void insert(int index, int value) {\n			if (index < 0 || index > size) {\n				throw new IndexOutOfBoundsException();\n			}\n			expand();\n			arraycopy(data, index, data, index + 1, size++ - index);\n			data[index] = value;\n		}\n\n		int delete(int index) {\n			if (index < 0 || index >= size) {\n				throw new IndexOutOfBoundsException();\n			}\n			int value = data[index];\n			arraycopy(data, index + 1, data, index, --size - index);\n			return value;\n		}\n\n		void push(int value) {\n			expand();\n			data[size++] = value;\n		}\n\n		int pop() {\n			if (size == 0) {\n				throw new NoSuchElementException();\n			}\n			return data[--size];\n		}\n\n		void unshift(int value) {\n			expand();\n			arraycopy(data, 0, data, 1, size++);\n			data[0] = value;\n		}\n\n		int shift() {\n			if (size == 0) {\n				throw new NoSuchElementException();\n			}\n			int value = data[0];\n			arraycopy(data, 1, data, 0, --size);\n			return value;\n		}\n	}\n\n	static void solve() throws Exception {\n		int n = scanInt(), m = scanInt();\n		IntList higherBad[] = new IntList[n];\n		for (int i = 0; i < n; i++) {\n			higherBad[i] = new IntList();\n		}\n		int nBad[] = new int[n];\n		for (int i = 0; i < m; i++) {\n			int a = scanInt() - 1, b = scanInt() - 1;\n			if (a > b) {\n				int t = a;\n				a = b;\n				b = t;\n			}\n			higherBad[a].push(b);\n			++nBad[a];\n			++nBad[b];\n		}\n		long ans = 0, pans[] = new long[n];\n		for (int i = 0; i < n; i++) {\n			ans += pans[i] = (long) (nBad[i] - higherBad[i].size()) * higherBad[i].size();\n		}\n		out.println(ans);\n		int q = scanInt();\n		for (int qq = 0; qq < q; qq++) {\n			int cur = scanInt() - 1;\n			ans -= pans[cur];\n			pans[cur] = 0;\n			for (int i = 0; i < higherBad[cur].size; i++) {\n				int e = higherBad[cur].data[i];\n				higherBad[e].push(cur);\n				ans -= pans[e];\n				ans += pans[e] = (long) (nBad[e] - higherBad[e].size()) * higherBad[e].size();\n			}\n			higherBad[cur].clear();\n			out.println(ans);\n		}\n	}\n\n	static int scanInt() throws IOException {\n		return parseInt(scanString());\n	}\n\n	static long scanLong() throws IOException {\n		return parseLong(scanString());\n	}\n\n	static String scanString() throws IOException {\n		while (tok == null || !tok.hasMoreTokens()) {\n			tok = new StringTokenizer(in.readLine());\n		}\n		return tok.nextToken();\n	}\n\n	static BufferedReader in;\n	static PrintWriter out;\n	static StringTokenizer tok;\n\n	public static void main(String[] args) {\n		try {\n			in = new BufferedReader(new InputStreamReader(System.in));\n			out = new PrintWriter(System.out);\n			solve();\n			in.close();\n			out.close();\n		} catch (Throwable e) {\n			e.printStackTrace();\n			exit(1);\n		}\n	}\n}",graphs
"import java.util.*;\nimport java.io.*;\n\npublic class D1210 {\n    static Stack<Integer>[] adjList;\n\n    public static void main(String[] args) throws IOException {\n        Reader sc = new Reader();\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        adjList = new Stack[n];\n        int[] in = new int[n];\n        int[] out = new int[n];\n        for (int i = 0; i < n; i++) {\n            adjList[i] = new Stack<>();\n        }\n        while (m-- > 0) {\n            int u = sc.nextInt() - 1;\n            int v = sc.nextInt() - 1;\n            adjList[Math.min(u, v)].add(Math.max(u, v));\n            out[Math.min(u, v)]++;\n            in[Math.max(u, v)]++;\n        }\n        long ans = 0;\n        for (int i = 0; i < n; i++) {\n            ans += 1L * in[i] * out[i];\n        }\n        pw.println(ans);\n        int q = sc.nextInt();\n        while (q-- > 0) {\n            int v = sc.nextInt() - 1;\n            while (!adjList[v].isEmpty()) {\n                int cur = adjList[v].pop();\n                ans += in[cur] - out[cur] - 1;\n                ans += -in[v] + out[v] - 1;\n                in[cur]--;\n                out[cur]++;\n                in[v]++;\n                out[v]--;\n                adjList[cur].add(v);\n            }\n            pw.println(ans);\n        }\n        pw.close();\n\n    }\n\n    static class Reader {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException {\n            din = new DataInputStream(\n                    new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\n') {\n                    if (cnt != 0) {\n                        break;\n                    } else {\n                        continue;\n                    }\n                }\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0,\n                    BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n}",graphs
"import java.util.*;\nimport java.io.*;\n\npublic class _1208_D {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        int n = Integer.parseInt(in.readLine());\n        long[] p = new long[n];\n        long[] a = new long[n + 1];\n        StringTokenizer line = new StringTokenizer(in.readLine());\n        for(int i = 0; i < n; i++) {\n            p[i] = Long.parseLong(line.nextToken());\n            a[i + 1] = i + 1;\n        }\n        int[] res = new int[n];\n        BIT bit = new BIT(a);\n        for(int i = n - 1; i >= 0; i--) {\n            int ind = bit.bsearch(p[i]) + 1;\n            res[i] = ind;\n            bit.update(ind, -ind);\n        }\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i < n; i++) {\n            sb.append(res[i]);\n            sb.append(' ');\n        }\n        out.println(sb.toString());\n        in.close();\n        out.close();\n    }\n    static class BIT {\n        long[] bit;\n        BIT(long[] a) {\n            bit = new long[a.length + 1];\n            for(int i = 0; i < a.length; i++) {\n                update(i, a[i]);\n            }\n        }\n        void update(int index, long add) {\n            index++;\n            while(index < bit.length) {\n                bit[index] += add;\n                index += index & -index;\n            }\n        }\n        long sum(int index) {\n            index++;\n            long res = 0;\n            while(index > 0) {\n                res += bit[index];\n                index -= index & -index;\n            }\n            return res;\n        }\n        int bsearch(long val) {\n            int l = 0;\n            int r = bit.length - 1;\n            int res = -1;\n            while(l <= r) {\n                int avg = (l + r) / 2;\n                if(sum(avg) <= val) {\n                    res = avg;\n                    l = avg + 1;\n                }else {\n                    r = avg - 1;\n                }\n            }\n            return res;\n        }\n    }\n}\n","binary search,data structures,greedy,implementation"
"import java.io.DataInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class P1208D9 {\n    public static void main(String[] args) throws IOException {\n        InputReader2 ir = new InputReader2();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = ir.nextInt();\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = ir.nextLong();\n        }\n\n        Fenwick f = new Fenwick(n);\n        for (int i = 1; i <= n; i++) {\n            f.add(i, i);\n        }\n        int[] list = new int[n];\n        for (int i = n - 1; i >= 0; i--) {\n            int ind = f.indexWithGivenCumFreq(a[i]);\n            f.add(ind, -ind);\n            list[i] = ind;\n        }\n\n        for (int i = 0; i < n; i++) {\n            pw.print(list[i] + "" "");\n        }\n        pw.close();\n    }\n\n    static class Fenwick {\n        public final long[] bit;\n        public final int size;\n\n        public Fenwick(int size) {\n            this.size = size + 1;\n            bit = new long[this.size];\n        }\n\n        public void add(int i, long delta) {\n            for (++i; i < size; i += (i & -i)) {\n                bit[i] += delta;\n            }\n        }\n\n        public int indexWithGivenCumFreq(long v) {\n            int i = 0, n = size;\n            for (int b = Integer.highestOneBit(n); b != 0; b >>= 1) {\n                if ((i | b) < n && bit[i | b] <= v) {\n                    i |= b;\n                    v -= bit[i];\n                }\n            }\n            return i;\n        }\n    }\n\n    private static class InputReader2 {\n        final private int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream dis;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public InputReader2() {\n            dis = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        private int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            return ret;\n        }\n\n        private long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = dis.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n    }\n}\n","binary search,data structures,greedy,implementation"
"import java.io.DataInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class P1208D7 {\n    public static void main(String[] args) throws IOException {\n        InputReader2 ir = new InputReader2();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = ir.nextInt();\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = ir.nextLong();\n        }\n\n        Fenwick f = new Fenwick(n);\n        for (int i = 1; i <= n; i++) {\n            f.add(i - 1, i);\n        }\n        int[] list = new int[n];\n        for (int i = n - 1; i >= 0; i--) {\n            int ind = f.indexWithGivenCumFreq(a[i]);\n            f.add(ind, -(ind + 1));\n            list[i] = ind + 1;\n        }\n\n        for (int i = 0; i < n; i++) {\n            pw.print(list[i] + "" "");\n        }\n        pw.close();\n    }\n\n    static class Fenwick {\n        public final long[] bit;\n        public final int size;\n\n        public Fenwick(int size) {\n            bit = new long[size + 1];\n            this.size = size + 1;\n        }\n\n        public void add(int i, long delta) {\n            for (++i; i < size; i += (i & -i)) {\n                bit[i] += delta;\n            }\n        }\n\n        public int indexWithGivenCumFreq(long v) {\n            int i = 0, n = size;\n            for (int b = Integer.highestOneBit(n); b != 0; b >>= 1) {\n                if ((i | b) < n && bit[i | b] <= v) {\n                    i |= b;\n                    v -= bit[i];\n                }\n            }\n            return i;\n        }\n    }\n\n    private static class InputReader2 {\n        final private int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream dis;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public InputReader2() {\n            dis = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        private int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            return ret;\n        }\n\n        private long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = dis.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n    }\n}\n","binary search,data structures,greedy,implementation"
"import java.io.DataInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class P1208D4 {\n    public static void main(String[] args) throws IOException {\n        InputReader2 ir = new InputReader2();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = ir.nextInt();\n        long[] s = new long[n];\n        for (int i = 0; i < n; i++) {\n            s[i] = ir.nextLong();\n        }\n\n        BIT tree = new BIT(n);\n        for (int i = 1; i <= n; i++) {\n            tree.add(i, i);\n        }\n        int[] ans = new int[n];\n        for (int i = n - 1; i >= 0; i--) {\n            long cur = s[i];\n            if (cur == 0) {\n                ans[i] = binSearch(tree, 0, n);\n            } else {\n                ans[i] = binSearch(tree, cur, n);\n            }\n            tree.remove(ans[i]);\n        }\n\n        for (int an : ans) {\n            pw.print(an + "" "");\n        }\n        pw.close();\n    }\n\n    private static int binSearch(BIT tree, long key, int n) {\n        int low = 1, high = n;\n\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            long amt = tree.prefixSum(mid);\n            if (amt <= key) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return low;\n    }\n\n    public static class BIT {\n        final int N;\n        private final long[] tree;\n\n        public BIT(int sz) {\n            tree = new long[(N = sz + 1)];\n        }\n\n        private static int lsb(int i) {\n            return i & -i;\n        }\n\n        private long prefixSum(int i) {\n            long sum = 0L;\n            while (i != 0) {\n                sum += tree[i];\n                i &= ~lsb(i);\n            }\n            return sum;\n        }\n\n        public void add(int i, long v) {\n            while (i < N) {\n                tree[i] += v;\n                i += lsb(i);\n            }\n        }\n\n        public void remove(int i) {\n            add(i, -(prefixSum(i) - prefixSum(i - 1)));\n        }\n    }\n\n    private static class InputReader2 {\n        final private int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream dis;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public InputReader2() {\n            dis = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        private int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            return ret;\n        }\n\n        private long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = dis.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n    }\n}\n","binary search,data structures,greedy,implementation"
"import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\npublic class Main \n{\n	public static void main(String[] args) throws IOException \n	{\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n		int n = Integer.parseInt(br.readLine());\n		int[][] ans = new int[n][n];\n		for(int step = 0, base = 0; step < n / 4 ; step++)\n		{\n			for(int i = 0 ; i < n ; i++)\n			{\n				for(int j = 4 * step ; j < 4 * (step + 1) ; j++)\n				{\n					ans[i][j] = base;\n					++base;\n				}\n			}\n		}\n		for(int i = 0 ; i < n ; i++)\n		{\n			for(int j = 0 ; j < n ; j++)\n				bw.write(Integer.toString(ans[i][j]) + "" "");\n			bw.write('\n');\n		}\n		bw.flush();\n	}\n}\n",constructive algorithms
"import java.io.*;\nimport java.util.*;\n\npublic class C {\n\n	public static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n	public static void main(String[] args) throws IOException {\n		// br = new BufferedReader(new FileReader("".in""));\n		// out = new PrintWriter(new FileWriter("".out""));\n		int n = Integer.parseInt(br.readLine());\n		int[][] copy = {\n			{8, 9, 1, 13},\n			{3, 12, 7, 5},\n			{0, 2, 4, 11},\n			{6, 10, 15, 14}\n		};\n		\n		int bias = 0;\n		\n		int[][] ans = new int[n][n];\n		\n		for (int i = 0; i < n; i+=4) {\n			for (int j = 0; j < n; j+=4) {\n				for (int k = i; k < i+4; k++) {\n					for (int l = j; l < j+4; l++) {\n						ans[k][l] = copy[k-i][l-j]+bias;\n					}\n				}\n				\n				bias += 16;\n			}	\n		}\n		\n		for (int[] x: ans) {\n			for (int y: x) out.print(y + "" "");\n			out.println();\n		}\n		\n		out.close();\n	}\n\n}\n",constructive algorithms
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Kraken\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    Scanner in = new Scanner(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskC solver = new TaskC();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskC {\n\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n      int n = in.nextInt();\n      long curr = 0;\n      long[][] mat = new long[n][n];\n      for (int i = 0; i < n / 2; i++) {\n        for (int j = 0; j < n / 2; j++) {\n          mat[i][j] = 4 * curr + 1;\n          mat[i][j + n / 2] = 4 * curr + 2;\n          mat[i + n / 2][j] = 4 * curr + 3;\n          mat[i + n / 2][j + n / 2] = 4 * curr;\n\n          curr++;\n        }\n      }\n\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n          out.print(mat[i][j] + "" "");\n        }\n        out.println();\n      }\n    }\n\n  }\n}\n\n",constructive algorithms
"import java.util.*;\nimport java.io.*;\n\npublic class File {\n	\n	public static class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n		\n		public FastScanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n		\n		String next() {\n			while (st == null || !st.hasMoreElements()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				}\n				catch (IOException e) {\n					e.printStackTrace();\n				}\n			}\n			\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n	}\n	\n	public static void main(String[] args) {\n		FastScanner sc = new FastScanner();\n		PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n		\n		\n		\n		int N = sc.nextInt();\n		int[][] board = new int[N][N];\n		int val = 0;\n		\n		for (int i = 0; i < N/2; i++) {\n			for (int j = 0; j < N/2; j++) {\n				\n				board[i][j] = val*4 + 1;\n				board[i][j + N/2] = val*4 + 2;\n				board[i + N/2][j] = val*4 + 3;\n				board[i + N/2][j + N/2] = val*4;\n				\n				val++;\n			}\n		}\n		\n		for (int i = 0; i < N; i++) {\n			for (int j = 0; j < N; j++) {\n				out.print(board[i][j] + "" "");\n			}\n			\n			out.println();\n		}\n		\n		\n		out.close();\n	}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",constructive algorithms
"public class B{\n    public static void main(String[] args){\n        var sc = new java.util.Scanner(System.in);\n        StringBuilder sb = new StringBuilder();\n        int n = sc.nextInt(),m=sc.nextInt(),c=0,a[][]=new int[n][m],b[][]=new int[n][m];\n        for (int i=0;i<n;i++) for(int j=0;j<m;j++) a[i][j]=sc.nextInt();\n        for (int i=0;i<n-1;i++)\n            for (int j = 0; j<m-1; j++)\n                if (a[i][j]==a[i+1][j+1]&&a[i][j]==a[i+1][j]&&a[i][j]==a[i][j+1]&&a[i][j]==1) {\n                    c++;\n                    sb.append(""\n""+(i+1)+"" ""+(j+1));\n                    b[i][j]=b[i+1][j]=b[i][j+1]=b[i+1][j+1]=1;\n                }\n        for (int i=0;i<n;i++) for(int j=0;j<m;j++) if(a[i][j]!=b[i][j]) { System.out.println(-1); return;}\n        System.out.println(c+""""+sb);\n    }\n}","constructive algorithms,greedy,implementation"
"import java.util.*;\npublic class hxdb\n{\npublic static void main(String[] args)\n{\nScanner in=new Scanner(System.in);\nint n=in.nextInt();\nint m=in.nextInt();\nint a[][]=new int[n+1][m+1];\nint b[][]=new int[n+1][m+1];\nint i,j,x=0;\nfor(i=1;i<=n;i++)\n{\nfor(j=1;j<=m;j++)\n	a[i][j]=in.nextInt();\n}\nArrayList<Integer> p=new ArrayList<Integer>();\nArrayList<Integer> q=new ArrayList<Integer>();\nfor(i=1;i<n;i++)\n{\nfor(j=1;j<m;j++)\n{\nif(a[i][j]==1&&a[i+1][j]==1&&a[i][j+1]==1&&a[i+1][j+1]==1)\n{\nb[i][j]=1;\nb[i][j+1]=1;\nb[i+1][j]=1;\nb[i+1][j+1]=1;\np.add(i);\nq.add(j);\n}\n}\n}\nfor(i=1;i<=n;i++)\n{\nfor(j=1;j<=m;j++)\n{\nif(a[i][j]!=b[i][j])\n{\n	x=-1;\n	break;\n}\n}\n}\nif(x==-1)\n	System.out.println(-1);\nelse\n{\n	System.out.println(p.size());\n	for(i=0;i<p.size();i++)\n		System.out.println(p.get(i)+"" ""+q.get(i));\n}\n}\n}\n	\n	\n","constructive algorithms,greedy,implementation"
"import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main \n{\n	public static class Pair\n	{\n		public int first;\n		public int second;\n		public Pair(int first, int second)\n		{\n			this.first = first;\n			this.second = second;\n		}\n	}\n	public static void main(String[] args) \n	{\n		Scanner scanner = new Scanner(System.in);\n		int n = scanner.nextInt();\n		int m = scanner.nextInt();\n		int[][] a = new int[n][m];\n		int[][] b = new int[n][m];\n		ArrayList<Pair> solution = new ArrayList<>();\n		for(int i = 0 ; i < n ; i++)\n			for(int j = 0 ; j < m ; j++)\n				a[i][j] = scanner.nextInt();\n		for(int i = 0 ; i < n - 1 ; i++)\n		{\n			for(int j = 0 ; j < m - 1 ; j++)\n			{\n				int sum = 0;\n				for(int t1 = i ; t1 < i + 2 ; t1++)\n					for(int t2 = j ; t2 < j + 2 ; t2++)\n						sum += a[t1][t2];\n				if(sum == 4)\n				{\n					solution.add(new Pair(i + 1, j + 1));\n					for(int t1 = i ; t1 < i + 2 ; t1++)\n						for(int t2 = j ; t2 < j + 2 ; t2++)\n							b[t1][t2] = 1;\n				}\n			}\n		}\n		for(int i = 0 ; i < n ; i++)\n			for(int j = 0 ; j < m ; j++)\n				if(a[i][j] != b[i][j])\n				{\n					System.out.println(-1);\n					return;\n				}\n		System.out.println(solution.size());\n		for(Pair p : solution)\n			System.out.println(p.first + "" "" + p.second);\n		\n		scanner.close();\n	}\n}\n","constructive algorithms,greedy,implementation"
"\n\nimport java.util.Scanner;\nimport static java.lang.Math.*;\nimport java.util.List;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.HashMap;\n\npublic class square_filling{\n\n static int n, m;\n static boolean[][] A, B;\n static Scanner scanner = new Scanner(System.in);\n \n\n static boolean check(){\n\n      for(int i = 0; i < n; ++i)\n        for(int j = 0; j < m; ++j)\n            if(A[i][j] != B[i][j])\n                return false;\n\n    return true;\n }\n\n public static void main(String[] args) {\n     \n\n  n = scanner.nextInt();\n  m = scanner.nextInt();\n  A = new boolean[n][m];\n  B = new boolean[n][m];\n\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < m; ++j){\n\n        \n        A[i][j] = scanner.nextInt() == 1;\n    }\n\n  String ans = ""\n"";\n  int counter = 0;\n\n   for(int i = 0; i < n - 1; ++i)\n       for(int j = 0; j < m - 1; ++j)\n           if(A[i][j] && A[i][j + 1] && A[i + 1][j] && A[i + 1][j + 1]){\n\n               B[i][j] = B[i + 1][j] = B[i][j + 1] = B[i + 1][j + 1] = true; \n               ++counter;\n               ans += (i + 1) + "" "" + (j + 1);\n               ans += ""\n""; \n           } \n\n    if(check()){\n        System.out.println(counter + ans);\n    }\n    else\n    {\n        System.out.println(-1);\n    }\n}\n\n\n}","constructive algorithms,greedy,implementation"
"import java.util.*;\n\npublic class Main\n{\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int m1=-1,m2=-1;\n		for(int i=0;i<n;i++)\n		m1=Math.max(m1,sc.nextInt());\n		int m=sc.nextInt();\n		for(int i=0;i<m;i++)\n		m2=Math.max(m2,sc.nextInt());\n		System.out.println(m1+"" ""+m2);\n	}\n}\n","math,sortings"
"import java.util.*;\n\npublic class Main\n{\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int m1=-1,m2=-1;\n		for(int i=0;i<n;i++)\n		m1=Math.max(m1,sc.nextInt());\n		int m=sc.nextInt();\n		for(int i=0;i<m;i++)\n		m2=Math.max(m2,sc.nextInt());\n		System.out.println(m1+"" ""+m2);\n	}\n}\n","math,sortings"
"import java.util.*;\n\npublic class Mainn\n{\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int m1=-1,m2=-1;\n		for(int i=0;i<n;i++)\n		m1=Math.max(m1,sc.nextInt());\n		int m=sc.nextInt();\n		for(int i=0;i<m;i++)\n		m2=Math.max(m2,sc.nextInt());\n		System.out.println(m1+"" ""+m2);\n	}\n}\n","math,sortings"
"import java.util.*;\n\npublic class dc {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n	int n=sc.nextInt();\n	int[] l=new int[n];\n	for(int i=0;i<n;i++) {\n		l[i]=sc.nextInt();\n	}int m=sc.nextInt();\n	int[] h=new int[m];\n		for(int k=0;k<m;k++) {\n			h[k]=sc.nextInt();\n		}Arrays.sort(l);\n		Arrays.sort(h);\n		System.out.println(l[n-1]+"" ""+h[m-1]);\n\n}}","math,sortings"
"import java.io.*;\nimport java.util.*;\npublic class Main {  \n	public static void main(String[] args) {\n		FastScanner sc = new FastScanner();\n		PrintWriter out = new PrintWriter(System.out);\n		String str = sc.next();char ch[]=str.toCharArray();\n		int c0=0,c1=0;\n		for(int i=str.length()-1 ; i>=0 ; i--) {\n			if(ch[i]=='0') {\n				c0++;\n			}\n			else {\n				c1++;\n				if(c1 > c0) {\n					ch[i]='0';c1--;\n				}\n			}\n		}\n		for(int i=0 ; i<str.length() ; i++) {\n			out.print(ch[i]);\n		}\n		out.flush();\n		out.close();\n	}\n	static class FastScanner {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n		String next() {\n			while (!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		int [] readArray(int n) {\n			int[] a=new int[n];\n			for (int i=0; i<n; i++) a[i]=nextInt();\n			return a;\n		}\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n	}\n} \nclass MyComparator implements Comparator<Pair> {\n	public int compare(Pair a, Pair b) {\n		return (int)a.first - (int)b.first;\n	}\n}\n\nclass Pair\n{\n    int first,second;\n    Pair(int first,int second)\n    {\n        this.first=first;\n        this.second=second;\n    }\n}\n","brute force,greedy,strings"
"import java.util.*;\nimport java.io.*;\npublic class Main {\n    static class Scan {\n        private byte[] buf=new byte[1024];\n        private int index;\n        private InputStream in;\n        private int total;\n        public Scan()\n        {\n            in=System.in;\n        }\n        public int scan()throws IOException\n        {\n            if(total<0)\n            throw new InputMismatchException();\n            if(index>=total)\n            {\n                index=0;\n                total=in.read(buf);\n                if(total<=0)\n                return -1;\n            }\n            return buf[index++];\n        }\n        public int scanInt()throws IOException\n        {\n            int integer=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n))\n            {\n                if(n>='0'&&n<='9')\n                {\n                    integer*=10;\n                    integer+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            return neg*integer;\n        }\n        public double scanDouble()throws IOException\n        {\n            double doub=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n)&&n!='.')\n            {\n                if(n>='0'&&n<='9')\n                {\n                    doub*=10;\n                    doub+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            if(n=='.')\n            {\n                n=scan();\n                double temp=1;\n                while(!isWhiteSpace(n))\n                {\n                    if(n>='0'&&n<='9')\n                    {\n                        temp/=10;\n                        doub+=(n-'0')*temp;\n                        n=scan();\n                    }\n                    else throw new InputMismatchException();\n                }\n            }\n            return doub*neg;\n        }\n        public String scanString()throws IOException\n        {\n            StringBuilder sb=new StringBuilder();\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            while(!isWhiteSpace(n))\n            {\n                sb.append((char)n);\n                n=scan();\n            }\n            return sb.toString();\n        }\n        private boolean isWhiteSpace(int n)\n        {\n            if(n==' '||n=='\n'||n=='\r'||n=='\t'||n==-1)\n            return true;\n            return false;\n        }\n    }\n    \n    public static void sort(int arr[],int l,int r) {    //sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(int arr[],int l1,int r1,int l2,int r2) {\n        int tmp[]=new int[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        //sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        //Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n    \n    public static void sort(long arr[],int l,int r) {    //sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(long arr[],int l1,int r1,int l2,int r2) {\n        long tmp[]=new long[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        //sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        //Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n    public static void main(String args[]) throws IOException {\n        Scan input=new Scan();\n        StringBuilder str=new StringBuilder(input.scanString());\n        StringBuilder cpy=new StringBuilder(str);\n        StringBuilder ans=new StringBuilder("""");\n        ArrayList<Integer> arrli=new ArrayList<>();\n        for(int i=0;i<str.length();i++) {\n            arrli.add(i);\n        }\n        while(true) {\n            boolean done=false;\n            for(int i=0;i<cpy.length()-1;i++) {\n                if(cpy.charAt(i)=='1' && cpy.charAt(i+1)=='0') {\n                    cpy.delete(i, i+2);\n                    arrli.remove(i);\n                    arrli.remove(i);\n                    done=true;\n                    break;\n                }\n            }\n            if(!done) {\n                break;\n            }\n        }\n        for(int i=0;i<str.length();i++) {\n            if(arrli.size()>0 && arrli.get(0)==i) {\n                ans.append(0);\n                arrli.remove(0);\n                continue;\n            }\n            ans.append(str.charAt(i));\n        }\n        System.out.println(ans);\n    }\n}\n","brute force,greedy,strings"
"import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1204d1 {\n\n    public static void main(String[] args) throws IOException {\n        char[] s = rcha();\n        int n = s.length, bal = 0;\n        for (int i = n - 1; i >= 0; --i) {\n            if (s[i] == '0') {\n                ++bal;\n            } else if (bal > 0) {\n                --bal;\n            } else {\n                s[i] = '0';\n            }\n        }\n        prln(s);\n        close();\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int lcm(int a, int b) {return a * b / gcf(a, b);}\n    static long lcm(long a, long b) {return a * b / gcf(a, b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {prln(""yes"");}\n    static void pry() {prln(""Yes"");}\n    static void prY() {prln(""YES"");}\n    static void prno() {prln(""no"");}\n    static void prn() {prln(""No"");}\n    static void prN() {prln(""NO"");}\n    static boolean pryesno(boolean b) {prln(b ? ""yes"" : ""no""); return b;};\n    static boolean pryn(boolean b) {prln(b ? ""Yes"" : ""No""); return b;}\n    static boolean prYN(boolean b) {prln(b ? ""YES"" : ""NO""); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(""hlfd""); flush();}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}\n}","brute force,greedy,strings"
import java.util.*;\npublic class kirksubstring {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\nScanner sc=new Scanner(System.in);\nString st=sc.nextLine();\nchar s[]=st.toCharArray();\nint c=0;\nfor(int i=s.length-1;i>=0;i--)\n{\n	if(s[i]=='0')\n		c++;\n	else\n	{\n		if(c!=0)\n			c--;\n		else\n			s[i]='0';\n	}\n}\nSystem.out.println(s);\n	}\n\n}\n,"brute force,greedy,strings"
"import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class F{\n	\n	static int n;\n	static char[][] c;\n	static int[][] p;\n	static int[][][][] dp;\n	\n	static int query(int x, int y, int x2, int y2) {\n		return p[x2+1][y2+1] - p[x2+1][y] - p[x][y2+1] + p[x][y];\n	}\n	\n	static int solve(int x, int y, int x2, int y2) {\n		if (x > x2 || y > y2) return 0;\n		if (dp[x][y][x2][y2] == -1) {\n			int ans = max(x2-x+1,y2-y+1);\n			if (query(x,y,x2,y2) == 0) return dp[x][y][x2][y2] = 0;\n			if (x==x2 || y==y2) {\n				return dp[x][y][x2][y2] = query(x,y,x2,y2);\n			}\n			// if this has no black things return 0\n			// if everything is on one line answer is number of guys on the line (lower bounded)\n			\n			// iterate on row breaks			\n			\n			for (int i = y; i <= y2; i++) {\n				int prev = i-1;\n				int next = i+1;\n				if (query(x,i,x2,i)!=0) continue;\n				int ot = solve(x, y, x2, prev) + solve(x, next,x2,y2);\n				if (max(x,y) == 0 && min(x2,y2) == n-1) {\n					//System.out.println(""Yo "" + ot + "" "" + prev  + "" "" + next);\n				}\n				ans = min(ans, ot);\n			}\n			\n			// iterate on col breaks\n			for (int i = x; i <=x2; i++) {\n				int prev = i-1;\n				int next = i+1;\n				if (query(i, y, i, y2) != 0) continue;\n				int ot = solve(x, y, prev, y2) + solve(next, y, x2, y2);\n				ans = min(ans, ot);\n			}\n			\n			\n			dp[x][y][x2][y2] = ans;\n		}\n		return dp[x][y][x2][y2];\n	}\n	\n	public static void main(String[] args) throws IOException{\n		// br = new BufferedReader(new FileReader("".in""));\n		// out = new PrintWriter(new FileWriter("".out""));\n		// new Thread(null, new (), ""fisa balls"", 1<<28).start();\n		\n		n =readInt();\n		dp = new int[n][n][n][n];\n		c = new char[n][n];\n		for (int i = 0; i < n; i++) c[i]=read().toCharArray();\n		p = new int[n+1][n+1];\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < n; j++) if (c[i][j] == '#')p[i+1][j+1]++;\n		}\n		\n		for (int i = 1; i <= n; i++) {\n			for (int j = 1; j <= n; j++) {\n				p[i][j] += p[i-1][j] + p[i][j-1] - p[i-1][j-1];\n			}\n		}\n				\n		for (int[][][] x: dp) for(int[][] y: x) for (int[] z: y) Arrays.fill(z, -1);\n		out.println(solve(0,0,n-1,n-1));\n		\n		out.close();\n	}\n	\n	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n	static StringTokenizer st = new StringTokenizer("""");\n	static String read() throws IOException{\n		while (!st.hasMoreElements()) st = new StringTokenizer(br.readLine());\n		return st.nextToken();\n	}\n	public static int readInt() throws IOException{return Integer.parseInt(read());}\n	public static long readLong() throws IOException{return Long.parseLong(read());}\n}",dp
"import java.util.*;\nimport java.io.*;\n\npublic class D576 {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int n = sc.nextInt();\n        int [][][][] dp = new int[n][n][n][n];\n        int [][] a = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            String s = sc.next();\n            for (int j = 0; j < n; j++) {\n                if (s.charAt(j) == '#') {\n                    a[i][j] = 1;\n                    dp[i][i][j][j] = 1;\n                }\n            }\n        }\n        for (int r = 1; r <= n; r++) {\n            for (int c = 1; c <= n; c++) {\n                for (int i = 0; i <= n - r; i++) {\n                    for (int j = 0; j <= n - c; j++) {\n                        if (r == 1 && c == 1) continue;\n                        int hr = i + r - 1;\n                        int hc = j + c - 1;\n                        dp[i][hr][j][hc] = Math.max(hr - i + 1, hc - j + 1);\n                        for (int split = i; split <= hr - 1; split++) {\n                            dp[i][hr][j][hc] = Math.min(dp[i][hr][j][hc], dp[i][split][j][hc] + dp[split + 1][hr][j][hc]);\n                        }\n                        for (int split = j; split <= hc - 1; split++) {\n                            dp[i][hr][j][hc] = Math.min(dp[i][hr][j][hc], dp[i][hr][j][split] + dp[i][hr][split + 1][hc]);\n                        }\n                    }\n                }\n            }\n        }\n        out.println(dp[0][n - 1][0][n - 1]);\n        out.close();\n    }\n\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n\n    }\n\n}",dp
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Jaynil\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        int[][][][] dp;\n        char[][] c;\n\n        public int solve(int x1, int x2, int y1, int y2) {\n            if (dp[x1][x2][y1][y2] != -1) return dp[x1][x2][y1][y2];\n            dp[x1][x2][y1][y2] = Math.max(x2 - x1 + 1, y2 - y1 + 1);\n            if (x1 == x2 && y1 == y2) dp[x1][x2][y1][y1] = c[x1][y1] == '#' ? 1 : 0;\n            for (int i = x1; i < x2; i++) {\n                dp[x1][x2][y1][y2] = Math.min(dp[x1][x2][y1][y2], solve(x1, i, y1, y2) + solve(i + 1, x2, y1, y2));\n            }\n            for (int i = y1; i < y2; i++) {\n                dp[x1][x2][y1][y2] = Math.min(dp[x1][x2][y1][y2], solve(x1, x2, y1, i) + solve(x1, x2, i + 1, y2));\n            }\n            return dp[x1][x2][y1][y2];\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            c = new char[n][n];\n            dp = new int[n][n][n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    for (int k = 0; k < n; k++) {\n                        for (int l = 0; l < n; l++) {\n                            dp[i][j][k][l] = -1;\n                        }\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                String x = in.next();\n                for (int j = 0; j < n; j++) {\n                    c[i][j] = x.charAt(j);\n                }\n            }\n            out.println(solve(0, n - 1, 0, n - 1));\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n",dp
"\n// Imports\nimport java.util.*;\nimport java.io.*;\n\npublic class D1198 {\n\n    static int[][] arr;\n    static int[][] presum;\n    \n    public static int query(int x, int y, int x2, int y2) {\n        if(x > 0 && y > 0) {\n            return presum[x2 - 1][y2 - 1] - presum[x2 - 1][y - 1] - presum[x - 1][y2 - 1] + presum[x - 1][y - 1];\n        }\n        else if(y > 0) {\n            return presum[x2 - 1][y2 - 1] - presum[x2 - 1][y - 1];\n        }\n        else if(x > 0) {\n            return presum[x2 - 1][y2 - 1] - presum[x - 1][y2 - 1];\n        }\n        else {\n            return presum[x2 - 1][y2 - 1];\n        }\n    }\n    \n    /**\n     * @param args the command line arguments\n     * @throws IOException, FileNotFoundException \n     */\n    public static void main(String[] args) throws IOException, FileNotFoundException {\n        \n        // TODO UNCOMMENT WHEN ALGORITHM CORRECT\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        \n        \n        // TODO code application logic here\n        int N = Integer.parseInt(f.readLine());\n        \n        arr = new int[N][N];\n        \n        for(int i = 0; i < N; i++) {\n            String s = f.readLine();\n            for(int j = 0; j < N; j++) {\n                if(s.charAt(j) == '#') {\n                    arr[i][j] = 1;\n                }\n            }\n        }\n        \n        presum = new int[N][N];\n        for(int i = 0; i < presum.length; i++) {\n            for(int j = 0; j < presum.length; j++) {\n                if(j > 0) {\n                    presum[i][j] += presum[i][j - 1];\n                }\n                presum[i][j] += arr[i][j];\n            }\n        }\n        \n        for(int i = 0; i < presum.length; i++) {\n            for(int j = 0; j < presum.length; j++) {\n                if(i > 0) {\n                    presum[i][j] += presum[i - 1][j];\n                }\n            }\n        }\n        \n        // System.out.println(Arrays.deepToString(presum));\n        \n        int[][][][] dp = new int[N][N][N + 1][N + 1];\n        for(int dx = 1; dx <= dp.length; dx++) {\n            for(int dy = 1; dy <= dp.length; dy++) {\n                // System.out.println(""dx: "" + dx + "" "" + ""dy: "" + dy);\n                for(int x = 0; x <= dp.length - dx; x++) {\n                    for(int y = 0; y <= dp.length - dy; y++) {\n                        // start by assigning \n                        // System.out.println(x + "" "" + y + "" "" + dx + "" "" + dy);\n                        dp[x][y][x + dx][y + dy] = Math.max(dx, dy);\n                        \n                        if(query(x, y, x + dx, y + dy) == 0) {\n                            dp[x][y][x + dx][y + dy] = 0;\n                        }\n                        \n                        // System.out.println(dp[x][y][x + dx][y + dy]);\n                        \n                        for(int c = 1; c < dy; c++) {\n                            dp[x][y][x + dx][y + dy] = Math.min(dp[x][y][x + dx][y + c] + dp[x][y + c][x + dx][y + dy],\n                                                                    dp[x][y][x + dx][y + dy]);\n                        }\n                        for(int r = 1; r < dx; r++) {\n                            dp[x][y][x + dx][y + dy] = Math.min(dp[x][y][x + r][y + dy] + dp[x + r][y][x + dx][y + dy],\n                                    dp[x][y][x + dx][y + dy]);\n                        }\n                        \n                        // System.out.print(dp[x][y][x + dx][y + dy]);\n                        // System.out.print("" "");\n                    }\n                    // System.out.println();\n                }\n                // System.out.println();\n            }\n        }\n        \n        \n        System.out.println(dp[0][0][N][N]);\n        \n        \n    }\n\n}\n",dp
import java.util.*;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		while(n-->0) {\n			long sum=sc.nextLong()+sc.nextLong()+sc.nextLong();\n			System.out.println(sum/2);\n		}\n	}\n},"brute force,constructive algorithms,math"
import java.util.*;\n\npublic class Test {\n\n	public static void main(String[] args) {\n		Scanner read = new Scanner(System.in);\n\n		int t = read.nextInt();\n		while(t-- > 0) {\n			System.out.println((read.nextLong() + read.nextLong() + read.nextLong()) / 2);\n		}\n	}\n},"brute force,constructive algorithms,math"
import java.util.*;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		while(n-->0) {\n			long sum=sc.nextLong()+sc.nextLong()+sc.nextLong();\n			System.out.println(sum/2);\n		}\n	}\n},"brute force,constructive algorithms,math"
import java.util.*;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		while(n-->0) {\n			long sum=sc.nextLong()+sc.nextLong()+sc.nextLong();\n			System.out.println(sum/2);\n		}\n	}\n},"brute force,constructive algorithms,math"
"/*package whatever //do not write package name here */\n\nimport java.io.*;\nimport java.util.Arrays;\nimport java.util.*;\npublic class GFG {\n	public static void main (String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int a[] = new int[n+1];\n		a[0]=0;\n		for(int i=1;i<=n;i++)\n		{\n		    a[i] = sc.nextInt();\n		    if(i>1)\n		    a[i] += a[i-1];\n		}\n		int q = sc.nextInt();\n		while(q-- > 0)\n		{\n		    int l,r;\n		    l = sc.nextInt();\n		    r = sc.nextInt();\n		    System.out.println((a[r]-a[l-1])/10);\n		}\n	}\n}","data structures,dp,implementation,math"
"import java.util.*;\npublic class Main {\n	final static int maxn=(int)1e5+10;\n	static int a[]=new int [maxn];\n	static int sum[]=new int [maxn];\n public static void main(String args[])\n {\n	// System.out.println(1);\n	 Scanner input=new Scanner(System.in);\n	 int n=input.nextInt();\n	 for(int i=1;i<=n;i++)\n		 a[i]=input.nextInt();\n	 for(int i=1;i<=n;i++)\n		 sum[i]=a[i]+sum[i-1];\n	 int q=input.nextInt();\n	 while(q-->0)\n	 {\n		 int l,r;\n		 l=input.nextInt();r=input.nextInt();\n		 System.out.println((sum[r]-sum[l-1])/10);\n	 }\n }\n}\n\n  			  		 	 					 	       	 			","data structures,dp,implementation,math"
import java.util.Scanner;\n\n/**\n *\n * @author DELL\n */\npublic class codeforces {\n    public static void main(String[] args) {\n           Scanner sc=new Scanner(System.in);\n          int n=sc.nextInt();\n          int a[]=new int[n];\n          for(int i=0;i<n;i++)\n              a[i]=sc.nextInt();\n          int b[]=new int[n+1];\n          for(int i=1;i<n+1;i++)\n          {\n              b[i]=b[i-1]+a[i-1];\n             }\n          int q=sc.nextInt();\n           for(int i=0;i<q;i++)\n           {   int c=0;\n               int x=sc.nextInt();\n               int y=sc.nextInt();\n               System.out.println((b[y]-b[x-1])/10);\n               }\n           }\n}\n\n,"data structures,dp,implementation,math"
import java.util.*;\nimport java.io.*;\n\npublic class File {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n		// Just need to store the total points and the\n		// final value % 10 after the combining is over.\n		int n = sc.nextInt();\n		\n		int[] arr = new int[n];\n		for (int i = 0; i < n; i++) {\n			arr[i] = sc.nextInt();\n		}\n		\n		int[] prefix = new int[n];\n		prefix[0] = arr[0];\n		\n		for (int i = 1; i < n; i++) {\n			prefix[i] = arr[i] + prefix[i-1];\n		}\n		\n		int q = sc.nextInt();\n		for (int i = 0; i < q; i++) {\n			int L = sc.nextInt() - 1;\n			int R = sc.nextInt() - 1;\n			\n			int total = prefix[R] - (L > 0 ? prefix[L-1] : 0);\n			int score = total / 10;\n			\n			System.out.println(score);\n		}\n    }\n}\n,"data structures,dp,implementation,math"
"import java.util.*;\nimport java.io.*;\n\npublic class E\n{\n\n	static FastIO f;\n\n	public static void main(String args[]) throws IOException\n	{\n		f = new FastIO();\n\n		int t, n, m, i, j;\n		PriorityQueue<Point> h;\n		char[][] g;\n		char cs;\n		Point x, y, temp;\n		ArrayList<Pair> a;\n		boolean xa, ya, c;\n		\n		t = f.ni();\n		\n		while(t-->0)\n		{\n			n = f.ni();\n			m = f.ni();\n			g = new char[n][];\n			h = new PriorityQueue<>(Point.comp);\n			a = new ArrayList<>();\n\n			for(i = 0; i < n; i++)\n				g[i] = f.nca();\n\n			for(i = 0; i < n; i++)\n			{\n				for(j = 0; j < m; j++)\n				{\n					if(g[i][j] != '.')\n					{\n						h.add(new Point(g[i][j], i, j));\n					}\n				}\n			}\n\n			// f.err(h + ""\n"");\n\n			if(h.isEmpty())\n			{\n				f.out(""YES\n0\n"");\n				continue;\n			}\n\n			c = xa = ya = true;\n			x = y = h.poll();\n			cs = 'a';\n			while(!h.isEmpty())\n			{\n				temp = h.poll();\n\n				if(x.s != temp.s)\n				{\n					c = check(g, x, y);\n					if((xa || ya) && c)\n					{\n						while(cs <= x.s)\n						{\n							a.add(new Pair(x, y));\n							cs++;\n						}\n					}\n					else\n						break;\n\n					x = y = temp;\n					xa = ya = true;\n				}\n				else\n				{\n					y = temp;\n					xa = xa && x.x == y.x;\n					ya = ya && x.y == y.y;\n				}\n			}\n\n			if((!xa && !ya) || !c)\n			{\n				f.out(""NO\n"");\n				continue;\n			}\n\n			if((xa || ya) && check(g, x, y))\n			{\n				while(cs <= x.s)\n				{\n					a.add(new Pair(x, y));\n					cs++;\n				}\n			}\n			else\n			{\n				f.out(""NO\n"");\n				continue;\n			}\n\n			// f.err(a + ""\n"");\n\n			f.out(""YES\n"" + (a.size()) + ""\n"");\n\n			for(Pair p : a)\n			{\n				f.out((p.s.x+1) + "" "" + (p.s.y+1) + "" "" + (p.e.x+1) + "" "" + (p.e.y+1) + ""\n"");\n			}\n\n			f.err(""\n"");\n		}\n\n		f.flush();\n	}\n\n	public static boolean check(char[][] g, Point x, Point y) throws IOException\n	{\n		int i;\n\n		if(x.x == y.x)\n		{\n			for(i = x.y; i <= y.y; i++)\n				if(g[x.x][i] < g[x.x][x.y])\n					return false;\n		}\n		else\n		{\n			for(i = x.x; i <= y.x; i++)\n				if(g[i][x.y] < g[x.x][x.y])\n					return false;\n		}\n\n		f.err(x + "" to "" + y + "" is clear.\n"");\n\n		return true;\n	}\n\n	static class Pair\n	{\n		Point s, e;\n	\n		Pair(Point x, Point y)\n		{\n			s = x;\n			e = y;\n		}\n	\n		@Override\n		public int hashCode()\n		{\n			return super.hashCode();\n		}\n	\n		@Override\n		public boolean equals(Object obj)\n		{\n			Pair that = (Pair)obj;\n	\n			return super.equals(obj);\n		}\n	\n		@Override\n		public String toString()\n		{\n			return ""["" + s + "", "" + e + ""]"";\n		}\n	}\n\n	static class Point\n	{\n		char s;\n		int x, y;\n\n		static Comparator<Point> comp = new Comparator<>(){\n\n			@Override\n			public int compare(Point a, Point b)\n			{\n				return (a.s != b.s) ? a.s-b.s : (a.x != b.x) ? a.x-b.x : a.y-b.y;\n			}\n		};\n	\n		Point(char a, int b, int c)\n		{\n			s = a;\n			x = b;\n			y = c;\n		}\n	\n		@Override\n		public int hashCode()\n		{\n			return Objects.hash(s, x, y);\n		}\n	\n		@Override\n		public boolean equals(Object obj)\n		{\n			Point that = (Point)obj;\n	\n			return s == that.s && x == that.x && y == that.y;\n		}\n	\n		@Override\n		public String toString()\n		{\n			return ""["" + s + "", ("" + x + "", "" + y + "")"" + ""]"";\n		}\n	}\n\n	public static class FastIO\n	{\n		BufferedReader br;\n		BufferedWriter bw, be;\n		StringTokenizer st;\n\n		public FastIO()\n		{\n			br = new BufferedReader(new InputStreamReader(System.in));\n			bw = new BufferedWriter(new OutputStreamWriter(System.out));\n			be = new BufferedWriter(new OutputStreamWriter(System.err));\n			st = new StringTokenizer("""");\n		}\n\n		private void read() throws IOException\n		{\n			st = new StringTokenizer(br.readLine());\n		}\n\n		public String ns() throws IOException\n		{\n			while(!st.hasMoreTokens())\n				read();\n			return st.nextToken();\n		}\n\n		public int ni() throws IOException\n		{\n			return Integer.parseInt(ns());\n		}\n\n		public long nl() throws IOException\n		{\n			return Long.parseLong(ns());\n		}\n\n		public float nf() throws IOException\n		{\n			return Float.parseFloat(ns());\n		}\n\n		public double nd() throws IOException\n		{\n			return Double.parseDouble(ns());\n		}\n\n		public char nc() throws IOException\n		{\n			return ns().charAt(0);\n		}\n\n		public int[] nia(int n) throws IOException\n		{\n			int[] a = new int[n];\n			for(int i = 0; i < n; i++)\n				a[i] = ni();\n\n			return a;\n		}\n\n		public long[] nla(int n) throws IOException\n		{\n			long[] a = new long[n];\n			for(int i = 0; i < n; i++)\n				a[i] = nl();\n\n			return a;\n		}\n\n		public char[] nca() throws IOException\n		{\n			return ns().toCharArray();\n		}\n\n		public void out(String s) throws IOException\n		{\n			bw.write(s);\n		}\n\n		public void flush() throws IOException\n		{\n			bw.flush();\n			be.flush();\n		}\n\n		public void err(String s) throws IOException\n		{\n			be.write(s);\n		}\n	}\n}","brute force,implementation"
"import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/**\n *\n * @author Dstoical\n */\n\npublic class F {\n\n	private static long INF = 2000000000L, M = 1000000007, MM = 998244353;\n	private static int N = 0;\n\n	public static void process() throws IOException {\n\n		int n = sc.nextInt(),m = sc.nextInt();\n		char[][] arr = new char[n+1][m+1];\n		for(int i=0; i<n; i++) {\n			String s = sc.next();\n			for(int j=0; j<m; j++) {\n				arr[i][j] = s.charAt(j);\n			}\n		}\n		\n		int maxX[] = new int[26];\n		int minX[] = new int[26];\n		int maxY[] = new int[26];\n		int minY[] = new int[26];\n		\n		Arrays.fill(maxX, -1);\n		Arrays.fill(minX, n+1);\n		Arrays.fill(maxY, -1);\n		Arrays.fill(minY, m+1);\n		\n		for(int i=0; i<n; i++) {\n			for(int j=0; j<m; j++) {\n				if(arr[i][j] == '.')continue;\n				int code = arr[i][j]-'a';\n				maxX[code] = max(maxX[code],i);\n				maxY[code] = max(maxY[code],j);\n				minX[code] = min(minX[code],i);\n				minY[code] = min(minY[code],j);\n			}\n		}\n		int max = 0;\n		for(int i=0; i<26; i++) {\n			if(maxX[i] != -1)max = max(max,i+1);\n		}\n		StringBuilder ans = new StringBuilder();\n		ans.append(max+""\n"");\n		\n		for(int x=0; x<max; x++) {\n			if(maxX[x] == -1) {\n				outer : for(int i=0; i<n; i++) {\n					for(int j=0; j<m; j++) {\n						if(arr[i][j] == '.')continue;\n						int code = arr[i][j]-'a';\n						if(code >= x) {\n							maxX[x] = i;\n							maxY[x] = j;\n							minX[x] = i;\n							minY[x] = j;\n							break outer;\n						}\n					}\n				}\n			}\n			\n			if((maxX[x]-minX[x])*(maxY[x]-minY[x]) != 0) {\n				println(""NO"");\n				return;\n			}\n			\n			for(int i=minX[x]; i<=maxX[x]; i++) {\n				for(int j=minY[x]; j<=maxY[x]; j++) {\n					if(arr[i][j] - 'a' < x) {\n						println(""NO"");\n						return;\n					}\n				}\n			}\n			\n			ans.append((minX[x]+1)+"" ""+(minY[x]+1)+"" ""+(maxX[x]+1)+"" ""+(maxY[x]+1)+""\n"");\n		}\n		\n		println(""YES"");\n		print(ans);\n		\n\n	}\n\n	//=============================================================================\n	//--------------------------The End---------------------------------\n	//=============================================================================\n\n	static FastScanner sc;\n	static PrintWriter out;\n\n	public static void main(String[] args) throws IOException {\n		boolean oj = true;\n		if (oj) {\n			sc = new FastScanner();\n			out = new PrintWriter(System.out);\n		} else {\n			sc = new FastScanner(100);\n			out = new PrintWriter(""output.txt"");\n		}\n		int t = 1;\n		t = sc.nextInt();\n		while (t-- > 0) {\n			process();\n		}\n		out.flush();\n		out.close();\n	}\n\n	static class Pair implements Comparable<Pair> {\n		int x, y;\n\n		Pair(int x, int y) {\n			this.x = x;\n			this.y = y;\n		}\n\n		@Override\n		public int compareTo(Pair o) {\n			return Integer.compare(this.x, o.x);\n		}\n	}\n\n	/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n	static void println(Object o) {\n		out.println(o);\n	}\n\n	static void println() {\n		out.println();\n	}\n\n	static void print(Object o) {\n		out.print(o);\n	}\n\n	static void pflush(Object o) {\n		out.println(o);\n		out.flush();\n	}\n\n	static int ceil(int x, int y) {\n		return (x % y == 0 ? x / y : (x / y + 1));\n	}\n\n	static long ceil(long x, long y) {\n		return (x % y == 0 ? x / y : (x / y + 1));\n	}\n\n	static int max(int x, int y) {\n		return Math.max(x, y);\n	}\n\n	static int min(int x, int y) {\n		return Math.min(x, y);\n	}\n\n	static int abs(int x) {\n		return Math.abs(x);\n	}\n\n	static long abs(long x) {\n		return Math.abs(x);\n	}\n\n	static int log2(int N) {\n		int result = (int) (Math.log(N) / Math.log(2));\n		return result;\n	}\n\n	static long max(long x, long y) {\n		return Math.max(x, y);\n	}\n\n	static long min(long x, long y) {\n		return Math.min(x, y);\n	}\n\n	public static int gcd(int a, int b) {\n		BigInteger b1 = BigInteger.valueOf(a);\n		BigInteger b2 = BigInteger.valueOf(b);\n		BigInteger gcd = b1.gcd(b2);\n		return gcd.intValue();\n	}\n\n	public static long gcd(long a, long b) {\n		BigInteger b1 = BigInteger.valueOf(a);\n		BigInteger b2 = BigInteger.valueOf(b);\n		BigInteger gcd = b1.gcd(b2);\n		return gcd.longValue();\n	}\n\n	/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n	static class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		FastScanner() throws FileNotFoundException {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		FastScanner(int a) throws FileNotFoundException {\n			br = new BufferedReader(new FileReader(""input.txt""));\n		}\n\n		String next() throws IOException {\n			while (st == null || !st.hasMoreElements()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			}\n			return st.nextToken();\n		}\n\n		int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n\n		String nextLine() throws IOException {\n			String str = """";\n			try {\n				str = br.readLine();\n			} catch (IOException e) {\n				e.printStackTrace();\n			}\n			return str;\n		}\n\n		int[] readArray(int n) throws IOException {\n			int[] A = new int[n];\n			for (int i = 0; i != n; i++) {\n				A[i] = sc.nextInt();\n			}\n			return A;\n		}\n\n		long[] readArrayLong(int n) throws IOException {\n			long[] A = new long[n];\n			for (int i = 0; i != n; i++) {\n				A[i] = sc.nextLong();\n			}\n			return A;\n		}\n	}\n\n	static void ruffleSort(int[] a) {\n		Random get = new Random();\n		for (int i = 0; i < a.length; i++) {\n			int r = get.nextInt(a.length);\n			int temp = a[i];\n			a[i] = a[r];\n			a[r] = temp;\n		}\n		Arrays.sort(a);\n	}\n\n	static void ruffleSort(long[] a) {\n		Random get = new Random();\n		for (int i = 0; i < a.length; i++) {\n			int r = get.nextInt(a.length);\n			long temp = a[i];\n			a[i] = a[r];\n			a[r] = temp;\n		}\n		Arrays.sort(a);\n	}\n}\n","brute force,implementation"
"import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1185e {\n\n    public static void main(String[] args) throws IOException {\n        int t = ri();\n        next: while (t --> 0) {\n            int n = rni(), m = ni(), pos[][] = new int[26][4], bounds[][] = new int[26][4];\n            for (int i = 0; i < 26; ++i) {\n                fill(pos[i], -1);\n                bounds[i][0] = n;\n                bounds[i][1] = m;\n            }\n            char[][] map = new char[n][m];\n            for (int i = 0; i < n; ++i) {\n                char[] row = rcha();\n                for (int j = 0; j < m; ++j) {\n                    map[i][j] = row[j];\n                    if (row[j] >= 'a') {\n                        int ind = row[j] - 'a';\n                        if (pos[ind][0] == -1) {\n                            pos[ind][0] = i;\n                            pos[ind][1] = j;\n                        }\n                        pos[ind][2] = i;\n                        pos[ind][3] = j;\n                        bounds[ind][0] = min(bounds[ind][0], i);\n                        bounds[ind][1] = min(bounds[ind][1], j);\n                        bounds[ind][2] = max(bounds[ind][2], i);\n                        bounds[ind][3] = max(bounds[ind][3], j);\n                    }\n                }\n            }\n            // prln(pos[0]);\n            int ans = 26;\n            for (int i = 25; i >= 0; --i) {\n                if (pos[i][0] == -1 && (i == 25 || pos[i + 1][0] == -1)) {\n                    --ans;\n                    continue;\n                }\n                if (pos[i][0] == -1) {\n                    pos[i][0] = pos[i][2] = pos[i + 1][0];\n                    pos[i][1] = pos[i][3] = pos[i + 1][1];\n                    continue;\n                }\n                if (bounds[i][0] != bounds[i][2] && bounds[i][1] != bounds[i][3]) {\n                    // prln(bounds[i]);\n                    prN();\n                    continue next;\n                }\n                if (pos[i][0] == pos[i][2]) {\n                    for (int j = pos[i][1] + 1; j < pos[i][3]; ++j) {\n                        if (map[pos[i][0]][j] - 'a' < i) {\n                            // prln(i, pos[i][0], j);\n                            prN();\n                            continue next;\n                        }\n                    }\n                } else {\n                    for (int j = pos[i][0] + 1; j < pos[i][2]; ++j) {\n                        if (map[j][pos[i][1]] - 'a' < i) {\n                            // prln(i, j, pos[i][1]);\n                            prN();\n                            continue next;\n                        }\n                    }\n                }\n            }\n            prY();\n            prln(ans);\n            for (int i = 0; i < ans; ++i) {\n                prln(pos[i][0] + 1, pos[i][1] + 1, pos[i][2] + 1, pos[i][3] + 1);\n            }\n        }\n        close();\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int lcm(int a, int b) {return a * b / gcf(a, b);}\n    static long lcm(long a, long b) {return a * b / gcf(a, b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {prln(""yes"");}\n    static void pry() {prln(""Yes"");}\n    static void prY() {prln(""YES"");}\n    static void prno() {prln(""no"");}\n    static void prn() {prln(""No"");}\n    static void prN() {prln(""NO"");}\n    static boolean pryesno(boolean b) {prln(b ? ""yes"" : ""no""); return b;};\n    static boolean pryn(boolean b) {prln(b ? ""Yes"" : ""No""); return b;}\n    static boolean prYN(boolean b) {prln(b ? ""YES"" : ""NO""); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(""hlfd""); flush();}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}\n}","brute force,implementation"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1185E {\n	static final int A = 26;\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter pw = new PrintWriter(System.out);\n		int[] i1 = new int[A];\n		int[] i2 = new int[A];\n		int[] j1 = new int[A];\n		int[] j2 = new int[A];\n		int t = Integer.parseInt(br.readLine());\n		while (t-- > 0) {\n			StringTokenizer st = new StringTokenizer(br.readLine());\n			int n = Integer.parseInt(st.nextToken());\n			int m = Integer.parseInt(st.nextToken());\n			char[][] cc = new char[n][m];\n			for (int i = 0; i < n; i++)\n				br.readLine().getChars(0, m, cc[i], 0);\n			Arrays.fill(i1, n);\n			Arrays.fill(i2, -1);\n			Arrays.fill(j1, m);\n			Arrays.fill(j2, -1);\n			for (int i = 0; i < n; i++)\n				for (int j = 0; j < m; j++) {\n					char c = cc[i][j];\n					if (c != '.') {\n						int a = c - 'a';\n						if (i1[a] > i)\n							i1[a] = i;\n						if (i2[a] < i)\n							i2[a] = i;\n						if (j1[a] > j)\n							j1[a] = j;\n						if (j2[a] < j)\n							j2[a] = j;\n					}\n				}\n			int b = -1;\n			boolean yes = true;\nout:\n			for (int a = A - 1; a >= 0; a--)\n				if (i1[a] <= i2[a] && j1[a] <= j2[a]) {\n					if (b == -1)\n						b = a;\n					if (i1[a] < i2[a] && j1[a] < j2[a]) {\n						yes = false;\n						break;\n					}\n					char c = (char) (a + 'a');\n					for (int i = i1[a]; i <= i2[a]; i++)\n						for (int j = j1[a]; j <= j2[a]; j++) {\n							if (cc[i][j] != c && cc[i][j] != ' ') {\n								yes = false;\n								break out;\n							}\n							cc[i][j] = ' ';\n						}\n				}\n			if (yes) {\n				pw.println(""YES"");\n				pw.println(b + 1);\n				for (int a = 0; a <= b; a++) {\n					int c = i1[a] <= i2[a] && j1[a] <= j2[a] ? a : b;\n					pw.println((i1[c] + 1) + "" "" + (j1[c] + 1) + "" "" + (i2[c] + 1) + "" "" + (j2[c] + 1));\n				}\n			} else\n				pw.println(""NO"");\n		}\n		pw.close();\n	}\n}\n","brute force,implementation"
"import java.io.*;\nimport java.util.*;\n \npublic class Main\n{\n	static class InputReader {\n		BufferedReader reader;\n		StringTokenizer tokenizer;\n		public InputReader(InputStream stream) {\n			reader = new BufferedReader(new InputStreamReader(stream), 32768);\n			tokenizer = null;\n		}\n		String next() { // reads in the next string\n			while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n				try {\n					tokenizer = new StringTokenizer(reader.readLine());\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n			return tokenizer.nextToken();\n		}\n		public int nextInt() { // reads in the next int\n			return Integer.parseInt(next());\n		}\n		public long nextLong() { // reads in the next long\n			return Long.parseLong(next());\n		}\n		public double nextDouble() { // reads in the next double\n			return Double.parseDouble(next());\n			}\n		}\n	static InputReader r = new InputReader(System.in);\n	static PrintWriter pw = new PrintWriter(System.out);\n	static long mod = 998244353;\n	public static void main(String[] args)\n	{\n		int n = r.nextInt();\n		int z = r.nextInt();\n		int[] p = new int[n];\n		int[] pos = new int[n];\n		for (int i= 0; i < n; i ++)\n		{\n			p[i] = r.nextInt() - 1;\n			pos[p[i]] = i;\n		}\n		int[][] min = new int[n][n];\n		for (int i = 0; i < n; i ++)\n		{\n			for (int j = i; j < n; j ++)\n			{\n				min[i][j] = n + 1;\n				for (int k = i; k <= j; k ++)\n				{\n					min[i][j] = Math.min(min[i][j],p[k]);\n				}\n			}\n		}\n		long[][] dp = new long[n][n];\n		for (int i = 0; i < n; i ++)\n		{\n			dp[i][i] = 1;\n		}\n		for (int k = 1; k < n; k ++)\n		{\n			for (int i = 0; i+k < n; i ++)\n			{\n				int j = i + k;\n				int x = pos[min[i][j]];\n				long count1;\n				if (x == i)\n				{\n					count1 = 1;\n				}\n				else\n				{\n					count1 = 2*dp[i][x-1];\n					count1 %= mod;\n					for (int m = i; m < x - 1; m ++)\n					{\n						count1 += dp[i][m]*dp[m+1][x-1];\n						count1 %= mod;\n					}\n				}\n				long count2;\n				if (x == j)\n				{\n					count2 = 1;\n				}\n				else\n				{\n					count2 = 2 * dp[x+1][j];\n					count2 %= mod;\n					for (int m = x + 1; m < j; m ++)\n					{\n						count2 += dp[x+1][m] * dp[m+1][j];\n						count2 %= mod;\n					}\n				}\n				dp[i][j] = (count1*count2)%mod;\n			}\n		}\n		pw.println(dp[0][n-1]);\n		pw.close();\n	}\n	\n}","combinatorics,dfs and similar,dp"
"import java.util.*;\nimport java.io.*;\n\npublic class F14 {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int n = sc.nextInt(); int m = sc.nextInt();\n        long mod = 998244353;\n        int [] a = new int[m];\n        for (int i = 0; i < m; i++) a[i] = sc.nextInt();\n        long [][] dp = new long[m][m];\n        for (int len = 1; len <= m; len++) {\n            for (int i = 0; i < m - len + 1; i++) {\n                int j = i + len - 1;\n                if (len == 1) {\n                    dp[i][j] = 1;\n                    continue;\n                }\n                int minIndex = -1; int min = Integer.MAX_VALUE;\n                for (int k = i; k <= j; k++) {\n                    if (a[k] < min) {\n                        min = a[k]; minIndex = k;\n                    }\n                }\n                long leftSum = 0;\n                for (int left = minIndex; left >= i; left--) {\n                    long r = 1; long l = 1;\n                    if (left < minIndex) r = dp[left][minIndex - 1];\n                    if (left > i) l = dp[i][left - 1];\n                    leftSum = (leftSum + (r * l) % mod) % mod;\n                }\n                long rightSum = 0;\n                for (int right = minIndex; right <= j; right++) {\n                    long l = 1; long r = 1;\n                    if (right > minIndex) l = dp[minIndex + 1][right];\n                    if (right < j) r = dp[right + 1][j];\n                    rightSum = (rightSum + (l * r) % mod) % mod;\n                }\n                dp[i][j] = (leftSum * rightSum) % mod;\n            }\n        }\n        out.println(dp[0][m - 1]);\n        out.close();\n    }\n\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n\n    }\n\n}","combinatorics,dfs and similar,dp"
"import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n\n	private static final String NO = ""No"";\n	private static final String YES = ""Yes"";\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n\n	private static final long MOD = 998244353;\n\n	void solve() {\n		int T = 1;// ni();\n\n		for (int i = 0; i < T; i++)\n			solve(i);\n	}\n\n	void solve(int nth) {\n		int n = ni();\n		int m = ni();\n		long[][] f = new long[n + 2][n + 2];\n		long[][] g = new long[n + 2][n + 2];\n		int[] a = new int[n + 1];\n		for (int i = 1; i <= n; i++)\n			a[i] = ni();\n\n		for (int i = 1; i <= n + 1; i++)\n			g[i][i] = f[i][i] = f[i][i - 1] = g[i][i - 1] = 1;\n		for (int len = 2; len <= n; len++) {\n			for (int l = 1; l + len - 1 <= n; l++) {\n				int r = l + len - 1;\n				int tmp = l;\n				for (int k = l; k <= r; k++) {\n					if (a[k] < a[tmp])\n						tmp = k;\n				}\n				g[l][r] = f[l][tmp - 1] * f[tmp + 1][r] % MOD;\n				for (int k = l; k <= r; k++) {\n					f[l][r] = (f[l][r] + g[l][k] * f[k + 1][r] % MOD) % MOD;\n				}\n			}\n		}\n		out.print(f[1][n]);\n\n	}\n\n	// a^b\n	long power(long a, long b) {\n		long x = 1, y = a;\n		while (b > 0) {\n			if (b % 2 != 0) {\n				x = (x * y) % MOD;\n			}\n			y = (y * y) % MOD;\n			b /= 2;\n		}\n		return x % MOD;\n	}\n\n	private long gcd(long a, long b) {\n		while (a != 0) {\n			long tmp = b % a;\n			b = a;\n			a = tmp;\n		}\n		return b;\n	}\n\n	void run() throws Exception {\n		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		if (!INPUT.isEmpty())\n			tr(System.currentTimeMillis() - s + ""ms"");\n	}\n\n	public static void main(String[] args) throws Exception {\n		new Main().run();\n	}\n\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n\n	private int readByte() {\n		if (lenbuf == -1)\n			throw new InputMismatchException();\n		if (ptrbuf >= lenbuf) {\n			ptrbuf = 0;\n			try {\n				lenbuf = is.read(inbuf);\n			} catch (IOException e) {\n				throw new InputMismatchException();\n			}\n			if (lenbuf <= 0)\n				return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n\n	private boolean isSpaceChar(int c) {\n		return !(c >= 33 && c <= 126);\n	}\n\n	private int skip() {\n		int b;\n		while ((b = readByte()) != -1 && isSpaceChar(b))\n			;\n		return b;\n	}\n\n	private double nd() {\n		return Double.parseDouble(ns());\n	}\n\n	private char nc() {\n		return (char) skip();\n	}\n\n	private char[] nc(int n) {\n		char[] ret = new char[n];\n		for (int i = 0; i < n; i++)\n			ret[i] = nc();\n		return ret;\n	}\n\n	private String ns() {\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n									// ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	private char[] ns(int n) {\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while (p < n) {\n			if (!(isSpaceChar(b)))\n				buf[p++] = (char) b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n\n	private char[][] nm(int n, int m) {\n		char[][] map = new char[n][];\n		for (int i = 0; i < n; i++)\n			map[i] = ns(m);\n		return map;\n	}\n\n	private int[] na(int n) {\n		int[] a = new int[n];\n		for (int i = 0; i < n; i++)\n			a[i] = ni();\n		return a;\n	}\n\n	private Integer[] na2(int n) {\n		Integer[] a = new Integer[n];\n		for (int i = 0; i < n; i++)\n			a[i] = ni();\n		return a;\n	}\n\n	private int[][] na(int n, int m) {\n		int[][] a = new int[n][];\n		for (int i = 0; i < n; i++)\n			a[i] = na(m);\n		return a;\n	}\n\n	private int ni() {\n		int num = 0, b;\n		boolean minus = false;\n		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n			;\n		if (b == '-') {\n			minus = true;\n			b = readByte();\n		}\n\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				num = num * 10 + (b - '0');\n			} else {\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n\n	private Long[] nl2(int n) {\n		Long[] a = new Long[n];\n		for (int i = 0; i < n; i++)\n			a[i] = nl();\n		return a;\n	}\n\n	private long[] nl(int n) {\n		long[] a = new long[n];\n		for (int i = 0; i < n; i++)\n			a[i] = nl();\n		return a;\n	}\n\n	private long[][] nl(int n, int m) {\n		long[][] a = new long[n][];\n		for (int i = 0; i < n; i++)\n			a[i] = nl(m);\n		return a;\n	}\n\n	private long nl() {\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n			;\n		if (b == '-') {\n			minus = true;\n			b = readByte();\n		}\n\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				num = num * 10 + (b - '0');\n			} else {\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n\n	private static void tr(Object... o) {\n		System.out.println(Arrays.deepToString(o));\n	}\n}\n","combinatorics,dfs and similar,dp"
"import java.util.*;\nimport java.io.*;\n \npublic class Main {\n	public static void main(String args[]) {new Main().work();}\n	\n	Scanner in = new Scanner(System.in);\n	PrintWriter out = new PrintWriter(System.out);\n	int mod=998244353;\n	void work() {		\n		int n=in.nextInt();\n		int m=in.nextInt();\n		\n		int[] A=new int[n];\n		for(int i=0;i<n;i++) A[i]=in.nextInt();\n		long[][] dp=new long[n][n];\n		out.print(helper(A,0,n-1,dp));\n		out.flush();\n	}\n	\n	long helper(int[] A,int s,int e,long[][] dp){\n	    if(s>e) return 1;\n	    if(dp[s][e]>0) return dp[s][e];\n	    int min=s;\n	    for(int i=s;i<=e;i++){\n	        if(A[i]<A[min]){\n	            min=i;\n	        }\n	        dp[s][e]+=((helper(A,s,min-1,dp)*helper(A,min+1,i,dp)%mod)*helper(A,i+1,e,dp))%mod;\n	    }\n	    dp[s][e]%=mod;\n	    return dp[s][e];\n	}\n}\n","combinatorics,dfs and similar,dp"
"import java.io.*;\nimport java.util.*;\n\npublic class ShovelsShop {\n    static final int INF = 1000000000;\n    private static void sortArray(int[] A) {\n        int N = A.length;\n        List<Integer> list = new ArrayList<>(N);\n        for (int x : A) {\n            list.add(x);\n        }\n        Collections.sort(list);\n        for (int i = 0; i < N; i++) {\n            A[i] = list.get(i);\n        }\n    }\n    public static void main(String[] args) {\n        InputReader reader = new InputReader(System.in);\n        PrintWriter writer = new PrintWriter(System.out, false);\n        int N = reader.nextInt();\n        int M = reader.nextInt();\n        int K = reader.nextInt();\n        int[] A = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = reader.nextInt();\n        }\n        int[] X = new int[M];\n        int[] Y = new int[M];\n        for (int i = 0; i < M; i++) {\n            X[i] = reader.nextInt();\n            Y[i] = reader.nextInt();\n        }\n        sortArray(A);\n        int[] prefix = new int[K + 1];\n        for (int i = 0; i < K; i++) {\n            prefix[i + 1] = prefix[i] + A[i];\n        }\n        int[] offers = new int[K + 1];\n        for (int i = 0; i < M; i++) {\n            if (X[i] <= K) offers[X[i]] = Math.max(offers[X[i]], Y[i]);\n        }\n        int[] dp = new int[K + 1];\n        Arrays.fill(dp, INF);\n        dp[0] = 0;\n        for (int i = 1; i <= K; i++) {\n            for (int j = 0; j < i; j++) {\n                dp[i] = Math.min(dp[i], dp[j] + prefix[i] - prefix[j + offers[i - j]]);\n            }\n        }\n        writer.println(dp[K]);\n        writer.close();\n        System.exit(0);\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        public String nextLine() {\n            String str = """";\n            try {\n                str = reader.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}","dp,greedy,sortings"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        FShovelsShop solver = new FShovelsShop();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FShovelsShop {\n        int n;\n        int m;\n        int k;\n        int[] arr;\n        int[] offPos;\n        int[] offCount;\n        int[] prefix;\n        int[] memo;\n\n        public void solve(int testNumber, Scanner sc, PrintWriter pw) {\n            n = sc.nextInt();\n            m = sc.nextInt();\n            k = sc.nextInt();\n            arr = new int[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = sc.nextInt();\n            for (int i = n - 1; i >= 0; i--) {\n                int rand = (int) (Math.random() * (i + 1));\n                int temp = arr[rand];\n                arr[rand] = arr[i];\n                arr[i] = temp;\n            }\n            Arrays.sort(arr);\n            prefix = new int[k];\n            for (int i = 0; i < prefix.length; i++) {\n                prefix[i] = arr[i];\n                if (i > 0)\n                    prefix[i] += prefix[i - 1];\n            }\n            offCount = new int[m];\n            offPos = new int[m];\n            for (int i = 0; i < m; i++) {\n                offCount[i] = sc.nextInt();\n                offPos[i] = sc.nextInt();\n            }\n            memo = new int[k];\n            Arrays.fill(memo, -1);\n            pw.println(dp(0));\n        }\n\n        private int dp(int idx) {\n            if (idx == k)\n                return 0;\n            if (memo[idx] != -1)\n                return memo[idx];\n            int min = arr[idx] + dp(idx + 1);\n            for (int i = 0; i < m; i++) {\n                if (offCount[i] + idx <= k) {\n                    min = Math.min(min, prefix[idx + offCount[i] - 1] - prefix[idx + offPos[i] - 1] + dp(idx + offCount[i]));\n                }\n            }\n            return memo[idx] = min;\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n","dp,greedy,sortings"
"import java.util.*;\nimport java.io.*;\n\npublic class E_1216 {\n	\n	static int k;\n	static int[] array, offers;\n	static long[] sum;\n	static long[] memo;\n	\n	public static long dp(int i) {\n		if(i == 0)\n			return 0;\n		\n		if(memo[i] != -1)\n			return memo[i];\n		\n		long min = array[i - 1] + dp(i - 1);\n		for(int j = 1; j <= i; j++)\n			min = Math.min(min, 1l * sum[i - 1] - ((i - (j - offers[j - 1]) - 1) == -1 ? 0 : sum[i - (j - offers[j - 1]) - 1]) + dp(i - j));\n		\n		return memo[i] = min;\n	}\n	\n	public static void main(String[] args) throws Exception {\n		Scanner sc = new Scanner(System.in);\n		PrintWriter pw = new PrintWriter(System.out);\n		\n		int n = sc.nextInt(), m = sc.nextInt();\n		k = sc.nextInt();\n		\n		int[] tmp = sc.shuffle(sc.nextIntArray(n));\n		Arrays.sort(tmp);\n		array = new int[k];\n		for(int i = 0; i < k; i++)\n			array[i] = tmp[i];\n		\n		sum = new long[n];\n		sum[0] = array[0];\n		for(int i = 1; i < k; i++)\n			sum[i] = 1l * sum[i - 1] + array[i];\n		\n		int[] tmpoffers = new int[(int)2e5];\n		for(int i = 0; i < m; i++) {\n			int x = sc.nextInt() - 1;\n			tmpoffers[x] = Math.max(tmpoffers[x], sc.nextInt());\n		}\n		\n		offers = new int[k];\n		for(int i = 0; i < k; i++)\n			offers[i] = tmpoffers[i];\n		\n		memo = new long[k + 1];\n		Arrays.fill(memo, -1);\n				\n		pw.println(dp(k));\n		pw.flush();\n	}\n\n	public static class Scanner {\n		StringTokenizer st;\n		BufferedReader br;\n\n		public Scanner(InputStream system) {\n			br = new BufferedReader(new InputStreamReader(system));\n		}\n\n		public Scanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n\n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n\n		public char nextChar() throws IOException {\n			return next().charAt(0);\n		}\n\n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n\n		public int[] nextIntArray(int n) throws IOException {\n			int[] array = new int[n];\n			for (int i = 0; i < n; i++)\n				array[i] = nextInt();\n			return array;\n		}\n\n		public Integer[] nextIntegerArray(int n) throws IOException {\n			Integer[] array = new Integer[n];\n			for (int i = 0; i < n; i++)\n				array[i] = new Integer(nextInt());\n			return array;\n		}\n\n		public long[] nextLongArray(int n) throws IOException {\n			long[] array = new long[n];\n			for (int i = 0; i < n; i++)\n				array[i] = nextLong();\n			return array;\n		}\n\n		public double[] nextDoubleArray(int n) throws IOException {\n			double[] array = new double[n];\n			for (int i = 0; i < n; i++)\n				array[i] = nextDouble();\n			return array;\n		}\n\n		public static int[] shuffle(int[] a) {\n			int n = a.length;\n			Random rand = new Random();\n			for (int i = 0; i < n; i++) {\n				int tmpIdx = rand.nextInt(n);\n				int tmp = a[i];\n				a[i] = a[tmpIdx];\n				a[tmpIdx] = tmp;\n			}\n			return a;\n		}\n\n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n\n		public void waitForInput() throws InterruptedException {\n			Thread.sleep(3000);\n		}\n	}\n}\n","dp,greedy,sortings"
"import java.util.*;\nimport java.io.*;\n\npublic class F_1154 {\n	\n	static int k;\n	static int[] array, offers;\n	static long[] sum;\n	static long[] memo;\n	\n	public static long dp(int i) {\n		if(i == 0)\n			return 0;\n		\n		if(memo[i] != -1)\n			return memo[i];\n		\n		long min = array[i - 1] + dp(i - 1);\n		for(int j = 1; j <= i; j++)\n			min = Math.min(min, 1l * sum[i - 1] - ((i - (j - offers[j - 1]) - 1) == -1 ? 0 : sum[i - (j - offers[j - 1]) - 1]) + dp(i - j));\n		\n		return memo[i] = min;\n	}\n	\n	public static void main(String[] args) throws Exception {\n		Scanner sc = new Scanner(System.in);\n		PrintWriter pw = new PrintWriter(System.out);\n		\n		int n = sc.nextInt(), m = sc.nextInt();\n		k = sc.nextInt();\n		\n		int[] tmp = sc.shuffle(sc.nextIntArray(n));\n		Arrays.sort(tmp);\n		array = new int[k];\n		for(int i = 0; i < k; i++)\n			array[i] = tmp[i];\n		\n		sum = new long[n];\n		sum[0] = array[0];\n		for(int i = 1; i < k; i++)\n			sum[i] = 1l * sum[i - 1] + array[i];\n		\n		int[] tmpoffers = new int[(int)2e5];\n		for(int i = 0; i < m; i++) {\n			int x = sc.nextInt() - 1;\n			tmpoffers[x] = Math.max(tmpoffers[x], sc.nextInt());\n		}\n		\n		offers = new int[k];\n		for(int i = 0; i < k; i++)\n			offers[i] = tmpoffers[i];\n		\n		memo = new long[k + 1];\n		Arrays.fill(memo, -1);\n				\n		pw.println(dp(k));\n		pw.flush();\n	}\n\n	public static class Scanner {\n		StringTokenizer st;\n		BufferedReader br;\n\n		public Scanner(InputStream system) {\n			br = new BufferedReader(new InputStreamReader(system));\n		}\n\n		public Scanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n\n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n\n		public char nextChar() throws IOException {\n			return next().charAt(0);\n		}\n\n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n\n		public int[] nextIntArray(int n) throws IOException {\n			int[] array = new int[n];\n			for (int i = 0; i < n; i++)\n				array[i] = nextInt();\n			return array;\n		}\n\n		public Integer[] nextIntegerArray(int n) throws IOException {\n			Integer[] array = new Integer[n];\n			for (int i = 0; i < n; i++)\n				array[i] = new Integer(nextInt());\n			return array;\n		}\n\n		public long[] nextLongArray(int n) throws IOException {\n			long[] array = new long[n];\n			for (int i = 0; i < n; i++)\n				array[i] = nextLong();\n			return array;\n		}\n\n		public double[] nextDoubleArray(int n) throws IOException {\n			double[] array = new double[n];\n			for (int i = 0; i < n; i++)\n				array[i] = nextDouble();\n			return array;\n		}\n\n		public static int[] shuffle(int[] a) {\n			int n = a.length;\n			Random rand = new Random();\n			for (int i = 0; i < n; i++) {\n				int tmpIdx = rand.nextInt(n);\n				int tmp = a[i];\n				a[i] = a[tmpIdx];\n				a[tmpIdx] = tmp;\n			}\n			return a;\n		}\n\n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n\n		public void waitForInput() throws InterruptedException {\n			Thread.sleep(3000);\n		}\n	}\n}\n","dp,greedy,sortings"
"import java.io.BufferedOutputStream;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.InputMismatchException;\nimport java.util.Objects;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	static class TaskAdapter implements Runnable {\n		@Override\n		public void run() {\n			long startTime = System.currentTimeMillis();\n			InputStream inputStream = System.in;\n			OutputStream outputStream = System.out;\n			FastReader in = new FastReader(inputStream);\n			Output out = new Output(outputStream);\n			EServalAndSnake solver = new EServalAndSnake();\n			solver.solve(1, in, out);\n			out.close();\n			System.err.println(System.currentTimeMillis()-startTime+""ms"");\n		}\n\n	}\n\n	public static void main(String[] args) throws Exception {\n		Thread thread = new Thread(null, new TaskAdapter(), """", 1<<28);\n		thread.start();\n		thread.join();\n	}\n\n	static class EServalAndSnake {\n		int n;\n\n		public EServalAndSnake() {\n		}\n\n		public Pair<Integer, Integer> search(Function<Integer, Boolean> f) {\n			int a = -1, b = -1;\n			for(int i = 1; i<=n; i++) {\n				if(f.apply(i)) {\n					if(a==-1) {\n						a = i;\n					}else {\n						b = i;\n					}\n				}\n			}\n			return new Pair<>(a, b);\n		}\n\n		public int bsearch(BiFunction<Integer, Integer, Boolean> f) {\n			int l = 1, r = n;\n			while(l<r) {\n				int mid = l+r >> 1;\n				if(f.apply(l, mid)) {\n					r = mid;\n				}else {\n					l = mid+1;\n				}\n			}\n			return l;\n		}\n\n		public void solve(int kase, InputReader in, Output pw) {\n			n = in.nextInt();\n			var x = search(i -> {\n				pw.println(""?"", i, 1, i, n);\n				pw.flush();\n				return (in.nextInt()&1)==1;\n			});\n			if(x.a!=-1) {\n				pw.println(""!"", x.a,\n						bsearch((a, b) -> {\n							pw.println(""?"", x.a, a, x.a, b);\n							pw.flush();\n							return (in.nextInt()&1)==1;\n						}),\n						x.b,\n						bsearch((a, b) -> {\n							pw.println(""?"", x.b, a, x.b, b);\n							pw.flush();\n							return (in.nextInt()&1)==1;\n						}));\n				return;\n			}\n			var y = search(i -> {\n				pw.println(""?"", 1, i, n, i);\n				pw.flush();\n				return (in.nextInt()&1)==1;\n			});\n			int xx = bsearch((a, b) -> {\n				pw.println(""?"", a, y.a, b, y.a);\n				pw.flush();\n				return (in.nextInt()&1)==1;\n			});\n			pw.println(""!"", xx, y.a, xx, y.b);\n			pw.flush();\n		}\n\n	}\n\n	static class Pair<T1, T2> implements Comparable<Pair<T1, T2>> {\n		public T1 a;\n		public T2 b;\n\n		public Pair(Pair<T1, T2> p) {\n			this(p.a, p.b);\n		}\n\n		public Pair(T1 a, T2 b) {\n			this.a = a;\n			this.b = b;\n		}\n\n		public String toString() {\n			return a+"" ""+b;\n		}\n\n		public int hashCode() {\n			return Objects.hash(a, b);\n		}\n\n		public boolean equals(Object o) {\n			if(o instanceof Pair) {\n				Pair p = (Pair) o;\n				return a.equals(p.a)&&b.equals(p.b);\n			}\n			return false;\n		}\n\n		public int compareTo(Pair<T1, T2> p) {\n			int cmp = ((Comparable<T1>) a).compareTo(p.a);\n			if(cmp==0) {\n				return ((Comparable<T2>) b).compareTo(p.b);\n			}\n			return cmp;\n		}\n\n	}\n\n	static class Output implements Closeable, Flushable {\n		public StringBuilder sb;\n		public OutputStream os;\n		public int BUFFER_SIZE;\n		public String lineSeparator;\n\n		public Output(OutputStream os) {\n			this(os, 1<<16);\n		}\n\n		public Output(OutputStream os, int bs) {\n			BUFFER_SIZE = bs;\n			sb = new StringBuilder(BUFFER_SIZE);\n			this.os = new BufferedOutputStream(os, 1<<17);\n			lineSeparator = System.lineSeparator();\n		}\n\n		public void print(String s) {\n			sb.append(s);\n			if(sb.length()>BUFFER_SIZE >> 1) {\n				flushToBuffer();\n			}\n		}\n\n		public void println(Object... o) {\n			for(int i = 0; i<o.length; i++) {\n				if(i!=0) {\n					print("" "");\n				}\n				print(String.valueOf(o[i]));\n			}\n			println();\n			if(sb.length()>BUFFER_SIZE >> 1) {\n				flushToBuffer();\n			}\n		}\n\n		public void println() {\n			sb.append(lineSeparator);\n		}\n\n		private void flushToBuffer() {\n			try {\n				os.write(sb.toString().getBytes());\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n			sb = new StringBuilder(BUFFER_SIZE);\n		}\n\n		public void flush() {\n			try {\n				flushToBuffer();\n				os.flush();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n		public void close() {\n			flush();\n			try {\n				os.close();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n	}\n\n	static class FastReader implements InputReader {\n		final private int BUFFER_SIZE = 1<<16;\n		private DataInputStream din;\n		private byte[] buffer;\n		private int bufferPointer;\n		private int bytesRead;\n\n		public FastReader(InputStream is) {\n			din = new DataInputStream(is);\n			buffer = new byte[BUFFER_SIZE];\n			bufferPointer = bytesRead = 0;\n		}\n\n		public int nextInt() {\n			int ret = 0;\n			byte c = skipToDigit();\n			boolean neg = (c=='-');\n			if(neg) {\n				c = read();\n			}\n			do {\n				ret = ret*10+c-'0';\n			} while((c = read())>='0'&&c<='9');\n			if(neg) {\n				return -ret;\n			}\n			return ret;\n		}\n\n		private boolean isDigit(byte b) {\n			return b>='0'&&b<='9';\n		}\n\n		private byte skipToDigit() {\n			byte ret;\n			while(!isDigit(ret = read())&&ret!='-') ;\n			return ret;\n		}\n\n		private void fillBuffer() {\n			try {\n				bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n			}catch(IOException e) {\n				e.printStackTrace();\n				throw new InputMismatchException();\n			}\n			if(bytesRead==-1) {\n				buffer[0] = -1;\n			}\n		}\n\n		private byte read() {\n			if(bytesRead==-1) {\n				throw new InputMismatchException();\n			}else if(bufferPointer==bytesRead) {\n				fillBuffer();\n			}\n			return buffer[bufferPointer++];\n		}\n\n	}\n\n	static interface InputReader {\n		int nextInt();\n\n	}\n}\n\n","binary search,brute force,interactive"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1153E {\n	static Scanner sc = new Scanner(System.in);\n	static boolean query(int x1, int x2, int y1, int y2) {\n		System.out.println(""? "" + x1 + "" "" + y1 + "" "" + x2 + "" "" + y2);\n		System.out.flush();\n		return sc.nextInt() % 2 == 1;\n	}\n	static int isearch(int upper, int j1, int j2) {\n		int lower = 0;\n		while (upper - lower > 1) {\n			int i = (lower + upper) / 2;\n			if (query(1, i, j1, j2))\n				upper = i;\n			else\n				lower = i;\n		}\n		return upper;\n	}\n	static int jsearch(int upper, int i1, int i2) {\n		int lower = 0;\n		while (upper - lower > 1) {\n			int j = (lower + upper) / 2;\n			if (query(i1, i2, 1, j))\n				upper = j;\n			else\n				lower = j;\n		}\n		return upper;\n	}\n	public static void main(String[] args) {\n		int n = sc.nextInt();\n		int ihead, jhead, itail, jtail, lower, upper;\n		ihead = jhead = itail = jtail = -1;\n		boolean same_j = true;\n		for (int j = n - 1; j >= 1; j--)\n			if (query(1, n, 1, j)) {\n				same_j = false;\n				jtail = j + 1;\n				break;\n			}\n		if (same_j) {\n			for (int i = n - 1; i >= 1; i--)\n				if (query(1, i, 1, n)) {\n					itail = i + 1;\n					break;\n				}\n			ihead = isearch(itail - 1, 1, n);\n			jhead = jtail = jsearch(n, 1, ihead);\n		} else {\n			jhead = jsearch(jtail - 1, 1, n);\n			ihead = isearch(n, 1, jhead);\n			itail = isearch(n, jtail, n);\n		}\n		System.out.println(""! "" + ihead + "" "" + jhead + "" "" + itail + "" "" + jtail);\n		System.out.flush();\n	}\n}\n","binary search,brute force,interactive"
"//package round551;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class E {\n	Scanner in;\n	PrintWriter out;\n	String INPUT = """";\n	\n	int q(int x1, int y1, int x2, int y2)\n	{\n		out.println(""? "" + x1 + "" "" + y1 + "" "" + x2 + "" "" + y2);\n		out.flush();\n		return ni()&1;\n	}\n	\n	void solve()\n	{\n		int n = ni();\n		int[] rs = new int[n+1];\n		int x = 0;\n		for(int i = 1;i < n;i++){\n			rs[i] = q(i, 1, i, n);\n			x ^= rs[i];\n		}\n		rs[n] = x;\n		\n		List<int[]> rets = new ArrayList<>();\n		for(int i = 1;i <= n;i++){\n			if(rs[i] == 1){\n				int l = 1, r = n+1;\n				while(r-l > 1){\n					int h = l+r>>1;\n					if(q(i, l, i, h-1) == 1){\n						r = h;\n					}else{\n						l = h;\n					}\n				}\n				rets.add(new int[]{i, l});\n			}\n		}\n		if(rets.size() == 0){\n			for(int i = 1;i < n;i++){\n				rs[i] = q(1, i, n, i);\n				x ^= rs[i];\n			}\n			rs[n] = x;\n			for(int i = 1;i <= n;i++){\n				if(rs[i] == 1){\n					int l = 1, r = n+1;\n					while(r-l > 1){\n						int h = l+r>>1;\n						if(q(l, i, h-1, i) == 1){\n							r = h;\n						}else{\n							l = h;\n						}\n					}\n					rets.add(new int[]{l, i});\n				}\n			}\n		}\n		\n		out.println(""! "" + \n				rets.get(0)[0] + "" "" + \n				rets.get(0)[1] + "" "" + \n				rets.get(1)[0] + "" "" + \n				rets.get(1)[1]);\n		out.flush();\n	}\n	\n	void run() throws Exception\n	{\n		in = oj ? new Scanner(System.in) : new Scanner(INPUT);\n		out = new PrintWriter(System.out);\n\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception\n	{\n		new E().run();\n	}\n	\n	int ni() { return Integer.parseInt(in.next()); }\n	long nl() { return Long.parseLong(in.next()); }\n	double nd() { return Double.parseDouble(in.next()); }\n	boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","binary search,brute force,interactive"
"import java.util.Scanner;\n\npublic class SnakeTask {\n\n    private static Scanner scanner = new Scanner(System.in);\n\n    private static int query(int x1, int y1, int x2, int y2) {\n        System.out.printf(""? %d %d %d %d\n"", x1, y1, x2, y2);\n        int ans = scanner.nextInt();\n        if (ans == -1) System.exit(0);\n        return ans;\n    }\n\n    private static void ans(int x1, int y1, int x2, int y2) {\n        System.out.printf(""! %d %d %d %d\n"", x1, y1, x2, y2);\n    }\n\n    public static void main(String[] args) {\n        int n = scanner.nextInt();\n\n        boolean flip = false;\n        int p1 = 0, p2 = 0;\n        for (int i = 1; i < n; i++) {\n            int ans = query(i, 1, i, n);\n            if ((ans & 1) != 0) {\n                if (p1 != 0) p2 = i; else p1 = i;\n            }\n        }\n\n\n        if (p2 == 0 && p1 == 0) {\n            for (int i = 1; i < n; i++) {\n                if ((query(1, i, n, i) & 1) != 0) {\n                    if (p1 != 0) p2 = i; else p1 = i;\n                }\n            }\n            flip = true;\n        }\n\n        if (p2 == 0) p2 = n;\n\n        //System.out.printf(""p1: %d, p2: %d, flip %b\n"", p1, p2, flip);\n\n        int l = 1, r = n;\n        while(l < r) {\n            int m =(l + r)/2;\n            int ans = !flip ? query(p1, 1, p1, m) : query(1, p1, m, p1);\n            if ((ans & 1) != 0)\n                r = m;\n            else\n                l = m +1;\n        }\n        int q1 = l;\n\n        l = 1; r = n;\n        while(l < r) {\n            int m =(l + r)/2;\n            int ans = !flip ? query(p2, 1, p2, m) : query(1, p2, m, p2);\n            if ((ans & 1) != 0)\n                r = m;\n            else\n                l = m +1;\n        }\n        int q2 = l;\n\n        //System.out.printf(""q1: %d, q2: %d\n"", q1, q2);\n\n        if (flip) {\n            ans(q1, p1, q2, p2);\n        } else {\n            ans(p1, q1, p2, q2);\n        }\n    }\n}","binary search,brute force,interactive"
import java.util.*;\npublic class codeforces{\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        \nint n=sc.nextInt();\nint t=sc.nextInt();\nint max=Integer.MAX_VALUE;\nint index=0;\nfor(int i=1;i<=n;i++){\n    int s=sc.nextInt();\n    int d=sc.nextInt();\n    while(s<t){\n        s+=d;\n    }\n    if(max>s){\nmax=s;\nindex=i;\n    }\n}\nSystem.out.println(index);        \n    }\n},"brute force,math"
import java.util.Scanner;\n\npublic class ServalAndBus1153A {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int n = s.nextInt();\n        int t = s.nextInt();\n        int ans = Integer.MAX_VALUE;\n        int num = 0;\n        for(int i=0; i<n; i++){\n            int a = s.nextInt();\n            int w = s.nextInt();\n            while (a < t){\n                a += w;\n            }\n            if(a < ans){\n                ans = a;\n                num = i+1;\n            }\n        }\n        System.out.println(num);\n    }\n}\n,"brute force,math"
import java.util.*;\n\npublic class Main{\n	public static void main(String args[]){\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int t = sc.nextInt();\n		int a[] = new int[n];\n		int b[] = new int[n];\n		for(int i=0;i<n;i++){\n			a[i] = sc.nextInt();\n			b[i] = sc.nextInt();\n			if(a[i]<t){\n				while(a[i]<t){\n					a[i] += b[i];\n				}\n			}\n		}\n        int min = Integer.MAX_VALUE;\n		int temp = -1;\n		for(int i=0;i<n;i++){\n			if(a[i]-t<min){\n				min = a[i]-t;\n				{\n				  temp =i+1;\n				}\n			}\n		}\n		System.out.println(temp);\n\n\n	}\n}\n,"brute force,math"
"import java.util.*;\n\n\npublic class ServalBus{\n	public static void main(String[] args){\n	Scanner sc = new Scanner(System.in);\n	String[] s = sc.nextLine().split("" "");\n	long n = Long.parseLong(s[0]);\n	long t = Long.parseLong(s[1]);\n	long min = Long.MAX_VALUE;\n	int ans =0;\n	int i =1;\n	while(n-->0){\n		s = sc.nextLine().split("" "");\n		long a = Long.parseLong(s[0]);\n	    long b = Long.parseLong(s[1]);\n		long x = (t-a)/b + ((t-a)%b != 0?1:0);\n		if(t <= a) {\n            if(min > a){\n                min = a;  ans = i;\n            }\n        }else{\n\n		if(min>a+(b*x)){\n		  min = a+(b*x);\n		  ans = i;\n		}\n		}\n		i++;\n	}\n	System.out.println(ans);\n	}\n}","brute force,math"
"import java.util.*;\nimport java.io.*;\n\npublic class F553 {\n    public static void main(String[] args) throws Exception {\n        MyScanner sc = new MyScanner();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int n = sc.nextInt();\n        long k = sc.nextLong();\n        int [] arr = new int[n];\n        int a = 0;\n        for (int i = 0; i < n; i++) {\n            arr[i] = sc.nextInt();\n            if (arr[i] == 0) a++;\n        }\n        int b = n - a;\n        initFac(104);\n        dimension = a + 1;\n        memo = new long[maxPow][dimension][dimension];\n        long [][] matrix = new long[dimension][dimension];\n        for (int i = 0; i < dimension; i++) {\n            // dp[i] = ...\n            long choose = (n * (n - 1)) / 2;\n            if (i > 0)\n                matrix[i][i - 1] = ((i * (b - a + i)) * inv(choose)) % mod;\n            if (i < a)\n                matrix[i][i + 1] = ((a - i) * (a - i) * inv(choose)) % mod;\n            long num = choose - (i * (b - a + i) + (a - i) * (a - i));\n            matrix[i][i] = (num * inv(choose)) % mod;\n        }\n        powers(matrix);\n        int start = 0;\n        for (int i = 0; i < a; i++) {\n            if (arr[i] == 0) start++;\n        }\n        long [][] res = exp(matrix, k);\n        long [] vector = new long[dimension];\n        vector[a] = 1;\n        vector = transform(vector, res);\n        out.println(vector[start]);\n        out.close();\n    }\n\n    static long mod = (long) 1e9 + 7; static long [][][] memo; static int maxPow = 30; static int dimension;\n\n    static long [][] multiply(long [][] a, long [][] b) throws Exception {\n        if (a[0].length != b.length) {\n            throw new Exception(""Matrices are not compatible."");\n        }\n        long [][] ret = new long[a.length][b[0].length];\n        for (int i = 0; i < a.length; i++) {\n            for (int j = 0; j < b[0].length; j++) {\n                long product = 0;\n                for (int k = 0; k < a.length; k++) {\n                    product = (product + a[i][k] * b[k][j]) % mod;\n                }\n                ret[i][j] = product;\n            }\n        }\n        return ret;\n    }\n\n    static long[][] exp(long [][] a, long pow) throws Exception {\n        long [][] ret = getIdentity(dimension);\n        for (int i = 0; i < maxPow; i++) {\n            if (((pow) & (1L << i)) >> i == 1) {\n                ret = multiply(ret, memo[i]);\n            }\n        }\n        return ret;\n    }\n\n    static void powers(long [][] a) throws Exception {\n        for (int i = 0; i < maxPow; i++) {\n            memo[i] = a;\n            a = square(a);\n        }\n    }\n\n    static long [][] square(long [][] a) throws Exception {\n        return multiply(a, a);\n    }\n\n    static long [][] getIdentity(int dimension) {\n        long [][] I = new long[dimension][dimension];\n        for (int i = 0; i < dimension; i++) {\n            I[i][i] = 1;\n        }\n        return I;\n    }\n\n    static long[] transform(long [] vector, long [][] matrix) throws Exception {\n        if (vector.length != matrix[0].length) {\n            throw new Exception(""Dimensions are not compatible."");\n        }\n        long [] res = new long[vector.length];\n        for (int i = 0; i < vector.length; i++) {\n            long sum = 0;\n            for (int j = 0; j < vector.length; j++) {\n                sum = (sum + matrix[i][j] * vector[j]) % mod;\n            }\n            res[i] = sum;\n        }\n        return res;\n    }\n\n\n    static void sort(int[] a) {\n        ArrayList<Integer> q = new ArrayList<>();\n        for (int i : a) q.add(i);\n        Collections.sort(q);\n        for (int i = 0; i < a.length; i++) a[i] = q.get(i);\n    }\n\n    static void sort(long[] a) {\n        ArrayList<Long> q = new ArrayList<>();\n        for (long i : a) q.add(i);\n        Collections.sort(q);\n        for (int i = 0; i < a.length; i++) a[i] = q.get(i);\n    }\n\n    static long[] fac;\n\n    static void initFac(long n) {\n        fac = new long[(int)n + 1];\n        fac[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fac[i] = (fac[i - 1]  * i) % mod;\n        }\n    }\n\n\n\n    static long nck(int n, int k) {\n        if (n < k)\n            return 0;\n        long den = inv((int) (fac[k] * fac[n - k] % mod));\n        return fac[n] * den % mod;\n    }\n\n    static long pow(long b, long e) {\n        long ans = 1;\n        while (e > 0) {\n            if (e % 2 == 1)\n                ans = ans * b % mod;\n            e >>= 1;\n            b = b * b % mod;\n        }\n        return ans;\n    }\n\n    static long inv(long x) {\n        return pow(x, mod - 2);\n    }\n\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n\n    }\n\n}","combinatorics,dp,matrices,probabilities"
"import java.io.*;\nimport java.util.*;\n\npublic class Codeforces1151F {\n\n	public static void main(String[] args) throws IOException {\n		int P = 1000000007;\n		\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int n = Integer.parseInt(st.nextToken());\n		int k = Integer.parseInt(st.nextToken());\n		st = new StringTokenizer(br.readLine());\n		int[] a = new int[n];\n		for (int i = 0; i < n; i++) {\n			a[i] = Integer.parseInt(st.nextToken());\n		}\n		\n		//count number of zeroes in array\n		int r = 0;\n		for (int i = 0; i < n; i++) {\n			r += (1-a[i]);\n		}\n		//count number of ones in first r things\n		int s = 0;\n		for (int i = 0; i < r; i++) {\n			s += a[i];\n		}\n		\n		if (r > (n/2)) {\n			r = n-r;\n		}\n		\n		int nC2Inv = (n*(n-1))/2;\n		nC2Inv = inverse(nC2Inv, P);\n		\n		//create matrix\n		int[][] matrix = new int[r+1][r+1];\n		for (int i = 0; i <= r; i++) {\n			matrix[i][i] = 1;\n			if (i > 0) {\n				matrix[i][i-1] = multiply(i*i, nC2Inv, P);\n				matrix[i][i] = (matrix[i][i] + P - matrix[i][i-1])%P;\n			}\n			if (i < r) {\n				matrix[i][i+1] = multiply(((r-i)*(n-r-i)), nC2Inv, P);\n				matrix[i][i] = (matrix[i][i] + P - matrix[i][i+1])%P;\n			}\n		}\n		\n		//matrix power k\n		int[][] ans = power(matrix, k, P);\n		System.out.println(ans[s][0]);\n	}\n	\n	public static int[][] power(int[][] a, int k, int N) {\n		if (k == 1) {\n			return a;\n		}\n		else {\n			int[][] prod = multiply(a, a, N);\n			int[][] ans = power(prod, k/2, N);\n			if (k%2 == 1) {\n				ans = multiply(ans, a, N);\n			}\n			return ans;\n		}\n		\n	}\n\n	public static int[][] multiply (int[][] a, int[][] b, int N) {\n		int n = a.length;\n		int m = a[0].length;\n		int p = b[0].length;\n		\n		int[][] ans = new int[n][p];\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < p; j++) {\n				for (int k = 0; k < m; k++) {\n					ans[i][j] = (ans[i][j] + multiply(a[i][k], b[k][j], N))%N;\n				}\n			}\n		}\n		\n		return ans;\n	}\n	\n	public static int multiply (int a, int b, int n) {\n		long ab = (long) a * (long) b;\n		return ((int) (ab%n));\n	}\n	\n	public static int inverse (int a, int n) {\n		int m = n;\n		int r1 = 1;\n		int r2 = 0;\n		int r3 = 0;\n		int r4 = 1;\n		while ((a > 0) && (n > 0)) {\n			if (n >= a) {\n				r3 -= r1*(n/a);\n				r4 -= r2*(n/a);\n				n = n%a;\n			}\n			else {\n				int tmp = a;\n				a = n;\n				n = tmp;\n				tmp = r1;\n				r1 = r3;\n				r3 = tmp;\n				tmp = r2;\n				r2 = r4;\n				r4 = tmp;\n			}\n		}\n		if (a == 0) {\n			if (r3 >= 0)\n				return (r3%m);\n			else\n				return (m+(r3%m));\n		}\n		else {\n			if (r1 >= 0)\n				return (r1%m);\n			else\n				return (m+(r1%m));\n		}\n\n	}\n\n}\n","combinatorics,dp,matrices,probabilities"
" //package Contest553;\n\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class mainF {\n    public static Scanner enter = new Scanner(System.in);\n    public static PrintWriter out = new PrintWriter(System.out);\n    public static void main(String[] args) {\n        long mod=(long)1e9+7;\n        int n=enter.nextInt();\n        long s=enter.nextLong();\n        int[] arr=new int[n];\n        int m=0;\n        long CON=n*(n-1)/2;\n        CON=bin_pow(CON,mod-2,mod);\n        for (int i = 0; i <n ; i++) {\n            arr[i]=enter.nextInt();\n            m+=arr[i];\n        }\n        int f_k=0;\n        for (int i = 0; i <n-m ; i++) {\n            f_k+=arr[i];\n        }\n        int k=n-m;\n        f_k=n-m-f_k;\n        /*if(m<n-m){//Если нулей больше чем единиц\n            k=m;\n            f_k=n-m-f_k;\n            m=n-m;\n        }*/\n        //f_k- кол-во нулей в первой части то есть это начальное состояние причём кол-во нулей меньше кол-ва единиц\n        long[][] CM=new long[k+1][k+1];\n        for (int i = Math.max(0,k-m); i <CM.length ; i++) {\n            CM[i][i]=(1-(long)(i*(m-k+i)+(k-i)*(k-i))*CON);\n            if(i<k) CM[i][i+1]=(long)(k-i)*(k-i)*CON;\n            if(i>0)CM[i][i-1]=(long)i*(m-k+i)*CON;\n        }\n        MATRIX_mod(CM,mod);\n        CM=bin_pow(CM,s,mod);\n        System.out.println((CM[f_k][k]+mod)%mod);\n\n\n\n    }\n    public static long bin_pow(long a,long b, long mod){//a^b %mod\n        long ans=1;\n        while(b!=0){\n            if((b&1)==1) ans*=a;\n            a*=a;\n            ans%=mod;\n            a%=mod;\n            b>>=1;\n        }\n        return ans;\n    }\n\n    public static long[][] bin_pow(long[][] a,long b, long mod){//a^b %mod\n        long[][] ans=new long[a.length][a.length];\n        for (int i = 0; i <ans.length ; i++) ans[i][i]=1;\n        while(b!=0){\n            if((b&1)==1) ans=MATRIX_mult(ans,a);\n            a=MATRIX_mult(a,a);\n            MATRIX_mod(ans,mod);\n            MATRIX_mod(a,mod);\n            b>>=1;\n        }\n        return ans;\n    }\n    public static long[][] MATRIX_mult(long[][] a, long[][] b) { //b не меняем a=a*b;\n        long[][] c=new long[a.length][a.length];\n        for (int i = 0; i <a.length ; i++) {\n            for (int j = 0; j <a.length ; j++) {\n                for (int k = 0; k <a.length ; k++) {\n                    c[i][j]+=a[i][k]*b[k][j];\n                    c[i][j]%=(long)(1e9+7);\n                }\n            }\n        }\n        return c;\n    }\n    public static void MATRIX_mod(long[][] a, long mod){\n        for (int i = 0; i <a.length ; i++) {\n            for (int j = 0; j <a.length ; j++) {\n                a[i][j]%=mod;\n            }\n        }\n    }\n}\n","combinatorics,dp,matrices,probabilities"
"import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static long MOD = 1000000007;\n\n    public static void main(String[] args) {\n        final Scanner scanner = new Scanner(System.in);\n        final int n = scanner.nextInt();\n        final int k = scanner.nextInt();\n\n        final ArrayList<Integer> values = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) {\n            values.add(scanner.nextInt());\n        }\n        \n        final int zeroCount = values.stream().filter(integer -> integer.equals(0)).mapToInt(i -> 1).sum();\n        final int oneCount = n - zeroCount;\n        final int size = Math.min(zeroCount, oneCount);\n\n        long[][] table = new long[size + 1][size + 1];\n\n        int diff = 0;\n        for (int i = 0; i < n; i++) {\n            if (values.get(i) == 0 && i >= zeroCount) {\n                diff++;\n            }\n        }\n\n\n        final int allPosible = (n * (n - 1)) / 2;\n        final long allPosibleInverse = binPow(allPosible, MOD - 2);\n        for (int i = 0; i < size + 1; i++) {\n            for (int j = 0; j < size + 1; j++) {\n\n                if (i - j == 1) {\n                    table[i][j] = i * i * allPosibleInverse;\n                }\n\n                if (i - j == 0) {\n                    table[i][j] = (allPosible - i * i - (zeroCount - i) * (oneCount - i)) * allPosibleInverse;\n                }\n\n                if (i - j == -1) {\n                    table[i][j] = (zeroCount - i) * (oneCount - i) * allPosibleInverse;\n                }\n                table[i][j] = table[i][j] % MOD;\n            }\n        }\n\n        table = binPow(table, k);\n\n//        for (long[] longs : table) {\n//            for (long value : longs) {\n//                System.out.printf(""%10d"", value);\n//            }\n//            System.out.println();\n//        }\n\n        System.out.println(table[diff][0]);\n    }\n\n    private static long binPow(long n, long count) {\n        if (count == 0) {\n            return 1L;\n        }\n\n        long temp = binPow(n, count / 2);\n        temp = (temp * temp) % MOD;\n        if (count % 2 != 0) {\n            temp = (temp * n) % MOD;\n        }\n\n        return temp % MOD;\n    }\n\n    private static long[][] binPow(long[][] table, long count) {\n        if (count == 0) {\n            final long[][] ans = new long[table.length][table.length];\n            for (int i = 0; i < table.length; i++) {\n                ans[i][i] = 1;\n            }\n            return ans;\n        }\n\n        long[][] temp = binPow(table, count / 2);\n        temp = (mul(temp, temp));\n        if (count % 2 != 0) {\n            temp = mul(temp, table);\n        }\n\n        return temp;\n    }\n\n    private static long[][] mul(long[][] a, long[][] b) {\n        final long[][] ans = new long[a.length][a.length];\n        for (int i = 0; i < a.length; i++) {\n            for (int j = 0; j < a.length; j++) {\n                for (int k = 0; k < a.length; k++) {\n                    ans[i][j] += (a[i][k] * b[k][j]) % MOD;\n                    ans[i][j] = ans[i][j] % MOD;\n                }\n            }\n        }\n        return ans;\n    }\n}","combinatorics,dp,matrices,probabilities"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.stream.IntStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.util.OptionalInt;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            EElectionPromises solver = new EElectionPromises();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class EElectionPromises {\n        IntegerVersionArray iva = new IntegerVersionArray((int) 1e6);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.ri();\n            int m = in.ri();\n            Node[] nodes = new Node[n];\n            for (int i = 0; i < n; i++) {\n                nodes[i] = new Node();\n                nodes[i].h = in.ri();\n            }\n            for (int i = 0; i < m; i++) {\n                Node a = nodes[in.ri() - 1];\n                Node b = nodes[in.ri() - 1];\n                a.adj.add(b);\n            }\n            int[] sg = new int[n];\n            for (int i = 0; i < n; i++) {\n                sg[sg(nodes[i])] ^= nodes[i].h;\n            }\n            int max = Arrays.stream(sg).max().orElse(-1);\n            if (max == 0) {\n                out.println(""LOSE"");\n                return;\n            }\n            out.println(""WIN"");\n            int maxIndex = 0;\n            for (int i = 0; i < n; i++) {\n                if (sg[i] > 0) {\n                    maxIndex = i;\n                }\n            }\n            Node end = null;\n            for (Node node : nodes) {\n                if (sg(node) == maxIndex && (node.h ^ sg[maxIndex]) < node.h) {\n                    end = node;\n                    break;\n                }\n            }\n            end.h ^= sg[maxIndex];\n            sg[maxIndex] = 0;\n            for (Node node : end.adj) {\n                node.h ^= sg[sg(node)];\n                sg[sg(node)] = 0;\n            }\n            for (Node node : nodes) {\n                out.append(node.h).append(' ');\n            }\n        }\n\n        public int sg(Node root) {\n            if (root.sg == -1) {\n                root.sg = 0;\n                for (Node node : root.adj) {\n                    sg(node);\n                }\n                iva.clear();\n                for (Node node : root.adj) {\n                    iva.set(sg(node), 1);\n                }\n                while (iva.get(root.sg) == 1) {\n                    root.sg++;\n                }\n            }\n            return root.sg;\n        }\n\n    }\n\n    static class IntegerVersionArray {\n        int[] data;\n        int[] version;\n        int now;\n        int[] def;\n\n        public IntegerVersionArray(int cap) {\n            this(cap, null);\n        }\n\n        public IntegerVersionArray(int cap, int[] def) {\n            data = new int[cap];\n            version = new int[cap];\n            now = 0;\n            this.def = def;\n        }\n\n        public void clear() {\n            now++;\n        }\n\n        public void visit(int i) {\n            if (version[i] < now) {\n                version[i] = now;\n                data[i] = def == null ? 0 : def[i];\n            }\n        }\n\n        public void set(int i, int v) {\n            version[i] = now;\n            data[i] = v;\n        }\n\n        public int get(int i) {\n            visit(i);\n            return data[i];\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < data.length; i++) {\n                if (version[i] < now) {\n                    continue;\n                }\n                builder.append(i).append(':').append(data[i]).append(',');\n            }\n            if (builder.length() > 0) {\n                builder.setLength(builder.length() - 1);\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static class Node {\n        List<Node> adj = new ArrayList<>();\n        int h;\n        int sg = -1;\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int ri() {\n            return readInt();\n        }\n\n        public int readInt() {\n            boolean rev = false;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                rev = next == '-';\n                next = read();\n            }\n\n            int val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 - next + '0';\n                next = read();\n            }\n\n            return rev ? val : -val;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 32 << 10;\n        private OutputStream writer;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n        private static Field stringBuilderValueField;\n        private char[] charBuf = new char[THRESHOLD * 2];\n        private byte[] byteBuf = new byte[THRESHOLD * 2];\n\n        static {\n            try {\n                stringBuilderValueField = StringBuilder.class.getSuperclass().getDeclaredField(""value"");\n                stringBuilderValueField.setAccessible(true);\n            } catch (Exception e) {\n                stringBuilderValueField = null;\n            }\n            stringBuilderValueField = null;\n        }\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n\n        public FastOutput(OutputStream writer) {\n            this.writer = writer;\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(String c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput println(String c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            return append('\n');\n        }\n\n        public FastOutput flush() {\n            try {\n                if (stringBuilderValueField != null) {\n                    try {\n                        byte[] value = (byte[]) stringBuilderValueField.get(cache);\n                        writer.write(value, 0, cache.length());\n                    } catch (Exception e) {\n                        stringBuilderValueField = null;\n                    }\n                }\n                if (stringBuilderValueField == null) {\n                    int n = cache.length();\n                    if (n > byteBuf.length) {\n                        //slow\n                        writer.write(cache.toString().getBytes(StandardCharsets.UTF_8));\n//                writer.append(cache);\n                    } else {\n                        cache.getChars(0, n, charBuf, 0);\n                        for (int i = 0; i < n; i++) {\n                            byteBuf[i] = (byte) charBuf[i];\n                        }\n                        writer.write(byteBuf, 0, n);\n                    }\n                }\n                writer.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                writer.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n}\n\n","games,graphs"
"import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n \nimport static java.lang.Math.*;\n \npublic class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n \n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),""Main"",1<<27).start();\n    } \n    void findCol(int i) {\n        HashSet<Integer> set = new HashSet<>();\n\n        for(int j : adj[i]) {\n            if(col[j] == -1)\n                findCol(j);\n\n            set.add(col[j]);\n        }\n\n        for(int j = 0; ; ++j) {\n            if(!set.contains(j)) {\n                col[i] = j;\n                break;\n            }\n        }\n    }\n    ArrayList<Integer> adj[];\n    int col[];\n    public void run() {\n        InputReader sc = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        int h[] = new int[n];\n        for(int i = 0; i < n; ++i)\n            h[i] = sc.nextInt();\n\n        adj = new ArrayList[n];\n        for(int i = 0; i < n; ++i)\n            adj[i] = new ArrayList<>();\n\n        for(int i = 0; i < m; ++i) {\n            int u = sc.nextInt() - 1;\n            int v = sc.nextInt() - 1;\n            adj[u].add(v);\n        }\n\n        col = new int[n];\n        Arrays.fill(col, -1);\n        for(int i = 0; i < n; ++i) {\n            if(col[i] == -1)\n                findCol(i);\n        }\n\n        int xor[] = new int[n];\n        for(int i = 0; i < n; ++i)\n            xor[col[i]] ^= h[i];\n\n        int curCol = -1;\n        for(int i = 0; i < n; ++i) {\n            if(xor[i] != 0)\n                curCol = i;\n        }\n\n        if(curCol == -1)\n            w.print(""LOSE"");\n        else {\n            w.println(""WIN"");\n\n            int ind = -1;\n            for(int i = 0; i < n; ++i) {\n                if(col[i] == curCol) {\n                    if((h[i] ^ xor[curCol]) < h[i])\n                        ind = i;\n                }\n            }\n\n            h[ind] ^= xor[col[ind]];\n            xor[col[ind]] = 0;\n\n            for(int j : adj[ind]) {\n                h[j] ^= xor[col[j]];\n                xor[col[j]] = 0;\n            }\n\n            for(int i : h)\n                w.print(i + "" "");\n        }\n\n        w.close();\n    }\n}","games,graphs"
"\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class CF1149E {\n    public static void main(String[] args) throws Exception {\n        boolean local = System.getProperty(""ONLINE_JUDGE"") == null;\n        boolean async = false;\n\n        Charset charset = Charset.forName(""ascii"");\n\n        FastIO io = local ? new FastIO(new FileInputStream(""D:\\DATABASE\\TESTCASE\\Code.in""), System.out, charset) : new FastIO(System.in, System.out, charset);\n        Task task = new Task(io, new Debug(local));\n\n        if (async) {\n            Thread t = new Thread(null, task, ""dalt"", 1 << 27);\n            t.setPriority(Thread.MAX_PRIORITY);\n            t.start();\n            t.join();\n        } else {\n            task.run();\n        }\n\n        if (local) {\n            io.cache.append(""\n\n--memory -- \n"" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + ""M"");\n        }\n\n        io.flush();\n    }\n\n    public static class Task implements Runnable {\n        final FastIO io;\n        final Debug debug;\n        int inf = (int) 1e8;\n        int mod = (int) 1e9 + 7;\n\n        public int mod(int val) {\n            val %= mod;\n            if (val < 0) {\n                val += mod;\n            }\n            return val;\n        }\n\n        public int mod(long val) {\n            val %= mod;\n            if (val < 0) {\n                val += mod;\n            }\n            return (int) val;\n        }\n\n        public Task(FastIO io, Debug debug) {\n            this.io = io;\n            this.debug = debug;\n        }\n\n        @Override\n        public void run() {\n            solve();\n        }\n\n        public void solve() {\n            int n = io.readInt();\n            int m = io.readInt();\n            Node[] nodes = new Node[n + 1];\n\n            for (int i = 1; i <= n; i++) {\n                nodes[i] = new Node();\n            }\n\n            for (int i = 1; i <= n; i++) {\n                nodes[i].tax = io.readInt();\n            }\n            for (int i = 0; i < m; i++) {\n                nodes[io.readInt()].next.add(nodes[io.readInt()]);\n            }\n\n            for (int i = 1; i <= n; i++) {\n                dfs(nodes[i]);\n            }\n\n            int[] xor = new int[n];\n            for (int i = 1; i <= n; i++) {\n                xor[nodes[i].mex] ^= nodes[i].tax;\n            }\n\n            boolean allZero = true;\n            int mex = n - 1;\n            for (int i = 0; i < n; i++) {\n                allZero = allZero && xor[i] == 0;\n                if (xor[i] != 0) {\n                    mex = i;\n                }\n            }\n\n            if (allZero) {\n                io.cache.append(""LOSE"");\n                return;\n            }\n\n\n            Node heldOn = null;\n            for (int i = 1; i <= n; i++) {\n                if (nodes[i].mex == mex && (nodes[i].tax ^ xor[mex]) < nodes[i].tax) {\n                    heldOn = nodes[i];\n                    break;\n                }\n            }\n\n            heldOn.tax = heldOn.tax ^ xor[mex];\n            xor[mex] = 0;\n            for (Node node : heldOn.next) {\n                if (xor[node.mex] == 0) {\n                    continue;\n                }\n                node.tax ^= xor[node.mex];\n                xor[node.mex] = 0;\n            }\n\n            io.cache.append(""WIN\n"");\n            for (int i = 1; i <= n; i++) {\n                io.cache.append(nodes[i].tax).append(' ');\n            }\n        }\n\n        public void dfs(Node root) {\n            if (root.visited) {\n                return;\n            }\n            root.visited = true;\n            for (Node node : root.next) {\n                dfs(node);\n            }\n            root.next.sort((a, b) -> a.mex - b.mex);\n            root.mex = 0;\n            for (Node node : root.next) {\n                if (node.mex > root.mex) {\n                    break;\n                }\n                if (node.mex == root.mex) {\n                    root.mex++;\n                }\n            }\n        }\n\n    }\n\n    public static class FastIO {\n        public final StringBuilder cache = new StringBuilder();\n        private final InputStream is;\n        private final OutputStream os;\n        private final Charset charset;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 8);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastIO(InputStream is, OutputStream os, Charset charset) {\n            this.is = is;\n            this.os = os;\n            this.charset = charset;\n        }\n\n        public FastIO(InputStream is, OutputStream os) {\n            this(is, os, Charset.forName(""ascii""));\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public double readDouble() {\n            boolean sign = true;\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+';\n                next = read();\n            }\n\n            long val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 + next - '0';\n                next = read();\n            }\n            if (next != '.') {\n                return sign ? val : -val;\n            }\n            next = read();\n            long radix = 1;\n            long point = 0;\n            while (next >= '0' && next <= '9') {\n                point = point * 10 + next - '0';\n                radix = radix * 10;\n                next = read();\n            }\n            double result = val + (double) point / radix;\n            return sign ? result : -result;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n        public int readLine(char[] data, int offset) {\n            int originalOffset = offset;\n            while (next != -1 && next != '\n') {\n                data[offset++] = (char) next;\n                next = read();\n            }\n            return offset - originalOffset;\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public int readString(byte[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (byte) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n        public void flush() {\n            try {\n                os.write(cache.toString().getBytes(charset));\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public boolean hasMore() {\n            skipBlank();\n            return next != -1;\n        }\n    }\n\n    public static class Debug {\n        private boolean allowDebug;\n\n        public Debug(boolean allowDebug) {\n            this.allowDebug = allowDebug;\n        }\n\n        public void assertTrue(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (!flag) {\n                fail();\n            }\n        }\n\n        public void fail() {\n            throw new RuntimeException();\n        }\n\n        public void assertFalse(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (flag) {\n                fail();\n            }\n        }\n\n        private void outputName(String name) {\n            System.out.print(name + "" = "");\n        }\n\n        public void debug(String name, int x) {\n            if (!allowDebug) {\n                return;\n            }\n\n            outputName(name);\n            System.out.println("""" + x);\n        }\n\n        public void debug(String name, long x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println("""" + x);\n        }\n\n        public void debug(String name, double x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println("""" + x);\n        }\n\n        public void debug(String name, int[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, long[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, double[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, Object x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println("""" + x);\n        }\n\n        public void debug(String name, Object... x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.deepToString(x));\n        }\n    }\n\n    public static class Node {\n        boolean visited;\n        int mex;\n        int tax;\n        List<Node> next = new ArrayList<>();\n    }\n}\n","games,graphs"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1148F extends PrintWriter {\n	CF1148F() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1148F o = new CF1148F(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int[] aa = new int[n];\n		long[] mask = new long[n];\n		long sum = 0;\n		for (int i = 0; i < n; i++) {\n			sum += aa[i] = sc.nextInt();\n			mask[i] = sc.nextLong();\n		}\n		if (sum < 0)\n			for (int i = 0; i < n; i++)\n				aa[i] = -aa[i];\n		long ans = 0;\n		for (int k = 0; k < 62; k++) {\n			long b = 1L << k;\n			sum = 0;\n			for (int i = 0; i < n; i++)\n				if (mask[i] == b)\n					sum += aa[i];\n			boolean flip = sum > 0;\n			if (flip)\n				ans |= b;\n			for (int i = 0; i < n; i++)\n				if ((mask[i] & b) != 0) {\n					if (flip)\n						aa[i] = -aa[i];\n					mask[i] ^= b;\n				}\n		}\n		println(ans);\n	}\n}\n","bitmasks,constructive algorithms"
"import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class F {\n\n	static void solve() throws Exception {\n		int n = scanInt();\n		int val[] = new int[n];\n		long mask[] = new long[n];\n		long sum = 0;\n		for (int i = 0; i < n; i++) {\n			sum += val[i] = scanInt();\n			mask[i] = scanLong();\n		}\n		int sgn = Long.signum(sum);\n		long s = 0;\n		for (int bit = 0; bit < 62; bit++) {\n			long sum0 = 0, sum1 = 0;\n			for (int i = 0; i < n; i++) {\n				if (mask[i] >> bit == 0) {\n					sum0 += val[i];\n				} else if (mask[i] >> bit == 1) {\n					sum1 += val[i];\n				}\n			}\n			int sgn0 = Long.signum(sum0 + sum1), sgn1 = Long.signum(sum0 - sum1);\n			if (sgn1 * sgn < sgn0 * sgn) {\n				s |= 1L << bit;\n				for (int i = 0; i < n; i++) {\n					if ((mask[i] & (1L << bit)) != 0) {\n						val[i] = -val[i];\n					}\n				}\n			}\n		}\n		out.print(s);\n	}\n\n	static int scanInt() throws IOException {\n		return parseInt(scanString());\n	}\n\n	static long scanLong() throws IOException {\n		return parseLong(scanString());\n	}\n\n	static String scanString() throws IOException {\n		while (tok == null || !tok.hasMoreTokens()) {\n			tok = new StringTokenizer(in.readLine());\n		}\n		return tok.nextToken();\n	}\n\n	static BufferedReader in;\n	static PrintWriter out;\n	static StringTokenizer tok;\n\n	public static void main(String[] args) {\n		try {\n			in = new BufferedReader(new InputStreamReader(System.in));\n			out = new PrintWriter(System.out);\n			solve();\n			in.close();\n			out.close();\n		} catch (Throwable e) {\n			e.printStackTrace();\n			exit(1);\n		}\n	}\n}","bitmasks,constructive algorithms"
"import java.io.*;\nimport java.util.*;\n\npublic class cF {\n	int M = 62;\n	Random rnd = new Random(566);\n	\n	void run() {\n		int n = in.nextInt();\n		int[] val = new int[n];\n		long[] mask = new long[n];\n		long sum = 0;\n		for (int i = 0; i < n; i++) {\n			val[i] = in.nextInt();\n			mask[i] = in.nextLong();\n			sum += val[i];\n		}\n		if (sum < 0) {\n			for (int i = 0; i < n; i++) {\n				val[i] *= -1;\n			}\n		}\n		long ans = 0;\n		for (int j = 0; j < M; j++) {\n			sum = 0;\n			for (int i = 0; i < n; i++) {\n				if ((mask[i] >> j) == 1) {\n					sum += val[i];\n				}\n			}\n			if (sum <= 0) {\n				continue;\n			}\n			ans ^= (1L << j);\n			for (int i = 0; i < n; i++) {\n				if (((mask[i] >> j) & 1) != 0) {\n					val[i] *= -1;\n				}\n			}\n		}\n		out.println(ans);\n	}\n\n	static MyScanner in;\n	static PrintWriter out;\n\n	public static void main(String[] args) throws IOException {\n		boolean stdStreams = true;\n		String fileName = cF.class.getSimpleName().replaceFirst(""_.*"", """").toLowerCase();\n		String inputFileName = fileName + "".in"";\n		String outputFileName = fileName + "".out"";\n		\n		Locale.setDefault(Locale.US);\n		BufferedReader br;\n		if (stdStreams) {\n			br = new BufferedReader(new InputStreamReader(System.in));\n			out = new PrintWriter(System.out);\n		} else {\n			br = new BufferedReader(new FileReader(inputFileName));\n			out = new PrintWriter(outputFileName);\n		}\n		in = new MyScanner(br);\n		int tests = 1;//in.nextInt();\n		for (int test = 0; test < tests; test++) {\n			//out.print(""Case #"" + (test + 1) + "": "");\n			new cF().run();\n		}\n		br.close();\n		out.close();\n	}\n	\n	static class MyScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		MyScanner(BufferedReader br) {\n			this.br = br;\n		}\n		\n		void findToken() {\n			while (st == null || !st.hasMoreTokens()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n		}\n		\n		String next() {\n			findToken();\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n		\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n	}\n}\n","bitmasks,constructive algorithms"
"import java.io.*;\nimport java.util.*;\n\npublic class cF {\n	int M = 62;\n	Random rnd = new Random(566);\n	\n	void run() {\n		int n = in.nextInt();\n		int[] val = new int[n];\n		long[] mask = new long[n];\n		long sum = 0;\n		for (int i = 0; i < n; i++) {\n			val[i] = in.nextInt();\n			mask[i] = in.nextLong();\n			sum += val[i];\n		}\n		if (sum < 0) {\n			for (int i = 0; i < n; i++) {\n				val[i] *= -1;\n			}\n			sum *= -1;\n		}\n		long ans = 0;\n		for (int j = 0; j < M; j++) {\n			long curSum = 0;\n			for (int i = 0; i < n; i++) {\n				if ((mask[i] >> j) == 1) {\n					curSum += val[i];\n				}\n			}\n			if (curSum <= 0) {\n				continue;\n			}\n			ans ^= (1L << j);\n			for (int i = 0; i < n; i++) {\n				if (((mask[i] >> j) & 1) != 0) {\n					val[i] *= -1;\n				}\n			}\n		}\n		out.println(ans);\n	}\n\n	static MyScanner in;\n	static PrintWriter out;\n\n	public static void main(String[] args) throws IOException {\n		boolean stdStreams = true;\n		String fileName = cF.class.getSimpleName().replaceFirst(""_.*"", """").toLowerCase();\n		String inputFileName = fileName + "".in"";\n		String outputFileName = fileName + "".out"";\n		\n		Locale.setDefault(Locale.US);\n		BufferedReader br;\n		if (stdStreams) {\n			br = new BufferedReader(new InputStreamReader(System.in));\n			out = new PrintWriter(System.out);\n		} else {\n			br = new BufferedReader(new FileReader(inputFileName));\n			out = new PrintWriter(outputFileName);\n		}\n		in = new MyScanner(br);\n		int tests = 1;//in.nextInt();\n		for (int test = 0; test < tests; test++) {\n			//out.print(""Case #"" + (test + 1) + "": "");\n			new cF().run();\n		}\n		br.close();\n		out.close();\n	}\n	\n	static class MyScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		MyScanner(BufferedReader br) {\n			this.br = br;\n		}\n		\n		void findToken() {\n			while (st == null || !st.hasMoreTokens()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n		}\n		\n		String next() {\n			findToken();\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n		\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n	}\n}\n","bitmasks,constructive algorithms"
"import java.util.Scanner;\npublic class Solution{\n    public static void main(String args[]){\n        Scanner in=new Scanner(System.in);\n        int n=in.nextInt();\n        \n        int arr[]=new int[n+1];\n        for(int i=0;i<n;i++)\n            arr[i]=in.nextInt();\n        \n        int inc=-1,desc=Integer.MAX_VALUE;\n        for(int i=0;i<n;i++){\n            if(inc<arr[i] && (arr[i]<arr[i+1] || arr[i]>=desc)){\n                inc=arr[i];\n                arr[i]=0;\n            }\n            else if(arr[i]<desc){\n                desc=arr[i];\n                arr[i]=1;\n            }\n            else{\n                System.out.println(""NO"");\n                return;\n            }\n        }\n        \n        System.out.println(""YES"");\n        for(int i=0;i<n;i++)\n            System.out.print(arr[i]+"" "");\n        System.out.println();\n    }\n}","dp,greedy"
"import java.util.*;\npublic class TwoMergedSequence\n{\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] arr = new int[n+1];\n        for(int i = 0; i<n;i++)\n        arr[i] = sc.nextInt();\n        int inc = -1;\n        int des = Integer.MAX_VALUE;\n        for(int i = 0; i<n;i++)\n        {\n            if(inc<arr[i] && (arr[i]<arr[i+1] || arr[i]>=des))\n            {\n                inc = arr[i];\n                arr[i] = 0;\n            }\n            else if (des>arr[i])\n            {\n                des = arr[i];\n                arr[i] = 1;\n            }\n            else\n            {\n                System.out.println(""NO"");\n                return;\n            }\n        }\n        System.out.println(""YES"");\n        for(int i = 0;i<n;i++)\n        {\n            System.out.print(arr[i]+"" "");\n        }\n    }\n}","dp,greedy"
"\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n	public static int max(int x,int y) {\n		return x > y ? x : y;\n	}\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		/**\n		 * dp(i,0) = true \n		 * I:dp(i-1,1) = true && a(i-1,1) < x(i)\n		 * II:dp(i-1,0) = true && x(i-1) < x(i)\n		 * dp(i,1) = true \n		 * I:dp(i-1,1) = true && x(i-1) > x(i)\n		 * II:dp(i-1,0) = true && a(i-1,0) > x(i)\n		 * */\n		int n;\n		Scanner scanner = new Scanner(System.in);\n		n = scanner.nextInt();\n		int x[] = new int[n+5],a[][] = new int[n+5][2];\n		boolean dp[][] = new boolean[n+5][2],pre[][] = new boolean[n+5][2],flag = true;\n		x[0] = 200005;x[n+1] = -1;\n		for(int i = 1;i <= n;++i) {\n			x[i] = scanner.nextInt();\n			if(i == 1) {\n				dp[i][0] = dp[i][1] = true;\n				a[i][0] = 0;\n				a[i][1] = n+1;\n				continue;\n			}\n			if(dp[i-1][1] && x[a[i-1][1]] < x[i]) {\n				dp[i][0] = true;\n				pre[i][0] = true;\n				a[i][0] = i-1;\n			}\n			if(dp[i-1][0] && x[i-1] < x[i]) {\n				dp[i][0] = true;\n				pre[i][0] = false;\n				a[i][0] = a[i-1][0];\n			}\n			if(dp[i-1][0] && x[a[i-1][0]] > x[i]) {\n				dp[i][1] = true;\n				pre[i][1] = false;\n				a[i][1] = i-1;\n			}\n			if(dp[i-1][1] && x[i-1] > x[i]) {\n				dp[i][1] = true;\n				pre[i][1] = true;\n				a[i][1] = a[i-1][1];\n			}\n			if(!dp[i][0] && !dp[i][1]) flag = false;\n		}\n		if(flag) {\n			System.out.println(""YES"");\n			int j = n,k = 0;\n			if(!dp[n][0]) {\n				j = n;\n				k = 1;\n			}\n			Stack<Integer> st = new Stack<Integer>();\n			do {\n				st.push(k);\n				boolean t = pre[j][k];\n				if(!t) {\n					k = 0;\n				}else {\n					k = 1;\n				}\n				--j;\n			}while(j >= 1);\n			while(!st.empty()) {\n				System.out.print(st.pop()+"" "");\n			}\n		}else {\n			System.out.println(""NO"");\n		}\n	}\n\n}\n","dp,greedy"
"import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    PP solver = new PP();\n    solver.run(1, in, out);\n    out.close();\n  }\n\n  static class PP {\n    public void run(int testNumber, InputReader in, PrintWriter out) {\n      int n = in.nextInt();\n      int[] a = new int[n];\n      for (int i = 0; i < n; i++) {\n        a[i] = in.nextInt();\n      }\n      StringBuilder ans = new StringBuilder();\n      int l = Integer.MIN_VALUE, h = Integer.MAX_VALUE;\n      for (int i = 0; i < n; i++) {\n        if (a[i] > l && a[i] < h) {\n          if (i < n - 1 && a[i + 1] > a[i]) {\n            l = a[i];\n            ans.append('0');\n          } else {\n            h = a[i];\n            ans.append('1');\n          }\n        } else if (a[i] > l) {\n          l = a[i];\n          ans.append('0');\n        } else if (a[i] < h) {\n          h = a[i];\n          ans.append('1');\n        } else {\n          out.println(""NO"");\n          return;\n        }\n        ans.append(' ');\n      }\n      out.println(""YES"");\n      out.println(ans);\n    }\n  }\n\n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream), 32768);\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n  }\n}","dp,greedy"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1143D extends PrintWriter {\n	CF1143D() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1143D o = new CF1143D(); o.main(); o.flush();\n	}\n\n	long gcd(long a, long b) {\n		return b == 0 ? a : gcd(b, a % b);\n	}\n	long solve(int n, int k, int a, int b, int i) {\n		int c = b - a;\n		if (c <= 0)\n			c += k;\n		long l = c + (long) i * k;\n		long m = (long) n * k;\n		long d = gcd(m, l);\n		return m / d;\n	}\n	void main() {\n		int n = sc.nextInt();\n		int k = sc.nextInt();\n		int a = sc.nextInt();\n		int b = sc.nextInt();\n		long x = (long) n * k, y = 0;\n		for (int a_ : new int[] { a, k - a })\n			for (int b_ : new int[] { b, k - b })\n				for (int i = 0; i < n; i++) {\n					long z = solve(n, k, a_, b_, i);\n					x = Math.min(x, z);\n					y = Math.max(y, z);\n				}\n		println(x + "" "" + y);\n	}\n}\n","brute force,math"
"//package thebeatles;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class thebeatles {\n	\n	public static long gcd(long a, long b) {\n		if(b == 0) {\n			return a;\n		}\n		return gcd(b, a % b);\n	}\n	\n	public static void main(String[] args) throws IOException {\n		BufferedReader fin = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer(fin.readLine());\n		long n = Integer.parseInt(st.nextToken());\n		long k = Integer.parseInt(st.nextToken());\n		st = new StringTokenizer(fin.readLine());\n		int a = Integer.parseInt(st.nextToken());\n		int b = Integer.parseInt(st.nextToken());\n		long min = Long.MAX_VALUE;\n		long max = 0;\n		long totalDist = n * k;\n		for(int i = 0; i <= n; i++) {\n			long d1 = (long) i * k + b - a;\n			long d2 = (long) (i + 1) * k - b - a;\n			if(d1 > 0) {\n				long cur = totalDist / gcd(totalDist, d1);\n				min = Math.min(cur, min);\n				max = Math.max(cur, max);\n			}\n			if(d2 > 0) {\n				long cur = totalDist / gcd(totalDist, d2);\n				min = Math.min(cur, min);\n				max = Math.max(cur, max);\n			}\n		}\n		System.out.println(min + "" "" + max);\n	}\n}\n","brute force,math"
"import java.util.*;\nimport java.io.*;\n\npublic class _1142_A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        StringTokenizer line = new StringTokenizer(in.readLine());\n        int n = Integer.parseInt(line.nextToken());\n        int k = Integer.parseInt(line.nextToken());\n        line = new StringTokenizer(in.readLine());\n        int a = Integer.parseInt(line.nextToken());\n        int b = Integer.parseInt(line.nextToken());\n        long min = Long.MAX_VALUE;\n        long max = 0;\n        long total = (long)n * k;\n        for(int i = 0; i <= n; i++) {\n            long l1 = (long)i * k + b - a;\n            long l2 = (long)(i + 1) * k - b - a;\n            if(l1 > 0) {\n                long stops = stops(l1, total);\n                min = Math.min(min, stops);\n                max = Math.max(max, stops);\n            }\n            if(l2 > 0) {\n                long stops = stops(l2, total);\n                min = Math.min(min, stops);\n                max = Math.max(max, stops);\n            }\n        }\n        out.println(min + "" "" + max);\n        in.close();\n        out.close();\n    }\n    static long gcd(long a, long b) {\n        if(b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n    static long stops(long l, long total) {\n        return total / gcd(total, l);\n    }\n}\n","brute force,math"
"import java.io.*;\nimport java.util.*;\n\npublic class D{\n	static long n,k;\n	static long b;\n	static void solve(long start) {\n		for (long p: pos) {\n			long v1 = ansMin(start,p-b,true);\n			long v2 = ansMin(start,p+b,false);\n			//System.out.println(start + "" "" + (p-b) + "" "" + (p+b));\n			//System.out.println(start + "" "" + v1 + "" "" +v2 + "" "" + min + "" "" + max);\n			min = Long.min(min, v1);\n			max = Long.max(max, v2);\n		}\n	}\n	\n	static long ansMin(long p1, long p2,boolean solveMin) {\n		long tot = n*k;\n		long dist = Math.abs(p1-p2)%tot;\n		long comp = tot-dist;\n		if (dist == 0 || comp == 0) return 1;\n		long v1 = tot/gcd(tot,dist);\n		long v2 = tot/gcd(tot,comp);\n		if (solveMin) return Long.min(v1, v2);\n		return Long.max(v1, v2);\n	}\n	\n	static long gcd(long a, long b) {\n		if (a==0) return b;\n		return gcd(b%a,a);\n	}\n	static long min = Long.MAX_VALUE;\n	static long max = Long.MIN_VALUE;\n	static List<Long> pos = new ArrayList<Long>();\n	public static void main(String[] args) throws IOException {\n		// br = new BufferedReader(new FileReader("".in""));\n		// out = new PrintWriter(new FileWriter("".out""));\n		//new Thread(null, new (), ""peepee"", 1<<28).start();\n		n  =readLong();\n		k=readLong();\n		for (long i = 0; i < n; i++) pos.add(1L+i*k);\n		long a=readLong();\n		b=readLong();\n		solve(a+1);\n		solve(1L-a);\n		out.println(min +  ""  "" + max);\n		out.close();\n	}\n	\n	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n	static StringTokenizer st = new StringTokenizer("""");\n	static String read() throws IOException{return st.hasMoreTokens() ? st.nextToken():(st = new StringTokenizer(br.readLine())).nextToken();}\n	static int readInt() throws IOException{return Integer.parseInt(read());}\n	static long readLong() throws IOException{return Long.parseLong(read());}\n	static double readDouble() throws IOException{return Double.parseDouble(read());}\n	\n}","brute force,math"
"import java.util.*;\npublic class MaximalContinuousRest {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();List<Integer> a=new ArrayList<>();\n		for(int i=0;i<n;i++)a.add(sc.nextInt());\n		a.addAll(a);int cnt=0,c=0;\n		for(int i=0;i<2*n;i++) {\n			if(a.get(i)==1)c++;\n			else c=0;\n			cnt=Math.max(c, cnt);\n		}\n		System.out.println(cnt);\n\n	}\n\n}\n",implementation
import java.util.*;\npublic class test \n{\n	public static void main(String[] args) {\n		Scanner in=new Scanner(System.in);\n		int[] a=new int[in.nextInt()];\n		int max=0;\n		for(int i=0;i<a.length;i++)\n			a[i]=in.nextInt();\n		int x=0;\n		for(int j=0;j<2;j++)\n		{\n			for(int i:a)\n			{\n				if(i==1)\n					x++;\n				else\n				{\n					if(x>max)\n						max=x;\n					x=0;\n				}	\n			}\n		}\n		System.out.println(max);\n	}\n}\n	 		 	  	 	  		    	 	 					  	,implementation
"import java.util.Scanner;\npublic class rest {\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		int n = s.nextInt();\n		int arr[] = new int[n];\n		int i,max=0,count=0;\n		for(i=0;i<arr.length;i++)\n			arr[i]=s.nextInt();\n		for(i=0;i<arr.length*2+2;i++) {\n			if(arr[i%n]==1)\n				count++;\n			else {\n				if(count>max)\n					max=count;\n				count=0;\n			}\n		}\n		System.out.println(max);\n	}\n}",implementation
"import java.util.Scanner;\n\npublic class CR547B {\n	public static void main(String[] args) {\n		Scanner s=new Scanner(System.in);\n		\n		int n=s.nextInt();\n		\n		int [] a=new int[n];\n		\n		for(int i=0;i<n;i++) {\n			a[i]=s.nextInt();\n		}\n		int count=0,m=0;\n		\n		for(int i=0;i<2*n;i++) {\n			if(a[i%n]==1) {\n				count++;\n				if(count>m) {m=count;}\n			}\n			else {\n				count=0;\n			}\n		}\n		System.out.println(m);\n		\n	}\n\n}\n",implementation
"import java.util.*;\nimport static java.lang.Math.*;\n\npublic class SolutionC {\n	static void dfs(int i) {\n		vis[i] = 1;\n		cnt++;\n\n		for(int j : adj[i]) {\n			if(vis[j] == 0)\n				dfs(j);\n		}\n	}\n\n	static long fast_pow(long a, long b) {\n		if(b == 0)\n			return 1L;\n\n		long val = fast_pow(a, b / 2);\n\n		if(b % 2 == 0)\n			return val * val % mod;\n		else \n			return val * val % mod * a % mod;\n	}\n	static long mod = (long)1e9 + 7;\n\n	static ArrayList<Integer> adj[];\n	static int vis[];\n	static long cnt = 0;\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n\n		int n = sc.nextInt();\n		int k = sc.nextInt();\n\n		adj = new ArrayList[n];\n		for(int i = 0; i < n; ++i)\n			adj[i] = new ArrayList<>();\n\n		for(int i = 0; i < n - 1; ++i) {\n			int u = sc.nextInt() - 1;\n			int v = sc.nextInt() - 1;\n			int col = sc.nextInt();\n\n			if(col == 0) {\n				adj[u].add(v);\n				adj[v].add(u);\n			}\n		}\n\n		long ans = fast_pow(n, k);\n		long rem = 0;\n\n		vis = new int[n];\n		for(int i = 0; i < n; ++i) {\n			if(vis[i] == 0) {\n				cnt = 0;\n				dfs(i);\n				rem += fast_pow(cnt, k);\n			}\n		}\n\n		rem %= mod;\n		ans = (ans - rem + mod) % mod;\n\n		System.out.print(ans);\n	}\n}","dfs and similar,dsu,graphs,math,trees"
"import java.util.*;\n\n\npublic class aemrllijghaer {\n\n	static Scanner in = new Scanner(System.in);\n	static ArrayList<Integer>[] adj;\n	static int n;\n	static int k;\n	static int count;\n	static long ans;\n	static long rem;\n	static int[] vis;\n	static long mod = (long) (1e9+7);\n	\n	public static void main(String[] args) {\n		\n		int n = in.nextInt();\n		int k = in.nextInt();\n		\n		adj = new ArrayList[n];\n		\n		for(int i = 0; i < n; i++) {\n			adj[i] = new ArrayList<>();\n		}\n		\n		for(int i = 0; i < n-1; i++) {\n			\n			int u = in.nextInt()-1;\n			int v = in.nextInt()-1;\n			int x = in.nextInt();\n			\n			if(x == 0) {\n				adj[u].add(v);\n				adj[v].add(u);\n			}\n		}\n		\n		ans = (long) pow(n, k);\n		rem = 0;\n		\n		vis = new int[n];\n		\n		for(int i = 0; i < n; i++) {\n			if(vis[i] == 0) {\n				count = 0;\n				dfs(i);\n				rem += pow(count, k);\n			}\n		}\n		rem %= mod;\n		ans = (ans - rem + mod)%mod;\n		System.out.println(ans);\n		\n	}\n	\n	public static long pow(int a, int b) {\n		if(b == 0) return 1;\n		long val = pow(a,b/2);\n		if(b%2==0) return val * val % mod;\n		else return val * val % mod * a % mod;\n	}\n	\n	public static void dfs(int i) {\n		count++;\n		vis[i] = 1;\n		for(int x : adj[i]) {\n			if(vis[x] == 0) {\n				dfs(x);\n			}\n		}\n	}\n}","dfs and similar,dsu,graphs,math,trees"
"import java.util.ArrayList;\nimport java.util.Scanner;\n \npublic class Main {\n	\n	public static ArrayList<Integer>[] g;\n	public static boolean [] visited;\n	\n	public static int mod = (int) (1e9+7);\n	public static int cnt = 0;\n	\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		\n		int n = sc.nextInt();\n		int k = sc.nextInt();\n		\n		g = new ArrayList[n+1];\n		\n		for(int i = 0; i <= n; i++) {\n			g[i] = new ArrayList<Integer>();\n		}\n		visited = new boolean[n+1];\n\n		for(int i = 1; i < n; i++) {\n			int u = sc.nextInt();\n			int v = sc.nextInt();\n			int c = sc.nextInt();\n			\n			if(c != 1) {\n				g[u].add(v);\n				g[v].add(u);\n			}\n\n\n		}\n		long res = 0;\n		for(int i = 0; i <= n; i++) {\n			if(!visited[i]) {\n				cnt = 0;\n				dfs(i);\n				res+= fast_pow(cnt, k)%mod;\n			}\n			\n		}\n		res = res%mod;\n		int ges = (int) (fast_pow(n, k)%mod);\n		System.out.println((ges - res + mod+1) % mod);\n				\n	}\n	\n	static void dfs(int v) {\n		visited[v] = true;\n		cnt++;\n		for(int u : g[v]) {\n			if(!visited[u]) {\n				dfs(u);\n			}\n		}\n\n	}\n	\n	static long fast_pow(long a, long b) {\n		if(b == 0)\n			return 1L;\n \n		long val = fast_pow(a, b / 2);\n \n		if(b % 2 == 0)\n			return val * val % mod;\n		else \n			return val * val % mod * a % mod;\n	}\n\n}","dfs and similar,dsu,graphs,math,trees"
"\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Edges {\n	public static long mod = 1000000007;\n	public static ArrayList<ArrayList<Integer>> list;\n	public static int vis[];\n	static long count = 0;\n	public static long fast_pow(long a, long b) {\n		if(b == 0)\n			return 1L;\n \n		long val = fast_pow(a, b / 2);\n \n		if(b % 2 == 0)\n			return val * val % mod;\n		else \n			return val * val % mod * a % mod;\n	}\n	\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int k = sc.nextInt();\n		list =  new ArrayList<ArrayList<Integer>>(n);\n		for (int i = 0; i<=n; i++) {\n			list.add(new ArrayList<Integer>());\n		}\n		vis =  new int[n+1];\n		for (int i = 0; i < n-1; i++) {\n			int u = sc.nextInt();\n			int v = sc.nextInt();\n			int c = sc.nextInt();\n			if(c==0) {\n				list.get(u).add(v);\n				list.get(v).add(u);\n			}\n		}\n		long total = fast_pow(n, k)%mod;\n		long rem = 0;\n		for (int i = 1; i <=n; i++) {\n			if(vis[i]==0) {\n			count  = 0;\n			dfs(i);\n			rem = (rem%mod + (fast_pow(count,k))%mod)%mod;\n			}\n		}\n		System.out.println((total-rem+mod)%mod);\n	}\n\n	private static void dfs(int i) {\n		vis[i] = 1;\n		count++;\n		for (Integer e : list.get(i)) {\n			if(vis[e]==0) {\n				dfs(e);\n			}\n		}\n		\n	}\n\n}\n","dfs and similar,dsu,graphs,math,trees"
"import java.util.*;\nimport java.io.*;\npublic class Main {\n	public static void main(String[] args) throws IOException {\n		StreamTokenizer in=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n		in.nextToken();\n		int n=(int)in.nval;\n		in.nextToken();\n		int m=(int)in.nval;\n		ArrayList<Integer>[] h=new ArrayList[n+1];\n		ArrayList<Long>[] c=new ArrayList[n+1];\n		for (int i=1;i<=n;++i) {\n			h[i]=new ArrayList();\n			c[i]=new ArrayList();\n		}\n		for (int i=1;i<=n;++i) {\n			in.nextToken();\n			int k=(int)in.nval;\n			for (int j=0;j<k;++j) {\n				in.nextToken();\n				int a=(int)in.nval;\n				h[i].add(a);\n			}\n			for (int j=0;j<k;++j) {\n				in.nextToken();\n				long a=(long)in.nval;\n				c[i].add(a);\n			}\n		}\n		in.nextToken();\n		int q=(int)in.nval;\n		int[] H=new int[m+1];\n		long[] C=new long[m+1];\n		int cnt=0;\n		for (int i=0;i<q;++i) {\n			in.nextToken();\n			int id=(int)in.nval;\n			in.nextToken();\n			int mul=(int)in.nval;\n			for (int j=0;j<h[id].size();++j) {\n				H[++cnt]=h[id].get(j);\n				C[cnt]=1L*c[id].get(j)*mul;\n			}\n		}\n		int[] L=new int[m+1];\n		int[] R=new int[m+1];\n		int[] deq=new int[m+1];\n		int ptr=0;\n		for (int i=1;i<=m;++i) {\n			int nowL=i-H[i]+1;\n			while (ptr>0&&deq[ptr-1]>=nowL) nowL=Math.min(nowL,L[deq[--ptr]]);\n			nowL=Math.max(1,nowL);\n			L[deq[ptr++]=i]=nowL;\n		}\n		ptr=0;\n		for (int i=m;i>=1;--i) {\n			int nowR=i+H[i]-1;\n			while (ptr>0&&deq[ptr-1]<=nowR) nowR=Math.max(nowR,R[deq[--ptr]]);\n			nowR=Math.min(nowR,m);\n			R[deq[ptr++]=i]=nowR;\n		}\n		long[] dp=new long[m+1];\n		ptr=0;\n		long[] mmin=new long[m+1];\n		for (int i=1;i<=m;++i) {\n			dp[i]=dp[L[i]-1]+C[i];\n			while (ptr>0&&i>R[deq[ptr-1]]) --ptr;\n			if (ptr>0) dp[i]=Math.min(dp[i],mmin[ptr-1]);\n			deq[ptr]=i;\n			mmin[ptr++]=dp[i-1]+C[i];\n			if (ptr>1) mmin[ptr-1]=Math.min(mmin[ptr-1],mmin[ptr-2]);\n		}\n		System.out.println(dp[m]);\n	}\n}","data structures,dp,two pointers"
"import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class G {\n    public static void main(String[] args) throws IOException {\n        try (Input input = new StandardInput(); PrintWriter writer = new PrintWriter(System.out)) {\n            int blockCount = input.nextInt();\n            int totalDominoes = input.nextInt();\n            int[][] heights = new int[blockCount][];\n            int[][] costs = new int[blockCount][];\n            for (int b = 0; b < blockCount; b++) {\n                int blockSize = input.nextInt();\n                heights[b] = input.nextIntArray(blockSize);\n                costs[b] = input.nextIntArray(blockSize);\n            }\n            int[] h = new int[totalDominoes];\n            long[] c = new long[totalDominoes];\n            int offset = 0;\n            for (int k = input.nextInt(); k > 0; k--) {\n                int block = input.nextInt() - 1;\n                long costMultiplier = input.nextInt();\n                System.arraycopy(heights[block], 0, h, offset, heights[block].length);\n                for (int cost : costs[block]) {\n                    c[offset++] = costMultiplier * cost;\n                }\n            }\n            int[] leftStack = new int[totalDominoes];\n            int leftTop = 0;\n            int[] rightStack = new int[totalDominoes];\n            long[] rightStackValue = new long[totalDominoes];\n            int rightTop = 0;\n            long[] dp = new long[totalDominoes + 1];\n            for (int i = 0; i < totalDominoes; i++) {\n                int left = i - h[i];\n                while (leftTop > 0 && left < leftStack[leftTop - 1]) {\n                    leftTop--;\n                }\n                if (leftTop > 0) {\n                    left = leftStack[leftTop - 1];\n                } else {\n                    left = -1;\n                }\n                leftStack[leftTop++] = i;\n                while (rightTop > 0 && rightStack[rightTop - 1] <= i) {\n                    rightTop--;\n                }\n                long bestFromPredecessors = rightTop == 0 ? Long.MAX_VALUE : rightStackValue[rightTop - 1];\n                dp[i + 1] = Math.min(bestFromPredecessors, c[i] + dp[left + 1]);\n                bestFromPredecessors = Math.min(bestFromPredecessors, dp[i] + c[i]);\n                while (rightTop > 0 && rightStack[rightTop - 1] < i + h[i]) {\n                    rightTop--;\n                }\n                if (rightTop == 0 || rightStackValue[rightTop - 1] != bestFromPredecessors) {\n                    rightStack[rightTop] = i + h[i];\n                    rightStackValue[rightTop++] = bestFromPredecessors;\n                }\n            }\n            writer.println(dp[totalDominoes]);\n        }\n    }\n\n    interface Input extends Closeable {\n        String next() throws IOException;\n\n        default int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        default long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        default int[] nextIntArray(int size) throws IOException {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = nextInt();\n            }\n            return array;\n        }\n    }\n\n    private static class StandardInput implements Input {\n        private final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        private StringTokenizer stringTokenizer;\n\n        @Override\n        public void close() throws IOException {\n            reader.close();\n        }\n\n        @Override\n        public String next() throws IOException {\n            if (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {\n                stringTokenizer = new StringTokenizer(reader.readLine());\n            }\n            return stringTokenizer.nextToken();\n        }\n    }\n}","data structures,dp,two pointers"
"//package round541;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class G {\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n//	String INPUT = ""1 7\n"" + \n//			""7\n"" + \n//			""1 3 1 1 1 5 1\n"" + \n//			""1 1 4 5 1 4 8\n"" + ""1 1 1"";\n//	String INPUT = ""2 7\n"" + \n//			""3\n"" + \n//			""1 2 2\n"" + \n//			""1 2 1\n"" + \n//			""1\n"" + \n//			""3\n"" + \n//			""2\n"" + \n//			""3\n"" + \n//			""2 2\n"" + \n//			""1 3\n"" + \n//			""1 1"";\n	\n	void solve()\n	{\n		int n = ni(), m = ni();\n		int[][] as = new int[n][];\n		int[][] cs = new int[n][];\n		for(int i = 0;i < n;i++){\n			int K = ni();\n			as[i] = na(K);\n			cs[i] = na(K);\n		}\n		\n		int[] hs = new int[m];\n		long[] costs = new long[m];\n		\n		int p = 0;\n		int Q = ni();\n		for(int z = 0;z < Q;z++){\n			int id = ni()-1, mul = ni();\n			for(int j = 0;j < as[id].length;j++){\n				hs[p] = as[id][j];\n				costs[p] = (long)cs[id][j] * mul;\n				p++;\n			}\n		}\n		\n//		tr(hs);\n//		tr(costs);\n//		\n		assert p == m;\n		\n		out.println(minimumDominoCost(hs, costs));\n	}\n	\n	long minimumDominoCost(int[] hs, long[] costs)\n	{\n		int n = hs.length;\n		assert n == costs.length;\n		int[] pre = enumDominoReaches(hs);\n		int[] suf = enumDominoReaches(rev(hs));\n		\n		int[][] g = hopBucket(suf, n);\n		long[] dp = new long[n+1];\n		Arrays.fill(dp, Long.MAX_VALUE / 2);\n		dp[0] = 0;\n		\n		int[] stack = new int[n+1]; // pos\n		int sp = 0;\n		stack[sp++] = 0;\n		for(int i = 0;i < n;i++){\n			// merge\n			// dp[pre[i], i) + cost[i]\n			while(sp-2 >= 0 && stack[sp-2] >= pre[i]){\n				dp[stack[sp-2]] = Math.min(dp[stack[sp-2]], dp[stack[sp-1]]);\n				sp--;\n			}\n//			tr(""stack"", Arrays.copyOf(stack, sp));\n			assert sp-1 >= 0;\n			dp[i+1] = Math.min(dp[i+1], dp[stack[sp-1]] + costs[i]);\n//			tr(""z"", i+1, dp[i+1]);\n			stack[sp++] = i+1;\n			\n			// dp[j-1] + cost[j] (j -> i)\n			for(int j = g[0][n-1-i];j != -1;j = g[1][j]){\n				dp[i+1] = Math.min(dp[i+1], dp[n-1-j] + costs[n-1-j]);\n			}\n		}\n		\n//		tr(dp);\n		return dp[n];\n	}\n	\n	public int[][] hopBucket(int[] a, int m)\n	{\n		int n = a.length;\n		int[] first = new int[m];\n		Arrays.fill(first, -1);\n		int[] next = new int[n];\n		for(int i = 0;i < n;i++){\n			next[i] = first[a[i]];\n			first[a[i]] = i;\n		}\n		return new int[][]{first, next};\n	}\n	\n	public static int[] rev(int[] a)\n	{\n		int[] b = new int[a.length];\n		for(int i = 0;i < a.length;i++)b[a.length-1-i] = a[i];\n		return b;\n	}\n\n	\n	int[] enumDominoReaches(int[] hs)\n	{\n		int n = hs.length;\n		int[] reach = new int[n];\n		int[] stack = new int[n];\n		int sp = 0;\n		for(int i = 0;i < n;i++){\n			// fall (i-hs[i], i]\n			int min = i-hs[i]+1;\n			while(sp > 0 && stack[sp-1] > i-hs[i]) {\n				min = Math.min(min, reach[stack[sp-1]]);\n				sp--;\n			}\n			reach[i] = Math.max(min, 0);\n			stack[sp++] = i;\n		}\n		return reach;\n	}\n	\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new G().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n	\n	private char[][] nm(int n, int m)\n	{\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n	\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n	\n	private int ni()\n	{\n		int num = 0, b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","data structures,dp,two pointers"
"//package round541;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class G {\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n//	String INPUT = ""1 7\n"" + \n//			""7\n"" + \n//			""1 3 1 1 1 5 1\n"" + \n//			""1 1 4 5 1 4 8\n"" + ""1 1 1"";\n//	String INPUT = ""2 7\n"" + \n//			""3\n"" + \n//			""1 2 2\n"" + \n//			""1 2 1\n"" + \n//			""1\n"" + \n//			""3\n"" + \n//			""2\n"" + \n//			""3\n"" + \n//			""2 2\n"" + \n//			""1 3\n"" + \n//			""1 1"";\n	\n	void solve()\n	{\n		int n = ni(), m = ni();\n		int[][] as = new int[n][];\n		int[][] cs = new int[n][];\n		for(int i = 0;i < n;i++){\n			int K = ni();\n			as[i] = na(K);\n			cs[i] = na(K);\n		}\n		\n		int[] hs = new int[m];\n		long[] costs = new long[m];\n		\n		int p = 0;\n		int Q = ni();\n		for(int z = 0;z < Q;z++){\n			int id = ni()-1, mul = ni();\n			for(int j = 0;j < as[id].length;j++){\n				hs[p] = as[id][j];\n				costs[p] = (long)cs[id][j] * mul;\n				p++;\n			}\n		}\n		\n//		tr(hs);\n//		tr(costs);\n//		\n		assert p == m;\n		\n		out.println(minimumDominoCost(hs, costs));\n	}\n	\n	long minimumDominoCost(int[] hs, long[] costs)\n	{\n		int n = hs.length;\n		assert n == costs.length;\n		int[] pre = enumDominoReaches(hs);\n		int[] suf = enumDominoReaches(rev(hs));\n		\n		int[][] g = hopBucket(suf, n);\n		long[] dp = new long[n+1];\n		Arrays.fill(dp, Long.MAX_VALUE / 2);\n		dp[0] = 0;\n		\n		int[] stack = new int[n+1]; // pos\n		int sp = 0;\n		stack[sp++] = 0;\n		for(int i = 0;i < n;i++){\n			// merge\n			// dp[pre[i], i) + cost[i]\n			while(sp-2 >= 0 && stack[sp-2] >= pre[i]){\n				dp[stack[sp-2]] = Math.min(dp[stack[sp-2]], dp[stack[sp-1]]);\n				sp--;\n			}\n//			tr(""stack"", Arrays.copyOf(stack, sp));\n			assert sp-1 >= 0;\n			dp[i+1] = Math.min(dp[i+1], dp[stack[sp-1]] + costs[i]);\n//			tr(""z"", i+1, dp[i+1]);\n			stack[sp++] = i+1;\n			\n			// dp[j-1] + cost[j] (j -> i)\n			for(int j = g[0][n-1-i];j != -1;j = g[1][j]){\n				dp[i+1] = Math.min(dp[i+1], dp[n-1-j] + costs[n-1-j]);\n			}\n		}\n		\n//		tr(dp);\n		return dp[n];\n	}\n	\n	public int[][] hopBucket(int[] a, int m)\n	{\n		int n = a.length;\n		int[] first = new int[m];\n		Arrays.fill(first, -1);\n		int[] next = new int[n];\n		for(int i = n-1;i >= 0;i--) {\n			next[i] = first[a[i]];\n			first[a[i]] = i;\n		}\n		return new int[][]{first, next};\n	}\n	\n	public static int[] rev(int[] a)\n	{\n		int[] b = new int[a.length];\n		for(int i = 0;i < a.length;i++)b[a.length-1-i] = a[i];\n		return b;\n	}\n\n	\n	int[] enumDominoReaches(int[] hs)\n	{\n		int n = hs.length;\n		int[] reach = new int[n];\n		int[] stack = new int[n];\n		int sp = 0;\n		for(int i = 0;i < n;i++){\n			// fall (i-hs[i], i]\n			int min = i-hs[i]+1;\n			while(sp > 0 && stack[sp-1] > i-hs[i]) {\n				min = Math.min(min, reach[stack[sp-1]]);\n				sp--;\n			}\n			reach[i] = Math.max(min, 0);\n			stack[sp++] = i;\n		}\n		return reach;\n	}\n	\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new G().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n	\n	private char[][] nm(int n, int m)\n	{\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n	\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n	\n	private int ni()\n	{\n		int num = 0, b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","data structures,dp,two pointers"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1131F extends PrintWriter {\n	CF1131F() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1131F o = new CF1131F(); o.main(); o.flush();\n	}\n\n	int[] head, tail, pp;\n	int find(int[] ds, int i) {\n		return ds[i] == 0 ? i : (ds[i] = find(ds, ds[i]));\n	}\n	void join(int i, int j) {\n		i = find(tail, i);\n		j = find(tail, j);\n		if (i == j)\n			return;\n		j = find(head, j);\n		pp[i] = j;\n		tail[i] = j; head[j] = i;\n	}\n	void main() {\n		int n = sc.nextInt();\n		head = new int[n + 1];\n		tail = new int[n + 1];\n		pp = new int[n + 1];\n		while (--n > 0) {\n			int i = sc.nextInt();\n			int j = sc.nextInt();\n			join(i, j);\n		}\n		for (int i = find(head, 1); i != 0; i = pp[i])\n			print(i + "" "");\n		println();\n	}\n}\n","constructive algorithms,dsu"
"//package DSU1;\n\nimport java.util.Scanner;\n\n\npublic class F1131 {\n	\n	public static void main(String[] args) {\n		Scanner sc = new Scanner (System.in);\n		int n =sc.nextInt();\n		DSU graph [] = new DSU [n+10];\n		for (int i = 0 ; i <= n ; i++)\n			graph[i] = new DSU(i);\n		\n		for (int i = 0 ; i < n-1 ; i++) {\n			int u = sc.nextInt();\n			int v = sc.nextInt();\n			graph [u].unite(graph[v]);\n		}\n		\n		//printing\n		DSU root = graph[n].find();\n		while (root.nextChild != root) {\n			System.out.print (root.id+"" "");\n			root = root.nextChild; \n		}\n		\n		System.out.println (root.id);\n	}\n}\n\nclass DSU{\n	  DSU lastChild, Parent, nextChild;\n	  int id ;\n	  DSU (int id){\n		  lastChild = this ; \n		  Parent = this;\n		  nextChild = this;\n		  this.id = id ; \n	  }\n	  \n	  DSU find () {\n		  if (this.Parent == this) return this ;\n		  \n		  DSU parental = this.Parent.find();\n		  this.Parent = parental ;\n		  return parental; \n	  }\n	  \n	  DSU unite (DSU o) {\n		  DSU oP = o.find() ; \n		  DSU tP = this.find() ; \n		  \n		  tP.lastChild.nextChild = oP;\n		  tP.lastChild = oP.lastChild; \n		  oP.Parent = tP;\n		  return tP;\n	  }\n}","constructive algorithms,dsu"
"import java.util.*;\n\npublic class Solution{\n    static int[] par,rank;\n    static ArrayList<Integer>[] gr;\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        par=new int[n+1];\n        rank=new int[n+1];\n        gr=new ArrayList[n+1];\n        for(int i=0;i<=n;i++){\n            gr[i]=new ArrayList<>();\n            par[i]=i;\n        }\n        for(int i=0;i<n-1;i++){\n            int a=sc.nextInt(), b=sc.nextInt(), x=find(a), y=find(b);\n            if(y!=x) merge(a,b,x,y);\n        }\n       int[] vis=new int[n+1];\n       \n      \n        StringBuilder sb=new StringBuilder();\nfor(int i=1;i<=n;i++)if(i==par[i])for(int b:gr[i]) if(vis[b]==0){sb.append(b+"" "");vis[b]=1;} \n       System.out.println(sb);\n          }\n    static int find(int n){\n        if(n==par[n])return n;\n        return par[n]=find(par[n]);\n    }\nstatic void merge(int a,int b,int x,int y){\n        if(rank[x]>=rank[y]){\n                 gr[x].add(a);\n                 for(int c:gr[par[b]]){gr[x].add(c);par[c]=x;}\n           gr[x].add(b); par[b]=a; rank[x]++;\n        }\n        else{rank[y]++;\n        gr[y].add(b);\n         for(int c:gr[par[a]]){gr[y].add(c); par[c]=y;}\n        gr[y].add(a); par[a]=b;\n        }\n    }\n}\n","constructive algorithms,dsu"
"import java.util.*;\n\npublic class Solution{\n    static int[] par,rank;\n    static ArrayList<Integer>[] gr;\n    static ArrayList<Integer> p;\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        par=new int[n+1];\n        rank=new int[n+1];\n        gr=new ArrayList[n+1];\n        for(int i=0;i<=n;i++){\n            gr[i]=new ArrayList<>();\n            par[i]=i;\n        }\n    p=new ArrayList<>();\n    Pair[] ar=new Pair[n-1];\n        for(int i=0;i<n-1;i++){\n            int a=sc.nextInt();\n            int b=sc.nextInt();\n            int x=find(a), y=find(b);\n            if(y!=x){\n              merge(a,b,x,y);\n            }\n            ar[i]=new Pair(a,b);\n            \n        }\n       int[] vis=new int[n+1];\n       \n      \n        StringBuilder sb=new StringBuilder();\n     for(int i=1;i<=n;i++){\n      if(i==par[i]){   for(int b:gr[i]){\n             if(vis[b]==0){sb.append(b+"" "");vis[b]=1;}\n         }}\n     }\n \n       System.out.println(sb);\n       // for(int i=1;i<=n;i++)System.out.print(par[i]+"" "");\n        \n    }\n    static int find(int n){\n        if(n==par[n])return n;\n        return par[n]=find(par[n]);\n    }\n    \n    static void merge(int a,int b,int x,int y){\n        \n        if(rank[x]>=rank[y]){\n                 gr[x].add(a);\n                 \n                 for(int c:gr[par[b]]){\n                     gr[x].add(c);\n                     par[c]=x;\n                     \n                 }\n                 gr[x].add(b);\n            par[b]=a;\n            rank[x]++;\n        }\n        else{rank[y]++;\n        gr[y].add(b);\n         for(int c:gr[par[a]]){\n                     gr[y].add(c);\n                     par[c]=y;\n                   \n                 }\n                \n                  gr[y].add(a);\n                  par[a]=b;\n        \n        }\n    }\n}\nclass Pair{\n    int x,y;\n    Pair(int x,int y){\n        this.x=x;\n        this.y=y;\n    }\n}","constructive algorithms,dsu"
"import java.util.*;\npublic class class304 {\npublic static void main(String arg[])\n{\n	Scanner sc=new Scanner(System.in);\n	long w1,h1,w2,h2;\n	w1=sc.nextLong();\n	h1=sc.nextLong();\n	w2=sc.nextLong();\n	h2=sc.nextLong();\n	System.out.println(2*(w1+h1+h2)+4);\n}\n}\n",math
"import java.util.*;\npublic class Demo{\n	public static void main(String[] args) {\n		int a,b,c,d;\n		Scanner in = new Scanner(System.in);\n		a = in.nextInt();\n		b = in.nextInt();\n		c = in.nextInt();\n		d = in.nextInt();\n		System.out.println(2*a + (b+d+2)*2);\n\n	}	\n}		\n",math
"import java.util.*;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int aw=sc.nextInt(),ah=sc.nextInt();\n		int bw=sc.nextInt(),bh=sc.nextInt();\n		int max=Math.max(aw, bw);\n		int t=ah+bh;\n		System.out.print(max*2+t*2+4);\n	}\n} ",math
"import java.util.*;\n\npublic class Solution {\n\n  private static Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    int w1 = sc.nextInt(), h1 = sc.nextInt(), w2 = sc.nextInt(), h2 = sc.nextInt();\n    System.out.println(2 * (w1 + h1 + h2) + 4);\n  }\n}",math
"import java.util.Scanner;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int arr[] = new int[n];\n		int left = 0;\n		int right = 0;\n		for(int i=0;i<n;i++) {\n			arr[i] = sc.nextInt();\n			if(arr[i]!=arr[0])left=i;\n		}\n		for(int i=0;i<n;i++) {\n			if(arr[n-1]!=arr[i]) {\n				right=i;\n				break;\n			}\n		}\n		System.out.println(Math.max(left,n-right-1));\n	}\n}\n		    	   		 	 	 	 	     				","greedy,implementation"
"import java.io.*;\nimport java.util.Scanner;\npublic class Main {\n	public static void main (String [] args) {\n		Scanner sc=new Scanner(System.in);\n		  \n		int n=sc.nextInt();\n		int a[]=new int[n];\n		  \n		for(int i=0;i<n;i++)\n			a[i]=sc.nextInt();\n			\n		int ans=0;\n		\n		for(int i=n-1;i>0;i--)\n		{\n			if(a[i]!=a[0])\n				ans=Math.max(ans,i);\n		}\n		\n		for(int i=0;i<n-1;i++)\n		{\n			if(a[i]!=a[n-1])\n				ans=Math.max(ans,n-1-i);\n		}\n		\n		System.out.println(ans);\n	}\n}","greedy,implementation"
"import java.util.Scanner;\n\npublic class ilya_walk_1119A{\n	public static void main(String[] args){\n		Scanner in = new Scanner(System.in);\n\n		int n = in.nextInt();\n		int[] arr = new int[n];\n		for(int i=0; i<n; i++){\n			arr[i] = in.nextInt();\n		}\n\n		int rMax = 0;\n		for(int i=0; i<n; i++){\n			if(arr[i] != arr[n-1]){\n				rMax = n-1 - i;\n				break;\n			}\n		}\n\n		int lMax = 0;\n		for(int i=n-1; i>0; i--){\n			if(arr[i] != arr[0]){\n				lMax = i - 0;\n				break;\n			}\n		}\n\n		System.out.println(Math.max(lMax, rMax));\n	}\n}","greedy,implementation"
"import java.util.Scanner;\n\npublic class IlyaAndAColorfulWalk {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int n = s.nextInt();\n        int[] a = new int[n];\n        for(int i = 0; i < n; i++) a[i] = s.nextInt();\n        int index1 = 0, index2 = n - 1;\n        while(a[index1] == a[n - 1]) index1++;\n        while(a[index2] == a[0]) index2--;\n        int one = n - index1 - 1;\n        int two = index2;\n        System.out.println(one > two ? one : two);\n    }\n}","greedy,implementation"
"import java.util.*;\npublic class SD {\n	public static void main(String[] args) {\n	Scanner sc=new Scanner(System.in);\n	int t=sc.nextInt();\n	while(t-->0){\n		int n=sc.nextInt(),m=sc.nextInt();\n		int[] arr=new int[n];long sum=0;\n		for(int i=0;i<n;i++){\n			arr[i]=sc.nextInt();\n			sum+=arr[i];\n		}\n		Arrays.sort(arr);\n		System.out.println(n+sum-arr[0]+arr[n-1]<=m?""YES"":""NO"");\n		}	\n	}\n}","greedy,math,sortings"
"import java.util.*;\n\npublic class social{\n\npublic static void main(String arg[]) {\n   Scanner sh = new Scanner(System.in);\n   int t = sh.nextInt();\n\n   while(t>0){\n     long n = sh.nextLong();\n     long m = sh.nextLong();\n     long sum = 0;\n     long arr[] = new long[(int)n];\n     for(int i =0; i<n; i++){\n         arr[i] = sh.nextLong();\n         sum = sum + arr[i];\n     }\n     Arrays.sort(arr);\n     m = m - n - sum + arr[0];\n     if(m >= arr[(int)n-1]){\n         System.out.println(""YES"");\n\n     }else{\n         System.out.println(""NO"");\n     }\n\n      \n\n   t--;}\n}\n\n\n\n\n}","greedy,math,sortings"
"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class P7 {\n\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int t=in.nextInt();\n		for(int h=0;h<t;h++) {\n			int n=in.nextInt();\n			long m=in.nextLong();\n			long []a=new long[n];\n			for(int i=0;i<n;i++) {\n				 a[i]=in.nextLong();\n			}\n			Arrays.sort(a);\n		    long k=n+2*a[n-1];\n		    int i=1;\n		    for( i=1;i<n;i++) {\n		    	if(k<=m) {\n		    		 k=k+a[i];\n		    	}\n		    	else\n		    		break;\n		    }\n			if(i==n) {\n				System.out.println(""Yes"");\n			}\n			else\n				System.out.println(""No"");\n			\n			\n		}\n		\n}}\n","greedy,math,sortings"
"import java.util.*;\n\npublic class chairs {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int t=sc.nextInt();\n        while(t-->0)\n        {\n            int n=sc.nextInt();\n            int m=sc.nextInt();\n            int[] a=new int[n];\n            for(int i=0;i<n;i++)\n            a[i]=sc.nextInt();\n\n            Arrays.sort(a);\n            long sum=0l;\n            for(int i=1;i<n-1;i++)\n                sum+=a[i];\n\n            sum+=a[n-1]*2+n;\n\n            if(sum<=m)\n            System.out.println(""YES"");\n            else\n            System.out.println(""NO"");\n        }\n        sc.close();\n    }\n}\n","greedy,math,sortings"
"import java.util.*;\npublic class c1668A {\n	public static void main (String[] args) {\n		Scanner in=new Scanner(System.in);\n		int tt=in.nextInt(), t=0;\n		while(t++<tt) {\n			int a=in.nextInt(),\n				b=in.nextInt(),\n				r;\n			if(a>b) { r=a; a=b; b=r; }\n			if(a==1 && b>2)\n				r=-1;\n			else\n				r=2*(b-1)-(b-a)%2;\n			System.out.println(r);\n		} in.close();\n	}\n}","implementation,math"
"import java.util.*;\npublic class DC {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0) {\n			int n=sc.nextInt(),m=sc.nextInt(),ans=0;\n			if(n<m) {\n				n^=m;m^=n;n^=m;\n			}\n				ans=n+m-2;\n			if((n-m)>1 && m<2) {\n				ans=-1;\n			}else {\n				ans+=(n-m>>1)<<1;\n			}\n			System.out.println(ans);\n		}\n	}\n}","implementation,math"
"import java.util.*;\n\npublic class s {\n	public static void main(String args[]) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n =sc.nextInt()-1;\n			int m =sc.nextInt()-1;\n			int res= Math.min(n, m)*2+1;\n			int diff =Math.abs(n-m)-1;\n			if(diff%2==0)\n			{\n				res+=diff*2;\n			}\n			else\n				res+=diff*2+1;\n			if(n==0||m==0)\n			{\n				if(Math.abs(n-m)>1)\n					res=-1;\n			}\n			System.out.println(res);\n			\n	}\n	\n}}","implementation,math"
import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class P7 {\n\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int t=in.nextInt();\n		for(int h=0;h<t;h++) {\n			int n=in.nextInt();\n			int m=in.nextInt();\n			if(n>1&m>1)\n			System.out.println(n+m-2+((Math.abs(n-m)/2)*2));\n			else {\n				if(n==1&m==1) \n					System.out.println(0);\n				else {\n					if(n==2|m==2)\n						System.out.println(1);\n					else\n				System.out.println(-1);}}\n		}\n		\n}}\n,"implementation,math"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1262D2 extends PrintWriter {\n	CF1262D2() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1262D2 o = new CF1262D2(); o.main(); o.flush();\n	}\n\n	int[] st; int n_;\n	void update(int i) {\n		for (i += n_; i > 0; i >>= 1)\n			st[i]++;\n	}\n	int query(int k) {\n		int i = 1;\n		while (i < n_) {\n			i <<= 1;\n			if (k > st[i]) {\n				k -= st[i];\n				i |= 1;\n			}\n		}\n		return i - n_;\n	}\n	void main() {\n		int n = sc.nextInt();\n		int[] aa = new int[n];\n		Integer[] ii = new Integer[n];\n		for (int i = 0; i < n; i++) {\n			aa[i] = sc.nextInt();\n			ii[i] = i;\n		}\n		Arrays.sort(ii, (i, j) -> aa[i] != aa[j] ? aa[j] - aa[i] : i - j);\n		int m = sc.nextInt();\n		int[] kk = new int[m];\n		int[] pp = new int[m];\n		int[] ans = new int[m];\n		Integer[] hh = new Integer[m];\n		for (int h = 0; h < m; h++) {\n			kk[h] = sc.nextInt();\n			pp[h] = sc.nextInt();\n			hh[h] = h;\n		}\n		Arrays.sort(hh, (u, v) -> kk[u] - kk[v]);\n		n_ = 1;\n		while (n_ < n)\n			n_ <<= 1;\n		st = new int[n_ << 1];\n		for (int k = 0, h = 0; h < m; h++) {\n			int h_ = hh[h], k_ = kk[h_], p_ = pp[h_];\n			while (k < k_)\n				update(ii[k++]);\n			ans[h_] = aa[query(p_)];\n		}\n		for (int h = 0; h < m; h++)\n			println(ans[h]);\n	}\n}\n","data structures,greedy"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1262D2 extends PrintWriter {\n	CF1262D2() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1262D2 o = new CF1262D2(); o.main(); o.flush();\n	}\n\n	int[] ft;\n	void update(int i, int n) {\n		while (i < n) {\n			ft[i]++;\n			i |= i + 1;\n		}\n	}\n	int query(int i) {\n		int sum = 0;\n		while (i >= 0) {\n			sum += ft[i];\n			i &= i + 1; i--;\n		}\n		return sum;\n	}\n	void main() {\n		int n = sc.nextInt();\n		int[] aa = new int[n];\n		Integer[] ii = new Integer[n];\n		for (int i = 0; i < n; i++) {\n			aa[i] = sc.nextInt();\n			ii[i] = i;\n		}\n		Arrays.sort(ii, (i, j) -> aa[i] != aa[j] ? aa[j] - aa[i] : i - j);\n		int m = sc.nextInt();\n		int[] kk = new int[m];\n		int[] pp = new int[m];\n		int[] ans = new int[m];\n		Integer[] hh = new Integer[m];\n		for (int h = 0; h < m; h++) {\n			kk[h] = sc.nextInt();\n			pp[h] = sc.nextInt();\n			hh[h] = h;\n		}\n		Arrays.sort(hh, (u, v) -> kk[u] - kk[v]);\n		ft = new int[n];\n		for (int k = 0, h = 0; h < m; h++) {\n			int h_ = hh[h], k_ = kk[h_], p_ = pp[h_];\n			while (k < k_)\n				update(ii[k++], n);\n			int lower = -1, upper = n - 1;\n			while (upper - lower > 1) {\n				int i = (lower + upper) / 2;\n				if (query(i) >= p_)\n					upper = i;\n				else\n					lower = i;\n			}\n			ans[h_] = aa[upper];\n		}\n		for (int h = 0; h < m; h++)\n			println(ans[h]);\n	}\n}\n","data structures,greedy"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1262D2 extends PrintWriter {\n	CF1262D2() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1262D2 o = new CF1262D2(); o.main(); o.flush();\n	}\n\n	Random rand = new Random();\n	int[] zz, ll, rr, xx, yy; int u_, l_, r_, $;\n	int[] st; int n_;\n	int node(int x) {\n		int u = ++$;\n		zz[u] = rand.nextInt();\n		xx[u] = x;\n		yy[u] = 1;\n		return u;\n	}\n	void pul(int u) {\n		yy[u] = 1 + yy[ll[u]] + yy[rr[u]];\n	}\n	void split(int u, int x) {\n		if (u == 0) {\n			u_ = l_ = r_ = 0;\n			return;\n		}\n		if (xx[u] < x) {\n			split(rr[u], x);\n			rr[u] = l_; l_ = u;\n		} else if (xx[u] > x) {\n			split(ll[u], x);\n			ll[u] = r_; r_ = u;\n		} else {\n			u_ = u; l_ = ll[u]; r_ = rr[u];\n			ll[u] = rr[u] = 0;\n		}\n		pul(u);\n	}\n	int merge(int u, int v) {\n		if (u == 0)\n			return v;\n		if (v == 0)\n			return u;\n		int w;\n		if (zz[u] <= zz[v]) {\n			rr[u] = merge(rr[u], v);\n			w = u;\n		} else {\n			ll[v] = merge(u, ll[v]);\n			w = v;\n		}\n		pul(w);\n		return w;\n	}\n	void update(int x) {\n		split(u_, x);\n		u_ = merge(l_, merge(node(x), r_));\n	}\n	int query(int k) {\n		for (int u = u_, v; ; u = v) {\n			v = ll[u];\n			int y = yy[v] + 1;\n			if (k == y)\n				return xx[u];\n			if (k > y) {\n				k -= y;\n				v = rr[u];\n			}\n		}\n	}\n	void main() {\n		int n = sc.nextInt();\n		int[] aa = new int[n];\n		Integer[] ii = new Integer[n];\n		for (int i = 0; i < n; i++) {\n			aa[i] = sc.nextInt();\n			ii[i] = i;\n		}\n		Arrays.sort(ii, (i, j) -> aa[i] != aa[j] ? aa[j] - aa[i] : i - j);\n		int m = sc.nextInt();\n		int[] kk = new int[m];\n		int[] pp = new int[m];\n		int[] ans = new int[m];\n		Integer[] hh = new Integer[m];\n		for (int h = 0; h < m; h++) {\n			kk[h] = sc.nextInt();\n			pp[h] = sc.nextInt();\n			hh[h] = h;\n		}\n		Arrays.sort(hh, (u, v) -> kk[u] - kk[v]);\n		zz = new int[1 + n]; ll = new int[1 + n]; rr = new int[1 + n];\n		xx = new int[1 + n]; yy = new int[1 + n];\n		for (int k = 0, h = 0; h < m; h++) {\n			int h_ = hh[h], k_ = kk[h_], p_ = pp[h_];\n			while (k < k_)\n				update(ii[k++]);\n			ans[h_] = aa[query(p_)];\n		}\n		for (int h = 0; h < m; h++)\n			println(ans[h]);\n	}\n}\n","data structures,greedy"
"import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class OptimalSubsequence {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int lengthSeq = scanner.nextInt();\n        int[] numbers = new int[lengthSeq + 1];\n        PriorityQueue<Integer[]> maxes = new PriorityQueue<>(new Comparator<Integer[]>() {\n            @Override\n            public int compare(Integer[] arr1, Integer[] arr2) {\n                return (!arr1[0].equals(arr2[0])) ? -arr1[0] + arr2[0] : arr1[1] - arr2[1];\n            }\n        });\n\n        for (int i = 1; i <= lengthSeq; i++) {\n            numbers[i] = scanner.nextInt();\n            maxes.add(new Integer[] {numbers[i], i});\n        }\n\n        int numQuery = scanner.nextInt();\n        int[] result = new int[numQuery];\n        int[][] queries = new int[numQuery][3];\n        for (int i = 0; i < numQuery; i++) {\n            queries[i][0] = scanner.nextInt();\n            queries[i][1] = scanner.nextInt();\n            queries[i][2] = i;\n        }\n        Arrays.sort(queries, (int[] r1, int[] r2) -> {\n            return (r1[0] != r2[0]) ? r1[0] - r2[0] : r1[1] - r2[1];\n        });\n\n        int[] appearance = new int[lengthSeq + 1];\n        int[] bit = new int[lengthSeq + 1];\n        int pointer = 0;\n        for (int i = 1; i <=  queries[queries.length - 1][0]; i++) {\n            Integer[] curr = maxes.poll();\n            assert curr != null;\n            appearance[curr[1]] = 1;\n            update(bit, curr[1]);\n            while (pointer < queries.length && queries[pointer][0] == i) {\n                int targetIndex = queries[pointer][1];\n                int left = 1;\n                int right = lengthSeq;\n                while (left < right) {\n                    int mid = (left + right) >> 1;\n                    if (query(bit, mid) >= targetIndex) right = mid; else left = mid + 1;\n                }\n                result[queries[pointer][2]] = numbers[left];\n                pointer++;\n            }\n\n        }\n        for (int out: result) System.out.println(out);\n    }\n\n    private static void update(int[] bit, int index) {\n        for (; index < bit.length; index += index & -index) bit[index]++;\n    }\n\n    private static int query(int[] bit, int index) {\n        int answer = 0;\n        for (; index > 0; index -= index & -index) answer += bit[index];\n        return answer;\n    }\n}\n\n","data structures,greedy"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1262C extends PrintWriter {\n	CF1262C() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1262C o = new CF1262C(); o.main(); o.flush();\n	}\n\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int k = sc.nextInt();\n			byte[] aa = sc.next().getBytes();\n			byte[] bb = new byte[n];\n			int h = n / 2 - (k - 1);\n			for (int i = 0; i < h; i++) {\n				bb[i] = '(';\n				bb[h + i] = ')';\n			}\n			for (int i = h * 2; i < n; i += 2) {\n				bb[i] = '(';\n				bb[i + 1] = ')';\n			}\n			println(n);\n			for (int i = 0; i < n; i++) {\n				int l = i, r = i;\n				while (aa[r] != bb[i])\n					r++;\n				println((l + 1) + "" "" + (r + 1));\n				while (l < r) {\n					byte tmp = aa[l]; aa[l] = aa[r]; aa[r] = tmp;\n					l++; r--;\n				}\n			}\n		}\n	}\n}\n",constructive algorithms
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n  public static void main(String[] args) throws IOException {\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n      PrintWriter wr = new PrintWriter(System.out);\n      StringBuilder sb = new StringBuilder();\n      \n      int t = Integer.parseInt(br.readLine());\n      while(t-->0){\n          String split[] = br.readLine().split("" "");\n          int n = Integer.parseInt(split[0]);\n          int k = Integer.parseInt(split[1]);\n          \n          // emotional damage !\n          char ch[] = br.readLine().toCharArray();\n          ArrayList<int[]> list = new ArrayList();\n          for(int i =0;i<n;i++){\n              int j = i;\n              if(i%2==0){\n                  while(ch[j]!='(') j++;\n              }else{\n                  while(ch[j]!=')') j++;\n              }\n              \n              if(i!=j){\n                  list.add(new int[]{i,j});\n                  char temp = ch[i];\n                  ch[i] = ch[j];\n                  ch[j] = temp;\n              }\n          }\n          \n          int ans = n/2; // balanced prefix obtained after converting to max epxression -> ()()()().......\n          int i = 1;\n          \n          while(ans!=k){\n            list.add(new int[]{i,i+1});\n            i+=2;\n            ans--;\n          }\n          \n          sb.append(list.size()).append(""\n"");\n          for(int arr[] : list){\n              sb.append(arr[0]+1).append("" "").append(arr[1]+1).append(""\n"");\n          }\n          \n      }\n      wr.println(sb);\n      wr.close();\n  }\n}",constructive algorithms
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Kraken7\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    Scanner in = new Scanner(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskC solver = new TaskC();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskC {\n\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n      int ts = in.nextInt();\n      while (ts-- > 0) {\n        int n = in.nextInt(), k = in.nextInt();\n        char[] s = in.next().toCharArray();\n        int left = n - (k - 1) * 2;\n        String sb = ""()"".repeat(Math.max(0, k - 1))\n          + ""("".repeat(Math.max(0, left / 2))\n          + "")"".repeat(Math.max(0, left / 2));\n        char[] t = sb.toCharArray();\n        ArrayList<Integer[]> res = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n          if (s[i] == t[i])\n            continue;\n          for (int j = i + 1; j < n; j++) {\n            if (s[j] == t[i]) {\n              res.add(new Integer[] { i + 1, j + 1 });\n              for (int x = i; x < j; x++, j--) {\n                char z = s[x];\n                s[x] = s[j];\n                s[j] = z;\n              }\n              break;\n            }\n          }\n        }\n        out.println(res.size());\n        for (Integer[] i : res)\n          out.println(i[0] + "" "" + i[1]);\n      }\n    }\n\n  }\n}\n\n",constructive algorithms
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n  public static void main(String[] args) throws IOException {\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n      PrintWriter wr = new PrintWriter(System.out);\n      StringBuilder sb = new StringBuilder();\n      \n      int t = Integer.parseInt(br.readLine());\n      while(t-->0){\n          String split[] = br.readLine().split("" "");\n          int n = Integer.parseInt(split[0]);\n          int k = Integer.parseInt(split[1]);\n          \n          char ch[] = br.readLine().toCharArray();\n          ArrayList<int[]> list = new ArrayList();\n          \n          for(int i=0;i<n;i++){\n              int j =i;\n              if(i%2==0){ // opening bracket required\n                  while(ch[j]!='(') j++;\n              }else{\n                  while(ch[j]!=')') j++;\n              }\n              \n              if(i!=j){\n                  // swapping works , ex : -> )((( -> reverse  ((()\n                  list.add(new int[]{i,j});\n                  char c = ch[i];\n                  ch[i] = ch[j];\n                  ch[j] = c;\n              }\n          }\n          \n          int ans = n/2;\n          int i = 1;\n          while(ans!=k){\n              list.add(new int[]{i,i+1});\n              i+=2;\n              ans--;\n          }\n          sb.append(list.size()).append(""\n"");\n          for(int arr[] : list){\n              int start = arr[0]+1;\n              int end = arr[1]+1;\n              \n              sb.append(start).append("" "").append(end).append(""\n"");\n          }\n          \n      }\n      wr.println(sb);\n      wr.close();\n  }\n}",constructive algorithms
"import java.util.*;\nimport java.math.*;\npublic class Solution {\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int t = in.nextInt();\n		for(int tt = 0; tt < t; tt++) {\n			int n = in.nextInt();\n			int[] seen = new int[n + 2];\n			int[] ans = new int[n];\n			int cur = 1;\n			int max = 0;\n			boolean flag = true;\n			for(int i = 0; i < n; i++) {\n				int gt = in.nextInt();\n				if(gt < max) {\n					flag = false;\n				}else {\n					max = gt;\n				}\n				if(seen[gt] == 0) {\n					ans[i] = gt;\n					seen[gt] = 1;\n				}else {\n					while(seen[cur] == 1) {\n					 	cur += 1;\n					}\n					if(cur >= max) {\n						flag = false;\n					}else {\n						ans[i] = cur;\n						seen[cur] = 1;\n						cur += 1;\n					}\n				}\n			}\n			if(flag == false) {\n				System.out.println(""-1"");\n				continue;\n			}\n			for(int i = 0; i < n; i++) {\n				if(i > 0) {\n					System.out.print("" "");\n				}\n				System.out.print(ans[i]);\n			}\n			System.out.print(""\n"");\n		}\n	}\n}",constructive algorithms
"import java.util.*;\npublic class MyClass {\n    public static void main(String args[]) {\n        Scanner sc=new Scanner(System.in);\n        int t=sc.nextInt();\n        while(t-->0){\n            int n=sc.nextInt();\n            int p[]=new int[n];\n            Set<Integer> set=new HashSet<>();\n            boolean permut=true;\n            int idx=1;\n            set.add(p[0]=sc.nextInt());\n            for(int i=1;i<n;i++){\n                int a=sc.nextInt();\n                if(!set.contains(a)){\n                    set.add(p[i]=a);\n                }\n                else{\n                    for(;idx<a;idx++){\n                        if(!set.contains(idx))break;\n                    }\n                    if(set.contains(idx))permut=false;\n                    else set.add(p[i]=idx);\n                }\n            }\n            if(permut){\n                for(Integer i:p)System.out.print(i+"" "");\n                System.out.println();\n            }\n            else\n                System.out.println(-1);\n        }\n    }\n}",constructive algorithms
"import java.util.*;\nimport java.io.*;\n\npublic class B {\n	public static void main(String ...args) {\n    Scanner input = new Scanner(System.in);\n    \n  	int t = input.nextInt();\n    \n    for (int i = 0; i < t; i++){\n    	int n = input.nextInt();\n      int[] q = new int[n];\n      TreeSet<Integer> set = new TreeSet<>();\n      \n      for (int j = 0; j < n; j++) {\n        q[j] = input.nextInt();\n        set.add(j + 1);\n      }\n      \n      int prev = -1;\n      StringBuilder answer = new StringBuilder();\n      \n      for (int j = 0; j < n; j++) {\n      	int cur = q[j];\n        \n        if (cur > prev) {\n					answer.append(cur).append("" "");\n          set.remove(cur);\n        } else {\n          Integer first = set.first();\n          \n          if (first >= cur) {\n            answer = new StringBuilder(""-1"");\n            break;\n          }\n        	\n          answer.append(first).append("" "");\n          set.remove(first);\n        }\n        \n        prev = cur;\n      }\n      \n      System.out.println(answer);\n    }\n  }\n}\n\n",constructive algorithms
"import java.util.*;\npublic class Main\n{\n	\n    public static void main(String args[]){\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        while(t-->0) {\n        	int l = sc.nextInt();\n        	int[] arr1 = new int[l];\n        	int[] arr2 = new int[l];\n        	for(int i=0; i<l; i++) {\n        		arr1[i] = sc.nextInt();\n        	}\n        	Queue<Integer> q = new LinkedList<>();\n        	int num = 0;\n        	arr2[0]=arr1[0];\n        	for(int j = 1; j< arr1[0]; j++)\n				q.add(j);\n        	for(int i=1; i<l; i++) {\n        		if(arr1[i]<i+1) {\n        			num=-1;\n        			break;\n        		}\n        		else if(arr1[i]>arr1[i-1]) {\n        			for(int j = arr1[i-1]+1; j< arr1[i]; j++)\n        				q.add(j);\n        		arr2[i] = arr1[i];\n        		}\n        		else {\n        			arr2[i] = q.remove();\n        		}\n        	}\n        	\n        	if(num==-1)\n        		System.out.print(""-1"");\n        	else\n        		for(int i=0; i<l; i++)\n        			System.out.print(arr2[i]+"" "");\n        	System.out.println();\n        }\n    }\n}",constructive algorithms
"import java.util.*;\npublic class Main{\npublic static void main(String [] args){  \n Scanner sc = new Scanner(System.in);\nint t = sc.nextInt(),cnt = 0;\nchar c[] = sc.next().toCharArray();\nfor(int i=0;i<t;i=i+2)\n{\nif(c[i]==c[i+1])\n{\ncnt++;\nc[i]='a';\nc[i+1]='b';\n\n}\n}\nSystem.out.println(cnt);\n System.out.println(c);\n}\n}",strings
"import java.util.*;\npublic class Main{\npublic static void main(String [] args){  \n Scanner sc = new Scanner(System.in);\nint t = sc.nextInt(),cnt = 0;\nchar c[] = sc.next().toCharArray();\nfor(int i=0;i<t;i=i+2)\n{\nif(c[i]==c[i+1])\n{\ncnt++;\nc[i]='a';\nc[i+1]='b';\n\n}\n}\nSystem.out.println(cnt);\n System.out.println(c);\n}\n}",strings
"import java.util.*;\npublic class Main{\npublic static void main(String [] args){  \n Scanner sc = new Scanner(System.in);\nint t = sc.nextInt(),cnt = 0;\nchar c[] = sc.next().toCharArray();\nfor(int i=0;i<t;i=i+2)\n{\nif(c[i]==c[i+1])\n{\ncnt++;\nc[i]='a';\nc[i+1]='b';\n \n}\n}\nSystem.out.println(cnt);\n System.out.println(c);\n}\n}",strings
"import java.util.*;\npublic class Main{\npublic static void main(String [] args){  \n Scanner sc = new Scanner(System.in);\nint t = sc.nextInt(),cnt=0;\n\nchar c[]=sc.next().toCharArray();\nfor(int i=0;i<t;i+=2)\n{\n    if(c[i]==c[i+1])\n    {\n        cnt++;\n        c[i]='a';\n        c[i+1]='b';\n    }\n}\n\nSystem.out.println(cnt);\nSystem.out.println(c);\n}\n}",strings
"import java.io.*;\nimport java.util.*;\n\npublic class HelloWorld{\n\n    public static void main(String []args)throws IOException{\n    \n        BufferedReader re = new BufferedReader(new InputStreamReader(System.in));\n        \n        int n = Integer.parseInt(re.readLine());\n        \n        ArrayList<ArrayList<Integer>> ls = new ArrayList<>();\n        \n        for(int i=0; i<20; i++) ls.add(new ArrayList<>());\n        \n        StringTokenizer tk = new StringTokenizer(re.readLine());\n        \n        for(int i=0; i<n; i++){\n            int input = Integer.parseInt(tk.nextToken())-1;\n            ls.get(input).add(i);\n        }\n        \n        long cnt[][] = new long[20][20];\n        \n        for(int i=0; i<20; i++){\n            for(int j=0; j<20; j++){\n                if(i != j){\n                    \n                    int ind1 = 0, ind2 = 0;\n                    cnt[i][j] = 0;\n                    \n                    ArrayList<Integer> ls1 = ls.get(i), ls2 = ls.get(j);\n                    while(ind1 < ls1.size()){\n                        \n                        while(ind2 < ls2.size() && ls2.get(ind2) < ls1.get(ind1))\n                            ind2++;\n            \n                        cnt[i][j] += ind2;\n                        \n                        ind1++;\n                    }\n                    \n                }\n            }\n        }\n        \n        long dp[] = new long[1<<20];\n        dp[0] = 0;\n        \n        for(int i=1; i<(1<<20); i++){\n            \n            dp[i] = Long.MAX_VALUE;\n            \n            if(Integer.bitCount(i) == 1)\n                dp[i] = 0;\n            else{\n                for(int j=0; j<20; j++){\n                    if((i&(1<<j)) > 0){\n                        \n                        long sum = dp[i^(1<<j)];\n                        \n                        for(int k=0; k<20; k++){\n                            if((i&(1<<k)) > 0 && j != k)\n                                sum += cnt[k][j];\n                        }\n                        \n                        dp[i] = Math.min(dp[i], sum);\n                    }\n                }\n            }\n        }\n        \n        System.out.println(+dp[(1<<20)-1]);\n    }\n}","bitmasks,dp"
"import java.io.*;\nimport java.util.*;\npublic class Sol{\n	final public static long MOD = 998244353;\n	public static void main(String[] args) throws IOException{\n		FastIO sc = new FastIO(System.in);\n		PrintWriter out = new PrintWriter(System.out);\n		int n = sc.nextInt();\n		ArrayList<Integer>[] pos = new ArrayList[20];\n		for(int i=0; i<20; ++i) {\n			pos[i] = new ArrayList<>();\n		}\n		for(int i=0; i<n; ++i) {\n			int a = sc.nextInt()-1;\n			pos[a].add(i);\n		}\n		long moves[][] = new long[20][20];\n		for(int i=0; i<20; ++i) {\n			for(int j=0; j<20; ++j) {\n				if(i==j) {\n					moves[i][j] = 0;\n					continue;\n				}\n				if(pos[i].size()==0||pos[j].size()==0) {\n					moves[i][j] = 0;\n					continue;\n				}\n				int idxi = 0;\n				int idxj = 0;\n				while(idxi<pos[i].size()) {\n					if(idxj==pos[j].size()) {\n						moves[i][j]+=idxj;\n						idxi++;\n					}else if(pos[j].get(idxj)<pos[i].get(idxi)) {\n						idxj++;\n					}else {\n						moves[i][j]+=idxj;\n						idxi++;\n					}\n				}\n			}\n		}\n		long dp[] = new long[1<<20];\n		Arrays.fill(dp, Long.MAX_VALUE);\n		dp[0] = 0;\n		for(int msk = 0; msk<(1<<20); msk++) {\n			if(dp[msk] == Long.MAX_VALUE) continue;\n			ArrayList<Integer> all = new ArrayList<>();\n			for(int i=0; i<20; ++i) {\n				if((msk&(1<<i))>0) {\n					all.add(i);\n				}\n			}\n			for(int i=0; i<20; ++i) {\n				if((msk&(1<<i))==0) {\n					int nextmsk = msk|(1<<i);\n					long best = 0;\n					for(int k:all) {\n						best+=moves[i][k];\n					}\n					dp[nextmsk] = Math.min(dp[msk] + best, dp[nextmsk]);\n				}\n			}\n		}\n		out.println(dp[(1<<20)-1]);\n		out.close();\n	}\n	static class FastIO {\n		 \n		// Is your Fast I/O being bad?\n \n		InputStream dis;\n		byte[] buffer = new byte[1 << 17];\n		int pointer = 0;\n \n		public FastIO(String fileName) throws IOException {\n			dis = new FileInputStream(fileName);\n		}\n \n		public FastIO(InputStream is) throws IOException {\n			dis = is;\n		}\n \n		int nextInt() throws IOException {\n			int ret = 0;\n \n			byte b;\n			do {\n				b = nextByte();\n			} while (b <= ' ');\n			boolean negative = false;\n			if (b == '-') {\n				negative = true;\n				b = nextByte();\n			}\n			while (b >= '0' && b <= '9') {\n				ret = 10 * ret + b - '0';\n				b = nextByte();\n			}\n \n			return (negative) ? -ret : ret;\n		}\n \n		long nextLong() throws IOException {\n			long ret = 0;\n \n			byte b;\n			do {\n				b = nextByte();\n			} while (b <= ' ');\n			boolean negative = false;\n			if (b == '-') {\n				negative = true;\n				b = nextByte();\n			}\n			while (b >= '0' && b <= '9') {\n				ret = 10 * ret + b - '0';\n				b = nextByte();\n			}\n \n			return (negative) ? -ret : ret;\n		}\n \n		byte nextByte() throws IOException {\n			if (pointer == buffer.length) {\n				dis.read(buffer, 0, buffer.length);\n				pointer = 0;\n			}\n			return buffer[pointer++];\n		}\n \n		String next() throws IOException {\n			StringBuffer ret = new StringBuffer();\n \n			byte b;\n			do {\n				b = nextByte();\n			} while (b <= ' ');\n			while (b > ' ') {\n				ret.appendCodePoint(b);\n				b = nextByte();\n			}\n \n			return ret.toString();\n		}\n \n	}\n}","bitmasks,dp"
"/*\n        ""Everything in the universe is balanced. Every disappointment\n                you face in life will be balanced by something good for you!\n                        Keep going, never give up.""\n\n                        Just have Patience + 1...\n\n*/\n\n\n\n\n\n\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n\npublic class Solution {\n\n    static long INF = (long) 1e18;\n    static int MAX = 21;\n    static long[] dp = new long[1 << MAX];\n    static long[][] swapOperations = new long[MAX][MAX];\n    static List<Integer>[] positions = new List[MAX];\n\n    public static void main(String[] args) throws java.lang.Exception {\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        sc = new FastReader();\n\n        int test = 1;\n        for (int t = 1; t <= test; t++) {\n            solve();\n        }\n        out.close();\n    }\n\n    private static void solve() {\n        int n = sc.nextInt();\n        for (int i = 0; i < 20; i++) {\n            positions[i] = new ArrayList<>();\n        }\n\n        for (int i = 0; i < n; i++) {\n            int x = sc.nextInt() - 1;\n            positions[x].add(i);\n        }\n\n        for (int i = 0; i < 20; i++) {\n            for (int j = 0; j < 20; j++) {\n                if (i == j) {\n                    continue;\n                }\n                if (positions[i].size() == 0 || positions[j].size() == 0) {\n                    continue;\n                }\n                int posJ = 0;\n                for (int posI = 0; posI < positions[i].size(); posI++) {\n                    while (true) {\n                        if (posJ == positions[j].size() - 1 || positions[j].get(posJ + 1) > positions[i].get(posI)) {\n                            break;\n                        }\n                        posJ++;\n                    }\n                    if (positions[i].get(posI) > positions[j].get(posJ)) {\n                        swapOperations[i][j] += posJ + 1;\n                    }\n                }\n            }\n        }\n\n        Arrays.fill(dp, INF);\n        dp[0] = 0;\n        for (int mask = 0; mask < (1 << 20); mask++) {\n            List<Integer> prevOrder = new ArrayList<>();\n            for (int i = 0; i < 20; i++) {\n                if ((mask & (1 << i)) >= 1) {\n                    prevOrder.add(i);\n                }\n            }\n\n            for (int i = 0; i < 20; i++) {\n                if ((mask & (1 << i)) >= 1) {\n                    continue;\n                }\n\n                long swapsNeeded = 0;\n                // place after j\n                for (int j = 0; j < prevOrder.size(); j++) {\n                    swapsNeeded += swapOperations[prevOrder.get(j)][i];\n                }\n\n                int newMask = mask | (1 << i);\n                dp[newMask] = Math.min(dp[newMask], dp[mask] + swapsNeeded);\n            }\n        }\n\n        out.println(dp[(1 << 20) - 1]);\n    }\n\n\n    public static FastReader sc;\n    public static PrintWriter out;\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer str;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (str == null || !str.hasMoreElements())\n            {\n                try\n                {\n                    str = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  lastMonthOfVacation)\n                {\n                    lastMonthOfVacation.printStackTrace();\n                }\n            }\n            return str.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = """";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException lastMonthOfVacation)\n            {\n                lastMonthOfVacation.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}","bitmasks,dp"
"/*\n        ""Everything in the universe is balanced. Every disappointment\n                you face in life will be balanced by something good for you!\n                        Keep going, never give up.""\n\n                        Just have Patience + 1...\n\n*/\n\n\n\n\n\n\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n\npublic class Solution {\n\n    static long INF = (long) 1e18;\n    static int MAX = 21;\n\n    // dp[mask] is the minimum number of operations needed to rearrange the marbles\n    // such that all marbles from the mask of colors forms exactly one contiguous segment.\n    static long[] dp = new long[1 << MAX];\n\n    // swapOperations[i][j] is the minimum number of swaps needed to place all marbles of color i before all marbles of color j.\n    static long[][] swapOperations = new long[MAX][MAX];\n\n    // stores all the positions of different colors.\n    static List<Integer>[] positions = new List[MAX];\n\n    public static void main(String[] args) throws java.lang.Exception {\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        sc = new FastReader();\n\n        int test = 1;\n        for (int t = 1; t <= test; t++) {\n            solve();\n        }\n        out.close();\n    }\n\n    private static void solve() {\n        int n = sc.nextInt();\n        for (int i = 0; i < 20; i++) {\n            positions[i] = new ArrayList<>();\n        }\n\n        for (int i = 0; i < n; i++) {\n            int x = sc.nextInt() - 1;\n            positions[x].add(i);\n        }\n\n        for (int i = 0; i < 20; i++) {\n            for (int j = 0; j < 20; j++) {\n                if (i == j) {\n                    continue;\n                }\n                if (positions[i].size() == 0 || positions[j].size() == 0) {\n                    continue;\n                }\n                int posJ = 0;\n                for (int posI = 0; posI < positions[i].size(); posI++) {\n                    while (true) {\n                        if (posJ == positions[j].size() - 1 || positions[j].get(posJ + 1) > positions[i].get(posI)) {\n                            break;\n                        }\n                        posJ++;\n                    }\n                    if (positions[i].get(posI) > positions[j].get(posJ)) {\n                        swapOperations[i][j] += posJ + 1;\n                    }\n                }\n            }\n        }\n\n        Arrays.fill(dp, INF);\n        dp[0] = 0;\n        for (int mask = 0; mask < (1 << 20); mask++) { // for each already correctly ordered mask of colors\n            List<Integer> prevOrder = new ArrayList<>();\n            for (int i = 0; i < 20; i++) {\n                if ((mask & (1 << i)) >= 1) {\n                    prevOrder.add(i);\n                }\n            }\n\n            for (int i = 0; i < 20; i++) {\n                if ((mask & (1 << i)) >= 1) {\n                    continue;\n                }\n\n                long swapsNeeded = 0;\n                // correctly order all marbles of color i after all marbles of color j.\n                for (int j = 0; j < prevOrder.size(); j++) {\n                    swapsNeeded += swapOperations[prevOrder.get(j)][i];\n                }\n\n                int newMask = mask | (1 << i);\n                dp[newMask] = Math.min(dp[newMask], dp[mask] + swapsNeeded);\n            }\n        }\n\n        out.println(dp[(1 << 20) - 1]);\n    }\n\n\n    public static FastReader sc;\n    public static PrintWriter out;\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer str;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (str == null || !str.hasMoreElements())\n            {\n                try\n                {\n                    str = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  lastMonthOfVacation)\n                {\n                    lastMonthOfVacation.printStackTrace();\n                }\n            }\n            return str.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = """";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException lastMonthOfVacation)\n            {\n                lastMonthOfVacation.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}","bitmasks,dp"
"import java.io.*;\nimport java.util.*;\npublic class GFG {\n	public static void main (String[] args) {\n	Scanner sc=new Scanner(System.in);\n	    int n=sc.nextInt();\n	    String s=sc.next();\n	    String t=sc.next();\n	    String arr[]={""abc"",""acb"",""bac"",""bca"",""cab"",""cba""};\n	    int f=0;\n	    for(int i=0;i<6;i++)\n	    {\n	        String w=arr[i];\n	        String tmp1=""""+w.charAt(2)+w.charAt(0);\n	        if(n>1&&w.indexOf(s)==-1&&w.indexOf(t)==-1&&tmp1.indexOf(s)==-1&&tmp1.indexOf(t)==-1)\n	        {\n	        System.out.println(""YES"");\n	        for(int j=0;j<n;j++)\n	        System.out.print(w);\n	        System.out.println();f=1;break;\n	        }\n	        if(n==1&&w.indexOf(s)==-1&&w.indexOf(t)==-1)\n	        {\n	            System.out.println(""YES"");\n	            System.out.println(w);f=1;break;\n	        }\n	       String tmp=""aakbblcc"";\n	       if(w.indexOf(s)==-1&&w.indexOf(t)==-1&&tmp.indexOf(s)==-1&&tmp.indexOf(t)==-1){\n	           System.out.println(""YES"");\n	        for(int j=0;j<n;j++)\n	        System.out.print(arr[i].charAt(0));\n	        for(int j=0;j<n;j++)\n	       System.out.print(arr[i].charAt(1));\n	         for(int j=0;j<n;j++)\n	        System.out.print(arr[i].charAt(2));f=1;break;}\n	   }\n	   if(f==0)\n	   System.out.println(""NO"");\n	}\n}","brute force,constructive algorithms"
"import java.io.*;\nimport java.util.*;\n\npublic class Codeforces\n{\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb=new StringBuilder();\n        int n=Integer.parseInt(bu.readLine());\n        String pos[]={""abc"",""acb"",""bca"",""bac"",""cab"",""cba""};\n        char a[]=bu.readLine().toCharArray();\n        char b[]=bu.readLine().toCharArray();\n        if(a[0]!=a[1] && b[0]!=b[1])\n        {\n            for(String s:pos)\n            {\n                if((s.charAt(0)==a[0] && s.charAt(1)==a[1]) || (s.charAt(1)==a[0] && s.charAt(2)==a[1])) continue;\n                if((s.charAt(0)==b[0] && s.charAt(1)==b[1]) || (s.charAt(1)==b[0] && s.charAt(2)==b[1])) continue;\n                int i;\n                sb.append(""YES\n"");\n                for(i=0;i<n;i++) sb.append(s.charAt(0));\n                for(i=0;i<n;i++) sb.append(s.charAt(1));\n                for(i=0;i<n;i++) sb.append(s.charAt(2));\n                sb.append(""\n"");\n                System.out.print(sb);\n                return;\n            }\n            return;     //will never execute\n        }\n\n        int i,j,k; char c[]=new char[3]; boolean found=false;\n        for(i=0;i<3 && !found;i++)\n        for(j=0;j<3 && !found;j++)\n        if(j!=i)\n        for(k=0;k<3 && !found;k++)\n        if(k!=i && k!=j)\n        {\n            char x=(char)('a'+i),y=(char)('a'+j),z=(char)('a'+k);\n            if((a[0]==x && a[1]==y) || (a[0]==y && a[1]==x) || (a[0]==y && a[1]==z) || (a[0]==z && a[1]==z)) continue;\n            if((b[0]==x && b[1]==y) || (b[0]==y && b[1]==x) || (b[0]==y && b[1]==z) || (b[0]==z && b[1]==z)) continue;\n            c[0]=x; c[1]=y; c[2]=z;\n            found=true;\n        }\n\n        sb.append(""YES\n"");\n        for(i=0;i<2*n;i++)\n        if(i%2==0) sb.append(c[0]);\n        else sb.append(c[1]);\n        for(i=0;i<n;i++) sb.append(c[2]);\n        sb.append(""\n"");\n        System.out.print(sb);\n    }\n}","brute force,constructive algorithms"
"	import java.io.*;\n	import java.util.*;\n	public class new1{\n		static long mod = 1000000007;\n		public static long gcd(long a, long b)\n	    {\n	        if (a == 0)\n	            return b;\n	        return gcd(b%a, a);\n	    }\n		\n	\n		public static void main(String[] args)  throws IOException{\n	\n			BufferedWriter output = new BufferedWriter(new OutputStreamWriter(System.out));\n			FastReader s = new FastReader();\n			int t = 1;//s.nextInt();\n			for(int z = 0; z < t; z++) {\n				int n = s.nextInt();\n				String str1 = s.next();\n				String str2 = s.next();\n				boolean over = false;\n				\n				for(int i = 0; i < 3; i++) {\n					for(int j = 0; j < 3; j++) {\n						for(int k = 0; k < 3; k++) {\n							if(i != j && j != k && k != i && !over) {\n								String ch1 = Character.toString((char) (i + 'a'));\n								String ch2 = Character.toString((char) (j + 'a'));\n								String ch3 = Character.toString((char) (k + 'a'));\n								String[] st = {ch1 + ch2, ch3 + ch3, ch2 + ch1};\n								int count = 0;\n								for(int l = 0; l < 3; l++) {\n									String st1 = st[l];\n									if(!st1.equals(str1) && !st1.equals(str2)) count++;\n								}\n								\n								if(count == 3) {\n									\n									String st1 = ch2 + ch3;\n									if(!over && !st1.equals(str1) && !st1.equals(str2)) {\n										output.write(""YES"" +""\n"");\n										over = true;\n										for(int l = 0; l < n; l++) output.write(ch1+ch2);\n										for(int l = 0; l < n; l++) output.write(ch3);\n									}\n									st1 = ch3 + ch1;\n									if(!over && !st1.equals(str1) && !st1.equals(str2)) {\n										output.write(""YES"" +""\n"");\n										over = true;\n										for(int l = 0; l < n; l++) output.write(ch3);\n										for(int l = 0; l < n; l++) output.write(ch1+ch2);\n									}\n									if(!over) {\n										output.write(""YES"" +""\n"");\n										over = true;\n										output.write(ch1);\n										for(int l = 0; l < n; l++) output.write(ch3);\n										output.write(ch2);\n										for(int l = 0; l < n - 1; l++) output.write(ch1+ch2);\n									}\n									\n								}\n								\n								\n								\n								\n								\n							}\n						}\n					}\n				}\n				if(!over) output.write(""NO"");\n				\n						\n				\n			}\n			output.flush();\n		  }\n	}\n	\n	\n	 \n	class FastReader {\n	    BufferedReader br;\n	    StringTokenizer st;\n	    public FastReader() {\n	        br = new BufferedReader(new InputStreamReader(System.in));\n	    }\n	    String next() {\n	        while (st == null || !st.hasMoreElements()) {\n	            try {\n	                st = new StringTokenizer(br.readLine());\n	            } catch (IOException e) {\n	                e.printStackTrace();\n	            }\n	        }\n	        return st.nextToken();\n	    }\n	 \n	    public int nextInt() {\n	        return Integer.parseInt(next());\n	    }\n	 \n	    long nextLong() {\n	        return Long.parseLong(next());\n	    }\n	 \n	    double nextDouble() {\n	        return Double.parseDouble(next());\n	    }\n	 \n	    String nextLine() {\n	        String str = """";\n	        try {\n	            str = br.readLine();\n	        } catch (IOException e) {\n	            e.printStackTrace();\n	        }\n	        return str;\n	}}","brute force,constructive algorithms"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class Task {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            String s = in.next();\n            String t = in.next();\n            ArrayList<String> pats = new ArrayList<>();\n            for (char c1 = 'a'; c1 <= 'c'; c1++) {\n                for (char c2 = 'a'; c2 <= 'c'; c2++) {\n                    for (char c3 = 'a'; c3 <= 'c'; c3++) {\n                        if (c1 == c2 || c1 == c3 || c2 == c3) continue;\n                        StringBuilder pat = new StringBuilder();\n                        for (int i = 0; i < n; i++) {\n                            pat.append(c1).append(c2).append(c3);\n                        }\n                        String p1 = pat.toString();\n                        if (!p1.contains(s) && !p1.contains(t)) {\n                            out.println(""YES"");\n                            out.println(p1);\n                            return;\n                        }\n                        pat = new StringBuilder();\n                        for (int i = 0; i < n; i++) {\n                            pat.append(c1);\n                        }\n                        for (int i = 0; i < n; i++) {\n                            pat.append(c2);\n                        }\n                        for (int i = 0; i < n; i++) {\n                            pat.append(c3);\n                        }\n                        String p2 = pat.toString();\n                        if (!p2.contains(s) && !p2.contains(t)) {\n                            out.println(""YES"");\n                            out.println(p2);\n                            return;\n                        }\n                    }\n                }\n            }\n            out.println(""NO"");\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer stt;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        public String next() {\n            while (stt == null || !stt.hasMoreTokens()) {\n                stt = new StringTokenizer(nextLine());\n            }\n            return stt.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n","brute force,constructive algorithms"
"\n\nimport java.io.*;\nimport java.util.Scanner;\nimport java.util.Vector;\n\npublic class Main {\n    static long cd[] = new long[100100],rd[] = new long[100100];\n    public static void main(String[] args) throws IOException{\n        Scanner cin=new Scanner(System.in);\n        PrintWriter cout = new PrintWriter(System.out);\n        int n = cin.nextInt(),m = cin.nextInt();\n        Vector []g = new Vector[100100];\n        for (int i = 1; i <= n; i++) {\n            g[i] = new Vector();\n        }\n        for (int i = 1; i <= m; i++) {\n            int u = cin.nextInt(),v = cin.nextInt();\n            if (u > v) {\n                int t = u;\n                u = v;\n                v = t;\n            }\n            rd[u]++; cd[v]++;\n            g[u].addElement(v);\n        }\n        long ans = 0;\n        for (int i = 1; i <= n; i++) ans += rd[i]*cd[i];\n        int q = cin.nextInt();\n        cout.print(ans+""\n"");\n        while (q-- != 0) {\n            int t = cin.nextInt();\n            ans -= rd[t]*cd[t];\n            for (int i = 0; i < g[t].size(); i++) {\n                int pos = (int) g[t].elementAt(i);\n                ans -= rd[pos]*cd[pos];\n                cd[pos]--; cd[t]++;\n                rd[pos]++; rd[t]--;\n                ans += rd[pos]*cd[pos];\n                g[pos].addElement(t);\n            }\n            g[t].clear();\n            cout.print(ans+""\n"");\n        }\n        cin.close(); cout.close();\n    }\n}\n",graphs
"import java.io.*;\nimport java.util.*;\n\npublic class A {\n    FastScanner in;\n    PrintWriter out;\n\n    void solve() {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[] cntLeft = new int[n];\n        List<Integer>[] goRight = new List[n];\n        for (int i = 0; i < goRight.length; i++) {\n            goRight[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < m; i++) {\n            int x = in.nextInt() - 1;\n            int y = in.nextInt() - 1;\n            int fr = Math.min(x, y), to = Math.max(x, y);\n            cntLeft[to]++;\n            goRight[fr].add(to);\n        }\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            res += (long) cntLeft[i] * goRight[i].size();\n        }\n        out.println(res);\n        int q = in.nextInt();\n        for (int it = 0; it < q; it++) {\n            int id = in.nextInt() - 1;\n            for (int to : goRight[id]) {\n                res -= cntLeft[id];\n                res -= goRight[to].size();\n                goRight[to].add(id);\n                cntLeft[to]--;\n                res += cntLeft[to];\n            }\n            cntLeft[id] += goRight[id].size();\n            goRight[id].clear();\n            out.println(res);\n        }\n    }\n\n    void run() {\n        try {\n            in = new FastScanner(new File(""A.in""));\n            out = new PrintWriter(new File(""A.out""));\n\n            solve();\n\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void runIO() {\n\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new A().runIO();\n    }\n}",graphs
"import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.arraycopy;\nimport static java.lang.System.exit;\nimport static java.util.Arrays.copyOf;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.util.StringTokenizer;\n\npublic class D {\n\n	static class IntList {\n\n		int data[] = new int[3];\n		int size = 0;\n\n		boolean isEmpty() {\n			return size == 0;\n		}\n\n		int size() {\n			return size;\n		}\n\n		int get(int index) {\n			if (index < 0 || index >= size) {\n				throw new IndexOutOfBoundsException();\n			}\n			return data[index];\n		}\n\n		void clear() {\n			size = 0;\n		}\n\n		void set(int index, int value) {\n			if (index < 0 || index >= size) {\n				throw new IndexOutOfBoundsException();\n			}\n			data[index] = value;\n		}\n\n		void expand() {\n			if (size >= data.length) {\n				data = copyOf(data, (data.length << 1) + 1);\n			}\n		}\n\n		void insert(int index, int value) {\n			if (index < 0 || index > size) {\n				throw new IndexOutOfBoundsException();\n			}\n			expand();\n			arraycopy(data, index, data, index + 1, size++ - index);\n			data[index] = value;\n		}\n\n		int delete(int index) {\n			if (index < 0 || index >= size) {\n				throw new IndexOutOfBoundsException();\n			}\n			int value = data[index];\n			arraycopy(data, index + 1, data, index, --size - index);\n			return value;\n		}\n\n		void push(int value) {\n			expand();\n			data[size++] = value;\n		}\n\n		int pop() {\n			if (size == 0) {\n				throw new NoSuchElementException();\n			}\n			return data[--size];\n		}\n\n		void unshift(int value) {\n			expand();\n			arraycopy(data, 0, data, 1, size++);\n			data[0] = value;\n		}\n\n		int shift() {\n			if (size == 0) {\n				throw new NoSuchElementException();\n			}\n			int value = data[0];\n			arraycopy(data, 1, data, 0, --size);\n			return value;\n		}\n	}\n\n	static void solve() throws Exception {\n		int n = scanInt(), m = scanInt();\n		IntList higherBad[] = new IntList[n];\n		for (int i = 0; i < n; i++) {\n			higherBad[i] = new IntList();\n		}\n		int nBad[] = new int[n];\n		for (int i = 0; i < m; i++) {\n			int a = scanInt() - 1, b = scanInt() - 1;\n			if (a > b) {\n				int t = a;\n				a = b;\n				b = t;\n			}\n			higherBad[a].push(b);\n			++nBad[a];\n			++nBad[b];\n		}\n		long ans = 0, pans[] = new long[n];\n		for (int i = 0; i < n; i++) {\n			ans += pans[i] = (long) (nBad[i] - higherBad[i].size()) * higherBad[i].size();\n		}\n		out.println(ans);\n		int q = scanInt();\n		for (int qq = 0; qq < q; qq++) {\n			int cur = scanInt() - 1;\n			ans -= pans[cur];\n			pans[cur] = 0;\n			for (int i = 0; i < higherBad[cur].size; i++) {\n				int e = higherBad[cur].data[i];\n				higherBad[e].push(cur);\n				ans -= pans[e];\n				ans += pans[e] = (long) (nBad[e] - higherBad[e].size()) * higherBad[e].size();\n			}\n			higherBad[cur].clear();\n			out.println(ans);\n		}\n	}\n\n	static int scanInt() throws IOException {\n		return parseInt(scanString());\n	}\n\n	static long scanLong() throws IOException {\n		return parseLong(scanString());\n	}\n\n	static String scanString() throws IOException {\n		while (tok == null || !tok.hasMoreTokens()) {\n			tok = new StringTokenizer(in.readLine());\n		}\n		return tok.nextToken();\n	}\n\n	static BufferedReader in;\n	static PrintWriter out;\n	static StringTokenizer tok;\n\n	public static void main(String[] args) {\n		try {\n			in = new BufferedReader(new InputStreamReader(System.in));\n			out = new PrintWriter(System.out);\n			solve();\n			in.close();\n			out.close();\n		} catch (Throwable e) {\n			e.printStackTrace();\n			exit(1);\n		}\n	}\n}",graphs
"import java.util.*;\nimport java.io.*;\n\npublic class D1210 {\n    static Stack<Integer>[] adjList;\n\n    public static void main(String[] args) throws IOException {\n        Reader sc = new Reader();\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        adjList = new Stack[n];\n        int[] in = new int[n];\n        int[] out = new int[n];\n        for (int i = 0; i < n; i++) {\n            adjList[i] = new Stack<>();\n        }\n        while (m-- > 0) {\n            int u = sc.nextInt() - 1;\n            int v = sc.nextInt() - 1;\n            adjList[Math.min(u, v)].add(Math.max(u, v));\n            out[Math.min(u, v)]++;\n            in[Math.max(u, v)]++;\n        }\n        long ans = 0;\n        for (int i = 0; i < n; i++) {\n            ans += 1L * in[i] * out[i];\n        }\n        pw.println(ans);\n        int q = sc.nextInt();\n        while (q-- > 0) {\n            int v = sc.nextInt() - 1;\n            while (!adjList[v].isEmpty()) {\n                int cur = adjList[v].pop();\n                ans += in[cur] - out[cur] - 1;\n                ans += -in[v] + out[v] - 1;\n                in[cur]--;\n                out[cur]++;\n                in[v]++;\n                out[v]--;\n                adjList[cur].add(v);\n            }\n            pw.println(ans);\n        }\n        pw.close();\n\n    }\n\n    static class Reader {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException {\n            din = new DataInputStream(\n                    new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\n') {\n                    if (cnt != 0) {\n                        break;\n                    } else {\n                        continue;\n                    }\n                }\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0,\n                    BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n}",graphs
"import java.util.*;\nimport java.io.*;\n\npublic class _1208_D {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        int n = Integer.parseInt(in.readLine());\n        long[] p = new long[n];\n        long[] a = new long[n + 1];\n        StringTokenizer line = new StringTokenizer(in.readLine());\n        for(int i = 0; i < n; i++) {\n            p[i] = Long.parseLong(line.nextToken());\n            a[i + 1] = i + 1;\n        }\n        int[] res = new int[n];\n        BIT bit = new BIT(a);\n        for(int i = n - 1; i >= 0; i--) {\n            int ind = bit.bsearch(p[i]) + 1;\n            res[i] = ind;\n            bit.update(ind, -ind);\n        }\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i < n; i++) {\n            sb.append(res[i]);\n            sb.append(' ');\n        }\n        out.println(sb.toString());\n        in.close();\n        out.close();\n    }\n    static class BIT {\n        long[] bit;\n        BIT(long[] a) {\n            bit = new long[a.length + 1];\n            for(int i = 0; i < a.length; i++) {\n                update(i, a[i]);\n            }\n        }\n        void update(int index, long add) {\n            index++;\n            while(index < bit.length) {\n                bit[index] += add;\n                index += index & -index;\n            }\n        }\n        long sum(int index) {\n            index++;\n            long res = 0;\n            while(index > 0) {\n                res += bit[index];\n                index -= index & -index;\n            }\n            return res;\n        }\n        int bsearch(long val) {\n            int l = 0;\n            int r = bit.length - 1;\n            int res = -1;\n            while(l <= r) {\n                int avg = (l + r) / 2;\n                if(sum(avg) <= val) {\n                    res = avg;\n                    l = avg + 1;\n                }else {\n                    r = avg - 1;\n                }\n            }\n            return res;\n        }\n    }\n}\n","binary search,data structures,greedy,implementation"
"import java.io.DataInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class P1208D9 {\n    public static void main(String[] args) throws IOException {\n        InputReader2 ir = new InputReader2();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = ir.nextInt();\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = ir.nextLong();\n        }\n\n        Fenwick f = new Fenwick(n);\n        for (int i = 1; i <= n; i++) {\n            f.add(i, i);\n        }\n        int[] list = new int[n];\n        for (int i = n - 1; i >= 0; i--) {\n            int ind = f.indexWithGivenCumFreq(a[i]);\n            f.add(ind, -ind);\n            list[i] = ind;\n        }\n\n        for (int i = 0; i < n; i++) {\n            pw.print(list[i] + "" "");\n        }\n        pw.close();\n    }\n\n    static class Fenwick {\n        public final long[] bit;\n        public final int size;\n\n        public Fenwick(int size) {\n            this.size = size + 1;\n            bit = new long[this.size];\n        }\n\n        public void add(int i, long delta) {\n            for (++i; i < size; i += (i & -i)) {\n                bit[i] += delta;\n            }\n        }\n\n        public int indexWithGivenCumFreq(long v) {\n            int i = 0, n = size;\n            for (int b = Integer.highestOneBit(n); b != 0; b >>= 1) {\n                if ((i | b) < n && bit[i | b] <= v) {\n                    i |= b;\n                    v -= bit[i];\n                }\n            }\n            return i;\n        }\n    }\n\n    private static class InputReader2 {\n        final private int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream dis;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public InputReader2() {\n            dis = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        private int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            return ret;\n        }\n\n        private long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = dis.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n    }\n}\n","binary search,data structures,greedy,implementation"
"import java.io.DataInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class P1208D7 {\n    public static void main(String[] args) throws IOException {\n        InputReader2 ir = new InputReader2();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = ir.nextInt();\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = ir.nextLong();\n        }\n\n        Fenwick f = new Fenwick(n);\n        for (int i = 1; i <= n; i++) {\n            f.add(i - 1, i);\n        }\n        int[] list = new int[n];\n        for (int i = n - 1; i >= 0; i--) {\n            int ind = f.indexWithGivenCumFreq(a[i]);\n            f.add(ind, -(ind + 1));\n            list[i] = ind + 1;\n        }\n\n        for (int i = 0; i < n; i++) {\n            pw.print(list[i] + "" "");\n        }\n        pw.close();\n    }\n\n    static class Fenwick {\n        public final long[] bit;\n        public final int size;\n\n        public Fenwick(int size) {\n            bit = new long[size + 1];\n            this.size = size + 1;\n        }\n\n        public void add(int i, long delta) {\n            for (++i; i < size; i += (i & -i)) {\n                bit[i] += delta;\n            }\n        }\n\n        public int indexWithGivenCumFreq(long v) {\n            int i = 0, n = size;\n            for (int b = Integer.highestOneBit(n); b != 0; b >>= 1) {\n                if ((i | b) < n && bit[i | b] <= v) {\n                    i |= b;\n                    v -= bit[i];\n                }\n            }\n            return i;\n        }\n    }\n\n    private static class InputReader2 {\n        final private int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream dis;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public InputReader2() {\n            dis = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        private int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            return ret;\n        }\n\n        private long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = dis.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n    }\n}\n","binary search,data structures,greedy,implementation"
"import java.io.DataInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class P1208D4 {\n    public static void main(String[] args) throws IOException {\n        InputReader2 ir = new InputReader2();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = ir.nextInt();\n        long[] s = new long[n];\n        for (int i = 0; i < n; i++) {\n            s[i] = ir.nextLong();\n        }\n\n        BIT tree = new BIT(n);\n        for (int i = 1; i <= n; i++) {\n            tree.add(i, i);\n        }\n        int[] ans = new int[n];\n        for (int i = n - 1; i >= 0; i--) {\n            long cur = s[i];\n            if (cur == 0) {\n                ans[i] = binSearch(tree, 0, n);\n            } else {\n                ans[i] = binSearch(tree, cur, n);\n            }\n            tree.remove(ans[i]);\n        }\n\n        for (int an : ans) {\n            pw.print(an + "" "");\n        }\n        pw.close();\n    }\n\n    private static int binSearch(BIT tree, long key, int n) {\n        int low = 1, high = n;\n\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            long amt = tree.prefixSum(mid);\n            if (amt <= key) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        return low;\n    }\n\n    public static class BIT {\n        final int N;\n        private final long[] tree;\n\n        public BIT(int sz) {\n            tree = new long[(N = sz + 1)];\n        }\n\n        private static int lsb(int i) {\n            return i & -i;\n        }\n\n        private long prefixSum(int i) {\n            long sum = 0L;\n            while (i != 0) {\n                sum += tree[i];\n                i &= ~lsb(i);\n            }\n            return sum;\n        }\n\n        public void add(int i, long v) {\n            while (i < N) {\n                tree[i] += v;\n                i += lsb(i);\n            }\n        }\n\n        public void remove(int i) {\n            add(i, -(prefixSum(i) - prefixSum(i - 1)));\n        }\n    }\n\n    private static class InputReader2 {\n        final private int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream dis;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public InputReader2() {\n            dis = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        private int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            return ret;\n        }\n\n        private long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = dis.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n    }\n}\n","binary search,data structures,greedy,implementation"
"import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\npublic class Main \n{\n	public static void main(String[] args) throws IOException \n	{\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n		int n = Integer.parseInt(br.readLine());\n		int[][] ans = new int[n][n];\n		for(int step = 0, base = 0; step < n / 4 ; step++)\n		{\n			for(int i = 0 ; i < n ; i++)\n			{\n				for(int j = 4 * step ; j < 4 * (step + 1) ; j++)\n				{\n					ans[i][j] = base;\n					++base;\n				}\n			}\n		}\n		for(int i = 0 ; i < n ; i++)\n		{\n			for(int j = 0 ; j < n ; j++)\n				bw.write(Integer.toString(ans[i][j]) + "" "");\n			bw.write('\n');\n		}\n		bw.flush();\n	}\n}\n",constructive algorithms
"import java.io.*;\nimport java.util.*;\n\npublic class C {\n\n	public static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n	public static void main(String[] args) throws IOException {\n		// br = new BufferedReader(new FileReader("".in""));\n		// out = new PrintWriter(new FileWriter("".out""));\n		int n = Integer.parseInt(br.readLine());\n		int[][] copy = {\n			{8, 9, 1, 13},\n			{3, 12, 7, 5},\n			{0, 2, 4, 11},\n			{6, 10, 15, 14}\n		};\n		\n		int bias = 0;\n		\n		int[][] ans = new int[n][n];\n		\n		for (int i = 0; i < n; i+=4) {\n			for (int j = 0; j < n; j+=4) {\n				for (int k = i; k < i+4; k++) {\n					for (int l = j; l < j+4; l++) {\n						ans[k][l] = copy[k-i][l-j]+bias;\n					}\n				}\n				\n				bias += 16;\n			}	\n		}\n		\n		for (int[] x: ans) {\n			for (int y: x) out.print(y + "" "");\n			out.println();\n		}\n		\n		out.close();\n	}\n\n}\n",constructive algorithms
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Kraken\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    Scanner in = new Scanner(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskC solver = new TaskC();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskC {\n\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n      int n = in.nextInt();\n      long curr = 0;\n      long[][] mat = new long[n][n];\n      for (int i = 0; i < n / 2; i++) {\n        for (int j = 0; j < n / 2; j++) {\n          mat[i][j] = 4 * curr + 1;\n          mat[i][j + n / 2] = 4 * curr + 2;\n          mat[i + n / 2][j] = 4 * curr + 3;\n          mat[i + n / 2][j + n / 2] = 4 * curr;\n\n          curr++;\n        }\n      }\n\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n          out.print(mat[i][j] + "" "");\n        }\n        out.println();\n      }\n    }\n\n  }\n}\n\n",constructive algorithms
"import java.util.*;\nimport java.io.*;\n\npublic class File {\n	\n	public static class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n		\n		public FastScanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n		\n		String next() {\n			while (st == null || !st.hasMoreElements()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				}\n				catch (IOException e) {\n					e.printStackTrace();\n				}\n			}\n			\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n	}\n	\n	public static void main(String[] args) {\n		FastScanner sc = new FastScanner();\n		PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n		\n		\n		\n		int N = sc.nextInt();\n		int[][] board = new int[N][N];\n		int val = 0;\n		\n		for (int i = 0; i < N/2; i++) {\n			for (int j = 0; j < N/2; j++) {\n				\n				board[i][j] = val*4 + 1;\n				board[i][j + N/2] = val*4 + 2;\n				board[i + N/2][j] = val*4 + 3;\n				board[i + N/2][j + N/2] = val*4;\n				\n				val++;\n			}\n		}\n		\n		for (int i = 0; i < N; i++) {\n			for (int j = 0; j < N; j++) {\n				out.print(board[i][j] + "" "");\n			}\n			\n			out.println();\n		}\n		\n		\n		out.close();\n	}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",constructive algorithms
"public class B{\n    public static void main(String[] args){\n        var sc = new java.util.Scanner(System.in);\n        StringBuilder sb = new StringBuilder();\n        int n = sc.nextInt(),m=sc.nextInt(),c=0,a[][]=new int[n][m],b[][]=new int[n][m];\n        for (int i=0;i<n;i++) for(int j=0;j<m;j++) a[i][j]=sc.nextInt();\n        for (int i=0;i<n-1;i++)\n            for (int j = 0; j<m-1; j++)\n                if (a[i][j]==a[i+1][j+1]&&a[i][j]==a[i+1][j]&&a[i][j]==a[i][j+1]&&a[i][j]==1) {\n                    c++;\n                    sb.append(""\n""+(i+1)+"" ""+(j+1));\n                    b[i][j]=b[i+1][j]=b[i][j+1]=b[i+1][j+1]=1;\n                }\n        for (int i=0;i<n;i++) for(int j=0;j<m;j++) if(a[i][j]!=b[i][j]) { System.out.println(-1); return;}\n        System.out.println(c+""""+sb);\n    }\n}","constructive algorithms,greedy,implementation"
"import java.util.*;\npublic class hxdb\n{\npublic static void main(String[] args)\n{\nScanner in=new Scanner(System.in);\nint n=in.nextInt();\nint m=in.nextInt();\nint a[][]=new int[n+1][m+1];\nint b[][]=new int[n+1][m+1];\nint i,j,x=0;\nfor(i=1;i<=n;i++)\n{\nfor(j=1;j<=m;j++)\n	a[i][j]=in.nextInt();\n}\nArrayList<Integer> p=new ArrayList<Integer>();\nArrayList<Integer> q=new ArrayList<Integer>();\nfor(i=1;i<n;i++)\n{\nfor(j=1;j<m;j++)\n{\nif(a[i][j]==1&&a[i+1][j]==1&&a[i][j+1]==1&&a[i+1][j+1]==1)\n{\nb[i][j]=1;\nb[i][j+1]=1;\nb[i+1][j]=1;\nb[i+1][j+1]=1;\np.add(i);\nq.add(j);\n}\n}\n}\nfor(i=1;i<=n;i++)\n{\nfor(j=1;j<=m;j++)\n{\nif(a[i][j]!=b[i][j])\n{\n	x=-1;\n	break;\n}\n}\n}\nif(x==-1)\n	System.out.println(-1);\nelse\n{\n	System.out.println(p.size());\n	for(i=0;i<p.size();i++)\n		System.out.println(p.get(i)+"" ""+q.get(i));\n}\n}\n}\n	\n	\n","constructive algorithms,greedy,implementation"
"import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main \n{\n	public static class Pair\n	{\n		public int first;\n		public int second;\n		public Pair(int first, int second)\n		{\n			this.first = first;\n			this.second = second;\n		}\n	}\n	public static void main(String[] args) \n	{\n		Scanner scanner = new Scanner(System.in);\n		int n = scanner.nextInt();\n		int m = scanner.nextInt();\n		int[][] a = new int[n][m];\n		int[][] b = new int[n][m];\n		ArrayList<Pair> solution = new ArrayList<>();\n		for(int i = 0 ; i < n ; i++)\n			for(int j = 0 ; j < m ; j++)\n				a[i][j] = scanner.nextInt();\n		for(int i = 0 ; i < n - 1 ; i++)\n		{\n			for(int j = 0 ; j < m - 1 ; j++)\n			{\n				int sum = 0;\n				for(int t1 = i ; t1 < i + 2 ; t1++)\n					for(int t2 = j ; t2 < j + 2 ; t2++)\n						sum += a[t1][t2];\n				if(sum == 4)\n				{\n					solution.add(new Pair(i + 1, j + 1));\n					for(int t1 = i ; t1 < i + 2 ; t1++)\n						for(int t2 = j ; t2 < j + 2 ; t2++)\n							b[t1][t2] = 1;\n				}\n			}\n		}\n		for(int i = 0 ; i < n ; i++)\n			for(int j = 0 ; j < m ; j++)\n				if(a[i][j] != b[i][j])\n				{\n					System.out.println(-1);\n					return;\n				}\n		System.out.println(solution.size());\n		for(Pair p : solution)\n			System.out.println(p.first + "" "" + p.second);\n		\n		scanner.close();\n	}\n}\n","constructive algorithms,greedy,implementation"
"\n\nimport java.util.Scanner;\nimport static java.lang.Math.*;\nimport java.util.List;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.HashMap;\n\npublic class square_filling{\n\n static int n, m;\n static boolean[][] A, B;\n static Scanner scanner = new Scanner(System.in);\n \n\n static boolean check(){\n\n      for(int i = 0; i < n; ++i)\n        for(int j = 0; j < m; ++j)\n            if(A[i][j] != B[i][j])\n                return false;\n\n    return true;\n }\n\n public static void main(String[] args) {\n     \n\n  n = scanner.nextInt();\n  m = scanner.nextInt();\n  A = new boolean[n][m];\n  B = new boolean[n][m];\n\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < m; ++j){\n\n        \n        A[i][j] = scanner.nextInt() == 1;\n    }\n\n  String ans = ""\n"";\n  int counter = 0;\n\n   for(int i = 0; i < n - 1; ++i)\n       for(int j = 0; j < m - 1; ++j)\n           if(A[i][j] && A[i][j + 1] && A[i + 1][j] && A[i + 1][j + 1]){\n\n               B[i][j] = B[i + 1][j] = B[i][j + 1] = B[i + 1][j + 1] = true; \n               ++counter;\n               ans += (i + 1) + "" "" + (j + 1);\n               ans += ""\n""; \n           } \n\n    if(check()){\n        System.out.println(counter + ans);\n    }\n    else\n    {\n        System.out.println(-1);\n    }\n}\n\n\n}","constructive algorithms,greedy,implementation"
"import java.util.*;\n\npublic class Main\n{\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int m1=-1,m2=-1;\n		for(int i=0;i<n;i++)\n		m1=Math.max(m1,sc.nextInt());\n		int m=sc.nextInt();\n		for(int i=0;i<m;i++)\n		m2=Math.max(m2,sc.nextInt());\n		System.out.println(m1+"" ""+m2);\n	}\n}\n","math,sortings"
"import java.util.*;\n\npublic class Main\n{\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int m1=-1,m2=-1;\n		for(int i=0;i<n;i++)\n		m1=Math.max(m1,sc.nextInt());\n		int m=sc.nextInt();\n		for(int i=0;i<m;i++)\n		m2=Math.max(m2,sc.nextInt());\n		System.out.println(m1+"" ""+m2);\n	}\n}\n","math,sortings"
"import java.util.*;\n\npublic class Mainn\n{\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int m1=-1,m2=-1;\n		for(int i=0;i<n;i++)\n		m1=Math.max(m1,sc.nextInt());\n		int m=sc.nextInt();\n		for(int i=0;i<m;i++)\n		m2=Math.max(m2,sc.nextInt());\n		System.out.println(m1+"" ""+m2);\n	}\n}\n","math,sortings"
"import java.util.*;\n\npublic class dc {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n	int n=sc.nextInt();\n	int[] l=new int[n];\n	for(int i=0;i<n;i++) {\n		l[i]=sc.nextInt();\n	}int m=sc.nextInt();\n	int[] h=new int[m];\n		for(int k=0;k<m;k++) {\n			h[k]=sc.nextInt();\n		}Arrays.sort(l);\n		Arrays.sort(h);\n		System.out.println(l[n-1]+"" ""+h[m-1]);\n\n}}","math,sortings"
"import java.io.*;\nimport java.util.*;\npublic class Main {  \n	public static void main(String[] args) {\n		FastScanner sc = new FastScanner();\n		PrintWriter out = new PrintWriter(System.out);\n		String str = sc.next();char ch[]=str.toCharArray();\n		int c0=0,c1=0;\n		for(int i=str.length()-1 ; i>=0 ; i--) {\n			if(ch[i]=='0') {\n				c0++;\n			}\n			else {\n				c1++;\n				if(c1 > c0) {\n					ch[i]='0';c1--;\n				}\n			}\n		}\n		for(int i=0 ; i<str.length() ; i++) {\n			out.print(ch[i]);\n		}\n		out.flush();\n		out.close();\n	}\n	static class FastScanner {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n		String next() {\n			while (!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		int [] readArray(int n) {\n			int[] a=new int[n];\n			for (int i=0; i<n; i++) a[i]=nextInt();\n			return a;\n		}\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n	}\n} \nclass MyComparator implements Comparator<Pair> {\n	public int compare(Pair a, Pair b) {\n		return (int)a.first - (int)b.first;\n	}\n}\n\nclass Pair\n{\n    int first,second;\n    Pair(int first,int second)\n    {\n        this.first=first;\n        this.second=second;\n    }\n}\n","brute force,greedy,strings"
"import java.util.*;\nimport java.io.*;\npublic class Main {\n    static class Scan {\n        private byte[] buf=new byte[1024];\n        private int index;\n        private InputStream in;\n        private int total;\n        public Scan()\n        {\n            in=System.in;\n        }\n        public int scan()throws IOException\n        {\n            if(total<0)\n            throw new InputMismatchException();\n            if(index>=total)\n            {\n                index=0;\n                total=in.read(buf);\n                if(total<=0)\n                return -1;\n            }\n            return buf[index++];\n        }\n        public int scanInt()throws IOException\n        {\n            int integer=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n))\n            {\n                if(n>='0'&&n<='9')\n                {\n                    integer*=10;\n                    integer+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            return neg*integer;\n        }\n        public double scanDouble()throws IOException\n        {\n            double doub=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n)&&n!='.')\n            {\n                if(n>='0'&&n<='9')\n                {\n                    doub*=10;\n                    doub+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            if(n=='.')\n            {\n                n=scan();\n                double temp=1;\n                while(!isWhiteSpace(n))\n                {\n                    if(n>='0'&&n<='9')\n                    {\n                        temp/=10;\n                        doub+=(n-'0')*temp;\n                        n=scan();\n                    }\n                    else throw new InputMismatchException();\n                }\n            }\n            return doub*neg;\n        }\n        public String scanString()throws IOException\n        {\n            StringBuilder sb=new StringBuilder();\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            while(!isWhiteSpace(n))\n            {\n                sb.append((char)n);\n                n=scan();\n            }\n            return sb.toString();\n        }\n        private boolean isWhiteSpace(int n)\n        {\n            if(n==' '||n=='\n'||n=='\r'||n=='\t'||n==-1)\n            return true;\n            return false;\n        }\n    }\n    \n    public static void sort(int arr[],int l,int r) {    //sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(int arr[],int l1,int r1,int l2,int r2) {\n        int tmp[]=new int[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        //sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        //Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n    \n    public static void sort(long arr[],int l,int r) {    //sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(long arr[],int l1,int r1,int l2,int r2) {\n        long tmp[]=new long[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        //sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        //Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n    public static void main(String args[]) throws IOException {\n        Scan input=new Scan();\n        StringBuilder str=new StringBuilder(input.scanString());\n        StringBuilder cpy=new StringBuilder(str);\n        StringBuilder ans=new StringBuilder("""");\n        ArrayList<Integer> arrli=new ArrayList<>();\n        for(int i=0;i<str.length();i++) {\n            arrli.add(i);\n        }\n        while(true) {\n            boolean done=false;\n            for(int i=0;i<cpy.length()-1;i++) {\n                if(cpy.charAt(i)=='1' && cpy.charAt(i+1)=='0') {\n                    cpy.delete(i, i+2);\n                    arrli.remove(i);\n                    arrli.remove(i);\n                    done=true;\n                    break;\n                }\n            }\n            if(!done) {\n                break;\n            }\n        }\n        for(int i=0;i<str.length();i++) {\n            if(arrli.size()>0 && arrli.get(0)==i) {\n                ans.append(0);\n                arrli.remove(0);\n                continue;\n            }\n            ans.append(str.charAt(i));\n        }\n        System.out.println(ans);\n    }\n}\n","brute force,greedy,strings"
"import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1204d1 {\n\n    public static void main(String[] args) throws IOException {\n        char[] s = rcha();\n        int n = s.length, bal = 0;\n        for (int i = n - 1; i >= 0; --i) {\n            if (s[i] == '0') {\n                ++bal;\n            } else if (bal > 0) {\n                --bal;\n            } else {\n                s[i] = '0';\n            }\n        }\n        prln(s);\n        close();\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int lcm(int a, int b) {return a * b / gcf(a, b);}\n    static long lcm(long a, long b) {return a * b / gcf(a, b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {prln(""yes"");}\n    static void pry() {prln(""Yes"");}\n    static void prY() {prln(""YES"");}\n    static void prno() {prln(""no"");}\n    static void prn() {prln(""No"");}\n    static void prN() {prln(""NO"");}\n    static boolean pryesno(boolean b) {prln(b ? ""yes"" : ""no""); return b;};\n    static boolean pryn(boolean b) {prln(b ? ""Yes"" : ""No""); return b;}\n    static boolean prYN(boolean b) {prln(b ? ""YES"" : ""NO""); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(""hlfd""); flush();}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}\n}","brute force,greedy,strings"
import java.util.*;\npublic class kirksubstring {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\nScanner sc=new Scanner(System.in);\nString st=sc.nextLine();\nchar s[]=st.toCharArray();\nint c=0;\nfor(int i=s.length-1;i>=0;i--)\n{\n	if(s[i]=='0')\n		c++;\n	else\n	{\n		if(c!=0)\n			c--;\n		else\n			s[i]='0';\n	}\n}\nSystem.out.println(s);\n	}\n\n}\n,"brute force,greedy,strings"
"import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class F{\n	\n	static int n;\n	static char[][] c;\n	static int[][] p;\n	static int[][][][] dp;\n	\n	static int query(int x, int y, int x2, int y2) {\n		return p[x2+1][y2+1] - p[x2+1][y] - p[x][y2+1] + p[x][y];\n	}\n	\n	static int solve(int x, int y, int x2, int y2) {\n		if (x > x2 || y > y2) return 0;\n		if (dp[x][y][x2][y2] == -1) {\n			int ans = max(x2-x+1,y2-y+1);\n			if (query(x,y,x2,y2) == 0) return dp[x][y][x2][y2] = 0;\n			if (x==x2 || y==y2) {\n				return dp[x][y][x2][y2] = query(x,y,x2,y2);\n			}\n			// if this has no black things return 0\n			// if everything is on one line answer is number of guys on the line (lower bounded)\n			\n			// iterate on row breaks			\n			\n			for (int i = y; i <= y2; i++) {\n				int prev = i-1;\n				int next = i+1;\n				if (query(x,i,x2,i)!=0) continue;\n				int ot = solve(x, y, x2, prev) + solve(x, next,x2,y2);\n				if (max(x,y) == 0 && min(x2,y2) == n-1) {\n					//System.out.println(""Yo "" + ot + "" "" + prev  + "" "" + next);\n				}\n				ans = min(ans, ot);\n			}\n			\n			// iterate on col breaks\n			for (int i = x; i <=x2; i++) {\n				int prev = i-1;\n				int next = i+1;\n				if (query(i, y, i, y2) != 0) continue;\n				int ot = solve(x, y, prev, y2) + solve(next, y, x2, y2);\n				ans = min(ans, ot);\n			}\n			\n			\n			dp[x][y][x2][y2] = ans;\n		}\n		return dp[x][y][x2][y2];\n	}\n	\n	public static void main(String[] args) throws IOException{\n		// br = new BufferedReader(new FileReader("".in""));\n		// out = new PrintWriter(new FileWriter("".out""));\n		// new Thread(null, new (), ""fisa balls"", 1<<28).start();\n		\n		n =readInt();\n		dp = new int[n][n][n][n];\n		c = new char[n][n];\n		for (int i = 0; i < n; i++) c[i]=read().toCharArray();\n		p = new int[n+1][n+1];\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < n; j++) if (c[i][j] == '#')p[i+1][j+1]++;\n		}\n		\n		for (int i = 1; i <= n; i++) {\n			for (int j = 1; j <= n; j++) {\n				p[i][j] += p[i-1][j] + p[i][j-1] - p[i-1][j-1];\n			}\n		}\n				\n		for (int[][][] x: dp) for(int[][] y: x) for (int[] z: y) Arrays.fill(z, -1);\n		out.println(solve(0,0,n-1,n-1));\n		\n		out.close();\n	}\n	\n	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n	static StringTokenizer st = new StringTokenizer("""");\n	static String read() throws IOException{\n		while (!st.hasMoreElements()) st = new StringTokenizer(br.readLine());\n		return st.nextToken();\n	}\n	public static int readInt() throws IOException{return Integer.parseInt(read());}\n	public static long readLong() throws IOException{return Long.parseLong(read());}\n}",dp
"import java.util.*;\nimport java.io.*;\n\npublic class D576 {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int n = sc.nextInt();\n        int [][][][] dp = new int[n][n][n][n];\n        int [][] a = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            String s = sc.next();\n            for (int j = 0; j < n; j++) {\n                if (s.charAt(j) == '#') {\n                    a[i][j] = 1;\n                    dp[i][i][j][j] = 1;\n                }\n            }\n        }\n        for (int r = 1; r <= n; r++) {\n            for (int c = 1; c <= n; c++) {\n                for (int i = 0; i <= n - r; i++) {\n                    for (int j = 0; j <= n - c; j++) {\n                        if (r == 1 && c == 1) continue;\n                        int hr = i + r - 1;\n                        int hc = j + c - 1;\n                        dp[i][hr][j][hc] = Math.max(hr - i + 1, hc - j + 1);\n                        for (int split = i; split <= hr - 1; split++) {\n                            dp[i][hr][j][hc] = Math.min(dp[i][hr][j][hc], dp[i][split][j][hc] + dp[split + 1][hr][j][hc]);\n                        }\n                        for (int split = j; split <= hc - 1; split++) {\n                            dp[i][hr][j][hc] = Math.min(dp[i][hr][j][hc], dp[i][hr][j][split] + dp[i][hr][split + 1][hc]);\n                        }\n                    }\n                }\n            }\n        }\n        out.println(dp[0][n - 1][0][n - 1]);\n        out.close();\n    }\n\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n\n    }\n\n}",dp
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Jaynil\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        int[][][][] dp;\n        char[][] c;\n\n        public int solve(int x1, int x2, int y1, int y2) {\n            if (dp[x1][x2][y1][y2] != -1) return dp[x1][x2][y1][y2];\n            dp[x1][x2][y1][y2] = Math.max(x2 - x1 + 1, y2 - y1 + 1);\n            if (x1 == x2 && y1 == y2) dp[x1][x2][y1][y1] = c[x1][y1] == '#' ? 1 : 0;\n            for (int i = x1; i < x2; i++) {\n                dp[x1][x2][y1][y2] = Math.min(dp[x1][x2][y1][y2], solve(x1, i, y1, y2) + solve(i + 1, x2, y1, y2));\n            }\n            for (int i = y1; i < y2; i++) {\n                dp[x1][x2][y1][y2] = Math.min(dp[x1][x2][y1][y2], solve(x1, x2, y1, i) + solve(x1, x2, i + 1, y2));\n            }\n            return dp[x1][x2][y1][y2];\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            c = new char[n][n];\n            dp = new int[n][n][n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    for (int k = 0; k < n; k++) {\n                        for (int l = 0; l < n; l++) {\n                            dp[i][j][k][l] = -1;\n                        }\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                String x = in.next();\n                for (int j = 0; j < n; j++) {\n                    c[i][j] = x.charAt(j);\n                }\n            }\n            out.println(solve(0, n - 1, 0, n - 1));\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n",dp
"\n// Imports\nimport java.util.*;\nimport java.io.*;\n\npublic class D1198 {\n\n    static int[][] arr;\n    static int[][] presum;\n    \n    public static int query(int x, int y, int x2, int y2) {\n        if(x > 0 && y > 0) {\n            return presum[x2 - 1][y2 - 1] - presum[x2 - 1][y - 1] - presum[x - 1][y2 - 1] + presum[x - 1][y - 1];\n        }\n        else if(y > 0) {\n            return presum[x2 - 1][y2 - 1] - presum[x2 - 1][y - 1];\n        }\n        else if(x > 0) {\n            return presum[x2 - 1][y2 - 1] - presum[x - 1][y2 - 1];\n        }\n        else {\n            return presum[x2 - 1][y2 - 1];\n        }\n    }\n    \n    /**\n     * @param args the command line arguments\n     * @throws IOException, FileNotFoundException \n     */\n    public static void main(String[] args) throws IOException, FileNotFoundException {\n        \n        // TODO UNCOMMENT WHEN ALGORITHM CORRECT\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        \n        \n        // TODO code application logic here\n        int N = Integer.parseInt(f.readLine());\n        \n        arr = new int[N][N];\n        \n        for(int i = 0; i < N; i++) {\n            String s = f.readLine();\n            for(int j = 0; j < N; j++) {\n                if(s.charAt(j) == '#') {\n                    arr[i][j] = 1;\n                }\n            }\n        }\n        \n        presum = new int[N][N];\n        for(int i = 0; i < presum.length; i++) {\n            for(int j = 0; j < presum.length; j++) {\n                if(j > 0) {\n                    presum[i][j] += presum[i][j - 1];\n                }\n                presum[i][j] += arr[i][j];\n            }\n        }\n        \n        for(int i = 0; i < presum.length; i++) {\n            for(int j = 0; j < presum.length; j++) {\n                if(i > 0) {\n                    presum[i][j] += presum[i - 1][j];\n                }\n            }\n        }\n        \n        // System.out.println(Arrays.deepToString(presum));\n        \n        int[][][][] dp = new int[N][N][N + 1][N + 1];\n        for(int dx = 1; dx <= dp.length; dx++) {\n            for(int dy = 1; dy <= dp.length; dy++) {\n                // System.out.println(""dx: "" + dx + "" "" + ""dy: "" + dy);\n                for(int x = 0; x <= dp.length - dx; x++) {\n                    for(int y = 0; y <= dp.length - dy; y++) {\n                        // start by assigning \n                        // System.out.println(x + "" "" + y + "" "" + dx + "" "" + dy);\n                        dp[x][y][x + dx][y + dy] = Math.max(dx, dy);\n                        \n                        if(query(x, y, x + dx, y + dy) == 0) {\n                            dp[x][y][x + dx][y + dy] = 0;\n                        }\n                        \n                        // System.out.println(dp[x][y][x + dx][y + dy]);\n                        \n                        for(int c = 1; c < dy; c++) {\n                            dp[x][y][x + dx][y + dy] = Math.min(dp[x][y][x + dx][y + c] + dp[x][y + c][x + dx][y + dy],\n                                                                    dp[x][y][x + dx][y + dy]);\n                        }\n                        for(int r = 1; r < dx; r++) {\n                            dp[x][y][x + dx][y + dy] = Math.min(dp[x][y][x + r][y + dy] + dp[x + r][y][x + dx][y + dy],\n                                    dp[x][y][x + dx][y + dy]);\n                        }\n                        \n                        // System.out.print(dp[x][y][x + dx][y + dy]);\n                        // System.out.print("" "");\n                    }\n                    // System.out.println();\n                }\n                // System.out.println();\n            }\n        }\n        \n        \n        System.out.println(dp[0][0][N][N]);\n        \n        \n    }\n\n}\n",dp
import java.util.*;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		while(n-->0) {\n			long sum=sc.nextLong()+sc.nextLong()+sc.nextLong();\n			System.out.println(sum/2);\n		}\n	}\n},"brute force,constructive algorithms,math"
import java.util.*;\n\npublic class Test {\n\n	public static void main(String[] args) {\n		Scanner read = new Scanner(System.in);\n\n		int t = read.nextInt();\n		while(t-- > 0) {\n			System.out.println((read.nextLong() + read.nextLong() + read.nextLong()) / 2);\n		}\n	}\n},"brute force,constructive algorithms,math"
import java.util.*;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		while(n-->0) {\n			long sum=sc.nextLong()+sc.nextLong()+sc.nextLong();\n			System.out.println(sum/2);\n		}\n	}\n},"brute force,constructive algorithms,math"
import java.util.*;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		while(n-->0) {\n			long sum=sc.nextLong()+sc.nextLong()+sc.nextLong();\n			System.out.println(sum/2);\n		}\n	}\n},"brute force,constructive algorithms,math"
"/*package whatever //do not write package name here */\n\nimport java.io.*;\nimport java.util.Arrays;\nimport java.util.*;\npublic class GFG {\n	public static void main (String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int a[] = new int[n+1];\n		a[0]=0;\n		for(int i=1;i<=n;i++)\n		{\n		    a[i] = sc.nextInt();\n		    if(i>1)\n		    a[i] += a[i-1];\n		}\n		int q = sc.nextInt();\n		while(q-- > 0)\n		{\n		    int l,r;\n		    l = sc.nextInt();\n		    r = sc.nextInt();\n		    System.out.println((a[r]-a[l-1])/10);\n		}\n	}\n}","data structures,dp,implementation,math"
"import java.util.*;\npublic class Main {\n	final static int maxn=(int)1e5+10;\n	static int a[]=new int [maxn];\n	static int sum[]=new int [maxn];\n public static void main(String args[])\n {\n	// System.out.println(1);\n	 Scanner input=new Scanner(System.in);\n	 int n=input.nextInt();\n	 for(int i=1;i<=n;i++)\n		 a[i]=input.nextInt();\n	 for(int i=1;i<=n;i++)\n		 sum[i]=a[i]+sum[i-1];\n	 int q=input.nextInt();\n	 while(q-->0)\n	 {\n		 int l,r;\n		 l=input.nextInt();r=input.nextInt();\n		 System.out.println((sum[r]-sum[l-1])/10);\n	 }\n }\n}\n\n  			  		 	 					 	       	 			","data structures,dp,implementation,math"
import java.util.Scanner;\n\n/**\n *\n * @author DELL\n */\npublic class codeforces {\n    public static void main(String[] args) {\n           Scanner sc=new Scanner(System.in);\n          int n=sc.nextInt();\n          int a[]=new int[n];\n          for(int i=0;i<n;i++)\n              a[i]=sc.nextInt();\n          int b[]=new int[n+1];\n          for(int i=1;i<n+1;i++)\n          {\n              b[i]=b[i-1]+a[i-1];\n             }\n          int q=sc.nextInt();\n           for(int i=0;i<q;i++)\n           {   int c=0;\n               int x=sc.nextInt();\n               int y=sc.nextInt();\n               System.out.println((b[y]-b[x-1])/10);\n               }\n           }\n}\n\n,"data structures,dp,implementation,math"
import java.util.*;\nimport java.io.*;\n\npublic class File {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n		// Just need to store the total points and the\n		// final value % 10 after the combining is over.\n		int n = sc.nextInt();\n		\n		int[] arr = new int[n];\n		for (int i = 0; i < n; i++) {\n			arr[i] = sc.nextInt();\n		}\n		\n		int[] prefix = new int[n];\n		prefix[0] = arr[0];\n		\n		for (int i = 1; i < n; i++) {\n			prefix[i] = arr[i] + prefix[i-1];\n		}\n		\n		int q = sc.nextInt();\n		for (int i = 0; i < q; i++) {\n			int L = sc.nextInt() - 1;\n			int R = sc.nextInt() - 1;\n			\n			int total = prefix[R] - (L > 0 ? prefix[L-1] : 0);\n			int score = total / 10;\n			\n			System.out.println(score);\n		}\n    }\n}\n,"data structures,dp,implementation,math"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1669E extends PrintWriter {\n	CF1669E() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1669E o = new CF1669E(); o.main(); o.flush();\n	}\n\n	void main() {\n		int A = 'k' - 'a' + 1;\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int[][] kk = new int[A][A];\n			int[] pp = new int[A];\n			int[] qq = new int[A];\n			int n = sc.nextInt();\n			while (n-- > 0) {\n				String s = sc.next();\n				int a = s.charAt(0) - 'a';\n				int b = s.charAt(1) - 'a';\n				kk[a][b]++;\n				pp[a]++;\n				qq[b]++;\n			}\n			long ans = 0;\n			for (int a = 0; a < A; a++) {\n				int p = pp[a], q = qq[a];\n				for (int b = 0; b < A; b++) {\n					int k = kk[a][b];\n					ans += (long) (p - k) * k;\n					k = kk[b][a];\n					ans += (long) (q - k) * k;\n				}\n			}\n			ans /= 2;\n			println(ans);\n		}\n	}\n}\n","brute force,data structures,math,strings"
"import java.util.*;\npublic class Main{\n	public static void main(String[] args){\n	    Scanner in=new Scanner(System.in);\n	    int t=Integer.parseInt(in.nextLine());\n	    while(t--!=0){\n	        int n=Integer.parseInt(in.nextLine());\n	        String s[]=new String[n];\n	        for(int i=0;i<n;i++) s[i]=in.nextLine();\n	        Map<Character,Integer> fP=new HashMap<>(),sP=new HashMap<>();\n	        Map<String,Integer> c=new HashMap<>();\n	        long res=0;\n	        for(int i=n-1;i>=0;i--){\n	            res+=(fP.getOrDefault(s[i].charAt(0),0)+sP.getOrDefault(s[i].charAt(1),0)-2L*c.getOrDefault(s[i],0));\n	            fP.put(s[i].charAt(0),fP.getOrDefault(s[i].charAt(0),0)+1);\n	            sP.put(s[i].charAt(1),sP.getOrDefault(s[i].charAt(1),0)+1);\n	            c.put(s[i],c.getOrDefault(s[i],0)+1);\n	        }\n	        System.out.println(res);\n	    }\n	}\n}","brute force,data structures,math,strings"
import java.util.*;\nimport java.lang.*;\nimport java.util.*;\n\npublic class Main\n{\n    public static void main (String[] args) throws java.lang.Exception\n    {\n        \n        Scanner sc = new Scanner(System.in);\n        int citizens = sc.nextInt();\n        for(int z=0;z<citizens;z++){\n          int n=sc.nextInt();\n    //String s=sc.next();\nlong ch[][]=new long[26][26];\nlong rev[][]=new long[26][26];\nlong ans=0;\nfor(int i=0;i<n;i++){\nString s=sc.next();\nchar first=s.charAt(0);\nchar second=s.charAt(1);\nlong d[]=ch[first-'a'];\nfor(int j=0;j<d.length;j++){\n    char c=(char)(j+'a');\n    if(c!=second){\n    ans=ans+d[j];    \n    }\n}\nlong d1[]=rev[second-'a'];\nfor(int j=0;j<d.length;j++){\n    char c=(char)(j+'a');\n    if(c!=first){\n    ans=ans+d1[j];    \n    }\n}\n\nch[first-'a'][second-'a']++;\nrev[second-'a'][first-'a']++;\n\n}\n\nSystem.out.println(ans);\n\n}}},"brute force,data structures,math,strings"
"import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int t = scan.nextInt();\n		while (t-- != 0) {\n			int n = scan.nextInt();\n			Map<String, Integer> map = new HashMap<>();\n			int arr[][] = new int[26][2];\n			String ar[] = new String[n];\n			for (int i = 0; i < n; i++) {\n				ar[i] = scan.next();\n				if (map.get(ar[i]) == null)\n					map.put(ar[i], 0);\n				map.put(ar[i], map.get(ar[i]) + 1);\n				arr[ar[i].charAt(0) - 97][0]++;\n				arr[ar[i].charAt(1) - 97][1]++;\n			}\n			long result = 0;\n			for (int i = 0; i < n; i++) {\n				map.put(ar[i], map.get(ar[i]) - 1);\n				arr[ar[i].charAt(0) - 97][0]--;\n				arr[ar[i].charAt(1) - 97][1]--;\n				result = result + (arr[ar[i].charAt(0) - 97][0] + arr[ar[i].charAt(1) - 97][1]) - 2 * map.get(ar[i]);\n			}\n			System.out.println(result);\n		}\n		scan.close();\n	}\n}\n","brute force,data structures,math,strings"
"import java.util.*;\nimport java.io.*;\n\npublic class E\n{\n\n	static FastIO f;\n\n	public static void main(String args[]) throws IOException\n	{\n		f = new FastIO();\n\n		int t, n, m, i, j;\n		PriorityQueue<Point> h;\n		char[][] g;\n		char cs;\n		Point x, y, temp;\n		ArrayList<Pair> a;\n		boolean xa, ya, c;\n		\n		t = f.ni();\n		\n		while(t-->0)\n		{\n			n = f.ni();\n			m = f.ni();\n			g = new char[n][];\n			h = new PriorityQueue<>(Point.comp);\n			a = new ArrayList<>();\n\n			for(i = 0; i < n; i++)\n				g[i] = f.nca();\n\n			for(i = 0; i < n; i++)\n			{\n				for(j = 0; j < m; j++)\n				{\n					if(g[i][j] != '.')\n					{\n						h.add(new Point(g[i][j], i, j));\n					}\n				}\n			}\n\n			// f.err(h + ""\n"");\n\n			if(h.isEmpty())\n			{\n				f.out(""YES\n0\n"");\n				continue;\n			}\n\n			c = xa = ya = true;\n			x = y = h.poll();\n			cs = 'a';\n			while(!h.isEmpty())\n			{\n				temp = h.poll();\n\n				if(x.s != temp.s)\n				{\n					c = check(g, x, y);\n					if((xa || ya) && c)\n					{\n						while(cs <= x.s)\n						{\n							a.add(new Pair(x, y));\n							cs++;\n						}\n					}\n					else\n						break;\n\n					x = y = temp;\n					xa = ya = true;\n				}\n				else\n				{\n					y = temp;\n					xa = xa && x.x == y.x;\n					ya = ya && x.y == y.y;\n				}\n			}\n\n			if((!xa && !ya) || !c)\n			{\n				f.out(""NO\n"");\n				continue;\n			}\n\n			if((xa || ya) && check(g, x, y))\n			{\n				while(cs <= x.s)\n				{\n					a.add(new Pair(x, y));\n					cs++;\n				}\n			}\n			else\n			{\n				f.out(""NO\n"");\n				continue;\n			}\n\n			// f.err(a + ""\n"");\n\n			f.out(""YES\n"" + (a.size()) + ""\n"");\n\n			for(Pair p : a)\n			{\n				f.out((p.s.x+1) + "" "" + (p.s.y+1) + "" "" + (p.e.x+1) + "" "" + (p.e.y+1) + ""\n"");\n			}\n\n			f.err(""\n"");\n		}\n\n		f.flush();\n	}\n\n	public static boolean check(char[][] g, Point x, Point y) throws IOException\n	{\n		int i;\n\n		if(x.x == y.x)\n		{\n			for(i = x.y; i <= y.y; i++)\n				if(g[x.x][i] < g[x.x][x.y])\n					return false;\n		}\n		else\n		{\n			for(i = x.x; i <= y.x; i++)\n				if(g[i][x.y] < g[x.x][x.y])\n					return false;\n		}\n\n		f.err(x + "" to "" + y + "" is clear.\n"");\n\n		return true;\n	}\n\n	static class Pair\n	{\n		Point s, e;\n	\n		Pair(Point x, Point y)\n		{\n			s = x;\n			e = y;\n		}\n	\n		@Override\n		public int hashCode()\n		{\n			return super.hashCode();\n		}\n	\n		@Override\n		public boolean equals(Object obj)\n		{\n			Pair that = (Pair)obj;\n	\n			return super.equals(obj);\n		}\n	\n		@Override\n		public String toString()\n		{\n			return ""["" + s + "", "" + e + ""]"";\n		}\n	}\n\n	static class Point\n	{\n		char s;\n		int x, y;\n\n		static Comparator<Point> comp = new Comparator<>(){\n\n			@Override\n			public int compare(Point a, Point b)\n			{\n				return (a.s != b.s) ? a.s-b.s : (a.x != b.x) ? a.x-b.x : a.y-b.y;\n			}\n		};\n	\n		Point(char a, int b, int c)\n		{\n			s = a;\n			x = b;\n			y = c;\n		}\n	\n		@Override\n		public int hashCode()\n		{\n			return Objects.hash(s, x, y);\n		}\n	\n		@Override\n		public boolean equals(Object obj)\n		{\n			Point that = (Point)obj;\n	\n			return s == that.s && x == that.x && y == that.y;\n		}\n	\n		@Override\n		public String toString()\n		{\n			return ""["" + s + "", ("" + x + "", "" + y + "")"" + ""]"";\n		}\n	}\n\n	public static class FastIO\n	{\n		BufferedReader br;\n		BufferedWriter bw, be;\n		StringTokenizer st;\n\n		public FastIO()\n		{\n			br = new BufferedReader(new InputStreamReader(System.in));\n			bw = new BufferedWriter(new OutputStreamWriter(System.out));\n			be = new BufferedWriter(new OutputStreamWriter(System.err));\n			st = new StringTokenizer("""");\n		}\n\n		private void read() throws IOException\n		{\n			st = new StringTokenizer(br.readLine());\n		}\n\n		public String ns() throws IOException\n		{\n			while(!st.hasMoreTokens())\n				read();\n			return st.nextToken();\n		}\n\n		public int ni() throws IOException\n		{\n			return Integer.parseInt(ns());\n		}\n\n		public long nl() throws IOException\n		{\n			return Long.parseLong(ns());\n		}\n\n		public float nf() throws IOException\n		{\n			return Float.parseFloat(ns());\n		}\n\n		public double nd() throws IOException\n		{\n			return Double.parseDouble(ns());\n		}\n\n		public char nc() throws IOException\n		{\n			return ns().charAt(0);\n		}\n\n		public int[] nia(int n) throws IOException\n		{\n			int[] a = new int[n];\n			for(int i = 0; i < n; i++)\n				a[i] = ni();\n\n			return a;\n		}\n\n		public long[] nla(int n) throws IOException\n		{\n			long[] a = new long[n];\n			for(int i = 0; i < n; i++)\n				a[i] = nl();\n\n			return a;\n		}\n\n		public char[] nca() throws IOException\n		{\n			return ns().toCharArray();\n		}\n\n		public void out(String s) throws IOException\n		{\n			bw.write(s);\n		}\n\n		public void flush() throws IOException\n		{\n			bw.flush();\n			be.flush();\n		}\n\n		public void err(String s) throws IOException\n		{\n			be.write(s);\n		}\n	}\n}","brute force,implementation"
"import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/**\n *\n * @author Dstoical\n */\n\npublic class F {\n\n	private static long INF = 2000000000L, M = 1000000007, MM = 998244353;\n	private static int N = 0;\n\n	public static void process() throws IOException {\n\n		int n = sc.nextInt(),m = sc.nextInt();\n		char[][] arr = new char[n+1][m+1];\n		for(int i=0; i<n; i++) {\n			String s = sc.next();\n			for(int j=0; j<m; j++) {\n				arr[i][j] = s.charAt(j);\n			}\n		}\n		\n		int maxX[] = new int[26];\n		int minX[] = new int[26];\n		int maxY[] = new int[26];\n		int minY[] = new int[26];\n		\n		Arrays.fill(maxX, -1);\n		Arrays.fill(minX, n+1);\n		Arrays.fill(maxY, -1);\n		Arrays.fill(minY, m+1);\n		\n		for(int i=0; i<n; i++) {\n			for(int j=0; j<m; j++) {\n				if(arr[i][j] == '.')continue;\n				int code = arr[i][j]-'a';\n				maxX[code] = max(maxX[code],i);\n				maxY[code] = max(maxY[code],j);\n				minX[code] = min(minX[code],i);\n				minY[code] = min(minY[code],j);\n			}\n		}\n		int max = 0;\n		for(int i=0; i<26; i++) {\n			if(maxX[i] != -1)max = max(max,i+1);\n		}\n		StringBuilder ans = new StringBuilder();\n		ans.append(max+""\n"");\n		\n		for(int x=0; x<max; x++) {\n			if(maxX[x] == -1) {\n				outer : for(int i=0; i<n; i++) {\n					for(int j=0; j<m; j++) {\n						if(arr[i][j] == '.')continue;\n						int code = arr[i][j]-'a';\n						if(code >= x) {\n							maxX[x] = i;\n							maxY[x] = j;\n							minX[x] = i;\n							minY[x] = j;\n							break outer;\n						}\n					}\n				}\n			}\n			\n			if((maxX[x]-minX[x])*(maxY[x]-minY[x]) != 0) {\n				println(""NO"");\n				return;\n			}\n			\n			for(int i=minX[x]; i<=maxX[x]; i++) {\n				for(int j=minY[x]; j<=maxY[x]; j++) {\n					if(arr[i][j] - 'a' < x) {\n						println(""NO"");\n						return;\n					}\n				}\n			}\n			\n			ans.append((minX[x]+1)+"" ""+(minY[x]+1)+"" ""+(maxX[x]+1)+"" ""+(maxY[x]+1)+""\n"");\n		}\n		\n		println(""YES"");\n		print(ans);\n		\n\n	}\n\n	//=============================================================================\n	//--------------------------The End---------------------------------\n	//=============================================================================\n\n	static FastScanner sc;\n	static PrintWriter out;\n\n	public static void main(String[] args) throws IOException {\n		boolean oj = true;\n		if (oj) {\n			sc = new FastScanner();\n			out = new PrintWriter(System.out);\n		} else {\n			sc = new FastScanner(100);\n			out = new PrintWriter(""output.txt"");\n		}\n		int t = 1;\n		t = sc.nextInt();\n		while (t-- > 0) {\n			process();\n		}\n		out.flush();\n		out.close();\n	}\n\n	static class Pair implements Comparable<Pair> {\n		int x, y;\n\n		Pair(int x, int y) {\n			this.x = x;\n			this.y = y;\n		}\n\n		@Override\n		public int compareTo(Pair o) {\n			return Integer.compare(this.x, o.x);\n		}\n	}\n\n	/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n	static void println(Object o) {\n		out.println(o);\n	}\n\n	static void println() {\n		out.println();\n	}\n\n	static void print(Object o) {\n		out.print(o);\n	}\n\n	static void pflush(Object o) {\n		out.println(o);\n		out.flush();\n	}\n\n	static int ceil(int x, int y) {\n		return (x % y == 0 ? x / y : (x / y + 1));\n	}\n\n	static long ceil(long x, long y) {\n		return (x % y == 0 ? x / y : (x / y + 1));\n	}\n\n	static int max(int x, int y) {\n		return Math.max(x, y);\n	}\n\n	static int min(int x, int y) {\n		return Math.min(x, y);\n	}\n\n	static int abs(int x) {\n		return Math.abs(x);\n	}\n\n	static long abs(long x) {\n		return Math.abs(x);\n	}\n\n	static int log2(int N) {\n		int result = (int) (Math.log(N) / Math.log(2));\n		return result;\n	}\n\n	static long max(long x, long y) {\n		return Math.max(x, y);\n	}\n\n	static long min(long x, long y) {\n		return Math.min(x, y);\n	}\n\n	public static int gcd(int a, int b) {\n		BigInteger b1 = BigInteger.valueOf(a);\n		BigInteger b2 = BigInteger.valueOf(b);\n		BigInteger gcd = b1.gcd(b2);\n		return gcd.intValue();\n	}\n\n	public static long gcd(long a, long b) {\n		BigInteger b1 = BigInteger.valueOf(a);\n		BigInteger b2 = BigInteger.valueOf(b);\n		BigInteger gcd = b1.gcd(b2);\n		return gcd.longValue();\n	}\n\n	/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n	static class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		FastScanner() throws FileNotFoundException {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		FastScanner(int a) throws FileNotFoundException {\n			br = new BufferedReader(new FileReader(""input.txt""));\n		}\n\n		String next() throws IOException {\n			while (st == null || !st.hasMoreElements()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			}\n			return st.nextToken();\n		}\n\n		int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n\n		String nextLine() throws IOException {\n			String str = """";\n			try {\n				str = br.readLine();\n			} catch (IOException e) {\n				e.printStackTrace();\n			}\n			return str;\n		}\n\n		int[] readArray(int n) throws IOException {\n			int[] A = new int[n];\n			for (int i = 0; i != n; i++) {\n				A[i] = sc.nextInt();\n			}\n			return A;\n		}\n\n		long[] readArrayLong(int n) throws IOException {\n			long[] A = new long[n];\n			for (int i = 0; i != n; i++) {\n				A[i] = sc.nextLong();\n			}\n			return A;\n		}\n	}\n\n	static void ruffleSort(int[] a) {\n		Random get = new Random();\n		for (int i = 0; i < a.length; i++) {\n			int r = get.nextInt(a.length);\n			int temp = a[i];\n			a[i] = a[r];\n			a[r] = temp;\n		}\n		Arrays.sort(a);\n	}\n\n	static void ruffleSort(long[] a) {\n		Random get = new Random();\n		for (int i = 0; i < a.length; i++) {\n			int r = get.nextInt(a.length);\n			long temp = a[i];\n			a[i] = a[r];\n			a[r] = temp;\n		}\n		Arrays.sort(a);\n	}\n}\n","brute force,implementation"
"import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1185e {\n\n    public static void main(String[] args) throws IOException {\n        int t = ri();\n        next: while (t --> 0) {\n            int n = rni(), m = ni(), pos[][] = new int[26][4], bounds[][] = new int[26][4];\n            for (int i = 0; i < 26; ++i) {\n                fill(pos[i], -1);\n                bounds[i][0] = n;\n                bounds[i][1] = m;\n            }\n            char[][] map = new char[n][m];\n            for (int i = 0; i < n; ++i) {\n                char[] row = rcha();\n                for (int j = 0; j < m; ++j) {\n                    map[i][j] = row[j];\n                    if (row[j] >= 'a') {\n                        int ind = row[j] - 'a';\n                        if (pos[ind][0] == -1) {\n                            pos[ind][0] = i;\n                            pos[ind][1] = j;\n                        }\n                        pos[ind][2] = i;\n                        pos[ind][3] = j;\n                        bounds[ind][0] = min(bounds[ind][0], i);\n                        bounds[ind][1] = min(bounds[ind][1], j);\n                        bounds[ind][2] = max(bounds[ind][2], i);\n                        bounds[ind][3] = max(bounds[ind][3], j);\n                    }\n                }\n            }\n            // prln(pos[0]);\n            int ans = 26;\n            for (int i = 25; i >= 0; --i) {\n                if (pos[i][0] == -1 && (i == 25 || pos[i + 1][0] == -1)) {\n                    --ans;\n                    continue;\n                }\n                if (pos[i][0] == -1) {\n                    pos[i][0] = pos[i][2] = pos[i + 1][0];\n                    pos[i][1] = pos[i][3] = pos[i + 1][1];\n                    continue;\n                }\n                if (bounds[i][0] != bounds[i][2] && bounds[i][1] != bounds[i][3]) {\n                    // prln(bounds[i]);\n                    prN();\n                    continue next;\n                }\n                if (pos[i][0] == pos[i][2]) {\n                    for (int j = pos[i][1] + 1; j < pos[i][3]; ++j) {\n                        if (map[pos[i][0]][j] - 'a' < i) {\n                            // prln(i, pos[i][0], j);\n                            prN();\n                            continue next;\n                        }\n                    }\n                } else {\n                    for (int j = pos[i][0] + 1; j < pos[i][2]; ++j) {\n                        if (map[j][pos[i][1]] - 'a' < i) {\n                            // prln(i, j, pos[i][1]);\n                            prN();\n                            continue next;\n                        }\n                    }\n                }\n            }\n            prY();\n            prln(ans);\n            for (int i = 0; i < ans; ++i) {\n                prln(pos[i][0] + 1, pos[i][1] + 1, pos[i][2] + 1, pos[i][3] + 1);\n            }\n        }\n        close();\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int lcm(int a, int b) {return a * b / gcf(a, b);}\n    static long lcm(long a, long b) {return a * b / gcf(a, b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {prln(""yes"");}\n    static void pry() {prln(""Yes"");}\n    static void prY() {prln(""YES"");}\n    static void prno() {prln(""no"");}\n    static void prn() {prln(""No"");}\n    static void prN() {prln(""NO"");}\n    static boolean pryesno(boolean b) {prln(b ? ""yes"" : ""no""); return b;};\n    static boolean pryn(boolean b) {prln(b ? ""Yes"" : ""No""); return b;}\n    static boolean prYN(boolean b) {prln(b ? ""YES"" : ""NO""); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(""hlfd""); flush();}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}\n}","brute force,implementation"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1185E {\n	static final int A = 26;\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter pw = new PrintWriter(System.out);\n		int[] i1 = new int[A];\n		int[] i2 = new int[A];\n		int[] j1 = new int[A];\n		int[] j2 = new int[A];\n		int t = Integer.parseInt(br.readLine());\n		while (t-- > 0) {\n			StringTokenizer st = new StringTokenizer(br.readLine());\n			int n = Integer.parseInt(st.nextToken());\n			int m = Integer.parseInt(st.nextToken());\n			char[][] cc = new char[n][m];\n			for (int i = 0; i < n; i++)\n				br.readLine().getChars(0, m, cc[i], 0);\n			Arrays.fill(i1, n);\n			Arrays.fill(i2, -1);\n			Arrays.fill(j1, m);\n			Arrays.fill(j2, -1);\n			for (int i = 0; i < n; i++)\n				for (int j = 0; j < m; j++) {\n					char c = cc[i][j];\n					if (c != '.') {\n						int a = c - 'a';\n						if (i1[a] > i)\n							i1[a] = i;\n						if (i2[a] < i)\n							i2[a] = i;\n						if (j1[a] > j)\n							j1[a] = j;\n						if (j2[a] < j)\n							j2[a] = j;\n					}\n				}\n			int b = -1;\n			boolean yes = true;\nout:\n			for (int a = A - 1; a >= 0; a--)\n				if (i1[a] <= i2[a] && j1[a] <= j2[a]) {\n					if (b == -1)\n						b = a;\n					if (i1[a] < i2[a] && j1[a] < j2[a]) {\n						yes = false;\n						break;\n					}\n					char c = (char) (a + 'a');\n					for (int i = i1[a]; i <= i2[a]; i++)\n						for (int j = j1[a]; j <= j2[a]; j++) {\n							if (cc[i][j] != c && cc[i][j] != ' ') {\n								yes = false;\n								break out;\n							}\n							cc[i][j] = ' ';\n						}\n				}\n			if (yes) {\n				pw.println(""YES"");\n				pw.println(b + 1);\n				for (int a = 0; a <= b; a++) {\n					int c = i1[a] <= i2[a] && j1[a] <= j2[a] ? a : b;\n					pw.println((i1[c] + 1) + "" "" + (j1[c] + 1) + "" "" + (i2[c] + 1) + "" "" + (j2[c] + 1));\n				}\n			} else\n				pw.println(""NO"");\n		}\n		pw.close();\n	}\n}\n","brute force,implementation"
"import java.io.*;\nimport java.util.*;\n \npublic class Main\n{\n	static class InputReader {\n		BufferedReader reader;\n		StringTokenizer tokenizer;\n		public InputReader(InputStream stream) {\n			reader = new BufferedReader(new InputStreamReader(stream), 32768);\n			tokenizer = null;\n		}\n		String next() { // reads in the next string\n			while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n				try {\n					tokenizer = new StringTokenizer(reader.readLine());\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n			return tokenizer.nextToken();\n		}\n		public int nextInt() { // reads in the next int\n			return Integer.parseInt(next());\n		}\n		public long nextLong() { // reads in the next long\n			return Long.parseLong(next());\n		}\n		public double nextDouble() { // reads in the next double\n			return Double.parseDouble(next());\n			}\n		}\n	static InputReader r = new InputReader(System.in);\n	static PrintWriter pw = new PrintWriter(System.out);\n	static long mod = 998244353;\n	public static void main(String[] args)\n	{\n		int n = r.nextInt();\n		int z = r.nextInt();\n		int[] p = new int[n];\n		int[] pos = new int[n];\n		for (int i= 0; i < n; i ++)\n		{\n			p[i] = r.nextInt() - 1;\n			pos[p[i]] = i;\n		}\n		int[][] min = new int[n][n];\n		for (int i = 0; i < n; i ++)\n		{\n			for (int j = i; j < n; j ++)\n			{\n				min[i][j] = n + 1;\n				for (int k = i; k <= j; k ++)\n				{\n					min[i][j] = Math.min(min[i][j],p[k]);\n				}\n			}\n		}\n		long[][] dp = new long[n][n];\n		for (int i = 0; i < n; i ++)\n		{\n			dp[i][i] = 1;\n		}\n		for (int k = 1; k < n; k ++)\n		{\n			for (int i = 0; i+k < n; i ++)\n			{\n				int j = i + k;\n				int x = pos[min[i][j]];\n				long count1;\n				if (x == i)\n				{\n					count1 = 1;\n				}\n				else\n				{\n					count1 = 2*dp[i][x-1];\n					count1 %= mod;\n					for (int m = i; m < x - 1; m ++)\n					{\n						count1 += dp[i][m]*dp[m+1][x-1];\n						count1 %= mod;\n					}\n				}\n				long count2;\n				if (x == j)\n				{\n					count2 = 1;\n				}\n				else\n				{\n					count2 = 2 * dp[x+1][j];\n					count2 %= mod;\n					for (int m = x + 1; m < j; m ++)\n					{\n						count2 += dp[x+1][m] * dp[m+1][j];\n						count2 %= mod;\n					}\n				}\n				dp[i][j] = (count1*count2)%mod;\n			}\n		}\n		pw.println(dp[0][n-1]);\n		pw.close();\n	}\n	\n}","combinatorics,dfs and similar,dp"
"import java.util.*;\nimport java.io.*;\n\npublic class F14 {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int n = sc.nextInt(); int m = sc.nextInt();\n        long mod = 998244353;\n        int [] a = new int[m];\n        for (int i = 0; i < m; i++) a[i] = sc.nextInt();\n        long [][] dp = new long[m][m];\n        for (int len = 1; len <= m; len++) {\n            for (int i = 0; i < m - len + 1; i++) {\n                int j = i + len - 1;\n                if (len == 1) {\n                    dp[i][j] = 1;\n                    continue;\n                }\n                int minIndex = -1; int min = Integer.MAX_VALUE;\n                for (int k = i; k <= j; k++) {\n                    if (a[k] < min) {\n                        min = a[k]; minIndex = k;\n                    }\n                }\n                long leftSum = 0;\n                for (int left = minIndex; left >= i; left--) {\n                    long r = 1; long l = 1;\n                    if (left < minIndex) r = dp[left][minIndex - 1];\n                    if (left > i) l = dp[i][left - 1];\n                    leftSum = (leftSum + (r * l) % mod) % mod;\n                }\n                long rightSum = 0;\n                for (int right = minIndex; right <= j; right++) {\n                    long l = 1; long r = 1;\n                    if (right > minIndex) l = dp[minIndex + 1][right];\n                    if (right < j) r = dp[right + 1][j];\n                    rightSum = (rightSum + (l * r) % mod) % mod;\n                }\n                dp[i][j] = (leftSum * rightSum) % mod;\n            }\n        }\n        out.println(dp[0][m - 1]);\n        out.close();\n    }\n\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n\n    }\n\n}","combinatorics,dfs and similar,dp"
"import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n\n	private static final String NO = ""No"";\n	private static final String YES = ""Yes"";\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n\n	private static final long MOD = 998244353;\n\n	void solve() {\n		int T = 1;// ni();\n\n		for (int i = 0; i < T; i++)\n			solve(i);\n	}\n\n	void solve(int nth) {\n		int n = ni();\n		int m = ni();\n		long[][] f = new long[n + 2][n + 2];\n		long[][] g = new long[n + 2][n + 2];\n		int[] a = new int[n + 1];\n		for (int i = 1; i <= n; i++)\n			a[i] = ni();\n\n		for (int i = 1; i <= n + 1; i++)\n			g[i][i] = f[i][i] = f[i][i - 1] = g[i][i - 1] = 1;\n		for (int len = 2; len <= n; len++) {\n			for (int l = 1; l + len - 1 <= n; l++) {\n				int r = l + len - 1;\n				int tmp = l;\n				for (int k = l; k <= r; k++) {\n					if (a[k] < a[tmp])\n						tmp = k;\n				}\n				g[l][r] = f[l][tmp - 1] * f[tmp + 1][r] % MOD;\n				for (int k = l; k <= r; k++) {\n					f[l][r] = (f[l][r] + g[l][k] * f[k + 1][r] % MOD) % MOD;\n				}\n			}\n		}\n		out.print(f[1][n]);\n\n	}\n\n	// a^b\n	long power(long a, long b) {\n		long x = 1, y = a;\n		while (b > 0) {\n			if (b % 2 != 0) {\n				x = (x * y) % MOD;\n			}\n			y = (y * y) % MOD;\n			b /= 2;\n		}\n		return x % MOD;\n	}\n\n	private long gcd(long a, long b) {\n		while (a != 0) {\n			long tmp = b % a;\n			b = a;\n			a = tmp;\n		}\n		return b;\n	}\n\n	void run() throws Exception {\n		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		if (!INPUT.isEmpty())\n			tr(System.currentTimeMillis() - s + ""ms"");\n	}\n\n	public static void main(String[] args) throws Exception {\n		new Main().run();\n	}\n\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n\n	private int readByte() {\n		if (lenbuf == -1)\n			throw new InputMismatchException();\n		if (ptrbuf >= lenbuf) {\n			ptrbuf = 0;\n			try {\n				lenbuf = is.read(inbuf);\n			} catch (IOException e) {\n				throw new InputMismatchException();\n			}\n			if (lenbuf <= 0)\n				return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n\n	private boolean isSpaceChar(int c) {\n		return !(c >= 33 && c <= 126);\n	}\n\n	private int skip() {\n		int b;\n		while ((b = readByte()) != -1 && isSpaceChar(b))\n			;\n		return b;\n	}\n\n	private double nd() {\n		return Double.parseDouble(ns());\n	}\n\n	private char nc() {\n		return (char) skip();\n	}\n\n	private char[] nc(int n) {\n		char[] ret = new char[n];\n		for (int i = 0; i < n; i++)\n			ret[i] = nc();\n		return ret;\n	}\n\n	private String ns() {\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n									// ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	private char[] ns(int n) {\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while (p < n) {\n			if (!(isSpaceChar(b)))\n				buf[p++] = (char) b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n\n	private char[][] nm(int n, int m) {\n		char[][] map = new char[n][];\n		for (int i = 0; i < n; i++)\n			map[i] = ns(m);\n		return map;\n	}\n\n	private int[] na(int n) {\n		int[] a = new int[n];\n		for (int i = 0; i < n; i++)\n			a[i] = ni();\n		return a;\n	}\n\n	private Integer[] na2(int n) {\n		Integer[] a = new Integer[n];\n		for (int i = 0; i < n; i++)\n			a[i] = ni();\n		return a;\n	}\n\n	private int[][] na(int n, int m) {\n		int[][] a = new int[n][];\n		for (int i = 0; i < n; i++)\n			a[i] = na(m);\n		return a;\n	}\n\n	private int ni() {\n		int num = 0, b;\n		boolean minus = false;\n		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n			;\n		if (b == '-') {\n			minus = true;\n			b = readByte();\n		}\n\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				num = num * 10 + (b - '0');\n			} else {\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n\n	private Long[] nl2(int n) {\n		Long[] a = new Long[n];\n		for (int i = 0; i < n; i++)\n			a[i] = nl();\n		return a;\n	}\n\n	private long[] nl(int n) {\n		long[] a = new long[n];\n		for (int i = 0; i < n; i++)\n			a[i] = nl();\n		return a;\n	}\n\n	private long[][] nl(int n, int m) {\n		long[][] a = new long[n][];\n		for (int i = 0; i < n; i++)\n			a[i] = nl(m);\n		return a;\n	}\n\n	private long nl() {\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n			;\n		if (b == '-') {\n			minus = true;\n			b = readByte();\n		}\n\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				num = num * 10 + (b - '0');\n			} else {\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n\n	private static void tr(Object... o) {\n		System.out.println(Arrays.deepToString(o));\n	}\n}\n","combinatorics,dfs and similar,dp"
"import java.util.*;\nimport java.io.*;\n \npublic class Main {\n	public static void main(String args[]) {new Main().work();}\n	\n	Scanner in = new Scanner(System.in);\n	PrintWriter out = new PrintWriter(System.out);\n	int mod=998244353;\n	void work() {		\n		int n=in.nextInt();\n		int m=in.nextInt();\n		\n		int[] A=new int[n];\n		for(int i=0;i<n;i++) A[i]=in.nextInt();\n		long[][] dp=new long[n][n];\n		out.print(helper(A,0,n-1,dp));\n		out.flush();\n	}\n	\n	long helper(int[] A,int s,int e,long[][] dp){\n	    if(s>e) return 1;\n	    if(dp[s][e]>0) return dp[s][e];\n	    int min=s;\n	    for(int i=s;i<=e;i++){\n	        if(A[i]<A[min]){\n	            min=i;\n	        }\n	        dp[s][e]+=((helper(A,s,min-1,dp)*helper(A,min+1,i,dp)%mod)*helper(A,i+1,e,dp))%mod;\n	    }\n	    dp[s][e]%=mod;\n	    return dp[s][e];\n	}\n}\n","combinatorics,dfs and similar,dp"
"import java.io.*;\nimport java.util.*;\n\npublic class ShovelsShop {\n    static final int INF = 1000000000;\n    private static void sortArray(int[] A) {\n        int N = A.length;\n        List<Integer> list = new ArrayList<>(N);\n        for (int x : A) {\n            list.add(x);\n        }\n        Collections.sort(list);\n        for (int i = 0; i < N; i++) {\n            A[i] = list.get(i);\n        }\n    }\n    public static void main(String[] args) {\n        InputReader reader = new InputReader(System.in);\n        PrintWriter writer = new PrintWriter(System.out, false);\n        int N = reader.nextInt();\n        int M = reader.nextInt();\n        int K = reader.nextInt();\n        int[] A = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = reader.nextInt();\n        }\n        int[] X = new int[M];\n        int[] Y = new int[M];\n        for (int i = 0; i < M; i++) {\n            X[i] = reader.nextInt();\n            Y[i] = reader.nextInt();\n        }\n        sortArray(A);\n        int[] prefix = new int[K + 1];\n        for (int i = 0; i < K; i++) {\n            prefix[i + 1] = prefix[i] + A[i];\n        }\n        int[] offers = new int[K + 1];\n        for (int i = 0; i < M; i++) {\n            if (X[i] <= K) offers[X[i]] = Math.max(offers[X[i]], Y[i]);\n        }\n        int[] dp = new int[K + 1];\n        Arrays.fill(dp, INF);\n        dp[0] = 0;\n        for (int i = 1; i <= K; i++) {\n            for (int j = 0; j < i; j++) {\n                dp[i] = Math.min(dp[i], dp[j] + prefix[i] - prefix[j + offers[i - j]]);\n            }\n        }\n        writer.println(dp[K]);\n        writer.close();\n        System.exit(0);\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        public String nextLine() {\n            String str = """";\n            try {\n                str = reader.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}","dp,greedy,sortings"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        FShovelsShop solver = new FShovelsShop();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FShovelsShop {\n        int n;\n        int m;\n        int k;\n        int[] arr;\n        int[] offPos;\n        int[] offCount;\n        int[] prefix;\n        int[] memo;\n\n        public void solve(int testNumber, Scanner sc, PrintWriter pw) {\n            n = sc.nextInt();\n            m = sc.nextInt();\n            k = sc.nextInt();\n            arr = new int[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = sc.nextInt();\n            for (int i = n - 1; i >= 0; i--) {\n                int rand = (int) (Math.random() * (i + 1));\n                int temp = arr[rand];\n                arr[rand] = arr[i];\n                arr[i] = temp;\n            }\n            Arrays.sort(arr);\n            prefix = new int[k];\n            for (int i = 0; i < prefix.length; i++) {\n                prefix[i] = arr[i];\n                if (i > 0)\n                    prefix[i] += prefix[i - 1];\n            }\n            offCount = new int[m];\n            offPos = new int[m];\n            for (int i = 0; i < m; i++) {\n                offCount[i] = sc.nextInt();\n                offPos[i] = sc.nextInt();\n            }\n            memo = new int[k];\n            Arrays.fill(memo, -1);\n            pw.println(dp(0));\n        }\n\n        private int dp(int idx) {\n            if (idx == k)\n                return 0;\n            if (memo[idx] != -1)\n                return memo[idx];\n            int min = arr[idx] + dp(idx + 1);\n            for (int i = 0; i < m; i++) {\n                if (offCount[i] + idx <= k) {\n                    min = Math.min(min, prefix[idx + offCount[i] - 1] - prefix[idx + offPos[i] - 1] + dp(idx + offCount[i]));\n                }\n            }\n            return memo[idx] = min;\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n","dp,greedy,sortings"
"import java.util.*;\nimport java.io.*;\n\npublic class E_1216 {\n	\n	static int k;\n	static int[] array, offers;\n	static long[] sum;\n	static long[] memo;\n	\n	public static long dp(int i) {\n		if(i == 0)\n			return 0;\n		\n		if(memo[i] != -1)\n			return memo[i];\n		\n		long min = array[i - 1] + dp(i - 1);\n		for(int j = 1; j <= i; j++)\n			min = Math.min(min, 1l * sum[i - 1] - ((i - (j - offers[j - 1]) - 1) == -1 ? 0 : sum[i - (j - offers[j - 1]) - 1]) + dp(i - j));\n		\n		return memo[i] = min;\n	}\n	\n	public static void main(String[] args) throws Exception {\n		Scanner sc = new Scanner(System.in);\n		PrintWriter pw = new PrintWriter(System.out);\n		\n		int n = sc.nextInt(), m = sc.nextInt();\n		k = sc.nextInt();\n		\n		int[] tmp = sc.shuffle(sc.nextIntArray(n));\n		Arrays.sort(tmp);\n		array = new int[k];\n		for(int i = 0; i < k; i++)\n			array[i] = tmp[i];\n		\n		sum = new long[n];\n		sum[0] = array[0];\n		for(int i = 1; i < k; i++)\n			sum[i] = 1l * sum[i - 1] + array[i];\n		\n		int[] tmpoffers = new int[(int)2e5];\n		for(int i = 0; i < m; i++) {\n			int x = sc.nextInt() - 1;\n			tmpoffers[x] = Math.max(tmpoffers[x], sc.nextInt());\n		}\n		\n		offers = new int[k];\n		for(int i = 0; i < k; i++)\n			offers[i] = tmpoffers[i];\n		\n		memo = new long[k + 1];\n		Arrays.fill(memo, -1);\n				\n		pw.println(dp(k));\n		pw.flush();\n	}\n\n	public static class Scanner {\n		StringTokenizer st;\n		BufferedReader br;\n\n		public Scanner(InputStream system) {\n			br = new BufferedReader(new InputStreamReader(system));\n		}\n\n		public Scanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n\n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n\n		public char nextChar() throws IOException {\n			return next().charAt(0);\n		}\n\n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n\n		public int[] nextIntArray(int n) throws IOException {\n			int[] array = new int[n];\n			for (int i = 0; i < n; i++)\n				array[i] = nextInt();\n			return array;\n		}\n\n		public Integer[] nextIntegerArray(int n) throws IOException {\n			Integer[] array = new Integer[n];\n			for (int i = 0; i < n; i++)\n				array[i] = new Integer(nextInt());\n			return array;\n		}\n\n		public long[] nextLongArray(int n) throws IOException {\n			long[] array = new long[n];\n			for (int i = 0; i < n; i++)\n				array[i] = nextLong();\n			return array;\n		}\n\n		public double[] nextDoubleArray(int n) throws IOException {\n			double[] array = new double[n];\n			for (int i = 0; i < n; i++)\n				array[i] = nextDouble();\n			return array;\n		}\n\n		public static int[] shuffle(int[] a) {\n			int n = a.length;\n			Random rand = new Random();\n			for (int i = 0; i < n; i++) {\n				int tmpIdx = rand.nextInt(n);\n				int tmp = a[i];\n				a[i] = a[tmpIdx];\n				a[tmpIdx] = tmp;\n			}\n			return a;\n		}\n\n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n\n		public void waitForInput() throws InterruptedException {\n			Thread.sleep(3000);\n		}\n	}\n}\n","dp,greedy,sortings"
"import java.util.*;\nimport java.io.*;\n\npublic class F_1154 {\n	\n	static int k;\n	static int[] array, offers;\n	static long[] sum;\n	static long[] memo;\n	\n	public static long dp(int i) {\n		if(i == 0)\n			return 0;\n		\n		if(memo[i] != -1)\n			return memo[i];\n		\n		long min = array[i - 1] + dp(i - 1);\n		for(int j = 1; j <= i; j++)\n			min = Math.min(min, 1l * sum[i - 1] - ((i - (j - offers[j - 1]) - 1) == -1 ? 0 : sum[i - (j - offers[j - 1]) - 1]) + dp(i - j));\n		\n		return memo[i] = min;\n	}\n	\n	public static void main(String[] args) throws Exception {\n		Scanner sc = new Scanner(System.in);\n		PrintWriter pw = new PrintWriter(System.out);\n		\n		int n = sc.nextInt(), m = sc.nextInt();\n		k = sc.nextInt();\n		\n		int[] tmp = sc.shuffle(sc.nextIntArray(n));\n		Arrays.sort(tmp);\n		array = new int[k];\n		for(int i = 0; i < k; i++)\n			array[i] = tmp[i];\n		\n		sum = new long[n];\n		sum[0] = array[0];\n		for(int i = 1; i < k; i++)\n			sum[i] = 1l * sum[i - 1] + array[i];\n		\n		int[] tmpoffers = new int[(int)2e5];\n		for(int i = 0; i < m; i++) {\n			int x = sc.nextInt() - 1;\n			tmpoffers[x] = Math.max(tmpoffers[x], sc.nextInt());\n		}\n		\n		offers = new int[k];\n		for(int i = 0; i < k; i++)\n			offers[i] = tmpoffers[i];\n		\n		memo = new long[k + 1];\n		Arrays.fill(memo, -1);\n				\n		pw.println(dp(k));\n		pw.flush();\n	}\n\n	public static class Scanner {\n		StringTokenizer st;\n		BufferedReader br;\n\n		public Scanner(InputStream system) {\n			br = new BufferedReader(new InputStreamReader(system));\n		}\n\n		public Scanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n\n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n\n		public char nextChar() throws IOException {\n			return next().charAt(0);\n		}\n\n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n\n		public int[] nextIntArray(int n) throws IOException {\n			int[] array = new int[n];\n			for (int i = 0; i < n; i++)\n				array[i] = nextInt();\n			return array;\n		}\n\n		public Integer[] nextIntegerArray(int n) throws IOException {\n			Integer[] array = new Integer[n];\n			for (int i = 0; i < n; i++)\n				array[i] = new Integer(nextInt());\n			return array;\n		}\n\n		public long[] nextLongArray(int n) throws IOException {\n			long[] array = new long[n];\n			for (int i = 0; i < n; i++)\n				array[i] = nextLong();\n			return array;\n		}\n\n		public double[] nextDoubleArray(int n) throws IOException {\n			double[] array = new double[n];\n			for (int i = 0; i < n; i++)\n				array[i] = nextDouble();\n			return array;\n		}\n\n		public static int[] shuffle(int[] a) {\n			int n = a.length;\n			Random rand = new Random();\n			for (int i = 0; i < n; i++) {\n				int tmpIdx = rand.nextInt(n);\n				int tmp = a[i];\n				a[i] = a[tmpIdx];\n				a[tmpIdx] = tmp;\n			}\n			return a;\n		}\n\n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n\n		public void waitForInput() throws InterruptedException {\n			Thread.sleep(3000);\n		}\n	}\n}\n","dp,greedy,sortings"
"import java.io.BufferedOutputStream;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.InputMismatchException;\nimport java.util.Objects;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	static class TaskAdapter implements Runnable {\n		@Override\n		public void run() {\n			long startTime = System.currentTimeMillis();\n			InputStream inputStream = System.in;\n			OutputStream outputStream = System.out;\n			FastReader in = new FastReader(inputStream);\n			Output out = new Output(outputStream);\n			EServalAndSnake solver = new EServalAndSnake();\n			solver.solve(1, in, out);\n			out.close();\n			System.err.println(System.currentTimeMillis()-startTime+""ms"");\n		}\n\n	}\n\n	public static void main(String[] args) throws Exception {\n		Thread thread = new Thread(null, new TaskAdapter(), """", 1<<28);\n		thread.start();\n		thread.join();\n	}\n\n	static class EServalAndSnake {\n		int n;\n\n		public EServalAndSnake() {\n		}\n\n		public Pair<Integer, Integer> search(Function<Integer, Boolean> f) {\n			int a = -1, b = -1;\n			for(int i = 1; i<=n; i++) {\n				if(f.apply(i)) {\n					if(a==-1) {\n						a = i;\n					}else {\n						b = i;\n					}\n				}\n			}\n			return new Pair<>(a, b);\n		}\n\n		public int bsearch(BiFunction<Integer, Integer, Boolean> f) {\n			int l = 1, r = n;\n			while(l<r) {\n				int mid = l+r >> 1;\n				if(f.apply(l, mid)) {\n					r = mid;\n				}else {\n					l = mid+1;\n				}\n			}\n			return l;\n		}\n\n		public void solve(int kase, InputReader in, Output pw) {\n			n = in.nextInt();\n			var x = search(i -> {\n				pw.println(""?"", i, 1, i, n);\n				pw.flush();\n				return (in.nextInt()&1)==1;\n			});\n			if(x.a!=-1) {\n				pw.println(""!"", x.a,\n						bsearch((a, b) -> {\n							pw.println(""?"", x.a, a, x.a, b);\n							pw.flush();\n							return (in.nextInt()&1)==1;\n						}),\n						x.b,\n						bsearch((a, b) -> {\n							pw.println(""?"", x.b, a, x.b, b);\n							pw.flush();\n							return (in.nextInt()&1)==1;\n						}));\n				return;\n			}\n			var y = search(i -> {\n				pw.println(""?"", 1, i, n, i);\n				pw.flush();\n				return (in.nextInt()&1)==1;\n			});\n			int xx = bsearch((a, b) -> {\n				pw.println(""?"", a, y.a, b, y.a);\n				pw.flush();\n				return (in.nextInt()&1)==1;\n			});\n			pw.println(""!"", xx, y.a, xx, y.b);\n			pw.flush();\n		}\n\n	}\n\n	static class Pair<T1, T2> implements Comparable<Pair<T1, T2>> {\n		public T1 a;\n		public T2 b;\n\n		public Pair(Pair<T1, T2> p) {\n			this(p.a, p.b);\n		}\n\n		public Pair(T1 a, T2 b) {\n			this.a = a;\n			this.b = b;\n		}\n\n		public String toString() {\n			return a+"" ""+b;\n		}\n\n		public int hashCode() {\n			return Objects.hash(a, b);\n		}\n\n		public boolean equals(Object o) {\n			if(o instanceof Pair) {\n				Pair p = (Pair) o;\n				return a.equals(p.a)&&b.equals(p.b);\n			}\n			return false;\n		}\n\n		public int compareTo(Pair<T1, T2> p) {\n			int cmp = ((Comparable<T1>) a).compareTo(p.a);\n			if(cmp==0) {\n				return ((Comparable<T2>) b).compareTo(p.b);\n			}\n			return cmp;\n		}\n\n	}\n\n	static class Output implements Closeable, Flushable {\n		public StringBuilder sb;\n		public OutputStream os;\n		public int BUFFER_SIZE;\n		public String lineSeparator;\n\n		public Output(OutputStream os) {\n			this(os, 1<<16);\n		}\n\n		public Output(OutputStream os, int bs) {\n			BUFFER_SIZE = bs;\n			sb = new StringBuilder(BUFFER_SIZE);\n			this.os = new BufferedOutputStream(os, 1<<17);\n			lineSeparator = System.lineSeparator();\n		}\n\n		public void print(String s) {\n			sb.append(s);\n			if(sb.length()>BUFFER_SIZE >> 1) {\n				flushToBuffer();\n			}\n		}\n\n		public void println(Object... o) {\n			for(int i = 0; i<o.length; i++) {\n				if(i!=0) {\n					print("" "");\n				}\n				print(String.valueOf(o[i]));\n			}\n			println();\n			if(sb.length()>BUFFER_SIZE >> 1) {\n				flushToBuffer();\n			}\n		}\n\n		public void println() {\n			sb.append(lineSeparator);\n		}\n\n		private void flushToBuffer() {\n			try {\n				os.write(sb.toString().getBytes());\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n			sb = new StringBuilder(BUFFER_SIZE);\n		}\n\n		public void flush() {\n			try {\n				flushToBuffer();\n				os.flush();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n		public void close() {\n			flush();\n			try {\n				os.close();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n	}\n\n	static class FastReader implements InputReader {\n		final private int BUFFER_SIZE = 1<<16;\n		private DataInputStream din;\n		private byte[] buffer;\n		private int bufferPointer;\n		private int bytesRead;\n\n		public FastReader(InputStream is) {\n			din = new DataInputStream(is);\n			buffer = new byte[BUFFER_SIZE];\n			bufferPointer = bytesRead = 0;\n		}\n\n		public int nextInt() {\n			int ret = 0;\n			byte c = skipToDigit();\n			boolean neg = (c=='-');\n			if(neg) {\n				c = read();\n			}\n			do {\n				ret = ret*10+c-'0';\n			} while((c = read())>='0'&&c<='9');\n			if(neg) {\n				return -ret;\n			}\n			return ret;\n		}\n\n		private boolean isDigit(byte b) {\n			return b>='0'&&b<='9';\n		}\n\n		private byte skipToDigit() {\n			byte ret;\n			while(!isDigit(ret = read())&&ret!='-') ;\n			return ret;\n		}\n\n		private void fillBuffer() {\n			try {\n				bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n			}catch(IOException e) {\n				e.printStackTrace();\n				throw new InputMismatchException();\n			}\n			if(bytesRead==-1) {\n				buffer[0] = -1;\n			}\n		}\n\n		private byte read() {\n			if(bytesRead==-1) {\n				throw new InputMismatchException();\n			}else if(bufferPointer==bytesRead) {\n				fillBuffer();\n			}\n			return buffer[bufferPointer++];\n		}\n\n	}\n\n	static interface InputReader {\n		int nextInt();\n\n	}\n}\n\n","binary search,brute force,interactive"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1153E {\n	static Scanner sc = new Scanner(System.in);\n	static boolean query(int x1, int x2, int y1, int y2) {\n		System.out.println(""? "" + x1 + "" "" + y1 + "" "" + x2 + "" "" + y2);\n		System.out.flush();\n		return sc.nextInt() % 2 == 1;\n	}\n	static int isearch(int upper, int j1, int j2) {\n		int lower = 0;\n		while (upper - lower > 1) {\n			int i = (lower + upper) / 2;\n			if (query(1, i, j1, j2))\n				upper = i;\n			else\n				lower = i;\n		}\n		return upper;\n	}\n	static int jsearch(int upper, int i1, int i2) {\n		int lower = 0;\n		while (upper - lower > 1) {\n			int j = (lower + upper) / 2;\n			if (query(i1, i2, 1, j))\n				upper = j;\n			else\n				lower = j;\n		}\n		return upper;\n	}\n	public static void main(String[] args) {\n		int n = sc.nextInt();\n		int ihead, jhead, itail, jtail, lower, upper;\n		ihead = jhead = itail = jtail = -1;\n		boolean same_j = true;\n		for (int j = n - 1; j >= 1; j--)\n			if (query(1, n, 1, j)) {\n				same_j = false;\n				jtail = j + 1;\n				break;\n			}\n		if (same_j) {\n			for (int i = n - 1; i >= 1; i--)\n				if (query(1, i, 1, n)) {\n					itail = i + 1;\n					break;\n				}\n			ihead = isearch(itail - 1, 1, n);\n			jhead = jtail = jsearch(n, 1, ihead);\n		} else {\n			jhead = jsearch(jtail - 1, 1, n);\n			ihead = isearch(n, 1, jhead);\n			itail = isearch(n, jtail, n);\n		}\n		System.out.println(""! "" + ihead + "" "" + jhead + "" "" + itail + "" "" + jtail);\n		System.out.flush();\n	}\n}\n","binary search,brute force,interactive"
"//package round551;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class E {\n	Scanner in;\n	PrintWriter out;\n	String INPUT = """";\n	\n	int q(int x1, int y1, int x2, int y2)\n	{\n		out.println(""? "" + x1 + "" "" + y1 + "" "" + x2 + "" "" + y2);\n		out.flush();\n		return ni()&1;\n	}\n	\n	void solve()\n	{\n		int n = ni();\n		int[] rs = new int[n+1];\n		int x = 0;\n		for(int i = 1;i < n;i++){\n			rs[i] = q(i, 1, i, n);\n			x ^= rs[i];\n		}\n		rs[n] = x;\n		\n		List<int[]> rets = new ArrayList<>();\n		for(int i = 1;i <= n;i++){\n			if(rs[i] == 1){\n				int l = 1, r = n+1;\n				while(r-l > 1){\n					int h = l+r>>1;\n					if(q(i, l, i, h-1) == 1){\n						r = h;\n					}else{\n						l = h;\n					}\n				}\n				rets.add(new int[]{i, l});\n			}\n		}\n		if(rets.size() == 0){\n			for(int i = 1;i < n;i++){\n				rs[i] = q(1, i, n, i);\n				x ^= rs[i];\n			}\n			rs[n] = x;\n			for(int i = 1;i <= n;i++){\n				if(rs[i] == 1){\n					int l = 1, r = n+1;\n					while(r-l > 1){\n						int h = l+r>>1;\n						if(q(l, i, h-1, i) == 1){\n							r = h;\n						}else{\n							l = h;\n						}\n					}\n					rets.add(new int[]{l, i});\n				}\n			}\n		}\n		\n		out.println(""! "" + \n				rets.get(0)[0] + "" "" + \n				rets.get(0)[1] + "" "" + \n				rets.get(1)[0] + "" "" + \n				rets.get(1)[1]);\n		out.flush();\n	}\n	\n	void run() throws Exception\n	{\n		in = oj ? new Scanner(System.in) : new Scanner(INPUT);\n		out = new PrintWriter(System.out);\n\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception\n	{\n		new E().run();\n	}\n	\n	int ni() { return Integer.parseInt(in.next()); }\n	long nl() { return Long.parseLong(in.next()); }\n	double nd() { return Double.parseDouble(in.next()); }\n	boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","binary search,brute force,interactive"
"import java.util.Scanner;\n\npublic class SnakeTask {\n\n    private static Scanner scanner = new Scanner(System.in);\n\n    private static int query(int x1, int y1, int x2, int y2) {\n        System.out.printf(""? %d %d %d %d\n"", x1, y1, x2, y2);\n        int ans = scanner.nextInt();\n        if (ans == -1) System.exit(0);\n        return ans;\n    }\n\n    private static void ans(int x1, int y1, int x2, int y2) {\n        System.out.printf(""! %d %d %d %d\n"", x1, y1, x2, y2);\n    }\n\n    public static void main(String[] args) {\n        int n = scanner.nextInt();\n\n        boolean flip = false;\n        int p1 = 0, p2 = 0;\n        for (int i = 1; i < n; i++) {\n            int ans = query(i, 1, i, n);\n            if ((ans & 1) != 0) {\n                if (p1 != 0) p2 = i; else p1 = i;\n            }\n        }\n\n\n        if (p2 == 0 && p1 == 0) {\n            for (int i = 1; i < n; i++) {\n                if ((query(1, i, n, i) & 1) != 0) {\n                    if (p1 != 0) p2 = i; else p1 = i;\n                }\n            }\n            flip = true;\n        }\n\n        if (p2 == 0) p2 = n;\n\n        //System.out.printf(""p1: %d, p2: %d, flip %b\n"", p1, p2, flip);\n\n        int l = 1, r = n;\n        while(l < r) {\n            int m =(l + r)/2;\n            int ans = !flip ? query(p1, 1, p1, m) : query(1, p1, m, p1);\n            if ((ans & 1) != 0)\n                r = m;\n            else\n                l = m +1;\n        }\n        int q1 = l;\n\n        l = 1; r = n;\n        while(l < r) {\n            int m =(l + r)/2;\n            int ans = !flip ? query(p2, 1, p2, m) : query(1, p2, m, p2);\n            if ((ans & 1) != 0)\n                r = m;\n            else\n                l = m +1;\n        }\n        int q2 = l;\n\n        //System.out.printf(""q1: %d, q2: %d\n"", q1, q2);\n\n        if (flip) {\n            ans(q1, p1, q2, p2);\n        } else {\n            ans(p1, q1, p2, q2);\n        }\n    }\n}","binary search,brute force,interactive"
import java.util.*;\npublic class codeforces{\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        \nint n=sc.nextInt();\nint t=sc.nextInt();\nint max=Integer.MAX_VALUE;\nint index=0;\nfor(int i=1;i<=n;i++){\n    int s=sc.nextInt();\n    int d=sc.nextInt();\n    while(s<t){\n        s+=d;\n    }\n    if(max>s){\nmax=s;\nindex=i;\n    }\n}\nSystem.out.println(index);        \n    }\n},"brute force,math"
import java.util.Scanner;\n\npublic class ServalAndBus1153A {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int n = s.nextInt();\n        int t = s.nextInt();\n        int ans = Integer.MAX_VALUE;\n        int num = 0;\n        for(int i=0; i<n; i++){\n            int a = s.nextInt();\n            int w = s.nextInt();\n            while (a < t){\n                a += w;\n            }\n            if(a < ans){\n                ans = a;\n                num = i+1;\n            }\n        }\n        System.out.println(num);\n    }\n}\n,"brute force,math"
import java.util.*;\n\npublic class Main{\n	public static void main(String args[]){\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int t = sc.nextInt();\n		int a[] = new int[n];\n		int b[] = new int[n];\n		for(int i=0;i<n;i++){\n			a[i] = sc.nextInt();\n			b[i] = sc.nextInt();\n			if(a[i]<t){\n				while(a[i]<t){\n					a[i] += b[i];\n				}\n			}\n		}\n        int min = Integer.MAX_VALUE;\n		int temp = -1;\n		for(int i=0;i<n;i++){\n			if(a[i]-t<min){\n				min = a[i]-t;\n				{\n				  temp =i+1;\n				}\n			}\n		}\n		System.out.println(temp);\n\n\n	}\n}\n,"brute force,math"
"import java.util.*;\n\n\npublic class ServalBus{\n	public static void main(String[] args){\n	Scanner sc = new Scanner(System.in);\n	String[] s = sc.nextLine().split("" "");\n	long n = Long.parseLong(s[0]);\n	long t = Long.parseLong(s[1]);\n	long min = Long.MAX_VALUE;\n	int ans =0;\n	int i =1;\n	while(n-->0){\n		s = sc.nextLine().split("" "");\n		long a = Long.parseLong(s[0]);\n	    long b = Long.parseLong(s[1]);\n		long x = (t-a)/b + ((t-a)%b != 0?1:0);\n		if(t <= a) {\n            if(min > a){\n                min = a;  ans = i;\n            }\n        }else{\n\n		if(min>a+(b*x)){\n		  min = a+(b*x);\n		  ans = i;\n		}\n		}\n		i++;\n	}\n	System.out.println(ans);\n	}\n}","brute force,math"
"import java.util.*;\nimport java.io.*;\n\npublic class F553 {\n    public static void main(String[] args) throws Exception {\n        MyScanner sc = new MyScanner();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int n = sc.nextInt();\n        long k = sc.nextLong();\n        int [] arr = new int[n];\n        int a = 0;\n        for (int i = 0; i < n; i++) {\n            arr[i] = sc.nextInt();\n            if (arr[i] == 0) a++;\n        }\n        int b = n - a;\n        initFac(104);\n        dimension = a + 1;\n        memo = new long[maxPow][dimension][dimension];\n        long [][] matrix = new long[dimension][dimension];\n        for (int i = 0; i < dimension; i++) {\n            // dp[i] = ...\n            long choose = (n * (n - 1)) / 2;\n            if (i > 0)\n                matrix[i][i - 1] = ((i * (b - a + i)) * inv(choose)) % mod;\n            if (i < a)\n                matrix[i][i + 1] = ((a - i) * (a - i) * inv(choose)) % mod;\n            long num = choose - (i * (b - a + i) + (a - i) * (a - i));\n            matrix[i][i] = (num * inv(choose)) % mod;\n        }\n        powers(matrix);\n        int start = 0;\n        for (int i = 0; i < a; i++) {\n            if (arr[i] == 0) start++;\n        }\n        long [][] res = exp(matrix, k);\n        long [] vector = new long[dimension];\n        vector[a] = 1;\n        vector = transform(vector, res);\n        out.println(vector[start]);\n        out.close();\n    }\n\n    static long mod = (long) 1e9 + 7; static long [][][] memo; static int maxPow = 30; static int dimension;\n\n    static long [][] multiply(long [][] a, long [][] b) throws Exception {\n        if (a[0].length != b.length) {\n            throw new Exception(""Matrices are not compatible."");\n        }\n        long [][] ret = new long[a.length][b[0].length];\n        for (int i = 0; i < a.length; i++) {\n            for (int j = 0; j < b[0].length; j++) {\n                long product = 0;\n                for (int k = 0; k < a.length; k++) {\n                    product = (product + a[i][k] * b[k][j]) % mod;\n                }\n                ret[i][j] = product;\n            }\n        }\n        return ret;\n    }\n\n    static long[][] exp(long [][] a, long pow) throws Exception {\n        long [][] ret = getIdentity(dimension);\n        for (int i = 0; i < maxPow; i++) {\n            if (((pow) & (1L << i)) >> i == 1) {\n                ret = multiply(ret, memo[i]);\n            }\n        }\n        return ret;\n    }\n\n    static void powers(long [][] a) throws Exception {\n        for (int i = 0; i < maxPow; i++) {\n            memo[i] = a;\n            a = square(a);\n        }\n    }\n\n    static long [][] square(long [][] a) throws Exception {\n        return multiply(a, a);\n    }\n\n    static long [][] getIdentity(int dimension) {\n        long [][] I = new long[dimension][dimension];\n        for (int i = 0; i < dimension; i++) {\n            I[i][i] = 1;\n        }\n        return I;\n    }\n\n    static long[] transform(long [] vector, long [][] matrix) throws Exception {\n        if (vector.length != matrix[0].length) {\n            throw new Exception(""Dimensions are not compatible."");\n        }\n        long [] res = new long[vector.length];\n        for (int i = 0; i < vector.length; i++) {\n            long sum = 0;\n            for (int j = 0; j < vector.length; j++) {\n                sum = (sum + matrix[i][j] * vector[j]) % mod;\n            }\n            res[i] = sum;\n        }\n        return res;\n    }\n\n\n    static void sort(int[] a) {\n        ArrayList<Integer> q = new ArrayList<>();\n        for (int i : a) q.add(i);\n        Collections.sort(q);\n        for (int i = 0; i < a.length; i++) a[i] = q.get(i);\n    }\n\n    static void sort(long[] a) {\n        ArrayList<Long> q = new ArrayList<>();\n        for (long i : a) q.add(i);\n        Collections.sort(q);\n        for (int i = 0; i < a.length; i++) a[i] = q.get(i);\n    }\n\n    static long[] fac;\n\n    static void initFac(long n) {\n        fac = new long[(int)n + 1];\n        fac[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fac[i] = (fac[i - 1]  * i) % mod;\n        }\n    }\n\n\n\n    static long nck(int n, int k) {\n        if (n < k)\n            return 0;\n        long den = inv((int) (fac[k] * fac[n - k] % mod));\n        return fac[n] * den % mod;\n    }\n\n    static long pow(long b, long e) {\n        long ans = 1;\n        while (e > 0) {\n            if (e % 2 == 1)\n                ans = ans * b % mod;\n            e >>= 1;\n            b = b * b % mod;\n        }\n        return ans;\n    }\n\n    static long inv(long x) {\n        return pow(x, mod - 2);\n    }\n\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n\n    }\n\n}","combinatorics,dp,matrices,probabilities"
"import java.io.*;\nimport java.util.*;\n\npublic class Codeforces1151F {\n\n	public static void main(String[] args) throws IOException {\n		int P = 1000000007;\n		\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int n = Integer.parseInt(st.nextToken());\n		int k = Integer.parseInt(st.nextToken());\n		st = new StringTokenizer(br.readLine());\n		int[] a = new int[n];\n		for (int i = 0; i < n; i++) {\n			a[i] = Integer.parseInt(st.nextToken());\n		}\n		\n		//count number of zeroes in array\n		int r = 0;\n		for (int i = 0; i < n; i++) {\n			r += (1-a[i]);\n		}\n		//count number of ones in first r things\n		int s = 0;\n		for (int i = 0; i < r; i++) {\n			s += a[i];\n		}\n		\n		if (r > (n/2)) {\n			r = n-r;\n		}\n		\n		int nC2Inv = (n*(n-1))/2;\n		nC2Inv = inverse(nC2Inv, P);\n		\n		//create matrix\n		int[][] matrix = new int[r+1][r+1];\n		for (int i = 0; i <= r; i++) {\n			matrix[i][i] = 1;\n			if (i > 0) {\n				matrix[i][i-1] = multiply(i*i, nC2Inv, P);\n				matrix[i][i] = (matrix[i][i] + P - matrix[i][i-1])%P;\n			}\n			if (i < r) {\n				matrix[i][i+1] = multiply(((r-i)*(n-r-i)), nC2Inv, P);\n				matrix[i][i] = (matrix[i][i] + P - matrix[i][i+1])%P;\n			}\n		}\n		\n		//matrix power k\n		int[][] ans = power(matrix, k, P);\n		System.out.println(ans[s][0]);\n	}\n	\n	public static int[][] power(int[][] a, int k, int N) {\n		if (k == 1) {\n			return a;\n		}\n		else {\n			int[][] prod = multiply(a, a, N);\n			int[][] ans = power(prod, k/2, N);\n			if (k%2 == 1) {\n				ans = multiply(ans, a, N);\n			}\n			return ans;\n		}\n		\n	}\n\n	public static int[][] multiply (int[][] a, int[][] b, int N) {\n		int n = a.length;\n		int m = a[0].length;\n		int p = b[0].length;\n		\n		int[][] ans = new int[n][p];\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < p; j++) {\n				for (int k = 0; k < m; k++) {\n					ans[i][j] = (ans[i][j] + multiply(a[i][k], b[k][j], N))%N;\n				}\n			}\n		}\n		\n		return ans;\n	}\n	\n	public static int multiply (int a, int b, int n) {\n		long ab = (long) a * (long) b;\n		return ((int) (ab%n));\n	}\n	\n	public static int inverse (int a, int n) {\n		int m = n;\n		int r1 = 1;\n		int r2 = 0;\n		int r3 = 0;\n		int r4 = 1;\n		while ((a > 0) && (n > 0)) {\n			if (n >= a) {\n				r3 -= r1*(n/a);\n				r4 -= r2*(n/a);\n				n = n%a;\n			}\n			else {\n				int tmp = a;\n				a = n;\n				n = tmp;\n				tmp = r1;\n				r1 = r3;\n				r3 = tmp;\n				tmp = r2;\n				r2 = r4;\n				r4 = tmp;\n			}\n		}\n		if (a == 0) {\n			if (r3 >= 0)\n				return (r3%m);\n			else\n				return (m+(r3%m));\n		}\n		else {\n			if (r1 >= 0)\n				return (r1%m);\n			else\n				return (m+(r1%m));\n		}\n\n	}\n\n}\n","combinatorics,dp,matrices,probabilities"
" //package Contest553;\n\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class mainF {\n    public static Scanner enter = new Scanner(System.in);\n    public static PrintWriter out = new PrintWriter(System.out);\n    public static void main(String[] args) {\n        long mod=(long)1e9+7;\n        int n=enter.nextInt();\n        long s=enter.nextLong();\n        int[] arr=new int[n];\n        int m=0;\n        long CON=n*(n-1)/2;\n        CON=bin_pow(CON,mod-2,mod);\n        for (int i = 0; i <n ; i++) {\n            arr[i]=enter.nextInt();\n            m+=arr[i];\n        }\n        int f_k=0;\n        for (int i = 0; i <n-m ; i++) {\n            f_k+=arr[i];\n        }\n        int k=n-m;\n        f_k=n-m-f_k;\n        /*if(m<n-m){//Если нулей больше чем единиц\n            k=m;\n            f_k=n-m-f_k;\n            m=n-m;\n        }*/\n        //f_k- кол-во нулей в первой части то есть это начальное состояние причём кол-во нулей меньше кол-ва единиц\n        long[][] CM=new long[k+1][k+1];\n        for (int i = Math.max(0,k-m); i <CM.length ; i++) {\n            CM[i][i]=(1-(long)(i*(m-k+i)+(k-i)*(k-i))*CON);\n            if(i<k) CM[i][i+1]=(long)(k-i)*(k-i)*CON;\n            if(i>0)CM[i][i-1]=(long)i*(m-k+i)*CON;\n        }\n        MATRIX_mod(CM,mod);\n        CM=bin_pow(CM,s,mod);\n        System.out.println((CM[f_k][k]+mod)%mod);\n\n\n\n    }\n    public static long bin_pow(long a,long b, long mod){//a^b %mod\n        long ans=1;\n        while(b!=0){\n            if((b&1)==1) ans*=a;\n            a*=a;\n            ans%=mod;\n            a%=mod;\n            b>>=1;\n        }\n        return ans;\n    }\n\n    public static long[][] bin_pow(long[][] a,long b, long mod){//a^b %mod\n        long[][] ans=new long[a.length][a.length];\n        for (int i = 0; i <ans.length ; i++) ans[i][i]=1;\n        while(b!=0){\n            if((b&1)==1) ans=MATRIX_mult(ans,a);\n            a=MATRIX_mult(a,a);\n            MATRIX_mod(ans,mod);\n            MATRIX_mod(a,mod);\n            b>>=1;\n        }\n        return ans;\n    }\n    public static long[][] MATRIX_mult(long[][] a, long[][] b) { //b не меняем a=a*b;\n        long[][] c=new long[a.length][a.length];\n        for (int i = 0; i <a.length ; i++) {\n            for (int j = 0; j <a.length ; j++) {\n                for (int k = 0; k <a.length ; k++) {\n                    c[i][j]+=a[i][k]*b[k][j];\n                    c[i][j]%=(long)(1e9+7);\n                }\n            }\n        }\n        return c;\n    }\n    public static void MATRIX_mod(long[][] a, long mod){\n        for (int i = 0; i <a.length ; i++) {\n            for (int j = 0; j <a.length ; j++) {\n                a[i][j]%=mod;\n            }\n        }\n    }\n}\n","combinatorics,dp,matrices,probabilities"
"import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static long MOD = 1000000007;\n\n    public static void main(String[] args) {\n        final Scanner scanner = new Scanner(System.in);\n        final int n = scanner.nextInt();\n        final int k = scanner.nextInt();\n\n        final ArrayList<Integer> values = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) {\n            values.add(scanner.nextInt());\n        }\n        \n        final int zeroCount = values.stream().filter(integer -> integer.equals(0)).mapToInt(i -> 1).sum();\n        final int oneCount = n - zeroCount;\n        final int size = Math.min(zeroCount, oneCount);\n\n        long[][] table = new long[size + 1][size + 1];\n\n        int diff = 0;\n        for (int i = 0; i < n; i++) {\n            if (values.get(i) == 0 && i >= zeroCount) {\n                diff++;\n            }\n        }\n\n\n        final int allPosible = (n * (n - 1)) / 2;\n        final long allPosibleInverse = binPow(allPosible, MOD - 2);\n        for (int i = 0; i < size + 1; i++) {\n            for (int j = 0; j < size + 1; j++) {\n\n                if (i - j == 1) {\n                    table[i][j] = i * i * allPosibleInverse;\n                }\n\n                if (i - j == 0) {\n                    table[i][j] = (allPosible - i * i - (zeroCount - i) * (oneCount - i)) * allPosibleInverse;\n                }\n\n                if (i - j == -1) {\n                    table[i][j] = (zeroCount - i) * (oneCount - i) * allPosibleInverse;\n                }\n                table[i][j] = table[i][j] % MOD;\n            }\n        }\n\n        table = binPow(table, k);\n\n//        for (long[] longs : table) {\n//            for (long value : longs) {\n//                System.out.printf(""%10d"", value);\n//            }\n//            System.out.println();\n//        }\n\n        System.out.println(table[diff][0]);\n    }\n\n    private static long binPow(long n, long count) {\n        if (count == 0) {\n            return 1L;\n        }\n\n        long temp = binPow(n, count / 2);\n        temp = (temp * temp) % MOD;\n        if (count % 2 != 0) {\n            temp = (temp * n) % MOD;\n        }\n\n        return temp % MOD;\n    }\n\n    private static long[][] binPow(long[][] table, long count) {\n        if (count == 0) {\n            final long[][] ans = new long[table.length][table.length];\n            for (int i = 0; i < table.length; i++) {\n                ans[i][i] = 1;\n            }\n            return ans;\n        }\n\n        long[][] temp = binPow(table, count / 2);\n        temp = (mul(temp, temp));\n        if (count % 2 != 0) {\n            temp = mul(temp, table);\n        }\n\n        return temp;\n    }\n\n    private static long[][] mul(long[][] a, long[][] b) {\n        final long[][] ans = new long[a.length][a.length];\n        for (int i = 0; i < a.length; i++) {\n            for (int j = 0; j < a.length; j++) {\n                for (int k = 0; k < a.length; k++) {\n                    ans[i][j] += (a[i][k] * b[k][j]) % MOD;\n                    ans[i][j] = ans[i][j] % MOD;\n                }\n            }\n        }\n        return ans;\n    }\n}","combinatorics,dp,matrices,probabilities"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.stream.IntStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.util.OptionalInt;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            EElectionPromises solver = new EElectionPromises();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class EElectionPromises {\n        IntegerVersionArray iva = new IntegerVersionArray((int) 1e6);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.ri();\n            int m = in.ri();\n            Node[] nodes = new Node[n];\n            for (int i = 0; i < n; i++) {\n                nodes[i] = new Node();\n                nodes[i].h = in.ri();\n            }\n            for (int i = 0; i < m; i++) {\n                Node a = nodes[in.ri() - 1];\n                Node b = nodes[in.ri() - 1];\n                a.adj.add(b);\n            }\n            int[] sg = new int[n];\n            for (int i = 0; i < n; i++) {\n                sg[sg(nodes[i])] ^= nodes[i].h;\n            }\n            int max = Arrays.stream(sg).max().orElse(-1);\n            if (max == 0) {\n                out.println(""LOSE"");\n                return;\n            }\n            out.println(""WIN"");\n            int maxIndex = 0;\n            for (int i = 0; i < n; i++) {\n                if (sg[i] > 0) {\n                    maxIndex = i;\n                }\n            }\n            Node end = null;\n            for (Node node : nodes) {\n                if (sg(node) == maxIndex && (node.h ^ sg[maxIndex]) < node.h) {\n                    end = node;\n                    break;\n                }\n            }\n            end.h ^= sg[maxIndex];\n            sg[maxIndex] = 0;\n            for (Node node : end.adj) {\n                node.h ^= sg[sg(node)];\n                sg[sg(node)] = 0;\n            }\n            for (Node node : nodes) {\n                out.append(node.h).append(' ');\n            }\n        }\n\n        public int sg(Node root) {\n            if (root.sg == -1) {\n                root.sg = 0;\n                for (Node node : root.adj) {\n                    sg(node);\n                }\n                iva.clear();\n                for (Node node : root.adj) {\n                    iva.set(sg(node), 1);\n                }\n                while (iva.get(root.sg) == 1) {\n                    root.sg++;\n                }\n            }\n            return root.sg;\n        }\n\n    }\n\n    static class IntegerVersionArray {\n        int[] data;\n        int[] version;\n        int now;\n        int[] def;\n\n        public IntegerVersionArray(int cap) {\n            this(cap, null);\n        }\n\n        public IntegerVersionArray(int cap, int[] def) {\n            data = new int[cap];\n            version = new int[cap];\n            now = 0;\n            this.def = def;\n        }\n\n        public void clear() {\n            now++;\n        }\n\n        public void visit(int i) {\n            if (version[i] < now) {\n                version[i] = now;\n                data[i] = def == null ? 0 : def[i];\n            }\n        }\n\n        public void set(int i, int v) {\n            version[i] = now;\n            data[i] = v;\n        }\n\n        public int get(int i) {\n            visit(i);\n            return data[i];\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < data.length; i++) {\n                if (version[i] < now) {\n                    continue;\n                }\n                builder.append(i).append(':').append(data[i]).append(',');\n            }\n            if (builder.length() > 0) {\n                builder.setLength(builder.length() - 1);\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static class Node {\n        List<Node> adj = new ArrayList<>();\n        int h;\n        int sg = -1;\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int ri() {\n            return readInt();\n        }\n\n        public int readInt() {\n            boolean rev = false;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                rev = next == '-';\n                next = read();\n            }\n\n            int val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 - next + '0';\n                next = read();\n            }\n\n            return rev ? val : -val;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 32 << 10;\n        private OutputStream writer;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n        private static Field stringBuilderValueField;\n        private char[] charBuf = new char[THRESHOLD * 2];\n        private byte[] byteBuf = new byte[THRESHOLD * 2];\n\n        static {\n            try {\n                stringBuilderValueField = StringBuilder.class.getSuperclass().getDeclaredField(""value"");\n                stringBuilderValueField.setAccessible(true);\n            } catch (Exception e) {\n                stringBuilderValueField = null;\n            }\n            stringBuilderValueField = null;\n        }\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n\n        public FastOutput(OutputStream writer) {\n            this.writer = writer;\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(String c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput println(String c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            return append('\n');\n        }\n\n        public FastOutput flush() {\n            try {\n                if (stringBuilderValueField != null) {\n                    try {\n                        byte[] value = (byte[]) stringBuilderValueField.get(cache);\n                        writer.write(value, 0, cache.length());\n                    } catch (Exception e) {\n                        stringBuilderValueField = null;\n                    }\n                }\n                if (stringBuilderValueField == null) {\n                    int n = cache.length();\n                    if (n > byteBuf.length) {\n                        //slow\n                        writer.write(cache.toString().getBytes(StandardCharsets.UTF_8));\n//                writer.append(cache);\n                    } else {\n                        cache.getChars(0, n, charBuf, 0);\n                        for (int i = 0; i < n; i++) {\n                            byteBuf[i] = (byte) charBuf[i];\n                        }\n                        writer.write(byteBuf, 0, n);\n                    }\n                }\n                writer.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                writer.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n}\n\n","games,graphs"
"import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n \nimport static java.lang.Math.*;\n \npublic class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n \n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        \n        public int read() {\n            if (numChars==-1) \n                throw new InputMismatchException();\n            \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                \n                if(numChars <= 0)               \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n            \n            while(isSpaceChar(c)) \n                c = read();\n            \n            int sgn = 1;\n            \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            \n            int res = 0;\n            do {\n                if(c<'0'||c>'9') \n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c)); \n            \n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n        \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } \n            while (!isSpaceChar(c));\n            \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n        \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(),""Main"",1<<27).start();\n    } \n    void findCol(int i) {\n        HashSet<Integer> set = new HashSet<>();\n\n        for(int j : adj[i]) {\n            if(col[j] == -1)\n                findCol(j);\n\n            set.add(col[j]);\n        }\n\n        for(int j = 0; ; ++j) {\n            if(!set.contains(j)) {\n                col[i] = j;\n                break;\n            }\n        }\n    }\n    ArrayList<Integer> adj[];\n    int col[];\n    public void run() {\n        InputReader sc = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        int h[] = new int[n];\n        for(int i = 0; i < n; ++i)\n            h[i] = sc.nextInt();\n\n        adj = new ArrayList[n];\n        for(int i = 0; i < n; ++i)\n            adj[i] = new ArrayList<>();\n\n        for(int i = 0; i < m; ++i) {\n            int u = sc.nextInt() - 1;\n            int v = sc.nextInt() - 1;\n            adj[u].add(v);\n        }\n\n        col = new int[n];\n        Arrays.fill(col, -1);\n        for(int i = 0; i < n; ++i) {\n            if(col[i] == -1)\n                findCol(i);\n        }\n\n        int xor[] = new int[n];\n        for(int i = 0; i < n; ++i)\n            xor[col[i]] ^= h[i];\n\n        int curCol = -1;\n        for(int i = 0; i < n; ++i) {\n            if(xor[i] != 0)\n                curCol = i;\n        }\n\n        if(curCol == -1)\n            w.print(""LOSE"");\n        else {\n            w.println(""WIN"");\n\n            int ind = -1;\n            for(int i = 0; i < n; ++i) {\n                if(col[i] == curCol) {\n                    if((h[i] ^ xor[curCol]) < h[i])\n                        ind = i;\n                }\n            }\n\n            h[ind] ^= xor[col[ind]];\n            xor[col[ind]] = 0;\n\n            for(int j : adj[ind]) {\n                h[j] ^= xor[col[j]];\n                xor[col[j]] = 0;\n            }\n\n            for(int i : h)\n                w.print(i + "" "");\n        }\n\n        w.close();\n    }\n}","games,graphs"
"\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class CF1149E {\n    public static void main(String[] args) throws Exception {\n        boolean local = System.getProperty(""ONLINE_JUDGE"") == null;\n        boolean async = false;\n\n        Charset charset = Charset.forName(""ascii"");\n\n        FastIO io = local ? new FastIO(new FileInputStream(""D:\\DATABASE\\TESTCASE\\Code.in""), System.out, charset) : new FastIO(System.in, System.out, charset);\n        Task task = new Task(io, new Debug(local));\n\n        if (async) {\n            Thread t = new Thread(null, task, ""dalt"", 1 << 27);\n            t.setPriority(Thread.MAX_PRIORITY);\n            t.start();\n            t.join();\n        } else {\n            task.run();\n        }\n\n        if (local) {\n            io.cache.append(""\n\n--memory -- \n"" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + ""M"");\n        }\n\n        io.flush();\n    }\n\n    public static class Task implements Runnable {\n        final FastIO io;\n        final Debug debug;\n        int inf = (int) 1e8;\n        int mod = (int) 1e9 + 7;\n\n        public int mod(int val) {\n            val %= mod;\n            if (val < 0) {\n                val += mod;\n            }\n            return val;\n        }\n\n        public int mod(long val) {\n            val %= mod;\n            if (val < 0) {\n                val += mod;\n            }\n            return (int) val;\n        }\n\n        public Task(FastIO io, Debug debug) {\n            this.io = io;\n            this.debug = debug;\n        }\n\n        @Override\n        public void run() {\n            solve();\n        }\n\n        public void solve() {\n            int n = io.readInt();\n            int m = io.readInt();\n            Node[] nodes = new Node[n + 1];\n\n            for (int i = 1; i <= n; i++) {\n                nodes[i] = new Node();\n            }\n\n            for (int i = 1; i <= n; i++) {\n                nodes[i].tax = io.readInt();\n            }\n            for (int i = 0; i < m; i++) {\n                nodes[io.readInt()].next.add(nodes[io.readInt()]);\n            }\n\n            for (int i = 1; i <= n; i++) {\n                dfs(nodes[i]);\n            }\n\n            int[] xor = new int[n];\n            for (int i = 1; i <= n; i++) {\n                xor[nodes[i].mex] ^= nodes[i].tax;\n            }\n\n            boolean allZero = true;\n            int mex = n - 1;\n            for (int i = 0; i < n; i++) {\n                allZero = allZero && xor[i] == 0;\n                if (xor[i] != 0) {\n                    mex = i;\n                }\n            }\n\n            if (allZero) {\n                io.cache.append(""LOSE"");\n                return;\n            }\n\n\n            Node heldOn = null;\n            for (int i = 1; i <= n; i++) {\n                if (nodes[i].mex == mex && (nodes[i].tax ^ xor[mex]) < nodes[i].tax) {\n                    heldOn = nodes[i];\n                    break;\n                }\n            }\n\n            heldOn.tax = heldOn.tax ^ xor[mex];\n            xor[mex] = 0;\n            for (Node node : heldOn.next) {\n                if (xor[node.mex] == 0) {\n                    continue;\n                }\n                node.tax ^= xor[node.mex];\n                xor[node.mex] = 0;\n            }\n\n            io.cache.append(""WIN\n"");\n            for (int i = 1; i <= n; i++) {\n                io.cache.append(nodes[i].tax).append(' ');\n            }\n        }\n\n        public void dfs(Node root) {\n            if (root.visited) {\n                return;\n            }\n            root.visited = true;\n            for (Node node : root.next) {\n                dfs(node);\n            }\n            root.next.sort((a, b) -> a.mex - b.mex);\n            root.mex = 0;\n            for (Node node : root.next) {\n                if (node.mex > root.mex) {\n                    break;\n                }\n                if (node.mex == root.mex) {\n                    root.mex++;\n                }\n            }\n        }\n\n    }\n\n    public static class FastIO {\n        public final StringBuilder cache = new StringBuilder();\n        private final InputStream is;\n        private final OutputStream os;\n        private final Charset charset;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 8);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastIO(InputStream is, OutputStream os, Charset charset) {\n            this.is = is;\n            this.os = os;\n            this.charset = charset;\n        }\n\n        public FastIO(InputStream is, OutputStream os) {\n            this(is, os, Charset.forName(""ascii""));\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public double readDouble() {\n            boolean sign = true;\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+';\n                next = read();\n            }\n\n            long val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 + next - '0';\n                next = read();\n            }\n            if (next != '.') {\n                return sign ? val : -val;\n            }\n            next = read();\n            long radix = 1;\n            long point = 0;\n            while (next >= '0' && next <= '9') {\n                point = point * 10 + next - '0';\n                radix = radix * 10;\n                next = read();\n            }\n            double result = val + (double) point / radix;\n            return sign ? result : -result;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n        public int readLine(char[] data, int offset) {\n            int originalOffset = offset;\n            while (next != -1 && next != '\n') {\n                data[offset++] = (char) next;\n                next = read();\n            }\n            return offset - originalOffset;\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public int readString(byte[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (byte) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n        public void flush() {\n            try {\n                os.write(cache.toString().getBytes(charset));\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public boolean hasMore() {\n            skipBlank();\n            return next != -1;\n        }\n    }\n\n    public static class Debug {\n        private boolean allowDebug;\n\n        public Debug(boolean allowDebug) {\n            this.allowDebug = allowDebug;\n        }\n\n        public void assertTrue(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (!flag) {\n                fail();\n            }\n        }\n\n        public void fail() {\n            throw new RuntimeException();\n        }\n\n        public void assertFalse(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (flag) {\n                fail();\n            }\n        }\n\n        private void outputName(String name) {\n            System.out.print(name + "" = "");\n        }\n\n        public void debug(String name, int x) {\n            if (!allowDebug) {\n                return;\n            }\n\n            outputName(name);\n            System.out.println("""" + x);\n        }\n\n        public void debug(String name, long x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println("""" + x);\n        }\n\n        public void debug(String name, double x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println("""" + x);\n        }\n\n        public void debug(String name, int[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, long[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, double[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, Object x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println("""" + x);\n        }\n\n        public void debug(String name, Object... x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.deepToString(x));\n        }\n    }\n\n    public static class Node {\n        boolean visited;\n        int mex;\n        int tax;\n        List<Node> next = new ArrayList<>();\n    }\n}\n","games,graphs"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1148F extends PrintWriter {\n	CF1148F() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1148F o = new CF1148F(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int[] aa = new int[n];\n		long[] mask = new long[n];\n		long sum = 0;\n		for (int i = 0; i < n; i++) {\n			sum += aa[i] = sc.nextInt();\n			mask[i] = sc.nextLong();\n		}\n		if (sum < 0)\n			for (int i = 0; i < n; i++)\n				aa[i] = -aa[i];\n		long ans = 0;\n		for (int k = 0; k < 62; k++) {\n			long b = 1L << k;\n			sum = 0;\n			for (int i = 0; i < n; i++)\n				if (mask[i] == b)\n					sum += aa[i];\n			boolean flip = sum > 0;\n			if (flip)\n				ans |= b;\n			for (int i = 0; i < n; i++)\n				if ((mask[i] & b) != 0) {\n					if (flip)\n						aa[i] = -aa[i];\n					mask[i] ^= b;\n				}\n		}\n		println(ans);\n	}\n}\n","bitmasks,constructive algorithms"
"import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class F {\n\n	static void solve() throws Exception {\n		int n = scanInt();\n		int val[] = new int[n];\n		long mask[] = new long[n];\n		long sum = 0;\n		for (int i = 0; i < n; i++) {\n			sum += val[i] = scanInt();\n			mask[i] = scanLong();\n		}\n		int sgn = Long.signum(sum);\n		long s = 0;\n		for (int bit = 0; bit < 62; bit++) {\n			long sum0 = 0, sum1 = 0;\n			for (int i = 0; i < n; i++) {\n				if (mask[i] >> bit == 0) {\n					sum0 += val[i];\n				} else if (mask[i] >> bit == 1) {\n					sum1 += val[i];\n				}\n			}\n			int sgn0 = Long.signum(sum0 + sum1), sgn1 = Long.signum(sum0 - sum1);\n			if (sgn1 * sgn < sgn0 * sgn) {\n				s |= 1L << bit;\n				for (int i = 0; i < n; i++) {\n					if ((mask[i] & (1L << bit)) != 0) {\n						val[i] = -val[i];\n					}\n				}\n			}\n		}\n		out.print(s);\n	}\n\n	static int scanInt() throws IOException {\n		return parseInt(scanString());\n	}\n\n	static long scanLong() throws IOException {\n		return parseLong(scanString());\n	}\n\n	static String scanString() throws IOException {\n		while (tok == null || !tok.hasMoreTokens()) {\n			tok = new StringTokenizer(in.readLine());\n		}\n		return tok.nextToken();\n	}\n\n	static BufferedReader in;\n	static PrintWriter out;\n	static StringTokenizer tok;\n\n	public static void main(String[] args) {\n		try {\n			in = new BufferedReader(new InputStreamReader(System.in));\n			out = new PrintWriter(System.out);\n			solve();\n			in.close();\n			out.close();\n		} catch (Throwable e) {\n			e.printStackTrace();\n			exit(1);\n		}\n	}\n}","bitmasks,constructive algorithms"
"import java.io.*;\nimport java.util.*;\n\npublic class cF {\n	int M = 62;\n	Random rnd = new Random(566);\n	\n	void run() {\n		int n = in.nextInt();\n		int[] val = new int[n];\n		long[] mask = new long[n];\n		long sum = 0;\n		for (int i = 0; i < n; i++) {\n			val[i] = in.nextInt();\n			mask[i] = in.nextLong();\n			sum += val[i];\n		}\n		if (sum < 0) {\n			for (int i = 0; i < n; i++) {\n				val[i] *= -1;\n			}\n		}\n		long ans = 0;\n		for (int j = 0; j < M; j++) {\n			sum = 0;\n			for (int i = 0; i < n; i++) {\n				if ((mask[i] >> j) == 1) {\n					sum += val[i];\n				}\n			}\n			if (sum <= 0) {\n				continue;\n			}\n			ans ^= (1L << j);\n			for (int i = 0; i < n; i++) {\n				if (((mask[i] >> j) & 1) != 0) {\n					val[i] *= -1;\n				}\n			}\n		}\n		out.println(ans);\n	}\n\n	static MyScanner in;\n	static PrintWriter out;\n\n	public static void main(String[] args) throws IOException {\n		boolean stdStreams = true;\n		String fileName = cF.class.getSimpleName().replaceFirst(""_.*"", """").toLowerCase();\n		String inputFileName = fileName + "".in"";\n		String outputFileName = fileName + "".out"";\n		\n		Locale.setDefault(Locale.US);\n		BufferedReader br;\n		if (stdStreams) {\n			br = new BufferedReader(new InputStreamReader(System.in));\n			out = new PrintWriter(System.out);\n		} else {\n			br = new BufferedReader(new FileReader(inputFileName));\n			out = new PrintWriter(outputFileName);\n		}\n		in = new MyScanner(br);\n		int tests = 1;//in.nextInt();\n		for (int test = 0; test < tests; test++) {\n			//out.print(""Case #"" + (test + 1) + "": "");\n			new cF().run();\n		}\n		br.close();\n		out.close();\n	}\n	\n	static class MyScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		MyScanner(BufferedReader br) {\n			this.br = br;\n		}\n		\n		void findToken() {\n			while (st == null || !st.hasMoreTokens()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n		}\n		\n		String next() {\n			findToken();\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n		\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n	}\n}\n","bitmasks,constructive algorithms"
"import java.io.*;\nimport java.util.*;\n\npublic class cF {\n	int M = 62;\n	Random rnd = new Random(566);\n	\n	void run() {\n		int n = in.nextInt();\n		int[] val = new int[n];\n		long[] mask = new long[n];\n		long sum = 0;\n		for (int i = 0; i < n; i++) {\n			val[i] = in.nextInt();\n			mask[i] = in.nextLong();\n			sum += val[i];\n		}\n		if (sum < 0) {\n			for (int i = 0; i < n; i++) {\n				val[i] *= -1;\n			}\n			sum *= -1;\n		}\n		long ans = 0;\n		for (int j = 0; j < M; j++) {\n			long curSum = 0;\n			for (int i = 0; i < n; i++) {\n				if ((mask[i] >> j) == 1) {\n					curSum += val[i];\n				}\n			}\n			if (curSum <= 0) {\n				continue;\n			}\n			ans ^= (1L << j);\n			for (int i = 0; i < n; i++) {\n				if (((mask[i] >> j) & 1) != 0) {\n					val[i] *= -1;\n				}\n			}\n		}\n		out.println(ans);\n	}\n\n	static MyScanner in;\n	static PrintWriter out;\n\n	public static void main(String[] args) throws IOException {\n		boolean stdStreams = true;\n		String fileName = cF.class.getSimpleName().replaceFirst(""_.*"", """").toLowerCase();\n		String inputFileName = fileName + "".in"";\n		String outputFileName = fileName + "".out"";\n		\n		Locale.setDefault(Locale.US);\n		BufferedReader br;\n		if (stdStreams) {\n			br = new BufferedReader(new InputStreamReader(System.in));\n			out = new PrintWriter(System.out);\n		} else {\n			br = new BufferedReader(new FileReader(inputFileName));\n			out = new PrintWriter(outputFileName);\n		}\n		in = new MyScanner(br);\n		int tests = 1;//in.nextInt();\n		for (int test = 0; test < tests; test++) {\n			//out.print(""Case #"" + (test + 1) + "": "");\n			new cF().run();\n		}\n		br.close();\n		out.close();\n	}\n	\n	static class MyScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		MyScanner(BufferedReader br) {\n			this.br = br;\n		}\n		\n		void findToken() {\n			while (st == null || !st.hasMoreTokens()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n		}\n		\n		String next() {\n			findToken();\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n		\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n	}\n}\n","bitmasks,constructive algorithms"
"import java.util.Scanner;\npublic class Solution{\n    public static void main(String args[]){\n        Scanner in=new Scanner(System.in);\n        int n=in.nextInt();\n        \n        int arr[]=new int[n+1];\n        for(int i=0;i<n;i++)\n            arr[i]=in.nextInt();\n        \n        int inc=-1,desc=Integer.MAX_VALUE;\n        for(int i=0;i<n;i++){\n            if(inc<arr[i] && (arr[i]<arr[i+1] || arr[i]>=desc)){\n                inc=arr[i];\n                arr[i]=0;\n            }\n            else if(arr[i]<desc){\n                desc=arr[i];\n                arr[i]=1;\n            }\n            else{\n                System.out.println(""NO"");\n                return;\n            }\n        }\n        \n        System.out.println(""YES"");\n        for(int i=0;i<n;i++)\n            System.out.print(arr[i]+"" "");\n        System.out.println();\n    }\n}","dp,greedy"
"import java.util.*;\npublic class TwoMergedSequence\n{\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] arr = new int[n+1];\n        for(int i = 0; i<n;i++)\n        arr[i] = sc.nextInt();\n        int inc = -1;\n        int des = Integer.MAX_VALUE;\n        for(int i = 0; i<n;i++)\n        {\n            if(inc<arr[i] && (arr[i]<arr[i+1] || arr[i]>=des))\n            {\n                inc = arr[i];\n                arr[i] = 0;\n            }\n            else if (des>arr[i])\n            {\n                des = arr[i];\n                arr[i] = 1;\n            }\n            else\n            {\n                System.out.println(""NO"");\n                return;\n            }\n        }\n        System.out.println(""YES"");\n        for(int i = 0;i<n;i++)\n        {\n            System.out.print(arr[i]+"" "");\n        }\n    }\n}","dp,greedy"
"\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n	public static int max(int x,int y) {\n		return x > y ? x : y;\n	}\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		/**\n		 * dp(i,0) = true \n		 * I:dp(i-1,1) = true && a(i-1,1) < x(i)\n		 * II:dp(i-1,0) = true && x(i-1) < x(i)\n		 * dp(i,1) = true \n		 * I:dp(i-1,1) = true && x(i-1) > x(i)\n		 * II:dp(i-1,0) = true && a(i-1,0) > x(i)\n		 * */\n		int n;\n		Scanner scanner = new Scanner(System.in);\n		n = scanner.nextInt();\n		int x[] = new int[n+5],a[][] = new int[n+5][2];\n		boolean dp[][] = new boolean[n+5][2],pre[][] = new boolean[n+5][2],flag = true;\n		x[0] = 200005;x[n+1] = -1;\n		for(int i = 1;i <= n;++i) {\n			x[i] = scanner.nextInt();\n			if(i == 1) {\n				dp[i][0] = dp[i][1] = true;\n				a[i][0] = 0;\n				a[i][1] = n+1;\n				continue;\n			}\n			if(dp[i-1][1] && x[a[i-1][1]] < x[i]) {\n				dp[i][0] = true;\n				pre[i][0] = true;\n				a[i][0] = i-1;\n			}\n			if(dp[i-1][0] && x[i-1] < x[i]) {\n				dp[i][0] = true;\n				pre[i][0] = false;\n				a[i][0] = a[i-1][0];\n			}\n			if(dp[i-1][0] && x[a[i-1][0]] > x[i]) {\n				dp[i][1] = true;\n				pre[i][1] = false;\n				a[i][1] = i-1;\n			}\n			if(dp[i-1][1] && x[i-1] > x[i]) {\n				dp[i][1] = true;\n				pre[i][1] = true;\n				a[i][1] = a[i-1][1];\n			}\n			if(!dp[i][0] && !dp[i][1]) flag = false;\n		}\n		if(flag) {\n			System.out.println(""YES"");\n			int j = n,k = 0;\n			if(!dp[n][0]) {\n				j = n;\n				k = 1;\n			}\n			Stack<Integer> st = new Stack<Integer>();\n			do {\n				st.push(k);\n				boolean t = pre[j][k];\n				if(!t) {\n					k = 0;\n				}else {\n					k = 1;\n				}\n				--j;\n			}while(j >= 1);\n			while(!st.empty()) {\n				System.out.print(st.pop()+"" "");\n			}\n		}else {\n			System.out.println(""NO"");\n		}\n	}\n\n}\n","dp,greedy"
"import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    PP solver = new PP();\n    solver.run(1, in, out);\n    out.close();\n  }\n\n  static class PP {\n    public void run(int testNumber, InputReader in, PrintWriter out) {\n      int n = in.nextInt();\n      int[] a = new int[n];\n      for (int i = 0; i < n; i++) {\n        a[i] = in.nextInt();\n      }\n      StringBuilder ans = new StringBuilder();\n      int l = Integer.MIN_VALUE, h = Integer.MAX_VALUE;\n      for (int i = 0; i < n; i++) {\n        if (a[i] > l && a[i] < h) {\n          if (i < n - 1 && a[i + 1] > a[i]) {\n            l = a[i];\n            ans.append('0');\n          } else {\n            h = a[i];\n            ans.append('1');\n          }\n        } else if (a[i] > l) {\n          l = a[i];\n          ans.append('0');\n        } else if (a[i] < h) {\n          h = a[i];\n          ans.append('1');\n        } else {\n          out.println(""NO"");\n          return;\n        }\n        ans.append(' ');\n      }\n      out.println(""YES"");\n      out.println(ans);\n    }\n  }\n\n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream), 32768);\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n  }\n}","dp,greedy"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1143D extends PrintWriter {\n	CF1143D() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1143D o = new CF1143D(); o.main(); o.flush();\n	}\n\n	long gcd(long a, long b) {\n		return b == 0 ? a : gcd(b, a % b);\n	}\n	long solve(int n, int k, int a, int b, int i) {\n		int c = b - a;\n		if (c <= 0)\n			c += k;\n		long l = c + (long) i * k;\n		long m = (long) n * k;\n		long d = gcd(m, l);\n		return m / d;\n	}\n	void main() {\n		int n = sc.nextInt();\n		int k = sc.nextInt();\n		int a = sc.nextInt();\n		int b = sc.nextInt();\n		long x = (long) n * k, y = 0;\n		for (int a_ : new int[] { a, k - a })\n			for (int b_ : new int[] { b, k - b })\n				for (int i = 0; i < n; i++) {\n					long z = solve(n, k, a_, b_, i);\n					x = Math.min(x, z);\n					y = Math.max(y, z);\n				}\n		println(x + "" "" + y);\n	}\n}\n","brute force,math"
"//package thebeatles;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class thebeatles {\n	\n	public static long gcd(long a, long b) {\n		if(b == 0) {\n			return a;\n		}\n		return gcd(b, a % b);\n	}\n	\n	public static void main(String[] args) throws IOException {\n		BufferedReader fin = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer(fin.readLine());\n		long n = Integer.parseInt(st.nextToken());\n		long k = Integer.parseInt(st.nextToken());\n		st = new StringTokenizer(fin.readLine());\n		int a = Integer.parseInt(st.nextToken());\n		int b = Integer.parseInt(st.nextToken());\n		long min = Long.MAX_VALUE;\n		long max = 0;\n		long totalDist = n * k;\n		for(int i = 0; i <= n; i++) {\n			long d1 = (long) i * k + b - a;\n			long d2 = (long) (i + 1) * k - b - a;\n			if(d1 > 0) {\n				long cur = totalDist / gcd(totalDist, d1);\n				min = Math.min(cur, min);\n				max = Math.max(cur, max);\n			}\n			if(d2 > 0) {\n				long cur = totalDist / gcd(totalDist, d2);\n				min = Math.min(cur, min);\n				max = Math.max(cur, max);\n			}\n		}\n		System.out.println(min + "" "" + max);\n	}\n}\n","brute force,math"
"import java.util.*;\nimport java.io.*;\n\npublic class _1142_A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        StringTokenizer line = new StringTokenizer(in.readLine());\n        int n = Integer.parseInt(line.nextToken());\n        int k = Integer.parseInt(line.nextToken());\n        line = new StringTokenizer(in.readLine());\n        int a = Integer.parseInt(line.nextToken());\n        int b = Integer.parseInt(line.nextToken());\n        long min = Long.MAX_VALUE;\n        long max = 0;\n        long total = (long)n * k;\n        for(int i = 0; i <= n; i++) {\n            long l1 = (long)i * k + b - a;\n            long l2 = (long)(i + 1) * k - b - a;\n            if(l1 > 0) {\n                long stops = stops(l1, total);\n                min = Math.min(min, stops);\n                max = Math.max(max, stops);\n            }\n            if(l2 > 0) {\n                long stops = stops(l2, total);\n                min = Math.min(min, stops);\n                max = Math.max(max, stops);\n            }\n        }\n        out.println(min + "" "" + max);\n        in.close();\n        out.close();\n    }\n    static long gcd(long a, long b) {\n        if(b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n    static long stops(long l, long total) {\n        return total / gcd(total, l);\n    }\n}\n","brute force,math"
"import java.io.*;\nimport java.util.*;\n\npublic class D{\n	static long n,k;\n	static long b;\n	static void solve(long start) {\n		for (long p: pos) {\n			long v1 = ansMin(start,p-b,true);\n			long v2 = ansMin(start,p+b,false);\n			//System.out.println(start + "" "" + (p-b) + "" "" + (p+b));\n			//System.out.println(start + "" "" + v1 + "" "" +v2 + "" "" + min + "" "" + max);\n			min = Long.min(min, v1);\n			max = Long.max(max, v2);\n		}\n	}\n	\n	static long ansMin(long p1, long p2,boolean solveMin) {\n		long tot = n*k;\n		long dist = Math.abs(p1-p2)%tot;\n		long comp = tot-dist;\n		if (dist == 0 || comp == 0) return 1;\n		long v1 = tot/gcd(tot,dist);\n		long v2 = tot/gcd(tot,comp);\n		if (solveMin) return Long.min(v1, v2);\n		return Long.max(v1, v2);\n	}\n	\n	static long gcd(long a, long b) {\n		if (a==0) return b;\n		return gcd(b%a,a);\n	}\n	static long min = Long.MAX_VALUE;\n	static long max = Long.MIN_VALUE;\n	static List<Long> pos = new ArrayList<Long>();\n	public static void main(String[] args) throws IOException {\n		// br = new BufferedReader(new FileReader("".in""));\n		// out = new PrintWriter(new FileWriter("".out""));\n		//new Thread(null, new (), ""peepee"", 1<<28).start();\n		n  =readLong();\n		k=readLong();\n		for (long i = 0; i < n; i++) pos.add(1L+i*k);\n		long a=readLong();\n		b=readLong();\n		solve(a+1);\n		solve(1L-a);\n		out.println(min +  ""  "" + max);\n		out.close();\n	}\n	\n	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n	static StringTokenizer st = new StringTokenizer("""");\n	static String read() throws IOException{return st.hasMoreTokens() ? st.nextToken():(st = new StringTokenizer(br.readLine())).nextToken();}\n	static int readInt() throws IOException{return Integer.parseInt(read());}\n	static long readLong() throws IOException{return Long.parseLong(read());}\n	static double readDouble() throws IOException{return Double.parseDouble(read());}\n	\n}","brute force,math"
"import java.util.*;\npublic class MaximalContinuousRest {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();List<Integer> a=new ArrayList<>();\n		for(int i=0;i<n;i++)a.add(sc.nextInt());\n		a.addAll(a);int cnt=0,c=0;\n		for(int i=0;i<2*n;i++) {\n			if(a.get(i)==1)c++;\n			else c=0;\n			cnt=Math.max(c, cnt);\n		}\n		System.out.println(cnt);\n\n	}\n\n}\n",implementation
import java.util.*;\npublic class test \n{\n	public static void main(String[] args) {\n		Scanner in=new Scanner(System.in);\n		int[] a=new int[in.nextInt()];\n		int max=0;\n		for(int i=0;i<a.length;i++)\n			a[i]=in.nextInt();\n		int x=0;\n		for(int j=0;j<2;j++)\n		{\n			for(int i:a)\n			{\n				if(i==1)\n					x++;\n				else\n				{\n					if(x>max)\n						max=x;\n					x=0;\n				}	\n			}\n		}\n		System.out.println(max);\n	}\n}\n	 		 	  	 	  		    	 	 					  	,implementation
"import java.util.Scanner;\npublic class rest {\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		int n = s.nextInt();\n		int arr[] = new int[n];\n		int i,max=0,count=0;\n		for(i=0;i<arr.length;i++)\n			arr[i]=s.nextInt();\n		for(i=0;i<arr.length*2+2;i++) {\n			if(arr[i%n]==1)\n				count++;\n			else {\n				if(count>max)\n					max=count;\n				count=0;\n			}\n		}\n		System.out.println(max);\n	}\n}",implementation
"import java.util.Scanner;\n\npublic class CR547B {\n	public static void main(String[] args) {\n		Scanner s=new Scanner(System.in);\n		\n		int n=s.nextInt();\n		\n		int [] a=new int[n];\n		\n		for(int i=0;i<n;i++) {\n			a[i]=s.nextInt();\n		}\n		int count=0,m=0;\n		\n		for(int i=0;i<2*n;i++) {\n			if(a[i%n]==1) {\n				count++;\n				if(count>m) {m=count;}\n			}\n			else {\n				count=0;\n			}\n		}\n		System.out.println(m);\n		\n	}\n\n}\n",implementation
"import java.util.*;\nimport static java.lang.Math.*;\n\npublic class SolutionC {\n	static void dfs(int i) {\n		vis[i] = 1;\n		cnt++;\n\n		for(int j : adj[i]) {\n			if(vis[j] == 0)\n				dfs(j);\n		}\n	}\n\n	static long fast_pow(long a, long b) {\n		if(b == 0)\n			return 1L;\n\n		long val = fast_pow(a, b / 2);\n\n		if(b % 2 == 0)\n			return val * val % mod;\n		else \n			return val * val % mod * a % mod;\n	}\n	static long mod = (long)1e9 + 7;\n\n	static ArrayList<Integer> adj[];\n	static int vis[];\n	static long cnt = 0;\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n\n		int n = sc.nextInt();\n		int k = sc.nextInt();\n\n		adj = new ArrayList[n];\n		for(int i = 0; i < n; ++i)\n			adj[i] = new ArrayList<>();\n\n		for(int i = 0; i < n - 1; ++i) {\n			int u = sc.nextInt() - 1;\n			int v = sc.nextInt() - 1;\n			int col = sc.nextInt();\n\n			if(col == 0) {\n				adj[u].add(v);\n				adj[v].add(u);\n			}\n		}\n\n		long ans = fast_pow(n, k);\n		long rem = 0;\n\n		vis = new int[n];\n		for(int i = 0; i < n; ++i) {\n			if(vis[i] == 0) {\n				cnt = 0;\n				dfs(i);\n				rem += fast_pow(cnt, k);\n			}\n		}\n\n		rem %= mod;\n		ans = (ans - rem + mod) % mod;\n\n		System.out.print(ans);\n	}\n}","dfs and similar,dsu,graphs,math,trees"
"import java.util.*;\n\n\npublic class aemrllijghaer {\n\n	static Scanner in = new Scanner(System.in);\n	static ArrayList<Integer>[] adj;\n	static int n;\n	static int k;\n	static int count;\n	static long ans;\n	static long rem;\n	static int[] vis;\n	static long mod = (long) (1e9+7);\n	\n	public static void main(String[] args) {\n		\n		int n = in.nextInt();\n		int k = in.nextInt();\n		\n		adj = new ArrayList[n];\n		\n		for(int i = 0; i < n; i++) {\n			adj[i] = new ArrayList<>();\n		}\n		\n		for(int i = 0; i < n-1; i++) {\n			\n			int u = in.nextInt()-1;\n			int v = in.nextInt()-1;\n			int x = in.nextInt();\n			\n			if(x == 0) {\n				adj[u].add(v);\n				adj[v].add(u);\n			}\n		}\n		\n		ans = (long) pow(n, k);\n		rem = 0;\n		\n		vis = new int[n];\n		\n		for(int i = 0; i < n; i++) {\n			if(vis[i] == 0) {\n				count = 0;\n				dfs(i);\n				rem += pow(count, k);\n			}\n		}\n		rem %= mod;\n		ans = (ans - rem + mod)%mod;\n		System.out.println(ans);\n		\n	}\n	\n	public static long pow(int a, int b) {\n		if(b == 0) return 1;\n		long val = pow(a,b/2);\n		if(b%2==0) return val * val % mod;\n		else return val * val % mod * a % mod;\n	}\n	\n	public static void dfs(int i) {\n		count++;\n		vis[i] = 1;\n		for(int x : adj[i]) {\n			if(vis[x] == 0) {\n				dfs(x);\n			}\n		}\n	}\n}","dfs and similar,dsu,graphs,math,trees"
"import java.util.ArrayList;\nimport java.util.Scanner;\n \npublic class Main {\n	\n	public static ArrayList<Integer>[] g;\n	public static boolean [] visited;\n	\n	public static int mod = (int) (1e9+7);\n	public static int cnt = 0;\n	\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		\n		int n = sc.nextInt();\n		int k = sc.nextInt();\n		\n		g = new ArrayList[n+1];\n		\n		for(int i = 0; i <= n; i++) {\n			g[i] = new ArrayList<Integer>();\n		}\n		visited = new boolean[n+1];\n\n		for(int i = 1; i < n; i++) {\n			int u = sc.nextInt();\n			int v = sc.nextInt();\n			int c = sc.nextInt();\n			\n			if(c != 1) {\n				g[u].add(v);\n				g[v].add(u);\n			}\n\n\n		}\n		long res = 0;\n		for(int i = 0; i <= n; i++) {\n			if(!visited[i]) {\n				cnt = 0;\n				dfs(i);\n				res+= fast_pow(cnt, k)%mod;\n			}\n			\n		}\n		res = res%mod;\n		int ges = (int) (fast_pow(n, k)%mod);\n		System.out.println((ges - res + mod+1) % mod);\n				\n	}\n	\n	static void dfs(int v) {\n		visited[v] = true;\n		cnt++;\n		for(int u : g[v]) {\n			if(!visited[u]) {\n				dfs(u);\n			}\n		}\n\n	}\n	\n	static long fast_pow(long a, long b) {\n		if(b == 0)\n			return 1L;\n \n		long val = fast_pow(a, b / 2);\n \n		if(b % 2 == 0)\n			return val * val % mod;\n		else \n			return val * val % mod * a % mod;\n	}\n\n}","dfs and similar,dsu,graphs,math,trees"
"\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Edges {\n	public static long mod = 1000000007;\n	public static ArrayList<ArrayList<Integer>> list;\n	public static int vis[];\n	static long count = 0;\n	public static long fast_pow(long a, long b) {\n		if(b == 0)\n			return 1L;\n \n		long val = fast_pow(a, b / 2);\n \n		if(b % 2 == 0)\n			return val * val % mod;\n		else \n			return val * val % mod * a % mod;\n	}\n	\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int k = sc.nextInt();\n		list =  new ArrayList<ArrayList<Integer>>(n);\n		for (int i = 0; i<=n; i++) {\n			list.add(new ArrayList<Integer>());\n		}\n		vis =  new int[n+1];\n		for (int i = 0; i < n-1; i++) {\n			int u = sc.nextInt();\n			int v = sc.nextInt();\n			int c = sc.nextInt();\n			if(c==0) {\n				list.get(u).add(v);\n				list.get(v).add(u);\n			}\n		}\n		long total = fast_pow(n, k)%mod;\n		long rem = 0;\n		for (int i = 1; i <=n; i++) {\n			if(vis[i]==0) {\n			count  = 0;\n			dfs(i);\n			rem = (rem%mod + (fast_pow(count,k))%mod)%mod;\n			}\n		}\n		System.out.println((total-rem+mod)%mod);\n	}\n\n	private static void dfs(int i) {\n		vis[i] = 1;\n		count++;\n		for (Integer e : list.get(i)) {\n			if(vis[e]==0) {\n				dfs(e);\n			}\n		}\n		\n	}\n\n}\n","dfs and similar,dsu,graphs,math,trees"
"import java.util.*;\nimport java.io.*;\npublic class Main {\n	public static void main(String[] args) throws IOException {\n		StreamTokenizer in=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n		in.nextToken();\n		int n=(int)in.nval;\n		in.nextToken();\n		int m=(int)in.nval;\n		ArrayList<Integer>[] h=new ArrayList[n+1];\n		ArrayList<Long>[] c=new ArrayList[n+1];\n		for (int i=1;i<=n;++i) {\n			h[i]=new ArrayList();\n			c[i]=new ArrayList();\n		}\n		for (int i=1;i<=n;++i) {\n			in.nextToken();\n			int k=(int)in.nval;\n			for (int j=0;j<k;++j) {\n				in.nextToken();\n				int a=(int)in.nval;\n				h[i].add(a);\n			}\n			for (int j=0;j<k;++j) {\n				in.nextToken();\n				long a=(long)in.nval;\n				c[i].add(a);\n			}\n		}\n		in.nextToken();\n		int q=(int)in.nval;\n		int[] H=new int[m+1];\n		long[] C=new long[m+1];\n		int cnt=0;\n		for (int i=0;i<q;++i) {\n			in.nextToken();\n			int id=(int)in.nval;\n			in.nextToken();\n			int mul=(int)in.nval;\n			for (int j=0;j<h[id].size();++j) {\n				H[++cnt]=h[id].get(j);\n				C[cnt]=1L*c[id].get(j)*mul;\n			}\n		}\n		int[] L=new int[m+1];\n		int[] R=new int[m+1];\n		int[] deq=new int[m+1];\n		int ptr=0;\n		for (int i=1;i<=m;++i) {\n			int nowL=i-H[i]+1;\n			while (ptr>0&&deq[ptr-1]>=nowL) nowL=Math.min(nowL,L[deq[--ptr]]);\n			nowL=Math.max(1,nowL);\n			L[deq[ptr++]=i]=nowL;\n		}\n		ptr=0;\n		for (int i=m;i>=1;--i) {\n			int nowR=i+H[i]-1;\n			while (ptr>0&&deq[ptr-1]<=nowR) nowR=Math.max(nowR,R[deq[--ptr]]);\n			nowR=Math.min(nowR,m);\n			R[deq[ptr++]=i]=nowR;\n		}\n		long[] dp=new long[m+1];\n		ptr=0;\n		long[] mmin=new long[m+1];\n		for (int i=1;i<=m;++i) {\n			dp[i]=dp[L[i]-1]+C[i];\n			while (ptr>0&&i>R[deq[ptr-1]]) --ptr;\n			if (ptr>0) dp[i]=Math.min(dp[i],mmin[ptr-1]);\n			deq[ptr]=i;\n			mmin[ptr++]=dp[i-1]+C[i];\n			if (ptr>1) mmin[ptr-1]=Math.min(mmin[ptr-1],mmin[ptr-2]);\n		}\n		System.out.println(dp[m]);\n	}\n}","data structures,dp,two pointers"
"import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class G {\n    public static void main(String[] args) throws IOException {\n        try (Input input = new StandardInput(); PrintWriter writer = new PrintWriter(System.out)) {\n            int blockCount = input.nextInt();\n            int totalDominoes = input.nextInt();\n            int[][] heights = new int[blockCount][];\n            int[][] costs = new int[blockCount][];\n            for (int b = 0; b < blockCount; b++) {\n                int blockSize = input.nextInt();\n                heights[b] = input.nextIntArray(blockSize);\n                costs[b] = input.nextIntArray(blockSize);\n            }\n            int[] h = new int[totalDominoes];\n            long[] c = new long[totalDominoes];\n            int offset = 0;\n            for (int k = input.nextInt(); k > 0; k--) {\n                int block = input.nextInt() - 1;\n                long costMultiplier = input.nextInt();\n                System.arraycopy(heights[block], 0, h, offset, heights[block].length);\n                for (int cost : costs[block]) {\n                    c[offset++] = costMultiplier * cost;\n                }\n            }\n            int[] leftStack = new int[totalDominoes];\n            int leftTop = 0;\n            int[] rightStack = new int[totalDominoes];\n            long[] rightStackValue = new long[totalDominoes];\n            int rightTop = 0;\n            long[] dp = new long[totalDominoes + 1];\n            for (int i = 0; i < totalDominoes; i++) {\n                int left = i - h[i];\n                while (leftTop > 0 && left < leftStack[leftTop - 1]) {\n                    leftTop--;\n                }\n                if (leftTop > 0) {\n                    left = leftStack[leftTop - 1];\n                } else {\n                    left = -1;\n                }\n                leftStack[leftTop++] = i;\n                while (rightTop > 0 && rightStack[rightTop - 1] <= i) {\n                    rightTop--;\n                }\n                long bestFromPredecessors = rightTop == 0 ? Long.MAX_VALUE : rightStackValue[rightTop - 1];\n                dp[i + 1] = Math.min(bestFromPredecessors, c[i] + dp[left + 1]);\n                bestFromPredecessors = Math.min(bestFromPredecessors, dp[i] + c[i]);\n                while (rightTop > 0 && rightStack[rightTop - 1] < i + h[i]) {\n                    rightTop--;\n                }\n                if (rightTop == 0 || rightStackValue[rightTop - 1] != bestFromPredecessors) {\n                    rightStack[rightTop] = i + h[i];\n                    rightStackValue[rightTop++] = bestFromPredecessors;\n                }\n            }\n            writer.println(dp[totalDominoes]);\n        }\n    }\n\n    interface Input extends Closeable {\n        String next() throws IOException;\n\n        default int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        default long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        default int[] nextIntArray(int size) throws IOException {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = nextInt();\n            }\n            return array;\n        }\n    }\n\n    private static class StandardInput implements Input {\n        private final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        private StringTokenizer stringTokenizer;\n\n        @Override\n        public void close() throws IOException {\n            reader.close();\n        }\n\n        @Override\n        public String next() throws IOException {\n            if (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {\n                stringTokenizer = new StringTokenizer(reader.readLine());\n            }\n            return stringTokenizer.nextToken();\n        }\n    }\n}","data structures,dp,two pointers"
"//package round541;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class G {\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n//	String INPUT = ""1 7\n"" + \n//			""7\n"" + \n//			""1 3 1 1 1 5 1\n"" + \n//			""1 1 4 5 1 4 8\n"" + ""1 1 1"";\n//	String INPUT = ""2 7\n"" + \n//			""3\n"" + \n//			""1 2 2\n"" + \n//			""1 2 1\n"" + \n//			""1\n"" + \n//			""3\n"" + \n//			""2\n"" + \n//			""3\n"" + \n//			""2 2\n"" + \n//			""1 3\n"" + \n//			""1 1"";\n	\n	void solve()\n	{\n		int n = ni(), m = ni();\n		int[][] as = new int[n][];\n		int[][] cs = new int[n][];\n		for(int i = 0;i < n;i++){\n			int K = ni();\n			as[i] = na(K);\n			cs[i] = na(K);\n		}\n		\n		int[] hs = new int[m];\n		long[] costs = new long[m];\n		\n		int p = 0;\n		int Q = ni();\n		for(int z = 0;z < Q;z++){\n			int id = ni()-1, mul = ni();\n			for(int j = 0;j < as[id].length;j++){\n				hs[p] = as[id][j];\n				costs[p] = (long)cs[id][j] * mul;\n				p++;\n			}\n		}\n		\n//		tr(hs);\n//		tr(costs);\n//		\n		assert p == m;\n		\n		out.println(minimumDominoCost(hs, costs));\n	}\n	\n	long minimumDominoCost(int[] hs, long[] costs)\n	{\n		int n = hs.length;\n		assert n == costs.length;\n		int[] pre = enumDominoReaches(hs);\n		int[] suf = enumDominoReaches(rev(hs));\n		\n		int[][] g = hopBucket(suf, n);\n		long[] dp = new long[n+1];\n		Arrays.fill(dp, Long.MAX_VALUE / 2);\n		dp[0] = 0;\n		\n		int[] stack = new int[n+1]; // pos\n		int sp = 0;\n		stack[sp++] = 0;\n		for(int i = 0;i < n;i++){\n			// merge\n			// dp[pre[i], i) + cost[i]\n			while(sp-2 >= 0 && stack[sp-2] >= pre[i]){\n				dp[stack[sp-2]] = Math.min(dp[stack[sp-2]], dp[stack[sp-1]]);\n				sp--;\n			}\n//			tr(""stack"", Arrays.copyOf(stack, sp));\n			assert sp-1 >= 0;\n			dp[i+1] = Math.min(dp[i+1], dp[stack[sp-1]] + costs[i]);\n//			tr(""z"", i+1, dp[i+1]);\n			stack[sp++] = i+1;\n			\n			// dp[j-1] + cost[j] (j -> i)\n			for(int j = g[0][n-1-i];j != -1;j = g[1][j]){\n				dp[i+1] = Math.min(dp[i+1], dp[n-1-j] + costs[n-1-j]);\n			}\n		}\n		\n//		tr(dp);\n		return dp[n];\n	}\n	\n	public int[][] hopBucket(int[] a, int m)\n	{\n		int n = a.length;\n		int[] first = new int[m];\n		Arrays.fill(first, -1);\n		int[] next = new int[n];\n		for(int i = 0;i < n;i++){\n			next[i] = first[a[i]];\n			first[a[i]] = i;\n		}\n		return new int[][]{first, next};\n	}\n	\n	public static int[] rev(int[] a)\n	{\n		int[] b = new int[a.length];\n		for(int i = 0;i < a.length;i++)b[a.length-1-i] = a[i];\n		return b;\n	}\n\n	\n	int[] enumDominoReaches(int[] hs)\n	{\n		int n = hs.length;\n		int[] reach = new int[n];\n		int[] stack = new int[n];\n		int sp = 0;\n		for(int i = 0;i < n;i++){\n			// fall (i-hs[i], i]\n			int min = i-hs[i]+1;\n			while(sp > 0 && stack[sp-1] > i-hs[i]) {\n				min = Math.min(min, reach[stack[sp-1]]);\n				sp--;\n			}\n			reach[i] = Math.max(min, 0);\n			stack[sp++] = i;\n		}\n		return reach;\n	}\n	\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new G().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n	\n	private char[][] nm(int n, int m)\n	{\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n	\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n	\n	private int ni()\n	{\n		int num = 0, b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","data structures,dp,two pointers"
"//package round541;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class G {\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n//	String INPUT = ""1 7\n"" + \n//			""7\n"" + \n//			""1 3 1 1 1 5 1\n"" + \n//			""1 1 4 5 1 4 8\n"" + ""1 1 1"";\n//	String INPUT = ""2 7\n"" + \n//			""3\n"" + \n//			""1 2 2\n"" + \n//			""1 2 1\n"" + \n//			""1\n"" + \n//			""3\n"" + \n//			""2\n"" + \n//			""3\n"" + \n//			""2 2\n"" + \n//			""1 3\n"" + \n//			""1 1"";\n	\n	void solve()\n	{\n		int n = ni(), m = ni();\n		int[][] as = new int[n][];\n		int[][] cs = new int[n][];\n		for(int i = 0;i < n;i++){\n			int K = ni();\n			as[i] = na(K);\n			cs[i] = na(K);\n		}\n		\n		int[] hs = new int[m];\n		long[] costs = new long[m];\n		\n		int p = 0;\n		int Q = ni();\n		for(int z = 0;z < Q;z++){\n			int id = ni()-1, mul = ni();\n			for(int j = 0;j < as[id].length;j++){\n				hs[p] = as[id][j];\n				costs[p] = (long)cs[id][j] * mul;\n				p++;\n			}\n		}\n		\n//		tr(hs);\n//		tr(costs);\n//		\n		assert p == m;\n		\n		out.println(minimumDominoCost(hs, costs));\n	}\n	\n	long minimumDominoCost(int[] hs, long[] costs)\n	{\n		int n = hs.length;\n		assert n == costs.length;\n		int[] pre = enumDominoReaches(hs);\n		int[] suf = enumDominoReaches(rev(hs));\n		\n		int[][] g = hopBucket(suf, n);\n		long[] dp = new long[n+1];\n		Arrays.fill(dp, Long.MAX_VALUE / 2);\n		dp[0] = 0;\n		\n		int[] stack = new int[n+1]; // pos\n		int sp = 0;\n		stack[sp++] = 0;\n		for(int i = 0;i < n;i++){\n			// merge\n			// dp[pre[i], i) + cost[i]\n			while(sp-2 >= 0 && stack[sp-2] >= pre[i]){\n				dp[stack[sp-2]] = Math.min(dp[stack[sp-2]], dp[stack[sp-1]]);\n				sp--;\n			}\n//			tr(""stack"", Arrays.copyOf(stack, sp));\n			assert sp-1 >= 0;\n			dp[i+1] = Math.min(dp[i+1], dp[stack[sp-1]] + costs[i]);\n//			tr(""z"", i+1, dp[i+1]);\n			stack[sp++] = i+1;\n			\n			// dp[j-1] + cost[j] (j -> i)\n			for(int j = g[0][n-1-i];j != -1;j = g[1][j]){\n				dp[i+1] = Math.min(dp[i+1], dp[n-1-j] + costs[n-1-j]);\n			}\n		}\n		\n//		tr(dp);\n		return dp[n];\n	}\n	\n	public int[][] hopBucket(int[] a, int m)\n	{\n		int n = a.length;\n		int[] first = new int[m];\n		Arrays.fill(first, -1);\n		int[] next = new int[n];\n		for(int i = n-1;i >= 0;i--) {\n			next[i] = first[a[i]];\n			first[a[i]] = i;\n		}\n		return new int[][]{first, next};\n	}\n	\n	public static int[] rev(int[] a)\n	{\n		int[] b = new int[a.length];\n		for(int i = 0;i < a.length;i++)b[a.length-1-i] = a[i];\n		return b;\n	}\n\n	\n	int[] enumDominoReaches(int[] hs)\n	{\n		int n = hs.length;\n		int[] reach = new int[n];\n		int[] stack = new int[n];\n		int sp = 0;\n		for(int i = 0;i < n;i++){\n			// fall (i-hs[i], i]\n			int min = i-hs[i]+1;\n			while(sp > 0 && stack[sp-1] > i-hs[i]) {\n				min = Math.min(min, reach[stack[sp-1]]);\n				sp--;\n			}\n			reach[i] = Math.max(min, 0);\n			stack[sp++] = i;\n		}\n		return reach;\n	}\n	\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new G().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n	\n	private char[][] nm(int n, int m)\n	{\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n	\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n	\n	private int ni()\n	{\n		int num = 0, b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","data structures,dp,two pointers"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1131F extends PrintWriter {\n	CF1131F() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1131F o = new CF1131F(); o.main(); o.flush();\n	}\n\n	int[] head, tail, pp;\n	int find(int[] ds, int i) {\n		return ds[i] == 0 ? i : (ds[i] = find(ds, ds[i]));\n	}\n	void join(int i, int j) {\n		i = find(tail, i);\n		j = find(tail, j);\n		if (i == j)\n			return;\n		j = find(head, j);\n		pp[i] = j;\n		tail[i] = j; head[j] = i;\n	}\n	void main() {\n		int n = sc.nextInt();\n		head = new int[n + 1];\n		tail = new int[n + 1];\n		pp = new int[n + 1];\n		while (--n > 0) {\n			int i = sc.nextInt();\n			int j = sc.nextInt();\n			join(i, j);\n		}\n		for (int i = find(head, 1); i != 0; i = pp[i])\n			print(i + "" "");\n		println();\n	}\n}\n","constructive algorithms,dsu"
"//package DSU1;\n\nimport java.util.Scanner;\n\n\npublic class F1131 {\n	\n	public static void main(String[] args) {\n		Scanner sc = new Scanner (System.in);\n		int n =sc.nextInt();\n		DSU graph [] = new DSU [n+10];\n		for (int i = 0 ; i <= n ; i++)\n			graph[i] = new DSU(i);\n		\n		for (int i = 0 ; i < n-1 ; i++) {\n			int u = sc.nextInt();\n			int v = sc.nextInt();\n			graph [u].unite(graph[v]);\n		}\n		\n		//printing\n		DSU root = graph[n].find();\n		while (root.nextChild != root) {\n			System.out.print (root.id+"" "");\n			root = root.nextChild; \n		}\n		\n		System.out.println (root.id);\n	}\n}\n\nclass DSU{\n	  DSU lastChild, Parent, nextChild;\n	  int id ;\n	  DSU (int id){\n		  lastChild = this ; \n		  Parent = this;\n		  nextChild = this;\n		  this.id = id ; \n	  }\n	  \n	  DSU find () {\n		  if (this.Parent == this) return this ;\n		  \n		  DSU parental = this.Parent.find();\n		  this.Parent = parental ;\n		  return parental; \n	  }\n	  \n	  DSU unite (DSU o) {\n		  DSU oP = o.find() ; \n		  DSU tP = this.find() ; \n		  \n		  tP.lastChild.nextChild = oP;\n		  tP.lastChild = oP.lastChild; \n		  oP.Parent = tP;\n		  return tP;\n	  }\n}","constructive algorithms,dsu"
"import java.util.*;\n\npublic class Solution{\n    static int[] par,rank;\n    static ArrayList<Integer>[] gr;\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        par=new int[n+1];\n        rank=new int[n+1];\n        gr=new ArrayList[n+1];\n        for(int i=0;i<=n;i++){\n            gr[i]=new ArrayList<>();\n            par[i]=i;\n        }\n        for(int i=0;i<n-1;i++){\n            int a=sc.nextInt(), b=sc.nextInt(), x=find(a), y=find(b);\n            if(y!=x) merge(a,b,x,y);\n        }\n       int[] vis=new int[n+1];\n       \n      \n        StringBuilder sb=new StringBuilder();\nfor(int i=1;i<=n;i++)if(i==par[i])for(int b:gr[i]) if(vis[b]==0){sb.append(b+"" "");vis[b]=1;} \n       System.out.println(sb);\n          }\n    static int find(int n){\n        if(n==par[n])return n;\n        return par[n]=find(par[n]);\n    }\nstatic void merge(int a,int b,int x,int y){\n        if(rank[x]>=rank[y]){\n                 gr[x].add(a);\n                 for(int c:gr[par[b]]){gr[x].add(c);par[c]=x;}\n           gr[x].add(b); par[b]=a; rank[x]++;\n        }\n        else{rank[y]++;\n        gr[y].add(b);\n         for(int c:gr[par[a]]){gr[y].add(c); par[c]=y;}\n        gr[y].add(a); par[a]=b;\n        }\n    }\n}\n","constructive algorithms,dsu"
"import java.util.*;\n\npublic class Solution{\n    static int[] par,rank;\n    static ArrayList<Integer>[] gr;\n    static ArrayList<Integer> p;\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        par=new int[n+1];\n        rank=new int[n+1];\n        gr=new ArrayList[n+1];\n        for(int i=0;i<=n;i++){\n            gr[i]=new ArrayList<>();\n            par[i]=i;\n        }\n    p=new ArrayList<>();\n    Pair[] ar=new Pair[n-1];\n        for(int i=0;i<n-1;i++){\n            int a=sc.nextInt();\n            int b=sc.nextInt();\n            int x=find(a), y=find(b);\n            if(y!=x){\n              merge(a,b,x,y);\n            }\n            ar[i]=new Pair(a,b);\n            \n        }\n       int[] vis=new int[n+1];\n       \n      \n        StringBuilder sb=new StringBuilder();\n     for(int i=1;i<=n;i++){\n      if(i==par[i]){   for(int b:gr[i]){\n             if(vis[b]==0){sb.append(b+"" "");vis[b]=1;}\n         }}\n     }\n \n       System.out.println(sb);\n       // for(int i=1;i<=n;i++)System.out.print(par[i]+"" "");\n        \n    }\n    static int find(int n){\n        if(n==par[n])return n;\n        return par[n]=find(par[n]);\n    }\n    \n    static void merge(int a,int b,int x,int y){\n        \n        if(rank[x]>=rank[y]){\n                 gr[x].add(a);\n                 \n                 for(int c:gr[par[b]]){\n                     gr[x].add(c);\n                     par[c]=x;\n                     \n                 }\n                 gr[x].add(b);\n            par[b]=a;\n            rank[x]++;\n        }\n        else{rank[y]++;\n        gr[y].add(b);\n         for(int c:gr[par[a]]){\n                     gr[y].add(c);\n                     par[c]=y;\n                   \n                 }\n                \n                  gr[y].add(a);\n                  par[a]=b;\n        \n        }\n    }\n}\nclass Pair{\n    int x,y;\n    Pair(int x,int y){\n        this.x=x;\n        this.y=y;\n    }\n}","constructive algorithms,dsu"
"import java.util.*;\npublic class class304 {\npublic static void main(String arg[])\n{\n	Scanner sc=new Scanner(System.in);\n	long w1,h1,w2,h2;\n	w1=sc.nextLong();\n	h1=sc.nextLong();\n	w2=sc.nextLong();\n	h2=sc.nextLong();\n	System.out.println(2*(w1+h1+h2)+4);\n}\n}\n",math
"import java.util.*;\npublic class Demo{\n	public static void main(String[] args) {\n		int a,b,c,d;\n		Scanner in = new Scanner(System.in);\n		a = in.nextInt();\n		b = in.nextInt();\n		c = in.nextInt();\n		d = in.nextInt();\n		System.out.println(2*a + (b+d+2)*2);\n\n	}	\n}		\n",math
"import java.util.*;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int aw=sc.nextInt(),ah=sc.nextInt();\n		int bw=sc.nextInt(),bh=sc.nextInt();\n		int max=Math.max(aw, bw);\n		int t=ah+bh;\n		System.out.print(max*2+t*2+4);\n	}\n} ",math
"import java.util.*;\n\npublic class Solution {\n\n  private static Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    int w1 = sc.nextInt(), h1 = sc.nextInt(), w2 = sc.nextInt(), h2 = sc.nextInt();\n    System.out.println(2 * (w1 + h1 + h2) + 4);\n  }\n}",math
"import java.util.Scanner;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int arr[] = new int[n];\n		int left = 0;\n		int right = 0;\n		for(int i=0;i<n;i++) {\n			arr[i] = sc.nextInt();\n			if(arr[i]!=arr[0])left=i;\n		}\n		for(int i=0;i<n;i++) {\n			if(arr[n-1]!=arr[i]) {\n				right=i;\n				break;\n			}\n		}\n		System.out.println(Math.max(left,n-right-1));\n	}\n}\n		    	   		 	 	 	 	     				","greedy,implementation"
"import java.io.*;\nimport java.util.Scanner;\npublic class Main {\n	public static void main (String [] args) {\n		Scanner sc=new Scanner(System.in);\n		  \n		int n=sc.nextInt();\n		int a[]=new int[n];\n		  \n		for(int i=0;i<n;i++)\n			a[i]=sc.nextInt();\n			\n		int ans=0;\n		\n		for(int i=n-1;i>0;i--)\n		{\n			if(a[i]!=a[0])\n				ans=Math.max(ans,i);\n		}\n		\n		for(int i=0;i<n-1;i++)\n		{\n			if(a[i]!=a[n-1])\n				ans=Math.max(ans,n-1-i);\n		}\n		\n		System.out.println(ans);\n	}\n}","greedy,implementation"
"import java.util.Scanner;\n\npublic class ilya_walk_1119A{\n	public static void main(String[] args){\n		Scanner in = new Scanner(System.in);\n\n		int n = in.nextInt();\n		int[] arr = new int[n];\n		for(int i=0; i<n; i++){\n			arr[i] = in.nextInt();\n		}\n\n		int rMax = 0;\n		for(int i=0; i<n; i++){\n			if(arr[i] != arr[n-1]){\n				rMax = n-1 - i;\n				break;\n			}\n		}\n\n		int lMax = 0;\n		for(int i=n-1; i>0; i--){\n			if(arr[i] != arr[0]){\n				lMax = i - 0;\n				break;\n			}\n		}\n\n		System.out.println(Math.max(lMax, rMax));\n	}\n}","greedy,implementation"
"import java.util.Scanner;\n\npublic class IlyaAndAColorfulWalk {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int n = s.nextInt();\n        int[] a = new int[n];\n        for(int i = 0; i < n; i++) a[i] = s.nextInt();\n        int index1 = 0, index2 = n - 1;\n        while(a[index1] == a[n - 1]) index1++;\n        while(a[index2] == a[0]) index2--;\n        int one = n - index1 - 1;\n        int two = index2;\n        System.out.println(one > two ? one : two);\n    }\n}","greedy,implementation"
"// upsolve with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1106F {\n	static final int MD = 998244353;\n	static void mult(int[][] aa, int[][] bb, int[][] cc, int k) {\n		for (int i = 0; i < k; i++) {\n			int[] ci = cc[i];\n			for (int j = 0; j < k; j++)\n				ci[j] = 0;\n			for (int h = 0; h < k; h++) {\n				int[] bh = bb[h];\n				long aih = aa[i][h];\n				for (int j = 0; j < k; j++)\n					ci[j] = (int) ((ci[j] + aih * bh[j]) % (MD - 1));\n			}\n		}\n	}\n	static void power_(int[][] aa, int[][] pp, int[][] tt, int k, int x) {\n		if (x == 0) {\n			for (int i = 0; i < k; i++)\n				for (int j = 0; j < k; j++)\n					pp[i][j] = i == j ? 1 : 0;\n			return;\n		}\n		if (x % 2 == 0) {\n			power_(aa, tt, pp, k, x / 2);\n			mult(tt, tt, pp, k);\n		} else {\n			power_(aa, pp, tt, k, x / 2);\n			mult(pp, pp, tt, k);\n			mult(tt, aa, pp, k);\n		}\n	}\n	static int power(int a, int x, int md) {\n		if (x == 0)\n			return 1;\n		int p = power(a, x / 2, md);\n		p = (int) ((long) p * p % md);\n		if (x % 2 == 1)\n			p = (int) ((long) p * a % md);\n		return p;\n	}\n	// https://math.stackexchange.com/questions/124408/finding-a-primitive-root-of-a-prime-number\n	static int totient(int n) {\n		int t = n;\n		for (int a = 2; a * a <= n; a++)\n			if (n % a == 0) {\n				t = t / a * (a - 1);\n				do\n					n /= a;\n				while (n % a == 0);\n			}\n		if (n > 1) {\n			int a = n;\n			t = t / a * (a - 1);\n		}\n		return t;\n	}\n	static boolean test(int r, int t, int n) {\n		int t_ = t;\n		for (int a = 2; a * a <= t; a++)\n			if (t % a == 0) {\n				if (power(r, t_ / a, n) == 1)\n					return false;\n				do\n					t /= a;\n				while (t % a == 0);\n			}\n		if (t > 1) {\n			int a = t;\n			if (power(r, t_ / a, n) == 1)\n				return false;\n		}\n		return true;\n	}\n	static int primroot(int n) {\n		int t = totient(n);\n		Random rand = new Random();\n		while (true) {\n			int r = rand.nextInt(n - 2) + 2;	// [2, n - 1]\n			if (test(r, t, n))\n				return r;\n		}\n	}\n	// https://en.wikipedia.org/wiki/Baby-step_giant-step\n	static int dislog(int a, int b) {\n		int m = (int) Math.sqrt(MD) + 1;\n		HashMap<Integer, Integer> map = new HashMap<>();\n		int p = 1;\n		for (int j = 0; j < m; j++) {\n			map.put(p, j);\n			p = (int) ((long) p * a % MD);\n		}\n		int am = power(power(a, MD - 2, MD), m, MD);\n		p = b;\n		for (int i = 0, j; i < m; i++) {\n			if ((j = map.getOrDefault(p, -1)) != -1)\n				return (i * m + j) % (MD - 1);\n			p = (int) ((long) p * am % MD);\n		}\n		return -1;\n	}\n	static int gcd(int a, int b) {\n		return b == 0 ? a : gcd(b, a % b);\n	}\n	static int x_, y_;\n	static int gcd_(int a, int b) {\n		if (b == 0) {\n			x_ = 1; y_ = 0;\n			return a;\n		} else {\n			int d = gcd_(b, a % b);\n			int t = x_ - a / b * y_; x_ = y_; y_ = t;\n			return d;\n		}\n	}\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		int k = Integer.parseInt(br.readLine());\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int[] bb = new int[k];\n		for (int i = 0; i < k; i++)\n			bb[i] = Integer.parseInt(st.nextToken());\n		st = new StringTokenizer(br.readLine());\n		int n = Integer.parseInt(st.nextToken());\n		int m = Integer.parseInt(st.nextToken());\n		int[][] aa = new int[k][k];\n		for (int i = 0; i < k - 1; i++)\n			aa[i][i + 1] = 1;\n		for (int j = 0; j < k; j++)\n			aa[k - 1][j] = bb[k - 1 - j];\n		int[][] pp = new int[k][k];\n		int[][] tt = new int[k][k];\n		power_(aa, pp, tt, k, n - k);\n		int d = gcd_(pp[k - 1][k - 1], MD - 1);\n		int r = primroot(MD);\n		int z = dislog(r, m);\n		int ans = -1;\n		if (z % d == 0) {\n			if (x_ < 0)\n				x_ += MD - 1;\n			ans = power(r, (int) ((long) x_ * (z / d) % (MD - 1)), MD);\n		}\n		System.out.println(ans);\n	}\n}\n","math,matrices,number theory"
"// upsolve with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1106F {\n	static final int MD = 998244353;\n	static void mult(int[][] aa, int[][] bb, int[][] cc, int k) {\n		for (int i = 0; i < k; i++) {\n			int[] ci = cc[i];\n			for (int j = 0; j < k; j++)\n				ci[j] = 0;\n			for (int h = 0; h < k; h++) {\n				int[] bh = bb[h];\n				long aih = aa[i][h];\n				for (int j = 0; j < k; j++)\n					ci[j] = (int) ((ci[j] + aih * bh[j]) % (MD - 1));\n			}\n		}\n	}\n	static void power_(int[][] aa, int[][] pp, int[][] tt, int k, int x) {\n		if (x == 0) {\n			for (int i = 0; i < k; i++)\n				for (int j = 0; j < k; j++)\n					pp[i][j] = i == j ? 1 : 0;\n			return;\n		}\n		if (x % 2 == 0) {\n			power_(aa, tt, pp, k, x / 2);\n			mult(tt, tt, pp, k);\n		} else {\n			power_(aa, pp, tt, k, x / 2);\n			mult(pp, pp, tt, k);\n			mult(tt, aa, pp, k);\n		}\n	}\n	static int power(int a, int x, int md) {\n		if (x == 0)\n			return 1;\n		int p = power(a, x / 2, md);\n		p = (int) ((long) p * p % md);\n		if (x % 2 == 1)\n			p = (int) ((long) p * a % md);\n		return p;\n	}\n	static int totient(int n) {\n		int t = n;\n		for (int a = 2; a * a <= n; a++)\n			if (n % a == 0) {\n				t = t / a * (a - 1);\n				do\n					n /= a;\n				while (n % a == 0);\n			}\n		if (n > 1) {\n			int a = n;\n			t = t / a * (a - 1);\n		}\n		return t;\n	}\n	// https://math.stackexchange.com/questions/124408/finding-a-primitive-root-of-a-prime-number\n	static boolean test(int r, int t, int n) {\n		int t_ = t;\n		for (int a = 2; a * a <= t; a++)\n			if (t % a == 0) {\n				if (power(r, t_ / a, n) == 1)\n					return false;\n				do\n					t /= a;\n				while (t % a == 0);\n			}\n		if (t > 1) {\n			int a = t;\n			if (power(r, t_ / a, n) == 1)\n				return false;\n		}\n		return true;\n	}\n	static int primroot(int n) {\n		int t = totient(n);\n		Random rand = new Random();\n		while (true) {\n			int r = rand.nextInt(n - 2) + 2;	// [2, n - 1]\n			if (test(r, t, n))\n				return r;\n		}\n	}\n	// https://en.wikipedia.org/wiki/Baby-step_giant-step\n	static class S {\n		int i, x;\n		S(int i, int x) {\n			this.i = i; this.x = x;\n		}\n	}\n	static int dislog(int a, int b) {\n		int m = (int) Math.sqrt(MD) + 1;\n		S[] pp = new S[m];\n		S[] qq = new S[m];\n		int x = 1;\n		for (int j = 0; j < m; j++) {\n			qq[j] = new S(j, x);\n			x = (int) ((long) x * a % MD);\n		}\n		int am = power(power(a, MD - 2, MD), m, MD);\n		x = b;\n		for (int i = 0; i < m; i++) {\n			pp[i] = new S(i, x);\n			x = (int) ((long) x * am % MD);\n		}\n		Arrays.sort(pp, (p, q) -> { return p.x - q.x; });\n		Arrays.sort(qq, (p, q) -> { return p.x - q.x; });\n		for (int i = 0, j = 0; i < m && j < m; ) {\n			if (pp[i].x == qq[j].x)\n				return (pp[i].i * m + qq[j].i) % (MD - 1);\n			if (pp[i].x < qq[j].x)\n				i++;\n			else\n				j++;\n		}\n		return -1;\n	}\n	static int x_, y_;\n	static int gcd_(int a, int b) {\n		if (b == 0) {\n			x_ = 1; y_ = 0;\n			return a;\n		} else {\n			int d = gcd_(b, a % b);\n			int t = x_ - a / b * y_; x_ = y_; y_ = t;\n			return d;\n		}\n	}\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		int k = Integer.parseInt(br.readLine());\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int[] bb = new int[k];\n		for (int i = 0; i < k; i++)\n			bb[i] = Integer.parseInt(st.nextToken());\n		st = new StringTokenizer(br.readLine());\n		int n = Integer.parseInt(st.nextToken());\n		int m = Integer.parseInt(st.nextToken());\n		int[][] aa = new int[k][k];\n		for (int i = 0; i < k - 1; i++)\n			aa[i][i + 1] = 1;\n		for (int j = 0; j < k; j++)\n			aa[k - 1][j] = bb[k - 1 - j];\n		int[][] pp = new int[k][k];\n		int[][] tt = new int[k][k];\n		power_(aa, pp, tt, k, n - k);\n		int d = gcd_(pp[k - 1][k - 1], MD - 1);\n		int r = primroot(MD);\n		int z = dislog(r, m);\n		int ans = -1;\n		if (z % d == 0) {\n			if (x_ < 0)\n				x_ += MD - 1;\n			ans = power(r, (int) ((long) x_ * (z / d) % (MD - 1)), MD);\n		}\n		System.out.println(ans);\n	}\n}\n","math,matrices,number theory"
"import java.io.*;\nimport java.util.*;\n\npublic class Main{\n    public static void main(String[] args){\n        try {\n            new Main().solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    int[]b;\n    int mod=998244353;\n    private void solve() throws Exception {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n        int k=in.nextInt();\n        b=new int[k];\n        for(int i=0;i<k;i++)b[i]=in.nextInt();\n        int n=in.nextInt(),m=in.nextInt();\n        int[][]ma=new int[k][k];\n        for(int i=0;i<k;i++){\n            ma[i][0]=b[i];\n            if(i!=k-1) ma[i][i+1]=1;\n        }\n        int[][]x=new int[1][k];x[0][0]=1;\n        int phi=mod-1;\n        int a=modMul(modPow(ma,n-k,phi),x,phi)[0][0];\n        int b=bsgs(m,mod);\n        int[] gcd=exgcd(a,phi);\n        gcd[1]=(gcd[1]%phi+phi)%phi;\n        if(b%gcd[0]!=0)out.println(-1);\n        else out.println(FastPowMod(3,(long)gcd[1]*(b/gcd[0]),mod));\n        out.flush();\n    }\n    public int bsgs(int a,int mod){\n        long sq=(long)Math.ceil(Math.sqrt(mod));\n        HashMap<Long,Integer>map=new HashMap<>();\n        long x=a;\n        for(int i=1;i<=sq;i++){\n            x=(x*3)%mod;\n            map.put(x,i);\n        }\n        x=1;\n        long a1=FastPowMod(3,sq,mod);\n        for(int i=1;i<=sq;i++){\n            x=(x*a1)%mod;\n            if(map.containsKey(x))return (int)sq*i-map.get(x);\n        }\n        return -1;\n    }\n    public static int FastPowMod(int a,long b,int c){\n        a=a%c;\n        long ans=1;\n        long a1=a;\n        while(b>0){\n            if((b&1)==1)\n                ans=(ans*a1)%c;\n            a1=(a1*a1)%c;\n            b>>=1;\n        }\n        return (int)ans;\n    }\n    public static int[] exgcd(int a,int b){\n        if(b==0) {\n            return new int[]{a,1,0};\n        }\n        int[]res=exgcd(b,a%b);\n        int tmp=res[1];\n        res[1]=res[2];\n        res[2]=tmp-(a/b)*res[2];\n        return res;\n    }\n    public int[][] modPow(int[][]a,int b,int mod){\n        int[][]ans=new int[a.length][a[0].length];\n        for(int i=0;i<ans.length;i++)ans[i][i]=1;\n        while(b>0){\n            if((b&1)!=0)ans=modMul(ans,a,mod);\n            a=modMul(a,a,mod);\n            b>>=1;\n        }\n        return ans;\n    }\n\n\n    public int[][] modMul(int[][]a,int[][]b,int mod) {\n        int row = a.length, column = b[0].length;\n        int len = b.length;\n        int[][] ans = new int[row][column];\n        for (int i = 0; i < row; i++) {\n            for (int j = 0; j < len; j++) {\n                if (a[i][j] == 0) continue;//稀疏矩阵优化\n                for (int k = 0; k < column; k++) {\n                    ans[i][k] += (long) a[i][j] * b[j][k] % mod;\n                    ans[i][k] %= mod;\n                }\n            }\n        }\n        return ans;\n    }\n    class InputReader{\n        StreamTokenizer tokenizer;\n        public InputReader(InputStream stream){\n            tokenizer=new StreamTokenizer(new BufferedReader(new InputStreamReader(stream)));\n            tokenizer.ordinaryChars(33,126);\n            tokenizer.wordChars(33,126);\n        }\n        public String next() throws IOException {\n            tokenizer.nextToken();\n            return tokenizer.sval;\n        }\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n        public boolean hasNext() throws IOException {\n            int res=tokenizer.nextToken();\n            tokenizer.pushBack();\n            return res!=tokenizer.TT_EOF;\n        }\n    }\n}","math,matrices,number theory"
"// upsolve with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1106F {\n	static final int MD = 998244353;\n	static void mult(int[][] aa, int[][] bb, int[][] cc, int k) {\n		for (int i = 0; i < k; i++) {\n			int[] ci = cc[i];\n			for (int j = 0; j < k; j++)\n				ci[j] = 0;\n			for (int h = 0; h < k; h++) {\n				int[] bh = bb[h];\n				long aih = aa[i][h];\n				for (int j = 0; j < k; j++)\n					ci[j] = (int) ((ci[j] + aih * bh[j]) % (MD - 1));\n			}\n		}\n	}\n	static void power_(int[][] aa, int[][] pp, int[][] tt, int k, int x) {\n		if (x == 0) {\n			for (int i = 0; i < k; i++)\n				for (int j = 0; j < k; j++)\n					pp[i][j] = i == j ? 1 : 0;\n			return;\n		}\n		if (x % 2 == 0) {\n			power_(aa, tt, pp, k, x / 2);\n			mult(tt, tt, pp, k);\n		} else {\n			power_(aa, pp, tt, k, x / 2);\n			mult(pp, pp, tt, k);\n			mult(tt, aa, pp, k);\n		}\n	}\n	static int power(int a, int x) {\n		if (x == 0)\n			return 1;\n		int p = power(a, x / 2);\n		p = (int) ((long) p * p % MD);\n		if (x % 2 == 1)\n			p = (int) ((long) p * a % MD);\n		return p;\n	}\n	static int totient(int n) {\n		int t = n;\n		for (int a = 2; a * a <= n; a++)\n			if (n % a == 0) {\n				t = t / a * (a - 1);\n				do\n					n /= a;\n				while (n % a == 0);\n			}\n		if (n > 1) {\n			int a = n;\n			t = t / a * (a - 1);\n		}\n		return t;\n	}\n	// https://math.stackexchange.com/questions/124408/finding-a-primitive-root-of-a-prime-number\n	static boolean test(int r, int t) {\n		int t_ = t;\n		for (int a = 2; a * a <= t; a++)\n			if (t % a == 0) {\n				if (power(r, t_ / a) == 1)\n					return false;\n				do\n					t /= a;\n				while (t % a == 0);\n			}\n		if (t > 1) {\n			int a = t;\n			if (power(r, t_ / a) == 1)\n				return false;\n		}\n		return true;\n	}\n	static int primroot(int t) {\n		Random rand = new Random();\n		while (true) {\n			int r = rand.nextInt(MD - 2) + 2;	// [2, MD - 1]\n			// if (gcd(r, MD) == 1 && test(r, t))\n			if (test(r, t))\n				return r;\n		}\n	}\n	// https://en.wikipedia.org/wiki/Baby-step_giant-step\n	static class S {\n		int i, x;\n		S(int i, int x) {\n			this.i = i; this.x = x;\n		}\n	}\n	static int dislog(int a, int b, int t) {\n		int m = (int) Math.sqrt(MD) + 1;\n		S[] pp = new S[m];\n		S[] qq = new S[m];\n		int x = 1;\n		for (int j = 0; j < m; j++) {\n			qq[j] = new S(j, x);\n			x = (int) ((long) x * a % MD);\n		}\n		//int am = power(power(a, t - 1), m);\n		//int am = power(a, (t - 1) * m % t);\n		int am = power(a, t - m % t);\n		x = b;\n		for (int i = 0; i < m; i++) {\n			pp[i] = new S(i, x);\n			x = (int) ((long) x * am % MD);\n		}\n		Arrays.sort(pp, (p, q) -> { return p.x - q.x; });\n		Arrays.sort(qq, (p, q) -> { return p.x - q.x; });\n		for (int i = 0, j = 0; i < m && j < m; ) {\n			if (pp[i].x == qq[j].x)\n				return (pp[i].i * m + qq[j].i) % t;\n			if (pp[i].x < qq[j].x)\n				i++;\n			else\n				j++;\n		}\n		return -1;\n	}\n	static int x_, y_;\n	static int gcd_(int a, int b) {\n		if (b == 0) {\n			x_ = 1; y_ = 0;\n			return a;\n		} else {\n			int d = gcd_(b, a % b);\n			int t = x_ - a / b * y_; x_ = y_; y_ = t;\n			return d;\n		}\n	}\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		int k = Integer.parseInt(br.readLine());\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int[] bb = new int[k];\n		for (int i = 0; i < k; i++)\n			bb[i] = Integer.parseInt(st.nextToken());\n		st = new StringTokenizer(br.readLine());\n		int n = Integer.parseInt(st.nextToken());\n		int m = Integer.parseInt(st.nextToken());\n		int[][] aa = new int[k][k];\n		for (int i = 0; i < k - 1; i++)\n			aa[i][i + 1] = 1;\n		for (int j = 0; j < k; j++)\n			aa[k - 1][j] = bb[k - 1 - j];\n		int[][] pp = new int[k][k];\n		int[][] tt = new int[k][k];\n		power_(aa, pp, tt, k, n - k);\n		int d = gcd_(pp[k - 1][k - 1], MD - 1);\n		int t = totient(MD);\n		int r = primroot(t);\n		int l = dislog(r, m, t);\n		int ans = -1;\n		if (l % d == 0) {\n			if (x_ < 0)\n				x_ += MD - 1;\n			ans = power(r, (int) ((long) x_ * (l / d) % t));\n		}\n		System.out.println(ans);\n	}\n}\n","math,matrices,number theory"
"import java.util.Scanner;\npublic class maumau {\n	\n	public static void main(String [] args) {\n		Scanner s = new Scanner(System.in);\n		String hand[] = s.nextLine().split("""");\n		String table = s.nextLine();\n		\n		if (table.contains(hand[0]) || table.contains(hand[1])) {\n			System.out.println(""YES"");\n		}\n		else System.out.println(""NO"");\n 	}\n\n}\n","brute force,implementation"
"import java.util.Scanner;\npublic class Main\n{\n	public static void main(String [] args)\n	{\n		Scanner s = new Scanner(System.in);\n		String hand[] = s.nextLine().split("""");\n		String table = s.nextLine();\n		\n		if (table.contains(hand[0]) || table.contains(hand[1])) \n		{\n			System.out.println(""YES"");\n		}\n		else System.out.println(""NO"");\n 	}\n \n}","brute force,implementation"
"import java.util.Scanner;\n\n\npublic class Araryss {\n	//\n	public static void main(String[] args) {\n	Scanner in= new Scanner(System.in);\n	String s=in.next();\n	String[] A=new String[5];\n	for(int i=0;i<5;i++) {\n		A[i]=in.next();\n		if(A[i].charAt(0)==s.charAt(0) || A[i].charAt(1)==s.charAt(1) ) {\n			System.out.println(""YES"");\n			return;\n		}\n	}\n		System.out.println(""NO"");\n	\n}\n}","brute force,implementation"
"import java.util.Scanner;\n\npublic class gennadyandacardgame{\n\n	public static void main(String[]args){\n\n		Scanner in = new Scanner(System.in);\n\n		String c = in.next();\n		String ans = ""NO"";\n		\n		for(int i = 0; i < 5; i++){\n			\n			String comp = in.next();\n\n				\n			if(c.charAt(0) == comp.charAt(0) || c.charAt(1) == comp.charAt(1)){\n\n				ans = ""YES"";\n				\n			}\n		}\n\n		System.out.println(ans);\n\n	}\n}\n","brute force,implementation"
"import java.util.*;\nimport java.lang.*;\n\npublic class Main {\n\n    public static void main (String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int k = in.nextInt();\n        int sum = k;\n        int[] a = new int[k];\n        Arrays.fill(a, 0, k, 1);\n        int i = k-1;\n        while(i>=0){ while (sum + a[i] <= n) {\n                sum += a[i]; a[i] *= 2; } i--; }\n        if(sum == n) {\n            System.out.println(""YES"");\n            System.out.println(Arrays.toString(a).replace(""["","""").replace(""]"","""").replace("", "","" ""));}\n        else System.out.println(""NO"");\n    }\n}","bitmasks,greedy"
"import java.util.*;\npublic class Main\n{\n    \n    \n	public static void main(String[] args) {\n	    Scanner sc=new Scanner(System.in);\n	    int n=sc.nextInt();\n	    int k=sc.nextInt();\n	    int a[]=new int[k];\n	    for(int i=0;i<k;i++)\n	    {\n	        a[i]=1;\n	    }\n	    int sum=k;\n	    \n	    for(int i=k-1;i>=0;i--)\n	    {\n	        \n	       while(sum+a[i]<=n) \n	       {\n	           sum+=a[i];\n	           a[i]*=2;\n	       }\n	        \n	    }\n	    if(sum==n){\n	       System.out.println(""YES"");\n	    \n	    for(int i=0;i<k;i++)\n	    {\n	        System.out.print(a[i]+"" "");\n	    }}\n	    else\n	    System.out.print(""NO"");\n	}\n}","bitmasks,greedy"
"import java.util.*;\nimport java.math.*;\n\npublic class powersOfTwo{\n    public static void main(String[] args){\n        long n;\n        int k;\n        Scanner sc = new Scanner(System.in);\n        n=sc.nextLong();\n        k=sc.nextInt();\n        int[] arr = new int[k];\n        Arrays.fill(arr, 0, k, 1);\n        int sum = k;\n        for(int i = k-1;i>=0;i--){\n            while(sum+arr[i]<=n){\n                sum+=arr[i];\n                arr[i]*=2;\n            }\n        }\n        if(sum==n){\n            System.out.println(""YES"");\n            for(int i=0;i<k;i++) System.out.print(arr[i]+"" "");\n        }\n        else System.out.println(""NO"");\n    }\n}","bitmasks,greedy"
"import java.util.*;\nimport java.lang.*;\n\npublic class Main {\n\n    public static void main (String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int k = in.nextInt();\n\n        int[] arr = new int[k];\n        Arrays.fill(arr, 0, k, 1);\n        int sum = k;\n\n        for (int i = k - 1; i >= 0; i--) {\n            while (sum + arr[i] <= n) {\n                sum += arr[i];\n                arr[i] *= 2;\n            }\n        }\n        if(sum == n) {\n            System.out.println(""YES"");\n            for (int i = 0; i < k; i++) {\n                System.out.print(arr[i] + "" "");\n            }\n        } else {\n            System.out.println(""NO"");\n        }\n    }\n}","bitmasks,greedy"
"import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class M {\n\n	static void solve() throws Exception {\n		int n = scanInt();\n		boolean edge[][] = new boolean[n][n];\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < n; j++) {\n				edge[i][j] = scanInt() != 0;\n			}\n		}\n		out.println((6 * n - 1) + "" "" + (6 * n - 1) + "" 3"");\n		for (int y = 0; y < 6 * n - 1; y++) {\n			for (int x = 0; x < 6 * n - 1; x++) {\n				if (y / 6 == x / 6 && y % 6 < 5 && x % 6 < 5) {\n					out.print('.');\n				} else if (y % 6 == 2) {\n					out.print('.');\n				} else if ((y % 6 == 1 || y % 6 == 3) && x % 6 >= 1 && x % 6 <= 3) {\n					out.print('.');\n				} else {\n					out.print('#');\n				}\n			}\n			out.println();\n		}\n		out.println();\n		for (int y = 0; y < 6 * n - 1; y++) {\n			for (int x = 0; x < 6 * n - 1; x++) {\n				if (y / 6 == x / 6 && y % 6 < 5 && x % 6 < 5) {\n					if (y % 6 == 2 && (x % 6 == 0 || x % 6 == 4)) {\n						out.print('#');\n					} else {\n						out.print('.');\n					}\n				} else if (x % 6 == 2 && y % 6 == 2 && edge[y / 6][x / 6]) {\n					out.print('.');\n				} else {\n					out.print('#');\n				}\n			}\n			out.println();\n		}\n		out.println();\n		for (int y = 0; y < 6 * n - 1; y++) {\n			for (int x = 0; x < 6 * n - 1; x++) {\n				if (y / 6 == x / 6 && y % 6 < 5 && x % 6 < 5) {\n					if (y % 6 == 2 && x % 6 == 2) {\n						out.print((char) ('1' + y / 6));\n					} else if (y % 6 == 2) {\n						out.print('#');\n					} else {\n						out.print('.');\n					}\n				} else if (x % 6 == 2) {\n					out.print('.');\n				} else {\n					out.print('#');\n				}\n			}\n			out.println();\n		}\n	}\n\n	static int scanInt() throws IOException {\n		return parseInt(scanString());\n	}\n\n	static long scanLong() throws IOException {\n		return parseLong(scanString());\n	}\n\n	static String scanString() throws IOException {\n		while (tok == null || !tok.hasMoreTokens()) {\n			tok = new StringTokenizer(in.readLine());\n		}\n		return tok.nextToken();\n	}\n\n	static BufferedReader in;\n	static PrintWriter out;\n	static StringTokenizer tok;\n\n	public static void main(String[] args) {\n		try {\n			in = new BufferedReader(new InputStreamReader(System.in));\n			out = new PrintWriter(System.out);\n			solve();\n			in.close();\n			out.close();\n		} catch (Throwable e) {\n			e.printStackTrace();\n			exit(1);\n		}\n	}\n}","constructive algorithms,graphs"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/**\n * Created by vaksenov on 20.11.2018.\n */\npublic class Main {\n    BufferedReader br;\n    StringTokenizer st;\n    PrintWriter out;\n\n    public String nextToken() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public void solve() throws IOException {\n        int n = nextInt();\n        boolean[][] a = new boolean[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                a[i][j] = nextInt() == 1;\n            }\n        }\n\n        char[][][] ans = new char[3][3 * n][3 * n * n];\n        for (int i = 0; i < ans.length; i++) {\n            for (int j = 0; j < ans[i].length; j++) {\n                Arrays.fill(ans[i][j], '#');\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 3 * n * n; j++) {\n                ans[0][3 * i][j] = '.';\n            }\n            ans[0][3 * i][0] = (char) ('1' + i);\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!a[i][j]) {\n                    continue;\n                }\n                int y = 3 * (i * n + j);\n                int dx = i < j ? 1 : -1;\n                ans[1][3 * i][y] = '.';\n                ans[1][3 * i + dx][y] = '.';\n                ans[2][3 * i + dx][y] = '.';\n                for (int k = 3 * i + 2 * dx; k != 3 * j; k += dx) {\n                    ans[2][k][y] = '.';\n                }\n                ans[2][3 * j][y] = '.';\n                ans[1][3 * j][y] = '.';\n            }\n        }\n\n        out.println(ans[0][0].length + "" "" + ans[0].length + "" "" + ans.length);\n\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < ans[i].length; j++) {\n                for (int k = 0; k < ans[i][j].length; k++) {\n                    out.print(ans[2 - i][j][k]);\n                }\n                out.println();\n            }\n            out.println();\n            out.println();\n        }\n    }\n\n    public void run() {\n        try {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n\n            solve();\n\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n","constructive algorithms,graphs"
"import java.util.*;\nimport java.io.*;\n\npublic class SolA {\n	\n	public static void main(String[] args) throws Exception {\n		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n		BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n		StringTokenizer tok = new StringTokenizer(in.readLine());\n		int n = Integer.parseInt(tok.nextToken());\n		\n		int x = 5 * n;\n		int y = 5 * n;\n		int h = 4 * n;\n		\n		out.write(x + "" "" + y + "" "" + h + ""\n"");\n		char[][][] ans = new char[x][y][h];\n		for(int xx = 0; xx < x; xx += 5) {\n			for(int yy = 0 ; yy < y; yy += 5) {\n				Arrays.fill(ans[xx][yy], '#');\n				Arrays.fill(ans[xx+1][yy], '#');\n				Arrays.fill(ans[xx+2][yy], '#');\n				Arrays.fill(ans[xx+3][yy], '#');\n				Arrays.fill(ans[xx+4][yy], '.');\n				Arrays.fill(ans[xx][yy+1], '#');\n				Arrays.fill(ans[xx+1][yy+1], '.');\n				Arrays.fill(ans[xx+2][yy+1], '.');\n				Arrays.fill(ans[xx+3][yy+1], '#');\n				Arrays.fill(ans[xx+4][yy+1], '.');\n				Arrays.fill(ans[xx][yy+2], '#');\n				Arrays.fill(ans[xx+1][yy+2], '.');\n				Arrays.fill(ans[xx+2][yy+2], '.');\n				Arrays.fill(ans[xx+3][yy+2], '#');\n				Arrays.fill(ans[xx+4][yy+2], '.');\n				Arrays.fill(ans[xx][yy+3], '#');\n				Arrays.fill(ans[xx+1][yy+3], '#');\n				Arrays.fill(ans[xx+2][yy+3], '#');\n				Arrays.fill(ans[xx+3][yy+3], '#');\n				Arrays.fill(ans[xx+4][yy+3], '.');\n				Arrays.fill(ans[xx][yy+4], '.');\n				Arrays.fill(ans[xx+1][yy+4], '.');\n				Arrays.fill(ans[xx+2][yy+4], '.');\n				Arrays.fill(ans[xx+3][yy+4], '.');\n				Arrays.fill(ans[xx+4][yy+4], '.');\n				for(int hh = 0; hh < h; hh++) {\n					if(hh % 4 == 0) {\n						ans[xx+1][yy+2][hh] = '#';\n					} else if (hh % 4 == 1) {\n						ans[xx+1][yy+1][hh] = '#';\n					} else if(hh % 4 == 2) {\n						ans[xx+2][yy+1][hh] = '#';\n					} else {\n						ans[xx+2][yy+2][hh] = '#';\n						ans[xx][yy+4][hh] = '#';\n						ans[xx+1][yy+4][hh] = '#';\n						ans[xx+2][yy+4][hh] = '#';\n						ans[xx+3][yy+4][hh] = '#';\n						ans[xx+4][yy+4][hh] = '#';\n						ans[xx+4][yy+3][hh] = '#';\n						ans[xx+4][yy+2][hh] = '#';\n						ans[xx+4][yy+1][hh] = '#';\n						ans[xx+4][yy][hh] = '#';\n					}\n				}\n			}\n		}\n		for(int i = 1; i <= n; i++) {\n			ans[5*i - 1][5*i - 1][4*(i - 1)] = (char) ('0' + (char) i);\n		}\n		//enter from\n		for(int i = 0; i < n; i++) {\n			tok = new StringTokenizer(in.readLine());\n			//leave at\n			for(int j = 0; j < n; j++) {\n				if(1 == Integer.parseInt(tok.nextToken())) {\n					//enter\n					ans[j*5 + 1][i*5 + 3][4*i] = '.';\n					ans[j*5 + 2][i*5 + 3][4*i] = '.';\n					\n					//leave\n					ans[j*5 + 3][i*5 + 1][4*j + 2] = '.';\n					ans[j*5 + 3][i*5 + 1][4*j + 3] = '.';\n				}\n			}\n		}\n		for(int hh = h-1; hh >= 0; hh--) {\n			for(int yy = 0; yy < y; yy++) {\n				for(int xx = 0; xx < x; xx++) {\n					out.write(ans[xx][yy][hh]);\n				}\n				out.write(""\n"");\n			}\n			if(hh != 0) out.write(""\n"");\n		}\n		out.flush();\n	}\n}","constructive algorithms,graphs"
"import java.util.Scanner;\n\npublic class Minegraphed {\n	\n	private static final int N = 32;\n	\n	private int n;\n	private int[][] a = new int[N][N];\n	private int[] f = new int[N];\n	private int[] list = new int[N];\n	private int listSize;\n	\n	private int[][] component = new int[N][N];\n	private int[] componentSize = new int[N];\n	int componentsCount;\n	\n	private int[][][] lo = new int[N][N][N];\n	\n	private void DFS(int x) {\n		f[x] = 1;\n		for(int i = 1; i <= n; i++) {\n			if(f[i] == 0 && a[x][i] == 1) {\n				DFS(i);\n			}\n		}\n		list[++listSize] = x;\n	}\n	\n	private void BackwardDFS(int x, int v) {\n		f[x] = v;\n		for(int i = 1; i <= n; i++) {\n			if(f[list[i]] == 0 && a[list[i]][x] == 1) {\n				BackwardDFS(list[i], v);\n			}\n		}\n	}\n	\n	public int processTestCase() {\n		Scanner s = new Scanner(System.in);\n		n = s.nextInt();\n		for(int i = 1; i <= n; i++) {\n			for(int j = 1; j <= n; j++) {\n				a[i][j] = s.nextInt();\n			}\n		}\n		for(int i = 1; i <= n; i++) {\n			if(f[i] == 0) {\n				DFS(i);\n			}\n		}\n		for(int i = 1; i <= n / 2; i++) {\n			int h = list[i];\n			list[i] = list[n - i + 1];\n			list[n - i + 1] = h;\n		}\n		for(int i = 1; i <= n; i++) {\n			//System.out.print(list[i] + "" "");\n		}\n		//System.out.println();\n		\n		java.util.Arrays.fill(f, 0);\n		\n		for(int i = 1; i <= n; i++) {\n			if(f[list[i]] == 0) {\n				BackwardDFS(list[i], i);\n				componentsCount++;\n				for(int j = 1; j <= n; j++) {\n					if(f[j] == i) {\n						component[componentsCount][componentSize[componentsCount]++] = j;\n					}\n				}\n			}\n		}\n		\n		for(int k = 1; k <= n; k++) {\n			for(int i = 1; i <= n; i++) {\n				for(int j = 1; j <= n; j++) {\n					if( a[i][j] == 0 && a[i][k] == 1 && a[k][j] == 1) {\n						a[i][j] = 1;\n					}\n				}\n			}\n		}\n		\n		int l = 0;\n		for(int i = 1; i <= componentsCount; i++) {\n			for(int j = 0; j < componentSize[componentsCount]; j++) {\n				lo[l][9][j + 1] = component[i][j];\n			}\n			for(int j = 1; j <= 18; j++) {\n				lo[l][2][j] = -1;\n				if(j % 2 == 0) lo[l][1][j] = -1;\n			}\n			lo[l][2][(componentsCount - i + 1) * 2 - 1] = 0;\n			for(int j = 1; j <= 9; j++) {\n				for(int k = 1; k <= 18; k++) {\n					lo[l + 1][j][k] = -1;\n				}\n			}\n			for(int j = 1; j < componentsCount - i + 1; j++) {\n				lo[l + 1][1][2 * j - 1] = 0;\n			}\n\n			for(int k = 1; k <= i; k++) {\n				if(a[component[k][0]][component[i][0]] == 1) {\n					lo[(k - 1) * 2][2][2 * (componentsCount - i) + 1] = 0;\n				}\n			}			\n			\n			l += 2;\n		}\n		\n		System.out.println(""18 9 "" + l);\n		for(int i = 0; i < l; i++) {\n			for(int j = 1; j <= 9; j++) {\n				for(int k = 1; k <= 18; k++) {\n					if(lo[i][j][k] == -1) System.out.print(""#""); else\n					if(lo[i][j][k] ==  0) System.out.print("".""); else \n						System.out.print(lo[i][j][k]); \n						\n				}\n				System.out.println();\n			}\n			System.out.println();\n		}\n		\n		s.close();\n		return 0;\n	}\n	\n	/*\n6\n0 1 1 0 0 0\n0 0 0 1 1 0\n0 0 0 1 0 1\n0 0 0 0 0 1\n0 0 0 0 0 0\n0 0 0 0 0 0	\n	 */\n	\n	public static void main(String[] args) {\n		Minegraphed np = new Minegraphed();\n		np.processTestCase();\n	}\n	\n}","constructive algorithms,graphs"
import java.util.*;\n\npublic class Solution {\n\n  private static Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    System.out.println(sc.nextInt() == 2 ? 2 : 1);\n  }\n\n},"constructive algorithms,math"
import java.util.*;\n\npublic class A {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        System.out.println(n == 2 ? 2 : 1);\n    }\n},"constructive algorithms,math"
import java.util.*;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		if(n==2)\n			System.out.print(2);\n		else\n			System.out.print(1);\n	}\n} ,"constructive algorithms,math"
"import java.util.Scanner;\npublic class main\n{\npublic static void main(String[]args)\n\n{\nScanner sc=new Scanner(System.in);\nlong n=sc.nextLong();\nif(n==2)\nSystem.out.println(""2"");\nelse\nSystem.out.println(""1"");\n}\n}","constructive algorithms,math"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author lewin\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        FChoosingTwoPaths solver = new FChoosingTwoPaths();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FChoosingTwoPaths {\n        int n;\n        List<Integer>[] graph;\n        boolean[] safe;\n        boolean[] removed;\n        int[][] bts;\n        int[] down;\n        int[] up;\n        int[] fup;\n        int[] fdown;\n        int[] fupid;\n        int[] fdownid;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            n = in.nextInt();\n            graph = LUtils.genArrayList(n);\n            for (int i = 0; i < n - 1; i++) {\n                int a = in.nextInt() - 1, b = in.nextInt() - 1;\n                graph[a].add(b);\n                graph[b].add(a);\n            }\n            safe = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                safe[i] = graph[i].size() >= 3;\n            }\n\n            Debug.print(safe);\n            removed = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                if (graph[i].size() == 1) {\n                    int prev = -1;\n                    int cur = i;\n                    while (true) {\n                        removed[cur] = true;\n                        int x = -1;\n                        for (int nxt : graph[cur]) {\n                            if (nxt != prev) {\n                                x = nxt;\n                                break;\n                            }\n                        }\n                        if (x == -1 || safe[x]) break;\n                        prev = cur;\n                        cur = x;\n                    }\n                }\n            }\n\n            bts = new int[n][];\n            for (int i = 0; i < n; i++) {\n                if (!removed[i]) {\n                    bts[i] = dfs3(i, -1);\n                }\n            }\n            down = new int[n];\n            up = new int[n];\n            fup = new int[n];\n            fdown = new int[n];\n            fupid = new int[n];\n            fdown = new int[n];\n            fdownid = new int[n];\n            for (int i = 0; i < n; i++) {\n                if (!removed[i]) {\n                    dfs(i, -1);\n                    dfs2(i, -1, 0, -1, -1);\n                    break;\n                }\n            }\n            int[] ret = new int[n];\n            int[] f = new int[n];\n            int[] fid = new int[n];\n            for (int i = 0; i < n; i++) {\n                if (up[i] > down[i] || (up[i] == down[i] && fup[i] > fdown[i])) {\n                    ret[i] = up[i];\n                    f[i] = fup[i];\n                    fid[i] = fupid[i];\n                } else {\n                    ret[i] = down[i];\n                    f[i] = fdown[i];\n                    fid[i] = fdownid[i];\n                }\n                Debug.print(i, bts[i], ret[i], f[i], fid[i]);\n            }\n            int mx = AUtils.max(ret);\n            int bestsum = 1, id1 = -1, id2 = -1;\n            for (int i = 0; i < n; i++) {\n                if (ret[i] == mx) {\n                    if (f[i] + bts[i][1] + bts[i][3] > bestsum) {\n                        bestsum = f[i] + bts[i][1] + bts[i][3];\n                        id1 = i;\n                        id2 = fid[i];\n                    }\n                }\n            }\n\n            Debug.print(mx, bestsum, id1, id2);\n            out.println((bts[id1][0] + 1) + "" "" + (bts[id2][0] + 1));\n            out.println((bts[id1][2] + 1) + "" "" + (bts[id2][2] + 1));\n        }\n\n        int[] dfs3(int node, int par) {\n            int x1 = node, x2 = -1, d1 = 0, d2 = 0;\n            if (graph[node].size() > 1) x1 = -1;\n            for (int next : graph[node]) {\n                if (next == par || !removed[next]) continue;\n                int[] q = dfs3(next, node);\n                for (int i = 0; i < 2; i++) {\n                    int cx = q[0 + 2 * i], cd = q[1 + 2 * i];\n                    if (cx == -1) continue;\n                    if (cd + 1 > d1) {\n                        x2 = x1;\n                        d2 = d1;\n                        x1 = cx;\n                        d1 = cd + 1;\n                    } else if (cd + 1 > d2) {\n                        x2 = cx;\n                        d2 = cd + 1;\n                    }\n                }\n            }\n            return new int[]{x1, d1, x2, d2};\n        }\n\n        public void dfs(int node, int par) {\n            fdown[node] = bts[node][1] + bts[node][3];\n            fdownid[node] = node;\n            for (int next : graph[node]) {\n                if (next == par || removed[next]) continue;\n                dfs(next, node);\n                if (down[next] + 1 > down[node]) {\n                    fdown[node] = fdown[next];\n                    fdownid[node] = fdownid[next];\n                    down[node] = down[next] + 1;\n                } else if (down[next] + 1 == down[node] && fdown[node] < fdown[next]) {\n                    fdown[node] = fdown[next];\n                    fdownid[node] = fdownid[next];\n                    down[node] = down[next] + 1;\n                }\n            }\n        }\n\n        public void dfs2(int node, int par, int frompar, int fromparf, int fromparid) {\n            up[node] = frompar;\n            fup[node] = fromparf;\n            fupid[node] = fromparid;\n\n            int mx1 = 0, id1 = -1, mx2 = 0;\n            int fmx1 = 0, fmx1id = -1, fmx2 = 0, fmx2id = -1;\n            for (int next : graph[node]) {\n                if (next == par || removed[next]) continue;\n                if (down[next] + 1 > mx1) {\n                    mx2 = mx1;\n                    fmx2id = fmx1id;\n                    fmx2 = fmx1;\n                    mx1 = down[next] + 1;\n                    id1 = next;\n                    fmx1 = fdown[next];\n                    fmx1id = fdownid[next];\n                } else if (down[next] + 1 == mx1 && fdown[next] > fmx1) {\n                    mx2 = mx1;\n                    fmx2id = fmx1id;\n                    fmx2 = fmx1;\n                    mx1 = down[next] + 1;\n                    id1 = next;\n                    fmx1 = fdown[next];\n                    fmx1id = fdownid[next];\n                } else if (down[next] + 1 > mx2) {\n                    mx2 = down[next] + 1;\n                    fmx2 = fdown[next];\n                    fmx2id = fdownid[next];\n                } else if (down[next] + 1 == mx2 && fdown[next] > fmx2) {\n                    fmx2 = fdown[next];\n                    fmx2id = fdownid[next];\n                }\n            }\n\n            for (int next : graph[node]) {\n                if (next == par || removed[next]) continue;\n                int dmx, fmx, fmxid;\n                if (next != id1) {\n                    dmx = mx1;\n                    fmx = fmx1;\n                    fmxid = fmx1id;\n                } else {\n                    dmx = mx2;\n                    fmx = fmx2;\n                    fmxid = fmx2id;\n                }\n                if (up[node] > dmx) {\n                    dmx = up[node];\n                    fmx = fromparf;\n                    fmxid = fromparid;\n                } else if (dmx == up[node] && fromparf > fmx) {\n                    dmx = up[node];\n                    fmx = fromparf;\n                    fmxid = fromparid;\n                }\n                dfs2(next, node, dmx + 1, fmx, fmxid);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1 << 20];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (this.numChars == -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar >= this.numChars) {\n                    this.curChar = 0;\n\n                    try {\n                        this.numChars = this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars <= 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c = this.read(); isSpaceChar(c); c = this.read()) {\n                ;\n            }\n\n            byte sgn = 1;\n            if (c == 45) {\n                sgn = -1;\n                c = this.read();\n            }\n\n            int res = 0;\n\n            while (c >= 48 && c <= 57) {\n                res *= 10;\n                res += c - 48;\n                c = this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c == 32 || c == 10 || c == 13 || c == 9 || c == -1;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class LUtils {\n        public static <E> List<E>[] genArrayList(int size) {\n            return Stream.generate(ArrayList::new).limit(size).toArray(List[]::new);\n        }\n\n    }\n\n    static class Debug {\n        public static boolean DEBUG;\n\n        static {\n            try {\n                DEBUG = System.getProperty(""user.dir"").contains(""Dropbox"");\n            } catch (Exception e) {\n                DEBUG = false;\n            }\n        }\n\n        private static ArrayList<String> getParams() {\n            StackTraceElement[] t = Thread.currentThread().getStackTrace();\n            StackTraceElement up = t[3];\n\n            ArrayList<String> ret = new ArrayList<>();\n            String qqq = up.toString();\n            ret.add(""."" + up.getMethodName() + qqq.substring(qqq.indexOf(""(""), qqq.length()));\n            try {\n                BufferedReader br = new BufferedReader(new FileReader(\n                        new File(""src/"" + up.getClassName().replaceAll(""\\."", ""/"") + "".java"")));\n                int g = up.getLineNumber();\n                while (--g > 0) br.readLine();\n                String q = br.readLine();\n                String[] ss = q.split(""Debug\\.print\\("");\n                String[] qq = ss[1].substring(0, ss[1].lastIndexOf("")"")).split("","");\n                for (int i = 0; i < qq.length; i++) {\n                    ret.add(qq[i].trim());\n                }\n            } catch (Exception e) {\n            }\n            for (int i = 0; i < 100; i++) ret.add(""???"");\n            return ret;\n        }\n\n        private static String toString(Object o) {\n            if (o == null) {\n                return ""null"";\n            } else if (o instanceof Object[]) {\n                return Arrays.toString((Object[]) o);\n            } else if (o instanceof char[]) {\n                return new String((char[]) o);\n            } else if (o instanceof int[]) {\n                return Arrays.toString((int[]) o);\n            } else if (o instanceof long[]) {\n                return Arrays.toString((long[]) o);\n            } else if (o instanceof double[]) {\n                return Arrays.toString((double[]) o);\n            } else if (o instanceof boolean[]) {\n                return Arrays.toString((boolean[]) o);\n            } else {\n                return o.toString();\n            }\n        }\n\n        public static void print(Object x) {\n            if (!DEBUG) return;\n            ArrayList<String> s = getParams();\n            System.out.println(s.get(0) + "": "" + s.get(1) + "" = "" + toString(x));\n        }\n\n        public static void print(Object... x) {\n            if (!DEBUG) return;\n            ArrayList<String> s = getParams();\n            System.out.print(s.get(0) + "": "");\n            for (int i = 0; i < x.length; i++) {\n                System.out.print(s.get(i + 1) + "" = "" + toString(x[i]));\n                if (i != x.length - 1) System.out.print("", "");\n            }\n            System.out.println();\n        }\n\n    }\n\n    static class AUtils {\n        public static int max(int[] arr) {\n            int res = arr[0];\n            for (int x : arr) if (x > res) res = x;\n            return res;\n        }\n\n    }\n}\n\n","dfs and similar,dp,greedy,trees"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FChoosingTwoPaths solver = new FChoosingTwoPaths();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FChoosingTwoPaths {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            Node[] nodes = new Node[n];\n            for (int i = 0; i < n; i++) {\n                nodes[i] = new Node();\n                nodes[i].id = i;\n            }\n\n            int[][] edges = new int[n - 1][2];\n            for (int i = 0; i < n - 1; i++) {\n                edges[i][0] = in.readInt() - 1;\n                edges[i][1] = in.readInt() - 1;\n                Node a = nodes[edges[i][0]];\n                Node b = nodes[edges[i][1]];\n                a.next.add(b);\n                b.next.add(a);\n            }\n\n            Node root = null;\n            for (Node node : nodes) {\n                if (node.next.size() >= 3) {\n                    root = node;\n                    break;\n                }\n            }\n            dfsForDepth(root, null, 0);\n\n            for (Node node : nodes) {\n                if (node.next.size() == 1) {\n                    upward(node);\n                }\n            }\n\n            MultiWayIntegerStack edgeStack = new MultiWayIntegerStack(n, n * 2);\n            for (int[] e : edges) {\n                if (nodes[e[0]].removed || nodes[e[1]].removed) {\n                    continue;\n                }\n                edgeStack.addLast(e[0], e[1]);\n                edgeStack.addLast(e[1], e[0]);\n            }\n            ForestDiameter td = new ForestDiameter(edgeStack, n);\n            if (td.getCenters(root.id).size() == 1) {\n                Node center = nodes[td.getCenters(root.id).get(0)];\n                int sd = td.getDiameter(root.id) / 2;\n                List<NodePair> pairs = new ArrayList<>(center.next.size());\n                for (Node node : center.next) {\n                    pairs.add(findLargestSum(node, center, 1, sd));\n                }\n                pairs.sort(this::compare);\n                NodePair a = pairs.get(pairs.size() - 1);\n                NodePair b = pairs.get(pairs.size() - 2);\n                answer(out, a, b);\n                return;\n            }\n\n            Node c1 = nodes[td.getCenters(root.id).get(0)];\n            Node c2 = nodes[td.getCenters(root.id).get(1)];\n            int sd = (td.getDiameter(root.id) - 1) / 2;\n            NodePair a = findLargestSum(c1, c2, 0, sd);\n            NodePair b = findLargestSum(c2, c1, 0, sd);\n            answer(out, a, b);\n        }\n\n        public void answer(FastOutput out, NodePair a, NodePair b) {\n            out.append(a.a.id + 1).append(' ').append(b.a.id + 1).println();\n            out.append(a.b.id + 1).append(' ').append(b.b.id + 1).println();\n        }\n\n        public NodePair max(NodePair a, NodePair b) {\n            return compare(a, b) >= 0 ? a : b;\n        }\n\n        public int compare(NodePair a, NodePair b) {\n            if (a == null) {\n                return -1;\n            }\n            if (b == null) {\n                return 1;\n            }\n            return a.len - b.len;\n        }\n\n        public NodePair findLargestSum(Node root, Node p, int depth, int searchDepth) {\n            if (root.removed) {\n                return null;\n            }\n\n            NodePair ans = null;\n            root.depth = depth;\n\n            if (depth == searchDepth) {\n                List<Node> nodes = new ArrayList<>(root.next.size());\n                for (Node node : root.next) {\n                    if (node == p) {\n                        continue;\n                    }\n                    nodes.add(findDepthest(node, root, depth + 1));\n                }\n                nodes.sort((a, b) -> -(a.depth - b.depth));\n                NodePair pair = new NodePair();\n                pair.a = nodes.get(0);\n                pair.b = nodes.get(1);\n                pair.len = pair.a.depth + pair.b.depth - 2 * depth;\n                return pair;\n            }\n\n            for (Node node : root.next) {\n                if (node == p) {\n                    continue;\n                }\n                ans = max(ans, findLargestSum(node, root, depth + 1, searchDepth));\n            }\n            return ans;\n        }\n\n        public Node findDepthest(Node root, Node p, int depth) {\n            root.depth = depth;\n            for (Node node : root.next) {\n                if (node == p) {\n                    continue;\n                }\n                return findDepthest(node, root, depth + 1);\n            }\n            return root;\n        }\n\n        public void upward(Node root) {\n            if (root == null || root.removed || root.next.size() >= 3) {\n                return;\n            }\n            root.removed = true;\n            upward(root.p);\n        }\n\n        public void dfsForDepth(Node root, Node p, int depth) {\n            root.depth = depth;\n            root.p = p;\n            for (Node node : root.next) {\n                if (node == p) {\n                    continue;\n                }\n                dfsForDepth(node, root, depth + 1);\n            }\n        }\n\n    }\n\n    static class ForestDiameter {\n        private MultiWayIntegerStack edges;\n        private int[] depth;\n        private int[] parents;\n        private int[] diameters;\n        private IntegerList[] centers;\n        private IntegerList[] ends;\n        private int[] treeIds;\n        private IntegerList collector;\n\n        public IntegerList getCenters(int i) {\n            return centers[i];\n        }\n\n        public int getDiameter(int i) {\n            return diameters[i];\n        }\n\n        public ForestDiameter(MultiWayIntegerStack edges, int n) {\n            this.edges = edges;\n            depth = new int[n];\n            parents = new int[n];\n            centers = new IntegerList[n];\n            ends = new IntegerList[n];\n            treeIds = new int[n];\n            diameters = new int[n];\n            collector = new IntegerList(n);\n            int idAllocator = 0;\n            Arrays.fill(treeIds, -1);\n\n            for (int j = 0; j < n; j++) {\n                if (treeIds[j] != -1) {\n                    continue;\n                }\n                IntegerList endList = new IntegerList(2);\n                IntegerList centerList = new IntegerList(2);\n                collector.clear();\n                dfsForCollect(j, -1);\n                dfsForDepth(j, -1);\n                int end = collector.get(0);\n                for (IntegerIterator iterator = collector.iterator(); iterator.hasNext(); ) {\n                    int node = iterator.next();\n                    if (depth[node] > depth[end]) {\n                        end = node;\n                    }\n                }\n                dfsForDepth(end, -1);\n                int another = collector.get(0);\n                for (IntegerIterator iterator = collector.iterator(); iterator.hasNext(); ) {\n                    int node = iterator.next();\n                    if (depth[node] > depth[another]) {\n                        another = node;\n                    }\n                }\n\n                endList.add(end);\n                endList.add(another);\n\n                int diameter = depth[another];\n                for (int i = another; i != -1; i = parents[i]) {\n                    if (depth[i] == DigitUtils.ceilDiv(diameter, 2) ||\n                            depth[i] == DigitUtils.floorDiv(diameter, 2)) {\n                        centerList.add(i);\n                    }\n                }\n\n                endList.unique();\n                centerList.unique();\n\n                for (IntegerIterator iterator = collector.iterator(); iterator.hasNext(); ) {\n                    int node = iterator.next();\n                    treeIds[node] = idAllocator;\n                    diameters[node] = diameter;\n                    ends[node] = endList;\n                    centers[node] = centerList;\n                }\n                idAllocator++;\n            }\n        }\n\n        private void dfsForCollect(int root, int p) {\n            collector.add(root);\n            for (IntegerIterator iterator = edges.iterator(root); iterator.hasNext(); ) {\n                int node = iterator.next();\n                if (node == p) {\n                    continue;\n                }\n                dfsForCollect(node, root);\n            }\n        }\n\n        private void dfsForDepth(int root, int p) {\n            parents[root] = p;\n            depth[root] = p != -1 ? depth[p] + 1 : 0;\n            for (IntegerIterator iterator = edges.iterator(root); iterator.hasNext(); ) {\n                int node = iterator.next();\n                if (node == p) {\n                    continue;\n                }\n                dfsForDepth(node, root);\n            }\n        }\n\n    }\n\n    static interface IntegerIterator {\n        boolean hasNext();\n\n        int next();\n\n    }\n\n    static class MultiWayIntegerStack {\n        private int[] values;\n        private int[] next;\n        private int[] heads;\n        private int alloc;\n        private int stackNum;\n\n        public IntegerIterator iterator(final int queue) {\n            return new IntegerIterator() {\n                int ele = heads[queue];\n\n\n                public boolean hasNext() {\n                    return ele != 0;\n                }\n\n\n                public int next() {\n                    int ans = values[ele];\n                    ele = next[ele];\n                    return ans;\n                }\n            };\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            values = Arrays.copyOf(values, newSize);\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n        }\n\n        public MultiWayIntegerStack(int qNum, int totalCapacity) {\n            values = new int[totalCapacity + 1];\n            next = new int[totalCapacity + 1];\n            heads = new int[qNum];\n            stackNum = qNum;\n        }\n\n        public void addLast(int qId, int x) {\n            alloc();\n            values[alloc] = x;\n            next[alloc] = heads[qId];\n            heads[qId] = alloc;\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < stackNum; i++) {\n                builder.append(i).append("": "");\n                for (IntegerIterator iterator = iterator(i); iterator.hasNext(); ) {\n                    builder.append(iterator.next()).append("","");\n                }\n                if (builder.charAt(builder.length() - 1) == ',') {\n                    builder.setLength(builder.length() - 1);\n                }\n                builder.append('\n');\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static class Node {\n        List<Node> next = new ArrayList<>();\n        boolean removed;\n        int id;\n        int depth;\n        Node p;\n\n        public String toString() {\n            return """" + (id + 1);\n        }\n\n    }\n\n    static class IntegerList implements Cloneable {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public IntegerList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntegerList(IntegerList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntegerList() {\n            this(0);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        private void checkRange(int i) {\n            if (i < 0 || i >= size) {\n                throw new ArrayIndexOutOfBoundsException();\n            }\n        }\n\n        public int get(int i) {\n            checkRange(i);\n            return data[i];\n        }\n\n        public void add(int x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public void addAll(int[] x, int offset, int len) {\n            ensureSpace(size + len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(IntegerList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public void sort() {\n            if (size <= 1) {\n                return;\n            }\n            Randomized.randomizedArray(data, 0, size);\n            Arrays.sort(data, 0, size);\n        }\n\n        public void unique() {\n            if (size <= 1) {\n                return;\n            }\n\n            sort();\n            int wpos = 1;\n            for (int i = 1; i < size; i++) {\n                if (data[i] != data[wpos - 1]) {\n                    data[wpos++] = data[i];\n                }\n            }\n            size = wpos;\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public void clear() {\n            size = 0;\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public IntegerIterator iterator() {\n            return new IntegerIterator() {\n                int i = 0;\n\n\n                public boolean hasNext() {\n                    return i < size;\n                }\n\n\n                public int next() {\n                    return data[i++];\n                }\n            };\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof IntegerList)) {\n                return false;\n            }\n            IntegerList other = (IntegerList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n        public int hashCode() {\n            int h = 1;\n            for (int i = 0; i < size; i++) {\n                h = h * 31 + Integer.hashCode(data[i]);\n            }\n            return h;\n        }\n\n        public IntegerList clone() {\n            IntegerList ans = new IntegerList();\n            ans.addAll(this);\n            return ans;\n        }\n\n    }\n\n    static class Randomized {\n        static Random random = new Random();\n\n        public static void randomizedArray(int[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                int tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static int floorDiv(int a, int b) {\n            return a < 0 ? -ceilDiv(-a, b) : a / b;\n        }\n\n        public static int ceilDiv(int a, int b) {\n            if (a < 0) {\n                return -floorDiv(-a, b);\n            }\n            int c = a / b;\n            if (c * b < a) {\n                return c + 1;\n            }\n            return c;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println() {\n            cache.append('\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class NodePair {\n        Node a;\n        Node b;\n        int len;\n\n    }\n\n    static class SequenceUtils {\n        public static boolean equal(int[] a, int al, int ar, int[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n}\n\n","dfs and similar,dp,greedy,trees"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        ESegmentSum solver = new ESegmentSum();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ESegmentSum {\n        char[] l;\n        char[] r;\n        int k;\n        char[] arr;\n        long[] pow;\n        int mod = 998244353;\n        long[][][][] memo;\n        long[][][][] memo2;\n\n        public void readInput(Scanner sc) {\n            l = ((sc.nextLong() - 1) + """").toCharArray();\n            r = (sc.nextLong() + """").toCharArray();\n            k = sc.nextInt();\n        }\n\n        public void solve(int testNumber, Scanner sc, PrintWriter pw) {\n            int q = 1;\n            while (q-- > 0) {\n                readInput(sc);\n                pow = new long[20];\n                pow[0] = 1;\n                for (int i = 1; i < pow.length; i++) {\n                    pow[i] = (10 * pow[i - 1]);\n                    pow[i] %= mod;\n                }\n                long ans = dp(r);\n                pw.println((ans - dp(l) + mod) % mod);\n            }\n        }\n\n        private long dp(char[] a) {\n            arr = a;\n            memo = new long[2][2][arr.length][1 << 10];\n            for (long[][][] x : memo)\n                for (long[][] y : x)\n                    for (long[] z : y)\n                        Arrays.fill(z, -1);\n            memo2 = new long[2][2][arr.length][1 << 10];\n            for (long[][][] x : memo2)\n                for (long[][] y : x)\n                    for (long[] z : y)\n                        Arrays.fill(z, -1);\n            return dp(0, 0, 0, 0);\n        }\n\n        private long dp(int idx, int msk, int bool, int bool2) {\n            if (idx == arr.length)\n                return 0;\n            if (memo[bool][bool2][idx][msk] != -1)\n                return memo[bool][bool2][idx][msk];\n            int e = bool == 1 ? 9 : arr[idx] - '0';\n            long ans = 0;\n            for (int i = 0; i <= e; i++) {\n                int nextBool = i < arr[idx] - '0' ? 1 : bool;\n                int nextBool2 = i != 0 ? 1 : bool2;\n                int nextMsk = nextBool2 == 1 ? msk | 1 << i : msk;\n                long temp = count(idx + 1, nextMsk, nextBool, nextBool2);\n                if (temp == 0)\n                    continue;\n                temp *= pow[arr.length - 1 - idx];\n                temp %= mod;\n                temp *= i;\n                ans += temp;\n                ans += dp(idx + 1, nextMsk, nextBool, nextBool2);\n                ans %= mod;\n            }\n            return memo[bool][bool2][idx][msk] = ans;\n        }\n\n        private long count(int idx, int msk, int bool, int bool2) {\n            if (idx == arr.length)\n                return bool2 == 1 && Integer.bitCount(msk) <= k ? 1 : 0;\n            if (memo2[bool][bool2][idx][msk] != -1)\n                return memo2[bool][bool2][idx][msk];\n            int e = bool == 1 ? 9 : arr[idx] - '0';\n            long ans = 0;\n            for (int i = 0; i <= e; i++) {\n                int nextBool = i < arr[idx] - '0' ? 1 : bool;\n                int nextBool2 = i != 0 ? 1 : bool2;\n                int nextMsk = nextBool2 == 1 ? msk | 1 << i : msk;\n                ans += count(idx + 1, nextMsk, nextBool, nextBool2);\n                ans %= mod;\n            }\n            return memo2[bool][bool2][idx][msk] = ans;\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() {\n            try {\n                while (st == null || !st.hasMoreTokens())\n                    st = new StringTokenizer(br.readLine());\n                return st.nextToken();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n\n","bitmasks,combinatorics,dp,math"
"import java.util.*;\nimport java.io.*;\n\npublic class Div712 {\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////                                                                                                               /////////\n////////                                                                                                               /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM         OOOOOO             SSSSSSS      EEEEEEEEEEEEE  /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMMMM      MMMMMM      OOO      OOO        SSSS   SSS     EEEEEEEEEEEEE  /////////\n////////   HHHH        HHHH  EEEEE           MMMM MMM  MMM MMMM    OOO          OOO    SSSS       SSS   EEEEE          /////////\n////////   HHHH        HHHH  EEEEE           MMMM  MMMMMM  MMMM   OOO            OOO   SSSS             EEEEE          /////////\n////////   HHHH        HHHH  EEEEE           MMMM          MMMM  OOO              OOO   SSSSSSS         EEEEE          /////////\n////////   HHHHHHHHHHHHHHHH  EEEEEEEEEEE     MMMM          MMMM  OOO              OOO      SSSSSS       EEEEEEEEEEE    /////////\n////////   HHHHHHHHHHHHHHHH  EEEEEEEEEEE     MMMM          MMMM  OOO              OOO         SSSSSSS   EEEEEEEEEEE    /////////\n////////   HHHH        HHHH  EEEEE           MMMM          MMMM   OOO            OOO              SSSS  EEEEE          /////////\n////////   HHHH        HHHH  EEEEE           MMMM          MMMM    OOO          OOO     SSS       SSSS  EEEEE          /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM      OOO      OOO        SSS    SSSS    EEEEEEEEEEEEE  /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM         OOOOOO             SSSSSSS      EEEEEEEEEEEEE  /////////\n////////                                                                                                               /////////\n////////                                                                                                               /////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    static int mod = 998244353;\n    static int[][][] memo, memo2;\n    static int k;\n    static int[] s;\n    static long pow10[];\n\n    static int dp(int limit, int idx, int taken) {\n        if (Integer.bitCount(taken) > k)\n            return 0;\n        if (idx == 19)\n            return 1;\n        if (memo[limit][idx][taken] != -1)\n            return memo[limit][idx][taken];\n        int ans = 0;\n        for (int i = 0; i < 10; i++) {\n            if (!can(limit, idx, i))\n                continue;\n            if (i == 0 && taken == 0) {\n                ans += dp(getl(limit, idx, i), idx + 1, taken);\n            } else ans += dp(getl(limit, idx, i), idx + 1, taken | 1 << i);\n            ans %= mod;\n        }\n        return memo[limit][idx][taken] = ans;\n    }\n\n    static int dp2(int limit, int idx, int taken) {\n        if (Integer.bitCount(taken) > k)\n            return 0;\n        if (idx == 19)\n            return 0;\n        if (memo2[limit][idx][taken] != -1)\n            return memo2[limit][idx][taken];\n        long ans = 0;\n        for (int i = 0; i < 10; i++) {\n            if (!can(limit, idx, i))\n                continue;\n            if (i == 0 && taken == 0) {\n                ans += dp2(getl(limit, idx, i), idx + 1, taken);\n            } else {\n                long v = dp2(getl(limit, idx, i), idx + 1, taken | 1 << i);\n                long count = dp(getl(limit, idx, i), idx + 1, taken | 1 << i);\n                v += (count * i * pow10[18 - idx]);\n                v %= mod;\n                ans += v;\n            }\n            ans %= mod;\n        }\n        return memo2[limit][idx][taken] = (int) ans;\n    }\n\n    static int getl(int limit, int idx, int d) {\n        return limit | (s[idx] > d ? 1 : 0);\n    }\n\n    static boolean can(int limit, int idx, int d) {\n        return limit == 1 | (s[idx] >= d);\n    }\n\n    static int dpvalue(long v) {\n        s = new int[19];\n\n        int idx = 18;\n        while (idx >= 0) {\n            s[idx] = (int) (v % 10);\n            v /= 10;\n            idx--;\n        }\n        memo = new int[2][19][1 << 10];\n        memo2 = new int[2][19][1 << 10];\n\n        for (int[][] x : memo) for (int[] y : x) Arrays.fill(y, -1);\n        for (int[][] x : memo2) for (int[] y : x) Arrays.fill(y, -1);\n//        System.err.println(Arrays.toString(s));\n//        System.err.println(v + "" "" + dp2(0, 17, 0));\n        return dp2(0, 0, 0);\n    }\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        pow10 = new long[20];\n        pow10[0] = 1;\n        for (int i = 1; i < 20; i++) {\n            pow10[i] = (10 * pow10[i - 1]) % mod;\n        }\n\n        long l = sc.nextLong();\n        long r = sc.nextLong();\n        k = sc.nextInt();\n        long ans = dpvalue(r) - dpvalue(l - 1) + mod;\n\n        pw.println(ans % mod);\n\n        pw.flush();\n    }\n\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int[] nextIntArr(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(""0"");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(""0"");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n\n}\n","bitmasks,combinatorics,dp,math"
"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class P1073E\n{\n	static int mod = 998244353;\n	static long[] pow10mod;\n	static int k;\n	static int[] num;\n	static int[][][] dp, dpWays;\n	public static void main(String[] args)\n	{\n		pow10mod = new long[30];\n		pow10mod[0] = 1;\n		for (int i = 1; i < pow10mod.length; i++)\n			pow10mod[i] = 10*pow10mod[i-1] % mod;\n		Scanner scan = new Scanner(System.in);\n		long a = scan.nextLong();\n		long b = scan.nextLong();\n		k = scan.nextInt();\n		System.out.println((cnt(b) - cnt(a-1) + mod) % mod);\n	}\n	private static long cnt(long n)\n	{\n		char[] ch = (""""+n).toCharArray();\n		num = new int[ch.length];\n		for (int i = 0; i < ch.length; i++)\n			num[i] = ch[i]-'0';\n		\n		dp = new int[2][num.length][1 << 10];\n		for (int[][] a : dp)\n			for (int[] b : a)\n				Arrays.fill(b, -1);\n		dpWays = new int[2][num.length][1 << 10];\n		for (int[][] a : dpWays)\n			for (int[] b : a)\n				Arrays.fill(b, -1);\n		\n		return go(0, 0, 0, true);\n	}\n	private static int go(int started, int ind, int mask, boolean bounded)\n	{\n		if (ind == num.length)\n			return 0;\n		if (!bounded && dp[started][ind][mask] >= 0)\n			return dp[started][ind][mask];\n		\n		long ans = 0;\n		int b = bounded ? num[ind] : 9;\n		for (int i = 0; i <= b; i++)\n		{\n			long mult = i*pow10mod[num.length-ind-1] % mod;\n			ans += mult*ways(started == 1 || i > 0 ? 1 : 0, ind+1, started == 0 && i == 0 ? mask : mask | (1 << i), bounded && i == b);\n			ans += go(started == 1 || i > 0 ? 1 : 0, ind+1, started == 0 && i == 0 ? mask : mask | (1 << i), bounded && i == b);\n		}\n		\n		if (!bounded)\n			dp[started][ind][mask] = (int)(ans % mod);\n		return (int)(ans % mod);\n	}\n	private static int ways(int started, int ind, int mask, boolean bounded)\n	{\n		if (ind == num.length)\n			return Integer.bitCount(mask) <= k ? 1 : 0;\n		if (!bounded && dpWays[started][ind][mask] >= 0)\n			return dpWays[started][ind][mask];\n		\n		long ans = 0;\n		int b = bounded ? num[ind] : 9;\n		for (int i = 0; i <= b; i++)\n			ans += ways(started == 1 || i > 0 ? 1 : 0, ind+1, started == 0 && i == 0 ? mask : mask | (1 << i), bounded && i == b);\n		\n		if (!bounded)\n			dpWays[started][ind][mask] = (int)(ans % mod);\n		return (int)(ans % mod);\n	}\n}\n","bitmasks,combinatorics,dp,math"
"import java.io.*;\nimport java.util.*;\n\npublic class H {\n\n	static char[] s;\n	static int n, k;\n	static long[] pow;\n	static int MOD = 998244353;\n\n	static int solve(long r) {\n		s = (r + """").toCharArray();\n		n = s.length;\n		memo=new pair[2][n][1100];\n		\n		return dp(0, 0, 0, 0).v;\n	}\n	static pair[][][]memo;\n	static class pair\n	{\n		int v,cnt;\n		pair(int a,int b){\n			v=a;\n			cnt=b;\n		}\n	}\n	static pair dp(int idx, int less, int dis, int msk) {\n		\n		\n		\n		if(idx==n)\n			return new pair(0,1);\n		if(memo[less][idx][msk]!=null)\n			return memo[less][idx][msk];\n		long ans = 0;\n		long cnt=0;\n		int up = less == 1 ? 9 : s[idx] - '0';\n		for (int d = 0; d <= up; d++) {\n			int newLess = less == 1 ? 1 : d < s[idx] - '0' ? 1 : 0;\n			int newDis =dis;\n			if((msk & 1 << d) == 0  && (msk>1 || d>0))\n				newDis++;\n			if(newDis>k)\n				continue;\n			\n			long x=d*pow[n-1-idx]%MOD;\n		    int newMsk=msk;\n		    if(newDis==dis+1)\n		        newMsk|=1<<d;\n			pair p=dp(idx + 1, newLess, newDis,newMsk);\n			ans = ans +p.v ;\n			\n			ans %= MOD;\n			long y=x*p.cnt%MOD;\n			ans+=y;\n			ans%=MOD;\n			cnt+=p.cnt;\n			cnt%=MOD;\n		}\n\n		return memo[less][idx][msk]=new pair((int) ans,(int)cnt);\n\n	}\n\n	public static void main(String[] args) throws IOException {\n		Scanner sc = new Scanner();\n		PrintWriter out = new PrintWriter(System.out);\n		long l=sc.nextLong(),r=sc.nextLong();\n		k=sc.nextInt();\n		\n		pow=new long [20];\n		pow[0]=1;\n		for(int i=1;i<pow.length;i++)\n			pow[i]=10*pow[i-1]%MOD;\n		long ans=(solve(r)-solve(l-1));\n		if(ans<0)\n			ans+=MOD;\n		out.println(ans);\n		out.close();\n	}\n\n	static class Scanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		Scanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n\n		int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n	}\n}","bitmasks,combinatorics,dp,math"
"import java.util.Scanner;\npublic class Main\n{\n	public static void main(String[] args)\n	{\n		Scanner in=new Scanner(System.in);\n		while(in.hasNext())\n		{\n			int n=in.nextInt();\n			int m=in.nextInt();\n			int minx=100000005;\n			int a[]=new int[200005];\n			for (int i = 0; i < n; i++)\n			{\n				int h=in.nextInt();\n				minx=Math.min(h, minx);\n				a[1]++;\n				a[h+1]--;\n			}\n			for(int i=1;i<=200000;i++)\n			{\n				a[i]+=a[i-1];\n			}\n			int temp=0;\n			int ans=0;\n			for(int i=200000;i>=minx+1;i--)\n			{\n				temp+=a[i];\n				if(temp>m)\n				{\n					ans++;\n					temp=0;\n					i++;\n				}\n			}\n			if(temp>0)\n			{\n				ans++;\n			}\n			System.out.println(ans);\n	    }\n	}\n}\n\n    		 	 	 		    	 	 		  	 		",greedy
"import java.io.*;\nimport java.util.*;\n\npublic class Codeforces\n{\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb=new StringBuilder();\n        String s[]=bu.readLine().split("" "");\n        int n=Integer.parseInt(s[0]),k=Integer.parseInt(s[1]);\n        int i,N=200004,c[]=new int[N+1],a,max=0;\n\n        s=bu.readLine().split("" "");\n        for(i=0;i<n;i++)\n        {\n            a=Integer.parseInt(s[i]);\n            c[0]++;\n            c[a+1]--;\n            max=Math.max(max,a);\n        }\n        for(i=1;i<=N;i++) c[i]+=c[i-1];\n\n        int cur=0,ans=0;\n        for(i=max;i>0;i--)\n        {\n            if(c[i]==n)\n            {\n                if(cur>0) ans++;\n                break;\n            }\n            if(cur+c[i]<=k) cur+=c[i];\n            else\n            {\n                cur=c[i];\n                ans++;\n            }\n        }\n        System.out.println(ans);\n    }\n}\n",greedy
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Scanner scn=new Scanner(System.in);\n        int n=scn.nextInt();\n        long k=scn.nextInt();\n        ArrayList<Long> arr=new ArrayList<Long>();\n        int cost=0;\n        for(int i=0;i<n;i++){\n            arr.add(scn.nextInt()+0l);\n        }\n        Collections.sort(arr);\n        for(int i=arr.size()-1;i>=1;i--){\n            arr.set(i,arr.get(i)-arr.get(i-1));\n        }\n        arr.set(0,0l);\n        arr.add(Integer.MAX_VALUE+0l);\n        int i=0;\n        while(i<arr.size()){\n            long sum=0l;\n            while((i<n)&&k>=(sum+(n-i)*arr.get(i))){\n                sum=sum+(n-i)*(arr.get(i));\n                i++;\n            }\n            cost++;\n            if(i==n){\n                if(sum==0){\n                    cost--;\n                }\n                break;\n            }\n            long val=(k-sum)/(n-i);\n            arr.set(i,arr.get(i)-val);\n        }\n        System.out.println(cost);\n    }\n}\n",greedy
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Scanner scn=new Scanner(System.in);\n        int n=scn.nextInt();\n        long k=scn.nextInt();\n        ArrayList<Long> arr=new ArrayList<Long>();\n        int cost=0;\n        for(int i=0;i<n;i++){\n            arr.add(scn.nextInt()+0l);\n        }\n        Collections.sort(arr);\n        for(int i=arr.size()-1;i>=1;i--){\n            arr.set(i,arr.get(i)-arr.get(i-1));\n        }\n        arr.set(0,0l);\n        arr.add(Integer.MAX_VALUE+0l);\n        int i=0;\n        while(i<arr.size()){\n            long sum=0l;\n            while((i<n)&&k>=sum){\n                i++;\n                sum=sum+(n-i)*(arr.get(i));\n            }\n            cost++;\n            if(i==n){\n                if(sum-(n-i)*arr.get(i)==0){\n                    cost--;\n                }\n                break;\n            }\n            long val=(k-sum+(n-i)*(arr.get(i)))/(n-i);\n            arr.set(i,arr.get(i)-val);\n            i--;\n        }\n        System.out.println(cost);\n    }\n}\n",greedy
"//package round523;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class F2 {\n	Scanner in;\n	PrintWriter out;\n	String INPUT = """";\n	\n	boolean q(int a, int b, int c)\n	{\n		out.println(""? "" + (a+1) + "" "" + (b+1) + "" "" + (c+1));\n		out.flush();\n		return in.next().trim().equals(""Yes"");\n	}\n	\n	void solve()\n	{\n		int n = ni(), K = ni();\n		int D = 0;\n		for(int q = 1, s = 0;;D++){\n			s += q;\n			if(s == n)break;\n			q *= K;\n		}\n		\n//		Random gen = new SecureRandom();\n		Random gen = new Random(114514);\n		List<Integer> ride = null;\n		int x, y;\n		while(true){\n			x = gen.nextInt(n);\n			y = gen.nextInt(n);\n			if(x == y)continue;\n			ride = new ArrayList<>();\n			for(int i = 0;i < n;i++){\n				if(i == x || i == y)continue;\n				if(q(x, i, y))ride.add(i);\n			}\n			if(ride.size() == 2*D-1){\n				break;\n			}\n		}\n		\n		for(int r : ride){\n			int dep = 0;\n			for(int o : ride){\n				if(o == r)continue;\n				if(q(x, o, r)){\n					dep++;\n				}\n			}\n			if(dep == D-1){\n				out.println(""! "" + (r+1));\n				out.flush();\n				return;\n			}\n		}\n		throw new RuntimeException();\n	}\n	\n	void run() throws Exception\n	{\n		in = oj ? new Scanner(System.in) : new Scanner(INPUT);\n		out = new PrintWriter(System.out);\n\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception\n	{\n		new F2().run();\n	}\n	\n	int ni() { return Integer.parseInt(in.next()); }\n	long nl() { return Long.parseLong(in.next()); }\n	double nd() { return Double.parseDouble(in.next()); }\n	boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","interactive,probabilities"
"import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class Div2_523F {\n\n	static int N;\n	static int K;\n	static int H;\n\n	static BufferedReader reader;\n	static PrintWriter printer;\n\n	static Random rng = new Random();\n\n	public static void main(String[] args) throws IOException {\n		reader = new BufferedReader(new InputStreamReader(System.in));\n		printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		StringTokenizer inputData = new StringTokenizer(reader.readLine());\n		N = Integer.parseInt(inputData.nextToken());\n		K = Integer.parseInt(inputData.nextToken());\n\n		int val = 1 + N * (K - 1);\n\n		while (val > 1) {\n			val /= K;\n			H++;\n		}\n\n		int a;\n		int b;\n		lLoop:\n		while (true) {\n			a = 1 + rng.nextInt(N);\n			b = 1 + rng.nextInt(N);\n			cData(a, b);\n			if (between.size() == 2 * H - 1) {\n				break lLoop;\n			}\n		}\n\n		int want = H - 1;\n\n		while (a != b) {\n			ArrayList<Integer> pCopy = new ArrayList<>(between);\n			int pivot = between.get(rng.nextInt(between.size()));\n			cData(a, pivot);\n\n			if (between.size() - 1 == want) {\n				printer.println(""! "" + pivot);\n				printer.close();\n				return;\n			}\n\n			if (between.size() <= want) {\n				want -= (between.size() - 1);\n				a = pivot;\n				between = exclude(pCopy, between);\n			} else {\n				b = pivot;\n			}\n		}\n		printer.println(""! "" + a);\n		printer.close();\n	}\n\n	static ArrayList<Integer> exclude(ArrayList<Integer> set, ArrayList<Integer> rmv) {\n		Collections.sort(set);\n		Collections.sort(rmv);\n\n		ArrayList<Integer> ret = new ArrayList<>();\n\n		int j = 0;\n		for (int i = 0; i < set.size(); i++) {\n			while (j < rmv.size() && rmv.get(j) < set.get(i)) {\n				j++;\n			}\n\n			if (j >= rmv.size() || !rmv.get(j).equals(set.get(i))) {\n				ret.add(set.get(i));\n			}\n		}\n		return ret;\n	}\n\n	static ArrayList<Integer> between = new ArrayList<>();\n\n	static void cData(int a, int b) throws IOException {\n		between.clear();\n\n		for (int i = 1; i <= N; i++) {\n			printer.println(""? "" + a + "" "" + i + "" "" + b);\n		}\n		printer.flush();\n\n		for (int i = 1; i <= N; i++) {\n			if (reader.readLine().equals(""Yes"")) {\n				between.add(i);\n			}\n		}\n	}\n}\n","interactive,probabilities"
"import java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\npublic class E {\n    public static void main(String[] args) throws Exception {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        // Scanner scan = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        // int n = Integer.parseInt(bf.readLine());\n        StringTokenizer st = new StringTokenizer(bf.readLine());\n        // int[] a = new int[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        int depth = 0;\n        int cur = 1;\n        while(cur < n) {\n          cur = cur * k;\n          cur += 1;\n          depth ++;\n        }\n        int path_length = depth*2 + 1;\n        Random rand = new Random();\n        while(true) {\n          int v1 = ((rand.nextInt()%n+n) % n) + 1;\n          int v2 = ((rand.nextInt()%n+n) % n) + 1;\n          if(v1 == v2) continue;\n          int counter = 0;\n          Set<Integer> vals = new HashSet<Integer>();\n          for(int i=1; i<=n; i++) {\n            if((i == v1) || (i == v2)) {\n              counter++;\n              vals.add(i);\n              continue;\n            }\n            out.println(""? "" + v1 + "" "" + i + "" "" + v2);\n            out.flush();\n            String s = bf.readLine();\n            if(s.equals(""Yes"")) {\n              counter++;\n              vals.add(i);\n            }\n          }\n          if(counter == path_length) {\n            int[] a = new int[path_length];\n            int counter2 = 0;\n            for(int v : vals) {\n              a[counter2] = v;\n              counter2++;\n            }\n            for(int i=0; i<path_length; i++) {\n              counter = 0;\n              for(int j=0; j<path_length; j++) {\n                for(int kk=0; kk<j; kk++) {\n                  out.println(""? "" + a[j] + "" "" + a[i] + "" "" + a[kk]);\n                  out.flush();\n                  String s = bf.readLine();\n                  if(s.equals(""Yes""))\n                    counter++;\n                }\n              }\n              if(counter == (path_length*(path_length-1))/2 - 2*depth*(depth-1)/2) {\n                out.println(""! "" + a[i]);\n                break;\n              }\n            }\n            break;\n          }\n        }\n\n        // int n = scan.nextInt();\n\n        out.close(); System.exit(0);\n    }\n}\n","interactive,probabilities"
"import java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Random;\n\npublic class F {\n\n	public static void main(String[] args) {\n		JS in = new JS();\n		PrintWriter out = new PrintWriter(System.out);\n		\n		int N = in.nextInt();\n		int K = in.nextInt();\n		Random r = new Random();\n		int dep = 1;\n		int size = 1;\n		int lastLen = 1;\n		while(size < N) {\n			size += lastLen*K;\n			lastLen *= K;\n			dep++;\n		}\n		int leaf1 = -1;\n		int leaf2 = -1;\n		ArrayList<Integer> path = new ArrayList<Integer>();\n		while(true) {\n			int v1 = r.nextInt(N)+1;\n			int v2 = r.nextInt(N)+1;\n			if(v1 == v2) continue;\n			path = new ArrayList<Integer>();\n			for(int i = 1; i <= N; i++) {\n				if(i == v1 || i == v2) continue;\n				out.println(""? ""+v1+"" ""+i+"" ""+v2);\n				out.flush();\n				boolean isYes = in.next().charAt(0) == 'Y';\n				if(isYes) {\n					path.add(i);\n				}			\n			}\n			if(path.size() == (dep-1)*2 - 1) {\n				leaf1 = v1;\n				leaf2 = v2;\n				break;\n			}\n		}\n\n		for(Integer root : path) { //check if root\n			//check if path to leaf1 is equal to dep-2\n			int pathLen = 0;\n			for(int i = 1; i <= N; i++) {\n				if(i == root || i == leaf1)continue;\n				out.println(""? ""+root+"" ""+i+"" ""+leaf1);\n				out.flush();\n				boolean isYes = in.next().charAt(0) == 'Y';\n				if(isYes) pathLen++;\n			}\n			if(pathLen == dep-2) {\n				out.println(""! ""+root);\n				out.close();\n				return;\n			}\n			\n		}\n		out.close();\n		\n	}\n\n	\n	static class JS{\n		public int BS = 1<<16;\n		public char NC = (char)0;\n		byte[] buf = new byte[BS];\n		int bId = 0, size = 0;\n		char c = NC;\n		double num = 1;\n		BufferedInputStream in;\n		\n		public JS() {\n			in = new BufferedInputStream(System.in, BS);\n		}\n		\n		public JS(String s) throws FileNotFoundException {\n			in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n		}\n		\n		public char nextChar(){\n			while(bId==size) {\n				try {\n					size = in.read(buf);\n				}catch(Exception e) {\n					return NC;\n				}				\n				if(size==-1)return NC;\n				bId=0;\n			}\n			return (char)buf[bId++];\n		}\n		\n		public int nextInt() {\n			return (int)nextLong();\n		}\n		\n		public long nextLong() {\n			num=1;\n			boolean neg = false;\n			if(c==NC)c=nextChar();\n			for(;(c<'0' || c>'9'); c = nextChar()) {\n				if(c=='-')neg=true;\n			}\n			long res = 0;\n			for(; c>='0' && c <='9'; c=nextChar()) {\n				res = (res<<3)+(res<<1)+c-'0';\n				num*=10;\n			}\n			return neg?-res:res;\n		}\n		\n		public double nextDouble() {\n		    while(c!='.'&&c!='-'&&(c <'0' || c>'9')) c = nextChar();\n		    boolean neg = c=='-';\n		    if(neg)c=nextChar();\n		    boolean fl = c=='.';\n		    double cur = nextLong();\n		    if(fl) return neg ? -cur/num : cur/num;\n		    if(c == '.') {\n			double next = nextLong();\n			return neg ? -cur-next/num : cur+next/num;\n		    }\n		    else return neg ? -cur : cur;\n		}\n		\n		public String next() {\n			StringBuilder res = new StringBuilder();\n			while(c<=32)c=nextChar();\n			while(c>32) {\n				res.append(c);\n				c=nextChar();\n			}\n			return res.toString();\n		}\n		\n		public String nextLine() {\n			StringBuilder res = new StringBuilder();\n			while(c<=32)c=nextChar();\n			while(c!='\n') {\n				res.append(c);\n				c=nextChar();\n			}\n			return res.toString();\n		}\n\n		public boolean hasNext() {\n			if(c>32)return true;\n			while(true) {\n				c=nextChar();\n				if(c==NC)return false;\n				else if(c>32)return true;\n			}\n		}\n	}\n	\n}\n","interactive,probabilities"
"import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class M {\n\n	static void solve() throws Exception {\n		int n = scanInt();\n		boolean edge[][] = new boolean[n][n];\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < n; j++) {\n				edge[i][j] = scanInt() != 0;\n			}\n		}\n		out.println((6 * n - 1) + "" "" + (6 * n - 1) + "" 3"");\n		for (int y = 0; y < 6 * n - 1; y++) {\n			for (int x = 0; x < 6 * n - 1; x++) {\n				if (y / 6 == x / 6 && y % 6 < 5 && x % 6 < 5) {\n					out.print('.');\n				} else if (y % 6 == 2) {\n					out.print('.');\n				} else if ((y % 6 == 1 || y % 6 == 3) && x % 6 >= 1 && x % 6 <= 3) {\n					out.print('.');\n				} else {\n					out.print('#');\n				}\n			}\n			out.println();\n		}\n		out.println();\n		for (int y = 0; y < 6 * n - 1; y++) {\n			for (int x = 0; x < 6 * n - 1; x++) {\n				if (y / 6 == x / 6 && y % 6 < 5 && x % 6 < 5) {\n					if (y % 6 == 2 && (x % 6 == 0 || x % 6 == 4)) {\n						out.print('#');\n					} else {\n						out.print('.');\n					}\n				} else if (x % 6 == 2 && y % 6 == 2 && edge[y / 6][x / 6]) {\n					out.print('.');\n				} else {\n					out.print('#');\n				}\n			}\n			out.println();\n		}\n		out.println();\n		for (int y = 0; y < 6 * n - 1; y++) {\n			for (int x = 0; x < 6 * n - 1; x++) {\n				if (y / 6 == x / 6 && y % 6 < 5 && x % 6 < 5) {\n					if (y % 6 == 2 && x % 6 == 2) {\n						out.print((char) ('1' + y / 6));\n					} else if (y % 6 == 2) {\n						out.print('#');\n					} else {\n						out.print('.');\n					}\n				} else if (x % 6 == 2) {\n					out.print('.');\n				} else {\n					out.print('#');\n				}\n			}\n			out.println();\n		}\n	}\n\n	static int scanInt() throws IOException {\n		return parseInt(scanString());\n	}\n\n	static long scanLong() throws IOException {\n		return parseLong(scanString());\n	}\n\n	static String scanString() throws IOException {\n		while (tok == null || !tok.hasMoreTokens()) {\n			tok = new StringTokenizer(in.readLine());\n		}\n		return tok.nextToken();\n	}\n\n	static BufferedReader in;\n	static PrintWriter out;\n	static StringTokenizer tok;\n\n	public static void main(String[] args) {\n		try {\n			in = new BufferedReader(new InputStreamReader(System.in));\n			out = new PrintWriter(System.out);\n			solve();\n			in.close();\n			out.close();\n		} catch (Throwable e) {\n			e.printStackTrace();\n			exit(1);\n		}\n	}\n}","constructive algorithms,graphs"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/**\n * Created by vaksenov on 20.11.2018.\n */\npublic class Main {\n    BufferedReader br;\n    StringTokenizer st;\n    PrintWriter out;\n\n    public String nextToken() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public void solve() throws IOException {\n        int n = nextInt();\n        boolean[][] a = new boolean[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                a[i][j] = nextInt() == 1;\n            }\n        }\n\n        char[][][] ans = new char[3][3 * n][3 * n * n];\n        for (int i = 0; i < ans.length; i++) {\n            for (int j = 0; j < ans[i].length; j++) {\n                Arrays.fill(ans[i][j], '#');\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 3 * n * n; j++) {\n                ans[0][3 * i][j] = '.';\n            }\n            ans[0][3 * i][0] = (char) ('1' + i);\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!a[i][j]) {\n                    continue;\n                }\n                int y = 3 * (i * n + j);\n                int dx = i < j ? 1 : -1;\n                ans[1][3 * i][y] = '.';\n                ans[1][3 * i + dx][y] = '.';\n                ans[2][3 * i + dx][y] = '.';\n                for (int k = 3 * i + 2 * dx; k != 3 * j; k += dx) {\n                    ans[2][k][y] = '.';\n                }\n                ans[2][3 * j][y] = '.';\n                ans[1][3 * j][y] = '.';\n            }\n        }\n\n        out.println(ans[0][0].length + "" "" + ans[0].length + "" "" + ans.length);\n\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < ans[i].length; j++) {\n                for (int k = 0; k < ans[i][j].length; k++) {\n                    out.print(ans[2 - i][j][k]);\n                }\n                out.println();\n            }\n            out.println();\n            out.println();\n        }\n    }\n\n    public void run() {\n        try {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n\n            solve();\n\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n","constructive algorithms,graphs"
"import java.util.*;\nimport java.io.*;\n\npublic class SolA {\n	\n	public static void main(String[] args) throws Exception {\n		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n		BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n		StringTokenizer tok = new StringTokenizer(in.readLine());\n		int n = Integer.parseInt(tok.nextToken());\n		\n		int x = 5 * n;\n		int y = 5 * n;\n		int h = 4 * n;\n		\n		out.write(x + "" "" + y + "" "" + h + ""\n"");\n		char[][][] ans = new char[x][y][h];\n		for(int xx = 0; xx < x; xx += 5) {\n			for(int yy = 0 ; yy < y; yy += 5) {\n				Arrays.fill(ans[xx][yy], '#');\n				Arrays.fill(ans[xx+1][yy], '#');\n				Arrays.fill(ans[xx+2][yy], '#');\n				Arrays.fill(ans[xx+3][yy], '#');\n				Arrays.fill(ans[xx+4][yy], '.');\n				Arrays.fill(ans[xx][yy+1], '#');\n				Arrays.fill(ans[xx+1][yy+1], '.');\n				Arrays.fill(ans[xx+2][yy+1], '.');\n				Arrays.fill(ans[xx+3][yy+1], '#');\n				Arrays.fill(ans[xx+4][yy+1], '.');\n				Arrays.fill(ans[xx][yy+2], '#');\n				Arrays.fill(ans[xx+1][yy+2], '.');\n				Arrays.fill(ans[xx+2][yy+2], '.');\n				Arrays.fill(ans[xx+3][yy+2], '#');\n				Arrays.fill(ans[xx+4][yy+2], '.');\n				Arrays.fill(ans[xx][yy+3], '#');\n				Arrays.fill(ans[xx+1][yy+3], '#');\n				Arrays.fill(ans[xx+2][yy+3], '#');\n				Arrays.fill(ans[xx+3][yy+3], '#');\n				Arrays.fill(ans[xx+4][yy+3], '.');\n				Arrays.fill(ans[xx][yy+4], '.');\n				Arrays.fill(ans[xx+1][yy+4], '.');\n				Arrays.fill(ans[xx+2][yy+4], '.');\n				Arrays.fill(ans[xx+3][yy+4], '.');\n				Arrays.fill(ans[xx+4][yy+4], '.');\n				for(int hh = 0; hh < h; hh++) {\n					if(hh % 4 == 0) {\n						ans[xx+1][yy+2][hh] = '#';\n					} else if (hh % 4 == 1) {\n						ans[xx+1][yy+1][hh] = '#';\n					} else if(hh % 4 == 2) {\n						ans[xx+2][yy+1][hh] = '#';\n					} else {\n						ans[xx+2][yy+2][hh] = '#';\n						ans[xx][yy+4][hh] = '#';\n						ans[xx+1][yy+4][hh] = '#';\n						ans[xx+2][yy+4][hh] = '#';\n						ans[xx+3][yy+4][hh] = '#';\n						ans[xx+4][yy+4][hh] = '#';\n						ans[xx+4][yy+3][hh] = '#';\n						ans[xx+4][yy+2][hh] = '#';\n						ans[xx+4][yy+1][hh] = '#';\n						ans[xx+4][yy][hh] = '#';\n					}\n				}\n			}\n		}\n		for(int i = 1; i <= n; i++) {\n			ans[5*i - 1][5*i - 1][4*(i - 1)] = (char) ('0' + (char) i);\n		}\n		//enter from\n		for(int i = 0; i < n; i++) {\n			tok = new StringTokenizer(in.readLine());\n			//leave at\n			for(int j = 0; j < n; j++) {\n				if(1 == Integer.parseInt(tok.nextToken())) {\n					//enter\n					ans[j*5 + 1][i*5 + 3][4*i] = '.';\n					ans[j*5 + 2][i*5 + 3][4*i] = '.';\n					\n					//leave\n					ans[j*5 + 3][i*5 + 1][4*j + 2] = '.';\n					ans[j*5 + 3][i*5 + 1][4*j + 3] = '.';\n				}\n			}\n		}\n		for(int hh = h-1; hh >= 0; hh--) {\n			for(int yy = 0; yy < y; yy++) {\n				for(int xx = 0; xx < x; xx++) {\n					out.write(ans[xx][yy][hh]);\n				}\n				out.write(""\n"");\n			}\n			if(hh != 0) out.write(""\n"");\n		}\n		out.flush();\n	}\n}","constructive algorithms,graphs"
"import java.util.Scanner;\n\npublic class Minegraphed {\n	\n	private static final int N = 32;\n	\n	private int n;\n	private int[][] a = new int[N][N];\n	private int[] f = new int[N];\n	private int[] list = new int[N];\n	private int listSize;\n	\n	private int[][] component = new int[N][N];\n	private int[] componentSize = new int[N];\n	int componentsCount;\n	\n	private int[][][] lo = new int[N][N][N];\n	\n	private void DFS(int x) {\n		f[x] = 1;\n		for(int i = 1; i <= n; i++) {\n			if(f[i] == 0 && a[x][i] == 1) {\n				DFS(i);\n			}\n		}\n		list[++listSize] = x;\n	}\n	\n	private void BackwardDFS(int x, int v) {\n		f[x] = v;\n		for(int i = 1; i <= n; i++) {\n			if(f[list[i]] == 0 && a[list[i]][x] == 1) {\n				BackwardDFS(list[i], v);\n			}\n		}\n	}\n	\n	public int processTestCase() {\n		Scanner s = new Scanner(System.in);\n		n = s.nextInt();\n		for(int i = 1; i <= n; i++) {\n			for(int j = 1; j <= n; j++) {\n				a[i][j] = s.nextInt();\n			}\n		}\n		for(int i = 1; i <= n; i++) {\n			if(f[i] == 0) {\n				DFS(i);\n			}\n		}\n		for(int i = 1; i <= n / 2; i++) {\n			int h = list[i];\n			list[i] = list[n - i + 1];\n			list[n - i + 1] = h;\n		}\n		for(int i = 1; i <= n; i++) {\n			//System.out.print(list[i] + "" "");\n		}\n		//System.out.println();\n		\n		java.util.Arrays.fill(f, 0);\n		\n		for(int i = 1; i <= n; i++) {\n			if(f[list[i]] == 0) {\n				BackwardDFS(list[i], i);\n				componentsCount++;\n				for(int j = 1; j <= n; j++) {\n					if(f[j] == i) {\n						component[componentsCount][componentSize[componentsCount]++] = j;\n					}\n				}\n			}\n		}\n		\n		for(int k = 1; k <= n; k++) {\n			for(int i = 1; i <= n; i++) {\n				for(int j = 1; j <= n; j++) {\n					if( a[i][j] == 0 && a[i][k] == 1 && a[k][j] == 1) {\n						a[i][j] = 1;\n					}\n				}\n			}\n		}\n		\n		int l = 0;\n		for(int i = 1; i <= componentsCount; i++) {\n			for(int j = 0; j < componentSize[componentsCount]; j++) {\n				lo[l][9][j + 1] = component[i][j];\n			}\n			for(int j = 1; j <= 18; j++) {\n				lo[l][2][j] = -1;\n				if(j % 2 == 0) lo[l][1][j] = -1;\n			}\n			lo[l][2][(componentsCount - i + 1) * 2 - 1] = 0;\n			for(int j = 1; j <= 9; j++) {\n				for(int k = 1; k <= 18; k++) {\n					lo[l + 1][j][k] = -1;\n				}\n			}\n			for(int j = 1; j < componentsCount - i + 1; j++) {\n				lo[l + 1][1][2 * j - 1] = 0;\n			}\n\n			for(int k = 1; k <= i; k++) {\n				if(a[component[k][0]][component[i][0]] == 1) {\n					lo[(k - 1) * 2][2][2 * (componentsCount - i) + 1] = 0;\n				}\n			}			\n			\n			l += 2;\n		}\n		\n		System.out.println(""18 9 "" + l);\n		for(int i = 0; i < l; i++) {\n			for(int j = 1; j <= 9; j++) {\n				for(int k = 1; k <= 18; k++) {\n					if(lo[i][j][k] == -1) System.out.print(""#""); else\n					if(lo[i][j][k] ==  0) System.out.print("".""); else \n						System.out.print(lo[i][j][k]); \n						\n				}\n				System.out.println();\n			}\n			System.out.println();\n		}\n		\n		s.close();\n		return 0;\n	}\n	\n	/*\n6\n0 1 1 0 0 0\n0 0 0 1 1 0\n0 0 0 1 0 1\n0 0 0 0 0 1\n0 0 0 0 0 0\n0 0 0 0 0 0	\n	 */\n	\n	public static void main(String[] args) {\n		Minegraphed np = new Minegraphed();\n		np.processTestCase();\n	}\n	\n}","constructive algorithms,graphs"
import java.util.*;\n\npublic class Solution {\n\n  private static Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    System.out.println(sc.nextInt() == 2 ? 2 : 1);\n  }\n\n},"constructive algorithms,math"
import java.util.*;\n\npublic class A {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        System.out.println(n == 2 ? 2 : 1);\n    }\n},"constructive algorithms,math"
import java.util.*;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		if(n==2)\n			System.out.print(2);\n		else\n			System.out.print(1);\n	}\n} ,"constructive algorithms,math"
"import java.util.Scanner;\npublic class main\n{\npublic static void main(String[]args)\n\n{\nScanner sc=new Scanner(System.in);\nlong n=sc.nextLong();\nif(n==2)\nSystem.out.println(""2"");\nelse\nSystem.out.println(""1"");\n}\n}","constructive algorithms,math"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author lewin\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        FChoosingTwoPaths solver = new FChoosingTwoPaths();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FChoosingTwoPaths {\n        int n;\n        List<Integer>[] graph;\n        boolean[] safe;\n        boolean[] removed;\n        int[][] bts;\n        int[] down;\n        int[] up;\n        int[] fup;\n        int[] fdown;\n        int[] fupid;\n        int[] fdownid;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            n = in.nextInt();\n            graph = LUtils.genArrayList(n);\n            for (int i = 0; i < n - 1; i++) {\n                int a = in.nextInt() - 1, b = in.nextInt() - 1;\n                graph[a].add(b);\n                graph[b].add(a);\n            }\n            safe = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                safe[i] = graph[i].size() >= 3;\n            }\n\n            Debug.print(safe);\n            removed = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                if (graph[i].size() == 1) {\n                    int prev = -1;\n                    int cur = i;\n                    while (true) {\n                        removed[cur] = true;\n                        int x = -1;\n                        for (int nxt : graph[cur]) {\n                            if (nxt != prev) {\n                                x = nxt;\n                                break;\n                            }\n                        }\n                        if (x == -1 || safe[x]) break;\n                        prev = cur;\n                        cur = x;\n                    }\n                }\n            }\n\n            bts = new int[n][];\n            for (int i = 0; i < n; i++) {\n                if (!removed[i]) {\n                    bts[i] = dfs3(i, -1);\n                }\n            }\n            down = new int[n];\n            up = new int[n];\n            fup = new int[n];\n            fdown = new int[n];\n            fupid = new int[n];\n            fdown = new int[n];\n            fdownid = new int[n];\n            for (int i = 0; i < n; i++) {\n                if (!removed[i]) {\n                    dfs(i, -1);\n                    dfs2(i, -1, 0, -1, -1);\n                    break;\n                }\n            }\n            int[] ret = new int[n];\n            int[] f = new int[n];\n            int[] fid = new int[n];\n            for (int i = 0; i < n; i++) {\n                if (up[i] > down[i] || (up[i] == down[i] && fup[i] > fdown[i])) {\n                    ret[i] = up[i];\n                    f[i] = fup[i];\n                    fid[i] = fupid[i];\n                } else {\n                    ret[i] = down[i];\n                    f[i] = fdown[i];\n                    fid[i] = fdownid[i];\n                }\n                Debug.print(i, bts[i], ret[i], f[i], fid[i]);\n            }\n            int mx = AUtils.max(ret);\n            int bestsum = 1, id1 = -1, id2 = -1;\n            for (int i = 0; i < n; i++) {\n                if (ret[i] == mx) {\n                    if (f[i] + bts[i][1] + bts[i][3] > bestsum) {\n                        bestsum = f[i] + bts[i][1] + bts[i][3];\n                        id1 = i;\n                        id2 = fid[i];\n                    }\n                }\n            }\n\n            Debug.print(mx, bestsum, id1, id2);\n            out.println((bts[id1][0] + 1) + "" "" + (bts[id2][0] + 1));\n            out.println((bts[id1][2] + 1) + "" "" + (bts[id2][2] + 1));\n        }\n\n        int[] dfs3(int node, int par) {\n            int x1 = node, x2 = -1, d1 = 0, d2 = 0;\n            if (graph[node].size() > 1) x1 = -1;\n            for (int next : graph[node]) {\n                if (next == par || !removed[next]) continue;\n                int[] q = dfs3(next, node);\n                for (int i = 0; i < 2; i++) {\n                    int cx = q[0 + 2 * i], cd = q[1 + 2 * i];\n                    if (cx == -1) continue;\n                    if (cd + 1 > d1) {\n                        x2 = x1;\n                        d2 = d1;\n                        x1 = cx;\n                        d1 = cd + 1;\n                    } else if (cd + 1 > d2) {\n                        x2 = cx;\n                        d2 = cd + 1;\n                    }\n                }\n            }\n            return new int[]{x1, d1, x2, d2};\n        }\n\n        public void dfs(int node, int par) {\n            fdown[node] = bts[node][1] + bts[node][3];\n            fdownid[node] = node;\n            for (int next : graph[node]) {\n                if (next == par || removed[next]) continue;\n                dfs(next, node);\n                if (down[next] + 1 > down[node]) {\n                    fdown[node] = fdown[next];\n                    fdownid[node] = fdownid[next];\n                    down[node] = down[next] + 1;\n                } else if (down[next] + 1 == down[node] && fdown[node] < fdown[next]) {\n                    fdown[node] = fdown[next];\n                    fdownid[node] = fdownid[next];\n                    down[node] = down[next] + 1;\n                }\n            }\n        }\n\n        public void dfs2(int node, int par, int frompar, int fromparf, int fromparid) {\n            up[node] = frompar;\n            fup[node] = fromparf;\n            fupid[node] = fromparid;\n\n            int mx1 = 0, id1 = -1, mx2 = 0;\n            int fmx1 = 0, fmx1id = -1, fmx2 = 0, fmx2id = -1;\n            for (int next : graph[node]) {\n                if (next == par || removed[next]) continue;\n                if (down[next] + 1 > mx1) {\n                    mx2 = mx1;\n                    fmx2id = fmx1id;\n                    fmx2 = fmx1;\n                    mx1 = down[next] + 1;\n                    id1 = next;\n                    fmx1 = fdown[next];\n                    fmx1id = fdownid[next];\n                } else if (down[next] + 1 == mx1 && fdown[next] > fmx1) {\n                    mx2 = mx1;\n                    fmx2id = fmx1id;\n                    fmx2 = fmx1;\n                    mx1 = down[next] + 1;\n                    id1 = next;\n                    fmx1 = fdown[next];\n                    fmx1id = fdownid[next];\n                } else if (down[next] + 1 > mx2) {\n                    mx2 = down[next] + 1;\n                    fmx2 = fdown[next];\n                    fmx2id = fdownid[next];\n                } else if (down[next] + 1 == mx2 && fdown[next] > fmx2) {\n                    fmx2 = fdown[next];\n                    fmx2id = fdownid[next];\n                }\n            }\n\n            for (int next : graph[node]) {\n                if (next == par || removed[next]) continue;\n                int dmx, fmx, fmxid;\n                if (next != id1) {\n                    dmx = mx1;\n                    fmx = fmx1;\n                    fmxid = fmx1id;\n                } else {\n                    dmx = mx2;\n                    fmx = fmx2;\n                    fmxid = fmx2id;\n                }\n                if (up[node] > dmx) {\n                    dmx = up[node];\n                    fmx = fromparf;\n                    fmxid = fromparid;\n                } else if (dmx == up[node] && fromparf > fmx) {\n                    dmx = up[node];\n                    fmx = fromparf;\n                    fmxid = fromparid;\n                }\n                dfs2(next, node, dmx + 1, fmx, fmxid);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1 << 20];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (this.numChars == -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar >= this.numChars) {\n                    this.curChar = 0;\n\n                    try {\n                        this.numChars = this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars <= 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c = this.read(); isSpaceChar(c); c = this.read()) {\n                ;\n            }\n\n            byte sgn = 1;\n            if (c == 45) {\n                sgn = -1;\n                c = this.read();\n            }\n\n            int res = 0;\n\n            while (c >= 48 && c <= 57) {\n                res *= 10;\n                res += c - 48;\n                c = this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c == 32 || c == 10 || c == 13 || c == 9 || c == -1;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void println(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class LUtils {\n        public static <E> List<E>[] genArrayList(int size) {\n            return Stream.generate(ArrayList::new).limit(size).toArray(List[]::new);\n        }\n\n    }\n\n    static class Debug {\n        public static boolean DEBUG;\n\n        static {\n            try {\n                DEBUG = System.getProperty(""user.dir"").contains(""Dropbox"");\n            } catch (Exception e) {\n                DEBUG = false;\n            }\n        }\n\n        private static ArrayList<String> getParams() {\n            StackTraceElement[] t = Thread.currentThread().getStackTrace();\n            StackTraceElement up = t[3];\n\n            ArrayList<String> ret = new ArrayList<>();\n            String qqq = up.toString();\n            ret.add(""."" + up.getMethodName() + qqq.substring(qqq.indexOf(""(""), qqq.length()));\n            try {\n                BufferedReader br = new BufferedReader(new FileReader(\n                        new File(""src/"" + up.getClassName().replaceAll(""\\."", ""/"") + "".java"")));\n                int g = up.getLineNumber();\n                while (--g > 0) br.readLine();\n                String q = br.readLine();\n                String[] ss = q.split(""Debug\\.print\\("");\n                String[] qq = ss[1].substring(0, ss[1].lastIndexOf("")"")).split("","");\n                for (int i = 0; i < qq.length; i++) {\n                    ret.add(qq[i].trim());\n                }\n            } catch (Exception e) {\n            }\n            for (int i = 0; i < 100; i++) ret.add(""???"");\n            return ret;\n        }\n\n        private static String toString(Object o) {\n            if (o == null) {\n                return ""null"";\n            } else if (o instanceof Object[]) {\n                return Arrays.toString((Object[]) o);\n            } else if (o instanceof char[]) {\n                return new String((char[]) o);\n            } else if (o instanceof int[]) {\n                return Arrays.toString((int[]) o);\n            } else if (o instanceof long[]) {\n                return Arrays.toString((long[]) o);\n            } else if (o instanceof double[]) {\n                return Arrays.toString((double[]) o);\n            } else if (o instanceof boolean[]) {\n                return Arrays.toString((boolean[]) o);\n            } else {\n                return o.toString();\n            }\n        }\n\n        public static void print(Object x) {\n            if (!DEBUG) return;\n            ArrayList<String> s = getParams();\n            System.out.println(s.get(0) + "": "" + s.get(1) + "" = "" + toString(x));\n        }\n\n        public static void print(Object... x) {\n            if (!DEBUG) return;\n            ArrayList<String> s = getParams();\n            System.out.print(s.get(0) + "": "");\n            for (int i = 0; i < x.length; i++) {\n                System.out.print(s.get(i + 1) + "" = "" + toString(x[i]));\n                if (i != x.length - 1) System.out.print("", "");\n            }\n            System.out.println();\n        }\n\n    }\n\n    static class AUtils {\n        public static int max(int[] arr) {\n            int res = arr[0];\n            for (int x : arr) if (x > res) res = x;\n            return res;\n        }\n\n    }\n}\n\n","dfs and similar,dp,greedy,trees"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FChoosingTwoPaths solver = new FChoosingTwoPaths();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FChoosingTwoPaths {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            Node[] nodes = new Node[n];\n            for (int i = 0; i < n; i++) {\n                nodes[i] = new Node();\n                nodes[i].id = i;\n            }\n\n            int[][] edges = new int[n - 1][2];\n            for (int i = 0; i < n - 1; i++) {\n                edges[i][0] = in.readInt() - 1;\n                edges[i][1] = in.readInt() - 1;\n                Node a = nodes[edges[i][0]];\n                Node b = nodes[edges[i][1]];\n                a.next.add(b);\n                b.next.add(a);\n            }\n\n            Node root = null;\n            for (Node node : nodes) {\n                if (node.next.size() >= 3) {\n                    root = node;\n                    break;\n                }\n            }\n            dfsForDepth(root, null, 0);\n\n            for (Node node : nodes) {\n                if (node.next.size() == 1) {\n                    upward(node);\n                }\n            }\n\n            MultiWayIntegerStack edgeStack = new MultiWayIntegerStack(n, n * 2);\n            for (int[] e : edges) {\n                if (nodes[e[0]].removed || nodes[e[1]].removed) {\n                    continue;\n                }\n                edgeStack.addLast(e[0], e[1]);\n                edgeStack.addLast(e[1], e[0]);\n            }\n            ForestDiameter td = new ForestDiameter(edgeStack, n);\n            if (td.getCenters(root.id).size() == 1) {\n                Node center = nodes[td.getCenters(root.id).get(0)];\n                int sd = td.getDiameter(root.id) / 2;\n                List<NodePair> pairs = new ArrayList<>(center.next.size());\n                for (Node node : center.next) {\n                    pairs.add(findLargestSum(node, center, 1, sd));\n                }\n                pairs.sort(this::compare);\n                NodePair a = pairs.get(pairs.size() - 1);\n                NodePair b = pairs.get(pairs.size() - 2);\n                answer(out, a, b);\n                return;\n            }\n\n            Node c1 = nodes[td.getCenters(root.id).get(0)];\n            Node c2 = nodes[td.getCenters(root.id).get(1)];\n            int sd = (td.getDiameter(root.id) - 1) / 2;\n            NodePair a = findLargestSum(c1, c2, 0, sd);\n            NodePair b = findLargestSum(c2, c1, 0, sd);\n            answer(out, a, b);\n        }\n\n        public void answer(FastOutput out, NodePair a, NodePair b) {\n            out.append(a.a.id + 1).append(' ').append(b.a.id + 1).println();\n            out.append(a.b.id + 1).append(' ').append(b.b.id + 1).println();\n        }\n\n        public NodePair max(NodePair a, NodePair b) {\n            return compare(a, b) >= 0 ? a : b;\n        }\n\n        public int compare(NodePair a, NodePair b) {\n            if (a == null) {\n                return -1;\n            }\n            if (b == null) {\n                return 1;\n            }\n            return a.len - b.len;\n        }\n\n        public NodePair findLargestSum(Node root, Node p, int depth, int searchDepth) {\n            if (root.removed) {\n                return null;\n            }\n\n            NodePair ans = null;\n            root.depth = depth;\n\n            if (depth == searchDepth) {\n                List<Node> nodes = new ArrayList<>(root.next.size());\n                for (Node node : root.next) {\n                    if (node == p) {\n                        continue;\n                    }\n                    nodes.add(findDepthest(node, root, depth + 1));\n                }\n                nodes.sort((a, b) -> -(a.depth - b.depth));\n                NodePair pair = new NodePair();\n                pair.a = nodes.get(0);\n                pair.b = nodes.get(1);\n                pair.len = pair.a.depth + pair.b.depth - 2 * depth;\n                return pair;\n            }\n\n            for (Node node : root.next) {\n                if (node == p) {\n                    continue;\n                }\n                ans = max(ans, findLargestSum(node, root, depth + 1, searchDepth));\n            }\n            return ans;\n        }\n\n        public Node findDepthest(Node root, Node p, int depth) {\n            root.depth = depth;\n            for (Node node : root.next) {\n                if (node == p) {\n                    continue;\n                }\n                return findDepthest(node, root, depth + 1);\n            }\n            return root;\n        }\n\n        public void upward(Node root) {\n            if (root == null || root.removed || root.next.size() >= 3) {\n                return;\n            }\n            root.removed = true;\n            upward(root.p);\n        }\n\n        public void dfsForDepth(Node root, Node p, int depth) {\n            root.depth = depth;\n            root.p = p;\n            for (Node node : root.next) {\n                if (node == p) {\n                    continue;\n                }\n                dfsForDepth(node, root, depth + 1);\n            }\n        }\n\n    }\n\n    static class ForestDiameter {\n        private MultiWayIntegerStack edges;\n        private int[] depth;\n        private int[] parents;\n        private int[] diameters;\n        private IntegerList[] centers;\n        private IntegerList[] ends;\n        private int[] treeIds;\n        private IntegerList collector;\n\n        public IntegerList getCenters(int i) {\n            return centers[i];\n        }\n\n        public int getDiameter(int i) {\n            return diameters[i];\n        }\n\n        public ForestDiameter(MultiWayIntegerStack edges, int n) {\n            this.edges = edges;\n            depth = new int[n];\n            parents = new int[n];\n            centers = new IntegerList[n];\n            ends = new IntegerList[n];\n            treeIds = new int[n];\n            diameters = new int[n];\n            collector = new IntegerList(n);\n            int idAllocator = 0;\n            Arrays.fill(treeIds, -1);\n\n            for (int j = 0; j < n; j++) {\n                if (treeIds[j] != -1) {\n                    continue;\n                }\n                IntegerList endList = new IntegerList(2);\n                IntegerList centerList = new IntegerList(2);\n                collector.clear();\n                dfsForCollect(j, -1);\n                dfsForDepth(j, -1);\n                int end = collector.get(0);\n                for (IntegerIterator iterator = collector.iterator(); iterator.hasNext(); ) {\n                    int node = iterator.next();\n                    if (depth[node] > depth[end]) {\n                        end = node;\n                    }\n                }\n                dfsForDepth(end, -1);\n                int another = collector.get(0);\n                for (IntegerIterator iterator = collector.iterator(); iterator.hasNext(); ) {\n                    int node = iterator.next();\n                    if (depth[node] > depth[another]) {\n                        another = node;\n                    }\n                }\n\n                endList.add(end);\n                endList.add(another);\n\n                int diameter = depth[another];\n                for (int i = another; i != -1; i = parents[i]) {\n                    if (depth[i] == DigitUtils.ceilDiv(diameter, 2) ||\n                            depth[i] == DigitUtils.floorDiv(diameter, 2)) {\n                        centerList.add(i);\n                    }\n                }\n\n                endList.unique();\n                centerList.unique();\n\n                for (IntegerIterator iterator = collector.iterator(); iterator.hasNext(); ) {\n                    int node = iterator.next();\n                    treeIds[node] = idAllocator;\n                    diameters[node] = diameter;\n                    ends[node] = endList;\n                    centers[node] = centerList;\n                }\n                idAllocator++;\n            }\n        }\n\n        private void dfsForCollect(int root, int p) {\n            collector.add(root);\n            for (IntegerIterator iterator = edges.iterator(root); iterator.hasNext(); ) {\n                int node = iterator.next();\n                if (node == p) {\n                    continue;\n                }\n                dfsForCollect(node, root);\n            }\n        }\n\n        private void dfsForDepth(int root, int p) {\n            parents[root] = p;\n            depth[root] = p != -1 ? depth[p] + 1 : 0;\n            for (IntegerIterator iterator = edges.iterator(root); iterator.hasNext(); ) {\n                int node = iterator.next();\n                if (node == p) {\n                    continue;\n                }\n                dfsForDepth(node, root);\n            }\n        }\n\n    }\n\n    static interface IntegerIterator {\n        boolean hasNext();\n\n        int next();\n\n    }\n\n    static class MultiWayIntegerStack {\n        private int[] values;\n        private int[] next;\n        private int[] heads;\n        private int alloc;\n        private int stackNum;\n\n        public IntegerIterator iterator(final int queue) {\n            return new IntegerIterator() {\n                int ele = heads[queue];\n\n\n                public boolean hasNext() {\n                    return ele != 0;\n                }\n\n\n                public int next() {\n                    int ans = values[ele];\n                    ele = next[ele];\n                    return ans;\n                }\n            };\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            values = Arrays.copyOf(values, newSize);\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n        }\n\n        public MultiWayIntegerStack(int qNum, int totalCapacity) {\n            values = new int[totalCapacity + 1];\n            next = new int[totalCapacity + 1];\n            heads = new int[qNum];\n            stackNum = qNum;\n        }\n\n        public void addLast(int qId, int x) {\n            alloc();\n            values[alloc] = x;\n            next[alloc] = heads[qId];\n            heads[qId] = alloc;\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < stackNum; i++) {\n                builder.append(i).append("": "");\n                for (IntegerIterator iterator = iterator(i); iterator.hasNext(); ) {\n                    builder.append(iterator.next()).append("","");\n                }\n                if (builder.charAt(builder.length() - 1) == ',') {\n                    builder.setLength(builder.length() - 1);\n                }\n                builder.append('\n');\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static class Node {\n        List<Node> next = new ArrayList<>();\n        boolean removed;\n        int id;\n        int depth;\n        Node p;\n\n        public String toString() {\n            return """" + (id + 1);\n        }\n\n    }\n\n    static class IntegerList implements Cloneable {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public IntegerList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntegerList(IntegerList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntegerList() {\n            this(0);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        private void checkRange(int i) {\n            if (i < 0 || i >= size) {\n                throw new ArrayIndexOutOfBoundsException();\n            }\n        }\n\n        public int get(int i) {\n            checkRange(i);\n            return data[i];\n        }\n\n        public void add(int x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public void addAll(int[] x, int offset, int len) {\n            ensureSpace(size + len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(IntegerList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public void sort() {\n            if (size <= 1) {\n                return;\n            }\n            Randomized.randomizedArray(data, 0, size);\n            Arrays.sort(data, 0, size);\n        }\n\n        public void unique() {\n            if (size <= 1) {\n                return;\n            }\n\n            sort();\n            int wpos = 1;\n            for (int i = 1; i < size; i++) {\n                if (data[i] != data[wpos - 1]) {\n                    data[wpos++] = data[i];\n                }\n            }\n            size = wpos;\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public void clear() {\n            size = 0;\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public IntegerIterator iterator() {\n            return new IntegerIterator() {\n                int i = 0;\n\n\n                public boolean hasNext() {\n                    return i < size;\n                }\n\n\n                public int next() {\n                    return data[i++];\n                }\n            };\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof IntegerList)) {\n                return false;\n            }\n            IntegerList other = (IntegerList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n        public int hashCode() {\n            int h = 1;\n            for (int i = 0; i < size; i++) {\n                h = h * 31 + Integer.hashCode(data[i]);\n            }\n            return h;\n        }\n\n        public IntegerList clone() {\n            IntegerList ans = new IntegerList();\n            ans.addAll(this);\n            return ans;\n        }\n\n    }\n\n    static class Randomized {\n        static Random random = new Random();\n\n        public static void randomizedArray(int[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                int tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static int floorDiv(int a, int b) {\n            return a < 0 ? -ceilDiv(-a, b) : a / b;\n        }\n\n        public static int ceilDiv(int a, int b) {\n            if (a < 0) {\n                return -floorDiv(-a, b);\n            }\n            int c = a / b;\n            if (c * b < a) {\n                return c + 1;\n            }\n            return c;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println() {\n            cache.append('\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class NodePair {\n        Node a;\n        Node b;\n        int len;\n\n    }\n\n    static class SequenceUtils {\n        public static boolean equal(int[] a, int al, int ar, int[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n}\n\n","dfs and similar,dp,greedy,trees"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        ESegmentSum solver = new ESegmentSum();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ESegmentSum {\n        char[] l;\n        char[] r;\n        int k;\n        char[] arr;\n        long[] pow;\n        int mod = 998244353;\n        long[][][][] memo;\n        long[][][][] memo2;\n\n        public void readInput(Scanner sc) {\n            l = ((sc.nextLong() - 1) + """").toCharArray();\n            r = (sc.nextLong() + """").toCharArray();\n            k = sc.nextInt();\n        }\n\n        public void solve(int testNumber, Scanner sc, PrintWriter pw) {\n            int q = 1;\n            while (q-- > 0) {\n                readInput(sc);\n                pow = new long[20];\n                pow[0] = 1;\n                for (int i = 1; i < pow.length; i++) {\n                    pow[i] = (10 * pow[i - 1]);\n                    pow[i] %= mod;\n                }\n                long ans = dp(r);\n                pw.println((ans - dp(l) + mod) % mod);\n            }\n        }\n\n        private long dp(char[] a) {\n            arr = a;\n            memo = new long[2][2][arr.length][1 << 10];\n            for (long[][][] x : memo)\n                for (long[][] y : x)\n                    for (long[] z : y)\n                        Arrays.fill(z, -1);\n            memo2 = new long[2][2][arr.length][1 << 10];\n            for (long[][][] x : memo2)\n                for (long[][] y : x)\n                    for (long[] z : y)\n                        Arrays.fill(z, -1);\n            return dp(0, 0, 0, 0);\n        }\n\n        private long dp(int idx, int msk, int bool, int bool2) {\n            if (idx == arr.length)\n                return 0;\n            if (memo[bool][bool2][idx][msk] != -1)\n                return memo[bool][bool2][idx][msk];\n            int e = bool == 1 ? 9 : arr[idx] - '0';\n            long ans = 0;\n            for (int i = 0; i <= e; i++) {\n                int nextBool = i < arr[idx] - '0' ? 1 : bool;\n                int nextBool2 = i != 0 ? 1 : bool2;\n                int nextMsk = nextBool2 == 1 ? msk | 1 << i : msk;\n                long temp = count(idx + 1, nextMsk, nextBool, nextBool2);\n                if (temp == 0)\n                    continue;\n                temp *= pow[arr.length - 1 - idx];\n                temp %= mod;\n                temp *= i;\n                ans += temp;\n                ans += dp(idx + 1, nextMsk, nextBool, nextBool2);\n                ans %= mod;\n            }\n            return memo[bool][bool2][idx][msk] = ans;\n        }\n\n        private long count(int idx, int msk, int bool, int bool2) {\n            if (idx == arr.length)\n                return bool2 == 1 && Integer.bitCount(msk) <= k ? 1 : 0;\n            if (memo2[bool][bool2][idx][msk] != -1)\n                return memo2[bool][bool2][idx][msk];\n            int e = bool == 1 ? 9 : arr[idx] - '0';\n            long ans = 0;\n            for (int i = 0; i <= e; i++) {\n                int nextBool = i < arr[idx] - '0' ? 1 : bool;\n                int nextBool2 = i != 0 ? 1 : bool2;\n                int nextMsk = nextBool2 == 1 ? msk | 1 << i : msk;\n                ans += count(idx + 1, nextMsk, nextBool, nextBool2);\n                ans %= mod;\n            }\n            return memo2[bool][bool2][idx][msk] = ans;\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() {\n            try {\n                while (st == null || !st.hasMoreTokens())\n                    st = new StringTokenizer(br.readLine());\n                return st.nextToken();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n\n","bitmasks,combinatorics,dp,math"
"import java.util.*;\nimport java.io.*;\n\npublic class Div712 {\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////                                                                                                               /////////\n////////                                                                                                               /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM         OOOOOO             SSSSSSS      EEEEEEEEEEEEE  /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMMMM      MMMMMM      OOO      OOO        SSSS   SSS     EEEEEEEEEEEEE  /////////\n////////   HHHH        HHHH  EEEEE           MMMM MMM  MMM MMMM    OOO          OOO    SSSS       SSS   EEEEE          /////////\n////////   HHHH        HHHH  EEEEE           MMMM  MMMMMM  MMMM   OOO            OOO   SSSS             EEEEE          /////////\n////////   HHHH        HHHH  EEEEE           MMMM          MMMM  OOO              OOO   SSSSSSS         EEEEE          /////////\n////////   HHHHHHHHHHHHHHHH  EEEEEEEEEEE     MMMM          MMMM  OOO              OOO      SSSSSS       EEEEEEEEEEE    /////////\n////////   HHHHHHHHHHHHHHHH  EEEEEEEEEEE     MMMM          MMMM  OOO              OOO         SSSSSSS   EEEEEEEEEEE    /////////\n////////   HHHH        HHHH  EEEEE           MMMM          MMMM   OOO            OOO              SSSS  EEEEE          /////////\n////////   HHHH        HHHH  EEEEE           MMMM          MMMM    OOO          OOO     SSS       SSSS  EEEEE          /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM      OOO      OOO        SSS    SSSS    EEEEEEEEEEEEE  /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM         OOOOOO             SSSSSSS      EEEEEEEEEEEEE  /////////\n////////                                                                                                               /////////\n////////                                                                                                               /////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    static int mod = 998244353;\n    static int[][][] memo, memo2;\n    static int k;\n    static int[] s;\n    static long pow10[];\n\n    static int dp(int limit, int idx, int taken) {\n        if (Integer.bitCount(taken) > k)\n            return 0;\n        if (idx == 19)\n            return 1;\n        if (memo[limit][idx][taken] != -1)\n            return memo[limit][idx][taken];\n        int ans = 0;\n        for (int i = 0; i < 10; i++) {\n            if (!can(limit, idx, i))\n                continue;\n            if (i == 0 && taken == 0) {\n                ans += dp(getl(limit, idx, i), idx + 1, taken);\n            } else ans += dp(getl(limit, idx, i), idx + 1, taken | 1 << i);\n            ans %= mod;\n        }\n        return memo[limit][idx][taken] = ans;\n    }\n\n    static int dp2(int limit, int idx, int taken) {\n        if (Integer.bitCount(taken) > k)\n            return 0;\n        if (idx == 19)\n            return 0;\n        if (memo2[limit][idx][taken] != -1)\n            return memo2[limit][idx][taken];\n        long ans = 0;\n        for (int i = 0; i < 10; i++) {\n            if (!can(limit, idx, i))\n                continue;\n            if (i == 0 && taken == 0) {\n                ans += dp2(getl(limit, idx, i), idx + 1, taken);\n            } else {\n                long v = dp2(getl(limit, idx, i), idx + 1, taken | 1 << i);\n                long count = dp(getl(limit, idx, i), idx + 1, taken | 1 << i);\n                v += (count * i * pow10[18 - idx]);\n                v %= mod;\n                ans += v;\n            }\n            ans %= mod;\n        }\n        return memo2[limit][idx][taken] = (int) ans;\n    }\n\n    static int getl(int limit, int idx, int d) {\n        return limit | (s[idx] > d ? 1 : 0);\n    }\n\n    static boolean can(int limit, int idx, int d) {\n        return limit == 1 | (s[idx] >= d);\n    }\n\n    static int dpvalue(long v) {\n        s = new int[19];\n\n        int idx = 18;\n        while (idx >= 0) {\n            s[idx] = (int) (v % 10);\n            v /= 10;\n            idx--;\n        }\n        memo = new int[2][19][1 << 10];\n        memo2 = new int[2][19][1 << 10];\n\n        for (int[][] x : memo) for (int[] y : x) Arrays.fill(y, -1);\n        for (int[][] x : memo2) for (int[] y : x) Arrays.fill(y, -1);\n//        System.err.println(Arrays.toString(s));\n//        System.err.println(v + "" "" + dp2(0, 17, 0));\n        return dp2(0, 0, 0);\n    }\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        pow10 = new long[20];\n        pow10[0] = 1;\n        for (int i = 1; i < 20; i++) {\n            pow10[i] = (10 * pow10[i - 1]) % mod;\n        }\n\n        long l = sc.nextLong();\n        long r = sc.nextLong();\n        k = sc.nextInt();\n        long ans = dpvalue(r) - dpvalue(l - 1) + mod;\n\n        pw.println(ans % mod);\n\n        pw.flush();\n    }\n\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int[] nextIntArr(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(""0"");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(""0"");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n\n}\n","bitmasks,combinatorics,dp,math"
"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class P1073E\n{\n	static int mod = 998244353;\n	static long[] pow10mod;\n	static int k;\n	static int[] num;\n	static int[][][] dp, dpWays;\n	public static void main(String[] args)\n	{\n		pow10mod = new long[30];\n		pow10mod[0] = 1;\n		for (int i = 1; i < pow10mod.length; i++)\n			pow10mod[i] = 10*pow10mod[i-1] % mod;\n		Scanner scan = new Scanner(System.in);\n		long a = scan.nextLong();\n		long b = scan.nextLong();\n		k = scan.nextInt();\n		System.out.println((cnt(b) - cnt(a-1) + mod) % mod);\n	}\n	private static long cnt(long n)\n	{\n		char[] ch = (""""+n).toCharArray();\n		num = new int[ch.length];\n		for (int i = 0; i < ch.length; i++)\n			num[i] = ch[i]-'0';\n		\n		dp = new int[2][num.length][1 << 10];\n		for (int[][] a : dp)\n			for (int[] b : a)\n				Arrays.fill(b, -1);\n		dpWays = new int[2][num.length][1 << 10];\n		for (int[][] a : dpWays)\n			for (int[] b : a)\n				Arrays.fill(b, -1);\n		\n		return go(0, 0, 0, true);\n	}\n	private static int go(int started, int ind, int mask, boolean bounded)\n	{\n		if (ind == num.length)\n			return 0;\n		if (!bounded && dp[started][ind][mask] >= 0)\n			return dp[started][ind][mask];\n		\n		long ans = 0;\n		int b = bounded ? num[ind] : 9;\n		for (int i = 0; i <= b; i++)\n		{\n			long mult = i*pow10mod[num.length-ind-1] % mod;\n			ans += mult*ways(started == 1 || i > 0 ? 1 : 0, ind+1, started == 0 && i == 0 ? mask : mask | (1 << i), bounded && i == b);\n			ans += go(started == 1 || i > 0 ? 1 : 0, ind+1, started == 0 && i == 0 ? mask : mask | (1 << i), bounded && i == b);\n		}\n		\n		if (!bounded)\n			dp[started][ind][mask] = (int)(ans % mod);\n		return (int)(ans % mod);\n	}\n	private static int ways(int started, int ind, int mask, boolean bounded)\n	{\n		if (ind == num.length)\n			return Integer.bitCount(mask) <= k ? 1 : 0;\n		if (!bounded && dpWays[started][ind][mask] >= 0)\n			return dpWays[started][ind][mask];\n		\n		long ans = 0;\n		int b = bounded ? num[ind] : 9;\n		for (int i = 0; i <= b; i++)\n			ans += ways(started == 1 || i > 0 ? 1 : 0, ind+1, started == 0 && i == 0 ? mask : mask | (1 << i), bounded && i == b);\n		\n		if (!bounded)\n			dpWays[started][ind][mask] = (int)(ans % mod);\n		return (int)(ans % mod);\n	}\n}\n","bitmasks,combinatorics,dp,math"
"import java.io.*;\nimport java.util.*;\n\npublic class H {\n\n	static char[] s;\n	static int n, k;\n	static long[] pow;\n	static int MOD = 998244353;\n\n	static int solve(long r) {\n		s = (r + """").toCharArray();\n		n = s.length;\n		memo=new pair[2][n][1100];\n		\n		return dp(0, 0, 0, 0).v;\n	}\n	static pair[][][]memo;\n	static class pair\n	{\n		int v,cnt;\n		pair(int a,int b){\n			v=a;\n			cnt=b;\n		}\n	}\n	static pair dp(int idx, int less, int dis, int msk) {\n		\n		\n		\n		if(idx==n)\n			return new pair(0,1);\n		if(memo[less][idx][msk]!=null)\n			return memo[less][idx][msk];\n		long ans = 0;\n		long cnt=0;\n		int up = less == 1 ? 9 : s[idx] - '0';\n		for (int d = 0; d <= up; d++) {\n			int newLess = less == 1 ? 1 : d < s[idx] - '0' ? 1 : 0;\n			int newDis =dis;\n			if((msk & 1 << d) == 0  && (msk>1 || d>0))\n				newDis++;\n			if(newDis>k)\n				continue;\n			\n			long x=d*pow[n-1-idx]%MOD;\n		    int newMsk=msk;\n		    if(newDis==dis+1)\n		        newMsk|=1<<d;\n			pair p=dp(idx + 1, newLess, newDis,newMsk);\n			ans = ans +p.v ;\n			\n			ans %= MOD;\n			long y=x*p.cnt%MOD;\n			ans+=y;\n			ans%=MOD;\n			cnt+=p.cnt;\n			cnt%=MOD;\n		}\n\n		return memo[less][idx][msk]=new pair((int) ans,(int)cnt);\n\n	}\n\n	public static void main(String[] args) throws IOException {\n		Scanner sc = new Scanner();\n		PrintWriter out = new PrintWriter(System.out);\n		long l=sc.nextLong(),r=sc.nextLong();\n		k=sc.nextInt();\n		\n		pow=new long [20];\n		pow[0]=1;\n		for(int i=1;i<pow.length;i++)\n			pow[i]=10*pow[i-1]%MOD;\n		long ans=(solve(r)-solve(l-1));\n		if(ans<0)\n			ans+=MOD;\n		out.println(ans);\n		out.close();\n	}\n\n	static class Scanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		Scanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n\n		int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n	}\n}","bitmasks,combinatorics,dp,math"
"import java.util.Scanner;\npublic class Main\n{\n	public static void main(String[] args)\n	{\n		Scanner in=new Scanner(System.in);\n		while(in.hasNext())\n		{\n			int n=in.nextInt();\n			int m=in.nextInt();\n			int minx=100000005;\n			int a[]=new int[200005];\n			for (int i = 0; i < n; i++)\n			{\n				int h=in.nextInt();\n				minx=Math.min(h, minx);\n				a[1]++;\n				a[h+1]--;\n			}\n			for(int i=1;i<=200000;i++)\n			{\n				a[i]+=a[i-1];\n			}\n			int temp=0;\n			int ans=0;\n			for(int i=200000;i>=minx+1;i--)\n			{\n				temp+=a[i];\n				if(temp>m)\n				{\n					ans++;\n					temp=0;\n					i++;\n				}\n			}\n			if(temp>0)\n			{\n				ans++;\n			}\n			System.out.println(ans);\n	    }\n	}\n}\n\n    		 	 	 		    	 	 		  	 		",greedy
"import java.io.*;\nimport java.util.*;\n\npublic class Codeforces\n{\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb=new StringBuilder();\n        String s[]=bu.readLine().split("" "");\n        int n=Integer.parseInt(s[0]),k=Integer.parseInt(s[1]);\n        int i,N=200004,c[]=new int[N+1],a,max=0;\n\n        s=bu.readLine().split("" "");\n        for(i=0;i<n;i++)\n        {\n            a=Integer.parseInt(s[i]);\n            c[0]++;\n            c[a+1]--;\n            max=Math.max(max,a);\n        }\n        for(i=1;i<=N;i++) c[i]+=c[i-1];\n\n        int cur=0,ans=0;\n        for(i=max;i>0;i--)\n        {\n            if(c[i]==n)\n            {\n                if(cur>0) ans++;\n                break;\n            }\n            if(cur+c[i]<=k) cur+=c[i];\n            else\n            {\n                cur=c[i];\n                ans++;\n            }\n        }\n        System.out.println(ans);\n    }\n}\n",greedy
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Scanner scn=new Scanner(System.in);\n        int n=scn.nextInt();\n        long k=scn.nextInt();\n        ArrayList<Long> arr=new ArrayList<Long>();\n        int cost=0;\n        for(int i=0;i<n;i++){\n            arr.add(scn.nextInt()+0l);\n        }\n        Collections.sort(arr);\n        for(int i=arr.size()-1;i>=1;i--){\n            arr.set(i,arr.get(i)-arr.get(i-1));\n        }\n        arr.set(0,0l);\n        arr.add(Integer.MAX_VALUE+0l);\n        int i=0;\n        while(i<arr.size()){\n            long sum=0l;\n            while((i<n)&&k>=(sum+(n-i)*arr.get(i))){\n                sum=sum+(n-i)*(arr.get(i));\n                i++;\n            }\n            cost++;\n            if(i==n){\n                if(sum==0){\n                    cost--;\n                }\n                break;\n            }\n            long val=(k-sum)/(n-i);\n            arr.set(i,arr.get(i)-val);\n        }\n        System.out.println(cost);\n    }\n}\n",greedy
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Scanner scn=new Scanner(System.in);\n        int n=scn.nextInt();\n        long k=scn.nextInt();\n        ArrayList<Long> arr=new ArrayList<Long>();\n        int cost=0;\n        for(int i=0;i<n;i++){\n            arr.add(scn.nextInt()+0l);\n        }\n        Collections.sort(arr);\n        for(int i=arr.size()-1;i>=1;i--){\n            arr.set(i,arr.get(i)-arr.get(i-1));\n        }\n        arr.set(0,0l);\n        arr.add(Integer.MAX_VALUE+0l);\n        int i=0;\n        while(i<arr.size()){\n            long sum=0l;\n            while((i<n)&&k>=sum){\n                i++;\n                sum=sum+(n-i)*(arr.get(i));\n            }\n            cost++;\n            if(i==n){\n                if(sum-(n-i)*arr.get(i)==0){\n                    cost--;\n                }\n                break;\n            }\n            long val=(k-sum+(n-i)*(arr.get(i)))/(n-i);\n            arr.set(i,arr.get(i)-val);\n            i--;\n        }\n        System.out.println(cost);\n    }\n}\n",greedy
"//package round523;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class F2 {\n	Scanner in;\n	PrintWriter out;\n	String INPUT = """";\n	\n	boolean q(int a, int b, int c)\n	{\n		out.println(""? "" + (a+1) + "" "" + (b+1) + "" "" + (c+1));\n		out.flush();\n		return in.next().trim().equals(""Yes"");\n	}\n	\n	void solve()\n	{\n		int n = ni(), K = ni();\n		int D = 0;\n		for(int q = 1, s = 0;;D++){\n			s += q;\n			if(s == n)break;\n			q *= K;\n		}\n		\n//		Random gen = new SecureRandom();\n		Random gen = new Random(114514);\n		List<Integer> ride = null;\n		int x, y;\n		while(true){\n			x = gen.nextInt(n);\n			y = gen.nextInt(n);\n			if(x == y)continue;\n			ride = new ArrayList<>();\n			for(int i = 0;i < n;i++){\n				if(i == x || i == y)continue;\n				if(q(x, i, y))ride.add(i);\n			}\n			if(ride.size() == 2*D-1){\n				break;\n			}\n		}\n		\n		for(int r : ride){\n			int dep = 0;\n			for(int o : ride){\n				if(o == r)continue;\n				if(q(x, o, r)){\n					dep++;\n				}\n			}\n			if(dep == D-1){\n				out.println(""! "" + (r+1));\n				out.flush();\n				return;\n			}\n		}\n		throw new RuntimeException();\n	}\n	\n	void run() throws Exception\n	{\n		in = oj ? new Scanner(System.in) : new Scanner(INPUT);\n		out = new PrintWriter(System.out);\n\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception\n	{\n		new F2().run();\n	}\n	\n	int ni() { return Integer.parseInt(in.next()); }\n	long nl() { return Long.parseLong(in.next()); }\n	double nd() { return Double.parseDouble(in.next()); }\n	boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","interactive,probabilities"
"import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class Div2_523F {\n\n	static int N;\n	static int K;\n	static int H;\n\n	static BufferedReader reader;\n	static PrintWriter printer;\n\n	static Random rng = new Random();\n\n	public static void main(String[] args) throws IOException {\n		reader = new BufferedReader(new InputStreamReader(System.in));\n		printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		StringTokenizer inputData = new StringTokenizer(reader.readLine());\n		N = Integer.parseInt(inputData.nextToken());\n		K = Integer.parseInt(inputData.nextToken());\n\n		int val = 1 + N * (K - 1);\n\n		while (val > 1) {\n			val /= K;\n			H++;\n		}\n\n		int a;\n		int b;\n		lLoop:\n		while (true) {\n			a = 1 + rng.nextInt(N);\n			b = 1 + rng.nextInt(N);\n			cData(a, b);\n			if (between.size() == 2 * H - 1) {\n				break lLoop;\n			}\n		}\n\n		int want = H - 1;\n\n		while (a != b) {\n			ArrayList<Integer> pCopy = new ArrayList<>(between);\n			int pivot = between.get(rng.nextInt(between.size()));\n			cData(a, pivot);\n\n			if (between.size() - 1 == want) {\n				printer.println(""! "" + pivot);\n				printer.close();\n				return;\n			}\n\n			if (between.size() <= want) {\n				want -= (between.size() - 1);\n				a = pivot;\n				between = exclude(pCopy, between);\n			} else {\n				b = pivot;\n			}\n		}\n		printer.println(""! "" + a);\n		printer.close();\n	}\n\n	static ArrayList<Integer> exclude(ArrayList<Integer> set, ArrayList<Integer> rmv) {\n		Collections.sort(set);\n		Collections.sort(rmv);\n\n		ArrayList<Integer> ret = new ArrayList<>();\n\n		int j = 0;\n		for (int i = 0; i < set.size(); i++) {\n			while (j < rmv.size() && rmv.get(j) < set.get(i)) {\n				j++;\n			}\n\n			if (j >= rmv.size() || !rmv.get(j).equals(set.get(i))) {\n				ret.add(set.get(i));\n			}\n		}\n		return ret;\n	}\n\n	static ArrayList<Integer> between = new ArrayList<>();\n\n	static void cData(int a, int b) throws IOException {\n		between.clear();\n\n		for (int i = 1; i <= N; i++) {\n			printer.println(""? "" + a + "" "" + i + "" "" + b);\n		}\n		printer.flush();\n\n		for (int i = 1; i <= N; i++) {\n			if (reader.readLine().equals(""Yes"")) {\n				between.add(i);\n			}\n		}\n	}\n}\n","interactive,probabilities"
"import java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\npublic class E {\n    public static void main(String[] args) throws Exception {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        // Scanner scan = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        // int n = Integer.parseInt(bf.readLine());\n        StringTokenizer st = new StringTokenizer(bf.readLine());\n        // int[] a = new int[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        int depth = 0;\n        int cur = 1;\n        while(cur < n) {\n          cur = cur * k;\n          cur += 1;\n          depth ++;\n        }\n        int path_length = depth*2 + 1;\n        Random rand = new Random();\n        while(true) {\n          int v1 = ((rand.nextInt()%n+n) % n) + 1;\n          int v2 = ((rand.nextInt()%n+n) % n) + 1;\n          if(v1 == v2) continue;\n          int counter = 0;\n          Set<Integer> vals = new HashSet<Integer>();\n          for(int i=1; i<=n; i++) {\n            if((i == v1) || (i == v2)) {\n              counter++;\n              vals.add(i);\n              continue;\n            }\n            out.println(""? "" + v1 + "" "" + i + "" "" + v2);\n            out.flush();\n            String s = bf.readLine();\n            if(s.equals(""Yes"")) {\n              counter++;\n              vals.add(i);\n            }\n          }\n          if(counter == path_length) {\n            int[] a = new int[path_length];\n            int counter2 = 0;\n            for(int v : vals) {\n              a[counter2] = v;\n              counter2++;\n            }\n            for(int i=0; i<path_length; i++) {\n              counter = 0;\n              for(int j=0; j<path_length; j++) {\n                for(int kk=0; kk<j; kk++) {\n                  out.println(""? "" + a[j] + "" "" + a[i] + "" "" + a[kk]);\n                  out.flush();\n                  String s = bf.readLine();\n                  if(s.equals(""Yes""))\n                    counter++;\n                }\n              }\n              if(counter == (path_length*(path_length-1))/2 - 2*depth*(depth-1)/2) {\n                out.println(""! "" + a[i]);\n                break;\n              }\n            }\n            break;\n          }\n        }\n\n        // int n = scan.nextInt();\n\n        out.close(); System.exit(0);\n    }\n}\n","interactive,probabilities"
"import java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Random;\n\npublic class F {\n\n	public static void main(String[] args) {\n		JS in = new JS();\n		PrintWriter out = new PrintWriter(System.out);\n		\n		int N = in.nextInt();\n		int K = in.nextInt();\n		Random r = new Random();\n		int dep = 1;\n		int size = 1;\n		int lastLen = 1;\n		while(size < N) {\n			size += lastLen*K;\n			lastLen *= K;\n			dep++;\n		}\n		int leaf1 = -1;\n		int leaf2 = -1;\n		ArrayList<Integer> path = new ArrayList<Integer>();\n		while(true) {\n			int v1 = r.nextInt(N)+1;\n			int v2 = r.nextInt(N)+1;\n			if(v1 == v2) continue;\n			path = new ArrayList<Integer>();\n			for(int i = 1; i <= N; i++) {\n				if(i == v1 || i == v2) continue;\n				out.println(""? ""+v1+"" ""+i+"" ""+v2);\n				out.flush();\n				boolean isYes = in.next().charAt(0) == 'Y';\n				if(isYes) {\n					path.add(i);\n				}			\n			}\n			if(path.size() == (dep-1)*2 - 1) {\n				leaf1 = v1;\n				leaf2 = v2;\n				break;\n			}\n		}\n\n		for(Integer root : path) { //check if root\n			//check if path to leaf1 is equal to dep-2\n			int pathLen = 0;\n			for(int i = 1; i <= N; i++) {\n				if(i == root || i == leaf1)continue;\n				out.println(""? ""+root+"" ""+i+"" ""+leaf1);\n				out.flush();\n				boolean isYes = in.next().charAt(0) == 'Y';\n				if(isYes) pathLen++;\n			}\n			if(pathLen == dep-2) {\n				out.println(""! ""+root);\n				out.close();\n				return;\n			}\n			\n		}\n		out.close();\n		\n	}\n\n	\n	static class JS{\n		public int BS = 1<<16;\n		public char NC = (char)0;\n		byte[] buf = new byte[BS];\n		int bId = 0, size = 0;\n		char c = NC;\n		double num = 1;\n		BufferedInputStream in;\n		\n		public JS() {\n			in = new BufferedInputStream(System.in, BS);\n		}\n		\n		public JS(String s) throws FileNotFoundException {\n			in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n		}\n		\n		public char nextChar(){\n			while(bId==size) {\n				try {\n					size = in.read(buf);\n				}catch(Exception e) {\n					return NC;\n				}				\n				if(size==-1)return NC;\n				bId=0;\n			}\n			return (char)buf[bId++];\n		}\n		\n		public int nextInt() {\n			return (int)nextLong();\n		}\n		\n		public long nextLong() {\n			num=1;\n			boolean neg = false;\n			if(c==NC)c=nextChar();\n			for(;(c<'0' || c>'9'); c = nextChar()) {\n				if(c=='-')neg=true;\n			}\n			long res = 0;\n			for(; c>='0' && c <='9'; c=nextChar()) {\n				res = (res<<3)+(res<<1)+c-'0';\n				num*=10;\n			}\n			return neg?-res:res;\n		}\n		\n		public double nextDouble() {\n		    while(c!='.'&&c!='-'&&(c <'0' || c>'9')) c = nextChar();\n		    boolean neg = c=='-';\n		    if(neg)c=nextChar();\n		    boolean fl = c=='.';\n		    double cur = nextLong();\n		    if(fl) return neg ? -cur/num : cur/num;\n		    if(c == '.') {\n			double next = nextLong();\n			return neg ? -cur-next/num : cur+next/num;\n		    }\n		    else return neg ? -cur : cur;\n		}\n		\n		public String next() {\n			StringBuilder res = new StringBuilder();\n			while(c<=32)c=nextChar();\n			while(c>32) {\n				res.append(c);\n				c=nextChar();\n			}\n			return res.toString();\n		}\n		\n		public String nextLine() {\n			StringBuilder res = new StringBuilder();\n			while(c<=32)c=nextChar();\n			while(c!='\n') {\n				res.append(c);\n				c=nextChar();\n			}\n			return res.toString();\n		}\n\n		public boolean hasNext() {\n			if(c>32)return true;\n			while(true) {\n				c=nextChar();\n				if(c==NC)return false;\n				else if(c>32)return true;\n			}\n		}\n	}\n	\n}\n","interactive,probabilities"
"import java.util.*;\nimport java.io.*; \npublic class B{\n	public static void main(String[] args)\n	{\n		FastScanner fs = new FastScanner();\n		PrintWriter out = new PrintWriter(System.out);\n		int n = fs.nextInt();\n		int[] arr = new int[n+2];\n		for(int i=1;i<=n;i++)\n		{\n			arr[i] = fs.nextInt();\n		}\n		for(int i=2;i<=n;i++)\n		{\n			arr[i] += arr[i-1];\n		}\n		int max = 0;\n		int ans = 0;\n		for(int i=1;i<=n;i++)\n		{\n			int res = -1; int len = -1;\n			for(int j=i;j<=n;j++)\n			{\n				res = arr[j]-arr[i-1];\n				len = j-i+1;\n				if(res>100*len)\n				{\n					ans = Math.max(ans,len);\n				}\n			}\n		}\n		out.println(ans);\n		out.close();\n	}\n	static class FastScanner {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n		String next() {\n			while (!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		int[] readArray(int n) {\n			int[] a=new int[n];\n			for (int i=0; i<n; i++) a[i]=nextInt();\n			return a;\n		}\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n	}\n}\n\n\n","*special,brute force"
"import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    // For fast input output\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            try {\n                br = new BufferedReader(new FileReader(""input.txt""));\n                PrintStream out = new PrintStream(new FileOutputStream(""output.txt""));\n                System.setErr(new PrintStream(new FileOutputStream(""error.txt"")));\n                System.setOut(out);\n            } catch (Exception e) {\n                br = new BufferedReader(new InputStreamReader(System.in));\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    // end of fast i/o code\n    static StringBuilder str = new StringBuilder("""");\n\n    public static void main(String[] args) {\n        FastReader reader = new FastReader();\n        int n = reader.nextInt();\n        int[] arr = new int[n];\n        int[] sum = new int[n];\n        for(int i = 0; i < n; i++)\n            arr[i] = reader.nextInt();\n        sum[0] = arr[0]; \n        for(int i = 1; i < n; i++)\n            sum[i] = sum[i-1] + arr[i];\n        int maxtime = 0;\n        for(int i=n-1; i>=0; i--)\n        {\n            int tempsum = sum[i];\n            for(int j=0; j<=i; j++)\n            {\n                int t = i-j+1;\n                //System.err.println(tempsum);\n                if(tempsum>(100*t))\n                    maxtime = Math.max(maxtime, t);\n                tempsum -= arr[j];\n            }\n        }\n        System.out.println(maxtime);\n    }\n}","*special,brute force"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n\npublic class Main {\n\n\n        public static void main(String[] args) throws IOException {\n            FastReader sc=new FastReader();\n\n                int n = sc.nextInt();\n                int[] a = new int[n];\n                long total =0;\n                for (int i = 0; i < n; i++)\n                {a[i] = sc.nextInt();\n                    total+=a[i];}\n                long[] pref = new long[n];\n                pref[0]=0;\n\n                long add=0;\n                for(int i=1;i<n;i++)\n                {  add+=a[i-1];\n                    pref[i]=add;\n                }\n\n\n\n            add=0;\n            long[] suf = new long[n];\n                suf[n-1]=0;\n            for(int i=n-2;i>=0;i--)\n            {  add+=a[i+1];\n                suf[i]=add;\n            }\n\n\n\n                 long count=0,len=0;\n\n                 for(int i=0;i<n;i++)\n                 {    count=0;\n                     for(int j=i;j<n;j++)\n                 {    count=total-suf[j]-pref[i];\n                     if(count>(j-i+1)*100)\n                     {   len=Math.max((j-i+1),len);\n\n                     }\n                 }\n                 }\n\n                 System.out.println(len);\n\n\n        }\n\n\n\n\n//Things to check when u r getting wrong answer\n// 1-  check the flow of the code\n\n\n//All the functions\n\n\n        //function to print an array for debugging\n        static void print(long[] a) {\n            for (int i = 0; i < a.length; i++)\n                System.out.print(a[i] + "" "");\n            System.out.println();\n        }\n\n\n        //normal gcd function, always put the greater number as a and the smaller number as b\n        static int gcd(int a, int b) {\n            if (b == 0)\n                return a;\n            return gcd(b, a % b);\n\n        }\n\n\n//Input Reader to read faster input\n        static class FastReader {\n            BufferedReader br;\n            StringTokenizer st;\n\n            public FastReader() {\n                br = new BufferedReader(new\n                        InputStreamReader(System.in));\n            }\n\n            String next() {\n                while (st == null || !st.hasMoreElements()) {\n                    try {\n                        st = new StringTokenizer(br.readLine());\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                return st.nextToken();\n            }\n\n            int nextInt() {\n                return Integer.parseInt(next());\n            }\n\n            long nextLong() {\n                return Long.parseLong(next());\n            }\n\n            double nextDouble() {\n                return Double.parseDouble(next());\n            }\n\n            String nextLine() {\n                String str = """";\n                try {\n                    str = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                return str;\n            }\n        }\n\n\n\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","*special,brute force"
"import java.io.*;\nimport java.util.*;\n//import java.math.*; // for bigInteger\n\npublic class Main {   \n\n  	public static void main(String args[]) throws Exception {\n        InputReader sc = new InputReader();\n        PrintWriter out = new PrintWriter(System.out);\n        int t=1;  //t = sc.nextInt();\n        for(int tt=1;tt<=t;++tt) solve(tt,sc,out);\n        out.close();\n    }\n\n    static void solve(int t, InputReader sc, PrintWriter out) {\n        int n = sc.nextInt();\n        int[] r = new int[n+1];\n        for(int i=1;i<=n;++i) {\n            r[i]=sc.nextInt();\n            r[i]+=r[i-1];\n        } \n        int ans = 0;\n        for(int i=1;i<=n;++i) {\n            for(int j=i;j<=n;++j) {\n                if(r[j]-r[i-1]>100*(j-i+1)) {\n                    ans = Math.max(ans,j-i+1);\n                }\n            }\n        }\n        out.println(ans);\n    }\n\n    public static class InputReader{\n        BufferedReader br;\n        StringTokenizer st;\n        InputReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n        public String next(){\n            while(st == null || !st.hasMoreTokens()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch(IOException e){}\n            }\n            return st.nextToken();\n        }\n    }\n     \n	/*private final static int m =(int)1e9+7;\n	private static class Pair<T,V> {\n		T first;\n		V second;\n		Pair(final T first, final V second) {\n			this.first = first;\n			this.second = second;\n		}\n		public boolean equals(Object o) {\n			Pair given = (Pair)o;\n			if(given.first == first && given.second == second)  return true;\n			return false;\n		}\n		public int hashCode() {\n			long temp = (long)(first.hashCode())*31;\n			temp = (temp+(long)second.hashCode())%m;\n			return (int)temp;\n		}\n	}*/\n\n    public static void debug(final int[] ...var) {\n        for(final int[] row : var) {\n            debug(row);\n        }\n    }\n\n    public static void debug(final long[] ...var) {\n        for(final long[] row : var) {\n            debug(row);\n        }\n    }\n\n    public static void debug(final String[] ...var) {\n        for(final String[] row : var) {\n            debug(row);\n        }\n    }\n\n    public static void debug(final double[] ...var) {\n        for(final double[] row : var) {\n            debug(row);\n        }\n    }\n\n    public static void debug(final char[] ...var) {\n        for(final char[] row : var) {\n            debug(row);\n        }\n    }\n\n    public static void debug(final int ...var) {\n        for(final int i:var)  System.err.print(i+"" "");\n        System.err.println();\n    }\n    public static void debug(final String ...var) {\n        for(final String i:var)  System.err.print(i+"" "");\n        System.err.println();\n    }\n    public static void debug(final double ...var) {\n        for(final double i:var)  System.err.print(i+"" "");\n        System.err.println();\n    }\n    \n    public static void debug(final long ...var) {\n        for(final long i:var)  System.err.print(i+"" "");\n        System.err.println();\n    }\n    \n    public static void debug(final char ...var) {\n        for(final char c:var)  System.err.print(c+"" "");\n        System.err.println();\n    }\n\n    /*\n    public static <T> void debug(T ...varargs) {\n        // Warning\n        // Heap Pollution might occur\n        // this overrides even 1d and 2d array methods as it is an object... \n        // + i am not using object based array like Integer[]\n        // I am using int[] so that is a problem as i need Wrapper class as an argument\n        for(T val:varargs)  System.err.printf(""%s "",val);\n        System.err.println();\n    }\n    */\n}","*special,brute force"
"import java.io.BufferedOutputStream;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.math.BigInteger;\nimport java.util.InputMismatchException;\nimport java.util.Random;\nimport java.util.TreeSet;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	static class TaskAdapter implements Runnable {\n		@Override\n		public void run() {\n			long startTime = System.currentTimeMillis();\n			InputStream inputStream = System.in;\n			OutputStream outputStream = System.out;\n			FastReader in = new FastReader(inputStream);\n			Output out = new Output(outputStream);\n			BSpaceIsaac solver = new BSpaceIsaac();\n			solver.solve(1, in, out);\n			out.close();\n			System.err.println(System.currentTimeMillis()-startTime+""ms"");\n		}\n	}\n\n	public static void main(String[] args) throws Exception {\n		Thread thread = new Thread(null, new TaskAdapter(), """", 1<<26);\n		thread.start();\n		thread.join();\n	}\n\n	static class BSpaceIsaac {\n		public BSpaceIsaac() {\n		}\n\n		public void solve(int kase, InputReader in, Output pw) {\n			int n = in.nextInt(), m = in.nextInt();\n			int[] arr = in.nextInt(n);\n			int[] diff = new int[n-1];\n			for(int i = 0; i<n-1; i++) {\n				diff[i] = arr[i+1]-arr[i];\n			}\n			BSpaceIsaac.MultiChecker pc = new BSpaceIsaac.MultiChecker(diff.clone());\n			TreeSet<Integer> ans = new TreeSet<>();\n			for(int i = 0; i<n-1; i++) {\n				int sum = (arr[0]+arr[i])%m;\n				if(sum>=arr[i]&&sum<=arr[i+1]&&(arr[i+1]+arr[n-1])%m==sum\n						&&(i==0||pc.isPalin(0, i-1))&&(i==n-2||pc.isPalin(i+1, n-2))) {\n					ans.add(sum);\n				}\n			}\n			loop:\n			{\n				int sum = (arr[0]+arr[n-1])%m;\n				if(sum<=arr[0]||sum>=arr[n-1]&&pc.isPalin(0, n-2)) {\n					for(int i = 0; i<n-1; i++) {\n						if(diff[i]!=diff[n-2-i]) {\n							break loop;\n						}\n					}\n					ans.add(sum);\n				}\n			}\n			pw.println(ans.size());\n			pw.println(ans);\n		}\n\n		static class PalindromeChecker {\n			int n;\n			Utilities.Hasher forw;\n			Utilities.Hasher rev;\n\n			public PalindromeChecker(int[] arr) {\n				n = arr.length;\n				long mod;\n				while((mod = BigInteger.probablePrime(30, new Random()).longValueExact())<=(1<<29)) ;\n				long mul = BigInteger.probablePrime(28, new Random()).longValueExact()%mod;\n				forw = new Utilities.Hasher(arr, mul, mod);\n				Utilities.reverse(arr);\n				rev = new Utilities.Hasher(arr, mul, mod);\n			}\n\n			public long revHash(int l, int r) {\n				return rev.hash(n-1-r, n-1-l);\n			}\n\n			public boolean isPalin(int l, int r) {\n				return forw.hash(l, r)==revHash(l, r);\n			}\n\n		}\n\n		static class MultiChecker {\n			int n = 25;\n			BSpaceIsaac.PalindromeChecker[] checkers;\n\n			public MultiChecker(int[] arr) {\n				if(arr.length==0) {\n					return;\n				}\n				checkers = new BSpaceIsaac.PalindromeChecker[n];\n				for(int i = 0; i<n; i++) {\n					checkers[i] = new BSpaceIsaac.PalindromeChecker(arr.clone());\n				}\n			}\n\n			public boolean isPalin(int l, int r) {\n				for(int i = 0; i<25; i++) {\n					if(!checkers[i].isPalin(l, r)) {\n						return false;\n					}\n				}\n				return true;\n			}\n\n		}\n\n	}\n\n	static interface InputReader {\n		int nextInt();\n\n		default int[] nextInt(int n) {\n			int[] ret = new int[n];\n			for(int i = 0; i<n; i++) {\n				ret[i] = nextInt();\n			}\n			return ret;\n		}\n\n		interface CharToIntFunction {\n			int apply(char c);\n\n		}\n\n	}\n\n	static class Output implements Closeable, Flushable {\n		public StringBuilder sb;\n		public OutputStream os;\n		public int BUFFER_SIZE;\n		public String lineSeparator;\n\n		public Output(OutputStream os) {\n			this(os, 1<<16);\n		}\n\n		public Output(OutputStream os, int bs) {\n			BUFFER_SIZE = bs;\n			sb = new StringBuilder(BUFFER_SIZE);\n			this.os = new BufferedOutputStream(os, 1<<17);\n			lineSeparator = System.lineSeparator();\n		}\n\n		public void print(Object... o) {\n			for(int i = 0; i<o.length; i++) {\n				if(i!=0) {\n					print("" "");\n				}\n				print(String.valueOf(o[i]));\n			}\n		}\n\n		public void print(String s) {\n			sb.append(s);\n			if(sb.length()>BUFFER_SIZE >> 1) {\n				flushToBuffer();\n			}\n		}\n\n		public void println(int i) {\n			println(String.valueOf(i));\n		}\n\n		public void println(String s) {\n			sb.append(s);\n			println();\n		}\n\n		public void println() {\n			sb.append(lineSeparator);\n		}\n\n		public <T> void println(Iterable<T> iter) {\n			boolean first = true;\n			for(T t: iter) {\n				if(!first) {\n					print("" "");\n				}\n				first = false;\n				print(t);\n			}\n			println();\n		}\n\n		private void flushToBuffer() {\n			try {\n				os.write(sb.toString().getBytes());\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n			sb = new StringBuilder(BUFFER_SIZE);\n		}\n\n		public void flush() {\n			try {\n				flushToBuffer();\n				os.flush();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n		public void close() {\n			flush();\n			try {\n				os.close();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n	}\n\n	static class FastReader implements InputReader {\n		final private int BUFFER_SIZE = 1<<16;\n		private DataInputStream din;\n		private byte[] buffer;\n		private int bufferPointer;\n		private int bytesRead;\n\n		public FastReader(InputStream is) {\n			din = new DataInputStream(is);\n			buffer = new byte[BUFFER_SIZE];\n			bufferPointer = bytesRead = 0;\n		}\n\n		public int nextInt() {\n			int ret = 0;\n			byte c = skipToDigit();\n			boolean neg = (c=='-');\n			if(neg) {\n				c = read();\n			}\n			do {\n				ret = ret*10+c-'0';\n			} while((c = read())>='0'&&c<='9');\n			if(neg) {\n				return -ret;\n			}\n			return ret;\n		}\n\n		private boolean isDigit(byte b) {\n			return b>='0'&&b<='9';\n		}\n\n		private byte skipToDigit() {\n			byte ret;\n			while(!isDigit(ret = read())&&ret!='-') ;\n			return ret;\n		}\n\n		private void fillBuffer() {\n			try {\n				bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n			}catch(IOException e) {\n				e.printStackTrace();\n				throw new InputMismatchException();\n			}\n			if(bytesRead==-1) {\n				buffer[0] = -1;\n			}\n		}\n\n		private byte read() {\n			if(bytesRead==-1) {\n				throw new InputMismatchException();\n			}else if(bufferPointer==bytesRead) {\n				fillBuffer();\n			}\n			return buffer[bufferPointer++];\n		}\n\n	}\n\n	static class Utilities {\n		public static void swap(int[] arr, int i, int j) {\n			if(i!=j) {\n				arr[i] ^= arr[j];\n				arr[j] ^= arr[i];\n				arr[i] ^= arr[j];\n			}\n		}\n\n		public static void reverse(int[] arr, int i, int j) {\n			while(i<j) {\n				swap(arr, i++, j--);\n			}\n		}\n\n		public static void reverse(int[] arr) {\n			reverse(arr, 0, arr.length-1);\n		}\n\n		public static class math {\n			public static long modInverse(long n, long mod) {\n				//https://www.extendedeuclideanalgorithm.com/code.php\n				long q = 0, r = 1, s1 = 1, s2 = 0, s3 = 1, t1 = 0, t2 = 1, t3 = 0, a = mod, b = n;\n				while(r>0) {\n					q = a/b;\n					r = a-q*b;\n					s3 = s1-q*s2;\n					t3 = t1-q*t2;\n					if(r>0) {\n						a = b;\n						s1 = s2;\n						t1 = t2;\n						b = r;\n						s2 = s3;\n						t2 = t3;\n					}\n				}\n				return (t2+mod)%mod;\n			}\n\n		}\n\n		public static class Hasher {\n			private final long mul;\n			private final long mod;\n			private final long[] powDiv;\n			private final long[] hash;\n\n			public Hasher(String s, InputReader.CharToIntFunction conv, long mul, long mod) {\n				this(s.toCharArray(), conv, mul, mod);\n			}\n\n			public Hasher(char[] arr, InputReader.CharToIntFunction conv, long mul, long mod) {\n				int n = arr.length;\n				this.mul = mul;\n				this.mod = mod;\n				long div = Utilities.math.modInverse(mul, mod);\n				powDiv = new long[n];\n				hash = new long[n];\n				powDiv[0] = 1;\n				hash[0] = conv.apply(arr[0])%mod;\n				long pow = 1;\n				for(int i = 1; i<n; i++) {\n					powDiv[i] = (powDiv[i-1]*div)%mod;\n					hash[i] = (hash[i-1]+conv.apply(arr[i])*pow)%mod;\n					pow = (pow*mul)%mod;\n				}\n			}\n\n			public Hasher(int[] arr, long mul, long mod) {\n				int n = arr.length;\n				this.mul = mul;\n				this.mod = mod;\n				long div = Utilities.math.modInverse(mul, mod);\n				powDiv = new long[n];\n				hash = new long[n];\n				powDiv[0] = 1;\n				hash[0] = arr[0]%mod;\n				long pow = 1;\n				for(int i = 1; i<n; i++) {\n					powDiv[i] = (powDiv[i-1]*div)%mod;\n					pow = (pow*mul)%mod;\n					hash[i] = (hash[i-1]+arr[i]*pow)%mod;\n				}\n			}\n\n			public Hasher(long[] arr, long mul, long mod) {\n				int n = arr.length;\n				this.mul = mul;\n				this.mod = mod;\n				long div = Utilities.math.modInverse(mul, mod);\n				powDiv = new long[n];\n				hash = new long[n];\n				powDiv[0] = 1;\n				hash[0] = arr[0]%mod;\n				long pow = 1;\n				for(int i = 1; i<n; i++) {\n					powDiv[i] = (powDiv[i-1]*div)%mod;\n					hash[i] = (hash[i-1]+arr[i]*pow)%mod;\n					pow = (pow*mul)%mod;\n				}\n			}\n\n			public long hash(int l, int r) {\n				if(l==0) {\n					return hash[r];\n				}\n				return ((hash[r]+mod-hash[l-1])*powDiv[l])%mod;\n			}\n\n		}\n\n	}\n}\n\n","hashing,number theory"
"import java.io.*;\nimport java.util.*;\npublic class Main2\n{\n	static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n	static StringTokenizer st;\n	static String ns()\n	{\n		while(st==null||(!st.hasMoreTokens()))\n		{	try {\n				st=new StringTokenizer(br.readLine());\n			} catch (IOException e) {\n				// TODO Auto-generated catch block\n				e.printStackTrace();\n			}\n		}\n		return st.nextToken();\n	}\n	static int ni()\n	{\n		return Integer.parseInt(ns());\n	}\n	public static void main(String[]args) throws Exception\n	{\n		int n=ni(),m=ni();\n		long time=System.currentTimeMillis();\n		int[]a=new int[n];\n		long sum=0;\n		for(int i=0; i<n; i++)\n		{\n			a[i]=ni();\n			sum+=a[i];\n		}\n		sum*=2;\n		sum%=m;\n		Random rn=new Random();\n		int teo,temp;\n		for(int i=0; i<n; i++)\n		{\n			teo=rn.nextInt(n);\n			temp=a[teo];\n			a[teo]=a[i];\n			a[i]=temp;\n		}\n		ArrayList<Integer> hol=new ArrayList<Integer>();\n		for(int i=0; i<n; i++)\n		{\n			if(((a[0]+a[i]+0L)*n)%m==sum)\n				hol.add((a[0]+a[i])%m);\n		}\n		Set<Integer> val=new HashSet<Integer>();\n		for(int i=0; i<n; i++)\n			val.add(a[i]);\n		for(int i=1; i<n&&(System.currentTimeMillis()-time<1.2e3); i++)\n		{\n			ArrayList<Integer> te=new ArrayList<Integer>();\n			for(int j:hol)\n				if(val.contains((j-a[i]+m)%m))\n					te.add(j);\n			hol=te;\n		}\n		System.out.println(hol.size());\n		StringBuilder out=new StringBuilder();\n		if(hol.size()>0)\n		{\n			Collections.sort(hol);\n			for(int i=0; i<hol.size()-1; i++)\n				out.append(hol.get(i)+"" "");\n			out.append(hol.get(hol.size()-1));\n			System.out.println(out);\n		}\n	}\n} ","hashing,number theory"
"//package bubble11;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.Random;\n\npublic class B {\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n	\n	void solve()\n	{\n		int n = ni(), mod = ni();\n		int[] a = na(n);\n		int[] b = new int[n];\n		for(int i = 0;i < n;i++){\n			b[i] = (a[0] + a[i]) % mod;\n		}\n		\n		RollingHashFactory rhf = new RollingHashFactory(2, 2*n+3, new Random(1));\n		RollingHash rh = new RollingHash(2*n+3, rhf);\n		for(int i = 0;i < n;i++){\n			rh.add(a[i]);\n		}\n		for(int i = 0;i < n;i++){\n			rh.add(a[i]+mod);\n		}\n		RollingHash rhr = new RollingHash(3*n+3, rhf);\n		for(int i = 0;i < n;i++){\n			rhr.add(a[n-1-i]+mod);\n		}\n		for(int i = 0;i < n;i++){\n			rhr.add(a[n-1-i]);\n		}\n		for(int i = 0;i < n;i++){\n			rhr.add(a[n-1-i]);\n		}\n		\n		long[] M = new long[2];\n		for(int j = 0;j < 2;j++){\n			for(int i = 0;i < n;i++){\n				M[j] = M[j] * rhf.muls[j] + 1;\n				M[j] %= rhf.mods[j];\n			}\n		}\n//		tr(a);\n//		tr(M);\n		\n		List<Integer> anss = new ArrayList<>();\n		long[] A = rh.query(0, 0+n);\n		for(int i = 0;i < n;i++){\n			// (i-n,i], [i,i+n)\n			long[] B = rhr.query(n-1-(i+n)+n, n-1-i+n);\n			long s = a[0] + mod + a[i];\n//			tr(A, B,s*M[0]-B[0], s, M[0]);\n			if(\n					(A[0] - (s * M[0] - B[0])) % rhf.mods[0] == 0 &&\n					(A[1] - (s * M[1] - B[1])) % rhf.mods[1] == 0\n					){\n				anss.add(b[i]);\n			}\n		}\n		out.println(anss.size());\n		Collections.sort(anss);\n		for(int x : anss){\n			out.print(x + "" "");\n		}\n	}\n	\n	public static class RollingHash\n	{\n		public RollingHashFactory rhf;\n		public long[][] buf;\n		public int p;\n		\n		public RollingHash(int bufsize, RollingHashFactory rhf)\n		{\n			buf = new long[rhf.deg][bufsize+1];\n			this.rhf = rhf;\n			this.p = 1;\n		}\n		\n		public void add(int c)\n		{\n			for(int i = 0;i < rhf.deg;i++)buf[i][p] = (buf[i][p-1]*rhf.muls[i]+c)%rhf.mods[i];\n			p++;\n		}\n		\n		public void addr(int c)\n		{\n			for(int i = 0;i < rhf.deg;i++)buf[i][p] = (buf[i][p-1]+rhf.powers[i][p-1]*c)%rhf.mods[i];\n			p++;\n		}\n		\n		public long queryTwin(int r)\n		{\n			return buf[0][r]<<32|buf[1][r];\n		}\n		\n		public long queryTwin(int l, int r)\n		{\n			assert l <= r;\n			assert rhf.deg == 2;\n			long h = 0;\n			for(int i = 0;i < rhf.deg;i++){\n				long v = (buf[i][r] - buf[i][l] * rhf.powers[i][r-l]) % rhf.mods[i];\n				if(v < 0)v += rhf.mods[i];\n				h = h<<32|v;\n			}\n			return h;\n		}\n		\n		public long[] query(int l, int r)\n		{\n			assert l <= r;\n			long[] h = new long[rhf.deg];\n			for(int i = 0;i < rhf.deg;i++){\n				h[i] = (buf[i][r] - buf[i][l] * rhf.powers[i][r-l]) % rhf.mods[i];\n				if(h[i] < 0)h[i] += rhf.mods[i];\n			}\n			return h;\n		}\n		\n		public static long add(long a, long b, int w, RollingHashFactory rhf)\n		{\n			assert rhf.deg == 2;\n			long high = ((a>>>32) * rhf.powers[0][w] + (b>>>32)) % rhf.mods[0];\n			long low = ((long)(int)a * rhf.powers[1][w] + (int)b) % rhf.mods[1];\n			return high<<32|low;\n		}\n	}\n	\n	public static class RollingHashFactory\n	{\n		public int[] mods;\n		public int[] muls;\n		public long[][] powers;\n		public int deg;\n		\n		public RollingHashFactory(int deg, int n, Random gen)\n		{\n			this.deg = deg;\n			mods = new int[deg];\n			muls = new int[deg];\n			for(int i = 0;i < deg;i++){\n				mods[i] = BigInteger.probablePrime(30, gen).intValue();\n				muls[i] = BigInteger.probablePrime(30, gen).intValue();\n			}\n			muls[0] = 100;\n			mods[0] = 1000000007;\n			powers = new long[deg][n+1];\n			for(int i = 0;i < deg;i++){\n				powers[i][0] = 1;\n				for(int j = 1;j <= n;j++){\n					powers[i][j] = powers[i][j-1] * muls[i] % mods[i];\n				}\n			}\n		}\n	}\n\n	\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new B().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n	\n	private char[][] nm(int n, int m)\n	{\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n	\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n	\n	private int ni()\n	{\n		int num = 0, b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","hashing,number theory"
"import java.io.*;\nimport java.util.*;\n\npublic class G {\n	int oo = (int)1e8;\n	\n	public static void main(String[] args) {\n		new G();\n	}\n\n	int SQRT;\n	int[] minTandemStart, minTandemEnd, sa, rsa, lcp;\n	boolean[] primes;\n	RMQ query3RMQ, lcpRMQ;\n	int[] trailingZeros, highestOneBit;\n	String str;\n	\n	public G() {\n		FastScanner fs = new FastScanner();\n		PrintWriter out = new PrintWriter(System.out);\n		System.err.println("""");\n\n		trailingZeros = new int[200200];\n		highestOneBit = new int[200200];\n		for(int i = 1; i < 200200; i++) {\n			highestOneBit[i] = Integer.highestOneBit(i);\n			trailingZeros[i] = Integer.numberOfTrailingZeros(highestOneBit[i]);\n		}\n		\n		doPrimes();\n		\n		int n = fs.nextInt();\n		SQRT = (int)Math.sqrt(n);\n		str = fs.next();\n		FastSuffixArray fsa = new FastSuffixArray();\n		sa = fsa.suffixArray(str.toCharArray());\n		rsa = new int[sa.length];\n		lcp = fsa.lcp(sa, str.toCharArray());\n		lcpRMQ = new RMQ(lcp);\n		for(int i = 0; i < sa.length; i++) rsa[sa[i]] = i;\n		\n		TandemRepeats tr = new TandemRepeats(str);\n		minTandemStart = tr.min;\n		TandemRepeats tr2 = new TandemRepeats(reverse(str));\n		minTandemEnd = reverse(tr2.min);\n		\n		int[] query3Values = new int[n];\n		for(int i = 0; i < n; i++) {\n			minTandemStart[i] <<= 1;\n			minTandemEnd[i] <<= 1;\n		}\n		for(int i = 0; i < n; i++) {\n			query3Values[i] = i+minTandemStart[i];\n		}\n		query3RMQ = new RMQ(query3Values);\n		\n		int[][] pref = new int[26][n];\n		for(int i = n-1; i >= 0; i--) {\n			for(int j = 0; j < 26 && i+1 < n; j++) pref[j][i] = pref[j][i+1];\n			pref[str.charAt(i)-'a'][i]++;\n		}\n		\n		int Q = fs.nextInt();\n		for(int qq = 1; qq <= Q; qq++) {\n			int L = fs.nextInt()-1, R = fs.nextInt()-1;\n			\n			//case -1\n			boolean good = false;\n			for(int i = 0; i < 26; i++) {\n				int sum = pref[i][L];\n				if(R + 1 < n) sum -= pref[i][R+1];\n				if(sum > 1) good = true;\n			}\n			if(!good) {\n				out.println(-1);\n				continue;\n			}\n			\n			//case 1:\n			boolean ans1 = false;\n			int N = R-L+1;\n			for(int div = 1; div*div <= N; div++) {\n				if(N % div != 0) continue;\n				int nd = N/div;\n				if(primes[nd] && check(L, R, div)) {\n					ans1 = true;\n				}\n				if(!ans1 && primes[div] && check(L, R, nd)) ans1 = true;\n				if(ans1) break;\n			}\n			if(ans1) {\n				out.println(1);\n				continue;\n			}\n			\n			//case 2:\n			boolean ans2 = false;\n			if(minTandemStart[L] < oo && L+minTandemStart[L]-1 <= R) {\n				ans2 = true;\n			}\n			if(minTandemEnd[R] < oo && R-minTandemEnd[R]+1 >= L) {\n				ans2 = true;\n			}\n			if(!ans2 && isBorder(L, R)) {\n				ans2 = true;\n			}\n			if(ans2) {\n				out.println(2);\n				continue;\n			}\n			\n			//case 3:\n			boolean ans3 = false;\n			{ //first character\n				int idx = str.charAt(L)-'a';\n				int sum = pref[idx][L];\n				if(R+1 < n) sum -= pref[idx][R+1];\n				if(sum > 1) ans3 = true;\n			}\n			{ //last character\n				int idx = str.charAt(R)-'a';\n				int sum = pref[idx][L];\n				if(R+1 < n) sum -= pref[idx][R+1];\n				if(sum > 1) ans3 = true;\n			}\n			{ //BAAC\n				int min = query3RMQ.query(L, R);\n				if(min <= R) ans3 = true;\n			}\n			if(ans3) {\n				out.println(3);\n				continue;\n			}\n			\n			out.println(4);\n		}\n\n		out.close();\n	}\n	\n	boolean check(int L, int R, int div) {\n		int minPos = rsa[L], maxPos = rsa[L];\n		char beg = str.charAt(L);\n		for(int j = L+div; j <= R; j += div) {\n			if(str.charAt(j) != beg) return false;\n			minPos = min(minPos, rsa[j]);\n			maxPos = max(maxPos, rsa[j]);\n		}\n		int lcp = lcpRMQ.query(minPos, maxPos-1);\n		if(lcp >= div) {\n			return true;\n		}\n		return false;\n	}\n	\n	Random rand = new Random();\n	boolean isBorder(int L, int R) {\n		for(int len = 1; len < SQRT; len++) {\n			int ptsTo = R-len+1;\n			if(ptsTo <= L+len-1) continue;\n			int min = min(rsa[L], rsa[ptsTo]);\n			int max = max(rsa[L], rsa[ptsTo]);\n			int lcp = lcpRMQ.query(min, max-1);\n			if(lcp >= len) {\n				return true;\n			}\n		}\n		int st = max(0, rsa[L]-SQRT/2-1);\n		int en = min(sa.length-1, rsa[L]+SQRT/2+1);\n		int him = rsa[L];\n		\n		for(int i = him-1; i >= st; i--) {\n			int idx = sa[i];\n			if(L <= idx && idx <= R) {}\n			else continue;\n			int min = min(i, him);\n			int max = max(i, him);\n			int lcp = lcpRMQ.query(min, max-1);\n			if(lcp < SQRT) break;\n			\n			if(idx+lcp-1 < R) continue;\n			int size = R-idx+1;\n			if(L+size-1 >= idx) continue;\n			return true;\n		}\n		for(int i = him+1; i <= en; i++) {\n			int idx = sa[i];\n			if(L <= idx && idx <= R) {}\n			else continue;\n			int min = min(i, him);\n			int max = max(i, him);\n			int lcp = lcpRMQ.query(min, max-1);\n			if(lcp < SQRT) break;\n			\n			if(idx+lcp-1 < R) continue;\n			int size = R-idx+1;\n			if(L+size-1 >= idx) continue;\n			return true;\n		}\n		\n		return false;\n	}\n	\n	class RMQ {\n		int[] vs;\n		int[][] lift;\n\n		public RMQ(int[] vs) {\n			this.vs = vs;\n			int n = vs.length;\n			int maxlog = Integer.numberOfTrailingZeros(Integer.highestOneBit(n)) + 1;\n			lift = new int[maxlog][n];\n			for (int i = 0; i < n; i++)\n				lift[0][i] = vs[i];\n			int lastRange = 1;\n			for (int lg = 1; lg < maxlog; lg++) {\n				for (int i = 0; i < n; i++) {\n					lift[lg][i] = min(lift[lg - 1][i], lift[lg - 1][min(i + lastRange, n - 1)]);\n				}\n				lastRange <<= 1;\n			}\n		}\n\n		public int query(int low, int hi) {\n			if(hi < low) return 0;\n			int range = hi - low + 1;\n			int exp = highestOneBit[range];\n			int lg = trailingZeros[exp];\n			return min(lift[lg][low], lift[lg][hi - exp + 1]);\n		}\n	}\n\n	class FastSuffixArray {\n		public int[] suffixArray(char[] S) {\n			int n = S.length;\n			Integer[] order = new Integer[n];\n			for (int i = 0; i < n; i++)\n				order[i] = n - 1 - i;\n\n			Arrays.sort(order, (a, b) -> Character.compare(S[a], S[b]));\n\n			int[] sa = new int[n];\n			int[] classes = new int[n];\n			for (int i = 0; i < n; i++) {\n				sa[i] = order[i];\n				classes[i] = S[i];\n			}\n\n			for (int len = 1; len < n; len <<= 1) {\n				int[] c = classes.clone();\n				for (int i = 0; i < n; i++) {\n					classes[sa[i]] = i > 0 && c[sa[i - 1]] == c[sa[i]] && sa[i - 1] + len < n && c[sa[i - 1] + len / 2] == c[sa[i] + len / 2] ? classes[sa[i - 1]] : i;\n				}\n				int[] cnt = new int[n];\n				for (int i = 0; i < n; i++)\n					cnt[i] = i;\n				int[] s = sa.clone();\n				for (int i = 0; i < n; i++) {\n					int s1 = s[i] - len;\n					if (s1 >= 0)\n						sa[cnt[classes[s1]]++] = s1;\n				}\n			}\n			return sa;\n		}\n\n		public int[] lcp(int[] sa, char[] s) {\n			int n = sa.length;\n			int[] rank = new int[n];\n			for (int i = 0; i < n; i++)\n				rank[sa[i]] = i;\n			int[] lcp = new int[n - 1];\n			for (int i = 0, h = 0; i < n; i++) {\n				if (rank[i] < n - 1) {\n					for (int j = sa[rank[i] + 1]; max(i, j) + h < s.length && s[i + h] == s[j + h]; ++h)\n						;\n					lcp[rank[i]] = h;\n					if (h > 0)\n						--h;\n				}\n			}\n			return lcp;\n		}\n	}\n\n	int MAX = 7500000;\n	class TandemRepeats {\n		Event[] list = new Event[MAX];\n		int ptr2 = 0;\n		int[] min;\n		TandemRepeats(String str) {\n			ptr2 = 0;\n			findRepetitions(str, 0, str.length()-1);\n			Arrays.sort(list, 0, ptr2);\n			min = new int[str.length()];\n			Arrays.fill(min, oo);\n\n			int n = str.length();\n			BIT bit = new BIT(n+1);\n			int ptr = 0;\n			for(int i = 0; i < str.length(); i++) {\n				while(ptr < ptr2) {\n					Event now = list[ptr];\n					if(now.pos <= i) {\n						if(now.type == 0) bit.update(now.val, 1);\n						else bit.update(now.val, -1);\n						ptr++;\n					} else break;\n				}\n				int pos = bit.getKth(0);\n				if(pos <= n) min[i] = min(min[i], pos);\n			}\n		}\n\n		//Main-Lorentz algorithm\n		void findRepetitions(String str, int L, int R) {\n			int n = R-L+1;\n			if(n < 2 || R < L) return;\n\n			String u = str.substring(0, n/2);\n			String v = str.substring(n/2);\n			findRepetitions(u, L, L+u.length()-1); findRepetitions(v, L+u.length(), R);\n\n			int[] z1 = zValues(reverse(u));\n			int[] z2 = zValues(v + ""#"" + u);\n			int[] z3 = zValues(reverse(u) + ""#"" + reverse(v));\n			int[] z4 = zValues(v);\n\n			int uLen = u.length(), vLen = v.length();\n			for(int cntr = 0; cntr < n; cntr++) {\n				int totLen, k1, k2;\n				if(cntr < uLen) {\n					totLen = uLen-cntr;\n					k1 = getIdx(z1, uLen-cntr);\n					k2 = getIdx(z2, vLen+1+cntr);\n\n					if(k1+k2 >= totLen) {\n						int min = findSmall1(k1, k2, totLen);\n						int max = findLarge1(k1, k2, totLen);\n						if(min < 0 || max < 0 || min > k1 || max > k1) continue;\n						int start = max(L, L+cntr-max);\n						int end = min(L+cntr-1, L+cntr-min);\n\n						if(start <= end) {\n							list[ptr2++] = (new Event(0, start, totLen));\n							list[ptr2++] = (new Event(1, end+1, totLen));\n						}\n					}\n\n				}\n				else {\n					totLen = cntr-uLen+1;\n					k1 = getIdx(z3, uLen + 1 + vLen - 1 - (cntr - uLen));\n					k2 = getIdx(z4, (cntr - uLen) + 1);\n\n					if(k1+k2 >= totLen && k1 > 0) {\n						int min = findSmall2(k1, k2, totLen);\n						int max = findLarge1(k1, k2, totLen);\n						if(min < 1 || max < 1 || min > k1 || max > k1) continue;\n						int start = max(L, L+n/2-1 - max + 1);\n						int end = min(L+n/2-1, L+n/2-1-min+1);\n\n						if(start <= end) {\n							list[ptr2++] = (new Event(0, start, totLen));\n							list[ptr2++] = (new Event(1, end+1, totLen));\n						}\n					}\n				}\n			}\n\n		}\n		\n		int findSmall1(int k1, int k2, int len) {\n			if(k2 >= len) return 0;\n			return len-k2;\n		}\n		int findSmall2(int k1, int k2, int len) {\n			if(k2 >= len-1) return 1;\n			return min(k1, len - k2);\n		}\n		int findLarge1(int k1, int k2, int len) {\n			if(k1 < len) return k1;\n			return len;\n		}\n\n		class Event implements Comparable<Event> {\n			int type, pos, val;\n			Event(int t, int p, int v) {\n				type = t; val = v;\n				pos = p;\n			}\n			public int compareTo(Event e) {\n				int comp = Integer.compare(pos, e.pos);\n				if(comp == 0) comp = Integer.compare(e.type, type);\n				return comp;\n			}\n			public String toString() {\n				return String.format(""Pos = %d Type = %d V = %d"", pos, type, val);\n			}\n		}\n\n		int getIdx(int[] a, int i) {\n			if(i >= 0 && i < a.length) return a[i];\n			return 0;\n		}\n\n		int[] zValues(String str) {\n			int n = str.length();  char[] s = str.toCharArray();\n			int[] z = new int[n];  z[0] = n;\n			int L = 0, R = 0;\n			int[] left = new int[n], right = new int[n];\n			for(int i = 1; i < n; ++i) {\n				if(i > R) {\n					L = R = i;\n					while(R < n && s[R-L] == s[R]) R++;\n					z[i] = R - L;  R--;\n				} else {\n					int k = i-L;\n					if(z[k] < R-i+1) z[i] = z[k];\n					else {\n						L = i;\n						while(R < n && s[R-L] == s[R]) R++;\n						z[i] = R - L;  R--;\n					}\n				}\n				left[i] = L;  right[i] = R;\n			}\n			return z;\n		}\n\n\n		void add(TreeMap<Integer, Integer> map, int x) {\n			map.put(x, map.getOrDefault(x, 0)+1);\n		}\n		void rem(TreeMap<Integer, Integer> map, int x) {\n			int fr = map.get(x)-1;\n			if(fr == 0) map.remove(x);\n			else map.put(x, fr);\n		}\n	}\n	\n	void doPrimes() {\n		primes = new boolean[200200];\n		Arrays.fill(primes, true);\n		primes[0] = primes[1] = false;\n		for(int i = 2; i < primes.length; i++) {\n			if(!primes[i]) continue;\n			for(int j = i+i; j < primes.length; j += i) primes[j] = false;\n		}\n	}\n	\n	String reverse(String s) {\n		return new StringBuilder(s).reverse().toString();\n	}\n	int[] reverse(int[] a) {\n		int n = a.length;\n		int[] res = new int[n];\n		for(int i = 0, j = n-1; i < n; i++, j--) {\n			res[i] = a[j];\n		}\n		return res;\n	}\n\n	int min(int a, int b) {\n		return a < b ? a : b;\n	}\n	int max(int a, int b) {\n		return a > b ? a : b;\n	}\n	\n	class BIT {\n		int n, hn;\n		int[] tree;\n		\n		public BIT(int n) {\n			this.n = n;\n			tree = new int[n + 2];\n			hn = Integer.highestOneBit(n);\n		}\n		\n		int read(int i) {\n			i++;\n			int sum = 0;\n			while (i > 0) {\n				sum += tree[i];\n				i -= i & -i;\n			}\n			return sum;\n		}\n		\n		void update(int i, int val) {\n			i++;\n			while (i <= n) {\n				tree[i] += val;\n				i += i & -i;\n			}\n		}\n\n		// if the BIT is a freq array, returns the\n		// index of the kth item, or n if there are fewer\n		// than k items.\n		int getKth(int k) {\n			int e=hn, o=0;\n			for (; e!=0; e>>=1) {\n				if (e+o<=n && tree[e+o]<=k) {\n					k-=tree[e+o];\n					o+=e;\n				}\n			}\n			return o;\n		}\n		\n	}\n	\n	class FastScanner {\n		public int BS = 1<<16;\n		public char NC = (char)0;\n		byte[] buf = new byte[BS];\n		int bId = 0, size = 0;\n		char c = NC;\n		double num = 1;\n		BufferedInputStream in;\n\n		public FastScanner() {\n			in = new BufferedInputStream(System.in, BS);\n		}\n\n		public FastScanner(String s) {\n			try {\n				in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n			}\n			catch (Exception e) {\n				in = new BufferedInputStream(System.in, BS);\n			}\n		}\n\n		public char nextChar(){\n			while(bId==size) {\n				try {\n					size = in.read(buf);\n				}catch(Exception e) {\n					return NC;\n				}                \n				if(size==-1)return NC;\n				bId=0;\n			}\n			return (char)buf[bId++];\n		}\n\n		public int nextInt() {\n			return (int)nextLong();\n		}\n\n		public long nextLong() {\n			num=1;\n			boolean neg = false;\n			if(c==NC)c=nextChar();\n			for(;(c<'0' || c>'9'); c = nextChar()) {\n				if(c=='-')neg=true;\n			}\n			long res = 0;\n			for(; c>='0' && c <='9'; c=nextChar()) {\n				res = (res<<3)+(res<<1)+c-'0';\n				num*=10;\n			}\n			return neg?-res:res;\n		}\n\n		public double nextDouble() {\n			double cur = nextLong();\n			return c!='.' ? cur:cur+nextLong()/num;\n		}\n\n		public String next() {\n			StringBuilder res = new StringBuilder();\n			while(c<=32)c=nextChar();\n			while(c>32) {\n				res.append(c);\n				c=nextChar();\n			}\n			return res.toString();\n		}\n\n		public String nextLine() {\n			StringBuilder res = new StringBuilder();\n			while(c<=32)c=nextChar();\n			while(c!='\n') {\n				res.append(c);\n				c=nextChar();\n			}\n			return res.toString();\n		}\n\n		public boolean hasNext() {\n			if(c>32)return true;\n			while(true) {\n				c=nextChar();\n				if(c==NC)return false;\n				else if(c>32)return true;\n			}\n		}\n		\n		public int[] nextIntArray(int n) {\n			int[] res = new int[n];\n			for(int i = 0; i < n; i++) res[i] = nextInt();\n			return res;\n		}\n		\n	}\n\n}","data structures,divide and conquer,hashing,string suffix structures,strings"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class NetworkSafety {\n    \n    int N = (int) 5e5 + 10;\n    int MOD = (int) 1e9 + 7;\n    \n    int sz = 0;\n    int[] parent = new int[N];\n    \n    void solve() {\n        int n = in.nextInt(), m = in.nextInt(), k = in.nextInt();\n        long[] c = new long[n];\n        for (int i = 0; i < n; i++) c[i] = in.nextLong();\n        int[] fr = new int[m], to = new int[m];\n        for (int i = 0; i < m; i++) {\n            fr[i] = in.nextInt() - 1;\n            to[i] = in.nextInt() - 1;\n        }\n        \n        long[] p2 = new long[N];\n        p2[0] = 1;\n        for (int i = 1; i < N; i++) p2[i] = 2 * p2[i - 1] % MOD;\n        \n        Map<Long, List<Integer>> x_to_edges = new HashMap<>();\n        for (int i = 0; i < m; i++) {\n            int u = fr[i], v = to[i];\n            long x = c[u] ^ c[v];\n            if (!x_to_edges.containsKey(x)) {\n                List<Integer> edges = new ArrayList<>();\n                edges.add(i);\n                x_to_edges.put(x, edges);\n            } else {\n                List<Integer> edges = x_to_edges.get(x);\n                edges.add(i);\n            }\n        }\n        \n        long ans = 0;\n        Arrays.fill(parent, -1);\n        for (long x : x_to_edges.keySet()) {\n            sz = n;\n            List<Integer> edges = x_to_edges.get(x);\n            for (int i : edges) {\n                int u = fr[i], v = to[i];\n                union(u, v);\n            }\n            ans = (ans + p2[sz]) % MOD;\n            for (int i : edges) {\n                int u = fr[i], v = to[i];\n                parent[u] = -1;\n                parent[v] = -1;\n            }\n        }\n        ans = (ans + ((1L << k) - x_to_edges.size()) % MOD * p2[n] % MOD) % MOD;       \n        out.println(ans);\n    }\n    \n    void union(int i, int j) {\n        int u = find(i), v = find(j);\n        if (u == v) return;\n        if (parent[u] > parent[v]) {\n            int tmp = u; u = v; v = tmp;\n        }\n        parent[u] += parent[v];\n        parent[v] = u;\n        sz--;\n    }\n    \n    int find(int i) {\n        if (parent[i] < 0) return i;\n        return parent[i] = find(parent[i]);\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new NetworkSafety().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n","dfs and similar,dsu,graphs,math,sortings"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\npublic class _507C {\n\n	static long mod=1_000_000_007;\n	\n	public static void main(String[] args) {\n		FastScanner fs=new FastScanner();\n		int n=fs.nextInt(), m=fs.nextInt(), k=fs.nextInt();\n		HashMap<Long, ArrayList<Edge>> map=new HashMap<>();\n		long[] values=new long[n];\n		for (int i=0; i<values.length; i++) values[i]=fs.nextLong();\n		for (int i=0; i<m; i++) {\n			int a=fs.nextInt()-1, b=fs.nextInt()-1;\n			if (!map.containsKey(values[a]^values[b])) map.put(values[a]^values[b], new ArrayList<>());\n			map.get(values[a]^values[b]).add(new Edge(a, b));\n		}\n		long freeMoves=(1l<<k)-map.size();\n		long choices=twoPow(n);\n		long total=freeMoves%mod*choices%mod;\n		RestorableDisjointSet dj=new RestorableDisjointSet(n);\n		for (long val:map.keySet()) {\n			ArrayList<Edge> edges=map.get(val);\n			dj.save();\n			int joins=0;\n			for (Edge e:edges) {\n				if (dj.find(e.from)==dj.find(e.to)) continue;\n				dj.union(e.from, e.to);\n				joins++;\n			}\n			dj.restore();\n			total=(total+twoPow(n-joins))%mod;\n		}\n		System.out.println(total);\n	}\n	\n	static long twoPow(long exp) {\n		if (exp==0) return 1;\n		long half=twoPow(exp/2);\n		if (exp%2==0) return half*half%mod;\n		return half*half%mod*2%mod;\n	}\n	\n\n	static class Edge {\n		int from, to;\n		public Edge(int from, int to) {\n			this.from=from;\n			this.to=to;\n		}\n	}\n\n	static class FastScanner {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n\n		String next() {\n			while (!st.hasMoreElements())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n	}\n\n	// Disjoint set but can set a save point and restore to it\n	// Do not save twice in a row without restoring first\n	static class RestorableDisjointSet {\n		int[] s, s2, vs;\n		int curv;\n		public RestorableDisjointSet(int n) {\n			s=new int[n];\n			s2=new int[n];\n			vs=new int[n];\n			Arrays.fill(s, -1);\n			curv=-1;\n		}\n		void save() {\n			curv=1-curv;\n		}\n		void restore() {\n			curv*=-1;\n		}\n		int find(int i) {\n			return get(i)<0 ? i : set(i, find(get(i)));\n		}\n		int get(int i) {\n			return vs[i]==curv ? s2[i] : s[i];\n		}\n		int set(int i, int v) {\n			if (curv<0)\n				return s[i]=v;\n			vs[i]=curv;\n			return s2[i]=v;\n		}\n		void union(int a, int b) {\n			if (get(a=find(a))==get(b=find(b)))\n				set(a, get(a)-1);\n			if (get(a)<=get(b))\n				set(b, a);\n			else\n				set(a, b);\n		}\n	}\n\n}\n","dfs and similar,dsu,graphs,math,sortings"
"import java.util.*;\nimport java.io.*;\n\npublic class Main\n{\n	static long mod = 1000000007;\n	static HashMap<Long, ArrayList<Pair>> map = new HashMap<>();\n\n	public static void main(String[] args)\n	{\n		FastReader reader = new FastReader();\n		PrintWriter writer = new PrintWriter(System.out);\n\n		int n = reader.nextInt();\n		int m = reader.nextInt();\n		int k = reader.nextInt();\n\n		Dsu set = new Dsu(n);\n\n		long[] key = new long[n];\n		for (int i=0; i<n; i++)\n			key[i] = reader.nextLong();\n\n		for (int i=0; i<m; i++)\n		{\n			int u = reader.nextInt()-1;\n			int v = reader.nextInt()-1;\n\n			long temp = key[u]^key[v];\n\n			if (!map.containsKey(temp))\n				map.put(temp, new ArrayList<Pair>());\n\n			ArrayList<Pair> got = map.get(temp);\n			got.add(new Pair(u, v));\n			map.put(temp, got);\n		}\n\n		long ans = (1L<<k) - map.size();\n		ans %= mod;\n\n		ans *= pow(2, n);\n		ans %= mod;\n\n		for (Map.Entry<Long, ArrayList<Pair>> entry : map.entrySet())\n		{\n			int count = 0;	\n			ArrayList<Pair> temp = entry.getValue();\n			\n			for (Pair p : temp)\n				count += set.union(p.a, p.b);\n\n			ans += pow(2, n-count);\n\n			set.refresh(temp);\n		}\n\n		ans %= mod;\n\n		writer.print(ans);\n		writer.close();\n	}\n\n	static long pow(long a, long p)\n	{\n		if (p==0)\n			return 1L;\n		else\n		{\n			long got = pow(a, p/2);\n			got *= got;\n			got %= mod;\n\n			if (p%2 == 1)\n				got *= a;\n\n			return got%mod;\n		}\n	}\n\n	static class FastReader\n	{\n		BufferedReader br;\n		StringTokenizer st;\n\n		public FastReader()\n		{\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		String next()\n		{\n			while (st == null || !st.hasMoreElements())\n			{\n				try\n				{\n					st = new StringTokenizer(br.readLine());\n				}\n				catch (IOException e)\n				{\n					e.printStackTrace();\n				}\n			}\n			return st.nextToken();\n		}\n\n		int nextInt()\n		{\n			return Integer.parseInt(next());\n		}\n\n		long nextLong()\n		{\n			return Long.parseLong(next());\n		}\n\n		double nextDouble()\n		{\n			return Double.parseDouble(next());\n		}\n\n		String nextLine()\n		{\n			String str = """";\n			try\n			{\n				str = br.readLine();\n			}\n			catch (IOException e)\n			{\n				e.printStackTrace();\n			}\n			return str;\n		}\n	}\n}\n\nclass Dsu\n{\n	int[] parent;\n	int[] size;\n\n	Dsu(int n)\n	{\n		parent = new int[n];\n		size = new int[n];\n\n		for (int i=0; i<n; i++)\n		{\n			parent[i] = i;\n			size[i] = 1;\n		}\n	}\n\n	int findRoot(int u)\n	{\n		while (u != parent[u])\n		{\n			parent[u] = parent[parent[u]];\n			u = parent[u];\n		}\n\n		return u;\n	}\n\n	int union (int u, int v)\n	{\n		int pu = findRoot(u);\n		int pv = findRoot(v);\n\n		if (pu == pv)\n			return 0;\n		else\n		{\n			if (size[u] > size[v])\n			{\n				int temp = u;\n				u = v;\n				v = temp;\n			}\n\n			parent[pu] = parent[pv];\n			size[pv] += size[pu];\n\n			return 1;\n		}\n	}\n\n	void refresh(ArrayList<Pair> list)\n	{\n		for (Pair p : list)\n		{\n			size[p.a] = 1;\n			size[p.b] = 1;\n\n			parent[p.a] = p.a;\n			parent[p.b] = p.b;\n		}\n	}\n\n}\n\nclass Pair\n{\n	int a;\n	int b;\n\n	Pair(int a, int b)\n	{\n		this.a = a;\n		this.b = b;\n	}\n}","dfs and similar,dsu,graphs,math,sortings"
"import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Main {\n\n    class E {\n        int a;\n        int b;\n        long xor;\n\n        E() {\n            a = nextInt() - 1;\n            b = nextInt() - 1;\n        }\n\n        long getXor() {\n            return xor;\n        }\n    }\n\n    private int nextInt() {\n        int r = 0;\n        try {\n            int c = System.in.read();\n            while (c < '0' || c > '9') {\n                c = System.in.read();\n            }\n            while (c >= '0' && c <= '9') {\n                r = r * 10 + c - '0';\n                c = System.in.read();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return r;\n    }\n\n    private long nextLong() {\n        long r = 0;\n        try {\n            int c = System.in.read();\n            while (c < '0' || c > '9') {\n                c = System.in.read();\n            }\n            while (c >= '0' && c <= '9') {\n                r = r * 10 + c - '0';\n                c = System.in.read();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return r;\n    }\n\n    private void resolve() {\n        int n = nextInt();\n        int m = nextInt();\n        int k = nextInt();\n        long[] x = new long[n];\n        long[] xx = new long[n];\n        int[] ff = new int[n];\n        E[] es = new E[m];\n        for (int i = 0; i < n; i++) {\n            x[i] = nextLong();\n            xx[i] = -1;\n        }\n        for (int i = 0; i < m; i++) {\n            es[i] = new E();\n            es[i].xor = x[es[i].a] ^ x[es[i].b];\n        }\n        Arrays.sort(es, Comparator.comparingLong(E::getXor));\n        long mod = 1000000007;\n        long res = 0;\n        long xor = -1;\n        int ct = n;\n        int diff = 0;\n        for (int i = 0; i < m; i++) {\n            if (es[i].xor != xor) {\n                if (xor != -1) {\n                    res = (res + pow(2, ct, mod)) % mod;\n                }\n                diff++;\n                ct = n;\n                xor = es[i].xor;\n            }\n            int fa = get(ff, xx, es[i].a, xor);\n            int fb = get(ff, xx, es[i].b, xor);\n            if (fa != fb) {\n                ff[fa] = fb;\n                xx[fa] = xor;\n                ct--;\n            }\n        }\n        if (m > 0) {\n            res = (res + pow(2, ct, mod)) % mod;\n        }\n        res = (res + (pow(2, k, mod) + mod - diff) % mod * pow(2, n, mod)) % mod;\n        System.out.println(res);\n    }\n\n    private int get(int[] ff, long[] xx, int k, long xor) {\n        if (xx[k] != xor) {\n            return k;\n        }\n        return ff[k] = get(ff, xx, ff[k], xor);\n    }\n\n    private long pow(long v, long k, long mod) {\n        if (k == 0) {\n            return 1;\n        }\n        long t = pow(v, k / 2, mod);\n        t = t * t % mod;\n        if ((k & 1) == 1) {\n            t = t * v % mod;\n        }\n        return t;\n    }\n\n    public static void main(String[] args) {\n        new Main().resolve();\n    }\n}","dfs and similar,dsu,graphs,math,sortings"
"import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	static class TaskAdapter implements Runnable {\n		@Override\n		public void run() {\n			long startTime = System.currentTimeMillis();\n			InputStream inputStream = System.in;\n			OutputStream outputStream = System.out;\n			Input in = new Input(inputStream);\n			Output out = new Output(outputStream);\n			BSubwayPursuit solver = new BSubwayPursuit();\n			solver.solve(1, in, out);\n			out.close();\n			System.err.println(System.currentTimeMillis()-startTime+""ms"");\n		}\n	}\n\n	public static void main(String[] args) throws Exception {\n		Thread thread = new Thread(null, new TaskAdapter(), """", 1<<28);\n		thread.start();\n		thread.join();\n	}\n\n	static class BSubwayPursuit {\n		Random rand = new Random();\n		InputReader in;\n		Output pw;\n		long n;\n		long k;\n		long l;\n		long r;\n\n		public BSubwayPursuit() {\n		}\n\n		public boolean bsearch() {\n			boolean equal = false;\n			while((r-l)>k<<2) {\n				long mid = r+l >> 1;\n				pw.println(l, mid);\n				pw.flush();\n				boolean valid = in.next().charAt(0)=='Y';\n				if(valid) {\n					r = mid;\n				}else {\n					l = mid+1;\n				}\n				if(l==mid&&valid) {\n					equal = true;\n				}\n				updateRange();\n			}\n			return equal;\n		}\n\n		public void updateRange() {\n			r += k;\n			l -= k;\n			r = Math.min(r, n);\n			l = Math.max(l, 1);\n		}\n\n		public long randLong() {\n			long a = rand.nextInt(), b = rand.nextInt();\n			return Math.abs(((a^(b >>> 16))<<32)|((a >>> 16)^b));\n		}\n\n		public long rand() {\n			return randLong()%(r-l+1)+l;\n		}\n\n		public void solve(int kase, InputReader in, Output pw) {\n			this.in = in;\n			this.pw = pw;\n			n = in.nextLong();\n			k = in.nextInt();\n			l = 1;\n			r = n;\n			do {\n				if(bsearch()) {\n					break;\n				}\n//				Utilities.Debug.dbg(l, r);\n				long query = rand();\n				pw.println(query, query);\n				pw.flush();\n				updateRange();\n			} while(in.next().charAt(0)=='N');\n		}\n\n	}\n\n	static interface InputReader {\n		String next();\n\n		int nextInt();\n\n		long nextLong();\n\n	}\n\n	static class Utilities {\n		public static class Debug {\n			public static final boolean LOCAL = System.getProperty(""ONLINE_JUDGE"")==null;\n\n			private static <T> String ts(T t) {\n				if(t==null) {\n					return ""null"";\n				}\n				try {\n					return ts((Iterable) t);\n				}catch(ClassCastException e) {\n					if(t instanceof int[]) {\n						String s = Arrays.toString((int[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof long[]) {\n						String s = Arrays.toString((long[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof char[]) {\n						String s = Arrays.toString((char[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof double[]) {\n						String s = Arrays.toString((double[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof boolean[]) {\n						String s = Arrays.toString((boolean[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}\n					try {\n						return ts((Object[]) t);\n					}catch(ClassCastException e1) {\n						return t.toString();\n					}\n				}\n			}\n\n			private static <T> String ts(T[] arr) {\n				StringBuilder ret = new StringBuilder();\n				ret.append(""{"");\n				boolean first = true;\n				for(T t: arr) {\n					if(!first) {\n						ret.append("", "");\n					}\n					first = false;\n					ret.append(ts(t));\n				}\n				ret.append(""}"");\n				return ret.toString();\n			}\n\n			private static <T> String ts(Iterable<T> iter) {\n				StringBuilder ret = new StringBuilder();\n				ret.append(""{"");\n				boolean first = true;\n				for(T t: iter) {\n					if(!first) {\n						ret.append("", "");\n					}\n					first = false;\n					ret.append(ts(t));\n				}\n				ret.append(""}"");\n				return ret.toString();\n			}\n\n			public static void dbg(Object... o) {\n				if(LOCAL) {\n					System.err.print(""Line #""+Thread.currentThread().getStackTrace()[2].getLineNumber()+"": ["");\n					for(int i = 0; i<o.length; i++) {\n						if(i!=0) {\n							System.err.print("", "");\n						}\n						System.err.print(ts(o[i]));\n					}\n					System.err.println(""]"");\n				}\n			}\n\n		}\n\n	}\n\n	static class Output implements Closeable, Flushable {\n		public StringBuilder sb;\n		public OutputStream os;\n		public int BUFFER_SIZE;\n		public String lineSeparator;\n\n		public Output(OutputStream os) {\n			this(os, 1<<16);\n		}\n\n		public Output(OutputStream os, int bs) {\n			BUFFER_SIZE = bs;\n			sb = new StringBuilder(BUFFER_SIZE);\n			this.os = new BufferedOutputStream(os, 1<<17);\n			lineSeparator = System.lineSeparator();\n		}\n\n		public void print(String s) {\n			sb.append(s);\n			if(sb.length()>BUFFER_SIZE >> 1) {\n				flushToBuffer();\n			}\n		}\n\n		public void println(Object... o) {\n			for(int i = 0; i<o.length; i++) {\n				if(i!=0) {\n					print("" "");\n				}\n				print(String.valueOf(o[i]));\n			}\n			println();\n		}\n\n		public void println() {\n			sb.append(lineSeparator);\n		}\n\n		private void flushToBuffer() {\n			try {\n				os.write(sb.toString().getBytes());\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n			sb = new StringBuilder(BUFFER_SIZE);\n		}\n\n		public void flush() {\n			try {\n				flushToBuffer();\n				os.flush();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n		public void close() {\n			flush();\n			try {\n				os.close();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n	}\n\n	static class Input implements InputReader {\n		BufferedReader br;\n		StringTokenizer st;\n\n		public Input(InputStream is) {\n			this(is, 1<<20);\n		}\n\n		public Input(InputStream is, int bs) {\n			br = new BufferedReader(new InputStreamReader(is), bs);\n			st = new StringTokenizer("""");\n		}\n\n		public boolean hasNext() {\n			try {\n				while(st==null||!st.hasMoreTokens()) {\n					String s = br.readLine();\n					if(s==null) {\n						return false;\n					}\n					st = new StringTokenizer(s);\n				}\n				return true;\n			}catch(Exception e) {\n				return false;\n			}\n		}\n\n		public String next() {\n			if(!hasNext()) {\n				throw new InputMismatchException();\n			}\n			return st.nextToken();\n		}\n\n		public int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n		public long nextLong() {\n			return Long.parseLong(next());\n		}\n\n	}\n}\n\n","binary search,interactive,probabilities"
"import java.util.*;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class D {\n\n	public static void main(String[] args) {\n		Scanner s=new Scanner(System.in);\n		long n=s.nextLong();\n		int k=s.nextInt();\n		long i=1,j=n;\n		String input="""";\n		if(i==j) {\n			System.out.println(i+"" ""+i);\n			return;\n		}\n		Random r=new Random();\n		while(i<j){\n			System.out.flush();\n			long check=ThreadLocalRandom.current().nextLong(i,j+1);\n			System.out.println(check+"" ""+check);\n			input=s.next();\n			if(input.equals(""Yes"")) {\n					break;\n			}\n			i=Math.max(1,i-k);\n			j=Math.min(n,j+k);\n\n			long mid=(i+j)/2;\n			System.out.println(i+"" ""+mid);\n			input=s.next();\n			if(input.equals(""Yes"")) {\n				j=Math.min(n,mid+k);\n				i=Math.max(1,i-k);\n				\n			}\n			else {\n				i=Math.max(1,mid+1-k);\n				j=Math.min(n,j+k);\n			}\n		}\n	}\n}\n","binary search,interactive,probabilities"
"import java.util.*;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class D {\n	public static void main(String[] args) throws Exception {\n		Scanner in = new Scanner(System.in);\n		long n = in.nextLong();\n		long k = in.nextInt();\n		long l = 1, r = n, x, mid;\n		String s;\n		while (true) {\n			if (r - l <= 49) {\n				x = ThreadLocalRandom.current().nextLong(l, r + 1);\n				System.out.println(x + "" "" + x);\n				System.out.flush();\n				s = in.next();\n				if (s.equals(""Yes"")) break;\n				else if (s.equals(""Bad"")) break;\n				l = Math.max(1, l - k);\n				r = Math.min(n, r + k);\n				continue;\n			}\n			mid = (l + r)/2;\n			System.out.println(l + "" "" + mid);\n			System.out.flush();\n			s = in.next();\n			if (s.equals(""Bad"")) break;\n			else if (s.equals(""Yes"")) {\n				if (l == mid) break;\n				l = Math.max(1, l - k);\n				r = Math.min(n, mid + k);\n			} else if (s.equals(""No"")) {\n				l = Math.max(1, mid - k + 1);\n				r = Math.min(n, r + k);\n			}\n		}\n		in.close();\n	}\n}\n","binary search,interactive,probabilities"
"    import java.util.*;\n    import java.util.concurrent.ThreadLocalRandom;\n     \n    public class D {\n     \n    	public static void main(String[] args) {\n    		Scanner s=new Scanner(System.in);\n    		long n=s.nextLong();\n    		int k=s.nextInt();\n    		long i=1,j=n;\n    		String input="""";\n    		if(i==j) {\n    			System.out.println(i+"" ""+i);\n    			return;\n    		}\n    		Random r=new Random();\n    		while(i<j){\n    			System.out.flush();\n    			long check=ThreadLocalRandom.current().nextLong(i,j+1);\n    			System.out.println(check+"" ""+check);\n    			input=s.next();\n    			if(input.equals(""Yes"")) {\n    					break;\n    			}\n    			i=Math.max(1,i-k);\n    			j=Math.min(n,j+k);\n     \n    			long mid=(i+j)/2;\n    			System.out.println(i+"" ""+mid);\n    			input=s.next();\n    			if(input.equals(""Yes"")) {\n    				j=Math.min(n,mid+k);\n    				i=Math.max(1,i-k);\n    				\n    			}\n    			else {\n    				i=Math.max(1,mid+1-k);\n    				j=Math.min(n,j+k);\n    			}\n    		}\n    	}\n    }","binary search,interactive,probabilities"
"import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\npublic class Main {\n\n  public static void main(String[] args) {\n    try {\n      MScanner in = new MScanner(System.in);\n      BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out, ""UTF-8""));\n      int n = in.nextInt();\n      int [][]a = new int [4][4];\n      int [][]w = new int [4][4];\n      int [][]sw = new int [4][4];\n      \n      for (int i = 0;i < n;++i) {\n        int i1 = in.nextInt() - 1;\n        int wt = in.nextInt();\n        int i2 = in.nextInt() - 1;\n        if (i1 < i2) {\n          int tmp = i1;\n          i1 = i2;\n          i2 = tmp;\n        }\n        a[i1][i2] += 1;\n        sw[i1][i2] += wt;\n        if (w[i1][i2] == 0 || wt < w[i1][i2]) {\n          w[i1][i2] = wt;\n        }\n      }\n      //System.out.println(all);\n      \n      int ans = 0;\n      for (int i = 0;i < 1<<16;++i) {\n\n        int [][]la = new int [4][4];\n        int [][]del = new int [4][4];\n        for (int s = 0;s < 4;++s) for (int t = 0;t < 4;++t) {\n          la[s][t] = a[s][t];\n        }\n        int bad = 0;\n        for (int j = 0;j < 16;++j) {\n          if ((i & (1<<j)) > 0) {\n            int s = j % 4;\n            int t = j / 4;\n            if (la[s][t] <= 0) {\n              bad = 1;\n              break;\n            } else {\n              la[s][t] -= 1;\n              del[s][t] = 1;\n            }\n          }\n        }\n        if (bad == 1) continue;\n        int []node = new int[4];\n\n        for (int s = 0;s < 4;++s) for (int t = 0;t < 4;++t) {\n          if (la[s][t] > 0) {\n            node[s] += la[s][t];\n            node[t] += la[s][t];\n          }\n        }\n        for (int q = 0;q < 4;++q) if (node[q] > 0) {\n          Queue<Integer> Q = new LinkedList<Integer>();\n          int odd = 0;\n          int []vis = new int[4];\n          vis[q] = 1;\n          Q.add(q);\n          while (Q.size() > 0) {\n            int t = Q.poll();\n            odd += node[t] % 2;\n            for (int s = 0;s < 4;++s) {\n              if (la[s][t] > 0 || la[t][s] > 0) {\n                if (vis[s] == 0) {\n                  vis[s] = 1;\n                  Q.add(s);\n                }\n              }\n            }\n          }\n          if (odd > 2) continue;\n\n          int all = 0;\n          for (int s = 0;s < 4;++s) for (int t = 0;t < 4;++t) {\n            if (vis[s] == 0) continue;\n            if (vis[t] == 0) continue;\n            all += sw[s][t];\n            if (del[s][t] == 1) {\n              all -= w[s][t];\n            }\n          }\n          if (all > ans) ans = all;\n        }\n      }\n      System.out.println(ans);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n  static class MScanner {\n    StringTokenizer st;\n    BufferedReader br;\n    public MScanner(InputStream system) {\n      br = new BufferedReader(new InputStreamReader(system));\n    }\n \n    public MScanner(String file) throws Exception {\n      br = new BufferedReader(new FileReader(file));\n    }\n \n    public String next() throws IOException {\n      while (st == null || !st.hasMoreTokens())\n        st = new StringTokenizer(br.readLine());\n      return st.nextToken();\n    }\n    public int[] takearr(int n) throws IOException {\n      int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n      return in;\n    }\n    public long[] takearrl(int n) throws IOException {\n      long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n      return in;\n    }\n    public Integer[] takearrobj(int n) throws IOException {\n      Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n      return in;\n    }\n    public Long[] takearrlobj(int n) throws IOException {\n      Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n      return in;\n    }\n    public String nextLine() throws IOException {\n      return br.readLine();\n    }\n \n    public int nextInt() throws IOException {\n      return Integer.parseInt(next());\n    }\n \n    public double nextDouble() throws IOException {\n      return Double.parseDouble(next());\n    }\n \n    public char nextChar() throws IOException {\n      return next().charAt(0);\n    }\n \n    public Long nextLong() throws IOException {\n      return Long.parseLong(next());\n    }\n \n    public boolean ready() throws IOException {\n      return br.ready();\n    }\n \n    public void waitForInput() throws InterruptedException {\n      Thread.sleep(3000);\n    }\n  }\n}\n","bitmasks,brute force,dfs and similar,dp,graphs"
"//package Cf.Round508;\n\nimport java.util.*;\n\n/**\n * Author : NoRainInNorthrend\n * Date: 2018/9/8 9:25\n */\npublic class E {\n    public static int n;\n    public static int[][] g;\n    public static int[] degree, sum;\n    public static boolean[] used;\n    public static int[][] minEdge;\n\n    public static void main(String[] args) {\n        inputAndInit();\n        List<Integer> ansList = new ArrayList<>();\n        int isAllOdd = getAnsList(ansList);\n        int ans = 0;\n        if(ansList.size() > 1){\n            ans = Collections.max(ansList);\n        }else{\n            ans = ansList.get(0);\n            if(isAllOdd > 0){\n                ans = 0;\n                for(int i = 1; i <= 4; i++){\n                    for(int j = i + 1; j <= 4; j++){\n                        if((degree[i] & degree[j]) > 0){\n                            g[i][j]--;\n                            g[j][i]--;\n                            getAnsList(ansList);\n                            g[i][j]++;\n                            g[j][i]++;\n                            ans = Math.max(ans, Collections.max(ansList) - minEdge[i][j]);\n                        }\n                    }\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n    public static int getAnsList(List<Integer> ansList){\n        ansList.clear();\n        int isAllOdd = 1;\n        Arrays.fill(used, false);\n        for(int i = 1; i <= 4; i++){\n            isAllOdd &= degree[i];\n            if(!used[i]) ansList.add(dfs(i) / 2);\n        }\n        return isAllOdd;\n    }\n    public static int dfs(int u){\n        used[u] = true;\n        int res = sum[u];\n        for(int v = 1; v <= 4; v++){\n            if(!used[v] && g[u][v] > 0) res += dfs(v);\n        }\n        return res;\n    }\n    public static void inputAndInit(){\n        Scanner scanner = new Scanner(System.in);\n        n = scanner.nextInt();\n        g = new int[5][5];\n        degree = new int[5];\n        sum = new int[5];\n        used = new boolean[5];\n        minEdge = new int[5][5];\n        for(int i = 0; i < 5; i++) Arrays.fill(minEdge[i], Integer.MAX_VALUE);\n        for(int i = 0; i < n; i++){\n            int x = scanner.nextInt();\n            int value = scanner.nextInt();\n            int y = scanner.nextInt();\n            g[x][y]++;\n            g[y][x]++;\n            degree[x] ^= 1;\n            degree[y] ^= 1;\n            sum[x] += value;\n            sum[y] += value;\n            if(x != y){\n                minEdge[x][y] = Math.min(minEdge[x][y], value);\n                minEdge[y][x] = Math.min(minEdge[y][x], value);\n            }\n        }\n    }\n}\n","bitmasks,brute force,dfs and similar,dp,graphs"
"import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic class Main {\n\n    class Int {\n        int v = 0;\n\n        void add(int v) {\n            this.v += v;\n        }\n\n        void add(Int o) {\n            this.v += o.v;\n        }\n\n        @Override\n        public String toString() {\n            return String.valueOf(v);\n        }\n    }\n\n    class E {\n        final int a;\n        final int b;\n        final int c;\n        final boolean f;\n\n        E(int a, int b, int c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n            this. f = (a == b);\n        }\n\n        public int getC() {\n            return c;\n        }\n    }\n\n    private int nextInt() {\n        int r = 0;\n        try {\n            int c = System.in.read();\n            while (c < '0' || c > '9') {\n                c = System.in.read();\n            }\n            while (c >= '0' && c <= '9') {\n                r = r * 10 + c - '0';\n                c = System.in.read();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return r;\n    }\n\n    private long nextLong() {\n        long r = 0;\n        try {\n            int c = System.in.read();\n            while (c < '0' || c > '9') {\n                c = System.in.read();\n            }\n            while (c >= '0' && c <= '9') {\n                r = r * 10 + c - '0';\n                c = System.in.read();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return r;\n    }\n\n    private int get(List<E> ee) {\n        List[][] cc = new List[4][4];\n        Int[] ss = new Int[4];\n        for (int i = 0; i < 4; i++) {\n            ss[i] = new Int();\n        }\n        int[] dd = new int[4];\n        Arrays.fill(dd, 0);\n\n        for (int i = 0; i < ee.size(); i++) {\n            int a = ee.get(i).a;\n            int b = ee.get(i).b;\n            int c = ee.get(i).c;\n            if (cc[a][b] == null) {\n                cc[a][b] = new ArrayList<>();\n            }\n            cc[a][b].add(c);\n            dd[a]++;\n            dd[b]++;\n            if (ss[a] != ss[b]) {\n                ss[a].add(ss[b]);\n                for (int j = 0; j < 4; j++) {\n                    if (j != a && j != b && ss[j] == ss[b]) {\n                        ss[j] = ss[a];\n                    }\n                }\n                ss[b] = ss[a];\n            }\n            ss[a].add(c);\n        }\n        if (ss[0] == ss[1] && ss[0] == ss[2] && ss[0] == ss[3]) {\n            if (dd[0] % 2 == 1 && dd[1] % 2 == 1 && dd[2] % 2 == 1 && dd[3] % 2 == 1) {\n                int res = 0;\n                for (int j = 0; j < ee.size(); j++) {\n                    if (ee.get(j).f) {\n                        continue;\n                    }\n                    List<E> ne = new ArrayList<>(ee.subList(0, j));\n                    ne.addAll(ee.subList(j + 1, ee.size()));\n                    res = Math.max(res, get(ne));\n                }\n                return res;\n            } else {\n                return ss[0].v;\n            }\n        } else {\n            int res = 0;\n            res = Math.max(res, ss[0].v);\n            res = Math.max(res, ss[1].v);\n            res = Math.max(res, ss[2].v);\n            res = Math.max(res, ss[3].v);\n            return res;\n        }\n    }\n\n    private void resolve() {\n        int n = nextInt();\n        List<E> ee = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            int a = nextInt() - 1;\n            int c = nextInt();\n            int b = nextInt() - 1;\n            if (a > b) {\n                int d = b;\n                b = a;\n                a = d;\n            }\n            ee.add(new E(a, b, c));\n        }\n        ee.sort(Comparator.comparingInt(E::getC));\n        System.out.println(get(ee));\n    }\n\n    public static void main(String[] args) {\n        new Main().resolve();\n    }\n}","bitmasks,brute force,dfs and similar,dp,graphs"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        int n;\n        int[] u = new int[200];\n        int[] v = new int[200];\n        int[] z = new int[200];\n        ArrayList<Integer>[][] g = new ArrayList[6][6];\n        int oddC = 0;\n        int ans = 0;\n        int curSum = 0;\n        int[] deg;\n        int[] used;\n\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            n = in.nextInt();\n            for (int i = 1; i <= n; ++i) {\n                u[i] = in.nextInt();\n                z[i] = in.nextInt();\n                v[i] = in.nextInt();\n            }\n            for (int i = 1; i <= 4; ++i) {\n                for (int j = 1; j <= 4; ++j) {\n                    g[i][j] = new ArrayList<>();\n                }\n            }\n            for (int edgeR = 0; edgeR <= n; ++edgeR) {\n                deg = new int[6];\n                used = new int[6];\n                for (int i = 1; i <= 4; ++i) {\n                    for (int j = 1; j <= 4; ++j) {\n                        g[i][j].clear();\n                    }\n                }\n                for (int i = 1; i <= n; ++i) {\n                    if (i == edgeR) continue;\n                    g[u[i]][v[i]].add(z[i]);\n                    g[v[i]][u[i]].add(z[i]);\n                    ++deg[u[i]];\n                    ++deg[v[i]];\n                }\n\n                for (int i = 1; i <= 4; ++i) {\n                    if (used[i] == 0) {\n                        oddC = 0;\n                        curSum = 0;\n                        dfs(i);\n                        if (oddC <= 2) ans = Math.max(ans, curSum >>> 1);\n                    }\n                }\n            }\n            out.println(ans);\n        }\n\n        public void dfs(int cur) {\n            used[cur] = 1;\n            oddC += deg[cur] % 2;\n            for (int next = 1; next <= 4; ++next) {\n                for (int w : g[cur][next]) curSum += w;\n                if (used[next] == 1 || g[cur][next].size() == 0) continue;\n                dfs(next);\n            }\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n        }\n\n    }\n}\n\n","bitmasks,brute force,dfs and similar,dp,graphs"
"import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Map.Entry;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class Techno19_2F {\n\n	static int MODE = -1;\n\n	static final Comparator<int[]> COMP_ARR = new Comparator<int[]>() {\n		public int compare(int[] a1, int[] a2) {\n			if (MODE != -1 && (a1.length == 32 || a2.length == 32)) {\n				if (a1.length == 32) {\n					if (MODE < a2.length) {\n						return -1;\n					}\n					if (MODE > a2.length) {\n						return 1;\n					}\n				} else {\n					if (a1.length < MODE) {\n						return -1;\n					}\n					if (a1.length > MODE) {\n						return 1;\n					}\n				}\n\n				for (int i = 0; i < MODE; i++) {\n					if (a1[i] < a2[i]) {\n						return -1;\n					}\n					if (a1[i] > a2[i]) {\n						return 1;\n					}\n				}\n				return 0;\n			} else {\n				if (a1.length < a2.length) {\n					return -1;\n				}\n				if (a1.length > a2.length) {\n					return 1;\n				}\n\n				for (int i = 0; i < a2.length; i++) {\n					if (a1[i] < a2[i]) {\n						return -1;\n					}\n					if (a1[i] > a2[i]) {\n						return 1;\n					}\n				}\n				return 0;\n			}\n		}\n	};\n\n	static TreeMap<int[], Integer> index = new TreeMap<>(COMP_ARR);\n	static int[][] states;\n\n	static ArrayList<int[]> start = new ArrayList<>();\n\n	static int[] numD;\n\n	static int[] pFact = new int[1_000_001];\n\n	static TreeMap<int[], Integer> divCostInd = new TreeMap<>(COMP_ARR);\n\n	public static void main(String[] args) throws IOException {\n		cGen = new int[23];\n		numD = new int[6000];\n		states = new int[6000][];\n		genAll(0, 23, 23, 1);\n\n		aList = new ArrayList[6000];\n		for (int i = 0; i < 6000; i++) {\n			aList[i] = new ArrayList<>();\n		}\n		fAList();\n\n		divCost = new int[400][301];\n		for (int[] a : divCost) {\n			Arrays.fill(a, Integer.MAX_VALUE / 2);\n		}\n		cost = new int[index.size()];\n\n		Arrays.fill(pFact, 1);\n		for (int i = 2; i <= 1_000_000; i++) {\n			if (pFact[i] == 1) {\n				for (int m = i; m <= 1_000_000; m += i) {\n					pFact[m] = i;\n				}\n			}\n		}\n\n		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n		int nT = Integer.parseInt(reader.readLine());\n\n		while (nT-- > 0) {\n			StringTokenizer inputData = new StringTokenizer(reader.readLine());\n			int a = Integer.parseInt(inputData.nextToken());\n			int b = Integer.parseInt(inputData.nextToken());\n\n			int[] aA = toArray(a);\n			int[] bA = toArray(b);\n\n			Integer aRes = divCostInd.get(aA);\n			if (aRes == null) {\n				aRes = divCostInd.size();\n				bfs(aA, divCostInd.size());\n				divCostInd.put(aA, divCostInd.size());\n			}\n			Integer bRes = divCostInd.get(bA);\n			if (bRes == null) {\n				bRes = divCostInd.size();\n				bfs(bA, divCostInd.size());\n				divCostInd.put(bA, divCostInd.size());\n			}\n\n			int minA = Integer.MAX_VALUE / 4;\n			for (int nD = 1; nD <= 300; nD++) {\n				minA = Math.min(minA, divCost[aRes][nD] + divCost[bRes][nD]);\n			}\n			printer.println(minA);\n		}\n		printer.close();\n	}\n\n	static int[] toArray(int a) {\n		ArrayList<Integer> cnts = new ArrayList<Integer>();\n		int last = -1;\n		int cCnt = 0;\n\n		while (a > 1) {\n			int cPFact = pFact[a];\n			if (cPFact == last) {\n				cCnt++;\n			} else {\n				if (cCnt != 0) {\n					cnts.add(cCnt);\n				}\n				last = cPFact;\n				cCnt = 1;\n			}\n			a /= pFact[a];\n		}\n		if (cCnt != 0) {\n			cnts.add(cCnt);\n		}\n		Collections.sort(cnts, Comparator.reverseOrder());\n		int[] res = new int[cnts.size()];\n		for (int i = 0; i < cnts.size(); i++) {\n			res[i] = cnts.get(i);\n		}\n		return res;\n	}\n\n	static int[] cost;\n\n	static int[][] divCost;\n\n	static void bfs(int[] sState, int searchI) {\n		int sInd = index.get(sState);\n		ArrayDeque<Integer> queue = new ArrayDeque<>();\n\n		queue.add(index.get(sState));\n\n		Arrays.fill(cost, -1);\n		cost[sInd] = 0;\n\n		while (!queue.isEmpty()) {\n			int cStInd = queue.remove();\n			for (int nStInd : aList[cStInd]) {\n				if (cost[nStInd] == -1) {\n					cost[nStInd] = cost[cStInd] + 1;\n					queue.add(nStInd);\n				}\n			}\n		}\n\n		for (Entry<int[], Integer> cE : index.entrySet()) {\n			int cNumD = numD[cE.getValue()];\n			if (cNumD <= 300) {\n				divCost[searchI][cNumD] = Math.min(divCost[searchI][cNumD], cost[cE.getValue()]);\n			}\n		}\n	}\n\n	static ArrayList<Integer>[] aList;\n\n	static void fAList() {\n		int[] cState = new int[32];\n		for (Entry<int[], Integer> cE : index.entrySet()) {\n			int[] oState = cE.getKey();\n			int cStInd = cE.getValue();\n\n			int cLen = states[cStInd].length;\n			for (int i = 0; i < cLen; i++) {\n				cState[i] = oState[i];\n			}\n			MODE = cLen;\n\n			for (int i = 0; i < cLen; i++) {\n				if (i == 0 || cState[i - 1] > cState[i]) {\n					cState[i]++;\n					Integer nStInd = index.get(cState);\n					cState[i]--;\n\n					if (nStInd == null) {\n						continue;\n					}\n					aList[cStInd].add(nStInd);\n				}\n\n				if (i == cLen - 1 && cState[i] == 1) {\n					MODE--;\n					Integer nStInd = index.get(cState);\n					MODE++;\n					if (nStInd == null) {\n						continue;\n					}\n					aList[cStInd].add(nStInd);\n				} else if (i == cLen - 1 || cState[i] > cState[i + 1]) {\n					cState[i]--;\n					Integer nStInd = index.get(cState);\n					cState[i]++;\n					if (nStInd == null) {\n						continue;\n					}\n					aList[cStInd].add(nStInd);\n				}\n			}\n			cState[cLen] = 1;\n\n			MODE++;\n			Integer nStInd = index.get(cState);\n			MODE--;\n			if (nStInd == null) {\n				continue;\n			}\n			aList[cStInd].add(nStInd);\n		}\n	}\n\n	static int[] cGen;\n\n	static void genAll(int i, int max, int rem, int cProd) {\n		numD[index.size()] = cProd;\n\n		int[] cKey = Arrays.copyOf(cGen, i);\n		states[index.size()] = cKey;\n		index.put(cKey, index.size());\n\n		if (rem > 0) {\n			for (int nV = Math.min(max, rem); nV >= 1; nV--) {\n				cGen[i] = nV;\n				genAll(i + 1, nV, rem - nV, cProd * (nV + 1));\n			}\n		}\n	}\n}","brute force,graphs,math"
"//package round517;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class D3 {\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n	\n	void solve()\n	{\n		int[] lpf = enumLowestPrimeFactors(1000000);\n		Map<Long, int[]> map = new HashMap<>();\n		long[] hs = new long[1000001];\n		for(int i = 1;i <= 1000000;i++){\n			int[] lu = factorE(i, lpf);\n			Arrays.sort(lu);\n			hs[i] = (long)Arrays.hashCode(lu);\n			map.put(hs[i], lu);\n		}\n		\n		int K = 8;\n		List<List<Set<Long>>> ls = new ArrayList<>();\n		List<int[]> vs = new ArrayList<>(map.values());\n		int gen = 0;\n		Map<Long, Integer> htov = new HashMap<>();\n		for(int[] v : vs){\n			htov.put((long)Arrays.hashCode(v), gen++);\n			cache = new HashSet<>();\n			List<Set<Long>> hey = new ArrayList<>();\n			for(int t = 0;t <= K;t++)hey.add(new HashSet<>());\n			dfs(v, 0, K, hey);\n			ls.add(hey);\n		}\n		\n		int[][] cans = new int[ls.size()][ls.size()];\n		for(int i = 0;i < ls.size();i++){\n			Arrays.fill(cans[i], -1);\n		}\n		\n		outer:\n		for(int T = ni();T > 0;T--){\n			int a = ni(), b = ni();\n			int ia = htov.get(hs[a]);\n			int ib = htov.get(hs[b]);\n			if(cans[ia][ib] != -1){\n				out.println(cans[ia][ib]);\n				continue;\n			}\n			for(int d = 0;d <= 16;d++){\n				for(int i = 0;i <= d && i <= 8;i++){\n					int j = d-i;\n					if(j >= 0 && j <= 8){\n						if(!Collections.disjoint(ls.get(ia).get(i), ls.get(ib).get(j))){\n							cans[ia][ib] = cans[ib][ia] = d;\n							out.println(d);\n							continue outer;\n						}\n					}\n				}\n			}\n			throw new RuntimeException();\n		}\n	}\n	\n	Set<Long> cache = new HashSet<>();\n	\n	void dfs(int[] a, int dep, int lim, List<Set<Long>> set)\n	{\n		long h = dep + 114514;\n		for(int v : a)h = h * 1000000009 + v;\n		if(!cache.add(h)){\n			return;\n		}\n		\n		long x = 1;\n		for(int v : a){\n			x = x * (v+1);\n		}\n		set.get(dep).add(x);\n		if(dep == lim)return;\n		\n		for(int i = 0;i < a.length;i++){\n			if(i > 0 && a[i] == a[i-1])continue;\n			if(a[i] > 1){\n				int[] b = Arrays.copyOf(a, a.length);\n				b[i]--;\n				Arrays.sort(b);\n				dfs(b, dep+1, lim, set);\n			}\n			{\n				int[] b = Arrays.copyOf(a, a.length);\n				b[i]++;\n				Arrays.sort(b);\n				dfs(b, dep+1, lim, set);\n			}\n			if(a[i] == 1){\n				int[] b = Arrays.copyOf(a, a.length-1);\n				int p = 0;\n				for(int j = 0;j < a.length;j++){\n					if(j == i)continue;\n					b[p++] = a[j];\n				}\n				dfs(b, dep+1, lim, set);\n			}\n		}\n		int[] b = Arrays.copyOf(a, a.length+1);\n		b[a.length] = 1;\n		Arrays.sort(b);\n		dfs(b, dep+1, lim, set);\n	}\n	\n	public static int[] factorE(int n, int[] lpf)\n	{\n		int[] f = new int[9];\n		int q = 0;\n		int pre = -1;\n		while(lpf[n] > 0){\n			int p = lpf[n];\n			if(p != pre){\n				pre = p;\n				f[q++] = 1;\n			}else{\n				f[q-1]++;\n			}\n			n /= p;\n		}\n		if(n > 1){\n			// big prime\n			return new int[]{1};\n		}\n		return Arrays.copyOf(f, q);\n	}\n\n	\n	public static int[] enumLowestPrimeFactors(int n) {\n		int tot = 0;\n		int[] lpf = new int[n + 1];\n		int u = n + 32;\n		double lu = Math.log(u);\n		int[] primes = new int[(int) (u / lu + u / lu / lu * 1.5)];\n		for (int i = 2; i <= n; i++)\n			lpf[i] = i;\n		for (int p = 2; p <= n; p++) {\n			if (lpf[p] == p)\n				primes[tot++] = p;\n			int tmp;\n			for (int i = 0; i < tot && primes[i] <= lpf[p] && (tmp = primes[i] * p) <= n; i++) {\n				lpf[tmp] = primes[i];\n			}\n		}\n		return lpf;\n	}\n\n	\n	void run() throws Exception\n	{\n//		int n = 99999, m = 99999;\n//		StringBuilder sb = new StringBuilder();\n//		sb.append(n + "" "");\n//		for (int i = 0; i < n; i++) {\n//			sb.append(36 + "" "" + (3*5*7*11<<9) + ""\n"");\n//		}\n//		INPUT = sb.toString();\n		\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new D3().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n	\n	private char[][] nm(int n, int m)\n	{\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n	\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n	\n	private int ni()\n	{\n		int num = 0, b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","brute force,graphs,math"
"import javax.swing.plaf.synth.SynthOptionPaneUI;\nimport java.util.Scanner;\nimport java.util.*;\nimport java.util.logging.XMLFormatter;\n\nimport static java.lang.Math.*;\n\n\npublic class Main {\n    static int n, m;\n    static Scanner in = new Scanner(System.in);\n\n    static class Tmp {\n        int[][] field = new int[55][55];\n        int[] ansx1 = new int[10800];\n        int[] ansx2 = new int[10800];\n        int[] ansy1 = new int[10800];\n        int[] ansy2 = new int[10800];\n        int size;\n        static int[] vx = {-1, 0, 0, 1};\n        static int[] vy = {0, -1, 1, 0};\n\n        void read() {\n            for (int i = 1; i <= m; i++) {\n                int x = in.nextInt();\n                int y = in.nextInt();\n                field[x][y] = i;\n            }\n        }\n\n        void move(int x, int y, int d) {\n            field[x + vx[d]][y + vy[d]] = field[x][y];\n            field[x][y] = 0;\n            ansx1[size] = x;\n            ansy1[size] = y;\n            ansx2[size] = x + vx[d];\n            ansy2[size++] = y + vy[d];\n        }\n\n        void moveShift(int x, int y) {\n            if (y + 1 <= n && field[x][y + 1] != 0) {\n                moveShift(x, y + 1);\n            }\n            move(x, y, 2);\n        }\n\n        void go() {\n            int pos = 0;\n            for (int i = 1; i <= n; i++) {\n                for (int j = 1; j <= n; j++)\n                    if (field[i][j] != 0) {\n                        int x = j;\n                        ++pos;\n                        while (x < pos) {\n                            moveShift(i, x++);\n                        }\n                        while (x > pos) {\n                            move(i, x--, 1);\n                        }\n                        for (x = i; x > 1; x--) {\n                            move(x, pos, 0);\n                        }\n                    }\n            }\n        }\n\n        void fix(int[] field2) {\n            if (n == 2 && field[1][1] != field2[1]) {\n                move(1, 1, 3);\n                move(2, 1, 2);\n                move(1, 2, 1);\n                move(2, 2, 0);\n            } else if (n > 3) {\n                for (int i = 1; i <= m; i++) {\n                    int j = 1, x = i;\n                    while (field2[j] != field[1][i]) {\n                        j++;\n                    }\n                    move(1, i, 3);\n                    while (x < j) move(2, x++, 2);\n                    while (x > j) move(2, x--, 1);\n                    move(2, x, 3);\n                }\n                for (int i = 1; i <= m; i++) {\n                    move(3, i, 0);\n                    move(2, i, 0);\n                }\n            }\n        }\n\n        void print(boolean reverse) {\n            if (reverse) {\n                for (int i = size - 1; i >= 0; i--) {\n                    System.out.println(ansx2[i] + "" "" + ansy2[i] + "" "" + ansx1[i] + "" "" + ansy1[i]);\n                }\n            } else for (int i = 0; i < size; i++) {\n                System.out.println(ansx1[i] + "" "" + ansy1[i] + "" "" + ansx2[i] + "" "" + ansy2[i]);\n            }\n        }\n\n    }\n\n    public static void main(String[] args) {\n        n = in.nextInt();\n        m = in.nextInt();\n        Tmp t1 = new Tmp();\n        Tmp t2 = new Tmp();\n        t1.read();\n        t2.read();\n        t1.go();\n        t2.go();\n        t1.fix(t2.field[1]);\n        System.out.println(t1.size + t2.size);\n        t1.print(false);\n        t2.print(true);\n    }\n\n\n    private static boolean check(int n, int[] a, int[] b, TreeSet<Integer> sb) {\n        for (int memb : sb) {\n            boolean check = true;\n            for (int i = 1; i < n; i++) {\n                if (a[i] % memb != 0 && b[i] % memb != 0) {\n                    check = false;\n                    break;\n                }\n            }\n            if (check) {\n                System.out.println(memb);\n                return true;\n            }\n        }\n        return false;\n    }\n}","constructive algorithms,implementation,matrices"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.Comparator;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author BSRK Aditya\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        EColoredCubes solver = new EColoredCubes();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EColoredCubes {\n        int boardSz;\n        int numCubes;\n        Pos[] initPos;\n        Pos[] finalPos;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            boardSz = in.readInt();\n            numCubes = in.readInt();\n            initPos = new Pos[numCubes + 1];\n            initPos[0] = new Pos(0, 0, 0);\n            for (int i = 1; i <= numCubes; ++i) {\n                initPos[i] = new Pos(in.readInt(), in.readInt(), i);\n            }\n\n            finalPos = new Pos[numCubes + 1];\n            finalPos[0] = new Pos(0, 0, 0);\n            for (int i = 1; i <= numCubes; ++i) {\n                finalPos[i] = new Pos(in.readInt(), in.readInt(), i);\n            }\n\n            ArrayList<Move> ansP1 = toBasic(initPos);\n            ArrayList<Move> ansP2 = toBasic(finalPos);\n            Collections.reverse(ansP2);\n\n            out.printLine(ansP1.size() + ansP2.size());\n            for (Move m : ansP1) {\n                out.printLine(m.start.x, m.start.y, m.end.x, m.end.y);\n            }\n            for (Move m : ansP2) {\n                out.printLine(m.end.x, m.end.y, m.start.x, m.start.y);\n            }\n        }\n\n        ArrayList<Move> toBasic(Pos[] pos) {\n            Arrays.sort(pos, new Comparator<Pos>() {\n\n                public int compare(Pos o1, Pos o2) {\n                    if (o1.x < o2.x) return -1;\n                    if (o1.x > o2.x) return 1;\n                    if (o1.y < o2.y) return -1;\n                    if (o1.y > o2.y) return 1;\n                    return 0;\n                }\n            });\n\n            boolean[][] board = new boolean[boardSz + 1][boardSz + 1];\n            for (int i = 0; i <= boardSz; ++i)\n                for (int j = 0; j <= boardSz; ++j)\n                    board[i][j] = false;\n            for (int i = 1; i <= numCubes; ++i)\n                board[pos[i].x][pos[i].y] = true;\n\n            ArrayList<Move> moves = new ArrayList<>();\n\n            boolean allDone = false;\n            while (!allDone) {\n                allDone = true;\n                for (int i = 1; i <= numCubes; ++i) {\n                    // set pos[i].x to i\n                    boolean canMove = true;\n                    while (pos[i].x != i && canMove) {\n                        allDone = false;\n                        Pos nPos = new Pos(pos[i].x - (int) Math.signum(pos[i].x - i), pos[i].y, pos[i].cn);\n                        if (!board[nPos.x][nPos.y]) {\n                            moves.add(new Move(pos[i], nPos));\n                            board[pos[i].x][pos[i].y] = false;\n                            board[nPos.x][nPos.y] = true;\n                            pos[i] = nPos;\n                        } else canMove = false;\n                    }\n                }\n            }\n\n            for (int i = 1; i <= numCubes; ++i) {\n                while (pos[i].y != pos[i].cn) {\n                    Pos nPos = new Pos(pos[i].x, pos[i].y - (int) Math.signum(pos[i].y - pos[i].cn), pos[i].cn);\n                    moves.add(new Move(pos[i], nPos));\n                    pos[i] = nPos;\n                }\n            }\n\n            for (int i = 1; i <= numCubes; ++i) {\n                while (pos[i].x != pos[i].cn) {\n                    Pos nPos = new Pos(pos[i].x - (int) Math.signum(pos[i].x - pos[i].cn), pos[i].y, pos[i].cn);\n                    moves.add(new Move(pos[i], nPos));\n                    pos[i] = nPos;\n                }\n            }\n\n            return moves;\n        }\n\n        class Pos {\n            final int x;\n            final int y;\n            final int cn;\n\n            Pos(int x, int y, int cn) {\n                this.x = x;\n                this.y = y;\n                this.cn = cn;\n            }\n\n        }\n\n        class Move {\n            final Pos start;\n            final Pos end;\n\n            Move(Pos start, Pos end) {\n                this.start = start;\n                this.end = end;\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0)\n                    writer.print(' ');\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n","constructive algorithms,implementation,matrices"
"import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class SkyFullOfStar\n{\n    static IO io = new IO (System.in);\n    static int n, m;\n    static Cood[] curr, target;\n\n    public static void main(String[] args) throws Exception\n    {\n        int i, j, k;\n        n = io.nextInt();   m = io.nextInt();\n        curr = new Cood[m];\n        target = new Cood[m];\n\n        for(i = 0; i < m; ++i)\n            curr[i] = new Cood(i, io.nextInt(), io.nextInt());\n        for(i = 0; i < m; ++i)\n            target[i] = new Cood(i, io.nextInt(), io.nextInt());\n        if(n == 2)\n        {\n            if(m == 1)\n                guide(curr[0], target[0].x, target[0].y);\n            else {\n                if (guide(curr[0], target[0].x, target[0].y))\n                    guide(curr[1], target[1].x, target[1].y);\n                else if (guide(curr[1], target[1].x, target[1].y))\n                    guide(curr[0], target[0].x, target[0].y);\n                else {\n                    if(curr[1].x == curr[0].x % 2 + 1 && curr[1].y == curr[0].y)\n                        guide(curr[0], curr[0].x, curr[0].y % 2 + 1);\n                    else\n                        guide(curr[0], curr[0].x % 2 + 1, curr[0].y);\n                    guide(curr[1], target[1].x, target[1].y);\n                    guide(curr[0], target[0].x, target[0].y);\n                }\n            }\n\n            io.flush();\n            System.exit(0);\n        }\n\n        int targetRow = findBestRow();\n        for(j = 1; j <= n; ++j)\n        {\n            if(contains(targetRow, j, -1, curr))\n                continue;\n            for(k = 0; k < m; ++k)\n                if(curr[k].x != targetRow && guide(curr[k], targetRow, j))\n                    break;\n            io.println();\n        }\n\n        io.print(""************************\n\n"");\n\n        for(j = 1; j <= n; ++j)\n        {\n            for(i = 0; i < m; ++i)\n                if(target[i].x == targetRow && target[i].y == j)\n                    break;\n            if(i >= m)\n                continue;\n\n            for(k = 0; k < m; ++k)\n                if(curr[k].x == targetRow && curr[k].y == j)\n                    break;\n            if(k < m)\n                swap(curr[k], curr[i], true);\n            else\n                guide(curr[i], target[i].x, target[i].y);\n            io.println();\n        }\n\n        io.print(""************************\n\n"");\n\n        for(i = 1; i < targetRow; ++i)\n        {\n            for(j = 1; j <= n; ++j)\n            {\n                for(k = 0; k < m; ++k)\n                    if(target[k].x == i && target[k].y == j)\n                        break;\n                if (k >= m)\n                    continue;\n                guide(curr[k], target[k].x, target[k].y);\n                io.println();\n            }\n        }\n        for(i = n; i > targetRow; --i)\n        {\n            for(j = 1; j <= n; ++j)\n            {\n                for(k = 0; k < m; ++k)\n                    if(target[k].x == i && target[k].y == j)\n                        break;\n                if (k >= m)\n                    continue;\n                guide(curr[k], target[k].x, target[k].y);\n                io.println();\n            }\n        }\n\n        io.flush();\n    }\n    static int findBestRow()\n    {\n        int i, j, minC = Integer.MAX_VALUE, count, bestR = -7;\n        for(i = 2; i < n - 1; ++i) {\n            for (j = 1, count = 0; j <= n; ++j) {\n                if (contains(i - 1, j, -1, target))\n                    ++count;\n                if (contains(i + 1, j, -1, target))\n                    ++count;\n            }\n            if(count < minC)\n            {\n                minC = count;\n                bestR = i;\n            }\n        }\n        return bestR;\n    }\n    static void swap(Cood c1, Cood c2, boolean rowWise)\n    {\n        if(c1.equals(c2)) return;\n        int x1 = c1.x, y1 = c1.y, x2 = c2.x, y2 = c2.y;\n\n        if(rowWise)\n        {\n            guide(c1, c1.x + 1, c1.y);\n            guide(c2, c2.x - 1, c2.y);\n        }\n        else\n        {\n            guide(c1, c1.x, c1.y + 1);\n            guide(c2, c2.x, c2.y - 1);\n        }\n        guide(c1, x2, y2);\n        guide(c2, x1, y1);\n    }\n\n    static HashSet<Integer> vis = new HashSet<>();\n    static ArrayList<String> path = new ArrayList<>();\n\n    static boolean guide(Cood c, int x, int y)\n    {\n        vis.clear();\n        path.clear();\n        if(!travel(c.x, c.y, x, y, c.ind))\n            return false;\n        for(int i = 1; i < path.size(); ++i)\n            io.println(path.get(i - 1) + "" "" + path.get(i));\n        c.x = x;    c.y = y;\n        return true;\n    }\n    static boolean travel(int cx, int cy, int tx, int ty, int exclInd)\n    {\n        if(invalid(cx, cy) || vis.contains(cx * (n + 5) + cy) || contains(cx, cy, exclInd, curr))\n            return false;\n        vis.add(cx * (n + 5) + cy);\n        path.add(cx + "" "" + cy);\n\n        if(cx == tx && cy == ty)\n            return true;\n\n        int currDist = dist(cx, cy, tx, ty);\n        if(dist(cx - 1, cy, tx, ty) < currDist && travel(cx - 1, cy, tx, ty, exclInd))\n            return true;\n        if(dist(cx + 1, cy, tx, ty) < currDist && travel(cx + 1, cy, tx, ty, exclInd))\n            return true;\n        if(dist(cx, cy - 1, tx, ty) < currDist && travel(cx, cy - 1, tx, ty, exclInd))\n            return true;\n        if(dist(cx, cy + 1, tx, ty) < currDist && travel(cx, cy + 1, tx, ty, exclInd))\n            return true;\n\n        path.remove(path.size() - 1);\n        return false;\n    }\n\n    static boolean invalid(int x, int y)\n    {\n        return x < 1 || y < 1 || x > n || y > n;\n    }\n    static int dist(int a, int b, int c, int d)\n    {\n        return Math.abs(a - c) + Math.abs(b - d);\n    }\n\n    static boolean contains(int x, int y, int exclInd, Cood[] ar)\n    {\n        int i;\n        for(i = 0; i < ar.length; ++i)\n            if(i != exclInd && ar[i].x == x && ar[i].y == y)\n                return true;\n        return false;\n    }\n}\n\nclass Cood\n{\n    int ind, x, y;\n    Cood(int in, int i, int j) {ind = in;  x = i;  y = j;}\n    boolean isEqual(Cood co) {return x == co.x && y == co.y;}\n    public String toString() {return ind + "".("" + x + "", "" + y + "")"";}\n}\n\nclass IO {\n    static byte[] buf = new byte[2048];\n    static int index, total;\n    static InputStream in;\n    static StringBuilder sb = new StringBuilder();\n    static int counter = 0;\n\n\n    IO(InputStream is) {\n        in = is;\n    }\n\n    int scan() throws Exception {\n        if (index >= total) {\n            index = 0;\n            total = in.read(buf);\n            if (total <= 0)\n                return -1;\n        }\n        return buf[index++];\n    }\n\n    String next() throws Exception {\n        int c;\n        for (c = scan(); c <= 32; c = scan()) ;\n        StringBuilder sb = new StringBuilder();\n        for (; c > 32; c = scan())\n            sb.append((char) c);\n        return sb.toString();\n    }\n\n    int nextInt() throws Exception {\n        int c, val = 0;\n        for (c = scan(); c <= 32; c = scan()) ;\n        boolean neg = c == '-';\n        if (c == '-' || c == '+')\n            c = scan();\n        for (; c >= '0' && c <= '9'; c = scan())\n            val = (val << 3) + (val << 1) + (c & 15);\n        return neg ? -val : val;\n    }\n\n    long nextLong() throws Exception {\n        int c;\n        long val = 0;\n        for (c = scan(); c <= 32; c = scan()) ;\n        boolean neg = c == '-';\n        if (c == '-' || c == '+')\n            c = scan();\n        for (; c >= '0' && c <= '9'; c = scan())\n            val = (val << 3) + (val << 1) + (c & 15);\n        return neg ? -val : val;\n    }\n\n    void print(Object a) {\n        //sb.append(a.toString());\n    }\n\n    void println(Object a) {\n        sb.append(a.toString()).append(""\n"");\n        ++counter;\n    }\n\n    void println() {\n        //sb.append(""\n"");\n    }\n\n    void flush() {\n        System.out.println(counter);\n        System.out.print(sb);\n        sb = new StringBuilder();\n    }\n}","constructive algorithms,implementation,matrices"
"//package round505;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class E {\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n	\n	void solve()\n	{\n		int n = ni(), m = ni();\n		int[][] co = new int[m][];\n		int[][] coto = new int[m][];\n		for(int i = 0;i < m;i++){\n			co[i] = new int[]{ni()-1, ni()-1, i};\n		}\n		for(int i = 0;i < m;i++){\n			coto[i] = new int[]{ni()-1, ni()-1, i, -1};\n		}\n		\n		int[][] coc = new int[m][];\n		for(int i = 0;i < m;i++)coc[i] = Arrays.copyOf(co[i], 2);\n		int[][] cotoc = new int[m][];\n		for(int i = 0;i < m;i++)cotoc[i] = Arrays.copyOf(coto[i], 2);\n		\n		boolean[][] map = new boolean[n][n];\n		for(int i = 0;i < m;i++){\n			map[co[i][0]][co[i][1]] = true;\n		}\n		\n		int[] who = new int[m];\n		Arrays.fill(who, -1);\n		List<String> ans = new ArrayList<>();\n		\n		\n//		Arrays.sort(co, new Comparator<int[]>() {\n//			public int compare(int[] a, int[] b) {\n//				if(a[1] != b[1])return -(a[1] - b[1]);\n//				return -(a[0] - b[0]);\n//			}\n//		});\n\n		boolean[] done = new boolean[m];\n		int ndone = 0;\n		\n		while(ndone < m){\n			outer:\n			for(int i = 0;i < m;i++){\n				if(done[i])continue;\n				for(int j = 0;j < m;j++){\n					if(who[j] == -1){\n						int[] route = route(map, co[i][0], co[i][1], j, n-1);\n						if(route == null)continue;\n						\n						trans(co[i][0], co[i][1], route, ans);\n						map[co[i][0]][co[i][1]] = false;\n						co[i][0] = j; co[i][1] = n-1;\n						who[j] = co[i][2];\n						map[co[i][0]][co[i][1]] = true;\n						done[i] = true;\n						ndone++;\n						continue outer;\n					}\n				}\n//				throw new RuntimeException();\n			}\n		}\n		\n		\n		Arrays.sort(coto, new Comparator<int[]>() {\n			public int compare(int[] a, int[] b) {\n				if(a[0] != b[0])return a[0] - b[0];\n				return a[1] - b[1];\n			}\n		});\n		Arrays.sort(co, new Comparator<int[]>() {\n			public int compare(int[] a, int[] b) {\n				return a[2] - b[2];\n			}\n		});\n		\n		\n		int p = 0;\n		for(int i = 0;i < m;i++){\n			if(i == 0 || coto[i][0] != coto[i-1][0]){\n				p = 0;\n			}else{\n				p++;\n			}\n			coto[i][3] = p;\n			int ind = coto[i][2];\n			int[] route = route(map, co[ind][0], co[ind][1], coto[i][0], p);\n			assert route != null;\n			trans(co[ind][0], co[ind][1], route, ans);\n			map[co[ind][0]][co[ind][1]] = false;\n			co[ind][0] = coto[i][0]; \n			co[ind][1] = p;\n			map[co[ind][0]][co[ind][1]] = true;\n		}\n		\n		for(int i = m-1;i >= 0;i--){\n			int ind = coto[i][2];\n			int[] route = route(map, co[ind][0], co[ind][1], coto[i][0], coto[i][1]);\n			if(route == null)continue;\n			trans(co[ind][0], co[ind][1], route, ans);\n			map[co[ind][0]][co[ind][1]] = false;\n			co[ind][0] = coto[i][0]; \n			co[ind][1] = coto[i][1];\n			map[co[ind][0]][co[ind][1]] = true;\n		}\n		\n		out.println(ans.size());\n		for(String line : ans){\n			out.println(line);\n		}\n		\n		check(ans, coc, cotoc, n);\n	}\n	\n	void check(List<String> ans, int[][] coc, int[][] cotoc, int n)\n	{\n		assert ans.size() <= 10800;\n		int[][] map = new int[n][n];\n		for(int i = 0;i < n;i++){\n			Arrays.fill(map[i], -1);\n		}\n		int m = coc.length;\n		for(int i = 0;i < m;i++){\n			map[coc[i][0]][coc[i][1]] = i;\n		}\n		\n		for(String line : ans){\n			String[] sp = line.split("" "");\n			int r = Integer.parseInt(sp[0])-1;\n			int c = Integer.parseInt(sp[1])-1;\n			int nr = Integer.parseInt(sp[2])-1;\n			int nc = Integer.parseInt(sp[3])-1;\n			assert Math.abs(r-nr)+Math.abs(c-nc) == 1;\n			assert map[r][c] != -1;\n			assert map[nr][nc] == -1;\n			map[nr][nc] = map[r][c];\n			map[r][c] = -1;\n		}\n		\n		for(int i = 0;i < m;i++){\n			assert map[cotoc[i][0]][cotoc[i][1]] == i;\n		}\n	}\n	\n	public static void tf(boolean[]... b)\n	{\n		for(boolean[] r : b) {\n			for(boolean x : r)System.out.print(x?'#':'.');\n			System.out.println();\n		}\n		System.out.println();\n	}\n\n	\n	int[] dr = { 1, 0, -1, 0 };\n	int[] dc = { 0, 1, 0, -1 };\n	\n	void trans(int r, int c, int[] route, List<String> ans)\n	{\n		for(int k : route){\n			int nr = r + dr[k], nc = c + dc[k];\n			ans.add((r+1) + "" "" + (c+1) + "" "" + (nr+1) + "" "" + (nc+1));\n			r = nr; c = nc;\n		}\n	}\n	\n	int[] route(boolean[][] map, int sr, int sc, int tr, int tc)\n	{\n		assert map[sr][sc];\n		if(sr == tr && sc == tc)return new int[0];\n		if(map[tr][tc])return null;\n		map[sr][sc] = false;\n		int n = map.length;\n		int[] q = new int[n*n];\n		int p = 0;\n		q[p++] = tr*n+tc;\n		int[][] prev = new int[n][n];\n		for(int i = 0;i < n;i++){\n			Arrays.fill(prev[i], -1);\n		}\n		prev[tr][tc] = 999;\n		\n		for(int z = 0;z < p;z++){\n			int cur = q[z];\n			int r = cur/n, c = cur%n;\n			for(int k = 0;k < 4;k++){\n				int nr = r + dr[k], nc = c + dc[k];\n				if(nr >= 0 && nr < n && nc >= 0 && nc < n && !map[nr][nc] && prev[nr][nc] == -1){\n					prev[nr][nc] = k;\n					q[p++] = nr*n+nc;\n				}\n			}\n		}\n		map[sr][sc] = true;\n		if(prev[sr][sc] == -1)return null;\n		\n		int[] route = new int[n*n];\n		int o = 0;\n		int r = sr, c = sc;\n		while(prev[r][c] != 999){\n			int k = prev[r][c];\n			r -= dr[k]; c -= dc[k];\n			route[o++] = k^2;\n		}\n		return Arrays.copyOf(route, o);\n	}\n	\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new E().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n	\n	private char[][] nm(int n, int m)\n	{\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n	\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n	\n	private int ni()\n	{\n		int num = 0, b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}","constructive algorithms,implementation,matrices"
"import java.util.*;\npublic class Main{\n	public static void main(String args[]){\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int a[] = new int[n];\n		for(int i=0;i<n;i++){\n			a[i] = sc.nextInt();\n		}\n		int s =0;\n		for(int i=0;i<n;i++){\n			boolean vis[] = new boolean[n];\n			int c=i;\n			while(!vis[c]){\n				vis[c] = true;\n				c=a[c]-1; \n			}\n			s++;\n			System.out.print(c+1+"" "");\n		}\n\n	}\n}\n","brute force,dfs and similar,graphs"
"import java.util.*;\n\npublic class A{\n	public static void main(String[] args){\n		Scanner in = new Scanner(System.in);\n		int n = in.nextInt();\n		int arr[] = new int[n];\n		for(int i = 0; i < n; i++){\n			arr[i] = in.nextInt();\n		}\n		int s = 0;\n		\n		for(int i = 0; i < n; i++){\n			boolean vis[] = new boolean[n];\n			int c = i;\n			\n			while(!vis[c]){\n				vis[c] = true;\n				c = arr[c] - 1;\n				\n			}\n			s++;\n			System.out.print(c + 1 + "" "");\n		}\n	}\n}","brute force,dfs and similar,graphs"
"import java.util.*;\n \npublic class A{\n	public static void main(String[] args){\n		Scanner in = new Scanner(System.in);\n		int n = in.nextInt();\n		int arr[] = new int[n];\n		for(int i = 0; i < n; i++){\n			arr[i] = in.nextInt();\n		}\n		int s = 0;\n		\n		for(int i = 0; i < n; i++){\n			boolean vis[] = new boolean[n];\n			int c = i;\n			\n			while(!vis[c]){\n				vis[c] = true;\n				c = arr[c] - 1;\n				\n			}\n			s++;\n			System.out.print(c + 1 + "" "");\n		}\n	}\n}","brute force,dfs and similar,graphs"
"/** author : SanskarxRawat\n**/\nimport java.util. * ;\n\npublic class solution {\n	public static void main(String[] args) {\n		Scanner in =new Scanner(System. in );\n		int n = in.nextInt();\n		int[] arr = new int[n];\n		for (int i = 0; i < n; i++) {\n			arr[i] = in.nextInt();\n		}\n\n		for (int i = 0; i < n; i++) {\n			boolean visited[] = new boolean[n];\n			int c = i;\n			while (!visited[c]) {\n				visited[c] = true;\n				c = arr[c] - 1;\n			}\n			System.out.print(c + 1 + "" "");\n		}\n	}\n}","brute force,dfs and similar,graphs"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1015D extends PrintWriter {\n	CF1015D() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1015D o = new CF1015D(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int k = sc.nextInt();\n		long s = sc.nextLong();\n		if (s < k || (long) k * (n - 1) < s) {\n			println(""NO"");\n			return;\n		}\n		println(""YES"");\n		int x = 1;\n		while (k-- > 0) {\n			int d = (int) Math.min(s - k, n - 1);\n			s -= d;\n			x = x > d ? x - d : x + d;\n			print(x + "" "");\n		}\n		println();\n	}\n}\n","constructive algorithms,greedy"
"import java.util.*;\npublic class Solution {  \n    public static void main(String args[]){\n        Scanner sc=new Scanner(System.in);\n        // int t=sc.nextInt();\n        // while (t-->0) {\n        long n=sc.nextLong(),k=sc.nextLong(),s=sc.nextLong();\n        if(k*(n-1)<s|| k>s){\n          System.out.println(""NO"");\n          return;\n          }\n          System.out.println(""YES"");\n          long start=1;\n          while (k!=0) {\n            long min=Math.min(n-1,s-(k-1));\n            if(start+min<=n){\n              System.out.print(start+min+"" "");\n              start+=min;\n          }else\n          {\n              System.out.print(start-min+"" "");\n              start-=min;\n          }\n          s-=min;\n          k--;\n        }\n        System.out.println("""");\n      // }\n}\n}","constructive algorithms,greedy"
"import java.util.Scanner;\n\npublic class walkingDead {\n	static void solve(long n ,  long k , long s , long p)\n	{\n		StringBuilder str = new StringBuilder("""");\n		while (s!=0)\n		{\n			for (long i=n-1;i>=1 && s>0;)\n			{\n				if (s-i>=k-1)\n				{\n					if(p-i>=1)\n					{\n						str.append((p-i)+"" "");\n						p = p - i;\n					}\n					else if(p-i<=n)\n					{\n						str.append((p+i)+"" "");\n						p = p +i;\n					}\n					s = s- i;\n					k--;\n				}\n				else\n				{\n					i = s-(k-1);\n				}\n			}\n		}\n		System.out.println(""YES"");  //1000000000 200000 199979000100000\n		System.out.println(str);\n	}\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		long n = sc.nextInt();\n		long k = sc.nextLong();\n		long s = sc.nextLong();\n		sc.close();\n		if ((n-1)*k<s|| s<k)\n		{\n			System.out.println(""NO"");\n		}\n		else\n		{\n			solve(n , k , s , 1);\n		}\n	}\n}\n","constructive algorithms,greedy"
"/*input\n5 5 2 3\n\n\n\n*/\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class Main\n {\n static Scanner in = new Scanner(System.in);\n    \n   static List<Integer> ans= new ArrayList<>();\n        \n        \n      \n \n \n    public static void solve()\n    {   \n   \n        long n=in.nextLong(),k=in.nextLong();\n    	long s=in.nextLong();\n    	\n    	if(k>s || k*(n-1)<s)\n    	{\n    	    System.out.println(""NO"");\n    	}\n    	else\n    	{\n    	    StringBuilder sb = new StringBuilder();\n    	    sb.append(""YES"").append(""\n"");\n    	    long start=1;\n    	    while(k>0)\n    	    {\n    	        \n    	        long dis=Math.min(n-1,s-(k-1));\n    	        \n    	        if(start-dis>0)\n    	        start=start-dis;\n    	        else\n    	        start=start+dis;\n    	        \n    	        sb.append(start).append("" "");\n    	        \n    	        s=s-dis;\n    	        k--;\n    	    }\n    	    \n    	    System.out.println(sb);\n    	}\n    	\n    }\n    \n	public static void main (String[] args)\n	 {\n	 int t=1;\n	 while(t-->0)\n	 {\n	  solve();\n	 }\n}\n}","constructive algorithms,greedy"
import java.util.*;\npublic class craddles {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int A = sc.nextInt();\n        int [] arr = new int[A];\n        for (int i=0;i<A;i++){\n            arr[i]=sc.nextInt();\n        }\n        int k = Arrays.stream(arr).min().getAsInt();\n        while (arr[k%A]>k){\n            k++;\n        }\n        System.out.println(k%A+1);\n    }\n},"binary search,math"
import java.util.*;\npublic class Yo {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		   int n=sc.nextInt();\n		   int arr[]=new int[n];\n		   for(int i=0;i<n;i++)\n			   arr[i]=sc.nextInt();\n		   \n		   int ans=0;\n		   int k=Integer.MAX_VALUE;\n		   for(int i=0;i<n;i++)\n		   {  \n			  int t=(int)Math.ceil((arr[i]-i)*1.0/n);\n		      if(t<k)\n		      {\n		    	 k=t;\n		    	 ans=i+1;\n		      }\n		   }\n		   System.out.println(ans);\n	}\n	\n},"binary search,math"
import java.util.*;\npublic class z_7 {\n \n	public static void main(String[] args) {\n		Scanner s =new Scanner(System.in);\n		   int n=s.nextInt();\n		   int arr[]=new int[n];\n		   for(int i=0;i<n;i++)\n			   arr[i]=s.nextInt();\n		   \n		   int ans=0;\n		   int k=Integer.MAX_VALUE;\n		   for(int i=0;i<n;i++)\n		   {  \n			  int t=(int)Math.ceil((arr[i]-i)*1.0/n);\n		      if(t<k)\n		      {\n		    	 k=t;\n		    	 ans=i+1;\n		      }\n		   }\n		   System.out.println(ans);\n	}\n	\n},"binary search,math"
import java.util.Calendar;\nimport java.util.*;\nimport java.io.*;\nimport java.lang.*;\n//import java.math;\nimport java.util.Arrays; \npublic class Rathod \n{\n  public static void main(String[] args)\n  {\n  Scanner sc=new Scanner(System.in);\n  int n=sc.nextInt();\n  long ar[]=new long[n];\n  int i;\n  for(i=0;i<n;i++)\n  {\n   ar[i]=sc.nextLong();\n  }\n  long min=ar[0];\n  for(i=1;i<n;i++)\n  {\n   if(ar[i]<min)\n   min=ar[i];\n  }\n  long times=min/n;\n  min=(times-1)*n;\n  int flag=0;\n  int t=0;\n  long c=0;\n  while(flag!=1)\n  {\n      if((ar[t]-min-c)<=0)\n      break;\n      t=(t+1)%n;\n      c++;\n  }\n  System.out.println(t+1);\n  \n  }\n},"binary search,math"
"\nimport java.awt.Point;\nimport java.util.Scanner;\nimport java.util.SortedSet;\n\npublic class E {\n\n    static boolean merre(Point p1, Point p2) {\n        return Point.distance(p1.x + p2.x, p1.y + p2.y, 0, 0)\n                < Point.distance(p1.x - p2.x, p1.y - p2.y, 0, 0);\n    }\n\n    static int max = 1500000;\n\n    public static void main(String args[]) {\n        Scanner s = new Scanner(System.in);\n        int N = s.nextInt();\n        Point p[] = new Point[N];\n        int ir[] = new int[N];\n        Point H = new Point(0, 0);\n        for (int i = 0; i < N; i++) {\n            p[i] = new Point(s.nextInt(), s.nextInt());\n            if (merre(H, p[i])) {\n                ir[i] = 1;\n                H.x += p[i].x;\n                H.y += p[i].y;\n            } else {\n                ir[i] = -1;\n                H.x -= p[i].x;\n                H.y -= p[i].y;\n            }\n        }\n        while (Point.distance(H.x, H.y, 0, 0) > (max)) {\n            for (int i = 0; i < N; i++) {\n                if (Point.distance(H.x, H.y, 0, 0)\n                        > Point.distance(H.x - 2 * ir[i] * p[i].x, H.y - 2 * ir[i] * p[i].y, 0, 0)) {\n                    H.x -= 2 * ir[i] * p[i].x;\n                    H.y -= 2 * ir[i] * p[i].y;\n                    ir[i] *= -1;\n                }\n            }\n        }\n           for (int i = 0; i < N; i++) {\n               System.out.print(ir[i]+"" "");\n           }\n    }\n}\n","brute force,data structures,geometry,greedy,math,sortings"
"import java.util.*;\nimport java.io.*;\npublic class Main {\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public Scanner(FileReader fileReader) {\n            br = new BufferedReader(fileReader);\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n    static p[] arr;\n    static p cur;\n    static int[] ans;\n    public static class p{\n        int x;int y;\n        p(int x,int y){\n            this.x=x;this.y=y;\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);PrintWriter pw = new PrintWriter(System.out);\n        int n=sc.nextInt();arr = new p[n];for (int i=0;i<n;i++)arr[i] = new p(sc.nextInt(),sc.nextInt());\n        cur=arr[0];ans=new int[n];ans[0]=1;\n        for (int i=n-1;i>=1;i--){\n            ans[i]=move(i);\n        }\n        for (int i=0;i<ans.length;i++) System.out.print(ans[i]+"" "");\n    }\n    private static int move(int i) {\n        p a = new p(cur.x+arr[i].x,cur.y+arr[i].y);\n        p b = new p(cur.x-arr[i].x,cur.y-arr[i].y);\n        if (dist(a)<dist(b)) {cur=a;return 1;}\n        else cur=b;return -1;\n    }\n    private static double dist(p a) {\n        double x = (double) a.x;double y = (double)a.y;\n        return Math.abs(Math.sqrt(x*x+y*y));\n    }\n}","brute force,data structures,geometry,greedy,math,sortings"
"\nimport java.util.*;\n\npublic class hoyejabe\n{\n    static Scanner io = new Scanner(System.in);\n    static int n, ans[];\n    static Integer arr[];\n    static Vector[] vectors;\n\n    public static void main(String[] args)\n    {\n        int i;\n        vectors = new Vector[n = io.nextInt()];\n        ans = new int[n];\n        arr = new Integer[n];\n\n        for(i = 0; i < n; ++i) {\n            vectors[i] = new Vector(io.nextDouble(), io.nextDouble());\n            arr[i] = i;\n        }\n\n        Arrays.sort(arr, (Integer a, Integer b) -> -Double.compare(vectors[a].m, vectors[b].m));\n\n        Vector p = new Vector(0, 0);\n        for(i = 0; i < n; ++i)\n        {\n            Vector add = p.add(vectors[arr[i]]), sub = p.sub(vectors[arr[i]]);\n            if(add.m > sub.m)\n            {\n                ans[arr[i]] = -1;\n                p = sub;\n            }\n            else\n            {\n                ans[arr[i]] = 1;\n                p = add;\n            }\n        }\n        while(p.m > 225e10)\n        {\n            Vector temp;\n            for(i = 0; i < n; ++i)\n            {\n                if(ans[i] > 0)\n                {\n                    temp = p.sub(vectors[i]).sub(vectors[i]);\n                    if(temp.m < p.m)\n                    {\n                        p = temp;\n                        ans[i] = -1;\n                    }\n                }\n                else\n                {\n                    temp = p.add(vectors[i]).add(vectors[i]);\n                    if(temp.m < p.m)\n                    {\n                        p = temp;\n                        ans[i] = 1;\n                    }\n                }\n            }\n        }\n        for(int jk: ans)\n            System.out.print(jk + "" "");\n    }\n}\n\nclass Vector\n{\n    double x, y, m;\n    Vector(double a, double b)\n    {\n        x = a;  y = b;\n        m = x*x + y*y;\n    }\n    Vector add(Vector v)\n    {\n        return new Vector(x + v.x, y + v.y);\n    }\n    Vector sub(Vector v)\n    {\n        return new Vector(x - v.x, y - v.y);\n    }\n}","brute force,data structures,geometry,greedy,math,sortings"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.util.Collections;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		FastScanner in = new FastScanner(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		TaskC solver = new TaskC();\n		solver.solve(1, in, out);\n		out.close();\n	}\n\n	static class TaskC {\n		public void solve(int testNumber, FastScanner in, PrintWriter out) {\n			int n = in.nextInt();\n			List<Point> ps = new ArrayList<>();\n			for (int i = 0; i < n; i++) {\n				Point p = new Point();\n				p.x = in.nextInt();\n				p.y = in.nextInt();\n				p.id = i;\n				ps.add(p);\n			}\n			while (true) {\n				Collections.shuffle(ps);\n				int[] ans = new int[n];\n				long x = 0;\n				long y = 0;\n				for (Point p : ps) {\n					ans[p.id] = (x * p.x + y * p.y >= 0) ? -1 : +1;\n					x += ans[p.id] * p.x;\n					y += ans[p.id] * p.y;\n				}\n				if (x * x + y * y > (long) (2.25e12)) {\n					continue;\n				}\n				for (int i = 0; i < n; i++) {\n					if (i > 0) {\n						out.print("" "");\n					}\n					out.print(ans[i]);\n				}\n				out.println();\n				break;\n			}\n		}\n\n		class Point {\n			int id;\n			int x;\n			int y;\n\n		}\n\n	}\n\n	static class FastScanner {\n		private BufferedReader in;\n		private StringTokenizer st;\n\n		public FastScanner(InputStream stream) {\n			in = new BufferedReader(new InputStreamReader(stream));\n		}\n\n		public String next() {\n			while (st == null || !st.hasMoreTokens()) {\n				try {\n					String rl = in.readLine();\n					if (rl == null) {\n						return null;\n					}\n					st = new StringTokenizer(rl);\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n			return st.nextToken();\n		}\n\n		public int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n	}\n}\n\n","brute force,data structures,geometry,greedy,math,sortings"
"import java.util.*;\npublic class blend\n{\n	public static void main(String []args)\n	{\n		Scanner obj=new Scanner(System.in);\nString s=obj.nextLine();\n if((s.indexOf(""ABC"")!=-1)||(s.indexOf(""ACB"")!=-1)||(s.indexOf(""BAC"")!=-1)||(s.indexOf(""BCA"")!=-1)||(s.indexOf(""CAB"")!=-1)||(s.indexOf(""CBA"")!=-1))\n 	System.out.println(""YES"");\n else\n 	System.out.println(""NO"");\n}\n}","implementation,strings"
"import java.util.*;\npublic class blend\n{\n	public static void main(String []args)\n	{\n		Scanner obj=new Scanner(System.in);\nString s=obj.nextLine();\nif((s.indexOf(""ABC"")!=-1) || (s.indexOf(""ACB"")!=-1) || (s.indexOf(""BAC"")!=-1) || (s.indexOf(""BCA"")!=-1) || (s.indexOf(""CAB"")!=-1) || (s.indexOf(""CBA"")!=-1))System.out.println(""YES"");\n else\n 	System.out.println(""NO"");\n}\n}","implementation,strings"
"import java.util.Scanner;\n\npublic class _0534ABlendofSpringtime {\n\n	public static void main(String[] args) {\n		\n		Scanner sc = new Scanner(System.in);\n		String s=sc.nextLine();\n		if(s.contains(""ABC"")||s.contains(""ACB"")||s.contains(""BCA"")||s.contains(""BAC"")||s.contains(""CAB"")||s.contains(""CBA"")) {\n			System.out.println(""YES"");\n		}\n		else {\n			System.out.println(""NO"");\n		}\n	}\n\n}\n","implementation,strings"
"import java.util.*;\n\npublic class test1 {\n\n    public static void main(String[] args) {\n        Scanner sc= new Scanner(System.in);\n        String s=sc.next();\n\n        if(s.contains(""ABC"")||s.contains(""ACB"")||s.contains(""BAC"")||s.contains(""BCA"")||s.contains(""CAB"")||s.contains(""CBA""))\n            System.out.println(""YES"");\n\n        else\n            System.out.println(""NO"");\n    }\n}\n","implementation,strings"
import java.util.*;public class Main{public static void main(String[] args) {Scanner sc=new Scanner(System.in);int n=sc.nextInt();int t=sc.nextInt();for(int i=1;i<=t;i++){if(n%10==0){n=n/10;}else{n=n-1;}}System.out.print(n);}},implementation
import java.util.*;\npublic class nfdngg\n{public static void main(String args[])\n{Scanner sc= new Scanner(System.in);\nlong n=sc.nextLong();\nint k=sc.nextInt();\nfor(int i=0;i<k;i++)\n{if(n%10==0)\nn=n/10;\nelse\nn=n-1;}\nSystem.out.println(n);}},implementation
import java.util.*;\npublic class nfdngg\n{public static void main(String args[])\n{Scanner sc= new Scanner(System.in);\nlong n=sc.nextLong();\nint k=sc.nextInt();\nfor(int i=0;i<k;i++)\n{if(n%10==0)\nn=n/10;\nelse\nn=n-1;}\nSystem.out.println(n);}},implementation
import java.util.*;\npublic class nfdngg\n{public static void main(String args[])\n{Scanner sc= new Scanner(System.in);\nlong n=sc.nextLong();\nint k=sc.nextInt();\nfor(int i=0;i<k;i++)\n{if(n%10==0)\nn=n/10;\nelse\nn=n-1;}\nSystem.out.println(n);}},implementation
"import java.io.*;\nimport java.util.*;\n\npublic class E {\n    static int[] arr, node;\n    static boolean[] end;\n    static int[][] trie;\n    static int cnt = 1, n, ans = 0, MAX = (int)1e5 + 5;\n    static TreeMap<Integer, Integer>[] vals;\n    public static void main(String[] args) throws IOException{\n        FastIO file = new FastIO();\n        n = file.nextInt();\n        trie = new int[MAX][26]; // trie[node id][c] = the node id that the edge (with character c) points to\n        end = new boolean[MAX];\n        for (int i=0; i<n; i++){\n            String s = file.next();\n            ans += s.length();\n            int x = 0; // node pointer, starts at the root\n            for (int j=0; j<s.length(); j++){\n                if (trie[x][s.charAt(j) - 'a'] == 0){\n                    trie[x][s.charAt(j) - 'a'] = cnt++; // new node\n                }\n                x = trie[x][s.charAt(j) - 'a']; // update node pointer\n            }\n            end[x] = true; // end of a word\n        }\n        // DFS on trie, with merge small to large the deepest depth\n        vals = new TreeMap[cnt];\n        node = new int[cnt];\n        for (int i=0; i<cnt; i++){\n            vals[i] = new TreeMap<>();\n        }\n        solve(0, -1, 0);\n        file.println(ans);\n        file.close();\n    }\n    public static void solve(int at, int parent, int depth){\n        // 26 possible edges\n        int big = at;\n        for (int i=0; i<26; i++){\n            if (trie[at][i] != 0 && trie[at][i] != parent){\n                solve(trie[at][i], at, depth+1);\n                if (vals[trie[at][i]].size() > big){\n                    big = node[trie[at][i]];\n                }\n            }\n        }\n        node[at] = big;\n        for (int i=0; i<26; i++){\n            if (trie[at][i] != 0 && trie[at][i] != parent && node[trie[at][i]] != big){\n                for (int x : vals[node[trie[at][i]]].keySet()){\n                    add(x, vals[node[trie[at][i]]].get(x), vals[node[at]]);\n                }\n            }\n        }\n        if (at == 0){\n            return;\n        }\n        if (end[at]){\n            add(depth, 1, vals[node[at]]);\n        }else{\n            // For every node, after merging small to large, we take the node with greatest depth\n            int deepest = vals[node[at]].lastKey();\n            if (depth >= deepest){\n                throw null;\n            }\n            ans -= deepest-depth;\n            remove(deepest,vals[node[at]]);\n            add(depth, 1, vals[node[at]]);\n        }\n    }\n    public static void add(int elem, int times, TreeMap<Integer, Integer> map){\n        if (!map.containsKey(elem)){\n            map.put(elem, times);\n        }else{\n            map.put(elem, map.get(elem)+times);\n        }\n    }\n    public static void remove(int elem, TreeMap<Integer, Integer> map){\n        map.put(elem, map.get(elem)-1);\n        if (map.get(elem) == 0){\n            map.remove(elem);\n        }\n    }\n    static class FastIO extends PrintWriter {\n        private InputStream stream;\n        private byte[] buf = new byte[1<<16];\n        private int curChar, numChars;\n    \n        public FastIO() { this(System.in,System.out); }\n        public FastIO(InputStream i, OutputStream o) {\n            super(o);\n            stream = i;\n        }\n        public FastIO(String i, String o) throws IOException {\n            super(new FileWriter(o));\n            stream = new FileInputStream(i);\n        }\n        public FastIO(String i) throws IOException {\n            super(System.out);\n            stream = new FileInputStream(i);\n        }\n        // throws InputMismatchException() if previously detected end of file\n        private int nextByte() {\n            if (numChars == -1) throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars == -1) return -1; // end of file\n            }\n            return buf[curChar++];\n        }\n        // to read in entire lines, replace c <= ' '\n        // with a function that checks whether c is a line break\n        public String next() {\n            int c; do { c = nextByte(); } while (c <= ' ');\n            StringBuilder res = new StringBuilder();\n            do { res.appendCodePoint(c); c = nextByte(); } while (c > ' ');\n            return res.toString();\n        }\n        public int nextInt() {\n            int c; do { c = nextByte(); } while (c <= ' ');\n            int sgn = 1; if (c == '-') { sgn = -1; c = nextByte(); }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res = 10*res+c-'0';\n                c = nextByte();\n            } while (c > ' ');\n            return res * sgn;\n        }\n        public long nextLong() {\n            int c; do { c = nextByte(); } while (c <= ' ');\n            int sgn = 1; if (c == '-') { sgn = -1; c = nextByte(); }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res = 10*res+c-'0';\n                c = nextByte();\n            } while (c > ' ');\n            return res * sgn;\n        }\n        public double nextDouble() { return Double.parseDouble(next()); }\n    }\n}","data structures,dp,greedy,strings,trees"
"import java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class eeee {\n	static int n;\n	\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		n = in.nextInt();\n		Trie t = new Trie();\n\n		for (int i=0; i<n; i++) \n			t.add(in.next().toCharArray());\n		Iterator<Integer> it = solve(t.root,0).iterator();\n		int sum = 0;\n		while(it.hasNext())\n			sum += it.next();\n		System.out.println(sum);\n		\n	}\n	\n	static PriorityQueue<Integer> solve(Node cur, int depth) {\n		PriorityQueue<Integer> ans = new PriorityQueue<Integer>(n, new Reverse());\n		\n		for (int i=0; i<26; i++) {\n			if (cur.go[i] != null) {\n				PriorityQueue<Integer> t = solve(cur.go[i], depth+1);\n				ans.addAll(t);\n			}\n		}\n		if (cur.term) {\n			ans.add(depth);\n		} else if (depth>0) {\n			ans.remove();\n			ans.add(depth);\n		}\n		return ans;\n	}\n	\n	static class Reverse implements Comparator<Integer>{\n		public int compare(Integer s1, Integer s2) {\n			if (s1 < s2)\n				return 1;\n			else if (s1 > s2)\n				return -1;\n			return 0;\n		}\n	}\n	\n	static class Trie {\n		Node root = new Node();\n		\n		void add(char word[]) {\n			Node cur = root;\n			for (char c : word) {\n				if (cur.go[c-'a'] == null)\n					cur.go[c-'a'] = new Node();\n				cur = cur.go[c-'a'];\n			}\n			cur.term = true;\n		}\n	}\n\n	static class Node {\n		Node go[] = new Node[26];\n		boolean term = false;\n	}\n}\n","data structures,dp,greedy,strings,trees"
"import java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class e965 {\n	static int n;\n	static Reverse reverse = new Reverse();\n	\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		n = in.nextInt();\n		Trie t = new Trie();\n\n		for (int i=0; i<n; i++) \n			t.add(in.next().toCharArray());\n		Iterator<Integer> it = solve(t.root,0).iterator();\n		int sum = 0;\n		while(it.hasNext())\n			sum += it.next();\n		System.out.println(sum);\n		\n	}\n	\n	static PriorityQueue<Integer> solve(Node cur, int depth) {\n		PriorityQueue<Integer> ans = new PriorityQueue<Integer>(n, reverse);\n		\n		for (int i=0; i<26; i++) {\n			if (cur.go[i] != null) {\n				PriorityQueue<Integer> t = solve(cur.go[i], depth+1);\n				ans.addAll(t);\n			}\n		}\n		if (cur.term) {\n			ans.add(depth);\n		} else if (depth>0) {\n			ans.remove();\n			ans.add(depth);\n		}\n		return ans;\n	}\n	\n	static class Reverse implements Comparator<Integer>{\n		public int compare(Integer s1, Integer s2) {\n			if (s1 < s2)\n				return 1;\n			else if (s1 > s2)\n				return -1;\n			return 0;\n		}\n	}\n	\n	static class Trie {\n		Node root = new Node();\n		\n		void add(char word[]) {\n			Node cur = root;\n			for (char c : word) {\n				if (cur.go[c-'a'] == null)\n					cur.go[c-'a'] = new Node();\n				cur = cur.go[c-'a'];\n			}\n			cur.term = true;\n		}\n	}\n\n	static class Node {\n		Node go[] = new Node[26];\n		boolean term = false;\n	}\n}\n","data structures,dp,greedy,strings,trees"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\npublic class TrieProblem {\n\n	public static void main(String[] args) {\n		FastScanner fs=new FastScanner();\n		int n=fs.nextInt();\n		Trie trie=new Trie();\n		trie.isRoot=true;\n		for (int i=0; i<n; i++)\n			trie.addWord(fs.next().toCharArray(), 0);\n\n		PriorityQueue<Integer> returned=trie.dfs();\n		int offset=trie.offset;\n		long total=0;\n		for (int i:returned) {\n			total+=i+offset;\n		}\n		System.out.println(total);\n	}\n	\n	private static class Trie implements Comparable<Trie> {\n		boolean isWord=false;\n		boolean isRoot=false;\n		Trie[] connected=new Trie[26];\n		ArrayList<Trie> children=new ArrayList<>();\n		int size=0;\n		int offset=0;\n		\n		public void addWord(char[] word, int index) {\n			size++;\n			if (index==word.length) {\n				isWord=true;\n				return;\n			}\n			int relevantEdge=word[index]-'a';\n			if (connected[relevantEdge]==null)\n				connected[relevantEdge]=new Trie();\n			connected[relevantEdge].addWord(word, index+1);\n		}\n\n		public int compareTo(Trie o) {\n			return size-o.size;\n		}\n		\n		public PriorityQueue<Integer> dfs() {\n			for (Trie t:connected) if (t!=null) children.add(t);\n			Collections.sort(children);\n			\n			if (children.isEmpty()) {\n				PriorityQueue<Integer> toReturn=new PriorityQueue<>((a, b)-> {return b-a;});\n				toReturn.add(0);\n				offset=0;\n				return toReturn;\n			}\n			\n			PriorityQueue<Integer> toReturn=children.get(0).dfs();\n			offset=children.get(0).offset+1;\n			for (int i=1; i<children.size(); i++) {\n				PriorityQueue<Integer> returned=children.get(i).dfs();\n				int oldOffset=children.get(i).offset+1;\n				for (int j:returned)\n					toReturn.add(j+oldOffset-offset);\n			}\n			if (!isRoot) {\n				if (!isWord)\n					toReturn.remove();\n				toReturn.add(0-offset);\n			}\n			return toReturn;\n		}\n		\n	}\n	\n	private static class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n		\n		public FastScanner() {\n			this(System.in);\n		}\n		public FastScanner(InputStream in) {\n			br = new BufferedReader(new InputStreamReader(in));\n		}\n		String next() {\n			while (st == null || !st.hasMoreElements()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			}\n			return st.nextToken();\n		}\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n		String nextLine() {\n			String str = """";\n			try {\n				str = br.readLine();\n			} catch (IOException e) {\n				e.printStackTrace();\n			}\n			return str;\n		}\n		int[] readArray(int n) {\n			int[] a=new int[n];\n			for (int i=0; i<n; i++)\n				a[i]=nextInt();\n			return a;\n		}\n		long[] readLongArray(int n) {\n			long[] a=new long[n];\n			for (int i=0; i<n; i++)\n				a[i]=nextLong();\n			return a;\n		}\n	}\n\n}\n","data structures,dp,greedy,strings,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class Main{\n	static int mod=(int)1e9+9,prime=31;\n	static long[]hashIn;\n	static long powerofP[],invpofp[];\n	static char[]in;\n	\n	static void preHash(int n) {\n		powerofP=new long[n+1];\n		invpofp=new long[n+1];\n		powerofP[0]=1;\n		invpofp[0]=1;\n		for(int i=1;i<powerofP.length;i++) {\n			powerofP[i]=(powerofP[i-1]*prime)%mod;\n			invpofp[i]=fastpow(powerofP[i], mod-2,mod);\n		}\n		hashIn=new long[n+1];\n		long p=1;\n		for(int i=1;i<=n;i++) {\n			hashIn[i]=(p*(in[i-1]-'a'+1))%mod;\n			hashIn[i]=(hashIn[i]+hashIn[i-1])%mod;\n			p=(p*prime)%mod;\n		}\n	}\n	\n	static long fastpow(long n,long ti,int mod3) {\n		 if (ti == 0) \n		        return 1l;\n		if(ti%2==0) {\n			long y=fastpow(n, ti/2,mod3);\n			long k=y*y;\n			k%=mod3;\n			return k;\n		}\n		else {\n			long y=fastpow(n, ti/2,mod3);\n			long k=((n*y)%mod3)*y;\n			k%=mod3;\n			return k;\n		}\n	}\n	//the hash value of substring 1 based [l,r] depending on mod , prime\n	static long compHash(int l,int r) {\n		l++;r++;\n		long val=(hashIn[r]-hashIn[l-1]+mod)%mod;\n		val=(val*invpofp[l-1])%mod;\n		return val;\n	}\n	\n	static void main() throws Exception{\n		int n=sc.nextInt();\n		in=(sc.nextLine()).toCharArray();\n		preHash(n);\n		int[]ans=new int[n];\n		for(int i=0;i<n;i++) {\n			ans[i]=-1;\n		}\n		for(int center=0;center<n/2;center++) {\n			int cPrefix=center,cSuffix=n-center-1;\n			\n			int lo=0,hi=Math.min(cPrefix, n-1-cSuffix);\n			int k=-1,len=0;\n			while(lo<=hi) {\n				int mid=(lo+hi)>>1;\n				if(compHash(cPrefix-mid,cPrefix+mid)==compHash(cSuffix-mid,cSuffix+mid)) {\n					len=2*mid+1;k=cPrefix-mid;\n					lo=mid+1;\n				}\n				else {\n					hi=mid-1;\n				}\n			}\n			if(k!=-1) {\n				ans[k]=Math.max(ans[k], len);\n			}\n		}\n		for(int i=0;i<n/2;i++) {\n			int last=i==0?-1:(ans[i-1]-2);\n			ans[i]=Math.max(last, ans[i]);\n			pw.print(ans[i]+"" "");\n		}\n		if(n%2==1) {\n			pw.println(-1);\n		}\n		else {\n			pw.println();\n		}\n	}\n	public static void main(String[] args) throws Exception{\n		sc=new MScanner(System.in);\n		pw = new PrintWriter(System.out);\n		int tc=1;\n//		tc=sc.nextInt();\n		while(tc-->0)\n			main();\n		pw.flush();\n	}\n	static PrintWriter pw;\n	static MScanner  sc;\n	static class MScanner {\n		StringTokenizer st;\n		BufferedReader br;\n		public MScanner(InputStream system) {\n			br = new BufferedReader(new InputStreamReader(system));\n		}\n \n		public MScanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n \n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n		public int[] intArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public long[] longArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public int[] intSortedArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		public long[] longSortedArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		public Integer[] IntegerArr(int n) throws IOException {\n	        Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public Long[] LongArr(int n) throws IOException {\n	        Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n \n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n \n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n \n		public char nextChar() throws IOException {\n			return next().charAt(0);\n		}\n \n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n \n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n \n		public void waitForInput() throws InterruptedException {\n			Thread.sleep(3000);\n		}\n	}\n	static void shuffle(int[]in) {\n		for(int i=0;i<in.length;i++) {\n			int idx=(int)(Math.random()*in.length);\n			int tmp=in[i];\n			in[i]=in[idx];\n			in[idx]=tmp;\n		}\n	}\n	static void shuffle(long[]in) {\n		for(int i=0;i<in.length;i++) {\n			int idx=(int)(Math.random()*in.length);\n			long tmp=in[i];\n			in[i]=in[idx];\n			in[idx]=tmp;\n		}\n	}\n}","binary search,hashing,string suffix structures"
"import java.io.*;\nimport java.util.*;\n\npublic class Main{\n	static public class suffixArrayIterative {\n		int[][]arrs;\n		char[]in;\n		int n;\n		public suffixArrayIterative(char[]in) {//has a terminating character (e.g. '$')\n			this.n=in.length;//O(n*log(n))\n			this.in=in;\n			\n			arrs=solve();\n			arr=lcpArr();\n			preProcess(n);\n		}\n		int[] saArr() {\n			return arrs[0];\n		}\n		int[] cArr() {\n			return arrs[1];\n		}\n		int[][] solve(){\n			int n=in.length;//O(n*log(n))\n			int[][]a=new int[n][2];\n			for(int i=0;i<in.length;i++) {\n				a[i]=new int[] {in[i]-'a',i};\n			}\n			Arrays.sort(a,(x,y)->x[0]-y[0]);\n			int[]sa=new int[n],c=new int[n];\n			for(int i=0;i<n;i++) {\n				sa[i]=a[i][1];\n			}\n			c[a[0][1]]=0;\n			for(int i=1;i<n;i++) {\n				c[a[i][1]]=(a[i][0]==a[i-1][0])?c[a[i-1][1]]:c[a[i-1][1]]+1;\n			}\n			int k=0;\n			while((1<<k)<n) {\n				for(int i=0;i<n;i++) {\n					sa[i]=(sa[i]+n-(1<<k))%n;\n				}\n				sa=countingSort(sa, c);\n				\n				int[]newc=new int[n];\n				newc[sa[0]]=0;\n				for(int i=1;i<n;i++) {\n					int[]curPair=new int[] {c[sa[i]],c[(sa[i]+(1<<k))%n]};\n					int[]prevPair=new int[] {c[sa[i-1]],c[(sa[i-1]+(1<<k))%n]};\n					newc[sa[i]]=(compare(prevPair, curPair)==0)?newc[sa[i-1]]:(newc[sa[i-1]]+1);\n				}\n				c=newc;\n				k++;\n			}\n			return new int[][] {sa,c};\n		}\n		\n		int compare(int[]x,int[]y) {\n			return x[0]!=y[0]?x[0]-y[0]:x[1]-y[1];\n		}\n		int[] countingSort(int[]sa,int[]c) {\n			int n=sa.length;\n			int[]cnt=new int[n];\n			for(int i:sa) {\n				cnt[c[i]]++;\n			}\n			int[]pointers=new int[n];\n			pointers[0]=0;\n			for(int i=1;i<n;i++) {\n				pointers[i]=pointers[i-1]+cnt[i-1];\n			}\n			int[]newSa=new int[n];\n			for(int i:sa) {\n				newSa[pointers[c[i]]++]=i;\n			}\n			return newSa;\n		}\n		int[] lcpArr() {\n			int[]sa=saArr();\n			int[]c=cArr();\n			int[]lcp=new int[n];\n			int k=0;\n			for(int i=0;i<n-1;i++) {\n				int cur=i,prev=sa[c[i]-1];\n				while(in[cur+k]==in[prev+k])k++;\n				lcp[c[i]]=k;\n				k=Math.max(k-1, 0);\n			}\n			return lcp;\n		}\n		int[]log,min[],arr;\n		int inf=(int)1e9;\n		int query(int l,int r) {\n			int len = r - l + 1;\n			int lg = log[len];\n			int u = min[l][lg];\n			int v = min[r - (1 << lg) + 1][lg];\n			int bestIdx = arr[u] < arr[v] ? u : v;\n			return arr[bestIdx];\n		}\n		void preProcess(int n) {\n			log = new int[n+1];\n			for (int i = 2; i <= n; i++)\n				log[i] = log[i / 2] + 1;\n			\n			min=new int[n][22];\n			for(int i=0;i<n;i++) {\n				min[i][0]=i;\n			}\n			for(int i=1,len=2;len<=n;i++,len<<=1) {\n				for(int j=0;j<n;j++) {\n					int u=min[j][i-1],v=j+(len>>1)>=n?inf:min[j+(len>>1)][i-1];\n					if(v==inf) {\n						min[j][i]=u;\n					}\n					else\n						min[j][i]=(arr[u]<arr[v]?u:v);\n				}\n			}\n		}\n		boolean equalSub(int[]x,int[]y) {\n			int[]c=cArr();\n			if(x[0]==y[0]) {\n				return x[1]==y[1];\n			}\n			int lenX=x[1]-x[0]+1,lenY=y[1]-y[0]+1;\n			int left=Math.min(c[x[0]], c[y[0]]),right=Math.max(c[x[0]], c[y[0]]);\n			int lcp=query(left+1, right);\n			if(lcp>=Math.min(lenX, lenY)) {\n				return lenX==lenY;\n			}\n			return false;\n		}\n	}\n	static void main() throws Exception{\n		int n=sc.nextInt();\n		char[]s=(sc.nextLine()+'$').toCharArray();\n		suffixArrayIterative sa=new suffixArrayIterative(s);\n		\n		int[]ans=new int[n];\n		for(int i=0;i<n;i++) {\n			ans[i]=-1;\n		}\n		for(int center=0;center<n/2;center++) {\n			int cPrefix=center,cSuffix=n-center-1;\n			if(s[cPrefix]!=s[cSuffix])continue;\n			int lo=0,hi=Math.min(cPrefix, n-1-cSuffix);\n			int k=-1,len=0;\n			while(lo<=hi) {\n				int mid=(lo+hi)>>1;\n				if(sa.equalSub(new int[] {cPrefix-mid,cPrefix+mid}, new int[] {cSuffix-mid,cSuffix+mid})) {\n					len=2*mid+1;k=cPrefix-mid;\n					lo=mid+1;\n				}\n				else {\n					hi=mid-1;\n				}\n			}\n			if(k!=-1) {\n				ans[k]=Math.max(ans[k], len);\n			}\n		}\n		for(int i=0;i<n/2;i++) {\n			int last=i==0?-1:(ans[i-1]-2);\n			ans[i]=Math.max(last, ans[i]);\n			pw.print(ans[i]+"" "");\n		}\n		if((n&1)==1) {\n			pw.println(-1);\n		}\n		else {\n			pw.println();\n		}\n	}\n	public static void main(String[] args) throws Exception{\n		sc=new MScanner(System.in);\n		pw = new PrintWriter(System.out);\n		int tc=1;\n//		tc=sc.nextInt();\n		while(tc-->0)\n			main();\n		pw.flush();\n	}\n	static PrintWriter pw;\n	static MScanner  sc;\n	static class MScanner {\n		StringTokenizer st;\n		BufferedReader br;\n		public MScanner(InputStream system) {\n			br = new BufferedReader(new InputStreamReader(system));\n		}\n \n		public MScanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n \n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n		public int[] intArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public long[] longArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public int[] intSortedArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		public long[] longSortedArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		public Integer[] IntegerArr(int n) throws IOException {\n	        Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public Long[] LongArr(int n) throws IOException {\n	        Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n \n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n \n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n \n		public char nextChar() throws IOException {\n			return next().charAt(0);\n		}\n \n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n \n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n \n		public void waitForInput() throws InterruptedException {\n			Thread.sleep(3000);\n		}\n	}\n	static void shuffle(int[]in) {\n		for(int i=0;i<in.length;i++) {\n			int idx=(int)(Math.random()*in.length);\n			int tmp=in[i];\n			in[i]=in[idx];\n			in[idx]=tmp;\n		}\n	}\n	static void shuffle(long[]in) {\n		for(int i=0;i<in.length;i++) {\n			int idx=(int)(Math.random()*in.length);\n			long tmp=in[i];\n			in[i]=in[idx];\n			in[idx]=tmp;\n		}\n	}\n}","binary search,hashing,string suffix structures"
"\n\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Created by dalt on 2018/4/11.\n */\npublic class CF961F {\n    static final int INF = (int) 1e8;\n    static final int MOD = (int) 1e9 + 7;\n    public static BlockReader input;\n    public static PrintStream output;\n    public static Debug debug;\n\n    public static void main(String[] args) throws FileNotFoundException {\n        init();\n\n        solve();\n\n        destroy();\n    }\n\n    public static void init() throws FileNotFoundException {\n        if (System.getProperty(""ONLINE_JUDGE"") == null) {\n            input = new BlockReader(new FileInputStream(""D:\\DataBase\\TESTCASE\\codeforces\\CF961F.in""));\n            //output = System.out;\n            output = new PrintStream(new BufferedOutputStream(System.out), false);\n        } else {\n            input = new BlockReader(System.in);\n            output = new PrintStream(new BufferedOutputStream(System.out), false);\n        }\n\n        debug = new Debug();\n        debug.enter(""main"");\n    }\n\n    public static void solve() {\n        int n = input.nextInteger();\n        char[] data = new char[n];\n        input.nextBlock(data, 0);\n\n\n        int[] rcpos = new int[n];\n\n        int blc, brc;\n        if (n % 2 == 0) {\n            blc = n / 2 - 1;\n            brc = blc + 1;\n        } else {\n            blc = n / 2 - 1;\n            brc = blc + 2;\n        }\n        int lc = blc;\n        int rc = brc;\n        int covered = -1;\n\n        Hash[] hash = new Hash[]{new Hash(data, 31)};\n\n        while (lc >= 0) {\n            if (data[lc] == data[rc]) {\n                int maxRadius = binarySearch(hash, lc, rc, data);\n                int until = rc + maxRadius;\n                for (covered = Math.max(covered, rc); covered <= until; covered++) {\n                    rcpos[covered] = rc;\n                }\n            }\n            lc--;\n            rc++;\n        }\n\n\n        for (int i = n - 1; i >= brc; i--) {\n            if (rcpos[i] == 0) {\n                output.print(""-1 "");\n            } else {\n                int radius = i - rcpos[i];\n                output.print((radius << 1) + 1);\n                output.print(' ');\n            }\n        }\n        if (n % 2 == 1) {\n            output.print(""-1 "");\n        }\n    }\n\n    public static void destroy() {\n        output.flush();\n        debug.exit();\n        debug.statistic();\n    }\n\n    public static int binarySearch(Hash[] hash, int lc, int rc, char[] data) {\n        int max = lc;\n        int min = 0;\n        while (min < max) {\n            int m = (min + max + 1) >> 1;\n            boolean equal = true;\n            for (Hash h : hash) {\n                if (h.getHash(lc - m, lc + m) != h.getHash(rc - m, rc + m)) {\n                    equal = false;\n                    break;\n                }\n            }\n            if (equal) {\n                min = m;\n            } else {\n                max = m - 1;\n            }\n        }\n        return min;\n    }\n\n    public static class Hash {\n        public int[] rev;\n        public int[] batch;\n        public int n;\n        public int base;\n\n        public Hash(char[] data, int base) {\n            n = data.length;\n            rev = new int[n];\n            this.base = base;\n            rev[0] = 1;\n            long reverse = pow(base, MOD - 2);\n            for (int i = 1; i < n; i++) {\n                this.rev[i] = (int) (this.rev[i - 1] * reverse % MOD);\n            }\n\n            batch = new int[n];\n            batch[n - 1] = data[n - 1];\n            long baseInc = 1;\n            for (int i = n - 2; i >= 0; i--) {\n                baseInc = baseInc * base % MOD;\n                batch[i] = (int) (((long) batch[i + 1] + data[i] * baseInc) % MOD);\n            }\n        }\n\n        public static long pow(int x, int n) {\n            int bit = 31 - Integer.numberOfLeadingZeros(n);\n            long product = 1;\n            for (; bit >= 0; bit--) {\n                product = product * product % MOD;\n                if (((1 << bit) & n) != 0) {\n                    product = product * x % MOD;\n                }\n            }\n            return product;\n        }\n\n        public int getHash(int l, int r) {\n            long hash = batch[l];\n            if (r < n - 1) {\n                hash = hash - batch[r + 1];\n                if (hash < 0) {\n                    hash += MOD;\n                }\n                hash = hash * rev[n - 1 - r] % MOD;\n            }\n            return (int) hash;\n        }\n    }\n\n    public static class Debug {\n        boolean debug = System.getProperty(""ONLINE_JUDGE"") == null;\n        Deque<ModuleRecorder> stack = new ArrayDeque<>();\n        StringBuilder msg = new StringBuilder();\n        Map<String, Module> fragmentMap = new HashMap<>();\n\n        public void enter(String module) {\n            if (debug) {\n                stack.push(new ModuleRecorder(getModule(module)));\n            }\n        }\n\n        public Module getModule(String moduleName) {\n            Module module = fragmentMap.get(moduleName);\n            if (module == null) {\n                module = new Module(moduleName);\n                fragmentMap.put(moduleName, module);\n            }\n            return module;\n        }\n\n        public void exit() {\n            if (debug) {\n                ModuleRecorder fragment = stack.pop();\n                fragment.exit();\n            }\n        }\n\n        public void statistic() {\n            if (!debug) {\n                return;\n            }\n\n            if (stack.size() > 0) {\n                throw new RuntimeException(""Exist unexited tag"");\n            }\n            System.out.println(""\n------------------------------------------"");\n\n            System.out.println(""memory used "" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + ""M"");\n\n            System.out.println(""\n------------------------------------------"");\n            for (Module module : fragmentMap.values()) {\n                System.out.println(String.format(""MOD %s : enter %d : cost %d"", module.moduleName, module.enterTime, module.totaltime));\n            }\n\n            System.out.println(""------------------------------------------"");\n        }\n\n        public static class ModuleRecorder {\n            Module fragment;\n            long time;\n\n            public ModuleRecorder(Module fragment) {\n                this.fragment = fragment;\n                time = System.currentTimeMillis();\n            }\n\n            public void exit() {\n                fragment.totaltime += System.currentTimeMillis() - time;\n                fragment.enterTime++;\n            }\n        }\n\n        public static class Module {\n            String moduleName;\n            long totaltime;\n            long enterTime;\n\n            public Module(String moduleName) {\n                this.moduleName = moduleName;\n            }\n        }\n    }\n\n    public static class BlockReader {\n        static final int EOF = -1;\n        InputStream is;\n        byte[] dBuf;\n        int dPos, dSize, next;\n        StringBuilder builder = new StringBuilder();\n\n        public BlockReader(InputStream is) {\n            this(is, 8192);\n        }\n\n        public BlockReader(InputStream is, int bufSize) {\n            this.is = is;\n            dBuf = new byte[bufSize];\n            next = nextByte();\n        }\n\n        public int nextByte() {\n            while (dPos >= dSize) {\n                if (dSize == -1) {\n                    return EOF;\n                }\n                dPos = 0;\n                try {\n                    dSize = is.read(dBuf);\n                } catch (Exception e) {\n                }\n            }\n            return dBuf[dPos++];\n        }\n\n        public String nextBlock() {\n            builder.setLength(0);\n            skipBlank();\n            while (next != EOF && !Character.isWhitespace(next)) {\n                builder.append((char) next);\n                next = nextByte();\n            }\n            return builder.toString();\n        }\n\n        public void skipBlank() {\n            while (Character.isWhitespace(next)) {\n                next = nextByte();\n            }\n        }\n\n        public int nextInteger() {\n            skipBlank();\n            int ret = 0;\n            boolean rev = false;\n            if (next == '+' || next == '-') {\n                rev = next == '-';\n                next = nextByte();\n            }\n            while (next >= '0' && next <= '9') {\n                ret = (ret << 3) + (ret << 1) + next - '0';\n                next = nextByte();\n            }\n            return rev ? -ret : ret;\n        }\n\n        public int nextBlock(char[] data, int offset) {\n            skipBlank();\n            int index = offset;\n            int bound = data.length;\n            while (next != EOF && index < bound && !Character.isWhitespace(next)) {\n                data[index++] = (char) next;\n                next = nextByte();\n            }\n            return index - offset;\n        }\n\n        public boolean hasMore() {\n            skipBlank();\n            return next != EOF;\n        }\n    }\n}\n","binary search,hashing,string suffix structures"
"\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Created by dalt on 2018/4/11.\n */\npublic class CF961F {\n    static final int INF = (int) 1e8;\n    static final int MOD = (int) 1e9 + 7;\n    public static BlockReader input;\n    public static PrintStream output;\n    public static Debug debug;\n\n    public static void main(String[] args) throws FileNotFoundException {\n        init();\n\n        solve();\n\n        destroy();\n    }\n\n    public static void init() throws FileNotFoundException {\n        if (System.getProperty(""ONLINE_JUDGE"") == null) {\n            input = new BlockReader(new FileInputStream(""D:\\DataBase\\TESTCASE\\codeforces\\CF961F.in""));\n            //output = System.out;\n            output = new PrintStream(new BufferedOutputStream(System.out), false);\n        } else {\n            input = new BlockReader(System.in);\n            output = new PrintStream(new BufferedOutputStream(System.out), false);\n        }\n\n        debug = new Debug();\n        debug.enter(""main"");\n    }\n\n    public static void solve() {\n        int n = input.nextInteger();\n        char[] data = new char[n];\n        input.nextBlock(data, 0);\n\n\n        int[] rcpos = new int[n];\n\n        int blc, brc;\n        if (n % 2 == 0) {\n            blc = n / 2 - 1;\n            brc = blc + 1;\n        } else {\n            blc = n / 2 - 1;\n            brc = blc + 2;\n        }\n        int lc = blc;\n        int rc = brc;\n        int covered = -1;\n\n        Hash[] hash = new Hash[]{new Hash(data, 31), new Hash(data, 67), new Hash(data, 11)};\n\n        while (lc >= 0) {\n            if (data[lc] == data[rc]) {\n                int maxRadius = binarySearch(hash, lc, rc, data);\n                int until = rc + maxRadius;\n                for (covered = Math.max(covered, rc); covered <= until; covered++) {\n                    rcpos[covered] = rc;\n                }\n            }\n            lc--;\n            rc++;\n        }\n\n\n        for (int i = n - 1; i >= brc; i--) {\n            if (rcpos[i] == 0) {\n                output.print(""-1 "");\n            } else {\n                int radius = i - rcpos[i];\n                output.print((radius << 1) + 1);\n                output.print(' ');\n            }\n        }\n        if (n % 2 == 1) {\n            output.print(""-1 "");\n        }\n    }\n\n    public static void destroy() {\n        output.flush();\n        debug.exit();\n        debug.statistic();\n    }\n\n    public static int binarySearch(Hash[] hash, int lc, int rc, char[] data) {\n        int max = lc;\n        int min = 0;\n        while (min < max) {\n            int m = (min + max + 1) >> 1;\n            boolean equal = true;\n            for (Hash h : hash) {\n                if (h.getHash(lc - m, lc + m) != h.getHash(rc - m, rc + m)) {\n                    equal = false;\n                    break;\n                }\n            }\n            if (equal) {\n                min = m;\n            } else {\n                max = m - 1;\n            }\n        }\n        return min;\n    }\n\n    public static class Hash {\n        public int[] rev;\n        public int[] batch;\n        public int n;\n        public int base;\n\n        public Hash(char[] data, int base) {\n            n = data.length;\n            rev = new int[n];\n            this.base = base;\n            rev[0] = 1;\n            long reverse = pow(base, MOD - 2);\n            for (int i = 1; i < n; i++) {\n                this.rev[i] = (int) (this.rev[i - 1] * reverse % MOD);\n            }\n\n            batch = new int[n];\n            batch[n - 1] = data[n - 1];\n            long baseInc = 1;\n            for (int i = n - 2; i >= 0; i--) {\n                baseInc = baseInc * base % MOD;\n                batch[i] = (int) (((long) batch[i + 1] + data[i] * baseInc) % MOD);\n            }\n        }\n\n        public static long pow(int x, int n) {\n            int bit = 31 - Integer.numberOfLeadingZeros(n);\n            long product = 1;\n            for (; bit >= 0; bit--) {\n                product = product * product % MOD;\n                if (((1 << bit) & n) != 0) {\n                    product = product * x % MOD;\n                }\n            }\n            return product;\n        }\n\n        public int getHash(int l, int r) {\n            long hash = batch[l];\n            if (r < n - 1) {\n                hash = hash - batch[r + 1];\n                if (hash < 0) {\n                    hash += MOD;\n                }\n                hash = hash * rev[n - 1 - r] % MOD;\n            }\n            return (int) hash;\n        }\n    }\n\n    public static class Debug {\n        boolean debug = System.getProperty(""ONLINE_JUDGE"") == null;\n        Deque<ModuleRecorder> stack = new ArrayDeque<>();\n        StringBuilder msg = new StringBuilder();\n        Map<String, Module> fragmentMap = new HashMap<>();\n\n        public void enter(String module) {\n            if (debug) {\n                stack.push(new ModuleRecorder(getModule(module)));\n            }\n        }\n\n        public Module getModule(String moduleName) {\n            Module module = fragmentMap.get(moduleName);\n            if (module == null) {\n                module = new Module(moduleName);\n                fragmentMap.put(moduleName, module);\n            }\n            return module;\n        }\n\n        public void exit() {\n            if (debug) {\n                ModuleRecorder fragment = stack.pop();\n                fragment.exit();\n            }\n        }\n\n        public void statistic() {\n            if (!debug) {\n                return;\n            }\n\n            if (stack.size() > 0) {\n                throw new RuntimeException(""Exist unexited tag"");\n            }\n            System.out.println(""\n------------------------------------------"");\n\n            System.out.println(""memory used "" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + ""M"");\n\n            System.out.println(""\n------------------------------------------"");\n            for (Module module : fragmentMap.values()) {\n                System.out.println(String.format(""MOD %s : enter %d : cost %d"", module.moduleName, module.enterTime, module.totaltime));\n            }\n\n            System.out.println(""------------------------------------------"");\n        }\n\n        public static class ModuleRecorder {\n            Module fragment;\n            long time;\n\n            public ModuleRecorder(Module fragment) {\n                this.fragment = fragment;\n                time = System.currentTimeMillis();\n            }\n\n            public void exit() {\n                fragment.totaltime += System.currentTimeMillis() - time;\n                fragment.enterTime++;\n            }\n        }\n\n        public static class Module {\n            String moduleName;\n            long totaltime;\n            long enterTime;\n\n            public Module(String moduleName) {\n                this.moduleName = moduleName;\n            }\n        }\n    }\n\n    public static class BlockReader {\n        static final int EOF = -1;\n        InputStream is;\n        byte[] dBuf;\n        int dPos, dSize, next;\n        StringBuilder builder = new StringBuilder();\n\n        public BlockReader(InputStream is) {\n            this(is, 8192);\n        }\n\n        public BlockReader(InputStream is, int bufSize) {\n            this.is = is;\n            dBuf = new byte[bufSize];\n            next = nextByte();\n        }\n\n        public int nextByte() {\n            while (dPos >= dSize) {\n                if (dSize == -1) {\n                    return EOF;\n                }\n                dPos = 0;\n                try {\n                    dSize = is.read(dBuf);\n                } catch (Exception e) {\n                }\n            }\n            return dBuf[dPos++];\n        }\n\n        public String nextBlock() {\n            builder.setLength(0);\n            skipBlank();\n            while (next != EOF && !Character.isWhitespace(next)) {\n                builder.append((char) next);\n                next = nextByte();\n            }\n            return builder.toString();\n        }\n\n        public void skipBlank() {\n            while (Character.isWhitespace(next)) {\n                next = nextByte();\n            }\n        }\n\n        public int nextInteger() {\n            skipBlank();\n            int ret = 0;\n            boolean rev = false;\n            if (next == '+' || next == '-') {\n                rev = next == '-';\n                next = nextByte();\n            }\n            while (next >= '0' && next <= '9') {\n                ret = (ret << 3) + (ret << 1) + next - '0';\n                next = nextByte();\n            }\n            return rev ? -ret : ret;\n        }\n\n        public int nextBlock(char[] data, int offset) {\n            skipBlank();\n            int index = offset;\n            int bound = data.length;\n            while (next != EOF && index < bound && !Character.isWhitespace(next)) {\n                data[index++] = (char) next;\n                next = nextByte();\n            }\n            return index - offset;\n        }\n\n        public boolean hasMore() {\n            skipBlank();\n            return next != EOF;\n        }\n    }\n}\n","binary search,hashing,string suffix structures"
"import java.util.*;\nimport java.math.*;\nimport java.io.*;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\npublic class Hello {\n\n  \n  public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n \n    int q = in.nextInt();\n    \n    long []shift = new long [70];\n \n    try {\n    BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out, ""UTF-8""));\n\n    for (int i = 1;i <= q;++i) {\n      int type = in.nextInt();\n      long x = 0;//in.nextLong();\n      long K = 0;//in.nextLong();\n      \n      if (type == 1 || type == 2) {\n	x = in.nextLong();\n	K = -in.nextLong();\n	if (type == 1) {\n	  int level = 63 - Long.numberOfLeadingZeros(x);//x = 1 level = 0\n	  shift[level] += K;\n	} else if (type == 2) {\n	  int level = 63 - Long.numberOfLeadingZeros(x);//x = 1 level = 0\n	  long curK = K;\n	  for (int z = level;z <= 63;++z) {\n	    shift[z] += curK;\n	    curK = curK * 2;\n	  }\n	  \n	}\n      } else if (type == 3) {\n	x = in.nextLong();\n	int level = 63 - Long.numberOfLeadingZeros(x);//x = 1 level = 0\n	long pos = x - shift[level];\n	do {\n	  out.write((1L << level) + ((pos + shift[level]) & ((1L << level) - 1)) + "" "");\n	  //System.out.print(' ');\n	  pos >>= 1;\n	} while (--level >= 0);\n\n	out.write(""\n"");\n      }\n    }\n    out.flush(); out.close();\n    } catch (Exception e) {\n      System.exit(0);\n    }\n\n  }\n}\n","brute force,implementation,trees"
"import java.util.*;\nimport java.io.*;\n\npublic class D474 {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int q = sc.nextInt();\n        Query [] queries = new Query[q];\n        for (int i = 0; i < q; i++) {\n            int t = sc.nextInt();\n            Query qq = new Query(t);\n            qq.x = sc.nextLong();\n            if (t == 1 || t == 2) {\n                qq.k = sc.nextLong();\n            }\n            queries[i] = qq;\n        }\n        Map<Long, Long> name = new HashMap<>();\n        Map<Long, Long> parent = new HashMap<>();\n        for (int i = 0; i < q; i++) {\n            if (queries[i].type == 1) {\n                long x = queries[i].x; long k = queries[i].k;\n                long bit = Long.highestOneBit(x);\n                long put = (name.getOrDefault(bit, 0L) + k) % bit;\n                if (put < 0) put += bit;\n                name.put(bit, put);\n            } else if (queries[i].type == 2) {\n                long x = queries[i].x; long k = queries[i].k;\n                long bit = Long.highestOneBit(x);\n                long put = (parent.getOrDefault(bit, 0L) + k) % bit;\n                if (put < 0) put += bit;\n                parent.put(bit, put);\n            } else {\n                long cur = queries[i].x;\n                while (cur != 1) {\n                    out.print(cur + "" "");\n                    long bit = Long.highestOneBit(cur);\n                    long actualName = cur + name.getOrDefault(bit,0L);\n                    if (actualName >= 2 * bit) actualName -= bit;\n                    long goTo = actualName + parent.getOrDefault(bit, 0L);\n                    if (goTo >= 2 * bit) goTo -= bit;\n                    long par = goTo / 2;\n                    cur = par - name.getOrDefault(bit / 2, 0L);\n                    if (cur < bit / 2) cur += bit / 2;\n                }\n                out.print(1);\n                out.println();\n            }\n        }\n        out.close();\n    }\n\n    static class Query {\n        int type; long x; long k;\n        Query(int type) {\n            this.type = type;\n        }\n    }\n\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n\n    }\n\n}","brute force,implementation,trees"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.InputStreamReader;\nimport java.io.BufferedOutputStream;\nimport java.util.StringTokenizer;\nimport java.io.Closeable;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.Flushable;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	static class TaskAdapter implements Runnable {\n		@Override\n		public void run() {\n			InputStream inputStream = System.in;\n			OutputStream outputStream = System.out;\n			Input in = new Input(inputStream);\n			Output out = new Output(outputStream);\n			DFullBinaryTreeQueries solver = new DFullBinaryTreeQueries();\n			solver.solve(1, in, out);\n			out.close();\n		}\n	}\n\n	public static void main(String[] args) throws Exception {\n		Thread thread = new Thread(null, new TaskAdapter(), """", 1<<29);\n		thread.start();\n		thread.join();\n	}\n	static class DFullBinaryTreeQueries {\n		long[] level;\n		long[] size;\n\n		public DFullBinaryTreeQueries() {\n		}\n\n		public void rotate(int l, long val) {\n			level[l] += val;\n			level[l] %= size[l];\n		}\n\n		public void nodeRotate(int l, long val) {\n			if(l<60) {\n				val %= size[l];\n				rotate(l, val);\n				nodeRotate(l+1, val<<1);\n			}\n		}\n\n		public int getLevel(long x) {\n			return 63-Long.numberOfLeadingZeros(x);\n		}\n\n		public void solve(int kase, Input in, Output pw) {\n			level = new long[60];\n			size = new long[60];\n			size[0] = 1;\n			for(int i = 1; i<60; i++) {\n				size[i] = size[i-1]<<1L;\n			}\n			int q = in.nextInt();\n			while(q-->0) {\n				int type = in.nextInt();\n				if(type==1) {\n					int level = getLevel(in.nextLong());\n					rotate(level, (size[level]+in.nextLong())%size[level]);\n				}else if(type==2) {\n					int level = getLevel(in.nextLong());\n					nodeRotate(level, (size[level]+in.nextLong())%size[level]);\n				}else {\n					long x = in.nextLong();\n					int l = getLevel(x);\n					x = (x+level[l])%size[l]+size[l];\n					while(x>0) {\n						pw.print((x-level[l])%size[l]+size[l]+"" "");\n						x >>= 1;\n						l--;\n					}\n					pw.println();\n				}\n			}\n		}\n\n	}\n\n	static class Output implements Closeable, Flushable {\n		public StringBuilder sb;\n		public OutputStream os;\n		public int BUFFER_SIZE;\n		public boolean autoFlush;\n		public String LineSeparator;\n\n		public Output(OutputStream os) {\n			this(os, 1<<16);\n		}\n\n		public Output(OutputStream os, int bs) {\n			BUFFER_SIZE = bs;\n			sb = new StringBuilder(BUFFER_SIZE);\n			this.os = new BufferedOutputStream(os, 1<<17);\n			autoFlush = false;\n			LineSeparator = System.lineSeparator();\n		}\n\n		public void print(String s) {\n			sb.append(s);\n			if(autoFlush) {\n				flush();\n			}else if(sb.length()>BUFFER_SIZE >> 1) {\n				flushToBuffer();\n			}\n		}\n\n		public void println() {\n			sb.append(LineSeparator);\n		}\n\n		private void flushToBuffer() {\n			try {\n				os.write(sb.toString().getBytes());\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n			sb = new StringBuilder(BUFFER_SIZE);\n		}\n\n		public void flush() {\n			try {\n				flushToBuffer();\n				os.flush();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n		public void close() {\n			flush();\n			try {\n				os.close();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n	}\n\n	static class Input {\n		BufferedReader br;\n		StringTokenizer st;\n\n		public Input(InputStream is) {\n			this(is, 1<<20);\n		}\n\n		public Input(InputStream is, int bs) {\n			br = new BufferedReader(new InputStreamReader(is), bs);\n			st = null;\n		}\n\n		public boolean hasNext() {\n			try {\n				while(st==null||!st.hasMoreTokens()) {\n					String s = br.readLine();\n					if(s==null) {\n						return false;\n					}\n					st = new StringTokenizer(s);\n				}\n				return true;\n			}catch(Exception e) {\n				return false;\n			}\n		}\n\n		public String next() {\n			if(!hasNext()) {\n				throw new InputMismatchException();\n			}\n			return st.nextToken();\n		}\n\n		public int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n		public long nextLong() {\n			return Long.parseLong(next());\n		}\n\n	}\n}\n\n\n","brute force,implementation,trees"
"import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n    static int MOD = 1000000007;\n\n    // After writing solution, quick scan for:\n    //   array out of bounds\n    //   special cases e.g. n=1?\n    //   npe, particularly in maps\n    //\n    // Big numbers arithmetic bugs:\n    //   int overflow\n    //   sorting, or taking max, after MOD\n    void solve() throws IOException {\n        int q = ri();\n        long[] rotateValues = new long[60];\n        long[] rotateNodes = new long[60];\n        long[] shifts = new long[60];\n        for (int qi = 0; qi < q; qi++) {\n            // Level i contains nodes [ 2^i, 2^(i+1) )\n            //   2^i nodes total.\n            String[] line = br.readLine().split("" "");\n            int type = Integer.parseInt(line[0]);\n            if (type == 1) {\n                long x = Long.parseLong(line[1]);\n                long k = Long.parseLong(line[2]);\n                int level = level(x);\n                long countHere = 1l << level;\n                if (k < 0) {\n                    k %= countHere;\n                    k = countHere + k;\n                } else k %= countHere;\n\n                rotateValues[level] += k;\n                if (rotateValues[level] >= countHere) rotateValues[level] -= countHere;\n            } else if (type == 2) {\n                long x = Long.parseLong(line[1]);\n                long k = Long.parseLong(line[2]);\n                int level = level(x);\n                long countHere = 1l << level;\n                if (k < 0) {\n                    k %= countHere;\n                    k = countHere + k;\n                } else k %= countHere;\n\n                rotateNodes[level] += k;\n                if (rotateNodes[level] >= countHere) rotateNodes[level] -= countHere;\n            } else if (type == 3) {\n                long x = Long.parseLong(line[1]);\n\n                int level = level(x);\n                long countHere = 1l << level;\n                long cumRotate = 0;\n                for (int l = 0; l <= level; l++) {\n                    cumRotate *= 2;\n                    long here = 1l << l;\n                    \n                    long shiftsHere = cumRotate + rotateValues[l];\n                    if (shiftsHere >= here) shiftsHere -= here;\n                    shiftsHere += rotateNodes[l];\n                    if (shiftsHere >= here) shiftsHere -= here;\n\n                    cumRotate += rotateNodes[l];\n                    if (cumRotate >= here) cumRotate -= here;\n\n                    shifts[l] = shiftsHere;\n                }\n\n                long ghost = ((x - countHere) + shifts[level]) % countHere + countHere;\n                pw.print(x + "" "");\n                for (int l = level-1; l >= 0; l--) {\n                    ghost /= 2;\n                    countHere /= 2;\n\n                    long actual = ((ghost - countHere) + (countHere - shifts[l])) % countHere + countHere;\n                    pw.print(actual + "" "");\n                }\n                pw.println();\n            }\n        }\n    }\n    // IMPORTANT\n    // DID YOU CHECK THE COMMON MISTAKES ABOVE?\n\n    int level(long x) {\n        int level = 0;\n        while (x > 1) {\n            level++;\n            x /= 2;\n        }\n        return level;\n    }\n\n    // Template code below\n\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    PrintWriter pw = new PrintWriter(System.out);\n\n    public static void main(String[] args) throws IOException {\n        Main m = new Main();\n        m.solve();\n        m.close();\n    }\n\n    void close() throws IOException {\n        pw.flush();\n        pw.close();\n        br.close();\n    }\n\n    int ri() throws IOException {\n        return Integer.parseInt(br.readLine().trim());\n    }\n\n    long rl() throws IOException {\n        return Long.parseLong(br.readLine().trim());\n    }\n\n    int[] ril(int n) throws IOException {\n        int[] nums = new int[n];\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n            int sign = 1;\n            c = br.read();\n            int x = 0;\n            if (c == '-') {\n                sign = -1;\n                c = br.read();\n            }\n            while (c >= '0' && c <= '9') {\n                x = x * 10 + c - '0';\n                c = br.read();\n            }\n            nums[i] = x * sign;\n        }\n        while (c != '\n' && c != -1) c = br.read();\n        return nums;\n    }\n\n    long[] rll(int n) throws IOException {\n        long[] nums = new long[n];\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n            int sign = 1;\n            c = br.read();\n            long x = 0;\n            if (c == '-') {\n                sign = -1;\n                c = br.read();\n            }\n            while (c >= '0' && c <= '9') {\n                x = x * 10 + c - '0';\n                c = br.read();\n            }\n            nums[i] = x * sign;\n        }\n        while (c != '\n' && c != -1) c = br.read();\n        return nums;\n    }\n\n    int[] rkil() throws IOException {\n        int sign = 1;\n        int c = br.read();\n        int x = 0;\n        if (c == '-') {\n            sign = -1;\n            c = br.read();\n        }\n        while (c >= '0' && c <= '9') {\n            x = x * 10 + c - '0';\n            c = br.read();\n        }\n        return ril(x);\n    }\n\n    long[] rkll() throws IOException {\n        int sign = 1;\n        int c = br.read();\n        int x = 0;\n        if (c == '-') {\n            sign = -1;\n            c = br.read();\n        }\n        while (c >= '0' && c <= '9') {\n            x = x * 10 + c - '0';\n            c = br.read();\n        }\n        return rll(x);\n    }\n\n    char[] rs() throws IOException {\n        return br.readLine().toCharArray();\n    }\n\n    void sort(int[] A) {\n        Random r = new Random();\n        for (int i = A.length-1; i > 0; i--) {\n            int j = r.nextInt(i+1);\n            int temp = A[i];\n            A[i] = A[j];\n            A[j] = temp;\n        }\n        Arrays.sort(A);\n    }\n\n    void printDouble(double d) {\n        pw.printf(""%.16f"", d);\n    }\n}","brute force,implementation,trees"
"import java.util.*;\nimport java.io.*;\n \npublic class f {\n	\n	static int n;\n	static long[] as, bs, ans;\n	static ArrayList<Integer>[] adjs;\n	\n	public static void main(String[] args) throws IOException {\n		FastScanner in = new FastScanner(System.in);\n		PrintWriter out = new PrintWriter(System.out);\n		try {\n			Thread.sleep(2000);\n		} catch (Exception e) {}\n		n = in.nextInt();\n		as = new long[n];\n		bs = new long[n];\n		ans = new long[n];\n		adjs = new ArrayList[n];\n		for (int i = 0; i < n; i++) {\n			as[i] = in.nextLong();\n			adjs[i] = new ArrayList<>();\n		}\n		for (int i = 0; i < n; i++)\n			bs[i] = in.nextLong();\n		for (int i = 0; i < n - 1; i++) {\n			int u = in.nextInt() - 1;\n			int v = in.nextInt() - 1;\n			adjs[u].add(v);\n			adjs[v].add(u);\n		}\n		\n		go(0, -1);\n		\n		for (long a : ans)\n			out.print(a + "" "");\n		out.println();\n		\n		out.close();\n	}\n	\n	static CHT go(int cur, int par) {\n		CHT cht = new CHT(-1);\n		boolean isLeaf = true;\n		for (int next : adjs[cur]) {\n			if (next == par) continue;\n			isLeaf = false;\n			CHT other = go(next, cur);\n			if (other.hull.size() > cht.size()) {\n				CHT tmp = other;\n				other = cht;\n				cht = tmp;\n			}\n			for (CHT.Line l : other.hull)\n				cht.add(l);\n		}\n		if (!isLeaf) {\n			ans[cur] = cht.query(as[cur]);\n		}\n		cht.add(bs[cur], ans[cur]);\n		return cht;\n	}\n	\nstatic class CHT {\n	TreeSet<Line> hull;\n	int type;  boolean query  = false;\n	Comparator<Line> comp = new Comparator<Line>() {\n		public int compare(Line a, Line b) {\n			if (!query) return type * Long.compare(a.m, b.m);\n			if (a.left == b.left) return Long.compare(a.m, b.m);\n			return Double.compare(a.left, b.left);\n		}\n	};\n	// -1 for min; +1 for max\n	public CHT(int typee) { type = typee;  hull = new TreeSet<>(comp); }\n \n	public void add(long m, long b) { add(new Line(m, b)); }\n \n	public void add(Line a) {\n		Line[] LR = { hull.lower(a), hull.ceiling(a) };\n		for (int i = 0; i < 2; i++)\n			if (LR[i] != null && LR[i].m == a.m) {\n				if (type == 1 && LR[i].b >= a.b) return;\n				if (type == -1 && LR[i].b <= a.b) return;\n				remove(LR[i]);\n			}\n		hull.add(a);\n		Line L = hull.lower(a), R = hull.higher(a);\n		if (L != null && R != null && a.inter(R) <= R.left) {\n			hull.remove(a);\n			return;\n		}\n		Line LL = (L != null) ? hull.lower(L) : null;\n		Line RR = (R != null) ? hull.higher(R) : null;\n		if (L != null) a.left = a.inter(L);\n		if (R != null) R.left = a.inter(R);\n		while (LL != null && L.left >= a.inter(LL)) {\n			remove(L);\n			a.left = a.inter(L = LL);\n			LL = hull.lower(L);\n		}\n		while (RR != null && R.inter(RR) <= a.inter(RR)) {\n			remove(R);\n			RR.left = a.inter(R = RR);\n			RR = hull.higher(R);\n		}\n	}\n \n	public long query(long x) {\n		Line temp = new Line(0, 0, 0);\n		temp.left = x;  query = true;\n		long ans = (long) hull.floor(temp).eval(x);\n		query = false;  return ans;\n	}\n \n	private void remove(Line x) { hull.remove(x); }\n \n	public int size() { return hull.size(); }\n \n	static class Line {\n		long m, b; double left = Long.MIN_VALUE;\n		public Line(long mm, long x, long y) { m = mm; b = -m * x + y; }\n		public Line(long mm, long bb) { m = mm; b = bb; }\n		public long eval(long x) { return m * x + b; }\n		public double inter(Line x) {\n			return (double) (x.b - this.b) / (double) (this.m - x.m);\n		}\n	}\n}\n \n	\n	static class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n		\n		public FastScanner(InputStream i) {\n			br = new BufferedReader(new InputStreamReader(i));\n			st = new StringTokenizer("""");\n		}\n				\n		public String next() throws IOException {\n			if(st.hasMoreTokens())\n				return st.nextToken();\n			else\n				st = new StringTokenizer(br.readLine());\n			return next();\n		}\n \n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n	}\n}","data structures,dp,geometry"
"import java.util.*;\n\npublic class EscapeThroughLeaf {\n	\n	static ArrayList<Integer>[] graph;\n	static long[] a;\n	static long[] b;\n	static long[] ans;\n\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int n = scan.nextInt();\n		ans = new long[n];\n		a = new long[n];\n		b = new long[n];\n		graph = new ArrayList[n];\n		for(int i = 0; i < n; i++) a[i] = scan.nextLong();\n		for(int i = 0; i < n; i++) b[i] = scan.nextLong();\n		for(int i = 0; i < n; i++) graph[i] = new ArrayList<Integer>();\n		for(int i = 0; i < n-1; i++) {\n			int u = scan.nextInt()-1;\n			int v = scan.nextInt()-1;\n			graph[u].add(v);\n			graph[v].add(u);\n		}\n		dfs(0, -1);\n		for(int i = 0; i < n; i++) System.out.print(ans[i]+"" "");\n	}\n	\n	static CHT dfs(int i, int p) {\n		CHT curr = new CHT(-1);\n		boolean leaf = true;\n		for(int j = 0; j < graph[i].size(); j++) {\n			int to = graph[i].get(j);\n			if(to != p) {\n				leaf = false;\n				CHT g = dfs(to, i);\n				if(g.size() > curr.size()) {\n					CHT temp = g;\n					g = curr;\n					curr = temp;\n				}\n				for(CHT.Line l : g.hull) {\n					curr.add(l);\n				}\n			}\n		}\n		if(leaf) {\n			ans[i] = 0;\n			curr.add(b[i], 0);\n			return curr;\n		}\n		long res = curr.query(a[i]);\n		curr.add(b[i], res);\n		ans[i] = res;\n		return curr;\n	}\n\n	static class CHT {\n		TreeSet<Line> hull;\n		int type;  boolean query  = false;\n		Comparator<Line> comp = new Comparator<Line>() {\n			public int compare(Line a, Line b) {\n				if (!query) return type * Long.compare(a.m, b.m);\n				if (a.left == b.left) return Long.compare(a.m, b.m);\n				return Double.compare(a.left, b.left);\n			}\n		};\n		// -1 for min; +1 for max\n		public CHT(int typee) { type = typee;  hull = new TreeSet<>(comp); }\n\n		public void add(long m, long b) { add(new Line(m, b)); }\n\n		public void add(Line a) {\n			Line[] LR = { hull.lower(a), hull.ceiling(a) };\n			for (int i = 0; i < 2; i++)\n				if (LR[i] != null && LR[i].m == a.m) {\n					if (type == 1 && LR[i].b >= a.b) return;\n					if (type == -1 && LR[i].b <= a.b) return;\n					remove(LR[i]);\n				}\n			hull.add(a);\n			Line L = hull.lower(a), R = hull.higher(a);\n			if (L != null && R != null && a.inter(R) <= R.left) {\n				hull.remove(a);\n				return;\n			}\n			Line LL = (L != null) ? hull.lower(L) : null;\n			Line RR = (R != null) ? hull.higher(R) : null;\n			if (L != null) a.left = a.inter(L);\n			if (R != null) R.left = a.inter(R);\n			while (LL != null && L.left >= a.inter(LL)) {\n				remove(L);\n				a.left = a.inter(L = LL);\n				LL = hull.lower(L);\n			}\n			while (RR != null && R.inter(RR) <= a.inter(RR)) {\n				remove(R);\n				RR.left = a.inter(R = RR);\n				RR = hull.higher(R);\n			}\n		}\n\n		public long query(long x) {\n			Line temp = new Line(0, 0, 0);\n			temp.left = x;  query = true;\n			long ans = (long) hull.floor(temp).eval(x);\n			query = false;  return ans;\n		}\n\n		private void remove(Line x) { hull.remove(x); }\n\n		public int size() { return hull.size(); }\n\n		static class Line {\n			long m, b; double left = Long.MIN_VALUE;\n			public Line(long mm, long x, long y) { m = mm; b = -m * x + y; }\n			public Line(long mm, long bb) { m = mm; b = bb; }\n			public long eval(long x) { return m * x + b; }\n			public double inter(Line x) {\n				return (double) (x.b - this.b) / (double) (this.m - x.m);\n			}\n		}\n	}\n}\n","data structures,dp,geometry"
"import java.util.*;\n\npublic class EscapeThroughLeaf {\n	\n	static ArrayList<Integer>[] graph;\n	static long[] a;\n	static long[] b;\n	static long[] ans;\n\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int n = scan.nextInt();\n		ans = new long[n];\n		a = new long[n];\n		b = new long[n];\n		graph = new ArrayList[n];\n		for(int i = 0; i < n; i++) a[i] = scan.nextLong();\n		for(int i = 0; i < n; i++) b[i] = scan.nextLong();\n		for(int i = 0; i < n; i++) graph[i] = new ArrayList<Integer>();\n		for(int i = 0; i < n-1; i++) {\n			int u = scan.nextInt()-1;\n			int v = scan.nextInt()-1;\n			graph[u].add(v);\n			graph[v].add(u);\n		}\n		dfs(0, -1);\n		for(int i = 0; i < n; i++) System.out.print(ans[i]+"" "");\n	}\n	\n	static CHT dfs(int i, int p) {\n		CHT curr = new CHT(-1);\n		boolean leaf = true;\n		for(int j = 0; j < graph[i].size(); j++) {\n			int to = graph[i].get(j);\n			if(to != p) {\n				leaf = false;\n				CHT g = dfs(to, i);\n				//what if i don't do this?\n//				if(g.size() > curr.size()) {\n//					CHT temp = g;\n//					g = curr;\n//					curr = temp;\n//				}\n				for(CHT.Line l : g.hull)\n					curr.add(l);\n			}\n		}\n		if(leaf) {\n			ans[i] = 0;\n			curr.add(b[i], 0);\n			return curr;\n		}\n		long res = curr.query(a[i]);\n		curr.add(b[i], res);\n		ans[i] = res;\n		return curr;\n	}\n\n	static class CHT {\n		TreeSet<Line> hull;\n		int type;  boolean query  = false;\n		Comparator<Line> comp = new Comparator<Line>() {\n			public int compare(Line a, Line b) {\n				if (!query) return type * Long.compare(a.m, b.m);\n				if (a.left == b.left) return Long.compare(a.m, b.m);\n				return Double.compare(a.left, b.left);\n			}\n		};\n		// -1 for min; +1 for max\n		public CHT(int typee) { type = typee;  hull = new TreeSet<>(comp); }\n\n		public void add(long m, long b) { add(new Line(m, b)); }\n\n		public void add(Line a) {\n			Line[] LR = { hull.lower(a), hull.ceiling(a) };\n			for (int i = 0; i < 2; i++)\n				if (LR[i] != null && LR[i].m == a.m) {\n					if (type == 1 && LR[i].b >= a.b) return;\n					if (type == -1 && LR[i].b <= a.b) return;\n					remove(LR[i]);\n				}\n			hull.add(a);\n			Line L = hull.lower(a), R = hull.higher(a);\n			if (L != null && R != null && a.inter(R) <= R.left) {\n				hull.remove(a);\n				return;\n			}\n			Line LL = (L != null) ? hull.lower(L) : null;\n			Line RR = (R != null) ? hull.higher(R) : null;\n			if (L != null) a.left = a.inter(L);\n			if (R != null) R.left = a.inter(R);\n			while (LL != null && L.left >= a.inter(LL)) {\n				remove(L);\n				a.left = a.inter(L = LL);\n				LL = hull.lower(L);\n			}\n			while (RR != null && R.inter(RR) <= a.inter(RR)) {\n				remove(R);\n				RR.left = a.inter(R = RR);\n				RR = hull.higher(R);\n			}\n		}\n\n		public long query(long x) {\n			Line temp = new Line(0, 0, 0);\n			temp.left = x;  query = true;\n			long ans = (long) hull.floor(temp).eval(x);\n			query = false;  return ans;\n		}\n\n		private void remove(Line x) { hull.remove(x); }\n\n		public int size() { return hull.size(); }\n\n		static class Line {\n			long m, b; double left = Long.MIN_VALUE;\n			public Line(long mm, long x, long y) { m = mm; b = -m * x + y; }\n			public Line(long mm, long bb) { m = mm; b = bb; }\n			public long eval(long x) { return m * x + b; }\n			public double inter(Line x) {\n				return (double) (x.b - this.b) / (double) (this.m - x.m);\n			}\n		}\n	}\n}\n","data structures,dp,geometry"
"import java.io.*;\nimport java.util.*;\n\npublic class CF932F {\n    static int MIN_X = (int)-1e5 - 5, MAX_X = (int)1e5 + 5;\n    static int N, A[], B[];\n    static long ans[];\n    static ArrayList<Integer> g[];\n    static ArrayList<Line> lines[];\n    static LiChaoNode roots[];\n\n    public static void main(String args[]) throws Exception {\n        FastReader fr = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int N = fr.nextInt();\n        A = new int[N];\n        B = new int[N];\n        for (int i = 0; i < N; i++) A[i] = fr.nextInt();\n        for (int i = 0; i < N; i++) B[i] = fr.nextInt();\n        g = new ArrayList[N];\n        for (int i = 0; i < N; i++) g[i] = new ArrayList<>();\n        for (int i = 0; i < N - 1; i++) {\n            int u = fr.nextInt() - 1, v = fr.nextInt() - 1;\n            g[u].add(v); g[v].add(u);\n        }\n\n        lines = new ArrayList[N];\n        roots = new LiChaoNode[N];\n        ans = new long[N];\n        dfs(0, 0);\n\n        for (int i = 0; i < N; i++)\n            pw.print(ans[i] + "" "");\n\n        pw.close();\n    }\n\n    static int dfs(int u, int p) {\n        int h = u;\n        roots[h] = new LiChaoNode(MIN_X, MAX_X, null);\n        lines[h] = new ArrayList<Line>();\n        for (int v : g[u]) if (v != p) {\n            int h1 = dfs(v, u);\n            if (lines[h].size()  < lines[h1].size()) { int t = h; h = h1; h1 = t; }\n            for (Line l : lines[h1]) {\n                roots[h].insert(l);\n                lines[h].add(l);\n            }\n        }\n        if (h != u) ans[u] = roots[h].query(A[u]);\n        Line l = new Line(B[u], ans[u]);\n        roots[h].insert(l);\n        lines[h].add(l);\n        return h;\n    }\n}\n\nclass LiChaoNode {\n    int s, e, m;\n    Line cur;\n    LiChaoNode lt, rt;\n\n    LiChaoNode(int ss, int ee, Line l) {\n        s = ss; e = ee; m = (s + e) >> 1; cur = l;\n    }\n\n    void insert(Line l) {\n        if (cur == null) {\n            cur = l;\n            return;\n        }\n        boolean b1 = l.eval(s) < cur.eval(s);\n        boolean b2 = l.eval(m) < cur.eval(m);\n        if (b2) { Line t = l; l = cur; cur = t; }\n        if (s == e) return;\n        if (b1 != b2) {\n            if (lt == null) lt = new LiChaoNode(s, m, l);\n            else lt.insert(l);\n        } else {\n            if (rt == null) rt = new LiChaoNode(m + 1, e, l);\n            else rt.insert(l);\n        }\n    }\n\n    long query(int x) {\n        long y = cur.eval(x);\n        if (x < m && lt != null) y = Math.min(y, lt.query(x));\n        if (x > m && rt != null) y = Math.min(y, rt.query(x));\n        return y;\n    }\n}\n\nclass Line {\n    long m, c;\n    Line(long mm, long cc) { m = mm; c = cc; }\n    long eval(long x) { return m * x + c; }\n}\n\nclass FastReader{\n    byte[] buf = new byte[2048];\n    int index, total;\n    InputStream in;\n\n    FastReader(InputStream is) {\n        in = is;\n    }\n\n    int scan() throws IOException {\n        if(index >= total){\n            index = 0;\n            total = in.read(buf);\n            if(total <= 0)\n                return -1;\n        }\n        return buf[index++];\n    }\n\n    int nextInt() throws IOException {\n        int c, val = 0;\n        for(c = scan(); c <= 32; c = scan());\n        boolean neg = c == '-';\n        if(c == '-' || c == '+')\n            c = scan();\n        for(; c >= '0' && c <= '9'; c = scan())\n            val = (val << 3) + (val << 1) + (c & 0xf);\n        return neg ? -val : val;\n    }\n}","data structures,dp,geometry"
"\nimport java.util.Scanner;\n\npublic class Main {\n     static int mod = 1000000007;\n     static long s[][] = new long[5010][5010];\n     public static void main(String[] args) {\n         Scanner cin = new Scanner(System.in);\n         int n,k;\n         n = cin.nextInt();\n         k = cin.nextInt();\n         solve(n,k);\n         cin.close();\n    }\n\n    static void solve(int n,int k){\n        init(k);\n        long ans = 0;\n        for(int i = 0;i <= Math.min(n,k);i++){\n            ans = (ans + quick_(2,n-i) * cal(n-i+1,n) % mod * s[k][i] )% mod;\n        }\n        System.out.println(ans);\n    }\n\n    static long cal(int a,int b){\n         long ans = 1;\n         for(int i = a;i <= b;i++){\n             ans = ans * i % mod;\n         }\n         return  ans;\n    }\n\n    static long quick_(long a,long b){\n         long ans = 1;\n         while(b>0){\n             if((b&1)==1)ans = ans * a  % mod ;\n             a = a * a %  mod;\n             b >>= 1;\n         }\n         return ans;\n    }\n\n    static void init(int k){\n         s[1][1] = 1;\n         for(int i = 2;i <= k;i++){\n             for(int j = 1;j <= i;j++){\n                 s[i][j] = (s[i-1][j-1] + j * s[i-1][j]) % mod;\n             }\n         }\n    }\n}\n","combinatorics,dp,math"
"import java.util.*;\npublic class Main {\n	static int mod=1000000007;\n	static int n,K;\n	static int[] p2=new int[5123];\n	static int[][] dp=new int[5123][5123];\n	static int ksm(int x,int n) {\n		int ret=1;\n		while (n>0) {\n			if ((n&1)==1) ret=(int)(1L*ret*x%mod);\n			n>>=1;\n			x=(int)(1L*x*x%mod);\n		}\n		return ret;\n	}\n	static int DP(int a,int b) {\n		if (a==0) return p2[b];\n		if (dp[a][b]>0) return dp[a][b];\n		int ret=0,c=n-b;\n		if (b>0) ret=(ret+(int)(1L*b*DP(a-1,b)%mod))%mod;\n		if (c>0) ret=(ret+(int)(1L*c*DP(a-1,b+1)%mod))%mod;\n		return dp[a][b]=ret;\n	}\n	public static void main(String[] args) {\n		Scanner in=new Scanner(System.in);\n		n=in.nextInt();\n		K=in.nextInt();\n		p2[0]=ksm(2,n);\n		for (int i=1;i<=K;++i) p2[i]=(int)(500000004L*p2[i-1]%mod);\n		System.out.println(DP(K,0));\n	}\n}","combinatorics,dp,math"
"import java.util.*;\npublic class Main {\n	static int mod=1000000007;\n	static int n,K;\n	static int[] p2=new int[5123];\n	static int[][] dp=new int[5123][5123];\n	static int ksm(int x,int n) {\n		int ret=1;\n		while (n>0) {\n			if ((n&1)==1) ret=(int)(1L*ret*x%mod);\n			n>>=1;\n			x=(int)(1L*x*x%mod);\n		}\n		return ret;\n	}\n	static int DP(int a,int b) {\n		if (a==0) return p2[b];\n		if (dp[a][b]>0) return dp[a][b];\n		int ret=0,c=n-b;\n		if (b>0) ret=(ret+(int)(1L*b*DP(a-1,b)%mod))%mod;\n		if (c>0) ret=(ret+(int)(1L*c*DP(a-1,b+1)%mod))%mod;\n		return dp[a][b]=ret;\n	}\n	public static void main(String[] args) {\n		Scanner in=new Scanner(System.in);\n		n=in.nextInt();\n		K=in.nextInt();\n		p2[0]=ksm(2,n);\n		for (int i=1;i<=K;++i) p2[i]=(int)(500000004L*p2[i-1]%mod);\n		System.out.println(DP(K,0));\n	}\n}","combinatorics,dp,math"
"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class e {\n	static long m = (long)(1e9+7);\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int n = in.nextInt(), k = in.nextInt();\n		long[] fall = new long[k+1];\n		fall[0] = 1;\n		for(int i=1;i<=k;i++)\n			fall[i] = (fall[i-1] * (n-i+1))%m;\n		long[] m1 = new long[k+1], m2 = new long[k+1];\n		for(int p=0;p<=k;p++)\n			m1[p] = (fall[p] * pow(2, n-p)) % m;\n		for(int i=1;i<=k;i++) {\n			for(int p=0;p<k;p++)\n				m2[p] = (m1[p+1] + p * m1[p]) % m;\n			long[] t = m1;\n			m1 = m2;\n			m2 = t;\n		}\n		System.out.println(m1[0]);\n	}\n	static long pow(long x, int exp) {\n		long ans = 1;\n		while(exp > 0) {\n			if((exp & 1) == 1)\n				ans = ans * x % m;\n			x = x * x % m;\n			exp >>= 1;\n		}\n		return ans;\n	}\n}\n","combinatorics,dp,math"
"import java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.util.Arrays.fill;\nimport static java.util.Collections.sort;\n\npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n    int inf = 1 << 20;\n\n    private void solve() throws IOException {\n        int n = in.nextInt(), l = in.nextInt(), r = in.nextInt();\n\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n\n        ArrayList<Integer> imp = new ArrayList<>(), unimp = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            if (in.nextInt() == 1)\n                imp.add(a[i]);\n            else\n                unimp.add(a[i]);\n        }\n\n        sort(imp);\n\n        // Knapsack\n        int[] ks = new int[r + 1];\n        fill(ks, inf);\n        ks[0] = 0;\n        for (int i : unimp)\n            for (int j = r; j >= i; j--)\n                ks[j] = min(ks[j], ks[j - i]);\n\n        int ans = 0, minL = l, cnt = 0, sum = 0;\n        for (int i = imp.size() - 1; i >= 0; i--) {\n            while (minL <= r && ks[minL] == inf)\n                minL++;\n\n            while (cnt <= i && imp.get(cnt) + sum <= r - minL)\n                sum += imp.get(cnt++);\n\n            ans = max(ans, cnt + (minL <= r && (cnt <= i || ks[minL] < imp.size() - (i + 1)) ? 1 : 0));\n\n            for (int k = r; k >= imp.get(i); k--) {\n                ks[k] = min(ks[k], ks[k - imp.get(i)] + 1);\n                if (l <= k && k < minL && ks[k] != inf)\n                    minL = k;\n            }\n\n            if (cnt > i)\n                sum -= imp.get(--cnt);\n        }\n\n        out.println(ans == 0 && minL <= r && ks[minL] < imp.size() ? 1 : ans);\n    }\n\n    class FastScanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        FastScanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n    }\n\n    private void run() throws IOException {\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.flush();\n        out.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n}\n",
"import java.io.BufferedReader;\n// import java.io.FileInputStream;\n// import java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.*;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.util.Arrays.copyOf;\nimport static java.util.Arrays.fill;\nimport static java.util.Arrays.sort;\nimport static java.util.Collections.reverseOrder;\nimport static java.util.Collections.sort;\n\npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n    int inf = 1 << 20;\n\n    class Box {\n        int high;\n        boolean type;\n\n        Box(int h) {\n            high = h;\n        }\n    }\n\n    private void solve() throws IOException {\n        int n = in.nextInt(), l = in.nextInt(), r = in.nextInt();\n\n        Box[] b = new Box[n];\n        int sumH = 0;\n        for (int i = 0; i < n; i++) {\n            sumH += (b[i] = new Box(in.nextInt())).high;\n        }\n        for (int i = 0; i < n; i++) {\n            b[i].type = in.next().equals(""1"");\n        }\n\n        int rl = sumH - r, rr = sumH - l;\n\n        sort(b, (o1, o2) -> o1.type == o2.type ? o2.high - o1.high : Boolean.compare(o1.type, o2.type));\n\n        int[] ans = new int[sumH + 1];\n        fill(ans, -inf);\n        ans[0] = 0;\n\n        for (int i = 0; i < n; i++) {\n            for (int h = sumH; h >= b[i].high; h--) {\n                ans[h] = max(ans[h], ans[h - b[i].high] + (b[i].type && rl <= h && h <= rr ? 1 : 0));\n            }\n        }\n\n        int max = 0;\n        for (int i : ans)\n            max = max(max, i);\n\n        out.print(max);\n    }\n\n    class FastScanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        FastScanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        boolean hasNext() throws IOException {\n            return br.ready() || (st != null && st.hasMoreTokens());\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next().replace(',', '.'));\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        boolean hasNextLine() throws IOException {\n            return br.ready();\n        }\n    }\n\n    private void run() throws IOException {\n        in = new FastScanner(System.in); // new FastScanner(new FileInputStream("".in""));\n        out = new PrintWriter(System.out); // new PrintWriter(new FileOutputStream("".out""));\n\n        solve();\n\n        out.flush();\n        out.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n}\n",
"import java.io.BufferedReader;\n// import java.io.FileInputStream;\n// import java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.util.Arrays.copyOf;\nimport static java.util.Arrays.fill;\nimport static java.util.Arrays.sort;\nimport static java.util.Collections.reverseOrder;\nimport static java.util.Collections.sort;\n\npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n    int inf = 1 << 20;\n\n    private void solve() throws IOException {\n        int n = in.nextInt(), l = in.nextInt(), r = in.nextInt();\n\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n\n        ArrayList<Integer> imp = new ArrayList<>(), unimp = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            if (in.nextInt() == 1)\n                imp.add(a[i]);\n            else\n                unimp.add(a[i]);\n        }\n\n        sort(imp);\n\n        // Knapsack\n        int[] ks = new int[r + 1];\n        fill(ks, inf);\n        ks[0] = 0;\n        for (int i : unimp)\n            for (int j = r; j >= i; j--)\n                ks[j] = min(ks[j], ks[j - i]);\n\n        int ans = 0, minL = l, cnt = 0, sum = 0;\n        for (int i = imp.size() - 1; i >= 0; i--) {\n            while (minL <= r && ks[minL] == inf)\n                minL++;\n\n            while (cnt <= i && imp.get(cnt) + sum <= r - minL)\n                sum += imp.get(cnt++);\n\n            ans = max(ans, cnt + (minL <= r && cnt <= i ? 1 : 0));\n\n            if (cnt + 1 > ans)\n                for (int k = minL; k + sum <= r; k++)\n                    if (ks[k] < imp.size() - (i + 1)) {\n                        ans = cnt + 1;\n                        break;\n                    }\n\n            for (int k = r; k >= imp.get(i); k--) {\n                ks[k] = min(ks[k], ks[k - imp.get(i)] + 1);\n                if (l <= k && k < minL && ks[k] != inf)\n                    minL = k;\n            }\n\n            if (cnt > i)\n                sum -= imp.get(--cnt);\n        }\n\n        out.println(ans == 0 && minL <= r && ks[minL] < imp.size() ? 1 : ans);\n    }\n\n    class FastScanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        FastScanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        boolean hasNext() throws IOException {\n            return br.ready() || (st != null && st.hasMoreTokens());\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next().replace(',', '.'));\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        boolean hasNextLine() throws IOException {\n            return br.ready();\n        }\n    }\n\n    private void run() throws IOException {\n        in = new FastScanner(System.in); // new FastScanner(new FileInputStream("".in""));\n        out = new PrintWriter(System.out); // new PrintWriter(new FileOutputStream("".out""));\n\n        solve();\n\n        out.flush();\n        out.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n}\n",
"import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class E {\n\n	static long start = System.currentTimeMillis();\n\n	static boolean nextPermutation(int[] a) {\n		int n = a.length;\n		int ptr = n - 1;\n		while (ptr > 0 && a[ptr - 1] >= a[ptr]) {\n			ptr--;\n		}\n\n		for (int i = ptr, j = n - 1; i < j; i++, j--) {\n			int tmp = a[i];\n			a[i] = a[j];\n			a[j] = tmp;\n		}\n\n		if (ptr == 0) {\n			return false;\n		}\n\n		for (int i = ptr;; i++) {\n			if (a[ptr - 1] < a[i]) {\n				int tmp = a[ptr - 1];\n				a[ptr - 1] = a[i];\n				a[i] = tmp;\n				return true;\n			}\n		}\n	}\n\n	int slow(int[] a, boolean[] good, int l, int r) {\n		int n = a.length;\n		int[] p = new int[n];\n		for (int i = 0; i < n; i++) {\n			p[i] = i;\n		}\n\n		int ret = 0;\n		do {\n			int sum = 0;\n			int cur = 0;\n			for (int i : p) {\n				if (sum >= l && sum <= r && good[i]) {\n					cur++;\n				}\n				sum += a[i];\n			}\n			ret = Math.max(ret, cur);\n		} while (nextPermutation(p));\n		return ret;\n	}\n\n	int slowBad(int[] a, boolean[] good, int l, int r) {\n		int n = a.length;\n		int[] p = new int[n];\n		for (int i = 0; i < n; i++) {\n			p[i] = i;\n		}\n\n		int ret = 0;\n		do {\n			int sum = 0;\n			int cur = 0;\n			int shortPref = Integer.MAX_VALUE;\n			int longMid = Integer.MIN_VALUE;\n			for (int i : p) {\n				if (sum < l && good[i]) {\n					shortPref = Math.min(shortPref, a[i]);\n				}\n				if (sum >= l && sum <= r && good[i]) {\n					longMid = Math.max(longMid, a[i]);\n				}\n				if (sum >= l && sum <= r && good[i]) {\n					cur++;\n				}\n				sum += a[i];\n			}\n			if (shortPref < longMid) {\n				continue;\n			}\n			ret = Math.max(ret, cur);\n		} while (nextPermutation(p));\n		return ret;\n	}\n\n	static final int LOG = 6;\n	static final int SIZE = 1 << LOG;\n	static final int MASK = SIZE - 1;\n\n	static class Knapsack {\n		long[] data;\n		int curSize = 0;\n\n		long getWord(int i) {\n			if (i <= -SIZE || (i >> LOG) + 1 >= data.length) {\n				return 0;\n			}\n			int rem = i & MASK;\n			int idx = i >> LOG;\n\n			if (rem == 0) {\n				return data[idx];\n			}\n\n			long head = idx < 0 ? 0 : (data[idx] >>> rem);\n			long tail = data[idx + 1] << (SIZE - rem);\n\n			return head | tail;\n		}\n\n		public Knapsack(int maxSize) {\n			data = new long[(maxSize >> LOG) + 3];\n			data[0] |= 1;\n		}\n\n		void add(int item) {\n			curSize += item;\n			for (int block = curSize >> LOG; block >= 0; block--) {\n				data[block] |= getWord((block << LOG) - item);\n			}\n		}\n\n		int getAfter(int l) {\n			// -1 if not present\n			if (curSize < l) {\n				return -1;\n			}\n			long tmp = getWord(l);\n			if (tmp != 0) {\n				return l + Long.numberOfTrailingZeros(tmp);\n			}\n			for (int i = (l >> LOG) + 1;; i++) {\n				if (data[i] != 0) {\n					return (i << LOG) + Long.numberOfTrailingZeros(data[i]);\n				}\n			}\n		}\n	}\n\n	static final int INF = Integer.MAX_VALUE / 3;\n\n	int fast(int[] a, boolean[] good, int l, int r) {\n		int sum = Arrays.stream(a).sum();\n		int n = a.length;\n		int tmp = sum - r;\n		r = sum - l;\n		l = tmp;\n\n		int[] dp = new int[sum + 1];\n		Arrays.fill(dp, -INF);\n		dp[0] = 0;\n\n		int[] arr = new int[n];\n		for (int i = 0; i < n; i++) {\n			if (good[i]) {\n				arr[i] = -a[i];\n			} else {\n				arr[i] = -2 * sum - a[i];\n			}\n		}\n\n		Arrays.sort(arr);\n		for (int x : arr) {\n			int cost;\n			if (x < -2 * sum) {\n				cost = 0;\n				x = -x - 2 * sum;\n			} else {\n				cost = 1;\n				x = -x;\n			}\n			\n			for (int i = sum; i >= x; i--) {\n				dp[i] = Math.max(dp[i], dp[i - x] + cost * (i >= l && i <= r ? 1 : 0));\n			}\n		}\n		\n		return Arrays.stream(dp).max().getAsInt();\n	}\n\n	void submit() {\n		int n = nextInt();\n		int l = nextInt();\n		int r = nextInt();\n		int[] a = new int[n];\n		boolean[] good = new boolean[n];\n		for (int i = 0; i < n; i++) {\n			a[i] = nextInt();\n		}\n		for (int i = 0; i < n; i++) {\n			good[i] = nextInt() == 1;\n		}\n		out.println(fast(a, good, l, r));\n		// out.println(slow(a, good, l, r));\n		// out.println(slowBad(a, good, l, r));\n	}\n\n	void preCalc() {\n\n	}\n\n	void test() {\n\n	}\n\n	void stress() {\n		for (int tst = 0;; tst++) {\n			int n = rand(1, C);\n			int sum = 0;\n			int[] a = new int[n];\n			boolean[] good = new boolean[n];\n			for (int i = 0; i < n; i++) {\n				a[i] = rand(1, C);\n				good[i] = rng.nextBoolean();\n				sum += a[i];\n			}\n\n			int l = rand(0, sum);\n			int r = rand(0, sum);\n			if (l > r) {\n				int tmp = l;\n				l = r;\n				r = tmp;\n			}\n\n			if (slow(a, good, l, r) != slowBad(a, good, l, r)) {\n				System.err.println(Arrays.toString(a));\n				System.err.println(Arrays.toString(good));\n				System.err.println(l + "" "" + r);\n				System.err.println(slow(a, good, l, r));\n				System.err.println(slowBad(a, good, l, r));\n				throw new AssertionError();\n			}\n			System.err.println(tst + "" OK"");\n		}\n	}\n\n	E() throws IOException {\n		is = System.in;\n		out = new PrintWriter(System.out);\n		preCalc();\n		submit();\n		// stress();\n		// test();\n		out.close();\n	}\n\n	static final Random rng = new Random();\n	static final int C = 4;\n\n	static int rand(int l, int r) {\n		return l + rng.nextInt(r - l + 1);\n	}\n\n	public static void main(String[] args) throws IOException {\n		new E();\n	}\n\n	private InputStream is;\n	PrintWriter out;\n\n	private byte[] buf = new byte[1 << 14];\n	private int bufSz = 0, bufPtr = 0;\n\n	private int readByte() {\n		if (bufSz == -1)\n			throw new RuntimeException(""Reading past EOF"");\n		if (bufPtr >= bufSz) {\n			bufPtr = 0;\n			try {\n				bufSz = is.read(buf);\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n			if (bufSz <= 0)\n				return -1;\n		}\n		return buf[bufPtr++];\n	}\n\n	private boolean isTrash(int c) {\n		return c < 33 || c > 126;\n	}\n\n	private int skip() {\n		int b;\n		while ((b = readByte()) != -1 && isTrash(b))\n			;\n		return b;\n	}\n\n	String nextToken() {\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b)) {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	String nextString() {\n		int b = readByte();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b) || b == ' ') {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	double nextDouble() {\n		return Double.parseDouble(nextToken());\n	}\n\n	char nextChar() {\n		return (char) skip();\n	}\n\n	int nextInt() {\n		int ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n\n	long nextLong() {\n		long ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n}\n",
"import  java.io.*;\nimport  java.math.*;\nimport  java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n    	Scanner cin = new Scanner(System.in);\n    	int n = cin.nextInt();\n    	long a[] = new long[n+1];\n    	long t[] = new long[n+1];\n    	long sum[] = new long[n+1];\n    	for(int i = 1; i <= n; i++){\n    		a[i] = cin.nextLong();\n    	}\n    	sum[0] = 0;\n    	for(int i = 1; i <= n; i++){\n    		t[i] = cin.nextLong();\n    		sum[i] = sum[i-1]+t[i];\n    	}\n    	Queue<Long> q = new PriorityQueue<Long>();\n    	for(int i = 1; i <= n; i++){\n    		long ans=0;\n    		q.offer(a[i]+sum[i-1]);\n    		while(!q.isEmpty()&&q.peek()<=sum[i]){\n    			ans+=q.peek()-sum[i-1];\n    			q.poll();\n    		}\n    		ans+=q.size()*1l*t[i];\n    		System.out.print(ans+"" "");\n    	}\n    }\n}\n   	  	 		  				   	 	  			 	 	","binary search,data structures"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF948C extends PrintWriter {\n	CF948C() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF948C o = new CF948C(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		long[] vv = new long[n];\n		for (int i = 0; i < n; i++)\n			vv[i] = sc.nextInt();\n		int[] tt = new int[n];\n		for (int i = 0; i < n; i++)\n			tt[i] = sc.nextInt();\n		long t = 0;\n		for (int i = 0; i < n; i++) {\n			vv[i] += t;\n			t += tt[i];\n		}\n		vv = Arrays.stream(vv).boxed().sorted().mapToLong($->$).toArray();\n		t = 0;\n		for (int i = 0, j = 0; i < n; i++) {\n			long sum = 0;\n			while (j < n && vv[j] <= t + tt[i])\n				sum += vv[j++] - t;\n			sum += (long) (i - j + 1) * tt[i];	// (n - j) - (n - 1 - i)\n			print(sum + "" "");\n			t += tt[i];\n		}\n		println();\n	}\n}\n","binary search,data structures"
"import java.util.*;\nimport java.io.*;\npublic class cf923B {\n  public static void main(String[] args) throws IOException{\n    BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n    int n=Integer.parseInt(br.readLine());\n    StringTokenizer st=new StringTokenizer(br.readLine());\n    StringTokenizer st1=new StringTokenizer(br.readLine());\n    int[] arr=new int[n];\n    for (int j=0;j<n;j++) arr[j]=Integer.parseInt(st.nextToken());\n    PriorityQueue<Long> pq=new PriorityQueue<Long>();\n    long cumTemp=0;\n    for (int i=0;i<n;i++) {\n      long melted=0;\n      int v=arr[i];\n      long t=Long.parseLong(st1.nextToken());\n      pq.add(v+cumTemp);\n      long lim=t+cumTemp;\n      while (pq.size()>0 && pq.peek()<=lim)\n          melted+=pq.poll()-cumTemp;\n      cumTemp+=t;\n      melted+=pq.size()*t;\n      System.out.print(melted+"" "");\n    }\n    System.out.println("""");\n  }\n}\n","binary search,data structures"
"\n\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        long[] v=new long[n+1];  //雪堆的初始大小\n        long[] t=new long[n+1];  //每天的温度\n        long[] pre=new long[n+1];  //温度的前缀和\n        for (int i = 1; i <=n ; i++) {\n            v[i]=sc.nextLong();\n        }\n        for (int i = 1; i <=n ; i++) {\n            t[i]=sc.nextLong();\n            pre[i]=pre[i-1]+t[i];\n        }\n        Queue<Long> q=new PriorityQueue<Long>();\n        for (int i = 1; i <=n ; i++) {\n            long ans=0;\n            q.add(v[i]+pre[i-1]);\n            ans+=t[i]*q.size();//队列里都是可以消的\n            while (!q.isEmpty()&&q.peek()<=pre[i]){\n                ans+=(q.peek()-pre[i]);\n                q.poll();\n            }\n\n            System.out.print(ans+"" "");\n        }\n\n    }\n}\n","binary search,data structures"
"import java.util.*;\npublic class cf461div2B {\npublic static void main(String[] args) {\nScanner sc=new Scanner(System.in);\nint n=sc.nextInt(),c=0;\nfor(int i=1;i<=n;i++)\n{for(int j=i+1;j<=n;j++)\n{if((i+j)>(i^j) && (i^j)>=i && (i^j)>=j && (i^j)<=n)\nc++;}}\nSystem.out.println(c);\nsc.close();   \n}    \n}",brute force
import java.util.*;\npublic class z_6 {\npublic static void main(String[] args) {\n   Scanner s=new Scanner(System.in);\n    int n=s.nextInt() ;\n    int c=0;\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=i+1;j<=n;j++){\n            if((i+j)>(i^j) && (i^j)>=i && (i^j)>=j && (i^j)<=n)\n    c++;\n        }\n    }\n    System.out.println(c);\n}    \n}\n,brute force
\nimport java.util.Scanner;\n\npublic class s {\n\n	public static void main(String[] args) {\n    	Scanner in  = new Scanner(System.in);\n		int n=in.nextInt();\n		int num=0;\n	\n		for(int i=1;i<=n;i++) {\n			for(int j=i;j<=n;j++) {\n				int k=i^j;\n				if(i+j>k&&i+k>j&&j+k>i&&k>=j&&k<=n&&i<=j) {\n					num++;\n				}\n			}\n			\n		}\n		System.out.println(num);\n		\n	}\n\n}\n\n	 	  	 	  		  		  	 	 			   	 	,brute force
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF922B extends PrintWriter {\n	CF922B() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF922B o = new CF922B(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int ans = 0;\n		for (int a = 1; a <= n; a++)\n			for (int b = a; b <= n; b++) {\n				int c = a ^ b;\n				if (b <= c && c <= n && c < a + b)\n					ans++;\n			}\n		println(ans);\n	}\n}\n",brute force
"import java.io.*;\nimport java.util.*;\n\npublic class Codeforces913F {\n	public static void main(String[] args) throws IOException {\n		Scanner input = new Scanner(System.in);\n		int n = input.nextInt();\n		int a = input.nextInt();\n		int b = input.nextInt();\n		input.close();\n		final int mod = 998244353;\n		\n		int frac = multiply(a, inverse(b, mod), mod);\n		int reverse = (mod+1-frac)%mod;\n		\n		int[] fracpower = new int[n+1];\n		int[] reversepower = new int[n+1];\n		fracpower[0] = 1;\n		reversepower[0] = 1;\n		for (int i = 1; i <= n; i++) {\n			fracpower[i] = multiply(fracpower[i-1], frac, mod);\n			reversepower[i] = multiply(reversepower[i-1], reverse, mod);\n		}\n		\n		int[][] dp1 = new int[n+1][n+1];\n		dp1[2][1] = 1;\n		for (int i = 3; i <= n; i++) {\n			for (int j = 1; j < i; j++) {\n				if (j == 1) {\n					dp1[i][j] = fracpower[i-1];\n				}\n				else {\n					dp1[i][j] = multiply(dp1[i-1][j-1], fracpower[i-j], mod);\n				}\n				if (j == i-1) {\n					dp1[i][j] += reversepower[i-1];\n					dp1[i][j] %= mod;\n				}\n				else {\n					dp1[i][j] += multiply(dp1[i-1][j], reversepower[j], mod);\n					dp1[i][j] %= mod;\n				}\n			}\n		}\n		\n		int[][] dp2 = new int[n+1][n+1];\n		dp2[1][1] = 1;\n		dp2[2][1] = 1;\n		dp2[2][2] = 0;\n		for (int i = 3; i <= n; i++) {\n			int val = 0;\n			for (int j = 1; j < i; j++) {\n				dp2[i][j] = multiply(dp2[j][j], dp1[i][j], mod);\n				val += dp2[i][j];\n				val %= mod;\n			}\n			dp2[i][i] = (mod+1-val)%mod;\n		}\n		\n		/*for (int i = 2; i <= n; i++) {\n			for (int j = 1; j <= i; j++) {\n				System.out.print(dp2[i][j] + "" "");\n			}\n			System.out.println();\n		}*/\n		\n		int[] EV = new int[n+1];\n		EV[1] = 0;\n		EV[2] = 1;\n		for (int i = 3; i <= n; i++) {\n			int val = 0;\n			for (int j = 1; j < i; j++) {\n				int r = j*(i-j) + (j*(j-1))/2 + EV[i-j] + EV[j];\n				r %= mod;\n				val += multiply(dp2[i][j], r, mod);\n				val %= mod;\n			}\n			val += multiply((i*(i-1))/2, dp2[i][i], mod);\n			val %= mod;\n			\n			int s = (mod+1-dp2[i][i])%mod;\n			EV[i] = multiply(val, inverse(s, mod), mod);\n		}\n		\n		System.out.println(EV[n]);\n	}\n	\n	public static int multiply(int a, int b, int mod) {\n		long x = (long)a*(long)b;\n		return (int) (x%mod);\n	}\n	\n	public static int inverse (int a, int n) {\n		int m = n;\n		int r1 = 1;\n		int r2 = 0;\n		int r3 = 0;\n		int r4 = 1;\n		while ((a > 0) && (n > 0)) {\n			if (n >= a) {\n				r3 -= r1*(n/a);\n				r4 -= r2*(n/a);\n				n = n%a;\n			}\n			else {\n				int tmp = a;\n				a = n;\n				n = tmp;\n				tmp = r1;\n				r1 = r3;\n				r3 = tmp;\n				tmp = r2;\n				r2 = r4;\n				r4 = tmp;\n			}\n		}\n		if (a == 0) {\n			if (r3 >= 0)\n				return (r3%m);\n			else\n				return (m+(r3%m));\n		}\n		else {\n			if (r1 >= 0)\n				return (r1%m);\n			else\n				return (m+(r1%m));\n		}\n\n	}\n}","dp,graphs,math,probabilities"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.FileNotFoundException;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author triveni\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		InputReader in = new InputReader(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		F solver = new F();\n		solver.solve(1, in, out);\n		out.close();\n	}\n\n	static class F {\n		private Long[][] lastX = new Long[2010][2010];\n		private long mod = 998244353;\n		private long p = 0;\n		private long[] pPow = new long[2010];\n		private long[] qPow = new long[2010];\n		private long[] strong = new long[2010];\n		private Long[] dp = new Long[2010];\n\n		public void solve(int testNumber, InputReader in, PrintWriter out) {\n			int n = in.nextInt();\n			int a = in.nextInt(), b = in.nextInt();\n			p = MathUtils.powMod(b, mod - 2, mod) * a % mod;\n			pPow[0] = 1;\n			qPow[0] = 1;\n			for (int i = 1; i < 2010; ++i) {\n				pPow[i] = pPow[i - 1] * p % mod;\n				qPow[i] = qPow[i - 1] * (1 - p + mod) % mod;\n			}\n			strong[1] = 1;\n			for (int i = 2; i <= n; ++i) {\n				long ans = 0;\n				for (int j = 1; j < i; ++j) {\n					ans += strong[j] * computeLastX(i, j) % mod;\n					if (ans >= mod) ans -= mod;\n				}\n				strong[i] = 1 - ans;\n				if (strong[i] < 0) strong[i] += mod;\n			}\n			long ans = dp(n);\n			out.println(ans);\n		}\n\n		private long computeLastX(int n, int i) {\n			if (lastX[n][i] != null) return lastX[n][i];\n			if (n == i || i == 0) return lastX[n][i] = 1L;\n			long ans = qPow[i] * computeLastX(n - 1, i) % mod + pPow[n - i] * computeLastX(n - 1, i - 1) % mod;\n			return lastX[n][i] = ans % mod;\n		}\n\n		private long dp(int n) {\n			if (dp[n] != null) return dp[n];\n			if (n < 2) return dp[n] = 0L;\n			if (n < 3) return dp[n] = 1L;\n			long ans = strong[n] * (n * (n - 1) / 2) % mod;\n			for (int x = 1; x < n; ++x) {\n				long tmp = computeLastX(n, x) * strong[x] % mod;\n				tmp *= (x * (x - 1) / 2 + x * (n - x) + dp(n - x) + dp(x)) % mod;\n				ans += tmp % mod;\n			}\n			ans %= mod;\n			ans *= MathUtils.powMod(1 + mod - strong[n], mod - 2, mod);\n			return dp[n] = ans % mod;\n		}\n\n	}\n\n	static class InputReader {\n		public BufferedReader reader;\n		public StringTokenizer tokenizer;\n\n		public InputReader(InputStream inputStream) {\n			reader = new BufferedReader(new InputStreamReader(inputStream));\n			tokenizer = null;\n		}\n\n		public InputReader(String inputFile) throws FileNotFoundException {\n			reader = new BufferedReader(new FileReader(inputFile));\n			tokenizer = null;\n		}\n\n		public String nextLine() {\n			String curr = """";\n			try {\n				curr = reader.readLine();\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n			return curr;\n		}\n\n		public String nextString() {\n			while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n				try {\n					tokenizer = new StringTokenizer(nextLine());\n				} catch (Exception e) {\n					throw new RuntimeException(e);\n				}\n			}\n			return tokenizer.nextToken();\n		}\n\n		public int nextInt() {\n			return Integer.parseInt(nextString());\n		}\n\n	}\n\n	static class MathUtils {\n		public static long powMod(long a, long b, long m) {\n			long ans = 1;\n			while (b > 0) {\n				if (b % 2 == 1) ans = ans * a % m;\n				b >>= 1;\n				a = a * a % m;\n			}\n			return ans % m;\n		}\n\n	}\n}\n\n","dp,graphs,math,probabilities"
"import java.util.*;\npublic class Main{\n    public static List<Triplet> check(List<Triplet> al, int mid, int timeLimit){\n        int time=0;\n        List<Triplet> ret = new ArrayList<>();\n        for(int i=0;i<al.size();i++){\n            Triplet t = al.get(i);\n            if(time+t.time>timeLimit)   break;\n            if(t.limit>=mid){\n                ret.add(t);\n                time+=t.time;\n                if(ret.size()==mid) return ret;\n            }\n        }\n        return null;\n    }\n	public static void main(String [] args){\n	    Scanner sc = new Scanner(System.in);\n	    int n = sc.nextInt(), totalTime = sc.nextInt();\n	    List<Triplet> al = new ArrayList<>();\n	    for(int i=0;i<n;i++){\n	        int temp1=sc.nextInt(),temp2=sc.nextInt();\n	        al.add(new Triplet(temp2,temp1,i));\n	    }\n	    Collections.sort(al,(i1,i2)->(i1.time-i2.time));\n	    List<Triplet> ansList = new ArrayList<>();\n	    int ans=0,l=1,h=n;\n	    while(l<=h){\n	        int mid = l+(h-l)/2;\n	        List<Triplet> temp = check(al,mid,totalTime);\n	        if(temp!=null){\n	            ansList = temp;\n	            ans = mid;\n	            l = mid+1;\n	        }\n	        else    h = mid-1;\n	    }\n	    StringBuffer prnt = new StringBuffer();\n	    prnt.append(ans+""\n""+ansList.size()+""\n"");\n	    for(Triplet t : ansList)    prnt.append(t.idx+1+"" "");\n	    System.out.println(prnt);\n	}\n}\nclass Triplet{\n    int time, limit, idx;\n    public Triplet(int a, int b, int c){\n        time = a;\n        limit = b;\n        idx = c;\n    }\n}","binary search,brute force,data structures,greedy,sortings"
"import java.util.*;\nimport java.io.*;\npublic class Main{\n	public static void main(String[] args) throws IOException{\n	    BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n	    String s[]=br.readLine().split("" "");\n	    int n=Integer.parseInt(s[0]),t=Integer.parseInt(s[1]);\n	    int inp[][]=new int[n][3];\n	    for(int i=0;i<n;i++){\n	        s=br.readLine().split("" "");\n	        inp[i][0]=Integer.parseInt(s[0]);inp[i][1]=Integer.parseInt(s[1]);inp[i][2]=i+1;\n	    }\n	    Arrays.sort(inp,(x,y)->{\n	        return x[1]-y[1];\n	    });\n	    int l=1,h=n,mid,res=0;\n	    List<Integer> resL=new ArrayList<>();\n	    class Pair{\n	        int a,b;\n	        Pair(int A,int B){\n	            a=A;\n	            b=B;\n	        }\n	    }\n	    while(l<=h){\n	        mid=(l+h)/2;\n	        int tot=t,num=0;\n	        List<Pair> ls=new ArrayList<>();\n	        for(int i=0;i<n;i++){\n	            if(inp[i][0]>=mid && inp[i][1]<=tot){\n	                tot-=inp[i][1];\n	                num++;\n	                ls.add(new Pair(inp[i][2],inp[i][0]));\n	            }\n	        }\n	        List<Integer> cur=new ArrayList<>();\n	        if(num>=mid){\n	            l=mid+1;\n	            res=mid;\n	            Collections.sort(ls,(x,y)->{\n	                return y.b-x.b;\n	            });\n	            for(int i=0;i<mid;i++) cur.add(ls.get(i).a);\n	            resL=cur;\n	        }else h=mid-1;\n	    }\n	    BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(System.out));\n	    bw.write(res+""\n""+resL.size()+""\n"");\n	    for(int i:resL) bw.write(i+"" "");\n	    bw.flush();\n	}\n}","binary search,brute force,data structures,greedy,sortings"
"import java.util.*;\npublic class Main\n{\n    static class Pair{\n        int id,a,t;\n        Pair(int id,int a, int t){\n        	this.id = id;\n            this.a = a;\n            this.t = t;\n        }\n    }\n    public static List<Integer> check(List<Pair> arr, int k, int limit){\n        int time = 0, i = 0, count = 0;\n        List<Integer> ans = new ArrayList<Integer>();\n        while(i < arr.size() && time <= limit){\n            if(arr.get(i).a >= k){\n                time += arr.get(i).t;\n                if(time <= limit) ans.add(arr.get(i).id);\n            }\n            if(ans.size() == k) return ans;\n            i++;\n        }\n        return null;\n    }\n	public static void main(String[] args) {\n	    Scanner sc = new Scanner(System.in);\n	    int t = 1;\n	    while(t-->0){\n	        int n = sc.nextInt(), limit = sc.nextInt();\n	        List<Pair> arr = new ArrayList<Pair>();\n	        for(int i=0;i<n;i++){\n	            arr.add(new Pair(i+1, sc.nextInt(), sc.nextInt()));\n	        }\n	        Collections.sort(arr, new Comparator<Pair>() {\n	            public int compare(Pair p1, Pair p2){\n	                return p1.t - p2.t;\n	            }\n	        });\n	        int lo = 1, hi = n, ans = 0;\n	        while(lo <= hi){\n	            int mid = (lo + hi)/2;\n	            if(check(arr,mid,limit) != null){\n	                ans = mid;\n	                lo = mid+1;\n	            }\n	            else hi = mid-1;\n	        }\n	        if(ans == 0){\n	        	System.out.println(""0\n0"");\n	        	continue;\n	        }\n	        List<Integer> res = check(arr,ans,limit);\n	        System.out.println(ans);\n	        System.out.println(res.size());\n	        for(int x : res)\n	        	System.out.print(x + "" "");\n	        System.out.println();\n	    }\n	}\n}\n","binary search,brute force,data structures,greedy,sortings"
"import java.util.*;\npublic class Main{\n    static class SortByTime implements Comparator<Pair>{ \n        public int compare(Pair a, Pair b){ \n            return a.key - b.key; \n        } \n    } \n    public static class Pair{\n        int key;\n        int value;\n        int index;\n        Pair(int value,int key,int index){\n            this.key = key;\n            this.value = value;\n            this.index = index;\n        }\n    }\n    public static ArrayList<Pair> ansList = new ArrayList<Pair>();\n    public static int ansTime = 0;\n    public static int BinarySearch(ArrayList<Pair> A,int timeAvailable){\n        int low = 1,high = A.size(),mid;\n        int ans = 0;\n        while(low <= high){\n            mid = (low + high)/2;\n            if(valid(A,timeAvailable,mid)){\n                ans = mid;\n                low = mid + 1;\n            }else\n                high = mid - 1;\n        }\n        return ans;\n    }\n    public static boolean valid(ArrayList<Pair> A,int timeAvailable,int val){\n        int val1 = 0;\n        int curTime = 0;\n        ArrayList<Pair> temp = new ArrayList<Pair>();\n        for(int i = 0 ; i < A.size() ; i++){\n            if(A.get(i).value >= val){\n                if(A.get(i).key <= timeAvailable){\n                    temp.add(A.get(i));\n                    timeAvailable = timeAvailable - A.get(i).key;\n                    curTime = curTime + A.get(i).key;\n                    val1++;\n                    if(val1 == val){\n                        ansList = temp;\n                        ansTime = curTime;\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n	public static void main(String[] args) {	\n	    Scanner sc = new Scanner(System.in);\n	    int n = sc.nextInt();\n	    int timeAvailable = sc.nextInt();\n	    ArrayList<Pair> A = new ArrayList<Pair>();\n	    for(int i = 0 ; i < n ; i++){\n	        int x = sc.nextInt();\n	        int y = sc.nextInt();\n	        Pair p1 = new Pair(x,y,i+1);\n	        A.add(p1);\n	    }\n	    Collections.sort(A,new SortByTime());\n	    System.out.println(BinarySearch(A,timeAvailable));\n	    System.out.println(ansList.size());\n        for(int i = 0 ; i < ansList.size() ; i++){\n            System.out.print(ansList.get(i).index+"" "");\n        }\n	}\n}\n","binary search,brute force,data structures,greedy,sortings"
"import java.util.*;\npublic class MyClass {\n    public static void main(String args[]) {\n        Scanner sc =new Scanner(System.in);\n        int n =sc.nextInt();\n        ArrayList<Integer> arr=new ArrayList<Integer>();\n        for(int i=0;i<n;i++){\n            int b =sc.nextInt();\n            arr.add(b);\n        }\n    int count=0;\n    for (int i=0;i<n;i++){\n        for(int j=i;j<n;j++){\n            int w=arr.get(i);\n            int r=arr.get(j);\n            if(w>r){\n                count=count+1;\n            }\n        }\n    }\n    count=count%2;\n    int q=sc.nextInt();\n    for(int j=0;j<q;j++){\n        int l=sc.nextInt();\n        int r=sc.nextInt();\n        int e=r-l+1;\n        e=(e-1)*e/2;\n        count=(count+e)%2;\n        if(count==1){\n            System.out.println(""odd"");\n        }\n        else{\n            System.out.println(""even"");\n        }\n        \n    }\n    \n    }\n}","brute force,math"
"import java.util.*;\n\npublic class Hello {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = Integer.parseInt(sc.nextLine());\n        int arr[] = new int[N];\n        for (int index = 0; index < N; index++) {\n            arr[index] = sc.nextInt();\n        }\n        int result = 0;\n        for (int index = 0; index < N; index++) {\n            for (int cmpIndex = index + 1; cmpIndex < N; cmpIndex++) {\n                if (arr[index] > arr[cmpIndex]) {\n                    result ^= 1;\n                }\n            }\n        }\n        int Q = sc.nextInt();\n        while (Q-- > 0) {\n            int left = sc.nextInt();\n            int right = sc.nextInt();\n            if (((right - left) * (right - left + 1) / 2) % 2 != 0) {\n                result ^= 1;\n            }\n            System.out.println(result == 1 ? ""odd"" : ""even"");\n        }\n    }\n}","brute force,math"
"import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class InversionCounting {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int t = 1;\n        for (int i = 0; i < t; i++) {\n            solve(sc, pw);\n        }\n        pw.close();\n    }\n\n    static void solve(Scanner in, PrintWriter out){\n        int n = in.nextInt();\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = in.nextInt();\n        }\n        int m = in.nextInt();\n        int[][] qs = new int[m][];\n        for (int i = 0; i < m; i++) {\n            qs[i] = new int[]{in.nextInt(), in.nextInt()};\n        }\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (arr[i] > arr[j]) cnt++;\n            }\n        }\n        cnt &= 1;\n        for(int[] q : qs){\n            int len = (q[1] - q[0] + 1);\n            int tot = (len - 1) * len / 2;\n            cnt ^= (tot & 1);\n            if (cnt == 0){\n                out.println(""even"");\n            }else{\n                out.println(""odd"");\n            }\n        }\n    }\n}\n","brute force,math"
"import java.io.*;\nimport java.util.*;\npublic class Main\n{\n	\n	private void solve()throws IOException\n	{\n		int n=nextInt();\n		int a[]=new int[n+1];\n		for(int i=1;i<=n;i++)\n			a[i]=nextInt();\n		long inversions=0;\n		for(int i=1;i<=n;i++)\n			for(int j=i+1;j<=n;j++)\n				if(a[i]>a[j])\n					inversions++;\n		int parity=(int)(inversions%2);\n		int m=nextInt();\n		while(m-->0)\n		{\n			int l=nextInt();\n			int r=nextInt();\n			int length=r-l+1;\n			long pairs=1l*length*(length-1)/2;\n			if(pairs%2==1)\n				parity=(parity+1)%2;\n			out.println(parity==0?""even"":""odd"");\n		}\n	}\n\n	 \n	///////////////////////////////////////////////////////////\n\n	public void run()throws IOException\n	{\n		br=new BufferedReader(new InputStreamReader(System.in));\n		st=null;\n		out=new PrintWriter(System.out);\n\n		solve();\n\n		br.close();\n		out.close();\n	}\n	public static void main(String args[])throws IOException{\n		new Main().run();\n	}\n	BufferedReader br;\n	StringTokenizer st;\n	PrintWriter out;\n	String nextToken()throws IOException{\n		while(st==null || !st.hasMoreTokens())\n		st=new StringTokenizer(br.readLine());\n		return st.nextToken();\n	}\n	String nextLine()throws IOException{\n		return br.readLine();\n	}\n	int nextInt()throws IOException{\n		return Integer.parseInt(nextToken());\n	}\n	long nextLong()throws IOException{\n		return Long.parseLong(nextToken());\n	}\n	double nextDouble()throws IOException{\n		return Double.parseDouble(nextToken());\n	}\n}","brute force,math"
"import java.util.*;\npublic class Rough1 {\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int d = sc.nextInt();\n		int count = 0;\n		int s =0;\n		String str = sc.next();\n		int i;\n		for(i=d;i>s;i--) {\n			if(i<=n-1&&str.charAt(i)=='1') {\n				count++;\n				s=i;\n				i=s+d+1;\n			}\n		}\n		if(i<n-1) {\n			System.out.println(""-1"");\n		}\n		else\n			System.out.println(count);\n	}\n}\n","dfs and similar,dp,greedy,implementation"
"import java.util.*;\n\npublic class A1 {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int in = sc.nextInt();\n		int in2 = sc.nextInt();\n		int count = 0;\n		int s = 0;\n		String str = sc.next();\n		int i;\n		for(i=in2; i>s; i--) {\n			if(i<=in-1&&str.charAt(i)=='1') {\n				count++;\n				s = i;\n				i = s+in2+1;\n			}\n		}\n\n		if (i < in - 1) {\n			System.out.println(""-1"");\n		}\n\n		else\n			System.out.println(count);\n	}\n}\n  	   	  	    			 	    	   				","dfs and similar,dp,greedy,implementation"
"import java.util.*;\npublic class Rough1 {\n \n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int d = sc.nextInt();\n		int count=0;\n		int s=0;\n		String str=sc.next();\n		int i;\n		\n		for(i=d;i>s;i--)\n		{\n		    if(i<=n-1 && str.charAt(i)=='1')\n		    {\n		        count++;\n		        s=i;\n		        i=s+d+1;\n		    }\n		}\n		\n		if(i<n-1)\n		System.out.println(""-1"");\n		else\n		System.out.println(count);\n	}\n}","dfs and similar,dp,greedy,implementation"
"import java.util.*;\n\npublic class TheWayHome {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n=sc.nextInt();\n        int d=sc.nextInt();\n        String str=sc.next();\n        int s=0,count=0,i=0;\n        for(i=d;i>s;i--){\n            if(i<=n-1 && str.charAt(i)=='1'){\n                count++;\n                s=i;\n                i=s+d+1;\n            }\n        }\n        if(i<n-1)System.out.println(-1);\n        else System.out.println(count);\n        sc.close();\n    }\n}","dfs and similar,dp,greedy,implementation"
"import java.util.Scanner;\n\npublic class F455 {\n\n	@SuppressWarnings(""resource"")\n	public static void main(String[] args) {\n		Scanner input = new Scanner(System.in);\n		int n = input.nextInt();\n		if (n % 2 ==1){\n			System.out.println(""NO"");\n		}else{\n			System.out.println(""YES"");\n			int[] p = new int[n + 1];\n			int max = n;\n			while (max > 0){\n				int i = gpt(max);\n				int j = i - 1;\n				while (i <= max){\n					p[i] = j;\n					p[j] = i;\n					i++;\n					j--;\n				}\n				max = j;\n			}\n			for (int i = 1; i <= n; i++){\n				System.out.print(p[i] + "" "");\n			}\n			System.out.println();\n		}\n		//other half\n		if (n < 6 || gpt(n) == n){\n			System.out.println(""NO"");\n		}else{\n			System.out.println(""YES"");\n			if (n == 6){\n				System.out.println(""5 3 2 6 1 4"");\n			}else if (n == 7){\n				System.out.println(""5 3 2 7 1 4 6"");\n			}else{\n				System.out.print(""5 3 2 7 1 4 6 "");\n				int i = 8;\n				int max = i * 2;\n				while (max < n){\n					while (i < max - 1){\n						System.out.print(i + 1 + "" "");\n						i++;\n					}\n					System.out.print(max / 2 + "" "");\n					i = max;\n					max = i * 2;\n				}\n				System.out.print(n + "" "");\n				i++;\n				for (; i <= n; i++){\n					System.out.print(i - 1 + "" "");\n				}\n			}\n		}\n	}\n	\n	public static int gpt(int n){\n		int i = 1;\n		while (i * 2 <= n){\n			i *= 2;\n		}\n		return i;\n	}\n\n}",constructive algorithms
"import java.util.Scanner;\n\npublic class F {\n\n    private static final int[] Q6 = {3, 6, 2, 5, 1, 4};\n\n    private static int N;\n\n    public static void main(String[] args) {\n        N = new Scanner(System.in).nextInt();\n\n        if (N % 2 == 0) {\n            int[] p = new int[N + 1];\n\n            int max = N;\n            int pow = Integer.highestOneBit(N);\n            while (max > 0) {\n                for (int i = 1; pow + i - 1 <= max; i++) {\n                    int tmp1 = pow - i;\n                    int tmp2 = pow + i - 1;\n                    p[tmp1] = tmp2;\n                    p[tmp2] = tmp1;\n                }\n                max = pow - (max - pow + 1) - 1;\n                pow = Integer.highestOneBit(max);\n            }\n\n            yes(p);\n        } else\n            System.out.println(""NO"");\n\n        if (N >= 6 && (N & (-N)) != N) {\n            int[] q = new int[N + 1];\n            for (int i = 1; i <= N; i++)\n                q[i] = i <= 6 ? Q6[i-1] : i;\n            for (int i = 7; i <= N; i++) {\n                int j = Integer.highestOneBit(i);\n                q[i] = q[j];\n                q[j] = i;\n            }\n            yes(q);\n        } else\n            System.out.println(""NO"");\n    }\n\n    private static void yes(int[] perm) {\n        System.out.println(""YES"");\n        for (int i = 1; i <= N; i++)\n            System.out.print(perm[i] + "" "");\n        System.out.println();\n    }\n\n}\n",constructive algorithms
"import java.io.*;\nimport java.util.*;\n\npublic class utkarsh{\n	BufferedReader br;\n	PrintWriter out;\n\n	void solve(){\n		br = new BufferedReader(new InputStreamReader(System.in));\n		out = new PrintWriter(System.out);\n		\n		int n = ni();\n\n		if(n%2 == 1){\n			out.println(""NO"");\n		}else{\n			out.println(""YES"");\n			int a[] = new int[n+1];\n			int l, r, m = n;\n			while(m > 0){\n				//System.out.println(m);\n				r = 1;\n				while(r <= m)	r <<= 1;\n				r >>= 1;\n				l = r-1;\n				while(r <= m){\n					a[l] = r;\n					a[r] = l;\n					r++;\n					l--;\n				}\n				m = l;\n			}\n			for(int i = 1; i <= n; i++)	out.print(a[i] + "" "");\n			out.println();\n		}\n\n		if(n <= 5 || (n & (n-1)) == 0){\n			out.println(""NO"");\n		}else if(n == 6){\n			out.println(""YES\n3 6 2 5 1 4"");\n		}else if(n == 7){\n			out.println(""YES\n7 3 6 5 1 2 4"");\n		}else{\n			out.println(""YES\n7 3 6 5 1 2 4 "");\n			int x = 8;\n			while(true){\n				int m = Math.min(n, x - 1 + x);\n				out.print(m + "" "");\n				for(int i = x; i < m; i++)	out.print(i + "" "");\n				if(m == n)	break;\n				x <<= 1;\n			}\n			out.println();\n		}\n\n		out.flush();\n	}\n\n	int ni(){\n		return Integer.parseInt(ns());\n	}\n\n	String ip[];\n	int len, sz;\n\n	String ns(){\n		if(len >= sz){\n			try{\n				ip = br.readLine().split("" "");\n				len = 0;\n				sz = ip.length;\n			}catch(IOException e){\n				throw new InputMismatchException();\n			}\n			if(sz <= 0)	return ""-1"";\n		}\n		return ip[len++];\n	}\n\n	public static void main(String[] args){	new utkarsh().solve();	}\n}",constructive algorithms
"import java.io.IOException;\nimport java.util.*;\n\npublic class Test {\n    int readInt() {\n        int ans = 0;\n        boolean neg = false;\n        try {\n            boolean start = false;\n            for (int c = 0; (c = System.in.read()) != -1; ) {\n                if (c == '-') {\n                    start = true;\n                    neg = true;\n                    continue;\n                } else if (c >= '0' && c <= '9') {\n                    start = true;\n                    ans = ans * 10 + c - '0';\n                } else if (start) break;\n            }\n        } catch (IOException e) {\n        }\n        return neg ? -ans : ans;\n    }\n\n    int[] ns;\n\n    void swap(int i, int j) {\n        int t = ns[i];\n        ns[i] = ns[j];\n        ns[j] = t;\n    }\n\n    void start() {\n        int n = readInt();\n        ns = new int[n+1];\n        if (n % 2 == 1) System.out.println(""NO"");\n        else {\n            System.out.println(""YES"");\n            for (int i = n; i >= 1; i--) {\n                if (ns[i] != 0) continue;\n                int one = Integer.highestOneBit(i);\n                int k = ~i & (one - 1);\n                ns[i] = k;\n                ns[k] = i;\n            }\n            for (int i = 1; i <= n; i++) {\n                System.out.print(ns[i] + "" "");\n            }\n            System.out.println();\n        }\n        Arrays.fill(ns, 0);\n        if (n < 6 || (n & (n - 1)) == 0) System.out.println(""NO"");\n        else {\n            System.out.println(""YES"");\n            for (int i = 1; i <= Math.min(7, n); i++) ns[i] = i;\n            swap(5, 1);\n            swap(2, 3);\n            swap(4, 6);\n            if (n >= 7) {\n                swap(7, 1);\n            }\n            for (int i = 8; i <= n;) {\n                int ni = i << 1;\n                int j = 0;\n                for (j = i + 1; j < ni && j <= n; j++) ns[j] = j - 1;\n                ns[i] = j - 1;\n                i = j;\n            }\n            for (int i = 1; i <= n; i++) System.out.print(ns[i] + "" "");\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] args) {\n\n        new Test().start();\n\n    }\n}\n",constructive algorithms
"import java.util.*;\npublic class GenerateLogin \n{\n	public static void main(String[] args) \n	{\n		Scanner sc=new Scanner(System.in);\n		String s1=sc.next();\n		String s2=sc.next();\n		String s3="""";\n		s3=s3+s1.charAt(0);\n		for(int i=1;i<s1.length();i++)\n		{\n			if(s1.charAt(i)<s2.charAt(0))\n			{\n				s3=s3+s1.charAt(i);\n			}\n			else\n			{\n				break;\n			}\n		}\n		s3=s3+s2.charAt(0);\n		System.out.println(s3);\n	}\n}\n","brute force,greedy,sortings"
"import java.util.*;\npublic class GenerateLogin \n{\n	public static void main(String[] args) \n	{\n		Scanner sc=new Scanner(System.in);\n		String s1=sc.next();\n		String s2=sc.next();\n		String s3="""";\n		s3=s3+s1.charAt(0);\n		for(int i=1;i<s1.length();i++)\n		{\n			if(s1.charAt(i)<s2.charAt(0))\n			{\n				s3=s3+s1.charAt(i);\n			}\n			else\n			{\n				break;\n			}\n		}\n		s3=s3+s2.charAt(0);\n		System.out.println(s3);\n	}\n}\n","brute force,greedy,sortings"
"import java.util.*;\npublic class Main {\n\n	public static void main(String args[]) {\n		Scanner sc= new Scanner(System.in);\n		String a = sc.next();\n    String b = sc.next();\n    String s = """";\n    s += a.charAt(0);\n    for(int i=1;i<a.length();i++){\n      if(a.charAt(i)<b.charAt(0)){\n         s = s+a.charAt(i);\n      }\n      else{\n        break;\n      }\n    }\n    s = s+b.charAt(0);\n    System.out.println(s);\n	}\n\n}","brute force,greedy,sortings"
"import java.util.Scanner;\n\npublic class _0765GenerateLogin {\n	\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		String[] store=sc.nextLine().trim().split("" "");\n		String s=store[0];\n		String h=store[1];\n		String ans=s.charAt(0)+"""";\n		for(int i=1;i<s.length();i++) {\n			if(s.charAt(i)<h.charAt(0)) {\n				ans+=s.charAt(i);\n			}\n			else {\n				break;\n			}\n		}\n		ans+=h.charAt(0);\n		System.out.println(ans);\n	}\n\n}\n","brute force,greedy,sortings"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF903E {\n	static char[][] cc;\n	static boolean check(int k, int n, int h, boolean dup) {\n		char[] s = cc[h];\n		for (int h_ = 0; h_ < k; h_++)\n			if (h_ != h) {\n				char[] s_ = cc[h_];\n				int i1 = -1, i2 = -1;\n				for (int i = 0; i < n; i++)\n					if (s_[i] != s[i]) {\n						if (i1 == -1)\n							i1 = i;\n						else if (i2 == -1)\n							i2 = i;\n						else\n							return false;\n					}\n				if (i1 == -1) {\n					if (dup)\n						continue;\n					return false;\n				}\n				if (i2 == -1 || s_[i1] != s[i2] || s_[i2] != s[i1])\n					return false;\n			}\n		return true;\n	}\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int k = Integer.parseInt(st.nextToken());\n		int n = Integer.parseInt(st.nextToken());\n		cc = new char[k][n];\n		for (int h = 0; h < k; h++)\n			br.readLine().getChars(0, n, cc[h], 0);\n		int h, d = -1;\nout:\n		for (h = 1; h < k; h++)\n			for (int i = 0; i < n; i++)\n				if (cc[0][i] != cc[h][i]) {\n					d = i;\n					break out;\n				}\n		char tmp;\n		if (d == -1) {\n			char[] s = cc[0];\n			tmp = s[0]; s[0] = s[1]; s[1] = tmp;\n			System.out.println(s);\n		} else {\n			boolean dup = false;\n			char[] s = cc[0];\n			for (int i = 0; i < n; i++)\n				for (int j = i + 1; j < n; j++)\n					if (s[i] == s[j])\n						dup = true;\n			for (int h_ = 0; h_ <= h; h_ += h) {\n				s = cc[h_];\n				for (int j = 0; j < n; j++)\n					if (j != d) {\n						tmp = s[j]; s[j] = s[d]; s[d] = tmp;\n						if (check(k, n, h_, dup)) {\n							System.out.println(s);\n							return;\n						}\n						tmp = s[j]; s[j] = s[d]; s[d] = tmp;\n					}\n			}\n			System.out.println(-1);\n		}\n	}\n}\n","brute force,hashing,implementation,strings"
"import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class e {\n	public static void main(String[] Args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int l = sc.nextInt();\n		int[][] alpha = new int[n][26];\n		String[] words = new String[n];\n		for (int i = 0; i < n; i++) {\n			words[i] = sc.next();\n			for (int j = 0; j < l; j++)\n				alpha[i][words[i].charAt(j) - 'a']++;\n		}\n		boolean dupe = false;\n		for (int i = 0; i < 26; i++)\n			if (alpha[0][i] > 1)\n				dupe = true;\n		boolean good = true;\n		for (int j = 1; j < n; j++)\n			for (int i = 0; i < 26; i++) {\n				if (alpha[j - 1][i] != alpha[j][i])\n					good = false;\n			}\n		if (!good) {\n			System.out.println(-1);\n			return;\n		}\n		int i = 0;\n		int maxDiff = 0;\n		for (int j = 0; j < n; j++) {\n			int diff = 0;\n			ArrayList<Integer> isDiff = new ArrayList<Integer>();\n			for (int k = 0; k < l; k++) {\n				if (words[i].charAt(k) != words[j].charAt(k)) {\n					diff++;\n					isDiff.add(k);\n				}\n			}\n			if (diff > maxDiff) {\n				maxDiff = diff;\n			}\n			if (maxDiff > 4) {\n				System.out.println(-1);\n				return;\n			} else if (diff == 3 || diff == 4) {\n				for (int ii = 0; ii < isDiff.size(); ii++)\n					for (int jj = ii + 1; jj < isDiff.size(); jj++) {\n						int iii = isDiff.get(ii);\n						int jjj = isDiff.get(jj);\n						String tmp = words[i].substring(0, iii) + words[i].charAt(jjj)\n								+ words[i].substring(iii + 1, jjj) + words[i].charAt(iii) + words[i].substring(jjj + 1);\n						good = true;\n						for (int a = 0; a < n; a++) {\n							int d = 0;\n							for (int b = 0; b < l; b++) {\n								if (tmp.charAt(b) != words[a].charAt(b)) {\n									d++;\n								}\n							}\n							if (d > 2 || (!dupe && d == 0))\n								good = false;\n						}\n						if (good) {\n							System.out.println(tmp);\n							return;\n						}\n					}\n				System.out.println(-1);\n				return;\n			}\n		}\n		if (maxDiff <= 2 && dupe) {\n			System.out.println(words[i]);\n			return;\n		}\n		if (maxDiff == 0) {\n			System.out.println(words[0].charAt(1) + """" + words[0].charAt(0) + words[0].substring(2));\n			return;\n		}\n		System.out.println(-1);\n	}\n}\n","brute force,hashing,implementation,strings"
"import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int k = sc.nextInt();\n        int n = sc.nextInt();\n\n        String[] s = new String[k];\n\n        for (int i = 0; i < k; i++) {\n            s[i] = sc.next();\n        }\n\n        char[] p = s[0].toCharArray();\n        Arrays.sort(p);\n\n        for (int i = 1; i < k; i++) {\n            char[] c = s[i].toCharArray();\n            Arrays.sort(c);\n            if (!Arrays.equals(p, c)) {\n                System.out.println(-1);\n                return;\n            }\n        }\n\n        int pi = 0, pj = 0;\n        boolean eq = true;\n\n        for (int i = 1; i < k; i++) {\n            if (!s[pi].equals(s[i])) {\n                eq = false;\n                pj = i;\n                break;\n            }\n        }\n\n        if (eq) {\n            char[] ans = s[0].toCharArray();\n\n            char tmp = ans[0];\n            ans[0] = ans[1];\n            ans[1] = tmp;\n\n            System.out.println(String.valueOf(ans));\n            return;\n        }\n\n        if (n == 2) {\n            System.out.println(-1);\n            return;\n        }\n\n        ArrayList<Integer> pos = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            if (s[pi].charAt(i) != s[pj].charAt(i)) {\n                pos.add(i);\n            }\n        }\n\n        if (pos.size() > 4) {\n            System.out.println(-1);\n            return;\n        }\n\n        for (int i : pos) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) continue;\n                char[] ans = s[pi].toCharArray();\n\n                char tmp = ans[i];\n                ans[i] = ans[j];\n                ans[j] = tmp;\n\n                boolean res = true;\n                for (String s1 : s) {\n                    int cnt = 0;\n                    for (int l = 0; l < n; l++) {\n                        if (ans[l] != s1.charAt(l)) {\n                            cnt++;\n                        }\n                    }\n\n                    if (cnt != 2 && cnt != 0) {\n                        res = false;\n                        break;\n                    }\n                }\n\n                if (res) {\n                    System.out.println(String.valueOf(ans));\n                    return;\n                }\n            }\n        }\n        System.out.println(-1);\n    }\n}","brute force,hashing,implementation,strings"
"import java.io.*;\nimport java.util.*;\npublic class EE {\n	public static void main(String[] args)throws Throwable {\n		MyScanner sc=new MyScanner();\n		PrintWriter pw=new PrintWriter(System.out);\n		\n		int k=sc.nextInt();\n		int n=sc.nextInt();\n		char [][] a=new char [k][n];\n		for(int i=0;i<k;i++)\n			a[i]=sc.next().toCharArray();\n		HashSet<Integer> [] dif=new HashSet [k];\n		for(int i=1;i<k;i++){\n			dif[i]=new HashSet<Integer>();\n			for(int j=0;j<n;j++)\n				if(a[i][j]!=a[0][j])\n					dif[i].add(j);\n		}\n		String ans=""-1"";\n		\n		boolean [] vis=new boolean [26];\n		boolean moreThenOnce=false;\n		for(char c : a[0]){\n			int x=c-'a';\n			if(vis[x]){\n				moreThenOnce=true;\n				break;\n			}\n			vis[x]=true;\n		}\n		for(int i=1;i<k;i++)\n			if(dif[i].size()>4){\n				System.out.println(-1);\n				return;\n			}\n		\n		toto : for(int i=0;i<n;i++){\n			for(int j=i+1;j<n;j++){\n				char tmp=a[0][i];\n				a[0][i]=a[0][j];\n				a[0][j]=tmp;\n				boolean ok=true;\n				third : for(int cur=1;cur<k;cur++){\n					HashSet<Integer> tmpDif=new HashSet<Integer>();\n					tmpDif.addAll(dif[cur]);\n					if(tmpDif.contains(i)){\n						if(a[0][i]==a[cur][i])\n							tmpDif.remove(i);\n					}else{\n						if(a[0][i]!=a[cur][i])\n							tmpDif.add(i);\n					}\n					if(tmpDif.contains(j)){\n						if(a[0][j]==a[cur][j])\n							tmpDif.remove(j);\n					}else{\n						if(a[0][j]!=a[cur][j])\n							tmpDif.add(j);\n					}\n					if(tmpDif.size()>2){\n						ok=false;\n						break third;\n					}\n					if(tmpDif.size()==2){\n						String first="""",second="""";\n						boolean f=true;\n						for(int x : tmpDif){\n							if(f)\n								first=""""+a[0][x]+a[cur][x];\n							else\n								second=""""+a[cur][x]+a[0][x];\n							f=false;\n						}\n//						if(i==1 && j==3){\n//							System.err.println(new String(a[0]));\n//							System.err.println(tmpDif);\n//							System.err.println(first+"" ""+second);\n//						}\n						if(!first.equals(second)){\n							ok=false;\n							break third;\n						}\n					}else\n						if(!moreThenOnce){\n							ok=false;\n							break third;\n						}\n				}\n				if(ok){\n					ans=new String(a[0]);\n					break toto;\n				}\n				tmp=a[0][i];\n				a[0][i]=a[0][j];\n				a[0][j]=tmp;\n			}\n		}\n		\n		\n		pw.println(ans);\n		pw.flush();\n		pw.close();\n	}\n	\n	static class MyScanner {\n		BufferedReader br;\n		StringTokenizer st;\n		public MyScanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n		String next() {while (st == null || !st.hasMoreElements()) {\n			try {st = new StringTokenizer(br.readLine());}\n			catch (IOException e) {e.printStackTrace();}}\n		return st.nextToken();}\n		int nextInt() {return Integer.parseInt(next());}\n		long nextLong() {return Long.parseLong(next());}\n		double nextDouble() {return Double.parseDouble(next());}\n		String nextLine(){String str = """";\n		try {str = br.readLine();}\n		catch (IOException e) {e.printStackTrace();}\n		return str;}\n	}\n}","brute force,hashing,implementation,strings"
"import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class cfShit {\n\n	int pow(int a, int b, int p) {\n		int ret = 1;\n		for (; b > 0; b >>= 1) {\n			if ((b & 1) == 1) {\n				ret = (int) ((long) ret * a % p);\n			}\n			a = (int) ((long) a * a % p);\n		}\n		return ret;\n	}\n\n	int primitiveRoot(int p) {\n		loop: for (int i = 2;; i++) {\n			for (int j = 2; j * j <= p - 1; j++) {\n				if ((p - 1) % j != 0) {\n					continue;\n				}\n				if (pow(i, (p - 1) / j, p) == 1) {\n					continue loop;\n				}\n				if (pow(i, j, p) == 1) {\n					continue loop;\n				}\n			}\n			return i;\n		}\n	}\n\n	static final int C = 5000;\n\n	int[] chirp(int[] a, int[] pz, int p) {\n		int n = a.length;\n		// pz[1] has order 2 * n modulo prime p\n\n		a = a.clone();\n		for (int i = 0; i < n; i++) {\n			a[i] %= p;\n		}\n\n		int[] one = new int[n];\n		for (int i = 0; i < n; i++) {\n			one[i] = (int) ((long) a[i] * pz[(int) ((long)i * i % (2 * n))] % p);\n		}\n\n		int[] two = new int[2 * n - 1];\n		for (int i = 0; i <= 2 * n - 2; i++) {\n			two[i] = pz[(int) Math.floorMod(-(long)(n - 1 - i) * (n - 1 - i), 2 * n)];\n		}\n\n		int[] prod = mult(one, two, p);\n\n		prod = Arrays.copyOfRange(prod, n - 1, 2 * n - 1);\n		for (int i = 0; i < n; i++) {\n			prod[i] = (int) ((long) prod[i] * pz[(int) ((long)i * i % (2 * n))] % p);\n		}\n\n		return prod;\n		// returns polynomial a modulo p at points 1, rootZ^2, rootZ^4, ...\n	}\n\n	void submit() {\n		int n = nextInt();\n		int[] b = new int[n];\n		int[] c = new int[n];\n		\n		for (int i = 0; i < n; i++) {\n			b[i] = nextInt();\n		}\n		\n		int[] initB = b.clone();\n		\n		b = makeInvPows(b);\n		\n		for (int i = 0; i < n; i++) {\n			c[i] = nextInt();\n		}\n		\n\n		int z, p;\n		int[] pz;\n\n		int[] fb;\n\n		for (int i = 1;; i++) {\n			p = 2 * n * i + 1;\n			if (p < C) {\n				continue;\n			}\n			if (!BigInteger.valueOf(p).isProbablePrime(30)) {\n				continue;\n			}\n			z = pow(primitiveRoot(p), (p - 1) / (2 * n), p);\n			pz = new int[2 * n];\n			pz[0] = 1;\n			for (int j = 1; j < pz.length; j++) {\n				pz[j] = (int) ((long) pz[j - 1] * z % p);\n			}\n\n			fb = chirp(b, pz, p);\n			boolean allGood = true;\n			for (int coef : fb) {\n				allGood &= coef != 0;\n			}\n\n			if (allGood) {\n				break;\n			}\n		}\n\n		int[] cc = new int[n];\n		int inv2 = (p + 1) / 2;\n		for (int i = 0; i < n; i++) {\n			cc[i] = (c[(i + n - 1) % n] - c[i]) % p;\n			if (cc[i] < 0) {\n				cc[i] += p;\n			}\n			cc[i] = (int)((long)cc[i] * inv2 % p);\n		}\n		\n		int[] fc = chirp(cc, pz, p);\n		\n		int[] fa = new int[n];\n		for (int i = 0; i < n; i++) {\n			fa[i] = (int)((long)fc[i] * pow(fb[i], p - 2, p) % p);\n		}\n		\n		int[] aa = chirp(fa, makeInvPows(pz), p);\n		int invN = pow(n, p - 2, p);\n		for (int i = 0; i < n; i++) {\n			aa[i] = (int)((long)aa[i] * invN % p);\n		}\n		\n		long[] d = new long[n];\n		for (int i = 1; i < n; i++) {\n			d[i] = d[i - 1] + makeInt(aa[i], p);\n		}\n		\n//		System.err.println(Arrays.toString(realAa));\n		\n		long A = n;\n		long B = 0;\n		long C = -c[0];\n		for (int i = 0; i < n; i++) {\n			long diff = initB[i] - d[i];\n			B -= diff;\n			C += diff * diff;\n		}\n		\n//		System.err.println(A + "" "" + B + "" "" + C);\n		\n		List<Long> x0s = new ArrayList<>();\n		\n		long D = B * B - A * C;\n		if (D < 0) {\n		} else if (D == 0) {\n			if ((-B % A) == 0) {\n				x0s.add((-B) / A);\n			}\n		} else {\n			long rd = (long) Math.sqrt(D);\n			if (rd * rd == D) {\n				if ((-B - rd) % A == 0) {\n					x0s.add((-B - rd) / A);\n				}\n				if ((-B + rd) % A == 0) {\n					x0s.add((-B + rd) / A);\n				}\n			}\n		}\n		\n		out.println(x0s.size());\n		for (long x0 : x0s) {\n			for(int i = 0; i < n; i++) {\n				out.print(d[i] + x0 + "" "");\n			}\n			out.println();\n		}\n		\n	}\n	\n	int makeInt(int x, int p) {\n		return x < p / 2 ? x : x - p;\n	}\n	\n	int[] makeInvPows(int[] a) {\n		int[] b = new int[a.length];\n		b[0] = a[0];\n		for (int i = 1, j = a.length - 1; i < a.length; i++, j--) {\n			b[i] = a[j];\n		}\n		return b;\n	}\n\n	void preCalc() {\n\n	}\n\n	void stress() {\n\n	}\n\n	void test() {\n\n	}\n\n	cfShit() throws IOException {\n		br = new BufferedReader(new InputStreamReader(System.in));\n		out = new PrintWriter(System.out);\n		preCalc();\n		submit();\n		// stress();\n		// test();\n		out.close();\n	}\n\n	static int nextPowerOf2(int x) {\n		return x == 1 ? 1 : Integer.highestOneBit(x - 1) << 1;\n	}\n\n	static double[][] foo(int[] intV, int len, int L) {\n		// pack into one complex vector\n		double[] f = new double[len << 1];\n		for (int i = 0; i < intV.length; i++) {\n			f[i << 1] = intV[i] % L;\n			f[i << 1 | 1] = intV[i] / L;\n		}\n\n		fft(f, false);\n\n		// unpack\n		double[] f1 = new double[len << 1];\n		double[] f2 = new double[len << 1];\n\n		// LEN MUST BE A POWER OF 2!!!\n		int zzz = (len << 1) - 1;\n		for (int i = 0; i < len << 1; i += 2) {\n			int j = (-i) & zzz;\n			f1[i] = .5 * (f[i] + f[j]);\n			f1[i + 1] = .5 * (f[i + 1] - f[j + 1]);\n			f2[i] = .5 * (f[i + 1] + f[j + 1]);\n			f2[i + 1] = .5 * (f[j] - f[i]);\n		}\n\n		return new double[][] { f1, f2 };\n	}\n\n	public static int[] mult(int[] a, int[] b, int pMod) {\n		\n		int k = (int) (Math.sqrt(pMod) + 1);\n		int k2 = k * k % pMod;\n		\n		int len = nextPowerOf2(a.length + b.length - 1);\n		int len2 = len << 1;\n\n		double[][] fA = foo(a, len, k);\n		double[][] fB = foo(b, len, k);\n\n		double[][] invF = new double[2][len2];\n\n		for (int ia = 0; ia < 2; ia++) {\n			for (int ib = 0; ib < 2; ib++) {\n\n				double[] r = invF[(ia + ib) >> 1];\n				double[] p = fA[ia];\n				double[] q = fB[ib];\n\n				if (((ia + ib) & 1) == 0) {\n					for (int i = 0; i < len2; i += 2) {\n						r[i] += p[i] * q[i] - p[i + 1] * q[i + 1];\n						r[i + 1] += p[i] * q[i + 1] + p[i + 1] * q[i];\n					}\n\n				} else {\n					for (int i = 0; i < len2; i += 2) {\n						r[i] -= p[i] * q[i + 1] + p[i + 1] * q[i];\n						r[i + 1] += p[i] * q[i] - p[i + 1] * q[i + 1];\n					}\n				}\n\n			}\n		}\n\n		fft(invF[0], true);\n		fft(invF[1], true);\n\n		int[] ret = new int[len];\n\n		for (int i = 0; i < len2; i += 2) {\n//			long v0 = Math.round(invF[0][i]) % P;\n//			long v1 = Math.round(invF[0][i + 1]) % P * L % P;\n//			long v2 = Math.round(invF[1][i]) % P * L2 % P;\n			long v0 = (long)(invF[0][i] + .5);\n			long v1 = ((long)(invF[0][i + 1] + .5)) % pMod * k;\n			long v2 = ((long)(invF[1][i] + .5)) % pMod * k2;\n			ret[i >> 1] = (int) ((v0 + v1 + v2) % pMod);\n		}\n\n		return ret;\n	}\n\n	public static void fft(double[] v, boolean invert) {\n		int n2 = v.length;\n		int n = n2 >> 1;\n		int logN = Integer.numberOfTrailingZeros(n);\n		prepareArrays(logN);\n		int[] rev = rev2D[logN];\n\n		for (int i = 0; i < n2; i += 2) {\n			int j = rev[i >> 1] << 1;\n			if (i < j) {\n				double t = v[i];\n				v[i] = v[j];\n				v[j] = t;\n				t = v[i + 1];\n				v[i + 1] = v[j + 1];\n				v[j + 1] = t;\n			}\n		}\n\n		double conj = invert ? -1 : 1;\n\n		for (int len = 2, row = 0; len <= n; len <<= 1, row++) {\n			double[] pow = pow2D[row];\n			for (int i = 0; i < n; i += len) {\n				for (int j1 = i << 1, j2 = j1 + len, k = 0; k < len; j1 += 2, j2 += 2, k += 2) {\n					double uA = v[j1];\n					double uB = v[j1 + 1];\n\n					double mRe = pow[k];\n					double mIm = pow[k + 1] * conj;\n\n					double vA = v[j2] * mRe - v[j2 + 1] * mIm;\n					double vB = v[j2] * mIm + v[j2 + 1] * mRe;\n\n					v[j1] = uA + vA;\n					v[j1 + 1] = uB + vB;\n					v[j2] = uA - vA;\n					v[j2 + 1] = uB - vB;\n				}\n			}\n		}\n		if (invert) {\n			for (int i = 0; i < n2; i++) {\n				v[i] /= n;\n			}\n		}\n	}\n\n	static double[][] pow2D = { { 1, 0 } };\n	static int[][] rev2D = {};\n\n	static void prepareArrays(int n) {\n		if (rev2D.length < n + 1) {\n			rev2D = Arrays.copyOf(rev2D, n + 1);\n		}\n\n		if (rev2D[n] == null) {\n			int[] tmp = rev2D[n] = new int[1 << n];\n			for (int i = 0; i < (1 << n); i++) {\n				tmp[i] = (tmp[i >> 1] >> 1) | ((i & 1) << (n - 1));\n			}\n		}\n\n		int oldN = pow2D.length;\n\n		if (oldN >= n) {\n			return;\n		}\n\n		pow2D = Arrays.copyOf(pow2D, n);\n\n		for (int i = oldN; i < n; i++) {\n			double angle = Math.PI / (1 << i);\n\n			double mRe = Math.cos(angle);\n			double mIm = Math.sin(angle);\n\n			double[] dst = pow2D[i] = new double[2 << i];\n			double[] src = pow2D[i - 1];\n\n			for (int j = 0; j < 1 << i; j += 2) {\n				double re = src[j];\n				double im = src[j + 1];\n\n				dst[j << 1] = re;\n				dst[j << 1 | 1] = im;\n				dst[j << 1 | 2] = re * mRe - im * mIm;\n				dst[j << 1 | 3] = re * mIm + im * mRe;\n			}\n		}\n	}\n\n	static final Random rng = new Random();\n\n	static int rand(int l, int r) {\n		return l + rng.nextInt(r - l + 1);\n	}\n\n	public static void main(String[] args) throws IOException {\n		new cfShit();\n	}\n\n	BufferedReader br;\n	PrintWriter out;\n	StringTokenizer st;\n\n	String nextToken() {\n		while (st == null || !st.hasMoreTokens()) {\n			try {\n				st = new StringTokenizer(br.readLine());\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n		}\n		return st.nextToken();\n	}\n\n	String nextString() {\n		try {\n			return br.readLine();\n		} catch (IOException e) {\n			throw new RuntimeException(e);\n		}\n	}\n\n	int nextInt() {\n		return Integer.parseInt(nextToken());\n	}\n\n	long nextLong() {\n		return Long.parseLong(nextToken());\n	}\n\n	double nextDouble() {\n		return Double.parseDouble(nextToken());\n	}\n}","fft,math"
"import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class cfShit {\n\n	int pow(int a, int b, int p) {\n		int ret = 1;\n		for (; b > 0; b >>= 1) {\n			if ((b & 1) == 1) {\n				ret = (int) ((long) ret * a % p);\n			}\n			a = (int) ((long) a * a % p);\n		}\n		return ret;\n	}\n\n	int primitiveRoot(int p) {\n		loop: for (int i = 2;; i++) {\n			for (int j = 2; j * j <= p - 1; j++) {\n				if ((p - 1) % j != 0) {\n					continue;\n				}\n				if (pow(i, (p - 1) / j, p) == 1) {\n					continue loop;\n				}\n				if (pow(i, j, p) == 1) {\n					continue loop;\n				}\n			}\n			return i;\n		}\n	}\n\n	static final int C = 5000;\n\n	int[] chirp(int[] a, int[] pz, int p) {\n		int n = a.length;\n		// pz[1] has order 2 * n modulo prime p\n\n		a = a.clone();\n		for (int i = 0; i < n; i++) {\n			a[i] %= p;\n		}\n\n		int[] one = new int[n];\n		for (int i = 0; i < n; i++) {\n			one[i] = (int) ((long) a[i] * pz[(int) ((long)i * i % (2 * n))] % p);\n		}\n\n		int[] two = new int[2 * n - 1];\n		for (int i = 0; i <= 2 * n - 2; i++) {\n			two[i] = pz[(int) Math.floorMod(-(long)(n - 1 - i) * (n - 1 - i), 2 * n)];\n		}\n\n		int[] prod = mult(one, two, p);\n\n		prod = Arrays.copyOfRange(prod, n - 1, 2 * n - 1);\n		for (int i = 0; i < n; i++) {\n			prod[i] = (int) ((long) prod[i] * pz[(int) ((long)i * i % (2 * n))] % p);\n		}\n\n		return prod;\n		// returns polynomial a modulo p at points 1, rootZ^2, rootZ^4, ...\n	}\n\n	void submit() {\n		int n = nextInt();\n		int[] b = new int[n];\n		int[] c = new int[n];\n		\n		for (int i = 0; i < n; i++) {\n			b[i] = nextInt();\n		}\n		\n		int[] initB = b.clone();\n		\n		b = makeInvPows(b);\n		\n		for (int i = 0; i < n; i++) {\n			c[i] = nextInt();\n		}\n		\n\n		int z, p;\n		int[] pz;\n\n		int[] fb;\n\n		for (int i = 1;; i++) {\n			p = 2 * n * i + 1;\n			if (p < C) {\n				continue;\n			}\n			if (!BigInteger.valueOf(p).isProbablePrime(30)) {\n				continue;\n			}\n			z = pow(primitiveRoot(p), (p - 1) / (2 * n), p);\n			pz = new int[2 * n];\n			pz[0] = 1;\n			for (int j = 1; j < pz.length; j++) {\n				pz[j] = (int) ((long) pz[j - 1] * z % p);\n			}\n\n			fb = chirp(b, pz, p);\n			boolean allGood = true;\n			for (int coef : fb) {\n				allGood &= coef != 0;\n			}\n\n			if (allGood) {\n				break;\n			}\n		}\n\n		int[] cc = new int[n];\n		int inv2 = (p + 1) / 2;\n		for (int i = 0; i < n; i++) {\n			cc[i] = (c[(i + n - 1) % n] - c[i]) % p;\n			if (cc[i] < 0) {\n				cc[i] += p;\n			}\n			cc[i] = (int)((long)cc[i] * inv2 % p);\n		}\n		\n		int[] fc = chirp(cc, pz, p);\n		\n		int[] fa = new int[n];\n		for (int i = 0; i < n; i++) {\n			fa[i] = (int)((long)fc[i] * pow(fb[i], p - 2, p) % p);\n		}\n		\n		int[] aa = chirp(fa, makeInvPows(pz), p);\n		int invN = pow(n, p - 2, p);\n		for (int i = 0; i < n; i++) {\n			aa[i] = (int)((long)aa[i] * invN % p);\n		}\n		\n		long[] d = new long[n];\n		for (int i = 1; i < n; i++) {\n			d[i] = d[i - 1] + makeInt(aa[i], p);\n		}\n		\n//		System.err.println(Arrays.toString(realAa));\n		\n		long A = n;\n		long B = 0;\n		long C = -c[0];\n		for (int i = 0; i < n; i++) {\n			long diff = initB[i] - d[i];\n			B -= diff;\n			C += diff * diff;\n		}\n		\n//		System.err.println(A + "" "" + B + "" "" + C);\n		\n		List<Long> x0s = new ArrayList<>();\n		\n		long D = B * B - A * C;\n		if (D < 0) {\n		} else if (D == 0) {\n			if ((-B % A) == 0) {\n				x0s.add((-B) / A);\n			}\n		} else {\n			long rd = (long) Math.sqrt(D);\n			if (rd * rd == D) {\n				if ((-B - rd) % A == 0) {\n					x0s.add((-B - rd) / A);\n				}\n				if ((-B + rd) % A == 0) {\n					x0s.add((-B + rd) / A);\n				}\n			}\n		}\n		\n		out.println(x0s.size());\n		for (long x0 : x0s) {\n			for(int i = 0; i < n; i++) {\n				out.print(d[i] + x0 + "" "");\n			}\n			out.println();\n		}\n		\n	}\n	\n	int makeInt(int x, int p) {\n		return x < p / 2 ? x : x - p;\n	}\n	\n	int[] makeInvPows(int[] a) {\n		int[] b = new int[a.length];\n		b[0] = a[0];\n		for (int i = 1, j = a.length - 1; i < a.length; i++, j--) {\n			b[i] = a[j];\n		}\n		return b;\n	}\n\n	void preCalc() {\n\n	}\n\n	void stress() {\n\n	}\n\n	void test() {\n\n	}\n\n	cfShit() throws IOException {\n		br = new BufferedReader(new InputStreamReader(System.in));\n		out = new PrintWriter(System.out);\n		preCalc();\n		submit();\n		// stress();\n		// test();\n		out.close();\n	}\n\n	static int nextPowerOf2(int x) {\n		return x == 1 ? 1 : Integer.highestOneBit(x - 1) << 1;\n	}\n\n	static double[][] foo(int[] intV, int len, int L) {\n		// pack into one complex vector\n		double[] f = new double[len << 1];\n		for (int i = 0; i < intV.length; i++) {\n			f[i << 1] = intV[i] % L;\n			f[i << 1 | 1] = intV[i] / L;\n		}\n\n		fft(f, false);\n\n		// unpack\n		double[] f1 = new double[len << 1];\n		double[] f2 = new double[len << 1];\n\n		// LEN MUST BE A POWER OF 2!!!\n		int zzz = (len << 1) - 1;\n		for (int i = 0; i < len << 1; i += 2) {\n			int j = (-i) & zzz;\n			f1[i] = .5 * (f[i] + f[j]);\n			f1[i + 1] = .5 * (f[i + 1] - f[j + 1]);\n			f2[i] = .5 * (f[i + 1] + f[j + 1]);\n			f2[i + 1] = .5 * (f[j] - f[i]);\n		}\n\n		return new double[][] { f1, f2 };\n	}\n\n	public static int[] mult(int[] a, int[] b, int pMod) {\n		\n		int k = (int) (Math.sqrt(pMod) + 1);\n		int k2 = k * k % pMod;\n		\n		int len = nextPowerOf2(a.length + b.length - 1);\n		int len2 = len << 1;\n\n		double[][] fA = foo(a, len, k);\n		double[][] fB = foo(b, len, k);\n\n		double[][] invF = new double[2][len2];\n\n		for (int ia = 0; ia < 2; ia++) {\n			for (int ib = 0; ib < 2; ib++) {\n\n				double[] r = invF[(ia + ib) >> 1];\n				double[] p = fA[ia];\n				double[] q = fB[ib];\n\n				if (((ia + ib) & 1) == 0) {\n					for (int i = 0; i < len2; i += 2) {\n						r[i] += p[i] * q[i] - p[i + 1] * q[i + 1];\n						r[i + 1] += p[i] * q[i + 1] + p[i + 1] * q[i];\n					}\n\n				} else {\n					for (int i = 0; i < len2; i += 2) {\n						r[i] -= p[i] * q[i + 1] + p[i + 1] * q[i];\n						r[i + 1] += p[i] * q[i] - p[i + 1] * q[i + 1];\n					}\n				}\n\n			}\n		}\n\n		fft(invF[0], true);\n		fft(invF[1], true);\n\n		int[] ret = new int[len];\n\n		for (int i = 0; i < len2; i += 2) {\n//			long v0 = Math.round(invF[0][i]) % P;\n//			long v1 = Math.round(invF[0][i + 1]) % P * L % P;\n//			long v2 = Math.round(invF[1][i]) % P * L2 % P;\n			long v0 = (long)(invF[0][i] + .5);\n			long v1 = ((long)(invF[0][i + 1] + .5)) % pMod * k;\n			long v2 = ((long)(invF[1][i] + .5)) % pMod * k2;\n			ret[i >> 1] = (int) ((v0 + v1 + v2) % pMod);\n		}\n\n		return ret;\n	}\n\n	public static void fft(double[] v, boolean invert) {\n		int n2 = v.length;\n		int n = n2 >> 1;\n		int logN = Integer.numberOfTrailingZeros(n);\n		prepareArrays(logN);\n		int[] rev = rev2D[logN];\n\n		for (int i = 0; i < n2; i += 2) {\n			int j = rev[i >> 1] << 1;\n			if (i < j) {\n				double t = v[i];\n				v[i] = v[j];\n				v[j] = t;\n				t = v[i + 1];\n				v[i + 1] = v[j + 1];\n				v[j + 1] = t;\n			}\n		}\n\n		double conj = invert ? -1 : 1;\n\n		for (int len = 2, row = 0; len <= n; len <<= 1, row++) {\n			double[] pow = pow2D[row];\n			for (int i = 0; i < n; i += len) {\n				for (int j1 = i << 1, j2 = j1 + len, k = 0; k < len; j1 += 2, j2 += 2, k += 2) {\n					double uA = v[j1];\n					double uB = v[j1 + 1];\n\n					double mRe = pow[k];\n					double mIm = pow[k + 1] * conj;\n\n					double vA = v[j2] * mRe - v[j2 + 1] * mIm;\n					double vB = v[j2] * mIm + v[j2 + 1] * mRe;\n\n					v[j1] = uA + vA;\n					v[j1 + 1] = uB + vB;\n					v[j2] = uA - vA;\n					v[j2 + 1] = uB - vB;\n				}\n			}\n		}\n		if (invert) {\n			for (int i = 0; i < n2; i++) {\n				v[i] /= n;\n			}\n		}\n	}\n\n	static double[][] pow2D = { { 1, 0 } };\n	static int[][] rev2D = {};\n\n	static void prepareArrays(int n) {\n		if (rev2D.length < n + 1) {\n			rev2D = Arrays.copyOf(rev2D, n + 1);\n		}\n\n		if (rev2D[n] == null) {\n			int[] tmp = rev2D[n] = new int[1 << n];\n			for (int i = 0; i < (1 << n); i++) {\n				tmp[i] = (tmp[i >> 1] >> 1) | ((i & 1) << (n - 1));\n			}\n		}\n\n		int oldN = pow2D.length;\n\n		if (oldN >= n) {\n			return;\n		}\n\n		pow2D = Arrays.copyOf(pow2D, n);\n\n		for (int i = oldN; i < n; i++) {\n			double angle = Math.PI / (1 << i);\n\n			double mRe = Math.cos(angle);\n			double mIm = Math.sin(angle);\n\n			double[] dst = pow2D[i] = new double[2 << i];\n			double[] src = pow2D[i - 1];\n\n			for (int j = 0; j < 1 << i; j += 2) {\n				double re = src[j];\n				double im = src[j + 1];\n\n				dst[j << 1] = re;\n				dst[j << 1 | 1] = im;\n				dst[j << 1 | 2] = re * mRe - im * mIm;\n				dst[j << 1 | 3] = re * mIm + im * mRe;\n			}\n		}\n	}\n\n	static final Random rng = new Random();\n\n	static int rand(int l, int r) {\n		return l + rng.nextInt(r - l + 1);\n	}\n\n	public static void main(String[] args) throws IOException {\n		new cfShit();\n	}\n\n	BufferedReader br;\n	PrintWriter out;\n	StringTokenizer st;\n\n	String nextToken() {\n		while (st == null || !st.hasMoreTokens()) {\n			try {\n				st = new StringTokenizer(br.readLine());\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n		}\n		return st.nextToken();\n	}\n\n	String nextString() {\n		try {\n			return br.readLine();\n		} catch (IOException e) {\n			throw new RuntimeException(e);\n		}\n	}\n\n	int nextInt() {\n		return Integer.parseInt(nextToken());\n	}\n\n	long nextLong() {\n		return Long.parseLong(nextToken());\n	}\n\n	double nextDouble() {\n		return Double.parseDouble(nextToken());\n	}\n}","fft,math"
"import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class E {\n\n	int pow(int a, int b, int p) {\n		int ret = 1;\n		for (; b > 0; b >>= 1) {\n			if ((b & 1) == 1) {\n				ret = (int) ((long) ret * a % p);\n			}\n			a = (int) ((long) a * a % p);\n		}\n		return ret;\n	}\n\n	int primitiveRoot(int p) {\n		loop: for (int i = 2;; i++) {\n			for (int j = 2; j * j <= p - 1; j++) {\n				if ((p - 1) % j != 0) {\n					continue;\n				}\n				if (pow(i, (p - 1) / j, p) == 1) {\n					continue loop;\n				}\n				if (pow(i, j, p) == 1) {\n					continue loop;\n				}\n			}\n			return i;\n		}\n	}\n\n	static final int C = 5000;\n\n	int[] chirp(int[] a, int[] pz, int p) {\n		int n = a.length;\n		// pz[1] has order 2 * n modulo prime p\n\n		a = a.clone();\n		for (int i = 0; i < n; i++) {\n			a[i] %= p;\n		}\n\n		int[] one = new int[n];\n		for (int i = 0; i < n; i++) {\n			one[i] = (int) ((long) a[i] * pz[(int) ((long)i * i % (2 * n))] % p);\n		}\n\n		int[] two = new int[2 * n - 1];\n		for (int i = 0; i <= 2 * n - 2; i++) {\n			two[i] = pz[(int) Math.floorMod(-(long)(n - 1 - i) * (n - 1 - i), 2 * n)];\n		}\n\n		int[] prod = mult(one, two, p);\n\n		prod = Arrays.copyOfRange(prod, n - 1, 2 * n - 1);\n		for (int i = 0; i < n; i++) {\n			prod[i] = (int) ((long) prod[i] * pz[(int) ((long)i * i % (2 * n))] % p);\n		}\n\n		return prod;\n		// returns polynomial a modulo p at points 1, rootZ^2, rootZ^4, ...\n	}\n\n	void submit() {\n		int n = nextInt();\n		int[] b = new int[n];\n		int[] c = new int[n];\n		\n		for (int i = 0; i < n; i++) {\n			b[i] = nextInt();\n		}\n		\n		int[] initB = b.clone();\n		\n		b = makeInvPows(b);\n		\n		for (int i = 0; i < n; i++) {\n			c[i] = nextInt();\n		}\n		\n\n		int z, p;\n		int[] pz;\n\n		int[] fb;\n\n		for (int i = 1;; i++) {\n			p = 2 * n * i + 1;\n			if (p < C) {\n				continue;\n			}\n			if (!BigInteger.valueOf(p).isProbablePrime(30)) {\n				continue;\n			}\n			z = pow(primitiveRoot(p), (p - 1) / (2 * n), p);\n			pz = new int[2 * n];\n			pz[0] = 1;\n			for (int j = 1; j < pz.length; j++) {\n				pz[j] = (int) ((long) pz[j - 1] * z % p);\n			}\n\n			fb = chirp(b, pz, p);\n			boolean allGood = true;\n			for (int coef : fb) {\n				allGood &= coef != 0;\n			}\n\n			if (allGood) {\n				break;\n			}\n		}\n\n		int[] cc = new int[n];\n		int inv2 = (p + 1) / 2;\n		for (int i = 0; i < n; i++) {\n			cc[i] = (c[(i + n - 1) % n] - c[i]) % p;\n			if (cc[i] < 0) {\n				cc[i] += p;\n			}\n			cc[i] = (int)((long)cc[i] * inv2 % p);\n		}\n		\n		int[] fc = chirp(cc, pz, p);\n		\n		int[] fa = new int[n];\n		for (int i = 0; i < n; i++) {\n			fa[i] = (int)((long)fc[i] * pow(fb[i], p - 2, p) % p);\n		}\n		\n		int[] aa = chirp(fa, makeInvPows(pz), p);\n		int invN = pow(n, p - 2, p);\n		for (int i = 0; i < n; i++) {\n			aa[i] = (int)((long)aa[i] * invN % p);\n		}\n		\n		long[] d = new long[n];\n		for (int i = 1; i < n; i++) {\n			d[i] = d[i - 1] + makeInt(aa[i], p);\n		}\n		\n//		System.err.println(Arrays.toString(realAa));\n		\n		long A = n;\n		long B = 0;\n		long C = -c[0];\n		for (int i = 0; i < n; i++) {\n			long diff = initB[i] - d[i];\n			B -= diff;\n			C += diff * diff;\n		}\n		\n//		System.err.println(A + "" "" + B + "" "" + C);\n		\n		List<Long> x0s = new ArrayList<>();\n		\n		long D = B * B - A * C;\n		if (D < 0) {\n		} else if (D == 0) {\n			if ((-B % A) == 0) {\n				x0s.add((-B) / A);\n			}\n		} else {\n			long rd = (long) Math.sqrt(D);\n			if (rd * rd == D) {\n				if ((-B - rd) % A == 0) {\n					x0s.add((-B - rd) / A);\n				}\n				if ((-B + rd) % A == 0) {\n					x0s.add((-B + rd) / A);\n				}\n			}\n		}\n		\n		out.println(x0s.size());\n		for (long x0 : x0s) {\n			for(int i = 0; i < n; i++) {\n				out.print(d[i] + x0 + "" "");\n			}\n			out.println();\n		}\n		\n	}\n	\n	int makeInt(int x, int p) {\n		return x < p / 2 ? x : x - p;\n	}\n	\n	int[] makeInvPows(int[] a) {\n		int[] b = new int[a.length];\n		b[0] = a[0];\n		for (int i = 1, j = a.length - 1; i < a.length; i++, j--) {\n			b[i] = a[j];\n		}\n		return b;\n	}\n\n	void preCalc() {\n\n	}\n\n	void stress() {\n\n	}\n\n	void test() {\n\n	}\n\n	E() throws IOException {\n		br = new BufferedReader(new InputStreamReader(System.in));\n		out = new PrintWriter(System.out);\n		preCalc();\n		submit();\n		// stress();\n		// test();\n		out.close();\n	}\n\n	// this version is more precise\n	// but looks like it might be a bit slower\n	// I should profile and optimize it some day...\n\n	static int nextPowerOf2(int x) {\n		return x == 1 ? 1 : Integer.highestOneBit(x - 1) << 1;\n	}\n\n	static class CompV {\n		double[] re, im;\n\n		void add(CompV o) {\n			for (int i = 0; i < re.length; i++) {\n				re[i] += o.re[i];\n				im[i] += o.im[i];\n			}\n		}\n\n		static CompV times(CompV a, CompV b) {\n			double[] aRe = a.re;\n			double[] aIm = a.im;\n			double[] bRe = b.re;\n			double[] bIm = b.im;\n			double[] re = new double[aRe.length];\n			double[] im = new double[aRe.length];\n\n			for (int i = 0; i < aRe.length; i++) {\n				re[i] = aRe[i] * bRe[i] - aIm[i] * bIm[i];\n				im[i] = aRe[i] * bIm[i] + aIm[i] * bRe[i];\n			}\n\n			return new CompV(re, im);\n		}\n\n		static CompV plus(CompV a, CompV b) {\n			double[] aRe = a.re;\n			double[] aIm = a.im;\n			double[] bRe = b.re;\n			double[] bIm = b.im;\n			double[] re = new double[aRe.length];\n			double[] im = new double[aRe.length];\n\n			for (int i = 0; i < aRe.length; i++) {\n				re[i] = aRe[i] + bRe[i];\n				im[i] = aIm[i] + bIm[i];\n			}\n\n			return new CompV(re, im);\n		}\n\n		/**\n		 * @return a + bi\n		 */\n		static CompV packFFT(CompV a, CompV b) {\n			double[] aRe = a.re;\n			double[] aIm = a.im;\n			double[] bRe = b.re;\n			double[] bIm = b.im;\n			double[] re = new double[aRe.length];\n			double[] im = new double[aRe.length];\n			for (int i = 0; i < aRe.length; i++) {\n				re[i] = aRe[i] - bIm[i];\n				im[i] = aIm[i] + bRe[i];\n			}\n			return new CompV(re, im);\n		}\n\n		/**\n		 * for real-valued a and b restores FFT(a) and FFT(b) from FFT(a + bi)\n		 */\n		void unpackFFT(CompV a, CompV b) {\n			int n = re.length;\n			double[] aRe = a.re;\n			double[] aIm = a.im;\n			double[] bRe = b.re;\n			double[] bIm = b.im;\n			for (int i = 0; i < n; i++) {\n				int j = i == 0 ? 0 : n - i;\n				aRe[i] = (re[i] + re[j]) * 0.5;\n				aIm[i] = (im[i] - im[j]) * 0.5;\n				bRe[i] = (im[i] + im[j]) * 0.5;\n				bIm[i] = (re[j] - re[i]) * 0.5;\n			}\n		}\n\n		public CompV(double[] re, double[] im) {\n			this.re = re;\n			this.im = im;\n		}\n\n		public CompV(int len) {\n			re = new double[len];\n			im = new double[len];\n		}\n	}\n\n	// !!!!\n	// TEST WITH JUST ONE MULTIPLICATION\n	public static int[] mult(int[] a, int[] b, int p) {\n		int len = nextPowerOf2(a.length + b.length - 1);\n\n		int k = (int) (Math.sqrt(p) + 1);\n		int k2 = k * k % p;\n\n		double[] p1 = new double[len];\n		double[] q1 = new double[len];\n		for (int i = 0; i < a.length; i++) {\n			p1[i] = a[i] % k;\n			q1[i] = a[i] / k;\n		}\n\n		double[] p2 = new double[len];\n		double[] q2 = new double[len];\n		for (int i = 0; i < b.length; i++) {\n			p2[i] = b[i] % k;\n			q2[i] = b[i] / k;\n		}\n\n		CompV p1p2Pack = new CompV(p1, p2);\n		CompV q1q2Pack = new CompV(q1, q2);\n\n		fft(p1p2Pack, false);\n		fft(q1q2Pack, false);\n\n		CompV fp1 = new CompV(len);\n		CompV fp2 = new CompV(len);\n		p1p2Pack.unpackFFT(fp1, fp2);\n\n		CompV fq1 = new CompV(len);\n		CompV fq2 = new CompV(len);\n		q1q2Pack.unpackFFT(fq1, fq2);\n\n		CompV back0 = CompV.times(fp1, fp2);\n\n		CompV back1 = CompV.times(fp1, fq2);\n		back1.add(CompV.times(fq1, fp2));\n\n		CompV back2 = CompV.times(fq1, fq2);\n\n		CompV back01 = CompV.packFFT(back0, back1);\n\n		fft(back01, true);\n		fft(back2, true);\n\n		int[] ret = new int[len];\n\n		for (int i = 0; i < len; i++) {\n			long v0 = Math.round(back01.re[i]) % p;\n			long v1 = Math.round(back01.im[i]) % p * k % p;\n			long v2 = Math.round(back2.re[i]) % p * k2 % p;\n			ret[i] = (int) ((v0 + v1 + v2) % p);\n		}\n\n		return ret;\n	}\n\n	public static void fft(CompV v, boolean invert) {\n		double[] a = v.re;\n		double[] b = v.im;\n		int n = a.length;\n		int shift = 32 - Integer.numberOfTrailingZeros(n);\n		prepareArrays(32 - shift);\n		int[] rev = rev2D[32 - shift];\n		// System.err.println(n + "" "" + shift);\n		for (int i = 1; i < n; i++) {\n			int j = rev[i];\n			if (i < j) {\n				double temp = a[i];\n				a[i] = a[j];\n				a[j] = temp;\n				temp = b[i];\n				b[i] = b[j];\n				b[j] = temp;\n			}\n		}\n\n		// this shit looks awkward\n		double multInv = invert ? -1 : 1;\n\n		for (int len = 2, row = 0; len <= n; len <<= 1, row++) {\n			int halfLen = len >> 1;\n			double[] multReArr = powRe[row];\n			double[] multImArr = powIm[row];\n			for (int i = 0; i < n; i += len) {\n				int toJ = i + halfLen;\n\n				for (int j1 = i, j2 = toJ, k = 0; k < halfLen; j1++, j2++, k++) {\n					double uA = a[j1];\n					double uB = b[j1];\n\n					double multRe = multReArr[k];\n					double multIm = multImArr[k] * multInv;\n\n					double vA = a[j2] * multRe - b[j2] * multIm;\n					double vB = a[j2] * multIm + b[j2] * multRe;\n					a[j1] = uA + vA;\n					b[j1] = uB + vB;\n					a[j2] = uA - vA;\n					b[j2] = uB - vB;\n				}\n			}\n		}\n		if (invert) {\n			for (int i = 0; i < n; i++) {\n				a[i] /= n;\n				b[i] /= n;\n			}\n		}\n	}\n\n	static double[][] powRe = { { 1 } };\n	static double[][] powIm = { { 0 } };\n	static int[][] rev2D = {};\n\n	static void prepareArrays(int n) {\n\n		if (rev2D.length < n + 1) {\n			rev2D = Arrays.copyOf(rev2D, n + 1);\n		}\n\n		if (rev2D[n] == null) {\n			int[] tmp = rev2D[n] = new int[1 << n];\n			for (int i = 0; i < (1 << n); i++) {\n				tmp[i] = tmp[i >> 1] >> 1;\n				if ((i & 1) == 1) {\n					tmp[i] |= 1 << (n - 1);\n				}\n			}\n		}\n\n		int oldN = powRe.length;\n\n		if (oldN >= n) {\n			return;\n		}\n\n		powRe = Arrays.copyOf(powRe, n);\n		powIm = Arrays.copyOf(powIm, n);\n\n		for (int i = oldN; i < n; i++) {\n\n			double angle = Math.PI / (1 << i);\n\n			double multRe = Math.cos(angle);\n			double multIm = Math.sin(angle);\n\n			double[] toRe = powRe[i] = new double[1 << i];\n			double[] toIm = powIm[i] = new double[1 << i];\n\n			double[] fromRe = powRe[i - 1];\n			double[] fromIm = powIm[i - 1];\n\n			for (int j = 0; j < 1 << (i - 1); j++) {\n\n				double re = fromRe[j];\n				double im = fromIm[j];\n\n				toRe[j << 1] = re;\n				toIm[j << 1] = im;\n				toRe[(j << 1) | 1] = re * multRe - im * multIm;\n				toIm[(j << 1) | 1] = re * multIm + im * multRe;\n			}\n\n			// System.err.println(Arrays.toString(toRe));\n			// System.err.println(Arrays.toString(toIm));\n		}\n	}\n\n	static final Random rng = new Random();\n\n	static int rand(int l, int r) {\n		return l + rng.nextInt(r - l + 1);\n	}\n\n	public static void main(String[] args) throws IOException {\n		new E();\n	}\n\n	BufferedReader br;\n	PrintWriter out;\n	StringTokenizer st;\n\n	String nextToken() {\n		while (st == null || !st.hasMoreTokens()) {\n			try {\n				st = new StringTokenizer(br.readLine());\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n		}\n		return st.nextToken();\n	}\n\n	String nextString() {\n		try {\n			return br.readLine();\n		} catch (IOException e) {\n			throw new RuntimeException(e);\n		}\n	}\n\n	int nextInt() {\n		return Integer.parseInt(nextToken());\n	}\n\n	long nextLong() {\n		return Long.parseLong(nextToken());\n	}\n\n	double nextDouble() {\n		return Double.parseDouble(nextToken());\n	}\n}\n","fft,math"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author aryssoncf\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        ECyclicCipher solver = new ECyclicCipher();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ECyclicCipher {\n        static final int C = 5000;\n        static double[][] pow2D = {{1, 0}};\n        static int[][] rev2D = {};\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int[] b = new int[n];\n            int[] c = new int[n];\n\n            for (int i = 0; i < n; i++) {\n                b[i] = in.readInt();\n            }\n\n            int[] initB = b.clone();\n\n            b = makeInvPows(b);\n\n            for (int i = 0; i < n; i++) {\n                c[i] = in.readInt();\n            }\n\n\n            int z, p;\n            int[] pz;\n\n            int[] fb;\n\n            for (int i = 1; ; i++) {\n                p = 2 * n * i + 1;\n                if (p < C) {\n                    continue;\n                }\n                if (!BigInteger.valueOf(p).isProbablePrime(30)) {\n                    continue;\n                }\n                z = pow(primitiveRoot(p), (p - 1) / (2 * n), p);\n                pz = new int[2 * n];\n                pz[0] = 1;\n                for (int j = 1; j < pz.length; j++) {\n                    pz[j] = (int) ((long) pz[j - 1] * z % p);\n                }\n\n                fb = chirp(b, pz, p);\n                boolean allGood = true;\n                for (int coef : fb) {\n                    allGood &= coef != 0;\n                }\n\n                if (allGood) {\n                    break;\n                }\n            }\n\n            int[] cc = new int[n];\n            int inv2 = (p + 1) / 2;\n            for (int i = 0; i < n; i++) {\n                cc[i] = (c[(i + n - 1) % n] - c[i]) % p;\n                if (cc[i] < 0) {\n                    cc[i] += p;\n                }\n                cc[i] = (int) ((long) cc[i] * inv2 % p);\n            }\n\n            int[] fc = chirp(cc, pz, p);\n\n            int[] fa = new int[n];\n            for (int i = 0; i < n; i++) {\n                fa[i] = (int) ((long) fc[i] * pow(fb[i], p - 2, p) % p);\n            }\n\n            int[] aa = chirp(fa, makeInvPows(pz), p);\n            int invN = pow(n, p - 2, p);\n            for (int i = 0; i < n; i++) {\n                aa[i] = (int) ((long) aa[i] * invN % p);\n            }\n\n            long[] d = new long[n];\n            for (int i = 1; i < n; i++) {\n                d[i] = d[i - 1] + makeInt(aa[i], p);\n            }\n\n//		System.err.println(Arrays.toString(realAa));\n\n            long B = 0;\n            long C = -c[0];\n            for (int i = 0; i < n; i++) {\n                long diff = initB[i] - d[i];\n                B -= diff;\n                C += diff * diff;\n            }\n\n//		System.err.println(A + "" "" + B + "" "" + C);\n\n            List<Long> x0s = new ArrayList<>();\n\n            long D = B * B - (long) n * C;\n            if (D >= 0) {\n                if (D == 0) {\n                    if ((-B % (long) n) == 0) {\n                        x0s.add((-B) / (long) n);\n                    }\n                } else {\n                    long rd = (long) Math.sqrt(D);\n                    if (rd * rd == D) {\n                        if ((-B - rd) % (long) n == 0) {\n                            x0s.add((-B - rd) / (long) n);\n                        }\n                        if ((-B + rd) % (long) n == 0) {\n                            x0s.add((-B + rd) / (long) n);\n                        }\n                    }\n                }\n            }\n\n            out.printLine(x0s.size());\n            for (long x0 : x0s) {\n                for (int i = 0; i < n; i++) {\n                    out.print(d[i] + x0 + "" "");\n                }\n                out.printLine();\n            }\n        }\n\n        int pow(int a, int b, int p) {\n            int ret = 1;\n            for (; b > 0; b >>= 1) {\n                if ((b & 1) == 1) {\n                    ret = (int) ((long) ret * a % p);\n                }\n                a = (int) ((long) a * a % p);\n            }\n            return ret;\n        }\n\n        int primitiveRoot(int p) {\n            loop:\n            for (int i = 2; ; i++) {\n                for (int j = 2; j * j <= p - 1; j++) {\n                    if ((p - 1) % j != 0) {\n                        continue;\n                    }\n                    if (pow(i, (p - 1) / j, p) == 1) {\n                        continue loop;\n                    }\n                    if (pow(i, j, p) == 1) {\n                        continue loop;\n                    }\n                }\n                return i;\n            }\n        }\n\n        int[] chirp(int[] a, int[] pz, int p) {\n            int n = a.length;\n            // pz[1] has order 2 * n modulo prime p\n\n            a = a.clone();\n            for (int i = 0; i < n; i++) {\n                a[i] %= p;\n            }\n\n            int[] one = new int[n];\n            for (int i = 0; i < n; i++) {\n                one[i] = (int) ((long) a[i] * pz[(int) ((long) i * i % (2 * n))] % p);\n            }\n\n            int[] two = new int[2 * n - 1];\n            for (int i = 0; i <= 2 * n - 2; i++) {\n                two[i] = pz[(int) Math.floorMod(-(long) (n - 1 - i) * (n - 1 - i), 2L * n)];\n            }\n\n            int[] prod = mult(one, two, p);\n\n            prod = Arrays.copyOfRange(prod, n - 1, 2 * n - 1);\n            for (int i = 0; i < n; i++) {\n                prod[i] = (int) ((long) prod[i] * pz[(int) ((long) i * i % (2 * n))] % p);\n            }\n\n            return prod;\n            // returns polynomial a modulo p at points 1, rootZ^2, rootZ^4, ...\n        }\n\n        int makeInt(int x, int p) {\n            return x < p / 2 ? x : x - p;\n        }\n\n        int[] makeInvPows(int[] a) {\n            int[] b = new int[a.length];\n            b[0] = a[0];\n            for (int i = 1, j = a.length - 1; i < a.length; i++, j--) {\n                b[i] = a[j];\n            }\n            return b;\n        }\n\n        static int nextPowerOf2(int x) {\n            return x == 1 ? 1 : Integer.highestOneBit(x - 1) << 1;\n        }\n\n        static double[][] foo(int[] intV, int len, int L) {\n            // pack into one complex vector\n            double[] f = new double[len << 1];\n            for (int i = 0; i < intV.length; i++) {\n                f[i << 1] = intV[i] % L;\n                f[i << 1 | 1] = intV[i] / L;\n            }\n\n            fft(f, false);\n\n            // unpack\n            double[] f1 = new double[len << 1];\n            double[] f2 = new double[len << 1];\n\n            // LEN MUST BE A POWER OF 2!!!\n            int zzz = (len << 1) - 1;\n            for (int i = 0; i < len << 1; i += 2) {\n                int j = (-i) & zzz;\n                f1[i] = .5 * (f[i] + f[j]);\n                f1[i + 1] = .5 * (f[i + 1] - f[j + 1]);\n                f2[i] = .5 * (f[i + 1] + f[j + 1]);\n                f2[i + 1] = .5 * (f[j] - f[i]);\n            }\n\n            return new double[][]{f1, f2};\n        }\n\n        public static int[] mult(int[] a, int[] b, int pMod) {\n\n            int k = (int) (Math.sqrt(pMod) + 1);\n            int k2 = k * k % pMod;\n\n            int len = nextPowerOf2(a.length + b.length - 1);\n            int len2 = len << 1;\n\n            double[][] fA = foo(a, len, k);\n            double[][] fB = foo(b, len, k);\n\n            double[][] invF = new double[2][len2];\n\n            for (int ia = 0; ia < 2; ia++) {\n                for (int ib = 0; ib < 2; ib++) {\n\n                    double[] r = invF[(ia + ib) >> 1];\n                    double[] p = fA[ia];\n                    double[] q = fB[ib];\n\n                    if (((ia + ib) & 1) == 0) {\n                        for (int i = 0; i < len2; i += 2) {\n                            r[i] += p[i] * q[i] - p[i + 1] * q[i + 1];\n                            r[i + 1] += p[i] * q[i + 1] + p[i + 1] * q[i];\n                        }\n\n                    } else {\n                        for (int i = 0; i < len2; i += 2) {\n                            r[i] -= p[i] * q[i + 1] + p[i + 1] * q[i];\n                            r[i + 1] += p[i] * q[i] - p[i + 1] * q[i + 1];\n                        }\n                    }\n\n                }\n            }\n\n            fft(invF[0], true);\n            fft(invF[1], true);\n\n            int[] ret = new int[len];\n\n            for (int i = 0; i < len2; i += 2) {\n//			long v0 = Math.round(invF[0][i]) % P;\n//			long v1 = Math.round(invF[0][i + 1]) % P * L % P;\n//			long v2 = Math.round(invF[1][i]) % P * L2 % P;\n                long v0 = (long) (invF[0][i] + .5);\n                long v1 = ((long) (invF[0][i + 1] + .5)) % pMod * k;\n                long v2 = ((long) (invF[1][i] + .5)) % pMod * k2;\n                ret[i >> 1] = (int) ((v0 + v1 + v2) % pMod);\n            }\n\n            return ret;\n        }\n\n        public static void fft(double[] v, boolean invert) {\n            int n2 = v.length;\n            int n = n2 >> 1;\n            int logN = Integer.numberOfTrailingZeros(n);\n            prepareArrays(logN);\n            int[] rev = rev2D[logN];\n\n            for (int i = 0; i < n2; i += 2) {\n                int j = rev[i >> 1] << 1;\n                if (i < j) {\n                    double t = v[i];\n                    v[i] = v[j];\n                    v[j] = t;\n                    t = v[i + 1];\n                    v[i + 1] = v[j + 1];\n                    v[j + 1] = t;\n                }\n            }\n\n            double conj = invert ? -1 : 1;\n\n            for (int len = 2, row = 0; len <= n; len <<= 1, row++) {\n                double[] pow = pow2D[row];\n                for (int i = 0; i < n; i += len) {\n                    for (int j1 = i << 1, j2 = j1 + len, k = 0; k < len; j1 += 2, j2 += 2, k += 2) {\n                        double uA = v[j1];\n                        double uB = v[j1 + 1];\n\n                        double mRe = pow[k];\n                        double mIm = pow[k + 1] * conj;\n\n                        double vA = v[j2] * mRe - v[j2 + 1] * mIm;\n                        double vB = v[j2] * mIm + v[j2 + 1] * mRe;\n\n                        v[j1] = uA + vA;\n                        v[j1 + 1] = uB + vB;\n                        v[j2] = uA - vA;\n                        v[j2 + 1] = uB - vB;\n                    }\n                }\n            }\n            if (invert) {\n                for (int i = 0; i < n2; i++) {\n                    v[i] /= n;\n                }\n            }\n        }\n\n        static void prepareArrays(int n) {\n            if (rev2D.length < n + 1) {\n                rev2D = Arrays.copyOf(rev2D, n + 1);\n            }\n\n            if (rev2D[n] == null) {\n                int[] tmp = rev2D[n] = new int[1 << n];\n                for (int i = 0; i < (1 << n); i++) {\n                    tmp[i] = (tmp[i >> 1] >> 1) | ((i & 1) << (n - 1));\n                }\n            }\n\n            int oldN = pow2D.length;\n\n            if (oldN >= n) {\n                return;\n            }\n\n            pow2D = Arrays.copyOf(pow2D, n);\n\n            for (int i = oldN; i < n; i++) {\n                double angle = Math.PI / (1 << i);\n\n                double mRe = Math.cos(angle);\n                double mIm = Math.sin(angle);\n\n                double[] dst = pow2D[i] = new double[2 << i];\n                double[] src = pow2D[i - 1];\n\n                for (int j = 0; j < 1 << i; j += 2) {\n                    double re = src[j];\n                    double im = src[j + 1];\n\n                    dst[j << 1] = re;\n                    dst[j << 1 | 1] = im;\n                    dst[j << 1 | 2] = re * mRe - im * mIm;\n                    dst[j << 1 | 3] = re * mIm + im * mRe;\n                }\n            }\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine() {\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n","fft,math"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF894D {\n	static void merge(int[] aa, int n, int[] bb, int m, int[] cc) {\n		int i = 0, j = 0, k = 1;\n		while (i < n && j < m)\n			if (aa[i] <= bb[j])\n				cc[k++] = aa[i++];\n			else\n				cc[k++] = bb[j++];\n		while (i < n)\n			cc[k++] = aa[i++];\n		while (j < m)\n			cc[k++] = bb[j++];\n	}\n	static int[] kk;\n	static int[][] dd;\n	static long[][] ss;\n	static long solve(int i, int d) {\n		int lower = -1, upper = kk[i];\n		while (upper - lower > 1) {\n			int h = (lower + upper) / 2;\n			if (dd[i][h] <= d)\n				lower = h;\n			else\n				upper = h;\n		}\n		return lower == -1 ? 0 : (long) (lower + 1) * d - ss[i][lower];\n	}\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter pw = new PrintWriter(System.out);\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int n = Integer.parseInt(st.nextToken());\n		int m = Integer.parseInt(st.nextToken());\n		int[] aa = new int[n];\n		for (int i = 1; i < n; i++)\n			aa[i] = Integer.parseInt(br.readLine()) + aa[(i - 1) / 2];\n		kk = new int[n];\n		dd = new int[n][];\n		ss = new long[n][];\n		Arrays.fill(kk, 1);\n		for (int i = n - 1; i >= 0; i--) {\n			int k = kk[i];\n			if (i > 0)\n				kk[(i - 1) / 2] += k;\n			dd[i] = new int[k];\n			dd[i][0] = aa[i];\n			int l = i * 2 + 1, r = i * 2 + 2;\n			int[] dl = l < n ? dd[l] : null;\n			int[] dr = r < n ? dd[r] : null;\n			int kl = l < n ? kk[l] : 0;\n			int kr = r < n ? kk[r] : 0;\n			merge(dl, kl, dr, kr, dd[i]);\n			ss[i] = new long[k];\n			long s = 0;\n			for (int h = 0; h < k; h++)\n				ss[i][h] = s += dd[i][h];\n		}\n		while (m-- > 0) {\n			st = new StringTokenizer(br.readLine());\n			int j = Integer.parseInt(st.nextToken()) - 1;\n			int x = Integer.parseInt(st.nextToken());\n			long ans = solve(j, x + aa[j]);\n			for (int i = j, p; i > 0; i = p) {\n				p = (i - 1) / 2;\n				int d = aa[j] - aa[p];\n				if (d >= x)\n					break;\n				ans += x - d;\n				int i_ = p * 4 + 3 - i;\n				if (i_ < n)\n					ans += solve(i_, x + aa[p] * 2 - aa[j]);\n			}\n			pw.println(ans);\n		}\n		pw.close();\n	}\n}\n","brute force,data structures,trees"
"import java.io.*;\nimport java.util.*;\npublic class D {\n	public static void main(String[] args)throws Throwable {\n		MyScanner sc=new MyScanner();\n		PrintWriter pw=new PrintWriter(System.out);\n		\n		int n=sc.nextInt();\n		int q=sc.nextInt();\n		int [] l=new int [n+1];\n		for(int i=2;i<=n;i++)\n			l[i]=sc.nextInt();\n		\n		dis=new int [n+1][];\n		cum=new long [n+1][];\n		\n		for(int i=n;i>0;i--){\n			int s=1;\n			if(2*i<=n)\n				s+=dis[2*i].length;\n			if(2*i+1<=n)\n				s+=dis[2*i+1].length;\n			dis[i]=new int [s];\n			cum[i]=new long [s];\n			int p=0;\n			dis[i][p++]=0;\n			if(2*i<=n && 2*i+1<=n){\n				int p1=0,p2=0;\n				while(p1<dis[2*i].length || p2<dis[2*i+1].length){\n					if(p1>=dis[2*i].length)\n						dis[i][p++]=(dis[2*i+1][p2++]+l[2*i+1]);\n					else\n						if(p2>=dis[2*i+1].length)\n							dis[i][p++]=(dis[2*i][p1++]+l[2*i]);\n						else\n							if(dis[2*i+1][p2]+l[2*i+1] < dis[2*i][p1]+l[2*i])\n								dis[i][p++]=(dis[2*i+1][p2++]+l[2*i+1]);\n							else\n								dis[i][p++]=(dis[2*i][p1++]+l[2*i]);\n				}\n			}else\n				if(2*i<=n){\n					for(int x : dis[2*i])\n						dis[i][p++]=(x+l[2*i]);\n				}\n			p=0;\n			long last=0;\n			for(long x : dis[i]){\n				last+=x;\n				cum[i][p++]=last;\n			}\n		}\n		\n		while(q-->0){\n			int u=sc.nextInt();\n			int h=sc.nextInt();\n			long ans=search(u, h);\n			\n			while(u>1){\n				h-=l[u];\n				if(h<0)\n					break;\n				ans+=search(u/2, h);\n				if(h-l[u]>=0)\n					ans-=search(u, h-l[u]);\n				u/=2;\n			}\n			\n			pw.println(ans);\n		}\n		\n		pw.flush();\n		pw.close();\n	}\n	static int [][] dis;\n	static long [][] cum;\n	\n	static long search(int i,int x){\n		int start=0,end=dis[i].length-1;\n		long ans=-1;\n		while(start<=end){\n			int mid=((start+end)>>1);\n			if(dis[i][mid]<=x){\n				ans=(1L*x*(mid+1))-cum[i][mid];\n				start=mid+1;\n			}else\n				end=mid-1;\n		}\n		return ans;\n	}\n	\n	static class MyScanner {\n		BufferedReader br;\n		StringTokenizer st;\n		public MyScanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n		String next() {while (st == null || !st.hasMoreElements()) {\n			try {st = new StringTokenizer(br.readLine());}\n			catch (IOException e) {e.printStackTrace();}}\n		return st.nextToken();}\n		int nextInt() {return Integer.parseInt(next());}\n		long nextLong() {return Long.parseLong(next());}\n		double nextDouble() {return Double.parseDouble(next());}\n		String nextLine(){String str = """";\n		try {str = br.readLine();}\n		catch (IOException e) {e.printStackTrace();}\n		return str;}\n	}\n}","brute force,data structures,trees"
"import java.io.*;\nimport java.util.*;\npublic class a {\n	public static void main(String[] arg) throws IOException {\n		new a();\n	}\n	long[] ans;\n	public a() throws IOException {\n		JoltyScanner in = new JoltyScanner(System.in);\n		PrintWriter out = new PrintWriter(System.out);\n		n = in.nextInt();\n		m = in.nextInt();\n		edges = new int[n];\n		for(int i = 1; i <= n-1; i++) edges[i] = in.nextInt();\n		vs = new int[n+1][];\n		pre = new long[n+1][];\n		dfs(1);\n		ans = new long[m];\n		for(int i = 0; i < m; i++) {\n			int v = in.nextInt();\n			int h = in.nextInt();\n			solve(v, h, i, v);\n			out.println(ans[i]);\n		}\n		out.close();\n	}\n	void solve(int v, int h, int qid, int prev) {\n		if(h < 0) return;\n		ans[qid] += h;\n		if(v/2 > 0) solve(v/2, h-edges[v-1], qid, v);\n		if(v*2 <= n && v*2 != prev) {\n			ans[qid] += bs(vs[2*v], pre[2*v], h-edges[2*v-1]);\n		}\n		if(v*2+1 <= n && v*2+1 != prev) {\n			ans[qid] += bs(vs[2*v+1], pre[2*v+1], h-edges[2*v]);\n		}\n	}\n	int n, m;\n	int[][] vs;\n	long[][] pre;\n	int[] edges;\n	int[] dfs(int v) {\n		if(v > n) return new int[0];\n		int[] a = dfs(2*v);\n		int[] b = dfs(2*v+1);\n		int al = 0;\n		int bl = 0;\n		if(2*v <= n) {\n			al = edges[2*v-1];\n		}\n		if(2*v+1 <= n) {\n			bl = edges[2*v];\n		}\n		vs[v] = new int[a.length+b.length+1];\n		pre[v] = new long[vs[v].length];\n		int idx = 1;\n		int lp = 0;\n		int rp = 0;\n		while(idx < vs[v].length) {\n			if(lp == a.length) {\n				vs[v][idx++] = b[rp++]+bl;\n			}\n			else if(rp == b.length) {\n				vs[v][idx++] = a[lp++]+al;\n			}\n			else {\n				if(a[lp]+al <= b[rp]+bl) {\n					vs[v][idx++] = a[lp++]+al;\n				} else {\n					vs[v][idx++] = b[rp++]+bl;\n				}\n			}\n		}\n		pre[v][0] = vs[v][0];\n		for(int i = 1; i < vs[v].length; i++) {\n			pre[v][i] += pre[v][i-1]+vs[v][i];\n		}\n		return vs[v];\n	}\n	long bs(int[] v, long[] pre, int target) {\n		\n		int lo = 0;\n		int hi = v.length-1;\n		while(lo <= hi) {\n			int mid = lo+(hi-lo)/2;\n			if(v[mid] <= target) lo = mid+1;\n			else hi = mid-1;\n		}\n		if(hi == -1) return 0;\n		return (hi+1)*(long)target-pre[hi];\n	}\n	//@\n	class JoltyScanner \n	{\n		public static final int BUFFER_SIZE = 1 << 16;\n		public static final char NULL_CHAR = (char) -1;\n		byte[] buffer = new byte[BUFFER_SIZE];\n		int bufferIdx = 0, size = 0;\n		char c = NULL_CHAR;\n		BufferedInputStream in;\n		public JoltyScanner(InputStream in) \n		{\n			this.in = new BufferedInputStream(in, BUFFER_SIZE);\n			c = nextChar();\n		}\n		public int nextInt() \n		{\n			while(c < '0' || c > '9')\n				c = nextChar();\n			int res = 0;\n			while(c >= '0' && c <= '9') {\n				res = (res << 3) + (res << 1) + c - '0';\n				c = nextChar();\n			}\n			return res;\n		}\n		public char nextChar() \n		{\n			while (bufferIdx == size) \n			{\n				try \n				{\n					size = in.read(buffer);\n				} catch (Exception e) \n				{\n					return NULL_CHAR;\n				}\n				bufferIdx = 0;\n			}\n			return (char) buffer[bufferIdx++];\n		}\n	}\n}","brute force,data structures,trees"
"\nimport java.io.*;\nimport java.util.*;\n\npublic class D894 {\n	\n\n	int n;\n	long[] L;\n	\n	long[] d;\n	long[][] sortedDistance;\n	long[][] sortedSum;\n	\n	private void solve() throws Exception {\n		n = nextInt();\n		int m = nextInt();\n		L = new long[n];\n		for(int i = 1; i < n; i++)	L[i] = nextLong();\n		d = new long[n+1];\n		sortedDistance = new long[n+1][];\n		sortedSum = new long[n+1][];\n		build(1,0);		\n		for(int i = 0; i < m; i++){\n			int A = nextInt();\n			long H = nextInt();\n			out.println(doit(A,true,A,H));\n		}\n	}\n	\n	long doit(int i, boolean left, int A, long H){\n		if(i == 0) return 0;\n		long sum = 0;\n		if(i == A) sum = res(A, H+2*d[i]-d[A], H, A, i);\n		else {\n			if(left) sum = res(2*i+1, H+2*d[i]-d[A], H, A, i); \n			else sum = res(2*i, H+2*d[i]-d[A], H, A, i);\n			if((H+d[i]-d[A]) > 0) sum += H+d[i]-d[A];\n		}\n		\n		return sum+doit(i/2, i%2==0, A, H);\n	}\n	\n	long res(int tree, long val, long H, int A, int i){\n		if(tree > n) return 0L;\n		long[] sorted = sortedDistance[tree];\n		int left = -1;\n		int right = sorted.length;\n		while(left < right-1){\n			int mid = (left+right)/2;\n			if(sorted[mid] < val) left = mid;\n			else right = mid;\n		}\n		return left < 0?0L:(left+1L)*(H+2*d[i]-d[A])-sortedSum[tree][left];\n	}\n	\n	void build(int i, long dist){\n		if(i > n) return;		\n		d[i] = dist+L[i-1];		\n		build(2*i, d[i]);\n		build(2*i+1, d[i]);\n		sortedDistance[i] = merge(d[i], 2*i, 2*i+1);\n		int len = sortedDistance[i].length;\n		sortedSum[i] = new long[len];\n		sortedSum[i][0] = sortedDistance[i][0]; \n		for(int j = 1; j < len; j++) sortedSum[i][j] = sortedSum[i][j-1]+sortedDistance[i][j];\n	}\n	\n	long[] merge(long d, int left, int right){\n		long[] A = null;\n		long[] B = null;\n		if(left <= n) A = sortedDistance[left];\n		if(right <= n) B = sortedDistance[right];\n		if(A == null && B == null) return new long[] {d};\n		else if(B == null) {\n			long[] C = new long[A.length+1];\n			C[0] = d;\n			for(int i = 0; i < A.length; i++) C[i+1] = A[i];\n			return C;\n		}\n		int a = A.length;\n		int b = B.length;\n		long[] C = new long[a+b+1];\n		C[0] = d;\n		for(int i = 0,j = 0; i+j < a+b; ){\n			if(j == b || (i < a && A[i] <= B[j])) C[i+j+1] = A[i++];\n			else C[i+j+1] = B[j++];\n		}\n		return C;\n	}\n\n	public static void main(String[] args) {\n		new D894().run();\n	}\n\n	private BufferedReader in;\n	private PrintWriter out;\n	private StringTokenizer tokenizer;\n\n	public void run() {\n		try {\n			in = new BufferedReader(new InputStreamReader(System.in));\n			tokenizer = null;\n			out = new PrintWriter(System.out);\n			solve();\n			in.close();\n			out.close();\n		} catch (Exception e) {\n			e.printStackTrace();\n			System.exit(1);\n		}\n	}\n\n	private int nextInt() throws IOException {\n		return Integer.parseInt(nextToken());\n	}\n\n	private long nextLong() throws IOException {\n		return Long.parseLong(nextToken());\n	}\n\n	private float nextFloat() throws IOException {\n		return Float.parseFloat(nextToken());\n	}\n\n	private String nextLine() throws IOException {\n		return new String(in.readLine());\n	}\n\n	private String nextToken() throws IOException {\n		while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n			tokenizer = new StringTokenizer(in.readLine());\n		}\n		return tokenizer.nextToken();\n	}\n\n\n}\n\n","brute force,data structures,trees"
"import java.io.*;\nimport java.util.*;\npublic class Buggybot\n{\n	public static void main(String args[])\n	{\n		Scanner in = new Scanner(System.in);\n		int u=0,d=0,l=0,r=0;\n		int n = in.nextInt();\n		String s = in.next();\n		for(int i=0;i<n;i++)\n		{\n			if(s.charAt(i)=='U')\n				u++;\n			else if(s.charAt(i)=='L')\n				l++;\n				else if(s.charAt(i)=='D')\n					d++;\n				else\n					r++;\n		}\n		System.out.println(n-(int)(Math.abs(u-d)+Math.abs(l-r)));\n\n	}\n}",greedy
"\nimport java.util.Scanner;\n\npublic class Codeforces888B {\n	\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		 \n		int n = sc.nextInt();\n		char[] a = sc.next().toCharArray();\n		int l = 0, u = 0, d = 0, r = 0;\n		for (char ch : a) {\n			if (ch == 'L') l++;\n			else if (ch == 'R') r++;\n			else if (ch == 'U') u++;\n			else d++;\n		}            \n		System.out.println(2 * Math.min(l, r) + 2 * Math.min(u, d));\n	\n		sc.close();\n	}\n\n}",greedy
"import java.util.*;\nimport java.lang.Math;\npublic class Main\n{\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		String s =sc.next();\n	    int u=0;\n	    int l=0;\n	    int r=0;\n	    int d=0;\n	    for(int i=0;i<s.length();i++){\n	        if(s.charAt(i)=='U') u++;\n	        if(s.charAt(i)=='L') l++;\n	        if(s.charAt(i)=='D') d++;\n	        if(s.charAt(i)=='R') r++;\n	    }\n	    \n	    System.out.println(2*Math.min(l,r) + 2*Math.min(u,d));\n	}\n}\n",greedy
import java.util.Scanner;\n\npublic class _0770BuggyRobot {\n	\n	public static void main(String[] args) {\n		\n		Scanner sc = new Scanner(System.in);\n		int n=sc.nextInt();\n		sc.nextLine();\n		String s=sc.nextLine();\n		int x=0;\n		int y=0;\n		for(int i=0;i<n;i++) {\n			if(s.charAt(i)=='U') {\n				x++;\n			}\n			else if(s.charAt(i)=='D') {\n				x--;\n			}\n			else if(s.charAt(i)=='L') {\n				y--;\n			}\n			else {\n				y++;\n			}\n		}\n		System.out.println(n-(Math.abs(x)+Math.abs(y)));\n		\n	}\n\n}\n,greedy
"import java.util.*;\npublic class Main\n{\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		String s=sc.next();\n		String str=f(s);\n		System.out.println(str);\n	}\n	static String f(String s){\n	    int c=0;\n		for(int i=s.length()-1;i>=0;i--){\n		    if(s.charAt(i)=='0')\n		    c++;\n		else if(c>=6)\n		return ""yes"";\n		}\n		return ""no"";\n	}\n}\n",implementation
"import java.util.*;\npublic class MAIN1 {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		String s=sc.nextLine();\n		int c0=0;\n		int flag=0;\n		for(int i=0;i<s.length();i++) {\n			if(s.charAt(i)=='1') {\n				flag=1;\n			}\n			if(s.charAt(i)=='0'&&flag==1) {\n				c0++;\n			}\n		}\n		if(c0<6) {\n			System.out.println(""no"");\n		}\n		else {\n			System.out.println(""yes"");\n		}\n	}\n}",implementation
"import java.util.*;\npublic class MAIN1 {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		String s=sc.nextLine();\n		int c0=0;\n		int flag=0;\n		for(int i=0;i<s.length();i++) {\n			if(s.charAt(i)=='1') {\n				flag=1;\n			}\n			if(s.charAt(i)=='0'&&flag==1) {\n				c0++;\n			}\n		}\n		if(c0<6) {\n			System.out.println(""no"");\n		}\n		else {\n			System.out.println(""yes"");\n		}\n	}\n}\n",implementation
"import java.util.*;\npublic class MAIN1 {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		String s=sc.nextLine();\n		int c0=0;\n		int flag=0;\n		for(int i=0;i<s.length();i++) {\n			if(s.charAt(i)=='1') {\n				flag=1;\n			}\n			if(s.charAt(i)=='0'&&flag==1) {\n				c0++;\n			}\n		}\n		if(c0<6) {\n			System.out.println(""no"");\n		}\n		else {\n			System.out.println(""yes"");\n		}\n	}\n}\n",implementation
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF884E extends PrintWriter {\n	CF884E() { super(System.out, true); }\n	static class Scanner {\n		Scanner(InputStream in) { this.in = in; } InputStream in;\n		int k, l; byte[] bb = new byte[1 << 7];\n		byte getc() {\n			if (k >= l) {\n				k = 0;\n				try { l = in.read(bb); } catch (IOException e) { l = 0; }\n				if (l <= 0) return -1;\n			}\n			return bb[k++];\n		}\n		int nextInt() {\n			byte c = 0; while (c <= 32) c = getc();\n			boolean minus = c == '-'; if (minus) c = getc();\n			int a = 0;\n			while (c > 32) { a = a * 10 + c - '0'; c = getc(); }\n			return minus ? -a : a;\n		}\n		int m = 1 << 7; byte[] cc = new byte[m];\n		int read() {\n			byte c = 0; while (c <= 32) c = getc();\n			int n = 0;\n			while (c > 32) {\n				if (n == m) cc = Arrays.copyOf(cc, m <<= 1);\n				cc[n++] = c; c = getc();\n			}\n			return n;\n		}\n		String next() { int n = read(); return new String(cc, 0, n); }\n	}\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF884E o = new CF884E(); o.main(); o.flush();\n	}\n\n	int[] dsu;\n	int find(int i) {\n		return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));\n	}\n	int join(int i, int j) {\n		i = find(i);\n		j = find(j);\n		if (i == j)\n			return 0;\n		if (dsu[i] > dsu[j])\n			dsu[i] = j;\n		else {\n			if (dsu[i] == dsu[j])\n				dsu[i]--;\n			dsu[j] = i;\n		}\n		return 1;\n	}\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		dsu = new int[m * 2]; Arrays.fill(dsu, -1);\n		int[] aa = new int[m];\n		int[] bb = new int[m];\n		char[] cc = new char[m / 4];\n		int[] jj = new int[m * 2];\n		int ans = 0;\n		for (int i = 0; i < n; i++) {\n			sc.next().getChars(0, m / 4, cc, 0);\n			for (int j = 0; j < m / 4; j++) {\n				char c = cc[j];\n				int b = '0' <= c && c <= '9' ? c - '0' : c - 'A' + 10;\n				for (int h = 0; h < 4; h++)\n					bb[j * 4 + h] = b >> 3 - h & 1;\n			}\n			for (int j = 0; j < m; j++)\n				if (bb[j] == 1) {\n					ans++;\n					if (aa[j] == 1)\n						ans -= join(j, m + j);\n					if (j > 0 && bb[j - 1] == 1)\n						ans -= join(m + j - 1, m + j);\n				}\n			for (int j = 0; j < m; j++) {\n				aa[j] = bb[j];\n				bb[j] = bb[j] == 0 ? -1 : find(m + j);\n			}\n			Arrays.fill(dsu, -1);\n			Arrays.fill(jj, -1);\n			for (int j = 0; j < m; j++) {\n				int b = bb[j];\n				if (b != -1) {\n					if (jj[b] != -1)\n						join(jj[b], j);\n					jj[b] = j;\n				}\n			}\n		}\n		println(ans);\n	}\n}\n",dsu
"import java.util.*;\nimport java.io.*;\n\npublic class E {\n    public static void main(String[] args) {\n        FastScanner in = new FastScanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        try {\n\n            int n = in.nextInt(), m = in.nextInt();\n            int numComponents = 0;\n\n            int[] parent = new int[m * 2];\n            Arrays.fill(parent, -1);\n\n            for (int r = 0; r < n; r++) {\n                String line = in.next();\n                for (int c = 0; c < m; c += 4) {\n                    char read = line.charAt(c / 4);\n                    int val = read >= 'A' ? read - 'A' + 10 : read - '0';\n                    for (int i = 0; i < 4; i++) {\n                        if ((val & (1 << (3 - i))) == 0) continue;\n                        parent[m + c + i] = m + c + i;\n                        numComponents++;\n\n                        if (c + i > 0 && union(parent, m + c + i, m + c + i - 1)) numComponents--;\n                        if (union(parent, m + c + i, c + i)) numComponents--;\n                    }\n                }\n                slide(parent, m);\n            }\n            out.printf(""%d\n"", numComponents);\n            out.close();\n\n        } catch (Exception exc) {\n            throw new RuntimeException(exc);\n        }\n    }\n\n    private static int find(int[] parent, int i) {\n        return parent[i] == i? i : (parent[i] = find(parent, parent[i]));\n    }\n\n    private static boolean union(int[] parent, int index1, int index2) {\n        if (parent[index1] == -1 || parent[index2] == -1) return false;\n        int par1 = find(parent, index1), par2 = find(parent, index2);\n        if (par1 == par2) return false;\n        if (par1 > par2) parent[par2] = par1;\n        else parent[par1] = par2;\n        return true;\n    }\n\n    private static void slide(int[] parent, int m) {\n        for (int i = 0; i < m; i++) {\n            parent[i] = parent[m + i];\n            if (parent[i] >= m) parent[i] -= m;\n        }\n        for (int i = m; i < 2 * m; i++) parent[i] = -1;\n    }\n\n    //@\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream i) {\n            br = new BufferedReader(new InputStreamReader(i));\n            st = new StringTokenizer("""");\n        }\n\n        public String next() throws IOException {\n            if (st.hasMoreTokens())\n                return st.nextToken();\n            else\n                st = new StringTokenizer(br.readLine());\n            return next();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        //#\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n        //$\n    }\n}\n",dsu
"import java.io.*;\nimport java.util.*;\n\npublic class Program\n{\n    static byte[] buffer = new byte[524288];\n    static int end = 0;\n    static int ptr = 0;\n\n    static int[] parent;\n\n    static int Find(int t)\n    {\n        return parent[t] == t ? t : (parent[t] = Find(parent[t]));\n    }\n\n    static boolean Union(int a, int b)\n    {\n        if (parent[a] == -1 || parent[b] == -1) return false;\n\n        a = Find(a); b = Find(b);\n        if (a == b) return false;\n\n        if (a > b) parent[b] = a;\n        else parent[a] = b;\n        return true;\n    }\n\n    static void Slide()\n    {\n        for (int i = 0; i < parent.length / 2; i++)\n        {\n            parent[i] = parent[parent.length / 2 + i];\n            if (parent[i] >= parent.length / 2) parent[i] -= parent.length / 2;\n        }\n\n        for (int i = parent.length / 2; i < parent.length; i++)\n        {\n            parent[i] = -1;\n        }\n    }\n\n    static byte GetChar()\n    {\n        while (ptr == end)\n        {\n            try {\n                end = System.in.read(buffer);\n            } catch (Exception e) {\n                return ' ';\n            }\n            ptr = 0;\n        }\n        return buffer[ptr++];\n    }\n\n    static int ReadInt()\n    {\n        int ret = 0;\n        byte ch;\n        while ((ch = GetChar()) < '-')\n            ;\n        boolean neg = (ch == '-'); if (neg) ch = GetChar();\n        do ret = ret * 10 + ch - '0'; while ((ch = GetChar()) >= '0');\n        return neg ? -ret : ret;\n    }\n\n    public static void main(String[] args)\n    {\n        int n = ReadInt(), m = ReadInt();\n\n        parent = new int[m * 2];\n        for (int i = 0; i < m * 2; i++) parent[i] = -1;\n\n        int ans = 0;\n\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < m; j += 4)\n            {\n                byte ch;\n                do ch = GetChar(); while (ch < '0');\n                int num = (ch >= 'A') ? ch - 'A' + 10 : ch - '0';\n                for (int k = 0; k < 4; k++)\n                {\n                    if ((num & (1 << (3 - k))) == 0) continue;\n\n                    parent[m + j + k] = m + j + k;\n                    ++ans;\n                    if (j + k > 0 && Union(m + j + k, m + j + k - 1)) --ans;\n                    if (Union(m + j + k, j + k)) --ans;\n                }\n            }\n\n            Slide();\n        }\n        \n        System.out.println(ans);\n    }\n}",dsu
"import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\n/**\n * Created by nadya on 6/11/17.\n */\npublic class Educational {\n    public static void main(String[] args) throws IOException {\n        Educational c = new Educational();\n        c.start();\n    }\n\n\n    private void start() throws IOException {\n        //BufferedReader in = new BufferedReader(new FileReader(""input.txt""));\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer str = new StringTokenizer(in.readLine());\n        int n = Integer.parseInt(str.nextToken());\n        int m = Integer.parseInt(str.nextToken());\n        boolean matrix[][] = new boolean[2][m];\n        int isTheSecondRow = 0;\n        WUF w = new WUF(2 * m);\n        int SUM = 0;\n        for(int i = 0 ; i < n; ++i) {\n            char[] s = in.readLine().toCharArray();\n            for(int j = 0; j < s.length; ++j) {\n                int[] tmp = getTmp(s[j]);\n                for(int k = 0; k < 4; ++k) {\n                    matrix[isTheSecondRow][4*j + k] = tmp[k] == 1;\n                    if(tmp[k] == 1) SUM++;\n                }\n            }\n\n            processOneLine(w, matrix[isTheSecondRow], i == 0? 0 : 1);\n            isTheSecondRow = 1 - isTheSecondRow;\n\n            if(i == 0) continue;\n            processTwoLines(w, matrix);\n\n            if(i < n - 1) {\n                w.shift();\n            }\n        }\n\n        System.out.println(SUM - w.merge);\n    }\n\n    private int[] getTmp(char s) {\n        switch (s){\n            case '0': return new int[]{0,0,0,0};\n            case '1': return new int[]{0,0,0,1};\n            case '2': return new int[]{0,0,1,0};\n            case '3': return new int[]{0,0,1,1};\n            case '4': return new int[]{0,1,0,0};\n            case '5': return new int[]{0,1,0,1};\n            case '6': return new int[]{0,1,1,0};\n            case '7': return new int[]{0,1,1,1};\n            case '8': return new int[]{1,0,0,0};\n            case '9': return new int[]{1,0,0,1};\n            case 'A': return new int[]{1,0,1,0};\n            case 'B': return new int[]{1,0,1,1};\n            case 'C': return new int[]{1,1,0,0};\n            case 'D': return new int[]{1,1,0,1};\n            case 'E': return new int[]{1,1,1,0};\n            case 'F': return new int[]{1,1,1,1};\n        }\n        return null;\n    }\n\n    private void processOneLine(WUF w, boolean[] line, int line_number) {\n        for(int i = 1 ;i < line.length; ++i){\n            if(line[i] && line[i - 1]){\n                w.union(line_number * line.length + i,line_number * line.length + i - 1);\n            }\n        }\n    }\n\n\n    private void processTwoLines(WUF w, boolean[][] lines) {\n\n        for(int i = 0; i < lines[0].length; ++i) {\n\n            if(lines[0][i] && lines[1][i]) {\n                w.union(i, lines[0].length + i);\n            }\n        }\n    }\n\n\n    class WUF {\n        private int[] id;\n        private int count;\n        private int half;\n        private int merge;\n\n\n\n        WUF(int count) {\n            this.count = count;\n            half = count/2;\n            id = new int[count];\n            merge = 0;\n            for(int i = 0; i < count; ++i) {\n                id[i] = i;\n            }\n        }\n\n        public int find(int p) {\n\n            int root = p;\n            while (root != id[root])\n                root = id[root];\n            while (p != root) {\n                int newp = id[p];\n                id[p] = root;\n                p = newp;\n            }\n            return root;\n        }\n\n\n        public void union(int p, int q) {\n            int i = find(p);\n            int j = find(q);\n            if(i == j) return;\n            merge++;\n\n            if(i > j) {\n              id[j] = i;\n            } else {\n                id[i] = j;\n            }\n        }\n\n\n        public void shift() {\n            for(int i = 0; i < half; ++i) {\n                id[i] = id[half + i] - half;\n            }\n            for(int i = half; i < count; i++) {\n                id[i] = i;\n            }\n        }\n    }\n\n}",dsu
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF883I extends PrintWriter {\n	CF883I() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF883I o = new CF883I(); o.main(); o.flush();\n	}\n\n	int[] aa;\n	boolean[] good;\n	boolean check(int n, int k, int d) {\n		Arrays.fill(good, false); good[0] = true;\n		for (int g = 0, h = -1, i = k - 1; i < n; i++) {\n			if (good[i - k + 1])\n				g++;\n			while (h < i - k && aa[i] - aa[h + 1] > d) {\n				if (good[h + 1])\n					g--;\n				h++;\n			}\n			good[i + 1] = g > 0 && aa[i] - aa[h + 1] <= d;\n		}\n		return good[n];\n	}\n	void main() {\n		int n = sc.nextInt();\n		int k = sc.nextInt();\n		if (k == 1) {\n			println(0);\n			return;\n		}\n		aa = new int[n];\n		for (int i = 0; i < n; i++)\n			aa[i] = sc.nextInt();\n		aa = Arrays.stream(aa).boxed().sorted().mapToInt($->$).toArray();\n		good = new boolean[n + 1];\n		int lower = -1, upper = aa[n - 1] - aa[0];\n		while (upper - lower > 1) {\n			int d = (lower + upper) / 2;\n			if (check(n, k, d))\n				upper = d;\n			else\n				lower = d;\n		}\n		println(upper);\n	}\n}\n","binary search,dp"
"/*\n        ""Everything in the universe is balanced. Every disappointment\n                you face in life will be balanced by something good for you!\n                        Keep going, never give up.""\n\n*/\n\n\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Solution {\n    static int MAX = 300005;\n    static int[] contrast;\n    static boolean[] canCutAt = new boolean[MAX];\n    static int n, k;\n    public static void main(String[] args) throws java.lang.Exception {\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        sc = new FastReader();\n\n        int test = 1;\n        for (int t = 0; t < test; t++) {\n            solve();\n        }\n        out.close();\n    }\n\n    private static void solve() {\n        n = sc.nextInt();\n        k = sc.nextInt();\n        contrast = new int[n];\n        for (int i = 0; i < n; i++) {\n            contrast[i] = sc.nextInt();\n        }\n        Arrays.sort(contrast);\n        long lo = 0, hi = Long.MAX_VALUE / 3;\n        while (lo < hi) {\n            long mid = (lo + hi) / 2;\n            if (check(mid)) {\n                hi = mid;\n            }else {\n                lo = mid + 1;\n            }\n        }\n        out.println(lo);\n    }\n\n    private static boolean check(long maxProcessingTime) {\n        Arrays.fill(canCutAt, false);\n        canCutAt[n] = true;\n        int cutAt = n;\n        for (int i = n - 1; i >= 0; i--) {\n            if (i + k <= n && canCutAt[i + k]) {\n                cutAt = i + k;\n            }\n            if (contrast[cutAt - 1] - contrast[i] <= maxProcessingTime && cutAt - i >= k) {\n                canCutAt[i] = true;\n            }\n        }\n        return canCutAt[0];\n    }\n\n\n    public static FastReader sc;\n    public static PrintWriter out;\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer str;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (str == null || !str.hasMoreElements())\n            {\n                try\n                {\n                    str = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  end)\n                {\n                    end.printStackTrace();\n                }\n            }\n            return str.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = """";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException end)\n            {\n                end.printStackTrace();\n            }\n            return str;\n        }\n    }\n}","binary search,dp"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        IPhotoProcessing solver = new IPhotoProcessing();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class IPhotoProcessing {\n        int n;\n        int k;\n        int[] arr;\n\n        public void readInput(Scanner sc) {\n            n = sc.nextInt();\n            k = sc.nextInt();\n            arr = new int[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = sc.nextInt();\n        }\n\n        public void solve(int testNumber, Scanner sc, PrintWriter pw) {\n            int q = 1;\n            while (q-- > 0) {\n                readInput(sc);\n                shuffle(arr);\n                Arrays.sort(arr);\n                long low = 0, high = (int) 2e9;\n                long ans = (int) 2e9;\n                while (low <= high) {\n                    long mid = low + (high - low) / 2;\n                    if (valid(mid)) {\n                        high = mid - 1;\n                        ans = mid;\n                    } else\n                        low = mid + 1;\n                }\n                pw.println(ans);\n            }\n        }\n\n        private boolean valid(long mid) {\n            boolean[] validPartition = new boolean[n];\n            int idx = k - 1;\n            for (int i = 0; i < n; i++) {\n                idx = Math.max(i + k - 1, idx);\n                if (i == 0 || validPartition[i - 1]) {\n                    while (idx < n && arr[idx] - arr[i] <= mid) {\n                        validPartition[idx] = true;\n                        idx++;\n                    }\n                }\n            }\n            return validPartition[n - 1];\n        }\n\n        private void shuffle(int[] arr) {\n            for (int i = 0; i < arr.length; i++) {\n                int rand = (int) (Math.random() * (i + 1));\n                int temp = arr[rand];\n                arr[rand] = arr[i];\n                arr[i] = temp;\n            }\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() {\n            try {\n                while (st == null || !st.hasMoreTokens())\n                    st = new StringTokenizer(br.readLine());\n                return st.nextToken();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n","binary search,dp"
"// package codeforces;\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class cf883I\n{\n    private static int N, K;\n    private static final int MAX_N = 300000 + 16;\n    private static int[] V = new int[MAX_N];\n    private static int[] dp = new int[MAX_N];\n\n    private static boolean C(int mid)\n    {\n        int last = 0;\n        for (int i = K; i <= N; i++)\n        {\n            int j = dp[i-K];\n            if (V[i] - V[j+1] <= mid)     last = i;\n            dp[i] = last;\n        }\n        return dp[N] == N;\n    }\n\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n\n        N = in.nextInt(); K = in.nextInt();\n\n        for (int i = 1; i <= N; i++)\n        {\n            V[i] = in.nextInt();\n        }\n\n        Arrays.sort(V, 1, N+1);\n\n        int lb = 0, ub = 1000000000;\n        while (lb <= ub)\n        {\n            int mid = (lb + ub) >> 1;\n            if (C(mid))     ub = mid - 1;\n            else            lb = mid + 1;\n        }\n\n        System.out.println(lb);\n    }\n}\n","binary search,dp"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF883G extends PrintWriter {\n	CF883G() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF883G o = new CF883G(); o.main(); o.flush();\n	}\n\n	int[] eo; int[][] eh;\n	int[] tt, ii, jj;\n	char[] ss;\n	boolean[] visited;\n	void append(int i, int h) {\n		int o = eo[i]++;\n		if (o >= 2 && (o & o - 1) == 0)\n			eh[i] = Arrays.copyOf(eh[i], o << 1);\n		eh[i][o] = h;\n	}\n	void dfs1(int h_, int i) {\n		if (visited[i])\n			return;\n		visited[i] = true;\n		for (int o = eo[i]; o-- > 0; ) {\n			int h = eh[i][o];\n			if (h != h_) {\n				int j = i ^ ii[h] ^ jj[h];\n				if (tt[h] == 1)\n					dfs1(h, j);\n				else if (ss[h] == 0) {\n					ss[h] = i == ii[h] ? '+' : '-';\n					dfs1(h, j);\n				}\n			}\n		}\n	}\n	void dfs2(int h_, int i) {\n		if (visited[i])\n			return;\n		visited[i] = true;\n		for (int o = eo[i]; o-- > 0; ) {\n			int h = eh[i][o];\n			if (h != h_) {\n				int j = i ^ ii[h] ^ jj[h];\n				if (tt[h] == 1)\n					dfs2(h, j);\n				else if (ss[h] == 0)\n					ss[h] = i == ii[h] ? '-' : '+';\n			}\n		}\n	}\n	void print_(int n, int m) {\n		int k = 0;\n		for (int i = 0; i < n; i++)\n			if (visited[i])\n				k++;\n		println(k);\n		for (int h = 0; h < m; h++)\n			if (tt[h] == 2) {\n				char s = ss[h];\n				if (s == 0)\n					s = '+';\n				print(s);\n			}\n		println();\n	}\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		int s = sc.nextInt() - 1;\n		eo = new int[n]; eh = new int[n][2];\n		tt = new int[m]; ii = new int[m]; jj = new int[m];\n		for (int h = 0; h < m; h++) {\n			tt[h] = sc.nextInt();\n			ii[h] = sc.nextInt() - 1;\n			jj[h] = sc.nextInt() - 1;\n			append(ii[h], h);\n			if (tt[h] == 2)\n				append(jj[h], h);\n		}\n		ss = new char[m]; visited = new boolean[n];\n		dfs1(-1, s);\n		print_(n, m);\n		Arrays.fill(ss, (char) 0); Arrays.fill(visited, false);\n		dfs2(-1, s);\n		print_(n, m);\n	}\n}\n","dfs and similar,graphs"
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static ArrayList<Integer> adjList[];\n    static boolean[] vis;\n    static Edge[] edges;\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner();\n        PrintWriter out = new PrintWriter(System.out);\n        int n = sc.nextInt(), m = sc.nextInt(), s = sc.nextInt() - 1;\n        adjList = new ArrayList[n];\n        for (int i = 0; i < n; i++)\n            adjList[i] = new ArrayList<>();\n        edges = new Edge[m];\n        for (int i = 0; i < m; i++) {\n            int t = sc.nextInt(), u = sc.nextInt() - 1, v = sc.nextInt() - 1;\n            edges[i] = new Edge(t, u, v);\n            adjList[u].add(i);\n            if (t == 2) adjList[v].add(i);\n        }\n        vis = new boolean[n];\n        dfs1(s);\n        int cnt = 0;\n        for (boolean x : vis)\n            if (x) cnt++;\n        out.println(cnt);\n        for (Edge e : edges)\n            if (e.un) out.print(!e.ans ? '+' : '-');\n        out.println();\n        Arrays.fill(vis, false);\n        dfs2(s);\n        cnt = 0;\n        for (boolean x : vis)\n            if (x) cnt++;\n        out.println(cnt);\n        for (Edge e : edges)\n            if (e.un) out.print(!e.ans ? '+' : '-');\n        out.println();\n        out.flush();\n        out.close();\n    }\n\n    static void dfs2(int u) {\n        vis[u] = true;\n        for (int i : adjList[u]) {\n            int v = edges[i].getNode(u);\n            if (vis[v]) continue;\n            if (!edges[i].un) dfs2(v);\n            else\n                edges[i].setFromTo(v);\n        }\n    }\n\n    static void dfs1(int u) {\n        vis[u] = true;\n        for (int idx : adjList[u]) {\n            int v = edges[idx].getNode(u);\n            if (vis[v]) continue;\n            edges[idx].setFromTo(u);\n            dfs1(v);\n        }\n    }\n\n\n    static class Edge {\n        int u, v;\n        boolean un;\n        boolean ans;\n\n        public Edge(int t, int u, int v) {\n            un = t == 2;\n            this.u = u;\n            this.v = v;\n        }\n\n        int getNode(int u) {\n            return this.u == u ? v : this.u;\n        }\n\n        void setFromTo(int u) {\n            if (this.u == u) ans = false;\n            else ans = true;\n        }\n\n    }\n\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public Scanner(String s) throws FileNotFoundException {\n            br = new BufferedReader(new FileReader(s));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public int[] nextIntArray(int n) throws IOException {\n            int[] ans = new int[n];\n            for (int i = 0; i < n; i++)\n                ans[i] = nextInt();\n            return ans;\n        }\n\n        public long[] nextLongArray(int n) throws IOException {\n            long[] ans = new long[n];\n            for (int i = 0; i < n; i++)\n                ans[i] = nextLong();\n            return ans;\n        }\n\n        public Integer[] nextIntegerArray(int n) throws IOException {\n            Integer[] ans = new Integer[n];\n            for (int i = 0; i < n; i++)\n                ans[i] = nextInt();\n            return ans;\n        }\n\n        public char nextChar() throws IOException {\n            return next().charAt(0);\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n\n    }\n}","dfs and similar,graphs"
"\nimport java.io.*;\nimport java.util.*;\n\npublic class tr7 {\n	static ArrayList<int[]>[] ad;\n	static int n, m, s;\n\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter out = new PrintWriter(System.out);\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		n = Integer.parseInt(st.nextToken());\n		m = Integer.parseInt(st.nextToken());\n		s = Integer.parseInt(st.nextToken()) - 1;\n		ad = new ArrayList[n];\n		for (int i = 0; i < n; i++)\n			ad[i] = new ArrayList<>();\n		int[][] edges = new int[m][3];\n		int twos = 0;\n		for (int i = 0; i < m; i++) {\n			st = new StringTokenizer(br.readLine());\n			int t = Integer.parseInt(st.nextToken());\n			int u = Integer.parseInt(st.nextToken()) - 1;\n			int v = Integer.parseInt(st.nextToken()) - 1;\n			edges[i][0] = t;\n			edges[i][1] = u;\n			edges[i][2] = v;\n			if (t == 1) {\n				ad[u].add(new int[] { v });\n			} else {\n				ad[u].add(new int[] { v, 0, twos });\n				ad[v].add(new int[] { u, 1, twos });\n				twos++;\n			}\n		}\n		int[] dist = new int[n];\n		char[] pr = new char[twos];\n		Arrays.fill(dist, -1);\n		Queue<Integer> q = new LinkedList<Integer>();\n		q.add(s);\n		int num = 1;\n		dist[s] = 0;\n		while (!q.isEmpty()) {\n			int u = q.poll();\n			for (int[] v : ad[u]) {\n				if (dist[v[0]] != -1)\n					continue;\n				num++;\n				if (v.length == 1) {\n					dist[v[0]] = dist[u] + 1;\n					q.add(v[0]);\n				} else {\n					dist[v[0]] = dist[u] + 1;\n					q.add(v[0]);\n					if (v[1] == 1) {\n						pr[v[2]] = '-';\n					} else {\n						pr[v[2]] = '+';\n					}\n				}\n			}\n		}\n\n		for (int i = 0; i < twos; i++)\n			if (pr[i] != '+' && pr[i] != '-')\n				pr[i] = '+';\n		out.println(num);\n		out.println(new String(pr));\n\n		dist = new int[n];\n		pr = new char[twos];\n		Arrays.fill(dist, -1);\n		q = new LinkedList<Integer>();\n		q.add(s);\n		num = 1;\n		dist[s] = 0;\n		while (!q.isEmpty()) {\n			int u = q.poll();\n			for (int[] v : ad[u]) {\n				if (dist[v[0]] != -1)\n					continue;\n			\n				if (v.length == 1) {\n					num++;\n					dist[v[0]] = dist[u] + 1;\n					q.add(v[0]);\n				} else {\n					if (v[1] == 0) {\n						pr[v[2]] = '-';\n					} else {\n						pr[v[2]] = '+';\n					}\n				}\n			}\n		}\n\n		for (int i = 0; i < twos; i++)\n			if (pr[i] != '+' && pr[i] != '-')\n				pr[i] = '+';\n		out.println(num);\n		out.println(new String(pr));\n\n		out.flush();\n	}\n\n}\n","dfs and similar,graphs"
"import java.util.*;\n\npublic class G {\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n\n		int n, m, s;\n		n = scan.nextInt();\n		m = scan.nextInt();\n		s = scan.nextInt() - 1;\n		Node[] nodes = new Node[n];\n		for (int i = 0; i < n; i++) {\n			nodes[i] = new Node();\n		}\n		List<Edge> directed = new ArrayList<>();\n		for (int i = 0; i < m; i++) {\n			int t, u, v;\n			t = scan.nextInt();\n			u = scan.nextInt() - 1;\n			v = scan.nextInt() - 1;\n			\n			Edge e = Edge.addEdge(t == 2, nodes[u], nodes[v]);\n			if (t==2) directed.add(e);\n		}\n\n		int max = maximize(nodes[s]);\n		String[] maxStrings = new String[directed.size()];\n		int idx = 0;\n		for (Edge e : directed) {\n			maxStrings[idx++] = e.max ? ""+"" : ""-"";\n		}\n		System.out.println(max);\n		System.out.println(String.join("""", maxStrings));\n		idx = 0;\n		for (Node nn : nodes) nn.visited = false;\n		int min = minimize(nodes[s]);\n		String[] minStrings = new String[directed.size()];\n		for (Edge e : directed) {\n			minStrings[idx++] = e.min ? ""+"" : ""-"";\n		}\n		//int min = minimize(nodes[s]);\n		System.out.println(min);\n		System.out.println(String.join("""", minStrings));\n	}\n\n	static int maximize(Node start) {\n		Queue<Node> Q = new LinkedList<>();\n		Q.add(start);\n		start.visited = true;\n		int tot = 0;\n		while (!Q.isEmpty()) {\n			Node cur = Q.poll();\n			tot++;\n			for (Edge e : cur.adj) {\n				if (!e.to.visited) {\n					e.max = true;\n					e.to.visited = true;\n					Q.add(e.to);\n				}\n			}\n		}\n		return tot;\n	}\n\n	static int minimize(Node start) {\n		Queue<Node> Q = new LinkedList<>();\n		Q.add(start);\n		start.visited = true;\n		int tot = 0;\n		while (!Q.isEmpty()) {\n			Node cur = Q.poll();\n			tot++;\n			for (Edge e : cur.adj) {\n				if (!e.to.visited) {\n					if (e.tentative) {\n						e.min = false;\n						e.reverse.min = true;\n					} else {\n						e.to.visited = true;\n						Q.add(e.to);\n					}\n				}\n			}\n		}\n		return tot;\n	}\n\n	static class Node {\n		List<Edge> adj = new ArrayList<>();\n		boolean visited = false;\n	}\n\n	static class Edge {\n		boolean tentative;\n		Edge reverse;\n		Node to;\n		boolean max = false;\n		boolean min = true;\n\n		Edge(boolean tentative, Node to) {\n			this.tentative = tentative;\n			this.to = to;\n		}\n\n		static Edge addEdge(boolean tentative, Node from, Node to) {\n			Edge e1 = new Edge(tentative, to);\n			Edge e2 = new Edge(tentative, from);\n			if (tentative) e1.reverse = e2;\n			if (tentative) e2.reverse = e1;\n\n			from.adj.add(e1);\n			if (tentative) to.adj.add(e2);\n\n			return e1;\n		}\n	}\n}\n","dfs and similar,graphs"
\n\nimport java.util.Scanner;\n\npublic class ChoresLuba {\n\n	public static void main(String[] args)\n	{\n		Scanner reader = new Scanner(System.in);\n		int n = reader.nextInt();\n		int k = reader.nextInt();\n		int x = reader.nextInt();\n		int sum = 0;\n		for(int i = 0; i < n-k; i++)\n			sum += reader.nextInt();\n		sum += (k * x);\n		System.out.println(sum);\n	}\n\n}\n,implementation
import java.util.*;\npublic class Codeforces{\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int k=sc.nextInt();\n		int x=sc.nextInt();\n		long sum=0;\n		for(int i=0;i<n;i++) {\n			int num=sc.nextInt();\n			if(n-i-1>=k) {\n				sum+=num;\n			}\n			else {\n				sum+=x;\n			}\n		}\n		System.out.println(sum);\n	}\n},implementation
import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n	Scanner in=new Scanner(System.in);\n	int n=in.nextInt();\n		int k=in.nextInt();\n		int x=in.nextInt();\n		int s=0;\n		for(int i=0;i<n;i++){\n			int temp=in.nextInt();\n			if (i>=n-k){\n				s+=x;\n			} else {\n				s+=temp;\n			}\n\n\n\n    }\n		System.out.println(s);\n    }\n}\n,implementation
"import java.util.Scanner;\n\npublic class Chores\n{\n    public static void main(String [] args)\n    {\n        Scanner input = new Scanner(System.in);\n        int n = input.nextInt(), k = input.nextInt(), x = input.nextInt();\n\n        int sum = 0;\n        for(int i = 0; i < n - k; i++)\n            sum += input.nextInt();\n\n        sum += k * x;\n        System.out.println(sum);\n    }\n}",implementation
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            TaskE.Vertex[] v = new TaskE.Vertex[n];\n            for (int i = 0; i < n; ++i) {\n                v[i] = new TaskE.Vertex();\n            }\n            for (int i = 0; i < n - 1; ++i) {\n                TaskE.Vertex a = v[in.nextInt() - 1];\n                TaskE.Vertex b = v[in.nextInt() - 1];\n                long len = in.nextLong();\n                TaskE.Edge ab = new TaskE.Edge(a, b, len);\n                TaskE.Edge ba = new TaskE.Edge(b, a, len);\n                ab.rev = ba;\n                ba.rev = ab;\n                a.edges.add(ab);\n                b.edges.add(ba);\n            }\n            TaskE.Vertex police = v[in.nextInt() - 1];\n            int m = in.nextInt();\n            for (int i = 0; i < m; ++i) {\n                ++v[in.nextInt() - 1].startCount;\n            }\n            for (TaskE.Vertex u : v) {\n                for (TaskE.Edge e : u.edges) {\n                    e.res = new long[m + 1][m + 1];\n                    for (long[] x : e.res) Arrays.fill(x, -1);\n                }\n            }\n            police.findSubtreeSums(null);\n            long res = Long.MAX_VALUE;\n            for (TaskE.Edge e : police.edges)\n                if (e.dst.subtreeSum > 0) {\n                    res = Math.min(res, e.solve(m, e.dst.subtreeSum));\n                }\n            out.println(res);\n        }\n\n        static class Edge {\n            TaskE.Vertex src;\n            TaskE.Vertex dst;\n            TaskE.Edge rev;\n            long[][] res;\n            long len;\n\n            public Edge(TaskE.Vertex src, TaskE.Vertex dst, long len) {\n                this.src = src;\n                this.dst = dst;\n                this.len = len;\n            }\n\n            public long solve(int totalRemaining, int inSubtree) {\n                if (totalRemaining == 0) return 0;\n                if (res[totalRemaining][inSubtree] >= 0) return res[totalRemaining][inSubtree];\n                boolean any = false;\n                long[] worst = new long[totalRemaining + 1];\n                Arrays.fill(worst, -1);\n                worst[0] = Long.MAX_VALUE;\n                for (TaskE.Edge e : dst.edges) {\n                    if (e.dst != src) {\n                        any = true;\n                        for (int before = worst.length - 1; before >= 0; --before)\n                            if (worst[before] >= 0) {\n                                for (int here = 1; before + here <= totalRemaining; ++here) {\n                                    long got = e.solve(totalRemaining, here);\n                                    worst[before + here] = Math.max(worst[before + here], Math.min(worst[before], got));\n                                }\n                            }\n                    }\n                }\n                if (!any) {\n                    for (int a = 1; a <= totalRemaining; ++a) {\n                        res[totalRemaining][a] = len + rev.solve(totalRemaining - a, totalRemaining - a);\n                    }\n                } else {\n                    for (int a = 1; a <= totalRemaining; ++a) {\n                        res[totalRemaining][a] = len + worst[a];\n                    }\n                }\n                return res[totalRemaining][inSubtree];\n            }\n\n        }\n\n        static class Vertex {\n            int startCount;\n            int subtreeSum;\n            List<TaskE.Edge> edges = new ArrayList<>();\n\n            public void findSubtreeSums(TaskE.Vertex parent) {\n                subtreeSum = startCount;\n                for (TaskE.Edge e : edges)\n                    if (e.dst != parent) {\n                        e.dst.findSubtreeSums(this);\n                        subtreeSum += e.dst.subtreeSum;\n                    }\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n\n","dp,graphs,trees"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            TaskE.Vertex[] v = new TaskE.Vertex[n];\n            for (int i = 0; i < n; ++i) {\n                v[i] = new TaskE.Vertex();\n            }\n            for (int i = 0; i < n - 1; ++i) {\n                TaskE.Vertex a = v[in.nextInt() - 1];\n                TaskE.Vertex b = v[in.nextInt() - 1];\n                long len = in.nextLong();\n                TaskE.Edge ab = new TaskE.Edge(a, b, len);\n                TaskE.Edge ba = new TaskE.Edge(b, a, len);\n                ab.rev = ba;\n                ba.rev = ab;\n                a.edges.add(ab);\n                b.edges.add(ba);\n            }\n            TaskE.Vertex police = v[in.nextInt() - 1];\n            int m = in.nextInt();\n            for (int i = 0; i < m; ++i) {\n                ++v[in.nextInt() - 1].startCount;\n            }\n            for (TaskE.Vertex u : v) {\n                for (TaskE.Edge e : u.edges) {\n                    e.res = new long[m + 1][m + 1];\n                    for (long[] x : e.res) Arrays.fill(x, -1);\n                }\n            }\n            police.findSubtreeSums(null);\n            long res = Long.MAX_VALUE;\n            for (TaskE.Edge e : police.edges)\n                if (e.dst.subtreeSum > 0) {\n                    res = Math.min(res, e.solve(m, e.dst.subtreeSum));\n                }\n            out.println(res);\n        }\n\n        static class Edge {\n            TaskE.Vertex src;\n            TaskE.Vertex dst;\n            TaskE.Edge rev;\n            long[][] res;\n            long len;\n\n            public Edge(TaskE.Vertex src, TaskE.Vertex dst, long len) {\n                this.src = src;\n                this.dst = dst;\n                this.len = len;\n            }\n\n            public long solve(int totalRemaining, int inSubtree) {\n                if (totalRemaining == 0) return 0;\n                if (res[totalRemaining][inSubtree] >= 0) return res[totalRemaining][inSubtree];\n                boolean any = false;\n                long[] worst = new long[totalRemaining + 1];\n                Arrays.fill(worst, -1);\n                worst[0] = Long.MAX_VALUE;\n                for (TaskE.Edge e : dst.edges) {\n                    if (e.dst != src) {\n                        any = true;\n                        for (int before = worst.length - 1; before >= 0; --before)\n                            if (worst[before] >= 0) {\n                                for (int here = 1; before + here <= totalRemaining; ++here) {\n                                    long got = e.solve(totalRemaining, here);\n                                    worst[before + here] = Math.max(worst[before + here], Math.min(worst[before], got));\n                                }\n                            }\n                    }\n                }\n                if (!any) {\n                    for (int a = 1; a <= totalRemaining; ++a) {\n                        res[totalRemaining][a] = len + rev.solve(totalRemaining - a, totalRemaining - a);\n                    }\n                } else {\n                    for (int a = 1; a <= totalRemaining; ++a) {\n                        res[totalRemaining][a] = len + worst[a];\n                    }\n                }\n                return res[totalRemaining][inSubtree];\n            }\n\n        }\n\n        static class Vertex {\n            int startCount;\n            int subtreeSum;\n            List<TaskE.Edge> edges = new ArrayList<>();\n\n            public void findSubtreeSums(TaskE.Vertex parent) {\n                subtreeSum = startCount;\n                for (TaskE.Edge e : edges)\n                    if (e.dst != parent) {\n                        e.dst.findSubtreeSums(this);\n                        subtreeSum += e.dst.subtreeSum;\n                    }\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}","dp,graphs,trees"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public int n;\n        public int s;\n        public int m;\n        public List<Integer>[] graph;\n        public int[][] dist;\n        public boolean[] leaf;\n        public int[] cc;\n        public int MAXANS = 50 * 50 * 50;\n        public ArrayList<Integer> leaves;\n        public int count;\n        public int[][] dp;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            n = in.nextInt();\n            dist = new int[n][n];\n            for (int[] x : dist) Arrays.fill(x, 1 << 29);\n            for (int i = 0; i < n; i++) dist[i][i] = 0;\n            graph = LUtils.genArrayList(n);\n            for (int i = 0; i < n - 1; i++) {\n                int a = in.nextInt() - 1, b = in.nextInt() - 1, c = in.nextInt();\n                dist[a][b] = dist[b][a] = c;\n                graph[a].add(b);\n                graph[b].add(a);\n            }\n            leaf = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                leaf[i] = graph[i].size() == 1;\n            }\n            for (int k = 0; k < n; k++) {\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < n; j++) {\n                        dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);\n                    }\n                }\n            }\n            s = in.nextInt() - 1;\n            m = in.nextInt();\n            cc = new int[n];\n            for (int i = 0; i < m; i++) cc[in.nextInt() - 1]++;\n\n            dp = new int[n + 1][m + 1];\n            int best = Integer.MAX_VALUE;\n            for (int[] x : dp) Arrays.fill(x, -1);\n            for (int j : graph[s]) {\n                count = 0;\n                leaves = new ArrayList<>();\n                dfs(j, s);\n\n                if (count > 0) {\n                    int lo = 0, hi = MAXANS;\n                    while (lo < hi) {\n                        int mid = (lo + hi + 1) / 2;\n                        if (can2(mid, count)) lo = mid;\n                        else hi = mid - 1;\n                    }\n                    best = Math.min(best, lo);\n                }\n            }\n            out.println(best);\n        }\n\n        public boolean can2(int target, int have) {\n            int tot = 0;\n            for (int j : leaves) {\n                int add = dist[s][j];\n                if (solve(j, m - 1) + add >= target) {\n                    int canadd = 1;\n                    while (canadd < have && solve(j, m - canadd - 1) + add >= target) canadd++;\n                    tot += canadd;\n                }\n            }\n            return tot >= have;\n        }\n\n        public void dfs(int node, int par) {\n            if (leaf[node]) leaves.add(node);\n            count += cc[node];\n            for (int next : graph[node]) {\n                if (next == par) continue;\n                dfs(next, node);\n            }\n        }\n\n        public int solve(int node, int crim) {\n            if (crim == 0) return 0;\n            if (dp[node][crim] != -1) return dp[node][crim];\n            int lo = 0, hi = MAXANS;\n            while (lo < hi) {\n                int mid = (lo + hi + 1) / 2;\n                if (can(mid, node, crim)) lo = mid;\n                else hi = mid - 1;\n            }\n            return dp[node][crim] = lo;\n        }\n\n        public boolean can(int target, int node, int crim) {\n            int tot = 0;\n            for (int j = 0; j < n; j++) {\n                if (leaf[j] && j != node) {\n                    int add = dist[node][j];\n                    if (solve(j, crim - 1) + add >= target) {\n                        int canadd = 1;\n                        while (canadd < crim && solve(j, crim - canadd - 1) + add >= target) canadd++;\n                        tot += canadd;\n                    }\n                }\n            }\n            return tot >= crim;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (this.numChars == -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar >= this.numChars) {\n                    this.curChar = 0;\n\n                    try {\n                        this.numChars = this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars <= 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c = this.read(); isSpaceChar(c); c = this.read()) {\n                ;\n            }\n\n            byte sgn = 1;\n            if (c == 45) {\n                sgn = -1;\n                c = this.read();\n            }\n\n            int res = 0;\n\n            while (c >= 48 && c <= 57) {\n                res *= 10;\n                res += c - 48;\n                c = this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c == 32 || c == 10 || c == 13 || c == 9 || c == -1;\n        }\n\n    }\n\n    static class LUtils {\n        public static <E> List<E>[] genArrayList(int size) {\n            return Stream.generate(ArrayList::new).limit(size).toArray(List[]::new);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n","dp,graphs,trees"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            EPolicemanAndATree solver = new EPolicemanAndATree();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class EPolicemanAndATree {\n        Debug debug = new Debug(true);\n        int[][] fdp;\n        int inf = (int) 1e9;\n        int[][] f;\n        Node[] nodes;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            nodes = new Node[n];\n            for (int i = 0; i < n; i++) {\n                nodes[i] = new Node();\n                nodes[i].id = i;\n            }\n\n            for (int i = 0; i < n - 1; i++) {\n                Node a = nodes[in.readInt() - 1];\n                Node b = nodes[in.readInt() - 1];\n                Edge e = new Edge();\n                e.a = a;\n                e.b = b;\n                e.w = in.readInt();\n                a.next.add(e);\n                b.next.add(e);\n            }\n\n\n            Node root = nodes[in.readInt() - 1];\n\n            int m = in.readInt();\n            for (int i = 0; i < m; i++) {\n                Node node = nodes[in.readInt() - 1];\n                node.thief++;\n            }\n            m -= root.thief;\n            root.thief = 0;\n            if (m == 0) {\n                out.println(0);\n                return;\n            }\n\n\n            f = new int[n][m + 1];\n            List<Node> leaf = new ArrayList<>(n);\n            fdp = new int[n + 1][m + 1];\n\n            for (int i = 1; i <= m; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (!isLeaf(nodes[j])) {\n                        continue;\n                    }\n                    leaf.clear();\n                    dfs(nodes[j], null, 0, leaf);\n                    f[j][i] = maxStep(leaf, i, i);\n                }\n            }\n\n            debug.debug(""f"", f);\n            int ans = inf;\n            for (Edge e : root.next) {\n                Node node = e.other(root);\n                leaf.clear();\n                int thief = dfs(node, root, e.w, leaf);\n                if (thief == 0) {\n                    continue;\n                }\n                int against = maxStep(leaf, thief, m);\n                ans = Math.min(ans, against);\n            }\n\n            out.println(ans);\n        }\n\n        public int maxStep(List<Node> leaf, int m, int total) {\n            SequenceUtils.deepFill(fdp, -inf);\n            fdp[0][0] = 0;\n            int n = leaf.size();\n            for (int i = 1; i <= n; i++) {\n                Node node = leaf.get(i - 1);\n                for (int j = 0; j <= m; j++) {\n                    fdp[i][j] = fdp[i - 1][j];\n                    for (int k = 1; k <= j; k++) {\n                        if (j - k > 0) {\n                            fdp[i][j] = Math.max(fdp[i][j], Math.min(fdp[i - 1][j - k], node.depth + f[node.id][total - k]));\n                        } else {\n                            fdp[i][j] = Math.max(fdp[i][j], node.depth + f[node.id][total - k]);\n                        }\n                    }\n                }\n            }\n            return fdp[n][m];\n        }\n\n        public boolean isLeaf(Node node) {\n            return node.next.size() == 1;\n        }\n\n        public int dfs(Node root, Node p, int depth, List<Node> leaf) {\n            root.depth = depth;\n            boolean isLeaf = true;\n            int ans = root.thief;\n            for (Edge e : root.next) {\n                Node node = e.other(root);\n                if (node == p) {\n                    continue;\n                }\n                isLeaf = false;\n                ans += dfs(node, root, depth + e.w, leaf);\n            }\n\n            if (isLeaf) {\n                leaf.add(root);\n            }\n            return ans;\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n        static int[] empty = new int[0];\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public Debug debug(String name, Object x) {\n            return debug(name, x, empty);\n        }\n\n        public Debug debug(String name, Object x, int... indexes) {\n            if (offline) {\n                if (x == null || !x.getClass().isArray()) {\n                    out.append(name);\n                    for (int i : indexes) {\n                        out.printf(""[%d]"", i);\n                    }\n                    out.append(""="").append("""" + x);\n                    out.println();\n                } else {\n                    indexes = Arrays.copyOf(indexes, indexes.length + 1);\n                    if (x instanceof byte[]) {\n                        byte[] arr = (byte[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof short[]) {\n                        short[] arr = (short[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof boolean[]) {\n                        boolean[] arr = (boolean[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof char[]) {\n                        char[] arr = (char[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof int[]) {\n                        int[] arr = (int[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof float[]) {\n                        float[] arr = (float[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof double[]) {\n                        double[] arr = (double[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof long[]) {\n                        long[] arr = (long[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else {\n                        Object[] arr = (Object[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    }\n                }\n            }\n            return this;\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static void deepFill(Object array, int val) {\n            if (!array.getClass().isArray()) {\n                throw new IllegalArgumentException();\n            }\n            if (array instanceof int[]) {\n                int[] intArray = (int[]) array;\n                Arrays.fill(intArray, val);\n            } else {\n                Object[] objArray = (Object[]) array;\n                for (Object obj : objArray) {\n                    deepFill(obj, val);\n                }\n            }\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Edge {\n        Node a;\n        Node b;\n        int w;\n\n        Node other(Node x) {\n            return a == x ? b : a;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class Node {\n        List<Edge> next = new ArrayList<>();\n        int id;\n        int thief;\n        int depth;\n\n        public String toString() {\n            return """" + id;\n        }\n\n    }\n}\n\n","dp,graphs,trees"
"import java.io.*;\nimport java.util.*;\npublic class kRounding\n{\n    static long gcd(long a, long b)\n    {\n        if(a==0)\n            return b;\n        return gcd(b%a,a);\n    }\n    public static void main(String args[])\n    {\n        Scanner sc=new Scanner(System.in);\n        long n=sc.nextLong();\n        long k=sc.nextLong();\n        long z=(long)Math.pow(10,k);\n        long p=z*n;\n        long lcm=p/gcd(n,z);\n        System.out.println(lcm);\n    }\n}","brute force,math,number theory"
"import java.util.Scanner;\n\npublic class Krounding {\n\n	public static void main(String args[]) {\n		Scanner sc = new Scanner(System.in);\n		long n = sc.nextLong();\n		long k = sc.nextLong();\n		long num = (long) Math.pow(10, k);\n\n		System.out.println(lcm(n, num));\n		sc.close();\n	}\n\n	public static long gcd(long a, long b) {\n		if (a == 0) {\n			return b;\n		}\n		return gcd(b % a, a);\n	}\n\n	public static long lcm(long a, long b) {\n		return (a * b) / gcd(a, b);\n	}\n}\n","brute force,math,number theory"
"import java.util.Scanner;\n\npublic class competitive18 {\n    public static long gcd(long a, long b)\n    {\n        if (a == 0)\n            return b;\n        return gcd((b%a) ,a);\n    }\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        long n=in.nextLong();\n        int k=in.nextInt();\n        long gcd1=gcd(n, (long) Math.pow(10,k));\n        long lcm= (long) ((n*Math.pow(10,k))/gcd1);\n        System.out.println(lcm);\n    }\n\n}\n","brute force,math,number theory"
"import java.util.Scanner;\n\npublic class Main {\n	\n	public static void roundMe(long x, int tens) {\n		tens = (int) Math.pow(10, tens);\n		System.out.println((x * tens / (gcd(x, tens))));\n	}\n	\n	public static long gcd(long x, long y) {\n		if(y == 0) return x;\n		else return gcd(y, (x % y));\n	}\n\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		long x = scan.nextLong(); int t = scan.nextInt();\n		roundMe(x, t);\n		scan.close();\n	}\n}\n\n       		    	  	 		   			   		","brute force,math,number theory"
"import java.io.*;\nimport java.util.*;\n\npublic class F {\n\n	void submit() {\n		int n = nextInt();\n		int[] a = new int[n];\n		int s = 0;\n		for (int i = 0; i < n; i++) {\n			a[i] = nextInt();\n			s += a[i];\n		}\n\n		int[] b = new int[100001];\n		b[1] = (int) ((long) (s - 1) * (s - 1) % P * inv(s) % P);\n		for (int i = 2; i <= s && i < b.length; i++) {\n			long tmp = 2L * b[i - 1] - (long)(s - 1) * inv(s - (i - 1)) - b[i - 2];\n			b[i] = (int) Math.floorMod(tmp, P);\n		}\n		\n		long ans = 0;\n		for (int x : a) {\n			ans += b[x];\n		}\n		\n		out.println(ans % P);\n	}\n\n	static final int P = 1_000_000_007;\n\n	static int inv(int x) {\n		return x == 1 ? 1 : P - (int) ((long) (P / x) * inv(P % x) % P);\n	}\n\n	void preCalc() {\n\n	}\n\n	void stress() {\n\n	}\n\n	void test() {\n\n	}\n\n	F() throws IOException {\n		br = new BufferedReader(new InputStreamReader(System.in));\n		out = new PrintWriter(System.out);\n		preCalc();\n		submit();\n		// stress();\n		// test();\n		out.close();\n	}\n\n	static final Random rng = new Random();\n\n	static int rand(int l, int r) {\n		return l + rng.nextInt(r - l + 1);\n	}\n\n	public static void main(String[] args) throws IOException {\n		new F();\n	}\n\n	BufferedReader br;\n	PrintWriter out;\n	StringTokenizer st;\n\n	String nextToken() {\n		while (st == null || !st.hasMoreTokens()) {\n			try {\n				st = new StringTokenizer(br.readLine());\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n		}\n		return st.nextToken();\n	}\n\n	String nextString() {\n		try {\n			return br.readLine();\n		} catch (IOException e) {\n			throw new RuntimeException(e);\n		}\n	}\n\n	int nextInt() {\n		return Integer.parseInt(nextToken());\n	}\n\n	long nextLong() {\n		return Long.parseLong(nextToken());\n	}\n\n	double nextDouble() {\n		return Double.parseDouble(nextToken());\n	}\n}\n",math
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        final int MOD = (int) (1e9 + 7);\n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt();\n            }\n            int s = 0;\n            int max = 0;\n            for (int x : a) {\n                s += x;\n                max = Math.max(max, x);\n            }\n\n            long[] e = new long[max + 2];\n            e[0] = 0;\n            e[1] = (s - 1) * (long) (s - 1) % MOD * inv(s) % MOD;\n            for (int i = 2; i < e.length; i++) {\n                long cur = 2 * e[i - 1] % MOD;\n                cur = (cur - e[i - 2]) % MOD;\n                cur = (cur - (long) (s - 1) * inv(s - i + 1)) % MOD;\n                if (cur < 0) {\n                    cur += MOD;\n                }\n                e[i] = cur;\n            }\n\n            long ans = 0;\n            for (int x : a) {\n                ans += e[x];\n                if (ans >= MOD) {\n                    ans -= MOD;\n                }\n            }\n            out.println(ans);\n        }\n\n        private int pow(long a, long s) {\n            long r = 1;\n            while (s > 0) {\n                if (s % 2 == 1) {\n                    r = r * a % MOD;\n                }\n                a = a * a % MOD;\n                s /= 2;\n            }\n            return (int) r;\n        }\n\n        private int inv(int n) {\n            return pow(n, MOD - 2);\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n",math
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        final int MOD = (int) (1e9 + 7);\n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = in.nextInt();\n            }\n            int s = 0;\n            int max = 0;\n            for (int x : a) {\n                s += x;\n                max = Math.max(max, x);\n            }\n\n            long[] e = new long[max + 2];\n            e[0] = 0;\n            e[1] = (s - 1) * (long) (s - 1) % MOD * inv(s) % MOD;\n            for (int i = 2; i < e.length; i++) {\n                long cur = 2 * e[i - 1] % MOD;\n                cur = (cur - e[i - 2]) % MOD;\n                cur = (cur - (long) (s - 1) * inv(s - i + 1)) % MOD;\n                if (cur < 0) {\n                    cur += MOD;\n                }\n                e[i] = cur;\n            }\n\n            long ans = 0;\n            for (int x : a) {\n                ans += e[x];\n                if (ans >= MOD) {\n                    ans -= MOD;\n                }\n            }\n            out.println(ans);\n        }\n\n        private int pow(long a, long s) {\n            long r = 1;\n            while (s > 0) {\n                if (s % 2 == 1) {\n                    r = r * a % MOD;\n                }\n                a = a * a % MOD;\n                s /= 2;\n            }\n            return (int) r;\n        }\n\n        private int inv(int n) {\n            return pow(n, MOD - 2);\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}",math
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.stream.IntStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.OptionalInt;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FRainbowBalls solver = new FRainbowBalls();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FRainbowBalls {\n        Modular mod = new Modular(1e9 + 7);\n        Power pow = new Power(mod);\n        Debug debug = new Debug(true);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int[] a = new int[n];\n            in.populate(a);\n            int max = Arrays.stream(a).max().getAsInt();\n            int m = Arrays.stream(a).sum();\n            int[] f = new int[max + 1];\n            f[0] = 0;\n            for (int i = 1; i <= max; i++) {\n                f[i] = f[i - 1];\n                f[i] = mod.plus(f[i], pow.inverseByFermat(m - i + 1));\n            }\n            for (int i = 0; i <= max; i++) {\n                f[i] = mod.mul(f[i], m - 1);\n                f[i] = mod.mul(f[i], m - i);\n            }\n\n            int ans = 0;\n            for (int x : a) {\n                ans = mod.plus(ans, f[x]);\n            }\n\n            debug.debug(""f"", f);\n\n            out.println(ans);\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        public void populate(int[] data) {\n            for (int i = 0; i < data.length; i++) {\n                data[i] = readInt();\n            }\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static interface InverseNumber {\n    }\n\n    static class Modular {\n        int m;\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        public String toString() {\n            return ""mod "" + m;\n        }\n\n    }\n\n    static class Power implements InverseNumber {\n        final Modular modular;\n\n        public Power(Modular modular) {\n            this.modular = modular;\n        }\n\n        public int pow(int x, int n) {\n            if (n == 0) {\n                return modular.valueOf(1);\n            }\n            long r = pow(x, n >> 1);\n            r = modular.valueOf(r * r);\n            if ((n & 1) == 1) {\n                r = modular.valueOf(r * x);\n            }\n            return (int) r;\n        }\n\n        public int inverseByFermat(int x) {\n            return pow(x, modular.m - 2);\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n        static int[] empty = new int[0];\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public Debug debug(String name, Object x) {\n            return debug(name, x, empty);\n        }\n\n        public Debug debug(String name, Object x, int... indexes) {\n            if (offline) {\n                if (x == null || !x.getClass().isArray()) {\n                    out.append(name);\n                    for (int i : indexes) {\n                        out.printf(""[%d]"", i);\n                    }\n                    out.append(""="").append("""" + x);\n                    out.println();\n                } else {\n                    indexes = Arrays.copyOf(indexes, indexes.length + 1);\n                    if (x instanceof byte[]) {\n                        byte[] arr = (byte[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof short[]) {\n                        short[] arr = (short[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof boolean[]) {\n                        boolean[] arr = (boolean[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof char[]) {\n                        char[] arr = (char[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof int[]) {\n                        int[] arr = (int[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof float[]) {\n                        float[] arr = (float[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof double[]) {\n                        double[] arr = (double[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof long[]) {\n                        long[] arr = (long[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else {\n                        Object[] arr = (Object[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    }\n                }\n            }\n            return this;\n        }\n\n    }\n}\n\n",math
"import java.io.*;\nimport java.util.*;\n\npublic class CF847K extends PrintWriter {\n	CF847K() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF847K o = new CF847K(); o.main(); o.flush();\n	}\n\n\n	void main() {\n		int n = sc.nextInt();\n		int a = sc.nextInt();\n		int b = sc.nextInt();\n		int k = sc.nextInt();\n		int f = sc.nextInt();\n		HashMap<String, Integer> mp = new HashMap<>();\n		String s = null;\n		int ans = 0;\n		for (int i = 0; i < n; i++) {\n			String u = sc.next();\n			String v = sc.next();\n			int x = u.equals(s) ? b : a;\n			s = v;\n			ans += x;\n			String w = u.compareTo(v) <= 0 ? u + "" "" + v : v + "" "" + u;\n			mp.put(w, mp.getOrDefault(w, 0) + x);\n		}\n		int[] qu = new int[n]; int cnt = 0;\n		for (int x : mp.values())\n			qu[cnt++] = x;\n		Arrays.sort(qu, 0, cnt);\n		while (k-- > 0 && cnt-- > 0 && qu[cnt] > f)\n			ans -= qu[cnt] - f;\n		println(ans);\n	}\n}\n","greedy,implementation,sortings"
"import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class Tickets {\n\n	public static void main(String [] args) {\n		new Transport().solve();\n	}\n	\n}\n\nclass Transport {\n	\n	class Bus implements Comparable <Bus> {\n		\n		String station_1, station_2;\n		\n		Bus(String a, String b){\n			station_1 = a;\n			station_2 = b;\n		}\n		\n		public int compareTo(Bus x) {\n			if (this.station_1.equals(x.station_1) && this.station_2.equals(x.station_2))\n				return 0;\n			if (this.station_1.equals(x.station_2) && this.station_2.equals(x.station_1))\n				return 0;\n			\n			String a1, b1;\n			if (this.station_1.compareTo(this.station_2) < 0) {\n				a1 = this.station_1;\n				b1 = this.station_2;\n			} else {\n				a1 = this.station_2;\n				b1 = this.station_1;\n			}\n			String a2, b2;\n			if (x.station_1.compareTo(x.station_2) < 0) {\n				a2 = x.station_1;\n				b2 = x.station_2;\n			} else {\n				a2 = x.station_2;\n				b2 = x.station_1;\n			}\n			if (a1.compareTo(a2) < 0)\n				return -1;\n			if (a1.compareTo(a2) > 0)\n				return 1;\n			if (b1.compareTo(b2) < 0)\n				return -1;\n			if (b1.compareTo(b1) > 0)\n				return 1;\n			return 100;\n		}\n		\n		public String toString() {\n			return ""["" + station_1 + "" -> "" + station_2 + ""]"";\n		}\n		\n	}\n	\n	int n, a, b, k, f;\n	Bus [] routes;\n	\n	Transport(){\n		Scanner in = new Scanner(System.in);\n		n = in.nextInt();\n		a = in.nextInt();\n		b = in.nextInt();\n		k = in.nextInt();\n		f = in.nextInt();\n		\n		routes = new Bus [n];\n		for (int u = 0; u < n; u++)\n			routes[u] = new Bus(in.next(), in.next());\n		in.close();\n	}\n	\n	void solve() {\n		Map <Bus, Integer> mp = new TreeMap<>();\n		String last = """";\n		for (Bus bs : routes) {\n			int price = (bs.station_1.equals(last) ? b : a);\n			last = bs.station_2;\n			mp.merge(bs, price, (sum, to_add) -> sum + to_add);\n		}\n		\n		List lst = new ArrayList(mp.values());\n		Collections.sort(lst, Collections.reverseOrder());\n		\n		int answer = 0;\n		for (Object num : lst)\n			if (k > 0 && f < (int) num) {\n				answer += f;\n				k--;\n			} else\n				answer += (int) num;\n		System.out.print(answer);\n	}\n	\n}","greedy,implementation,sortings"
"import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class Tickets {\n\n	public static void main(String [] args) {\n		new Transport().solve();\n	}\n	\n}\n\nclass Transport {\n	\n	class Bus implements Comparable <Bus> {\n		\n		String station_1, station_2;\n		\n		Bus(String a, String b){\n			station_1 = a;\n			station_2 = b;\n		}\n		\n		public int compareTo(Bus x) {\n			if (this.station_1.equals(x.station_1) && this.station_2.equals(x.station_2))\n				return 0;\n			if (this.station_1.equals(x.station_2) && this.station_2.equals(x.station_1))\n				return 0;\n			\n			String a1, b1;\n			if (this.station_1.compareTo(this.station_2) < 0) {\n				a1 = this.station_1;\n				b1 = this.station_2;\n			} else {\n				a1 = this.station_2;\n				b1 = this.station_1;\n			}\n			String a2, b2;\n			if (x.station_1.compareTo(x.station_2) < 0) {\n				a2 = x.station_1;\n				b2 = x.station_2;\n			} else {\n				a2 = x.station_2;\n				b2 = x.station_1;\n			}\n			if (a1.compareTo(a2) < 0)\n				return -1;\n			if (a1.compareTo(a2) > 0)\n				return 1;\n			if (b1.compareTo(b2) < 0)\n				return -1;\n			if (b1.compareTo(b1) > 0)\n				return 1;\n			return 100;\n		}\n		\n		public String toString() {\n			return ""["" + station_1 + "" -> "" + station_2 + ""]"";\n		}\n		\n	}\n	\n	int n, a, b, k, f;\n	Bus [] routes;\n	\n	Transport(){\n		Scanner in = new Scanner(System.in);\n		n = in.nextInt();\n		a = in.nextInt();\n		b = in.nextInt();\n		k = in.nextInt();\n		f = in.nextInt();\n		\n		routes = new Bus [n];\n		for (int u = 0; u < n; u++)\n			routes[u] = new Bus(in.next(), in.next());\n		in.close();\n	}\n	\n	void solve() {\n		Map <Bus, Integer> mp = new TreeMap<>();\n		String last = """";\n		for (Bus bs : routes) {\n			int price = (bs.station_1.equals(last) ? b : a);\n			last = bs.station_2;\n			//mp.merge(bs, price, (sum, to_add) -> sum + to_add);\n			int nv = price;\n			if (mp.get(bs) != null) \n				nv = nv + mp.get(bs);			\n			mp.put(bs, nv);\n		}\n		\n		List lst = new ArrayList(mp.values());\n		Collections.sort(lst, Collections.reverseOrder());\n		\n		int answer = 0;\n		for (Object num : lst)\n			if (k > 0 && f < (int) num) {\n				answer += f;\n				k--;\n			} else\n				answer += (int) num;\n		System.out.print(answer);\n	}\n	\n}","greedy,implementation,sortings"
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    private static BufferedReader in;\n    private static StringTokenizer tok;\n    private static PrintWriter out;\n\n    private static String readToken() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    private static int readInt() throws IOException {\n        return Integer.parseInt(readToken());\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n\n        var ssi = new HashMap<String,HashMap<String,Integer>>();\n        int n = readInt();\n        int a = readInt();\n        int b = readInt();\n        int k = readInt();\n        int f = readInt();\n\n        String[][] stans = new String[n][2];\n        for (int i = 0; i < n; i++) {\n            stans[i][0] = readToken();\n            stans[i][1] = readToken();\n        }\n\n        for (int i = 0; i < n; i++) {\n            int price = a;\n            String sl;\n            String sh;\n            int temp = 0;\n            if (i > 0 && stans[i][0].equals(stans[i - 1][1])) price = b;\n            if (stans[i][0].compareTo(stans[i][1]) > 0) {\n                sh = stans[i][0];\n                sl = stans[i][1];\n            } else {\n                sh = stans[i][1];\n                sl = stans[i][0];\n            }\n            if (!ssi.containsKey(sl))\n                ssi.put(sl, new HashMap<String, Integer>());\n            if (ssi.get(sl).containsKey(sh)) {\n                temp = ssi.get(sl).get(sh);\n                temp += price;\n                ssi.get(sl).put(sh, temp);\n            } else\n                ssi.get(sl).put(sh, price);\n\n        }\n\n\n        ArrayList<Integer> arrPrice= new ArrayList<Integer>();\n        for (var i:ssi.keySet()) {\n            for (var j:ssi.get(i).keySet()) {\n                arrPrice.add(ssi.get(i).get(j));\n            }\n        }\n\n\n        int[] prices = new int[arrPrice.size()];\n        for (int i = 0; i < prices.length; i++) {\n            prices[i] = arrPrice.get(i);\n            //out.println(prices[i]);\n        }\n        Arrays.sort(prices);\n\n        for (int i = prices.length - 1; i >= 0; i--) {\n            if(k>0 && prices[i] - f > 0)\n            {\n                prices[i] = f;\n                --k;\n            }\n        }\n\n        int res = 0;\n        for (var i:prices) {\n            res+=i;\n        }\n\n        System.out.println(res);\n\n\n        in.close();\n        out.close();\n    }\n}","greedy,implementation,sortings"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF847H extends PrintWriter {\n	CF847H() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF847H o = new CF847H(); o.main(); o.flush();\n	}\n\n	static final long INF = 0x3f3f3f3f3f3f3f3fL;\n	void main() {\n		int n = sc.nextInt();\n		int[] aa = new int[n];\n		for (int i = 0; i < n; i++)\n			aa[i] = sc.nextInt();\n		int[] hh = new int[n];\n		long[] xx = new long[n];\n		long x = 0;\n		for (int h = 0, i = 0; i < n; i++) {\n			hh[i] = h = Math.max(h + 1, aa[i]);\n			xx[i] = x; x += h - aa[i];\n		}\n		x = 0;\n		for (int h = 0, i = n - 1; i >= 0; i--) {\n			hh[i] = Math.max(hh[i], h = Math.max(h + 1, aa[i]));\n			xx[i] += x; x += h - aa[i];\n		}\n		x = INF;\n		for (int i = 0; i < n; i++)\n			x = Math.min(x, hh[i] - aa[i] + xx[i]);\n		println(x);\n	}\n}\n",greedy
"import java.util.*;\npublic class Main{\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] arr = new int[n];\n        for(int i = 0; i < n; i++)\n            arr[i] = sc.nextInt();\n        long[] how_many_pf = new long[n];\n        long[] last_pf = new long[n];\n        last_pf[0] = arr[0];\n        for(int i = 1; i < n; i++){\n            last_pf[i] = Math.max(last_pf[i - 1] + 1, arr[i]);\n            how_many_pf[i] = how_many_pf[i - 1] + (last_pf[i] - arr[i]);\n        }\n        long[] how_many_sf = new long[n];\n        long[] last_sf = new long[n];\n        last_sf[n - 1] = arr[n - 1];\n        for(int i = n - 2; i >= 0; i--){\n            last_sf[i] = Math.max(last_sf[i + 1] + 1, arr[i]);\n            how_many_sf[i] = how_many_sf[i + 1] + (last_sf[i] - arr[i]);\n        }\n        long ans = (long)1e18;\n        for(int i = 0; i < n; i++){\n            long mx_left_right = 0, to_add = 0;\n            if(i + 1 < n) {\n                mx_left_right = Math.max(mx_left_right, last_sf[i + 1]);\n                to_add += how_many_sf[i + 1];\n            }\n            if(i - 1 >= 0) {\n                mx_left_right = Math.max(mx_left_right, last_pf[i - 1]);\n                to_add += how_many_pf[i - 1];\n            }\n            long curr = Math.max(mx_left_right + 1, arr[i]) - arr[i] + to_add;\n            ans = Math.min(ans, curr);\n        }\n        System.out.print(ans);\n    }\n}",greedy
"import java.io.*;\nimport java.util.*;\n\npublic class tank {\n\n    static final FastScanner fs = new FastScanner();\n\n    public static void main(String[] args) {\n        int n = fs.nextInt();\n        int[] arr = fs.readArray(n);\n        long[] inc = new long[n];\n        long[] dec = new long[n + 1];\n\n        int[] tmp = Arrays.copyOf(arr, n);\n\n        inc[0] = 0;\n\n        for (int i = 1; i < n; i++) {\n            if(tmp[i] <= tmp[i - 1]){\n                inc[i] = tmp[i - 1] - tmp[i] + 1;\n                tmp[i] += inc[i];\n            }\n\n            inc[i] += inc[i - 1];\n        }\n\n        int[] tmp2 = Arrays.copyOf(arr, n);\n\n        dec[n - 1] = 0;\n\n        for (int i = n - 2; i >= 0; i--) {\n            if(tmp2[i + 1] >= tmp2[i]){\n                dec[i] = tmp2[i + 1] - tmp2[i] + 1;\n                tmp2[i] += dec[i];\n\n                if(i > 0){\n                    if(tmp2[i] == tmp[i - 1]){\n                        tmp2[i]++;\n                        dec[i]++;\n                    }\n                }\n            }\n\n            dec[i] += dec[i + 1];\n        }\n\n        long ans = Long.MAX_VALUE;\n\n        for (int i = 0; i < n; i++) {\n            ans = Math.min(ans, dec[i + 1] + inc[i]);\n        }\n\n        System.out.println(ans);\n    }\n\n    static void printar(long[] a){\n        for(long i: a) System.out.print(i + "" "");\n        System.out.println();\n    }\n\n    static void printar(int[] a){\n        for(int i: a) System.out.print(i + "" "");\n        System.out.println();\n    }\n\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer("""");\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        String nextLine(){\n            try {\n                return br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n            return """";\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readArray(int n) {\n            int[] a=new int[n];\n            for (int i=0; i<n; i++) a[i]=nextInt();\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n}\n\n",greedy
"//package main;\n\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int size = scanner.nextInt();\n        int[] numbers = new int[size];\n        for (int i = 0; i < size; i++) {\n            numbers[i] = scanner.nextInt();\n        }\n        int left = 0, right = size - 1;\n        long answer = 0;\n        while (left < right - 1) {\n            if (numbers[left] < numbers[right]) {\n                if (numbers[left + 1] <= numbers[left]) {\n                    answer += numbers[left] + 1 - numbers[left + 1];\n                    numbers[left + 1] = numbers[left] + 1;\n                }\n                left++;\n            } else {\n                if (numbers[right - 1] <= numbers[right]) {\n                    answer += numbers[right] + 1 - numbers[right - 1];\n                    numbers[right - 1] = numbers[right] + 1;\n                }\n                right--;\n            }\n        }\n        if (numbers[left] == numbers[right] && left != right) {\n            answer++;\n        }\n        System.out.println(answer);\n    }\n}\n",greedy
"import java.io.*;\nimport java.util.*;\n\npublic class interactive_lower_bound {\n	public static void main(String[] args) {\n		try (Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)))) {\n			final int n = in.nextInt(), start = in.nextInt(), x = in.nextInt();\n			int y = -1, i = start;\n			if (n >= 2000) {\n				System.out.println(""? "" + i);\n				System.out.flush();\n				y = in.nextInt();\n				i = in.nextInt();\n				if (y == -1 && i == -1) {\n					return;\n				}\n				if (y >= x) {\n					System.out.println(""! "" + y);\n					System.out.flush();\n					return;\n				}\n				final Random rnd = new Random();\n				for (int j = 0; j < 999; j++) {\n					System.out.println(""? "" + (1 + rnd.nextInt(n)));\n					System.out.flush();\n					final int z = in.nextInt();\n					final int k = in.nextInt();\n					if (z == -1 && k == -1) {\n						return;\n					}\n					if (z <= x && z > y) {\n						y = z;\n						i = k;\n					}\n				}\n			}\n			\n			while (i != -1 && y < x) {\n				System.out.println(""? "" + i);\n				System.out.flush();\n				y = in.nextInt();\n				i = in.nextInt();\n				if (y == -1 && i == -1) {\n					return;\n				}\n			}\n			if (y < x) {\n				y = -1;\n			}\n			\n			System.out.println(""! "" + y);\n			System.out.flush();\n		}\n	}\n}\n","brute force,interactive,probabilities"
"import java.util.Scanner;\n\npublic class b {\n	static Scanner in = new Scanner(System.in);\n	public static void main(String[] args) {\n		int n = in.nextInt(), curIdx = in.nextInt()-1, x = in.nextInt();\n		int curMax = query(curIdx).v;\n		for(int i=0;i<999;i++) {\n			int qidx = (int) (Math.random()*n);\n			int qval = query(qidx).v;\n			if(qval > curMax && qval <= x) {\n				curMax = qval;\n				curIdx = qidx;\n			}\n		}\n		for(int i=0;i<998;i++) {\n			Answer res = query(curIdx);\n			curMax = res.v;\n			if(curMax >= x) break;\n			curIdx = res.next;\n			if(curIdx == -2) {\n				curMax = -1;\n				break;\n			}\n		}\n		System.out.println(""! "" + curMax);\n	}\n	static Answer query(int idx) {\n		System.out.println(""? "" + (idx+1));\n		return new Answer(in.nextInt(), in.nextInt()-1);\n	}\n	static class Answer {\n		int v, next;\n		public Answer(int v, int next) {\n			this.v = v;\n			this.next = next;\n		}\n	}\n}\n","brute force,interactive,probabilities"
"import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class D {\n\n	public static void main(String[] args) {\n		try (Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)))) {\n			final int n = in.nextInt(), start = in.nextInt(), x = in.nextInt();\n			int y = -1, i = start;\n			if (n >= 2000) {\n				System.out.println(""? "" + i);\n				System.out.flush();\n				y = in.nextInt();\n				i = in.nextInt();\n				if (y == -1 && i == -1) {\n					return;\n				}\n				if (y >= x) {\n					System.out.println(""! "" + y);\n					System.out.flush();\n					return;\n				}\n				final Random rnd = new Random();\n				for (int j = 0; j < 999; j++) {\n					System.out.println(""? "" + (1 + rnd.nextInt(n)));\n					System.out.flush();\n					final int z = in.nextInt();\n					final int k = in.nextInt();\n					if (z == -1 && k == -1) {\n						return;\n					}\n					if (z <= x && z > y) {\n						y = z;\n						i = k;\n					}\n				}\n			}\n			while (i != -1 && y < x) {\n				System.out.println(""? "" + i);\n				System.out.flush();\n				y = in.nextInt();\n				i = in.nextInt();\n				if (y == -1 && i == -1) {\n					return;\n				}\n			}\n			if (y < x) {\n				y = -1;\n			}\n			System.out.println(""! "" + y);\n			System.out.flush();\n		}\n	}\n\n}","brute force,interactive,probabilities"
"import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class D {\n\n	public static void main(String[] args) {\n		try (Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)))) {\n			final int n = in.nextInt(), start = in.nextInt(), x = in.nextInt();\n			int y = -1, i = start;\n			if (n >= 2000) {\n				System.out.println(""? "" + i);\n				System.out.flush();\n				y = in.nextInt();\n				i = in.nextInt();\n				if (y == -1 && i == -1) {\n					return;\n				}\n				if (y >= x) {\n					System.out.println(""! "" + y);\n					System.out.flush();\n					return;\n				}\n				final Random rnd = new Random();\n				for (int j = 0; j < 999; j++) {\n					System.out.println(""? "" + (1 + rnd.nextInt(n)));\n					System.out.flush();\n					final int z = in.nextInt();\n					final int k = in.nextInt();\n					if (z == -1 && k == -1) {\n						return;\n					}\n					if (z <= x && z > y) {\n						y = z;\n						i = k;\n					}\n				}\n			}\n			while (i != -1 && y < x) {\n				System.out.println(""? "" + i);\n				System.out.flush();\n				y = in.nextInt();\n				i = in.nextInt();\n				if (y == -1 && i == -1) {\n					return;\n				}\n			}\n			if (y < x) {\n				y = -1;\n			}\n			System.out.println(""! "" + y);\n			System.out.flush();\n		}\n	}\n\n}\n","brute force,interactive,probabilities"
"import java.util.*;\npublic class Main {\n	static int a[][],n;\n	static boolean isClique[];\n	static int maxClique[];\n	static void DFS1(int p,int n,int S)\n	{\n		if(p>n)\n		{\n			isClique[S]=true;\n			return ;\n		}\n		DFS1(p+1,n,S);\n		boolean mark=true;\n		for(int i=1;i<p;++i)\n			if((S>>(i-1)&1)==1&&a[p][i]==0)\n				mark=false;\n		if(mark)\n			DFS1(p+1,n,1<<(p-1)|S);\n	}\n	static void DFS2(int p,int n,int m,int S)\n	{\n		if(p>n)\n		{\n			int cnt=0;\n			for(int i=m;i<=n;++i)\n				if((S>>(i-m)&1)==1)\n					++cnt;\n			maxClique[S]=cnt;\n			return ;\n		}\n		DFS2(p+1,n,m,S);\n		boolean mark=true;\n		for(int i=m;i<p;++i)\n			if((S>>(i-m)&1)==1&&a[p][i]==0)\n				mark=false;\n		if(mark)\n			DFS2(p+1,n,m,1<<(p-m)|S);\n	}\n	public static void main(String[] args)\n	{\n		Scanner sc=new Scanner(System.in);\n		n=Integer.parseInt(sc.next());\n		a=new int [n+10][n+10];\n		int cap=Integer.parseInt(sc.next());\n		for(int i=1;i<=n;++i)\n			for(int j=1;j<=n;++j)\n				a[i][j]=Integer.parseInt(sc.next());\n		int m=(n+1)>>1;\n		isClique=new boolean [1<<m];\n		Arrays.fill(isClique,false);\n		DFS1(1,m,0);\n		maxClique=new int [1<<(n-m)];\n		Arrays.fill(maxClique,0);\n		DFS2(m+1,n,m+1,0);\n		for(int i=1;i<1<<(n-m);++i)\n			for(int j=m+1;j<=n;++j)\n				if((i>>(j-m-1)&1)==1)\n					maxClique[i]=Math.max(maxClique[i],maxClique[i-(1<<(j-m-1))]);\n		int ans=0,tmp[]=new int [m+10];\n		for(int i=0;i<1<<m;++i)\n			if(isClique[i])\n			{\n				int mask=0,cnt=0;\n				for(int j=1;j<=m;++j)\n					if((i>>(j-1)&1)==1)\n						tmp[++cnt]=j;\n				for(int j=m+1;j<=n;++j)\n				{\n					boolean mark=true;\n					for(int k=1;k<=cnt;++k)\n						if(a[j][tmp[k]]==0)\n							mark=false;\n					if(mark)\n						mask|=1<<(j-m-1);\n				}\n				ans=Math.max(ans,cnt+maxClique[mask]);\n			}\n		System.out.printf(""%.9f\n"",cap*cap*(ans-1)/2.0/ans);\n	}\n}\n","brute force,graphs,math,meet-in-the-middle"
"import java.util.*;\nimport java.io.*;\npublic class E {\n    void solve(BufferedReader in) throws Exception {\n        int[] xx = toInts(in.readLine());\n        int n = xx[0];\n        double k = xx[1];\n        int[][] board = new int[n][n];\n        for(int i = 0; i<n; i++) board[i] = toInts(in.readLine());\n        int fst = n/2;\n        int snd = n - fst;\n        int[] maxc = new int[1<<fst];\n        int max = 1;\n        for(int i = 0; i<(1<<fst); i++) {\n            for(int j = 0; j<fst; j++) {\n                if((i&1<<j) != 0) maxc[i] = Math.max(maxc[i], maxc[i^(1<<j)]);\n            }\n            boolean ok = true;\n            for(int a = 0; a<fst; a++) if((i&1<<a) != 0) {\n                for(int b = a+1; b<fst; b++) if((i&1<<b) != 0) {\n                    if(board[a][b] == 0) ok = false;\n                }\n            }\n            if(ok) {\n                maxc[i] = Integer.bitCount(i);\n                max = Math.max(max, maxc[i]);\n            }\n        }\n        for(int i = 0; i<(1<<snd); i++) {\n            boolean ok = true;\n            for(int a = 0; a<snd; a++) if((i&1<<a) != 0) {\n                for(int b = a+1; b<snd; b++) if((i&1<<b) != 0) {\n                    if(board[a+fst][b+fst] == 0) ok = false;\n                }\n            }\n            if(!ok) continue;\n            int mask = 0;\n            for(int a = 0; a<fst; a++) {\n                ok = true;\n                for(int b = 0; b<snd; b++) {\n                    if((i&1<<b) != 0) {\n                        if(board[a][b+fst] == 0) ok = false;\n                    }\n                }\n                if(ok) mask |= (1<<a);\n            }\n            max = Math.max(Integer.bitCount(i) + maxc[mask], max);\n        }\n        System.out.println(k*k*(max-1.0)/(2*max));\n    }\n    int toInt(String s) {return Integer.parseInt(s);}\n    int[] toInts(String s) {\n        String[] a = s.split("" "");\n        int[] o = new int[a.length];\n        for(int i = 0; i<a.length; i++) o[i] = toInt(a[i]);\n        return o;\n    }\n    void e(Object o) {\n        System.err.println(o);\n    }\n    public static void main(String[] args) throws Exception{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        (new E()).solve(in);\n    }\n}\n","brute force,graphs,math,meet-in-the-middle"
"import java.util.*;\nimport java.io.*;\npublic class E {\n    void solve(BufferedReader in) throws Exception {\n        int[] xx = toInts(in.readLine());\n        int n = xx[0];\n        double k = xx[1];\n        int[][] board = new int[n][n];\n        for(int i = 0; i<n; i++) board[i] = toInts(in.readLine());\n        int fst = n/2;\n        int snd = n - fst;\n        int[] maxc = new int[1<<fst];\n        int max = 1;\n        for(int i = 0; i<(1<<fst); i++) {\n            for(int j = 0; j<fst; j++) {\n                if((i&(1<<j)) != 0) maxc[i] = Math.max(maxc[i], maxc[i^(1<<j)]);\n            }\n            boolean ok = true;\n            for(int a = 0; a<fst; a++) if(((1<<a)&i) != 0) {\n                for(int b = a+1; b<fst; b++) if(((1<<b)&i) != 0) {\n                    if(board[a][b] == 0) ok = false;\n                }\n            }\n            if(ok) {\n                maxc[i] = Integer.bitCount(i);\n                max = Math.max(max, maxc[i]);\n            }\n        }\n        for(int i = 0; i<(1<<snd); i++) {\n            boolean ok = true;\n            for(int a = 0; a<snd; a++) if(((1<<a)&i) != 0) {\n                for(int b = a+1; b<snd; b++) if(((1<<b)&i) != 0) {\n                    if(board[a+fst][b+fst] == 0) ok = false;\n                }\n            }\n            if(!ok) continue;\n            int mask = 0;\n            for(int a = 0; a<fst; a++) {\n                ok = true;\n                for(int b = 0; b<snd; b++) {\n                    if(((1<<b)&i) != 0) {\n                        if(board[a][b+fst] == 0) ok = false;\n                    }\n                }\n                if(ok) mask |= (1<<a);\n            }\n            max = Math.max(Integer.bitCount(i) + maxc[mask], max);\n        }\n        System.out.println(k*k*(max-1.0)/(2*max));\n    }\n    int toInt(String s) {return Integer.parseInt(s);}\n    int[] toInts(String s) {\n        String[] a = s.split("" "");\n        int[] o = new int[a.length];\n        for(int i = 0; i<a.length; i++) o[i] = toInt(a[i]);\n        return o;\n    }\n    void e(Object o) {\n        System.err.println(o);\n    }\n    public static void main(String[] args) throws Exception{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        (new E()).solve(in);\n    }\n}\n","brute force,graphs,math,meet-in-the-middle"
"\nimport java.util.*;\nimport java.io.*;\npublic class code839E\n{\n    public static void main(String[] args) throws Exception{\n        BufferedReader bff=new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter wff=new PrintWriter(System.out);\n        String[] st=bff.readLine().split("" "");\n        int V=Integer.parseInt(st[0]);\n        int K=Integer.parseInt(st[1]);\n        BronKerbosch bk=new BronKerbosch(V);\n        for(int i=0;i<V;i++){\n            st=bff.readLine().split("" "");\n            for(int j=0;j<V;j++){\n                if(st[j].equals(""1"")){\n                    bk.anadir(i,j);\n                }\n            }\n        }\n        long num=bk.numeroCamarilla();\n        wff.printf(""%.12f\n"", num * (num - 1.0) / 2 * K / num * K / num);\n        wff.flush();\n    }\n    \n    \n    \nstatic class BronKerbosch {\n    int V;\n    long[] neig;\n    Random random = new Random();\n    long maxClique;\n\n    public BronKerbosch(int v){\n        V=v;\n        neig=new long[V];\n    }\n\n    public void anadir(int a,int b){\n        long aux=1;\n        neig[a] |= aux << (long)b;\n    }\n    \n    public long numeroCamarilla(){\n        long numero = Long.bitCount(bronKerbosch());\n        return numero;\n    }\n    \n    public long bronKerbosch() {\n        maxClique = 0;\n        bronKerbosch2(0, (1L << V) - 1, 0);\n        return maxClique;\n    }\n\n    public void bronKerbosch2(long r, long p, long x) {\n        if (Long.bitCount(maxClique) >= Long.bitCount(r | p | x)) return;\n        long px = p | x;\n        if (px == 0) {\n            if (Long.bitCount(maxClique) < Long.bitCount(r)) {\n                maxClique = r;\n            }\n            return;\n        }\n        int cnt = Long.bitCount(px);\n        int choice = random.nextInt(cnt);\n        int u;\n        for (int i = 0; ; i++) {\n            if ((px >>> i & 1) != 0 && choice-- == 0) {\n                u = i;\n                break;\n            }\n        }\n\n        long ne = p & ~neig[u];\n        for (int v = 0; v < V; v++){\n            if ((ne >>> v & 1) != 0) {\n                bronKerbosch2(r | 1L << v, p & neig[v], x & neig[v]);\n                p &= ~(1L << v);\n                x |= 1L << v;\n            }\n        }\n    }\n\n}\n\n\n    \n}\n","brute force,graphs,math,meet-in-the-middle"
"//package Codeforces;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class DivergingDirections{\n\n	static long INF=(long)1e18;\n	static int n;\n	static int []tin,tout,back,atTime;\n	static long []dist1;\n	static int timer;\n	static ArrayList<edge>[]adj;\n	static void dfs(int u,long d)\n	{\n		atTime[timer]=u;\n		dist1[u]=d;\n		tin[u]=timer++;\n		\n		for(edge nxt:adj[u])\n			dfs(nxt.v,d+nxt.c);\n		tout[u]=timer-1;\n	}\n	static boolean isAnc(int u,int v) {\n		return tin[v]>=tin[u] && tout[v]<=tout[u];\n	}\n	\n	public static void main(String[] args) throws IOException {\n		Scanner sc=new Scanner();\n		PrintWriter out=new PrintWriter(System.out);\n		n=sc.nextInt();\n		int q=sc.nextInt();\n		adj=new ArrayList[n];\n		for(int i=0;i<n;i++)\n			adj[i]=new ArrayList();\n		\n		int []to=new int [2*n],cost=new int [n];\n		for(int i=1;i<n;i++)\n		{\n			int u=sc.nextInt()-1,v=sc.nextInt()-1,c=sc.nextInt();\n			adj[u].add(new edge(v,c));\n			to[i]=v;\n			cost[i]=c;\n		}\n		back=new int [n];\n		for(int i=1;i<n;i++)\n		{\n			int u=sc.nextInt()-1,v=sc.nextInt()-1,c=sc.nextInt();\n			back[u]=c;\n			to[i+n-1]=u;\n		}\n		tin=new int [n];\n		tout=new int [n];\n		atTime=new int [n];\n		dist1=new long [n];\n		dfs(0,0);\n		\n		SegmentTree tree=new SegmentTree();\n		while(q-->0) {\n			if(sc.nextInt()==1)\n			{\n				int idx=sc.nextInt(),w=sc.nextInt();\n				if(idx>=n)\n				{\n					tree.updatePoint(to[idx], w);\n				}\n				else\n				{\n					int v=to[idx];\n					int change=w-cost[idx];\n					cost[idx]=w;\n					tree.updateRange(tin[v], tout[v], change);\n				}\n				\n			}\n			else\n			{\n				int u=sc.nextInt()-1,v=sc.nextInt()-1;\n				long ans=tree.queryPoint(v)-tree.queryPoint(u);\n				if(!isAnc(u,v)) \n					ans+=tree.query(tin[u], tout[u]);\n				\n				out.println(ans);\n			}\n		}\n		\n		out.close();\n\n	}\n	static class edge\n	{\n		int v,c;\n		edge(int y,int z){\n			\n			v=y;\n			c=z;\n		}\n	}\n	static class SegmentTree\n	{\n		long []lazy,dist,minTotal;\n		SegmentTree()\n		{\n			lazy=new long [4*n];\n			dist=new long [4*n];\n			minTotal=new long [4*n];\n			build(1,0,n-1);\n		}\n		void build(int node, int tl,int tr) {\n			if(tl==tr)\n			{\n				dist[node]=dist1[atTime[tl]];\n				minTotal[node]=dist[node]+back[atTime[tl]];\n			}\n			else\n			{\n				int mid=tl+tr>>1,left=node<<1,right=left+1;\n				build(left,tl,mid);\n				build(right,mid+1,tr);\n				minTotal[node]=Math.min(minTotal[left], minTotal[right]);\n			}\n		}\n		void updatePoint(int idx,int newBack)\n		{\n			back[idx]=newBack;\n			updatePoint(1,0,n-1,tin[idx]);\n		}\n		void updatePoint(int node,int tl,int tr,int idx)\n		{\n			if(tl==tr)\n				minTotal[node]=dist[node]+back[atTime[idx]];\n			else\n			{\n				int mid=tl+tr>>1,left=node<<1,right=left+1;\n				propagate(node);\n				if(idx<=mid)\n					updatePoint(left,tl,mid,idx);\n				else\n					updatePoint(right,mid+1,tr,idx);\n				minTotal[node]=Math.min(minTotal[left], minTotal[right]);\n\n		\n			}\n		}\n		void updateRange(int l,int r,int change)\n		{\n			updateRange(1,0,n-1,l,r,change);\n		}\n		void updateRange(int node,int tl,int tr,int l,int r,int change) {\n			if(r<tl || tr<l)\n				return ;\n			if(tl>=l && tr<=r)\n			{\n				lazy[node]+=change;\n				minTotal[node]+=change;\n				dist[node]+=change;\n				return;\n			}\n			int mid=tl+tr>>1,left=node<<1,right=left+1;\n			propagate(node);;\n			updateRange(left,tl,mid,l,r,change);\n			updateRange(right,mid+1,tr,l,r,change);\n			minTotal[node]=Math.min(minTotal[left], minTotal[right]);\n\n		}\n		long queryPoint(int u) {\n			return queryPoint(1,0,n-1,tin[u]);\n		}\n		long queryPoint(int node,int tl,int tr,int idx) {\n			if(tl==tr)\n				return dist[node];\n			int mid=tl+tr>>1,left=node<<1,right=left+1;\n			propagate(node);\n			if(idx<=mid)\n				return queryPoint(left,tl,mid,idx);\n			else\n				return queryPoint(right,mid+1,tr,idx);\n			\n		}\n		void propagate(int node) {\n			int left=node<<1,right=left+1;\n			long x=lazy[node];\n			lazy[left]+=x;\n			lazy[right]+=x;\n			minTotal[left]+=x;\n			minTotal[right]+=x;\n			dist[left]+=x;\n			dist[right]+=x;\n			lazy[node]=0;\n		}\n		long query(int l,int r) {\n			return query(1,0,n-1,l,r);\n		}\n		long query(int node,int tl,int tr,int l,int r) {\n			if(r<tl || tr<l)\n				return INF;\n			if(tl>=l && tr<=r)\n				return minTotal[node];\n			int mid=tl+tr>>1,left=node<<1,right=left+1;\n			propagate(node);;\n			return Math.min(query(left,tl,mid,l,r), query(right,mid+1,tr,l,r));\n		}\n		\n	}\n	static class Scanner\n	{\n		BufferedReader br;\n		StringTokenizer st;\n		Scanner(){\n			br=new BufferedReader(new InputStreamReader(System.in));\n		}\n		Scanner(String fileName) throws FileNotFoundException{\n			br=new BufferedReader(new FileReader(fileName));\n		}\n		String next() throws IOException {\n			while(st==null || !st.hasMoreTokens())\n				st=new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n		String nextLine() throws IOException {\n			return br.readLine();\n		}\n		int nextInt() throws IOException{\n			return Integer.parseInt(next());\n		}\n		long nextLong()  throws NumberFormatException, IOException {\n			return Long.parseLong(next());\n		}\n		double nextDouble() throws NumberFormatException, IOException {\n			return Double.parseDouble(next());\n		}\n	}\n}\n","data structures,dfs and similar,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class B {\n    static int n, q, pathTimer = 0, timer = 0;\n    static ArrayList<Edge>[] arr;\n    static Edge[] edges;\n    static int[] pathTour, tour, cost, start, end, pathTime, backEdge, backEdgeId, size;\n    public static void main(String[] args) throws IOException{\n        FastIO file = new FastIO();\n        n = file.nextInt();\n        q = file.nextInt();\n        cost = new int[2*n-2];\n        arr = new ArrayList[n];\n        edges = new Edge[n-1];\n        for (int i=0; i<n; i++){\n            arr[i] = new ArrayList<>();\n        }\n        for (int i=0; i<n-1; i++){\n            int a = file.nextInt()-1;\n            int b = file.nextInt()-1;\n            edges[i] = new Edge(b, i);\n            arr[a].add(edges[i]);\n            cost[i] = file.nextInt();\n        }\n        backEdge = new int[n];\n        backEdgeId = new int[2*n-2];\n        for (int i=0; i<n-1; i++){\n            int a = file.nextInt()-1;\n            int b = file.nextInt()-1;\n            backEdge[a] = n-1+i;\n            backEdgeId[n-1+i] = a;\n            cost[n-1+i] = file.nextInt();\n        }\n        pathTour = new int[n];\n        tour = new int[2*n];\n        start = new int[n];\n        end = new int[n];\n        pathTime = new int[n];\n        size = new int[n];\n        dfs(0, -1, 0);\n        // for (int i=0; i<n; i++){\n        //     System.out.print(pathTour[i] + "" "");\n        // }\n        BIT bit = new BIT(n+1);\n        int prev = 0;\n        for (int i=0; i<n; i++){\n            bit.update(i+1, pathTour[i] - prev);\n            prev = pathTour[i];\n        }\n        // for (int i=0; i<n; i++){\n        //     System.out.println(bit.query(i+1));\n        // }\n        int[] costToRoot = new int[2*n];\n        for (int i=1; i<n; i++){\n            costToRoot[start[i]] = pathTour[pathTime[i]] + cost[backEdge[i]];\n            costToRoot[end[i]] = pathTour[pathTime[i]] + cost[backEdge[i]];\n        }\n        SegTree st = new SegTree(costToRoot);\n        for (int i=0; i<q; i++){\n            int t= file.nextInt();\n            if (t == 2){\n                int a = file.nextInt()-1;\n                int b = file.nextInt()-1;\n                if (a == b){\n                    file.println(0);\n                    continue;\n                }\n                if (start[a] <= start[b] && end[a] >= end[b]){\n                    // a is a parent of b\n                    file.println(bit.query(pathTime[b]+1) - bit.query(pathTime[a]+1));\n                }else{\n                    // we need to route through the root\n                    long minToRoot = st.query(start[a], end[a]) - bit.query(pathTime[a]+1);\n                    file.println(minToRoot + bit.query(pathTime[b]+1));\n                }\n            }else{\n                int a = file.nextInt()-1;\n                int b = file.nextInt();\n                if (a < n-1){\n                    // Update tree edge\n                    Edge curr = edges[a];\n                    bit.update(pathTime[curr.to]+1, b - cost[a]);\n                    bit.update(pathTime[curr.to]+1+size[curr.to], -(b - cost[a]));\n                    st.update(start[curr.to], end[curr.to], b - cost[a]);\n                }else{\n                    // Update back edge\n                    st.update(start[backEdgeId[a]], start[backEdgeId[a]], b - cost[a]);\n                    st.update(end[backEdgeId[a]], end[backEdgeId[a]], b - cost[a]);\n                }\n                // System.out.println(""-----------"");\n                // for (int j=0; j<n; j++){\n                //     System.out.println(bit.query(j+1));\n                // }\n                cost[a] = b;\n            }\n        }\n        file.close();\n    }\n    public static void dfs(int at, int par, int curCost){\n        pathTour[pathTimer] = curCost;\n        pathTime[at] = pathTimer++;\n        tour[timer] = at;\n        start[at] = timer++;\n        size[at] = 1;\n        for (Edge i : arr[at]){\n            if (i.to != par){\n                dfs(i.to, at, curCost + cost[i.id]);\n                size[at] += size[i.to];\n            }\n        }\n        tour[timer] = at;\n        end[at] = timer++;\n    }\n    static class Edge{\n        int to, id;\n        public Edge(int to, int id){\n            this.to = to;\n            this.id = id;\n        }\n    }\n    static class BIT {\n        int n;\n        long[] ft;\n        public BIT(int n){\n            this.n = n;\n            this.ft = new long[n];\n        }\n        // Update a point, query (the sum of) a range\n        public void update(int x, long v){\n            while (x < n){\n                ft[x] += v;\n                x += x&-x;\n            }\n        }\n        public long query(int x){\n            return x > 0 ? ft[x] + query(x - (x&-x)) : 0;\n        }\n    }\n    static class SegTree {\n        int[] arr, seg, lazy;\n        int n;\n    \n        public SegTree(int[] arr) {\n            this.arr = arr;\n            this.n = arr.length;\n            seg = new int[4 * n];\n            lazy = new int[4 * n];\n            build(0, 0, n-1);\n        }\n    \n        public SegTree(int n) {\n            this.n = n;\n            seg = new int[4 * n];\n            lazy = new int[4 * n];\n        }\n    \n        private void build(int node, int l, int r) {\n            if (l == r) {\n                // CAREFUL! THIS ASSUMES THE ARRAY IS 0 INDEXED(which it probably is)\n                seg[node] = arr[l];\n                return;\n            }\n            int mid = (l + r) / 2;\n            build(node * 2 + 1, l, mid);\n            build(node * 2 + 2, mid + 1, r);\n            // change this\n            seg[node] = Math.min(seg[node * 2 + 1], seg[node * 2 + 2]);\n    \n        }\n    \n        private int query(int a, int b) {\n            return query(0, 0, n-1, a, b);\n        }\n    \n        private int query(int node, int l, int r, int a, int b) {\n            if (a <= l && r <= b) {\n                return seg[node];\n            }\n            prop(node, l, r);\n            int ans = Integer.MAX_VALUE;\n            int mid = (l + r) / 2;\n            if (a <= mid) {\n                // change this\n                ans = Math.min(ans, query(node * 2 + 1, l, mid, a, b));\n            }\n            if (b > mid) {\n                // change this\n                ans = Math.min(ans, query(node * 2 + 2, mid + 1, r, a, b));\n            }\n            return ans;\n        }\n    \n        private void update(int a, int b, int x) {\n            update(0, 0, n-1, a, b, x);\n        }\n    \n        private void update(int node, int l, int r, int a, int b, int x) {\n            if (a <= l && r <= b) {\n                lazy[node] += x;\n                // change this\n                seg[node] += x;\n                return;\n            }\n            prop(node, l, r);\n            int mid = (l + r) / 2;\n            if (a <= mid) {\n                // change this\n                update(node * 2 + 1, l, mid, a, b, x);\n            }\n            if (b > mid) {\n                // change this\n                update(node * 2 + 2, mid + 1, r, a, b, x);\n            }\n            // change this\n            seg[node] = Math.min(seg[node * 2 + 1], seg[node * 2 + 2]);\n    \n        }\n    \n        private void prop(int node, int l, int r) {\n            if (lazy[node] != 0) {\n                int mid = (l + r) / 2;\n                // change this\n                seg[node * 2 + 1] += lazy[node];\n                seg[node * 2 + 2] += lazy[node];\n                lazy[node * 2 + 1] += lazy[node];\n                lazy[node * 2 + 2] += lazy[node];\n                lazy[node] = 0;\n            }\n        }\n    }\n    \n\n    static class FastIO extends PrintWriter {\n        private InputStream stream;\n        private byte[] buf = new byte[1<<16];\n        private int curChar, numChars;\n    \n        public FastIO() { this(System.in,System.out); }\n        public FastIO(InputStream i, OutputStream o) {\n            super(o);\n            stream = i;\n        }\n        public FastIO(String i, String o) throws IOException {\n            super(new FileWriter(o));\n            stream = new FileInputStream(i);\n        }\n        public FastIO(String i) throws IOException {\n            super(System.out);\n            stream = new FileInputStream(i);\n        }\n        // throws InputMismatchException() if previously detected end of file\n        private int nextByte() {\n            if (numChars == -1) throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars == -1) return -1; // end of file\n            }\n            return buf[curChar++];\n        }\n        // to read in entire lines, replace c <= ' '\n        // with a function that checks whether c is a line break\n        public String next() {\n            int c; do { c = nextByte(); } while (c <= ' ');\n            StringBuilder res = new StringBuilder();\n            do { res.appendCodePoint(c); c = nextByte(); } while (c > ' ');\n            return res.toString();\n        }\n        public int nextInt() {\n            int c; do { c = nextByte(); } while (c <= ' ');\n            int sgn = 1; if (c == '-') { sgn = -1; c = nextByte(); }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res = 10*res+c-'0';\n                c = nextByte();\n            } while (c > ' ');\n            return res * sgn;\n        }\n        public long nextLong() {\n            int c; do { c = nextByte(); } while (c <= ' ');\n            int sgn = 1; if (c == '-') { sgn = -1; c = nextByte(); }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res = 10*res+c-'0';\n                c = nextByte();\n            } while (c > ' ');\n            return res * sgn;\n        }\n        public double nextDouble() { return Double.parseDouble(next()); }\n    }\n}","data structures,dfs and similar,trees"
"\nimport java.io.*;\nimport java.util.*;\n\npublic class A{\n\n	static long INF=(long)1e18;\n	static int n;\n	static int []tin,tout,back,atTime;\n	static long []dist1;\n	static int timer;\n	static ArrayList<edge>[]adj;\n	static void dfs(int u,long d)\n	{\n		atTime[timer]=u;\n		dist1[u]=d;\n		tin[u]=timer++;\n		\n		for(edge nxt:adj[u])\n			dfs(nxt.v,d+nxt.c);\n		tout[u]=timer-1;\n	}\n	static boolean isAnc(int u,int v) {\n		return tin[v]>=tin[u] && tout[v]<=tout[u];\n	}\n	\n	public static void main(String[] args) throws IOException {\n		Scanner sc=new Scanner();\n		PrintWriter out=new PrintWriter(System.out);\n		n=sc.nextInt();\n		int q=sc.nextInt();\n		adj=new ArrayList[n];\n		for(int i=0;i<n;i++)\n			adj[i]=new ArrayList();\n		\n		int []to=new int [2*n],cost=new int [n];\n		for(int i=1;i<n;i++)\n		{\n			int u=sc.nextInt()-1,v=sc.nextInt()-1,c=sc.nextInt();\n			adj[u].add(new edge(v,c));\n			to[i]=v;\n			cost[i]=c;\n		}\n		back=new int [n];\n		for(int i=1;i<n;i++)\n		{\n			int u=sc.nextInt()-1,v=sc.nextInt()-1,c=sc.nextInt();\n			back[u]=c;\n			to[i+n-1]=u;\n		}\n		tin=new int [n];\n		tout=new int [n];\n		atTime=new int [n];\n		dist1=new long [n];\n		dfs(0,0);\n		\n		SegmentTree tree=new SegmentTree();\n		while(q-->0) {\n			if(sc.nextInt()==1)\n			{\n				int idx=sc.nextInt(),w=sc.nextInt();\n				if(idx>=n)\n				{\n					tree.updatePoint(to[idx], w);\n				}\n				else\n				{\n					int v=to[idx];\n					int change=w-cost[idx];\n					cost[idx]=w;\n					tree.updateRange(tin[v], tout[v], change);\n				}\n				\n			}\n			else\n			{\n				int u=sc.nextInt()-1,v=sc.nextInt()-1;\n				long ans=tree.queryPoint(v)-tree.queryPoint(u);\n				if(!isAnc(u,v)) \n					ans+=tree.query(tin[u], tout[u]);\n				\n				out.println(ans);\n			}\n		}\n		\n		out.close();\n\n	}\n	static class edge\n	{\n		int v,c;\n		edge(int y,int z){\n			\n			v=y;\n			c=z;\n		}\n	}\n	static class SegmentTree\n	{\n		long []lazy,dist,minTotal;\n		SegmentTree()\n		{\n			lazy=new long [4*n];\n			dist=new long [4*n];\n			minTotal=new long [4*n];\n			build(1,0,n-1);\n		}\n		void build(int node, int tl,int tr) {\n			if(tl==tr)\n			{\n				dist[node]=dist1[atTime[tl]];\n				minTotal[node]=dist[node]+back[atTime[tl]];\n			}\n			else\n			{\n				int mid=tl+tr>>1,left=node<<1,right=left+1;\n				build(left,tl,mid);\n				build(right,mid+1,tr);\n				minTotal[node]=Math.min(minTotal[left], minTotal[right]);\n			}\n		}\n		void updatePoint(int idx,int newBack)\n		{\n			back[idx]=newBack;\n			updatePoint(1,0,n-1,tin[idx]);\n		}\n		void updatePoint(int node,int tl,int tr,int idx)\n		{\n			if(tl==tr)\n				minTotal[node]=dist[node]+back[atTime[idx]];\n			else\n			{\n				int mid=tl+tr>>1,left=node<<1,right=left+1;\n				propagate(node);\n				if(idx<=mid)\n					updatePoint(left,tl,mid,idx);\n				else\n					updatePoint(right,mid+1,tr,idx);\n				minTotal[node]=Math.min(minTotal[left], minTotal[right]);\n\n		\n			}\n		}\n		void updateRange(int l,int r,int change)\n		{\n			updateRange(1,0,n-1,l,r,change);\n		}\n		void updateRange(int node,int tl,int tr,int l,int r,int change) {\n			if(r<tl || tr<l)\n				return ;\n			if(tl>=l && tr<=r)\n			{\n				lazy[node]+=change;\n				minTotal[node]+=change;\n				dist[node]+=change;\n				return;\n			}\n			int mid=tl+tr>>1,left=node<<1,right=left+1;\n			propagate(node);;\n			updateRange(left,tl,mid,l,r,change);\n			updateRange(right,mid+1,tr,l,r,change);\n			minTotal[node]=Math.min(minTotal[left], minTotal[right]);\n\n		}\n		long queryPoint(int u) {\n			return queryPoint(1,0,n-1,tin[u]);\n		}\n		long queryPoint(int node,int tl,int tr,int idx) {\n			if(tl==tr)\n				return dist[node];\n			int mid=tl+tr>>1,left=node<<1,right=left+1;\n			propagate(node);\n			if(idx<=mid)\n				return queryPoint(left,tl,mid,idx);\n			else\n				return queryPoint(right,mid+1,tr,idx);\n			\n		}\n		void propagate(int node) {\n			int left=node<<1,right=left+1;\n			long x=lazy[node];\n			lazy[left]+=x;\n			lazy[right]+=x;\n			minTotal[left]+=x;\n			minTotal[right]+=x;\n			dist[left]+=x;\n			dist[right]+=x;\n			lazy[node]=0;\n		}\n		long query(int l,int r) {\n			return query(1,0,n-1,l,r);\n		}\n		long query(int node,int tl,int tr,int l,int r) {\n			if(r<tl || tr<l)\n				return INF;\n			if(tl>=l && tr<=r)\n				return minTotal[node];\n			int mid=tl+tr>>1,left=node<<1,right=left+1;\n			propagate(node);;\n			return Math.min(query(left,tl,mid,l,r), query(right,mid+1,tr,l,r));\n		}\n		\n	}\n	static class Scanner\n	{\n		BufferedReader br;\n		StringTokenizer st;\n		Scanner(){\n			br=new BufferedReader(new InputStreamReader(System.in));\n		}\n		Scanner(String fileName) throws FileNotFoundException{\n			br=new BufferedReader(new FileReader(fileName));\n		}\n		String next() throws IOException {\n			while(st==null || !st.hasMoreTokens())\n				st=new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n		String nextLine() throws IOException {\n			return br.readLine();\n		}\n		int nextInt() throws IOException{\n			return Integer.parseInt(next());\n		}\n		long nextLong()  throws NumberFormatException, IOException {\n			return Long.parseLong(next());\n		}\n		double nextDouble() throws NumberFormatException, IOException {\n			return Double.parseDouble(next());\n		}\n	}\n}\n","data structures,dfs and similar,trees"
"import java.io.*;\nimport java.util.*;\n \npublic class Main{\n	static long INF=(long)1e18;\n	static int n;\n	static int []tin,tout,back,atTime;\n	static long []dist1;\n	static int timer;\n	static ArrayList<edge>[]adj;\n	static void dfs(int u,long d)\n	{\n		atTime[timer]=u;\n		dist1[u]=d;\n		tin[u]=timer++;\n		\n		for(edge nxt:adj[u])\n			dfs(nxt.v,d+nxt.c);\n		tout[u]=timer-1;\n	}\n	static boolean isAnc(int u,int v) {\n		return tin[v]>=tin[u] && tout[v]<=tout[u];\n	}\n	\n	public static void main(String[] args) throws IOException {\n		Scanner sc=new Scanner();\n		PrintWriter out=new PrintWriter(System.out);\n		n=sc.nextInt();\n		int q=sc.nextInt();\n		adj=new ArrayList[n];\n		for(int i=0;i<n;i++)\n			adj[i]=new ArrayList();\n		\n		int []to=new int [2*n],cost=new int [n];\n		for(int i=1;i<n;i++)\n		{\n			int u=sc.nextInt()-1,v=sc.nextInt()-1,c=sc.nextInt();\n			adj[u].add(new edge(v,c));\n			to[i]=v;\n			cost[i]=c;\n		}\n		back=new int [n];\n		for(int i=1;i<n;i++)\n		{\n			int u=sc.nextInt()-1,v=sc.nextInt()-1,c=sc.nextInt();\n			back[u]=c;\n			to[i+n-1]=u;\n		}\n		tin=new int [n];\n		tout=new int [n];\n		atTime=new int [n];\n		dist1=new long [n];\n		dfs(0,0);\n		\n		SegmentTree tree=new SegmentTree();\n		while(q-->0) {\n			if(sc.nextInt()==1)\n			{\n				int idx=sc.nextInt(),w=sc.nextInt();\n				if(idx>=n)\n				{\n					tree.updatePoint(to[idx], w);\n				}\n				else\n				{\n					int v=to[idx];\n					int change=w-cost[idx];\n					cost[idx]=w;\n					tree.updateRange(tin[v], tout[v], change);\n				}\n				\n			}\n			else\n			{\n				int u=sc.nextInt()-1,v=sc.nextInt()-1;\n				long ans=tree.queryPoint(v)-tree.queryPoint(u);\n				if(!isAnc(u,v)) \n					ans+=tree.query(tin[u], tout[u]);\n				\n				out.println(ans);\n			}\n		}\n		\n		out.close();\n \n	}\n	static class edge\n	{\n		int v,c;\n		edge(int y,int z){\n			\n			v=y;\n			c=z;\n		}\n	}\n	static class SegmentTree\n	{\n		long []lazy,dist,minTotal;\n		SegmentTree()\n		{\n			lazy=new long [4*n];\n			dist=new long [4*n];\n			minTotal=new long [4*n];\n			build(1,0,n-1);\n		}\n		void build(int node, int tl,int tr) {\n			if(tl==tr)\n			{\n				dist[node]=dist1[atTime[tl]];\n				minTotal[node]=dist[node]+back[atTime[tl]];\n			}\n			else\n			{\n				int mid=tl+tr>>1,left=node<<1,right=left+1;\n				build(left,tl,mid);\n				build(right,mid+1,tr);\n				minTotal[node]=Math.min(minTotal[left], minTotal[right]);\n			}\n		}\n		void updatePoint(int idx,int newBack)\n		{\n			back[idx]=newBack;\n			updatePoint(1,0,n-1,tin[idx]);\n		}\n		void updatePoint(int node,int tl,int tr,int idx)\n		{\n			if(tl==tr)\n				minTotal[node]=dist[node]+back[atTime[idx]];\n			else\n			{\n				int mid=tl+tr>>1,left=node<<1,right=left+1;\n				propagate(node);\n				if(idx<=mid)\n					updatePoint(left,tl,mid,idx);\n				else\n					updatePoint(right,mid+1,tr,idx);\n				minTotal[node]=Math.min(minTotal[left], minTotal[right]);\n \n		\n			}\n		}\n		void updateRange(int l,int r,int change)\n		{\n			updateRange(1,0,n-1,l,r,change);\n		}\n		void updateRange(int node,int tl,int tr,int l,int r,int change) {\n			if(r<tl || tr<l)\n				return ;\n			if(tl>=l && tr<=r)\n			{\n				lazy[node]+=change;\n				minTotal[node]+=change;\n				dist[node]+=change;\n				return;\n			}\n			int mid=tl+tr>>1,left=node<<1,right=left+1;\n			propagate(node);;\n			updateRange(left,tl,mid,l,r,change);\n			updateRange(right,mid+1,tr,l,r,change);\n			minTotal[node]=Math.min(minTotal[left], minTotal[right]);\n \n		}\n		long queryPoint(int u) {\n			return queryPoint(1,0,n-1,tin[u]);\n		}\n		long queryPoint(int node,int tl,int tr,int idx) {\n			if(tl==tr)\n				return dist[node];\n			int mid=tl+tr>>1,left=node<<1,right=left+1;\n			propagate(node);\n			if(idx<=mid)\n				return queryPoint(left,tl,mid,idx);\n			else\n				return queryPoint(right,mid+1,tr,idx);\n			\n		}\n		void propagate(int node) {\n			int left=node<<1,right=left+1;\n			long x=lazy[node];\n			lazy[left]+=x;\n			lazy[right]+=x;\n			minTotal[left]+=x;\n			minTotal[right]+=x;\n			dist[left]+=x;\n			dist[right]+=x;\n			lazy[node]=0;\n		}\n		long query(int l,int r) {\n			return query(1,0,n-1,l,r);\n		}\n		long query(int node,int tl,int tr,int l,int r) {\n			if(r<tl || tr<l)\n				return INF;\n			if(tl>=l && tr<=r)\n				return minTotal[node];\n			int mid=tl+tr>>1,left=node<<1,right=left+1;\n			propagate(node);;\n			return Math.min(query(left,tl,mid,l,r), query(right,mid+1,tr,l,r));\n		}\n		\n	}\n	static class Scanner\n	{\n		BufferedReader br;\n		StringTokenizer st;\n		Scanner(){\n			br=new BufferedReader(new InputStreamReader(System.in));\n		}\n		Scanner(String fileName) throws FileNotFoundException{\n			br=new BufferedReader(new FileReader(fileName));\n		}\n		String next() throws IOException {\n			while(st==null || !st.hasMoreTokens())\n				st=new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n		String nextLine() throws IOException {\n			return br.readLine();\n		}\n		int nextInt() throws IOException{\n			return Integer.parseInt(next());\n		}\n		long nextLong()  throws NumberFormatException, IOException {\n			return Long.parseLong(next());\n		}\n		double nextDouble() throws NumberFormatException, IOException {\n			return Double.parseDouble(next());\n		}\n	}\n}","data structures,dfs and similar,trees"
"import java.util.*;\npublic class Main\n{\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n =sc.nextInt();\n		String s = sc.nextLine();\n		s = sc.nextLine();\n		int c=0,max=0;\n		for(int i=0;i<s.length();i++)\n		{\n			if(s.charAt(i)!=' ') { if(s.charAt(i)>='A' && s.charAt(i)<='Z') c++;}\n			else {max = Math.max(max, c); c=0;}\n		}\n		max = Math.max(max, c);\n		System.out.println(max);\n	}\n}",implementation
\nimport java.util.*;\npublic class A {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner sc=new Scanner(System.in);\n		String n=sc.nextLine();\n		String s=sc.nextLine();\n		int res=0; int max=0;\n		for (int i=0;i<s.length();i++) {\n			if (s.charAt(i)==' ') {\n				if (max<res) max=res;\n				res=0;\n			}\n			if (s.charAt(i)>='A' && s.charAt(i)<='Z') res++;\n		}\n		if (max<res) max=res;\n		System.out.print(max);\n	}\n\n}\n,implementation
import java.util.*;\npublic class TextVolume {\n	public static void main(String[] args) {\n		Scanner S= new Scanner(System.in);\n		int n=S.nextInt();int curr=0;int tem=0;\n		while(S.hasNext()) {\n			String s=S.next();\n			tem=tem+s.length()+1;\n			int max=0;\n			for(int i=0;i<s.length();i++) {\n				if(Character.isUpperCase(s.charAt(i))) {\n					max++;\n				}\n			}\n			if(max>curr) {\n				curr=max;\n			}\n			if(tem>=n) {\n				break;\n			}\n		}\n		System.out.println(curr);\n	}\n}\n,implementation
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main {\n	public static void main (String[] args) {\n		Scanner in = new Scanner(System.in);\n		int n = Integer.parseInt(in.nextLine());\n		String str = in.nextLine();\n		String[] words = str.split("" "");\n		int top = -1;\n		for (String word : words) {\n			int count = 0;\n			for (char character : word.toCharArray())\n				if (character < 97) ++count;\n			top = Math.max(count, top);\n		}\n		System.out.println(top);\n	}\n}",implementation
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        static final long MODULO = (long) (1e9 + 7);\n        long res = 1;\n        int n;\n\n        private long pow(long a, long k) {\n            if (k == 0) return 1;\n            if (k % 2 == 0) {\n                return pow(a * a % MODULO, k / 2);\n            }\n            return a * pow(a, k - 1) % MODULO;\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            n = in.nextInt();\n            Vertex[] vs = new Vertex[n];\n            for (int i = 0; i < n; ++i) {\n                vs[i] = new Vertex();\n            }\n            for (int i = 0; i < n - 1; ++i) {\n                Vertex a = vs[in.nextInt() - 1];\n                Vertex b = vs[in.nextInt() - 1];\n                long value = in.nextLong();\n                int color = in.nextInt();\n                a.adj.add(new Edge(b, color, value));\n                b.adj.add(new Edge(a, color, value));\n            }\n\n            Vertex root = vs[0];\n            root.subtreeSizes(null);\n            int[] colorCosts = new int[]{2, -1};\n            root.countNegative(null, colorCosts);\n            colorCosts = new int[]{-1, 2};\n            root.countNegative(null, colorCosts);\n            res = inv(res);\n            root.countAll(null);\n            out.println(res % MODULO);\n        }\n\n        private long inv(long res) {\n            return pow(res, MODULO - 2);\n        }\n\n        class Edge {\n            Vertex dest;\n            int color;\n            long value;\n\n            public Edge(Vertex dest, int color, long value) {\n                this.dest = dest;\n                this.color = color;\n                this.value = value;\n            }\n\n        }\n\n        class PathCollection {\n            int minCost = 0;\n            long extraProd = 1;\n            long[] prods = new long[]{1};\n            int[] counts = new int[]{1};\n            long[] prodsFenwick = new long[]{1};\n            int[] countsFenwick = new int[]{1};\n\n            public void expand() {\n                int size = counts.length;\n                int extra = (size + 1) / 2;\n                long[] nprods = new long[size + 2 * extra];\n                Arrays.fill(nprods, 1);\n                int[] ncounts = new int[size + 2 * extra];\n                System.arraycopy(prods, 0, nprods, extra, prods.length);\n                System.arraycopy(counts, 0, ncounts, extra, counts.length);\n                counts = ncounts;\n                prods = nprods;\n                rebuildCountsFenwick();\n                rebuildProdsFenwick();\n                minCost -= extra;\n            }\n\n            private void rebuildProdsFenwick() {\n                prodsFenwick = new long[prods.length];\n                Arrays.fill(prodsFenwick, 1);\n                for (int i = 0; i < prods.length; ++i) {\n                    prodsFenwickUpd(i, prods[i]);\n                }\n            }\n\n            private void prodsFenwickUpd(int at, long by) {\n                if (by == 1) return;\n                while (at < prodsFenwick.length) {\n                    prodsFenwick[at] = (prodsFenwick[at] * by) % MODULO;\n                    at |= at + 1;\n                }\n            }\n\n            private void rebuildCountsFenwick() {\n                countsFenwick = new int[counts.length];\n                for (int i = 0; i < counts.length; ++i) {\n                    countsFenwickUpd(i, counts[i]);\n                }\n            }\n\n            private void countsFenwickUpd(int at, int by) {\n                if (by == 0) return;\n                while (at < countsFenwick.length) {\n                    countsFenwick[at] += by;\n                    at |= at + 1;\n                }\n            }\n\n            public void updateResult(int cost, int count, long prod) {\n                if (count == 0) {\n                    if (prod != 1) throw new RuntimeException();\n                    return;\n                }\n                int lessThan = Math.min(-cost - minCost - 1, counts.length - 1);\n                int cnt = countsFenwickGet(lessThan);\n                long prd = prodsFenwickGet(lessThan);\n                if (cnt > 0) {\n                    prd = prd * pow(extraProd, cnt) % MODULO;\n                    res = res * pow(prd, count) % MODULO * pow(prod, cnt) % MODULO;\n                }\n            }\n\n            public void update(int cost, int count, long prod) {\n                if (count == 0) {\n                    if (prod != 1) throw new RuntimeException();\n                    return;\n                }\n                while (minCost > cost || minCost + counts.length - 1 < cost) {\n                    expand();\n                }\n                prod = prod * pow(inv(extraProd), count) % MODULO;\n                counts[cost - minCost] += count;\n                prods[cost - minCost] = prods[cost - minCost] * prod % MODULO;\n                countsFenwickUpd(cost - minCost, count);\n                prodsFenwickUpd(cost - minCost, prod);\n            }\n\n            private long prodsFenwickGet(int at) {\n                long res = 1;\n                while (at >= 0) {\n                    res = res * prodsFenwick[at] % MODULO;\n                    at = (at & (at + 1)) - 1;\n                }\n                return res;\n            }\n\n            private int countsFenwickGet(int at) {\n                int res = 0;\n                while (at >= 0) {\n                    res += countsFenwick[at];\n                    at = (at & (at + 1)) - 1;\n                }\n                return res;\n            }\n\n        }\n\n        class Vertex {\n            List<Edge> adj = new ArrayList<>();\n            int subtreeSize;\n\n            public void subtreeSizes(Vertex parent) {\n                subtreeSize = 1;\n                for (Edge e : adj)\n                    if (e.dest != parent) {\n                        e.dest.subtreeSizes(this);\n                        subtreeSize += e.dest.subtreeSize;\n                    }\n            }\n\n            public void countAll(Vertex parent) {\n                for (Edge e : adj)\n                    if (e.dest != parent) {\n                        e.dest.countAll(this);\n                        int u = e.dest.subtreeSize;\n                        int v = n - u;\n                        res = res * pow(e.value, u * (long) v) % MODULO;\n                    }\n            }\n\n            public PathCollection countNegative(Vertex parent, int[] colorCosts) {\n                Vertex firstChild = null;\n                int firstColor = -1;\n                long firstValue = 0;\n                for (Edge e : adj)\n                    if (e.dest != parent) {\n                        if (firstChild == null || e.dest.subtreeSize > firstChild.subtreeSize) {\n                            firstChild = e.dest;\n                            firstColor = e.color;\n                            firstValue = e.value;\n                        }\n                    }\n                if (firstChild == null) {\n                    return new PathCollection();\n                }\n                PathCollection p = firstChild.countNegative(this, colorCosts);\n                p.minCost += colorCosts[firstColor];\n                p.extraProd = (p.extraProd * firstValue) % MODULO;\n                p.updateResult(0, 1, 1);\n                p.update(0, 1, 1);\n                for (Edge e : adj)\n                    if (e.dest != parent && e.dest != firstChild) {\n                        PathCollection q = e.dest.countNegative(this, colorCosts);\n                        q.minCost += colorCosts[e.color];\n                        q.extraProd = (q.extraProd * e.value) % MODULO;\n                        for (int i = 0; i < q.counts.length; ++i) {\n                            p.updateResult(q.minCost + i, q.counts[i], q.prods[i] * pow(q.extraProd, q.counts[i]) % MODULO);\n                        }\n                        for (int i = 0; i < q.counts.length; ++i) {\n                            p.update(q.minCost + i, q.counts[i], q.prods[i] * pow(q.extraProd, q.counts[i]) % MODULO);\n                        }\n                    }\n                return p;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n\n","data structures,divide and conquer,implementation,trees"
"//package round426;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class D {\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n	\n	static int mod = 1000000007;\n	\n	// 0418\n	\n	void solve()\n	{\n		int n = ni();\n		int[] from = new int[n - 1];\n		int[] to = new int[n - 1];\n		int[] w = new int[n-1];\n		int[] color = new int[n-1];\n		for (int i = 0; i < n - 1; i++) {\n			from[i] = ni() - 1;\n			to[i] = ni() - 1;\n			w[i] = ni();\n			color[i] = ni();\n		}\n		int[][][] g = packWU(n, from, to, w, color);\n		int[][] pars = parents(g, 0);\n		int[] par = pars[0], ord = pars[1], dep = pars[2];\n		\n		int[] cpar = buildCentroidTree(g);\n		CentroidTreeDistancePreordersSimple ctdps = dfsTopCTDPS(cpar, g);\n		long ans = 1;\n		for(int i = 0;i < n;i++){\n			long[] u = concatx(ctdps.gds[i]);\n			u[0] = 1;\n			ans = ans * go(u, concatx(ctdps.gdreds[i]), concatx(ctdps.gdblas[i]));\n			ans %= mod;\n			long div = 1;\n			for(int j = 0;j < ctdps.gds[i].length;j++){\n				long res = go(ctdps.gds[i][j], ctdps.gdreds[i][j], ctdps.gdblas[i][j]);\n				div = div * res % mod;\n			}\n			ans = ans * invl(div, mod) % mod;\n		}\n		out.println(ans);\n	}\n	\n	public static long invl(long a, long mod) {\n		long b = mod;\n		long p = 1, q = 0;\n		while (b > 0) {\n			long c = a / b;\n			long d;\n			d = a;\n			a = b;\n			b = d % b;\n			d = p;\n			p = q;\n			q = d - c * q;\n		}\n		return p < 0 ? p + mod : p;\n	}\n\n	\n	long go(long[] ds, int[] red, int[] black)\n	{\n//		tr(ds, red, black);\n		int n = ds.length;\n		long[][] es = new long[n][];\n		int maxv = 0, minv = 0;\n		for(int i = 0;i < n;i++){\n			es[i] = new long[]{2*red[i]-black[i], 2*black[i]-red[i], ds[i]};\n			maxv = Math.max(maxv, 2*black[i]-red[i]);\n			minv = Math.min(minv, 2*black[i]-red[i]);\n		}\n		Arrays.sort(es, new Comparator<long[]>() {\n			public int compare(long[] a, long[] b) {\n				return Long.compare(a[0], b[0]);\n			}\n		});\n		long[] ft = new long[maxv-minv + 5];\n		Arrays.fill(ft, 1);\n		\n		long ans = 1;\n		int p = n-1;\n		for(int i = 0;i < n;i++){\n			while(p >= 0 && es[p][0] + es[i][0] >= 0){\n				mulFenwick(ft, maxv-(int)es[p][1], es[p][2]);\n				p--;\n			}\n			ans = ans * prodFenwick(ft, Math.min(ft.length - 2, maxv+(int)es[i][1])) % mod;\n		}\n//		tr(""ans"", ans);\n\n		return ans;\n	}\n	\n	public static long prodFenwick(long[] ft, int i)\n	{\n		long sum = 1;\n		for(i++;i > 0;i -= i&-i){\n			sum = sum * ft[i] % mod;\n		}\n		return sum;\n	}\n	\n	public static void mulFenwick(long[] ft, int i, long v)\n	{\n		v %= mod;\n		if(v < 0)v += mod;\n		int n = ft.length;\n		for(i++;i < n;i += i&-i){\n			ft[i] = ft[i] * v % mod;\n		}\n	}\n\n	\n	static long[] concatx(long[]... s)\n	{\n		int n = 1;\n		for(long[] u : s)n += u.length;\n		long[] ret = new long[n];\n		n = 1;\n		for(long[] u : s){\n			System.arraycopy(u, 0, ret, n, u.length);\n			n += u.length;\n		}\n		return ret;\n	}\n	\n	static int[] concatx(int[]... s)\n	{\n		int n = 1;\n		for(int[] u : s)n += u.length;\n		int[] ret = new int[n];\n		n = 1;\n		for(int[] u : s){\n			System.arraycopy(u, 0, ret, n, u.length);\n			n += u.length;\n		}\n		return ret;\n	}\n	\n	public static class CentroidTreeDistancePreordersSimple\n	{\n		public int root; // root of centroid tree\n		public int[][] ctch; // centroid tree children\n		public long[][][] gds; // gds[sep][neckind][i]=(distances subject to separator sep + neckind)\n		public int[][][] gdreds; // gds[sep][neckind][i]=(distances subject to separator sep + neckind)\n		public int[][][] gdblas; // gds[sep][neckind][i]=(distances subject to separator sep + neckind)\n		public int[] dep; // depth of separator in centroid tree\n		public int[] neckind; // neck[x]=(y which gds[cpar[x]][y] represents distances of separator x's zone)\n	}\n	\n	public static int[][] parentToChildren(int[] par)\n	{\n		int n = par.length;\n		int[] ct = new int[n];\n		for(int i = 0;i < n;i++){\n			if(par[i] >= 0){\n				ct[par[i]]++;\n			}\n		}\n		int[][] g = new int[n][];\n		for(int i = 0;i < n;i++){\n			g[i] = new int[ct[i]];\n		}\n		for(int i = 0;i < n;i++){\n			if(par[i] >= 0){\n				g[par[i]][--ct[par[i]]] = i;\n			}\n		}\n		\n		return g;\n	}\n\n	\n	public CentroidTreeDistancePreordersSimple dfsTopCTDPS(int[] cpar, int[][][] g) {\n		int n = g.length;\n		int ctroot = -1;\n		for(int i = 0;i < n;i++)if(cpar[i] == -1)ctroot = i;\n		int[][] ctch = parentToChildren(cpar);\n		long I = Long.MAX_VALUE / 2;\n		int J = Integer.MAX_VALUE / 2;\n		long[] dd = new long[n];\n		Arrays.fill(dd, I);\n		int[] dredd = new int[n];\n		Arrays.fill(dredd, J);\n		int[] dblad = new int[n];\n		Arrays.fill(dblad, J);\n		long[][][] gds = new long[n][][];\n		int[][][] gdreds = new int[n][][];\n		int[][][] gdblas = new int[n][][];\n		int[] gdep = new int[n];\n		int[] gneckind = new int[n];\n		Arrays.fill(gneckind, -1);\n		dfs(ctroot, new boolean[n], \n				new long[n], new long[n][], dd, gds,\n				new int[n], new int[n][], dredd, gdreds,\n				new int[n], new int[n][], dblad, gdblas,\n				new int[n], new int[n], gneckind, gdep, g, ctch, cpar);\n		CentroidTreeDistancePreordersSimple ret = new CentroidTreeDistancePreordersSimple();\n		ret.gds = gds;\n		ret.gdreds = gdreds;\n		ret.gdblas = gdblas;\n		ret.ctch = ctch;\n		ret.dep = gdep;\n		ret.neckind = gneckind;\n		ret.root = ctroot;\n		return ret;\n	}\n	\n	private void dfs(int sep, boolean[] seps, \n			long[] ds, long[][] dss, long[] dd, long[][][] gds,\n			int[] dreds, int[][] dredss, int[] dredd, int[][][] gdreds,\n			int[] dblas, int[][] dblass, int[] dblad, int[][][] gdblas,\n			int[] stack, int[] inds, int[] gneckind, int[] gdep,\n			int[][][] g, int[][] ctch, int[] cpar)\n	{\n		long I = Long.MAX_VALUE / 2;\n		int J = Integer.MAX_VALUE / 2;\n		seps[sep] = true;\n		int neckp = 0;\n		for(int[] neck : g[sep]){\n			if(seps[neck[0]])continue;\n			int sp = 0;\n			inds[sp] = 0;\n			stack[sp++] = neck[0];\n			int gdp = 0;\n			dd[neck[0]] = neck[1];\n			dredd[neck[0]] = neck[2]^1;\n			dblad[neck[0]] = neck[2];\n			while(sp > 0){\n				int cur = stack[sp-1];\n				if(inds[sp-1] == 0){\n					if(cpar[cur] == sep)gneckind[cur] = neckp;\n					dreds[gdp] = dredd[cur];\n					dblas[gdp] = dblad[cur];\n					ds[gdp++] = dd[cur];\n				}\n				if(inds[sp-1] == g[cur].length){\n					sp--; \n					dd[cur] = I;\n					dredd[cur] = J;\n					dblad[cur] = J;\n					continue; \n				}\n				int[] e = g[cur][inds[sp-1]++];\n				if(!seps[e[0]] && dd[e[0]] == I){\n					dd[e[0]] = dd[cur] * e[1] % mod;\n					dredd[e[0]] = dredd[cur] + (e[2]^1);\n					dblad[e[0]] = dblad[cur] + (e[2]);\n					stack[sp] = e[0];\n					inds[sp] = 0;\n					sp++;\n				}\n			}\n			dredss[neckp] = Arrays.copyOf(dreds, gdp);\n			dblass[neckp] = Arrays.copyOf(dblas, gdp);\n			dss[neckp++] = Arrays.copyOf(ds, gdp);\n		}\n		gdreds[sep] = Arrays.copyOf(dredss, neckp);\n		gdblas[sep] = Arrays.copyOf(dblass, neckp);\n		gds[sep] = Arrays.copyOf(dss, neckp);\n		\n		for(int e : ctch[sep]){\n			gdep[e] = gdep[sep] + 1;\n			dfs(e, seps, \n					ds, dss, dd, gds,\n					dreds, dredss, dredd, gdreds,\n					dblas, dblass, dblad, gdblas,\n					stack, inds, gneckind, gdep, g, ctch, cpar);\n		}\n		seps[sep] = false;\n	}\n\n	\n	public static int[] buildCentroidTree(int[][][] g) {\n		int n = g.length;\n		int[] ctpar = new int[n];\n		Arrays.fill(ctpar, -1);\n		buildCentroidTree(g, 0, new boolean[n], new int[n], new int[n], new int[n], ctpar);\n		return ctpar;\n	}\n	\n	private static int buildCentroidTree(int[][][] g, int root, boolean[] sed, int[] par, int[] ord, int[] des, int[] ctpar)\n	{\n		// parent and level-order\n		ord[0] = root;\n		par[root] = -1;\n		int r = 1;\n		for(int p = 0;p < r;p++) {\n			int cur = ord[p];\n			for(int[] nex : g[cur]){\n				if(par[cur] != nex[0] && !sed[nex[0]]){\n					ord[r++] = nex[0];\n					par[nex[0]] = cur;\n				}\n			}\n		}\n		// if(r == 1)return;\n		\n		// DP and find a separator\n		int sep = -1; // always exists\n		outer:\n		for(int i = r-1;i >= 0;i--){\n			int cur = ord[i];\n			des[cur] = 1;\n			for(int[] e : g[cur]){\n				if(par[cur] != e[0] && !sed[e[0]])des[cur] += des[e[0]];\n			}\n			if(r-des[cur] <= r/2){\n				for(int[] e : g[cur]){\n					if(par[cur] != e[0] && !sed[e[0]] && des[e[0]] >= r/2+1)continue outer;\n				}\n				sep = cur;\n				break;\n			}\n		}\n		\n		sed[sep] = true;\n		for(int[] e : g[sep]){\n			if(!sed[e[0]])ctpar[buildCentroidTree(g, e[0], sed, par, ord, des, ctpar)] = sep;\n		}\n		return sep;\n	}\n\n	\n	public static int[][] parents(int[][][] g, int root) {\n		int n = g.length;\n		int[] par = new int[n];\n		Arrays.fill(par, -1);\n		int[] dw = new int[n];\n		int[] pw = new int[n];\n		int[] dep = new int[n];\n\n		int[] q = new int[n];\n		q[0] = root;\n		for (int p = 0, r = 1; p < r; p++) {\n			int cur = q[p];\n			for (int[] nex : g[cur]) {\n				if (par[cur] != nex[0]) {\n					q[r++] = nex[0];\n					par[nex[0]] = cur;\n					dep[nex[0]] = dep[cur] + 1;\n					dw[nex[0]] = dw[cur] + nex[1];\n					pw[nex[0]] = nex[1];\n				}\n			}\n		}\n		return new int[][] { par, q, dep, dw, pw };\n	}\n\n	\n	public static int[][][] packWU(int n, int[] from, int[] to, int[]... ws){ return packWU(n, from, to, from.length, ws); }\n	public static int[][][] packWU(int n, int[] from, int[] to, int sup, int[]... ws)\n	{\n		int[][][] g = new int[n][][];\n		int[] p = new int[n];\n		for(int i = 0;i < sup;i++)p[from[i]]++;\n		for(int i = 0;i < sup;i++)p[to[i]]++;\n		for(int i = 0;i < n;i++)g[i] = new int[p[i]][ws.length+1];\n		for(int i = 0;i < sup;i++){\n			--p[from[i]];\n			g[from[i]][p[from[i]]][0] = to[i];\n			for(int j = 0;j < ws.length;j++)g[from[i]][p[from[i]]][j+1] = ws[j][i];\n			--p[to[i]];\n			g[to[i]][p[to[i]]][0] = from[i];\n			for(int j = 0;j < ws.length;j++)g[to[i]][p[to[i]]][j+1] = ws[j][i];\n		}\n		return g;\n	}\n\n	public static int[][] parents3(int[][] g, int root) {\n		int n = g.length;\n		int[] par = new int[n];\n		Arrays.fill(par, -1);\n\n		int[] depth = new int[n];\n		depth[0] = 0;\n\n		int[] q = new int[n];\n		q[0] = root;\n		for (int p = 0, r = 1; p < r; p++) {\n			int cur = q[p];\n			for (int nex : g[cur]) {\n				if (par[cur] != nex) {\n					q[r++] = nex;\n					par[nex] = cur;\n					depth[nex] = depth[cur] + 1;\n				}\n			}\n		}\n		return new int[][] { par, q, depth };\n	}\n\n	static int[][] packU(int n, int[] from, int[] to) {\n		int[][] g = new int[n][];\n		int[] p = new int[n];\n		for (int f : from)\n			p[f]++;\n		for (int t : to)\n			p[t]++;\n		for (int i = 0; i < n; i++)\n			g[i] = new int[p[i]];\n		for (int i = 0; i < from.length; i++) {\n			g[from[i]][--p[from[i]]] = to[i];\n			g[to[i]][--p[to[i]]] = from[i];\n		}\n		return g;\n	}\n\n	\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new D().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n	\n	private char[][] nm(int n, int m)\n	{\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n	\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n	\n	private int ni()\n	{\n		int num = 0, b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","data structures,divide and conquer,implementation,trees"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            DRedBlackCobweb solver = new DRedBlackCobweb();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class DRedBlackCobweb {\n        Modular mod = new Modular(1e9 + 7);\n        Power power = new Power(mod);\n        int fix = 250000;\n        Debug debug = new Debug(true);\n        IntegerBIT add = new IntegerBIT(fix * 2);\n        IntegerBIT sub = new IntegerBIT(fix * 2);\n        int ans = 1;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            Node[] nodes = new Node[n];\n            for (int i = 0; i < n; i++) {\n                nodes[i] = new Node();\n                nodes[i].id = i;\n            }\n            for (int i = 0; i < n - 1; i++) {\n                Node u = nodes[in.readInt() - 1];\n                Node v = nodes[in.readInt() - 1];\n                int x = in.readInt();\n                int c = in.readInt();\n\n                Edge edge = new Edge();\n                edge.a = u;\n                edge.b = v;\n                edge.w = x;\n                if (c == 0) {\n                    edge.c0 = 1;\n                } else {\n                    edge.c1 = 1;\n                }\n\n                u.adj.add(edge);\n                v.adj.add(edge);\n            }\n\n            dac(nodes[0]);\n            out.println(ans);\n        }\n\n        public void dfsForSize(Node root, Node p) {\n            root.size = 1;\n            for (Edge e : root.adj) {\n                Node node = e.other(root);\n                if (node == p) {\n                    continue;\n                }\n                dfsForSize(node, root);\n                root.size += node.size;\n            }\n        }\n\n        public Node dfsForCentroid(Node root, Node p, int total) {\n            int max = total - root.size;\n            for (Edge e : root.adj) {\n                Node node = e.other(root);\n                if (node == p) {\n                    continue;\n                }\n                Node ans = dfsForCentroid(node, root, total);\n                if (ans != null) {\n                    return ans;\n                }\n                max = Math.max(max, node.size);\n            }\n\n            if (max * 2 <= total) {\n                return root;\n            }\n            return null;\n        }\n\n        public void dfsForAns(Node root, Node p, int a, int b, int prod) {\n            int exp = mod.subtract(add.query(2 * a - b + fix), sub.query(a - 2 * b - 1 + fix));\n            ans = mod.mul(ans, power.pow(prod, exp));\n            for (Edge e : root.adj) {\n                Node node = e.other(root);\n                if (node == p) {\n                    continue;\n                }\n                dfsForAns(node, root, a + e.c0, b + e.c1, mod.mul(prod, e.w));\n            }\n        }\n\n        public void dfsForModify(Node root, Node p, int a, int b, int x) {\n            add.update(b - 2 * a + fix, x);\n            sub.update(b * 2 - a + fix, x);\n            for (Edge e : root.adj) {\n                Node node = e.other(root);\n                if (node == p) {\n                    continue;\n                }\n                dfsForModify(node, root, a + e.c0, b + e.c1, x);\n            }\n        }\n\n        public void dac(Node root) {\n            dfsForSize(root, null);\n            root = dfsForCentroid(root, null, root.size);\n            debug.debug(""root"", root);\n            add.update(0 + fix, 1);\n            sub.update(0 + fix, 1);\n\n            for (int i = 0; i < 2; i++) {\n                for (Edge e : root.adj) {\n                    Node node = e.other(root);\n                    dfsForAns(node, root, e.c0, e.c1, e.w);\n                    dfsForModify(node, root, e.c0, e.c1, 1);\n                }\n                for (Edge e : root.adj) {\n                    Node node = e.other(root);\n                    dfsForModify(node, root, e.c0, e.c1, -1);\n                }\n                if (i == 0) {\n                    SequenceUtils.reverse(root.adj);\n                    add.update(0 + fix, -1);\n                    sub.update(0 + fix, -1);\n                }\n            }\n            for (Edge e : root.adj) {\n                Node node = e.other(root);\n                node.adj.remove(e);\n                dac(node);\n            }\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static <T> void swap(List<T> data, int i, int j) {\n            T tmp = data.get(i);\n            data.set(i, data.get(j));\n            data.set(j, tmp);\n        }\n\n        public static <T> void reverse(List<T> data, int l, int r) {\n            while (l < r) {\n                swap(data, l, r);\n                l++;\n                r--;\n            }\n        }\n\n        public static <T> void reverse(List<T> data) {\n            reverse(data, 0, data.size() - 1);\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int subtract(int x, int y) {\n            return valueOf(x - y);\n        }\n\n        public String toString() {\n            return ""mod "" + m;\n        }\n\n    }\n\n    static class IntegerBIT {\n        private int[] data;\n        private int n;\n\n        public IntegerBIT(int n) {\n            this.n = n;\n            data = new int[n + 1];\n        }\n\n        public int query(int i) {\n            int sum = 0;\n            for (; i > 0; i -= i & -i) {\n                sum += data[i];\n            }\n            return sum;\n        }\n\n        public void update(int i, int mod) {\n            if (i <= 0) {\n                return;\n            }\n            for (; i <= n; i += i & -i) {\n                data[i] += mod;\n            }\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 1; i <= n; i++) {\n                builder.append(query(i) - query(i - 1)).append(' ');\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static class Power {\n        final Modular modular;\n\n        public Power(Modular modular) {\n            this.modular = modular;\n        }\n\n        public int pow(int x, int n) {\n            if (n == 0) {\n                return modular.valueOf(1);\n            }\n            long r = pow(x, n >> 1);\n            r = modular.valueOf(r * r);\n            if ((n & 1) == 1) {\n                r = modular.valueOf(r * x);\n            }\n            return (int) r;\n        }\n\n    }\n\n    static class Node {\n        List<Edge> adj = new ArrayList<>();\n        int id;\n        int size;\n\n        public String toString() {\n            return """" + id;\n        }\n\n    }\n\n    static class Edge {\n        Node a;\n        Node b;\n        int c0;\n        int c1;\n        int w;\n\n        Node other(Node x) {\n            return a == x ? b : a;\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n        static int[] empty = new int[0];\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public Debug debug(String name, Object x) {\n            return debug(name, x, empty);\n        }\n\n        public Debug debug(String name, Object x, int... indexes) {\n            if (offline) {\n                if (x == null || !x.getClass().isArray()) {\n                    out.append(name);\n                    for (int i : indexes) {\n                        out.printf(""[%d]"", i);\n                    }\n                    out.append(""="").append("""" + x);\n                    out.println();\n                } else {\n                    indexes = Arrays.copyOf(indexes, indexes.length + 1);\n                    if (x instanceof byte[]) {\n                        byte[] arr = (byte[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof short[]) {\n                        short[] arr = (short[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof boolean[]) {\n                        boolean[] arr = (boolean[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof char[]) {\n                        char[] arr = (char[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof int[]) {\n                        int[] arr = (int[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof float[]) {\n                        float[] arr = (float[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof double[]) {\n                        double[] arr = (double[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof long[]) {\n                        long[] arr = (long[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else {\n                        Object[] arr = (Object[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    }\n                }\n            }\n            return this;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n}\n\n","data structures,divide and conquer,implementation,trees"
"import java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n	static PrintWriter out;\n	static Reader in;\n	public static void main(String[] args) throws IOException {\n		input_output();\n		Main solver = new Main();\n		solver.solve();\n		out.close();\n		out.flush();\n	}\n\n	static long INF = (long)1e18;\n	static int MAXN = (int)4e5 + 5;\n	static int MOD = (int)1e9 + 7;\n	static int q, t, n, m, k;\n	static double pi = Math.PI;\n\n	void solve() throws IOException {\n		n = in.nextInt();\n		k = in.nextInt();\n\n		int[] arr = new int[n+1];\n		SegTree st = new SegTree(0, n, arr);\n		for (int i = 1; i <= n; i++) arr[i] = in.nextInt();\n\n		int[] left = new int[n+1],\n			  last = new int[n+1];\n		for (int i = 1; i <= n; i++) {\n			left[i] = last[arr[i]];\n			last[arr[i]] = i;\n		}\n\n		int[][] dp = new int[n+1][k+1];\n		for (int kk = 1; kk <= k; kk++) {\n			for (int i = 1; i <= n; i++) {\n				if (left[i] != 0) {\n					st.update(0, left[i]-1, -1);\n				}\n				st.update(0, i-1, 1);\n			}\n\n			for (int i = n; i >= 1; i--) {\n				dp[i][kk] = (int)st.query(0, i-1);\n\n				st.update(i, i, -dp[i][kk-1]+dp[i][kk]);\n				st.update(0, i-1, -1);\n				if (left[i] != 0) st.update(0, left[i]-1, 1);\n			}\n		}\n\n		out.println(dp[n][k]);\n	}\n\n	static class SegTree {\n		int leftmost, rightmost;\n		SegTree lChild, rChild;\n		long value;\n		long toProp;\n\n		public SegTree(int leftmost, int rightmost, int[] a) {\n			this.leftmost = leftmost;\n			this.rightmost = rightmost;\n			if (leftmost != rightmost) {\n				int mid = (leftmost + rightmost) / 2;\n				lChild = new SegTree(leftmost, mid, a);\n				rChild = new SegTree(mid + 1, rightmost, a);\n				recalc();\n			} else init_leaf(a[leftmost]);\n		}\n\n		public void init_leaf(int val) {\n			value = val;\n		}\n\n		public void recalc() {\n			value = Math.max(lChild.value, rChild.value);\n		}\n\n		public void prop() {\n			if (toProp == 0) {\n				return;\n			}\n\n			value += toProp;\n			if (leftmost != rightmost) {\n				lChild.toProp += toProp;\n				rChild.toProp += toProp;\n			}\n			toProp = 0;\n		}\n\n		public void pointUpdate(int position, int newValue) {\n			if (leftmost == rightmost) {\n				value = newValue;\n				return;\n			}\n\n			if (position <= lChild.rightmost) {\n				lChild.pointUpdate(position, newValue);\n			} else {\n				rChild.pointUpdate(position, newValue);\n			}\n			recalc();\n		}\n\n		public void update(int l, int r, int v) {\n			if (l <= leftmost && rightmost <= r) {\n				toProp += v;\n				prop();\n				return;\n			}\n			prop();\n			if (l > rightmost || r < leftmost) {\n				return;\n			}\n			lChild.update(l, r, v);\n			rChild.update(l, r, v);\n			recalc();\n		}\n\n		public long query(int l, int r) {\n			prop();\n			if (l <= leftmost && rightmost <= r) {\n				return value;\n			}\n			if (l > rightmost || r < leftmost) {\n				return 0;\n			}\n\n			return Math.max(lChild.query(l, r), rChild.query(l, r));\n		}\n	}\n\n	static class Reader {\n		private InputStream mIs;\n		private byte[] buf = new byte[1024];\n		private int curChar;\n		private int numChars;\n\n		public Reader() {\n			this(System.in);\n		}\n\n		public Reader(InputStream is) {\n			mIs = is;\n		}\n\n		public int read() {\n			if (numChars == -1) {\n				throw new InputMismatchException();\n\n			}\n			if (curChar >= numChars) {\n				curChar = 0;\n				try {\n					numChars = mIs.read(buf);\n				} catch (IOException e) {\n					throw new InputMismatchException();\n				}\n				if (numChars <= 0) {\n					return -1;\n				}\n			}\n			return buf[curChar++];\n		}\n\n		public String nextLine() {\n			int c = read();\n			while (isSpaceChar(c)) {\n				c = read();\n			}\n			StringBuilder res = new StringBuilder();\n			do {\n				res.appendCodePoint(c);\n				c = read();\n			} while (!isEndOfLine(c));\n			return res.toString();\n		}\n\n		public String next() {\n			int c = read();\n			while (isSpaceChar(c)) {\n				c = read();\n			}\n			StringBuilder res = new StringBuilder();\n			do {\n				res.appendCodePoint(c);\n				c = read();\n			} while (!isSpaceChar(c));\n			return res.toString();\n		}\n\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n\n		public long nextLong() {\n			int c = read();\n			while (isSpaceChar(c)) {\n				c = read();\n			}\n			int sgn = 1;\n			if (c == '-') {\n				sgn = -1;\n				c = read();\n			}\n			long res = 0;\n			do {\n				if (c < '0' || c > '9') {\n					throw new InputMismatchException();\n				}\n				res *= 10;\n				res += c - '0';\n				c = read();\n			} while (!isSpaceChar(c));\n			return res * sgn;\n		}\n\n		public int nextInt() {\n			int c = read();\n			while (isSpaceChar(c)) {\n				c = read();\n			}\n			int sgn = 1;\n			if (c == '-') {\n				sgn = -1;\n				c = read();\n			}\n			int res = 0;\n			do {\n				if (c < '0' || c > '9') {\n					throw new InputMismatchException();\n				}\n				res *= 10;\n				res += c - '0';\n				c = read();\n			} while (!isSpaceChar(c));\n			return res * sgn;\n		}\n\n		public boolean isSpaceChar(int c) {\n			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n		}\n\n		public boolean isEndOfLine(int c) {\n			return c == '\n' || c == '\r' || c == -1;\n		}\n\n	}\n	static void input_output() throws IOException {\n		File f = new File(""in.txt"");\n		if (f.exists() && !f.isDirectory()) {\n			in = new Reader(new FileInputStream(""in.txt""));\n		} else in = new Reader();\n		f = new File(""out.txt"");\n		if (f.exists() && !f.isDirectory()) {\n			out = new PrintWriter(new File(""out.txt""));\n		} else out = new PrintWriter(System.out);\n	}\n}","binary search,data structures,divide and conquer,dp,two pointers"
"import java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n	static PrintWriter out;\n	static Reader in;\n	public static void main(String[] args) throws IOException {\n		input_output();\n		Main solver = new Main();\n		solver.solve();\n		out.close();\n		out.flush();\n	}\n\n	static long INF = (long)1e18;\n	static int MAXN = (int)4e5 + 5;\n	static int MOD = (int)1e9 + 7;\n	static int q, t, n, m, k;\n	static double pi = Math.PI;\n\n	void solve() throws IOException {\n		n = in.nextInt();\n		k = in.nextInt();\n\n		int[] arr = new int[n+1];\n		SegTree st = new SegTree(0, n, arr);\n		for (int i = 1; i <= n; i++) arr[i] = in.nextInt();\n\n		int[] left = new int[n+1],\n			  last = new int[n+1];\n		for (int i = 1; i <= n; i++) {\n			left[i] = last[arr[i]];\n			last[arr[i]] = i;\n		}\n\n		int[] dp = new int[n+1],\n			  ndp;\n		for (int kk = 1; kk <= k; kk++) {\n			ndp = new int[n+1];\n			for (int i = 1; i <= n; i++) {\n				if (left[i] != 0) {\n					st.update(0, left[i]-1, -1);\n				}\n				st.update(0, i-1, 1);\n			}\n\n			for (int i = n; i >= 1; i--) {\n				ndp[i] = (int)st.query(0, i-1);\n\n				st.update(i, i, -dp[i]+ndp[i]);\n				st.update(0, i-1, -1);\n				if (left[i] != 0) st.update(0, left[i]-1, 1);\n			}\n			dp = ndp;\n		}\n\n		out.println(dp[n]);\n	}\n\n	static class SegTree {\n		int leftmost, rightmost;\n		SegTree lChild, rChild;\n		long value;\n		long toProp;\n\n		public SegTree(int leftmost, int rightmost, int[] a) {\n			this.leftmost = leftmost;\n			this.rightmost = rightmost;\n			if (leftmost != rightmost) {\n				int mid = (leftmost + rightmost) / 2;\n				lChild = new SegTree(leftmost, mid, a);\n				rChild = new SegTree(mid + 1, rightmost, a);\n				recalc();\n			} else init_leaf(a[leftmost]);\n		}\n\n		public void init_leaf(int val) {\n			value = val;\n		}\n\n		public void recalc() {\n			value = Math.max(lChild.value, rChild.value);\n		}\n\n		public void prop() {\n			if (toProp == 0) {\n				return;\n			}\n\n			value += toProp;\n			if (leftmost != rightmost) {\n				lChild.toProp += toProp;\n				rChild.toProp += toProp;\n			}\n			toProp = 0;\n		}\n\n		public void pointUpdate(int position, int newValue) {\n			if (leftmost == rightmost) {\n				value = newValue;\n				return;\n			}\n\n			if (position <= lChild.rightmost) {\n				lChild.pointUpdate(position, newValue);\n			} else {\n				rChild.pointUpdate(position, newValue);\n			}\n			recalc();\n		}\n\n		public void update(int l, int r, int v) {\n			if (l <= leftmost && rightmost <= r) {\n				toProp += v;\n				prop();\n				return;\n			}\n			prop();\n			if (l > rightmost || r < leftmost) {\n				return;\n			}\n			lChild.update(l, r, v);\n			rChild.update(l, r, v);\n			recalc();\n		}\n\n		public long query(int l, int r) {\n			prop();\n			if (l <= leftmost && rightmost <= r) {\n				return value;\n			}\n			if (l > rightmost || r < leftmost) {\n				return 0;\n			}\n\n			return Math.max(lChild.query(l, r), rChild.query(l, r));\n		}\n	}\n\n	static class Reader {\n		private InputStream mIs;\n		private byte[] buf = new byte[1024];\n		private int curChar;\n		private int numChars;\n\n		public Reader() {\n			this(System.in);\n		}\n\n		public Reader(InputStream is) {\n			mIs = is;\n		}\n\n		public int read() {\n			if (numChars == -1) {\n				throw new InputMismatchException();\n\n			}\n			if (curChar >= numChars) {\n				curChar = 0;\n				try {\n					numChars = mIs.read(buf);\n				} catch (IOException e) {\n					throw new InputMismatchException();\n				}\n				if (numChars <= 0) {\n					return -1;\n				}\n			}\n			return buf[curChar++];\n		}\n\n		public String nextLine() {\n			int c = read();\n			while (isSpaceChar(c)) {\n				c = read();\n			}\n			StringBuilder res = new StringBuilder();\n			do {\n				res.appendCodePoint(c);\n				c = read();\n			} while (!isEndOfLine(c));\n			return res.toString();\n		}\n\n		public String next() {\n			int c = read();\n			while (isSpaceChar(c)) {\n				c = read();\n			}\n			StringBuilder res = new StringBuilder();\n			do {\n				res.appendCodePoint(c);\n				c = read();\n			} while (!isSpaceChar(c));\n			return res.toString();\n		}\n\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n\n		public long nextLong() {\n			int c = read();\n			while (isSpaceChar(c)) {\n				c = read();\n			}\n			int sgn = 1;\n			if (c == '-') {\n				sgn = -1;\n				c = read();\n			}\n			long res = 0;\n			do {\n				if (c < '0' || c > '9') {\n					throw new InputMismatchException();\n				}\n				res *= 10;\n				res += c - '0';\n				c = read();\n			} while (!isSpaceChar(c));\n			return res * sgn;\n		}\n\n		public int nextInt() {\n			int c = read();\n			while (isSpaceChar(c)) {\n				c = read();\n			}\n			int sgn = 1;\n			if (c == '-') {\n				sgn = -1;\n				c = read();\n			}\n			int res = 0;\n			do {\n				if (c < '0' || c > '9') {\n					throw new InputMismatchException();\n				}\n				res *= 10;\n				res += c - '0';\n				c = read();\n			} while (!isSpaceChar(c));\n			return res * sgn;\n		}\n\n		public boolean isSpaceChar(int c) {\n			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n		}\n\n		public boolean isEndOfLine(int c) {\n			return c == '\n' || c == '\r' || c == -1;\n		}\n\n	}\n	static void input_output() throws IOException {\n		File f = new File(""in.txt"");\n		if (f.exists() && !f.isDirectory()) {\n			in = new Reader(new FileInputStream(""in.txt""));\n		} else in = new Reader();\n		f = new File(""out.txt"");\n		if (f.exists() && !f.isDirectory()) {\n			out = new PrintWriter(new File(""out.txt""));\n		} else out = new PrintWriter(System.out);\n	}\n}","binary search,data structures,divide and conquer,dp,two pointers"
"import java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class Main {\n	static PrintWriter out;\n	static Reader in;\n	public static void main(String[] args) throws IOException {\n		input_output();\n		Main solver = new Main();\n		solver.solve();\n		out.close();\n		out.flush();\n	}\n\n	static long INF = (long)1e18;\n	static int MAXN = (int)4e5 + 5;\n	static int MOD = (int)1e9 + 7;\n	static int q, t, n, m, k;\n	static double pi = Math.PI;\n\n	void solve() throws IOException {\n		n = in.nextInt();\n		k = in.nextInt();\n\n		int[] arr = new int[n+1];\n		SegTree st = new SegTree(0, n, arr);\n		for (int i = 1; i <= n; i++) arr[i] = in.nextInt();\n\n		int[] left = new int[n+1],\n			  last = new int[n+1];\n		for (int i = 1; i <= n; i++) {\n			left[i] = last[arr[i]];\n			last[arr[i]] = i;\n		}\n\n		int[] dp = new int[n+1],\n			  ndp = new int[n+1];\n		for (int kk = 1; kk <= k; kk++) {\n			Arrays.fill(ndp, 0);\n			for (int i = 1; i <= n; i++) {\n				if (left[i] != 0) {\n					st.update(0, left[i]-1, -1);\n				}\n				st.update(0, i-1, 1);\n			}\n\n			for (int i = n; i >= 1; i--) {\n				ndp[i] = (int)st.query(0, i-1);\n\n				st.update(i, i, -dp[i]+ndp[i]);\n				st.update(0, i-1, -1);\n				if (left[i] != 0) st.update(0, left[i]-1, 1);\n			}\n			for (int i = 0; i <= n; i++) dp[i] = ndp[i];\n		}\n\n		out.println(dp[n]);\n	}\n\n	static class SegTree {\n		int leftmost, rightmost;\n		SegTree lChild, rChild;\n		long value;\n		long toProp;\n\n		public SegTree(int leftmost, int rightmost, int[] a) {\n			this.leftmost = leftmost;\n			this.rightmost = rightmost;\n			if (leftmost != rightmost) {\n				int mid = (leftmost + rightmost) / 2;\n				lChild = new SegTree(leftmost, mid, a);\n				rChild = new SegTree(mid + 1, rightmost, a);\n				recalc();\n			} else init_leaf(a[leftmost]);\n		}\n\n		public void init_leaf(int val) {\n			value = val;\n		}\n\n		public void recalc() {\n			value = Math.max(lChild.value, rChild.value);\n		}\n\n		public void prop() {\n			if (toProp == 0) {\n				return;\n			}\n\n			value += toProp;\n			if (leftmost != rightmost) {\n				lChild.toProp += toProp;\n				rChild.toProp += toProp;\n			}\n			toProp = 0;\n		}\n\n		public void pointUpdate(int position, int newValue) {\n			if (leftmost == rightmost) {\n				value = newValue;\n				return;\n			}\n\n			if (position <= lChild.rightmost) {\n				lChild.pointUpdate(position, newValue);\n			} else {\n				rChild.pointUpdate(position, newValue);\n			}\n			recalc();\n		}\n\n		public void update(int l, int r, int v) {\n			if (l <= leftmost && rightmost <= r) {\n				toProp += v;\n				prop();\n				return;\n			}\n			prop();\n			if (l > rightmost || r < leftmost) {\n				return;\n			}\n			lChild.update(l, r, v);\n			rChild.update(l, r, v);\n			recalc();\n		}\n\n		public long query(int l, int r) {\n			prop();\n			if (l <= leftmost && rightmost <= r) {\n				return value;\n			}\n			if (l > rightmost || r < leftmost) {\n				return 0;\n			}\n\n			return Math.max(lChild.query(l, r), rChild.query(l, r));\n		}\n	}\n\n	static class Reader {\n		private InputStream mIs;\n		private byte[] buf = new byte[1024];\n		private int curChar;\n		private int numChars;\n\n		public Reader() {\n			this(System.in);\n		}\n\n		public Reader(InputStream is) {\n			mIs = is;\n		}\n\n		public int read() {\n			if (numChars == -1) {\n				throw new InputMismatchException();\n\n			}\n			if (curChar >= numChars) {\n				curChar = 0;\n				try {\n					numChars = mIs.read(buf);\n				} catch (IOException e) {\n					throw new InputMismatchException();\n				}\n				if (numChars <= 0) {\n					return -1;\n				}\n			}\n			return buf[curChar++];\n		}\n\n		public String nextLine() {\n			int c = read();\n			while (isSpaceChar(c)) {\n				c = read();\n			}\n			StringBuilder res = new StringBuilder();\n			do {\n				res.appendCodePoint(c);\n				c = read();\n			} while (!isEndOfLine(c));\n			return res.toString();\n		}\n\n		public String next() {\n			int c = read();\n			while (isSpaceChar(c)) {\n				c = read();\n			}\n			StringBuilder res = new StringBuilder();\n			do {\n				res.appendCodePoint(c);\n				c = read();\n			} while (!isSpaceChar(c));\n			return res.toString();\n		}\n\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n\n		public long nextLong() {\n			int c = read();\n			while (isSpaceChar(c)) {\n				c = read();\n			}\n			int sgn = 1;\n			if (c == '-') {\n				sgn = -1;\n				c = read();\n			}\n			long res = 0;\n			do {\n				if (c < '0' || c > '9') {\n					throw new InputMismatchException();\n				}\n				res *= 10;\n				res += c - '0';\n				c = read();\n			} while (!isSpaceChar(c));\n			return res * sgn;\n		}\n\n		public int nextInt() {\n			int c = read();\n			while (isSpaceChar(c)) {\n				c = read();\n			}\n			int sgn = 1;\n			if (c == '-') {\n				sgn = -1;\n				c = read();\n			}\n			int res = 0;\n			do {\n				if (c < '0' || c > '9') {\n					throw new InputMismatchException();\n				}\n				res *= 10;\n				res += c - '0';\n				c = read();\n			} while (!isSpaceChar(c));\n			return res * sgn;\n		}\n\n		public boolean isSpaceChar(int c) {\n			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n		}\n\n		public boolean isEndOfLine(int c) {\n			return c == '\n' || c == '\r' || c == -1;\n		}\n\n	}\n	static void input_output() throws IOException {\n		File f = new File(""in.txt"");\n		if (f.exists() && !f.isDirectory()) {\n			in = new Reader(new FileInputStream(""in.txt""));\n		} else in = new Reader();\n		f = new File(""out.txt"");\n		if (f.exists() && !f.isDirectory()) {\n			out = new PrintWriter(new File(""out.txt""));\n		} else out = new PrintWriter(System.out);\n	}\n}","binary search,data structures,divide and conquer,dp,two pointers"
"import java.io.*;\nimport java.util.*;\npublic class Main {\n	static class Node{\n		int l,r;\n		int add,sum;\n	}\n	static int ed,n,maxn=35010,q;\n	static Node[] tr=new Node[4*maxn];\n	static int[] f=new int[maxn];\n	static int[] a=new int[maxn];\n	static int[] lst=new int[maxn];\n	static void mkt(int k,int l,int r)throws IOException{\n		tr[k]=new Node();\n		tr[k].l=l;\n		tr[k].r=r;\n		if(l==r){\n			tr[k].sum=f[l];\n			return;\n		}\n		int mid=(l+r)>>1;\n		mkt(k<<1,l,mid);\n		mkt(k<<1|1,mid+1,r);\n		pushup(k);\n	}\n	static void pushup(int k){\n		tr[k].sum=Math.max(tr[k<<1].sum,tr[k<<1|1].sum);\n	}\n	static void pushdown(int k){\n		if(tr[k].add!=0){\n			tr[k<<1].add+=tr[k].add;\n			tr[k<<1|1].add+=tr[k].add;\n			tr[k<<1].sum+=tr[k].add;\n			tr[k<<1|1].sum+=tr[k].add;\n			tr[k].add=0;\n		}	\n	}\n	static void change(int k,int l,int r,int x){\n		if(tr[k].l==l&&tr[k].r==r){\n			tr[k].add+=x;\n			tr[k].sum+=x;\n			return;\n		}\n		pushdown(k);\n		int mid=(tr[k].l+tr[k].r)>>1;\n		if(r<=mid)change(k<<1,l,r,x);\n		else if(l>mid)change(k<<1|1,l,r,x);\n		else {\n			change(k<<1,l,mid,x);\n			change(k<<1|1,mid+1,r,x);\n		}\n		pushup(k);\n	}\n	static int getans(int k,int l,int r){\n		if(tr[k].l==l&&tr[k].r==r){\n			return tr[k].sum;\n		}\n		pushdown(k);\n		int mid=(tr[k].l+tr[k].r)>>1;\n		if(r<=mid)return getans(k<<1,l,r);\n		else if(l>mid) return getans(k<<1|1,l,r);\n		else return Math.max(getans(k<<1,l,mid),getans(k<<1|1,mid+1,r));\n	}\n	static StreamTokenizer in=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n	static PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out));\n	static int nextInt()throws IOException{\n		in.nextToken();\n		return (int)in.nval;\n	}\n	static String next()throws IOException{\n		in.nextToken();\n		return in.sval;\n	}\n	public static void main(String args[])throws IOException{\n		while(in.nextToken()!=in.TT_EOF){\n			n=(int)in.nval;\n			q=nextInt();	\n			for(int i=1;i<=n;i++){\n				a[i]=nextInt();\n			}\n			for(int t=1;t<=q;t++){\n				mkt(1,0,n);\n				for(int i=0;i<=n;i++){\n					f[i]=0;\n					lst[a[i]]=0;\n				}\n				for(int i=1;i<=n;i++){\n					change(1,lst[a[i]],i-1,1);\n					lst[a[i]]=i;\n					f[i]=getans(1,0,i-1);\n				}\n			}\n			out.println(f[n]);\n			out.flush();\n		}\n	}\n}\n 	 				 			 		  		 		  	 	 		","binary search,data structures,divide and conquer,dp,two pointers"
"import java.util.*;\npublic class Main {\n	public static void main(String[] args){\n		Scanner sc=new Scanner(System.in);\n		long a=sc.nextLong(),b=sc.nextLong();\n		String c = a/b%2==1?""YES"":""NO"";\n		System.out.println(c);\n	}\n}\n","games,math"
"\nimport java.util.*;\n\npublic class FEB3 {\n    public static void main(String[] args) {\n        Scanner rand = new Scanner(System.in);\n        System.out.print(((rand.nextLong() / rand.nextLong()) & 1 ) == 1 ? ""YES"" : ""NO"");\n             }\n         }","games,math"
"import java.util.*;\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        Long n=in.nextLong();\n        Long k=in.nextLong();\n        System.out.println(((n/k)%2==1)?""YES"":""NO"");\n    }\n}\n","games,math"
"import java.util.*;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		long a=sc.nextLong(),b=sc.nextLong();\n		long n=a/b;\n		if(n%2==0)\n			System.out.print(""NO"");\n		else\n			System.out.print(""YES"");\n	}\n}\n","games,math"
"import java.util.Scanner;\n\npublic class C {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner in = new Scanner(System.in);\n		\n		int a=in.nextInt();\n		int b=in.nextInt();\n		int l=in.nextInt();\n		int r=in.nextInt();\n		\n		\n		System.out.println(fun(a,b,l,r));\n		\n	}\n	\n	static int fun(int a,int b,int l,int r){\n		if ((r-l+1)>2*(a+b))\n			if (a<=b)\n				return a+1;\n			else\n				return (2*a-b);\n		\n		int[] flag = new int[3*(a+b)+1];\n		\n		int temp=0;\n		for (int i=1;i<=a;i++){\n			flag[i]=i;\n			temp=i;\n		}\n		\n		for (int i=a+1;i<=a+b;i++){\n			flag[i]=temp;\n		}\n		\n		for (int i=a+b+1;i<=a+b+a;i++){\n			int tc=1;\n			while (in(flag,tc,a+b-a+1,i-1))\n				tc++;\n			flag[i]=tc;\n			temp=flag[i];\n		}\n		for (int i=a+b+a+1;i<=a+b+a+b;i++){\n			flag[i]=temp;\n		}\n		for (int i=2*(a+b)+1;i<=3*(a+b);i++){\n			flag[i]=flag[i-(a+b)];\n		}\n		\n		int[] flagc = new int[25];\n		int templ = l % (a+b);\n		if (templ==0) templ+=a+b;\n		int tempr = r - l + templ;\n		if (tempr<templ) tempr+=a+b;\n		for (int i=templ;i<=tempr;i++){\n			flagc[flag[i]]=1;\n		}	\n		\n		int res=0;\n		for (int i=1;i<=24;i++)\n			res+=flagc[i];\n		\n		return res;\n		\n	}\n	\n	static boolean in(int[] a,int b,int l,int r){\n		for (int i=l;i<=r;i++){\n			if (a[i]==b)\n				return true;\n		}\n		return false;\n	}\n	\n\n}\n","games,greedy"
"import java.io.*;\nimport java.util.*;\n\npublic class CF819A {\n	static int count(int[] cc, int l, int r) {\n		boolean[] used = new boolean[24];\n		int cnt = 0;\n		for (int i = l; i <= r; i++) {\n			int c = cc[i];\n			if (!used[c]) {\n				used[c] = true;\n				cnt++;\n			}\n		}\n		return cnt;\n	}\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int a = Integer.parseInt(st.nextToken());\n		int b = Integer.parseInt(st.nextToken());\n		int l = Integer.parseInt(st.nextToken()) - 1;\n		int r = Integer.parseInt(st.nextToken()) - 1;\n		int ab = a + b;\n		int m = 4;	//	ab ab ab ab\n		int[] cc = new int[ab * m];\n		int h = l / ab;\n		l -= h * ab;\n		r -= h * ab;\n		h = (r - l + 1) / ab;\n		if (h > 2)\n			r -= (h - 2) * ab;\n		int d = a > b ? a - b : 1;\n		for (h = 0; h < m; h++) {\n			for (int k = 0; k < a - d; k++)\n				cc[(a + b) * h + k] = k;\n			for (int k = 0; k < d; k++)\n				cc[(a + b) * h + a - d + k] = h % 2 == 0 ? a - d + k : a + k;\n		}\n		int min = a + a;\n		for (int k0 = 1; k0 <= d; k0++) {\n			for (int k = 0; k < b; k++)\n				cc[(a + b) * 0 + a + k] = cc[(a + b) * 0 + a - k0];\n			for (int k1 = 1; k1 <= d; k1++) {\n				for (int k = 0; k < b; k++)\n					cc[(a + b) * 1 + a + k] = cc[(a + b) * 1 + a - k1];\n				for (int k2 = 1; k2 <= d; k2++) {\n					for (int k = 0; k < b; k++)\n						cc[(a + b) * 2 + a + k] = cc[(a + b) * 2 + a - k2];\n					for (int k3 = 1; k3 <= d; k3++) {\n						for (int k = 0; k < b; k++)\n							cc[(a + b) * 3 + a + k] = cc[(a + b) * 3 + a - k3];\n						min = Math.min(min, count(cc, l, r));\n					}\n				}\n			}\n		}\n		System.out.println(min);\n	}\n}\n","games,greedy"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class Div2_421C {\n\n	public static void main(String[] args) throws IOException {\n		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer inputData = new StringTokenizer(reader.readLine());\n		int a = Integer.parseInt(inputData.nextToken());\n		int b = Integer.parseInt(inputData.nextToken());\n		long l = Long.parseLong(inputData.nextToken());\n		long r = Long.parseLong(inputData.nextToken());\n\n		if (r - l + 1 >= 2 * (a + b)) {\n			if (a <= b) {\n				System.out.println(a + 1);\n			} else {\n				System.out.println(2 * a - b);\n			}\n			return;\n		}\n\n		StringBuilder cString = new StringBuilder();\n		for (int i = 0; i < a; i++) {\n			cString.append((char) ('a' + i));\n		}\n\n		l--;\n		r--;\n\n		TreeSet<Integer> used = new TreeSet<Integer>();\n\n		\n		int ans = 26;\n		for (int first = 0; first < 26; first++) {\n			for (int second = a; second < 26; second++) {\n				for (int i = 0; i < b; i++) {\n					cString.append((char)('a' + first));\n				}\n				used.clear();\n				for (char c : cString.substring(cString.length() - a, cString.length()).toCharArray()) {\n					used.add(c - 'a');\n				}\n				int nxt = 0;\n				for (int i = 0; i < a; i++) {\n					while (used.contains(nxt)) {\n						nxt++;\n					}\n					cString.append((char) ('a' + nxt));\n					nxt++;\n				}\n				for (int i = 0; i < b; i++) {\n					cString.append((char)('a' + second));\n				}\n\n				int len = cString.length();\n\n				used.clear();\n				for (int i = (int) (l % len); i != (r + 1) % len; i = (i + 1) % len) {\n					used.add(cString.charAt(i) - 'a');\n				}\n				if(used.size() < ans){\n					ans = used.size();\n				}\n				cString.delete(a, cString.length());\n			}\n		}\n\n		System.out.println(ans);\n	}\n\n}","games,greedy"
"\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class A819 {\n	static int count(int[] cc, int l, int r) {\n		boolean[] used = new boolean[24];\n		int cnt = 0;\n		for (int i = l; i <= r; i++) {\n			int c = cc[i];\n			if (!used[c]) {\n				used[c] = true;\n				cnt++;\n			}\n		}\n		return cnt;\n	}\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int a = Integer.parseInt(st.nextToken());\n		int b = Integer.parseInt(st.nextToken());\n		int l = Integer.parseInt(st.nextToken()) - 1;\n		int r = Integer.parseInt(st.nextToken()) - 1;\n		int ab = a + b;\n		int m = 4;	//	ab ab ab ab\n		int[] cc = new int[ab * m];\n		int h = l / ab;\n		l -= h * ab;\n		r -= h * ab;\n		h = (r - l + 1) / ab;\n		if (h > 2)\n			r -= (h - 2) * ab;\n		int d = a > b ? a - b : 1;\n		for (h = 0; h < m; h++) {\n			for (int k = 0; k < a - d; k++)\n				cc[(a + b) * h + k] = k;\n			for (int k = 0; k < d; k++)\n				cc[(a + b) * h + a - d + k] = h % 2 == 0 ? a - d + k : a + k;\n		}\n		int min = a + a;\n		for (int k0 = 1; k0 <= d; k0++) {\n			for (int k = 0; k < b; k++)\n				cc[(a + b) * 0 + a + k] = cc[(a + b) * 0 + a - k0];\n			for (int k1 = 1; k1 <= d; k1++) {\n				for (int k = 0; k < b; k++)\n					cc[(a + b) * 1 + a + k] = cc[(a + b) * 1 + a - k1];\n				for (int k2 = 1; k2 <= d; k2++) {\n					for (int k = 0; k < b; k++)\n						cc[(a + b) * 2 + a + k] = cc[(a + b) * 2 + a - k2];\n					for (int k3 = 1; k3 <= d; k3++) {\n						for (int k = 0; k < b; k++)\n							cc[(a + b) * 3 + a + k] = cc[(a + b) * 3 + a - k3];\n						min = Math.min(min, count(cc, l, r));\n					}\n				}\n			}\n		}\n		System.out.println(min);\n	}\n}\n","games,greedy"
"import java.io.*;\nimport java.util.Arrays;\n \npublic class MulticoloredCars {\n	public static void main(String[] args) throws IOException{\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		String[] split = br.readLine().split("" "");\n		int n = Integer.parseInt(split[0]), a = Integer.parseInt(split[1]);\n		boolean[] g = new boolean[1000000]; Arrays.fill(g, true);\n		int[] freq = new int[1000000];\n		int max = 0, in = 0;\n		String[] s = br.readLine().split("" "");\n		for(int i = 0; i < n; i++) {\n			int temp = Integer.parseInt(s[i]);\n			if(freq[temp-1]>=freq[a-1]) {\n				freq[temp-1]++;\n				if(freq[temp-1]>max) {\n					max = freq[temp-1];\n					in = temp;\n				}\n				if(in==a) {\n					System.out.println(-1);\n					return;\n				}\n			}			\n		}\n		System.out.println(in);\n	}\n}\n			  		  	  	 				  				  	","data structures,implementation"
import java.util.*;\n\npublic class Solution\n{\n       public static void main(String []args)\n       {\n              Scanner sc = new Scanner(System.in);\n              int n = sc.nextInt();\n              int A = sc.nextInt();\n              int countA = 0;\n              int count[] = new int[1000001];\n              for(int i = 0 ; i < n ; i++)\n              {\n                     int x = sc.nextInt();\n                     if(x != A)\n                     {\n                            if(count[x] >= countA)\n                            count[x]++;\n                     }\n                     \n                     else\n                     countA++;\n              }\n              int color = -1;\n              for(int i = 1 ; i <= 1000000 ; i++)\n              {\n                     if(count[i] >= countA && i != A)\n                     {\n                           color = i;\n                           break;\n                     }\n              }\n              System.out.println(color);\n       }\n},"data structures,implementation"
"import java.math.BigInteger;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Pair{\n        int a;\n        int b;\n        Pair(int a,int b){\n            this.a=a;\n            this.b=b;\n        }\n    }\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n        FastReader() { br = new BufferedReader(new InputStreamReader(System.in)); }\n        String next() { while (st == null || !st.hasMoreElements()) {\n            try { st = new StringTokenizer(br.readLine()); }\n            catch (IOException e) { e.printStackTrace(); } }\n            return st.nextToken();\n        }\n\n        int nextInt() { return Integer.parseInt(next()); }\n        long nextLong() { return Long.parseLong(next()); }\n        double nextDouble() { return Double.parseDouble(next()); }\n\n        String nextLine() {\n            String str = """";\n            try { str = br.readLine(); }\n            catch (IOException e) { e.printStackTrace(); }\n            return str;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        FastReader ip = new FastReader();\n        OutputStream output = System.out;\n        PrintWriter out = new PrintWriter(output);\n        int n=ip.nextInt();\n        int x=ip.nextInt();\n        int[] arr=new int[n];\n        for(int i=0;i<n;i++){\n            arr[i]=ip.nextInt();\n        }\n        HashMap<Integer,Integer> hm=new HashMap<>();\n        int i=0;\n        HashSet<Integer> hs=new HashSet<>();\n        while(i<n && arr[i]!=x){\n            int c=hm.getOrDefault(arr[i],0);\n            hm.put(arr[i],c+1);\n            hs.add(arr[i]);\n            i++;\n        }\n        int c=1;\n        if(i+1<n) {\n            for (int j = i+1; j < n; j++) {\n                int val = arr[j];\n                if (val != x) {\n                    if (hs.contains(val)) {\n                        hm.put(val, hm.get(val) + 1);\n                    }\n                } else {\n                    c++;\n                    Iterator<Integer> itr = hs.iterator();\n                    while (itr.hasNext()) {\n                        if (hm.get(itr.next()) < c) {\n                            itr.remove();\n                        }\n                    }\n                }\n            }\n        }\n        int ans=-1;\n        for(Integer y:hs){\n                ans=y;\n                break;\n        }\n        out.print(ans);\n\n        out.close();\n    }\n}","data structures,implementation"
"import java.io.*;\nimport java.util.*;\n\npublic class tank {\n\n    static final FastScanner fs = new FastScanner();\n\n    //static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        int t = 1;\n        while(t-->0) {\n            run_case();\n        }\n\n        //out.close();\n    }\n\n    static void run_case() {\n        int n = fs.nextInt(), a = fs.nextInt();\n        int[] car = fs.readArray(n);\n\n        HashMap<Integer, Integer> hm = new HashMap<>();\n\n        int bob = -1, cnt = 0, ali = 0;\n\n        // 1 3 2 3 1 2 3 2 1 1 1 1\n\n        for (int i = 0; i < n; i++) {\n            if(car[i] == a) {\n                ali++;\n                if (ali > cnt) {\n                    System.out.println(-1);\n                    return;\n                }\n\n                continue;\n            }else if(ali > 1 && !hm.containsKey(car[i])) continue;\n\n            int cur;\n\n            if(!hm.containsKey(car[i])) {\n                hm.put(car[i], 1);\n                cur = 1;\n            }else{\n                cur = hm.get(car[i]) + 1;\n                hm.put(car[i], cur);\n            }\n\n            if(cur <= ali) {\n                hm.remove(car[i]);\n                continue;\n            }\n\n            if(cur > cnt) {\n                cnt = cur;\n                bob = car[i];\n            }\n        }\n\n        System.out.println(bob);\n    }\n\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer("""");\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        String nextLine(){\n            try {\n                return br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n            return """";\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readArray(int n) {\n            int[] a=new int[n];\n            for (int i=0; i<n; i++) a[i]=nextInt();\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}\n","data structures,implementation"
"import java.io.BufferedInputStream;\nimport java.util.*;\n\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(new BufferedInputStream(System.in));\n        int d = sc.nextInt();\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int left[] = new int[n + 5], right[] = new int[n + 5], top[] = new int[m + 5], bottom[] = new int[m + 5];\n\n        int x1[] = new int[d];\n        int x2[] = new int[d];\n        int y1[] = new int[d];\n        int y2[] = new int[d];\n\n        for (int i = 0; i < d; i++) {\n            x1[i] = sc.nextInt();\n            y1[i] = sc.nextInt();\n            x2[i] = sc.nextInt();\n            y2[i] = sc.nextInt();\n\n            left[Math.min(x1[i], x2[i])]++;\n            right[Math.max(x1[i], x2[i])]++;\n            top[Math.min(y1[i], y2[i])]++;\n            bottom[Math.max(y1[i], y2[i])]++;\n        }\n\n        for (int i = 1; i < n + 1; i++)\n            left[i] = left[i - 1] + left[i];\n        for (int i = n; i >= 1; i--)\n            right[i] = right[i + 1] + right[i];\n\n        for (int i = 1; i < m + 1; i++)\n            top[i] = top[i - 1] + top[i];\n        for (int i = m; i >= 1; i--)\n            bottom[i] = bottom[i + 1] + bottom[i];\n\n        int cnt_l = sc.nextInt();\n        int cnt_r = sc.nextInt();\n        int cnt_t = sc.nextInt();\n        int cnt_b = sc.nextInt();\n        int ans = 0;\n\n        for (int i = 0; i < d; i++) {\n            int cl, cr, ct, cb;\n\n            cl = left[Math.max(x1[i], x2[i]) - 1];\n            cr = right[Math.min(x1[i], x2[i]) + 1];\n            ct = top[Math.max(y1[i], y2[i]) - 1];\n            cb = bottom[Math.min(y1[i], y2[i]) + 1];\n            if (x1[i] != x2[i]) {\n                cl--;\n                cr--;\n            }\n            if (y1[i] != y2[i]) {\n                ct--;\n                cb--;\n            }\n            if (cnt_l == cl && cnt_b == cb && cnt_t == ct && cnt_r == cr)\n                ans = i + 1;\n        }\n        if (ans == 0)\n            System.out.print(""-1"");\n        else\n            System.out.print(ans);\n    }\n\n\n}","brute force,implementation"
"import java.io.*;\nimport java.util.*;\npublic class Main {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		InputReader in = new InputReader(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		A solver = new A();\n		solver.solve(1, in, out);\n		out.close();\n	}\n\n}\n\nclass A {\n	public void solve(int cas, InputReader in, PrintWriter out) {\n		int d = in.nextInt(), n = in.nextInt(), m = in.nextInt();\n		int[][] a = new int[100000][4], c = new int[4][100001];\n		for(int i = 0; i < d; ++i) {\n			for(int j = 0; j < 4; ++j) {\n				a[i][j] = in.nextInt();\n			}\n			if(a[i][0] > a[i][2]) {\n				int t = a[i][0]; a[i][0] = a[i][2]; a[i][2] = t;\n			}\n			if(a[i][1] > a[i][3]) {\n				int t = a[i][1]; a[i][1] = a[i][3]; a[i][3] = t;\n			}\n		}\n		for(int i = 0; i < d; ++i) {\n			for(int j = 0; j < 4; ++j) {\n				++c[j][a[i][j]];\n			}\n		}\n		for(int i = 0; i < 4; ++i) {\n			for(int j = 1; j <= 100000; ++j) c[i][j] += c[i][j-1];\n		}\n		int[] b = new int[4];\n		for(int i = 0; i < 4; ++i) b[i] = in.nextInt();\n		int ans = -1;\n		for(int i = 0; i < d; ++i) {\n			if(b[0] == c[0][a[i][2]-1] - (a[i][0] != a[i][2] ? 1 : 0)\n					&& b[1] == d - c[2][a[i][0]] - (a[i][0] != a[i][2] ? 1 : 0)\n					&& b[2] == c[1][a[i][3]-1] - (a[i][1] != a[i][3] ? 1 : 0)\n					&& b[3] == d - c[3][a[i][1]] - (a[i][1] != a[i][3] ? 1 : 0)) {\n				ans = i + 1;\n				break;\n			}\n//			for(int j = 0; j < 4; ++j) out.print(a[i][j] + "" "");\n//			out.println();\n//			out.println(c[0][a[i][2]-1] + "" "" + (d - c[2][a[i][0]]) + "" "" + c[1][a[i][3]-1] + "" "" + (d - c[3][a[i][1]]));\n		}\n		out.println(ans);\n	}\n}\n\nclass InputReader {\n	public BufferedReader reader;\n	public StringTokenizer tokenizer;\n	\n	public InputReader(InputStream stream) {\n		reader = new BufferedReader(new InputStreamReader(stream), 32768);\n		tokenizer = null;\n	}\n	\n	public String next() {\n		while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n			try {\n				tokenizer = new StringTokenizer(reader.readLine());\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n		}\n		return tokenizer.nextToken();\n	}\n	\n	public int nextInt() {\n		return Integer.parseInt(next());\n	}\n	\n	public Long nextLong() {\n		return Long.parseLong(next());\n	}\n}","brute force,implementation"
"import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main {\n\n    static Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\n    public static void main(String[] args) {\n        int d = input.nextInt();\n        int n = input.nextInt();\n        int m = input.nextInt();\n        int[] left = new int[n];\n        int[] right = new int[n];\n        int[] top = new int[m];\n        int[] buttom = new int[m];\n        int[] colR = new int[n];\n        int[] rowU = new int[m];\n        int[] colL = new int[n];\n        int[] rowD = new int[m];\n        int[][] c = new int[d][4];\n        for (int i = 0; i < d; i++) {\n            c[i][0] = input.nextInt();\n            c[i][1] = input.nextInt();\n            c[i][2] = input.nextInt();\n            c[i][3] = input.nextInt();\n            colR[Math.max(c[i][0] - 1, c[i][2] - 1)]++;\n            colL[Math.min(c[i][0] - 1, c[i][2] - 1)]++;\n            rowU[Math.min(c[i][1] - 1, c[i][3] - 1)]++;\n            rowD[Math.max(c[i][1] - 1, c[i][3] - 1)]++;\n        }\n        int l = input.nextInt();\n        int r = input.nextInt();\n        int t = input.nextInt();\n        int b = input.nextInt();\n\n        for (int i = 1; i < n; i++) {\n            left[i] = left[i - 1] + colL[i - 1];\n        }\n        for (int i = n - 2; i >= 0; i--) {\n            right[i] = right[i + 1] + colR[i + 1];\n        }\n        for (int i = 1; i < m; i++) {\n            top[i] = top[i - 1] + rowU[i - 1];\n        }\n        for (int i = m - 2; i >= 0; i--) {\n            buttom[i] = buttom[i + 1] + rowD[i + 1];\n        }\n\n        int cl = 0, cr = 0, ct = 0, cb = 0;\n        for (int i = 0; i < d; i++) {\n            if (c[i][0] == c[i][2]) {\n                cl = left[c[i][0] - 1];\n                cr = right[c[i][0] - 1];\n                ct = top[Math.max(c[i][1], c[i][3]) - 1] - 1;\n                cb = buttom[Math.min(c[i][1], c[i][3]) - 1] - 1;\n            }\n            if (c[i][1] == c[i][3]) {\n                cl = left[Math.max(c[i][0], c[i][2]) - 1] - 1;\n                cr = right[Math.min(c[i][0], c[i][2]) - 1] - 1;\n                ct = top[c[i][1] - 1];\n                cb = buttom[c[i][1] - 1];\n            }\n            if (cl == l && cr == r && ct == t && cb == b) {\n                System.out.println(i + 1);\n                return;\n            }\n        }\n        System.out.println(-1);\n    }\n}","brute force,implementation"
"import java.io.*;\nimport java.util.*;\n\npublic class CF818C {\n	static class V {\n		int i, x, y;\n		int l, r, t, b;\n		V(int i, int x1, int y1, int x2, int y2) {\n			this.i = i;\n			x = x1 + x2;\n			y = y1 + y2;\n		}\n	}\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		int d = Integer.parseInt(br.readLine());\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int n = Integer.parseInt(st.nextToken());\n		int m = Integer.parseInt(st.nextToken());\n		V[] vv = new V[d];\n		for (int i = 0; i < d; i++) {\n			st = new StringTokenizer(br.readLine());\n			int x1 = Integer.parseInt(st.nextToken());\n			int y1 = Integer.parseInt(st.nextToken());\n			int x2 = Integer.parseInt(st.nextToken());\n			int y2 = Integer.parseInt(st.nextToken());\n			vv[i] = new V(i + 1, x1, y1, x2, y2);\n		}\n		st = new StringTokenizer(br.readLine());\n		int l_ = Integer.parseInt(st.nextToken());\n		int r_ = Integer.parseInt(st.nextToken());\n		int t_ = Integer.parseInt(st.nextToken());\n		int b_ = Integer.parseInt(st.nextToken());\n		Arrays.sort(vv, (u, v) -> u.x - v.x);\n		for (int i = 0, l = 0; i < d; ) {\n			if (i - 1 >= 0 && vv[i].x > vv[i - 1].x)\n				l = i;\n			if (vv[i].x % 2 == 0)\n				vv[i++].l = l;\n			else {\n				int j = i + 1;\n				while (j < d && vv[j].x == vv[i].x) {\n					l++;\n					j++;\n				}\n				while (i < j)\n					vv[i++].l = l;\n			}\n		}\n		for (int i = d - 1, r = 0; i >= 0; ) {\n			if (i + 1 < d && vv[i].x < vv[i + 1].x)\n				r = d - 1 - i;\n			if (vv[i].x % 2 == 0)\n				vv[i--].r = r;\n			else {\n				int j = i - 1;\n				while (j >= 0 && vv[j].x == vv[i].x) {\n					r++;\n					j--;\n				}\n				while (i > j)\n					vv[i--].r = r;\n			}\n		}\n		Arrays.sort(vv, (u, v) -> u.y - v.y);\n		for (int i = 0, t = 0; i < d; ) {\n			if (i - 1 >= 0 && vv[i].y > vv[i - 1].y)\n				t = i;\n			if (vv[i].y % 2 == 0)\n				vv[i++].t = t;\n			else {\n				int j = i + 1;\n				while (j < d && vv[j].y == vv[i].y) {\n					t++;\n					j++;\n				}\n				while (i < j)\n					vv[i++].t = t;\n			}\n		}\n		for (int i = d - 1, b = 0; i >= 0; ) {\n			if (i + 1 < d && vv[i].y < vv[i + 1].y)\n				b = d - 1 - i;\n			if (vv[i].y % 2 == 0)\n				vv[i--].b = b;\n			else {\n				int j = i - 1;\n				while (j >= 0 && vv[j].y == vv[i].y) {\n					b++;\n					j--;\n				}\n				while (i > j)\n					vv[i--].b = b;\n			}\n		}\n		for (int i = 0; i < d; i++) {\n			V v = vv[i];\n			if (v.l == l_ && v.r == r_ && v.t == t_ && v.b == b_) {\n				System.out.println(v.i);\n				return;\n			}\n		}\n		System.out.println(-1);\n	}\n}\n","brute force,implementation"
"import java.util.*;\npublic class Main\n{\n	public static void main(String[] args){\n		Scanner reader=new Scanner(System.in);\n		int n=reader.nextInt(), k=reader.nextInt();\n		int a[][]=new int[n+1][n+1];\n		if(k>n*n) {\n			System.out.println(-1);\n			return;\n		}\n		if(k==0) {\n			for(int i=1;i<=n;i++) {\n				for(int j=1;j<=n;j++) {\n					System.out.print(a[i][j]+"" "");\n				}\n				System.out.println();\n			}\n			return;\n		}\n		for(int i=1;i<=n;i++) {\n			if(k==0) break;\n			for(int j=1;j<=n;j++) {\n				if(k==0) break;\n				if(k>=2&&a[i][j]==0&&i!=j) {\n					a[i][j]=a[j][i]=1;\n					k-=2;\n				}\n				if(i==j) {\n					a[i][j]=1;\n					k--;\n				}\n			}\n		}\n		if(k!=0) {\n			System.out.println(-1);\n			return;\n		}\n		for(int i=1;i<=n;i++) {\n			for(int j=1;j<=n;j++) {\n				System.out.print(a[i][j]+"" "");\n			}\n			System.out.println();\n		}\n	}\n}",constructive algorithms
"import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt();\n        int k = scanner.nextInt();\n\n        if (k > n*n) {\n            System.out.println(-1);\n            return;\n        }\n\n        int[][] output = new int[n][n];\n\n        for (int i = 0; i < n; i++) {\n            if (k >= 1) {\n                output[i][i] = 1;\n                k --;\n            }\n            for (int j = i+1; j < n; j++) {\n                if (k >= 2) {\n                    output[i][j] = 1;\n                    output[j][i] = 1;\n                    k -= 2;\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                System.out.print(output[i][j] + "" "");\n            }\n            System.out.println();\n        }\n\n    }\n\n}\n",constructive algorithms
"import java.io.*;\nimport java.util.*;\n\npublic class B{\n   public static void main(String[] args) throws Exception {\n      Scanner sc = new Scanner(System.in);\n      PrintWriter out = new PrintWriter(System.out);\n\n      int n = sc.nextInt(), k = sc.nextInt();\n      int matrix[][] = new int[n][n];\n\n      for (int i = 0; i < n; i++){\n         for (int j = i; j < n; j++){\n            if (i == j && k >= 1){\n               matrix[i][j] = 1;\n               k--;\n            }\n            if (i != j && k >= 2){\n               matrix[i][j] = 1;\n               matrix[j][i] = 1;\n               k -= 2;\n            }\n         }\n      }\n\n      if (k == 0){\n         for (int i = 0; i < n; i++){\n            for (int j = 0; j < n; j++){\n               out.print(matrix[i][j] + "" "");\n            }\n            out.println();\n         }\n       }\n      else\n         out.println(""-1"");\n      out.flush();\n      sc.close();\n      out.close();\n   }\n}",constructive algorithms
"\n\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int k=sc.nextInt();\n        int[][] arr=new int[n+1][n+1];\n        int flag=0;\n        if(n * n < k) {\n            flag=1;\n        } else {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (arr[i][j] == 1)\n                        continue;\n                    if (i == j && k!=0) {\n                        arr[i][j] = 1;\n                        k--;\n                    } else if (k >= 2) {\n                        arr[i][j] = 1;\n                        arr[j][i] = 1;\n                        k -= 2;\n                    }\n                }\n            }\n            if (k > 0)\n                flag =1;\n        }\n        if (flag == 0) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if(arr[i][j] == 1)\n                        System.out.print(1+"" "");\n                    else\n                        System.out.print(0+"" "");\n                }\n                System.out.println();\n            }\n        } else {\n            System.out.println(-1);\n        }\n    }\n}\n\n  		         			 	 		  	   				",constructive algorithms
"import java.util.*;\n\npublic class Main {\n\n	static void solve() {\n		Scanner sc = new Scanner(System.in);\n		long n = sc.nextLong(), k = sc.nextLong(), no = n, min=Long.MAX_VALUE, tot=0;\n		int i=0;\n		long[] o = new long[(int)n];\n		while (no-->0) {\n			o[i] = sc.nextInt();\n			min = Math.min(o[i++],min);\n		}\n		no=n; i=0;\n		while (no-->0) {\n			if ((o[i]-min)%k!=0) {\n				System.out.println(-1);\n				System.exit(0);	\n			} else {\n				tot+=((o[i]-min)/k);\n			}	\n			i++;\n		}\n		System.out.println(tot);\n		sc.close();\n	}\n\n	public static void main(String[] args) {\n		solve();\n	}\n}","implementation,math"
import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class probe {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        long sum = 0;\n\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = sc.nextInt();\n        }\n        long min = Arrays.stream(arr).min().getAsInt();\n\n        for (int i = 0; i < n; i++){\n            long x = arr[i]-min;\n            if (x%k != 0){\n                System.out.println(-1);\n                return;\n            }\n            sum += x;\n        }\n\n        System.out.println(sum/k);\n    }\n},"implementation,math"
"import java.util.Scanner;\n\npublic class _0575Olegandshares {\n\n	public static void main(String[] args) {\n		\n		Scanner sc = new Scanner(System.in);\n		int n=sc.nextInt();\n		int k=sc.nextInt();\n		if(n==1) {\n			System.out.println(0);\n			return;\n		}\n		int[] arr = new int[n];\n		int min=Integer.MAX_VALUE;\n		for(int i=0;i<n;i++) {\n			int temp=sc.nextInt();\n			arr[i]=temp;\n			min=Math.min(min, temp);\n		}\n		long count=0;\n		for(int i=0;i<n;i++) {\n			if(arr[i]==min) {\n				continue;\n			}\n			else {\n				int val=(arr[i]-min);\n			if(val%k!=0) {\n				System.out.println(-1);\n				return;\n			}\n			else {\n				count+=val/k;\n			}\n			}\n		}\n		System.out.println(count);\n		\n	}\n\n}\n","implementation,math"
"import java.util.Scanner;\n\npublic class probe {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        int min = Integer.MAX_VALUE;\n        long sum = 0;\n\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            int tmp = sc.nextInt();\n            arr[i] = tmp;\n            min = Math.min(min, tmp);\n        }\n\n        for (int i = 0; i < n; i++){\n            long x = arr[i]-min;\n            if (x%k != 0){\n                System.out.println(-1);\n                return;\n            }\n            sum += x;\n        }\n\n        System.out.println(sum/k);\n    }\n}","implementation,math"
"import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf786a {\n\n    public static void main(String[] args) throws IOException {\n        int n = ri(), k1 = rni(), s1[] = nia(k1), k2 = rni(), s2[] = nia(k2), ans[][] = new int[2][n], cnt[][] = new int[2][n];\n        ans[0][0] = ans[1][0] = -1;\n        Queue<int[]> q = new ArrayDeque<>();\n        q.offer(new int[] {0, 0});\n        q.offer(new int[] {1, 0});\n        while (!q.isEmpty()) {\n            int e[] = q.poll(), r = e[0], c = e[1];\n            if (r == 0) {\n                if (ans[r][c] == 1) {\n                    for (int i = 0; i < k2; ++i) {\n                        int j = (n + c - s2[i]) % n;\n                        if (ans[1][j] == 0 && ++cnt[1][j] == k2) {\n                            ans[1][j] = -1;\n                            q.offer(new int[] {1, j});\n                        }\n                    }\n                } else {\n                    for (int i = 0; i < k2; ++i) {\n                        int j = (n + c - s2[i]) % n;\n                        if (ans[1][j] == 0) {\n                            ans[1][j] = 1;\n                            q.offer(new int[] {1, j});\n                        }\n                    }\n                }\n            } else {\n                if (ans[r][c] == 1) {\n                    for (int i = 0; i < k1; ++i) {\n                        int j = (n + c - s1[i]) % n;\n                        if (ans[0][j] == 0 && ++cnt[0][j] == k1) {\n                            ans[0][j] = -1;\n                            q.offer(new int[] {0, j});\n                        }\n                    }\n                } else {\n                    for (int i = 0; i < k1; ++i) {\n                        int j = (n + c - s1[i]) % n;\n                        if (ans[0][j] == 0) {\n                            ans[0][j] = 1;\n                            q.offer(new int[] {0, j});\n                        }\n                    }\n                }\n            }\n        }\n        for (int i = 1; i < n; ++i) {\n            if (i != 1) {\n                pr(' ');\n            }\n            pr(ans[0][i] == -1 ? ""Lose"" : ans[0][i] == 0 ? ""Loop"" : ""Win"");\n        }\n        prln();\n        for (int i = 1; i < n; ++i) {\n            if (i != 1) {\n                pr(' ');\n            }\n            pr(ans[1][i] == -1 ? ""Lose"" : ans[1][i] == 0 ? ""Loop"" : ""Win"");\n        }\n        prln();\n        close();\n    }\n\n    static BufferedReader __i = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __o = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __r = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final long LMAX = 9223372036854775807L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);}\n    static long gcd(long a, long b) {return b == 0 ? a : gcd(b, a % b);}\n    static int[] exgcd(int a, int b) {if (b == 0) return new int[] {1, 0}; int[] y = exgcd(b, a % b); return new int[] {y[1], y[0] - y[1] * (a / b)};}\n    static long[] exgcd(long a, long b) {if (b == 0) return new long[] {1, 0}; long[] y = exgcd(b, a % b); return new long[] {y[1], y[0] - y[1] * (a / b)};}\n    static int randInt(int min, int max) {return __r.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] nia(int n) throws IOException {int[] a = new int[n]; for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static void ria(int[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = ni();}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static void riam1(int[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static void rla(long[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = nl();}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static void rda(double[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = nd();}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static void rcha(char[] a) throws IOException {int n = a.length, i = 0; for (char c : rline().toCharArray()) a[i++] = c;}\n    static String rline() throws IOException {return __i.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__o.print(i);}\n    static void prln(int i) {__o.println(i);}\n    static void pr(long l) {__o.print(l);}\n    static void prln(long l) {__o.println(l);}\n    static void pr(double d) {__o.print(d);}\n    static void prln(double d) {__o.println(d);}\n    static void pr(char c) {__o.print(c);}\n    static void prln(char c) {__o.println(c);}\n    static void pr(char[] s) {__o.print(new String(s));}\n    static void prln(char[] s) {__o.println(new String(s));}\n    static void pr(String s) {__o.print(s);}\n    static void prln(String s) {__o.println(s);}\n    static void pr(Object o) {__o.print(o);}\n    static void prln(Object o) {__o.println(o);}\n    static void prln() {__o.println();}\n    static void pryes() {prln(""yes"");}\n    static void pry() {prln(""Yes"");}\n    static void prY() {prln(""YES"");}\n    static void prno() {prln(""no"");}\n    static void prn() {prln(""No"");}\n    static void prN() {prln(""NO"");}\n    static boolean pryesno(boolean b) {prln(b ? ""yes"" : ""no""); return b;};\n    static boolean pryn(boolean b) {prln(b ? ""Yes"" : ""No""); return b;}\n    static boolean prYN(boolean b) {prln(b ? ""YES"" : ""NO""); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(""hlfd""); flush();}\n    static void flush() {__o.flush();}\n    static void close() {__o.close();}\n}","dfs and similar,dp,games"
"import java.util.*;\n\npublic class berzerk {\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		int n = s.nextInt();\n		int[][] ss = new int[2][];\n		for(int i=0; i<2; ++i) {\n			int k = s.nextInt();\n			ss[i] = new int[k];\n			for(int j=0; j<k; ++j) ss[i][j] = s.nextInt();\n		}\n		int[][] res = new int[2][n];\n		int[][] cnt = new int[2][n];\n		res[0][0] = -1;\n		res[1][0] = -1;\n		int[] done = new int[2*n];\n		done[0] = 0;\n		done[1] = n;\n		int k=2;\n		for(int i=0; i<k; ++i) {\n			int a = done[i];\n			int x=0;\n			if (a>=n) {\n				a -= n;\n				x = 1;\n			}\n			if (res[x][a] > 0) {\n				for(int j : ss[1-x]) {\n					int v = a - j;\n					if (v<0) v+=n;\n					if (++cnt[1-x][v] == ss[1-x].length && res[1-x][v]==0) {\n						res[1-x][v] = -1;\n						done[k++] = v + (x==0 ? n : 0);\n					}\n				}\n			} else {\n				for(int j : ss[1-x]) {\n					int v = a - j;\n					if (v<0) v+=n;\n					if (res[1-x][v]==0) {\n						res[1-x][v] = 1;\n						done[k++] = v + (x==0 ? n : 0);\n					}\n				}\n			}\n		}\n		for(int i=0; i<2; ++i) {\n			String[] r = new String[n-1];\n			for(int j=1; j<n; ++j) {\n				int a = res[i][j];\n				r[j-1] = a<0 ? ""Lose"" : a>0 ? ""Win"" : ""Loop"";\n			}\n			System.out.println(String.join("" "", r));\n		}\n	}\n}\n","dfs and similar,dp,games"
"import java.io.*;\nimport java.util.*;\n\npublic class CF787C {\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		int n = Integer.parseInt(br.readLine());\n		int[] kk = new int[2];\n		int[][] ss = new int[2][n];\n		int[][] cc = new int[2][n];\n		for (int p = 0; p <= 1; p++) {\n			StringTokenizer st = new StringTokenizer(br.readLine());\n			kk[p] = Integer.parseInt(st.nextToken());\n			for (int i = 0; i < kk[p]; i++)\n				ss[p][i] = Integer.parseInt(st.nextToken());\n			Arrays.fill(cc[p], kk[p]);\n		}\n		int[][] xx = new int[2][n];\n		ArrayDeque<Integer> stack = new ArrayDeque<>();\n		xx[0][0] = -8;\n		stack.addLast(0); stack.addLast(0); stack.addLast(-8);\n		xx[1][0] = -8;\n		stack.addLast(1); stack.addLast(0); stack.addLast(-8);\n		while (!stack.isEmpty()) {\n			int x = stack.removeLast();\n			int j = stack.removeLast();\n			int q = stack.removeLast(), p = 1 - q;\n			if (x > 0)\n				for (int k = 0; k < kk[p]; k++) {\n					int i = (j - ss[p][k] + n) % n;\n					if (xx[p][i] == 0 && --cc[p][i] == 0) {\n						xx[p][i] = -8;\n						stack.addLast(p); stack.addLast(i); stack.addLast(-8);\n					}\n				}\n			else if (x < 0)\n				for (int k = 0; k < kk[p]; k++) {\n					int i = (j - ss[p][k] + n) % n;\n					if (xx[p][i] == 0) {\n						xx[p][i] = 8;\n						stack.addLast(p); stack.addLast(i); stack.addLast(8);\n					}\n				}\n		}\n		for (int p = 0; p <= 1; p++) {\n			StringBuilder sb = new StringBuilder();\n			for (int i = 1; i < n; i++) {\n				int x = xx[p][i];\n				String s;\n				if (x > 0)\n					s = ""Win "";\n				else if (x < 0)\n					s = ""Lose "";\n				else\n					s = ""Loop "";\n				sb.append(s);\n			}\n			System.out.println(sb);\n		}\n	}\n}\n","dfs and similar,dp,games"
"import java.util.Scanner;\n\npublic class Main {\n	private static final Scanner in = new Scanner(System.in);\n    public static void main(String[] args) {\n		int n = in.nextInt();\n		int k1 = in.nextInt();\n		int[] s1 = genNums(k1);\n		\n		int k2 = in.nextInt();\n		int[] s2 = genNums(k2);\n\n		int[] result1 = new int[n];\n		int[] result2 = new int[n];\n\n		for (int i = 0; i < k1; i++) {\n			result1[n - s1[i]] = 1;\n		}\n		for (int i = 0; i < k2; i++) {\n			result2[n - s2[i]] = 1;\n		}\n		\n		result2[0] = -1;\n		result1[0] = -1;\n\n		boolean changed = true;\n		while (changed) {\n			changed = false;\n			for (int i = n - 1; i > 0; i--) {\n\n				changed = stateChanged(n, k1, s1, result1, result2, changed, i);\n\n				changed = stateChanged(n, k2, s2, result2, result1, changed, i);\n			}\n		}\n\n		printRound(n, result1);\n		System.out.println();\n		printRound(n, result2);\n	}\n    \n    //im lazy\n	static void printRound(int n, int[] res1) {\n		for (int i = 1; i < n; i++) {\n			if (res1[i] == 1) System.out.print(""Win "");\n			else if (res1[i] == -1) System.out.print(""Lose "");\n			else System.out.print(""Loop "");\n		}\n	}\n\n	static boolean stateChanged(final int n,final int k1,final int[] s1,final int[] res1,final int[] res2, boolean changed, int i) {\n		if (res1[i] == 0) {\n			boolean winEverythig = true;\n			boolean oneLoss = false;\n			for (int j = 0; j < k1; j++) {\n				if (res2[(i + s1[j]) % n] == -1) {\n					oneLoss = true;\n					break;\n				}\n				if (res2[(i + s1[j]) % n] != 1) {\n					winEverythig = false;\n				}\n			}\n			if (oneLoss) {\n				res1[i] = 1;\n				changed = true;\n			} else if (winEverythig) {\n				res1[i] = -1;\n				changed = true;\n			}\n		}\n		return changed;\n	}\n    \n    \n    //stop doing next int lots of times\n	static int[] genNums(int n) {\n		int[] ar = new int[n];\n		for (int i = 0; i < n; i++) {\n			ar[i] = in.nextInt();\n		}\n		return ar;\n	}\n\n}","dfs and similar,dp,games"
"import java.io.*;\nimport java.util.*;\n\npublic class TheHolmesChildren {\n    static final int MOD = 1000000007;\n    public static long phi(long N) {\n        long ret = N;\n        for (long i = 2; i * i <= N; i++) {\n            if (N % i == 0) {\n                while (N % i == 0) N /= i;\n                ret -= ret / i;\n            }\n        }\n        if (N != 1) ret -= ret / N;\n        return ret;\n    }\n    public static void main(String[] args) {\n        InputReader reader = new InputReader(System.in);\n        PrintWriter writer = new PrintWriter(System.out, false);\n        long N = reader.nextLong();\n        long K = reader.nextLong();\n        K = (K + 1) / 2;\n        long answer = N;\n        while (K-- > 0) {\n            answer = phi(answer);\n            if (answer == 1) break;\n        }\n        writer.println(answer % MOD);\n        writer.close();\n        System.exit(0);\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        public String nextLine() {\n            String str = """";\n            try {\n                str = reader.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}","math,number theory"
"import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\n\npublic class Test {\n\n  static PrintWriter writer =\n      new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n  static int readInt() {\n    int ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  static long readLong() {\n    long ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  static String readString() {\n    StringBuilder b = new StringBuilder();\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (Character.isLetterOrDigit(c)) {\n          start = true;\n          b.append((char) c);\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return b.toString();\n  }\n\n  static int readChars(char[] a, int off) {\n    int cnt = 0;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (Character.isLetterOrDigit(c)) {\n          start = true;\n          a[off + cnt++] = (char) c;\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return cnt;\n  }\n\n  public static void main(String[] args) {\n    Test te = new Test();\n    te.start();\n    writer.flush();\n  }\n\n  long f(long n) {\n    long ret = n;\n    long v = n;\n    for (long i = 2; i * i <= v; i++)\n      if (v % i == 0) {\n        while (v % i == 0) v /= i;\n        ret -= ret / i;\n      }\n    if (v > 1) ret -= ret / v;\n    return ret;\n  }\n\n  long F(long n, long k) {\n    long v = n;\n    for (long i = 1; i <= k && v > 1; i++) {\n      if (i == 1) v = f(n);\n      else if (i % 2 == 1) v = f(v);\n    }\n    return v;\n  }\n\n  void start() {\n    long n = readLong(), k = readLong();\n    writer.println(F(n, k) % 1_000_000_007);\n  }\n}\n","math,number theory"
import java.util.Scanner;\n\n\npublic class TheHolmesChildren {\n	\n	static long phi(long n){\n		long res=n;\n		for(long i=2;i*i<=n;i++){\n			if(n%i==0){\n				while(n%i==0){\n					n/=i;\n				}\n				res-=res/i;\n			}\n		}\n		if(n>1)\n			res-=res/n;\n		return res;\n	}\n	public static void main(String[] args) {\n		Scanner s=new Scanner(System.in);\n		long n=s.nextLong();\n		long k=s.nextLong();\n		long res=n;\n		k=(k+1)/2;\n		while(k>0){\n			res=phi(res);\n			if(res==1)\n				break;\n			k--;\n		}\n		System.out.println(res%1000000007);\n		s.close();\n	}\n\n}\n,"math,number theory"
import java.util.Scanner;\n\npublic class Main {\n  static Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    long N = sc.nextLong();\n    long K = sc.nextLong();\n    for (long i = 0; i < (K + 1) / 2; i++) {\n      N = totient(N);\n      if (N == 1) break;\n    }\n    System.out.println(N % 1000000007);\n  }\n\n  static long totient(long v) {\n    long d = 1;\n    for (long i = 2; i * i <= v; i++) {\n      if (v % i == 0) {\n        v /= i;\n        long pow = i;\n        while (v % i == 0) {\n          pow *= i;\n          v /= i;\n        }\n        d *= pow - pow / i;\n      }\n    }\n    if (v > 1) d *= v - 1;\n    return d;\n  }\n}\n,"math,number theory"
"import java.util.*;\n\npublic class A{\n    public static void main(String[] argc){\n\n      String s;\n      int n, oldman=0, i;\n      long c1, c2, ans = Long.MAX_VALUE, a1, b1, q;\n\n      Scanner sc = new Scanner(System.in);\n      n = sc.nextInt(); c1 = sc.nextLong(); c2 = sc.nextLong();\n      s = sc.next();\n      for (i = 0; i < n; i++) if (s.charAt(i) == '1') oldman++;\n      \n      for (i = 1; i <= oldman; i++) {\n	   q=n-i; a1 = q/i; b1 = n % i;\n	   q = c1 * i + c2 * (a1 * a1 * i + b1 * ((a1+1) * (a1+1) - a1 * a1));\n           if (q<ans) ans=q;\n      }\n      System.out.println(ans);\n    }\n}","*special,ternary search"
"import java.util.*;\n\npublic class Main{\n	public static long min(long a, long b){\n		return a<b?a:b;\n	}\n	public static void main(String[] argc){\n		Scanner sc = new Scanner(System.in);\n		long n=sc.nextInt();\n		long c=0;\n		long a=0;\n		long c1=sc.nextInt();\n		long c2=sc.nextInt();\n		String s=sc.next();\n		for(int i=0; i<n; i++)\n			if(s.charAt(i)=='1')\n				a++;\n		long ans=c1+c2*(n-1)*(n-1);\n		for(long i=2; i<=a; i++){\n			c=n-i;\n			if(c%i==0){\n				c/=i;\n				ans=min(ans, c1*i+c2*c*c*i);\n			}\n			else{\n				long cc=c%i;\n				c/=i;\n				ans=min(ans, c1*i+c2*(cc*(c+1)*(c+1)+(i-cc)*c*c));\n			}\n		}\n		System.out.println(ans);\n	}\n}","*special,ternary search"
"import java.util.Scanner;\n\npublic class Solver {\n\n	public static void main(String[] args) {\n		Scanner input = new Scanner(System.in);\n		\n		int n = input.nextInt();\n		long c1 = input.nextLong();\n		long c2 = input.nextLong();\n		String s = input.next();\n		\n		int adults = 0;\n		\n		for (int i = 0; i < n; ++i)\n			if (s.charAt(i) == '1')\n				++adults;\n\n		long ans = Long.MAX_VALUE, cnt, rem, sum;\n		\n		for (int g = 1; g <= adults; ++g) {\n			cnt = (n - g) / g;\n			rem = (n - g) % g;\n			sum = c1 * g + c2 * rem * (cnt + 1) * (cnt + 1) + c2 * (g - rem) * cnt * cnt;\n			ans = Math.min(ans, sum);\n		}\n		\n		System.out.println(ans);\n	}\n}","*special,ternary search"
"import java.io.*;\nimport java.util.*;\nimport java.math.*;\npublic class Main{\n	public static void main(String args[]) throws IOException{\n		Scanner sc = new Scanner(System.in);\n		int n; long A, B;\n		n = sc.nextInt(); A = sc.nextLong(); B = sc.nextLong();\n		String S;\n		S = sc.next();\n		int pu = 0, ad = 0;\n		for(int i = 0; i < n; i++){\n			if(S.charAt(i) == '0') pu++;\n			else ad++;\n		}\n		long best = Long.MAX_VALUE;\n		for(int i = 1; i <= ad; i++){\n			long ans = A*i;\n			int cap = n/i, res = n%i;\n			long cost = ans + (i - res)*B*(cap - 1)*(cap - 1) + res*B*cap*cap;\n			best = Math.min(best, cost);\n		}\n		System.out.println(best);\n	}\n}","*special,ternary search"
"import java.util.*;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner z=new Scanner(System.in);\n		int n=z.nextInt();\n		int k=z.nextInt();\n		String s="""";\n		for(int i=0;i<n;i++){\n		s+=(char)(97+i%k);}\n		System.out.print(s);	\n		\n	}\n}","*special,implementation"
"import java.util.*;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner z=new Scanner(System.in);\n		int n=z.nextInt();\n		int k=z.nextInt();\n		String s="""";\n		for(int i=0;i<n;i++){\n		s+=(char)(97+i%k);}\n		System.out.print(s);	\n		\n	}\n}\n	 		  	   	 			 	  			 		  	","*special,implementation"
"import java.util.Scanner;\npublic class CF770A {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n =sc.nextInt(), k = sc.nextInt();\n        for(int i=0; i<n; i++) {\n            System.out.print(Character.toChars('a' + i%k));\n        }\n    }\n}\n","*special,implementation"
import java.util.Scanner;\n\npublic class _0313NewPassword {\n\n	public static void main(String[] args) {\n		\n		Scanner sc = new Scanner(System.in);\n		int n=sc.nextInt();\n		int k=sc.nextInt();\n		int j=0;\n		for(int i=0;i<n;i++) {\n			System.out.print((char)('a'+j));\n			j++;\n\n			j=j%k;\n		}\n	}\n\n}\n,"*special,implementation"
"import java.util.*;\n\npublic class MahmoudandaTriangle_766B {\n\n\npublic static void main(String[] args) {\n\nScanner sc = new Scanner(System.in);\n\nint n = sc.nextInt(); \nlong arr[] = new long[n];\n\nfor (int i = 0; i < n; i++) arr[i] = sc.nextLong();\n\nArrays.sort(arr);\n\nfor (int i = 0; i < n-2; i++) { if(arr[i]+arr[i+1]>arr[i+2]) {\nSystem.out.println(""YES"");\nreturn;\n} \n}\nSystem.out.println(""NO"");\n}\n}","constructive algorithms,geometry,greedy,math,number theory,sortings"
"import java.util.*;\n\npublic class MahmoudandaTriangle_766B {\n\n\npublic static void main(String[] args) {\n\nScanner sc = new Scanner(System.in);\n\nint n = sc.nextInt(); \nlong arr[] = new long[n];\n\nfor (int i = 0; i < n; i++) arr[i] = sc.nextLong();\n\nArrays.sort(arr);\n\nfor (int i = 0; i < n-2; i++) { if(arr[i]+arr[i+1]>arr[i+2]) {\nSystem.out.println(""YES"");\nreturn;\n} \n}\nSystem.out.println(""NO"");\n}\n}","constructive algorithms,geometry,greedy,math,number theory,sortings"
"import java.util.*;\n \npublic class MahmoudandaTriangle_766B {\n \n \npublic static void main(String[] args) {\n \nScanner sc = new Scanner(System.in);\n \nint n = sc.nextInt(); \nlong arr[] = new long[n];\n \nfor (int i = 0; i < n; i++) arr[i] = sc.nextLong();\n \nArrays.sort(arr);\n \nfor (int i = 0; i < n-2; i++) { if(arr[i]+arr[i+1]>arr[i+2]) {\nSystem.out.println(""YES"");\nreturn;\n} \n}\nSystem.out.println(""NO"");\n}\n}","constructive algorithms,geometry,greedy,math,number theory,sortings"
"import java.util.*;\npublic class MahmoudAndATriangle {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		Integer arr[]=new Integer[n];\n		for(int i=0;i<n;i++) {\n			arr[i]=sc.nextInt();\n		}\n		Arrays.parallelSort(arr);\n		for(int i=n-1;i>1;i--) {\n			if(arr[i]<arr[i-1]+arr[i-2]) {\n				System.out.println(""YES"");\n				return;\n			}\n		}\n		System.out.println(""NO"");\n	}\n\n}\n","constructive algorithms,geometry,greedy,math,number theory,sortings"
"\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int n = input.nextInt();\n        int m = input.nextInt();\n        ArrayList<String> value = new ArrayList<>();\n\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            String s = input.next();\n            value.add(s);\n        }\n        for (int i = 0; i < m; i++) {\n            String s = input.next();\n            if (value.contains(s)) {\n                count++;\n            }\n        }\n        System.out.println(n > m ? ""YES"" : n == m ? count % 2 == 0 ? ""NO"" : ""YES"" : ""NO"");\n    }\n}\n\n   		 	  				  	 		 	 	 			","binary search,data structures,games,greedy,sortings,strings"
"\n\nimport java.util.*;\nimport java.io.*;\n\npublic class main {\n\n	\n\n	public static void main(String args[]) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int m=sc.nextInt();\n		 Stack s = new Stack();int same=0,diff=0;\n		 for(int i=0;i<n;i++) {\n			 String s1=sc.next();\n			 s.push(s1);\n		 }\n		 for(int i=0;i<m;i++) {\n			 String s2=sc.next();\n			 if(s.search(s2)!=-1) {\n				 same++;\n			 }\n		 }\n		 int p=same%2;\n		 int p1=n-same;int p2=m-same;\n		 if(p1>p2) {\n			 System.out.println(""YES"");\n		 }else if(p1<p2) {\n			 System.out.println(""NO"");\n		 }else  {\n			 if(p==0) {\n				 System.out.println(""NO""); \n			 }else {\n				 System.out.println(""YES"");\n			 }\n		 }\n	}\n}\n","binary search,data structures,games,greedy,sortings,strings"
"\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\n\npublic class F {\n    public static void main(String[] args) {\n        ArrayList<String> cs = new ArrayList<>();;\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int contain=0;\n        for (int i = 0 ;i < n; i++){\n            String str = in.next();\n            cs.add(str);\n\n        }\n        for (int i = 0 ;i < m; i++){\n            String str = in.next();\n            if (cs.contains(str)){\n                contain++;\n            }\n            cs.add(str);\n        }\n        if(contain % 2 != 0){n++;}\n        System.out.println((n>m) ? ""YES"" : ""NO"");\n\n    }\n\n}\n","binary search,data structures,games,greedy,sortings,strings"
"\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int n = input.nextInt(), m = input.nextInt();\n        ArrayList<String> frequency = new ArrayList<>();\n        String s;\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            s = input.next();\n            frequency.add(s);\n        }\n        for (int i = 0; i < m; i++) {\n            s = input.next();\n            if (frequency.contains(s)) {\n                count++;\n            }\n        }\n        System.out.println(n > m ? ""YES"" : n == m ? count % 2 == 0 ? ""NO"" : ""YES"" : ""NO"");\n    }\n}\n\n      	 		 	    		   	  	 		 	","binary search,data structures,games,greedy,sortings,strings"
"// package contest;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class taemb {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n     \n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken()); int t = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        List<int[]> edges = new ArrayList<>();\n        int[] nums = new int[t+2];\n        nums[0] = 1;\n        \n        st = new StringTokenizer(br.readLine());\n        for(int i =1; i<=t; i++){\n            nums[i] = Integer.parseInt(st.nextToken());\n        }\n        int[] suf = new int[nums.length];\n        for(int i = t; i>=0; i--){\n            suf[i] = suf[i+1] + Math.max(0, nums[i] - nums[i+1]);\n        }\n        int cur = 1;\n        for(int i = 0; i<=t; i++){ //consider 0\n            if(nums[i] == 0 && nums[i+1] != 0){\n                k = -1; break;\n            }\n\n           int next = cur + nums[i];\n            if(suf[i] < k){\n                int diff = Math.min(nums[i] - 1, k - suf[i+1]); k-=diff;\n//                System.out.println(diff);\n                int start = cur;\n                cur += diff;\n                for(int j = 0; j<nums[i+1]; j++, next++){\n                    edges.add(new int[]{cur, next});\n                    if(cur - start < nums[i]-1) cur++;\n                }\n                cur++;\n                continue;\n            }\n            \n            if(nums[i] >= nums[i+1]){\n                int diff = nums[i] - nums[i+1]; k-=diff;\n                cur += diff;\n                for(int j = 0; j<nums[i+1]; j++, next++, cur++){\n                    edges.add(new int[]{cur, next});\n                }\n            }else{\n                for(int j = 0; j<nums[i]; j++, next++, cur++){\n                    edges.add(new int[]{cur, next});\n                }\n                cur--;\n                for(int j = 0; j<nums[i+1] - nums[i]; j++, next++){\n                    edges.add(new int[]{cur, next});\n                }\n                cur++;\n            }\n        }\n        if(k!= 0){\n            pw.println(-1);\n        }else{\n            pw.println(n);\n            for(int[] i : edges){\n                pw.println((i[0]) + "" ""  + (i[1]));\n            }\n        }\n        \n        pw.close();\n        br.close();\n    }\n}\n","constructive algorithms,graphs,trees"
"import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n    static int MOD = 1000000007;\n\n    // After writing solution, quick scan for:\n    //   array out of bounds\n    //   special cases e.g. n=1?\n    //   npe, particularly in maps\n    //\n    // Big numbers arithmetic bugs:\n    //   int overflow\n    //   sorting, or taking max, after MOD\n    void solve() throws IOException {\n        int[] ntk = ril(3);\n        int n = ntk[0];\n        int t = ntk[1];\n        int k = ntk[2];\n        int[] a = ril(t);\n\n        int[] parent = new int[n];\n        parent[0] = -1;\n\n        // Main trunk: root 0, then cities 1->t\n        // Node t is a leaf.\n        // Node x is on level x.\n        for (int i = 1; i <= t; i++) parent[i] = i-1;\n        for (int i = 0; i < t; i++) a[i]--;  // Update requirements.\n\n        int id = t+1;\n\n        int countleaves = 1;\n\n        // leaves on each level\n        List<List<Integer>> leaves = new ArrayList<>(t+1);\n        // movable if it does not have a ""job""\n        List<List<Integer>> movable = new ArrayList<>(t+1);\n        for (int i = 0; i <= t; i++) leaves.add(new ArrayList<>());\n        for (int i = 0; i <= t; i++) movable.add(new ArrayList<>());\n        for (int d = 1; d <= t; d++) {\n            for (int times = 0; times < a[d-1]; times++) {\n                parent[id] = d-1;\n                leaves.get(d).add(id);\n                movable.get(d).add(id);\n                id++;\n                countleaves++;\n            }\n        }\n\n        if (countleaves < k) {\n            pw.println(""-1"");\n            return;\n        }\n\n        int leavesIdx = 0;\n        while (countleaves > k) {\n            while (leavesIdx < leaves.size() && leaves.get(leavesIdx).isEmpty()) leavesIdx++;\n            if (leavesIdx == leaves.size()) {\n                // pretty sure this is impossible\n                pw.println(""-1"");\n                return;\n            }\n\n            if (leavesIdx+1 >= leaves.size()) {\n                pw.println(""-1"");\n                return;\n            }\n\n            if (movable.get(leavesIdx+1).isEmpty()) {\n                leavesIdx++;\n                continue;\n            }\n\n            int leafChoice = leaves.get(leavesIdx).remove(leaves.get(leavesIdx).size() - 1);\n            int child = movable.get(leavesIdx+1).remove(movable.get(leavesIdx+1).size() - 1);\n            parent[child] = leafChoice;\n            countleaves--;\n        }\n\n        pw.println(n);\n        for (int i = 1; i < n; i++) pw.println(i+1 + "" "" + (parent[i]+1));\n    }\n    // IMPORTANT\n    // DID YOU CHECK THE COMMON MISTAKES ABOVE?\n\n    // Template code below\n\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    PrintWriter pw = new PrintWriter(System.out);\n\n    public static void main(String[] args) throws IOException {\n        Main m = new Main();\n        m.solve();\n        m.close();\n    }\n\n    void close() throws IOException {\n        pw.flush();\n        pw.close();\n        br.close();\n    }\n\n    int ri() throws IOException {\n        return Integer.parseInt(br.readLine().trim());\n    }\n\n    long rl() throws IOException {\n        return Long.parseLong(br.readLine().trim());\n    }\n\n    int[] ril(int n) throws IOException {\n        int[] nums = new int[n];\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n            int sign = 1;\n            c = br.read();\n            int x = 0;\n            if (c == '-') {\n                sign = -1;\n                c = br.read();\n            }\n            while (c >= '0' && c <= '9') {\n                x = x * 10 + c - '0';\n                c = br.read();\n            }\n            nums[i] = x * sign;\n        }\n        while (c != '\n' && c != -1) c = br.read();\n        return nums;\n    }\n\n    long[] rll(int n) throws IOException {\n        long[] nums = new long[n];\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n            int sign = 1;\n            c = br.read();\n            long x = 0;\n            if (c == '-') {\n                sign = -1;\n                c = br.read();\n            }\n            while (c >= '0' && c <= '9') {\n                x = x * 10 + c - '0';\n                c = br.read();\n            }\n            nums[i] = x * sign;\n        }\n        while (c != '\n' && c != -1) c = br.read();\n        return nums;\n    }\n\n    int[] rkil() throws IOException {\n        int sign = 1;\n        int c = br.read();\n        int x = 0;\n        if (c == '-') {\n            sign = -1;\n            c = br.read();\n        }\n        while (c >= '0' && c <= '9') {\n            x = x * 10 + c - '0';\n            c = br.read();\n        }\n        return ril(x);\n    }\n\n    long[] rkll() throws IOException {\n        int sign = 1;\n        int c = br.read();\n        int x = 0;\n        if (c == '-') {\n            sign = -1;\n            c = br.read();\n        }\n        while (c >= '0' && c <= '9') {\n            x = x * 10 + c - '0';\n            c = br.read();\n        }\n        return rll(x);\n    }\n\n    char[] rs() throws IOException {\n        return br.readLine().toCharArray();\n    }\n\n    void sort(int[] A) {\n        Random r = new Random();\n        for (int i = A.length-1; i > 0; i--) {\n            int j = r.nextInt(i+1);\n            int temp = A[i];\n            A[i] = A[j];\n            A[j] = temp;\n        }\n        Arrays.sort(A);\n    }\n\n    void printDouble(double d) {\n        pw.printf(""%.16f"", d);\n    }\n}","constructive algorithms,graphs,trees"
"/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/**\n *\n * @author wilso\n */\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\npublic class codeforces {\n    static final long MOD2 = 998_244_353;\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n       \n        int tc = 1;\n        for (int rep = 0; rep < tc; rep++) {\n            int n = sc.ni();\n            int t = sc.ni();\n            int k = sc.ni();\n            int[] arr = sc.intArray(t);\n            pw.println(solve(n,t,k,arr));\n        }\n        \n        pw.close();\n    }\n    \n    \n    static String solve(int n, int t, int k, int[] arr) {\n        int ret = n-t;\n        if (k > ret) return ""-1"";\n        int[] ref = new int[n];\n        int parent = 0;\n        int idx = 1;\n        for (int i = 0; i < t; i++) {\n            int pos = idx;\n            for (int j = 0; j < arr[i]; j++) {\n                ref[idx] = parent;\n                if (ret > k && parent < pos-1) {\n                    parent++;\n                    if (j+1 < arr[i]) ret--;\n                }\n                idx++;\n            }\n            parent = pos;\n        }\n        if (ret == k) {\n            StringBuilder sb = new StringBuilder();\n            sb.append(n);\n            sb.append(""\n"");\n            for (int i = 1; i < n; i++) {\n                sb.append((i+1) + "" "" + (ref[i] + 1));\n//                sb.append(i + "" "" + ref[i]);\n                sb.append(""\n"");\n            }\n            return sb.toString();\n        }\n        else {\n            return ""-1"";\n        }\n    }\n \n    static int summation(int x) {\n        return x * (x+1) / 2;\n    }  \n    static long pow(long num, long exp, long mod){\n        long ans=1;\n        for(int i=1;i<=exp;i++){\n            ans=(ans*num)%mod;\n        }\n        return ans;\n    }\n    static boolean isPrime(int n)\n    {\n \n        if (n <= 1)\n            return false;\n        else if (n == 2)\n            return true;\n        else if (n % 2 == 0)\n            return false;\n        for (int i = 3; i <= Math.sqrt(n); i += 2) {\n            if (n % i == 0)\n                return false;\n        }\n        return true;\n    }\n    static int gcd(int a, int b)\n    {\n        if (a == 0)\n            return b; \n        return gcd(b % a, a); \n    }\n    static long gcd(long a, long b) {\n        if (a == 0) return b;\n        return gcd(b % a, a);\n    }\n    static int lcm(int a, int b)\n    {\n        return (a / gcd(a, b)) * b;\n    }\n    public static void sort(int[] arr) {\n        Random rgen = new Random();\n        for (int i = 0; i < arr.length; i++) {\n            int r = rgen.nextInt(arr.length);\n            int temp = arr[i];\n            arr[i] = arr[r];\n            arr[r] = temp;\n        }\n        Arrays.sort(arr);\n    }\n    public static void sort(long[] arr) {\n        Random rgen = new Random();\n        for (int i = 0; i < arr.length; i++) {\n            int r = rgen.nextInt(arr.length);\n            long temp = arr[i];\n            arr[i] = arr[r];\n            arr[r] = temp;\n        }\n        Arrays.sort(arr);\n    }\n    static int charint(char c) {\n        return Integer.parseInt(String.valueOf(c));\n    }\n    \n    /* */\n    //printing methods\n    /* */\n    //WOW!\n    /* */\n    public static void printArr(PrintWriter pw, int[] arr) {\n        StringBuilder sb = new StringBuilder();\n        for (int x : arr) {\n            sb.append(x + """");\n        }\n        sb.setLength(sb.length() - 1);\n        pw.println(sb.toString());\n    }\n    public static void printArr2d(PrintWriter pw, int[][] arr) {\n        StringBuilder sb = new StringBuilder();\n        for (int[] row : arr) {\n            for (int x : row) {\n                sb.append(x + "" "");\n            }\n            sb.setLength(sb.length() - 1);\n            sb.append(""\n"");\n        }\n        pw.println(sb.toString());\n    }\n}\n\nclass FastScanner {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastScanner() {\n        br = new BufferedReader(new InputStreamReader(System.in), 32768);\n        st = null;\n    }\n\n    String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n                \n            }\n        }\n        return st.nextToken();\n    }\n\n    int ni() {\n        return Integer.parseInt(next());\n    }\n\n    int[] intArray(int N) {\n        int[] ret = new int[N];\n        for (int i = 0; i < N; i++)\n            ret[i] = ni();\n        return ret;\n    }\n\n    long nl() {\n        return Long.parseLong(next());\n    }\n\n    long[] longArray(int N) {\n        long[] ret = new long[N];\n        for (int i = 0; i < N; i++)\n            ret[i] = nl();\n        return ret;\n    }\n\n    double nd() {\n        return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n        String str = """";\n        try {\n            str = br.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}\n\nclass MultiSet {\n    TreeMap<Long, Integer> map = new TreeMap<>();\n    private int size = 0;\n    public MultiSet() {\n    }\n    public void add(Long val) {\n        map.put(val, map.getOrDefault(val, 0) + 1);\n        size++;\n    }\n    public void remove(Long val) {\n        map.put(val, map.get(val) - 1);\n        if (map.get(val) == 0) {\n            map.remove(val);\n        }\n        size--;\n    }\n    public int size() {\n        return size;\n    }\n    public Long higher(Long val) {\n        return map.higherKey(val);\n    }\n    public Long lower(Long val) {\n        return map.lowerKey(val);\n    }\n    public Long ceiling(Long val) {\n        return map.ceilingKey(val);\n    }\n    public Long floor(Long val) {\n        return map.floorKey(val);\n    }\n    public Long first() {\n        return map.firstKey();\n    }\n    public Long last() {\n        return map.lastKey();\n    }\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n}\n","constructive algorithms,graphs,trees"
"\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class P7 {\n\n	static Scanner in = new Scanner(System.in);\n	\n	public static void main(String[] args) {\n		int n = in.nextInt();\n		int t = in.nextInt();\n		int k = in.nextInt();\n		int[] a = array(t);\n		if (k > n-t) {\n			System.out.println(-1);\n			return;\n		}\n		int ans = n-t;\n		int[] p = new int[n];\n		int parent = 0;\n		int index = 1;\n		for (int i = 0; i < t; i++) {\n			int start = index;\n			for (int j = 0; j < a[i]; j++) {\n				p[index++] = parent;\n				if (ans > k && parent + 1 < start) {\n					parent++;\n					if (j + 1 < a[i]) ans--;\n				}\n			}\n			parent = start;\n		}\n		if (ans != k) {\n			System.out.println(-1);\n		} else {\n			System.out.println(n);\n			for (int i = 1; i < n; i++) {\n				System.out.println((i+1) + "" "" + (p[i] + 1));\n			}\n		}\n	}\n\n	private static int[] array(int n) {\n		int[] a = new int[n];\n		for (int i = 0; i < n; i++) a[i] = in.nextInt();\n		return a;\n	}\n\n}\n","constructive algorithms,graphs,trees"
import java.util.*;\nimport java.lang.*;\npublic class Main\n{\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n        if(isPrime(n)) System.out.println(1);\n        else if(isPrime(n-2)||n%2==0) System.out.println(2);\n        else System.out.println(3);\n	}\n	static boolean isPrime(int n){\n	    for(int i=2;i*i<=n;i++){\n	        if(n%i==0) return false;\n	    }\n	    return true;\n	}\n}\n,"math,number theory"
\n\nimport java.util.Scanner;\n\npublic class Solution{\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		     long n=sc.nextLong();\n		     \n		     if(prime(n)){System.out.println(1);return ;}\n		     \n		     if(n%2==0 || prime(n-2))System.out.println(2);\n		     else System.out.println(3);\n		     \n		     \n		\n	}\n	\n	static boolean prime(long n){\n	    for(long i=2;i*i<=n;i++){\n	       if(n%i==0)return false;\n	    }\n	    return true;\n	}\n\n}\n,"math,number theory"
import java.util.Scanner;\n\npublic class taxes {\n	static boolean isPr(int n) {\n		for (int i = 2; i <= Math.sqrt(n); i++) {\n			if (n % i == 0)\n				return false;\n		}\n		return true;\n	}\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		if (isPr(n)) {\n			System.out.println(1);\n		} else if (n % 2 == 0) {\n			System.out.println(2);\n		} else {\n			if (isPr(n - 2))\n				System.out.println(2);\n			else\n				System.out.println(3);\n		}\n		sc.close();\n	}\n},"math,number theory"
import java.util.*;\n\npublic class Main {\n\n  public static void main(String[] args) {\n    Scanner scn = new Scanner(System.in);\n    // your code here\n    long n = scn.nextLong();\n    if(isPrime(n)) System.out.println(1);\n    else if(n%2==0) System.out.println(2);\n    else{\n        if(isPrime(n-2)) System.out.println(2);\n        else System.out.println(3);\n    }\n  }\n  \n  private static boolean isPrime(long n){\n      for(long num = 2;num*num<=n;num++){\n          if(n%num==0) return false;\n      }\n      return true;\n  }\n},"math,number theory"
"\nimport java.util.HashMap;\nimport java.util.Scanner;\n\nimport javax.print.attribute.HashAttributeSet;\n\npublic class exams {\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		int n = s.nextInt();\n		int m = s.nextInt();\n		int[] day = new int[n];\n		int[] a = new int[m];\n		for (int i = 0; i < n; i++) {\n			day[i] = s.nextInt();\n		}\n		long min = m;\n		for (int i = 0; i < m; i++) {\n			a[i] = s.nextInt();\n			min += a[i];\n		}\n		long max = n;\n		if (min > max) {\n			System.out.println(-1);\n			return;\n		}\n		long ans = -1;\n		while (min <= max) {\n			long mid = (min + max) / 2;\n			if (check(day, a, (int) mid)) {\n				max = mid - 1;\n				ans = mid;\n			} else {\n				min = mid + 1;\n			}\n		}\n		System.out.println(ans);\n	}\n\n	private static boolean check(int[] day, int[] a, int m) {\n		// TODO Auto-generated method stub\n		int[] temp = new int[m];\n		HashMap<Integer, Boolean> map = new HashMap<>();\n		for (int i = m - 1; i >= 0; i--) {\n			if (day[i] != 0 && !map.containsKey(day[i])) {\n				map.put(day[i], true);\n				temp[i] = day[i];\n			}\n		}\n		if(map.size() < a.length)\n			return false;\n		\n		int count = 0 ;\n		for(int i = 0 ; i < m ;i++) {\n			if(temp[i] == 0) {\n				count++;\n			}else {\n				if(a[temp[i]-1] > count) {\n					return false;\n				}else {\n					count -= a[temp[i]-1];\n				}\n			}\n		}\n		return true;\n	}\n}\n","binary search,greedy,sortings"
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class Main\n{\n	public static void main (String[] args) throws java.lang.Exception\n	{\n	    Scanner sc=new Scanner(System.in);\n	   // BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n	    int t=1;\n	   // t=sc.nextInt();\n	  //  int t=Integer.parseInt(br.readLine());\n	    while(--t>=0){\n	        int n=sc.nextInt();\n	        int m=sc.nextInt();\n	        \n	         int a[]=new int[n];\n	        for(int i=0;i<n;i++)a[i]=sc.nextInt();\n	        \n	        int b[]=new int[n];\n	        for(int i=0;i<m;i++)b[i]=sc.nextInt();\n	        int l=1,r=n;\n	        int min=n+2;\n	        while(l<=r){\n	            int mid=(l+r)/2;\n	           // System.out.println(mid);\n	            boolean v[]=new boolean[m];\n	            long needed=0;\n	            int dist=0;\n	            for(int i=mid-1;i>=0;i--){\n	                if(a[i]==0||v[a[i]-1])needed=Math.max(needed-1,0);\n	                else{\n	                  needed=needed+b[a[i]-1];\n	                  v[a[i]-1]=true;\n	                  dist++;\n	                } \n	            }\n	            if(dist>=m&&needed==0){\n	                r=mid-1;\n	                min=Math.min(min,mid);\n	            }\n	            else{\n	                l=mid+1;\n	            }\n	            \n	        }\n	        if(min>n)System.out.println(-1);\n	        else System.out.println(min);\n	        \n	    }\n	    \n	}\n}\n","binary search,greedy,sortings"
/**\n * Created by ezhang on 7/23/17.\n */\nimport java.util.*;\nimport java.io.*;\n\npublic class CF_732D {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n\n        int[] D = new int[N];\n        int[] A = new int[M];\n\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < N; i++)\n            D[i] = Integer.parseInt(st.nextToken()) - 1;\n\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < M; i++)\n            A[i] = Integer.parseInt(st.nextToken());\n\n        int lo = 1;\n        int hi = N + 1;\n        while (lo != hi) {\n            int mid = (lo + hi) / 2;\n            // see if using first mid days [0..mid) is sufficient\n            boolean[] seen = new boolean[M];\n            int debt = 0;\n            int count = 0;\n            for (int i = mid - 1; i >= 0; i--) {\n                if (D[i] != -1 && !seen[D[i]]) {\n                    seen[D[i]] = true;\n                    ++count;\n                    debt -= A[D[i]];\n                }\n                else {\n                    if (debt < 0) ++debt;\n                }\n            }\n\n            if (debt == 0 && count == M) {\n                // we can take all the tests in the first mid days\n                hi = mid;\n            }\n            else {\n                lo = mid + 1;\n            }\n        }\n        out.println(lo <= N ? lo : -1);\n\n        out.flush();\n        System.exit(0);\n    }\n}\n,"binary search,greedy,sortings"
"import java.io.*;\nimport java.util.*;\nimport java.lang.*;\n\npublic class Rextester{\n    static class Pair{\n        int exam;\n        int seen;\n        Pair(){\n            exam = -1;\n            seen = -1;\n        }\n    }\n    \n    static boolean possible(int count,int[] exams,int[] prep){\n        Pair[] lastSeen = new Pair[prep.length];\n        boolean[] done = new boolean[prep.length];\n        int p = prep.length-1;\n        for(int i=0;i<prep.length;i++){\n            lastSeen[i]=new Pair();\n        }\n        for(int i=count-1;i>=0;i--){\n            if(exams[i]==0){\n                continue;\n            }\n            else if(!done[exams[i]-1]){\n                done[exams[i]-1]=true;\n                lastSeen[p].exam = exams[i]-1;\n                lastSeen[p].seen = i;\n                p--;\n            }\n        }\n        int days = 0;\n        for(int i=0;i<prep.length;i++){\n            if(lastSeen[i].seen==-1){\n                return false;\n            }\n            days += (i==0 ? lastSeen[i].seen : lastSeen[i].seen - 1 - lastSeen[i-1].seen);\n            if(days>=prep[lastSeen[i].exam]){\n                days-=prep[lastSeen[i].exam];\n            }\n            else{\n                return false;\n            }\n        }\n        return true;                   \n    }\n    \n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        StringTokenizer st1 = new StringTokenizer(br.readLine());\n        StringTokenizer st2 = new StringTokenizer(br.readLine());\n        br.close();\n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        int[] exams = new int[n];\n        for(int i=0;i<n;i++){\n            exams[i]=Integer.parseInt(st1.nextToken());\n        }\n        int[] prep = new int[k];\n        for(int i=0;i<k;i++){\n            prep[i]=Integer.parseInt(st2.nextToken());\n        }\n        int low = 0,high = n;\n        while(high>low){\n            int mid = (high+low)/2;\n            if(possible(mid,exams,prep)){\n                high = mid;\n            }\n            else{\n                low = mid+1;\n            }\n        }\n        if(possible(low,exams,prep)){\n            System.out.println(low);\n        }\n        else{\n            System.out.println(""-1"");\n        }\n            \n    }\n}\n    ","binary search,greedy,sortings"
"import java.util.*;\n \npublic class Main {\n	\n	public static void main(String args[]){\n		Scanner sc = new Scanner(System.in);\n		\n		String s = ""a""+sc.next();\n		int sum=0;\n		for(int i=1;i<s.length();i++){\n			int d = Math.abs(s.charAt(i)-s.charAt(i-1));\n			int rot = Math.min(d, 26-d);\n			sum+= rot;\n		}\n		System.out.print(sum);\n	}\n	}","implementation,strings"
"\nimport java.util.*;\npublic class Answer {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		String s;\n		s=sc.next();\n		s='a'+s;\n		int sum=0;\n		for(int i=1;i<s.length();i++) {\n			sum+=Math.min(Math.abs(s.charAt(i)-s.charAt(i-1)),26-Math.abs(s.charAt(i)-s.charAt(i-1)));\n		}\n		System.out.println(sum);\n	}\n	 \n}\n","implementation,strings"
"\nimport java.util.*;\npublic class Answer {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		String s;\n		s=sc.next();\n		s='a'+s;\n		int sum=0;\n		for(int i=1;i<s.length();i++) {\n			sum+=Math.min(Math.abs(s.charAt(i)-s.charAt(i-1)),26-Math.abs(s.charAt(i)-s.charAt(i-1)));\n		}\n		System.out.println(sum);\n	}\n	 \n}\n","implementation,strings"
"import java.util.Scanner;\npublic class Main {\npublic static void main(String[] args) {\nScanner in=new Scanner(System.in);\nString x = in.nextLine();\nx = 'a' + x;\nint s = 0;\nfor(int i = 1; i < x.length(); i++)\n{\ns += Math.min(Math.abs(x.charAt(i) - x.charAt(i - 1)), 26 - Math.abs(x.charAt(i) - x.charAt(i - 1)));\n}\n\nSystem.out.println(s);\n\n}\n}","implementation,strings"
"import java.util.Scanner;\n\npublic class Main {\n    static Scanner scn = new Scanner(System.in);\n    public static int ask(int x ,int y){\n        System.out.println(""? ""+x+"" ""+y);\n        System.out.flush();\n        return scn.nextInt();\n    }\n    public static void main(String[] args) {\n        int n = scn.nextInt();\n        int x = ask(1,2);\n        int y = ask(2,3);\n        int z = ask(1,3);\n        int [] arr = new int[n+1];\n        arr[1] = (x-y+z) / 2;\n        arr[2] = x - arr[1];\n        arr[3] = z - arr[1];\n        for(int i = 4 ; i <= n ; i++){\n            int temp = ask(i,i-1);\n            arr[i] = temp - arr[i-1];\n        }\n        System.out.print(""! "");\n        System.out.flush();\n        for(int i = 1 ; i <= n ; i++)\n            System.out.print(arr[i]+"" "");\n    }\n}\n\n  	  		  	 		  	  			 			","constructive algorithms,interactive,math"
"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int arr[] = new int[n+3];\n        int a = ask(1, 2);\n        int b = ask(1, 3);\n        int c = ask(2, 3);\n\n        arr[1] = (a + b - c) / 2;\n        arr[2] = a - arr[1];\n        arr[3] = b - arr[1];\n\n        for(int i = 4; i <= n; ++i) arr[i] = ask(i-1, i) - arr[i-1];\n\n        System.out.print(""!"");\n        for(int i = 1; i <= n; ++i) System.out.print("" "" + arr[i]);\n        System.out.println();\n\n        sc.close();\n    }\n\n    static int ask(int i, int j)\n    {\n        System.out.println(""? "" + i + "" "" + j);\n        System.out.flush();\n\n        Scanner sc = new Scanner(System.in);\n        int res = sc.nextInt();\n\n        return res;\n    }\n\n}","constructive algorithms,interactive,math"
"import java.io.*;\nimport java.util.*;\n\npublic class Codeforces\n{\n    static BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n    public static void main(String args[])throws Exception\n    {\n        StringBuilder sb=new StringBuilder();\n        int n=Integer.parseInt(bu.readLine());\n        int x=query(0,1),y=query(1,2),z=query(0,2);\n        int a[]=new int[n],i;\n        a[0]=(x-y+z)/2; a[1]=x-a[0]; a[2]=z-a[0];\n\n        for(i=3;i<n;i++)\n        {\n            x=query(0,i);\n            a[i]=x-a[0];\n        }\n        sb.append(""! "");\n        for(i=0;i<n;i++) sb.append(a[i]+"" "");\n        System.out.println(sb);\n        System.out.flush();\n    }\n\n    static int query(int i,int j)throws Exception\n    {\n        System.out.println(""? ""+(i+1)+"" ""+(j+1));\n        int a=Integer.parseInt(bu.readLine());\n        System.out.flush();\n        return a;\n    }\n}\n","constructive algorithms,interactive,math"
"import java.util.*;\n\npublic class Main {\n  public static void main(String[] args){\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    int[] array = new int[n + 1];\n    System.out.println(""? 1 "" + n);\n    System.out.flush();\n    int a1an = in.nextInt();\n    System.out.println(""? 1 2"");\n    System.out.flush();\n    int a1a2 = in.nextInt();\n    System.out.println(""? 2 "" + n);\n    System.out.flush();\n    int a2an = in.nextInt();\n    array[1] = (a1an + a1a2 - a2an) / 2;\n    array[2] = a1a2 - array[1]; \n    array[n] = a2an - array[2];\n    for (int i = 3; i < array.length - 1; i++){\n      System.out.println(""? "" + (i - 1) + "" "" + i);\n      System.out.flush();\n      int ans = in.nextInt();\n      array[i] = ans - array[i - 1];\n    }\n\n    System.out.print(""! "");\n    for (int i = 1; i < array.length; i++) System.out.print(array[i] + "" ""); System.out.println();\n  }\n}","constructive algorithms,interactive,math"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF725E extends PrintWriter {\n	CF725E() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF725E o = new CF725E(); o.main(); o.flush();\n	}\n\n	int[] kk, next;\n	boolean check(int c, int a) {\n		int b = c + 1;\n		while (c > 0) {\n			b = next[Math.min(b, c)];\n			if (b <= a && a <= c) {\n				c -= a;\n				a = -1;\n			} else {\n				if (b == 0)\n					return false;\n				int k = Math.min(kk[b], c / b);\n				c -= k * b;\n				b--;\n			}\n		}\n		return true;\n	}\n	void main() {\n		int c = sc.nextInt();\n		int n = sc.nextInt();\n		kk = new int[c + 1];\n		while (n-- > 0) {\n			int x = sc.nextInt();\n			kk[x]++;\n		}\n		next = new int[c + 1];\n		for (int a = c, b = c; b >= 1; b--)\n			if (kk[b] > 0)\n				while (a >= b) {\n					next[a] = b;\n					a--;\n				}\n		for (int a = 1; a <= c; a++)\n			if (!check(c, a)) {\n				println(a);\n				return;\n			}\n		println(""Greed is good"");\n	}\n}\n","brute force,greedy"
"import java.util.*;\nimport java.io.*;\n \npublic class too_much_money extends PrintWriter {\n	too_much_money() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		too_much_money o = new too_much_money(); o.main(); o.flush();\n	}\n \n	int[] kk, next;\n	boolean check(int c, int a) {\n		int b = c + 1;\n		while (c > 0) {\n			b = next[Math.min(b, c)];\n			if (b <= a && a <= c) {\n				c -= a;\n				a = -1;\n			} else {\n				if (b == 0)\n					return false;\n				int k = Math.min(kk[b], c / b);\n				c -= k * b;\n				b--;\n			}\n		}\n		return true;\n	}\n	void main() {\n		int c = sc.nextInt();\n		int n = sc.nextInt();\n		kk = new int[c + 1];\n		while (n-- > 0) {\n			int x = sc.nextInt();\n			kk[x]++;\n		}\n		next = new int[c + 1];\n		for (int a = c, b = c; b >= 1; b--)\n			if (kk[b] > 0)\n				while (a >= b) {\n					next[a] = b;\n					a--;\n				}\n		for (int a = 1; a <= c; a++)\n			if (!check(c, a)) {\n				println(a);\n				return;\n			}\n		\n		println(""Greed is good"");\n	}\n}\n","brute force,greedy"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		FastScanner in = new FastScanner(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		TaskE solver = new TaskE();\n		solver.solve(1, in, out);\n		out.close();\n	}\n\n	static class TaskE {\n		public void solve(int testNumber, FastScanner in, PrintWriter out) {\n			int c = in.nextInt();\n			int n = in.nextInt();\n			int[] a = new int[n];\n			int[] coins = new int[c + 1];\n			for (int i = 0; i < n; i++) {\n				a[i] = in.nextInt();\n				++coins[a[i]];\n			}\n\n			int[] who = new int[c + 1];\n			int cur = -1;\n			for (int i = 0; i <= c; i++) {\n				if (coins[i] > 0) {\n					cur = i;\n				}\n				who[i] = cur;\n			}\n\n			int ans = Integer.MAX_VALUE;\n			for (int i = c; i > 0; i--) {\n				if (c >= i && !can(c - i, who, coins)) {\n					ans = Math.min(ans, i);\n				}\n				int take = Math.min(coins[i], c / i);\n				c -= i * take;\n				if (coins[i] > 0) {\n					coins[i] = 0;\n\n					cur = who[i - 1];\n					for (int j = i; j <= c; j++) {\n						who[j] = cur;\n					}\n				}\n			}\n\n			if (ans == Integer.MAX_VALUE) {\n				out.println(""Greed is good"");\n			} else {\n				out.println(ans);\n			}\n		}\n\n		private boolean can(int c, int[] who, int[] coins) {\n			int i = c;\n			while (c > 0) {\n				int x = Math.min(who[i], who[c]);\n				if (x < 0) {\n					break;\n				}\n				int am = coins[x];\n				int take = Math.min(am, c / x);\n				c -= x * take;\n				i = x - 1;\n			}\n			return c == 0;\n		}\n\n	}\n\n	static class FastScanner {\n		private BufferedReader in;\n		private StringTokenizer st;\n\n		public FastScanner(InputStream stream) {\n			in = new BufferedReader(new InputStreamReader(stream));\n		}\n\n		public String next() {\n			while (st == null || !st.hasMoreTokens()) {\n				try {\n					String rl = in.readLine();\n					if (rl == null) {\n						return null;\n					}\n					st = new StringTokenizer(rl);\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n			return st.nextToken();\n		}\n\n		public int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n	}\n}\n\n","brute force,greedy"
"import static java.lang.Double.parseDouble;\nimport static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Math.min;\nimport static java.lang.System.arraycopy;\nimport static java.lang.System.exit;\nimport static java.util.Arrays.sort;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class E {\n\n	static BufferedReader in;\n	static PrintWriter out;\n	static StringTokenizer tok;\n\n	static void solve() throws Exception {\n		int c = nextInt();\n		int n = nextInt();\n		int a[] = new int[n];\n		for (int i = 0; i < n; i++) {\n			a[i] = nextInt();\n		}\n		sort(a);\n		int need[] = new int[n + 1];\n		int offset[] = new int[n + 1];\n		need[n] = c + 1;\n		offset[n] = 0;\n		for (int i = n - 1; i >= 0; i--) {\n			if (a[i] > need[i + 1] / 2) {\n				need[i] = a[i];\n				offset[i] = offset[i + 1];\n			} else {\n				need[i] = need[i + 1] - a[i];\n				offset[i] = offset[i + 1] + a[i];\n			}\n		}\n		boolean can[] = new boolean[c + 1];\n		can[offset[0]] = true;\n		for (int i = 0; i < n; i++) {\n			if (a[i] > need[i + 1] / 2) {\n				arraycopy(can, offset[i], can, offset[i] + a[i], need[i + 1] - a[i]);\n			} else {\n				arraycopy(can, offset[i], can, offset[i + 1], a[i]);\n			}\n		}\n		if (!can[c]) {\n			throw new AssertionError();\n		}\n		int ans = Integer.MAX_VALUE;\n		for (int i = n - 1, pos = 0; i >= 0; i--) {\n			if (pos + a[i] > c) {\n				continue;\n			}\n			for (int j = pos + 1; j < pos + a[i] && j < c - a[i]; j++) {\n				if (!can[j]) {\n					ans = min(ans, c - j);\n				}\n			}\n			pos += a[i];\n		}\n		if (ans == Integer.MAX_VALUE) {\n			out.print(""Greed is good"");\n		} else {\n			out.print(ans);\n		}\n	}\n\n	static int nextInt() throws IOException {\n		return parseInt(next());\n	}\n\n	static long nextLong() throws IOException {\n		return parseLong(next());\n	}\n\n	static double nextDouble() throws IOException {\n		return parseDouble(next());\n	}\n\n	static String next() throws IOException {\n		while (tok == null || !tok.hasMoreTokens()) {\n			tok = new StringTokenizer(in.readLine());\n		}\n		return tok.nextToken();\n	}\n\n	public static void main(String[] args) {\n		try {\n			in = new BufferedReader(new InputStreamReader(System.in));\n			out = new PrintWriter(new OutputStreamWriter(System.out));\n			solve();\n			in.close();\n			out.close();\n		} catch (Throwable e) {\n			e.printStackTrace();\n			exit(1);\n		}\n	}\n}","brute force,greedy"
"import java.util.*;\nimport java.io.*;\n\npublic class spanning_tree {\n	\n	static int s, t;\n	\n	public static void main(String[] args) throws Exception {\n		Scanner sc = new Scanner(System.in);\n		PrintWriter out = new PrintWriter(System.out);\n		int n = sc.nextInt(), m = sc.nextInt();\n		int [] x = new int[m];\n		int [] y = new int[m];\n		boolean [] tak = new boolean[m];\n		for (int i = 0; i < y.length; i++) {\n			x[i] = sc.nextInt();\n			y[i] = sc.nextInt();\n			x[i]--; y[i]--;\n		}\n		s = sc.nextInt(); t = sc.nextInt();\n		s--; t--;\n		int ds = sc.nextInt(), dt = sc.nextInt();\n		UnionFind uf = new UnionFind(n);\n		int dir = -1;\n		int [] iS = new int[n];\n		Arrays.fill(iS, -1);\n		int [] iT = new int[n];\n		Arrays.fill(iT, -1);\n		for (int i = 0; i < y.length; i++) {\n			if(good(x[i]) && good(y[i])){\n				if(uf.union(x[i], y[i]))\n					tak[i] = true;\n			}\n			else if(!good(x[i]) && !good(y[i]))\n				dir = i;\n			else if(!good(x[i])){\n				if(x[i] == s)\n					iS[y[i]] = i;\n				else iT[y[i]] = i;\n			}\n			else {\n				if(y[i] == s)\n					iS[x[i]] = i;\n				else iT[x[i]] = i;\n			}\n		}\n		for (int i = 0; i < iT.length; i++) {\n			if(iS[i] != -1 && iT[i] != -1 || iS[i] == -1 && iT[i] == -1)\n				continue;\n			if(iS[i] != -1){\n				if(uf.union(i, s)){\n					--ds;\n					tak[iS[i]] = true;\n				}\n			}\n			else {\n				if(uf.union(i, t)){\n					--dt;\n					tak[iT[i]] = true;\n				}\n			}\n		}\n		for (int i = 0; i < iT.length; i++) {\n			if(iS[i] == -1 || iT[i] == -1)\n				continue;\n			if(ds > 0 && dt > 0 && !uf.same(s, t)){\n				if(uf.union(s, i)){\n					--ds;\n					tak[iS[i]] = true;\n				}\n				if(uf.union(t, i)){\n					--dt;\n					tak[iT[i]] = true;\n				}\n			}\n			else if(ds > 0 && uf.union(s, i)){\n				--ds;\n				tak[iS[i]] = true;\n			}\n			else if(dt > 0 && uf.union(t, i)){\n				--dt;\n				tak[iT[i]] = true;\n			}\n		}\n		if(dir != -1 && uf.union(s, t)){\n			--ds; \n			--dt;\n			tak[dir] = true;\n		}\n		if(uf.numS > 1 || ds < 0 || dt < 0)\n			out.println(""No"");\n		else{\n			out.println(""Yes"");\n			for (int i = 0; i < tak.length; i++) {\n				if(tak[i])\n					out.println(x[i]+1 + "" "" + (y[i]+1));\n			}\n		}\n		out.flush();\n		out.close();\n	}\n	\n	static boolean good(int u){\n		return u != s && u != t;\n	}\n	\n	static class UnionFind {                                              \n		int[] p, rank; \n		int numS;\n \n		UnionFind(int N) \n		{\n			p = new int[N];\n			rank = new int[N];\n			for (int i = 0; i < N; i++) \n				p[i] = i;\n			numS = N;\n		}\n \n		boolean same(int x, int y){\n			return findSet(x) == findSet(y);\n		}\n		int findSet(int x) { return p[x] == x ? x : (p[x] = findSet(p[x])); }\n \n		boolean union(int x, int y) \n		{ \n			if(same(x, y))\n				return false;\n			x = findSet(x);\n			y = findSet(y);\n			numS--;\n			if (rank[x] > rank[y]) \n				p[y] = x;\n			else\n			{	\n				p[x] = y;\n				if(rank[x] == rank[y])\n					++rank[y]; \n			} \n			return true;\n		}\n	}\n	static class Scanner {\n		StringTokenizer st;\n		BufferedReader br;\n \n		public Scanner(InputStream s)\n		{\n			br = new BufferedReader(new InputStreamReader(s));\n		}\n \n		public Scanner(FileReader fileReader)\n		{\n			br = new BufferedReader(fileReader);\n		}\n \n		public String next() throws IOException\n		{\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n \n		public int nextInt() throws IOException\n		{\n			return Integer.parseInt(next());\n		}\n \n		public long nextLong() throws IOException\n		{\n			return Long.parseLong(next());\n		}\n \n		public String nextLine() throws IOException\n		{\n			return br.readLine();\n		}\n \n		public boolean ready() throws IOException\n		{\n			return br.ready();\n		}\n	}\n}\n","dsu,graphs,greedy,implementation"
"import java.io.*;\nimport java.util.*;\n\npublic class CF723F {\n	static class E {\n		int u, v;\n		E(int u, int v) {\n			this.u = u;\n			this.v = v;\n		}\n		@Override public String toString() {\n			return (u + 1) + "" "" + (v + 1);\n		}\n	}\n	static int[] dsu;\n	static int find(int i) {\n		return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));\n	}\n	static boolean join(int i, int j) {\n		i = find(i);\n		j = find(j);\n		if (i == j)\n			return false;\n		if (dsu[i] > dsu[j])\n			dsu[i] = j;\n		else if (dsu[i] < dsu[j])\n			dsu[j] = i;\n		else {\n			dsu[i]--;\n			dsu[j] = i;\n		}\n		return true;\n	}\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int n = Integer.parseInt(st.nextToken());\n		int m = Integer.parseInt(st.nextToken());\n		E[] ee = new E[m];\n		for (int i = 0; i < m; i++) {\n			st = new StringTokenizer(br.readLine());\n			int u = Integer.parseInt(st.nextToken()) - 1;\n			int v = Integer.parseInt(st.nextToken()) - 1;\n			ee[i] = new E(u, v);\n		}\n		st = new StringTokenizer(br.readLine());\n		int s = Integer.parseInt(st.nextToken()) - 1;\n		int t = Integer.parseInt(st.nextToken()) - 1;\n		int ds = Integer.parseInt(st.nextToken());\n		int dt = Integer.parseInt(st.nextToken());\n		dsu = new int[n];\n		Arrays.fill(dsu, -1);\n		ArrayList<E> ll = new ArrayList<>();\n		ArrayList<E> ls = new ArrayList<>();\n		ArrayList<E> lt = new ArrayList<>();\n		E est = null;\n		for (int i = 0; i < m; i++) {\n			E e = ee[i];\n			boolean is = e.u == s || e.v == s;\n			boolean it = e.u == t || e.v == t;\n			if (is && it)\n				est = e;\n			else if (is)\n				ls.add(e);\n			else if (it)\n				lt.add(e);\n			else if (join(e.u, e.v))\n				ll.add(e);\n		}\n		boolean[] rr = new boolean[n];\n		for (int u = 0; u < n; u++) {\n			int r = find(u);\n			if (r != s && r != t)\n				rr[r] = true;\n		}\n		E[] ss = new E[n];\n		E[] tt = new E[n];\n		for (E e : ls) {\n			int u = e.u == s ? e.v : e.u;\n			u = find(u);\n			ss[u] = e;\n		}\n		for (E e : lt) {\n			int u = e.u == t ? e.v : e.u;\n			u = find(u);\n			tt[u] = e;\n		}\n		for (int r = 0; r < n; r++) {\n			if (!rr[r])\n				continue;\n			if (ss[r] == null && tt[r] == null) {\n				System.out.println(""No"");\n				return;\n			}\n			if (ss[r] == null) {\n				ll.add(tt[r]);\n				dt--;\n			}\n			if (tt[r] == null) {\n				ll.add(ss[r]);\n				ds--;\n			}\n			if (dt < 0 || ds < 0) {\n				System.out.println(""No"");\n				return;\n			}\n		}\n		boolean s_t = false;\n		for (int r = 0; r < n; r++) {\n			if (!rr[r])\n				continue;\n			if (ss[r] == null || tt[r] == null)\n				continue;\n			if (!s_t && ds > 0 && dt > 0) {\n				s_t = true;\n				ll.add(ss[r]);\n				ll.add(tt[r]);\n				ds--;\n				dt--;\n			} else if (ds > 0) {\n				ll.add(ss[r]);\n				ds--;\n			} else if (dt > 0) {\n				ll.add(tt[r]);\n				dt--;\n			} else {\n				System.out.println(""No"");\n				return;\n			}\n		}\n		if (!s_t && est != null && ds > 0 && dt > 0) {\n			s_t = true;\n			ll.add(est);\n			ds--;\n			dt--;\n		}\n		if (!s_t) {\n			System.out.println(""No"");\n			return;\n		}\n		PrintWriter pw = new PrintWriter(System.out);\n		pw.println(""Yes"");\n		for (E e : ll)\n			pw.println(e);\n		pw.close();\n	}\n}\n","dsu,graphs,greedy,implementation"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class A {\n\n	static int s, t;\n	\n	public static void main(String[] args) throws IOException \n	{\n		Scanner sc = new Scanner(System.in);\n		PrintWriter out = new PrintWriter(System.out);\n		\n		int n = sc.nextInt(), m = sc.nextInt(), x[] = new int[m], y[] = new int[m];\n		boolean[] take = new boolean[m];\n		for(int i = 0; i < m; ++i)\n		{\n			x[i] = sc.nextInt() - 1;\n			y[i] = sc.nextInt() - 1;\n		}\n		s = sc.nextInt() - 1;\n		t = sc.nextInt() - 1;\n		int ds = sc.nextInt(), dt = sc.nextInt();\n		DSU dsu = new DSU(n);\n		for(int i = 0; i < m; ++i)	\n			if(good(x[i]) && good(y[i]) && dsu.union(x[i], y[i]))\n				take[i] = true;\n		int[] comp = new int[n], sTake = new int[n], tTake = new int[n];\n		int directIdx = -1;\n		for(int i = 0; i < m; ++i)\n		{\n			if(!good(x[i]) && !good(y[i]))\n			{\n				directIdx = i;\n				continue;\n			}\n			int j = dsu.find(!good(x[i]) ? y[i] : x[i]);\n			if(x[i] == s || y[i] == s)\n			{\n				comp[j] |= 1;\n				sTake[j] = i;\n			}\n			if(x[i] == t || y[i] == t)\n			{\n				comp[j] |= 2;\n				tTake[j] = i;\n			}\n		}\n		boolean possible = true, first = true;\n		for(int i = 0; i < n; ++i)\n			if(good(i) && dsu.find(i) == i)\n			{\n				if(comp[i] == 0)\n					possible = false;\n				else if(comp[i] == 1)\n				{\n					--ds;\n					take[sTake[i]] = true;\n				}\n				else if(comp[i] == 2)\n				{\n					--dt;\n					take[tTake[i]] = true;\n				}\n			}\n		for(int i = 0; i < n; ++i)\n			if(comp[i] == 3)\n			{\n				if(first)\n				{\n					first = false;\n					--ds;\n					--dt;\n					take[sTake[i]] = true;\n					take[tTake[i]] = true;\n				}\n				else if(ds > 0)\n				{\n					--ds;\n					take[sTake[i]] = true;\n				}\n				else\n				{\n					--dt;\n					take[tTake[i]] = true;\n				}\n			}\n		if(first && directIdx != -1)\n		{\n			take[directIdx] = true;\n			first = false;\n			--ds;\n			--dt;\n		}\n		possible &= ds >= 0 && dt >= 0 && !first;\n		if(!possible)\n			out.println(""No"");\n		else\n		{\n			out.println(""Yes"");		\n			for(int i = 0; i < m; ++i)\n				if(take[i])\n					out.printf(""%d %d\n"", x[i] + 1, y[i] + 1);\n		}\n		out.flush();\n		out.close();\n	}\n	\n	static boolean good(int x) { return x != s && x != t; }\n	\n	static class DSU\n	{\n		int[] r, p;\n		\n		DSU(int N)\n		{\n			r = new int[N];\n			p = new int[N];\n			for(int i = 0; i < N; ++i)\n				p[i] = i;\n		}\n		\n		int find(int x) { return x == p[x] ? x : (p[x] = find(p[x])); }\n		\n		boolean union(int x, int y)\n		{\n			x = find(x);\n			y = find(y);\n			if(x == y)\n				return false;\n			if(r[x] > r[y])\n				p[y] = x;\n			else\n			{\n				p[x] = y;\n				if(r[x] == r[y])\n					++r[y];\n			}\n			return true;\n		}\n	}\n\n	static class Scanner \n	{\n		StringTokenizer st;	\n		BufferedReader br;\n\n		public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}\n\n		public String next() throws IOException \n		{\n			while (st == null || !st.hasMoreTokens()) \n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		public int nextInt() throws IOException {return Integer.parseInt(next());}\n\n		public long nextLong() throws IOException {return Long.parseLong(next());}\n\n		public String nextLine() throws IOException {return br.readLine();}\n\n		public double nextDouble() throws IOException { return Double.parseDouble(next()); }\n	}\n}","dsu,graphs,greedy,implementation"
"// package CF;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\npublic class F {\n	static int s, t;\n	public static void main(String[] args) throws Exception\n	{\n		Scanner sc = new Scanner(System.in);\n		PrintWriter out = new PrintWriter(System.out);\n		int n = sc.nextInt(), m = sc.nextInt();\n		int [] x = new int[m];\n		int [] y = new int[m];\n		boolean [] tak = new boolean[m];\n		for (int i = 0; i < y.length; i++) {\n			x[i] = sc.nextInt();\n			y[i] = sc.nextInt();\n			x[i]--; y[i]--;\n		}\n		s = sc.nextInt(); t = sc.nextInt();\n		s--; t--;\n		int ds = sc.nextInt(), dt = sc.nextInt();\n		UnionFind uf = new UnionFind(n);\n		int dir = -1;\n		int [] iS = new int[n];\n		Arrays.fill(iS, -1);\n		int [] iT = new int[n];\n		Arrays.fill(iT, -1);\n		for (int i = 0; i < y.length; i++) {\n			if(good(x[i]) && good(y[i])){\n				if(uf.union(x[i], y[i]))\n					tak[i] = true;\n			}\n			else if(!good(x[i]) && !good(y[i]))\n				dir = i;\n			else if(!good(x[i])){\n				if(x[i] == s)\n					iS[y[i]] = i;\n				else iT[y[i]] = i;\n			}\n			else {\n				if(y[i] == s)\n					iS[x[i]] = i;\n				else iT[x[i]] = i;\n			}\n		}\n		for (int i = 0; i < iT.length; i++) {\n			if(iS[i] != -1 && iT[i] != -1 || iS[i] == -1 && iT[i] == -1)\n				continue;\n			if(iS[i] != -1){\n				if(uf.union(i, s)){\n					--ds;\n					tak[iS[i]] = true;\n				}\n			}\n			else {\n				if(uf.union(i, t)){\n					--dt;\n					tak[iT[i]] = true;\n				}\n			}\n		}\n		for (int i = 0; i < iT.length; i++) {\n			if(iS[i] == -1 || iT[i] == -1)\n				continue;\n			if(ds > 0 && dt > 0 && !uf.same(s, t)){\n				if(uf.union(s, i)){\n					--ds;\n					tak[iS[i]] = true;\n				}\n				if(uf.union(t, i)){\n					--dt;\n					tak[iT[i]] = true;\n				}\n			}\n			else if(ds > 0 && uf.union(s, i)){\n				--ds;\n				tak[iS[i]] = true;\n			}\n			else if(dt > 0 && uf.union(t, i)){\n				--dt;\n				tak[iT[i]] = true;\n			}\n		}\n		if(dir != -1 && uf.union(s, t)){\n			--ds; \n			--dt;\n			tak[dir] = true;\n		}\n		if(uf.numS > 1 || ds < 0 || dt < 0)\n			out.println(""No"");\n		else{\n			out.println(""Yes"");\n			for (int i = 0; i < tak.length; i++) {\n				if(tak[i])\n					out.println(x[i]+1 + "" "" + (y[i]+1));\n			}\n		}\n		out.flush();\n		out.close();\n	}\n	static boolean good(int u){\n		return u != s && u != t;\n	}\n	static class UnionFind {                                              \n		int[] p, rank; \n		int numS;\n\n		UnionFind(int N) \n		{\n			p = new int[N];\n			rank = new int[N];\n			for (int i = 0; i < N; i++) \n				p[i] = i;\n			numS = N;\n		}\n\n		boolean same(int x, int y){\n			return findSet(x) == findSet(y);\n		}\n		int findSet(int x) { return p[x] == x ? x : (p[x] = findSet(p[x])); }\n\n		boolean union(int x, int y) \n		{ \n			if(same(x, y))\n				return false;\n			x = findSet(x);\n			y = findSet(y);\n			numS--;\n			if (rank[x] > rank[y]) \n				p[y] = x;\n			else\n			{	\n				p[x] = y;\n				if(rank[x] == rank[y])\n					++rank[y]; \n			} \n			return true;\n		}\n	}\n	static class Scanner {\n		StringTokenizer st;\n		BufferedReader br;\n\n		public Scanner(InputStream s)\n		{\n			br = new BufferedReader(new InputStreamReader(s));\n		}\n\n		public Scanner(FileReader fileReader)\n		{\n			br = new BufferedReader(fileReader);\n		}\n\n		public String next() throws IOException\n		{\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		public int nextInt() throws IOException\n		{\n			return Integer.parseInt(next());\n		}\n\n		public long nextLong() throws IOException\n		{\n			return Long.parseLong(next());\n		}\n\n		public String nextLine() throws IOException\n		{\n			return br.readLine();\n		}\n\n		public boolean ready() throws IOException\n		{\n			return br.ready();\n		}\n	}\n}","dsu,graphs,greedy,implementation"
"import java.io.*;\nimport java.util.*;\npublic class cf715b {\nstatic ArrayList<Integer>[] adj;\nstatic long[][] w;\nstatic int n,m,s,t,l;\nstatic long[] d1;\nstatic long[] d2;\n	public static void main(String[] args)throws IOException {\n		BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer(bf.readLine());\n		n=Integer.parseInt(st.nextToken());\n		m=Integer.parseInt(st.nextToken());\n		l=Integer.parseInt(st.nextToken());\n		s=Integer.parseInt(st.nextToken());\n		t=Integer.parseInt(st.nextToken());\n		adj=new ArrayList[n];\n		int[] u=new int[m];\n		int[] v=new int[m];\n		w=new long[n][n];\n		d1=new long[n];\n		d2=new long[n];\n		for(int i=0;i<n;i++) {\n			adj[i]=new ArrayList<Integer>();\n		}\n		for(int i=0;i<m;i++) {\n			st=new StringTokenizer(bf.readLine());\n			u[i]=Integer.parseInt(st.nextToken());\n			v[i]=Integer.parseInt(st.nextToken());\n			int w1=Integer.parseInt(st.nextToken());\n			adj[u[i]].add(v[i]);\n			adj[v[i]].add(u[i]);\n			w[u[i]][v[i]]=(w1==0)?-1:w1;\n			w[v[i]][u[i]]=(w1==0)?-1:w1;\n		}\n		dijk();\n		dijk2();\n		if(d2[t]!=l) System.out.println(""NO"");\n		else {\n			System.out.println(""YES"");\n			for(int i=0;i<m;i++) {\n				if(w[u[i]][v[i]]==-1) System.out.println(u[i]+"" ""+v[i]+"" 1000000000"");\n				else System.out.println(u[i]+"" ""+v[i]+"" ""+w[u[i]][v[i]]);\n			}\n		}\n	}\n	static void dijk() {\n		TreeSet<pair> pq=new TreeSet<>();\n		pq.add(new pair(0,t));\n		Arrays.fill(d1, Long.MAX_VALUE);\n		d1[t]=0;\n		boolean[] vis=new boolean[n];\n		while(!pq.isEmpty()) {\n			pair p=pq.pollFirst();\n			int x=p.b;\n			long d=p.a;\n			vis[x]=true;\n			if(d>d1[x]) continue;\n			for(int i:adj[x]) {\n				if(!vis[i]) {\n					long nxt=d+Math.abs(w[x][i]);\n					if(nxt<d1[i]) {\n						d1[i]=nxt;\n						pq.add(new pair(d1[i],i));\n					}\n				}\n			}\n		}\n	}\n	static void dijk2() {\n		TreeSet<pair> pq=new TreeSet<>();\n		pq.add(new pair(0,s));\n		Arrays.fill(d2, Long.MAX_VALUE);\n		d2[s]=0;\n		boolean[] vis=new boolean[n];\n		while(!pq.isEmpty()) {\n			pair p=pq.pollFirst();\n			int x=p.b;\n			long d=p.a;\n			if(vis[x]) continue;\n			vis[x]=true;\n			for(int i:adj[x]) {\n				if(!vis[i]) {\n					long nxt=(w[x][i]==-1)?Math.max(1, l-d1[i]-d):w[x][i];\n					if(nxt+d<=d2[i]) {\n						d2[i]=nxt+d;\n						w[x][i]=nxt;\n						w[i][x]=nxt;\n						pq.add(new pair(d2[i],i));\n					}\n				}\n			}\n		}\n	}\n	static class pair implements Comparable<pair>{\n		long a;int b;\n		public pair(long aa,int bb) {\n			a=aa; b=bb;\n		}\n		public int compareTo(pair p) {\n			if(a>p.a) {\n				return 1;\n			}\n			return -1;\n		}\n	}\n}\n","binary search,constructive algorithms,graphs,shortest paths"
"import java.io.*;\nimport java.util.*;\npublic class cf715b {\nstatic ArrayList<Integer>[] adj;\nstatic long[][] w;\nstatic int n,m,s,t,l;\nstatic long[] d1;\nstatic long[] d2;\n	public static void main(String[] args)throws IOException {\n		BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer(bf.readLine());\n		n=Integer.parseInt(st.nextToken());\n		m=Integer.parseInt(st.nextToken());\n		l=Integer.parseInt(st.nextToken());\n		s=Integer.parseInt(st.nextToken());\n		t=Integer.parseInt(st.nextToken());\n		adj=new ArrayList[n];\n		int[] u=new int[m];\n		int[] v=new int[m];\n		w=new long[n][n];\n		d1=new long[n];\n		d2=new long[n];\n		for(int i=0;i<n;i++) {\n			adj[i]=new ArrayList<Integer>();\n		}\n		for(int i=0;i<m;i++) {\n			st=new StringTokenizer(bf.readLine());\n			u[i]=Integer.parseInt(st.nextToken());\n			v[i]=Integer.parseInt(st.nextToken());\n			int w1=Integer.parseInt(st.nextToken());\n			adj[u[i]].add(v[i]);\n			adj[v[i]].add(u[i]);\n			w[u[i]][v[i]]=(w1==0)?-1:w1;\n			w[v[i]][u[i]]=(w1==0)?-1:w1;\n		}\n		dijk();\n		dijk2();\n		if(d2[t]!=l) System.out.println(""NO"");\n		else {\n			System.out.println(""YES"");\n			for(int i=0;i<m;i++) {\n				if(w[u[i]][v[i]]==-1) System.out.println(u[i]+"" ""+v[i]+"" 1000000000"");\n				else System.out.println(u[i]+"" ""+v[i]+"" ""+w[u[i]][v[i]]);\n			}\n		}\n	}\n	static void dijk() {\n		TreeSet<pair> pq=new TreeSet<>();\n		pq.add(new pair(0,t));\n		Arrays.fill(d1, Long.MAX_VALUE);\n		d1[t]=0;\n		boolean[] vis=new boolean[n];\n		while(!pq.isEmpty()) {\n			pair p=pq.pollFirst();\n			int x=p.b;\n			long d=p.a;\n			vis[x]=true;\n			if(d>d1[x]) continue;\n			for(int i:adj[x]) {\n				if(!vis[i]) {\n					long nxt=d+Math.abs(w[x][i]);\n					if(nxt<d1[i]) {\n						d1[i]=nxt;\n						pq.add(new pair(d1[i],i));\n					}\n				}\n			}\n		}\n	}\n	static void dijk2() {\n		TreeSet<pair> pq=new TreeSet<>();\n		pq.add(new pair(0,s));\n		Arrays.fill(d2, Long.MAX_VALUE);\n		d2[s]=0;\n		boolean[] vis=new boolean[n];\n		while(!pq.isEmpty()) {\n			pair p=pq.pollFirst();\n			int x=p.b;\n			long d=p.a;\n			vis[x]=true;\n			if(d>d2[x]) continue;\n			for(int i:adj[x]) {\n				if(!vis[i]) {\n					long nxt=(w[x][i]==-1)?Math.max(1, l-d1[i]-d):w[x][i];\n					if(nxt+d<=d2[i]) {\n						d2[i]=nxt+d;\n						w[x][i]=nxt;\n						w[i][x]=nxt;\n						pq.add(new pair(d2[i],i));\n					}\n				}\n			}\n		}\n	}\n	static class pair implements Comparable<pair>{\n		long a;int b;\n		public pair(long aa,int bb) {\n			a=aa; b=bb;\n		}\n		public int compareTo(pair p) {\n			if(a==p.a) {\n				return b-p.b;\n			}\n			if(a>p.a) {\n				return 1;\n			}\n			return -1;\n		}\n	}\n}\n","binary search,constructive algorithms,graphs,shortest paths"
"import java.io.*;\nimport java.util.*;\n\npublic class complete_graph {\n	static long BIG = (long)1e13;\n	static int ASONE = 2, ASBIG = 1, NOTUSED = 0; \n	static void dijkstra(ArrayList<Integer>[] adj, long[][] adjm, int[] from, long[] cost, int useBig, int s)\n	{\n		PriorityQueue<Long> pq = new PriorityQueue<>();\n		pq.add(0L+s);\n		cost[s] = 0;\n		boolean[] isDone = new boolean[adj.length];\n		while (!pq.isEmpty())\n		{\n			long p = pq.poll();\n			int v = (int)(p%1000);\n			long c = p/1000;\n			if (isDone[v]) continue;\n			isDone[v] = true;\n			for (int i = 0; i < adj[v].size(); ++i)\n			{\n				int vv = adj[v].get(i);\n				long cc = adjm[v][vv];\n				boolean isBig = cc == BIG;\n				if (isBig && useBig == NOTUSED) continue;\n				long newCost = isBig ? c+(useBig==ASONE?1:BIG) : c + cc;\n				if (cost[vv] == -1 || newCost < cost[vv]) {\n					cost[vv] = newCost;\n					from[vv] = v;\n					pq.add(1000*newCost+vv);\n				}\n			}\n		}\n \n	}\n	public static void main(String[] args) throws Exception\n	{\n		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer toks = new StringTokenizer(in.readLine());\n		int n = Integer.parseInt(toks.nextToken());\n		int m = Integer.parseInt(toks.nextToken());\n		int L = Integer.parseInt(toks.nextToken());\n		int s = Integer.parseInt(toks.nextToken());\n		int t = Integer.parseInt(toks.nextToken());\n		ArrayList<Integer>[] adj = new ArrayList[n]; \n		long[][] adjm = new long[n][n];\n		for (int i = 0; i < n; ++i) Arrays.fill(adjm[i], -1);\n		for (int i = 0; i < n; ++i) adj[i] = new ArrayList<Integer>();\n		for (int i = 0; i < m; ++i)\n		{\n			toks = new StringTokenizer(in.readLine());\n			int u = Integer.parseInt(toks.nextToken());\n			int v = Integer.parseInt(toks.nextToken());\n			int w = Integer.parseInt(toks.nextToken());\n			adj[u].add(v);\n			adj[v].add(u);\n			adjm[u][v] = w == 0 ? BIG : (long)w;\n			adjm[v][u] = w == 0 ? BIG : (long)w;\n		}\n		int[] from = new int[n];\n		long[] cost = new long[n];\n		Arrays.fill(from,-1); Arrays.fill(cost, -1);		\n		dijkstra(adj, adjm, from, cost, ASONE, s);\n		if (cost[t] > L || cost[t] == -1) { System.out.println(""NO""); return; }\n		Arrays.fill(from,-1); Arrays.fill(cost, -1);		\n		dijkstra(adj, adjm, from, cost, ASBIG, s);\n		if (cost[t] != -1 && cost[t] < L) { System.out.println(""NO""); return; }\n		outer: for (int i = 0; i < adj.length; ++i) \n			for (int j = 0; j < adj[i].size(); ++j)\n			{\n				int v = adj[i].get(j);\n				if (adjm[i][v] != BIG) continue;\n				adjm[i][v] = adjm[v][i] = 1;\n				Arrays.fill(from,-1); Arrays.fill(cost, -1);		\n				dijkstra(adj, adjm, from, cost, ASBIG, s);\n				if (cost[t] != -1 && cost[t] <= L) { adjm[i][v] = adjm[v][i] += L-cost[t]; break outer; } \n			}\n		printGraph(adj,adjm);\n	}\n \n	static void printGraph(ArrayList<Integer>[] adj, long[][] adjm)\n	{\n		StringBuilder sb = new StringBuilder();\n		sb.append(""YES\n"");\n		for (int i = 0; i < adj.length; ++i)\n		{\n			for (int j = 0; j < adj[i].size(); ++j)\n			{\n				int v = adj[i].get(j);\n				if (v > i) continue;\n				sb.append(i).append(' ').append(v).append(' ').append(adjm[i][v]).append('\n');\n			}\n		}\n		System.out.print(sb);\n	}\n}\n","binary search,constructive algorithms,graphs,shortest paths"
"import java.io.*;\nimport java.util.*;\n\npublic class complete_graph {\n	static long BIG = (long)1e13;\n	static int ASONE = 2, ASBIG = 1, NOTUSED = 0; \n	static void dijkstra(ArrayList<Integer>[] adj, long[][] adjm, int[] from, long[] cost, int useBig, int s)\n	{\n		PriorityQueue<Long> pq = new PriorityQueue<>();\n		pq.add(0L+s);\n		cost[s] = 0;\n		boolean[] isDone = new boolean[adj.length];\n		while (!pq.isEmpty())\n		{\n			long p = pq.poll();\n			int v = (int)(p%1000);\n			long c = p/1000;\n			if (isDone[v]) continue;\n			//System.out.printf(""Looking at %d with cost %d, %d\n"", v,c,useBig);\n			isDone[v] = true;\n			for (int i = 0; i < adj[v].size(); ++i)\n			{\n				int vv = adj[v].get(i);\n				long cc = adjm[v][vv];\n				boolean isBig = cc == BIG;\n				if (isBig && useBig == NOTUSED) continue;\n				long newCost = isBig ? c+(useBig==ASONE?1:BIG) : c + cc;\n				if (cost[vv] == -1 || newCost < cost[vv]) {\n					cost[vv] = newCost;\n					from[vv] = v;\n					//System.out.printf(""Updating cost of %d to %d, %d\n"", vv, newCost, useBig);\n					pq.add(1000*newCost+vv);\n				}\n			}\n		}\n \n	}\n	public static void main(String[] args) throws Exception\n	{\n		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer toks = new StringTokenizer(in.readLine());\n		int n = Integer.parseInt(toks.nextToken());\n		int m = Integer.parseInt(toks.nextToken());\n		int L = Integer.parseInt(toks.nextToken());\n		int s = Integer.parseInt(toks.nextToken());\n		int t = Integer.parseInt(toks.nextToken());\n		ArrayList<Integer>[] adj = new ArrayList[n]; \n		long[][] adjm = new long[n][n];\n		for (int i = 0; i < n; ++i) Arrays.fill(adjm[i], -1);\n		for (int i = 0; i < n; ++i) adj[i] = new ArrayList<Integer>();\n		for (int i = 0; i < m; ++i)\n		{\n			toks = new StringTokenizer(in.readLine());\n			int u = Integer.parseInt(toks.nextToken());\n			int v = Integer.parseInt(toks.nextToken());\n			int w = Integer.parseInt(toks.nextToken());\n			adj[u].add(v);\n			adj[v].add(u);\n			adjm[u][v] = w == 0 ? BIG : (long)w;\n			adjm[v][u] = w == 0 ? BIG : (long)w;\n		}\n		int[] from = new int[n];\n		long[] cost = new long[n];\n		Arrays.fill(from,-1); Arrays.fill(cost, -1);		\n		dijkstra(adj, adjm, from, cost, ASONE, s);\n		if (cost[t] > L || cost[t] == -1) { System.out.println(""NO""); return; }\n		Arrays.fill(from,-1); Arrays.fill(cost, -1);		\n		dijkstra(adj, adjm, from, cost, ASBIG, s);\n		if (cost[t] != -1 && cost[t] < L) { System.out.println(""NO""); return; }\n		outer: for (int i = 0; i < adj.length; ++i) \n			for (int j = 0; j < adj[i].size(); ++j)\n			{\n				int v = adj[i].get(j);\n				if (adjm[i][v] != BIG) continue;\n				adjm[i][v] = adjm[v][i] = 1;\n				Arrays.fill(from,-1); Arrays.fill(cost, -1);		\n				dijkstra(adj, adjm, from, cost, ASBIG, s);\n				if (cost[t] != -1 && cost[t] <= L) { adjm[i][v] = adjm[v][i] += L-cost[t]; break outer; } \n			}\n		printGraph(adj,adjm);\n	}\n \n	static void printGraph(ArrayList<Integer>[] adj, long[][] adjm)\n	{\n		StringBuilder sb = new StringBuilder();\n		sb.append(""YES\n"");\n		for (int i = 0; i < adj.length; ++i)\n		{\n			for (int j = 0; j < adj[i].size(); ++j)\n			{\n				int v = adj[i].get(j);\n				if (v > i) continue;\n				sb.append(i).append(' ').append(v).append(' ').append(adjm[i][v]).append('\n');\n			}\n		}\n		System.out.print(sb);\n	}\n}\n","binary search,constructive algorithms,graphs,shortest paths"
"import java.util.*;\npublic class Problem0712c {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int y = sc.nextInt();\n        int x = sc.nextInt();\n        int side1 = x;\n        int side2 = x;\n        int side3 = x;\n        int time = 0;\n        while(Math.max(Math.max(side1, side2), side3) < y) {\n            side3 = (side1 + side2) - 1;\n            time++;\n            if (side3 >= y) {\n                break;\n            }\n            side2 = (side1 + side3) - 1;\n            time++;\n            if(side2 >= y) {\n                break;\n            }\n            side1 = (side2 + side3) - 1;\n            time++;\n            if(side1 >= y) {\n                break;\n            }\n        }\n        System.out.println(time+2);\n    }\n\n}\n","greedy,math"
"import java.util.*;\nimport java.io.*;\n\npublic class memory {\n    int X, Y;\n\n    memory(BufferedReader in, PrintWriter out) throws IOException {\n        StringTokenizer st = new StringTokenizer(in.readLine());\n        X = Integer.parseInt(st.nextToken());\n        Y = Integer.parseInt(st.nextToken());\n        if (X == Y) {\n            out.println(0);\n            return;\n        } else if (X > Y) {\n            int t = X;\n            X = Y;\n            Y = t;\n        }\n\n        int side1 = X, side2 = X, side3 = X, seconds = 0;\n        while (side1 < Y || side2 < Y || side3 < Y) {\n            if (side1 <= side2 && side2 <= side3) {\n                // Side1 min\n                side1 = side2 + side3 - 1;\n            } else if (side2 <= side1 && side2 <= side3) {\n                // Side2 min\n                side2 = side1 + side3 - 1;\n            } else {\n                // Side3 min\n                side3 = side1 + side2 - 1;\n            }\n            seconds++;\n        }\n        out.println(seconds);\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        new memory(in, out);\n        in.close();\n        out.close();\n    }\n}\n","greedy,math"
"import java.io.*;\nimport java.lang.*;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.math.*;\n\n// Sachin_2961 submission //\npublic class CodeforcesA {\n\n    public long check(int a,int b,int c){\n        long s = (a + b + c)/2;\n        long s1 = s * (s - a)* (s-b) * (s-c);\n        return (long)Math.sqrt(s1);\n    }\n    public void solve() {\n        int x = fs.nInt(), y = fs.nInt();\n        int a = y, b = y, c = y,move =0;\n        while ( true ){\n            if ( a >= x && b >= x && c >= x )\n                break;\n            move++;\n            if( move%3 == 1)\n                a = b + c - 1;\n            else if (move%3 == 2)\n                b = a + c - 1;\n            else if ( move%3 == 0)\n                c = a + b -1;\n\n        }\n        out.println(move);\n    }\n\n    static boolean multipleTestCase = false; static FastScanner fs; static PrintWriter out;\n    public void run(){\n        fs = new FastScanner();\n        out = new PrintWriter(System.out);\n        int tc = (multipleTestCase)?fs.nInt():1;\n        while (tc-->0)solve();\n        out.flush();\n        out.close();\n    }\n    static long max(long a,long b){ return Math.max(a,b);}\n    static long min(long a,long b){ return Math.min(a,b);}\n    static long abs(long a){return Math.abs(a);}\n    public static void main(String[]args){\n        try{\n            new CodeforcesA().run();\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n\n    }\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer("""");\n        String n() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        String Line()\n        {\n            String str = """";\n            try\n            {\n                str = br.readLine();\n            }catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        int nInt() {return Integer.parseInt(n()); }\n        long nLong() {return Long.parseLong(n());}\n        int[]aI(int n){\n            int[]ar = new int[n];\n            for(int i=0;i<n;i++)\n                ar[i] = nInt();\n            return ar;\n        }\n    }\n}","greedy,math"
"import java.util.*;\nimport java.math.*;\nimport java.io.*;\nimport java.text.*;\n\npublic class practice {\n    // heloo world nudniobv udivbo\n    // buyfhsfnoisdfnoi\n    public static void merge(int arr[], int l, int m, int r) {\n        // Find sizes of two subarrays to be merged\n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        /* Create temp arrays */\n        int L[] = new int[n1];\n        int R[] = new int[n2];\n\n        /*Copy data to temp arrays*/\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n\n        /* Merge the temp arrays */\n\n        // Initial indexes of first and second subarrays\n        int i = 0, j = 0;\n\n        // Initial index of merged subarry array\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        /* Copy remaining elements of L[] if any */\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        /* Copy remaining elements of R[] if any */\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    // Main function that sorts arr[l..r] using\n    // merge()\n    public static void sort(int arr[], int l, int r) {\n        if (l < r) {\n            // Find the middle point\n            int m = (l + r) / 2;\n\n            // Sort first and second halves\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            // Merge the sorted halves\n            merge(arr, l, m, r);\n        }\n    }\n\n    public static long getValue(char a, char b, char x[]) {\n        long m1 = 0, m2 = 0, ans = 0;\n        for (int i = 0; i < x.length; i++) {\n            if (i % 2 == 0 && x[i] != a) {\n                m1++;\n            }\n            if (i % 2 != 0 && x[i] != b) {\n                m2++;\n            }\n        }\n        ans = Math.max(m1, m2);\n        return ans;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int x = Integer.parseInt(st.nextToken());\n        int y = Integer.parseInt(st.nextToken());\n        int a = y;\n        int b= y;\n        int c = y;\n        int ans = 0;\n        while(true){\n            //check the current\n            if(a>=x && b>=x && c>=x){\n                System.out.println(ans);\n                break;\n            }\n            ans++;\n            if(ans%3==1){\n                //update a\n                a = b+c-1;\n            }\n            if(ans%3==2){\n                //update b\n                b = a+c-1;\n            }\n            if(ans%3==0){\n                //update c\n                c = a+b-1;\n            }\n        }\n    }\n}","greedy,math"
import java.util.*;\n\npublic class Letters{\n\n    public static void main(String args[]){\n\n        Scanner scan = new Scanner (System.in);\n\n        String t = scan.next();\n        char s [] = t.toCharArray();\n        int i = 0;\n        int j = 0;\n        for(i=0; i<t.length(); i++){\n            if(s[i] != 'a'){\n                j++;\n            }\n            if(j>0 && s[i]=='a'){\n                break;\n            }\n            if(j>0){\n                s[i]=(char)(s[i]-1);\n            }\n        }\n        if(j==0){\n            s[t.length()-1]='z';\n        }\n        for(char z:s){\n            System.out.print(z);\n        }\n    }\n},"constructive algorithms,greedy,implementation,strings"
"import java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        new Main();\n    }\n\n    public Main() {\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.nextLine();\n        int i = 0;\n        while (i < s.length() && s.charAt(i) == 'a') i++;\n        if (i == s.length()) {\n            System.out.println(s.substring(0, s.length() - 1) + ""z"");\n            return;\n        }\n        StringBuilder b = new StringBuilder(s.substring(0, i));\n        for (; i < s.length() && s.charAt(i) != 'a'; i++) {\n            b.append((char) (s.charAt(i) - 1));\n        }\n        b.append(s.substring(i));\n        System.out.println(b);\n    }\n}","constructive algorithms,greedy,implementation,strings"
"import java.util.Scanner;\n\npublic class codeforces_708 {\n    public static void main(String[] args) {\n        Scanner sc  = new Scanner(System.in);\n        String s= sc.nextLine();\n        String ans="""";\n\n        int i=0;\n        while(i<s.length() && s.charAt(i)=='a')\n        {\n                if(i==s.length()-1)\n                    ans+='z';\n                else\n                    ans+='a';\n\n                i++;\n        }\n        boolean flag=true;\n        while(i<s.length())\n        {\n            if(s.charAt(i)=='a')\n                flag=false;\n            if(flag)\n                ans+=(char) (s.charAt(i)-1);\n\n            else\n                ans+=s.charAt(i);\n            i++;\n\n        }\n        System.out.println(ans);\n    }\n}\n","constructive algorithms,greedy,implementation,strings"
"import java.util.Scanner;\n\npublic class codeforces_708 {\n    public static void main(String[] args) {\n        Scanner sc  = new Scanner(System.in);\n        String s= sc.nextLine();\n        String ans="""";\n\n        int i=0;\n        while(i<s.length() && s.charAt(i)=='a')\n        {\n                if(i==s.length()-1)\n                    ans+='z';\n                else\n                    ans+='a';\n\n                i++;\n        }\n        boolean flag=true;\n        while(i<s.length())\n        {\n            if(s.charAt(i)=='a') {\n                flag = false;\n                break;\n            }\n            if(flag)\n                ans+=(char) (s.charAt(i)-1);\n\n            else\n                ans+=s.charAt(i);\n            i++;\n\n        }\n        if(!flag)\n        ans+=s.substring(i);\n        System.out.println(ans);\n    }\n}\n","constructive algorithms,greedy,implementation,strings"
"public class Triples {\n \n	public static void main(String[] args) throws Exception {\n		long n = new java.util.Scanner(System.in).nextInt();\n		if(n < 3) System.out.println(-1);\n		else if(n%2==1) System.out.println((n*n)/2 + "" "" + ((n*n)/2+1));\n		else System.out.println((n*n/4-1) + "" "" + (n*n/4+1));\n	}\n	\n}\n","math,number theory"
"public class Triples {\n \n	public static void main(String[] args) throws Exception {\n		long n = new java.util.Scanner(System.in).nextInt();\n		if(n < 3) System.out.println(-1);\n		else if(n%2==1) System.out.println((n*n)/2 + "" "" + ((n*n)/2+1));\n		else System.out.println((n*n/4-1) + "" "" + (n*n/4+1));\n	}\n	\n}\n","math,number theory"
"import java.util.Scanner;\n\npublic class E707C {\n    public static void main(String[] args) {\n        Scanner scn = new Scanner(System.in);\n        long a = scn.nextLong();\n        if (a < 3) {\n            System.out.println(-1);\n            return;\n        }\n        long sub = 1;\n        long sum = a * a;\n        if (a % 2 == 0) {\n            sum /= 2;\n            sub = 2;\n        }\n        System.out.print((sum - sub) / 2 + "" "" + (sum + sub) / 2);\n    }\n}\n","math,number theory"
"import java.io.*;\nimport java.util.*;\npublic class Pytriple\n{\n	public static void main(String args[])throws IOException\n	{\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		long x = Integer.parseInt(br.readLine());\n		long y=0,z=0;\n		if(x<=2){\n			System.out.println(""-1"");\n			return;\n		}\n		else\n		{\n			if(x%2==0)\n			{\n				y = x*x/4 + 1;\n				z = x*x/4 - 1;\n			}\n			else\n			{\n				y = (x*x+1)/2;\n				z = (x*x-1)/2; \n			}\n		}\n		System.out.println(z+"" ""+y);\n	}\n}","math,number theory"
"import java.util.Scanner;\npublic class ty {\n	public static void main(String[] args){\n		Scanner sc=new Scanner(System.in);\n		int n,i,m=0;\n		int a[] = new int[106];\n		n=sc.nextInt();\n		for (i=1;i<=n;i++)\n			a[i]=sc.nextInt();\n		for (i=1;i<=n;i++)\n		{\n			if (a[i]==0) m++;\n			if (a[i]==1&&a[i+1]==3) a[i+1]=2;\n			if (a[i]==2&&a[i+1]==3) a[i+1]=1;\n			if (a[i]==a[i+1]&&a[i+1]!=3) a[i+1]=0;\n		}\n		System.out.println(m);\n	}\n}",dp
"import java.util.Scanner;\npublic class ty {\n	public static void main(String[] args){\n		Scanner sc=new Scanner(System.in);\n		int n,i,m=0;\n		int a[] = new int[106];\n		n=sc.nextInt();\n		for (i=1;i<=n;i++)\n			a[i]=sc.nextInt();\n		for (i=1;i<=n;i++)\n		{\n			if (a[i]==0) m++;\n			if (a[i]==1&&a[i+1]==3) a[i+1]=2;\n			if (a[i]==2&&a[i+1]==3) a[i+1]=1;\n			if (a[i]==a[i+1]&&a[i+1]!=3) a[i+1]=0;\n		}\n		System.out.println(m);\n	}\n}",dp
import java.util.*;\nimport java.io.*;\npublic class cf {\n    public static void main(String[] args) {\n		Scanner in=new Scanner(System.in);\n		int n= in.nextInt();\n		int m=0;\n		int[] a=new int[n];\n		for(int i=0;i<n;i++){\n			a[i]=in.nextInt();\n		}\n		for(int i=0;i<n-1;i++){\n		 if(a[i]==0)  m++;\n		 if(a[i]==1 && a[i+1]==3)  a[i+1]=2;\n		 if(a[i]==2 && a[i+1]==3)  a[i+1]=1;\n		 if(a[i]==a[i+1] && a[i+1]!=3)  a[i+1]=0;\n		}\n		if(a[n-1]==0) m++;\n		System.out.println(m);\n		in.close();\n		return;\n    }\n}\n\n\n\n,dp
"import java.util.Scanner;\n\npublic class CR363A {\n	public static void main(String[] args) {\n\n		Scanner sc = new Scanner(System.in);\n\n		int n, i, m = 0;\n		int a[] = new int[106];\n		n = sc.nextInt();\n		for (i = 1; i <= n; i++)\n			a[i] = sc.nextInt();\n		for (i = 1; i <= n; i++) {\n			if (a[i] == 0)\n				m++;\n			if (a[i] == 1 && a[i + 1] == 3)\n				a[i + 1] = 2;\n			if (a[i] == 2 && a[i + 1] == 3)\n				a[i + 1] = 1;\n			if (a[i] == a[i + 1] && a[i + 1] != 3)\n				a[i + 1] = 0;\n		}\n		System.out.println(m);\n	}\n\n}\n",dp
"import java.util.Scanner;\npublic class NicholasandPermutation{\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int a = 0;\n		int b = 0;\n		for(int i = 1; i <= n; i++){\n			int g = sc.nextInt();\n			if(g == 1) a = i;\n			if(g == n) b = i;\n		}\n\n		System.out.println(Math.max(Math.max(n - b, b - 1), Math.max(n - a, a - 1)));\n	}\n}","constructive algorithms,implementation"
"import java.util.*;\n\n\npublic class Nicholas_and_Permutation {\n	public static void main(String args[]) {\n		Scanner sc = new Scanner(System.in);\n		int n =sc.nextInt(),x=0,y=0;\n		for(int i=0;i<n;i++)\n		{\n			int m =sc.nextInt();\n			if(m==n)\n				x=i+1;\n			if(m==1)\n				y=i+1;\n		}\n		if(y>x)\n		{\n			int temp =y;\n			y=x;\n			x=temp;\n		}\n		System.out.println(Math.max(x-1, n-y));\n	}\n}\n","constructive algorithms,implementation"
"import java.util.*;\npublic class JavaApplicationM{\npublic static void main(String[] args) {\nScanner in=new Scanner(System.in);\n\n//----------------------------------------------\nint n=in.nextInt();\nint s;\n\nint p=0,q=0,max=-1,min=101;\nfor(int i=0;i<n;i++)\n{\n    s=in.nextInt();\n    if(s>max){max=s;p=i+1;}\n    if(s<min){min=s;q=i+1;}\n}\nint v=Math.min(q, p),v1=Math.max(p, q);\nint z1=v1-1;\nint z2=n-v;\n\nSystem.out.println(Math.max(z1,z2));\n // \n}} \n\n","constructive algorithms,implementation"
"import java.util.*;\npublic class JavaApplicationM{\npublic static void main(String[] args) {\nScanner in=new Scanner(System.in);\n\n//----------------------------------------------\nint n=in.nextInt();\nint s;\n\nint p=0,q=0,max=-1,min=101;\nfor(int i=0;i<n;i++)\n{\n    s=in.nextInt();\n    if(s>max){max=s;p=i+1;}\n    if(s<min){min=s;q=i+1;}\n}\nint v=Math.min(q, p),v1=Math.max(p, q);\nint z1=v1-1;\nint z2=n-v;\n\nSystem.out.println(Math.max(z1,z2));\n // \n}} \n\n","constructive algorithms,implementation"
"import java.io.*;\nimport java.util.*;\npublic class cf653e {\nstatic TreeSet<Integer>[] adj;\nstatic TreeSet<Integer> avail;\nstatic int[] col;\n	public static void main(String[] args)throws IOException {\n		BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter out=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		StringTokenizer st=new StringTokenizer(bf.readLine());\n		int n=Integer.parseInt(st.nextToken());\n		int m=Integer.parseInt(st.nextToken());\n		int k=Integer.parseInt(st.nextToken());\n		adj=new TreeSet[n];\n		col=new int[n];\n		avail=new TreeSet<>();\n		for(int i=0;i<n;i++) {\n			adj[i]=new TreeSet<>();\n			if(i!=0) avail.add(i);\n		}\n		for(int i=0;i<m;i++) {\n			st=new StringTokenizer(bf.readLine());\n			int a1=Integer.parseInt(st.nextToken())-1;\n			int a2=Integer.parseInt(st.nextToken())-1;\n			adj[a1].add(a2);\n			adj[a2].add(a1);\n		}\n		int z=0;\n		for(int i=1;i<n;i++) {\n			if(col[i]==0) dfs(i,++z);\n		}\n		int x=n-1;\n		boolean[] no=new boolean[n];\n		for(int i:adj[0]) {\n			x--;\n			no[i]=true;\n		}\n		if(x<k||z>k) {\n			out.println(""impossible"");\n			out.close();\n			return;\n		}\n		boolean[] cols=new boolean[z+1];\n		for(int i=1;i<n;i++) {\n			if(!no[i]) cols[col[i]]=true;\n		}\n		for(int i=1;i<=z;i++) {\n			if(!cols[i]) {\n				out.println(""impossible"");\n				out.close();\n				return;\n			}\n		}\n		out.println(""possible"");\n		out.close();\n	}\n	static void dfs(int x, int z) {\n		col[x]=z;\n		ArrayList<Integer> q=new ArrayList<>();\n		for(int i:avail) {\n			if(!adj[x].contains(i)) {\n				q.add(i);\n			}\n		}\n		for(int i:q) {\n			avail.remove(i);\n		}\n		for(int i:q) {\n			dfs(i,z);\n		}\n	}\n}\n","dfs and similar,dsu,graphs,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class E {\n	FastScanner in;\n	PrintWriter out;\n\n	TreeSet<Integer>[] g;\n\n	String impossible = ""impossible"";\n	String possible = ""possible"";\n\n	TreeSet<Integer> notVisited = new TreeSet<>();\n	int[] color;\n\n	void dfs(int v, int col) {\n		color[v] = col;\n		ArrayList<Integer> vs = new ArrayList<>();\n		for (int u : notVisited) {\n			if (!g[v].contains(u)) {\n				vs.add(u);\n			}\n		}\n		for (int u : vs) {\n			notVisited.remove(u);\n		}\n		for (int u : vs) {\n			dfs(u, col);\n		}\n	}\n\n	void solve() {\n		int n = in.nextInt(), m = in.nextInt();\n		int k = in.nextInt();\n		g = new TreeSet[n];\n		color = new int[n];\n		for (int i = 0; i < n; i++) {\n			g[i] = new TreeSet<>();\n			if (i > 0) {\n				notVisited.add(i);\n			}\n		}\n		for (int i = 0; i < m; i++) {\n			int a = in.nextInt() - 1, b = in.nextInt() - 1;\n			g[a].add(b);\n			g[b].add(a);\n		}\n		int cntColor = 0;\n		for (int v = 1; v < n; v++) {\n			if (color[v] == 0) {\n				dfs(v, ++cntColor);\n			}\n		}\n		boolean[] was = new boolean[cntColor + 1];\n\n		boolean[] attached1 = new boolean[n];\n		int rest = n - 1;\n		for (int u : g[0]) {\n			attached1[u] = true;\n			rest--;\n		}\n		if (rest < k || cntColor > k) {\n			out.println(impossible);\n			return;\n		}\n		for (int i = 1; i < n; i++) {\n			if (!attached1[i]) {\n				was[color[i]] = true;\n			}\n		}\n		for (int i = 1; i <= cntColor; i++) {\n			if (!was[i]) {\n				out.println(impossible);\n				return;\n			}\n		}\n		out.println(possible);\n	}\n\n	void run() {\n		in = new FastScanner();\n		out = new PrintWriter(System.out);\n\n		solve();\n\n		out.close();\n	}\n\n	class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		public FastScanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		String next() {\n			while (st == null || !st.hasMoreTokens()) {\n				try {\n					st = new StringTokenizer(in.br.readLine());\n				} catch (IOException e) {\n					// TODO Auto-generated catch block\n					e.printStackTrace();\n				}\n			}\n			return st.nextToken();\n		}\n\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n	}\n\n	public static void main(String[] args) {\n		new E().run();\n	}\n}","dfs and similar,dsu,graphs,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class E {\n	FastScanner in;\n	PrintWriter out;\n\n	TreeSet<Integer>[] g;\n\n	String impossible = ""impossible"";\n	String possible = ""possible"";\n\n	TreeSet<Integer> notVisited = new TreeSet<>();\n	int[] color;\n\n	void dfs(int v, int col) {\n		color[v] = col;\n		ArrayList<Integer> vs = new ArrayList<>();\n		for (int u : notVisited) {\n			if (!g[v].contains(u)) {\n				vs.add(u);\n			}\n		}\n		for (int u : vs) {\n			notVisited.remove(u);\n		}\n		for (int u : vs) {\n			dfs(u, col);\n		}\n	}\n\n	void solve() {\n		int n = in.nextInt(), m = in.nextInt();\n		int k = in.nextInt();\n		g = new TreeSet[n];\n		color = new int[n];\n		for (int i = 0; i < n; i++) {\n			g[i] = new TreeSet<>();\n			if (i > 0) {\n				notVisited.add(i);\n			}\n		}\n		for (int i = 0; i < m; i++) {\n			int a = in.nextInt() - 1, b = in.nextInt() - 1;\n			g[a].add(b);\n			g[b].add(a);\n		}\n		int cntColor = 0;\n		for (int v = 1; v < n; v++) {\n			if (color[v] == 0) {\n				dfs(v, ++cntColor);\n			}\n		}\n		boolean[] was = new boolean[cntColor + 1];\n\n		boolean[] attached1 = new boolean[n];\n		int rest = n - 1;\n		for (int u : g[0]) {\n			attached1[u] = true;\n			rest--;\n		}\n		if (rest < k || cntColor > k) {\n			out.println(impossible);\n			return;\n		}\n		for (int i = 1; i < n; i++) {\n			if (!attached1[i]) {\n				was[color[i]] = true;\n			}\n		}\n		for (int i = 1; i <= cntColor; i++) {\n			if (!was[i]) {\n				out.println(impossible);\n				return;\n			}\n		}\n		out.println(possible);\n	}\n\n	void run() {\n		in = new FastScanner();\n		out = new PrintWriter(System.out);\n\n		solve();\n\n		out.close();\n	}\n\n	class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		public FastScanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		String next() {\n			while (st == null || !st.hasMoreTokens()) {\n				try {\n					st = new StringTokenizer(in.br.readLine());\n				} catch (IOException e) {\n					// TODO Auto-generated catch block\n					e.printStackTrace();\n				}\n			}\n			return st.nextToken();\n		}\n\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n	}\n\n	public static void main(String[] args) {\n		new E().run();\n	}\n}","dfs and similar,dsu,graphs,trees"
"import java.util.TreeSet;\nimport java.util.ArrayList;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.List;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Collections;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		Reader in = new Reader(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		TaskE solver = new TaskE();\n		solver.solve(1, in, out);\n		out.close();\n	}\n}\n\nclass TaskE {\n    List<Integer>[] r;\n    int n, k;\n    TreeSet<Integer> nw;\n    void dfs(int q) {\n        int j = 0; int one = 0;\n        int w = -1;\n        while (!nw.isEmpty()) {\n            Integer ww = nw.ceiling(w + 1);\n            if (ww == null) break;\n            w = ww;\n            while (j < r[q].size() && r[q].get(j) < w) j++;\n            if (j < r[q].size() && r[q].get(j) == w) continue;\n            nw.remove(w);\n            dfs(w);\n            if (q == 0) one++;\n            if (one == k) break;\n        }\n    }\n    public void solve(int testNumber, Reader in, PrintWriter out) {\n        n = in.nextInt();\n        r = new ArrayList[n];\n        nw = new TreeSet<>();\n        for (int i = 0; i < n; i++) nw.add(i);\n        for (int i = 0; i < n; i++) r[i] = new ArrayList<>();\n        int m = in.nextInt();\n        k = in.nextInt();\n        for (int i = 0; i < m; i++) {\n            int a = in.nextInt() - 1;\n            int b = in.nextInt() - 1;\n            r[a].add(b);\n            r[b].add(a);\n        }\n        for (int i = 0; i < n; i++) Collections.sort(r[i]);\n        nw.remove(0);\n\n        dfs(0);\n        out.println(nw.isEmpty() && r[0].size() <= n - k - 1 ? ""possible"" : ""impossible"");\n    }\n}\n\nclass Reader {\n    private BufferedReader in;\n    private StringTokenizer st;\n    public Reader(InputStream is) {\n        in = new BufferedReader(new InputStreamReader(is));\n    }\n    public String next() {\n        try {\n            while (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(in.readLine());\n            }\n            return st.nextToken();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}\n\n","dfs and similar,dsu,graphs,trees"
"import static java.lang.Double.parseDouble;\nimport static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.StringTokenizer;\n\npublic class F {\n	\n	static BufferedReader in;\n	static PrintWriter out;\n	static StringTokenizer tok;\n	\n	static void solve() throws Exception {\n		int n = nextInt();\n		int p = nextInt();\n		int q = nextInt();\n		if (p >= n) {\n			p = n - 1;\n		}\n		int c[] = new int[p + 1];\n		c[0] = 1;\n		for (int i = 1, val = 1, pow = 0; i <= p; i++) {\n			int mul = n - i + 1;\n			int shift = Integer.numberOfTrailingZeros(mul);\n			val *= mul >> shift;\n			pow += shift;\n			mul = i;\n			shift = Integer.numberOfTrailingZeros(mul);\n			val *= BigInteger.valueOf(mul >> shift).modInverse(BigInteger.valueOf(0x100000000L)).intValue();\n			pow -= shift;\n			c[i] = pow >= 32 ? 0 : val << pow;\n		}\n		int ans = 0;\n		for (int day = 1; day <= q; day++) {\n			int cans = 0;\n			for (int i = 0, pow = 1; i <= p; i++, pow *= day) {\n				cans += c[i] * pow;\n			}\n			ans ^= day * cans;\n		}\n		out.print(ans & 0xffffffffL);\n	}\n	\n	static int nextInt() throws IOException {\n		return parseInt(next());\n	}\n\n	static long nextLong() throws IOException {\n		return parseLong(next());\n	}\n\n	static double nextDouble() throws IOException {\n		return parseDouble(next());\n	}\n\n	static String next() throws IOException {\n		while (tok == null || !tok.hasMoreTokens()) {\n			tok = new StringTokenizer(in.readLine());\n		}\n		return tok.nextToken();\n	}\n\n	public static void main(String[] args) {\n		try {\n			in = new BufferedReader(new InputStreamReader(System.in));\n			out = new PrintWriter(new OutputStreamWriter(System.out));\n			solve();\n			in.close();\n			out.close();\n		} catch (Throwable e) {\n			e.printStackTrace();\n			exit(1);\n		}\n	}\n}\n","dp,math,meet-in-the-middle"
"import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class VK16_3F {\n\n	static int B;\n	static int P;\n	static int Q;\n\n	static long[] iFact;\n	static long[] iFact2;\n\n	public static void main0(String[] args) {\n		System.out.println(Integer.toUnsignedString(inv(7)));\n	}\n\n	static int[] numF;\n	static int[] numFP;\n	static int[] iNumF;\n\n	static int[] denF;\n	static int[] denFP;\n	static int[] iDenF;\n\n	public static void main(String[] args) throws IOException {\n		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		StringTokenizer inputData = new StringTokenizer(reader.readLine());\n\n		B = Integer.parseInt(inputData.nextToken());\n		P = Integer.parseInt(inputData.nextToken());\n		P = Math.min(P, B);\n		Q = Integer.parseInt(inputData.nextToken());\n\n		numF = new int[P * 2 + 1];\n		numF[0] = 1;\n		numFP = new int[P * 2 + 1];\n\n		iNumF = new int[P * 2 + 1];\n\n		for (int i = 1; i <= P * 2; i++) {\n			int cPow = Integer.numberOfTrailingZeros(B - i + 1);\n			numF[i] = numF[i - 1] * ((B - i + 1) >> cPow);\n			numFP[i] = numFP[i - 1] + cPow;\n		}\n\n		for (int i = 0; i <= P * 2; i++) {\n			iNumF[i] = inv(numF[i]);\n		}\n\n		denF = new int[P * 2 + 1];\n		denF[0] = 1;\n		denFP = new int[P * 2 + 1];\n\n		iDenF = new int[P * 2 + 1];\n\n		for (int i = 1; i <= P * 2; i++) {\n			int cPow = Integer.numberOfTrailingZeros(i);\n			denF[i] = denF[i - 1] * (i >> cPow);\n			denFP[i] = denFP[i - 1] + cPow;\n		}\n\n		for (int i = 0; i <= P * 2; i++) {\n			iDenF[i] = inv(denF[i]);\n		}\n\n		int ans = 0;\n		for (int n = 1; n <= Q; n++) {\n			ans ^= n * calculate(n);\n		}\n		printer.println(Integer.toUnsignedString(ans));\n		printer.close();\n	}\n\n	static int calculate(int n) {\n		int cPow = 1;\n		int sum = 0;\n		int endI = Math.min(P, B - 1);\n		for (int i = 0; i <= endI; i++) {\n			sum += comb(B, i) * cPow;\n			cPow *= n;\n		}\n		return sum;\n	}\n\n	static int comb(int n, int k) {\n		int off = B - n;\n		int cNumF = numF[k + off] * iNumF[off];\n		int cNumP = numFP[k + off] - numFP[off];\n		return (cNumF * iDenF[k]) << (cNumP - denFP[k]);\n	}\n\n	static int inv(int n) {\n		int x = 1;\n		x = x * (2 - x * n); /* Newton's method */\n		x = x * (2 - x * n); /* 5 steps enough for 32 bits */\n		x = x * (2 - x * n);\n		x = x * (2 - x * n);\n		x = x * (2 - x * n);\n		return x;\n	}\n}\n","dp,math,meet-in-the-middle"
"import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        double a=sc.nextDouble();\n        double b=sc.nextDouble();\n        double c=sc.nextDouble();\n        double k=(-b+Math.pow((b*b)-(4*a*c),0.5))/(2*a);\n        double l=(-b-Math.pow((b*b)-(4*a*c),0.5))/(2*a);\n        System.out.println(Math.max(k,l));\n        System.out.println(Math.min(k,l));\n    }\n}",math
"\n    import java.math.BigInteger;\n    import java.util.*;\n    public class Main\n    {\n        public static void main(String[] args) {\n            Scanner input = new Scanner(System.in);\n            StringBuffer sb = new StringBuffer();\n            int a = input.nextInt() , b = input.nextInt() , c = input.nextInt() ;\n            double delta = Math.pow(b,2) - (4*a*c) ;\n            double x1 = (-b-Math.sqrt(delta))/(2*a);\n            double x2 = (-b+Math.sqrt(delta))/(2*a);\n            System.out.println(Math.max(x1,x2));\n            System.out.println(Math.min(x1,x2));\n        }\n\n    }\n",math
"import java.util.*;\npublic class Forecast {\n\n	public static void main(String[] args) {\n		Scanner Scan = new Scanner(System.in);\n		\n		//System.out.println(""Enter a:"");\n		Double a = Scan.nextDouble();\n		//System.out.println(""Enter b:"");\n		Double b = Scan.nextDouble();\n		//System.out.println(""Enter c:"");\n		Double c = Scan.nextDouble();\n		\n		Double Delta=(b*b)-(4*a*c);\n		Double X1= (-b-Math.sqrt(Delta))/(2*a);\n		Double X2= (-b+Math.sqrt(Delta))/(2*a);\n		\n		Double Min= X1;\n		Double Max= X2;\n		if(X2<Min) {\n			Min= X2;\n			Max= X1;\n		}\n		System.out.println(Max);\n		System.out.println(Min);\n	}\n\n}\n",math
"import java.io.*;\nimport java.util.*;\nimport java.lang.*;\n\npublic class Sol {\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        double a = Double.parseDouble(st.nextToken()), b = Double.parseDouble(st.nextToken()), c = Double.parseDouble(st.nextToken());\n        double pl = Math.sqrt(b*b - 4*a*c), mi = pl;\n        mi *= -1;\n        pl += -b; mi += -b;\n        pl /= (2*a); mi /= (2*a);\n        out.println( (pl > mi ? pl + ""\n"" + mi : mi + ""\n"" + pl) );\n        br.close(); out.close();\n    }\n}",math
"import java.util.*;\npublic class Orchestra\n{\n	public static void main(String[] args)\n	{\n		Scanner in = new Scanner(System.in);\n		\n		int r = in.nextInt();\n		int c = in.nextInt();\n		int n = in.nextInt();\n		int k = in.nextInt();\n		\n		Viola[] violas = new Viola[n];\n		for(int x = 0; x < n; x++)\n		{\n			violas[x] = new Viola(in.nextInt() - 1, in.nextInt() - 1);\n		}\n		\n		Arrays.sort(violas);\n		\n		int[] column = new int[n + 2];\n		for(int y = 0; y < violas.length; y++)\n		{\n			violas[y].index = y + 1;\n			column[y + 1] = violas[y].col;\n		}\n		\n		column[0] = -1;\n		column[n + 1] = c;\n		\n		Arrays.sort(violas, new CompareRow());\n		\n		int index = 0;\n		long result = 0;\n		for(int z = 0; z < r; z++)\n		{\n			while(index < violas.length && violas[index].row == z)\n			{\n				index++;\n			}\n			\n			ArrayList<Viola> list = new ArrayList<Viola>();\n			for(int a = 0; a < index; a++)\n			{\n				list.add(violas[a]);\n			}\n			\n			Collections.sort(list);\n			\n			int[] left = new int[n + 2];\n			int[] right = new int[n + 2];\n			int[] side = new int[n + 2];\n			long[] count = new long[n + 2];\n			long total = 0;\n			for(int b = 0; b < list.size(); b++)\n			{\n				int current = list.get(b).index;\n				int li = b == 0 ? 0 : list.get(b - 1).index;\n				int ri = b == list.size() - 1 ? n + 1 : list.get(b + 1).index;\n				\n				left[current] = li;\n				right[li] = current;\n				right[current] = ri;\n				left[ri] = current;\n			}\n			\n			for(int d = 0; d < list.size(); d++)\n			{\n				int current = list.get(d).index;\n				\n				if(d + k - 1 < list.size())\n				{\n					side[current] = list.get(d + k - 1).index;\n				}\n				else\n				{\n					side[current] = n + 1;\n				}\n				\n				count[current] = (column[current] - column[left[current]]) * (c - column[side[current]]);\n				total += count[current];\n			}\n			\n			int i = 0;\n			for(int e = 0; e <= z; e++)\n			{\n				result += total;\n				\n				while(i < violas.length && violas[i].row == e)\n				{\n					int current = violas[i].index;\n					\n					total -= count[current];\n					\n					left[right[current]] = left[current];\n					right[left[current]] = right[current];\n					\n					if(right[current] <= n)\n					{\n						total -= count[right[current]];\n						int node = right[current];\n						count[right[current]] = (column[node] - column[left[node]]) * (c - column[side[node]]);\n						total += count[right[current]];\n					}\n					\n					int node = left[current];\n					for(int f = 0; f < k - 1; f++)\n					{\n						if(node == 0)\n						{\n							break;\n						}\n						\n						total -= count[node];\n						\n						if(side[node] <= n)\n						{\n							side[node] = right[side[node]];\n						}\n						\n						count[node] = (column[node] - column[left[node]]) * (c - column[side[node]]);\n						\n						total += count[node];\n						\n						node = left[node];\n					}\n					\n					i++;\n				}\n			}\n		}\n		\n		System.out.println(result);\n	}\n	\n	static class Viola implements Comparable<Viola>\n	{\n		int row;\n		int col;\n		int index;\n		\n		public Viola(int r, int c)\n		{\n			row = r;\n			col = c;\n		}\n		\n		public int compareTo(Viola o)\n		{\n			if(col != o.col)\n			{\n				return col - o.col;\n			}\n			else\n			{\n				return o.row - row;\n			}\n		}\n	}\n	\n	static class CompareRow implements Comparator<Viola>\n	{\n		public int compare(Viola o1, Viola o2)\n		{\n			return o1.row - o2.row;\n		}\n	}\n}\n",two pointers
"import java.util.*;\npublic class Orchestra\n{\n	public static void main(String[] args)\n	{\n		Scanner in = new Scanner(System.in);\n		\n		int r = in.nextInt();\n		int c = in.nextInt();\n		int n = in.nextInt();\n		int k = in.nextInt();\n		\n		Viola[] violas = new Viola[n];\n		for(int x = 0; x < n; x++)\n		{\n			violas[x] = new Viola(in.nextInt() - 1, in.nextInt() - 1);\n		}\n		\n		Arrays.sort(violas);\n		\n		int[] column = new int[n + 2];\n		for(int y = 0; y < violas.length; y++)\n		{\n			violas[y].index = y + 1;\n			column[y + 1] = violas[y].col;\n		}\n		\n		column[0] = -1;\n		column[n + 1] = c;\n		\n		Arrays.sort(violas, new CompareRow());\n		\n		for(int i = 0; i < violas.length; i++)\n		{\n			violas[i].index2 = i;\n		}\n		\n		int index = 0;\n		long result = 0;\n		for(int z = 0; z < r; z++)\n		{\n			while(index < violas.length && violas[index].row == z)\n			{\n				index++;\n			}\n			\n			ArrayList<Viola> list = new ArrayList<Viola>();\n			for(int a = 0; a < index; a++)\n			{\n				list.add(violas[a]);\n			}\n			\n			Collections.sort(list);\n			\n			int[] left = new int[n + 2];\n			int[] right = new int[n + 2];\n			int[] side = new int[n + 2];\n			long[] count = new long[n + 2];\n			long total = 0;\n			for(int b = 0; b < list.size(); b++)\n			{\n				int current = list.get(b).index;\n				int li = b == 0 ? 0 : list.get(b - 1).index;\n				int ri = b == list.size() - 1 ? n + 1 : list.get(b + 1).index;\n				\n				left[current] = li;\n				right[li] = current;\n				right[current] = ri;\n				left[ri] = current;\n			}\n			\n			for(int d = 0; d < list.size(); d++)\n			{\n				int current = list.get(d).index;\n				\n				if(d + k - 1 < list.size())\n				{\n					side[current] = list.get(d + k - 1).index;\n				}\n				else\n				{\n					side[current] = n + 1;\n				}\n				\n				count[current] = (column[current] - column[left[current]]) * (c - column[side[current]]);\n				total += count[current];\n			}\n			\n			int i = 0;\n			for(int e = 0; e <= z; e++)\n			{\n				result += total;\n				\n				while(i < violas.length && violas[i].row == e)\n				{\n					int current = violas[i].index;\n					\n					total -= count[current];\n					\n					left[right[current]] = left[current];\n					right[left[current]] = right[current];\n					\n					if(right[current] <= n)\n					{\n						total -= count[right[current]];\n						int node = right[current];\n						count[right[current]] = (column[node] - column[left[node]]) * (c - column[side[node]]);\n						total += count[right[current]];\n					}\n					\n					int node = left[current];\n					for(int f = 0; f < k - 1; f++)\n					{\n						if(node == 0)\n						{\n							break;\n						}\n						\n						total -= count[node];\n						\n						if(side[node] <= n)\n						{\n							side[node] = right[side[node]];\n						}\n						\n						count[node] = (column[node] - column[left[node]]) * (c - column[side[node]]);\n						\n						total += count[node];\n						\n						node = left[node];\n					}\n					\n					i++;\n				}\n			}\n		}\n		\n		System.out.println(result);\n	}\n	\n	static class Viola implements Comparable<Viola>\n	{\n		int row;\n		int col;\n		int index;\n		int index2;\n		\n		public Viola(int r, int c)\n		{\n			row = r;\n			col = c;\n		}\n		\n		public int compareTo(Viola o)\n		{\n			if(col != o.col)\n			{\n				return col - o.col;\n			}\n			else\n			{\n				return o.row - row;\n			}\n		}\n	}\n	\n	static class CompareRow implements Comparator<Viola>\n	{\n		public int compare(Viola o1, Viola o2)\n		{\n			return o1.row - o2.row;\n		}\n	}\n}\n",two pointers
"import java.util.*;\npublic class Orchestra\n{\n	public static void main(String[] args)\n	{\n		Scanner in = new Scanner(System.in);\n		\n		int r = in.nextInt();\n		int c = in.nextInt();\n		int n = in.nextInt();\n		int k = in.nextInt();\n		\n		Viola[] violas = new Viola[n];\n		for(int x = 0; x < n; x++)\n		{\n			violas[x] = new Viola(in.nextInt() - 1, in.nextInt() - 1);\n		}\n		\n		Arrays.sort(violas);\n		\n		int[] column = new int[n + 2];\n		for(int y = 0; y < violas.length; y++)\n		{\n			violas[y].index = y + 1;\n			column[y + 1] = violas[y].col;\n			\n//			System.out.println(violas[y].row + "" "" + violas[y].col);\n		}\n		\n		column[0] = -1;\n		column[n + 1] = c;\n		\n		Arrays.sort(violas, new CompareRow());\n		\n		for(int i = 0; i < violas.length; i++)\n		{\n			violas[i].index2 = i;\n		}\n		\n		int index = 0;\n		long result = 0;\n		for(int z = 0; z < r; z++)\n		{\n			while(index < violas.length && violas[index].row == z)\n			{\n//				System.out.println(violas[index].index);\n				\n				index++;\n			}\n			\n//			System.out.println(""ROW: "" + z);\n//			System.out.println(index);\n			\n			ArrayList<Viola> list = new ArrayList<Viola>();\n			for(int a = 0; a < index; a++)\n			{\n				list.add(violas[a]);\n			}\n			\n			Collections.sort(list);\n			\n			boolean[] ignore = new boolean[n];\n			for(int b = 0; b < list.size(); b++)\n			{\n				if(b > 0 && list.get(b).col == list.get(b - 1).col)\n				{\n					ignore[list.get(b).index2] = true;\n				}\n			}\n			\n//			System.out.println(Arrays.toString(ignore));\n			\n//			System.out.println(""LIST SIZE: "" + list.size());\n			\n			int[] left = new int[n + 2];\n			int[] right = new int[n + 2];\n			int[] side = new int[n + 2];\n			long[] count = new long[n + 2];\n			long total = 0;\n			for(int b = 0; b < list.size(); b++)\n			{\n				int current = list.get(b).index;\n				int li = b == 0 ? 0 : list.get(b - 1).index;\n				int ri = b == list.size() - 1 ? n + 1 : list.get(b + 1).index;\n				\n				left[current] = li;\n				right[li] = current;\n				right[current] = ri;\n				left[ri] = current;\n			}\n			\n//			System.out.println(Arrays.toString(column));\n//			System.out.println(Arrays.toString(left));\n//			System.out.println(Arrays.toString(right));\n			\n			for(int d = 0; d < list.size(); d++)\n			{\n				int current = list.get(d).index;\n				\n				if(d + k - 1 < list.size())\n				{\n					side[current] = list.get(d + k - 1).index;\n				}\n				else\n				{\n					side[current] = n + 1;\n				}\n				\n				if(d > 0 && list.get(d).col == list.get(d - 1).col)\n				{\n					side[current] = n + 1;\n				}\n				\n				count[current] = (column[current] - column[left[current]]) * (c - column[side[current]]);\n				total += count[current];\n			}\n			\n//			System.out.println(Arrays.toString(side));\n//			System.out.println(Arrays.toString(count));\n			\n			int i = 0;\n			for(int e = 0; e <= z; e++)\n			{\n				result += total;\n				\n//				System.out.println(result);\n				\n				while(i < violas.length && violas[i].row == e)\n				{\n					int current = violas[i].index;\n					if(!ignore[i])\n					{\n						total -= count[current];\n					}\n					\n					left[right[current]] = left[current];\n					right[left[current]] = right[current];\n					\n					if(right[current] <= n)\n					{\n						total -= count[right[current]];\n						int node = right[current];\n						count[right[current]] = (column[node] - column[left[node]]) * (c - column[side[node]]);\n						total += count[right[current]];\n					}\n					\n					int node = left[current];\n					for(int f = 0; f < k - 1; f++)\n					{\n//						System.out.println(node);\n						\n						if(node == 0)\n						{\n							break;\n						}\n						\n						total -= count[node];\n						\n//						System.out.println(side[node]);\n						\n						if(side[node] <= n)\n						{\n							side[node] = right[side[node]];\n						}\n						\n//						System.out.println(side[node]);\n						\n						count[node] = (column[node] - column[left[node]]) * (c - column[side[node]]);\n						\n						total += count[node];\n						\n						node = left[node];\n					}\n					\n//					System.out.println(Arrays.toString(left));\n//					System.out.println(Arrays.toString(right));\n//					System.out.println(Arrays.toString(side));\n//					System.out.println(Arrays.toString(count));\n					\n					i++;\n				}\n			}\n			\n//			System.out.println(result);\n		}\n		\n		System.out.println(result);\n	}\n	\n	static class Viola implements Comparable<Viola>\n	{\n		int row;\n		int col;\n		int index;\n		int index2;\n		\n		public Viola(int r, int c)\n		{\n			row = r;\n			col = c;\n		}\n		\n		public int compareTo(Viola o)\n		{\n			if(col != o.col)\n			{\n				return col - o.col;\n			}\n			else\n			{\n				return o.row - row;\n			}\n		}\n	}\n	\n	static class CompareRow implements Comparator<Viola>\n	{\n		public int compare(Viola o1, Viola o2)\n		{\n			return o1.row - o2.row;\n		}\n	}\n}\n",two pointers
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.Random;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int rows = in.nextInt();\n            int cols = in.nextInt();\n            int violas = in.nextInt();\n            int need = in.nextInt();\n            int[] violaCol = new int[violas];\n            int[] nextSameRow = new int[violas];\n            int[] firstByRow = new int[rows];\n            Arrays.fill(firstByRow, -1);\n            for (int i = 0; i < violas; ++i) {\n                int row = in.nextInt() - 1;\n                nextSameRow[i] = firstByRow[row];\n                firstByRow[row] = i;\n                violaCol[i] = in.nextInt() - 1;\n            }\n            long res = rows * (rows + 1) / 2 * (long) (cols * (cols + 1) / 2);\n            Random random = new Random(3274342331L + System.currentTimeMillis());\n            int layers = 1;\n            while ((1 << layers) <= cols) ++layers;\n            int[] colCount = new int[cols];\n            int[][] next = new int[layers][cols + 1];\n            int[][] prev = new int[layers][cols + 1];\n            int sentinel = cols;\n            for (int bottom = 0; bottom < rows; ++bottom) {\n                Arrays.fill(colCount, 0);\n                for (int layer = 0; layer < layers; ++layer) {\n                    next[layer][sentinel] = prev[layer][sentinel] = sentinel;\n                }\n                int sofar = cols * (cols + 1) / 2;\n                for (int top = bottom; top < rows; ++top) {\n                    int cur = firstByRow[top];\n                    while (cur >= 0) {\n                        int col = violaCol[cur];\n                        ++colCount[col];\n                        if (colCount[col] == 1) {\n                            int upto = Integer.numberOfTrailingZeros(random.nextInt(1 << (layers - 1)) + 1);\n                            int at = sentinel;\n                            for (int layer = layers - 1; layer >= 0; --layer) {\n                                while (next[layer][at] < col) at = next[layer][at];\n                                if (layer <= upto) {\n                                    next[layer][col] = next[layer][at];\n                                    prev[layer][col] = at;\n                                    next[layer][prev[layer][col]] = col;\n                                    prev[layer][next[layer][col]] = col;\n                                }\n                            }\n                        }\n                        int inside = colCount[col];\n                        int left = col;\n                        int right = col;\n                        while (inside < need) {\n                            if (next[0][right] < sentinel) {\n                                right = next[0][right];\n                                inside += colCount[right];\n                            } else {\n                                break;\n                            }\n                        }\n                        while (true) {\n                            if (inside == need) {\n                                int leftFree = left + 1;\n                                if (prev[0][left] < sentinel)\n                                    leftFree -= prev[0][left] + 1;\n                                int rightFree = cols - right;\n                                if (next[0][right] < sentinel) {\n                                    rightFree -= cols - next[0][right];\n                                }\n                                sofar -= leftFree * rightFree;\n                            }\n                            if (prev[0][left] == sentinel) {\n                                break;\n                            }\n                            left = prev[0][left];\n                            inside += colCount[left];\n                            while (right > left && inside - colCount[right] >= need) {\n                                inside -= colCount[right];\n                                right = prev[0][right];\n                            }\n                            if (right < col) break;\n                        }\n                        cur = nextSameRow[cur];\n                    }\n                    res -= sofar;\n                }\n            }\n            out.println(res);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n",two pointers
"import java.util.*;\nimport java.io.*;\npublic class B{\n	static int n;\n	static int m;\n	static long[] st;\n	static long[] lazy;\n	static long[] color;\n	static List<Integer>[] adj;\n	static int[] tin;\n	static int[] tout;\n	static int time = 0;\n	static long[] arr;\n	static void dfs(int node, int par)\n	{\n		time++;\n		tin[node] = time;\n		arr[time] = color[node];\n		for(int i:adj[node])\n		{\n			if(i != par)dfs(i,node);\n		}\n		tout[node] = time;\n	}\n	\n	static void build(int node,int left, int right)\n	{\n		if(left == right)\n		{\n			st[node] = arr[left];\n			return;\n		}\n		int mid = (left+right)/2;\n		build(2*node,left,mid);\n		build(2*node+1,mid+1,right);\n		st[node] = st[2*node]|st[2*node+1];\n	}\n	\n	static void propagate(int node, int left, int right)\n	{\n		if(left != right)\n		{\n			lazy[2*node] = lazy[2*node+1] = lazy[node];\n		}\n		st[node] = lazy[node];\n		lazy[node] = 0;\n	}\n	\n	static void update(int node, int left, int right, int targetLeft, int targetRight, long val)\n	{\n		if(lazy[node] != 0)\n		{\n			propagate(node,left,right);\n		}\n		// no overlap\n		if(left>targetRight || right<targetLeft)return;\n		\n		// total overlap\n		if(targetLeft<=left && targetRight>=right)\n		{\n			st[node] = val;\n			if(left != right)\n			{\n				lazy[2*node] = lazy[2*node+1] = val;\n			}\n			return;\n		}\n		int mid = (left+right)/2;\n		update(2*node,left,mid,targetLeft,targetRight,val);\n		update(2*node+1,mid+1,right,targetLeft,targetRight,val);\n		\n		st[node] = st[2*node]|st[2*node+1];\n		\n	}\n	\n	static long query(int node, int left, int right, int targetLeft, int targetRight)\n	{\n		if(lazy[node] != 0)\n		{\n			propagate(node,left,right);\n		}\n		// no overlap\n		if(left>targetRight || right<targetLeft)return 0;\n		\n		// total overlap\n		if(targetLeft<=left && targetRight>=right)\n		{\n			return st[node];\n		}\n		int mid = (left+right)/2;\n		long l = query(2*node,left,mid,targetLeft,targetRight);\n		long r = query(2*node+1,mid+1,right,targetLeft,targetRight);\n		\n		return l|r;\n	}\n	\n	public static void main(String[] args)\n	{\n		FastScanner fs = new FastScanner();\n		PrintWriter out = new PrintWriter(System.out);\n		n = fs.nextInt(); m = fs.nextInt();\n		color = new long[n+1];\n		\n		for(int i=1;i<=n;i++)color[i] = 1l<<fs.nextInt();\n		\n		adj = new ArrayList[n+1];\n		for(int i=1;i<=n;i++)adj[i] = new ArrayList();\n		\n		for(int i=1;i<n;i++)\n		{\n			int u = fs.nextInt(); int v = fs.nextInt();\n			adj[u].add(v); adj[v].add(u);\n		}\n		tin = new int[n+1]; tout = new int[n+1];\n		arr = new long[n+1];\n		dfs(1,-1);\n		st = new long[4*n]; lazy = new long[4*n];\n		build(1,1,n);\n		\n		for(int i=1;i<=m;i++)\n		{\n			int work = fs.nextInt();\n			if(work == 1)\n			{\n				int node = fs.nextInt(); long val = 1l<<fs.nextInt();\n				update(1,1,n,tin[node],tout[node],val);\n			}\n			else\n			{\n				int node = fs.nextInt();\n				long my = query(1,1,n,tin[node],tout[node]);\n				out.println(Long.bitCount(my));\n			}\n		}\n		\n		out.close();\n	}\n	static class FastScanner {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n		String next() {\n			while (!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		int[] readArray(int n) {\n			int[] a=new int[n];\n			for (int i=0; i<n; i++) a[i]=nextInt();\n			return a;\n		}\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n	}\n	public static int[] sort(int[] arr)\n	{\n		List<Integer> temp = new ArrayList();\n		for(int i:arr)temp.add(i);\n		Collections.sort(temp);\n		int start = 0;\n		for(int i:temp)arr[start++]=i;\n		return arr;\n	}\n	public static String rev(String str)\n	{\n		char[] arr = str.toCharArray();\n		char[] ret = new char[arr.length];\n		int start = arr.length-1;\n		for(char i:arr)ret[start--] = i;\n		String ret1 = """";\n		for(char ch:ret)ret1+=ch;\n		return ret1;\n	}\n}","bitmasks,data structures,trees"
"/*\n        ""Everything in the universe is balanced. Every disappointment\n                you face in life will be balanced by something good for you!\n                        Keep going, never give up.""\n\n*/\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class CodeChef {\n    static int MAX = 400005;\n    static int n, m, time = 0;\n    static int[] tin = new int[MAX], tout = new int[MAX];\n    static long[] a = new long[MAX], c = new long[MAX];\n    static long[] st = new long[4 * MAX], lazy = new long[4 * MAX];\n    static HashMap<Integer, List<Integer>> graph = new HashMap<>();\n    public static void main(String[] args) throws java.lang.Exception {\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        sc = new FastReader();\n\n        int test = 1;\n        for (int t = 0; t < test; t++) {\n            solve();\n        }\n        out.close();\n    }\n\n    private static void solve() {\n        n = sc.nextInt();\n        m = sc.nextInt();\n        for (int i = 1; i <= n; i++) {\n            long color = sc.nextLong();\n            c[i] = (1L << color);\n        }\n        for (int i = 1; i <= n; i++) {\n            graph.put(i, new ArrayList<>());\n        }\n        for (int i = 1; i < n; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n\n        //out.println(graph);\n        dfs(1, 1);\n\n        build(1, 1, n);\n\n        for (int i = 1; i <= m; i++) {\n            int type = sc.nextInt();\n\n            if (type == 1) {\n                int v = sc.nextInt();\n                long color = sc.nextLong();\n                color = (1L << color);\n                update(1, 1, n, tin[v], tout[v], color);\n            }else {\n                int v = sc.nextInt();\n                long val = query(1, 1, n, tin[v], tout[v]);\n                out.println(Long.bitCount(val));\n            }\n        }\n    }\n\n    private static long query(int node, int l, int r, int s, int e) {\n        if (lazy[node] > 0){\n            propogate(node, l, r);\n        }\n        if (s > r || e < l) {\n            return 0;\n        }\n        if (s <= l && e >= r) {\n            return st[node];\n        }\n        int mid = (l + r) >> 1;\n        return query(2 * node, l, mid, s, e) | query(2 * node + 1, mid + 1, r, s, e);\n    }\n\n    private static void update(int node, int l, int r, int s, int e, long color) {\n        if (lazy[node] > 0) {\n            propogate(node, l, r);\n        }\n\n        if (s > r || e < l) {\n            return;\n        }\n\n        if (s <= l && e >= r) {\n            st[node] = color;\n            if (l != r) {\n                lazy[2 * node] = color;\n                lazy[2 * node + 1] = color;\n            }\n            return;\n        }\n\n        int mid = (l + r) >> 1;\n        update(2 * node, l, mid, s, e, color);\n        update(2 * node + 1, mid + 1, r, s, e, color);\n        st[node] = st[2 * node] | st[2 * node + 1];\n    }\n\n    private static void propogate(int node, int l, int r) {\n        if (l != r) {\n            lazy[2 * node] = lazy[node];\n            lazy[2 * node + 1] = lazy[node];\n        }\n        st[node] = lazy[node];\n        lazy[node] = 0;\n    }\n\n    private static void build(int node, int l, int r) {\n        if (l == r) {\n            st[node] = a[l];\n            return;\n        }\n        int mid = (l + r) >> 1;\n        build(2 * node, l, mid);\n        build(2 * node + 1, mid + 1, r);\n        st[node] = st[2 * node] | st[2 * node + 1];\n    }\n\n    private static void dfs(int u, int p) {\n        time++;\n        tin[u] = time;\n        a[time] = c[u];\n        for (int v : graph.get(u)) {\n            if (v == p) {\n                continue;\n            }\n            dfs(v, u);\n        }\n        tout[u] = time;\n    }\n\n\n    public static FastReader sc;\n    public static PrintWriter out;\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = """";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}","bitmasks,data structures,trees"
"import java.util.*;\nimport java.io.*;\nimport java.math.*;\n \npublic class Main\n{\n    static void dfs(int node, ArrayList<Integer> l[], boolean visited[]){\n        visited[node] = true;\n        in[node] = ++T;\n\n        for(Integer child : l[node]){\n            if(visited[child])\n                continue;\n            dfs(child, l, visited);\n        }\n\n        out[node] = T;\n    }\n\n    static void buildTree(int s,int e,int index){\n        if(s == e){\n            tree[index] = (long)Math.pow(2l, arr[s]);\n            return;\n        }\n\n        int mid = (s+e)/2;\n        buildTree(s,mid, 2*index);\n        buildTree(mid+1,e, 2*index+1);\n\n        tree[index] = (tree[2*index] | tree[2*index+1]);\n    }\n\n    static long query(int qs,int qe,int s,int e,int index){\n\n         //No Overlap\n        if(qs > e || qe < s)\n            return 0;\n\n         lazy_push(s, e, index);\n        //Complete Overlap\n        if(qs <= s && qe >= e)\n            return tree[index];\n\n        //Partial Overlap- Call on both sides and update the current ans\n        int mid = s + (e - s)/2;\n        return (query(qs,qe,s,mid,2*index) | query(qs,qe,mid+1,e,2*index+1));\n    }\n\n    static void lazy_push(int l ,int r, int idx){\n        if(lazy[idx] == 0)\n            return ;\n        tree[idx] = lazy[idx];\n\n        if(l != r){\n            lazy[2 * idx] = (lazy[2 * idx + 1] = lazy[idx]);\n        }\n\n        lazy[idx] = 0;\n    }\n\n    static void updateRange(int qs, int qe, int s,int e, int c,int index){\n        lazy_push(s, e, index);\n        //Out of bound\n        if(qs > e || qe < s)\n            return ;\n\n        if(s >= qs && qe >= e){\n            lazy[index] = (long)Math.pow(2l, c);\n            lazy_push(s, e, index);\n            return ;\n        }\n\n        int mid = s + (e - s)/2;\n        updateRange(qs, qe, s, mid, c, 2* index);\n        updateRange(qs, qe, mid + 1, e, c, 2* index + 1);\n\n        tree[index] = (tree[2*index] | tree[2*index+1]);\n    }\n\n    public static void process(int test_number)throws IOException\n    {\n        int n = ni(), m = ni(), col[] = new int[n+1];\n        arr = new int[n+1];\n        in = new int[n+1];\n        out = new int[n+1];\n        lazy = new long[4*n + 4];\n        tree = new long[4*n + 4];\n        boolean visited[] = new boolean[n+1];\n        T = 0;\n        PrintWriter pt = new PrintWriter(System.out);\n\n        for(int i = 1; i <= n; i++)\n            col[i] = ni();\n\n        ArrayList<Integer> l[] = new ArrayList[n+1];\n        for(int i = 0; i <= n; i++)\n            l[i] = new ArrayList<>();\n\n        for(int i = 1; i < n; i++){\n            int u = ni(), v = ni();\n            l[u].add(v);\n            l[v].add(u);\n        }\n\n        dfs(1, l, visited);\n        for(int i = 1; i <= n; i++){\n            arr[in[i]] = col[i];\n        }\n\n        buildTree(1, n, 1);\n\n        while(m-- > 0){\n            int type  = ni();\n\n            if(m == 0) trace(tree);\n\n            if(type == 2){\n                int v = ni();\n                long mask = query(in[v], out[v], 1, n, 1);\n                pt.println(bit(mask));\n            }\n            else{\n                int v = ni(), c = ni();\n                updateRange(in[v], out[v], 1, n, c, 1); \n            }\n        }\n        pt.flush();\n    }\n \n    static final long mod = (long)1e9+7l;\n    static int in[], out[], T, arr[];\n    static long lazy[], tree[];\n\n    static FastReader sc;\n    public static void main(String[]args)throws IOException\n    {\n        sc = new FastReader();\n \n        long s = System.currentTimeMillis();\n        int t = 1;\n       // t = ni();\n        for(int i = 1; i <= t; i++)\n            process(i);\n \n        System.err.println(System.currentTimeMillis()-s+""ms"");\n    }\n\n    static void trace(Object... o){ System.err.println(Arrays.deepToString(o)); };\n    static int ni()throws IOException{ return Integer.parseInt(sc.next()); }\n    static long nl()throws IOException{ return Long.parseLong(sc.next()); }\n    static double nd()throws IOException{ return Double.parseDouble(sc.next()); }\n    static String nln()throws IOException{ return sc.nextLine(); }\n    static long gcd(long a, long b)throws IOException{ return (b==0)?a:gcd(b,a%b);}\n    static int gcd(int a, int b)throws IOException{ return (b==0)?a:gcd(b,a%b); }\n    static int bit(long n)throws IOException{ return (n==0)?0:(1+bit(n&(n-1))); }\n    \n    static class FastReader{ \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader(){ \n            br = new BufferedReader(new InputStreamReader(System.in)); \n        } \n  \n        String next(){ \n            while (st == null || !st.hasMoreElements()){ \n                try{ st = new StringTokenizer(br.readLine()); } catch (IOException  e){ e.printStackTrace(); } \n            } \n            return st.nextToken(); \n        } \n  \n        String nextLine(){ \n            String str = """"; \n            try{ str = br.readLine(); } catch (IOException e) { e.printStackTrace(); } \n            return str; \n        } \n    } \n}","bitmasks,data structures,trees"
"import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.StringTokenizer;\n\npublic class Solve6 {\n\n    public static void main(String[] args) throws IOException {\n        PrintWriter pw = new PrintWriter(System.out);\n        new Solve6().solve(pw);\n        pw.flush();\n        pw.close();\n    }\n\n    public void solve(PrintWriter pw) throws IOException {\n        FastReader sc = new FastReader();\n        int n = sc.nextInt(), m = sc.nextInt();\n        c = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            c[i] = sc.nextInt();\n        }\n        ArrayList<Integer>[] adj = new ArrayList[n + 1];\n        for (int i = 1; i <= n; i++) {\n            adj[i] = new ArrayList();\n        }\n        for (int i = 0; i < n - 1; i++) {\n            int x = sc.nextInt(), y = sc.nextInt();\n            adj[x].add(y);\n            adj[y].add(x);\n        }\n        in = new int[n + 1];\n        out = new int[n + 1];\n        n <<= 1;\n        a = new int[n + 1];\n        dfsOrder(1, 0, adj);\n        SegmentTree st = new SegmentTree(a, n);\n        for (int i = 0; i < m; i++) {\n            if (sc.nextInt() == 1) {\n                int v = sc.nextInt(), c = sc.nextInt();\n                st.update(in[v], out[v], c, 1, n, 1);\n            } else {\n                int v = sc.nextInt();\n                long x = st.query(in[v], out[v], 1, n, 1);\n                int cnt = 0;\n                for (long j = x; j > 0; j &= j - 1, cnt++);\n                pw.println(cnt);\n            }\n        }\n    }\n    int timer;\n    int[] in, out, a, c;\n\n    public void dfsOrder(int u, int p, ArrayList<Integer>[] adj) {\n        in[u] = ++timer;\n        a[in[u]] = c[u];\n        for (Integer v : adj[u]) {\n            if (v != p) {\n                dfsOrder(v, u, adj);\n            }\n        }\n        out[u] = ++timer;\n    }\n\n    static class SegmentTree {\n\n        long[] t;\n        int[] lazy;\n\n        public SegmentTree(int[] a, int n) {\n            t = new long[n << 2];\n            lazy = new int[n << 2];\n            build(1, n, 1, a);\n        }\n\n        public void build(int left, int right, int nd, int[] a) {\n            if (left == right) {\n                if (a[left] != 0) {\n                    t[nd] = (1l << a[left]);\n                }\n                return;\n            }\n            int mid = (left + right) >> 1;\n            build(left, mid, nd << 1, a);\n            build(mid + 1, right, nd << 1 | 1, a);\n            t[nd] = t[nd << 1];\n            t[nd] |= t[nd << 1 | 1];\n        }\n\n        public long query(int l, int r, int left, int right, int nd) {\n            push(left, right, nd);\n            if (l <= left && right <= r) {\n                return t[nd];\n            }\n            if (l > right || r < left) {\n                return 0;\n            }\n            int mid = (left + right) >> 1;\n            long x = query(l, r, left, mid, nd << 1);\n            x |= query(l, r, mid + 1, right, nd << 1 | 1);\n            return x;\n        }\n\n        public void push(int left, int right, int nd) {\n            if (lazy[nd] != 0) {\n                t[nd] = 1l << lazy[nd];\n                if (left != right) {\n                    lazy[nd << 1] = lazy[nd];\n                    lazy[nd << 1 | 1] = lazy[nd];\n                }\n                lazy[nd] = 0;\n            }\n        }\n\n        public void update(int l, int r, int c, int left, int right, int nd) {\n            push(left, right, nd);\n            if (l <= left && right <= r) {\n                lazy[nd] = c;\n                push(left, right, nd);\n                return;\n            }\n            if (l > right || r < left) {\n                return;\n            }\n            int mid = (left + right) >> 1;\n            update(l, r, c, left, mid, nd << 1);\n            update(l, r, c, mid + 1, right, nd << 1 | 1);\n            t[nd] = t[nd << 1];\n            t[nd] |= t[nd << 1 | 1];\n        }\n    }\n\n    static class FastReader {\n\n        StringTokenizer st;\n        BufferedReader br;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastReader(String s) {\n            try {\n                br = new BufferedReader(new FileReader(s));\n            } catch (Exception e) {\n            }\n        }\n\n        public String next() {\n            if (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception e) {\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public boolean hasNext() throws IOException {\n            if (st != null && st.hasMoreTokens()) {\n                return true;\n            }\n            String s = br.readLine();\n            if (s == null || s.isEmpty()) {\n                return false;\n            }\n            st = new StringTokenizer(s);\n            return true;\n        }\n    }\n}\n","bitmasks,data structures,trees"
"import java.util.Scanner;\n\npublic class _0752DinnerwithEmma {\n\n	public static void main(String[] args) {\n		\n		Scanner sc = new Scanner(System.in);\n		int n=sc.nextInt();\n		int m=sc.nextInt();\n		int[][] arr = new int[n][m];\n		int ans=Integer.MIN_VALUE;\n		for(int i=0;i<n;i++) {\n			int min=Integer.MAX_VALUE;\n			for(int j=0;j<m;j++) {\n				arr[i][j]=sc.nextInt();\n				min=Math.min(min,arr[i][j]);\n			}\n			if(min>ans) {\n				ans=min;\n			}\n		}\n		System.out.println(ans);\n	}\n\n}\n","games,greedy"
import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		int[][] c = new int[n][m];\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < m; j++) {\n				c[i][j] = sc.nextInt();\n			}\n		}\n		System.out.println(solve(c));\n\n		sc.close();\n	}\n\n	static int solve(int[][] c) {\n		return Arrays.stream(c).mapToInt(row -> Arrays.stream(row).min().getAsInt()).max().getAsInt();\n	}\n},"games,greedy"
"import java.util.*;\npublic class Dinner {\n    public static void main(String[]args){\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        long mn = Long.MAX_VALUE,mx=0;\n        for(int i = 0; i < n; i++){\n            long c = 0;\n            for(int j = 0; j<m;j++){\n                c = in.nextInt();\n                mn=Math.min(mn,c);\n            }\n            mx = Math.max(mx,mn);\n            mn = Long.MAX_VALUE;\n        }\n        System.out.println(mx);\n    }\n}\n","games,greedy"
"\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int n,m;\n        n = scan.nextInt();\n        m = scan.nextInt();\n        long c, min, max = 0;\n\n        for (int i = 0; i < n; ++i) {\n            min = scan.nextLong();\n            for (int j = 1; j < m; ++j) {\n                c = scan.nextLong();;\n                if(min > c)min=c;\n            }\n            if(max < min)max=min;\n        }\n        System.out.println(max);\n    }\n}","games,greedy"
"import java.util.*;\n\npublic class CodingPractice {\n	\n	public static void main(String[] args) {\n		boolean testCases = false;\n		int t = 1;\n		\n		Scanner sc = new Scanner(System.in);\n		if (testCases) {\n			t = sc.nextInt();\n		}\n		\n		for (int i = 0; i < t; i++) {\n			solve(sc);\n		}\n		\n		sc.close();\n	}\n	\n	@SuppressWarnings(""unchecked"")\n	private static void solve(Scanner sc) {\n		int n = 0, m = 0, u = 0, v = 0;\n		long ans = 0;\n		\n		n = sc.nextInt();\n		m = sc.nextInt();\n		\n		Vector<Integer>[] arr = new Vector[n+1];\n		Vector<Integer> vec= new Vector<Integer>();\n		int dp[] = new int[n+1];\n		\n		for (int i = 0; i <= n; i++) {\n			dp[i] = 1;\n			arr[i] = new Vector<>();\n		}\n		\n		for(int i = 0; i < m; i++) {\n			u = sc.nextInt();\n			v = sc.nextInt();\n			\n			vec = arr[u];\n			vec.add(v);\n			arr[u] = vec;\n			\n			vec = arr[v];\n			vec.add(u);\n			arr[v] = vec;\n		}\n		\n		for (int i = 1; i <= n; i++) {\n			for (int point : arr[i]) {\n				if (point < i) {\n					dp[i] = Math.max(dp[i], dp[point] + 1);\n				}\n			}\n			\n			ans = Math.max(ans,  dp[i] * (long)arr[i].size());\n		}\n		\n		System.out.print(ans);\n	}\n	\n}\n","dp,graphs"
"/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be ""Main"" only if the class is public. */\npublic class Main\n{\n	public static void main (String[] args) throws java.lang.Exception\n	{\n		int n, m , u, v;\n		long res = 1;\n		Scanner in = new Scanner(System.in);\n        n =  in.nextInt();\n        m =  in.nextInt(); \n        ArrayList<ArrayList<Integer>> g = new ArrayList<ArrayList<Integer>>(n + 1);\n        ArrayList<Integer> l = new ArrayList<Integer>(n+1);\n        for(int i = 0 ; i <= n; ++i)\n        	g.add(i,new ArrayList<Integer>());\n        for(int i = 0; i < m; ++i){\n        	v = in.nextInt();\n        	u = in.nextInt();\n        	g.get(v).add(u);\n        	g.get(u).add(v);\n        }\n        in.close();\n        l.add(0, 1);\n		for (int i = 1; i <= n; i++) {\n        	l.add(i, 1);\n        u = g.get(i).size();\n        for (int j = 0; j < u; ++j) {\n        	v = g.get(i).get(j);\n            if (v < i) {\n            	l.set(i, Math.max(l.get(i), l.get(v) + 1));\n            }\n        }\n        res = Math.max(res, l.get(i) * (long) g.get(i).size());\n    	}\n		System.out.println(res);\n	}\n}\n","dp,graphs"
"import java.util.*;\n\npublic class Solution {\n\n    static class Node {\n        int index;\n        long tailLength;\n        List<Node> predecessors = new ArrayList<>();\n        List<Node> successors = new ArrayList<>();\n\n        public Node(int index) {\n            this.index = index;\n        }\n\n        @Override\n        public String toString() {\n            return tailLength + """";\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        Node[] nodes = new Node[n+1];\n\n        for (int i = 0; i < nodes.length; i++) {\n           nodes[i] = new Node(i);\n        }\n\n        for (int i = 0; i < m; i++) {\n            int ui = scanner.nextInt();\n            int vi = scanner.nextInt();\n\n            int minNode = Math.min(ui, vi);\n            int maxNode = Math.max(ui, vi);\n\n            nodes[maxNode].predecessors.add(nodes[minNode]);\n            nodes[minNode].successors.add(nodes[maxNode]);\n        }\n\n        for (int i = 1; i <= n; i++) {\n            OptionalLong largestPredecessorTailLength = nodes[i].predecessors.stream().\n                    mapToLong(node -> node.tailLength).max();\n            long length = largestPredecessorTailLength.isPresent() ? largestPredecessorTailLength.getAsLong() : 0;\n            nodes[i].tailLength = length + 1;\n        }\n\n        System.out.println(Arrays.stream(nodes).mapToLong(node -> node.tailLength * (node.predecessors.size() + node.successors.size())).max().getAsLong());\n    }\n\n}","dp,graphs"
"import java.io.*;\nimport java.util.*;\n\npublic class Codeforces {\n\n    public  void solve() {\n        FastScanner fs = new FastScanner();\n        StringBuilder print = new StringBuilder();\n        int n = fs.nextInt(), m = fs.nextInt();\n        ArrayList<Integer>[]graph = new ArrayList[n+1];\n        for(int i=0;i<=n;i++)graph[i] = new ArrayList<>();\n        long[]dp = new long[n+1];\n        for(int i=0;i<m;i++){\n            int u = fs.nextInt(), v = fs.nextInt();\n            graph[u].add(v);\n            graph[v].add(u);\n        }\n        long ans = 0;\n        for(int i=0;i<=n;i++){\n            dp[i] = 1;\n            for(int u:graph[i]){\n                if(u < i){\n                    dp[i] = Math.max(dp[i],dp[u]+1);\n                }\n            }\n            ans = Math.max(ans,dp[i]*graph[i].size());\n//            System.out.println(dp[i]+"" ""+graph[i].size()+"" ""+i);\n        }\n        System.out.println(ans);\n    }\n    public static void main(String[]args){\n        try{\n            new Codeforces().solve();\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n\n    }\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer("""");\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        String nextLine()\n        {\n            String str = """";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n}\n\n","dp,graphs"
"import java.io.*;\nimport java.util.*;\n\n/**\n * @auther chao\n */\npublic class CF2 {\n    public static void main(String[] args) throws IOException {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[] a = new int[26];\n        int m = 0;\n        int x = a[0];\n        for (int i = 0; i < n ;i++) {\n            a[i] = in.nextInt();\n            if (a[i] % 2 == 1) m++;\n            x = gcd(x, a[i]);\n        }\n\n        StringBuffer sb = new StringBuffer();\n        if (x%2 == 1) {\n            if (m == 1) System.out.println(x);\n            else System.out.println(0);\n            x *= 2;\n        } else {\n            System.out.println(x);\n        }\n\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < a[i]/x; j++)\n                sb.append((char)('a'+i));\n\n        String s = sb.toString();\n        sb.reverse();\n        for (int i = 0; i < n ;i++)\n            if (a[i]%2 == 1) sb.append((char)('a'+i));\n\n        sb.append(s);\n        s = sb.toString();\n\n        for (int i = 1; i < x/2; i++) sb.append(s);\n\n        System.out.println(sb);\n    }\n    private static int gcd(int x, int y) {\n        while (x%y != 0) {\n            int t = x%y;\n            x = y;\n            y = t;\n        }\n        return y;\n    }\n}","constructive algorithms,math"
"/**\n * @(#)necklace.java\n *\n * @author Sayson, Duco\n * 2nd Program (outside the class)\n * @version 1.00 2016/8/25\n */\n\n\nimport java.io.*;\nimport java.util.*;\n\n\npublic class necklace {\n    public static void main(String[] args) throws IOException {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[] a = new int[26];\n        int m = 0;\n        int x = a[0];\n        for (int i = 0; i < n ;i++) {\n            a[i] = in.nextInt();\n            if (a[i] % 2 == 1) m++;\n            x = gcd(x, a[i]);\n        }\n\n        StringBuffer sb = new StringBuffer();\n        if (x%2 == 1) {\n            if (m == 1) System.out.println(x);\n            else System.out.println(0);\n            x *= 2;\n        } else {\n            System.out.println(x);\n        }\n\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < a[i]/x; j++)\n                sb.append((char)('a'+i));\n\n        String s = sb.toString();\n        sb.reverse();\n        for (int i = 0; i < n ;i++)\n            if (a[i]%2 == 1) sb.append((char)('a'+i));\n\n        sb.append(s);\n        s = sb.toString();\n\n        for (int i = 1; i < x/2; i++) sb.append(s);\n\n        System.out.println(sb);\n    }\n    private static int gcd(int x, int y) {\n        while (x%y != 0) {\n            int t = x%y;\n            x = y;\n            y = t;\n        }\n        return y;\n    }\n}","constructive algorithms,math"
"import java.util.Scanner;\n\npublic class Main {\n	public static int gcd(int a,int b) {\n		if(a < b) {\n			int t = a;\n			a = b;\n			b = t;\n		}\n		if(b == 0)\n			return a;\n		return gcd(b,a%b);\n	}\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner in = new Scanner(System.in);\n		int n = in.nextInt();\n		int[] a = new int[30];\n		int oushu = 0;\n		int book = 0;\n		for(int i = 0;i < n;i++) {\n			a[i] = in.nextInt();{\n				if(a[i]%2 == 1) {\n					oushu = oushu + a[i]%2;\n					book = i;\n				}\n			}\n		}\n		if(oushu > 1) {\n			System.out.println(0);\n			for(int i = 0;i < n;i++) {\n				for(int j = 0;j < a[i];j++)\n					System.out.print((char)('a'+i));\n			}\n		}\n		else if(oushu == 1){\n			int agcd = a[0];\n			for(int i = 1;i < n;i++) {\n				agcd = gcd(agcd,a[i]);\n			}\n			System.out.println(agcd);\n			for(int i = 0;i < agcd;i++) {\n				for(int j = 0;j < n;j++) {\n					if(j != book)\n					for(int k = 0;k < a[j]/agcd/2;k++) {\n						System.out.print((char)('a' + j));\n					}\n				}\n				for(int j = 0;j < a[book]/agcd;j++) {\n					System.out.print((char)('a' + book));\n				}\n				for(int j = n-1;j >= 0;j--) {\n					if(j != book)\n					for(int k = 0;k < a[j]/agcd/2;k++) {\n						System.out.print((char)('a' + j));\n					}\n				}\n			}\n		}\n		else {\n			int agcd = a[0];\n			for(int i = 1;i < n;i++) {\n				agcd = gcd(agcd,a[i]);\n			}\n			System.out.println(agcd);\n			for(int i = 0;i < agcd/2;i++) {\n				for(int j = 0;j < n;j++) {\n					for(int k = 0;k < a[j]/agcd;k++) {\n						System.out.print((char)(j + 'a'));\n					}\n				}\n				for(int j = n-1;j >= 0;j--) {\n					for(int k = 0;k < a[j]/agcd;k++) {\n						System.out.print((char)(j + 'a'));\n					}\n				}\n			}\n		}\n		return ;\n	}\n\n}\n","constructive algorithms,math"
"import java.io.*;\nimport java.util.*;\n\n/**\n * @auther chao\n */\npublic class CF2 {\n    public static void main(String[] args) throws IOException {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[] a = new int[26];\n        int m = 0;\n        int x = a[0];\n        for (int i = 0; i < n ;i++) {\n            a[i] = in.nextInt();\n            if (a[i] % 2 == 1) m++;\n            x = gcd(x, a[i]);\n        }\n\n        StringBuffer sb = new StringBuffer();\n        if (n == 1) {\n            System.out.println(a[0]);\n            for (int i = 0; i < a[0]; i++) sb.append('a');\n        }\n        else if (x % 2 == 1) {\n            if (m == 1) {\n                System.out.println(x);\n                // 2x for each group\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < a[i]/x/2; j++) {\n                        sb.append((char)('a'+i));\n                    }\n                }\n                String s = sb.toString();\n                sb.reverse();\n                for (int i = 0; i < n; i++) {\n                    if (a[i]%2==1) sb.append((char)('a'+i));\n                }\n                sb.append(s);\n                s = sb.toString();\n                for (int i = 1; i < x; i++) sb.append(s);\n\n            } else {\n                System.out.println(0);\n                for (int i = 0; i < n ;i++)\n                    for (int j = 0; j < a[i]; j++)\n                        sb.append((char)('a'+i));\n            }\n        } else {\n            System.out.println(x);\n            // x for each group\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < a[i]/x; j++) {\n                    sb.append((char)('a'+i));\n                }\n            }\n            String s = sb.toString();\n            sb.reverse();\n            sb.append(s);\n            s = sb.toString();\n            for (int i = 1; i < x/2; i++) sb.append(s);\n        }\n\n        System.out.println(sb);\n    }\n    private static int gcd(int x, int y) {\n        while (x%y != 0) {\n            int t = x%y;\n            x = y;\n            y = t;\n        }\n        return y;\n    }\n}","constructive algorithms,math"
"import java.io.*;\nimport java.util.*;\n \npublic class Contest612E\n{\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        String next() { // reads in the next string\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public int nextInt() { // reads in the next int\n            return Integer.parseInt(next());\n        }\n        public long nextLong() { // reads in the next long\n            return Long.parseLong(next());\n        }\n        public double nextDouble() { // reads in the next double\n            return Double.parseDouble(next());\n            }\n        }\n    static InputReader r = new InputReader(System.in);\n    static PrintWriter pw = new PrintWriter(System.out);\n    static long mod = 1000000007;\n    static int[] q; static int c; static ArrayList<Integer>[] cc; static boolean[] visit;\n    public static void main(String[] args)\n    {\n    	int n = r.nextInt();\n    	q = new int[n];\n    	for (int i = 0; i < n; i ++)\n    	{\n    		q[i] = r.nextInt() - 1;\n    	}\n    	visit = new boolean[n];\n    	int[] p = new int[n];\n    	cc = new ArrayList[n];\n    	c = 0;\n    	for (int i = 0; i < n; i ++)\n    	{\n    		cc[i] = new ArrayList<Integer>();\n    	}\n    	for (int i = 0; i < n; i ++)\n    	{\n    		if (!visit[i])\n    		{\n    			dfs(i);\n    			c++;\n    		}\n    	}\n    	ArrayList<Pair> hi = new ArrayList<Pair>();\n    	for (int i = 0; i < n; i ++)\n    	{\n    		int x = cc[i].size();\n    		if (x%2 == 1)\n    		{\n    			for (int j = 0; j < x; j ++)\n    			{\n    				p[cc[i].get(j)] = cc[i].get((j+(x+1)/2)%x);\n    			}\n    		}\n    		else\n    		{\n    			hi.add(new Pair(i,x));\n    		}\n    	}\n    	Collections.sort(hi);\n    	int sz = hi.size();\n    	boolean flag = false;\n    	if (sz%2 != 0)\n    	{\n    		flag = false;\n    	}\n    	for (int i = 0; i < sz/2; i ++)\n    	{\n    		if (hi.get(2*i).b != hi.get(2*i+1).b)\n    		{\n    			flag = true;\n    			break;\n    		}\n    		int x = hi.get(2*i).b;\n    		ArrayList<Integer> a1 = cc[hi.get(2*i).a];\n    		ArrayList<Integer> a2 = cc[hi.get(2*i+1).a];\n    		for (int j = 0; j < x; j ++)\n    		{\n    			p[a1.get(j)] = a2.get(j);\n    		}\n    		for (int j = 0; j < x; j ++)\n    		{\n    			p[a2.get(j)] = a1.get((j+1)%x);\n    		}\n    		\n    	}\n    	if (flag)\n    	{\n    		pw.println(-1);\n    	}\n    	else\n    	{\n    		for (int i = 0; i < n; i ++)\n    		{\n    			pw.println(p[i]+1);\n    		}\n    		\n    	}\n        pw.close();\n    }\n    static class Pair implements Comparable<Pair>\n    {\n    	int a,b;\n    	public Pair(int x, int y)\n    	{\n    		a = x; b = y;\n    	}\n    	public int compareTo(Pair p)\n    	{\n    		return Integer.compare(b, p.b);\n    	}\n    }\n    static void dfs(int node)\n    {\n    	int x = node;\n    	visit[x] = true;\n		cc[c].add(x);\n		x = q[x];\n    	while (x != node)\n    	{\n    		visit[x] = true;\n    		cc[c].add(x);\n    		x = q[x];\n    	}\n    }\n}","combinatorics,constructive algorithms,dfs and similar,graphs,math"
"import java.io.*;\nimport java.util.*;\n\npublic class CF612E {\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		int n = Integer.parseInt(br.readLine());\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int[] pp = new int[n];\n		for (int i = 0; i < n; i++)\n			pp[i] = Integer.parseInt(st.nextToken()) - 1;\n		boolean[] used = new boolean[n];\n		int[] tt = new int[n];\n		int[] qq = new int[n];\n		int[] ii = new int[n + 1];\n		Arrays.fill(ii, -1);\n		int even = 0;\n		for (int i = 0; i < n; i++) {\n			if (used[i])\n				continue;\n			int cnt = 0;\n			for (int j = i; !used[j]; j = pp[j]) {\n				used[j] = true;\n				tt[cnt++] = j;\n			}\n			if (cnt % 2 == 1) {\n				int h = (1 + cnt) / 2;\n				for (int k = 0, j = i; k < cnt; k++, j = pp[j])\n					qq[j] = tt[(k + h) % cnt];\n			} else if (ii[cnt] == -1) {\n				ii[cnt] = i;\n				even++;\n			} else {\n				for (int k = 0, j1 = ii[cnt], j2 = i; k < cnt; k++, j1 = pp[j1], j2 = pp[j2]) {\n					qq[j1] = j2;\n					qq[j2] = pp[j1];\n				}\n				ii[cnt] = -1;\n				even--;\n			}\n		}\n		if (even > 0) {\n			System.out.println(-1);\n			return;\n		}\n		StringBuilder sb = new StringBuilder();\n		for (int i = 0; i < n; i++)\n			sb.append((qq[i] + 1) + "" "");\n		System.out.println(sb);\n	}\n}\n","combinatorics,constructive algorithms,dfs and similar,graphs,math"
"import java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class E {\n\n    static void solve() throws IOException {\n        int n = nextInt();\n        int[] p = new int[n];\n        for ( int i = 0; i < n; i ++ ) {\n            p[i] = nextInt() - 1;\n        }\n        ArrayList<ArrayList<Integer>> cycle = new ArrayList<>();\n        boolean[] g = new boolean[n];\n        for ( int i = 0; i < n; i ++ ) {\n            if ( g[i] ) continue;\n            ArrayList<Integer> list = new ArrayList<>();\n            for ( int j = i; ! g[j]; j = p[j] ) {\n                list.add( j );\n                g[j] = true;\n            }\n            cycle.add( list );\n        }\n        Collections.sort( cycle, ( o1, o2 ) -> Integer.compare( o1.size(), o2.size() ) );\n        int[] q = new int[n];\n        for ( int i = 0; i < cycle.size(); i ++ ) {\n            ArrayList< Integer > list = cycle.get( i );\n            int size = list.size();\n            if ( size % 2 == 1 ) {\n                for ( int j = 0, c = 0; j < size; j ++ ) {\n                    int next = ( c + ( size + 1 ) / 2 ) % size;\n                    q[list.get( c )] = list.get( next );\n                    c = next;\n                }\n            } else {\n                ArrayList< Integer > next = i + 1 < cycle.size() ? cycle.get( i + 1 ) : null;\n                if ( next != null && next.size() == size ) {\n                    for ( int j = 0; j < size; j ++ ) {\n                        q[list.get( j )] = next.get( j );\n                        q[next.get( j )] = list.get( ( j + 1 ) % size );\n                    }\n                    i ++;\n                } else {\n                    out.println( -1 );\n                    return;\n                }\n            }\n        }\n        for ( int x : q ) {\n            out.print( ( x + 1 ) + "" "" );\n        }\n    }\n\n    static StreamTokenizer in;\n    static PrintWriter out;\n\n    static int nextInt() throws IOException {\n        in.nextToken();\n        return ( int ) in.nval;\n    }\n\n    public static void main( String[] args ) throws IOException {\n        in = new StreamTokenizer( new InputStreamReader( System.in ) );\n        out = new PrintWriter( System.out );\n        solve();\n        out.close();\n    }\n}\n","combinatorics,constructive algorithms,dfs and similar,graphs,math"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class PermutationRoot {\n\n    static int[][] next;\n    static boolean[] used;\n    static int[] ans;\n\n    static Map<Integer, List<Integer>> even = new HashMap<>();\n\n    static List<Integer> getList(int start) {\n        List<Integer> ls = new ArrayList<>();\n        ls.add(start);\n        int last = next[0][start];\n        while(last!=start) {\n            ls.add(last);\n            last = next[0][last];\n        }\n        for(int i: ls) used[i] = true;\n        return ls;\n    }\n\n    static void processCycle(List<Integer> ls) {\n        if(ls.size()%2 == 1) processOdd(ls);\n        else processEven(ls);\n    }\n\n    private static void processEven(List<Integer> ls) {\n        int n = ls.size();\n        if(!even.containsKey(n)) {\n            even.put(n, ls);\n        } else {\n            processPair(ls, even.remove(n));\n        }\n    }\n\n    private static void processPair(List<Integer> first, List<Integer> second) {\n        //first.size == second.size\n        int n = first.size();\n        first.add(first.get(0));\n        for(int i = 0; i<n; ++i){\n            ans[first.get(i)] = second.get(i);\n            ans[second.get(i)] = first.get(i+1);\n        }\n\n    }\n\n    private static void processOdd(List<Integer> ls) {\n        if(ls.size() == 1) {\n            int v = ls.get(0);\n            ans[v] = v;\n            return;\n        }\n        int n = (ls.size()+1)/2;\n        for(int i: ls) ans[i] = jump(i, n);\n    }\n\n    static int jump(int i, int j) {\n        for(int t = 0; t< 20; ++t)\n            if( (j &(1<<t)) != 0 )\n                i = next[t][i];\n        return i;\n    }\n\n    static BufferedReader input;\n    static StringTokenizer stoken = new StringTokenizer("""");\n    static String nextString() throws IOException {\n        while (!stoken.hasMoreTokens()){\n            String st = input.readLine();\n            stoken = new StringTokenizer(st);\n        }\n        return stoken.nextToken();\n    }\n    static int nextInt() throws Exception {\n        return Integer.parseInt(nextString());\n    }\n\n    public static void main(String[] args) throws Exception{\n        input = new BufferedReader(\n                new InputStreamReader(System.in)\n        );\n        int n = nextInt();\n        next = new int[20][n];\n        used = new boolean[n];\n        ans = new int[n];\n        for(int i = 0; i<n; ++i) next[0][i] = nextInt() - 1;\n        for(int i = 1; i<20; ++i)\n            for(int j = 0; j<n; ++j) next[i][j] = next[i-1][next[i-1][j]];\n\n        for(int i = 0; i<n; ++i)\n            if(!used[i]) {\n                List<Integer> ls = getList(i);\n                processCycle(ls);\n            }\n        if(!even.isEmpty()) {\n            System.out.println(""-1"");\n            return;\n        }\n        StringBuilder sb = new StringBuilder();\n        for(int i: ans) {\n            sb.append(i+1);sb.append(' ');\n        }\n        System.out.println(sb.toString());\n    }\n\n\n}\n","combinatorics,constructive algorithms,dfs and similar,graphs,math"
"import java.util.Scanner;\n\npublic class TextSplit {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n    int p = sc.nextInt();\n    int q = sc.nextInt();\n    sc.nextLine();\n    String str = sc.nextLine();\n\n    int a = 0;\n    boolean found = false;\n\n    while (a <= n / p && !found) {\n      int remainder = n - a * p;\n      if (remainder % q == 0) {\n        int b = remainder / q;\n        System.out.println(a + b);\n        for (int i = 1; i <= a; i++) {\n          System.out.println(str.substring(p * (i - 1), p * i));\n        }\n        for (int i = 1; i <= b; i++) {\n          System.out.println(str.substring(a * p + q * (i - 1), a * p + q * i));\n        }\n        found = true;\n      }\n      a++;\n    }\n    if (!found) {\n      System.out.println(-1);\n    }\n  }\n}\n","brute force,implementation,strings"
"// Don't place your source in a package\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main {\n	public static void main (String[] args) throws java.lang.Exception {\n	    Scanner in = new Scanner(System.in);\n	    int n = in.nextInt();\n		int p = in.nextInt();\n		int q = in.nextInt();\n		String s = in.next();\n		int x= 0 ;int y = 0;\n		for(int i=0;i<=n;i++){\n		    if(i%p ==0 && (n-i)%q==0){\n		        x = i/p;\n		        y= (n-i)/q;\n		    }\n		}\n	\n		if(x==0 &&  y == 0){\n		    System.out.print(-1);\n		}else{\n		    System.out.println(x+y);\n		    int j = 0;\n		    for(int i =0;i<x;i++){\n		        System.out.println(s.substring(j,j+p));\n		        j+=p;\n		    }\n		        for(int i =0;i<y;i++){\n		        System.out.println(s.substring(j,j+q));\n		        j+=q;\n		    }\n		}\n	\n	}\n}","brute force,implementation,strings"
"import java.util.Scanner;\n\npublic class TextSplit {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n    int p = sc.nextInt();\n    int q = sc.nextInt();\n    sc.nextLine();\n    String str = sc.nextLine();\n\n    int a = 0;\n    boolean found = false;\n\n    while (a <= n / p && !found) {\n      int remainder = n - a * p;\n      if (remainder % q == 0) {\n        int b = remainder / q;\n        System.out.println(a + b);\n        for (int i = 1; i <= a; i++) {\n          System.out.println(str.substring(p * (i - 1), p * i));\n        }\n        for (int i = 1; i <= b; i++) {\n          System.out.println(str.substring(a * p + q * (i - 1), a * p + q * i));\n        }\n        found = true;\n      }\n      a++;\n    }\n    if (!found) {\n      System.out.println(-1);\n    }\n  }\n}\n","brute force,implementation,strings"
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n \npublic class Main\n{\n    \n   \n    \n	public static void main (String[] args) throws java.lang.Exception\n	{\n	    Scanner sc = new Scanner(System.in);\n	    \n	    int n = sc.nextInt();\n	    int p = sc.nextInt();\n	    int q = sc.nextInt();\n	    String s = sc.next();\n	    \n	    int i=0;\n	    int j=0;\n	    boolean flag = false;\n	    loop:\n	    for(i=0;i<=n;i++){\n	        for(j=0;j<=n;j++){\n	            if((i*p + j*q) == n){\n	                flag = true;\n	                break loop;\n	            }\n	        }\n	    }\n	    if(flag==false){\n	        System.out.println(""-1"");\n	        return;\n	    }\n	    \n	    System.out.println(i+j);\n	    for(int k=0;k<i;k++){\n	        String temp = s.substring(p*k,(k+1)*p);\n	        System.out.println(temp);\n	    }\n	    \n	    int st = i*p;\n	    \n	     for(int k=1;k<=j;k++){\n	        String temp = s.substring(st+(k-1)*q,st+k*q);\n	        System.out.println(temp);\n	    }\n	    \n	    \n	    \n	}\n}","brute force,implementation,strings"
"/**\n * author: derrick20\n * created: 3/30/21 2:53 PM\n */\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class F_FrogsAndMosquitoes {\n    static FastScanner sc = new FastScanner();\n    static PrintWriter out = new PrintWriter(System.out);\n    \n    public static void main(String[] args) {\n        int N = sc.nextInt(), M = sc.nextInt();\n        long[] frogs = new long[N];\n        long[] tongues = new long[N];\n        int[] eaten = new int[N];\n        covers = new long[N][2];\n        intervals = new TreeSet<>();\n        Integer[] indices = new Integer[N];\n        Arrays.setAll(indices, i -> i);\n        for (int i = 0; i < N; i++) {\n            frogs[i] = sc.nextLong();\n            tongues[i] = sc.nextLong();\n        }\n        Arrays.sort(indices, Comparator.comparingLong(i -> frogs[i]));\n        long oo = (long) 9e18;\n        intervals.add(new Endpoint(oo, -1, true));\n        intervals.add(new Endpoint(-oo, -1, false));\n        for (int j = N - 1; j >= 0; j--) {\n            int i = indices[j];\n            Endpoint open = new Endpoint(frogs[i], i, true);\n            Endpoint close = new Endpoint(frogs[i] + tongues[i] + 1, i, false);\n            insert(open, close);\n        }\n        TreeSet<Endpoint> uneaten = new TreeSet<>();\n        uneaten.add(new Endpoint(-oo, -1, false));\n        long[] sizes = new long[M];\n        for (int j = 0; j < M; j++) {\n//            System.out.println(""On "" + j);\n            long pos = sc.nextLong();\n            sizes[j] = sc.nextLong();\n            Endpoint mosquito = new Endpoint(pos, (int) 2e9, true);\n            Endpoint below = intervals.floor(mosquito);\n            mosquito.id = j;\n            if (below.open) {\n                int id = below.id;\n                long end = covers[id][1];\n                Endpoint oldClose = new Endpoint(end, id, false);\n                intervals.remove(below);\n                intervals.remove(oldClose);\n\n                tongues[id] += sizes[j];\n                eaten[id]++;\n                Endpoint newOpen = below;\n                Endpoint newClose = new Endpoint(end + sizes[j], (int) 2e9, false);\n                Endpoint newMosquito;\n//                System.out.println(newClose);\n//                System.out.println(""Eating "" + mosquito + "" at reach = "" + newClose.pos);\n                while ((newMosquito = uneaten.floor(newClose)).pos >= below.pos) {\n//                    System.out.println(""Eating "" + newMosquito + "" at reach = "" + newClose.pos);\n                    uneaten.remove(newMosquito);\n                    newClose.pos += sizes[newMosquito.id];\n                    tongues[id] += sizes[newMosquito.id];\n                    eaten[id]++;\n                }\n                newClose.id = id;\n                insert(newOpen, newClose); // reinsert both since easier to code, but left end won't have any issues\n                // this insertion will update the cover locations\n            } else {\n                ASSERT(!uneaten.contains(mosquito));\n                uneaten.add(mosquito);\n            }\n//            System.out.println(uneaten);\n        }\n        for (int i = 0; i < N; i++) {\n            out.println(eaten[i] + "" "" + tongues[i]);\n        }\n        out.close();\n    }\n/*\n1 3\n1 0\n2 4\n2 4\n1 3\n */\n    static TreeSet<Endpoint> intervals;\n    static long[][] covers;\n\n    static void insert(Endpoint open, Endpoint close) {\n        Endpoint last = intervals.floor(close);\n        if (last.pos >= open.pos && last.open) {\n            intervals.remove(last);\n            if (covers[last.id][1] > close.pos) {\n                intervals.add(new Endpoint(close.pos, last.id, true));\n                // don't add it unless it has nonzero size\n                covers[last.id][0] = close.pos;\n            }\n        }\n        Endpoint next;\n        while ((next = intervals.ceiling(open)).compareTo(close) <= 0) {\n            intervals.remove(next);\n        }\n        intervals.add(open);\n        intervals.add(close);\n        covers[open.id] = new long[]{open.pos, close.pos};\n    }\n\n    static class Endpoint implements Comparable<Endpoint> {\n        long pos; int id;\n        boolean open; // false comes before true (close before opens)\n        public Endpoint(long position, int index, boolean isOpen) {\n            pos = position; id = index; open = isOpen;\n        }\n\n        public String toString() {\n            return pos + "" "" + id + "" "" + (open ? ""open"" : ""closed"");\n        }\n\n        public int compareTo(Endpoint i2) {\n//            return Long.compare(pos, i2.pos);\n            if (pos != i2.pos) {\n                return Long.compare(pos, i2.pos);\n            } else if (open != i2.open) {\n                return Boolean.compare(open, i2.open);\n            } else {\n                return Integer.compare(id, i2.id); // MOSQUITOES CAN BE DUPLICATE\n            }\n        }\n    }\n\n    static class FastScanner {\n        private int BS = 1 << 16;\n        private char NC = (char) 0;\n        private byte[] buf = new byte[BS];\n        private int bId = 0, size = 0;\n        private char c = NC;\n        private double cnt = 1;\n        private BufferedInputStream in;\n    \n        public FastScanner() {\n            in = new BufferedInputStream(System.in, BS);\n        }\n    \n        public FastScanner(String s) {\n            try {\n                in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n            } catch (Exception e) {\n                in = new BufferedInputStream(System.in, BS);\n            }\n        }\n    \n        char getChar() {\n            while (bId == size) {\n                try {\n                    size = in.read(buf);\n                } catch (Exception e) {\n                    return NC;\n                }\n                if (size == -1) return NC;\n                bId = 0;\n            }\n            return (char) buf[bId++];\n        }\n    \n        int nextInt() {\n            return (int) nextLong();\n        }\n    \n        long nextLong() {\n            cnt = 1;\n            boolean neg = false;\n            if (c == NC) c = getChar();\n            for (; (c < '0' || c > '9'); c = getChar()) {\n                if (c == '-') neg = true;\n            }\n            long res = 0;\n            for (; c >= '0' && c <= '9'; c = getChar()) {\n                res = (res << 3) + (res << 1) + c - '0';\n                cnt *= 10;\n            }\n            return neg ? -res : res;\n        }\n    \n        double nextDouble() {\n            boolean neg = false;\n            if (c == NC) c = getChar();\n            for (; (c < '0' || c > '9'); c = getChar()) {\n                if (c == '-') neg = true;\n            }\n            double cur = nextLong();\n            if (c != '.') {\n                return neg ? -cur : cur;\n            } else {\n                double frac = nextLong() / cnt;\n                return neg ? -cur - frac : cur + frac;\n            }\n        }\n    \n        String next() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c > 32) {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n    \n        String nextLine() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c != '\n') {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n    \n        boolean hasNext() {\n            if (c > 32) return true;\n            while (true) {\n                c = getChar();\n                if (c == NC) return false;\n                else if (c > 32) return true;\n            }\n        }\n    }\n    \n    static void ASSERT(boolean assertion, String message) {\n        if (!assertion) throw new AssertionError(message);\n    }\n    \n    static void ASSERT(boolean assertion) {\n        if (!assertion) throw new AssertionError();\n    }\n}","data structures,greedy"
"import java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.*;\n\npublic class F {\n\n    static void solve() throws IOException {\n        int fn = nextInt();\n        int kn = nextInt();\n        Frog[] f = new Frog[fn];\n        for ( int i = 0; i < fn; i ++ ) {\n            f[i] = new Frog( i, nextInt(), nextInt() );\n        }\n        Arrays.sort( f, ( f1, f2 ) -> Integer.compare( f1.x, f2.x ) );\n        Comparator< Frog > setComparator = ( f1, f2 ) -> Long.compare( f1.x + f1.t, f2.x + f2.t );\n        TreeSet<Frog> set = new TreeSet<>( setComparator );\n        for ( Frog frog : f ) {\n            if ( set.isEmpty() || setComparator.compare( frog, set.last() ) > 0 ) {\n                set.add( frog );\n            }\n        }\n        TreeMap<Integer, Kom> map = new TreeMap<>();\n        for ( ; kn > 0; kn -- ) {\n            int pos = nextInt();\n            int size = nextInt();\n            if ( map.containsKey( pos ) ) {\n                Kom kom = map.get( pos );\n                map.put( pos, new Kom( kom.size + size, kom.cnt + 1 ) );\n            } else {\n                map.put( pos, new Kom( size, 1 ) );\n            }\n            SortedSet< Frog > tailSet = set.tailSet( new Frog( -1, pos, 0 ) );\n            if ( tailSet.isEmpty() ) continue;\n            Frog frog = tailSet.first();\n            set.remove( frog );\n            while ( true ) {\n                SortedMap< Integer, Kom > tailMap = map.tailMap( frog.x );\n                if ( tailMap.isEmpty() ) break;\n                Integer firstKey = tailMap.firstKey();\n                if ( firstKey > frog.x + frog.t ) break;\n                Kom kom = map.get( firstKey );\n                frog.t += kom.size;\n                frog.ate += kom.cnt;\n                map.remove( firstKey );\n            }\n            Frog frog1 = frog.incTail();\n            while ( true ) {\n                SortedSet< Frog > headSet = set.headSet( frog1 );\n                if ( headSet.isEmpty() ) break;\n                Frog last = headSet.last();\n                if ( last.x < frog.x ) break;\n                set.remove( last );\n            }\n            set.add( frog );\n        }\n        Arrays.sort( f, ( f1, f2 ) -> Integer.compare( f1.id, f2.id ) );\n        for ( Frog frog : f ) {\n            out.println( frog.ate + "" "" + frog.t );\n        }\n    }\n\n    private static class Kom {\n        long size;\n        int cnt;\n\n        Kom( long s, int c ) {\n            size = s;\n            cnt = c;\n        }\n    }\n\n    private static class Frog {\n        int id;\n        int x;\n        long t;\n        int ate;\n\n        Frog( int Id, int X, long T ) {\n            id = Id;\n            x = X;\n            t = T;\n        }\n\n        public Frog incTail() {\n            return new Frog( -1, x, t + 1 );\n        }\n    }\n\n    static StreamTokenizer in;\n    static PrintWriter out;\n\n    static int nextInt() throws IOException {\n        in.nextToken();\n        return ( int ) in.nval;\n    }\n\n    public static void main( String[] args ) throws IOException {\n        in = new StreamTokenizer( new InputStreamReader( System.in ) );\n        out = new PrintWriter( System.out );\n        solve();\n        out.close();\n    }\n}\n","data structures,greedy"
"//package com.rocketfuel.kamran;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.Scanner;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * Hello world!\n *\n */\npublic class App\n{\n    private static class Interval {\n        int a;\n        long b;\n        int idx;\n        int mc;\n\n        public Interval(int a, long b, int idx) {\n            this.a = a;\n            this.b = b;\n            this.idx = idx;\n            this.mc = 0;\n        }\n    }\n\n    private static class MosqData {\n        int mc;\n        long totalsize;\n\n        public MosqData(int mc, long totalsize) {\n            this.mc = mc;\n            this.totalsize = totalsize;\n        }\n    }\n\n    public static void main( String[] args ) throws IOException {\n        BufferedReader input = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = input.readLine().split("" "");\n        int n = Integer.parseInt(line[0]);\n        int m = Integer.parseInt(line[1]);\n\n        TreeSet<Interval> tree = new TreeSet<Interval>(\n                new Comparator<Interval>() {\n                    @Override\n                    public int compare(Interval o1, Interval o2) {\n                        if (o1.b != o2.b) {\n                            return o1.b < o2.b ? -1 : 1;\n                        }\n                        if (o1.a != o2.a) {\n                            return o1.a > o2.a ? -1 : 1;\n                        }\n                        return 0;\n                    }\n\n                    @Override\n                    public boolean equals(Object obj) {\n                        return super.equals(obj);\n                    }\n                });\n\n        MosqData[] res = new MosqData[n];\n\n        for (int i=1; i<=n; ++i) {\n            line = input.readLine().split("" "");\n            int x = Integer.parseInt(line[0]);\n            int t = Integer.parseInt(line[1]);\n\n            Interval seg = new Interval(x, x+t, i);\n            Interval lbseg = tree.ceiling(seg);\n            if (lbseg != null && lbseg.a <= seg.a) {\n                res[i-1] = new MosqData(seg.mc, seg.b-seg.a);\n            } else {\n                Interval flseg = tree.floor(seg);\n                while (flseg != null && flseg.a >= seg.a) {\n                    res[flseg.idx-1] = new MosqData(flseg.mc, flseg.b-flseg.a);\n                    tree.remove(flseg);\n                    flseg = tree.floor(seg);\n                }\n                tree.add(seg);\n            }\n        }\n\n        TreeMap<Integer, MosqData> mosq = new TreeMap<Integer, MosqData>();\n        for (int i=1; i<=m; ++i) {\n            line = input.readLine().split("" "");\n            Integer p = Integer.parseInt(line[0]);\n            int b = Integer.parseInt(line[1]);\n\n            MosqData mosqd = mosq.get(p);\n            if (mosqd == null) {\n                mosqd = new MosqData(1, b);\n            } else {\n                mosqd.mc++;\n                mosqd.totalsize += b;\n            }\n            mosq.put(p, mosqd);\n\n            Interval frog = tree.ceiling(new Interval(Integer.MAX_VALUE, p, -100));\n\n            if (frog != null && frog.a <= p) {\n                tree.remove(frog);\n\n                do {\n                    mosqd = mosq.remove(p);\n                    frog.mc += mosqd.mc;\n                    frog.b += mosqd.totalsize;\n\n                    p = mosq.ceilingKey(frog.a);\n                } while (p != null && p <= frog.b);\n\n                Interval flseg = tree.floor(frog);\n                while (flseg != null && flseg.a >= frog.a) {\n                    res[flseg.idx-1] = new MosqData(flseg.mc, flseg.b-flseg.a);\n                    tree.remove(flseg);\n                    flseg = tree.floor(frog);\n                }\n                tree.add(frog);\n            }\n        }\n\n        Iterator<Interval> iter = tree.iterator();\n\n        while (iter.hasNext()) {\n            Interval i = iter.next();\n            res[i.idx-1] = new MosqData(i.mc, i.b - i.a);\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (int i=0; i<res.length; ++i) {\n            sb.append(res[i].mc).append("" "").append(res[i].totalsize).append(""\n"");\n        }\n        System.out.print(sb.toString());\n    }\n}\n","data structures,greedy"
"import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n\n    private static class Frog {\n        int pos;\n        long length;\n        int number;\n        int eaten;\n\n        Frog(int pos, long length, int number) {\n            this.pos = pos;\n            this.length = length;\n            this.number = number;\n            this.eaten = 0;\n        }\n    }\n\n    private static long[] st;\n\n    private static void build(int v, int tl, int tr, Frog[] frogs) {\n        if (tl == tr) {\n            st[v] = frogs[tl].length + frogs[tl].pos;\n            return;\n        }\n        int mid = (tl + tr) >> 1;\n        build(v * 2 + 1, tl, mid, frogs);\n        build(v * 2 + 2, mid + 1, tr, frogs);\n        st[v] = Math.max(st[v * 2 + 1], st[v * 2 + 2]);\n    }\n\n    private static int get(int v, int tl, int tr, int x) {\n        if (tr == tl) {\n            if (st[v] < x) {\n                return -1;\n            }\n            return tl;\n        }\n        int mid = (tl + tr) >> 1;\n        if (st[v * 2 + 1] >= x) {\n            return get(v * 2 + 1, tl, mid, x);\n        } else if (st[v * 2 + 2] >= x) {\n            return get(v * 2 + 2, mid + 1, tr, x);\n        }\n        return -1;\n    }\n\n    private static void update(int v, int tl, int tr, int pos, long val) {\n        if (tl == tr) {\n            st[v] += val;\n            return;\n        }\n        int mid = (tl + tr) >> 1;\n        if (pos <= mid) {\n            update(v * 2 + 1, tl, mid, pos, val);\n        } else {\n            update(v * 2 + 2, mid + 1, tr, pos, val);\n        }\n        st[v] = Math.max(st[v * 2 + 1], st[v * 2 + 2]);\n    }\n\n\n    public static void main(String[] args) throws IOException {\n        MyScanner sc = new MyScanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        Frog[] frogs = new Frog[n];\n        st = new long[4 * n];\n        for (int i = 0; i < n; i++) {\n            frogs[i] = new Frog(sc.nextInt(), sc.nextInt(), i);\n        }\n        Arrays.sort(frogs, (Frog f1, Frog f2) -> Integer.compare(f1.pos, f2.pos));\n        build(0, 0, n - 1, frogs);\n        TreeMap<Integer, ArrayList<Integer>> uneaten = new TreeMap<>();\n        for (int i = 0; i < m; i++) {\n            int pos = sc.nextInt();\n            int size = sc.nextInt();\n            int l = get(0, 0, n - 1, pos);\n            if (l != -1 && frogs[l].pos <= pos) {\n                frogs[l].eaten += 1;\n                frogs[l].length += size;\n                update(0, 0, n - 1, l, size);\n                Map.Entry<Integer, ArrayList<Integer>> uneatenMosquitos = uneaten.ceilingEntry(frogs[l].pos);\n                while (uneatenMosquitos != null && frogs[l].length + frogs[l].pos >= uneatenMosquitos.getKey()) {\n                    frogs[l].eaten += uneatenMosquitos.getValue().size();\n                    long sizeInc = 0;\n                    for (int item : uneatenMosquitos.getValue()) {\n                        sizeInc += item;\n                    }\n                    frogs[l].length += sizeInc;\n                    update(0, 0, n - 1, l, sizeInc);\n                    uneaten.remove(uneatenMosquitos.getKey());\n                    uneatenMosquitos = uneaten.ceilingEntry(frogs[l].pos);\n                }\n            } else {\n                ArrayList<Integer> old = uneaten.get(pos);\n                if (old != null) {\n                    old.add(size);\n                } else {\n                    ArrayList<Integer> newMosquites = new ArrayList<>();\n                    newMosquites.add(size);\n                    uneaten.put(pos, newMosquites);\n                }\n\n            }\n        }\n        int[] eatens = new int[n];\n        long[] lengths = new long[n];\n        for (int i = 0; i < n; i++) {\n            eatens[frogs[i].number] = frogs[i].eaten;\n            lengths[frogs[i].number] = frogs[i].length;\n        }\n        for (int i = 0; i < n; i++) {\n            out.printf(""%d %d\n"", eatens[i], lengths[i]);\n        }\n        out.close();\n    }\n\n\n    private static class MyScanner {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n\n        MyScanner(InputStream isr) {\n            br = new BufferedReader(new InputStreamReader(isr));\n        }\n\n        String next() throws IOException {\n            while (st == null || !st.hasMoreElements()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n    }\n}\n\n","data structures,greedy"
"import java.util.*;\n\npublic class lieges {\n	public static int mex(int a, int b) {\n		if (a != 0 && b != 0) return 0;\n		else if (a != 1 && b != 1) return 1;\n		return 2;\n	}\n\n	public static int nim(int a, int k) {\n		if (k == 0 && a < 3) return a;\n		if (k == 0) return 1 - (a&1);\n		else if ((a&1) == 1) return a < 4 ? 1 : 0;\n\n		return mex(nim(a-1,k), nim(a>>1,k));\n	}\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n\n		int n = sc.nextInt(), k = sc.nextInt()&1;\n\n		int nimber = 0;\n		for (int i=0; i<n; i++) nimber ^= nim(sc.nextInt(), k);\n\n		System.out.println(nimber == 0 ? ""Nicky"" : ""Kevin"");\n	}\n}","games,math"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF603C extends PrintWriter {\n	CF603C() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF603C o = new CF603C(); o.main(); o.flush();\n	}\n\n	int solve(int a) {\n		if (a < 4)\n			return a & 1;\n		if (a == 4)\n			return 2;\n		if ((a & 1) == 1)\n			return 0;\n		return solve(a / 2) == 1 ? 2 : 1;\n	}\n	void main() {\n		int n = sc.nextInt();\n		int k = sc.nextInt() & 1;\n		int sum = 0;\n		while (n-- > 0) {\n			int a = sc.nextInt();\n			int x;\n			if (k == 0)\n				x = a < 3 ? a : a + 1 & 1;\n			else\n				x = solve(a);\n			sum ^= x;\n		}\n		println(sum == 0 ? ""Nicky"" : ""Kevin"");\n	}\n}\n","games,math"
"import java.util.Scanner;\n\npublic class Main {\n\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n\n			int n=in.nextInt();\n			int k=in.nextInt();\n	\n			int sum=0;\n		for(int i=0;i<n;i++){\n			if(k%2==0)sum^=even(in.nextInt());\n			else sum^=odd(in.nextInt());}\n		if(sum!=0)System.out.println(""Kevin"" );\n		else System.out.println(""Nicky"");\n			\n		\n\n	}\n	private static int even(int x) {\n		   if (x <= 2) return x;  \n		return x%2==0?1:0;\n	}\n	private static int odd(int x) {\n		 if(x==0)return 0;  \n		    if(x==1)return 1;  \n		    if(x==2)return 0;  \n		    if(x>=5&&(x&1)!=0)return 0;  \n		    int two=0;while(x%2==0){x/=2;++two;}  \n		    if(x==3)return (two&1)!=0?2:1;  \n		    else return (two&1)!=0?1:2;  \n	}\n\n}","games,math"
"\nimport java.util.Scanner;\n\npublic class LiegesLegendre {\n    static int PRE[] = {0, 1, 0, 1, 2};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int K = sc.nextInt();\n        int res = 0;\n        for (int i = 0; i < N; i++) {\n            int a = sc.nextInt();\n            res ^= grundy(K, a);\n        }\n        System.out.println(res != 0? ""Kevin"" : ""Nicky"");\n    }\n\n    static int grundy(int K, int a) {\n        if (K % 2 == 0) {\n            if (a == 1) return 1;\n            if (a == 2) return 2;\n            return (a % 2) ^ 1;\n        } else {\n            if (a < 5) return PRE[a];\n            if (a % 2 == 1) return 0;\n            return (grundy(K, a / 2) == 1 ? 2 : 1);\n        }\n    }\n\n}\n","games,math"
"import java.io.*;\nimport java.util.*;\npublic class c {\npublic static void main(String[] args) throws IOException {\n    input.init(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    int n = input.nextInt(), k = input.nextInt();\n    Point[] data = new Point[n];\n    for(int i = 0; i<n; i++)\n    {\n        int x1 = input.nextInt(), y1 = input.nextInt(), x2 = input.nextInt(), y2 = input.nextInt();\n        int x = x1+x2;\n        int y = y1+y2;\n        data[i] = new Point(x, y);\n    }\n    Arrays.sort(data);\n    long min = (long)1e18;\n    for(int i = 0; i<=k; i++)\n        for(int j = 0; j+i<=k; j++)\n        {\n            int minx = data[i].x;\n            int maxx = data[n-1-j].x;\n            int[] ys = new int[n-i-j];\n            for(int ii = i; ii<=n-1-j; ii++) ys[ii-i] = data[ii].y;\n            //out.println(i+"" ""+j+"" ""+minx+"" ""+maxx+"" ""+Arrays.toString(ys));\n            Arrays.sort(ys);\n            int skip = k - i - j;\n            for(int ii = 0; ii<=skip; ii++)\n            {\n                int miny = ys[ii];\n                int maxy = ys[ys.length-1-(skip-ii)];\n                //out.println(minx+"" ""+maxx+"" ""+miny+"" ""+maxy);\n                if(maxx == minx) maxx++;\n                if(maxy == miny) maxy++;\n                long cur = (long)(maxy - miny + 1)/2 * ((maxx - minx + 1)/2);\n                min = Math.min(min, cur);\n            }\n        }\n    out.println(min);\n    out.close();\n}\nstatic class Point implements Comparable<Point>\n{\n    int x, y;\n    Point(int xx, int yy)\n    {\n        x = xx; y = yy;\n    }\n    @Override\n    public int compareTo(Point o) {\n    return x - o.x;\n    }\n}\npublic static class input {\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    static void init(InputStream input) {\n    reader = new BufferedReader(new InputStreamReader(input));\n    tokenizer = new StringTokenizer("""");\n    }\n\n    static String next() throws IOException {\n    while (!tokenizer.hasMoreTokens())\n        tokenizer = new StringTokenizer(reader.readLine());\n    return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n    return Integer.parseInt(next());\n    }\n\n    static double nextDouble() throws IOException {\n    return Double.parseDouble(next());\n    }\n\n    static long nextLong() throws IOException {\n    return Long.parseLong(next());\n    }\n}\n}\n","brute force,greedy,implementation,two pointers"
"import java.util.*;\nimport java.io.*;\n\npublic class C2 {\n\n  class Magnet {\n    int x, y;\n    int id;\n    \n    Magnet(int x, int y, int id) {\n      this.x  = x;\n      this.y  = y;\n      this.id = id;\n    }\n  }\n\n  Comparator<Magnet> cmpX = new Comparator<Magnet>() {\n    public int compare(Magnet m1, Magnet m2) { return m1.x - m2.x; }\n  };\n\n  Comparator<Magnet> cmpY = new Comparator<Magnet>() {\n    public int compare(Magnet m1, Magnet m2) { return m1.y - m2.y; }\n  };\n\n  int ind = 0, cnt = 0;\n  int[] removed;\n\n  void mark(int id) {\n    if(removed[id] != ind) {\n      removed[id] = ind;\n      cnt++;\n    }\n  }\n\n  void solve() {\n    Input in = new Input(System.in);\n    \n    int n = in.nextInt();\n    int k = in.nextInt();\n    \n    Magnet[] mX = new Magnet[n + 1];\n    Magnet[] mY = new Magnet[n + 1];\n    \n    for(int i = 1; i <= n; i++) {\n      int x1 = in.nextInt();\n      int y1 = in.nextInt();\n      int x2 = in.nextInt();\n      int y2 = in.nextInt();\n      Magnet m = new Magnet(x1 + x2, y1 +y2, i);\n      mX[i] = m;\n      mY[i] = m;\n    }\n    \n    Arrays.sort(mX, 1, n + 1, cmpX);\n    Arrays.sort(mY, 1, n + 1, cmpY);\n    \n    removed = new int[n + 1];\n    \n    long res = Long.MAX_VALUE;\n    \n    for(int i1 = 0; i1 <= k; i1++) {\n      for(int i2 = 0; i2 <= k; i2++) {\n        for(int i3 = 0; i3 <= k; i3++) {\n          for(int i4 = 0; i4 <= k; i4++) {\n            ind++;\n            cnt = 0;\n            \n            for(int i = 1; i <= i1; i++)    mark(mX[i].id);\n            for(int i = n; i > n - i2; i--) mark(mX[i].id);\n            for(int i = 1; i <= i3; i++)    mark(mY[i].id);\n            for(int i = n; i > n - i4; i--) mark(mY[i].id);\n            \n            if(cnt > k) {\n              continue;\n            }\n            \n            int w = Math.max(2, mX[n - i2].x - mX[i1 + 1].x);\n            int h = Math.max(2, mY[n - i4].y - mY[i3 + 1].y);\n            \n            long area = ((long) w) * h;\n            res = Math.min(res, area);\n          }\n        }\n      }\n    }\n    \n    System.out.println(res / 4);\n  }\n\n  public static void main(String[] args) {\n    new C2().solve();\n  }\n\n  class Input {\n\n    BufferedReader br;\n    StringTokenizer st;\n\n    Input(InputStream is) {\n      br = new BufferedReader(new InputStreamReader(is));\n    }\n\n    String next() {\n      try {\n        while(st == null || !st.hasMoreTokens()) {\n          String line = br.readLine();\n          if(line == null) {\n            return null;\n          }\n          st = new StringTokenizer(line);\n        }\n      } catch (IOException e) {\n        return null;\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n  }\n\n}\n","brute force,greedy,implementation,two pointers"
"import java.util.*;\nimport java.io.*;\n\npublic class C {\n\n  class Magnet {\n    int x, y;\n    boolean present = true;\n    \n    Magnet(int x, int y) {\n      this.x = x;\n      this.y = y;\n    }\n    \n    @Override\n    public String toString() {\n      return ""("" + x + "","" + y + "")"";\n    }\n  }\n\n  void solve() {\n    Input in = new Input(System.in);\n    \n    int N = in.nextInt();\n    int k = in.nextInt();\n    \n    Magnet[][] magnets = new Magnet[4][N];\n    \n    for(int i = 0; i < N; i++) {\n      int x1 = in.nextInt();\n      int y1 = in.nextInt();\n      int x2 = in.nextInt();\n      int y2 = in.nextInt();\n      Magnet m = new Magnet(x1 + x2, y1 + y2);\n      for(int j = 0; j < 4; j++) {\n        magnets[j][i] = m;\n      }\n    }\n    \n    Comparator<Magnet> compByX = new Comparator<Magnet>() {\n      @Override\n      public int compare(Magnet m1, Magnet m2) {\n        return m1.x - m2.x;\n      }\n    };\n    \n    Comparator<Magnet> compByY = new Comparator<Magnet>() {\n      @Override\n      public int compare(Magnet m1, Magnet m2) {\n        return m1.y - m2.y;\n      }\n    };\n    \n    Arrays.sort(magnets[0], compByX);\n    //System.out.println(""X: "" + Arrays.toString(magnets[0]));\n    Arrays.sort(magnets[1], compByX.reversed());\n    Arrays.sort(magnets[2], compByY);\n    //System.out.println(""Y: "" + Arrays.toString(magnets[2]));\n    Arrays.sort(magnets[3], compByY.reversed());\n    \n    int ii[] = new int[4];\n    int jj[] = new int[4];\n    \n    long res = Long.MAX_VALUE;\n    \n    for(ii[0] = 0; ii[0] <= k; ii[0]++) {\n      for(ii[1] = 0; ii[1] <= k - ii[0]; ii[1]++) {\n        for(ii[2] = 0; ii[2] <= k - ii[0] - ii[1]; ii[2]++) {\n          for(ii[3] = 0; ii[3] <= k - ii[0] - ii[1] - ii[2]; ii[3]++) {\n            for(int i = 0; i < 4; i++) {\n              int r = 0;\n              while(r < ii[i]) {\n                if(magnets[i][jj[i]].present) {\n                  magnets[i][jj[i]].present = false;\n                  r++;\n                }\n                jj[i]++;\n              }\n            }\n            \n            for(int i = 0; i < 4; i++) {\n              while(!magnets[i][jj[i]].present) {\n                jj[i]++;\n              }\n            }\n            \n            long area = Math.max(((long) magnets[1][jj[1]].x - magnets[0][jj[0]].x), 2)\n                      * Math.max(((long) magnets[3][jj[3]].y - magnets[2][jj[2]].y), 2);\n            res = Math.min(res, area);\n            \n            //if(area == 0) {\n            //  for(int i = 0; i < 4; i++) {\n            //    System.out.print(jj[i] + "" "");\n            //  }\n            //  System.out.println();\n            //}\n            \n            for(int i = 0; i < 4; i++) {\n              while(jj[i] > 0) {\n                magnets[i][--jj[i]].present = true;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    System.out.println(res / 4);\n  }\n\n  public static void main(String[] args) {\n    new C().solve();\n  }\n\n  class Input {\n\n    BufferedReader br;\n    StringTokenizer st;\n\n    Input(InputStream is) {\n      br = new BufferedReader(new InputStreamReader(is));\n    }\n\n    String next() {\n      try {\n        while(st == null || !st.hasMoreTokens()) {\n          String line = br.readLine();\n          if(line == null) {\n            return null;\n          }\n          st = new StringTokenizer(line);\n        }\n      } catch (IOException e) {\n        return null;\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n  }\n\n}\n","brute force,greedy,implementation,two pointers"
"import java.util.*;\nimport java.io.*;\n\npublic class C {\n	FastScanner in;\n	PrintWriter out;\n\n	class Point {\n		long x, y;\n		int id;\n\n		public Point(long x, long y, int id) {\n			super();\n			this.x = x;\n			this.y = y;\n			this.id = id;\n		}\n	}\n	\n	Point[] pts;\n	int n;\n	TreeSet<Point> minY, maxY, minX, maxX;\n	long ans = Long.MAX_VALUE;\n	TreeSet<Point>[] sets;\n	\n	public void solve() throws IOException {\n		n = in.nextInt();\n		int k = in.nextInt();\n		pts = new Point[n];\n		for (int i = 0; i < n; i++) {\n			long x1 = in.nextLong(), y1 = in.nextLong();\n			long x2 = in.nextLong(), y2 = in.nextLong();\n			pts[i] = new Point((x2 + x1), (y2 + y1), i);\n		}\n		minY = new TreeSet<>(new Comparator<Point>() {\n\n			@Override\n			public int compare(Point o1, Point o2) {\n				if (o1.y != o2.y) {\n					return Long.compare(o1.y, o2.y);\n				}\n				return Integer.compare(o1.id, o2.id);\n			}\n		});\n		maxY = new TreeSet<>(new Comparator<Point>() {\n\n			@Override\n			public int compare(Point o1, Point o2) {\n				if (o1.y != o2.y) {\n					return -Long.compare(o1.y, o2.y);\n				}\n				return Integer.compare(o1.id, o2.id);\n			}\n		});\n		minX = new TreeSet<>(new Comparator<Point>() {\n\n			@Override\n			public int compare(Point o1, Point o2) {\n				if (o1.x != o2.x) {\n					return Long.compare(o1.x, o2.x);\n				}\n				return Integer.compare(o1.id, o2.id);\n			}\n		});\n		maxX = new TreeSet<>(new Comparator<Point>() {\n\n			@Override\n			public int compare(Point o1, Point o2) {\n				if (o1.x != o2.x) {\n					return -Long.compare(o1.x, o2.x);\n				}\n				return Integer.compare(o1.id, o2.id);\n			}\n		});\n		sets = new TreeSet[4];\n		sets[0] = minX;\n		sets[1] = maxX;\n		sets[2] = minY;\n		sets[3] = maxY;\n		for (Point p : pts) {\n			for (TreeSet<Point> set : sets) {\n				set.add(p);\n			}\n		}\n		int[] cnt = new int[4];\n		for (cnt[0] = 0; cnt[0] <= k; cnt[0]++) {\n			for (cnt[1] = 0; cnt[1] <= k; cnt[1]++) {\n				for (cnt[2] = 0; cnt[2] <= k; cnt[2]++) {\n					for (cnt[3] = 0; cnt[3] <= k; cnt[3]++) {\n						if (cnt[0] + cnt[1] + cnt[2] + cnt[3] == k) {\n							ArrayList<Point> toRemove = new ArrayList<>();\n							for (int i = 0; i < 4; i++) {\n								for (int j = 0; j < cnt[i]; j++) {\n									Point toDel = sets[i].first();\n									toRemove.add(toDel);\n									for (TreeSet<Point> set : sets) {\n										set.remove(toDel);\n									}\n								}\n							}\n							long dx = maxX.first().x - minX.first().x;\n							long dy = maxY.first().y - minY.first().y;\n							dx = Math.max(1, dx);\n							dy = Math.max(1, dy);\n							dx = (dx + 1) / 2;\n							dy = (dy + 1) / 2;\n							ans = Math.min(dx * dy, ans);\n							for (Point p : toRemove) {\n								for (TreeSet<Point> set : sets) {\n									set.add(p);\n								}\n							}\n						}\n					}\n				}\n			}\n		}\n		out.println(ans);\n	}\n\n	public void run() {\n		try {\n			in = new FastScanner();\n			out = new PrintWriter(System.out);\n\n			solve();\n\n			out.close();\n		} catch (IOException e) {\n			e.printStackTrace();\n		}\n	}\n\n	class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		FastScanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		String next() {\n			while (st == null || !st.hasMoreTokens()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			}\n			return st.nextToken();\n		}\n\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n	}\n\n	public static void main(String[] arg) {\n		new C().run();\n	}\n}","brute force,greedy,implementation,two pointers"
"import java.util.Scanner;\n\npublic class D {\n    public static void main(String[] args) {\n        Scanner cin = new Scanner(System.in);\n        double x1 = cin.nextDouble();\n        double y1 = cin.nextDouble();\n        double x2 = cin.nextDouble();\n        double y2 = cin.nextDouble();\n        double v = cin.nextDouble();\n        double t = cin.nextDouble();\n        double vx = cin.nextDouble();\n        double vy = cin.nextDouble();\n        double wx = cin.nextDouble();\n        double wy = cin.nextDouble();\n        cin.close();\n\n        double left = 0;\n        double right = 1e8;\n        for (int time = 0; time < 100000; time++) {\n            double mid = (left + right) / 2.0;\n\n            double nx, ny;\n            if (mid <= t) {\n                nx = vx * mid;\n                ny = vy * mid;\n            } else {\n                nx = vx * t + wx * (mid - t);\n                ny = vy * t + wy * (mid - t);\n            }\n\n            double dx = x2 - x1 - nx;\n            double dy = y2 - y1 - ny;\n            if (v * v * mid * mid > dx * dx + dy * dy) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        System.out.println(right);\n    }\n}\n","binary search,geometry,math"
"import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n    static int MOD = 1000000007;\n\n    // After writing solution, quick scan for:\n    //   array out of bounds\n    //   special cases e.g. n=1?\n    //   npe, particularly in maps\n    //\n    // Big numbers arithmetic bugs:\n    //   int overflow\n    //   sorting, or taking max, after MOD\n    void solve() throws IOException {\n        int[] xyxy = ril(4);\n        int x1 = xyxy[0];\n        int y1 = xyxy[1];\n        int x2 = xyxy[2];\n        int y2 = xyxy[3];\n        int[] vt = ril(2);\n        int v_max = vt[0];\n        int t = vt[1];\n\n        int[] v = ril(2);\n        int vx = v[0];\n        int vy = v[1];\n        int[] w = ril(2);\n        int wx = w[0];\n        int wy = w[1];\n\n        // Case 1: can we get to target <= t.\n        int dx = x2 - x1;\n        int dy = y2 - y1;\n        double zx = (double) dx / t - vx;\n        double zy = (double) dy / t - vy;\n        if (zx * zx + zy * zy <= v_max * v_max) {\n            double l = 0;\n            double r = t;\n            double best = Double.MAX_VALUE;\n            for (int i = 0; i < 100; i++) {\n                double m = (l + r) / 2;\n                zx = (double) dx / m - vx;\n                zy = (double) dy / m - vy;\n                if (zx * zx + zy * zy <= v_max * v_max) {\n                    best = m;\n                    r = m;\n                } else {\n                    l = m;\n                }\n            }\n            printDouble(best);\n            return;\n        }\n\n        // Case 2: get as far as possible in first phase. This is a circular region, offset\n        // by the wind speed: t * (vx, vy).\n        double x_offseted = (double) vx * t + x1;\n        double y_offseted = (double) vy * t + y1;\n        double radius = (double) v_max * t;\n        double l = 0;\n        double r = Integer.MAX_VALUE;  // this is probably big enough.\n        double best = Double.MAX_VALUE;\n        for (int i = 0; i < 100; i++) {\n            double m = (l + r) / 2;\n            double radius2 = (double) v_max * m;\n            double x_offseted2 = x2 - (double) wx * m;\n            double y_offseted2 = y2 - (double) wy * m;\n            double DX = x_offseted2 - x_offseted;\n            double DY = y_offseted2 - y_offseted;\n            double D = Math.sqrt(DX * DX + DY * DY);\n            if (radius + radius2 >= D) {\n                best = m;\n                r = m;\n            } else {\n                l = m;\n            }\n        }\n        printDouble(t + best);\n    }\n    // IMPORTANT\n    // DID YOU CHECK THE COMMON MISTAKES ABOVE?\n\n    // Template code below\n\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    PrintWriter pw = new PrintWriter(System.out);\n\n    public static void main(String[] args) throws IOException {\n        Main m = new Main();\n        m.solve();\n        m.close();\n    }\n\n    void close() throws IOException {\n        pw.flush();\n        pw.close();\n        br.close();\n    }\n\n    int ri() throws IOException {\n        return Integer.parseInt(br.readLine().trim());\n    }\n\n    long rl() throws IOException {\n        return Long.parseLong(br.readLine().trim());\n    }\n\n    int[] ril(int n) throws IOException {\n        int[] nums = new int[n];\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n            int sign = 1;\n            c = br.read();\n            int x = 0;\n            if (c == '-') {\n                sign = -1;\n                c = br.read();\n            }\n            while (c >= '0' && c <= '9') {\n                x = x * 10 + c - '0';\n                c = br.read();\n            }\n            nums[i] = x * sign;\n        }\n        while (c != '\n' && c != -1) c = br.read();\n        return nums;\n    }\n\n    long[] rll(int n) throws IOException {\n        long[] nums = new long[n];\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n            int sign = 1;\n            c = br.read();\n            long x = 0;\n            if (c == '-') {\n                sign = -1;\n                c = br.read();\n            }\n            while (c >= '0' && c <= '9') {\n                x = x * 10 + c - '0';\n                c = br.read();\n            }\n            nums[i] = x * sign;\n        }\n        while (c != '\n' && c != -1) c = br.read();\n        return nums;\n    }\n\n    int[] rkil() throws IOException {\n        int sign = 1;\n        int c = br.read();\n        int x = 0;\n        if (c == '-') {\n            sign = -1;\n            c = br.read();\n        }\n        while (c >= '0' && c <= '9') {\n            x = x * 10 + c - '0';\n            c = br.read();\n        }\n        return ril(x);\n    }\n\n    long[] rkll() throws IOException {\n        int sign = 1;\n        int c = br.read();\n        int x = 0;\n        if (c == '-') {\n            sign = -1;\n            c = br.read();\n        }\n        while (c >= '0' && c <= '9') {\n            x = x * 10 + c - '0';\n            c = br.read();\n        }\n        return rll(x);\n    }\n\n    char[] rs() throws IOException {\n        return br.readLine().toCharArray();\n    }\n\n    void sort(int[] A) {\n        Random r = new Random();\n        for (int i = A.length-1; i > 0; i--) {\n            int j = r.nextInt(i+1);\n            int temp = A[i];\n            A[i] = A[j];\n            A[j] = temp;\n        }\n        Arrays.sort(A);\n    }\n\n    void printDouble(double d) {\n        pw.printf(""%.16f"", d);\n    }\n}","binary search,geometry,math"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF590B extends PrintWriter {\n	CF590B() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF590B o = new CF590B(); o.main(); o.flush();\n	}\n\n	double solve(long x, long y, long vx, long vy, long v) {\n		// (x - vx t)^2 + (y - vy t)^2 = v^2 t^2\n		// (v^2 - vx^2 - vy^2) t^2 + 2(x vx + y vy) t - (x^2 + y^2) = 0\n		double a = v * v - vx * vx - vy * vy;\n		double b = 2 * (x * vx + y * vy);\n		double c = -(x * x + y * y);\n		return (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n	}\n	void main() {\n		int x1 = sc.nextInt();\n		int y1 = sc.nextInt();\n		int x2 = sc.nextInt();\n		int y2 = sc.nextInt();\n		int x = x1 - x2;\n		int y = y1 - y2;\n		int v = sc.nextInt();\n		int t = sc.nextInt();\n		int vx = -sc.nextInt();\n		int vy = -sc.nextInt();\n		int wx = -sc.nextInt();\n		int wy = -sc.nextInt();\n		double t1 = solve(x, y, vx, vy, v);\n		if (t1 >= 0 && t1 <= t) {\n			println(t1);\n			return;\n		}\n		double t2 = solve(x + (long) (wx - vx) * t, y + (long) (wy - vy) * t, wx, wy, v);\n		println(Math.max(t2, t));\n	}\n}\n","binary search,geometry,math"
"import java.util.Scanner;\n\npublic class D {\n    public static void main(String[] args) {\n        Scanner cin = new Scanner(System.in);\n        double x1 = cin.nextDouble();\n        double y1 = cin.nextDouble();\n        double x2 = cin.nextDouble();\n        double y2 = cin.nextDouble();\n        double v = cin.nextDouble();\n        double t = cin.nextDouble();\n        double vx = cin.nextDouble();\n        double vy = cin.nextDouble();\n        double wx = cin.nextDouble();\n        double wy = cin.nextDouble();\n        cin.close();\n\n        double left = 0;\n        double right = 1e8;\n        for (int time = 0; time < 100000; time++) {\n            double mid = (left + right) / 2.0;\n\n            double nx, ny;\n            if (mid <= t) {\n                nx = vx * mid;\n                ny = vy * mid;\n            } else {\n                nx = vx * t + wx * (mid - t);\n                ny = vy * t + wy * (mid - t);\n            }\n\n            double dx = x2 - x1 - nx;\n            double dy = y2 - y1 - ny;\n            if (v * v * mid * mid > dx * dx + dy * dy) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        System.out.println(right);\n    }\n}\n","binary search,geometry,math"
"import java.io.*;\nimport java.util.*;\n\n/*\n\n1\n16 4\n...AAAAA........\nBB.CCCCC..\n...PDDDDD....\n\n\n1\ntime=0\n16 4\n...AAAAA........\ns.BBB....CCCCC..\n.......DDDDD....\n\n\ntime=1\n16 4\n..AAAAA.........\n.BBB....CCCCC...\n.s....DDDDD.....\n\n\ntime=2\n16 4\n.AAAAA..........\nBBB....CCCCC....\n..s..DDDDD......\n\ntime=3\n16 4\nAAAAA...........\nBB....CCCCC.....\n...sDDDDD.......\n\ntime=4\n16 4\nAAAA............\nB....CCCCC......\n...sDDDDD.......\n\n*/\n\n\npublic class C {\n	static FastReader sc=null;\n	static boolean dp[][][],processed[][][];\n	\n	\n	public static void main(String[] args) {\n		sc=new FastReader();\n		int t=sc.nextInt();\n		while(t-->0) {\n			int n=sc.nextInt(),k=sc.nextInt();\n			char b[][]=new char[3][n];\n			int r=b.length,c=b[0].length;\n			dp=new boolean[r+5][c+5][c+5];\n			processed=new boolean[r+5][c+5][c+5];\n			for(int i=0;i<3;i++) {\n				b[i]=sc.next().toCharArray();\n			}\n			\n//			for(int i=0;i<r;i++)\n//				for(int j=0;j<c;j++)\n//					System.out.println(Arrays.toString(processed[i][j]));\n			\n			int sx=-1;\n			for(int i=0;i<3;i++)if(b[i][0]=='s')sx=i;\n			\n			boolean pos=go(sx,0,0,b);\n			System.out.println(pos?""YES"":""NO"");\n		}\n		\n	}\n	\n	static boolean go(int x,int y,int time,char b[][]) {\n		\n		if(y==b[0].length) {\n			return true;\n		}\n		//you should move first to the right\n		//and then change the direction\n		if(processed[x][y][time])return dp[x][y][time];\n		\n		if(Train(x,y,time,b)) {\n			processed[x][y][time]=true;\n			return dp[x][y][time]=false;\n		}\n		if(Train(x,y+1,time,b)) {\n			processed[x][y][time]=true;\n			return dp[x][y][time]=false;\n		}\n		boolean pos=false;\n		//stay\n		pos|=go(x,y+1,time+1,b);\n		//go up\n		if(x>0 && (!Train(x-1,y+1,time,b)))pos|=go(x-1,y+1,time+1,b);\n		//go down\n		if(x<2 && (!Train(x+1,y+1,time,b)))pos|=go(x+1,y+1,time+1,b);\n		\n		processed[x][y][time]=true;\n\n		return dp[x][y][time]=pos;\n	}\n	\n	static boolean Train(int x,int y,int time,char b[][]) {\n		int now=2*time+y;\n		\n		if(now>=0 && now<b[0].length && (Character.isUpperCase(b[x][now]))) {\n			//System.out.println(""x: ""+x+"" y: ""+y+"" time: ""+time+"" TRAIN now: ""+now);\n\n			return true;\n		}\n		\n		//System.out.println(""x: ""+x+"" y: ""+y+"" time: ""+time+"" NO TRAIN now: ""+now);\n		\n		return false;\n	}\n	\n	\n	\n	\n\n	\n	static int[] ruffleSort(int a[]) {\n		ArrayList<Integer> al=new ArrayList<>();\n		for(int i:a)al.add(i);\n		Collections.sort(al);\n		for(int i=0;i<a.length;i++)a[i]=al.get(i);\n		return a;\n	}\n	\n	static class FastReader{\n		\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n		\n		String next() {\n			while(!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());\n				}\n				catch(IOException e){\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n		\n		int[] readArray(int n) {\n			int a[]=new int[n];\n			for(int i=0;i<n;i++)a[i]=sc.nextInt();\n			return a;\n		}\n	}\n}\n\n\n\n\n\n\n","dfs and similar,graphs,shortest paths"
"/*\n        ""Everything in the universe is balanced. Every disappointment\n                you face in life will be balanced by something good for you!\n                        Keep going, never give up.""\n\n                        Just have Patience + 1...\n\n*/\n\n\n\n\n\n\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n\npublic class Solution {\n\n    static int MAX = 110;\n    static char[][] arr = new char[3][MAX];\n    static boolean[][] visited = new boolean[3][MAX];\n    static int n, k;\n\n    public static void main(String[] args) throws java.lang.Exception {\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        sc = new FastReader();\n\n        int test = sc.nextInt();\n        for (int t = 1; t <= test; t++) {\n            solve();\n        }\n        out.close();\n    }\n\n    private static void solve() {\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n\n        for (int i = 0; i < 3; i++) {\n            Arrays.fill(arr[i], '.');\n            Arrays.fill(visited[i], false);\n        }\n\n        for (int i = 0; i < 3; i++) {\n            char[] temp = sc.next().toCharArray();\n            for (int j = 0; j < n; j++) {\n                arr[i][j] = temp[j];\n            }\n        }\n\n        for (int i = 0; i < 3; i++) {\n            if (arr[i][0] == 's') {\n                dfs(i, 0);\n                break;\n            }\n        }\n\n        for (int i = 0; i < 3; i++) {\n            for (int j = 105; j < MAX; j++) {\n                if (visited[i][j]) {\n                    out.println(""YES"");\n                    return;\n                }\n            }\n        }\n\n        out.println(""NO"");\n    }\n\n    private static void dfs(int row, int col) {\n        if (visited[row][col]) {\n            return;\n        }\n\n        visited[row][col] = true;\n        if (col >= 105) {\n            return;\n        }\n\n        // right up\n        if (isValid(row, col + 1) && isValid(row - 1, col + 1) && isValid(row - 1, col + 2) && isValid(row - 1, col + 3)) {\n            dfs(row - 1, col + 3);\n        }\n\n        // right stay\n        if (isValid(row, col + 1) && isValid(row, col + 2) && isValid(row, col + 3)) {\n            dfs(row, col + 3);\n        }\n\n        // right down\n        if (isValid(row, col + 1) && isValid(row + 1, col + 1) && isValid(row + 1, col + 2) && isValid(row + 1, col + 3)) {\n            dfs(row + 1, col + 3);\n        }\n    }\n    \n    private static boolean isValid(int row, int col) {\n        return row >= 0 && row < 3 && col >= 0 && col < MAX && (arr[row][col] < 'A' || arr[row][col] > 'Z');\n    }\n\n\n    public static FastReader sc;\n    public static PrintWriter out;\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer str;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (str == null || !str.hasMoreElements())\n            {\n                try\n                {\n                    str = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  lastMonthOfVacation)\n                {\n                    lastMonthOfVacation.printStackTrace();\n                }\n            }\n            return str.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = """";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException lastMonthOfVacation)\n            {\n                lastMonthOfVacation.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}","dfs and similar,graphs,shortest paths"
"\n\n\nimport java.io.*;\nimport java.util.*;\nimport java.math.BigInteger; \nimport java.lang.*;\n\n\n\n\npublic class Main {\n    \n    \n    static class sort1 implements Comparator<List<Integer>>\n   {\n        public int compare(List<Integer>  a,List<Integer> b)\n        {\n            \n            return (a.size() - b.size());\n        }\n   }\n    \n   static class sort implements Comparator<int[]>\n   {\n        public int compare(int[] a,int[] b)\n        {\n            \n            return -b[0]+a[0];\n        }\n   }\n    static class sortP implements Comparator<int[]>\n   {\n        public int compare(int[] a,int[] b)\n        {\n            \n            return -b[0]+a[0];\n        }\n   }\n   static class sort1111 implements Comparator<long[]>\n   {\n        public int compare(long[] a,long[] b)\n        {\n            \n          long c = a[1]-b[1];\n          if(c==0l) c = (a[0]-b[0]);\n          if(c==0l) return 0;\n          if(c>0l) return 1;\n          return -1;\n        }\n   }\n  \n   static class sort11 implements Comparator<double[]>\n   {\n        public int compare(double[] a,double[] b)\n        {\n            //if(a[0] == b[0]) return a[1]-b[1];\n           if(a[1] < b[1]) return -1;\n           else if(a[1] > b[1]) return 1;\n           return 0;\n        }\n   }\n   public static String[] F(BufferedReader bf) throws Exception\n    {\n        return (bf.readLine().split("" ""));\n    }\n    \n   public static void pr(PrintWriter out,Object o)\n   {\n      \n    out.println(o.toString());//out.flush();\n    \n   }\n   public static void prW(PrintWriter out,Object o)\n   {\n      \n    out.print(o.toString());//out.flush();\n    \n   }\n   public static int intIn(String st)\n   {\n      return Integer.parseInt(st);\n   }\n   \n   \n    \n    public static void pr(Object o)\n    {\n        System.out.println(o.toString());\n    }\n    public static void prW(Object o)\n    {\n        System.out.print(o.toString());\n    }\n    \n   \n    public static int inInt(String s)\n    {\n        return Integer.parseInt(s);\n    }\n    public static long in(String s)\n    {\n        return Long.parseLong(s);\n    }\n \n \n    static int[] toIntArray(String[] m) \n    { \n        int[] p=new int[m.length];\n        for(int o=0;o<m.length;o++)\n        {\n            p[o]= inInt(m[o]);\n        }\n        return p;\n    }\n    static double[] toDArray(String[] m) \n    { \n        double[] p=new double[m.length];\n        for(int o=0;o<m.length;o=0)\n        {\n            p[o]= Double.parseDouble(m[o]);\n        }\n        return p;\n    }\n    static long[] toLArray(String[] m) \n    { \n       long[] p=new long[m.length];\n        for(int o=0;o<m.length;o++)\n        {\n            p[o]= in(m[o]);\n        }\n        return p;\n    }\n   \n     static long gcd(long a, long b)\n        {\n          if (b == 0)\n            return a;\n          return gcd(b, a % b); \n        }\n     \n        static long pow(long x, long y, long p)\n      {\n        if(y == 0) return 1l;\n        long res = 1; // Initialize result\n     \n        x = x % p; // Update x if it is more than or\n        // equal to p\n     \n        if (x == 0)\n          return 0l; // In case x is divisible by p;\n     \n        while (y > 0)\n        {\n     \n          // If y is odd, multiply x with result\n          if ((y & 1) != 0)\n            res = (res * x) % p;\n     \n          // y must be even now\n          y = y >> 1; // y = y/2\n          x = (x * x) % p;\n        }\n        return res;\n      }\n    \n   \n    \n\n   \n   \n\n   \n    static long __gcd(long n1, long n2)\n    {\n\n        if(n1==0l) return n2;\n        if(n2==0l) return n1;\n        if(n1==1l || n2==1l) return 1l;\n       // long gcd = 1;\n        if(n1 == n2)  return n1;\n        if(n1>n2) return __gcd(n1%n2,n2);\n        return __gcd(n1,n2%n1);\n        \n    }\n    \n   \n    \n    public static boolean F(int r,int c,int it,Boolean[][][] dp,char[][] arr,List<int[]> list){\n      if(c == (arr[0].length-1)) {\n        if(r<0 || r>=3) return false;\n        dp[r][c][it] = true;\n        return true;\n      }\n      if(r<0 || r>=3) return false;\n\n      if(dp[r][c][it] != null)  return dp[r][c][it];\n\n\n      boolean b = false;boolean res=true;\n    \n      boolean b1,b2,b3;b1=b2=b3=true;\n      for(int[] p : list){\n\n        int rx,ry;\n        rx = p[0];ry=p[1];\n        int l = p[2];\n        int nry;int ory;\n        nry = ry - 2*it;\n\n        if(rx == r){\n            if(it > 0){\n\n             ory = ry - 2*(it-1);\n\n             if(c<=Math.max(ory,nry) && c>=Math.min(ory,nry) ){\n              b1=false;\n             }\n             if((c+1)<=Math.max(ory,nry) && (c+1)>=Math.min(ory,nry) ) b1=false;\n\n          }\n          else{\n          if(nry == c){\n            b1=false;break;\n          }\n          if((nry) == (c+1)){\n            b1=false;\n          }}\n          \n\n        }\n        else if(rx == (r-1)){\n          int vp = c+1;int low = nry;int high = nry+l-1;\n          if(vp >= low && vp<=high){\n            b2=false;\n          }\n\n        }\n        else if(rx == (r+1)){\n          int vp = c+1;int low = nry;int high = nry+l-1;\n          if(vp >= low && vp<=high){\n            b3=false;\n          }\n\n        }\n      }\n\n      if(!b1){\n\n         dp[r][c][it] = false;return false;\n\n      }\n      boolean bol = false;\n      if(b2){\n\n        bol = bol || F(r-1,c+1,it+1,dp,arr,list);\n\n      }\n       if(b3){\n\n        bol = bol || F(r+1,c+1,it+1,dp,arr,list);\n\n      }\n\n      bol = bol || F(r,c+1,it+1,dp,arr,list);\n\n      dp[r][c][it] = bol;return bol;\n\n\n\n\n    }\n    public static void main (String[] args) throws Exception {\n        \n        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);;;//\n        \n        //int[] map=new int[1000001];\n      \n       int yy=inInt(bf.readLine());\n       \n\n\n        \n\n        for(int w=0;w<yy;w++)\n        {\n             //String str = bf.readLine();\n          out.flush();\n         \n            String[] xlp = bf.readLine().split("" "");\n            \n            //String st = bf.readLine();\n      int n;//boolean bol=false;\n           int  m;//long a,b,c;\n           int k;\n          // int l;\n           //int double avg  k;//pr(out,""vbc"");\n       // boolean bol = false;\n           //long mod=1000000000+7\n       n=inInt(xlp[0]);k=inInt(xlp[1]);//m=inInt(xlp[2]);//int j=in(xlp[3]);//long k=in(xlp[4]);\n       char[][] arr = new char[3][n];\n       List<int[]> list=new ArrayList<>();int p=-1;\n       for(int i=0;i<3;i++){\n        arr[i] = bf.readLine().toCharArray();\n       }\n       for(int i=0;i<3;i++){\n        for(int j=0;j<n;){\n          if(arr[i][j] == '.'){\n            j++;continue;\n          }\n          if(arr[i][j] == 's'){\n            p=i;\n            j++;continue;\n          }\n\n          k = j;\n          while(k<n && arr[i][k] == arr[i][j]){\n            k++;\n          }\n          list.add(new int[]{i,j,k-j});\n          j=k;\n\n        }\n       }\n      // pr(out,p);\n      if(F(p,0,0,new Boolean[3][n][n],arr,list)) pr(out,""YES"");\n      else pr(out,""NO"");\n       \n\n\n\n\n\n       \n\n       \n\n\n   }\n    out.close();\n   bf.close();//\n       \n}}\n\n\n/*\n\n\nKickstart\n String rp;\n            rp = ""Case #""+(w+1)+"": ""+(n-ans)+"" "";\nstatic int[][] dir={{0,1},{1,0},{-1,0},{0,-1}};\n\nstatic class SegmentTreeRMQ \n    { \n    int st[]; \n    int minVal(int x, int y) { \n        return (x > y) ? x : y; \n    } \n  \n    \n    int getMid(int s, int e) { \n        return s + (e - s) / 2; \n    } \n  \n    \n    int RMQUtil(int ss, int se, int qs, int qe, int index) \n    { \n        \n        if (qs <= ss && qe >= se) \n            return st[index]; \n  \n        // If segment of this node is outside the given range \n        if (se < qs || ss > qe) \n            return Integer.MIN_VALUE; \n  \n        // If a part of this segment overlaps with the given range \n        int mid = getMid(ss, se); \n        return minVal(RMQUtil(ss, mid, qs, qe, 2 * index + 1), \n                RMQUtil(mid + 1, se, qs, qe, 2 * index + 2)); \n    } \n  \n    // Return minimum of elements in range from index qs (query \n    // start) to qe (query end).  It mainly uses RMQUtil() \n    int RMQ(int n, int qs, int qe) \n    { \n        // Check for erroneous input values \n        \n  \n        return RMQUtil(0, n - 1, qs, qe, 0); \n    } \n  \n    // A recursive function that constructs Segment Tree for \n    // array[ss..se]. si is index of current node in segment tree st \n    int constructSTUtil(int arr[], int ss, int se, int si) \n    { \n        // If there is one element in array, store it in current \n        //  node of segment tree and return \n        if (ss == se) { \n            st[si] = arr[ss]; \n            return arr[ss]; \n        } \n  \n        // If there are more than one elements, then recur for left and \n        // right subtrees and store the minimum of two values in this node \n        int mid = getMid(ss, se); \n        st[si] = minVal(constructSTUtil(arr, ss, mid, si * 2 + 1), \n                constructSTUtil(arr, mid + 1, se, si * 2 + 2)); \n        return st[si]; \n    } \n  \n    \n    void con(int arr[]) \n    { \n        // Allocate memory for segment tree \n  \n        //Height of segment tree \n        int n = (arr.length);\n        int x = (int) (Math.ceil(Math.log(n) / Math.log(2))); \n  \n        //Maximum size of segment tree \n        int max_size = 2 * (int) Math.pow(2, x) - 1; \n        st = new int[max_size]; // allocate memory \n  \n        // Fill the allocated memory st \n        constructSTUtil(arr, 0, n - 1, 0); \n    }\n    }\n     static class DSU {\n    \n    int[] p;int[] sz;int op;int c;;\n    int[] last;\n    public void G(int n)\n    {\n        last=new int[n];\n        p=new int[n];\n        sz=new int[n];c=n;\n        op=n;\n        for(int h=0;h<n;h++)\n        {\n            sz[h]=1;p[h]=h;\n            last[h]=h;\n        }\n    }\n    public int find(int x)\n    {\n        int y=x;\n        while(x!=p[x]) x=p[x];\n        while(y!=p[y])\n        {\n            int tem=p[y];\n            p[y]=x;y=tem;\n        }\n        return p[y];\n    }\n    public void union(int a,int b)\n    {\n        int x,y;\n        x=find(a);y=find(b);\n        if(x==y) return;\n        if(sz[x]>sz[y])\n        {\n            p[y] = x;\n            sz[x]+=sz[y];\n            last[x]=Math.max(last[x],last[y]);\n        }\n        else\n        {\n            p[x]=y;sz[y]+=sz[x];\n            last[y]=Math.max(last[y],last[x]);\n        }\n        c--;\n        \n    }}\n\n    static long pow(long x, long y, long p)\n      {\n        long res = 1; // Initialize result\n     \n        x = x % p; // Update x if it is more than or\n        // equal to p\n     \n        if (x == 0)\n          return 0l; // In case x is divisible by p;\n     \n        while (y > 0)\n        {\n     \n          // If y is odd, multiply x with result\n          if ((y & 1) != 0)\n            res = (res * x) % p;\n     \n          // y must be even now\n          y = y >> 1; // y = y/2\n          x = (x * x) % p;\n        }\n        return res;\n      }\n      static long gcd(long a, long b)\n        {\n          if (b == 0)\n            return a;\n          return gcd(b, a % b); \n        }\n        static int gcd(int a, int b,int o)\n        {\n          if (b == 0)\n            return a;\n          return gcd(b, a % b,o); \n        }\n\nGeometric median\n\npublic static double F(double[] x,double[] w)\n    {\n        double d1,d2;\n        double S=0.00;\n        for(double dp : w) S += dp;\n        int k = 0;\n        double sum = S - w[0]; // sum is the total weight of all `x[i] > x[k]`\n\n        while(sum > S/2)\n        {\n            ++k;\n            sum -= w[k];\n        }\n        d1=x[k];\n        return d1;\n        k = w.length-1;\n       sum = S - w[k]; // sum is the total weight of all `x[i] > x[k]`\n\n        while(sum > S/2)\n        {\n            --k;\n            sum -= w[k];\n        }\n        d2=x[k];\n        return new double[]{d1,d2};\n    }\n*/","dfs and similar,graphs,shortest paths"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF585B extends PrintWriter {\n	CF585B() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF585B o = new CF585B(); o.main(); o.flush();\n	}\n\n	byte[][] cc;\n	int n;\n	boolean bad(int h, int j) {\n		return j < n && cc[h][j] != '.';\n	}\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			n = sc.nextInt();\n			int k = sc.nextInt();\n			cc = new byte[3][];\n			for (int h = 0; h < 3; h++)\n				cc[h] = sc.next().getBytes();\n			boolean[][] dp = new boolean[n][3];\n			for (int h = 0; h < 3; h++)\n				dp[0][h] = cc[h][0] == 's';\n			for (int i = 0; i < n - 1; i++)\n				for (int h = 0; h < 3; h++) {\n					if (!dp[i][h])\n						continue;\n					int j = 3 * i + 1;\n					if (bad(h, j))\n						continue;\n					for (int h_ = 0; h_ < 3; h_++)\n						if (Math.abs(h_ - h) <= 1 && !bad(h_, j) && !bad(h_, j + 1) && !bad(h_, j + 2))\n							dp[i + 1][h_] = true;\n				}\n			println(dp[n - 1][0] || dp[n - 1][1] || dp[n - 1][2] ? ""YES"" : ""NO"");\n		}\n	}\n}\n","dfs and similar,graphs,shortest paths"
"import java.util.Scanner;\n\npublic class Main {\n	private void solve() {\n		Scanner scanner = new Scanner(System.in);\n		int n = scanner.nextInt();\n		int m = scanner.nextInt();\n		char[] s = scanner.next().toCharArray();\n\n		long ret = (long) n * (m - 1); // one char different\n\n		for (int i = 0; i < n - 1; i++) {\n			if (s[i] != s[i + 1]) {\n				ret += n * (m - 1); // as prefix and suffix\n			}\n		}\n\n		for (int i = 0, j = 0; i < n - 1;) {\n			if (s[i] == s[i + 1]) {\n				i++;\n				continue;\n			}\n			j = Math.max(j, i + 1);\n			char c1 = s[i];\n			char c2 = s[i + 1];\n			while (j < n && s[j] == ((j - i & 1) == 0 ? c1 : c2)) {\n				j++;\n			}\n			ret -= j - i - 1;\n			i++;\n		}\n\n		System.out.println(ret);\n		scanner.close();\n	}\n\n	public static void main(String[] args) {\n		new Main().solve();\n	}\n}\n","dp,greedy"
"import java.util.Scanner;\n\npublic class Main {\n	private void solve() {\n		Scanner scanner = new Scanner(System.in);\n		int n = scanner.nextInt();\n		int m = scanner.nextInt();\n		String s = scanner.next();\n		int[] a = new int[n];\n		for (int i = 0; i < n; i++) {\n			a[i] = s.charAt(i) - 'a';\n		}\n\n		long ans = n * (m - 1);\n		int[] same = new int[n];\n		for (int i = 0; i < n - 1; i++) {\n			if (i > 0 && a[i + 1] == a[i - 1]) {\n				same[i + 1] = same[i - 1] + 1;\n			}\n			if (a[i] != a[i + 1]) {\n				ans += (m - 1) * n;\n				int x = same[i];\n				int y = same[i + 1];\n				int length = (1 + Math.min(x, y)) * 2;\n				if (y > x) {\n					length++;\n				}\n				ans -= length - 1;\n			}\n		}\n		System.out.println(ans);\n		scanner.close();\n	}\n\n	public static void main(String[] args) {\n		new Main().solve();\n	}\n}\n","dp,greedy"
"import java.io.*;\nimport java.util.Scanner;\n\n\npublic class Main1 {\n	static int hashi(int x, int y)\n	{\n		if (x == y) return -1;\n		if (x > y) {\n			int temp = x;\n			x = y;\n			y = temp;\n		}\n		return x * 1000 + y;\n	}\n	public static void main(String[] args) {\n		\n		Scanner sc = new Scanner(System.in);\n		int n, m;\n		int id[] = new int[100005];\n		\n		 long ans = 0;\n		String s;//[100005];\n		\n		n = sc.nextInt();\n		m = sc.nextInt();\n		String str = sc.next();\n		s = "" "" + str;\n		\n			ans = (m - 1) * n;\n			for (int i = 2; i <= n; i++)\n				if (s.charAt(i - 1) != s.charAt(i))\n					ans +=  (i - 1) * (m - 1);\n			\n			for (int i = 1; i <= n - 1; i++)\n				if (s.charAt(i) != s.charAt(i + 1))\n					ans +=(n - i) * (m - 1);\n			\n			for (int i = 1; i <= n - 1; i++) \n				id[i] = hashi(s.charAt(i), s.charAt(i + 1));\n			\n			for (int i = 1; i <= n - 1; i++){\n				if (id[i] != -1 && (i == 1 || id[i] != id[i - 1])){\n					for (int j = i; j <= n - 1 && id[j] == id[i]; j++){\n						ans -= j - i + 1;\n					}\n						\n				}\n					\n			}\n				\n			\n			System.out.println(ans);\n		}\n	}\n\n","dp,greedy"
"import java.io.*;\nimport java.util.Scanner;\n\n\npublic class Main1 {\n	static int hashi(int x, int y)\n	{\n		if (x == y) return -1;\n		if (x > y) {\n			int temp = x;\n			x = y;\n			y = temp;\n		}\n		return x * 1000 + y;\n	}\n	public static void main(String[] args) {\n		\n		Scanner sc = new Scanner(System.in);\n		int n, m;\n		int id[] = new int[100005];\n		\n		 long ans = 0;\n		String s;//[100005];\n		\n		n = sc.nextInt();\n		m = sc.nextInt();\n		String str = sc.next();\n		s = "" "" + str;\n		\n			ans = (m - 1) * n;\n			for (int i = 2; i <= n; i++)\n				if (s.charAt(i - 1) != s.charAt(i))\n					ans +=  (i - 1) * (m - 1);\n			\n			for (int i = 1; i <= n - 1; i++)\n				if (s.charAt(i) != s.charAt(i + 1))\n					ans +=(n - i) * (m - 1);\n			\n			for (int i = 1; i <= n - 1; i++) \n				id[i] = hashi(s.charAt(i), s.charAt(i + 1));\n			\n			for (int i = 1; i <= n - 1; i++)\n				if (id[i] != -1 && (i == 1 || id[i] != id[i - 1]))\n					for (int j = i; j <= n - 1 && id[j] == id[i]; j++)\n						ans -= j - i + 1;\n			\n			System.out.println(ans);\n		}\n	}\n\n","dp,greedy"
"//package Competitive_Programming;\n\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class ModuloSum_Codeforces {\n\n	public static void main(String[] args) throws Exception {\n		// TODO Auto-generated method stub\n		Scanner sc =new Scanner(System.in);\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		ArrayList<Integer> arr = new ArrayList<Integer>();\n		ArrayList<Integer> dpArr = new ArrayList<>(); \n		int[] dp = new int[m];\n		\n		Arrays.fill(dp, 0);\n		\n		for(int i = 0; i < n; i++)\n			arr.add(sc.nextInt());\n		\n		if(!arr.contains(0) && n>=m ) {\n			System.out.println(""YES"");\n			return;\n		}\n		else {\n			for(int i = 0; i < n; i++) {\n				int x = arr.get(i);\n				\n				for(int j = 1; j < m; j++) {\n					if(dp[j] == 1 )\n						dpArr.add((j+x)%m);\n				}\n				for(int y:dpArr)\n					dp[y] = 1;\n				dpArr.clear();\n\n				dp[x%m] = 1;\n\n				\n				if(dp[0] == 1) {\n					System.out.println(""YES"");\n					return;\n				}\n			}\n			System.out.println(""NO"");\n		}\n			\n	}\n}\n","combinatorics,data structures,dp,two pointers"
"import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Scanner;\n \npublic class CF577B {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int n = s.nextInt();\n        int m = s.nextInt();\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = s.nextInt();\n        }\n        if(n > m){\n            System.out.println(""YES"");\n        }else{\n            boolean[][] mat = new boolean[n+1][m];\n            for (int i = 0; i < n; i++) {\n                int val = arr[i];\n                mat[i+1][val % m] = true;\n                for (int j = 0; j < m; j++) {\n                    if(mat[i][j]){\n                        mat[i+1][j] = true;\n                        mat[i+1][(j+val) % m] = true;\n                    }\n                }\n            }\n            if(mat[n][0]){\n                System.out.println(""YES"");\n            }else{\n                System.out.println(""NO"");\n            }\n \n        }\n    }\n \n \n}","combinatorics,data structures,dp,two pointers"
"import java.util.Scanner;\n\npublic class E200 {\n    public static void main(String[] args) {\n        Scanner scn = new Scanner(System.in);\n        int n = scn.nextInt();\n        int m = scn.nextInt();\n        int[] arr = new int[n];\n\n        if (n > m) {\n            System.out.println(""YES"");\n            return;\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i] = scn.nextInt();\n        }\n\n        boolean[][] dp = new boolean[n][m];\n\n        for (int index = 0; index < n; index++) {\n            int val = (arr[index]) % m;\n            dp[0][val] = true;\n        }\n        for (int index = 0; index < n - 1; index++) {\n            for (int sum = 0; sum < m; sum++) {\n                if (dp[index][sum]) {\n                    dp[index + 1][sum] = true;\n                    dp[index + 1][(sum + arr[index]) % m] = true;\n                }\n            }\n        }\n\n        if (dp[n - 1][0]) {\n            System.out.println(""YES"");\n        } else {\n            System.out.println(""NO"");\n        }\n    }\n}\n","combinatorics,data structures,dp,two pointers"
"// package com.company.codeforces;\n\nimport java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner input=new Scanner(System.in);\n\n\n            int n=input.nextInt();\n            int m=input.nextInt();\n            int a[]=new int[n];\n            for (int i = 0; i <n ; i++) {\n                a[i]=input.nextInt();\n            }\n            if (n>=m){\n                System.out.println(""YES"");\n\n            }else {\n                boolean dp[][] = new boolean[n + 1][m];\n                for (int i = 0; i < n; i++) {\n                    int val = a[i];\n                    dp[i + 1][val % m] = true;\n                    for (int j = 0; j < m; j++) {\n                        if (dp[i][j]) {\n                            dp[i + 1][j] = true;\n                            dp[i + 1][(j + val) % m] = true;\n\n                        }\n\n                    }\n\n                }\n                if (dp[n][0]) {\n                    System.out.println(""YES"");\n                } else {\n                    System.out.println(""NO"");\n                }\n            }\n\n    }\n}\n","combinatorics,data structures,dp,two pointers"
"//package bubble8;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class A {\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n	\n	void solve()\n	{\n		long K = nl();\n		int P = ni();\n		int n = ni();\n		int[] s = na(n);\n		for(int i = 0;i < n;i++)s[i] %= P;\n		int m = ni();\n		long[][] irs = new long[m*2][];\n		for(int i = 0;i < m;i++){\n			long J = nl();\n			int v = ni();\n			irs[i*2] = new long[]{J, 1, v%P};\n			irs[i*2+1] = new long[]{J-1, 0, v%P};\n		}\n		if(K == 0){\n			out.println(0);\n			return;\n		}\n		if(K == 1){\n			out.println(1%P);\n			return;\n		}\n		Arrays.sort(irs, new Comparator<long[]>() {\n			public int compare(long[] a, long[] b) {\n				return Long.compare(a[0], b[0]);\n			}\n		});\n		m *= 2;\n		for(int i = 0;i < m;i++){\n			if(irs[i][0]/n > (K-1)/n){\n				m = i;\n				break;\n			}\n		}\n		\n		SegmentTreeArray st = new SegmentTreeArray(s, P);\n		long[] base = st.node[1];\n		int[][] B = new int[][]{{(int)base[0], (int)base[1]}, {(int)base[2], (int)base[3]}};\n		\n		long e = 0;\n		int[] v = {1%P, 0};\n		// 0 1 1 4 2 3\n		for(int i = 0;i < m;){\n			int j = i;\n			for(;j < m && irs[i][0]/n == irs[j][0]/n;)j++;\n			if(e < irs[i][0]/n){\n				v = pow(B, v, irs[i][0]/n-e, P);\n			}\n			for(int k = i;k < j;k++){\n				st.update((int)(irs[k][0]%n), (int)(irs[k][1]), (int)(irs[k][2]));\n			}\n			long[] ls = st.sum(0, (int)(Math.min(n, K-1-irs[i][0]/n*n)));\n			if(ls != null){\n				long nv0 = (v[0]*ls[0]+v[1]*ls[1])%P;\n				long nv1 = (v[0]*ls[2]+v[1]*ls[3])%P;\n				v[0] = (int)nv0; v[1] = (int)nv1;\n			}\n			\n			e = irs[i][0]/n+1;\n			for(int k = i;k < j;k++){\n				st.update((int)(irs[k][0]%n), (int)(irs[k][1]), s[(int)((irs[k][0]+1-irs[k][1])%n)]);\n			}\n			\n			i = j;\n		}\n		if(e < (K-1)/n){\n			v = pow(B, v, (K-1)/n-e, P);\n		}\n		if(e <= (K-1)/n){\n			long[] ls = st.sum(0, (int)((K-1)%n));\n			if(ls != null){\n				long nv0 = (v[0]*ls[0]+v[1]*ls[1])%P;\n				long nv1 = (v[0]*ls[2]+v[1]*ls[3])%P;\n				v[0] = (int)nv0; v[1] = (int)nv1;\n			}\n		}\n		\n		if(!(v[0] >= 0 && v[0] < P))throw new RuntimeException();\n		out.println(v[0]);\n	}\n	\n	// A^e*v\n	public static int[] pow(int[][] A, int[] v, long e, int mod)\n	{\n		int[][] MUL = A;\n		for(int i = 0;i < v.length;i++)v[i] %= mod;\n		for(;e > 0;e>>>=1) {\n			if((e&1)==1)v = mul(MUL, v, mod);\n			MUL = p2(MUL, mod);\n		}\n		return v;\n	}\n	\n	\n	// int matrix * int vector\n	public static int[] mul(int[][] A, int[] v, int mod)\n	{\n		int m = A.length;\n		int n = v.length;\n		int[] w = new int[m];\n		for(int i = 0;i < m;i++){\n			long sum = 0;\n			for(int k = 0;k < n;k++){\n				sum += (long)A[i][k] * v[k];\n				sum %= mod;\n			}\n			w[i] = (int)sum;\n		}\n		return w;\n	}\n	\n	// int matrix^2 (cannot ensure negative values)\n	public static int[][] p2(int[][] A, int mod)\n	{\n		int n = A.length;\n		int[][] C = new int[n][n];\n		for(int i = 0;i < n;i++){\n			for(int j = 0;j < n;j++){\n				long sum = 0;\n				for(int k = 0;k < n;k++){\n					sum += (long)A[i][k] * A[k][j];\n					sum %= mod;\n				}\n				C[i][j] = (int)sum;\n			}\n		}\n		return C;\n	}\n\n	\n	public static class SegmentTreeArray {\n		public int M, H, N;\n		public long[][] node;\n		public int P;\n		\n		public SegmentTreeArray(int[] a, int P)\n		{\n			this.P = P;\n			N = a.length;\n			M = Integer.highestOneBit(Math.max(N-1, 1))<<2;\n			H = M>>>1;\n			\n			node = new long[M][];\n			for(int i = 0;i < N;i++){\n				long[] item = new long[]{a[(i+1)%N], a[i], 1, 0};\n				node[H+i] = item;\n			}\n			for(int i = H-1;i >= 1;i--)propagate(i);\n		}\n		\n		private void propagate(int cur)\n		{\n			node[cur] = prop2(node[2*cur], node[2*cur+1], node[cur]);\n		}\n		\n		private long[] prop2(long[] L, long[] R, long[] C)\n		{\n			if(L != null && R != null){\n				if(C == null)C = new long[4];\n				// L[0] L[1]\n				// L[2] L[3]\n				// R[0] R[1]\n				// R[2] R[3]\n				C[0] = (R[0]*L[0] + R[1]*L[2])%P;\n				C[1] = (R[0]*L[1]+R[1]*L[3])%P;\n				C[2] = (R[2]*L[0]+R[3]*L[2])%P;\n				C[3] = (R[2]*L[1]+R[3]*L[3])%P;\n				\n				return C;\n			}else if(L != null){\n				return prop1(L, C);\n			}else if(R != null){\n				return prop1(R, C);\n			}else{\n				return null;\n			}\n		}\n		\n		private long[] prop1(long[] L, long[] C)\n		{\n			if(C == null)C = new long[4];\n			for(int i = 0;i < 4;i++)C[i] = L[i];\n			return C;\n		}\n		\n		public void update(int x, int e, int v) {\n			node[H+x][e] = v;\n			for(int i = H+x>>>1;i >= 1;i>>>=1)propagate(i);\n		}\n		\n		public long[] sum(int l, int r) {\n			return l >= r ? null : sum(l, r, 0, H, 1);\n		}\n		\n		protected long[] sum(int l, int r, int cl, int cr, int cur)\n		{\n			if(l <= cl && cr <= r){\n				return node[cur];\n			}else{\n				long[] L = null, R = null;\n				int mid = cl+cr>>>1;\n				if(cl < r && l < mid){\n					L = sum(l, r, cl, mid, 2*cur);\n				}\n				if(mid < r && l < cr){\n					R = sum(l, r, mid, cr, 2*cur+1);\n				}\n				return prop2(L, R, null);\n			}\n		}\n	}	\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new A().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	private int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n	\n	private char[][] nm(int n, int m)\n	{\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n	\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n	\n	private int ni()\n	{\n		int num = 0, b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","data structures,math,matrices"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\nimport java.util.*;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\npublic class A {\n \n	static final int mod = 1000000007;\n	static final long temp = 998244353;\n	static final long MOD = 1000000007;\n	static final long M = (long)1e9+7;\n \n	\n	static class Pair implements Comparable<Pair>\n	{\n		int first, second;\n		public Pair(int aa, int bb)\n		{\n			first = aa; second = bb;\n		}\n		public int compareTo(Pair p)\n		{\n			if(first == p.first) return (int)(second - p.second);\n			return (int)(first - p.first);\n		}\n	}\n	\n	/*\n	 * IO FOR 2D GRID IN JAVA\n	 * 	char[][] grid = new char[n][m];\n			for(int i = 0;i<n;i++)\n			{\n				char[] s = sc.next().toCharArray();\n				for(int j = 0;j<m;j++)\n				{\n					grid[i][j] = s[j];\n				}\n			}\n	 * */\n	\n	static class Reader {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n		String next() {\n			while (!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		\n		int[] readArray(int n) throws IOException {\n			int[] a=new int[n];\n			for (int i=0; i<n; i++) a[i]=nextInt();\n			return a;\n		}\n		\n		long[] longReadArray(int n) throws IOException {\n			long[] a=new long[n];\n			for (int i=0; i<n; i++) a[i]=nextLong();\n			return a;\n		}\n		\n		\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n	}\n	\n \n		public static boolean isPrime(int n) \n		{\n			if(n == 1)\n			{\n				return false;\n			}\n			for(int i = 2;i*i<=n;i++)\n			{\n				if(n%i == 0)\n				{\n					return false;\n				}\n			}\n			return true;\n	}\n	\n	public static List<Integer> SieveList(int n)\n	{\n		boolean prime[] = new boolean[n+1];\n		Arrays.fill(prime, true);\n		\n		List<Integer> l = new ArrayList<>();\n		for (int p=2; p*p<=n; p++) \n		{ \n			if (prime[p] == true) \n			{ 	\n			    for(int i=p*p; i<=n; i += p) \n				{\n				    prime[i] = false; \n				}	\n			} \n		} \n \n		for (int p=2; p<=n; p++) \n		{\n		    if (prime[p] == true)\n		    {\n		       l.add(p); \n		    }\n		}\n		\n		return l;\n	}\n	\n	\n	public static int gcd(int a, int b)\n	{\n		if(b == 0)\n		 return a;\n		\n		else\n		return gcd(b,a%b);\n	} \n \n		public static int lcm(int a, int b)\n	    {\n	        return (a / gcd(a, b)) * b;\n	    }\n	\n	public static long LongGCD(long a, long b)\n	{\n		if(b == 0)\n			 return a;\n			\n			else\n			return LongGCD(b,a%b);\n	}\n	\n		public static long LongLCM(long a, long b)\n	    {\n	        return (a / LongGCD(a, b)) * b;\n	    }\n	\n		public static int phi(int n)  //euler totient function\n	    { \n	        int result = 1; \n	        for (int i = 2; i < n; i++) \n	            if (gcd(i, n) == 1) \n	                result++; \n	        return result; \n	    }\n	\n	public static long fastPow(long x, long n) //include mod at each step if asked and in args of fn too\n	{\n		if(n == 0)\n			return 1;\n		else if(n%2 == 0)\n			return fastPow(x*x,n/2);\n		else\n			return x*fastPow(x*x,(n-1)/2);\n	}\n	\n	\n	   public static long modPow(long x, long y, long p)\n	    {\n	        long res = 1;\n	        x = x % p;\n	 \n	        while (y > 0) {\n	            if (y % 2 == 1)\n	                res = (res * x) % p;\n	 \n	            y = y >> 1; \n	            x = (x * x) % p;\n	        }\n	        return res;\n	    }\n	   \n	   static long modInverse(long n, long p)\n	    {\n	        return modPow(n, p - 2, p);\n	    }\n	 \n	    // Returns nCr % p using Fermat's little theorem.\n	    \n	    public static long nCrModP(long n, long r,long p)\n	    {\n	          if (n<r) \n	              return 0;\n	          \n	        if (r == 0)\n	            return 1;\n	 \n	        long[] fac = new long[(int)(n) + 1];\n	        fac[0] = 1;\n	 \n	        for (int i = 1; i <= n; i++)\n	            fac[i] = fac[i - 1] * i % p;\n	 \n	        return (fac[(int)(n)] * modInverse(fac[(int)(r)], p)\n	                % p * modInverse(fac[(int)(n - r)], p)\n	                % p)\n	            % p;\n	    }\n	    \n	    public static long nCr(long n, long r)\n	    {\n	    	long ans = 1;\n	    	for(long i = 1,j = n;i<=r;i++,j--)\n	    	{\n	    		ans = ans * j / i;\n	    	}\n	    	return ans;\n	    }\n \n		public static void Sort(int[] a) {\n			List<Integer> l=new ArrayList<>();\n			for (int i : a) l.add(i);\n			Collections.sort(l);\n//			Collections.reverse(l);  //Use to Sort decreasingly \n			for (int i=0; i<a.length; i++) a[i]=l.get(i);\n		}\n		\n		public static void ssort(char[] a)\n		{\n			List<Character> l = new ArrayList<>();\n			for (char i : a) l.add(i);\n			Collections.sort(l);\n			for (int i=0; i<a.length; i++) a[i]=l.get(i);\n		}\n		\n		\n		//Modular Operations for Addition and Multiplication. \n		\n		   public static long perfomMod(long x)\n		   {\n		        return ((x%M + M)%M);\n		    }\n		   public static long addMod(long a, long  b)\n		   {\n		        return perfomMod(perfomMod(a)+perfomMod(b));\n		    }\n		   public static long mulMod(long  a, long b)\n		   {\n		        return perfomMod(perfomMod(a)*perfomMod(b));\n		   }\n		\n		   public static int LowerBound(int a[], int x) \n		   {\n				  int l=-1,r=a.length;\n				  while(l+1<r) {\n				    int m=(l+r)>>>1;\n				    if(a[m]>=x) r=m;\n				    else l=m;\n				  }\n				  return r;\n			}\n		\n		   \n			public static int UpperBound(int a[], int x) \n			{\n			    int l=-1;\n			    int r=a.length;\n			    while(l+1<r) {\n			       int m=(l+r)>>>1;\n			       if(a[m]<=x) l=m;\n			       else r=m;\n			    }\n			    return l+1;\n			}\n	\n		public static long fn(int a, int b, int c, int ans)\n		{\n			if(b + c > a) return 0;\n			ans = min((a - b - c),ans);\n			return 1L * (ans + 2)*(ans + 1)/2;\n		}\n	\n	public static void main(String[] args) throws IOException \n	{\n		Reader sc = new Reader();\n		PrintWriter fout = new PrintWriter(System.out);\n		\n			int a = sc.nextInt(), b = sc.nextInt(), c = sc.nextInt(), n = sc.nextInt();\n			long res = 0;\n			for(int i = 0;i<n+1;i++)\n			{\n				res += (1L * (i + 1) * (i + 2))/2;\n				res -= fn(a + i, b, c, (n - i));\n				res -= fn(b + i,a,c,(n - i));\n				res -= fn(c + i,a,b,(n - i));\n			}\n			System.out.println(res);\n		\n		\n		fout.close();\n	}\n}","combinatorics,implementation,math"
"import java.util.*;\n\npublic class A {\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    long[] a = new long[3];\n    a[0] = sc.nextLong();\n    a[1] = sc.nextLong();\n    a[2] = sc.nextLong();\n    long l = sc.nextLong();\n    \n    long total = (l+1)*(l+2)*(l+3)/6;\n    \n    for(int i = 0; i < 3; i++) {\n      for(long la = 0L; la <= l; la++) {\n        long x = Math.min(a[i] - a[(i+1)%3] - a[(i+2)%3] + la, l - la);\n        if(x >= 0) {\n          total -= (x+1)*(x+2)/2;\n        }\n      }\n    }\n    \n    System.out.println("""" + total);\n  }\n\n}\n","combinatorics,implementation,math"
"//package labels.math.math_02_combinatorics.p_01_cf_571_A;\n\nimport java.util.Scanner;\n\n/**\n *\n * */\npublic class Main {\n	static long wrong(long a, long b, long c, long l) {\n		long ret = 0;\n		for(long i = 0; i <= l; i++) {\n			long x = Math.min(l - i, c + i - a - b);\n			if(x >= 0) {\n				ret += (x + 2) * (x + 1) / 2;\n			}\n		}\n\n		return ret;\n	}\n\n	public static void main(String[] args){\n		Scanner sc = new Scanner(System.in);\n		int a = sc.nextInt(), b = sc.nextInt(), c = sc.nextInt();\n		int l = sc.nextInt();\n\n		long ans = 0;\n		for(long i = 0; i <= l; i++) {\n			ans += (i + 2) * (i + 1) / 2;\n		}\n		ans = ans - wrong(a, b, c, l) - wrong(a, c, b, l) - wrong(b, c, a, l);\n		System.out.println(ans);\n	}\n}\n","combinatorics,implementation,math"
"import java.util.*;\nimport java.io.*;\npublic class Main {\nstatic long calFunc(int a,int b,int c,int l){\n	long ret = 0;\n	for(int i = 0;i <= l;i++){\n		int t = Math.min(l - i,a - b - c + i);\n		if(t < 0)continue;\n		ret += (t + 1)*1L*(t + 2)/2;\n	}\n	return ret;\n}	\npublic static void main(String [] args)throws Exception{\n	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	StringTokenizer st = new StringTokenizer(br.readLine());\n	int a = Integer.parseInt(st.nextToken());\n	int b = Integer.parseInt(st.nextToken());\n	int c = Integer.parseInt(st.nextToken());\n	int l = Integer.parseInt(st.nextToken());\n	\n	long tot = (l + 1)*1L*(l + 2)*(l + 3)/6;\n	System.out.println(tot - calFunc(a,b,c,l) - calFunc(b,a,c,l) - calFunc(c,a,b,l));	\n}\n}","combinatorics,implementation,math"
"import java.util.Scanner;\n\npublic class PlayGround {\n    public static void main(String... args) {\n        Scanner in = new Scanner(System.in);\n        int a1 = in.nextInt(), b1 = in.nextInt(), a2 = in.nextInt(),\n                b2 = in.nextInt(), a3 = in.nextInt(), b3 = in.nextInt();\n        if (check(a2 + a3, Math.max(b2, b3), a1, b1) || (check(a2 + b3, Math.max(b2, a3), a1, b1))\n                || (check(b2 + a3, Math.max(a2, b3), a1, b1))\n                || (check(b2 + b3, Math.max(a2, a3), a1, b1)))\n            System.out.println(""YES"");\n        else\n            System.out.println(""NO"");\n    }\n\n    private static boolean check(int a, int b, int c, int d) {\n        if (a <= c && b <= d)\n            return true;\n        if (a <= d && b <= c)\n            return true;\n        return false;\n    }\n}\n\n","constructive algorithms,implementation"
"import java.util.Scanner;\n\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n\n		int a1 = sc.nextInt();\n		int b1 = sc.nextInt();\n		int a2 = sc.nextInt();\n		int b2 = sc.nextInt();\n		int a3 = sc.nextInt();\n		int b3 = sc.nextInt();\n		System.out.println(solve(a1, b1, a2, b2, a3, b3) ? ""YES"" : ""NO"");\n\n		sc.close();\n	}\n\n	static boolean solve(int a1, int b1, int a2, int b2, int a3, int b3) {\n		return check(a1, b1, a2, b2, a3, b3) || check(a1, b1, a2, b2, b3, a3) || check(a1, b1, b2, a2, a3, b3)\n				|| check(a1, b1, b2, a2, b3, a3) || check(b1, a1, a2, b2, a3, b3) || check(b1, a1, a2, b2, b3, a3)\n				|| check(b1, a1, b2, a2, a3, b3) || check(b1, a1, b2, a2, b3, a3);\n	}\n\n	static boolean check(int sumLimit, int maxLimit, int toSum1, int toMax1, int toSum2, int toMax2) {\n		return toSum1 + toSum2 <= sumLimit && Math.max(toMax1, toMax2) <= maxLimit;\n	}\n}","constructive algorithms,implementation"
"/******************************************************************************\n\nWelcome to GDB Online.\nGDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,\nC#, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.\nCode, Compile, Run and Debug online from anywhere in world.\n\n*******************************************************************************/\nimport java.util.*;\n\npublic class Main\n{\n	\n	    \n	\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		\n		int a= scan.nextInt();\n		int b= scan.nextInt();\n		int a1= scan.nextInt();\n		int b1= scan.nextInt();\n		int a2= scan.nextInt();\n		int b2= scan.nextInt();\n		\n		// case 1\n        if((a1+a2)<=a && Math.max(b1,b2)<=b)\n        System.out.println(""YES"");\n        else if((a1+a2)<=b && Math.max(b1,b2)<=a)\n        System.out.println(""YES"");\n        \n        // case 2\n        else if((a1+b2)<=a && Math.max(b1,a2)<=b)\n        System.out.println(""YES"");\n        else if((a1+b2)<=b && Math.max(b1,a2)<=a)\n        System.out.println(""YES"");\n        \n        // case 3\n        else if((b1+a2)<=a && Math.max(a1,b2)<=b)\n        System.out.println(""YES"");\n        else if((b1+a2)<=b && Math.max(a1,b2)<=a)\n        System.out.println(""YES"");\n        \n        // case 4\n        else if((b1+b2)<=a && Math.max(a1,a2)<=b)\n        System.out.println(""YES"");\n        else if((b1+b2)<=b && Math.max(a1,a2)<=a)\n        System.out.println(""YES"");\n        else\n        System.out.println(""NO"");\n		\n	}\n}\n\n						   	 		  	 		    	 	  			","constructive algorithms,implementation"
"/******************************************************************************\n\nWelcome to GDB Online.\nGDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,\nC#, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.\nCode, Compile, Run and Debug online from anywhere in world.\n\n*******************************************************************************/\nimport java.util.*;\n\npublic class Codeforces\n{\n\n	\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		\n		int a= scan.nextInt();\n		int b= scan.nextInt();\n		int a1= scan.nextInt();\n		int b1= scan.nextInt();\n		int a2= scan.nextInt();\n		int b2= scan.nextInt();\n		\n		// case 1\n        if((a1+a2)<=a && Math.max(b1,b2)<=b)\n        System.out.println(""YES"");\n        else if((a1+a2)<=b && Math.max(b1,b2)<=a)\n        System.out.println(""YES"");\n        \n        // case 2\n        else if((a1+b2)<=a && Math.max(b1,a2)<=b)\n        System.out.println(""YES"");\n        else if((a1+b2)<=b && Math.max(b1,a2)<=a)\n        System.out.println(""YES"");\n        \n        // case 3\n        else if((b1+a2)<=a && Math.max(a1,b2)<=b)\n        System.out.println(""YES"");\n        else if((b1+a2)<=b && Math.max(a1,b2)<=a)\n        System.out.println(""YES"");\n        \n        // case 4\n        else if((b1+b2)<=a && Math.max(a1,a2)<=b)\n        System.out.println(""YES"");\n        else if((b1+b2)<=b && Math.max(a1,a2)<=a)\n        System.out.println(""YES"");\n        else\n        System.out.println(""NO"");\n		\n	}\n}\n","constructive algorithms,implementation"
"import java.util.*;\n\n\npublic class Solve {\n    private static Scanner sc;\n	public static void main(String[] args) {\n    	long h,q,left,right,fl=0;\n    	sc = new Scanner(System.in);\n    	h=sc.nextLong();\n    	q=sc.nextLong();\n    	left=(long) Math.pow(2, h-1);\n    	right=(long )Math.pow(2, h)-1;\n    	ArrayList<pair> s=new ArrayList<pair>();\n    	for(int j=0;j<q;j++){\n    		long i=sc.nextLong(),l=sc.nextLong(),r=sc.nextLong(),a=sc.nextLong();\n    		while(i<h){\n    			l=l*2;\n    			r=r*2+1;\n    			i++;\n    		}\n    		if(a==1){\n    			if(l>right || r<left){\n    				fl=1;\n    			}else{\n    				left=Math.max(left, l);\n    				right=Math.min(right, r);\n    			}\n    		}else{\n    			s.add(new pair(l,r));\n    		}\n    	}\n    	Collections.sort(s);\n       	for(int i=0;i<s.size();i++){\n       		\n       		if(s.get(i).l<=left && s.get(i).r<=right && s.get(i).r>=left){\n    			left=Math.max(s.get(i).r+1,left);\n    			//s.remove(i);\n    		}\n    	}\n       	for(int i=0;i<s.size();i++){\n       		s.get(i).flipFlag();\n       	}\n       	Collections.sort(s);\n       	for(int i=0;i<s.size();i++){\n       		if(s.get(i).l>=left && s.get(i).r>=right && s.get(i).l<=right){\n    			right=Math.min(right,s.get(i).l-1);\n    			//s.remove(i);\n    		}\n    	}\n       	if(right<left){\n       		fl=1;\n       	}else{\n       		for(int i=0;i<s.size();i++){\n        		if(s.get(i).l<=left && s.get(i).r>=right){\n        			fl=1;\n        			s.remove(i);\n        		}\n        	}\n       	}\n       	if(fl==1){\n       		System.out.println(""Game cheated!"");\n       	}else if(left==right){\n       		System.out.println(left+"""");\n       	}else System.out.println(""Data not sufficient!"");\n    }\n}\nclass pair implements Comparable<pair>{\n	long l,r;\n	boolean fl=true;\n	public void flipFlag(){\n		fl=!fl;\n	}\n	public pair(long x,long y){\n		l=x;\n		r=y;\n	}\n	\n	@Override\n	public int compareTo(pair o) {\n		if(fl){\n			if(this.l<o.l) return -1;\n			else if(this.l==o.l) return 0;\n			return 1;\n		}else{\n			if(this.r>o.r) return -1;\n			else if(this.r==o.r) return 0;\n			return 1;\n		}\n	}\n}","data structures,implementation,sortings"
"import java.io.*;\nimport java.util.*;\npublic final class guess_out_2\n{\n    static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n	static FastScanner sc=new FastScanner(br);\n    static PrintWriter out=new PrintWriter(System.out);\n	static Random rnd=new Random();\n	static List<Pair> list=new ArrayList<Pair>();\n	\n    public static void main(String args[]) throws Exception\n    {\n		long n=sc.nextInt(),q=sc.nextInt();list.add(new Pair(1L<<n,1L<<n));\n		while(q>0)\n		{\n			long idx=sc.nextLong(),l=sc.nextLong(),r=sc.nextLong();int ans=sc.nextInt();\n			if(ans==0)\n			{\n				long idx1=idx,idx2=idx;\n				while(idx1!=n)\n				{\n					l*=2L;idx1++;\n				}\n				while(idx2!=n)\n				{\n					r=(r*2L)+1;idx2++;\n				}\n				list.add(new Pair(l,r));\n			}\n			else\n			{\n				long idx1=idx,idx2=idx;\n				if(l!=(1L<<(idx-1L)))\n				{\n					while(idx1!=n)\n					{\n						l=(l*2L);idx1++;\n					}\n					list.add(new Pair(1L<<(n-1),l-1));\n				}\n				if(r!=(1L<<idx)-1)\n				{\n					while(idx2!=n)\n					{\n						r=(r*2L)+1;idx2++;\n					}\n					list.add(new Pair(r+1,(1L<<n)-1));\n				}\n			}\n			q--;\n		}\n		Collections.sort(list);boolean get=false,ans=false;long now=(1L<<(n-1));long res=-1;\n		/*\n		for(Pair p:list)\n		{\n			out.println(p.l+"" ""+p.r);\n		}\n		*/\n		for(int i=0;i<list.size();i++)\n		{\n			if(list.get(i).l>now)\n			{\n				long size=(list.get(i).l-now);\n				if(size>1)\n				{\n					get=true;ans=false;break;\n				}\n				else if(get)\n				{\n					ans=false;break;\n				}\n				else\n				{\n					get=true;ans=true;res=now;now=list.get(i).r+1;\n				}\n			}\n			else\n			{\n				now=Math.max(now,list.get(i).r+1);\n			}\n		}\n		if(!get)\n		{\n			out.println(""Game cheated!"");\n		}\n		else if(get && !ans)\n		{\n			out.println(""Data not sufficient!"");\n		}\n		else\n		{\n			out.println(res);\n		}\n		out.close();\n    }\n}\nclass Pair implements Comparable<Pair>\n{\n	long l,r;\n	public Pair(long l,long r)\n	{\n		this.l=l;this.r=r;\n	}\n	public int compareTo(Pair x)\n	{\n		return Long.compare(this.l,x.l);\n	}\n}\nclass FastScanner\n{\n    BufferedReader in;\n    StringTokenizer st;\n\n    public FastScanner(BufferedReader in) {\n        this.in = in;\n    }\n	\n    public String nextToken() throws Exception {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n	\n	public String next() throws Exception {\n		return nextToken().toString();\n	}\n	\n    public int nextInt() throws Exception {\n        return Integer.parseInt(nextToken());\n    }\n\n    public long nextLong() throws Exception {\n        return Long.parseLong(nextToken());\n    }\n\n    public double nextDouble() throws Exception {\n        return Double.parseDouble(nextToken());\n    }\n}","data structures,implementation,sortings"
"import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\npublic class D {\n\n    private static class Range implements Comparable<Range> {\n        private final long left;\n        private final long right;\n        private final boolean containsExit;\n\n        public Range(long left, long right, boolean containsExit) {\n            this.left = left;\n            this.right = right;\n            this.containsExit = containsExit;\n        }\n\n        public long getLeft() {\n            return left;\n        }\n\n        public long getRight() {\n            return right;\n        }\n\n        public boolean isContainsExit() {\n            return containsExit;\n        }\n\n        @Override\n        public int compareTo(Range o) {\n            return Long.compare(getLeft(), o.getLeft());\n        }\n    }\n\n    private static String findExit(List<Range> ranges, int height) {\n        List<Range> positiveAnswers = ranges.stream().filter(Range::isContainsExit).collect(Collectors.toList());Collectors.toList();\n        List<Range> negativeAnswers = ranges.stream().filter(r -> !r.isContainsExit()).sorted().collect(Collectors.toList());Collectors.toList();\n\n        long left = 1L << (height - 1);\n        long right = 2L * left;\n        for (Range range : positiveAnswers) {\n            if (range.getRight() <= left || right <= range.getLeft()) {\n                return ""Game cheated!"";\n            }\n            left = Math.max(range.getLeft(), left);\n            right = Math.min(range.getRight(), right);\n        }\n\n        long rightBound = left;\n        long lastSkipStart = 0L;\n        long skipCount = 0L;\n        for (Range range : negativeAnswers) {\n            if (range.getRight() <= rightBound) {\n                continue;\n            }\n            if (range.getLeft() >= right) {\n                continue;\n            }\n            if (range.getLeft() > rightBound) {\n                skipCount += range.getLeft() - rightBound;\n                lastSkipStart = rightBound;\n            }\n            rightBound = Math.max(range.getRight(), rightBound);\n        }\n\n        if (skipCount == 0L && right - rightBound == 1L) {\n            return String.valueOf(rightBound);\n        }\n\n        if (skipCount == 1L && rightBound >= right) {\n            return String.valueOf(lastSkipStart);\n        }\n\n        if (skipCount == 0L && rightBound >= right) {\n            return ""Game cheated!"";\n        }\n        return ""Data not sufficient!"";\n    }\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int h = s.nextInt();\n        int q = s.nextInt();\n        List<Range> ranges = new ArrayList<>();\n        for (int i = 0; i < q; i++) {\n            int level = s.nextInt();\n            long left = s.nextLong();\n            long right = s.nextLong();\n            int answer = s.nextInt();\n\n            long shift = 1L <<  (h - level);\n            long leftLeaf = left * shift;\n            long rightLeaf = right * shift + shift;\n\n            ranges.add(new Range(leftLeaf, rightLeaf, answer == 1));\n        }\n        System.out.println(findExit(ranges, h));\n    }\n}","data structures,implementation,sortings"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\npublic class P558E {\n\n    private static final long[] P2 = new long[51];\n    static {\n        P2[0] = 1;\n        for (int i = 1; i<=50; i++) {\n            P2[i] = P2[i-1] * 2;\n        }\n    }\n\n    private final int h;\n    private final SortedMap<Long, Long> intervals = new TreeMap<>();\n\n    public P558E(int h) {\n        this.h = h;\n        intervals.put(P2[h-1], P2[h]);\n        // logState();\n    }\n\n    public void process(int i, long li, long ri, boolean a) {\n        if (intervals.isEmpty()) {\n            return;\n        }\n        final long l = li * P2[h-i];\n        final long r = (ri + 1) * P2[h-i];\n        // System.err.println((a ? ""+"" : ""-"") + "" ["" + l + "", "" + r + "")"");\n        if (a) {\n            final SortedMap<Long, Long> i1 = intervals.headMap(l);\n            if (!i1.isEmpty()) {\n                final long r2 = i1.get(i1.lastKey());\n                i1.clear();\n                if (r2 > l) {\n                    intervals.put(l, r2);\n                }\n            }\n            final SortedMap<Long, Long> i2 = intervals.subMap(l, r);\n            if (!i2.isEmpty()) {\n                final long l2 = i2.lastKey();\n                i2.put(l2, Math.min(i2.get(l2), r));\n            }\n            intervals.tailMap(r).clear();\n        } else {\n            final SortedMap<Long, Long> i1 = intervals.headMap(l);\n            if (!i1.isEmpty()) {\n                final long l2 = i1.lastKey();\n                final long r2 = i1.get(l2);\n                i1.put(l2, Math.min(r2, l));\n                if (r2 > r) {\n                    intervals.put(r, r2);\n                }\n            }\n            final SortedMap<Long, Long> i2 = intervals.subMap(l, r);\n            if (!i2.isEmpty()) {\n                final long r2 = i2.get(i2.lastKey());\n                i2.clear();\n                if (r2 > r) {\n                    intervals.put(r, r2);\n                }\n            }\n        }\n\n        // logState();\n    }\n\n    private void logState() {\n        if (intervals.isEmpty()) {\n            System.err.println(""--"");\n        } else {\n            for (java.util.Map.Entry<Long, Long> e : intervals.entrySet()) {\n                System.err.print(""["" + e.getKey() + "" "" + e.getValue() + "")"" + "" "");\n            }\n            System.err.println();\n        }\n    }\n\n    public long getResult() throws P558EException {\n        if (intervals.isEmpty()) {\n            throw new P558EException(""Game cheated!"");\n        }\n        if (intervals.size() == 1) {\n            final long l = intervals.firstKey();\n            final long r = intervals.get(l);\n            if (r == l+1) {\n                return l;\n            }\n        }\n        throw new P558EException(""Data not sufficient!"");\n    }\n\n    public static class P558EException extends Exception {\n        public P558EException(String message) {\n            super(message);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        final BufferedReader in = new BufferedReader(\n            new InputStreamReader(System.in));\n\n        String[] ss = in.readLine().split("" "", 2);\n        final int h = Integer.parseInt(ss[0]);\n        final int q = Integer.parseInt(ss[1]);\n        final P558E p558e = new P558E(h);\n\n        for (int k = 0; k < q; k++) {\n            ss = in.readLine().split("" "", 4);\n            final int i = Integer.parseInt(ss[0]);\n            final long li = Long.parseLong(ss[1]);\n            final long ri = Long.parseLong(ss[2]);\n            final boolean a = (Integer.parseInt(ss[3]) != 0);\n            p558e.process(i, li, ri, a);\n        }\n\n        try {\n            System.out.println(p558e.getResult());\n        } catch (P558EException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n","data structures,implementation,sortings"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF550E extends PrintWriter {\n	CF550E() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF550E o = new CF550E(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int[] aa = new int[n];\n		for (int i = 0; i < n; i++)\n			aa[i] = sc.nextInt();\n		if (aa[n - 1] == 1) {\n			println(""NO"");\n			return;\n		}\n		if (n >= 2 && aa[n - 2] == 0 && aa[n - 1] == 0) {\n			boolean one = true;\n			for (int i = 0; i < n - 2; i++)\n				if (aa[i] != 1) {\n					one = false;\n					break;\n				}\n			if (one) {\n				println(""NO"");\n				return;\n			}\n		}\n		println(""YES"");\n		if (n == 1) {\n			println(""0"");\n			return;\n		}\n		for (int i = 0; i < n - 2; i++)\n			print(""("" + aa[i] + ""->"");\n		print(aa[n - 2]);\n		for (int i = 0; i < n - 2; i++)\n			print("")"");\n		println(""->"" + aa[n - 1]);\n	}\n}\n","constructive algorithms,greedy,implementation,math"
"import java.io.*;\nimport java.util.*;\n\npublic class A {\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int n = in.nextInt();\n		\n		int[] a = new int[n];\n		for(int i=0; i<n; i++) {\n			a[i] = in.nextInt();\n		}\n		\n		Solver A = new Solver(a, n);\n		A.solve();\n		//System.out.println(A.solve());\n	}\n\n}\n\nclass Solver {\n	int[] a;\n	int n;\n	int t;\n	public Solver(int[] a, int n) {\n		this.a = a;\n		this.n = n;\n		for(int i=0; i<n; i++) {\n			if(a[i] == 0) t++;\n		}\n	}\n	\n	public void solve() {\n		if(n == 1) {\n			if(a[0] == 0) {\n				System.out.println(""YES\n0"");\n				return;\n			}\n			else {\n				System.out.println(""NO"");\n				return;\n			}\n		}\n		\n		if(a[n-1] == 1 || a[n-2] == 0 && t == 2) {\n			System.out.println(""NO"");\n			return;\n		}\n		\n		System.out.println(""YES"");\n		fi(0, n - 2, """");\n		//res += """" + fi(0, n - 2, """");\n		System.out.println(""->0"");\n	}\n	\n	private void fi(int cur, int nn, String aa) {\n		if(nn == 0) {\n			System.out.print("""" + a[cur]);\n			//String aaa = """" + a[cur];\n			//return aaa;\n		}\n		else {\n			System.out.print(""("" + a[cur] + ""->"");\n			fi(cur + 1, nn - 1, aa);\n			System.out.print("")"");\n			//aa += ""("";\n			//aa += a[cur];\n			//aa += ""->"";\n			//aa += fi(cur + 1, nn - 1, aa);\n			//aa += "")"";\n			//return aa;\n		}\n	}\n}\n","constructive algorithms,greedy,implementation,math"
"import java.util.*;\n\npublic class CF550E {\n    private static String range(int[] a, int n, int m) {\n        StringBuilder s = new StringBuilder();\n        for (int i = n; i < m; ++i)\n            s.append(a[i]).append(""->"");\n        return s.toString();\n    }\n    public static void main (String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; ++i)\n            a[i] = scan.nextInt();\n        if (a[n-1] == 1) // ... -> 1 == 1\n            System.out.println(""NO"");\n        else if (n == 1) // 0\n            System.out.printf(""YES\n0\n"");\n        else if (a[n-2] == 1) // ... -> 1 -> 0 == 0\n            System.out.printf(""YES\n%s0\n"", range(a, 0, n-1));\n        else if (n == 2) // 0 -> 0 == 1\n            System.out.println(""NO"");\n        else if (a[n-3] == 0) // ... -> (0 -> 0) -> 0 == 0\n            System.out.printf(""YES\n%s(0->0)->0\n"", range(a, 0, n-3));\n        else {\n            int i;\n            for (i = n-4; i >= 0 && a[i] != 0; --i) ;\n            if (i >= 0) // ... -> (0->(1...1->0)) -> 0 == 0\n                System.out.printf(""YES\n%s(0->(%s0))->0\n"",\n                    range(a, 0, i), range(a, i+1, n-2));\n            else // 1...1 -> 0 -> 0 == 1\n                System.out.println(""NO"");\n        }\n    }\n}","constructive algorithms,greedy,implementation,math"
"import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n\npublic class A {\n	\n	public static void main(String args[]) throws IOException{\n		Scanner sc=new Scanner(System.in);\n		PrintWriter wr=new PrintWriter(System.out);\n		int n=sc.nextInt();\n		int arr[]=new int [n];\n		int zero=0;\n		for(int i=0;i<n;i++) {\n			arr[i]=sc.nextInt();\n			if(arr[i]==0)zero++;\n		}\n		if(n==1) {\n			if(arr[0]==0)System.out.println(""YES\n0"");\n			else System.out.println(""NO"");\n			return;\n		}\n		if(n==2) {\n			if(arr[0]==1 && arr[1]==0)System.out.println(""YES\n1->0"");\n			else System.out.println(""NO"");\n			return;\n		}\n		\n		\n		int c=0;\n		for(int i=n-1;i>=0;i--)\n			if(arr[i]==0)c++;\n			else break;\n		if(c==0 ||(c==2 && zero==2)) {\n			System.out.println(""NO"");\n			return;\n		}\n		StringBuilder sb=new StringBuilder();\n		if(c==2) {\n			int i=0;\n			for( i=n-3;i>=0;i--) {\n				if(arr[i]==0)break;\n			}\n			for(int j=0;j<i;j++) {\n				sb.append(arr[j]+""->"");\n			}\n			sb.append(""(0->("");\n			for(int j=i+1;j<n-2;j++) {\n				sb.append(arr[j]+""->"");\n			}\n			sb.append(""0))->0"");\n			System.out.println(""YES"");\n			System.out.println(sb);\n			return;\n		}\n		\n		for(int i=0;i<n-3;i++) {\n			sb.append(arr[i]+""->"");\n		}\n		sb.append(""(""+arr[n-3]+""->""+arr[n-2]+"")->""+arr[n-1]);\n		System.out.println(""YES"");\n		System.out.println(sb);\n	}\n	\n}\n","constructive algorithms,greedy,implementation,math"
"import java.util.Scanner;\n\npublic class _0929EquidistantString {\n\n	public static void main(String[] args) {\n		\n		Scanner sc = new Scanner(System.in);\n		char[]  s=sc.nextLine().toCharArray();\n		char[] t=sc.nextLine().toCharArray();\n		int count=0;\n		boolean takeS=true;\n		String ans="""";\n		for(int i=0;i<s.length;i++) {\n			if(s[i]==t[i]) {\n				continue;\n			}\n			else {\n				if(!takeS) {\n					s[i]=t[i];\n				}\n				takeS=!takeS;\n				count++;\n			}\n		}\n		if(count%2!=0) {\n			System.out.println(""impossible"");\n		}\n		else {\n			System.out.println(new String(s));\n		}\n	}\n\n}\n",greedy
"import java.util.Scanner;\n \npublic class _0929EquidistantString {\n \n	public static void main(String[] args) {\n		\n		Scanner sc = new Scanner(System.in);\n		char[] s=sc.nextLine().toCharArray();\n		char[] t=sc.nextLine().toCharArray();\n		int count=0;\n		boolean takes=true;\n		String ans="""";\n		\n		for(int i=0;i<s.length;i++)\n		{\n		    if(s[i]==t[i])\n		    continue;\n		    \n		    else\n		    {\n		        if(!takes)\n		        s[i]=t[i];\n		        \n		        takes=!takes;\n		        count++;\n		    }\n		}\n		\n		if(count%2!=0)\n		{\n			System.out.println(""impossible"");\n		}\n		else {\n			System.out.println(new String(s));\n		}\n	}\n}",greedy
"import java.util.*;\n\npublic class EquidistantString {\n\n	static void solve() {\n		Scanner sc = new Scanner(System.in);\n		String s = sc.next(), t = sc.next();\n		int res = 0,j = 0;\n		char[] c = new char[s.length()];\n		for (int i=0; i<s.length(); i++) {\n			char x = s.charAt(i), y = t.charAt(i);\n			if (x==y) {\n				c[j++]=x;\n			} else {\n				if (res==0) c[j++]=x;\n				else c[j++]=y;\n				res^=1;\n			}\n		}\n		if (res!=0) {\n			System.out.println(""impossible"");\n		} else {\n			StringBuilder o = new StringBuilder();\n			for (char ch : c) o.append(ch);\n			System.out.println(o);\n		}\n		sc.close();\n	}\n\n	public static void main(String[] args) {\n		solve();\n	}\n}",greedy
"import java.io.*;\nimport java.util.*;\npublic class equidistant_string\n{\n	public static void main(String[] args) \n	{\n	    Scanner in=new Scanner(System.in);\n		String s=in.next();\n		int cnt=0;\n		String str=in.next();\n		for(int i=0;i<s.length();i++)\n		{\n			if(s.charAt(i)!=str.charAt(i))\n			{\n				cnt++;\n			}\n		}\n		if(cnt%2!=0)\n		{\n			System.out.println(""impossible"");\n			return;\n		}\n		boolean bool=false;\n//		out.println(""YES"");\n		for(int i=0;i<s.length();i++)\n		{\n			if(s.charAt(i)==str.charAt(i))\n			{\n				System.out.print(s.charAt(i));\n			}\n			else\n			{\n				if(bool==false)\n				{\n					System.out.print(str.charAt(i));\n					bool=true;\n				}\n				else\n				{\n					System.out.print(s.charAt(i));\n					bool=false;\n				}\n			}\n		}\n//		out.close();\n	}\n}",greedy
"import java.util.*;\n\npublic class Solution\n{\n    public static void main(String []args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        \n        \n        int day = sc.nextInt();\n        long height = sc.nextLong();\n        \n       long max = day + height - 1;\n        \n       \n        for(int i = 1 ; i < m ; i++)\n        {\n           int d = sc.nextInt();\n           long h = sc.nextLong();\n           \n           if(d - day < Math.abs(height - h))\n           {\n               max = -1;\n               break;\n           }\n           \n           long k = d - day;\n           \n           k = k - (Math.abs(h - height));\n           \n           long maxNow = Math.max(height , h) + k/2;\n           \n           if(maxNow > max)\n           max = maxNow;\n           \n           \n           day = d;\n           height = h;\n        }\n        \n        \n        if(max != -1)\n        {\n        if(day == n)\n        System.out.println(max);\n        \n        else\n        {\n            long maxNow = height + n - day;\n            \n            if(maxNow > max)\n            System.out.println(maxNow);\n            \n            else\n            System.out.println(max);\n        }\n        \n        }\n        \n        else\n        System.out.println(""IMPOSSIBLE"");\n    }\n}","binary search,brute force,greedy,implementation,math"
"import java.io.*;\nimport java.util.*;\npublic class Main\n{\n	\n	private void solve()throws IOException\n	{\n		int n=nextInt();\n		int m=nextInt();\n		int d[]=new int[m+1];\n		int h[]=new int[m+1];\n		for(int i=1;i<=m;i++)\n		{\n			d[i]=nextInt();\n			h[i]=nextInt();\n		}\n		int first=h[1]+d[1]-1;\n		int last=h[m]+n-d[m];\n		int max=Math.max(first,last);\n		for(int i=1;i<m;i++)\n		{\n			if(Math.abs(h[i+1]-h[i])>d[i+1]-d[i])\n			{\n				out.println(""IMPOSSIBLE"");\n				return;\n			}\n			int extra=d[i+1]-d[i]-Math.abs(h[i]-h[i+1]);\n			max=Math.max(max,Math.max(h[i],h[i+1])+extra/2);\n		}\n		out.println(max);\n	}\n\n	 \n	///////////////////////////////////////////////////////////\n\n	public void run()throws IOException\n	{\n		br=new BufferedReader(new InputStreamReader(System.in));\n		st=null;\n		out=new PrintWriter(System.out);\n\n		solve();\n		\n		br.close();\n		out.close();\n	}\n	public static void main(String args[])throws IOException{\n		new Main().run();\n	}\n	BufferedReader br;\n	StringTokenizer st;\n	PrintWriter out;\n	String nextToken()throws IOException{\n		while(st==null || !st.hasMoreTokens())\n		st=new StringTokenizer(br.readLine());\n		return st.nextToken();\n	}\n	String nextLine()throws IOException{\n		return br.readLine();\n	}\n	int nextInt()throws IOException{\n		return Integer.parseInt(nextToken());\n	}\n	long nextLong()throws IOException{\n		return Long.parseLong(nextToken());\n	}\n	double nextDouble()throws IOException{\n		return Double.parseDouble(nextToken());\n	}\n}","binary search,brute force,greedy,implementation,math"
"import java.io.*;\nimport java.util.*;\nimport java.lang.*;\n\npublic class Rextester{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int d = Integer.parseInt(st.nextToken());\n        int initialDay = 0,initialHeight = 0,maxHeight = 0;\n        for(int i=0;i<d;i++){\n            StringTokenizer st1 = new StringTokenizer(br.readLine());\n            int day = Integer.parseInt(st1.nextToken());\n            int height = Integer.parseInt(st1.nextToken());\n            if(initialDay==0){\n                int nd = day - initialDay-1;\n                maxHeight = Math.max(maxHeight,height+nd);\n                initialDay = day;\n                initialHeight = height;\n                continue;\n            }\n            int nd = day-initialDay;\n            int hc = Math.abs(height - initialHeight);\n            if(nd==hc){\n                maxHeight = Math.max(maxHeight,Math.max(height,initialHeight));\n            }\n            else if(nd<hc){\n                System.out.println(""IMPOSSIBLE"");\n                return;\n            }\n            else{\n                int maxChange = (nd-hc)/2;\n                maxHeight = Math.max(maxHeight,Math.max(height+maxChange,initialHeight+maxChange));\n            }\n            initialDay = day;\n            initialHeight = height;\n        }\n        int nd = n - initialDay;\n        maxHeight = Math.max(maxHeight,initialHeight+nd);\n        System.out.println(maxHeight);\n    }\n}","binary search,brute force,greedy,implementation,math"
"\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\npublic class Div3_724 {\n\n	static void sort(int[] a) {\n		ArrayList<Integer> l = new ArrayList<>();\n		for (int i : a)\n			l.add(i);\n		Collections.sort(l);\n		for (int i = 0; i < a.length; i++)\n			a[i] = l.get(i);\n	}\n\n	public static void main(String[] args) {\n		FastReader sc = new FastReader();\n\n		int t = 1;\n		out: while (t-- > 0) {\n			int n = sc.nextInt();\n			int m = sc.nextInt();\n\n			if (m == 1) {\n				int a = sc.nextInt();\n				int h = sc.nextInt();\n				int x = Math.max(a - 1, n - a);\n				System.out.println(h + x);\n				continue;\n			}\n\n			long ans = 0;\n			int a1 = sc.nextInt();\n			int h1 = sc.nextInt();\n\n			ans = Math.max(ans, a1 - 1 + h1);\n\n			for (int i = 1; i < m; i++) {\n				int a2 = sc.nextInt();\n				int h2 = sc.nextInt();\n				int gap = a2 - a1;\n				int diff = Math.abs(h2 - h1);\n\n				if (diff > gap) {\n					System.out.println(""IMPOSSIBLE"");\n					continue out;\n				}\n				ans = Math.max(ans, Math.max(h1, h2));\n\n				int d = (gap - diff) / 2;\n				ans = Math.max(ans, Math.max(h1, h2) + d);\n				h1 = h2;\n				a1 = a2;\n\n			}\n			ans = Math.max(ans, h1 + n - a1);\n			System.out.println(ans);\n		}\n	}\n\n	static class FastReader {\n		BufferedReader br;\n		StringTokenizer st;\n\n		public FastReader() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		String next() {\n			while (st == null || !st.hasMoreElements()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			}\n			return st.nextToken();\n		}\n\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n\n		long[] readArray(int n) {\n			long[] a = new long[n];\n			for (int i = 0; i < n; i++)\n				a[i] = nextLong();\n			return a;\n		}\n\n		String nextLine() {\n			String str = """";\n			try {\n				str = br.readLine();\n			} catch (IOException e) {\n				e.printStackTrace();\n			}\n			return str;\n		}\n	}\n\n}\n","binary search,brute force,greedy,implementation,math"
import java.util.*;\n\npublic class solution {\n	public static void main(String[] args)  {\n		Scanner sc = new Scanner(System.in);\n        int w=sc.nextInt();\n        int h=sc.nextInt();\n        char[][] c=new char[h][w];\n        sc.nextLine();\n        for(int i=0;i<h;i++) {\n        	c[i]=sc.nextLine().toCharArray();\n        }\n        char[][] d=new char[w][h];\n        for(int i=0;i<w;i++) {\n        	for(int j=0;j<h;j++) {\n        		d[i][j]=c[j][i];\n        	}\n        }\n        for(int i=0;i<w;i++) {\n        	for(int l=0;l<2;l++) {\n        		for(int j=0;j<h;j++) {\n            		for(int k=0;k<2;k++) {\n            			System.out.print(d[i][j]);\n            		}\n            	}\n        		System.out.println();\n        	}\n        }\n	}\n},"*special,implementation"
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Eshan {\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static StringTokenizer st;\n    static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) throws IOException {\n        // int t = readInt();\n        // while(t-- > 0){\n\n        // }\n        int n = readInt(), m = readInt();\n        char[][] arr = new char[n][m];\n        for (int j = 0; j < m; j++) {\n            String str = readLine();\n            for (int i = 0; i < n; i++)\n                arr[i][j] = str.charAt(i);\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++)\n                out.print(arr[i][j] + """" + arr[i][j]);\n            out.println("" "");\n            for (int j = 0; j < m; j++)\n                out.print(arr[i][j] + """" + arr[i][j]);\n            out.println("" "");\n        }\n        out.flush();\n    }\n\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(readLine());\n        return st.nextToken();\n    }\n\n    static long readLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    static int readInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    static double readDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    static char readCharacter() throws IOException {\n        return next().charAt(0);\n    }\n\n    static String readLine() throws IOException {\n        return br.readLine().trim();\n    }\n\n    private static boolean isInteger(String s) {\n        try {\n            Integer.parseInt(s);\n        } catch (NumberFormatException e) {\n            return false;\n        } catch (NullPointerException e) {\n            return false;\n        }\n        return true;\n    }\n\n    private static int gcd(int a, int b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n    private static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n    private static int lcm(int a, int b) {\n        return (a / gcd(a, b)) * b;\n    }\n\n    private static long lcm(long a, long b) {\n        return (a / gcd(a, b)) * b;\n    }\n\n    private static long mod_power(long a, long b, int mod) {\n        if (b == 0)\n            return 1L;\n        long temp = mod_power(a, b / 2, mod);\n        temp %= mod;\n        temp = (temp * temp) % mod;\n        if ((b & 1) == 1)\n            temp = (temp * a) % mod;\n        return temp;\n    }\n}","*special,implementation"
"import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;\nimport java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;\nimport java.security.AccessControlException;import java.util.List;public class _p000523A {\nstatic public void main(final String[] args) throws IOException{p000523A._main(args);}\n\nstatic class p000523A extends Solver{public p000523A(){singleTest=true;}@Override public \nvoid solve()throws IOException{int w=sc.nextInt();int h=sc.nextInt();sc.nextLine();\nint[][]c=new int[h][];for(int $i0=0;$i0<h;$i0++){c[$i0]=sc.nextLine().chars().toArray();\n}int[][]c1=new int[h][w];for(int i=0;i<h;i++){for(int j=0;j<w;j++){c1[h-1-i][j]=\nc[i][j];}}for(int j=0;j<w;j++){for(int k=0;k<2;k++){for(int i=h-1;i>=0;i--){pw.print((char)c1[i][j]);\npw.print((char)c1[i][j]);}pw.println();}}}static public void _main(String[]args)throws \nIOException{new p000523A().run();}}static class MyScanner{private StringBuilder \ncache=new StringBuilder();int cache_pos=0;private int first_linebreak=-1;private \nint second_linebreak=-1;private StringBuilder sb=new StringBuilder();private InputStream \nis=null;public MyScanner(final InputStream is){this.is=is;}public String charToString(final \nint c){return String.format(""'%s'"",c=='\n'?""\\n"":(c=='\r'?""\\r"":String.valueOf((char)c)));\n}public int get(){int res=-1;if(cache_pos<cache.length()){res=cache.charAt(cache_pos);\ncache_pos++;if(cache_pos==cache.length()){cache.delete(0,cache_pos);cache_pos=0;\n}}else{try{res=is.read();}catch(IOException ex){throw new RuntimeException(ex);}\n}return res;}private void unget(final int c){if(cache_pos==0){cache.insert(0,(char)c);\n}else{cache_pos--;}}public String nextLine(){sb.delete(0,sb.length());int c;boolean \ndone=false;boolean end=false;while((c=get())!=-1){if(check_linebreak(c)){done=true;\nif(c==first_linebreak){if(!end){end=true;}else{cache.append((char)c);break;}}else \nif(second_linebreak!=-1 && c==second_linebreak){break;}}if(end && c!=first_linebreak \n&& c!=second_linebreak){cache.append((char)c);break;}if(!done){sb.append((char)c);\n}}return!done && sb.length()==0?null:sb.toString();}private boolean check_linebreak(int \nc){if(c=='\n'|| c=='\r'){if(first_linebreak==-1){first_linebreak=c;}else if(c!=first_linebreak \n&& second_linebreak==-1){second_linebreak=c;}return true;}return false;}public int \nnextInt(){return Integer.parseInt(next());}public long nextLong(){return Long.parseLong(next());\n}public boolean hasNext(){boolean res=false;int c;while((c=get())!=-1){if(!check_linebreak(c)\n&& c!=' '&& c!='\t'){res=true;unget(c);break;}}return res;}public String next(){\nsb.delete(0,sb.length());boolean started=false;int c;while((c=get())!=-1){if(check_linebreak(c)\n|| c==' '|| c=='\t'){if(started){unget(c);break;}}else{started=true;sb.append((char)c);\n}}return sb.toString();}public int nextChar(){return get();}public boolean eof()\n{int c=get();boolean res=false;if(c!=-1){unget(c);}else{res=true;}return res;}public \ndouble nextDouble(){return Double.parseDouble(next());}}static abstract class Solver\n{protected String nameIn=null;protected String nameOut=null;protected boolean singleTest\n=false;protected MyScanner sc=null;protected PrintWriter pw=null;private int current_test\n=0;private int count_tests=0;protected int currentTest(){return current_test;}protected \nint countTests(){return count_tests;}private void process()throws IOException{if(!singleTest)\n{count_tests=sc.nextInt();sc.nextLine();for(current_test=1;current_test<=count_tests;\ncurrent_test++){solve();pw.flush();}}else{count_tests=1;current_test=1;solve();}\n}abstract protected void solve()throws IOException;public void run()throws IOException\n{boolean done=false;try{if(nameIn!=null){if(new File(nameIn).exists()){try(FileInputStream \nfis=new FileInputStream(nameIn);PrintWriter pw0=select_output();){select_output();\ndone=true;sc=new MyScanner(fis);pw=pw0;process();}}else{throw new RuntimeException(""File ""\n+new File(nameIn).getAbsolutePath()+"" does not exist!"");}}}catch(IOException | AccessControlException \nex){}if(!done){try(PrintWriter pw0=select_output();){sc=new MyScanner(System.in);\npw=pw0;process();}}}private PrintWriter select_output()throws FileNotFoundException\n{if(nameOut!=null){return new PrintWriter(nameOut);}return new PrintWriter(System.out);\n}}static abstract class Tester{static public int getRandomInt(final int min,final \nint max){return(min+(int)Math.floor(Math.random()*(max-min+1)));}static public long \ngetRandomLong(final long min,final long max){return(min+(long)Math.floor(Math.random()\n*(max-min+1)));}static public double getRandomDouble(final double min,final double \nmaxExclusive){return(min+Math.random()*(maxExclusive-min));}abstract protected void \ntestOutput(final List<String>output_data);abstract protected void generateInput();\nabstract protected String inputDataToString();private boolean break_tester=false;\nprotected void beforeTesting(){}protected void breakTester(){break_tester=true;}\npublic boolean broken(){return break_tester;}}}\n","*special,implementation"
"import java.util.Scanner;\n\npublic class A_Rotate_Flip_and_Zoom{\n	\n	static Scanner in=new Scanner(System.in);\n	\n	static int n,m;\n	\n	public static void main(String [] amit){\n		\n		m=in.nextInt();\n		\n		n=in.nextInt();\n		\n		char a[][]=new char[n][];\n		\n		for(int i=0;i<n;i++){\n			\n			a[i]=in.next().toCharArray();\n			\n        }\n    \n	\n        for (int i = 0; i < 2 * m; i++) {\n            for (int j = 0; j < 2 * n; j++) {\n                System.out.print(a[j / 2][i / 2]);\n            }\n            System.out.println();\n        }\n		\n	}\n	\n}\n	\n\n		 						 	 	  	 		 	 			 	  		","*special,implementation"
"import java.util.*;\n\npublic class lieges {\n	public static int mex(int a, int b) {\n		if (a != 0 && b != 0) return 0;\n		else if (a != 1 && b != 1) return 1;\n		return 2;\n	}\n\n	public static int nim(int a, int k) {\n		if (k == 0 && a < 3) return a;\n		if (k == 0) return 1 - (a&1);\n		else if ((a&1) == 1) return a < 4 ? 1 : 0;\n\n		return mex(nim(a-1,k), nim(a>>1,k));\n	}\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n\n		int n = sc.nextInt(), k = sc.nextInt()&1;\n\n		int nimber = 0;\n		for (int i=0; i<n; i++) nimber ^= nim(sc.nextInt(), k);\n\n		System.out.println(nimber == 0 ? ""Nicky"" : ""Kevin"");\n	}\n}","games,math"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF603C extends PrintWriter {\n	CF603C() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF603C o = new CF603C(); o.main(); o.flush();\n	}\n\n	int solve(int a) {\n		if (a < 4)\n			return a & 1;\n		if (a == 4)\n			return 2;\n		if ((a & 1) == 1)\n			return 0;\n		return solve(a / 2) == 1 ? 2 : 1;\n	}\n	void main() {\n		int n = sc.nextInt();\n		int k = sc.nextInt() & 1;\n		int sum = 0;\n		while (n-- > 0) {\n			int a = sc.nextInt();\n			int x;\n			if (k == 0)\n				x = a < 3 ? a : a + 1 & 1;\n			else\n				x = solve(a);\n			sum ^= x;\n		}\n		println(sum == 0 ? ""Nicky"" : ""Kevin"");\n	}\n}\n","games,math"
"import java.util.Scanner;\n\npublic class Main {\n\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n\n			int n=in.nextInt();\n			int k=in.nextInt();\n	\n			int sum=0;\n		for(int i=0;i<n;i++){\n			if(k%2==0)sum^=even(in.nextInt());\n			else sum^=odd(in.nextInt());}\n		if(sum!=0)System.out.println(""Kevin"" );\n		else System.out.println(""Nicky"");\n			\n		\n\n	}\n	private static int even(int x) {\n		   if (x <= 2) return x;  \n		return x%2==0?1:0;\n	}\n	private static int odd(int x) {\n		 if(x==0)return 0;  \n		    if(x==1)return 1;  \n		    if(x==2)return 0;  \n		    if(x>=5&&(x&1)!=0)return 0;  \n		    int two=0;while(x%2==0){x/=2;++two;}  \n		    if(x==3)return (two&1)!=0?2:1;  \n		    else return (two&1)!=0?1:2;  \n	}\n\n}","games,math"
"\nimport java.util.Scanner;\n\npublic class LiegesLegendre {\n    static int PRE[] = {0, 1, 0, 1, 2};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int K = sc.nextInt();\n        int res = 0;\n        for (int i = 0; i < N; i++) {\n            int a = sc.nextInt();\n            res ^= grundy(K, a);\n        }\n        System.out.println(res != 0? ""Kevin"" : ""Nicky"");\n    }\n\n    static int grundy(int K, int a) {\n        if (K % 2 == 0) {\n            if (a == 1) return 1;\n            if (a == 2) return 2;\n            return (a % 2) ^ 1;\n        } else {\n            if (a < 5) return PRE[a];\n            if (a % 2 == 1) return 0;\n            return (grundy(K, a / 2) == 1 ? 2 : 1);\n        }\n    }\n\n}\n","games,math"
"import java.io.*;\nimport java.util.*;\npublic class c {\npublic static void main(String[] args) throws IOException {\n    input.init(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n    int n = input.nextInt(), k = input.nextInt();\n    Point[] data = new Point[n];\n    for(int i = 0; i<n; i++)\n    {\n        int x1 = input.nextInt(), y1 = input.nextInt(), x2 = input.nextInt(), y2 = input.nextInt();\n        int x = x1+x2;\n        int y = y1+y2;\n        data[i] = new Point(x, y);\n    }\n    Arrays.sort(data);\n    long min = (long)1e18;\n    for(int i = 0; i<=k; i++)\n        for(int j = 0; j+i<=k; j++)\n        {\n            int minx = data[i].x;\n            int maxx = data[n-1-j].x;\n            int[] ys = new int[n-i-j];\n            for(int ii = i; ii<=n-1-j; ii++) ys[ii-i] = data[ii].y;\n            //out.println(i+"" ""+j+"" ""+minx+"" ""+maxx+"" ""+Arrays.toString(ys));\n            Arrays.sort(ys);\n            int skip = k - i - j;\n            for(int ii = 0; ii<=skip; ii++)\n            {\n                int miny = ys[ii];\n                int maxy = ys[ys.length-1-(skip-ii)];\n                //out.println(minx+"" ""+maxx+"" ""+miny+"" ""+maxy);\n                if(maxx == minx) maxx++;\n                if(maxy == miny) maxy++;\n                long cur = (long)(maxy - miny + 1)/2 * ((maxx - minx + 1)/2);\n                min = Math.min(min, cur);\n            }\n        }\n    out.println(min);\n    out.close();\n}\nstatic class Point implements Comparable<Point>\n{\n    int x, y;\n    Point(int xx, int yy)\n    {\n        x = xx; y = yy;\n    }\n    @Override\n    public int compareTo(Point o) {\n    return x - o.x;\n    }\n}\npublic static class input {\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    static void init(InputStream input) {\n    reader = new BufferedReader(new InputStreamReader(input));\n    tokenizer = new StringTokenizer("""");\n    }\n\n    static String next() throws IOException {\n    while (!tokenizer.hasMoreTokens())\n        tokenizer = new StringTokenizer(reader.readLine());\n    return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n    return Integer.parseInt(next());\n    }\n\n    static double nextDouble() throws IOException {\n    return Double.parseDouble(next());\n    }\n\n    static long nextLong() throws IOException {\n    return Long.parseLong(next());\n    }\n}\n}\n","brute force,greedy,implementation,two pointers"
"import java.util.*;\nimport java.io.*;\n\npublic class C2 {\n\n  class Magnet {\n    int x, y;\n    int id;\n    \n    Magnet(int x, int y, int id) {\n      this.x  = x;\n      this.y  = y;\n      this.id = id;\n    }\n  }\n\n  Comparator<Magnet> cmpX = new Comparator<Magnet>() {\n    public int compare(Magnet m1, Magnet m2) { return m1.x - m2.x; }\n  };\n\n  Comparator<Magnet> cmpY = new Comparator<Magnet>() {\n    public int compare(Magnet m1, Magnet m2) { return m1.y - m2.y; }\n  };\n\n  int ind = 0, cnt = 0;\n  int[] removed;\n\n  void mark(int id) {\n    if(removed[id] != ind) {\n      removed[id] = ind;\n      cnt++;\n    }\n  }\n\n  void solve() {\n    Input in = new Input(System.in);\n    \n    int n = in.nextInt();\n    int k = in.nextInt();\n    \n    Magnet[] mX = new Magnet[n + 1];\n    Magnet[] mY = new Magnet[n + 1];\n    \n    for(int i = 1; i <= n; i++) {\n      int x1 = in.nextInt();\n      int y1 = in.nextInt();\n      int x2 = in.nextInt();\n      int y2 = in.nextInt();\n      Magnet m = new Magnet(x1 + x2, y1 +y2, i);\n      mX[i] = m;\n      mY[i] = m;\n    }\n    \n    Arrays.sort(mX, 1, n + 1, cmpX);\n    Arrays.sort(mY, 1, n + 1, cmpY);\n    \n    removed = new int[n + 1];\n    \n    long res = Long.MAX_VALUE;\n    \n    for(int i1 = 0; i1 <= k; i1++) {\n      for(int i2 = 0; i2 <= k; i2++) {\n        for(int i3 = 0; i3 <= k; i3++) {\n          for(int i4 = 0; i4 <= k; i4++) {\n            ind++;\n            cnt = 0;\n            \n            for(int i = 1; i <= i1; i++)    mark(mX[i].id);\n            for(int i = n; i > n - i2; i--) mark(mX[i].id);\n            for(int i = 1; i <= i3; i++)    mark(mY[i].id);\n            for(int i = n; i > n - i4; i--) mark(mY[i].id);\n            \n            if(cnt > k) {\n              continue;\n            }\n            \n            int w = Math.max(2, mX[n - i2].x - mX[i1 + 1].x);\n            int h = Math.max(2, mY[n - i4].y - mY[i3 + 1].y);\n            \n            long area = ((long) w) * h;\n            res = Math.min(res, area);\n          }\n        }\n      }\n    }\n    \n    System.out.println(res / 4);\n  }\n\n  public static void main(String[] args) {\n    new C2().solve();\n  }\n\n  class Input {\n\n    BufferedReader br;\n    StringTokenizer st;\n\n    Input(InputStream is) {\n      br = new BufferedReader(new InputStreamReader(is));\n    }\n\n    String next() {\n      try {\n        while(st == null || !st.hasMoreTokens()) {\n          String line = br.readLine();\n          if(line == null) {\n            return null;\n          }\n          st = new StringTokenizer(line);\n        }\n      } catch (IOException e) {\n        return null;\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n  }\n\n}\n","brute force,greedy,implementation,two pointers"
"import java.util.*;\nimport java.io.*;\n\npublic class C {\n\n  class Magnet {\n    int x, y;\n    boolean present = true;\n    \n    Magnet(int x, int y) {\n      this.x = x;\n      this.y = y;\n    }\n    \n    @Override\n    public String toString() {\n      return ""("" + x + "","" + y + "")"";\n    }\n  }\n\n  void solve() {\n    Input in = new Input(System.in);\n    \n    int N = in.nextInt();\n    int k = in.nextInt();\n    \n    Magnet[][] magnets = new Magnet[4][N];\n    \n    for(int i = 0; i < N; i++) {\n      int x1 = in.nextInt();\n      int y1 = in.nextInt();\n      int x2 = in.nextInt();\n      int y2 = in.nextInt();\n      Magnet m = new Magnet(x1 + x2, y1 + y2);\n      for(int j = 0; j < 4; j++) {\n        magnets[j][i] = m;\n      }\n    }\n    \n    Comparator<Magnet> compByX = new Comparator<Magnet>() {\n      @Override\n      public int compare(Magnet m1, Magnet m2) {\n        return m1.x - m2.x;\n      }\n    };\n    \n    Comparator<Magnet> compByY = new Comparator<Magnet>() {\n      @Override\n      public int compare(Magnet m1, Magnet m2) {\n        return m1.y - m2.y;\n      }\n    };\n    \n    Arrays.sort(magnets[0], compByX);\n    //System.out.println(""X: "" + Arrays.toString(magnets[0]));\n    Arrays.sort(magnets[1], compByX.reversed());\n    Arrays.sort(magnets[2], compByY);\n    //System.out.println(""Y: "" + Arrays.toString(magnets[2]));\n    Arrays.sort(magnets[3], compByY.reversed());\n    \n    int ii[] = new int[4];\n    int jj[] = new int[4];\n    \n    long res = Long.MAX_VALUE;\n    \n    for(ii[0] = 0; ii[0] <= k; ii[0]++) {\n      for(ii[1] = 0; ii[1] <= k - ii[0]; ii[1]++) {\n        for(ii[2] = 0; ii[2] <= k - ii[0] - ii[1]; ii[2]++) {\n          for(ii[3] = 0; ii[3] <= k - ii[0] - ii[1] - ii[2]; ii[3]++) {\n            for(int i = 0; i < 4; i++) {\n              int r = 0;\n              while(r < ii[i]) {\n                if(magnets[i][jj[i]].present) {\n                  magnets[i][jj[i]].present = false;\n                  r++;\n                }\n                jj[i]++;\n              }\n            }\n            \n            for(int i = 0; i < 4; i++) {\n              while(!magnets[i][jj[i]].present) {\n                jj[i]++;\n              }\n            }\n            \n            long area = Math.max(((long) magnets[1][jj[1]].x - magnets[0][jj[0]].x), 2)\n                      * Math.max(((long) magnets[3][jj[3]].y - magnets[2][jj[2]].y), 2);\n            res = Math.min(res, area);\n            \n            //if(area == 0) {\n            //  for(int i = 0; i < 4; i++) {\n            //    System.out.print(jj[i] + "" "");\n            //  }\n            //  System.out.println();\n            //}\n            \n            for(int i = 0; i < 4; i++) {\n              while(jj[i] > 0) {\n                magnets[i][--jj[i]].present = true;\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    System.out.println(res / 4);\n  }\n\n  public static void main(String[] args) {\n    new C().solve();\n  }\n\n  class Input {\n\n    BufferedReader br;\n    StringTokenizer st;\n\n    Input(InputStream is) {\n      br = new BufferedReader(new InputStreamReader(is));\n    }\n\n    String next() {\n      try {\n        while(st == null || !st.hasMoreTokens()) {\n          String line = br.readLine();\n          if(line == null) {\n            return null;\n          }\n          st = new StringTokenizer(line);\n        }\n      } catch (IOException e) {\n        return null;\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n  }\n\n}\n","brute force,greedy,implementation,two pointers"
"import java.util.*;\nimport java.io.*;\n\npublic class C {\n	FastScanner in;\n	PrintWriter out;\n\n	class Point {\n		long x, y;\n		int id;\n\n		public Point(long x, long y, int id) {\n			super();\n			this.x = x;\n			this.y = y;\n			this.id = id;\n		}\n	}\n	\n	Point[] pts;\n	int n;\n	TreeSet<Point> minY, maxY, minX, maxX;\n	long ans = Long.MAX_VALUE;\n	TreeSet<Point>[] sets;\n	\n	public void solve() throws IOException {\n		n = in.nextInt();\n		int k = in.nextInt();\n		pts = new Point[n];\n		for (int i = 0; i < n; i++) {\n			long x1 = in.nextLong(), y1 = in.nextLong();\n			long x2 = in.nextLong(), y2 = in.nextLong();\n			pts[i] = new Point((x2 + x1), (y2 + y1), i);\n		}\n		minY = new TreeSet<>(new Comparator<Point>() {\n\n			@Override\n			public int compare(Point o1, Point o2) {\n				if (o1.y != o2.y) {\n					return Long.compare(o1.y, o2.y);\n				}\n				return Integer.compare(o1.id, o2.id);\n			}\n		});\n		maxY = new TreeSet<>(new Comparator<Point>() {\n\n			@Override\n			public int compare(Point o1, Point o2) {\n				if (o1.y != o2.y) {\n					return -Long.compare(o1.y, o2.y);\n				}\n				return Integer.compare(o1.id, o2.id);\n			}\n		});\n		minX = new TreeSet<>(new Comparator<Point>() {\n\n			@Override\n			public int compare(Point o1, Point o2) {\n				if (o1.x != o2.x) {\n					return Long.compare(o1.x, o2.x);\n				}\n				return Integer.compare(o1.id, o2.id);\n			}\n		});\n		maxX = new TreeSet<>(new Comparator<Point>() {\n\n			@Override\n			public int compare(Point o1, Point o2) {\n				if (o1.x != o2.x) {\n					return -Long.compare(o1.x, o2.x);\n				}\n				return Integer.compare(o1.id, o2.id);\n			}\n		});\n		sets = new TreeSet[4];\n		sets[0] = minX;\n		sets[1] = maxX;\n		sets[2] = minY;\n		sets[3] = maxY;\n		for (Point p : pts) {\n			for (TreeSet<Point> set : sets) {\n				set.add(p);\n			}\n		}\n		int[] cnt = new int[4];\n		for (cnt[0] = 0; cnt[0] <= k; cnt[0]++) {\n			for (cnt[1] = 0; cnt[1] <= k; cnt[1]++) {\n				for (cnt[2] = 0; cnt[2] <= k; cnt[2]++) {\n					for (cnt[3] = 0; cnt[3] <= k; cnt[3]++) {\n						if (cnt[0] + cnt[1] + cnt[2] + cnt[3] == k) {\n							ArrayList<Point> toRemove = new ArrayList<>();\n							for (int i = 0; i < 4; i++) {\n								for (int j = 0; j < cnt[i]; j++) {\n									Point toDel = sets[i].first();\n									toRemove.add(toDel);\n									for (TreeSet<Point> set : sets) {\n										set.remove(toDel);\n									}\n								}\n							}\n							long dx = maxX.first().x - minX.first().x;\n							long dy = maxY.first().y - minY.first().y;\n							dx = Math.max(1, dx);\n							dy = Math.max(1, dy);\n							dx = (dx + 1) / 2;\n							dy = (dy + 1) / 2;\n							ans = Math.min(dx * dy, ans);\n							for (Point p : toRemove) {\n								for (TreeSet<Point> set : sets) {\n									set.add(p);\n								}\n							}\n						}\n					}\n				}\n			}\n		}\n		out.println(ans);\n	}\n\n	public void run() {\n		try {\n			in = new FastScanner();\n			out = new PrintWriter(System.out);\n\n			solve();\n\n			out.close();\n		} catch (IOException e) {\n			e.printStackTrace();\n		}\n	}\n\n	class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		FastScanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		String next() {\n			while (st == null || !st.hasMoreTokens()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			}\n			return st.nextToken();\n		}\n\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n	}\n\n	public static void main(String[] arg) {\n		new C().run();\n	}\n}","brute force,greedy,implementation,two pointers"
"import java.util.Scanner;\n\npublic class D {\n    public static void main(String[] args) {\n        Scanner cin = new Scanner(System.in);\n        double x1 = cin.nextDouble();\n        double y1 = cin.nextDouble();\n        double x2 = cin.nextDouble();\n        double y2 = cin.nextDouble();\n        double v = cin.nextDouble();\n        double t = cin.nextDouble();\n        double vx = cin.nextDouble();\n        double vy = cin.nextDouble();\n        double wx = cin.nextDouble();\n        double wy = cin.nextDouble();\n        cin.close();\n\n        double left = 0;\n        double right = 1e8;\n        for (int time = 0; time < 100000; time++) {\n            double mid = (left + right) / 2.0;\n\n            double nx, ny;\n            if (mid <= t) {\n                nx = vx * mid;\n                ny = vy * mid;\n            } else {\n                nx = vx * t + wx * (mid - t);\n                ny = vy * t + wy * (mid - t);\n            }\n\n            double dx = x2 - x1 - nx;\n            double dy = y2 - y1 - ny;\n            if (v * v * mid * mid > dx * dx + dy * dy) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        System.out.println(right);\n    }\n}\n","binary search,geometry,math"
"import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n    static int MOD = 1000000007;\n\n    // After writing solution, quick scan for:\n    //   array out of bounds\n    //   special cases e.g. n=1?\n    //   npe, particularly in maps\n    //\n    // Big numbers arithmetic bugs:\n    //   int overflow\n    //   sorting, or taking max, after MOD\n    void solve() throws IOException {\n        int[] xyxy = ril(4);\n        int x1 = xyxy[0];\n        int y1 = xyxy[1];\n        int x2 = xyxy[2];\n        int y2 = xyxy[3];\n        int[] vt = ril(2);\n        int v_max = vt[0];\n        int t = vt[1];\n\n        int[] v = ril(2);\n        int vx = v[0];\n        int vy = v[1];\n        int[] w = ril(2);\n        int wx = w[0];\n        int wy = w[1];\n\n        // Case 1: can we get to target <= t.\n        int dx = x2 - x1;\n        int dy = y2 - y1;\n        double zx = (double) dx / t - vx;\n        double zy = (double) dy / t - vy;\n        if (zx * zx + zy * zy <= v_max * v_max) {\n            double l = 0;\n            double r = t;\n            double best = Double.MAX_VALUE;\n            for (int i = 0; i < 100; i++) {\n                double m = (l + r) / 2;\n                zx = (double) dx / m - vx;\n                zy = (double) dy / m - vy;\n                if (zx * zx + zy * zy <= v_max * v_max) {\n                    best = m;\n                    r = m;\n                } else {\n                    l = m;\n                }\n            }\n            printDouble(best);\n            return;\n        }\n\n        // Case 2: get as far as possible in first phase. This is a circular region, offset\n        // by the wind speed: t * (vx, vy).\n        double x_offseted = (double) vx * t + x1;\n        double y_offseted = (double) vy * t + y1;\n        double radius = (double) v_max * t;\n        double l = 0;\n        double r = Integer.MAX_VALUE;  // this is probably big enough.\n        double best = Double.MAX_VALUE;\n        for (int i = 0; i < 100; i++) {\n            double m = (l + r) / 2;\n            double radius2 = (double) v_max * m;\n            double x_offseted2 = x2 - (double) wx * m;\n            double y_offseted2 = y2 - (double) wy * m;\n            double DX = x_offseted2 - x_offseted;\n            double DY = y_offseted2 - y_offseted;\n            double D = Math.sqrt(DX * DX + DY * DY);\n            if (radius + radius2 >= D) {\n                best = m;\n                r = m;\n            } else {\n                l = m;\n            }\n        }\n        printDouble(t + best);\n    }\n    // IMPORTANT\n    // DID YOU CHECK THE COMMON MISTAKES ABOVE?\n\n    // Template code below\n\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    PrintWriter pw = new PrintWriter(System.out);\n\n    public static void main(String[] args) throws IOException {\n        Main m = new Main();\n        m.solve();\n        m.close();\n    }\n\n    void close() throws IOException {\n        pw.flush();\n        pw.close();\n        br.close();\n    }\n\n    int ri() throws IOException {\n        return Integer.parseInt(br.readLine().trim());\n    }\n\n    long rl() throws IOException {\n        return Long.parseLong(br.readLine().trim());\n    }\n\n    int[] ril(int n) throws IOException {\n        int[] nums = new int[n];\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n            int sign = 1;\n            c = br.read();\n            int x = 0;\n            if (c == '-') {\n                sign = -1;\n                c = br.read();\n            }\n            while (c >= '0' && c <= '9') {\n                x = x * 10 + c - '0';\n                c = br.read();\n            }\n            nums[i] = x * sign;\n        }\n        while (c != '\n' && c != -1) c = br.read();\n        return nums;\n    }\n\n    long[] rll(int n) throws IOException {\n        long[] nums = new long[n];\n        int c = 0;\n        for (int i = 0; i < n; i++) {\n            int sign = 1;\n            c = br.read();\n            long x = 0;\n            if (c == '-') {\n                sign = -1;\n                c = br.read();\n            }\n            while (c >= '0' && c <= '9') {\n                x = x * 10 + c - '0';\n                c = br.read();\n            }\n            nums[i] = x * sign;\n        }\n        while (c != '\n' && c != -1) c = br.read();\n        return nums;\n    }\n\n    int[] rkil() throws IOException {\n        int sign = 1;\n        int c = br.read();\n        int x = 0;\n        if (c == '-') {\n            sign = -1;\n            c = br.read();\n        }\n        while (c >= '0' && c <= '9') {\n            x = x * 10 + c - '0';\n            c = br.read();\n        }\n        return ril(x);\n    }\n\n    long[] rkll() throws IOException {\n        int sign = 1;\n        int c = br.read();\n        int x = 0;\n        if (c == '-') {\n            sign = -1;\n            c = br.read();\n        }\n        while (c >= '0' && c <= '9') {\n            x = x * 10 + c - '0';\n            c = br.read();\n        }\n        return rll(x);\n    }\n\n    char[] rs() throws IOException {\n        return br.readLine().toCharArray();\n    }\n\n    void sort(int[] A) {\n        Random r = new Random();\n        for (int i = A.length-1; i > 0; i--) {\n            int j = r.nextInt(i+1);\n            int temp = A[i];\n            A[i] = A[j];\n            A[j] = temp;\n        }\n        Arrays.sort(A);\n    }\n\n    void printDouble(double d) {\n        pw.printf(""%.16f"", d);\n    }\n}","binary search,geometry,math"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF590B extends PrintWriter {\n	CF590B() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF590B o = new CF590B(); o.main(); o.flush();\n	}\n\n	double solve(long x, long y, long vx, long vy, long v) {\n		// (x - vx t)^2 + (y - vy t)^2 = v^2 t^2\n		// (v^2 - vx^2 - vy^2) t^2 + 2(x vx + y vy) t - (x^2 + y^2) = 0\n		double a = v * v - vx * vx - vy * vy;\n		double b = 2 * (x * vx + y * vy);\n		double c = -(x * x + y * y);\n		return (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n	}\n	void main() {\n		int x1 = sc.nextInt();\n		int y1 = sc.nextInt();\n		int x2 = sc.nextInt();\n		int y2 = sc.nextInt();\n		int x = x1 - x2;\n		int y = y1 - y2;\n		int v = sc.nextInt();\n		int t = sc.nextInt();\n		int vx = -sc.nextInt();\n		int vy = -sc.nextInt();\n		int wx = -sc.nextInt();\n		int wy = -sc.nextInt();\n		double t1 = solve(x, y, vx, vy, v);\n		if (t1 >= 0 && t1 <= t) {\n			println(t1);\n			return;\n		}\n		double t2 = solve(x + (long) (wx - vx) * t, y + (long) (wy - vy) * t, wx, wy, v);\n		println(Math.max(t2, t));\n	}\n}\n","binary search,geometry,math"
"import java.util.Scanner;\n\npublic class D {\n    public static void main(String[] args) {\n        Scanner cin = new Scanner(System.in);\n        double x1 = cin.nextDouble();\n        double y1 = cin.nextDouble();\n        double x2 = cin.nextDouble();\n        double y2 = cin.nextDouble();\n        double v = cin.nextDouble();\n        double t = cin.nextDouble();\n        double vx = cin.nextDouble();\n        double vy = cin.nextDouble();\n        double wx = cin.nextDouble();\n        double wy = cin.nextDouble();\n        cin.close();\n\n        double left = 0;\n        double right = 1e8;\n        for (int time = 0; time < 100000; time++) {\n            double mid = (left + right) / 2.0;\n\n            double nx, ny;\n            if (mid <= t) {\n                nx = vx * mid;\n                ny = vy * mid;\n            } else {\n                nx = vx * t + wx * (mid - t);\n                ny = vy * t + wy * (mid - t);\n            }\n\n            double dx = x2 - x1 - nx;\n            double dy = y2 - y1 - ny;\n            if (v * v * mid * mid > dx * dx + dy * dy) {\n                right = mid;\n            } else {\n                left = mid;\n            }\n        }\n        System.out.println(right);\n    }\n}\n","binary search,geometry,math"
"import java.io.*;\nimport java.util.*;\n\n/*\n\n1\n16 4\n...AAAAA........\nBB.CCCCC..\n...PDDDDD....\n\n\n1\ntime=0\n16 4\n...AAAAA........\ns.BBB....CCCCC..\n.......DDDDD....\n\n\ntime=1\n16 4\n..AAAAA.........\n.BBB....CCCCC...\n.s....DDDDD.....\n\n\ntime=2\n16 4\n.AAAAA..........\nBBB....CCCCC....\n..s..DDDDD......\n\ntime=3\n16 4\nAAAAA...........\nBB....CCCCC.....\n...sDDDDD.......\n\ntime=4\n16 4\nAAAA............\nB....CCCCC......\n...sDDDDD.......\n\n*/\n\n\npublic class C {\n	static FastReader sc=null;\n	static boolean dp[][][],processed[][][];\n	\n	\n	public static void main(String[] args) {\n		sc=new FastReader();\n		int t=sc.nextInt();\n		while(t-->0) {\n			int n=sc.nextInt(),k=sc.nextInt();\n			char b[][]=new char[3][n];\n			int r=b.length,c=b[0].length;\n			dp=new boolean[r+5][c+5][c+5];\n			processed=new boolean[r+5][c+5][c+5];\n			for(int i=0;i<3;i++) {\n				b[i]=sc.next().toCharArray();\n			}\n			\n//			for(int i=0;i<r;i++)\n//				for(int j=0;j<c;j++)\n//					System.out.println(Arrays.toString(processed[i][j]));\n			\n			int sx=-1;\n			for(int i=0;i<3;i++)if(b[i][0]=='s')sx=i;\n			\n			boolean pos=go(sx,0,0,b);\n			System.out.println(pos?""YES"":""NO"");\n		}\n		\n	}\n	\n	static boolean go(int x,int y,int time,char b[][]) {\n		\n		if(y==b[0].length) {\n			return true;\n		}\n		//you should move first to the right\n		//and then change the direction\n		if(processed[x][y][time])return dp[x][y][time];\n		\n		if(Train(x,y,time,b)) {\n			processed[x][y][time]=true;\n			return dp[x][y][time]=false;\n		}\n		if(Train(x,y+1,time,b)) {\n			processed[x][y][time]=true;\n			return dp[x][y][time]=false;\n		}\n		boolean pos=false;\n		//stay\n		pos|=go(x,y+1,time+1,b);\n		//go up\n		if(x>0 && (!Train(x-1,y+1,time,b)))pos|=go(x-1,y+1,time+1,b);\n		//go down\n		if(x<2 && (!Train(x+1,y+1,time,b)))pos|=go(x+1,y+1,time+1,b);\n		\n		processed[x][y][time]=true;\n\n		return dp[x][y][time]=pos;\n	}\n	\n	static boolean Train(int x,int y,int time,char b[][]) {\n		int now=2*time+y;\n		\n		if(now>=0 && now<b[0].length && (Character.isUpperCase(b[x][now]))) {\n			//System.out.println(""x: ""+x+"" y: ""+y+"" time: ""+time+"" TRAIN now: ""+now);\n\n			return true;\n		}\n		\n		//System.out.println(""x: ""+x+"" y: ""+y+"" time: ""+time+"" NO TRAIN now: ""+now);\n		\n		return false;\n	}\n	\n	\n	\n	\n\n	\n	static int[] ruffleSort(int a[]) {\n		ArrayList<Integer> al=new ArrayList<>();\n		for(int i:a)al.add(i);\n		Collections.sort(al);\n		for(int i=0;i<a.length;i++)a[i]=al.get(i);\n		return a;\n	}\n	\n	static class FastReader{\n		\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n		\n		String next() {\n			while(!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());\n				}\n				catch(IOException e){\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n		\n		int[] readArray(int n) {\n			int a[]=new int[n];\n			for(int i=0;i<n;i++)a[i]=sc.nextInt();\n			return a;\n		}\n	}\n}\n\n\n\n\n\n\n","dfs and similar,graphs,shortest paths"
"/*\n        ""Everything in the universe is balanced. Every disappointment\n                you face in life will be balanced by something good for you!\n                        Keep going, never give up.""\n\n                        Just have Patience + 1...\n\n*/\n\n\n\n\n\n\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n\npublic class Solution {\n\n    static int MAX = 110;\n    static char[][] arr = new char[3][MAX];\n    static boolean[][] visited = new boolean[3][MAX];\n    static int n, k;\n\n    public static void main(String[] args) throws java.lang.Exception {\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        sc = new FastReader();\n\n        int test = sc.nextInt();\n        for (int t = 1; t <= test; t++) {\n            solve();\n        }\n        out.close();\n    }\n\n    private static void solve() {\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n\n        for (int i = 0; i < 3; i++) {\n            Arrays.fill(arr[i], '.');\n            Arrays.fill(visited[i], false);\n        }\n\n        for (int i = 0; i < 3; i++) {\n            char[] temp = sc.next().toCharArray();\n            for (int j = 0; j < n; j++) {\n                arr[i][j] = temp[j];\n            }\n        }\n\n        for (int i = 0; i < 3; i++) {\n            if (arr[i][0] == 's') {\n                dfs(i, 0);\n                break;\n            }\n        }\n\n        for (int i = 0; i < 3; i++) {\n            for (int j = 105; j < MAX; j++) {\n                if (visited[i][j]) {\n                    out.println(""YES"");\n                    return;\n                }\n            }\n        }\n\n        out.println(""NO"");\n    }\n\n    private static void dfs(int row, int col) {\n        if (visited[row][col]) {\n            return;\n        }\n\n        visited[row][col] = true;\n        if (col >= 105) {\n            return;\n        }\n\n        // right up\n        if (isValid(row, col + 1) && isValid(row - 1, col + 1) && isValid(row - 1, col + 2) && isValid(row - 1, col + 3)) {\n            dfs(row - 1, col + 3);\n        }\n\n        // right stay\n        if (isValid(row, col + 1) && isValid(row, col + 2) && isValid(row, col + 3)) {\n            dfs(row, col + 3);\n        }\n\n        // right down\n        if (isValid(row, col + 1) && isValid(row + 1, col + 1) && isValid(row + 1, col + 2) && isValid(row + 1, col + 3)) {\n            dfs(row + 1, col + 3);\n        }\n    }\n    \n    private static boolean isValid(int row, int col) {\n        return row >= 0 && row < 3 && col >= 0 && col < MAX && (arr[row][col] < 'A' || arr[row][col] > 'Z');\n    }\n\n\n    public static FastReader sc;\n    public static PrintWriter out;\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer str;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (str == null || !str.hasMoreElements())\n            {\n                try\n                {\n                    str = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  lastMonthOfVacation)\n                {\n                    lastMonthOfVacation.printStackTrace();\n                }\n            }\n            return str.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = """";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException lastMonthOfVacation)\n            {\n                lastMonthOfVacation.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}","dfs and similar,graphs,shortest paths"
"\n\n\nimport java.io.*;\nimport java.util.*;\nimport java.math.BigInteger; \nimport java.lang.*;\n\n\n\n\npublic class Main {\n    \n    \n    static class sort1 implements Comparator<List<Integer>>\n   {\n        public int compare(List<Integer>  a,List<Integer> b)\n        {\n            \n            return (a.size() - b.size());\n        }\n   }\n    \n   static class sort implements Comparator<int[]>\n   {\n        public int compare(int[] a,int[] b)\n        {\n            \n            return -b[0]+a[0];\n        }\n   }\n    static class sortP implements Comparator<int[]>\n   {\n        public int compare(int[] a,int[] b)\n        {\n            \n            return -b[0]+a[0];\n        }\n   }\n   static class sort1111 implements Comparator<long[]>\n   {\n        public int compare(long[] a,long[] b)\n        {\n            \n          long c = a[1]-b[1];\n          if(c==0l) c = (a[0]-b[0]);\n          if(c==0l) return 0;\n          if(c>0l) return 1;\n          return -1;\n        }\n   }\n  \n   static class sort11 implements Comparator<double[]>\n   {\n        public int compare(double[] a,double[] b)\n        {\n            //if(a[0] == b[0]) return a[1]-b[1];\n           if(a[1] < b[1]) return -1;\n           else if(a[1] > b[1]) return 1;\n           return 0;\n        }\n   }\n   public static String[] F(BufferedReader bf) throws Exception\n    {\n        return (bf.readLine().split("" ""));\n    }\n    \n   public static void pr(PrintWriter out,Object o)\n   {\n      \n    out.println(o.toString());//out.flush();\n    \n   }\n   public static void prW(PrintWriter out,Object o)\n   {\n      \n    out.print(o.toString());//out.flush();\n    \n   }\n   public static int intIn(String st)\n   {\n      return Integer.parseInt(st);\n   }\n   \n   \n    \n    public static void pr(Object o)\n    {\n        System.out.println(o.toString());\n    }\n    public static void prW(Object o)\n    {\n        System.out.print(o.toString());\n    }\n    \n   \n    public static int inInt(String s)\n    {\n        return Integer.parseInt(s);\n    }\n    public static long in(String s)\n    {\n        return Long.parseLong(s);\n    }\n \n \n    static int[] toIntArray(String[] m) \n    { \n        int[] p=new int[m.length];\n        for(int o=0;o<m.length;o++)\n        {\n            p[o]= inInt(m[o]);\n        }\n        return p;\n    }\n    static double[] toDArray(String[] m) \n    { \n        double[] p=new double[m.length];\n        for(int o=0;o<m.length;o=0)\n        {\n            p[o]= Double.parseDouble(m[o]);\n        }\n        return p;\n    }\n    static long[] toLArray(String[] m) \n    { \n       long[] p=new long[m.length];\n        for(int o=0;o<m.length;o++)\n        {\n            p[o]= in(m[o]);\n        }\n        return p;\n    }\n   \n     static long gcd(long a, long b)\n        {\n          if (b == 0)\n            return a;\n          return gcd(b, a % b); \n        }\n     \n        static long pow(long x, long y, long p)\n      {\n        if(y == 0) return 1l;\n        long res = 1; // Initialize result\n     \n        x = x % p; // Update x if it is more than or\n        // equal to p\n     \n        if (x == 0)\n          return 0l; // In case x is divisible by p;\n     \n        while (y > 0)\n        {\n     \n          // If y is odd, multiply x with result\n          if ((y & 1) != 0)\n            res = (res * x) % p;\n     \n          // y must be even now\n          y = y >> 1; // y = y/2\n          x = (x * x) % p;\n        }\n        return res;\n      }\n    \n   \n    \n\n   \n   \n\n   \n    static long __gcd(long n1, long n2)\n    {\n\n        if(n1==0l) return n2;\n        if(n2==0l) return n1;\n        if(n1==1l || n2==1l) return 1l;\n       // long gcd = 1;\n        if(n1 == n2)  return n1;\n        if(n1>n2) return __gcd(n1%n2,n2);\n        return __gcd(n1,n2%n1);\n        \n    }\n    \n   \n    \n    public static boolean F(int r,int c,int it,Boolean[][][] dp,char[][] arr,List<int[]> list){\n      if(c == (arr[0].length-1)) {\n        if(r<0 || r>=3) return false;\n        dp[r][c][it] = true;\n        return true;\n      }\n      if(r<0 || r>=3) return false;\n\n      if(dp[r][c][it] != null)  return dp[r][c][it];\n\n\n      boolean b = false;boolean res=true;\n    \n      boolean b1,b2,b3;b1=b2=b3=true;\n      for(int[] p : list){\n\n        int rx,ry;\n        rx = p[0];ry=p[1];\n        int l = p[2];\n        int nry;int ory;\n        nry = ry - 2*it;\n\n        if(rx == r){\n            if(it > 0){\n\n             ory = ry - 2*(it-1);\n\n             if(c<=Math.max(ory,nry) && c>=Math.min(ory,nry) ){\n              b1=false;\n             }\n             if((c+1)<=Math.max(ory,nry) && (c+1)>=Math.min(ory,nry) ) b1=false;\n\n          }\n          else{\n          if(nry == c){\n            b1=false;break;\n          }\n          if((nry) == (c+1)){\n            b1=false;\n          }}\n          \n\n        }\n        else if(rx == (r-1)){\n          int vp = c+1;int low = nry;int high = nry+l-1;\n          if(vp >= low && vp<=high){\n            b2=false;\n          }\n\n        }\n        else if(rx == (r+1)){\n          int vp = c+1;int low = nry;int high = nry+l-1;\n          if(vp >= low && vp<=high){\n            b3=false;\n          }\n\n        }\n      }\n\n      if(!b1){\n\n         dp[r][c][it] = false;return false;\n\n      }\n      boolean bol = false;\n      if(b2){\n\n        bol = bol || F(r-1,c+1,it+1,dp,arr,list);\n\n      }\n       if(b3){\n\n        bol = bol || F(r+1,c+1,it+1,dp,arr,list);\n\n      }\n\n      bol = bol || F(r,c+1,it+1,dp,arr,list);\n\n      dp[r][c][it] = bol;return bol;\n\n\n\n\n    }\n    public static void main (String[] args) throws Exception {\n        \n        BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);;;//\n        \n        //int[] map=new int[1000001];\n      \n       int yy=inInt(bf.readLine());\n       \n\n\n        \n\n        for(int w=0;w<yy;w++)\n        {\n             //String str = bf.readLine();\n          out.flush();\n         \n            String[] xlp = bf.readLine().split("" "");\n            \n            //String st = bf.readLine();\n      int n;//boolean bol=false;\n           int  m;//long a,b,c;\n           int k;\n          // int l;\n           //int double avg  k;//pr(out,""vbc"");\n       // boolean bol = false;\n           //long mod=1000000000+7\n       n=inInt(xlp[0]);k=inInt(xlp[1]);//m=inInt(xlp[2]);//int j=in(xlp[3]);//long k=in(xlp[4]);\n       char[][] arr = new char[3][n];\n       List<int[]> list=new ArrayList<>();int p=-1;\n       for(int i=0;i<3;i++){\n        arr[i] = bf.readLine().toCharArray();\n       }\n       for(int i=0;i<3;i++){\n        for(int j=0;j<n;){\n          if(arr[i][j] == '.'){\n            j++;continue;\n          }\n          if(arr[i][j] == 's'){\n            p=i;\n            j++;continue;\n          }\n\n          k = j;\n          while(k<n && arr[i][k] == arr[i][j]){\n            k++;\n          }\n          list.add(new int[]{i,j,k-j});\n          j=k;\n\n        }\n       }\n      // pr(out,p);\n      if(F(p,0,0,new Boolean[3][n][n],arr,list)) pr(out,""YES"");\n      else pr(out,""NO"");\n       \n\n\n\n\n\n       \n\n       \n\n\n   }\n    out.close();\n   bf.close();//\n       \n}}\n\n\n/*\n\n\nKickstart\n String rp;\n            rp = ""Case #""+(w+1)+"": ""+(n-ans)+"" "";\nstatic int[][] dir={{0,1},{1,0},{-1,0},{0,-1}};\n\nstatic class SegmentTreeRMQ \n    { \n    int st[]; \n    int minVal(int x, int y) { \n        return (x > y) ? x : y; \n    } \n  \n    \n    int getMid(int s, int e) { \n        return s + (e - s) / 2; \n    } \n  \n    \n    int RMQUtil(int ss, int se, int qs, int qe, int index) \n    { \n        \n        if (qs <= ss && qe >= se) \n            return st[index]; \n  \n        // If segment of this node is outside the given range \n        if (se < qs || ss > qe) \n            return Integer.MIN_VALUE; \n  \n        // If a part of this segment overlaps with the given range \n        int mid = getMid(ss, se); \n        return minVal(RMQUtil(ss, mid, qs, qe, 2 * index + 1), \n                RMQUtil(mid + 1, se, qs, qe, 2 * index + 2)); \n    } \n  \n    // Return minimum of elements in range from index qs (query \n    // start) to qe (query end).  It mainly uses RMQUtil() \n    int RMQ(int n, int qs, int qe) \n    { \n        // Check for erroneous input values \n        \n  \n        return RMQUtil(0, n - 1, qs, qe, 0); \n    } \n  \n    // A recursive function that constructs Segment Tree for \n    // array[ss..se]. si is index of current node in segment tree st \n    int constructSTUtil(int arr[], int ss, int se, int si) \n    { \n        // If there is one element in array, store it in current \n        //  node of segment tree and return \n        if (ss == se) { \n            st[si] = arr[ss]; \n            return arr[ss]; \n        } \n  \n        // If there are more than one elements, then recur for left and \n        // right subtrees and store the minimum of two values in this node \n        int mid = getMid(ss, se); \n        st[si] = minVal(constructSTUtil(arr, ss, mid, si * 2 + 1), \n                constructSTUtil(arr, mid + 1, se, si * 2 + 2)); \n        return st[si]; \n    } \n  \n    \n    void con(int arr[]) \n    { \n        // Allocate memory for segment tree \n  \n        //Height of segment tree \n        int n = (arr.length);\n        int x = (int) (Math.ceil(Math.log(n) / Math.log(2))); \n  \n        //Maximum size of segment tree \n        int max_size = 2 * (int) Math.pow(2, x) - 1; \n        st = new int[max_size]; // allocate memory \n  \n        // Fill the allocated memory st \n        constructSTUtil(arr, 0, n - 1, 0); \n    }\n    }\n     static class DSU {\n    \n    int[] p;int[] sz;int op;int c;;\n    int[] last;\n    public void G(int n)\n    {\n        last=new int[n];\n        p=new int[n];\n        sz=new int[n];c=n;\n        op=n;\n        for(int h=0;h<n;h++)\n        {\n            sz[h]=1;p[h]=h;\n            last[h]=h;\n        }\n    }\n    public int find(int x)\n    {\n        int y=x;\n        while(x!=p[x]) x=p[x];\n        while(y!=p[y])\n        {\n            int tem=p[y];\n            p[y]=x;y=tem;\n        }\n        return p[y];\n    }\n    public void union(int a,int b)\n    {\n        int x,y;\n        x=find(a);y=find(b);\n        if(x==y) return;\n        if(sz[x]>sz[y])\n        {\n            p[y] = x;\n            sz[x]+=sz[y];\n            last[x]=Math.max(last[x],last[y]);\n        }\n        else\n        {\n            p[x]=y;sz[y]+=sz[x];\n            last[y]=Math.max(last[y],last[x]);\n        }\n        c--;\n        \n    }}\n\n    static long pow(long x, long y, long p)\n      {\n        long res = 1; // Initialize result\n     \n        x = x % p; // Update x if it is more than or\n        // equal to p\n     \n        if (x == 0)\n          return 0l; // In case x is divisible by p;\n     \n        while (y > 0)\n        {\n     \n          // If y is odd, multiply x with result\n          if ((y & 1) != 0)\n            res = (res * x) % p;\n     \n          // y must be even now\n          y = y >> 1; // y = y/2\n          x = (x * x) % p;\n        }\n        return res;\n      }\n      static long gcd(long a, long b)\n        {\n          if (b == 0)\n            return a;\n          return gcd(b, a % b); \n        }\n        static int gcd(int a, int b,int o)\n        {\n          if (b == 0)\n            return a;\n          return gcd(b, a % b,o); \n        }\n\nGeometric median\n\npublic static double F(double[] x,double[] w)\n    {\n        double d1,d2;\n        double S=0.00;\n        for(double dp : w) S += dp;\n        int k = 0;\n        double sum = S - w[0]; // sum is the total weight of all `x[i] > x[k]`\n\n        while(sum > S/2)\n        {\n            ++k;\n            sum -= w[k];\n        }\n        d1=x[k];\n        return d1;\n        k = w.length-1;\n       sum = S - w[k]; // sum is the total weight of all `x[i] > x[k]`\n\n        while(sum > S/2)\n        {\n            --k;\n            sum -= w[k];\n        }\n        d2=x[k];\n        return new double[]{d1,d2};\n    }\n*/","dfs and similar,graphs,shortest paths"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF585B extends PrintWriter {\n	CF585B() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF585B o = new CF585B(); o.main(); o.flush();\n	}\n\n	byte[][] cc;\n	int n;\n	boolean bad(int h, int j) {\n		return j < n && cc[h][j] != '.';\n	}\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			n = sc.nextInt();\n			int k = sc.nextInt();\n			cc = new byte[3][];\n			for (int h = 0; h < 3; h++)\n				cc[h] = sc.next().getBytes();\n			boolean[][] dp = new boolean[n][3];\n			for (int h = 0; h < 3; h++)\n				dp[0][h] = cc[h][0] == 's';\n			for (int i = 0; i < n - 1; i++)\n				for (int h = 0; h < 3; h++) {\n					if (!dp[i][h])\n						continue;\n					int j = 3 * i + 1;\n					if (bad(h, j))\n						continue;\n					for (int h_ = 0; h_ < 3; h_++)\n						if (Math.abs(h_ - h) <= 1 && !bad(h_, j) && !bad(h_, j + 1) && !bad(h_, j + 2))\n							dp[i + 1][h_] = true;\n				}\n			println(dp[n - 1][0] || dp[n - 1][1] || dp[n - 1][2] ? ""YES"" : ""NO"");\n		}\n	}\n}\n","dfs and similar,graphs,shortest paths"
"import java.util.Scanner;\n\npublic class Main {\n	private void solve() {\n		Scanner scanner = new Scanner(System.in);\n		int n = scanner.nextInt();\n		int m = scanner.nextInt();\n		char[] s = scanner.next().toCharArray();\n\n		long ret = (long) n * (m - 1); // one char different\n\n		for (int i = 0; i < n - 1; i++) {\n			if (s[i] != s[i + 1]) {\n				ret += n * (m - 1); // as prefix and suffix\n			}\n		}\n\n		for (int i = 0, j = 0; i < n - 1;) {\n			if (s[i] == s[i + 1]) {\n				i++;\n				continue;\n			}\n			j = Math.max(j, i + 1);\n			char c1 = s[i];\n			char c2 = s[i + 1];\n			while (j < n && s[j] == ((j - i & 1) == 0 ? c1 : c2)) {\n				j++;\n			}\n			ret -= j - i - 1;\n			i++;\n		}\n\n		System.out.println(ret);\n		scanner.close();\n	}\n\n	public static void main(String[] args) {\n		new Main().solve();\n	}\n}\n","dp,greedy"
"import java.util.Scanner;\n\npublic class Main {\n	private void solve() {\n		Scanner scanner = new Scanner(System.in);\n		int n = scanner.nextInt();\n		int m = scanner.nextInt();\n		String s = scanner.next();\n		int[] a = new int[n];\n		for (int i = 0; i < n; i++) {\n			a[i] = s.charAt(i) - 'a';\n		}\n\n		long ans = n * (m - 1);\n		int[] same = new int[n];\n		for (int i = 0; i < n - 1; i++) {\n			if (i > 0 && a[i + 1] == a[i - 1]) {\n				same[i + 1] = same[i - 1] + 1;\n			}\n			if (a[i] != a[i + 1]) {\n				ans += (m - 1) * n;\n				int x = same[i];\n				int y = same[i + 1];\n				int length = (1 + Math.min(x, y)) * 2;\n				if (y > x) {\n					length++;\n				}\n				ans -= length - 1;\n			}\n		}\n		System.out.println(ans);\n		scanner.close();\n	}\n\n	public static void main(String[] args) {\n		new Main().solve();\n	}\n}\n","dp,greedy"
"import java.io.*;\nimport java.util.Scanner;\n\n\npublic class Main1 {\n	static int hashi(int x, int y)\n	{\n		if (x == y) return -1;\n		if (x > y) {\n			int temp = x;\n			x = y;\n			y = temp;\n		}\n		return x * 1000 + y;\n	}\n	public static void main(String[] args) {\n		\n		Scanner sc = new Scanner(System.in);\n		int n, m;\n		int id[] = new int[100005];\n		\n		 long ans = 0;\n		String s;//[100005];\n		\n		n = sc.nextInt();\n		m = sc.nextInt();\n		String str = sc.next();\n		s = "" "" + str;\n		\n			ans = (m - 1) * n;\n			for (int i = 2; i <= n; i++)\n				if (s.charAt(i - 1) != s.charAt(i))\n					ans +=  (i - 1) * (m - 1);\n			\n			for (int i = 1; i <= n - 1; i++)\n				if (s.charAt(i) != s.charAt(i + 1))\n					ans +=(n - i) * (m - 1);\n			\n			for (int i = 1; i <= n - 1; i++) \n				id[i] = hashi(s.charAt(i), s.charAt(i + 1));\n			\n			for (int i = 1; i <= n - 1; i++){\n				if (id[i] != -1 && (i == 1 || id[i] != id[i - 1])){\n					for (int j = i; j <= n - 1 && id[j] == id[i]; j++){\n						ans -= j - i + 1;\n					}\n						\n				}\n					\n			}\n				\n			\n			System.out.println(ans);\n		}\n	}\n\n","dp,greedy"
"import java.io.*;\nimport java.util.Scanner;\n\n\npublic class Main1 {\n	static int hashi(int x, int y)\n	{\n		if (x == y) return -1;\n		if (x > y) {\n			int temp = x;\n			x = y;\n			y = temp;\n		}\n		return x * 1000 + y;\n	}\n	public static void main(String[] args) {\n		\n		Scanner sc = new Scanner(System.in);\n		int n, m;\n		int id[] = new int[100005];\n		\n		 long ans = 0;\n		String s;//[100005];\n		\n		n = sc.nextInt();\n		m = sc.nextInt();\n		String str = sc.next();\n		s = "" "" + str;\n		\n			ans = (m - 1) * n;\n			for (int i = 2; i <= n; i++)\n				if (s.charAt(i - 1) != s.charAt(i))\n					ans +=  (i - 1) * (m - 1);\n			\n			for (int i = 1; i <= n - 1; i++)\n				if (s.charAt(i) != s.charAt(i + 1))\n					ans +=(n - i) * (m - 1);\n			\n			for (int i = 1; i <= n - 1; i++) \n				id[i] = hashi(s.charAt(i), s.charAt(i + 1));\n			\n			for (int i = 1; i <= n - 1; i++)\n				if (id[i] != -1 && (i == 1 || id[i] != id[i - 1]))\n					for (int j = i; j <= n - 1 && id[j] == id[i]; j++)\n						ans -= j - i + 1;\n			\n			System.out.println(ans);\n		}\n	}\n\n","dp,greedy"
"//package Competitive_Programming;\n\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class ModuloSum_Codeforces {\n\n	public static void main(String[] args) throws Exception {\n		// TODO Auto-generated method stub\n		Scanner sc =new Scanner(System.in);\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		ArrayList<Integer> arr = new ArrayList<Integer>();\n		ArrayList<Integer> dpArr = new ArrayList<>(); \n		int[] dp = new int[m];\n		\n		Arrays.fill(dp, 0);\n		\n		for(int i = 0; i < n; i++)\n			arr.add(sc.nextInt());\n		\n		if(!arr.contains(0) && n>=m ) {\n			System.out.println(""YES"");\n			return;\n		}\n		else {\n			for(int i = 0; i < n; i++) {\n				int x = arr.get(i);\n				\n				for(int j = 1; j < m; j++) {\n					if(dp[j] == 1 )\n						dpArr.add((j+x)%m);\n				}\n				for(int y:dpArr)\n					dp[y] = 1;\n				dpArr.clear();\n\n				dp[x%m] = 1;\n\n				\n				if(dp[0] == 1) {\n					System.out.println(""YES"");\n					return;\n				}\n			}\n			System.out.println(""NO"");\n		}\n			\n	}\n}\n","combinatorics,data structures,dp,two pointers"
"import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Scanner;\n \npublic class CF577B {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int n = s.nextInt();\n        int m = s.nextInt();\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = s.nextInt();\n        }\n        if(n > m){\n            System.out.println(""YES"");\n        }else{\n            boolean[][] mat = new boolean[n+1][m];\n            for (int i = 0; i < n; i++) {\n                int val = arr[i];\n                mat[i+1][val % m] = true;\n                for (int j = 0; j < m; j++) {\n                    if(mat[i][j]){\n                        mat[i+1][j] = true;\n                        mat[i+1][(j+val) % m] = true;\n                    }\n                }\n            }\n            if(mat[n][0]){\n                System.out.println(""YES"");\n            }else{\n                System.out.println(""NO"");\n            }\n \n        }\n    }\n \n \n}","combinatorics,data structures,dp,two pointers"
"import java.util.Scanner;\n\npublic class E200 {\n    public static void main(String[] args) {\n        Scanner scn = new Scanner(System.in);\n        int n = scn.nextInt();\n        int m = scn.nextInt();\n        int[] arr = new int[n];\n\n        if (n > m) {\n            System.out.println(""YES"");\n            return;\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i] = scn.nextInt();\n        }\n\n        boolean[][] dp = new boolean[n][m];\n\n        for (int index = 0; index < n; index++) {\n            int val = (arr[index]) % m;\n            dp[0][val] = true;\n        }\n        for (int index = 0; index < n - 1; index++) {\n            for (int sum = 0; sum < m; sum++) {\n                if (dp[index][sum]) {\n                    dp[index + 1][sum] = true;\n                    dp[index + 1][(sum + arr[index]) % m] = true;\n                }\n            }\n        }\n\n        if (dp[n - 1][0]) {\n            System.out.println(""YES"");\n        } else {\n            System.out.println(""NO"");\n        }\n    }\n}\n","combinatorics,data structures,dp,two pointers"
"// package com.company.codeforces;\n\nimport java.util.Scanner;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner input=new Scanner(System.in);\n\n\n            int n=input.nextInt();\n            int m=input.nextInt();\n            int a[]=new int[n];\n            for (int i = 0; i <n ; i++) {\n                a[i]=input.nextInt();\n            }\n            if (n>=m){\n                System.out.println(""YES"");\n\n            }else {\n                boolean dp[][] = new boolean[n + 1][m];\n                for (int i = 0; i < n; i++) {\n                    int val = a[i];\n                    dp[i + 1][val % m] = true;\n                    for (int j = 0; j < m; j++) {\n                        if (dp[i][j]) {\n                            dp[i + 1][j] = true;\n                            dp[i + 1][(j + val) % m] = true;\n\n                        }\n\n                    }\n\n                }\n                if (dp[n][0]) {\n                    System.out.println(""YES"");\n                } else {\n                    System.out.println(""NO"");\n                }\n            }\n\n    }\n}\n","combinatorics,data structures,dp,two pointers"
"//package bubble8;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class A {\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n	\n	void solve()\n	{\n		long K = nl();\n		int P = ni();\n		int n = ni();\n		int[] s = na(n);\n		for(int i = 0;i < n;i++)s[i] %= P;\n		int m = ni();\n		long[][] irs = new long[m*2][];\n		for(int i = 0;i < m;i++){\n			long J = nl();\n			int v = ni();\n			irs[i*2] = new long[]{J, 1, v%P};\n			irs[i*2+1] = new long[]{J-1, 0, v%P};\n		}\n		if(K == 0){\n			out.println(0);\n			return;\n		}\n		if(K == 1){\n			out.println(1%P);\n			return;\n		}\n		Arrays.sort(irs, new Comparator<long[]>() {\n			public int compare(long[] a, long[] b) {\n				return Long.compare(a[0], b[0]);\n			}\n		});\n		m *= 2;\n		for(int i = 0;i < m;i++){\n			if(irs[i][0]/n > (K-1)/n){\n				m = i;\n				break;\n			}\n		}\n		\n		SegmentTreeArray st = new SegmentTreeArray(s, P);\n		long[] base = st.node[1];\n		int[][] B = new int[][]{{(int)base[0], (int)base[1]}, {(int)base[2], (int)base[3]}};\n		\n		long e = 0;\n		int[] v = {1%P, 0};\n		// 0 1 1 4 2 3\n		for(int i = 0;i < m;){\n			int j = i;\n			for(;j < m && irs[i][0]/n == irs[j][0]/n;)j++;\n			if(e < irs[i][0]/n){\n				v = pow(B, v, irs[i][0]/n-e, P);\n			}\n			for(int k = i;k < j;k++){\n				st.update((int)(irs[k][0]%n), (int)(irs[k][1]), (int)(irs[k][2]));\n			}\n			long[] ls = st.sum(0, (int)(Math.min(n, K-1-irs[i][0]/n*n)));\n			if(ls != null){\n				long nv0 = (v[0]*ls[0]+v[1]*ls[1])%P;\n				long nv1 = (v[0]*ls[2]+v[1]*ls[3])%P;\n				v[0] = (int)nv0; v[1] = (int)nv1;\n			}\n			\n			e = irs[i][0]/n+1;\n			for(int k = i;k < j;k++){\n				st.update((int)(irs[k][0]%n), (int)(irs[k][1]), s[(int)((irs[k][0]+1-irs[k][1])%n)]);\n			}\n			\n			i = j;\n		}\n		if(e < (K-1)/n){\n			v = pow(B, v, (K-1)/n-e, P);\n		}\n		if(e <= (K-1)/n){\n			long[] ls = st.sum(0, (int)((K-1)%n));\n			if(ls != null){\n				long nv0 = (v[0]*ls[0]+v[1]*ls[1])%P;\n				long nv1 = (v[0]*ls[2]+v[1]*ls[3])%P;\n				v[0] = (int)nv0; v[1] = (int)nv1;\n			}\n		}\n		\n		if(!(v[0] >= 0 && v[0] < P))throw new RuntimeException();\n		out.println(v[0]);\n	}\n	\n	// A^e*v\n	public static int[] pow(int[][] A, int[] v, long e, int mod)\n	{\n		int[][] MUL = A;\n		for(int i = 0;i < v.length;i++)v[i] %= mod;\n		for(;e > 0;e>>>=1) {\n			if((e&1)==1)v = mul(MUL, v, mod);\n			MUL = p2(MUL, mod);\n		}\n		return v;\n	}\n	\n	\n	// int matrix * int vector\n	public static int[] mul(int[][] A, int[] v, int mod)\n	{\n		int m = A.length;\n		int n = v.length;\n		int[] w = new int[m];\n		for(int i = 0;i < m;i++){\n			long sum = 0;\n			for(int k = 0;k < n;k++){\n				sum += (long)A[i][k] * v[k];\n				sum %= mod;\n			}\n			w[i] = (int)sum;\n		}\n		return w;\n	}\n	\n	// int matrix^2 (cannot ensure negative values)\n	public static int[][] p2(int[][] A, int mod)\n	{\n		int n = A.length;\n		int[][] C = new int[n][n];\n		for(int i = 0;i < n;i++){\n			for(int j = 0;j < n;j++){\n				long sum = 0;\n				for(int k = 0;k < n;k++){\n					sum += (long)A[i][k] * A[k][j];\n					sum %= mod;\n				}\n				C[i][j] = (int)sum;\n			}\n		}\n		return C;\n	}\n\n	\n	public static class SegmentTreeArray {\n		public int M, H, N;\n		public long[][] node;\n		public int P;\n		\n		public SegmentTreeArray(int[] a, int P)\n		{\n			this.P = P;\n			N = a.length;\n			M = Integer.highestOneBit(Math.max(N-1, 1))<<2;\n			H = M>>>1;\n			\n			node = new long[M][];\n			for(int i = 0;i < N;i++){\n				long[] item = new long[]{a[(i+1)%N], a[i], 1, 0};\n				node[H+i] = item;\n			}\n			for(int i = H-1;i >= 1;i--)propagate(i);\n		}\n		\n		private void propagate(int cur)\n		{\n			node[cur] = prop2(node[2*cur], node[2*cur+1], node[cur]);\n		}\n		\n		private long[] prop2(long[] L, long[] R, long[] C)\n		{\n			if(L != null && R != null){\n				if(C == null)C = new long[4];\n				// L[0] L[1]\n				// L[2] L[3]\n				// R[0] R[1]\n				// R[2] R[3]\n				C[0] = (R[0]*L[0] + R[1]*L[2])%P;\n				C[1] = (R[0]*L[1]+R[1]*L[3])%P;\n				C[2] = (R[2]*L[0]+R[3]*L[2])%P;\n				C[3] = (R[2]*L[1]+R[3]*L[3])%P;\n				\n				return C;\n			}else if(L != null){\n				return prop1(L, C);\n			}else if(R != null){\n				return prop1(R, C);\n			}else{\n				return null;\n			}\n		}\n		\n		private long[] prop1(long[] L, long[] C)\n		{\n			if(C == null)C = new long[4];\n			for(int i = 0;i < 4;i++)C[i] = L[i];\n			return C;\n		}\n		\n		public void update(int x, int e, int v) {\n			node[H+x][e] = v;\n			for(int i = H+x>>>1;i >= 1;i>>>=1)propagate(i);\n		}\n		\n		public long[] sum(int l, int r) {\n			return l >= r ? null : sum(l, r, 0, H, 1);\n		}\n		\n		protected long[] sum(int l, int r, int cl, int cr, int cur)\n		{\n			if(l <= cl && cr <= r){\n				return node[cur];\n			}else{\n				long[] L = null, R = null;\n				int mid = cl+cr>>>1;\n				if(cl < r && l < mid){\n					L = sum(l, r, cl, mid, 2*cur);\n				}\n				if(mid < r && l < cr){\n					R = sum(l, r, mid, cr, 2*cur+1);\n				}\n				return prop2(L, R, null);\n			}\n		}\n	}	\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new A().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	private int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n	\n	private char[][] nm(int n, int m)\n	{\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n	\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n	\n	private int ni()\n	{\n		int num = 0, b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","data structures,math,matrices"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\nimport java.util.*;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\npublic class A {\n \n	static final int mod = 1000000007;\n	static final long temp = 998244353;\n	static final long MOD = 1000000007;\n	static final long M = (long)1e9+7;\n \n	\n	static class Pair implements Comparable<Pair>\n	{\n		int first, second;\n		public Pair(int aa, int bb)\n		{\n			first = aa; second = bb;\n		}\n		public int compareTo(Pair p)\n		{\n			if(first == p.first) return (int)(second - p.second);\n			return (int)(first - p.first);\n		}\n	}\n	\n	/*\n	 * IO FOR 2D GRID IN JAVA\n	 * 	char[][] grid = new char[n][m];\n			for(int i = 0;i<n;i++)\n			{\n				char[] s = sc.next().toCharArray();\n				for(int j = 0;j<m;j++)\n				{\n					grid[i][j] = s[j];\n				}\n			}\n	 * */\n	\n	static class Reader {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n		String next() {\n			while (!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		\n		int[] readArray(int n) throws IOException {\n			int[] a=new int[n];\n			for (int i=0; i<n; i++) a[i]=nextInt();\n			return a;\n		}\n		\n		long[] longReadArray(int n) throws IOException {\n			long[] a=new long[n];\n			for (int i=0; i<n; i++) a[i]=nextLong();\n			return a;\n		}\n		\n		\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n	}\n	\n \n		public static boolean isPrime(int n) \n		{\n			if(n == 1)\n			{\n				return false;\n			}\n			for(int i = 2;i*i<=n;i++)\n			{\n				if(n%i == 0)\n				{\n					return false;\n				}\n			}\n			return true;\n	}\n	\n	public static List<Integer> SieveList(int n)\n	{\n		boolean prime[] = new boolean[n+1];\n		Arrays.fill(prime, true);\n		\n		List<Integer> l = new ArrayList<>();\n		for (int p=2; p*p<=n; p++) \n		{ \n			if (prime[p] == true) \n			{ 	\n			    for(int i=p*p; i<=n; i += p) \n				{\n				    prime[i] = false; \n				}	\n			} \n		} \n \n		for (int p=2; p<=n; p++) \n		{\n		    if (prime[p] == true)\n		    {\n		       l.add(p); \n		    }\n		}\n		\n		return l;\n	}\n	\n	\n	public static int gcd(int a, int b)\n	{\n		if(b == 0)\n		 return a;\n		\n		else\n		return gcd(b,a%b);\n	} \n \n		public static int lcm(int a, int b)\n	    {\n	        return (a / gcd(a, b)) * b;\n	    }\n	\n	public static long LongGCD(long a, long b)\n	{\n		if(b == 0)\n			 return a;\n			\n			else\n			return LongGCD(b,a%b);\n	}\n	\n		public static long LongLCM(long a, long b)\n	    {\n	        return (a / LongGCD(a, b)) * b;\n	    }\n	\n		public static int phi(int n)  //euler totient function\n	    { \n	        int result = 1; \n	        for (int i = 2; i < n; i++) \n	            if (gcd(i, n) == 1) \n	                result++; \n	        return result; \n	    }\n	\n	public static long fastPow(long x, long n) //include mod at each step if asked and in args of fn too\n	{\n		if(n == 0)\n			return 1;\n		else if(n%2 == 0)\n			return fastPow(x*x,n/2);\n		else\n			return x*fastPow(x*x,(n-1)/2);\n	}\n	\n	\n	   public static long modPow(long x, long y, long p)\n	    {\n	        long res = 1;\n	        x = x % p;\n	 \n	        while (y > 0) {\n	            if (y % 2 == 1)\n	                res = (res * x) % p;\n	 \n	            y = y >> 1; \n	            x = (x * x) % p;\n	        }\n	        return res;\n	    }\n	   \n	   static long modInverse(long n, long p)\n	    {\n	        return modPow(n, p - 2, p);\n	    }\n	 \n	    // Returns nCr % p using Fermat's little theorem.\n	    \n	    public static long nCrModP(long n, long r,long p)\n	    {\n	          if (n<r) \n	              return 0;\n	          \n	        if (r == 0)\n	            return 1;\n	 \n	        long[] fac = new long[(int)(n) + 1];\n	        fac[0] = 1;\n	 \n	        for (int i = 1; i <= n; i++)\n	            fac[i] = fac[i - 1] * i % p;\n	 \n	        return (fac[(int)(n)] * modInverse(fac[(int)(r)], p)\n	                % p * modInverse(fac[(int)(n - r)], p)\n	                % p)\n	            % p;\n	    }\n	    \n	    public static long nCr(long n, long r)\n	    {\n	    	long ans = 1;\n	    	for(long i = 1,j = n;i<=r;i++,j--)\n	    	{\n	    		ans = ans * j / i;\n	    	}\n	    	return ans;\n	    }\n \n		public static void Sort(int[] a) {\n			List<Integer> l=new ArrayList<>();\n			for (int i : a) l.add(i);\n			Collections.sort(l);\n//			Collections.reverse(l);  //Use to Sort decreasingly \n			for (int i=0; i<a.length; i++) a[i]=l.get(i);\n		}\n		\n		public static void ssort(char[] a)\n		{\n			List<Character> l = new ArrayList<>();\n			for (char i : a) l.add(i);\n			Collections.sort(l);\n			for (int i=0; i<a.length; i++) a[i]=l.get(i);\n		}\n		\n		\n		//Modular Operations for Addition and Multiplication. \n		\n		   public static long perfomMod(long x)\n		   {\n		        return ((x%M + M)%M);\n		    }\n		   public static long addMod(long a, long  b)\n		   {\n		        return perfomMod(perfomMod(a)+perfomMod(b));\n		    }\n		   public static long mulMod(long  a, long b)\n		   {\n		        return perfomMod(perfomMod(a)*perfomMod(b));\n		   }\n		\n		   public static int LowerBound(int a[], int x) \n		   {\n				  int l=-1,r=a.length;\n				  while(l+1<r) {\n				    int m=(l+r)>>>1;\n				    if(a[m]>=x) r=m;\n				    else l=m;\n				  }\n				  return r;\n			}\n		\n		   \n			public static int UpperBound(int a[], int x) \n			{\n			    int l=-1;\n			    int r=a.length;\n			    while(l+1<r) {\n			       int m=(l+r)>>>1;\n			       if(a[m]<=x) l=m;\n			       else r=m;\n			    }\n			    return l+1;\n			}\n	\n		public static long fn(int a, int b, int c, int ans)\n		{\n			if(b + c > a) return 0;\n			ans = min((a - b - c),ans);\n			return 1L * (ans + 2)*(ans + 1)/2;\n		}\n	\n	public static void main(String[] args) throws IOException \n	{\n		Reader sc = new Reader();\n		PrintWriter fout = new PrintWriter(System.out);\n		\n			int a = sc.nextInt(), b = sc.nextInt(), c = sc.nextInt(), n = sc.nextInt();\n			long res = 0;\n			for(int i = 0;i<n+1;i++)\n			{\n				res += (1L * (i + 1) * (i + 2))/2;\n				res -= fn(a + i, b, c, (n - i));\n				res -= fn(b + i,a,c,(n - i));\n				res -= fn(c + i,a,b,(n - i));\n			}\n			System.out.println(res);\n		\n		\n		fout.close();\n	}\n}","combinatorics,implementation,math"
"import java.util.*;\n\npublic class A {\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    long[] a = new long[3];\n    a[0] = sc.nextLong();\n    a[1] = sc.nextLong();\n    a[2] = sc.nextLong();\n    long l = sc.nextLong();\n    \n    long total = (l+1)*(l+2)*(l+3)/6;\n    \n    for(int i = 0; i < 3; i++) {\n      for(long la = 0L; la <= l; la++) {\n        long x = Math.min(a[i] - a[(i+1)%3] - a[(i+2)%3] + la, l - la);\n        if(x >= 0) {\n          total -= (x+1)*(x+2)/2;\n        }\n      }\n    }\n    \n    System.out.println("""" + total);\n  }\n\n}\n","combinatorics,implementation,math"
"//package labels.math.math_02_combinatorics.p_01_cf_571_A;\n\nimport java.util.Scanner;\n\n/**\n *\n * */\npublic class Main {\n	static long wrong(long a, long b, long c, long l) {\n		long ret = 0;\n		for(long i = 0; i <= l; i++) {\n			long x = Math.min(l - i, c + i - a - b);\n			if(x >= 0) {\n				ret += (x + 2) * (x + 1) / 2;\n			}\n		}\n\n		return ret;\n	}\n\n	public static void main(String[] args){\n		Scanner sc = new Scanner(System.in);\n		int a = sc.nextInt(), b = sc.nextInt(), c = sc.nextInt();\n		int l = sc.nextInt();\n\n		long ans = 0;\n		for(long i = 0; i <= l; i++) {\n			ans += (i + 2) * (i + 1) / 2;\n		}\n		ans = ans - wrong(a, b, c, l) - wrong(a, c, b, l) - wrong(b, c, a, l);\n		System.out.println(ans);\n	}\n}\n","combinatorics,implementation,math"
"import java.util.*;\nimport java.io.*;\npublic class Main {\nstatic long calFunc(int a,int b,int c,int l){\n	long ret = 0;\n	for(int i = 0;i <= l;i++){\n		int t = Math.min(l - i,a - b - c + i);\n		if(t < 0)continue;\n		ret += (t + 1)*1L*(t + 2)/2;\n	}\n	return ret;\n}	\npublic static void main(String [] args)throws Exception{\n	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	StringTokenizer st = new StringTokenizer(br.readLine());\n	int a = Integer.parseInt(st.nextToken());\n	int b = Integer.parseInt(st.nextToken());\n	int c = Integer.parseInt(st.nextToken());\n	int l = Integer.parseInt(st.nextToken());\n	\n	long tot = (l + 1)*1L*(l + 2)*(l + 3)/6;\n	System.out.println(tot - calFunc(a,b,c,l) - calFunc(b,a,c,l) - calFunc(c,a,b,l));	\n}\n}","combinatorics,implementation,math"
"import java.util.Scanner;\n\npublic class PlayGround {\n    public static void main(String... args) {\n        Scanner in = new Scanner(System.in);\n        int a1 = in.nextInt(), b1 = in.nextInt(), a2 = in.nextInt(),\n                b2 = in.nextInt(), a3 = in.nextInt(), b3 = in.nextInt();\n        if (check(a2 + a3, Math.max(b2, b3), a1, b1) || (check(a2 + b3, Math.max(b2, a3), a1, b1))\n                || (check(b2 + a3, Math.max(a2, b3), a1, b1))\n                || (check(b2 + b3, Math.max(a2, a3), a1, b1)))\n            System.out.println(""YES"");\n        else\n            System.out.println(""NO"");\n    }\n\n    private static boolean check(int a, int b, int c, int d) {\n        if (a <= c && b <= d)\n            return true;\n        if (a <= d && b <= c)\n            return true;\n        return false;\n    }\n}\n\n","constructive algorithms,implementation"
"import java.util.Scanner;\n\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n\n		int a1 = sc.nextInt();\n		int b1 = sc.nextInt();\n		int a2 = sc.nextInt();\n		int b2 = sc.nextInt();\n		int a3 = sc.nextInt();\n		int b3 = sc.nextInt();\n		System.out.println(solve(a1, b1, a2, b2, a3, b3) ? ""YES"" : ""NO"");\n\n		sc.close();\n	}\n\n	static boolean solve(int a1, int b1, int a2, int b2, int a3, int b3) {\n		return check(a1, b1, a2, b2, a3, b3) || check(a1, b1, a2, b2, b3, a3) || check(a1, b1, b2, a2, a3, b3)\n				|| check(a1, b1, b2, a2, b3, a3) || check(b1, a1, a2, b2, a3, b3) || check(b1, a1, a2, b2, b3, a3)\n				|| check(b1, a1, b2, a2, a3, b3) || check(b1, a1, b2, a2, b3, a3);\n	}\n\n	static boolean check(int sumLimit, int maxLimit, int toSum1, int toMax1, int toSum2, int toMax2) {\n		return toSum1 + toSum2 <= sumLimit && Math.max(toMax1, toMax2) <= maxLimit;\n	}\n}","constructive algorithms,implementation"
"/******************************************************************************\n\nWelcome to GDB Online.\nGDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,\nC#, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.\nCode, Compile, Run and Debug online from anywhere in world.\n\n*******************************************************************************/\nimport java.util.*;\n\npublic class Main\n{\n	\n	    \n	\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		\n		int a= scan.nextInt();\n		int b= scan.nextInt();\n		int a1= scan.nextInt();\n		int b1= scan.nextInt();\n		int a2= scan.nextInt();\n		int b2= scan.nextInt();\n		\n		// case 1\n        if((a1+a2)<=a && Math.max(b1,b2)<=b)\n        System.out.println(""YES"");\n        else if((a1+a2)<=b && Math.max(b1,b2)<=a)\n        System.out.println(""YES"");\n        \n        // case 2\n        else if((a1+b2)<=a && Math.max(b1,a2)<=b)\n        System.out.println(""YES"");\n        else if((a1+b2)<=b && Math.max(b1,a2)<=a)\n        System.out.println(""YES"");\n        \n        // case 3\n        else if((b1+a2)<=a && Math.max(a1,b2)<=b)\n        System.out.println(""YES"");\n        else if((b1+a2)<=b && Math.max(a1,b2)<=a)\n        System.out.println(""YES"");\n        \n        // case 4\n        else if((b1+b2)<=a && Math.max(a1,a2)<=b)\n        System.out.println(""YES"");\n        else if((b1+b2)<=b && Math.max(a1,a2)<=a)\n        System.out.println(""YES"");\n        else\n        System.out.println(""NO"");\n		\n	}\n}\n\n						   	 		  	 		    	 	  			","constructive algorithms,implementation"
"/******************************************************************************\n\nWelcome to GDB Online.\nGDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,\nC#, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.\nCode, Compile, Run and Debug online from anywhere in world.\n\n*******************************************************************************/\nimport java.util.*;\n\npublic class Codeforces\n{\n\n	\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		\n		int a= scan.nextInt();\n		int b= scan.nextInt();\n		int a1= scan.nextInt();\n		int b1= scan.nextInt();\n		int a2= scan.nextInt();\n		int b2= scan.nextInt();\n		\n		// case 1\n        if((a1+a2)<=a && Math.max(b1,b2)<=b)\n        System.out.println(""YES"");\n        else if((a1+a2)<=b && Math.max(b1,b2)<=a)\n        System.out.println(""YES"");\n        \n        // case 2\n        else if((a1+b2)<=a && Math.max(b1,a2)<=b)\n        System.out.println(""YES"");\n        else if((a1+b2)<=b && Math.max(b1,a2)<=a)\n        System.out.println(""YES"");\n        \n        // case 3\n        else if((b1+a2)<=a && Math.max(a1,b2)<=b)\n        System.out.println(""YES"");\n        else if((b1+a2)<=b && Math.max(a1,b2)<=a)\n        System.out.println(""YES"");\n        \n        // case 4\n        else if((b1+b2)<=a && Math.max(a1,a2)<=b)\n        System.out.println(""YES"");\n        else if((b1+b2)<=b && Math.max(a1,a2)<=a)\n        System.out.println(""YES"");\n        else\n        System.out.println(""NO"");\n		\n	}\n}\n","constructive algorithms,implementation"
"import java.util.*;\n\n\npublic class Solve {\n    private static Scanner sc;\n	public static void main(String[] args) {\n    	long h,q,left,right,fl=0;\n    	sc = new Scanner(System.in);\n    	h=sc.nextLong();\n    	q=sc.nextLong();\n    	left=(long) Math.pow(2, h-1);\n    	right=(long )Math.pow(2, h)-1;\n    	ArrayList<pair> s=new ArrayList<pair>();\n    	for(int j=0;j<q;j++){\n    		long i=sc.nextLong(),l=sc.nextLong(),r=sc.nextLong(),a=sc.nextLong();\n    		while(i<h){\n    			l=l*2;\n    			r=r*2+1;\n    			i++;\n    		}\n    		if(a==1){\n    			if(l>right || r<left){\n    				fl=1;\n    			}else{\n    				left=Math.max(left, l);\n    				right=Math.min(right, r);\n    			}\n    		}else{\n    			s.add(new pair(l,r));\n    		}\n    	}\n    	Collections.sort(s);\n       	for(int i=0;i<s.size();i++){\n       		\n       		if(s.get(i).l<=left && s.get(i).r<=right && s.get(i).r>=left){\n    			left=Math.max(s.get(i).r+1,left);\n    			//s.remove(i);\n    		}\n    	}\n       	for(int i=0;i<s.size();i++){\n       		s.get(i).flipFlag();\n       	}\n       	Collections.sort(s);\n       	for(int i=0;i<s.size();i++){\n       		if(s.get(i).l>=left && s.get(i).r>=right && s.get(i).l<=right){\n    			right=Math.min(right,s.get(i).l-1);\n    			//s.remove(i);\n    		}\n    	}\n       	if(right<left){\n       		fl=1;\n       	}else{\n       		for(int i=0;i<s.size();i++){\n        		if(s.get(i).l<=left && s.get(i).r>=right){\n        			fl=1;\n        			s.remove(i);\n        		}\n        	}\n       	}\n       	if(fl==1){\n       		System.out.println(""Game cheated!"");\n       	}else if(left==right){\n       		System.out.println(left+"""");\n       	}else System.out.println(""Data not sufficient!"");\n    }\n}\nclass pair implements Comparable<pair>{\n	long l,r;\n	boolean fl=true;\n	public void flipFlag(){\n		fl=!fl;\n	}\n	public pair(long x,long y){\n		l=x;\n		r=y;\n	}\n	\n	@Override\n	public int compareTo(pair o) {\n		if(fl){\n			if(this.l<o.l) return -1;\n			else if(this.l==o.l) return 0;\n			return 1;\n		}else{\n			if(this.r>o.r) return -1;\n			else if(this.r==o.r) return 0;\n			return 1;\n		}\n	}\n}","data structures,implementation,sortings"
"import java.io.*;\nimport java.util.*;\npublic final class guess_out_2\n{\n    static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n	static FastScanner sc=new FastScanner(br);\n    static PrintWriter out=new PrintWriter(System.out);\n	static Random rnd=new Random();\n	static List<Pair> list=new ArrayList<Pair>();\n	\n    public static void main(String args[]) throws Exception\n    {\n		long n=sc.nextInt(),q=sc.nextInt();list.add(new Pair(1L<<n,1L<<n));\n		while(q>0)\n		{\n			long idx=sc.nextLong(),l=sc.nextLong(),r=sc.nextLong();int ans=sc.nextInt();\n			if(ans==0)\n			{\n				long idx1=idx,idx2=idx;\n				while(idx1!=n)\n				{\n					l*=2L;idx1++;\n				}\n				while(idx2!=n)\n				{\n					r=(r*2L)+1;idx2++;\n				}\n				list.add(new Pair(l,r));\n			}\n			else\n			{\n				long idx1=idx,idx2=idx;\n				if(l!=(1L<<(idx-1L)))\n				{\n					while(idx1!=n)\n					{\n						l=(l*2L);idx1++;\n					}\n					list.add(new Pair(1L<<(n-1),l-1));\n				}\n				if(r!=(1L<<idx)-1)\n				{\n					while(idx2!=n)\n					{\n						r=(r*2L)+1;idx2++;\n					}\n					list.add(new Pair(r+1,(1L<<n)-1));\n				}\n			}\n			q--;\n		}\n		Collections.sort(list);boolean get=false,ans=false;long now=(1L<<(n-1));long res=-1;\n		/*\n		for(Pair p:list)\n		{\n			out.println(p.l+"" ""+p.r);\n		}\n		*/\n		for(int i=0;i<list.size();i++)\n		{\n			if(list.get(i).l>now)\n			{\n				long size=(list.get(i).l-now);\n				if(size>1)\n				{\n					get=true;ans=false;break;\n				}\n				else if(get)\n				{\n					ans=false;break;\n				}\n				else\n				{\n					get=true;ans=true;res=now;now=list.get(i).r+1;\n				}\n			}\n			else\n			{\n				now=Math.max(now,list.get(i).r+1);\n			}\n		}\n		if(!get)\n		{\n			out.println(""Game cheated!"");\n		}\n		else if(get && !ans)\n		{\n			out.println(""Data not sufficient!"");\n		}\n		else\n		{\n			out.println(res);\n		}\n		out.close();\n    }\n}\nclass Pair implements Comparable<Pair>\n{\n	long l,r;\n	public Pair(long l,long r)\n	{\n		this.l=l;this.r=r;\n	}\n	public int compareTo(Pair x)\n	{\n		return Long.compare(this.l,x.l);\n	}\n}\nclass FastScanner\n{\n    BufferedReader in;\n    StringTokenizer st;\n\n    public FastScanner(BufferedReader in) {\n        this.in = in;\n    }\n	\n    public String nextToken() throws Exception {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n	\n	public String next() throws Exception {\n		return nextToken().toString();\n	}\n	\n    public int nextInt() throws Exception {\n        return Integer.parseInt(nextToken());\n    }\n\n    public long nextLong() throws Exception {\n        return Long.parseLong(nextToken());\n    }\n\n    public double nextDouble() throws Exception {\n        return Double.parseDouble(nextToken());\n    }\n}","data structures,implementation,sortings"
"import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\npublic class D {\n\n    private static class Range implements Comparable<Range> {\n        private final long left;\n        private final long right;\n        private final boolean containsExit;\n\n        public Range(long left, long right, boolean containsExit) {\n            this.left = left;\n            this.right = right;\n            this.containsExit = containsExit;\n        }\n\n        public long getLeft() {\n            return left;\n        }\n\n        public long getRight() {\n            return right;\n        }\n\n        public boolean isContainsExit() {\n            return containsExit;\n        }\n\n        @Override\n        public int compareTo(Range o) {\n            return Long.compare(getLeft(), o.getLeft());\n        }\n    }\n\n    private static String findExit(List<Range> ranges, int height) {\n        List<Range> positiveAnswers = ranges.stream().filter(Range::isContainsExit).collect(Collectors.toList());Collectors.toList();\n        List<Range> negativeAnswers = ranges.stream().filter(r -> !r.isContainsExit()).sorted().collect(Collectors.toList());Collectors.toList();\n\n        long left = 1L << (height - 1);\n        long right = 2L * left;\n        for (Range range : positiveAnswers) {\n            if (range.getRight() <= left || right <= range.getLeft()) {\n                return ""Game cheated!"";\n            }\n            left = Math.max(range.getLeft(), left);\n            right = Math.min(range.getRight(), right);\n        }\n\n        long rightBound = left;\n        long lastSkipStart = 0L;\n        long skipCount = 0L;\n        for (Range range : negativeAnswers) {\n            if (range.getRight() <= rightBound) {\n                continue;\n            }\n            if (range.getLeft() >= right) {\n                continue;\n            }\n            if (range.getLeft() > rightBound) {\n                skipCount += range.getLeft() - rightBound;\n                lastSkipStart = rightBound;\n            }\n            rightBound = Math.max(range.getRight(), rightBound);\n        }\n\n        if (skipCount == 0L && right - rightBound == 1L) {\n            return String.valueOf(rightBound);\n        }\n\n        if (skipCount == 1L && rightBound >= right) {\n            return String.valueOf(lastSkipStart);\n        }\n\n        if (skipCount == 0L && rightBound >= right) {\n            return ""Game cheated!"";\n        }\n        return ""Data not sufficient!"";\n    }\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int h = s.nextInt();\n        int q = s.nextInt();\n        List<Range> ranges = new ArrayList<>();\n        for (int i = 0; i < q; i++) {\n            int level = s.nextInt();\n            long left = s.nextLong();\n            long right = s.nextLong();\n            int answer = s.nextInt();\n\n            long shift = 1L <<  (h - level);\n            long leftLeaf = left * shift;\n            long rightLeaf = right * shift + shift;\n\n            ranges.add(new Range(leftLeaf, rightLeaf, answer == 1));\n        }\n        System.out.println(findExit(ranges, h));\n    }\n}","data structures,implementation,sortings"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\npublic class P558E {\n\n    private static final long[] P2 = new long[51];\n    static {\n        P2[0] = 1;\n        for (int i = 1; i<=50; i++) {\n            P2[i] = P2[i-1] * 2;\n        }\n    }\n\n    private final int h;\n    private final SortedMap<Long, Long> intervals = new TreeMap<>();\n\n    public P558E(int h) {\n        this.h = h;\n        intervals.put(P2[h-1], P2[h]);\n        // logState();\n    }\n\n    public void process(int i, long li, long ri, boolean a) {\n        if (intervals.isEmpty()) {\n            return;\n        }\n        final long l = li * P2[h-i];\n        final long r = (ri + 1) * P2[h-i];\n        // System.err.println((a ? ""+"" : ""-"") + "" ["" + l + "", "" + r + "")"");\n        if (a) {\n            final SortedMap<Long, Long> i1 = intervals.headMap(l);\n            if (!i1.isEmpty()) {\n                final long r2 = i1.get(i1.lastKey());\n                i1.clear();\n                if (r2 > l) {\n                    intervals.put(l, r2);\n                }\n            }\n            final SortedMap<Long, Long> i2 = intervals.subMap(l, r);\n            if (!i2.isEmpty()) {\n                final long l2 = i2.lastKey();\n                i2.put(l2, Math.min(i2.get(l2), r));\n            }\n            intervals.tailMap(r).clear();\n        } else {\n            final SortedMap<Long, Long> i1 = intervals.headMap(l);\n            if (!i1.isEmpty()) {\n                final long l2 = i1.lastKey();\n                final long r2 = i1.get(l2);\n                i1.put(l2, Math.min(r2, l));\n                if (r2 > r) {\n                    intervals.put(r, r2);\n                }\n            }\n            final SortedMap<Long, Long> i2 = intervals.subMap(l, r);\n            if (!i2.isEmpty()) {\n                final long r2 = i2.get(i2.lastKey());\n                i2.clear();\n                if (r2 > r) {\n                    intervals.put(r, r2);\n                }\n            }\n        }\n\n        // logState();\n    }\n\n    private void logState() {\n        if (intervals.isEmpty()) {\n            System.err.println(""--"");\n        } else {\n            for (java.util.Map.Entry<Long, Long> e : intervals.entrySet()) {\n                System.err.print(""["" + e.getKey() + "" "" + e.getValue() + "")"" + "" "");\n            }\n            System.err.println();\n        }\n    }\n\n    public long getResult() throws P558EException {\n        if (intervals.isEmpty()) {\n            throw new P558EException(""Game cheated!"");\n        }\n        if (intervals.size() == 1) {\n            final long l = intervals.firstKey();\n            final long r = intervals.get(l);\n            if (r == l+1) {\n                return l;\n            }\n        }\n        throw new P558EException(""Data not sufficient!"");\n    }\n\n    public static class P558EException extends Exception {\n        public P558EException(String message) {\n            super(message);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        final BufferedReader in = new BufferedReader(\n            new InputStreamReader(System.in));\n\n        String[] ss = in.readLine().split("" "", 2);\n        final int h = Integer.parseInt(ss[0]);\n        final int q = Integer.parseInt(ss[1]);\n        final P558E p558e = new P558E(h);\n\n        for (int k = 0; k < q; k++) {\n            ss = in.readLine().split("" "", 4);\n            final int i = Integer.parseInt(ss[0]);\n            final long li = Long.parseLong(ss[1]);\n            final long ri = Long.parseLong(ss[2]);\n            final boolean a = (Integer.parseInt(ss[3]) != 0);\n            p558e.process(i, li, ri, a);\n        }\n\n        try {\n            System.out.println(p558e.getResult());\n        } catch (P558EException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n","data structures,implementation,sortings"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF550E extends PrintWriter {\n	CF550E() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF550E o = new CF550E(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int[] aa = new int[n];\n		for (int i = 0; i < n; i++)\n			aa[i] = sc.nextInt();\n		if (aa[n - 1] == 1) {\n			println(""NO"");\n			return;\n		}\n		if (n >= 2 && aa[n - 2] == 0 && aa[n - 1] == 0) {\n			boolean one = true;\n			for (int i = 0; i < n - 2; i++)\n				if (aa[i] != 1) {\n					one = false;\n					break;\n				}\n			if (one) {\n				println(""NO"");\n				return;\n			}\n		}\n		println(""YES"");\n		if (n == 1) {\n			println(""0"");\n			return;\n		}\n		for (int i = 0; i < n - 2; i++)\n			print(""("" + aa[i] + ""->"");\n		print(aa[n - 2]);\n		for (int i = 0; i < n - 2; i++)\n			print("")"");\n		println(""->"" + aa[n - 1]);\n	}\n}\n","constructive algorithms,greedy,implementation,math"
"import java.io.*;\nimport java.util.*;\n\npublic class A {\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int n = in.nextInt();\n		\n		int[] a = new int[n];\n		for(int i=0; i<n; i++) {\n			a[i] = in.nextInt();\n		}\n		\n		Solver A = new Solver(a, n);\n		A.solve();\n		//System.out.println(A.solve());\n	}\n\n}\n\nclass Solver {\n	int[] a;\n	int n;\n	int t;\n	public Solver(int[] a, int n) {\n		this.a = a;\n		this.n = n;\n		for(int i=0; i<n; i++) {\n			if(a[i] == 0) t++;\n		}\n	}\n	\n	public void solve() {\n		if(n == 1) {\n			if(a[0] == 0) {\n				System.out.println(""YES\n0"");\n				return;\n			}\n			else {\n				System.out.println(""NO"");\n				return;\n			}\n		}\n		\n		if(a[n-1] == 1 || a[n-2] == 0 && t == 2) {\n			System.out.println(""NO"");\n			return;\n		}\n		\n		System.out.println(""YES"");\n		fi(0, n - 2, """");\n		//res += """" + fi(0, n - 2, """");\n		System.out.println(""->0"");\n	}\n	\n	private void fi(int cur, int nn, String aa) {\n		if(nn == 0) {\n			System.out.print("""" + a[cur]);\n			//String aaa = """" + a[cur];\n			//return aaa;\n		}\n		else {\n			System.out.print(""("" + a[cur] + ""->"");\n			fi(cur + 1, nn - 1, aa);\n			System.out.print("")"");\n			//aa += ""("";\n			//aa += a[cur];\n			//aa += ""->"";\n			//aa += fi(cur + 1, nn - 1, aa);\n			//aa += "")"";\n			//return aa;\n		}\n	}\n}\n","constructive algorithms,greedy,implementation,math"
"import java.util.*;\n\npublic class CF550E {\n    private static String range(int[] a, int n, int m) {\n        StringBuilder s = new StringBuilder();\n        for (int i = n; i < m; ++i)\n            s.append(a[i]).append(""->"");\n        return s.toString();\n    }\n    public static void main (String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; ++i)\n            a[i] = scan.nextInt();\n        if (a[n-1] == 1) // ... -> 1 == 1\n            System.out.println(""NO"");\n        else if (n == 1) // 0\n            System.out.printf(""YES\n0\n"");\n        else if (a[n-2] == 1) // ... -> 1 -> 0 == 0\n            System.out.printf(""YES\n%s0\n"", range(a, 0, n-1));\n        else if (n == 2) // 0 -> 0 == 1\n            System.out.println(""NO"");\n        else if (a[n-3] == 0) // ... -> (0 -> 0) -> 0 == 0\n            System.out.printf(""YES\n%s(0->0)->0\n"", range(a, 0, n-3));\n        else {\n            int i;\n            for (i = n-4; i >= 0 && a[i] != 0; --i) ;\n            if (i >= 0) // ... -> (0->(1...1->0)) -> 0 == 0\n                System.out.printf(""YES\n%s(0->(%s0))->0\n"",\n                    range(a, 0, i), range(a, i+1, n-2));\n            else // 1...1 -> 0 -> 0 == 1\n                System.out.println(""NO"");\n        }\n    }\n}","constructive algorithms,greedy,implementation,math"
"import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n\npublic class A {\n	\n	public static void main(String args[]) throws IOException{\n		Scanner sc=new Scanner(System.in);\n		PrintWriter wr=new PrintWriter(System.out);\n		int n=sc.nextInt();\n		int arr[]=new int [n];\n		int zero=0;\n		for(int i=0;i<n;i++) {\n			arr[i]=sc.nextInt();\n			if(arr[i]==0)zero++;\n		}\n		if(n==1) {\n			if(arr[0]==0)System.out.println(""YES\n0"");\n			else System.out.println(""NO"");\n			return;\n		}\n		if(n==2) {\n			if(arr[0]==1 && arr[1]==0)System.out.println(""YES\n1->0"");\n			else System.out.println(""NO"");\n			return;\n		}\n		\n		\n		int c=0;\n		for(int i=n-1;i>=0;i--)\n			if(arr[i]==0)c++;\n			else break;\n		if(c==0 ||(c==2 && zero==2)) {\n			System.out.println(""NO"");\n			return;\n		}\n		StringBuilder sb=new StringBuilder();\n		if(c==2) {\n			int i=0;\n			for( i=n-3;i>=0;i--) {\n				if(arr[i]==0)break;\n			}\n			for(int j=0;j<i;j++) {\n				sb.append(arr[j]+""->"");\n			}\n			sb.append(""(0->("");\n			for(int j=i+1;j<n-2;j++) {\n				sb.append(arr[j]+""->"");\n			}\n			sb.append(""0))->0"");\n			System.out.println(""YES"");\n			System.out.println(sb);\n			return;\n		}\n		\n		for(int i=0;i<n-3;i++) {\n			sb.append(arr[i]+""->"");\n		}\n		sb.append(""(""+arr[n-3]+""->""+arr[n-2]+"")->""+arr[n-1]);\n		System.out.println(""YES"");\n		System.out.println(sb);\n	}\n	\n}\n","constructive algorithms,greedy,implementation,math"
"import java.util.Scanner;\n\npublic class _0929EquidistantString {\n\n	public static void main(String[] args) {\n		\n		Scanner sc = new Scanner(System.in);\n		char[]  s=sc.nextLine().toCharArray();\n		char[] t=sc.nextLine().toCharArray();\n		int count=0;\n		boolean takeS=true;\n		String ans="""";\n		for(int i=0;i<s.length;i++) {\n			if(s[i]==t[i]) {\n				continue;\n			}\n			else {\n				if(!takeS) {\n					s[i]=t[i];\n				}\n				takeS=!takeS;\n				count++;\n			}\n		}\n		if(count%2!=0) {\n			System.out.println(""impossible"");\n		}\n		else {\n			System.out.println(new String(s));\n		}\n	}\n\n}\n",greedy
"import java.util.Scanner;\n \npublic class _0929EquidistantString {\n \n	public static void main(String[] args) {\n		\n		Scanner sc = new Scanner(System.in);\n		char[] s=sc.nextLine().toCharArray();\n		char[] t=sc.nextLine().toCharArray();\n		int count=0;\n		boolean takes=true;\n		String ans="""";\n		\n		for(int i=0;i<s.length;i++)\n		{\n		    if(s[i]==t[i])\n		    continue;\n		    \n		    else\n		    {\n		        if(!takes)\n		        s[i]=t[i];\n		        \n		        takes=!takes;\n		        count++;\n		    }\n		}\n		\n		if(count%2!=0)\n		{\n			System.out.println(""impossible"");\n		}\n		else {\n			System.out.println(new String(s));\n		}\n	}\n}",greedy
"import java.util.*;\n\npublic class EquidistantString {\n\n	static void solve() {\n		Scanner sc = new Scanner(System.in);\n		String s = sc.next(), t = sc.next();\n		int res = 0,j = 0;\n		char[] c = new char[s.length()];\n		for (int i=0; i<s.length(); i++) {\n			char x = s.charAt(i), y = t.charAt(i);\n			if (x==y) {\n				c[j++]=x;\n			} else {\n				if (res==0) c[j++]=x;\n				else c[j++]=y;\n				res^=1;\n			}\n		}\n		if (res!=0) {\n			System.out.println(""impossible"");\n		} else {\n			StringBuilder o = new StringBuilder();\n			for (char ch : c) o.append(ch);\n			System.out.println(o);\n		}\n		sc.close();\n	}\n\n	public static void main(String[] args) {\n		solve();\n	}\n}",greedy
"import java.io.*;\nimport java.util.*;\npublic class equidistant_string\n{\n	public static void main(String[] args) \n	{\n	    Scanner in=new Scanner(System.in);\n		String s=in.next();\n		int cnt=0;\n		String str=in.next();\n		for(int i=0;i<s.length();i++)\n		{\n			if(s.charAt(i)!=str.charAt(i))\n			{\n				cnt++;\n			}\n		}\n		if(cnt%2!=0)\n		{\n			System.out.println(""impossible"");\n			return;\n		}\n		boolean bool=false;\n//		out.println(""YES"");\n		for(int i=0;i<s.length();i++)\n		{\n			if(s.charAt(i)==str.charAt(i))\n			{\n				System.out.print(s.charAt(i));\n			}\n			else\n			{\n				if(bool==false)\n				{\n					System.out.print(str.charAt(i));\n					bool=true;\n				}\n				else\n				{\n					System.out.print(s.charAt(i));\n					bool=false;\n				}\n			}\n		}\n//		out.close();\n	}\n}",greedy
"import java.util.*;\n\npublic class Solution\n{\n    public static void main(String []args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        \n        \n        int day = sc.nextInt();\n        long height = sc.nextLong();\n        \n       long max = day + height - 1;\n        \n       \n        for(int i = 1 ; i < m ; i++)\n        {\n           int d = sc.nextInt();\n           long h = sc.nextLong();\n           \n           if(d - day < Math.abs(height - h))\n           {\n               max = -1;\n               break;\n           }\n           \n           long k = d - day;\n           \n           k = k - (Math.abs(h - height));\n           \n           long maxNow = Math.max(height , h) + k/2;\n           \n           if(maxNow > max)\n           max = maxNow;\n           \n           \n           day = d;\n           height = h;\n        }\n        \n        \n        if(max != -1)\n        {\n        if(day == n)\n        System.out.println(max);\n        \n        else\n        {\n            long maxNow = height + n - day;\n            \n            if(maxNow > max)\n            System.out.println(maxNow);\n            \n            else\n            System.out.println(max);\n        }\n        \n        }\n        \n        else\n        System.out.println(""IMPOSSIBLE"");\n    }\n}","binary search,brute force,greedy,implementation,math"
"import java.io.*;\nimport java.util.*;\npublic class Main\n{\n	\n	private void solve()throws IOException\n	{\n		int n=nextInt();\n		int m=nextInt();\n		int d[]=new int[m+1];\n		int h[]=new int[m+1];\n		for(int i=1;i<=m;i++)\n		{\n			d[i]=nextInt();\n			h[i]=nextInt();\n		}\n		int first=h[1]+d[1]-1;\n		int last=h[m]+n-d[m];\n		int max=Math.max(first,last);\n		for(int i=1;i<m;i++)\n		{\n			if(Math.abs(h[i+1]-h[i])>d[i+1]-d[i])\n			{\n				out.println(""IMPOSSIBLE"");\n				return;\n			}\n			int extra=d[i+1]-d[i]-Math.abs(h[i]-h[i+1]);\n			max=Math.max(max,Math.max(h[i],h[i+1])+extra/2);\n		}\n		out.println(max);\n	}\n\n	 \n	///////////////////////////////////////////////////////////\n\n	public void run()throws IOException\n	{\n		br=new BufferedReader(new InputStreamReader(System.in));\n		st=null;\n		out=new PrintWriter(System.out);\n\n		solve();\n		\n		br.close();\n		out.close();\n	}\n	public static void main(String args[])throws IOException{\n		new Main().run();\n	}\n	BufferedReader br;\n	StringTokenizer st;\n	PrintWriter out;\n	String nextToken()throws IOException{\n		while(st==null || !st.hasMoreTokens())\n		st=new StringTokenizer(br.readLine());\n		return st.nextToken();\n	}\n	String nextLine()throws IOException{\n		return br.readLine();\n	}\n	int nextInt()throws IOException{\n		return Integer.parseInt(nextToken());\n	}\n	long nextLong()throws IOException{\n		return Long.parseLong(nextToken());\n	}\n	double nextDouble()throws IOException{\n		return Double.parseDouble(nextToken());\n	}\n}","binary search,brute force,greedy,implementation,math"
"import java.io.*;\nimport java.util.*;\nimport java.lang.*;\n\npublic class Rextester{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int d = Integer.parseInt(st.nextToken());\n        int initialDay = 0,initialHeight = 0,maxHeight = 0;\n        for(int i=0;i<d;i++){\n            StringTokenizer st1 = new StringTokenizer(br.readLine());\n            int day = Integer.parseInt(st1.nextToken());\n            int height = Integer.parseInt(st1.nextToken());\n            if(initialDay==0){\n                int nd = day - initialDay-1;\n                maxHeight = Math.max(maxHeight,height+nd);\n                initialDay = day;\n                initialHeight = height;\n                continue;\n            }\n            int nd = day-initialDay;\n            int hc = Math.abs(height - initialHeight);\n            if(nd==hc){\n                maxHeight = Math.max(maxHeight,Math.max(height,initialHeight));\n            }\n            else if(nd<hc){\n                System.out.println(""IMPOSSIBLE"");\n                return;\n            }\n            else{\n                int maxChange = (nd-hc)/2;\n                maxHeight = Math.max(maxHeight,Math.max(height+maxChange,initialHeight+maxChange));\n            }\n            initialDay = day;\n            initialHeight = height;\n        }\n        int nd = n - initialDay;\n        maxHeight = Math.max(maxHeight,initialHeight+nd);\n        System.out.println(maxHeight);\n    }\n}","binary search,brute force,greedy,implementation,math"
"\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\npublic class Div3_724 {\n\n	static void sort(int[] a) {\n		ArrayList<Integer> l = new ArrayList<>();\n		for (int i : a)\n			l.add(i);\n		Collections.sort(l);\n		for (int i = 0; i < a.length; i++)\n			a[i] = l.get(i);\n	}\n\n	public static void main(String[] args) {\n		FastReader sc = new FastReader();\n\n		int t = 1;\n		out: while (t-- > 0) {\n			int n = sc.nextInt();\n			int m = sc.nextInt();\n\n			if (m == 1) {\n				int a = sc.nextInt();\n				int h = sc.nextInt();\n				int x = Math.max(a - 1, n - a);\n				System.out.println(h + x);\n				continue;\n			}\n\n			long ans = 0;\n			int a1 = sc.nextInt();\n			int h1 = sc.nextInt();\n\n			ans = Math.max(ans, a1 - 1 + h1);\n\n			for (int i = 1; i < m; i++) {\n				int a2 = sc.nextInt();\n				int h2 = sc.nextInt();\n				int gap = a2 - a1;\n				int diff = Math.abs(h2 - h1);\n\n				if (diff > gap) {\n					System.out.println(""IMPOSSIBLE"");\n					continue out;\n				}\n				ans = Math.max(ans, Math.max(h1, h2));\n\n				int d = (gap - diff) / 2;\n				ans = Math.max(ans, Math.max(h1, h2) + d);\n				h1 = h2;\n				a1 = a2;\n\n			}\n			ans = Math.max(ans, h1 + n - a1);\n			System.out.println(ans);\n		}\n	}\n\n	static class FastReader {\n		BufferedReader br;\n		StringTokenizer st;\n\n		public FastReader() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		String next() {\n			while (st == null || !st.hasMoreElements()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			}\n			return st.nextToken();\n		}\n\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n\n		long[] readArray(int n) {\n			long[] a = new long[n];\n			for (int i = 0; i < n; i++)\n				a[i] = nextLong();\n			return a;\n		}\n\n		String nextLine() {\n			String str = """";\n			try {\n				str = br.readLine();\n			} catch (IOException e) {\n				e.printStackTrace();\n			}\n			return str;\n		}\n	}\n\n}\n","binary search,brute force,greedy,implementation,math"
import java.util.*;\n\npublic class solution {\n	public static void main(String[] args)  {\n		Scanner sc = new Scanner(System.in);\n        int w=sc.nextInt();\n        int h=sc.nextInt();\n        char[][] c=new char[h][w];\n        sc.nextLine();\n        for(int i=0;i<h;i++) {\n        	c[i]=sc.nextLine().toCharArray();\n        }\n        char[][] d=new char[w][h];\n        for(int i=0;i<w;i++) {\n        	for(int j=0;j<h;j++) {\n        		d[i][j]=c[j][i];\n        	}\n        }\n        for(int i=0;i<w;i++) {\n        	for(int l=0;l<2;l++) {\n        		for(int j=0;j<h;j++) {\n            		for(int k=0;k<2;k++) {\n            			System.out.print(d[i][j]);\n            		}\n            	}\n        		System.out.println();\n        	}\n        }\n	}\n},"*special,implementation"
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Eshan {\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static StringTokenizer st;\n    static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) throws IOException {\n        // int t = readInt();\n        // while(t-- > 0){\n\n        // }\n        int n = readInt(), m = readInt();\n        char[][] arr = new char[n][m];\n        for (int j = 0; j < m; j++) {\n            String str = readLine();\n            for (int i = 0; i < n; i++)\n                arr[i][j] = str.charAt(i);\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++)\n                out.print(arr[i][j] + """" + arr[i][j]);\n            out.println("" "");\n            for (int j = 0; j < m; j++)\n                out.print(arr[i][j] + """" + arr[i][j]);\n            out.println("" "");\n        }\n        out.flush();\n    }\n\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(readLine());\n        return st.nextToken();\n    }\n\n    static long readLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    static int readInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    static double readDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    static char readCharacter() throws IOException {\n        return next().charAt(0);\n    }\n\n    static String readLine() throws IOException {\n        return br.readLine().trim();\n    }\n\n    private static boolean isInteger(String s) {\n        try {\n            Integer.parseInt(s);\n        } catch (NumberFormatException e) {\n            return false;\n        } catch (NullPointerException e) {\n            return false;\n        }\n        return true;\n    }\n\n    private static int gcd(int a, int b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n    private static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n    private static int lcm(int a, int b) {\n        return (a / gcd(a, b)) * b;\n    }\n\n    private static long lcm(long a, long b) {\n        return (a / gcd(a, b)) * b;\n    }\n\n    private static long mod_power(long a, long b, int mod) {\n        if (b == 0)\n            return 1L;\n        long temp = mod_power(a, b / 2, mod);\n        temp %= mod;\n        temp = (temp * temp) % mod;\n        if ((b & 1) == 1)\n            temp = (temp * a) % mod;\n        return temp;\n    }\n}","*special,implementation"
"import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;\nimport java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;\nimport java.security.AccessControlException;import java.util.List;public class _p000523A {\nstatic public void main(final String[] args) throws IOException{p000523A._main(args);}\n\nstatic class p000523A extends Solver{public p000523A(){singleTest=true;}@Override public \nvoid solve()throws IOException{int w=sc.nextInt();int h=sc.nextInt();sc.nextLine();\nint[][]c=new int[h][];for(int $i0=0;$i0<h;$i0++){c[$i0]=sc.nextLine().chars().toArray();\n}int[][]c1=new int[h][w];for(int i=0;i<h;i++){for(int j=0;j<w;j++){c1[h-1-i][j]=\nc[i][j];}}for(int j=0;j<w;j++){for(int k=0;k<2;k++){for(int i=h-1;i>=0;i--){pw.print((char)c1[i][j]);\npw.print((char)c1[i][j]);}pw.println();}}}static public void _main(String[]args)throws \nIOException{new p000523A().run();}}static class MyScanner{private StringBuilder \ncache=new StringBuilder();int cache_pos=0;private int first_linebreak=-1;private \nint second_linebreak=-1;private StringBuilder sb=new StringBuilder();private InputStream \nis=null;public MyScanner(final InputStream is){this.is=is;}public String charToString(final \nint c){return String.format(""'%s'"",c=='\n'?""\\n"":(c=='\r'?""\\r"":String.valueOf((char)c)));\n}public int get(){int res=-1;if(cache_pos<cache.length()){res=cache.charAt(cache_pos);\ncache_pos++;if(cache_pos==cache.length()){cache.delete(0,cache_pos);cache_pos=0;\n}}else{try{res=is.read();}catch(IOException ex){throw new RuntimeException(ex);}\n}return res;}private void unget(final int c){if(cache_pos==0){cache.insert(0,(char)c);\n}else{cache_pos--;}}public String nextLine(){sb.delete(0,sb.length());int c;boolean \ndone=false;boolean end=false;while((c=get())!=-1){if(check_linebreak(c)){done=true;\nif(c==first_linebreak){if(!end){end=true;}else{cache.append((char)c);break;}}else \nif(second_linebreak!=-1 && c==second_linebreak){break;}}if(end && c!=first_linebreak \n&& c!=second_linebreak){cache.append((char)c);break;}if(!done){sb.append((char)c);\n}}return!done && sb.length()==0?null:sb.toString();}private boolean check_linebreak(int \nc){if(c=='\n'|| c=='\r'){if(first_linebreak==-1){first_linebreak=c;}else if(c!=first_linebreak \n&& second_linebreak==-1){second_linebreak=c;}return true;}return false;}public int \nnextInt(){return Integer.parseInt(next());}public long nextLong(){return Long.parseLong(next());\n}public boolean hasNext(){boolean res=false;int c;while((c=get())!=-1){if(!check_linebreak(c)\n&& c!=' '&& c!='\t'){res=true;unget(c);break;}}return res;}public String next(){\nsb.delete(0,sb.length());boolean started=false;int c;while((c=get())!=-1){if(check_linebreak(c)\n|| c==' '|| c=='\t'){if(started){unget(c);break;}}else{started=true;sb.append((char)c);\n}}return sb.toString();}public int nextChar(){return get();}public boolean eof()\n{int c=get();boolean res=false;if(c!=-1){unget(c);}else{res=true;}return res;}public \ndouble nextDouble(){return Double.parseDouble(next());}}static abstract class Solver\n{protected String nameIn=null;protected String nameOut=null;protected boolean singleTest\n=false;protected MyScanner sc=null;protected PrintWriter pw=null;private int current_test\n=0;private int count_tests=0;protected int currentTest(){return current_test;}protected \nint countTests(){return count_tests;}private void process()throws IOException{if(!singleTest)\n{count_tests=sc.nextInt();sc.nextLine();for(current_test=1;current_test<=count_tests;\ncurrent_test++){solve();pw.flush();}}else{count_tests=1;current_test=1;solve();}\n}abstract protected void solve()throws IOException;public void run()throws IOException\n{boolean done=false;try{if(nameIn!=null){if(new File(nameIn).exists()){try(FileInputStream \nfis=new FileInputStream(nameIn);PrintWriter pw0=select_output();){select_output();\ndone=true;sc=new MyScanner(fis);pw=pw0;process();}}else{throw new RuntimeException(""File ""\n+new File(nameIn).getAbsolutePath()+"" does not exist!"");}}}catch(IOException | AccessControlException \nex){}if(!done){try(PrintWriter pw0=select_output();){sc=new MyScanner(System.in);\npw=pw0;process();}}}private PrintWriter select_output()throws FileNotFoundException\n{if(nameOut!=null){return new PrintWriter(nameOut);}return new PrintWriter(System.out);\n}}static abstract class Tester{static public int getRandomInt(final int min,final \nint max){return(min+(int)Math.floor(Math.random()*(max-min+1)));}static public long \ngetRandomLong(final long min,final long max){return(min+(long)Math.floor(Math.random()\n*(max-min+1)));}static public double getRandomDouble(final double min,final double \nmaxExclusive){return(min+Math.random()*(maxExclusive-min));}abstract protected void \ntestOutput(final List<String>output_data);abstract protected void generateInput();\nabstract protected String inputDataToString();private boolean break_tester=false;\nprotected void beforeTesting(){}protected void breakTester(){break_tester=true;}\npublic boolean broken(){return break_tester;}}}\n","*special,implementation"
"import java.util.Scanner;\n\npublic class A_Rotate_Flip_and_Zoom{\n	\n	static Scanner in=new Scanner(System.in);\n	\n	static int n,m;\n	\n	public static void main(String [] amit){\n		\n		m=in.nextInt();\n		\n		n=in.nextInt();\n		\n		char a[][]=new char[n][];\n		\n		for(int i=0;i<n;i++){\n			\n			a[i]=in.next().toCharArray();\n			\n        }\n    \n	\n        for (int i = 0; i < 2 * m; i++) {\n            for (int j = 0; j < 2 * n; j++) {\n                System.out.print(a[j / 2][i / 2]);\n            }\n            System.out.println();\n        }\n		\n	}\n	\n}\n	\n\n		 						 	 	  	 		 	 			 	  		","*special,implementation"
"import java.util.*;\n\npublic class MishaAndChangingHandles {\n\n	static void solve() {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt(), no = n;\n		Map<String, String> d = new HashMap<>();\n		while (no-->0) {\n			String old = sc.next(), _new = sc.next();\n			String t = d.getOrDefault(old, old);\n			d.put(_new,t);\n			if (!t.equals(old)) {\n				d.remove(old);\n			}\n		}\n		System.out.println(d.size());\n		for (Map.Entry<String, String> x : d.entrySet()) {\n			System.out.println(x.getValue()+"" ""+x.getKey());\n		}\n		sc.close();\n	}\n\n	public static void main(String[] args) {\n		solve();\n	}\n}","data structures,dsu,strings"
"import java.util.*;\n\npublic class MishaAndChangingHandles {\n\n	static void solve() {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt(), no = n;\n		Map<String, String> d = new HashMap<>();\n		while (no-->0) {\n			String old = sc.next(), _new = sc.next();\n			String t = d.getOrDefault(old, old);\n			d.put(_new,t);\n			if (!t.equals(old)) {\n				d.remove(old);\n			}\n		}\n		System.out.println(d.size());\n		for (Map.Entry<String, String> x : d.entrySet()) {\n			System.out.println(x.getValue()+"" ""+x.getKey());\n		}\n		sc.close();\n	}\n\n	public static void main(String[] args) {\n		solve();\n	}\n}","data structures,dsu,strings"
"import java.util.*;\n\npublic class CBR79B {\n\n	public static void main(String[] args) {\n\n		Scanner s = new Scanner(System.in);\n\n		int t = s.nextInt();\n		HashMap<String, String> h = new HashMap<String, String>();\n		while (t-- > 0) {\n			String old = s.next();\n			String neww = s.next();\n			\n			if(h.containsValue(old)) {\n				for(String name:h.keySet()) {\n					if(h.get(name).equals(old))\n					{\n						h.put(name,neww);\n						break;\n					}\n				}\n			}\n			else {\n				h.put(old,neww);\n			}\n\n		}\n		System.out.println(h.size());\n		\n		for(String name:h.keySet()) {\n			System.out.println(name+"" ""+h.get(name));\n		}\n\n	}\n}\n\n","data structures,dsu,strings"
"import java.io.*;\nimport java.util.*;\n\npublic class test\n{\n	public static void main(String[] args)\n	{\n		HashMap<String,String> hmap = new HashMap<String,String>();\n		Scanner in = new Scanner(System.in);\n		int t = in.nextInt();\n		for(int i=0;i<t;i++)\n		{\n			String old = in.next();\n			String neww = in.next();\n			if(hmap.containsValue(old))\n			{\n				for (String name : hmap.keySet())  \n				{\n					if(hmap.get(name).equals(old))\n					{\n						hmap.put(name,neww);\n						break;\n					}\n				}\n			}\n			else\n			{\n				hmap.put(old,neww);\n			}\n		}\n		//System.out.println(""yo"");\n		System.out.println(hmap.size());\n		for (String name : hmap.keySet())  \n		{\n			System.out.println(name+"" ""+hmap.get(name));\n		}\n\n	}\n\n}","data structures,dsu,strings"
"\nimport java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m= in.nextInt();\n        String nn[] = new String[n];\n        String va[] = new String[n];\n        for (int i = 0; i < n; i++) {\n            nn[i] = in.next();\n            va[i] = """";\n        }\n        int rv = 0;\n        for (int i = 0; i <m; i++) {\n            boolean cnt = true;\n            for (int j = 1; j < n; j++) {\n                String a = va[j] + nn[j].charAt(i), b = va[j - 1] + nn[j - 1].charAt(i);\n                if (a.compareTo(b) < 0) {\n                    cnt = false;\n                    rv++;\n                    break;\n                }\n            }\n            if (cnt) {\n                for (int j = 0; j < n; j++) {\n                    va[j] += nn[j].charAt(i);\n                }\n            }\n        }\n        System.out.println(rv);\n    }\n}\n\n\n","brute force,constructive algorithms,implementation"
\nimport java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        char[][] x = new char[n][m];\n        for (int i=0; i<n; i++){\n            String s = in.next();\n            for (int j=0; j<m; j++){\n                x[i][j] = s.charAt(j);\n            }\n        }\n        boolean[] l = new boolean[n];\n        int sc = 0;\n        for (int i=0; i<m; i++){\n            boolean f = false;\n            for (int j=1; j<n; j++){\n                if (x[j][i]<x[j-1][i] && !l[j]){\n                    f = true;\n                    break;\n                }\n            }\n\n            if (f){\n                sc++;\n                continue;\n            }\n\n            for (int j=1; j<n; j++){\n                if (x[j][i]>x[j-1][i]){\n                    l[j] = true;\n                }\n            }\n        }\n\n        System.out.println(sc);\n    }\n}\n\n\n\n 		 	  	 			 	        	  	 				,"brute force,constructive algorithms,implementation"
"/* package codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be ""Main"" only if the class is public. */\npublic class Codechef\n{\n	public static void main (String[] args) throws java.lang.Exception\n	{\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int m=sc.nextInt();\n		String s[]=new String[n];\n		for(int i=0;i<n;i++){\n		    s[i]=sc.next();\n		}\n		int count=0;\n		String si[]=new String[n];\n		for(int i=0;i<n;i++){si[i]="""";}\n		for(int j=0;j<m;j++){\n		    si[0]=si[0]+s[0].charAt(j);\n		    boolean b=true;\n		    for(int i=1;i<n;i++){\n		        si[i]=si[i]+s[i].charAt(j);\n		       // System.out.println(si[i]);\n		        if(si[i].compareTo(si[i-1])<0)b=false;\n		    }\n		    if(!b){\n		        count++;\n		        for(int i=0;i<n;i++){\n		        //System.out.println(si[i]);\n		        si[i]=si[i].substring(0,si[i].length()-1);\n		        //if(si[i]==null) si[i]="""";\n		    }\n		    }\n		}\n		System.out.println(count);\n	}\n}\n","brute force,constructive algorithms,implementation"
import java.util.*;\npublic class Main {\n\n    public static void main(String[] args) {\n	// write your code here\n        Scanner in = new Scanner(System.in);\n       int n = in.nextInt();\n       int m = in.nextInt();\n       char[][] a = new char[n][m];\n       int[] b = new int[101];\n       int sum = 0;\n        for (int i = 0; i < n; i++) {\n            String s = in.next();\n            for (int j = 0; j < m; j++) {\n                a[i][j] = s.charAt(j);\n            }\n        }\n        for(int i = 0;i < m;i++)\n            b[i]=1;\n        for(int i = 1;i < n;i++)\n        {\n            for(int j = 0;j < m;j++)\n            {\n                if(b[j] == 1)\n                {\n                    if(a[i][j] < a[i-1][j])\n                    {\n                        b[j] = 0;\n                        i = 0;\n                        break;\n                    }\n                    if(a[i][j] > a[i-1][j])\n                        break;\n                }\n            }\n        }\n        for(int i = 0;i < m;i++)\n            sum  += 1-b[i];\n        System.out.println(sum);\n    }\n}\n\n 	 				  	 		      		   	 	   	,"brute force,constructive algorithms,implementation"
"import java.util.*;\n\npublic class InitialBet {\n\n	static void solve() {\n		Scanner sc = new Scanner(System.in);\n		int n = 5, no=n, s=0;\n		while (no-->0) s+=sc.nextInt();\n		System.out.println(s%5==0 && s!=0 ? s/5 : -1);\n		sc.close();\n	}\n\n	public static void main(String[] args) {\n		solve();\n	}\n}",implementation
import java.util.*;\npublic class InitialBet {\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int sum=0;\n		for(int i=0;i<5;i++) {\n			int c=sc.nextInt();\n			sum+=c;\n		}\n		if(sum%5==0 && sum!=0) System.out.println(sum/5);\n		else System.out.println(-1);\n\n	}\n\n},implementation
"import java.util.Scanner;\n\npublic class A478 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = 5, sum = 0;\n        while (n-- > 0) {\n            sum += in.nextInt();\n        }\n        System.out.println(sum !=0 && sum % 5 == 0 ? sum / 5 : -1);\n    }\n}",implementation
\nimport java.util.Scanner;\n\npublic class SolnA {\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int a = 0;\n		for(int i=0;i<5;i++) {\n			int x = sc.nextInt();\n			a+=x;\n		}\n		if(a%5!=0||a/5==0)	System.out.println(-1);\n		else System.out.println(a/5);\n		sc.close();\n	}\n\n}\n,implementation
"import java.util.*;\npublic class Doremon\n{\n	public static void main(String []args)\n	{\n		Scanner sc=new Scanner(System.in);\n		int n,m;\n		n=sc.nextInt();\n		m=sc.nextInt();\n		int l= (n+1)/2 ;\n    int ans = (l+m-1)/m*m ;\n    if(ans>n)\n        ans = -1 ;\n	System.out.println(ans);\n	}\n}","implementation,math"
"import java.util.*;\npublic class S476{\npublic static void main(String[] args) {\nScanner sc=new Scanner(System.in);\nint n=sc.nextInt();\nint m=sc.nextInt();\nint res=0;\nif(n>=m){if(n==m){System.out.println(n);}\nelse{res=(n+1)/2;while(!(res%m==0)){res++;}\nSystem.out.println(res);}}\nelse{System.out.println(""-1"");}}}","implementation,math"
"import java.util.*;\npublic class Problem_476A \n{\n	public static void main(String[] args)\n	{\n		Scanner in = new Scanner(System.in);\n		int n = in.nextInt();\n		int m = in.nextInt();\n		int s = 0;\n		if(n/m>0) \n		{\n			s = (n/2)/m;\n			System.out.println((s*m*2==n)?s*m:(s+1)*m);\n		}\n		else\n			System.out.println(""-1"");\n	}\n}","implementation,math"
\n	\nimport java.util.*;\n\npublic class test {\n\n	public static void main(String[] args) {\n			\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int m=sc.nextInt();\n		int a=n/2+n%2;\n		if(m>n) System.out.println(-1);\n		else if(a<=m) System.out.println(m);\n		\n		else System.out.println((a%m==0)?a:a-a%m+m);\n	}\n}\n\n\n,"implementation,math"
"//package mynewone;\nimport java.util.Scanner;\npublic class Cppractice\n{\n	static int k;\n	static long mod=1000000007;\n	static Scanner sc=new Scanner(System.in);\n	public static void main(String []args )\n	{	\n		int t = sc.nextInt();\n		k=sc.nextInt();\n		int a,b;\n		long[]dp = new long[100000+1];\n		dp[0]=1;\n		for(int i=1;i<=100000;++i)\n		{\n			dp[i]=dp[i-1];\n			if(i>=k) \n			{\n				dp[i]+=dp[i-k];\n				dp[i]%=mod;\n			}\n			\n		}\n		for(int i=1;i<dp.length;++i)\n		{\n			dp[i]+=dp[i-1];\n			dp[i]%=mod;\n			//System.out.println(dp[i]);	\n		}	\n		while(t-->0)\n		{\n			a=sc.nextInt();\n			b=sc.nextInt();\n			System.out.println( (dp[b] - dp[a-1]+mod)%mod);			\n		}		\n	}\n}\n",dp
"//package mynewone;\nimport java.util.Scanner;\npublic class Cppractice\n{\n	static int k;\n	static long mod=1000000007;\n	static Scanner sc=new Scanner(System.in);\n	public static void main(String []args )\n	{	\n		int t = sc.nextInt();\n		k=sc.nextInt();\n		int a,b;\n		long[]dp = new long[100000+1];\n		dp[0]=1;\n		for(int i=1;i<=100000;++i)\n		{\n			dp[i]=dp[i-1];\n			if(i>=k) \n			{\n				dp[i]+=dp[i-k];\n				dp[i]%=mod;\n			}\n			\n		}\n		for(int i=1;i<dp.length;++i)\n		{\n			dp[i]+=dp[i-1];\n			dp[i]%=mod;\n			//System.out.println(dp[i]);	\n		}	\n		while(t-->0)\n		{\n			a=sc.nextInt();\n			b=sc.nextInt();\n			System.out.println( (dp[b] - dp[a-1]+mod)%mod);			\n		}		\n	}\n}\n",dp
\n//normal\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n// String Tokenizer\n\npublic class Main {\n	public static void main(String[] args) {\n		// code\n		Scanner scn = new Scanner(System.in);\n\n		int t = scn.nextInt();\n		int k = scn.nextInt();\n		int M = 1000000007;\n		int n = 100001;\n		int[] dp = new int[n];\n		dp[0] = 1;\n		for (int i = 1; i < n; i++) {\n			dp[i] = (dp[i] + dp[i - 1]) % M;\n			if (i - k >= 0) {\n				dp[i] = (dp[i] + dp[i - k]) % M;\n			}\n		}\n		for (int i = 1; i < n; i++) {\n\n			dp[i] = (dp[i] + dp[i - 1]) % M;\n\n		}\n		while (t > 0) {\n			t--;\n\n			int a = scn.nextInt();\n			int b = scn.nextInt();\n\n			System.out.println((dp[b] - dp[a - 1] + M) % M);\n\n		}\n	}\n},dp
import java.util.Scanner;\n\npublic class flowers {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n\n		Scanner in = new Scanner(System.in);\n		int t = in.nextInt();\n		int k = in.nextInt();\n		int n = 100000;\n		int dn[][] = new int[n + 1][4];\n		int mod = 1000000007;\n		\n		dn[0][0] = 1; \n		dn[0][1] = 0;\n		for(int i = 1; i <= n; ++i) {\n			dn[i][0] = (dn[i - 1][0] + dn[i - 1][1]) % mod;\n			if(i >= k)\n				dn[i][1] = (dn[i - k][0] + dn[i - k][1]) % mod;\n			dn[i][2] = (dn[i][0] + dn[i][1]) % mod;\n			dn[i][3] = (dn[i][2] + dn[i-1][3]) % mod;\n		}	\n		\n		while(t-- > 0)  {\n			int a = in.nextInt();\n			int b = in.nextInt();\n			int ans = (mod + dn[b][3] - dn[a - 1][3]) % mod;\n			System.out.println(ans);\n		}\n	}\n\n}\n,dp
"import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		FastScanner in = new FastScanner(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		TaskD solver = new TaskD();\n		solver.solve(1, in, out);\n		out.close();\n	}\n}\n\nclass TaskD {\n	public void solve(int testNumber, FastScanner in, PrintWriter out) {\n		int n = in.nextInt();\n		int[][] d = new int[n][n];\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < n; j++) {\n				d[i][j] = in.nextInt();\n			}\n		}\n		for (int i = 0; i < n; i++) {\n			if (d[i][i] != 0) {\n				out.println(""NO"");\n				return;\n			}\n			for (int j = 0; j < n; j++) {\n				if (d[i][j] != d[j][i]) {\n					out.println(""NO"");\n					return;\n				}\n				if (i != j && d[i][j] == 0) {\n					out.println(""NO"");\n					return;\n				}\n			}\n		}\n		int[] p = new int[n];\n		int[] d0 = new int[n];\n		for (int i = 0; i < n; i++) {\n			d0[i] = d[0][i];\n			p[i] = i;\n		}\n		for (int i = 0; i < n; i++) {\n			for (int j = i + 1; j < n; j++) {\n				if (d0[i] > d0[j]) {\n					int t;\n					t = d0[i]; d0[i] = d0[j]; d0[j] = t;\n					t = p[i]; p[i] = p[j]; p[j] = t;\n				}\n			}\n		}\n		for (int i = 1; i < n; i++) {\n			int minPos = -1;\n			int minEdge = 0;\n			for (int j = 0; j < i; j++) {\n				if (minPos < 0 || minEdge > d[p[j]][p[i]]) {\n					minEdge = d[p[j]][p[i]];\n					minPos = j;\n				}\n			}\n			for (int j = 0; j < i; j++) {\n				if (d[p[minPos]][p[j]] + minEdge != d[p[i]][p[j]]) {\n					out.println(""NO"");\n					return;\n				}\n			}\n		}\n		out.println(""YES"");\n	}\n}\n\nclass FastScanner {\n\n	private BufferedReader in;\n	private StringTokenizer st;\n\n	public FastScanner(InputStream stream) {\n		in = new BufferedReader(new InputStreamReader(stream));\n	}\n\n	public String next() {\n		while (st == null || !st.hasMoreTokens()) {\n			try {\n				String rl = in.readLine();\n				if (rl == null) {\n					return null;\n				}\n				st = new StringTokenizer(rl);\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n		}\n		return st.nextToken();\n	}\n\n	public int nextInt() {\n		return Integer.parseInt(next());\n	}\n\n}\n\n","dfs and similar,dsu,shortest paths,trees"
"import java.io.*;\nimport java.util.*;\n \npublic class Main {\n \n    public static int n;\n    public static int[][] matrix;\n    public static Map<Integer, List<Integer>> graph;\n \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer token = new StringTokenizer(br.readLine());\n        n = Integer.parseInt(token.nextToken());\n        matrix = new int[n][n];\n \n        for (int i = 0; i < n; i++) {\n            token = new StringTokenizer(br.readLine());\n            for (int j = 0; j < n; j++) {\n                int num = Integer.parseInt(token.nextToken());\n                matrix[i][j] = num;\n            }\n        }\n \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++) {\n                if (i == j && matrix[i][j] != 0) {\n                    System.out.println(""NO"");\n                    return;\n                }\n                if (i != j && (matrix[i][j] != matrix[j][i] || matrix[i][j] == 0)) {\n                    System.out.println(""NO"");\n                    return;\n                }\n            }\n        }\n \n        if (prim()) {\n            System.out.println(""YES"");\n        } else {\n            System.out.println(""NO"");\n        }\n    }\n \n    public static boolean prim() {\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        Set<Integer> visited = new HashSet<>();\n        int[][] construct = new int[n][n];\n        int[] distance = new int[n];\n        Arrays.fill(distance, Integer.MAX_VALUE);\n        distance[0] = 0;\n        int[] prior = new int[n];\n        while (visited.size() < n) {\n \n            int min = -1;\n            for (int i = 0; i < n; i++) {\n                if (!visited.contains(i) && (min == -1 || distance[i] < distance[min])) {\n                    min = i;\n                }\n            }\n \n            for (int i = 0; i < n; i++) {\n                if (visited.contains(i)) {\n                    construct[i][min] = construct[i][prior[min]] + distance[min];\n                    construct[min][i] = construct[i][prior[min]] + distance[min];\n                }\n            }\n \n            visited.add(min);\n            for (int i = 0; i < n; i++) {\n                if (distance[i] > matrix[min][i]) {\n                    distance[i] = matrix[min][i];\n                    prior[i] = min;\n                }\n            }\n        }\n \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) {\n                    construct[i][j] = 0;\n                }\n                if (construct[i][j] != matrix[i][j])\n                    return false;\n            }\n        }\n        return true;\n    }\n}\n												 	 		  	  		   	  	","dfs and similar,dsu,shortest paths,trees"
"\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    public static int n;\n    public static int[][] matrix;\n    public static Map<Integer, List<Integer>> graph;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader bfr = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer token = new StringTokenizer(bfr.readLine());\n        n = Integer.parseInt(token.nextToken());\n        matrix = new int[n][n];\n\n        for (int i = 0; i < n; i++) {\n            token = new StringTokenizer(bfr.readLine());\n            for (int j = 0; j < n; j++) {\n                int num = Integer.parseInt(token.nextToken());\n                matrix[i][j] = num;\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++) {\n                if (i == j && matrix[i][j] != 0) {\n                    System.out.println(""NO"");\n                    return;\n                }\n                if (i != j && (matrix[i][j] != matrix[j][i] || matrix[i][j] == 0)) {\n                    System.out.println(""NO"");\n                    return;\n                }\n            }\n        }\n\n        if (prim()) {\n            System.out.println(""YES"");\n        } else {\n            System.out.println(""NO"");\n        }\n    }\n\n    public static boolean prim() {\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        Set<Integer> visited = new HashSet<>();\n        int[][] construct = new int[n][n];\n        int[] dist = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0] = 0;\n        int[] prior = new int[n];\n        while (visited.size() < n) {\n\n            int min = -1;\n            for (int i = 0; i < n; i++) {\n                if (!visited.contains(i) && (min == -1 || dist[i] < dist[min])) {\n                    min = i;\n                }\n            }\n\n            for (int i = 0; i < n; i++) {\n                if (visited.contains(i)) {\n                    construct[i][min] = construct[i][prior[min]] + dist[min];\n                    construct[min][i] = construct[i][prior[min]] + dist[min];\n                }\n            }\n\n            visited.add(min);\n            for (int i = 0; i < n; i++) {\n                if (dist[i] > matrix[min][i]) {\n                    dist[i] = matrix[min][i];\n                    prior[i] = min;\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) {\n                    construct[i][j] = 0;\n                }\n                if (construct[i][j] != matrix[i][j])\n                    return false;\n            }\n        }\n        return true;\n    }\n}\n","dfs and similar,dsu,shortest paths,trees"
"\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\n/*\n    Time O(n + e): n is number of nodes & v is number of edges\n    Space O(n * e): n is number of nodes & v is number of edges\n    Explanation: Use Prim's algorithm to construct MST and compare that one with the input\n */\n\npublic class Main {\n\n    public static int n;\n    public static int[][] matrix;\n    public static Map<Integer, List<Integer>> graph;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader bfr = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer token = new StringTokenizer(bfr.readLine());\n        n = Integer.parseInt(token.nextToken());\n        matrix = new int[n][n];\n\n        for (int i = 0; i < n; i++) {\n            token = new StringTokenizer(bfr.readLine());\n            for (int j = 0; j < n; j++) {\n                int num = Integer.parseInt(token.nextToken());\n                matrix[i][j] = num;\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++) {\n                if (i == j && matrix[i][j] != 0) {\n                    System.out.println(""NO"");\n                    return;\n                }\n                if (i != j && (matrix[i][j] != matrix[j][i] || matrix[i][j] == 0)) {\n                    System.out.println(""NO"");\n                    return;\n                }\n            }\n        }\n\n        if (prim()) {\n            System.out.println(""YES"");\n        } else {\n            System.out.println(""NO"");\n        }\n    }\n\n    public static boolean prim() {\n        Set<Integer> visited = new HashSet<>();\n        int[][] construct = new int[n][n];\n        int[] dist = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0] = 0;\n        int[] prior = new int[n];\n        while (visited.size() < n) {\n\n            int min = -1;\n            for (int i = 0; i < n; i++) {\n                if (!visited.contains(i) && (min == -1 || dist[i] < dist[min])) {\n                    min = i;\n                }\n            }\n\n            for (int i = 0; i < n; i++) {\n                if (visited.contains(i)) {\n                    construct[i][min] = construct[i][prior[min]] + dist[min];\n                    construct[min][i] = construct[i][prior[min]] + dist[min];\n                }\n            }\n\n            visited.add(min);\n            for (int i = 0; i < n; i++) {\n                if (dist[i] > matrix[min][i]) {\n                    dist[i] = matrix[min][i];\n                    prior[i] = min;\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) {\n                    construct[i][j] = 0;\n                }\n                if (construct[i][j] != matrix[i][j])\n                    return false;\n            }\n        }\n        return true;\n    }\n}\n\n							 	    	    	 	 						","dfs and similar,dsu,shortest paths,trees"
"import java.util.*;\npublic class Main\n{public static void main(String args[])\n{Scanner sc=new Scanner(System.in);\nint n,i,c=0,a=0,b=0;\nn=sc.nextInt();\nfor(i=1;i<=n;i++)\n{a=sc.nextInt();\nb=sc.nextInt();\nif(b-a>1)\nc++;\n}\nSystem.out.print(c);\n    \n}}",implementation
"import java.util.*;\npublic class cf{\n	public static void main(String[] args){\n		Scanner r=new Scanner(System.in);\n		int n=r.nextInt(),i,p,q,c=0;\n		for(i=0;i<n;i++){\n			p=r.nextInt();q=r.nextInt();\n			if(q-p>1)c++;\n		}\n		System.out.println(""""+c);\n	}\n}",implementation
"import java.util.*;\npublic class Main{\npublic static void main(String[] args){\nScanner k=new Scanner(System.in);\nint n=k.nextInt();\nint cn,tot,count=0;\nwhile(n!=0){\ncn=k.nextInt();\ntot=k.nextInt();\nif(cn+2<=tot) count++;\nn--;\n}System.out.println(count);\n\n}}",implementation
import java.util.*;\npublic class nnfff{\npublic static void main(String args[])\n{Scanner sc= new Scanner(System.in);\nint t=sc.nextInt();\nint an=0;\nfor(int i=0;i<t;i++)\n{\n    int a=sc.nextInt();\n    int b=sc.nextInt();\n    if((b-a)>=2)\n    an++;\n}System.out.println(an);}},implementation
"import java.util.*;\nimport java.io.*;\n\npublic class Main {\n	\n	static int n, MAXN;\n	static ArrayList<int[]>[] adjList;\n	static int[] parent, level, edge;\n	static int[][] lcaP, lcaMax;\n	\n	public static void dfs(int u, int p) {\n		parent[u] = p;\n		for(int[] e : adjList[u])\n			if(e[0] != p) {\n				level[e[0]] = level[u] + 1;\n				edge[e[0]] = e[1];\n				dfs(e[0], u);\n			}\n	}\n	\n	public static void preprocess() {\n		lcaP[0] = parent;\n		lcaMax[0] = edge;\n		for(int i = 1; i < MAXN; i++)\n			for(int j = 0; j < n; j++) {\n				lcaP[i][j] = lcaP[i - 1][j] == -1 ? -1 : lcaP[i - 1][lcaP[i - 1][j]];\n				lcaMax[i][j] = Math.max(lcaMax[i - 1][j], lcaP[i - 1][j] == -1 ? 0 : lcaMax[i - 1][lcaP[i - 1][j]]);\n			}\n	}\n	\n	public static boolean solve(int x, int y, int t) {\n		if(level[x] < level[y])\n			return false;\n		int diff = level[x] - level[y];\n		int max = 0;\n		for(int i = 0; i < MAXN; i++)\n			if((diff & (1 << i)) != 0) {\n				max = Math.max(max, lcaMax[i][x]);\n				x = lcaP[i][x];\n			}\n		if(x != y)\n			return false;\n		if(max > t)\n			return false;\n		return true;\n	}\n	\n	public static void main(String[] args) throws Exception {\n		Scanner sc = new Scanner(System.in);\n		PrintWriter pw = new PrintWriter(System.out);\n		\n		MAXN = 18;\n		n = sc.nextInt();\n		int m = sc.nextInt();\n		adjList = new ArrayList[n];\n		for(int i = 0; i < n; i++)\n			adjList[i] = new ArrayList<>();\n		\n		int[] deg = new int[n];\n		ArrayList<int[]> doc = new ArrayList<int[]>();\n		ArrayList<int[]> query = new ArrayList<int[]>();\n		for(int i = 0; i < m; i++) {\n			int t = sc.nextInt();\n			if(t == 1) {\n				int x = sc.nextInt() - 1, y = sc.nextInt() - 1;\n				adjList[y].add(new int[] {x, i});\n				deg[x]++;\n			} else if(t == 2) {\n				doc.add(new int[] {sc.nextInt() - 1, i});\n			} else {\n				int x = sc.nextInt() - 1, y = sc.nextInt() - 1;\n				query.add(new int[] {x, y});\n			}\n		}\n		\n		\n		parent = new int[n];\n		level = new int[n];\n		edge = new int[n];\n		for(int i = 0; i < n; i++)\n			if(deg[i] == 0)\n				dfs(i, -1);\n		\n		lcaP = new int[MAXN][n];\n		lcaMax = new int[MAXN][n];\n		preprocess();\n		\n		for(int[] i : query)\n			pw.println(solve(doc.get(i[1])[0], i[0], doc.get(i[1])[1]) ? ""YES"" : ""NO"");\n		\n		pw.flush();\n	}\n\n	public static class Scanner {\n		StringTokenizer st;\n		BufferedReader br;\n\n		public Scanner(InputStream system) {\n			br = new BufferedReader(new InputStreamReader(system));\n		}\n\n		public Scanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n\n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n\n		public char nextChar() throws IOException {\n			return next().charAt(0);\n		}\n\n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n\n		public int[] nextIntArray(int n) throws IOException {\n			int[] array = new int[n];\n			for (int i = 0; i < n; i++)\n				array[i] = nextInt();\n			return array;\n		}\n\n		public Integer[] nextIntegerArray(int n) throws IOException {\n			Integer[] array = new Integer[n];\n			for (int i = 0; i < n; i++)\n				array[i] = new Integer(nextInt());\n			return array;\n		}\n\n		public long[] nextLongArray(int n) throws IOException {\n			long[] array = new long[n];\n			for (int i = 0; i < n; i++)\n				array[i] = nextLong();\n			return array;\n		}\n\n		public double[] nextDoubleArray(int n) throws IOException {\n			double[] array = new double[n];\n			for (int i = 0; i < n; i++)\n				array[i] = nextDouble();\n			return array;\n		}\n\n		public static int[] shuffle(int[] a) {\n			int n = a.length;\n			Random rand = new Random();\n			for (int i = 0; i < n; i++) {\n				int tmpIdx = rand.nextInt(n);\n				int tmp = a[i];\n				a[i] = a[tmpIdx];\n				a[tmpIdx] = tmp;\n			}\n			return a;\n		}\n\n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n\n		public void waitForInput() throws InterruptedException {\n			Thread.sleep(3000);\n		}\n	}\n}\n\n   	  							  				  	  		","dfs and similar,dsu,graphs,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class tr1 {\n	static PrintWriter out;\n	static StringBuilder sb;\n	static int n, m, k;\n	static long mod = 998244353;\n	static Boolean[][][] memo;\n	static String s;\n	static HashMap<Integer, Integer> nums;\n	static ArrayList<Integer>[] ad, ad1;\n	static int inf = 1000000, time = 1, timein[], timeout[];\n	static TreeSet<Integer> h;\n\n	public static void main(String[] args) throws Exception {\n		Scanner sc = new Scanner(System.in);\n		out = new PrintWriter(System.out);\n		n = sc.nextInt();\n		m = sc.nextInt();\n		int[] p = new int[n+1];\n		int[][] qu = new int[m][3];\n		ArrayList<Integer>[] packets = new ArrayList[m];\n		int[] source = new int[m];\n		ad = new ArrayList[n+1];\n		for (int i = 1; i <= n; i++)\n			ad[i] = new ArrayList<>();\n		for (int i = 0; i < m; i++)\n			packets[i] = new ArrayList<>();\n		Boolean[] ans = new Boolean[m];\n		int co = 1;\n		for (int i = 0; i < m; i++) {\n			qu[i][0] = sc.nextInt();\n			if (qu[i][0] == 1) {\n				qu[i][1] = sc.nextInt() ;\n				qu[i][2] = sc.nextInt() ;\n				p[qu[i][1]]++;\n				ad[qu[i][2]].add(qu[i][1]);\n			} else if (qu[i][0] == 2) {\n				qu[i][1] = sc.nextInt() ;\n				source[co] = qu[i][1];\n				co++;\n			} else {\n				qu[i][1] = sc.nextInt() ;\n				qu[i][2] = sc.nextInt();\n				packets[qu[i][2]].add(i);\n				packets[qu[i][2]].add(qu[i][1]);\n			}\n		}\n		timein = new int[n+1];\n		timeout = new int[n+1];\n		for (int i = 1; i <= n; i++)\n			if (p[i] == 0)\n				dfs(i, -1);\n		unionfind uf = new unionfind(n + 1);\n		//System.out.println(Arrays.toString(source));\n		//System.out.println(Arrays.toString(packets));\n		co=1;\n		for (int i = 0; i < m; i++) {\n			if (qu[i][0] == 3)\n				continue;\n			if (qu[i][0] == 1) {\n				uf.combine(qu[i][1], qu[i][2]);\n			} else {\n			//	System.out.println(co+"" co"");\n				for (int j = 0; j < packets[co].size(); j += 2) {\n					int id = packets[co].get(j);\n					int v = packets[co].get(j + 1);\n					if (!uf.sameSet(v, source[co])) {\n						ans[id] = false;\n						continue;\n					}\n					if (timein[v] <= timein[source[co]] && timeout[v] >= timeout[source[co]])\n						ans[id] = true;\n					else\n						ans[id] = false;\n				}\n				co++;\n			}\n		}\n		for (int i = 0; i < m; i++)\n			if (ans[i] != null)\n				if(ans[i]==true)\n				out.println(""YES"");\n				else\n					out.println(""NO"");\n		out.flush();\n	}\n\n	static void dfs(int u, int p) {\n		timein[u] = time++;\n		for (int v : ad[u])\n			if (v != p)\n				dfs(v, u);\n		timeout[u] = time++;\n	}\n\n	static class unionfind {\n		int[] p;\n		int[] size;\n		int[] max;\n		int num;\n\n		unionfind(int n) {\n			p = new int[n];\n			size = new int[n];\n			max = new int[n];\n			for (int i = 0; i < n; i++) {\n				p[i] = i;\n				max[i] = i;\n			}\n			Arrays.fill(size, 1);\n			num = n;\n		}\n\n		int findSet(int v) {\n			if (v == p[v])\n				return v;\n\n			max[v] = Math.max(max[v], max[p[v]]);\n\n			p[v] = findSet(p[v]);\n\n			max[v] = Math.max(max[v], max[p[v]]);\n\n			return p[v];\n		}\n\n		boolean sameSet(int a, int b) {\n			a = findSet(a);\n			b = findSet(b);\n			if (a == b)\n				return true;\n			return false;\n		}\n\n		int max() {\n			int max = 0;\n			for (int i = 0; i < size.length; i++)\n				if (size[i] > max)\n					max = size[i];\n			return max;\n		}\n\n		boolean combine(int a, int b) {\n			a = findSet(a);\n			b = findSet(b);\n			if (a == b)\n				return true;\n			num--;\n			if (size[a] > size[b]) {\n				p[b] = a;\n				max[a] = Math.max(max[a], max[b]);\n				size[a] += size[b];\n\n			} else {\n				p[a] = b;\n				max[b] = Math.max(max[a], max[b]);\n				size[b] += size[a];\n			}\n			return false;\n		}\n	}\n\n	static class Scanner {\n		StringTokenizer st;\n		BufferedReader br;\n\n		public Scanner(InputStream system) {\n			br = new BufferedReader(new InputStreamReader(system));\n		}\n\n		public Scanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n\n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n\n		public char nextChar() throws IOException {\n			return next().charAt(0);\n		}\n\n		public Long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n\n		public int[] nextArrInt(int n) throws IOException {\n			int[] a = new int[n];\n			for (int i = 0; i < n; i++)\n				a[i] = nextInt();\n			return a;\n		}\n\n		public long[] nextArrLong(int n) throws IOException {\n			long[] a = new long[n];\n			for (int i = 0; i < n; i++)\n				a[i] = nextLong();\n			return a;\n		}\n\n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n\n		public void waitForInput() throws InterruptedException {\n			Thread.sleep(3000);\n		}\n	}\n}","dfs and similar,dsu,graphs,trees"
"import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    static Scanner sc = new Scanner(System.in);\n    static PrintWriter out = new PrintWriter(System.out);\n    static int N, L[], P[][], mx[][], mxEdge;            // P[i][j] --> the 2^j th ancestor of node i\n    static int[] dirP, t;\n    static ArrayList<Integer>[] graph;\n\n\n    public static void main(String[] args) throws Exception {\n        N = sc.nextInt();\n        graph = new ArrayList[N];\n        for (int i = 0; i < N; i++)\n            graph[i] = new ArrayList<>();\n        int m =sc.nextInt();\n        int[][] q = new int[m][3];\n        int[] in = new int[N];\n        int[] mapDoc = new int[m];\n        t = new int[N];\n        int[] tdoc= new int[m];\n        int lstDoc = 0;\n        for(int i=0;i<m;i++){\n            q[i][0] = sc.nextInt();\n            q[i][1] = sc.nextInt()-1;\n            if(q[i][0] != 2) q[i][2] = sc.nextInt()-1;\n            if(q[i][0] == 1){\n                graph[q[i][2]].add(q[i][1]);\n                in[q[i][1]]++;\n                t[q[i][1]] = i;\n            }\n            if(q[i][0] == 2){\n                tdoc[lstDoc] = i;\n                mapDoc[lstDoc++] = q[i][1];\n            }\n        }\n        dirP = new int[N];\n        L = new int[N];\n        for(int i=0;i<N;i++)\n            if(in[i]==0)\n                dfs1(i, -1);\n        preprocessParents(0, dirP);\n        UnionFind uf = new UnionFind(N);\n        for(int[] cur: q){\n            if(cur[0]==1)\n                uf.unionSet(cur[1], cur[2]);\n            else if(cur[0]==3){\n                int x = mapDoc[cur[2]], y = cur[1];\n                int curtDoc = tdoc[cur[2]];\n                // find if y is an ancestor of x\n                out.println(uf.isSameSet(x,y) && query(x,y)==y && curtDoc>mxEdge?""YES"":""NO"");\n            }\n\n        }\n\n\n        out.flush();\n    }\n    public static int dis(int a, int b) {\n\n        return L[a] + L[b] - 2 * L[query(a, b)];\n    }\n\n    // get kth node (0 based) on the path from a to b in Log(N)\n    public static int kthNode(int a, int b, int k) {\n        int lca = query(a, b);\n        int dif = L[a] - L[lca];\n        if (k <= dif)\n            return kthParent(a, k);\n        else\n            return kthParent(b, L[b] - L[lca] - (k - dif));\n    }\n\n    public static void dfs1(int u, int p) {\n        dirP[u] = p;\n        for (int v : graph[u])\n            if (v != p) {\n                L[v] = 1 + L[u];\n                dfs1(v, u);\n            }\n\n    }\n\n\n    static class Edge {\n        int v, cost;\n\n        public Edge(int v, int cost) {\n            this.v = v;\n            this.cost = cost;\n        }\n    }\n\n\n    static void preprocessParents(int root, int[] T)    // O(n log n)\n    {\n        int k = 0;\n        while (1 << k + 1 < N) ++k;        // max parent = floor(log2(N - 1))\n\n        P = new int[N][k + 1];\n        mx = new int[N][k+1];\n\n        for (int i = 0; i < N; i++)\n            Arrays.fill(P[i], -1);\n\n        // base case: direct parents\n        for (int i = 0; i < N; ++i) {\n            P[i][0] = T[i];                    // T[root] = -1\n            mx[i][0] = t[i];\n        }\n        for (int j = 1; j <= k; j++)\n            for (int i = 0; i < N; i++)\n                if (P[i][j - 1] != -1) {\n                    P[i][j] = P[P[i][j - 1]][j - 1];\n                    mx[i][j] = Math.max(mx[i][j-1], mx[P[i][j-1]][j-1]);\n                }\n    }\n\n    static int query(int p, int q)        // O(log n)\n    {\n        //if p is situated on a higher level than q, swap them\n        if (L[p] < L[q]) {\n            p ^= q;\n            q ^= p;\n            p ^= q;\n        }\n\n        //find largest k such that 2^k is a parent of p\n        int k = 0;\n        while (1 << k + 1 <= L[p])\n            ++k;\n\n        mxEdge = -1;\n        //find the ancestor of p situated on the same level with q\n        for (int i = k; i >= 0; --i)\n            if (L[p] - (1 << i) >= L[q]) {\n                mxEdge = Math.max(mxEdge, mx[p][i]);\n                p = P[p][i];\n            }\n\n        if (p == q)\n            return p;\n\n        //go up to lowest (non-common) ancestors for p and q\n        for (int i = k; i >= 0; --i)\n            if (P[p][i] != -1 && P[p][i] != P[q][i]) {\n                p = P[p][i];\n                q = P[q][i];\n            }\n\n        return P[p][0];\n    }\n\n    public static int kthParent(int u, int k) {\n        for (int i = 0; (1 << i) <= k; i++)\n            if ((k & (1 << i)) > 0)\n                u = u > -1 ? P[u][i] : -1;\n        return u;\n    }\n\n    static class UnionFind {\n        int[] p, rank, setSize;\n        int numSets;\n\n        public UnionFind(int N)\n        {\n            p = new int[numSets = N];\n            rank = new int[N];\n            setSize = new int[N];\n            for (int i = 0; i < N; i++) {  p[i] = i; setSize[i] = 1; }\n        }\n\n        public int findSet(int i) { return p[i] == i ? i : (p[i] = findSet(p[i])); }\n\n        public boolean isSameSet(int i, int j) { return findSet(i) == findSet(j); }\n\n        public void unionSet(int i, int j)\n        {\n            if (isSameSet(i, j))\n                return;\n            numSets--;\n            int x = findSet(i), y = findSet(j);\n            if(rank[x] > rank[y]) { p[y] = x; setSize[x] += setSize[y]; }\n            else\n            {	p[x] = y; setSize[y] += setSize[x];\n                if(rank[x] == rank[y]) rank[y]++;\n            }\n        }\n\n        public int numDisjointSets() { return numSets; }\n\n        public int sizeOfSet(int i) { return setSize[findSet(i)]; }\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public boolean check() {\n            if (!st.hasMoreTokens()) return false;\n            return true;\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() {\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public boolean ready() {\n            try {\n                return br.ready();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int[] nextIntArr(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArr(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n\n        public double[] nextDoubleArr(int n) {\n            double[] a = new double[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextDouble();\n            return a;\n        }\n\n\n        public void waitForInput() {\n            try {\n                Thread.sleep(3000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n    								 		 	  	 	 		  				","dfs and similar,dsu,graphs,trees"
"import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    static Scanner sc = new Scanner(System.in);\n    static PrintWriter out = new PrintWriter(System.out);\n    static int N, L[], P[][], mx[][], mxEdge;            // P[i][j] --> the 2^j th ancestor of node i\n    static int[] dirP, t;\n    static ArrayList<Integer>[] graph;\n\n\n    public static void main(String[] args) throws Exception {\n        N = sc.nextInt();\n        graph = new ArrayList[N];\n        for (int i = 0; i < N; i++)\n            graph[i] = new ArrayList<>();\n        int m =sc.nextInt();\n        int[][] q = new int[m][3];\n        int[] in = new int[N];\n        int[] mapDoc = new int[m];\n        t = new int[N];\n        int[] tdoc= new int[m];\n        int lstDoc = 0;\n        for(int i=0;i<m;i++){\n            q[i][0] = sc.nextInt();\n            q[i][1] = sc.nextInt()-1;\n            if(q[i][0] != 2) q[i][2] = sc.nextInt()-1;\n            if(q[i][0] == 1){\n                graph[q[i][2]].add(q[i][1]);\n                in[q[i][1]]++;\n                t[q[i][1]] = i;\n            }\n            if(q[i][0] == 2){\n                tdoc[lstDoc] = i;\n                mapDoc[lstDoc++] = q[i][1];\n            }\n        }\n        dirP = new int[N];\n        L = new int[N];\n        for(int i=0;i<N;i++)\n            if(in[i]==0)\n                dfs1(i, -1);\n        preprocessParents(0, dirP);\n        UnionFind uf = new UnionFind(N);\n        for(int[] cur: q){\n            if(cur[0]==1)\n                uf.unionSet(cur[1], cur[2]);\n            else if(cur[0]==3){\n                int x = mapDoc[cur[2]], y = cur[1];\n                int curtDoc = tdoc[cur[2]];\n                // find if y is an ancestor of x\n                out.println(uf.isSameSet(x,y) && query(x,y)==y && curtDoc>mxEdge?""YES"":""NO"");\n            }\n\n        }\n\n\n        out.flush();\n    }\n    public static int dis(int a, int b) {\n\n        return L[a] + L[b] - 2 * L[query(a, b)];\n    }\n\n    // get kth node (0 based) on the path from a to b in Log(N)\n    public static int kthNode(int a, int b, int k) {\n        int lca = query(a, b);\n        int dif = L[a] - L[lca];\n        if (k <= dif)\n            return kthParent(a, k);\n        else\n            return kthParent(b, L[b] - L[lca] - (k - dif));\n    }\n\n    public static void dfs1(int u, int p) {\n        dirP[u] = p;\n        for (int v : graph[u])\n            if (v != p) {\n                L[v] = 1 + L[u];\n                dfs1(v, u);\n            }\n\n    }\n\n\n    static class Edge {\n        int v, cost;\n\n        public Edge(int v, int cost) {\n            this.v = v;\n            this.cost = cost;\n        }\n    }\n\n\n    static void preprocessParents(int root, int[] T)    // O(n log n)\n    {\n        int k = 0;\n        while (1 << k + 1 < N) ++k;        // max parent = floor(log2(N - 1))\n\n        P = new int[N][k + 1];\n        mx = new int[N][k+1];\n\n        for (int i = 0; i < N; i++)\n            Arrays.fill(P[i], -1);\n\n        // base case: direct parents\n        for (int i = 0; i < N; ++i) {\n            P[i][0] = T[i];                    // T[root] = -1\n            mx[i][0] = t[i];\n        }\n        for (int j = 1; j <= k; j++)\n            for (int i = 0; i < N; i++)\n                if (P[i][j - 1] != -1) {\n                    P[i][j] = P[P[i][j - 1]][j - 1];\n                    mx[i][j] = Math.max(mx[i][j-1], mx[P[i][j-1]][j-1]);\n                }\n    }\n\n    static int query(int p, int q)        // O(log n)\n    {\n        //if p is situated on a higher level than q, swap them\n        if (L[p] < L[q]) {\n            p ^= q;\n            q ^= p;\n            p ^= q;\n        }\n\n        //find largest k such that 2^k is a parent of p\n        int k = 0;\n        while (1 << k + 1 <= L[p])\n            ++k;\n\n        mxEdge = -1;\n        //find the ancestor of p situated on the same level with q\n        for (int i = k; i >= 0; --i)\n            if (L[p] - (1 << i) >= L[q]) {\n                mxEdge = Math.max(mxEdge, mx[p][i]);\n                p = P[p][i];\n            }\n\n        if (p == q)\n            return p;\n\n        //go up to lowest (non-common) ancestors for p and q\n        for (int i = k; i >= 0; --i)\n            if (P[p][i] != -1 && P[p][i] != P[q][i]) {\n                p = P[p][i];\n                q = P[q][i];\n            }\n\n        return P[p][0];\n    }\n\n    public static int kthParent(int u, int k) {\n        for (int i = 0; (1 << i) <= k; i++)\n            if ((k & (1 << i)) > 0)\n                u = u > -1 ? P[u][i] : -1;\n        return u;\n    }\n\n    static class UnionFind {\n        int[] p, rank, setSize;\n        int numSets;\n\n        public UnionFind(int N)\n        {\n            p = new int[numSets = N];\n            rank = new int[N];\n            setSize = new int[N];\n            for (int i = 0; i < N; i++) {  p[i] = i; setSize[i] = 1; }\n        }\n\n        public int findSet(int i) { return p[i] == i ? i : (p[i] = findSet(p[i])); }\n\n        public boolean isSameSet(int i, int j) { return findSet(i) == findSet(j); }\n\n        public void unionSet(int i, int j)\n        {\n            if (isSameSet(i, j))\n                return;\n            numSets--;\n            int x = findSet(i), y = findSet(j);\n            if(rank[x] > rank[y]) { p[y] = x; setSize[x] += setSize[y]; }\n            else\n            {	p[x] = y; setSize[y] += setSize[x];\n                if(rank[x] == rank[y]) rank[y]++;\n            }\n        }\n\n        public int numDisjointSets() { return numSets; }\n\n        public int sizeOfSet(int i) { return setSize[findSet(i)]; }\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public boolean check() {\n            if (!st.hasMoreTokens()) return false;\n            return true;\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() {\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public boolean ready() {\n            try {\n                return br.ready();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int[] nextIntArr(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArr(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n\n        public double[] nextDoubleArr(int n) {\n            double[] a = new double[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextDouble();\n            return a;\n        }\n\n\n        public void waitForInput() {\n            try {\n                Thread.sleep(3000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}","dfs and similar,dsu,graphs,trees"
"import java.io.*;\nimport java.util.*;\npublic class Main\n{\n	int n,a[];\n	Pair ans[];\n	Stack<Pair> deepest[];\n	ArrayList<Integer> list[];\n	final int maxn=(int)(2e6+1);\n	private void solve()throws IOException\n	{\n		sieve();\n		n=nextInt();\n		int q=nextInt();\n		a=new int[n+1];\n		for(int i=1;i<=n;i++)\n			a[i]=nextInt();\n		list=new ArrayList[n+1];\n		for(int i=1;i<=n;i++)\n			list[i]=new ArrayList<>();\n		for(int i=1;i<n;i++)\n		{\n			int u=nextInt();\n			int v=nextInt();\n			list[u].add(v);\n			list[v].add(u);\n		}\n		ans=new Pair[n+1];\n		deepest=new Stack[maxn+1];\n		for(int i=1;i<=maxn;i++)\n			deepest[i]=new Stack<>();\n		for(int i=1;i<=n;i++)\n			ans[i]=new Pair(-1,-1);\n		dfs(1,0,0);\n		while(q-->0)\n		{\n			int type=nextInt();\n			int v=nextInt();\n			if(type==1)\n				out.println(ans[v].first);\n			else\n			{\n				a[v]=nextInt();\n				for(int i=1;i<=n;i++)\n					ans[i]=new Pair(-1,-1);\n				dfs(1,0,0);\n			}\n		}\n	}\n	Pair curr;\n	int prime,x;\n	void dfs(int v,int p,int depth)\n	{\n		curr=new Pair(v,depth);\n		for(x=a[v];x>1;)\n		{\n			prime=sieve[x];\n			if(!deepest[prime].isEmpty() && deepest[prime].peek().second>ans[v].second)\n				ans[v]=deepest[prime].peek();\n			deepest[prime].push(curr);\n			while(x%prime==0)\n				x=x/prime;\n		}\n		for(int vv:list[v])\n			if(vv!=p)\n				dfs(vv,v,depth+1);\n		for(x=a[v];x>1;)\n		{\n			prime=sieve[x];\n			deepest[prime].pop();\n			while(x%prime==0)\n				x=x/prime;\n		}\n	}\n	int sieve[];\n	void sieve(){\n		sieve=new int[maxn+1];\n		for(int i=1;i<=maxn;i++)\n			sieve[i]=i;\n		for(int i=2;i*i<=maxn;i++){\n			if(sieve[i]==i){\n				for(int j=i;j<=maxn;j+=i)\n					sieve[j]=i;\n			}\n		}\n	}\n	class Pair{\n	    int first,second;\n	    Pair(int a,int b){\n	        first=a;\n	        second=b;\n	    }\n	}\n\n	 \n	///////////////////////////////////////////////////////////\n\n	public void run()throws IOException\n	{\n		br=new BufferedReader(new InputStreamReader(System.in));\n		st=null;\n		out=new PrintWriter(System.out);\n\n		solve();\n\n		br.close();\n		out.close();\n	}\n	public static void main(String args[])throws IOException{\n		new Main().run();\n	}\n	BufferedReader br;\n	StringTokenizer st;\n	PrintWriter out;\n	String nextToken()throws IOException{\n		while(st==null || !st.hasMoreTokens())\n		st=new StringTokenizer(br.readLine());\n		return st.nextToken();\n	}\n	String nextLine()throws IOException{\n		return br.readLine();\n	}\n	int nextInt()throws IOException{\n		return Integer.parseInt(nextToken());\n	}\n	long nextLong()throws IOException{\n		return Long.parseLong(nextToken());\n	}\n	double nextDouble()throws IOException{\n		return Double.parseDouble(nextToken());\n	}\n}","brute force,dfs and similar,math,number theory,trees"
"import java.io.*;\nimport java.util.*;\n\n\npublic class  Main{\n	static int[]smallestPrime;\n	 static void seive()\n	    {\n	        int N = (int)2e6 + 1 ;\n	        smallestPrime = new int [N + 1] ;\n	        for(int i = 2 ; i <= N ; i++)\n	            if(smallestPrime[i] == 0) \n	            {\n	                smallestPrime[i] = i ;\n	                if(1L * i * i <= N)\n	                    for (int j = i * i; j <= N; j += i) \n	                    {\n	                        if (smallestPrime[j] == 0)\n	                            smallestPrime[j] = i;\n	                    }\n	            }\n	    }\n	    static LinkedList<Integer> factorize(int val)\n	    {\n	        LinkedList<Integer> primes = new LinkedList<Integer>() ;\n	        while (val > 1)\n	        {\n	            primes.add(smallestPrime[val]) ;\n	            val /= smallestPrime[val] ;\n	        }\n	        return primes ;\n	    }\n	static LinkedList<Integer>[]adj;\n	static int[]vals,ans,levels;\n	static int[]map;\n	static void build() {\n		Arrays.fill(map, -1);\n		dfs2(0, -1);\n	}\n	static void dfs2(int i,int par) {\n		int nearest=-2;\n		LinkedList<Integer>primeFactors=factorize(vals[i]);\n		int[]primes=new int[primeFactors.size()];\n		int[]before=new int[primeFactors.size()];\n		int c=0;\n		for(int p:primeFactors) {\n			if(map[p]!=-1) {\n				int u=map[p];\n				primes[c]=p;\n				before[c++]=u;\n				if(nearest==-2 || levels[u]>levels[nearest]) {\n					nearest=u;\n				}\n			}\n			else {\n				primes[c]=p;\n				before[c++]=-1;\n			}\n		}\n		ans[i]=nearest;\n		\n		//adding my primes for my subtree\n		for(int p:primeFactors) {\n			map[p]=i;\n		}\n		\n		for(int j:adj[i]) {\n			if(j!=par)dfs2(j, i);\n		}\n		\n		//removing my primes for my siblings\n		for(int j=0;j<before.length;j++) {\n			map[primes[j]]=before[j];\n		}\n	}\n	static void dfs1(int i,int par,int lvl) {\n		levels[i]=lvl;\n		for(int j:adj[i]) {\n			if(j!=par) {\n				dfs1(j, i, lvl+1);\n			}\n		}\n	}\n	public static void main(String[] args) throws Exception{\n		MScanner sc=new MScanner(System.in);\n		//PrintWriter pw=new PrintWriter(System.out);\n		seive();\n		int n=sc.nextInt(),q=sc.nextInt();\n		adj=new LinkedList[n];\n		ans=new int[n];\n		map=new int[(int)2e6];\n		for(int i=0;i<n;i++)adj[i]=new LinkedList<Integer>();\n		vals=new int[n];\n		for(int i=0;i<n;i++)vals[i]=sc.nextInt();\n		for(int i=0;i<n-1;i++) {\n			int x=sc.nextInt()-1,y=sc.nextInt()-1;\n			adj[x].add(y);\n			adj[y].add(x);\n		}\n		\n		\n		levels=new int[n];\n		dfs1(0, -1, 0);\n		build();\n		\n		while(q-->0) {\n			if(sc.nextInt()==1) {\n				System.out.println(ans[sc.nextInt()-1]+1);\n			}\n			else {\n				vals[sc.nextInt()-1]=sc.nextInt();\n				build();\n			}\n		}\n		//pw.flush();\n	}\n	static class MScanner {\n		StringTokenizer st;\n		BufferedReader br;\n		public MScanner(InputStream system) {\n			br = new BufferedReader(new InputStreamReader(system));\n		}\n \n		public MScanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n \n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n		public int[] takearr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public long[] takearrl(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public Integer[] takearrobj(int n) throws IOException {\n	        Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public Long[] takearrlobj(int n) throws IOException {\n	        Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n \n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n \n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n \n		public char nextChar() throws IOException {\n			return next().charAt(0);\n		}\n \n		public Long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n \n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n \n		public void waitForInput() throws InterruptedException {\n			Thread.sleep(3000);\n		}\n	}\n}","brute force,dfs and similar,math,number theory,trees"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF463E extends PrintWriter {\n	CF463E() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF463E o = new CF463E(); o.main(); o.flush();\n	}\n\n	static final int A = 2000000;\n	int[] next, jj; int $ = 1, $$;\n	int link(int l, int j) {\n		next[$] = l; jj[$] = j;\n		return $++;\n	}\n	int[] aa, ao, dd, cc;\n	int[] tt, vv, bb;\n	int[][] pp = new int[A + 1][7];\n	int[] kk = new int[A + 1], po = new int[A + 1];\n	void init(int n, int m, int q) {\n		next = new int[1 + m * 2 + n * 7]; jj = new int[1 + m * 2 + n * 7];\n		aa = new int[n];\n		ao = new int[n]; dd = new int[n];\n		cc = new int[n];\n		tt = new int[q]; vv = new int[q]; bb = new int[q];\n		for (int a = 2; a <= A; a++) {\n			if (kk[a] != 0)\n				continue;\n			for (int b = a; b <= A; b += a)\n				pp[b][kk[b]++] = a;\n		}\n	}\n	void dfs(int p, int i, int d) {\n		dd[i] = d;\n		for (int l = ao[i]; l != 0; l = next[l]) {\n			int j = jj[l];\n			if (j != p)\n				dfs(i, j, d + 1);\n		}\n	}\n	void dfs_(int p, int i) {\n		int c = -1, a = aa[i];\n		for (int h = 0; h < kk[a]; h++) {\n			int a_ = pp[a][h], l = po[a_];\n			if (l != 0) {\n				int j = jj[l];\n				if (c == -1 || dd[c] < dd[j])\n					c = j;\n			}\n		}\n		for (int h = 0; h < kk[a]; h++) {\n			int a_ = pp[a][h];\n			po[a_] = link(po[a_], i);\n		}\n		for (int l = ao[i]; l != 0; l = next[l]) {\n			int j = jj[l];\n			if (j != p)\n				dfs_(i, j);\n		}\n		for (int h = 0; h < kk[a]; h++) {\n			int a_ = pp[a][h];\n			po[a_] = next[po[a_]];\n		}\n		cc[i] = c;\n	}\n	void solve(int l, int r) {\n		$ = $$;\n		dfs_(-1, 0);\n		for (int h = l; h < r; h++)\n			bb[h] = cc[vv[h]];\n	}\n	void main() {\n		int n = sc.nextInt();\n		int q = sc.nextInt();\n		init(n, n - 1, q);\n		for (int i = 0; i < n; i++)\n			aa[i] = sc.nextInt();\n		for (int h = 0; h < n - 1; h++) {\n			int i = sc.nextInt() - 1;\n			int j = sc.nextInt() - 1;\n			ao[i] = link(ao[i], j);\n			ao[j] = link(ao[j], i);\n		}\n		dfs(-1, 0, 0);\n		$$ = $;\n		for (int h = 0; h < q; h++) {\n			tt[h] = sc.nextInt();\n			vv[h] = sc.nextInt() - 1;\n			if (tt[h] == 2)\n				bb[h] = sc.nextInt();\n		}\n		int l = -1;\n		for (int h_ = -1, h = 0; h <= q; h++)\n			if (h == q || tt[h] == 2) {\n				if (h - h_ - 1 > 0)\n					solve(h_ + 1, h);\n				h_ = h;\n				if (h < q)\n					aa[vv[h]] = bb[h];\n			}\n		for (int h = 0; h < q; h++)\n			if (tt[h] == 1)\n				println(bb[h] == -1 ? -1 : bb[h] + 1);\n	}\n}\n","brute force,dfs and similar,math,number theory,trees"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class codeforces {\n	static int N,Q;\n	static int[] val, sol, sieve, depth;\n	static ArrayDeque<Integer>[] pSet;\n	static ArrayList<Integer>[] adj;\n	public static void main(String[] args) {\n		\n		sieve = new int[2000001];\n		Arrays.fill(sieve, -1);\n		for(int i=2;i<=2000000;i++){\n			if(sieve[i] != -1)continue;\n			for(int j=2;i*j<=2000000;j++){\n				sieve[i*j] = i;\n			}\n		}\n		\n		\n		FS scan = new FS(System.in);\n		N = scan.nextInt();\n		Q = scan.nextInt();\n		val = new int[N];\n		depth = new int[N];\n		for(int i=0;i<N;i++)val[i] = scan.nextInt();\n		\n		adj = new ArrayList[N];\n		for(int i=0;i<N;i++)adj[i] = new ArrayList<>();\n		for(int i=0;i<N-1;i++){\n			int u = scan.nextInt()-1, v = scan.nextInt()-1;\n			adj[u].add(v);\n			adj[v].add(u);\n		}\n		\n		sol = new int[N];\n		pSet = new ArrayDeque[2000001];\n		for(int i=0;i<pSet.length;i++)pSet[i] = new ArrayDeque<>();\n		Arrays.fill(sol, -1);\n		boolean reset = true;\n		\n		PrintWriter out = new PrintWriter(System.out);\n		for(int i=0;i<Q;i++){\n			int t = scan.nextInt();\n			if(t==1) {\n				if(reset){\n					solve(0,-1,0);\n					reset = false;\n				}\n				int u = scan.nextInt()-1;\n				out.println(sol[u] == -1 ? -1 : (sol[u]+1));\n			}\n			else{\n				int u = scan.nextInt()-1;\n				int v = scan.nextInt();\n				val[u] = v;\n				Arrays.fill(sol, -1);\n				reset = true;\n			}\n		}\n		out.close();\n	}\n	private static void solve(int idx, int par,int d) {\n		depth[idx] = d;\n		int x = val[idx];\n		while(x!=1) {\n			if(sieve[x] != -1) {\n				Integer X = pSet[sieve[x]].peekLast();\n				if(X != null){\n					if(sol[idx] == -1) sol[idx] = X;\n					else if(depth[sol[idx]] < depth[X]) sol[idx] = X;\n				}\n				x/=sieve[x];\n			} else{\n				Integer X = pSet[x].peekLast();\n				if(X != null) {\n					if(sol[idx] == -1) sol[idx] = X;\n					else if(depth[sol[idx]] < depth[X]) sol[idx] = X;\n				}\n				break;\n			}\n		}\n		x = val[idx];\n		while(x != 1) {\n			if(sieve[x]!=-1) {\n				pSet[sieve[x]].add(idx);\n				x /= sieve[x];\n			} else {\n				pSet[x].add(idx);\n				break;\n			}\n		}\n		\n		for(int u : adj[idx]) {\n			if(u == par)continue;\n			solve(u,idx,d+1);\n		}\n		\n		x = val[idx];\n		while(x != 1) {\n			if(sieve[x]!=-1) {\n				pSet[sieve[x]].pollLast();\n				x /= sieve[x];\n			} else {\n				pSet[x].pollLast();\n				break;\n			}\n		}\n		\n	}\n	private static class FS {\n		BufferedReader br;\n		StringTokenizer st;\n		public FS(InputStream in) {\n			br = new BufferedReader(new InputStreamReader(in));\n		}\n		String next(){\n			while(st==null||!st.hasMoreElements()){\n				try{st = new StringTokenizer(br.readLine());}\n				catch(IOException e){e.printStackTrace();}\n			}\n			return st.nextToken();\n		}\n		int nextInt() {return Integer.parseInt(next());}\n		long nextLong() {return Long.parseLong(next());}\n		double nextDouble() { return Double.parseDouble(next());}\n	}\n}\n","brute force,dfs and similar,math,number theory,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class F {\n\n	static ArrayList<Integer>[] adj;\n	static int a[], dp[][], MOD = (int) 1e9 + 7;\n\n	static void dfs(int u) {\n		dp[u][a[u]] = 1;\n		for (int v : adj[u]) {\n			dfs(v);\n\n			// calc for num=1\n			long ans = 0;\n			// take edge\n			ans = dp[v][1] * 1L * dp[u][0] + dp[v][0] * 1L * dp[u][1];\n			ans %= MOD;\n			// leave edge\n			ans += dp[u][1] * 1L * dp[v][1] % MOD;\n			ans %= MOD;\n			dp[u][1] = (int) ans;\n\n			// calc for num = 0;\n\n			// take this edge\n			ans = dp[u][0] * 1L * dp[v][0] % MOD;\n			// leave this edge\n			ans += dp[u][0] * 1L * dp[v][1] % MOD;\n			dp[u][0] = (int) (ans % MOD);\n\n		}\n\n	}\n\n	public static void main(String[] args) throws IOException {\n		Scanner sc = new Scanner();\n		PrintWriter out = new PrintWriter(System.out);\n		int n = sc.nextInt();\n		adj = new ArrayList[n];\n		for (int i = 0; i < n; i++)\n			adj[i] = new ArrayList();\n		for (int i = 1; i < n; i++)\n			adj[sc.nextInt()].add(i);\n		a = new int[n];\n		for (int i = 0; i < n; i++)\n			a[i] = sc.nextInt();\n		dp = new int[n][2];\n		dfs(0);\n		out.println(dp[0][1]);\n		out.close();\n\n	}\n\n	static class Scanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		Scanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		Scanner(String fileName) throws FileNotFoundException {\n			br = new BufferedReader(new FileReader(fileName));\n		}\n\n		String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() throws NumberFormatException, IOException {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() throws NumberFormatException, IOException {\n			return Double.parseDouble(next());\n		}\n\n		boolean ready() throws IOException {\n			return br.ready();\n		}\n\n	}\n\n	static void sort(int[] a) {\n		shuffle(a);\n		Arrays.sort(a);\n	}\n\n	static void shuffle(int[] a) {\n		int n = a.length;\n		Random rand = new Random();\n		for (int i = 0; i < n; i++) {\n			int tmpIdx = rand.nextInt(n);\n			int tmp = a[i];\n			a[i] = a[tmpIdx];\n			a[tmpIdx] = tmp;\n		}\n	}\n\n}","dfs and similar,dp,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class ApplemanAndTree {\n    static long[][] dp;\n    static int[] X;\n    static List<List<Integer>> G;\n    static final int MOD = 1000000007;\n    public static void dfs(int cur, int par) {\n        dp[cur][X[cur]] = 1;\n        for (int nxt : G.get(cur)) {\n            if (nxt != par) {\n                dfs(nxt, cur);\n                dp[cur][1] = (dp[cur][1] * dp[nxt][1] + dp[cur][1] * dp[nxt][0] + dp[cur][0] * dp[nxt][1]) % MOD;\n                dp[cur][0] = (dp[cur][0] * dp[nxt][1] + dp[cur][0] * dp[nxt][0]) % MOD;\n            }\n        }\n    }\n    public static void main(String[] args) {\n        InputReader reader = new InputReader(System.in);\n        PrintWriter writer = new PrintWriter(System.out, false);\n        int N = reader.nextInt();\n        G = new ArrayList<>(N);\n        for (int i = 0; i < N; i++) {\n            G.add(new ArrayList<>());\n        }\n        for (int i = 0; i < N - 1; i++) {\n            int p = reader.nextInt();\n            G.get(p).add(i + 1);\n        }\n        X = new int[N];\n        for (int i = 0; i < N; i++) {\n            X[i] = reader.nextInt();\n        }\n        dp = new long[N][2];\n        dfs(0, -1);\n        writer.println(dp[0][1]);\n        writer.close();\n        System.exit(0);\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        public String nextLine() {\n            String str = """";\n            try {\n                str = reader.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}","dfs and similar,dp,trees"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        BApplemanAndTree solver = new BApplemanAndTree();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BApplemanAndTree {\n        int n;\n        ArrayList<Integer>[] g;\n        int[] arr;\n        int mod = 1000000007;\n        long[][] dp;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n//        precompFacts();\n            n = in.nextInt();\n            g = new ArrayList[n];\n            for (int i = 0; i < n; i++) g[i] = new ArrayList<>();\n            for (int i = 0; i < n - 1; i++) {\n                int u = in.nextInt();\n                g[u].add(i + 1);\n                g[i + 1].add(u);\n            }\n            arr = in.nextIntArray(n);\n            dp = new long[n][2];\n            dfs(0, -1);\n            out.println(dp[0][1]);\n        }\n\n        void dfs(int nn, int pp) {\n            dp[nn][arr[nn]] = 1;\n            for (int a : g[nn]) {\n                if (a == pp) continue;\n                dfs(a, nn);\n                //taking\n                long val1 = mul(dp[nn][0], dp[a][0]);\n                long val2 = add(mul(dp[nn][1], dp[a][0]), mul(dp[nn][0], dp[a][1]));\n                //not taking\n                val1 = add(val1, mul(dp[nn][0], dp[a][1]));\n                val2 = add(val2, mul(dp[nn][1], dp[a][1]));\n                dp[nn][0] = val1;\n                dp[nn][1] = val2;\n            }\n        }\n\n        long add(long a, long b) {\n            return (a + b) % mod;\n        }\n\n        long mul(long a, long b) {\n            return (a * b) % mod;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] array = new int[n];\n            for (int i = 0; i < n; ++i) array[i] = nextInt();\n            return array;\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n","dfs and similar,dp,trees"
"/*\n        ""Everything in the universe is balanced. Every disappointment\n                you face in life will be balanced by something good for you!\n                        Keep going, never give up.""\n\n\n*/\n\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Solution {\n    static int MAX = 200005, MODULO = 1000000007;\n    static Map<Integer, List<Integer>> tree = new HashMap<>();\n    static int[] color = new int[MAX];\n    // dp[currNode][0] -> number of ways when currNode is not connected to a black vertex.\n    // dp[currNode][1] -> number of ways when currNode is connected to a black vertex.\n    static long[][] dp = new long[MAX][2];\n    static int n;\n    public static void main(String[] args) throws java.lang.Exception {\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        sc = new FastReader();\n\n        int test = 1;\n        for (int t = 0; t < test; t++) {\n            solve();\n        }\n        out.close();\n    }\n\n    private static void solve() {\n        n = sc.nextInt();\n        for (int i = 0; i < n; i++) {\n            tree.put(i, new ArrayList<>());\n        }\n        for (int i = 1; i < n; i++) {\n            int parent = sc.nextInt();\n            tree.get(parent).add(i);\n        }\n        for (int i = 0; i < n; i++) {\n            color[i] = sc.nextInt();\n        }\n        applemanAndTree(0); // start from root node\n        out.println(dp[0][1]);\n    }\n\n    private static void applemanAndTree(int currNode) {\n        for (int childNode : tree.get(currNode)) { // dfs\n            applemanAndTree(childNode);\n        }\n        long noOfWays = 1;\n        for (int childNode : tree.get(currNode)) {\n            /*\n                If the currNode is black, dp[currNode][0] has no possible way, and\n                dp[currNode][1] = (remove the edge between currNode and childNode, ie forming different sub-parts each having exactly one black vertex,\n                + don't remove the edge, ie. the childNode must not have any black vertex).\n\n            */\n            noOfWays = mulMod(noOfWays, addMod(dp[childNode][0], dp[childNode][1]));\n        }\n        if (color[currNode] == 1) { // black node\n            dp[currNode][0] = 0;\n            dp[currNode][1] = noOfWays;\n        }else {\n            dp[currNode][0] = noOfWays;\n            dp[currNode][1] = 0;\n\n            /*\n                If currNode is white, we can take exactly one childNode having black vertex, and rest as no black vertex.\n                so, dp[currNode][1] = dp[child1][0] * (dp[child2][1] + dp[child3][1]...) + dp[child2][0] * (dp[child1][1] + dp[child3][1]...)...\n            */\n            for (int childNode : tree.get(currNode)) {\n                long extra = divMod(noOfWays, addMod(dp[childNode][0], dp[childNode][1]));\n                dp[currNode][1] = addMod(dp[currNode][1], mulMod(dp[childNode][1], extra));\n            }\n        }\n    }\n\n    private static long addMod(long a, long b) {\n        return (a % MODULO + b % MODULO) % MODULO;\n    }\n\n    private static long subMod(long a, long b) {\n        return (a % MODULO - b % MODULO + MODULO) % MODULO;\n    }\n\n    private static long mulMod(long a, long b) {\n        return ((a % MODULO) * (b % MODULO)) % MODULO;\n    }\n\n    private static long divMod(long a, long b) {\n        return mulMod(a, power(b, MODULO - 2));\n    }\n\n    private static long power(long a, int b) {\n        long ans = 1;\n        a %= MODULO;\n        while (b > 0) {\n            if ((b & 1) == 1) {\n                ans *= a;\n                ans %= MODULO;\n            }\n            b >>= 1;\n            a = (a * a) % MODULO;\n        }\n        return ans;\n    }\n\n\n\n    public static FastReader sc;\n    public static PrintWriter out;\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer str;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (str == null || !str.hasMoreElements())\n            {\n                try\n                {\n                    str = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  end)\n                {\n                    end.printStackTrace();\n                }\n            }\n            return str.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = """";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException end)\n            {\n                end.printStackTrace();\n            }\n            return str;\n        }\n    }\n}","dfs and similar,dp,trees"
"import java.util.*;\npublic class JzzhuAndChildren {\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		int max = 0, ans = 0;\n		\n		for(int i = 1; i <= n; i++) {\n			int a = (int) Math.ceil( sc.nextDouble()/m);\n			if(a >= max) {\n				max = a;\n				ans = i;\n			}\n		}\n		\n		System.out.print(ans);\n\n	}\n\n}\n",implementation
"import java.util.*;\npublic class JzzhuAndChildren {\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		int max = 0, ans = 0;\n		\n		for(int i = 1; i <= n; i++) {\n			int a = (int) Math.ceil( sc.nextDouble()/m);\n			if(a >= max) {\n				max = a;\n				ans = i;\n			}\n		}\n		\n		System.out.print(ans);\n\n	}\n\n}\n",implementation
"import java.util.*;\npublic class JzzhuAndChildren {\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		int max = 0, ans = 0;\n		\n		for(int i = 1; i <= n; i++) {\n			int a = (int) Math.ceil( sc.nextDouble()/m);\n			if(a >= max) {\n				max = a;\n				ans = i;\n			}\n		}\n		\n		System.out.print(ans);\n\n	}\n\n}\n",implementation
"import java.util.*;\npublic class JzzhuAndChildren {\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		int max = 0, ans = 0;\n		\n		for(int i = 1; i <= n; i++) {\n			int a = (int) Math.ceil( sc.nextDouble()/m);\n			if(a >= max) {\n				max = a;\n				ans = i;\n			}\n		}\n		\n		System.out.print(ans);\n\n	}\n\n}\n",implementation
"import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		FastScanner in = new FastScanner(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		TaskD solver = new TaskD();\n		solver.solve(1, in, out);\n		out.close();\n	}\n}\n\nclass TaskD {\n	public void solve(int testNumber, FastScanner in, PrintWriter out) {\n		int n = in.nextInt() + 1;\n		int[] p = new int[n];\n		// d[i] is what we are going to ""return"" to p[i] in our DP\n		// so the answer is max(d[j]) over all chlidren j of the root\n		int[] d = new int[n];\n		int[] max1 = new int[n];\n		int[] max2 = new int[n];\n		int[] numChildren = new int[n];\n		p[0] = -1;\n		int ans = 0;\n		for (int i = 1; i < n; i++) {\n			p[i] = in.nextInt() - 1;\n			++numChildren[p[i]];\n			d[i] = 1;\n			for (int j = i; j > 0; j = p[j]) {\n				int k = p[j];\n				int old = d[k];\n				if (max1[k] < d[j]) {\n					max2[k] = max1[k];\n					max1[k] = d[j];\n				} else if (max2[k] < d[j]) {\n					max2[k] = d[j];\n				}\n				if (numChildren[k] == 1) {\n					d[k] = Math.max(max1[k], 1);\n				} else {\n					d[k] = Math.max(max1[k], max2[k] + 1);\n				}\n				if (k == 0) {\n					ans = Math.max(ans, d[j]);\n				}\n				if (d[k] == old) {\n					break;\n				}\n			}\n			out.print(ans + "" "");\n		}\n	}\n\n}\n\nclass FastScanner {\n\n	private BufferedReader in;\n	private StringTokenizer st;\n\n	public FastScanner(InputStream stream) {\n		in = new BufferedReader(new InputStreamReader(stream));\n	}\n\n	public String next() {\n		while (st == null || !st.hasMoreTokens()) {\n			try {\n				st = new StringTokenizer(in.readLine());\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n		}\n		return st.nextToken();\n	}\n\n	public int nextInt() {\n		return Integer.parseInt(next());\n	}\n\n}\n\n","data structures,trees"
"import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		FastScanner in = new FastScanner(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		TaskD solver = new TaskD();\n		solver.solve(1, in, out);\n		out.close();\n	}\n}\n\nclass TaskD {\n	public void solve(int testNumber, FastScanner in, PrintWriter out) {\n		int n = in.nextInt() + 1;\n		int[] p = new int[n];\n		// d[i] is what we are going to ""return"" to p[i] in our DP\n		// so the answer is max(d[j]) over all chlidren j of the root\n		// in other words, ans == max1[0]\n		int[] d = new int[n];\n		int[] max1 = new int[n];\n		int[] max2 = new int[n];\n		int[] numChildren = new int[n];\n		p[0] = -1;\n		int ans = 0;\n		for (int i = 1; i < n; i++) {\n			p[i] = in.nextInt() - 1;\n			++numChildren[p[i]];\n			d[i] = 1;\n			for (int j = i; j > 0; j = p[j]) {\n				int k = p[j];\n				int old = d[k];\n				if (max1[k] < d[j]) {\n					max2[k] = max1[k];\n					max1[k] = d[j];\n				} else if (max2[k] < d[j]) {\n					max2[k] = d[j];\n				}\n				if (numChildren[k] == 1) {\n					d[k] = Math.max(max1[k], 1);\n				} else {\n					d[k] = Math.max(max1[k], max2[k] + 1);\n				}\n				if (k == 0) {\n					ans = Math.max(ans, d[j]);\n				}\n				if (d[k] == old) {\n					break;\n				}\n			}\n			out.print(ans + "" "");\n		}\n	}\n\n}\n\nclass FastScanner {\n\n	private BufferedReader in;\n	private StringTokenizer st;\n\n	public FastScanner(InputStream stream) {\n		in = new BufferedReader(new InputStreamReader(stream));\n	}\n\n	public String next() {\n		while (st == null || !st.hasMoreTokens()) {\n			try {\n				st = new StringTokenizer(in.readLine());\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n		}\n		return st.nextToken();\n	}\n\n	public int nextInt() {\n		return Integer.parseInt(next());\n	}\n\n}\n\n","data structures,trees"
"import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		InputReader in = new InputReader(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		TaskD solver = new TaskD();\n		solver.solve(1, in, out);\n		out.close();\n	}\n}\n\nclass TaskD {\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = in.nextInt();\n        int[] parent = new int[n + 2];\n        int[] value = new int[n + 2];\n        int[] max = new int[n + 2];\n        for (int i = 2; i <= n+1; ++i) {\n            parent[i] = in.nextInt();\n            value[i] = 0;\n            int up = 1;\n            int cur = i;\n            while (cur != 1) {\n                int next = parent[cur];\n                if (value[next] < up) {\n                    value[next] = up;\n                    max[next] = cur;\n                } else if (value[next] == up && cur != max[next]) {\n                    ++up;\n                } else {\n                    break;\n                }\n                cur = next;\n            }\n            out.print(value[1] + "" "");\n        }\n        out.println();\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer stt;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n    }\n\n    public String nextLine() {\n        try {\n            return reader.readLine().trim();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    public String nextString() {\n        while (stt == null || !stt.hasMoreTokens()) {\n            stt = new StringTokenizer(nextLine());\n        }\n        return stt.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(nextString());\n    }\n\n}\n\n","data structures,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class D_new {\n\n	BufferedReader br;\n	PrintWriter out;\n	StringTokenizer st;\n	boolean eof;\n\n	void solve() throws IOException {\n		int n = nextInt();\n		int outp = 0;\n		int[] p = new int[n];\n		int[] val = new int[n];\n		int[] childMax = new int[n];\n		Arrays.fill(childMax, -1);\n		for (int i = 0; i < n; i++) {\n			p[i] = nextInt() - 2;\n			val[i] = 1;\n			if (p[i] == -1) {\n				outp = Math.max(outp, 1);\n			} else {\n				do {\n					if (childMax[p[i]] == -1) {\n						childMax[p[i]] = 1;\n						break;\n					}\n					if (val[p[i]] > 1) {\n						break;\n					}\n					int v = p[i];\n					val[v] = 2;\n					while (p[v] != -1) {\n//						if (i == n - 1) {\n//							System.err.println(v + "" "" + val[v]);\n//						}\n						if (val[v] == childMax[p[v]]\n								&& val[p[v]] == childMax[p[v]]) {\n							val[p[v]]++;\n							v = p[v];\n						} else if (val[v] > childMax[p[v]]) {\n							childMax[p[v]] = val[v];\n							if (val[p[v]] < val[v]) {\n								val[p[v]]++;\n								v = p[v];\n							} else {\n								break;\n							}\n						} else {\n							break;\n						}\n					}\n					if (p[v] == -1) {\n						outp = Math.max(outp, val[v]);\n					}\n				} while (false);\n			}\n			out.print(outp + "" "");\n		}\n		out.println();\n	}\n\n	D_new() throws IOException {\n		br = new BufferedReader(new InputStreamReader(System.in));\n		out = new PrintWriter(System.out);\n		solve();\n		out.close();\n	}\n\n	public static void main(String[] args) throws IOException {\n		new D_new();\n	}\n\n	String nextToken() {\n		while (st == null || !st.hasMoreTokens()) {\n			try {\n				st = new StringTokenizer(br.readLine());\n			} catch (Exception e) {\n				eof = true;\n				return null;\n			}\n		}\n		return st.nextToken();\n	}\n\n	String nextString() {\n		try {\n			return br.readLine();\n		} catch (IOException e) {\n			eof = true;\n			return null;\n		}\n	}\n\n	int nextInt() throws IOException {\n		return Integer.parseInt(nextToken());\n	}\n\n	long nextLong() throws IOException {\n		return Long.parseLong(nextToken());\n	}\n\n	double nextDouble() throws IOException {\n		return Double.parseDouble(nextToken());\n	}\n}","data structures,trees"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        DTheChildAndSequence solver = new DTheChildAndSequence();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DTheChildAndSequence {\n        int[] val;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt(), m = in.nextInt();\n            val = in.nextIntArray(n);\n            ST s = new ST(0, n - 1, val);\n            while (m-- > 0) {\n                int t = in.nextInt();\n                if (t == 1) {\n                    int l = in.nextInt() - 1, r = in.nextInt() - 1;\n                    out.println(s.querys(l, r));\n                } else if (t == 2) {\n                    int l = in.nextInt() - 1, r = in.nextInt() - 1, x = in.nextInt();\n                    int now = s.querym(l, r);\n                    while (val[now] >= x) {\n                        int mod = val[now] % x;\n//                    out.println(now,val[now],mod,l,r);\n                        s.update(now, mod);\n                        val[now] = mod;\n                        now = s.querym(l, r);\n                    }\n                } else {\n                    int id = in.nextInt() - 1, x = in.nextInt();\n                    s.update(id, x);\n                    val[id] = x;\n//                out.println(id,x,s.querys(id,id));\n                }\n            }\n        }\n\n        class ST {\n            int leftmost;\n            int rightmost;\n            ST lchild;\n            ST rchild;\n            long sum;\n            int max;\n            int maxind;\n\n            public ST(int leftmost, int rightmost, int[] a) {\n                this.leftmost = leftmost;\n                this.rightmost = rightmost;\n                if (leftmost == rightmost) {\n                    //leaf\n                    sum = a[leftmost];\n                    max = a[leftmost];\n                    maxind = leftmost;\n                } else {\n                    // 2 children\n                    int mid = (leftmost + rightmost) / 2;\n                    // (l,mid) (mid+1,r)\n                    lchild = new ST(leftmost, mid, a);\n                    rchild = new ST(mid + 1, rightmost, a);\n                    recalc();\n                }\n            }\n\n            public void recalc() {\n                if (leftmost == rightmost) return;\n                sum = lchild.sum + rchild.sum;\n                max = Math.max(lchild.max, rchild.max);\n                if (lchild.max > rchild.max) maxind = lchild.maxind;\n                else maxind = rchild.maxind;\n            }\n\n            public void update(int index, int newVal) {\n                if (leftmost == rightmost) {\n                    //leaf;\n                    sum = newVal;\n                    max = newVal;\n                } else {\n                    // 2 children\n                    if (index <= lchild.rightmost) lchild.update(index, newVal);\n                    else rchild.update(index, newVal);\n                    recalc();\n                }\n            }\n\n            public long querys(int l, int r) {\n                // entirely disjoint\n                if (l > rightmost || r < leftmost) return 0;\n                // covers us\n                if (l <= leftmost && r >= rightmost) return sum;\n                // we don't know\n                return lchild.querys(l, r) + rchild.querys(l, r);\n            }\n\n            public int querym(int l, int r) {\n                if (l > rightmost || r < leftmost) return -1;\n                // covers us\n                if (l <= leftmost && r >= rightmost) return maxind;\n                // we don't know\n                int a = lchild.querym(l, r);\n                int b = rchild.querym(l, r);\n                if (a == -1) return b;\n                else if (b == -1) return a;\n                else {\n                    if (val[a] > val[b]) return a;\n                    else return b;\n                }\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] array = new int[n];\n            for (int i = 0; i < n; ++i) array[i] = nextInt();\n            return array;\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n","data structures,math"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.Comparator;\nimport java.util.TreeSet;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DTheChildAndSequence solver = new DTheChildAndSequence();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DTheChildAndSequence {\n        int MAXN = 200005;\n        PrintWriter out;\n        InputReader in;\n        int n;\n        int sqrt;\n        long[] segtree;\n        long[] arr = new long[MAXN];\n        TreeSet<Tuple>[] tset = new TreeSet[MAXN];\n        final Comparator<Tuple> com = new Comparator<Tuple>() {\n            public int compare(Tuple t1, Tuple t2) {\n                if (t1.x != t2.x)\n                    return Long.compare(t1.x, t2.x);\n                else\n                    return Long.compare(t1.y, t2.y);\n            }\n        };\n\n        long merge(long x, long y) {\n            return x + y;\n        }\n\n        void build_segtree() {\n            int i = 0;\n            for (i = n - 1; i > 0; i--)\n                segtree[i] = merge(segtree[i << 1], segtree[i << 1 | 1]);\n        }\n\n        void segtree_update(int ind, long val) {\n            for (segtree[ind += n] = val; ind > 1; ind >>= 1)\n                segtree[ind >> 1] = merge(segtree[ind], segtree[ind ^ 1]);\n        }\n\n        long query(int l, int r) {\n            long res = 0;\n            for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n                if ((l & 1) == 1)\n                    res = merge(res, segtree[l++]);\n                if ((r & 1) == 1)\n                    res = merge(res, segtree[--r]);\n            }\n            return res;\n        }\n\n        void build_sqrt() {\n            int i = 0, blk_ind = -1;\n            for (i = 0; i < n; i++) {\n                if (i % sqrt == 0)\n                    blk_ind++;\n                tset[blk_ind].add(new Tuple(arr[i], i));\n            }\n        }\n\n        void sqrt_update(int l, int r, long X) {\n            int ind = l / sqrt;\n            while (l < r && l % sqrt != 0 && l != 0) {\n                if (arr[l] >= X) {\n                    tset[ind].remove(new Tuple(arr[l], l));\n                    arr[l] %= X;\n                    segtree_update(l, arr[l]);\n                    tset[ind].add(new Tuple(arr[l], l));\n                }\n                l++;\n            }\n            while (l + sqrt <= r) {\n                while (tset[l / sqrt].last().x >= X) {\n                    Tuple curr = tset[l / sqrt].pollLast();\n                    arr[(int) curr.y] %= X;\n                    segtree_update((int) curr.y, arr[(int) curr.y]);\n                    tset[l / sqrt].add(new Tuple(arr[(int) curr.y], curr.y));\n                }\n                l += sqrt;\n            }\n            ind = l / sqrt;\n            while (l <= r) {\n                if (arr[l] >= X) {\n                    tset[ind].remove(new Tuple(arr[l], l));\n                    arr[l] %= X;\n                    segtree_update(l, arr[l]);\n                    tset[ind].add(new Tuple(arr[l], l));\n                }\n                l++;\n            }\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            this.out = out;\n            this.in = in;\n            n = ni();\n            sqrt = (int) Math.sqrt(n);\n            int m = ni();\n            segtree = new long[2 * n];\n            int i = 0;\n            for (i = 0; i < n; i++) {\n                tset[i] = new TreeSet<>(com);\n                arr[i] = nl();\n                segtree[n + i] = arr[i];\n            }\n            build_segtree();\n            build_sqrt();\n            while (m-- > 0) {\n                int type = ni();\n                if (type == 1) {\n                    pn(query(ni() - 1, ni()));\n                } else if (type == 2) {\n                    sqrt_update(ni() - 1, ni() - 1, nl());\n                } else {\n                    int ind = ni() - 1;\n                    long x = nl();\n                    tset[ind / sqrt].remove(new Tuple(arr[ind], ind));\n                    segtree_update(ind, x);\n                    arr[ind] = x;\n                    tset[ind / sqrt].add(new Tuple(arr[ind], ind));\n                }\n            }\n        }\n\n        int ni() {\n            return in.nextInt();\n        }\n\n        long nl() {\n            return in.nextLong();\n        }\n\n        void pn(long zx) {\n            out.println(zx);\n        }\n\n        class Tuple {\n            long x;\n            long y;\n\n            Tuple(long a, long b) {\n                x = a;\n                y = b;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new UnknownError();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n        }\n\n    }\n}\n\n","data structures,math"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DTheChildAndSequence solver = new DTheChildAndSequence();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DTheChildAndSequence {\n        int n;\n        int m;\n        int[] arr;\n\n        public void readInput(Scanner sc) {\n            n = sc.nextInt();\n            m = sc.nextInt();\n            arr = new int[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = sc.nextInt();\n        }\n\n        public void solve(int testNumber, Scanner sc, PrintWriter pw) {\n            readInput(sc);\n            int N = 1;\n            while (N < n)\n                N <<= 1;\n            SegmentTree st = new SegmentTree(N);\n            for (int i = 0; i < n; i++)\n                st.update_point(i + 1, arr[i]);\n            for (int i = n + 1; i <= N; i++)\n                st.update_point(i, 0);\n            for (int i = 0; i < m; i++) {\n                int type = sc.nextInt();\n                if (type == 1) {\n                    pw.println(st.query(sc.nextInt(), sc.nextInt()));\n                } else if (type == 2) {\n                    int l = sc.nextInt(), r = sc.nextInt();\n                    st.update_range(l, r, sc.nextInt());\n                } else {\n                    st.update_point(sc.nextInt(), sc.nextInt());\n                }\n            }\n        }\n\n        public class SegmentTree {\n            int N;\n            Node[] sTree;\n            int[] lazy;\n\n            SegmentTree(int N) {\n                this.N = N;\n                sTree = new Node[N << 1];        //no. of nodes = 2*N - 1, we add one to cross out index zero\n                lazy = new int[N << 1];\n                Arrays.fill(sTree, new Node(0, 0, 0));\n                Arrays.fill(lazy, -1);\n            }\n\n            public Node merge(Node first, Node second) {\n                long sum = first.sum + second.sum;\n                int max = Math.max(first.max, second.max);\n                int min = Math.min(first.min, second.min);\n                return new Node(sum, max, min);\n            }\n\n            void update_point(int index, int val) {\n                update_point(1, 1, N, index, index, val);\n            }\n\n            private void update_point(int node, int b, int e, int i, int j, int val) {\n                if (i > e || b > j)\n                    return;\n                if (b >= i && e <= j) {\n                    sTree[node] = new Node(val, val, val);\n                    return;\n                }\n                int mid = b + e >> 1;\n                propagate(node, b, mid, e);\n                update_point(node << 1, b, mid, i, j, val);\n                update_point(node << 1 | 1, mid + 1, e, i, j, val);\n                sTree[node] = merge(sTree[node << 1], sTree[node << 1 | 1]);\n            }\n\n            void update_range(int i, int j, int val) {\n                update_range(1, 1, N, i, j, val);\n            }\n\n            void update_range(int node, int b, int e, int i, int j, int val) {\n                if (i > e || j < b || sTree[node].max < val)\n                    return;\n                if (b >= i && e <= j && sTree[node].max == sTree[node].min) {\n                    int max = sTree[node].max % val;\n                    sTree[node].sum = 1l * (e - b + 1) * max;\n                    sTree[node].max = max;\n                    sTree[node].min = max;\n                    lazy[node] = val;\n                } else {\n                    int mid = b + e >> 1;\n                    propagate(node, b, mid, e);\n                    update_range(node << 1, b, mid, i, j, val);\n                    update_range(node << 1 | 1, mid + 1, e, i, j, val);\n                    sTree[node] = merge(sTree[node << 1], sTree[node << 1 | 1]);\n                }\n            }\n\n            void propagate(int node, int b, int mid, int e) {\n                if (lazy[node] != -1) {\n                    lazy[node << 1] = lazy[node];\n                    lazy[node << 1 | 1] = lazy[node];\n                    sTree[node << 1].sum = 1l * (mid - b + 1) * sTree[node].max;\n                    sTree[node << 1 | 1].sum = 1l * (e - mid) * sTree[node].max;\n                    sTree[node << 1].max = sTree[node].max;\n                    sTree[node << 1].min = sTree[node].max;\n                    sTree[node << 1 | 1].max = sTree[node].max;\n                    sTree[node << 1 | 1].min = sTree[node].max;\n                }\n                lazy[node] = -1;\n            }\n\n            long query(int i, int j) {\n                return query(1, 1, N, i, j);\n            }\n\n            long query(int node, int b, int e, int i, int j) {\n                if (i > e || j < b)\n                    return 0;\n                if (b >= i && e <= j)\n                    return sTree[node].sum;\n                int mid = b + e >> 1;\n                propagate(node, b, mid, e);\n                long q1 = query(node << 1, b, mid, i, j);\n                long q2 = query(node << 1 | 1, mid + 1, e, i, j);\n                return q1 + q2;\n\n            }\n\n            public class Node {\n                long sum;\n                int max;\n                int min;\n\n                public Node(long sum, int max, int min) {\n                    this.sum = sum;\n                    this.max = max;\n                    this.min = min;\n                }\n\n                public String toString() {\n                    return ""Node{"" +\n                            ""sum="" + sum +\n                            "", max="" + max +\n                            "", min="" + min +\n                            '}';\n                }\n\n            }\n\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() {\n            try {\n                while (st == null || !st.hasMoreTokens())\n                    st = new StringTokenizer(br.readLine());\n                return st.nextToken();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n","data structures,math"
"import java.io.*;\nimport java.util.*;\n \npublic class Main extends PrintWriter {\n    \n    \n    private void solve()  {\n        n = sc.nextInt();\n        int m = sc.nextInt();\n        a = new long[n];\n        for(int i = 0; i < n; i++) a[i] = sc.nextLong();\n        sum = new long[4*n];\n        max = new long[4*n];\n        min = new long[4*n];\n        build(1,n,1);\n        lazy_set = new long[4*n];\n        old = new boolean[4*n];\n        for(int i = 0; i < m; i++) {\n            int qt = sc.nextInt();\n            if(qt == 1) {\n                int l = sc.nextInt();\n                int r = sc.nextInt();\n                println(query_range(1, n, 1, l, r));\n            } else if(qt == 2) {\n                int l = sc.nextInt();\n                int r = sc.nextInt();\n                long x = sc.nextLong();\n                mod_range(1, n, 1, l, r, x);\n            } else {\n                int k = sc.nextInt();\n                long x = sc.nextLong();\n                set_point(1, n, 1, k, x);\n            }\n        }\n    }\n    \n    void build(int il, int ir, int i) {\n        if(il == ir) {\n            sum[i] = a[il-1];\n            max[i] = a[il-1];\n            min[i] = a[il-1];\n        } else {\n            int imid = (il+ir)/2;\n            build(il, imid, 2*i);\n            build(imid+1, ir, 2*i+1);\n            sum[i] = sum[2*i] + sum[2*i+1];\n            max[i] = Math.max(max[2*i], max[2*i+1]);\n            min[i] = Math.min(min[2*i], min[2*i+1]);\n        }\n    }\n \n    int n;\n    long[] a;\n    long[] sum;\n    long[] max;\n    long[] min;\n    \n    long[] lazy_set;\n    boolean[] old;\n    \n    long query_range(int il, int ir, int i, int ql, int qr) {\n        lazy_propagate(il, ir, i);\n        if(ir < ql || il > qr) return 0L;\n \n        \n        if(ql <= il && ir <= qr) {\n            return sum[i];\n        }\n        \n        int imid = (il+ir)/2;\n        long a_l = query_range(il, imid, 2*i, ql, qr);\n        long a_r = query_range(imid+1, ir, 2*i+1, ql, qr);\n        return a_l + a_r;\n    }\n    \n    void mod_range(int il, int ir, int i, int ql, int qr, long x) {\n        lazy_propagate(il, ir, i);\n        if(ir < ql || il > qr || max[i] < x) return;\n        \n        if(ql <= il && ir <= qr && max[i] == min[i]) {\n            long res = max[i] % x;\n            push(i, res);\n            lazy_propagate(il, ir, i);\n            return;\n        }\n        \n        int imid = (il+ir)/2;\n        mod_range(il, imid, 2*i, ql, qr, x);\n        mod_range(imid+1, ir, 2*i+1, ql, qr, x);\n        sum[i] = sum[2*i] + sum[2*i+1];\n        max[i] = Math.max(max[2*i], max[2*i+1]);\n        min[i] = Math.min(min[2*i], min[2*i+1]);\n    }\n    \n    void set_point(int il, int ir, int i, int q, long x) {\n        lazy_propagate(il, ir, i);\n        if(ir < q || il > q) return;\n        \n        if(q <= il && ir <= q) {\n            sum[i] = x;\n            max[i] = x;\n            min[i] = x;\n            return;\n        }\n        \n        int imid = (il+ir)/2;\n        set_point(il, imid, 2*i, q, x);\n        set_point(imid+1, ir, 2*i+1, q, x);\n        sum[i] = sum[2*i] + sum[2*i+1];\n        max[i] = Math.max(max[2*i], max[2*i+1]);\n        min[i] = Math.min(min[2*i], min[2*i+1]);\n    }\n    \n    void push(int i, long res) {\n        lazy_set[i] = res;\n        old[i] = true;\n    }\n    \n    void lazy_propagate(int il, int ir, int i) {\n        if(old[i]) {\n            max[i] = lazy_set[i];\n            min[i] = lazy_set[i];\n            sum[i] = lazy_set[i] * (ir-il+1);\n            if(il != ir) {\n                push(2*i, lazy_set[i]);\n                push(2*i+1, lazy_set[i]);\n            }\n            lazy_reset(i);\n        }\n    }\n    \n    void lazy_reset(int i) {\n        lazy_set[i] = 0L;\n        old[i] = false;\n    }\n   \n//  Main() throws FileNotFoundException { super(new File(""output.txt"")); }\n//  InputReader sc = new InputReader(new FileInputStream(""test_input.txt""));\n    \n  Main() { super(System.out); }\n  InputReader sc = new InputReader(System.in);\n  static class InputReader {\n      InputReader(InputStream in) { this.in = in; } InputStream in;\n      \n      private byte[] buf = new byte[16384];\n      private int    curChar;\n      private int    numChars;\n      \n \n      public int read() {\n          if (numChars == -1)\n              throw new InputMismatchException();\n          if (curChar >= numChars) {\n              curChar = 0;\n              try {\n                  numChars = in.read(buf);\n              } catch (IOException e) {\n                  throw new InputMismatchException();\n              }\n              if (numChars <= 0)\n                  return -1;\n          }\n          return buf[curChar++];\n      }\n \n      public String nextLine() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          StringBuilder res = new StringBuilder();\n          do {\n              res.appendCodePoint(c);\n              c = read();\n          } while (!isEndOfLine(c));\n          return res.toString();\n      }\n \n      public String nextString() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          StringBuilder res = new StringBuilder();\n          do {\n              res.appendCodePoint(c);\n              c = read();\n          } while (!isSpaceChar(c));\n          return res.toString();\n      }\n \n      public long nextLong() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = read();\n          }\n          long res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = read();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      public int nextInt() {\n          int c = read();\n          while (isSpaceChar(c))\n              c = read();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = read();\n          }\n          int res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = read();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      private boolean isSpaceChar(int c) {\n          return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n      }\n \n      private boolean isEndOfLine(int c) {\n          return c == '\n' || c == '\r' || c == -1;\n      }\n  }\n \n    public static void main(String[] $) {\n        new Thread(null, new Runnable() {\n            public void run() {\n                long start = System.nanoTime();\n                try {Main solution = new Main(); solution.solve(); solution.close();} \n                catch (Exception e) {e.printStackTrace(); System.exit(1);}\n                System.err.println((System.nanoTime()-start)/1E9);\n            }\n        }, ""1"", 1 << 27).start();\n \n    }\n    \n}","data structures,math"
"import java.util.Scanner;\n\npublic class Main{\n\n	static int N = 200;\n	static int[] a = new int[N];\n	static int[] b = new int[N];\n	\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner in = new Scanner(System.in);\n		int n, k, i;\n		n = in.nextInt();\n		k = in.nextInt();\n		int ans = (int)Double.NEGATIVE_INFINITY;\n		\n		for (i=0; i<n; i++) {\n			a[i] = in.nextInt();\n		}\n		\n		for ( i=0; i<n; i++) {\n			for (int j=i; j<n; j++) {\n				ans = max(ans, solve(i, j, n, k));\n			}\n		}\n		\n		System.out.println(ans);\n	}\n\n	private static int max(int x, int y) {\n		if (x > y) {\n			return x;\n		}\n		else {\n			return y;\n		}\n	}\n\n	\n	static int solve(int l, int r, int n, int k) {\n		int ans = 0;\n		b = a.clone();\n		\n		for (int i=l; i<=r; i++) {\n			ans += a[i];\n		}\n		\n		int p=0, q=0;\n		int bmax, bmin;\n		for (int i=0; i<k; i++) {\n			bmax = (int)Double.NEGATIVE_INFINITY;\n			bmin = (int)Double.POSITIVE_INFINITY;\n			for (int j=0; j<n; j++) {\n				if ((j<l || j>r) && b[j]>bmax) {\n					bmax = b[j];\n					p = j;\n				} else if ((j>l && j<r) && b[j]<bmin) {\n					bmin = b[j];\n					q = j;\n				}\n			}\n			if (bmax < bmin) {\n				break;\n			}\n			ans += bmax-bmin;\n			int temp;\n			temp = b[p];\n			b[p] = b[q];\n			b[q] = temp;\n		}\n		\n		return ans;\n	}\n\n}\n\n 		 	  		   			 				  	 	   		","brute force,sortings"
"import java.util.Scanner;\n\npublic class Main{\n\n	static int N = 200;\n	static int[] a = new int[N];\n	static int[] b = new int[N];\n	\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner in = new Scanner(System.in);\n		int n, k;\n		n = in.nextInt();\n		k = in.nextInt();\n		int ans = (int)Double.NEGATIVE_INFINITY;\n		\n		for (int i=0; i<n; i++) {\n			a[i] = in.nextInt();\n		}\n		\n		for (int i=0; i<n; i++) {\n			for (int j=i; j<n; j++) {\n				ans = max(ans, solve(i, j, n, k));\n			}\n		}\n		\n		System.out.println(ans);\n	}\n\n	private static int max(int x, int y) {\n		if (x > y) {\n			return x;\n		}\n		else {\n			return y;\n		}\n	}\n\n	\n	static int solve(int l, int r, int n, int k) {\n		int ans = 0;\n		b = a.clone();\n		\n		for (int i=l; i<=r; i++) {\n			ans += a[i];\n		}\n		\n		int w=0, q=0;\n		int bmax, bmin;\n		for (int i=0; i<k; i++) {\n			bmax = (int)Double.NEGATIVE_INFINITY;\n			bmin = (int)Double.POSITIVE_INFINITY;\n			for (int j=0; j<n; j++) {\n				if ((j<l || j>r) && b[j]>bmax) {\n					bmax = b[j];\n					w = j;\n				} else if ((j>l && j<r) && b[j]<bmin) {\n					bmin = b[j];\n					q = j;\n				}\n			}\n			if (bmax < bmin) {\n				break;\n			}\n			ans += bmax-bmin;\n			int temp;\n			temp = b[w];\n			b[w] = b[q];\n			b[q] = temp;\n		}\n		\n		return ans;\n	}\n\n}\n\n		    		 				 				 				 	 				","brute force,sortings"
"import java.util.Scanner;\n\npublic class Main{\n\n	static int N = 200;\n	static int[] a = new int[N];\n	static int[] b = new int[N];\n	\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner in = new Scanner(System.in);\n		int n, k;\n		n = in.nextInt();\n		k = in.nextInt();\n		int ans = (int)Double.NEGATIVE_INFINITY;\n		\n		for (int i=0; i<n; i++) {\n			a[i] = in.nextInt();\n		}\n		\n		for (int i=0; i<n; i++) {\n			for (int j=i; j<n; j++) {\n				ans = max(ans, solve(i, j, n, k));\n			}\n		}\n		\n		System.out.println(ans);\n	}\n\n	private static int max(int x, int y) {\n		if (x > y) {\n			return x;\n		}\n		else {\n			return y;\n		}\n	}\n\n	\n	static int solve(int l, int r, int n, int k) {\n		int ans = 0;\n		b = a.clone();\n		\n		for (int i=l; i<=r; i++) {\n			ans += a[i];\n		}\n		\n		int p=0, w=0;\n		int bmax, bmin;\n		for (int i=0; i<k; i++) {\n			bmax = (int)Double.NEGATIVE_INFINITY;\n			bmin = (int)Double.POSITIVE_INFINITY;\n			for (int j=0; j<n; j++) {\n				if ((j<l || j>r) && b[j]>bmax) {\n					bmax = b[j];\n					p = j;\n				} else if ((j>l && j<r) && b[j]<bmin) {\n					bmin = b[j];\n					w = j;\n				}\n			}\n			if (bmax < bmin) {\n				break;\n			}\n			ans += bmax-bmin;\n			int temp;\n			temp = b[p];\n			b[p] = b[w];\n			b[w] = temp;\n		}\n		\n		return ans;\n	}\n\n}\n\n   	 		 	     	 	 		   				 			","brute force,sortings"
"import java.util.Scanner;\n\npublic class Main{\n\n	static int N = 200;\n	static int[] a = new int[N];\n	static int[] b = new int[N];\n	\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner in = new Scanner(System.in);\n		int n, k;\n		n = in.nextInt();\n		k = in.nextInt();\n		int ans = (int)Double.NEGATIVE_INFINITY;\n		\n		for (int i=0; i<n; i++) {\n			a[i] = in.nextInt();\n		}\n		\n		for (int i=0; i<n; i++) {\n			for (int j=i; j<n; j++) {\n				ans = max(ans, solve(i, j, n, k));\n			}\n		}\n		\n		System.out.println(ans);\n	}\n\n	private static int max(int x, int y) {\n		if (x > y) {\n			return x;\n		}\n		else {\n			return y;\n		}\n	}\n\n	\n	static int solve(int l, int r, int n, int k) {\n		int ans = 0;\n		b = a.clone();\n		\n		for (int i=l; i<=r; i++) {\n			ans += a[i];\n		}\n		\n		int p=0, q=0;\n		int bmax, bmin;\n		for (int i=0; i<k; i++) {\n			bmax = (int)Double.NEGATIVE_INFINITY;\n			bmin = (int)Double.POSITIVE_INFINITY;\n			for (int j=0; j<n; j++) {\n				if ((j<l || j>r) && b[j]>bmax) {\n					bmax = b[j];\n					p = j;\n				} else if ((j>l && j<r) && b[j]<bmin) {\n					bmin = b[j];\n					q = j;\n				}\n			}\n			if (bmax < bmin) {\n				break;\n			}\n			ans += bmax-bmin;\n			int temp;\n			temp = b[p];\n			b[p] = b[q];\n			b[q] = temp;\n		}\n		\n		return ans;\n	}\n\n}\n\n	     						 				  				  			  	","brute force,sortings"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF416E extends PrintWriter {\n	CF416E() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF416E o = new CF416E(); o.main(); o.flush();\n	}\n\n	static final int INF = 0x3f3f3f3f;\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		int[][] aa = new int[n][n];\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < n; j++)\n				aa[i][j] = INF;\n			aa[i][i] = 0;\n		}\n		while (m-- > 0) {\n			int i = sc.nextInt() - 1;\n			int j = sc.nextInt() - 1;\n			int a = sc.nextInt();\n			aa[i][j] = aa[j][i] = a;\n		}\n		int[][] dd = new int[n][n];\n		for (int i = 0; i < n; i++)\n			for (int j = 0; j < n; j++)\n				dd[i][j] = aa[i][j];\n		for (int k = 0; k < n; k++)\n			for (int i = 0; i < n; i++)\n				for (int j = 0; j < n; j++)\n					dd[i][j] = Math.min(dd[i][j], dd[i][k] + dd[k][j]);\n		int[][] kk = new int[n][n];\n		for (int s = 0; s < n; s++)\n			for (int i = 0; i < n; i++)\n				for (int j = 0; j < n; j++)\n					if (i != j && dd[s][i] + aa[i][j] == dd[s][j])\n						kk[s][j]++;\n		for (int s = 0; s < n; s++)\n			for (int t = s + 1; t < n; t++) {\n				int d = dd[s][t], k = 0;\n				if (d != INF)\n					for (int j = 0; j < n; j++)\n						if (dd[s][j] + dd[j][t] == d)\n							k += kk[s][j];\n				print(k + "" "");\n			}\n		println();\n	}\n}\n","dp,graphs,shortest paths"
"\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n	static int arr[][], brr[][], dp[][];\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner sc = new Scanner(System.in);\n		while (sc.hasNext()) {\n			int n = sc.nextInt();\n			int m = sc.nextInt();\n			arr = new int[n][n];\n			brr = new int[n][n];\n			dp = new int[n][n];\n			for (int i = 0; i < arr.length; i++) {\n				for (int j = 0; j < arr.length; j++) {\n					if (i == j) {\n						brr[i][j] = 0;\n					} else\n						brr[i][j] = arr[i][j] = Integer.MAX_VALUE;\n				}\n			}\n			while (m-- > 0) {\n				int a = sc.nextInt() - 1;\n				int b = sc.nextInt() - 1;\n				int c = sc.nextInt();\n				if (arr[a][b] > c || arr[b][a] > c)\n					arr[a][b] = arr[b][a] = brr[a][b] = brr[b][a] = c;\n			}\n\n			floyd();\n			for (int i = 0; i < n; i++) {\n				for (int j = 0; j < n; j++) {\n					dp[i][j]=-1;\n				}\n			}\n			for (int i = 0; i < n; i++) {\n				for (int j = 0; j < n; j++) {\n					for (int j2 = 0; j2 < n; j2++) {\n						if (arr[i][j] != Integer.MAX_VALUE && brr[i][j2] == arr[i][j] + brr[j][j2]) {\n							++dp[i][j2];\n						}\n					}\n				}\n			}\n//			for (int i = 0; i < n; i++) {\n//				for (int j = 0; j < n; j++) {\n//					System.out.print(dp[i][j]+"" "");\n//				}\n//				System.out.println();\n//			}\n			for (int i = 0; i < n ; i++) {\n				for (int j = i + 1; j < n; j++) {\n					int ans = 0;\n					for (int j2 = 0; j2 < n; j2++) {\n						if (brr[i][j] == brr[i][j2] + brr[j2][j]) {\n							ans += dp[j2][j];\n						}\n					}\n					if(i!=n-1) {\n						System.out.print(ans+"" "");\n					}else {\n						System.out.println(ans);\n					}\n				}\n			}\n\n		}\n	}\n           //TODO floyd\n	private static void floyd() {\n		for (int i = 0; i < arr.length; i++) {\n			for (int j = 0; j < arr.length; j++) {\n				for (int j2 = 0; j2 < arr.length; j2++) {\n					if(brr[j][i]!=Integer.MAX_VALUE&&brr[i][j2]!=Integer.MAX_VALUE)\n					brr[j][j2] = Math.min(brr[j][j2], brr[j][i] + brr[i][j2]);\n				}\n			}\n		}\n	\n//		for (int i = 0; i < arr.length; i++) {\n//			for (int j = 0; j < arr.length; j++) {\n//				System.out.print(brr[i][j]+"" "");\n//			}\n//			System.out.println();\n//		}\n\n	}\n\n}\n\n 	  			     	  	   	     			","dp,graphs,shortest paths"
"\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n	static int arr[][], brr[][], dp[][];\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner sc = new Scanner(System.in);\n		while (sc.hasNext()) {\n			int n = sc.nextInt();\n			int m = sc.nextInt();\n			arr = new int[n][n];\n			brr = new int[n][n];\n			dp = new int[n][n];\n			for (int i = 0; i < arr.length; i++) {\n				for (int j = 0; j < arr.length; j++) {\n					if (i == j) {\n						brr[i][j] = 0;\n					} else\n						brr[i][j] = arr[i][j] = Integer.MAX_VALUE;\n				}\n			}\n			while (m-- > 0) {\n				int a = sc.nextInt() - 1;\n				int b = sc.nextInt() - 1;\n				int c = sc.nextInt();\n				if (arr[a][b] > c || arr[b][a] > c)\n					arr[a][b] = arr[b][a] = brr[a][b] = brr[b][a] = c;\n			}\n\n			floyd();\n			for (int i = 0; i < n; i++) {\n				for (int j = 0; j < n; j++) {\n					dp[i][j]=-1;\n				}\n			}\n			for (int i = 0; i < n; i++) {\n				for (int j = 0; j < n; j++) {\n					for (int j2 = 0; j2 < n; j2++) {\n						if (arr[i][j] != Integer.MAX_VALUE && brr[i][j2] == arr[i][j] + brr[j][j2]) {\n							++dp[i][j2];\n						}\n					}\n				}\n			}\n//			for (int i = 0; i < n; i++) {\n//				for (int j = 0; j < n; j++) {\n//					System.out.print(dp[i][j]+"" "");\n//				}\n//				System.out.println();\n//			}\n			for (int i = 0; i < n ; i++) {\n				for (int j = i + 1; j < n; j++) {\n					int ans = 0;\n					for (int j2 = 0; j2 < n; j2++) {\n						if (brr[i][j] == brr[i][j2] + brr[j2][j]) {\n							ans += dp[j2][j];\n						}\n					}\n					if(1!=n-1) {\n						System.out.print(ans+"" "");\n					}else {\n						System.out.println(ans);\n					}\n				}\n			}\n\n		}\n	}\n           //TODO floyd\n	private static void floyd() {\n		for (int i = 0; i < arr.length; i++) {\n			for (int j = 0; j < arr.length; j++) {\n				for (int j2 = 0; j2 < arr.length; j2++) {\n					if(brr[j][i]!=Integer.MAX_VALUE&&brr[i][j2]!=Integer.MAX_VALUE)\n					brr[j][j2] = Math.min(brr[j][j2], brr[j][i] + brr[i][j2]);\n				}\n			}\n		}\n	\n//		for (int i = 0; i < arr.length; i++) {\n//			for (int j = 0; j < arr.length; j++) {\n//				System.out.print(brr[i][j]+"" "");\n//			}\n//			System.out.println();\n//		}\n\n	}\n\n}\n\n	  	  		 		  	   	  	    	 	  	","dp,graphs,shortest paths"
"\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport static java.lang.Math.*;\nimport static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Double.parseDouble;\nimport static java.lang.String.*;\n\npublic class Main {\n    \n    static int n,m;\n    static int inf = (int)1e9+10;\n    static int [][] sp,en,ans;\n    static List<edge> edges;\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder out = new StringBuilder();\n        StringTokenizer tk;\n        \n        tk = new StringTokenizer(in.readLine());\n        int n = parseInt(tk.nextToken()),m = parseInt(tk.nextToken());\n        sp = new int[n][n];\n        for(int i=0; i<n; i++) {\n            Arrays.fill(sp[i], inf);\n            sp[i][i] = 0;\n        }\n        \n        edges = new ArrayList<>();\n        \n        while(m-- > 0) {\n            tk = new StringTokenizer(in.readLine());\n            int a = parseInt(tk.nextToken())-1,b = parseInt(tk.nextToken())-1,c = parseInt(tk.nextToken());\n            \n            sp[a][b] = c;\n            sp[b][a] = c;\n            edges.add(new edge(a,b,c));\n        }\n        \n        for(int k=0; k<n; k++)\n            for(int i=0; i<n; i++)\n                for(int j=0; j<n; j++)\n                    sp[i][j] = min(sp[i][j],sp[i][k]+sp[k][j]);\n        \n        en = new int[n][n];\n        ans = new int[n][n];\n        \n        for(int i=0; i<n; i++)\n            for(edge e : edges) {\n                if(sp[i][e.s]+e.c == sp[i][e.e])\n                    en[i][e.e]++;\n                if(sp[i][e.e]+e.c == sp[i][e.s])\n                    en[i][e.s]++;\n            }\n        \n        for(int s=0; s<n; s++)\n            for(int e=s+1; e<n; e++)\n                for(int u=0; u<n; u++)\n                    if(sp[s][u]+sp[u][e] == sp[s][e])\n                        ans[s][e] += en[s][u];\n        \n        for(int s=0; s<n; s++)\n            for(int e=s+1; e<n; e++)\n                out.append(ans[s][e]).append("" "");\n        \n        System.out.println(out);\n    }\n\n}\n\nclass edge {\n    int s,e,c;\n    \n    public edge(int s,int e,int c) {\n        this.s = s;\n        this.e = e;\n        this.c = c;\n    }\n}","dp,graphs,shortest paths"
"import java.util.*;\npublic class sde {\n	\n	public static void main (String args[]) {\n		Scanner sc = new Scanner(System.in);\n		\n		\n		\n	\n		\n	int x = sc.nextInt();\n	int y = sc.nextInt();\n		int[] no = new int [x];\n		\n\nArrayList<Integer> as = new ArrayList<Integer>();\n\n\n		int[] a = new int [y];\n		\n	for(int i = 0; i<x; i++) {\n		\n		//no [i] = sc.nextInt();\n		as.add(sc.nextInt());\n		\n	}\n	\n	int q = 0;\n	for(int i = 0; i<y; i++) {\n		q =sc.nextInt()-1;\n		a [i] = as.get(q);\n		\n		as.set(q, 0);\n	}\n	Long sum =0L;\n	for(int i = 0; i<x; i++) {\n	sum = sum + as.get(i);\n	}\n	\n	\n	\n	\n	Arrays.sort(a);\n	\n	\n	for(int i = y-1; i>=0; i--) {\n		\n	if(a[i]<sum) {\n		sum = sum +sum;\n	}\n	else {\n		sum = sum+a[i];\n	}\n	\n	}\n	\n	\n	\n	\n	System.out.println( sum);\n}}\n\n\n\n","greedy,math"
"import java.util.*;\npublic class Jeopardy {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int m=sc.nextInt();\n		int arr[]=new int[n];\n		Set<Integer> foo=new HashSet<>();\n		Integer brr[]=new Integer[m];\n		for(int i=0;i<n;i++) {\n			arr[i]=sc.nextInt();\n		}\n		int k=0;\n		for(int i=0;i<m;i++) {\n			k=sc.nextInt();\n			foo.add(k);\n			brr[i]=arr[k-1];\n		}\n		long sum=0;\n		for(int i=0;i<n;i++) {\n			if(!foo.contains(i+1)) {\n				sum+=arr[i];\n			}\n		}\n		Arrays.sort(brr, Collections.reverseOrder());\n//		System.out.println(Arrays.toString(brr));\n		for(int i=0;i<m;i++) {\n//			System.out.println(sum+"" ""+brr[i]);\n			if(sum>brr[i]) {\n				sum+=sum;\n			}\n			else {\n				sum+=brr[i];\n			}\n		}\n		System.out.println(sum);\n	}\n\n}\n","greedy,math"
"import java.io.*;\nimport java.util.*;\n\npublic class Jeopardy{\n    public static void main(String[] args)  throws IOException, InterruptedException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken()), m = Integer.parseInt(st.nextToken());\n        int[][] arr = new int[n][2];\n        boolean[] auc = new boolean[n];\n        st = new StringTokenizer(br.readLine());\n        for(int i = 0; i<n; i++){\n            arr[i][0] = Integer.parseInt(st.nextToken());\n        }\n        st = new StringTokenizer(br.readLine());\n        for(int i = 0; i<m; i++){\n            arr[Integer.parseInt(st.nextToken())-1][1]++;\n        }\n        Arrays.sort(arr, (a, b)->{\n            if(a[1]==1 && b[1]==0) return 1;\n            if(a[1]==0 && b[1]==1) return -1;\n            return b[0]-a[0];\n        });\n\n        long c = 0;\n        for(int i = 0; i<n; i++){\n            if(c<=arr[i][0]){\n                c+=arr[i][0];\n            }else{\n                if(arr[i][1]==1){\n                    c*=2;\n                }else{\n                    c+=arr[i][0];\n                }\n            }\n        }\n        System.out.println(c);\n\n        // for(int i = 0; i<n; i++){\n        //     System.out.println(arr[i][0]);\n        // }\n    }\n}","greedy,math"
import java.io.*;\n        import java.util.*;\n        import java.lang.*;\n        public class NewClass {\n            public static void main(String[] args) throws IOException{\n                BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n                StringTokenizer st=new StringTokenizer(br.readLine());\n                int n=Integer.parseInt(st.nextToken());\n                int m=Integer.parseInt(st.nextToken());\n                int a[]=new int[n];\n                int auction[]=new int[m];\n                st=new StringTokenizer(br.readLine());\n                for(int i=0;i<n;i++){\n                    a[i]=Integer.parseInt(st.nextToken());\n                }\n                st=new StringTokenizer(br.readLine());\n                for(int i=0;i<m;i++){\n                    int index=Integer.parseInt(st.nextToken())-1;\n                    auction[i]=a[index];\n                    a[index]=-1;\n                }\n                Arrays.sort(auction);\n                long sum=0;\n                for(int i=0;i<n;i++){\n                    if(a[i]!=-1){\n                        sum+=a[i];\n                    }\n                }\n                for(int i=m-1;i>=0;i--){\n                    if(sum>auction[i]){\n                        sum=sum*2;\n                    }\n                    else{\n                        sum=sum+auction[i];\n                    }\n                }\n                System.out.print(sum);\n\n\n\n            }\n        }\n,"greedy,math"
\nimport java.util.Scanner;\n\npublic class APlusB {\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n\n        System.out.println(sc.nextInt() + sc.nextInt());\n        sc.close();\n    }\n}\n,"*special,brute force,constructive algorithms,dsu,implementation"
import java.util.*; \n\npublic class test {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n\n        int a = s.nextInt(); \n        int b = s.nextInt(); \n\n        System.out.println((a + b)); \n    }\n}\n,"*special,brute force,constructive algorithms,dsu,implementation"
import java.util.Scanner;\npublic class AbStrikesBack{\n  public static void main(String[]args){\n  Scanner sc=new Scanner(System.in);\n   int a=sc.nextInt();\n   int b=sc.nextInt();\n   int c=a+b;\n\n   System.out.println(c);  \n     \n   \n  }\n},"*special,brute force,constructive algorithms,dsu,implementation"
import java.util.*;\n\npublic class Main {\n    static Scanner sc = new Scanner(System.in);\n    public static void main(String[] args) {\n        //hi\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        System.out.println(a+b);\n    }\n}\n,"*special,brute force,constructive algorithms,dsu,implementation"
"import java.util.*;\npublic class Garland\n{\n	public static void main(String[] args) \n	{\n		Scanner sc=new Scanner(System.in);\n		String s1=sc.next();\n		String s2=sc.next();\n		int a[]=new int[26];\n		int b[]=new int[26];\n		\n		for(int i=0;i<s1.length();i++)\n		{\n			a[s1.charAt(i)-'a']++;\n		}\n		\n		for(int i=0;i<s2.length();i++)\n		{\n			b[s2.charAt(i)-'a']++;\n		}\n		\n		int sum=0;\n		int flag=0;\n		for(int i=0;i<a.length;i++)\n		{\n			if(a[i]==0 && b[i]>0)\n			{\n				flag=1;\n				break;\n			}\n			\n			else\n			{\n				sum=sum+Math.min(a[i],b[i]);\n			}\n		}\n		\n		if(flag==1)\n		{\n			System.out.println(""-1"");\n		}\n		else\n		{\n			System.out.println(sum);\n		}\n	}\n}\n",implementation
"import java.util.*;\npublic class vv {\n\n public static void main(String[] args) {\n  Scanner no=new Scanner(System.in);\n  int arr[]=new int[27];\n  int arr1[]=new int[27];\n  int sum=0;\n  boolean t=true;\n  String s=no.nextLine();\n  String s1=no.nextLine();\n  for(int i=0;i<s.length();i++){\n    arr[s.charAt(i)-'a']++;\n  }\n  for(int i=0;i<s1.length();i++){\n    arr1[s1.charAt(i)-'a']++;\n  }\n  for(int i=0;i<27;i++){\n    if(arr[i]>0&&arr1[i]>0){\n      sum=sum+Math.min(arr[i],arr1[i]);\n    }\n    else if(arr1[i]>0&&arr[i]==0){\n      t=false;\n      break; \n    }\n  }\n  if(t){\n    System.out.println(sum);\n  }\n  else{\n    System.out.println(""-1"");\n  }\n }\n\n}\n ",implementation
"import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    char [] a, b;\n    String s = sc.next();\n    a = s.toCharArray();\n    s = sc.next();\n    b = s.toCharArray();\n\n    int [] cnt = new int[26];\n    for (int i = 0; i < a.length; ++i) {\n      int x = a[i] - 'a';\n      ++cnt[x];\n    }\n    for (int i = 0; i < 26; ++i)\n      if(cnt[i] == 0)\n        cnt[i] = -1;\n    int ans = 0;\n    for (int i = 0; i < b.length; ++i) {\n      int x = b[i] - 'a';\n      if(cnt[x] == -1) {\n        ans = -1;\n        break;\n      }\n      if(cnt[x] > 0) {\n        ++ans;\n        --cnt[x];\n      }\n    }\n    System.out.println(ans);\n }\n \n}\n",implementation
"import java.util.*;\n\npublic class Garland {\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		String a = sc.next();\n		String g = sc.next();\n		sc.close();\n		List<Character> l = new ArrayList<>();\n		List<Character> gar = new ArrayList<>();\n		\n		for(int i=0; i<a.length(); i++)\n		{\n			l.add(a.charAt(i));\n		}\n		\n		for(int i=0; i<g.length(); i++)\n		{\n			gar.add(g.charAt(i));\n		}\n		\n		int count = 0;\n		int flag = 0;\n		for(char x: gar)\n		{\n			if(!l.contains(x))\n			{\n				flag=1;\n				break;\n			}\n		}\n		\n		for(char x: gar)\n		{\n			if(l.contains(x))\n			{\n				count++;\n				int t = l.indexOf(x);\n				l.remove(t);\n			}\n		}\n		\n		if(flag==1)\n		{\n			System.out.println(""-1"");\n		}\n		else\n		{\n			System.out.println(count);\n		}\n	}\n\n}\n",implementation
"import java.util.*;\nimport java.math.*;\npublic class Main{\n    public static void main(String args[]){\n        Scanner cin=new Scanner(System.in);\n        int a=cin.nextInt(),b=cin.nextInt(),zc,i,j,pd=0;\n        if(a<b){\n            zc=a;\n            a=b;\n            b=zc;\n        }\n        for(i=1;i<=a-1;i++){\n            j=(int)Math.sqrt(a*a-i*i);\n            if(i*i+j*j==a*a&&(i*b)%a==0&&(j*b)%a==0){\n                pd=1;\n                System.out.println(""YES"");\n                System.out.println(""0 0"");\n                System.out.printf(""%d %d\n"",i,j);\n                System.out.printf(""%d %d\n"",-j*b/a,i*b/a);\n                break;\n            }\n        }\n        if(pd==0) System.out.println(""NO"");\n    }\n}","brute force,geometry,implementation,math"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class CF_triangle {\n\n	public static void main(String args[])throws Exception\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st;\n        st=new StringTokenizer(br.readLine());\n        int a=Integer.parseInt(st.nextToken());\n        int b=Integer.parseInt(st.nextToken());\n        \n        for(int i=1;i<=1000;i++){\n            for(int j=1;j<=1000;j++){\n                if(i*i+j*j==a*a){\n                    int n=b*j/a;\n                    int m=b*i/a;\n                    if(n*n+m*m==b*b && m!=j){\n                        System.out.println(""YES"");\n                        System.out.println(""0 0"");\n                        System.out.println(i+"" ""+j);\n                        System.out.println(-n+"" ""+(m));\n                        return;\n                    }\n                    \n                }\n            }\n        \n    }\n        System.out.println(""NO"");\n\n\n\n}\n}\n","brute force,geometry,implementation,math"
"import java.io.*;\nimport java.util.*;\nimport java.lang.*;\n\npublic class Rextester{\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        br.close();\n        int a = Integer.parseInt(st.nextToken());\n        int b = Integer.parseInt(st.nextToken());\n        int x = Math.min(a,b);\n        int y = Math.max(a,b);\n        int[][] rights = new int[1000][2];\n        int p = 0;\n        for(int i=1;i<x;i++){\n            for(int j=1;j<x;j++){\n                int w = (int)Math.pow(i,2)+(int)Math.pow(j,2);\n                int r = (int)Math.pow(x,2);\n                if(w==r){\n                    rights[p][0]=Math.min(i,j);\n                    rights[p][1]=Math.max(i,j);\n                    p++;\n                }\n            }\n        }\n        int[][] lefts = new int[1000][2];\n        int q=0;\n        for(int i=1;i<y;i++){\n            for(int j=1;j<y;j++){\n                int w = (int)Math.pow(i,2)+(int)Math.pow(j,2);\n                int r = (int)Math.pow(y,2);\n                if(w==r){\n                    lefts[q][0]=Math.min(i,j);\n                    lefts[q][1]=Math.max(i,j);\n                    q++;\n                }\n            }\n        }\n        for(int i=0;i<p;i++){\n            for(int j=0;j<q;j++){\n                //System.out.println(rights[i][0]+"" ""+rights[i][1]+"" ""+lefts[j][0]+"" ""+lefts[j][1]);\n                if((double)rights[i][0]/rights[i][1] == (double)lefts[j][0]/lefts[j][1]){\n                    System.out.println(""YES\n"");\n                    System.out.println(rights[i][1]+"" ""+rights[i][0]);\n                    System.out.println(""0 0"");\n                    System.out.println((-lefts[j][0])+"" ""+lefts[j][1]);\n                    return;\n                }\n            }\n        }\n        System.out.println(""NO"");\n    }\n}\n        ","brute force,geometry,implementation,math"
"import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class P_407A {\n    static final FS sc = new FS();\n    static final PrintWriter pw = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        boolean oa = false, ob = false;\n        int xa = 0, ya = 0, xb = 0, yb = 0;\n        for(int i=1; i<=a; i++){\n            long y = a*a-i*i;\n            if(y>0){\n                long c = (long) Math.sqrt(y);\n                if(c*c==y){\n                    y = c;\n                    if((y*b)%a==0 && (i*b)%a==0){\n                        int p = (int) ((y*b)/a);\n                        int q = (i*b)/a;\n                        if(-p!=i && q!=y){\n                            System.out.println(""YES"");\n                            System.out.println(0+"" ""+0);\n                            System.out.println(i+"" ""+y);\n                            System.out.println(-p+"" ""+q);\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        System.out.println(""NO"");\n    }\n\n    static class FS {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer("""");\n\n        String next() {\n            while (!st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception ignored) {\n                }\n            }\n            return st.nextToken();\n        }\n\n        int[] nextArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n","brute force,geometry,implementation,math"
"import java.io.*;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\npublic class C {\n\n    public static void main(String[] args) throws IOException {\n\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n\n\n        int n = sc.nextInt();\n        String[][] procedures = new String[n][];\n        for(int i = 0; i < n; ++i)\n            procedures[i] = sc.nextLine().trim().split(""[ (),]+"");\n\n        int m = sc.nextInt();\n        HashMap<String, String> variables = new HashMap<>();\n        while(m-->0) {\n            String t = sc.next(), v = sc.next();\n            variables.put(v, t);\n        }\n        int k = sc.nextInt();\n        while(k-->0) {\n            String[] s = sc.nextLine().trim().split(""[ (),]+"");\n            int ans = 0;\n            ll: for(int j = 0; j < procedures.length; ++j) {\n                String[] p = procedures[j];\n                if(s.length + 1 != p.length || !s[0].equals(p[1]))\n                    continue;\n                for(int i = 1; i < s.length; ++i) {\n                    String t = variables.get(s[i]);\n                    if(!p[i+1].equals(""T"") && !p[i+1].equals(t))\n                        continue ll;\n                }\n                ans++;\n            }\n            out.println(ans);\n        }\n\n        out.close();\n\n    }\n\n    static class Scanner\n    {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}\n\n        public String next() throws IOException\n        {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {return Integer.parseInt(next());}\n\n        public long nextLong() throws IOException {return Long.parseLong(next());}\n\n        public String nextLine() throws IOException {return br.readLine();}\n\n        public boolean ready() throws IOException {return br.ready();}\n\n\n    }\n}","binary search,brute force,expression parsing,implementation"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF200D extends PrintWriter {\n	CF200D() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF200D o = new CF200D(); o.main(); o.flush();\n	}\n\n	String parse1(char[] s, String[][] ss, int i) {\n		int l = 0;\n		while (s[l] != '(')\n			l++;\n		int r = l;\n		while (s[r] != ')')\n			r++;\n		int hr = l - 1;\n		while (s[hr] <= ' ')\n			hr--;\n		int hl = hr;\n		while (hl >= 0 && s[hl] > ' ')\n			hl--;\n		hl++;\n		String p = new String(s, hl, hr - hl + 1);\n		int c = 0;\n		for (int j = l + 1; j < r; j++)\n			if (s[j] == ',')\n				c++;\n		ss[i] = new String[c + 1];\n		l++;\n		for (int h = 0; h <= c; h++) {\n			r = l;\n			while (s[r] != ',' && s[r] != ')')\n				r++;\n			hl = l; hr = r - 1;\n			while (s[hl] <= ' ')\n				hl++;\n			while (s[hr] <= ' ')\n				hr--;\n			ss[i][h] = new String(s, hl, hr - hl + 1);\n			l = r + 1;\n		}\n		return p;\n	}\n	void main() {\n		int n = Integer.parseInt(sc.nextLine());\n		String[] procedures = new String[n];\n		String[][] parameters = new String[n + 1][];\n		for (int i = 0; i < n; i++) {\n			char[] s = sc.nextLine().toCharArray();\n			procedures[i] = parse1(s, parameters, i);\n		}\n		int m = Integer.parseInt(sc.nextLine());\n		String[] types = new String[m];\n		String[] names = new String[m];\n		for (int j = 0; j < m; j++) {\n			StringTokenizer st = new StringTokenizer(sc.nextLine());\n			types[j] = st.nextToken();\n			names[j] = st.nextToken();\n		}\n		int k = Integer.parseInt(sc.nextLine());\n		String[] tt = new String[5];\n		while (k-- > 0) {\n			char[] s = sc.nextLine().toCharArray();\n			String name = parse1(s, parameters, n);\n			int c = parameters[n].length;\n			for (int h = 0; h < c; h++)\n				for (int j = 0; j < m; j++)\n					if (names[j].equals(parameters[n][h])) {\n						tt[h] = types[j];\n						break;\n					}\n			int ans = 0;\n			for (int i = 0; i < n; i++) {\n				if (parameters[i].length != c || !procedures[i].equals(name))\n					continue;\n				boolean yes = true;\n				for (int h = 0; h < c; h++)\n					if (!parameters[i][h].equals(""T"") && !parameters[i][h].equals(tt[h])) {\n						yes = false;\n						break;\n					}\n				if (yes)\n					ans++;\n			}\n			println(ans);\n		}\n	}\n}\n","binary search,brute force,expression parsing,implementation"
"import java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class P200D {\n\n  private static final Pattern decl = Pattern.compile(""void(.*)\\((.*)\\)"");\n  private static final Pattern call = Pattern.compile(""(.*)\\((.*)\\)"");\n\n  public static void main(String[] args) {\n    Scanner input = new Scanner(System.in);\n\n    int n = input.nextInt();\n\n    Func[] funcs = new Func[n];\n\n    input.nextLine();\n    for (int i = 0; i < n; i++) {\n      funcs[i] = create(input.nextLine(), decl);\n    }\n\n    int variables = input.nextInt();\n\n    Map<String, String> map = new HashMap<>();\n\n    for (int i = 0; i < variables; i++) {\n      String a = input.next();\n      String b = input.next();\n\n      map.put(b, a);\n    }\n\n    int functions = input.nextInt();\n\n    input.nextLine();\n    for (int i = 0; i < functions; i++) {\n      Func target = create(input.nextLine(), call);\n\n      int cnt = 0;\n      for (int j = 0; j < funcs.length; j++) {\n        Func check = funcs[j];\n        if (check.name.equals(target.name)) {\n          if (target.types.length == check.types.length) {\n            boolean good = true;\n            for (int k = 0; k < target.types.length && good; k++) {\n              if (!check.types[k].equals(""T"") && !check.types[k].equals(map.get(target.types[k]))) {\n                good = false;\n              }\n            }\n            if (good) {\n              cnt++;\n            }\n          }\n        }\n      }\n\n      System.out.println(cnt);\n    }\n\n  }\n\n  private static Func create(String str, Pattern pat) {\n    Matcher matcher = pat.matcher(strip(str));\n    if (matcher.matches()) {\n      String funcName = matcher.group(1);\n      String[] toks = matcher.group(2).split("","");\n\n      return new Func(funcName, toks);\n    }\n\n    return null;\n  }\n\n  private static String strip(String str) {\n    StringBuilder sb = new StringBuilder();\n\n    for (int i = 0; i < str.length(); i++) {\n      if (str.charAt(i) != ' ') {\n        sb.append(str.charAt(i));\n      }\n    }\n\n    return sb.toString();\n  }\n\n  private static class Func {\n    private final String name;\n    private final String[] types;\n\n    private Func(String name, String[] types) {\n      this.name = name;\n      this.types = types;\n    }\n\n    @Override\n    public String toString() {\n      return String.format(""[%s, %s]"", name, Arrays.toString(types));\n    }\n  }\n\n}","binary search,brute force,expression parsing,implementation"
"import java.io.*;\nimport java.util.*;\n\npublic class ProgrammingLanguage {\n    public static void main(String[] args) throws Exception {\n        PrintWriter out = new PrintWriter(System.out, true);\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(in.readLine());\n        Proc[] mas = new Proc[n];\n        for (int i = 0; i < n; i++) {\n            StringTokenizer st = new StringTokenizer(in.readLine(), "" ,()"");\n            st.nextToken();\n            String name = st.nextToken();\n            String[] params = new String[st.countTokens()];\n            for (int j = 0; j < params.length; j++) {\n                params[j] = st.nextToken();\n            }\n            mas[i] = new Proc(name, params);\n        }\n        int m = Integer.parseInt(in.readLine());\n        Map<String, String> map = new HashMap<>();\n        for (int i = 0; i < m; i++) {\n            StringTokenizer st = new StringTokenizer(in.readLine());\n            String type = st.nextToken();\n            String name = st.nextToken();\n            map.put(name, type);\n        }\n        int k = Integer.parseInt(in.readLine());\n        for (int i = 0; i < k; i++) {\n            StringTokenizer st = new StringTokenizer(in.readLine(), "" ,()"");\n            String name = st.nextToken();\n            String[] params = new String[st.countTokens()];\n            for (int j = 0; j < params.length; j++) {\n                params[j] = map.get(st.nextToken());\n            }\n            int res = 0;\n            for (int j = 0; j < mas.length; j++) {\n                if (mas[j].isOk(name, params)) {\n                    res++;\n                }\n            }\n            out.println(res);\n        }\n    }\n}\n\nclass Proc {\n    String name;\n    String[] params;\n\n    Proc(String name, String... params) {\n        this.name = name;\n        this.params = params;\n    }\n\n    public boolean isOk(String name, String[] params) {\n        if (this.name.equals(name) && isParamsOk(params)) {\n            return true;\n        }\n        return false;\n    }\n\n    private boolean isParamsOk(String[] params) {\n        if (this.params.length != params.length) {\n            return false;\n        }\n        for (int i = 0; i < params.length; i++) {\n            if (!(this.params[i].equals(params[i]) || this.params[i]\n                    .equals(""T""))) {\n                return false;\n            }\n        }\n        return true;\n    }\n}","binary search,brute force,expression parsing,implementation"
"import java.util.Scanner;\npublic class Main {\n    public static char array[][];\n    public static int arr[][];\n    public static int n,k;\n    public static int counter = 1;\n    public static boolean engine(int pos, int cur){\n        if(cur > n){\n            return true;\n        }\n        if(array[pos][cur] == 'X' || arr[pos][cur] == 1 ||counter  > cur){\n            return false;\n        }\n        arr[pos][cur] = 1;\n        counter++;\n        boolean flag = false;\n        if(engine(pos, cur - 1) || engine(1 - pos, cur + k) || engine(pos,cur + 1)){\n            flag = true;\n        }\n        counter --;\n        return flag;\n    }\n\n    public static void main(String[] args) {\n	// write your code here\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        k = in.nextInt();\n\n        array = new char[2][n + k + 100];\n        arr = new int[2][n + k + 100];\n        for(int i = 0; i < 2; i++){\n            char c[] = in.next().toCharArray();\n            array[i][0] = 'X';\n\n            for(int j = 0; j < c.length; j++){\n                array[i][j + 1] = c[j];\n            }\n        }\n        if(engine(0,1)){\n            System.out.println(""YES"");\n        }else{\n            System.out.println(""NO"");\n        }\n    }\n}\n",shortest paths
"import java.util.*;\n\npublic class Solve{\n    static boolean ok;\n    static    boolean[][] dep;\n    static int n,k;\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n     n=sc.nextInt();\n         k=sc.nextInt();\n         dep=new boolean[2][n];\n        for(int i=0;i<2;i++){\n            char[] c=sc.next().toCharArray();\n            for(int j=0;j<c.length;j++){\n                if(c[j]=='-')dep[i][j]=true;\n                else dep[i][j]=false;\n            }\n        }\n        ispos(-1,0,0);\n        if(ok) System.out.println(""YES"");\n        else System.out.println(""NO"");\n        \n    }\n    static void ispos(int water,int x,int y){\n        if(ok)return ;\n        if(y+k>n-1){\n            ok=true;\n            return;\n        }\n        else{\n            if(x==0){\n                if(dep[1][y+k] ){\n                    ispos(water+1,1,y+k);\n                }\n                else{\n                    dep[x][y]=false;\n                }\n            }\n            else{\n                 if(dep[0][y+k] ){\n                    ispos(water+1,0,y+k);\n                }\n                else{\n                    dep[x][y]=false;\n                }\n            }\n        }\n        if(dep[x][y+1])ispos(water+1,x,y+1);\n        if(y-1>=0 && water+1<y-1)if(dep[x][y-1])ispos(water+1,x,y-1);\n        \n    }\n}",shortest paths
"import java.util.Scanner;\n\npublic final class JumpingOnWalls {\n\n    static Scanner sc = new Scanner(System.in);\n    static char[] leftWall, rightWall;\n    static boolean[] leftVisited, rightVisted;\n    static int n, k;\n\n    public static void main(String[] args) {\n        n = sc.nextInt();\n        k = sc.nextInt();\n        sc.nextLine();\n        leftWall = sc.nextLine().toCharArray();\n        rightWall = sc.nextLine().toCharArray();\n\n        leftVisited = new boolean[n];\n        rightVisted = new boolean[n];\n        System.out.println(isPossible(0, -1, true) ? ""YES"" : ""NO"");\n    }\n\n    private static boolean isPossible(int currPos, int waterLevel, boolean isLeft) {\n        char[] currWall = isLeft ? leftWall : rightWall;\n        char[] otherWall = isLeft ? rightWall : leftWall;\n        boolean[] currVisited = isLeft ? leftVisited : rightVisted;\n        boolean[] otherVisted = isLeft ? rightVisted : leftVisited;\n\n        if (currPos < 0) return false;\n        if (currPos > n - 1 || currPos + k >= n) return true;\n        if (waterLevel >= currPos) return false;\n\n        currVisited[currPos] = true;\n\n        if (currWall[currPos] == 'X') return false;\n        if (!otherVisted[currPos + k] && !(otherWall[currPos+k] == 'X') && isPossible(currPos+k, waterLevel+1, !isLeft)) return true;\n        if (!currVisited[currPos+1] && !(currWall[currPos+1] == 'X') && isPossible(currPos+1, waterLevel+1, isLeft)) return true;\n        if (currPos > 0 && !currVisited[currPos-1] && waterLevel < currPos-1 && isPossible(currPos-1, waterLevel+1, isLeft))\n            return true;\n        return false;\n    }\n}\n",shortest paths
"import java.util.Scanner;\n \npublic final class JumpingOnWalls {\n \n    static Scanner sc = new Scanner(System.in);\n    static char[] leftWall, rightWall;\n    static boolean[] leftVisited, rightVisted;\n    static int n, k;\n \n    public static void main(String[] args) {\n        n = sc.nextInt();\n        k = sc.nextInt();\n        sc.nextLine();\n        leftWall = sc.nextLine().toCharArray();\n        rightWall = sc.nextLine().toCharArray();\n \n        leftVisited = new boolean[n];\n        rightVisted = new boolean[n];\n        System.out.println(isPossible(0, -1, true) ? ""YES"" : ""NO"");\n    }\n \n    private static boolean isPossible(int currPos, int waterLevel, boolean isLeft) {\n        char[] currWall = isLeft ? leftWall : rightWall;\n        char[] otherWall = isLeft ? rightWall : leftWall;\n        boolean[] currVisited = isLeft ? leftVisited : rightVisted;\n        boolean[] otherVisted = isLeft ? rightVisted : leftVisited;\n \n        if (currPos < 0) return false;\n        if (currPos > n - 1 || currPos + k >= n) return true;\n        if (waterLevel >= currPos) return false;\n \n        currVisited[currPos] = true;\n \n        if (currWall[currPos] == 'X') return false;\n        if (!otherVisted[currPos + k] && !(otherWall[currPos+k] == 'X') && isPossible(currPos+k, waterLevel+1, !isLeft)) return true;\n        if (!currVisited[currPos+1] && !(currWall[currPos+1] == 'X') && isPossible(currPos+1, waterLevel+1, isLeft)) return true;\n        if (currPos > 0 && !currVisited[currPos-1] && waterLevel < currPos-1 && isPossible(currPos-1, waterLevel+1, isLeft))\n            return true;\n        return false;\n    }\n}",shortest paths
"import java.util.Scanner;\n\npublic class LexMax1 {\n    public static void main(String[] args) {\n\n        Scanner scan = new Scanner(System.in);\n\n        String s = scan.next();\n        StringBuilder ans = new StringBuilder();\n        ans.append(s.charAt(s.length()-1));\n\n        for(int i=s.length()-2; i>=0; i--) {\n            if(s.charAt(i)>=ans.charAt(0)) {\n                ans.insert(0, s.charAt(i));\n            }\n        }\n        System.out.println(ans);\n\n\n    }\n}\n","greedy,strings"
"import java.util.*;\npublic class LexMaxSubSeq {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        String in = scan.next();\n        char cur = in.charAt(in.length()-1);\n        StringBuilder ans = new StringBuilder(cur+"""");\n        for(int i=in.length()-2; i>=0; i--) {\n            if(in.charAt(i)>=cur) {\n                cur = in.charAt(i);\n                ans.insert(0, cur);\n            }\n        }\n\n        System.out.println(ans);\n\n    }\n}\n\n","greedy,strings"
"import java.util.*;\npublic class LMS {\n    public static void main(String [] args) {\n\n        Scanner scan = new Scanner(System.in);\n        String in = scan.next();\n        char cur = in.charAt(in.length()-1);\n        StringBuilder ans = new StringBuilder();\n        ans.append(cur);\n        for (int i=in.length()-2;i>=0;i--) {\n            if (in.charAt(i)>=cur) {\n                cur = in.charAt(i);\n                ans.insert(0, cur);\n\n            }\n        }\n        System.out.println(ans);\n    }\n}\n","greedy,strings"
"import java.util.Scanner;\n \npublic class LexMax1 {\n    public static void main(String[] args) {\n \n        Scanner scan = new Scanner(System.in);\n \n        String s = scan.next();\n        StringBuilder ans=new StringBuilder();\n        ans.append(s.charAt(s.length()-1));\n        \n        for(int i=s.length()-2;i>=0;i--)\n        {\n            if(s.charAt(i)>=ans.charAt(0))\n            {\n                ans.insert(0,s.charAt(i));\n            }\n        }\n        \n        System.out.println(ans);\n    }\n}","greedy,strings"
"import java.util.*;\n\npublic class Main {\n\n	public static void main(String[] args) {\n		\n\n		Scanner input = new Scanner(System.in);\n		int n = input.nextInt();\n		int[] arr = new int[n];\n		for(int i=0; i<n;i++)arr[i] = input.nextInt();\n		int min = arr[0];\n		for(int i=1;i<n;i++){\n			min = Math.min(min, Math.max(arr[i-1],arr[i]));\n		}\n		min = Math.min(arr[n-1],min);\n		System.out.println(min);\n				\n	}\n\n}\n","brute force,implementation"
"import java.util.Scanner;\n\npublic class _1035WalkingintheRain {\n\n	public static void main(String[] args) {\n		\n		Scanner sc = new Scanner(System.in);\n		int n=sc.nextInt();\n		int[] arr = new int[n];\n		for(int i=0;i<n;i++) {\n			arr[i]=sc.nextInt();\n		}\n		int minDaysLeft=Integer.MAX_VALUE;\n		minDaysLeft=Math.min(arr[0], arr[n-1]);\n		for(int i=1;i<n;i++) {\n			minDaysLeft=Math.min(minDaysLeft, Math.max(arr[i],arr[i-1]));\n		}\n		System.out.println(minDaysLeft);\n		\n	}\n\n}\n","brute force,implementation"
"import java.util.Scanner;\n\npublic class bheegibaarish {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n\n        int arr[]=new  int[n];\n        for(int i=0;i<n;i++)\n        {   int t= sc.nextInt();\n            arr[i]= t;\n        }\n        int min=Math.min(arr[n-1],arr[0]);\n        for(int k=0;k<n-2;k++)\n        {\n            min=Math.min(min,Math.max(arr[k+1],arr[k+2]));\n        }\n\n            System.out.print(min);\n        }\n    }","brute force,implementation"
"import java.util.*;\npublic class Minsum{\n\n     public static void main(String[] args){\n         Scanner sc = new Scanner(System.in);\n         int n= sc.nextInt();\n         int arr[] = new int[n];\n         for(int i =0; i<n; i++){\n              arr[i] = sc.nextInt();\n         }\n         int a = Math.min(arr[0],arr[n-1]);\n         for(int i =0; i<n-1; i++){\n              if(arr[i]<a  &&  arr[i+1]<a){\n                   a= Math.max(arr[i],arr[i+1]);\n              }\n         }\n         System.out.println(a);\n     } \n}","brute force,implementation"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF187B extends PrintWriter {\n	CF187B() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF187B o = new CF187B(); o.main(); o.flush();\n	}\n\n	static final int A = 1000001;\n	void init(int[][] aa, int n) {\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < n; j++)\n				aa[i][j] = A;\n			aa[i][i] = 0;\n		}\n	}\n	void mult(int[][] aa, int[][] bb, int[][] cc, int n) {\n		for (int i = 0; i < n; i++)\n			for (int j = 0; j < n; j++) {\n				int c = A;\n				for (int k = 0; k < n; k++)\n					c = Math.min(c, aa[i][k] + bb[k][j]);\n				cc[i][j] = c;\n			}\n	}\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		int r = sc.nextInt();\n		int[][] aa = new int[n][n];\n		int[][] bb = new int[n][n];\n		init(bb, n);\n		while (m-- > 0) {\n			for (int i = 0; i < n; i++)\n				for (int j = 0; j < n; j++)\n					aa[i][j] = sc.nextInt();\n			for (int k = 0; k < n; k++)\n				for (int i = 0; i < n; i++)\n					for (int j = 0; j < n; j++)\n						aa[i][j] = Math.min(aa[i][j], aa[i][k] + aa[k][j]);\n			for (int i = 0; i < n; i++)\n				for (int j = 0; j < n; j++)\n					bb[i][j] = Math.min(bb[i][j], aa[i][j]);\n		}\n		int[][][] pp = new int[n][n][n];\n		int[][] qq = new int[n][n];\n		init(qq, n);\n		for (int h = 0; h < n; h++) {\n			mult(qq, bb, aa, n);\n			for (int i = 0; i < n; i++)\n				for (int j = 0; j < n; j++)\n					pp[h][i][j] = qq[i][j] = aa[i][j];\n		}\n		while (r-- > 0) {\n			int i = sc.nextInt() - 1;\n			int j = sc.nextInt() - 1;\n			int k = sc.nextInt();\n			k = Math.min(k, n - 1);\n			println(pp[k][i][j]);\n		}\n	}\n}\n","dp,shortest paths"
"    import java.io.*;\n    import java.util.*;\n     \n    public class CF187B extends PrintWriter {\n    	CF187B() { super(System.out); }\n    	Scanner sc = new Scanner(System.in);\n    	public static void main(String[] $) {\n    		CF187B o = new CF187B(); o.main(); o.flush();\n    	}\n     \n    	static final int A = 1000001;\n    	void init(int[][] aa, int n) {\n    		for (int i = 0; i < n; i++) {\n    			for (int j = 0; j < n; j++)\n    				aa[i][j] = A;\n    			aa[i][i] = 0;\n    		}\n    	}\n    	void mult(int[][] aa, int[][] bb, int[][] cc, int n) {\n    		for (int i = 0; i < n; i++)\n    			for (int j = 0; j < n; j++) {\n    				int c = A;\n    				for (int k = 0; k < n; k++)\n    					c = Math.min(c, aa[i][k] + bb[k][j]);\n    				cc[i][j] = c;\n    			}\n    	}\n    	void main() {\n    		int n = sc.nextInt();\n    		int m = sc.nextInt();\n    		int r = sc.nextInt();\n    		int[][] aa = new int[n][n];\n    		int[][] bb = new int[n][n];\n    		init(bb, n);\n    		while (m-- > 0) {\n    			for (int i = 0; i < n; i++)\n    				for (int j = 0; j < n; j++)\n    					aa[i][j] = sc.nextInt();\n    			for (int k = 0; k < n; k++)\n    				for (int i = 0; i < n; i++)\n    					for (int j = 0; j < n; j++)\n    						aa[i][j] = Math.min(aa[i][j], aa[i][k] + aa[k][j]);\n    			for (int i = 0; i < n; i++)\n    				for (int j = 0; j < n; j++)\n    					bb[i][j] = Math.min(bb[i][j], aa[i][j]);\n    		}\n    		int[][][] pp = new int[n][n][n];\n    		int[][] qq = new int[n][n];\n    		init(qq, n);\n    		for (int h = 0; h < n; h++) {\n    			mult(qq, bb, aa, n);\n    			for (int i = 0; i < n; i++)\n    				for (int j = 0; j < n; j++)\n    					pp[h][i][j] = qq[i][j] = aa[i][j];\n    		}\n    		while (r-- > 0) {\n    			int i = sc.nextInt() - 1;\n    			int j = sc.nextInt() - 1;\n    			int k = sc.nextInt();\n    			k = Math.min(k, n - 1);\n    			println(pp[k][i][j]);\n    		}\n    	}\n    }","dp,shortest paths"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Solution {\n    private static final int MAX = Integer.MAX_VALUE;\n    private static int n, m, r;\n    private static int[][][] given;\n    private static void floid(int mm) {\n        for (int k=0; k<n; k++) {\n            for (int i=0; i<n; i++) {\n                for (int j=0; j<n; j++) {\n                    given[mm][i][j] = Math.min(given[mm][i][j], given[mm][i][k] + given[mm][k][j]);\n                }\n            }\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer sToken = new StringTokenizer(reader.readLine());\n        n = Integer.parseInt(sToken.nextToken());\n        m = Integer.parseInt(sToken.nextToken());\n        r = Integer.parseInt(sToken.nextToken());\n        given = new int[m][n][n];\n        for (int t=0; t<m; t++) {\n            for (int i=0; i<n; i++) {\n                sToken = new StringTokenizer(reader.readLine());\n                for (int j=0; j<n; j++) given[t][i][j] = Integer.parseInt(sToken.nextToken());\n            }\n        }\n        for (int mm=0; mm<m; mm++) floid(mm);\n        int[][] lengths = new int[n][n];\n        for (int i=0; i<n; i++) Arrays.fill(lengths[i], MAX);\n        for (int mm=0; mm<m; mm++) {\n            for (int i=0; i<n; i++) {\n                for (int j=0; j<n; j++) {\n                    lengths[i][j] = Math.min(lengths[i][j], given[mm][i][j]);\n                }\n            }\n        }\n        int[][][] dp = new int[n+1][n][n];\n        for (int i=1; i<=n; i++) {\n            for (int j=0; j<n; j++) {\n                Arrays.fill(dp[i][j], MAX);\n            }\n        }\n        for (int i=0; i<n; i++) dp[0][i] = Arrays.copyOf(lengths[i], n);\n        for (int l=1; l<=n; l++) {\n            for (int a=0; a<n; a++) {\n                for (int b=0; b<n; b++) {\n                    dp[l][a][b] = dp[l-1][a][b];\n                    if (a==b) continue;\n                    for (int c=0; c<n; c++) {\n                        if (b==c) continue;\n                        if (dp[l-1][a][c]!=MAX)\n                            dp[l][a][b] = Math.min(dp[l][a][b], dp[l-1][a][c] + lengths[c][b]);\n                    }\n                }\n            }\n        }\n        StringBuilder res = new StringBuilder();\n        while (r-->0) {\n            sToken = new StringTokenizer(reader.readLine());\n            int s = Integer.parseInt(sToken.nextToken()) - 1;\n            int t = Integer.parseInt(sToken.nextToken()) - 1;\n            int k = Integer.parseInt(sToken.nextToken());\n            res.append(dp[Math.min(k, n)][s][t]).append(""\n"");\n        }\n        System.out.println(res);\n    }\n}","dp,shortest paths"
"import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        FastScanner in = new FastScanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        new Main().run(in, out);\n        out.close();\n    }\n\n    public static long mod = 17352642619633L;\n\n    void run(FastScanner in, PrintWriter out) {\n\n        // state\n        // s,t,k\n\n        // s,t < 60\n        // k < 1e3\n        // r < 1e5\n\n        int N = in.nextInt();\n        int M = in.nextInt();\n        int Q = in.nextInt();\n\n        int[][][] c = new int[M][N][N];\n        for (int car = 0; car < M; car++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    c[car][i][j] = in.nextInt();\n                }\n            }\n            fw(c[car]);\n        }\n\n        int[][][] dp = new int[N+1][N][N];\n        int oo = Integer.MAX_VALUE;\n        for (int[][] dd : dp) for (int[] d : dd) Arrays.fill(d, oo);\n\n\n        // base case k = 0\n        for (int u = 0; u < N; u++) {\n            for (int v = 0; v < N; v++) {\n                for (int m = 0; m < M; m++) {\n                    dp[0][u][v] = Math.min(dp[0][u][v], c[m][u][v]);\n                }\n            }\n        }\n\n        for (int k = 1; k <= N; k++) {\n\n            for (int mid = 0; mid < N; mid++) {\n\n                for (int u = 0; u < N; u++) {\n                    for (int v = 0; v < N; v++) {\n                        if (dp[k-1][u][mid] != oo)\n                            dp[k][u][v] = Math.min(dp[k][u][v],\n                                    dp[k-1][u][mid] + dp[0][mid][v]);\n                        dp[k][u][v] = Math.min(dp[k][u][v],\n                                dp[k-1][u][v]);\n                    }\n                }\n            }\n\n        }\n\n\n        while (Q-- > 0) {\n            int s = in.nextInt()-1;\n            int t = in.nextInt()-1;\n            int K = in.nextInt();\n            K = Math.min(K, N);\n\n            out.println(dp[K][s][t]);\n        }\n\n    }\n\n    void fw(int[][] c) {\n\n        int N = c.length;\n        for (int k = 0; k < N; k++) {\n            for (int x = 0; x < N; x++) {\n                for (int y = 0; y < N; y++) {\n                    c[x][y] = Math.min(c[x][y], c[x][k] + c[k][y]);\n                }\n            }\n        }\n    }\n\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n            st = null;\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n","dp,shortest paths"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF180A extends PrintWriter {\n	CF180A() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF180A o = new CF180A(); o.main(); o.flush();\n	}\n\n	int[][] aa; int[] jj, ii;\n	void move(int a, int c) {\n		aa[jj[a]][ii[a]] = c;\n		jj[c] = jj[a]; ii[c] = ii[a];\n	}\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		jj = new int[n + 1]; Arrays.fill(jj, -1);\n		ii = new int[n + 1];\n		aa = new int[m][]; int[] kk = new int[m];\n		for (int j = 0; j < m; j++) {\n			int k = sc.nextInt();\n			aa[j] = new int[kk[j] = k];\n			for (int i = 0; i < k; i++) {\n				int a = sc.nextInt();\n				aa[j][i] = a;\n				jj[a] = j; ii[a] = i;\n			}\n		}\n		int c = 1;\n		while (jj[c] != -1)\n			c++;\n		int[] qu = new int[n * 2], qv = new int[n * 2]; int cnt = 0;\n		for (int a = 1, j = 0; j < m; j++) {\n			int k = kk[j];\n			for (int i = 0; i < k; i++, a++) {\n				int b = aa[j][i];\n				if (b != a) {\n					if (a != c && jj[a] != -1) {\n						qu[cnt] = a; qv[cnt] = c; cnt++;\n						move(a, c);\n					}\n					qu[cnt] = b; qv[cnt] = a; cnt++;\n					move(b, a);\n					c = b;\n				}\n			}\n		}\n		println(cnt);\n		for (int h = 0; h < cnt; h++)\n			println(qu[h] + "" "" + qv[h]);\n	}\n}\n",implementation
"import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        int m = scan.nextInt();\n        int empty = n + 1;\n        int[] cluster = new int[n];\n        ArrayList<String> ans = new ArrayList<>();\n        for (int i = 0; i < cluster.length; i++) {\n            cluster[i] = empty;\n        }\n        int counter = 0;\n        for (int i = 0; i < m; i++) {\n            int numClusters = scan.nextInt();\n            for (int j = 0; j < numClusters; j++) {\n                cluster[scan.nextInt() - 1] = counter++;\n            }\n        }\n//        System.out.println(Arrays.toString(cluster));\n        for (int i = 0; i < cluster.length; i++) {\n            if (cluster[i] != i) {\n                if (cluster[i] != empty) {\n                    for (int j = 0; j < cluster.length; j++) {\n                        if (cluster[j] == empty) {\n                            cluster[j] = cluster[i];\n                            ans.add(i+1 + "" "" + (j+1));\n                            break;\n                        }\n                    }\n                }\n                for (int j = i+1; j < cluster.length; j++) {\n                    if (cluster[j]==i) {\n                        cluster[i] = cluster[j];\n                        cluster[j] = empty;\n                        ans.add(j+1 + "" "" + (i+1));\n                    }\n                }\n            }\n        }\n        System.out.println(ans.size());\n        for (String s: ans) {\n            System.out.println(s);\n        }\n\n    }\n}\n",implementation
"import java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.util.*;\n\npublic class Main{\n    static int f[][] = new int[201][201] ;            //Files\n    static int c[][] = new int[201][2];       //Clusters\n    static int f_size[] = new int[201];\n\n    static void putData(int f_id, int s_id, int c_id){\n        f[f_id][s_id] = c_id;\n        c[c_id] =new int[] {f_id, s_id};\n    }\n\n    public static void main(String[] args) throws IOException {\n        Scanner in = new Scanner(new BufferedInputStream(System.in));\n        int n = in.nextInt();\n        int m = in.nextInt();\n\n        for(int f_id = 1; f_id<= m; f_id++){\n            f_size[f_id] = in.nextInt();\n            for(int s_id = 1; s_id <=f_size[f_id]; s_id++){\n                int c_id = in.nextInt();\n                putData(f_id, s_id, c_id);\n            }\n        }\n\n        //e_id = find(c+1, c+n+1, make_pair(0,0)) - c;\n        int e_id = 0;\n        for (int i = 1; i<=n; i++){\n            if(test(i,0,0)) {\n                e_id = i;\n                break;\n            }\n        }\n\n        int next_id = 1;\n\n        ArrayList<int[]> op = new ArrayList<>();\n        for(int f_id = 1; f_id<= m; f_id++){\n            for(int s_id = 1; s_id <=f_size[f_id]; s_id++, next_id++){\n                if(test(next_id, f_id, s_id))\n                    continue;\n                if(!test(next_id, 0,0)){    //then is not empty\n                    op.add(new int[]{next_id, e_id});         //not push_back() because we are pushing a pair into the vector\n                    putData(c[next_id][0], c[next_id][1], e_id);\n                }\n                e_id = f[f_id][s_id];\n                c[e_id] = new int[]{0,0};\n                op.add(new int[]{e_id, next_id});\n                putData(f_id, s_id, next_id);\n            }\n        }\n\n        System.out.printf(""%d\n"", op.size());\n        for(int [] p: op){\n            System.out.printf(""%d %d\n"", p[0], p[1]);\n        }\n    }\n\n    private static boolean test(int i, int a, int b) {\n        return c[i][0]==a && c[i][1]==b;\n    }\n}\n",implementation
"// Name: William James\n// Date: Feb 7, 2019\n// Description:\n\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        PrintWriter out = new PrintWriter(System.out);\n        in.init(System.in);\n        ArrayList<String> answers = new ArrayList<>();\n        int numClusters = in.nextInt();\n        int numFiles = in.nextInt();\n        int numClustersInRow, posInArray;\n        int[] arr = new int[numClusters];\n        for (int i = 0; i < numClusters; i++) {\n           arr[i] = -1;\n        }\n        int counter = 0;\n        for (int i = 0; i < numFiles; i++) {\n            numClustersInRow = in.nextInt();\n            for (int j = 0; j < numClustersInRow; j++) {\n                  arr[in.nextInt() - 1] = counter++;\n            }\n        }\n        \n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] != i) {\n                if (arr[i] != -1) {\n                    for (int j = 0; j < arr.length; j++) {\n                        if (arr[j] == -1) {\n                            arr[j] = arr[i];\n                            answers.add((i + 1) + "" "" + (j + 1));\n                            break;\n                        }\n                    }\n                }\n                for (int j = i + 1; j < arr.length; j++) {\n                    if (arr[j] == i)\n                    {\n                        arr[i] = arr[j];\n                        arr[j] = -1;\n                        answers.add((j+1) + "" "" + (i + 1));\n                    }\n                }\n            }\n        }\n        System.out.println(answers.size());\n        for(String s : answers)\n        {\n            out.println(s);\n        }\n\n//        for (int i = 1; i < count + 1; i++) {\n//            System.out.printf(""%d "", arr[i].getFileNum());\n//            System.out.printf(""%d\n"", arr[i].getPosNum());\n//        }\n        out.close();\n    }\n}\n\nclass Cluster {\n\n    int fileNum, posNum;\n\n    public Cluster(int fileNum, int posNum) {\n        this.fileNum = fileNum;\n        this.posNum = posNum;\n    }\n    public Cluster()\n    {\n        this.fileNum = -1;\n        this.posNum = -1;\n    }\n\n    public int getFileNum() {\n        return fileNum;\n    }\n\n    public int getPosNum() {\n        return posNum;\n    }\n\n}\n\n/**\n * Class for buffered reading integer and double values\n */\nclass in {\n\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    /**\n     * call this method to initialize reader for InputStream\n     */\n    static void init(InputStream input) {\n        reader = new BufferedReader(new InputStreamReader(input));\n        tokenizer = new StringTokenizer("""");\n    }\n\n    /**\n     * get next word\n     */\n    static String next() throws IOException {\n        while (!tokenizer.hasMoreTokens()) {\n            //TODO add check for eof if necessary\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n}\n",implementation
"import java.io.*;\nimport java.util.*;\n\n// Brute force: discrete optimization.\n// Random-solution.\n\npublic class Main {\n	Scanner in;\n	PrintWriter out;\n\n	private int getQuality(final int avgSum,\n						   final int n,\n						   int[][] magicSquare) {\n		int curSum;\n		int quality = 0;\n		for (int i = 0; i < n; i++) {\n			curSum = 0;\n			for (int j = 0; j < n; j++) {\n				curSum += magicSquare[i][j];\n			}\n			quality += Math.abs(curSum - avgSum);\n		}\n		for (int j = 0; j < n; j++) {\n			curSum = 0;\n			for (int i = 0; i < n; i++) {\n				curSum += magicSquare[i][j];\n			}\n			quality += Math.abs(curSum - avgSum);\n		}\n		curSum = 0;\n		for (int i = 0; i < n; i++) {\n			curSum += magicSquare[i][i];\n		}\n		quality += Math.abs(curSum - avgSum);\n		curSum = 0;\n		for (int i = 0; i < n; i++) {\n			curSum += magicSquare[i][n - 1 - i];\n		}\n		quality += Math.abs(curSum - avgSum);\n		return quality;\n	}\n\n	private void solve() {\n		int n = in.nextInt();\n		int avgSum = 0;\n		List<Integer> numbers = new ArrayList<>();\n		for (int i = 0; i < n * n; i++) {\n			int curNum = in.nextInt();\n			numbers.add(curNum);\n			avgSum += curNum;\n		}\n		avgSum /= n;\n		int[][] magicSquare = new int[n][n];\n		while (true) {\n			Collections.shuffle(numbers, new Random(System.currentTimeMillis()));\n			for (int i = 0; i < n; i++) {\n				for (int j = 0; j < n; j++) {\n					magicSquare[i][j] = numbers.get(i * n + j);\n				}\n			}\n			while (true) {\n				boolean updated = false;\n				int curQuality = getQuality(avgSum, n, magicSquare);\n				for (int i = 0; i < n * n; i++) {\n					for (int j = i; j < n * n; j++) {\n						int r1 = i / n;\n						int c1 = i % n;\n						int r2 = j / n;\n						int c2 = j % n;\n						if (magicSquare[r1][c1] == magicSquare[r2][c2]) {\n							continue;\n						}\n						{\n							int tmp = magicSquare[r1][c1];\n							magicSquare[r1][c1] = magicSquare[r2][c2];\n							magicSquare[r2][c2] = tmp;\n						}\n						int newQuality = getQuality(avgSum, n, magicSquare);\n						if (newQuality < curQuality) {\n							i = n * n;\n							updated = true;\n							break;\n						}\n						{\n							int tmp = magicSquare[r1][c1];\n							magicSquare[r1][c1] = magicSquare[r2][c2];\n							magicSquare[r2][c2] = tmp;\n						}\n					}\n				}\n				if (!updated) {\n					break;\n				}\n			}\n			int curQuality = getQuality(avgSum, n, magicSquare);\n			if (curQuality == 0) {\n				break;\n			}\n		}\n		out.println(avgSum);\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < n; j++) {\n				if (j > 0) {\n					out.print("" "");\n				}\n				out.format(""%d"", magicSquare[i][j]);\n			}\n			if (i + 1 != n) {\n				out.println();\n			}\n		}\n	}\n\n	public void run() {\n		try {\n			in = new Scanner(System.in);\n			out = new PrintWriter(System.out);\n\n			solve();\n\n			out.close();\n		} catch (Exception e) {\n			e.printStackTrace();\n			System.exit(-1);\n		}\n	}\n\n	public static void main(String[] args) {\n		new Main().run();\n	}\n}",
"import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int t =s.nextInt();\n        int a,b,n,k;\n        int ans=0;\n        int [] ar=new int[t];\n        for(int i=0;i<t;i++)ar[i]=0;\n        for(int i=0;i<t-1;i++){\n            ar[i]+=s.nextInt();\n            a=(int)(Math.log(t-i-1)/Math.log(2));\n            ar[i+(int)(Math.pow(2, a))]+=ar[i];\n            ans+=ar[i];\n            System.out.println(ans);\n        }\n        \n        //end code\n    }\n}\n",greedy
"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class _0826EducationalGame {\n	static int findIndex(int i,int n) {\n		int inc=0;\n		int start=i;\n	while(i<=n) {\n		if(start+Math.pow(2, inc)<=n) {\n			i=(int) (start+Math.pow(2, inc));\n		}\n		else {\n			break;\n		}\n		inc++;\n	}\n	return (int) (i);\n	}\n	public static void main(String[] args) {\n		\n		Scanner sc = new Scanner(System.in);\n		int n=sc.nextInt();\n		int[] arr = new int[n+1];\n		for(int i=1;i<=n;i++) {\n			arr[i]=sc.nextInt();\n		}\n		long minMoves=0;\n		for(int i=1;i<n;i++) {\n			minMoves+=arr[i];\n			arr[findIndex(i, n)]+=arr[i];\n			System.out.println(minMoves);\n		}\n	}\n\n}\n",greedy
import java.util.*;\npublic class Minsum{\n\n     public static void main(String[] args){\n         Scanner sc = new Scanner(System.in);\n         int n =sc.nextInt();\n         int arr[] = new int[n+1];\n         for(int i =1; i<=n; i++){\n             arr[i] = sc.nextInt();\n         }\n         int ans[] = new int[n+1];\n         \n         for(int i =1; i<n; i++){\n             int var = 2;\n             while(i+var <=n){\n                 var = var*2;\n             }var = var/2;\n             \n             ans[i] = arr[i] + ans[i-1];\n             arr[i+var] = arr[i+var] + arr[i];\n          }\n         for(int i =1; i<n; i++){\n             System.out.println(ans[i]);\n         }\n         \n     } \n},greedy
"import java.util.Scanner;\n\npublic class EducationalGame1 {\n    public static void main (String[] args) {\n        Scanner sc = new Scanner(System.in);\n       \n        int n = sc.nextInt();\n        if (n > 1) {\n            // Store the number of moves needed for every i\n            int[] moves = new int[n-1];\n           \n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = sc.nextInt();\n            } \n\n            // Initialize dynamic programming array \n            moves[0] = a[0];\n       \n            // Typecast to truncate after decimal point\n            int t = (int) (Math.log(n-1) / Math.log(2));\n            a[0+(int)Math.pow(2, t)] += a[0];\n\n            for (int i = 1; i < n-1; i++) {\n                moves[i] = moves[i-1] + a[i];\n                t = (int) (Math.log(n-1-i) / Math.log(2));\n                a[i + (int) Math.pow(2, t)] += a[i];\n            }\n      \n            for (int m : moves) {\n                System.out.println(m);\n            } \n        }\n        sc.close();\n    }\n}\n",greedy
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF174C extends PrintWriter {\n	CF174C() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF174C o = new CF174C(); o.main(); o.flush();\n	}\n\n	static final int K = 100000;\n	void main() {\n		int n = sc.nextInt();\n		int[] aa = new int[n + 2];\n		for (int i = 1; i <= n; i++)\n			aa[i] = sc.nextInt();\n		int[] qu = new int[n + 2]; int cnt = 0;\n		qu[cnt++] = 0;\n		int[] ll = new int[K], rr = new int[K]; int k = 0;\n		for (int i = 1; i <= n + 1; i++) {\n			int a = aa[i], l = i, r = i - 1;\n			while (aa[qu[cnt - 1]] > a) {\n				int d = aa[qu[cnt - 1]] - Math.max(aa[qu[cnt - 2]], a);\n				l = qu[--cnt];\n				while (d-- > 0) {\n					ll[k] = l; rr[k] = r; k++;\n				}\n			}\n			aa[l] = a;\n			if (aa[qu[cnt - 1]] < a)\n				qu[cnt++] = l;\n		}\n		println(k);\n		while (k-- > 0)\n			println(ll[k] + "" "" + rr[k]);\n	}\n}\n","data structures,greedy"
"import java.io.*;\nimport java.util.*;\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\npublic class RangeIncrements\n{\n    void run() {\n        int tc=1,mx_n=(int)1e5+10;\n        StringBuilder sb = new StringBuilder();\n        while(tc-->0) {\n            int n=ni(),a[]=new int[mx_n],b[]=new int[mx_n],c[]=new int[mx_n],f=0,g=0;\n            for(int i=1;i<=n;a[i++]=ni());\n            for(int i=1;i<=n;i++) {\n            	for(int j=a[i-1];j<a[i];j++) b[f++]=i;\n            	for(int j=a[i+1];j<a[i];j++) c[g++]=i;\n            }\n        	out.println(f);\n        	for(int i=0;i<f;i++) sb.append(b[i]+"" ""+c[i]+""\n"");\n        }\n        out.println(sb);\n        out.flush(); \n        out.close();\n    }\n\n    public static void main(String[] args)throws Exception {\n        try { \n            // new Thread(null, new RangeIncrements()::run, ""1"", 1 << 26).start();\n            new Thread(null, new RangeIncrements(""ONLINE_JUDGE"")::run, ""1"", 1 << 26).start();\n        } catch(Exception e) {}\n    }\n\n    FastReader sc=null;PrintWriter out = null;\n    public RangeIncrements()throws Exception {\n        sc = new FastReader(new FileInputStream(""D:\\CP\\input.txt""));\n        out = new PrintWriter(new BufferedWriter(new FileWriter(""D:\\CP\\output.txt"")));\n    }\n    public RangeIncrements(String JUDGE) {\n        sc = new FastReader(System.in);\n        out = new PrintWriter(System.out);      \n    }\n    \n    String ns() { return sc.next(); }\n    int ni() { return sc.nextInt(); }\n    long nl() { return sc.nextLong(); }\n    int[] ni(int n) {\n        int a[]=new int[n];\n        for(int i=0;i<n;a[i++]=ni());\n        return a;\n    }\n    long[] nl(int n) {\n        long a[]=new long[n];\n        for(int i=0;i<n;a[i++]=nl());\n        return a;\n    }\n    \n    int[][] ni(int n,int m) {\n        int a[][]=new int[n][m];\n        for(int i=0;i<n;i++) \n            for(int j=0;j<m;j++)\n                a[i][j]=ni();\n        return a;\n    }\n    long[][] nl(int n,int m) {\n        long a[][]=new long[n][m];\n        for(int i=0;i<n;i++) \n            for(int j=0;j<m;j++)\n                a[i][j]=nl();\n        return a;\n    }\n    int gcd(int a, int b) {\n        return b==0?a:gcd(b,a%b);\n    }\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastReader.SpaceCharFilter filter;\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res = res*1L*10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res *1L* sgn;\n        }\n        \n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) return filter.isSpaceChar(c);\n            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n    }\n}","data structures,greedy"
"import java.io.*;\nimport java.util.*;\n\npublic class ONE74C \n{\n    public static void main(String args[])\n    {\n        ONE74C o = new ONE74C();\n        o.process();\n    }\n    \n    public void process()\n    {\n        Scanner s = new Scanner(System.in);\n        int n = s.nextInt();\n        \n        int hist[] = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            hist[i] = s.nextInt();\n        }\n        \n        int cur = 0;\n        Stack<RangePair> q = new Stack<RangePair>();\n        ArrayList<RangePair> ans = new ArrayList<RangePair>();\n        \n        for (int i = 0; i < n; i++)\n        {\n            if (cur != hist[i])\n            {\n                if (cur < hist[i])\n                {\n                    for (int j = 0; j < hist[i] - cur; j++)\n                    {\n                        RangePair r = new RangePair(i, -1);\n                        q.add(r);\n                    }\n                    cur = hist[i];\n                }\n                else\n                {\n                    for (int j = 0; j < cur - hist[i]; j++)\n                    {\n                        RangePair pair = q.pop();\n                        pair.right = i-1;\n                        ans.add(pair);\n                    }\n                    cur = hist[i];\n                }\n            }\n        }\n        \n        while (!q.isEmpty())\n        {\n            RangePair p = q.pop();\n            p.right = n-1;\n            ans.add(p);\n        }\n        \n        System.out.println(ans.size());\n        for (int i = 0; i < ans.size(); i++)\n        {\n            RangePair curPair = ans.get(i);\n            int val1 = curPair.left + 1;\n            int val2 = curPair.right + 1;\n            \n            System.out.println(val1 + "" "" + val2);\n        }\n    }\n\n}\n\nclass RangePair\n{\n    public int left, right;\n    public RangePair(int l, int r)\n    {\n        left = l;\n        right = r;\n    }\n}\n","data structures,greedy"
"import java.awt.Point;\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class A {\n	public static void main(String[] args) throws Exception {\n		Scanner sc = new Scanner();\n		PrintWriter out = new PrintWriter(System.out);\n		int n = sc.nextInt();\n		int[] a = new int[n];\n		TreeMap<Integer, ArrayList<Integer>> nums = new TreeMap<Integer, ArrayList<Integer>>();\n		TreeSet<Point> ranges = new TreeSet<>(new Comparator<Point>() {\n\n			@Override\n			public int compare(Point o1, Point o2) {\n				// TODO Auto-generated method stub\n				return Integer.compare(o1.x, o2.x);\n			}\n		});\n		for (int i = 0; i < a.length; ++i) {\n			a[i] = sc.nextInt();\n			ArrayList<Integer> indices = nums.getOrDefault(a[i], new ArrayList<Integer>());\n			indices.add(i);\n			nums.put(a[i], indices);\n		}\n		ranges.add(new Point(0, n - 1));\n		ArrayList<Point> operations = new ArrayList<>();\n		for (int i = 0; i < nums.lastKey(); ++i) {\n			if (nums.containsKey(i)) {\n				ArrayList<Integer> num = nums.get(i);\n				for (int idx : num) {\n					Point lower = ranges.floor(new Point(idx, idx));\n					ranges.remove(lower);\n					Point newRange = new Point(lower.x, idx - 1);\n					if (newRange.y - newRange.x + 1 > 0)\n						ranges.add(newRange);\n					newRange = new Point(idx + 1, lower.y);\n					if (newRange.y - newRange.x + 1 > 0)\n						ranges.add(newRange);\n				}\n			}\n			for (Point range : ranges)\n				operations.add(range);\n		}\n		out.println(operations.size());\n		for (Point op : operations)\n			out.printf(""%d %d\n"", op.x + 1, op.y + 1);\n		out.flush();\n		out.close();\n	}\n\n	static class Scanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		public Scanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		public Scanner(String s) throws FileNotFoundException {\n			br = new BufferedReader(new FileReader(s));\n		}\n\n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens()) {\n				st = new StringTokenizer(br.readLine(), "" \t\n\r\f,()"");\n			}\n			return st.nextToken();\n		}\n\n		public int nextInt() throws NumberFormatException, IOException {\n			return Integer.parseInt(next());\n		}\n\n		public long nextLong() throws NumberFormatException, IOException {\n			return Long.parseLong(next());\n		}\n\n		public double nextDouble() throws NumberFormatException, IOException {\n			return Double.parseDouble(next());\n		}\n\n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n	}\n\n}","data structures,greedy"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class G{\n\n	public static void main(String[] args) {\n		FastScanner scan = new FastScanner();\n		PrintWriter out = new PrintWriter(System.out);\n		int[] dp = new int[30];\n		dp[0] = scan.nextInt();\n		dp[1] = scan.nextInt();\n		for(int i = 2; i < 30; i++) dp[i] = dp[i-1]+dp[i-2];\n		out.println(dp[scan.nextInt()]);\n		out.close();\n	}\n\n	static class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		public FastScanner() {\n			try	{\n				br = new BufferedReader(new InputStreamReader(System.in));\n				st = new StringTokenizer(br.readLine());\n			} catch (Exception e){e.printStackTrace();}\n		}\n\n		public String next() {\n			if (st.hasMoreTokens())	return st.nextToken();\n			try {st = new StringTokenizer(br.readLine());}\n			catch (Exception e) {e.printStackTrace();}\n			return st.nextToken();\n		}\n\n		public int nextInt() {return Integer.parseInt(next());}\n\n		public long nextLong() {return Long.parseLong(next());}\n\n		public double nextDouble() {return Double.parseDouble(next());}\n\n		public String nextLine() {\n			String line = """";\n			if(st.hasMoreTokens()) line = st.nextToken();\n			else try {return br.readLine();}catch(IOException e){e.printStackTrace();}\n			while(st.hasMoreTokens()) line += "" ""+st.nextToken();\n			return line;\n		}\n\n		public int[] nextIntArray(int n) {\n			int[] a = new int[n];\n			for(int i = 0; i < n; i++) a[i] = nextInt();\n			return a;\n		}\n\n		public long[] nextLongArray(int n){\n			long[] a = new long[n];\n			for(int i = 0; i < n; i++) a[i] = nextLong();\n			return a;\n		}\n\n		public double[] nextDoubleArray(int n){\n			double[] a = new double[n];\n			for(int i = 0; i < n; i++) a[i] = nextDouble();\n			return a;\n		}\n\n		public char[][] nextGrid(int n, int m){\n			char[][] grid = new char[n][m];\n			for(int i = 0; i < n; i++) grid[i] = next().toCharArray();\n			return grid;\n		}\n	}\n\n}",*special
"import java.util.*;\nimport java.io.*;\nimport java.text.*;\nimport java.math.*;\nimport static java.lang.Integer.*;\nimport static java.lang.Double.*;\nimport java.lang.Math.*;\n\npublic class mysterious_numbers2 {\n\n	public static void main(String[] args) throws Exception {\n		new mysterious_numbers2().run();\n	}\n\n	public void run() throws Exception {\n		FastIO file = new FastIO();\n		int a = file.nextInt();\n		int b = file.nextInt();\n		int c = file.nextInt();\n		if (c == 0) System.out.println(a);\n		else if (c == 1) System.out.println(b);\n		else {\n			while (c > 1) {\n				c--;\n				int d = a + b;\n				a = b;\n				b = d;\n			}\n			System.out.println(b);\n		}\n		file.out.flush();\n	}\n\n	public static class FastIO {\n		BufferedReader br;\n		StringTokenizer st;\n		PrintWriter out;\n\n		public FastIO() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n			out = new PrintWriter(System.out);\n		}\n\n		String next() {\n			while (st == null || !st.hasMoreElements()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			}\n			return st.nextToken();\n		}\n\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n\n		String nextLine() {\n			String str = """";\n			try {\n				str = br.readLine();\n			} catch (IOException e) {\n				e.printStackTrace();\n			}\n			return str;\n		}\n\n		void print(Object o) {\n			out.print(o);\n		}\n\n		void println(Object o) {\n			out.println(o);\n		}\n\n		void printf(String s, Object... o) {\n			out.printf(s, o);\n		}\n	}\n\n	public static long pow(long n, long p, long mod) {\n		if (p == 0)\n			return 1;\n		if (p == 1)\n			return n % mod;\n		if (p % 2 == 0) {\n			long temp = pow(n, p / 2, mod);\n			return (temp * temp) % mod;\n		} else {\n			long temp = pow(n, (p - 1) / 2, mod);\n			temp = (temp * temp) % mod;\n			return (temp * n) % mod;\n\n		}\n	}\n\n	public static long pow(long n, long p) {\n		if (p == 0)\n			return 1;\n		if (p == 1)\n			return n;\n		if (p % 2 == 0) {\n			long temp = pow(n, p / 2);\n			return (temp * temp);\n		} else {\n			long temp = pow(n, (p - 1) / 2);\n			temp = (temp * temp);\n			return (temp * n);\n\n		}\n	}\n\n	public static long gcd(long x, long y) {\n		if (x == 0)\n			return y;\n		else\n			return gcd(y % x, x);\n	}\n\n	public static boolean isPrime(int n) {\n		if (n <= 1)\n			return false;\n		if (n <= 3)\n			return true;\n\n		if (n % 2 == 0 || n % 3 == 0)\n			return false;\n\n		for (int i = 5; i * i <= n; i = i + 6)\n			if (n % i == 0 || n % (i + 2) == 0)\n				return false;\n\n		return true;\n	}\n}\n",*special
"import java.io.*;\nimport java.util.*;\n\npublic class Template implements Runnable {\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer("""");\n\n    void init() throws FileNotFoundException {\n        try {\n            in = new BufferedReader(new FileReader(""input.txt""));\n            out = new PrintWriter(""output.txt"");\n        } catch (Exception e) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        }\n    }\n\n    class GraphBuilder {\n        int n, m;\n        int[] x, y;\n        int index;\n        int[] size;\n\n\n        GraphBuilder(int n, int m) {\n            this.n = n;\n            this.m = m;\n            x = new int[m];\n            y = new int[m];\n            size = new int[n];\n        }\n\n        void add(int u, int v) {\n            x[index] = u;\n            y[index] = v;\n            size[u]++;\n            size[v]++;\n            index++;\n        }\n\n        int[][] build() {\n            int[][] graph = new int[n][];\n            for (int i = 0; i < n; i++) {\n                graph[i] = new int[size[i]];\n            }\n            for (int i = index - 1; i >= 0; i--) {\n                int u = x[i];\n                int v = y[i];\n                graph[u][--size[u]] = v;\n                graph[v][--size[v]] = u;\n            }\n            return graph;\n        }\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            try {\n                tok = new StringTokenizer(in.readLine());\n            } catch (Exception e) {\n                return null;\n            }\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    int[] readIntArray(int size) throws IOException {\n        int[] res = new int[size];\n        for (int i = 0; i < size; i++) {\n            res[i] = readInt();\n        }\n        return res;\n    }\n\n    long[] readLongArray(int size) throws IOException {\n        long[] res = new long[size];\n        for (int i = 0; i < size; i++) {\n            res[i] = readLong();\n        }\n        return res;\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    <T> List<T>[] createGraphList(int size) {\n        List<T>[] list = new List[size];\n        for (int i = 0; i < size; i++) {\n            list[i] = new ArrayList<>();\n        }\n        return list;\n    }\n\n    public static void main(String[] args) {\n        new Template().run();\n        // new Thread(null, new Template(), """", 1l * 200 * 1024 * 1024).start();\n    }\n\n    long timeBegin, timeEnd;\n\n    void time() {\n        timeEnd = System.currentTimeMillis();\n        System.err.println(""Time = "" + (timeEnd - timeBegin));\n    }\n\n    long memoryTotal, memoryFree;\n\n    void memory() {\n        memoryFree = Runtime.getRuntime().freeMemory();\n        System.err.println(""Memory = "" + ((memoryTotal - memoryFree) >> 10)\n                + "" KB"");\n    }\n\n    public void run() {\n        try {\n            timeBegin = System.currentTimeMillis();\n            memoryTotal = Runtime.getRuntime().freeMemory();\n            init();\n            solve();\n            out.close();\n            if (System.getProperty(""ONLINE_JUDGE"") == null) {\n                time();\n                memory();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n\n    void solve() throws IOException {\n        long x = readLong();\n        long y = readLong();\n        int it = readInt();\n        while (it --> 0) {\n            long z = x + y;\n            x = y;\n            y = z;\n        }\n        out.println(x);\n\n\n    }\n\n\n}",*special
"import java.util.*;\npublic class supercentralpoint \n{\n	public static void main(String[] args) \n	{\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int c,d,e,f,ans=0;\n		int a[]=new int[n];\n		int b[]=new int[n];\n		for(int i=0;i<n;i++)\n		{\n			a[i]=sc.nextInt();\n			b[i]=sc.nextInt();\n		}\n		for(int i=0;i<n;i++)\n		{\n			c=1;e=1;f=1;d=1;\n			for(int j=0;j<n;j++)\n			{\n				if(i==j)continue;\n				if(a[i]>a[j] && b[i]==b[j])c=0;\n				if(a[i]<a[j] && b[i]==b[j])d=0;\n				if(a[i]==a[j] && b[i]>b[j])e=0;\n				if(a[i]==a[j] && b[i]<b[j])f=0;\n			}\n			if(c+d+e+f==0)ans++;\n		}\n		System.out.println(ans);\n		\n	}\n\n}\n",implementation
"import java.util.*;\npublic class one\n{\npublic static void main(String args[])\n{\nScanner ss=new Scanner(System.in);\nint n=ss.nextInt();\nint a[][]=new int[n][2];\n\nfor(int i1=0;i1<n;i1++)\n{\na[i1][0]=ss.nextInt();\na[i1][1]=ss.nextInt();\n}\nint ans=0;\nfor(int i=0;i<n;i++)\n{\n    int d=0, t=0, r=0, l=0;\nfor(int j=0;j<n;j++)\n{\n    if(a[i][0]<a[j][0] && a[i][1]==a[j][1])\n    l=1;\n if(a[i][0]>a[j][0] && a[i][1]==a[j][1])\n    r=1;\n if(a[i][0]==a[j][0] && a[i][1]>a[j][1])\n    t=1;\n if(a[i][0]==a[j][0] && a[i][1]<a[j][1])\n    d=1;\n    if(l==1 && r==1 && t==1 && d==1)\n    {ans+=1;\n    break;\n    }\n   }\n}\n\nSystem.out.println(ans);\n\n}\n}",implementation
"import java.util.*;\n\npublic class blipblop {\n\n	\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int x[]=new int[n];\n		int y[]=new int[n];\n		for(int i=0 ; i< n ; i++) {\n			x[i]=sc.nextInt();\n			y[i]=sc.nextInt();\n		}\n		int ans=0;\n		for(int i=0 ; i<n ; i++) {\n			int u=0,l=0,d=0,r=0;\n			for(int j=0 ; j<n ; j++) {\n				if(x[i]==x[j] && i!=j) {\n					if(y[j]>y[i]) {\n						u++;\n					}else {\n						d++;\n					}\n				}\n				if(y[i]==y[j] && i!=j) {\n					if(x[j]>x[i]) {\n						r++;\n					}else {\n						l++;\n					}\n				}\n			}\n			if(u>=1 && d>=1 && r>=1 && l>=1) {\n				ans++;\n			}\n		}\n		System.out.println(ans);\n\n	}\n\n}\n",implementation
"import java.util.*;\npublic class supercentral {\n	public static void main(String args[])\n	{\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int x[]=new int[n];\n		int y[]=new int[n];int count=0;\n		for(int i=0;i<n;i++)\n		{\n			x[i]=sc.nextInt();\n			y[i]=sc.nextInt();\n		}\n		for(int i=0;i<n;i++)\n		{\n			int x1=x[i];\n			int y1=y[i];\n			int l=0,r=0,u=0,b=0;\n			for(int j=0;j<n;j++)\n			{\n				if(y1==y[j])\n				{\n					if(x[j]<x1)\n						l++;\n					else if(x[j]>x1)\n						r++;\n				}\n				else if(x1==x[j])\n				{\n					if(y[j]<y1)\n						b++;\n					 else if(y[j]>y1)\n						u++;\n				}\n			}\n			if(l>0&&r>0&&u>0&&b>0)\n			if((l+b+r+u)>=4)\n				count++;\n		}\n		System.out.print(count);\n	}\n}\n",implementation
"import java.util.*;\n\npublic class Main\n{\n	static int n;static int k;static int h;\n	static ArrayList<su> list=new ArrayList<>();\n	static int ans[]=new int[10000000];\n	public static void main(String[] args)\n	{\n		Scanner in=new Scanner(System.in);\n		n=in.nextInt();\n		k=in.nextInt();\n		h=in.nextInt();\n		for(int i=1;i<=n;i++)\n		{\n			list.add(new su(in.nextInt(),i));\n		}\n		for(int i=0;i<n;i++)\n		{\n			list.get(i).sd=in.nextInt();\n		}\n		Collections.sort(list);\n		double l=0;\n		double r=1000000000;\n		for(int k=0;k<=200;k++)\n		{\n			double m=(r+l)/2.0;\n			if(pd(m))\n			{\n				r=m;\n			}\n			else\n			{\n				l=m;\n			}\n		}\n		pd(r);\n		for(int i=1;i<=k;i++)\n		{\n			if(i!=1)System.out.print("" ""+ans[i]);\n			else System.out.print(ans[i]);\n		}\n		System.out.println();\n	}\n	static boolean pd(double x)\n	{\n		int t=1;\n		for(int i=0;i<list.size();i++)\n		{\n			if(1.0*h*t<=list.get(i).sd*x)\n			{\n				ans[t++]=(int) list.get(i).wz;\n				if(t>k)return true;\n			}\n		}\n		return false;\n	}\n}\nclass su implements Comparable<su>\n{\n	double zl,sd,wz;\n	public su(double zl,double wz)\n	{\n		this.zl=zl;\n		this.wz=wz;\n	}\n	@Override\n	public int compareTo(su o)\n	{\n		if(this.zl>o.zl)return 1;\n		else if(this.zl<o.zl)return -1;\n		else \n		{\n			if(this.sd>o.sd)return 1;\n			else if(this.sd<o.sd)return -1;\n			else {\n				return 0;\n			}\n		}\n	}\n}\n\n  				 				   			    	 	  	 	",binary search
"import java.io.*;\nimport java.util.*;\n\npublic class Main\n{\n	static StreamTokenizer in=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n	static PrintWriter out=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n	public static void main(String[] args) throws IOException\n	{\n		\n		Scanner sc=new Scanner(System.in);\n		long n=inl();\n		long k=inl();\n		long h=inl();\n		Lem[]a=new Lem[(int)n+10];\n		for(int i=1;i<=n;i++)\n		{\n			long m=inl();\n			a[i]=new Lem(i,m);\n		}\n		double l=0x3f3f3f3f,r=0;\n		for(int i=1;i<=n;i++)\n		{\n			long v=inl();\n			a[i].v=v;\n			l=Math.min(l,h*1.0/v);\n			r=Math.max(r,k*h*1.0/v);\n		}\n		Arrays.sort(a,1,(int) (n+1));\n		int cnt=100;\n		long[]high=new long[(int)n+10];\n		while(cnt-->0)\n		{\n			double mid=(l+r)/2.0;\n			for(int i=1;i<=n;i++)\n				high[i]=(long)(mid*a[i].v/h);\n			long tmp=k;\n			for(int i=(int)n;i>=1;i--)\n				if(high[i]>=tmp)tmp--;\n			if(tmp<=0)r=mid;\n			else l=mid;\n		}\n		for(int i=1;i<=n;i++)\n			high[i]=(long)(r*a[i].v/h);\n		long tmp=k;\n		int[]ans=new int[(int)n+10];\n		for(int i=(int)n;i>=1;i--)\n		{\n			if(high[i]>=tmp)ans[(int)tmp--]=(int)a[i].id;\n			if(tmp==0)break;\n		}\n		for(int i=1;i<=k;i++)\n			out.printf(""%d%c"",ans[i],i==n?'\n':' ');\n		out.flush();\n	}\n	\n	public static long inl() throws IOException\n	{\n		in.nextToken();\n		return (long)in.nval;\n	}\n	\n}\nclass Lem implements Comparable<Lem>\n{\n	long id,m,v;\n	public Lem(long a,long b)\n	{\n		id=a;\n		m=b;\n	}\n	@Override\n	public int compareTo(Lem o)\n	{\n		if(m==o.m)\n			return v>o.v?1:-1;\n		return m>o.m?1:-1;\n	}\n	\n}\n 	 						 	  	  				 		   		  	",binary search
"import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.*;\npublic class B \n{\n	public static void main(String [] args) throws IOException\n	{\n		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter writer = new PrintWriter(System.out);\n		\n		StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n		int n = Integer.parseInt(tokenizer.nextToken());\n		int k = Integer.parseInt(tokenizer.nextToken());\n		int h = Integer.parseInt(tokenizer.nextToken());\n		\n		int [][] lemmings = new int[n][3];\n		tokenizer = new StringTokenizer(reader.readLine());\n		for(int i = 0 ; i < n ; i++)\n			lemmings[i][0] = Integer.parseInt(tokenizer.nextToken());\n		tokenizer = new StringTokenizer(reader.readLine());\n		for(int i = 0 ; i < n ; i++)\n			lemmings[i][1] = Integer.parseInt(tokenizer.nextToken());\n		for(int i = 0 ; i < n ; i++)\n			lemmings[i][2] = i;\n		\n		Arrays.sort(lemmings, new Comparator<int[]>() {\n\n			@Override\n			public int compare(int[] a, int[] b) {\n				for(int i = 0 ; i < a.length ; i++)\n					if(a[i] != b[i])\n						return Integer.compare(a[i], b[i]);\n				\n				return 0;\n			}\n		});\n		\n		double lb = 0;\n		double ub = 1000000000 + 13;\n		\n		for(int time = 0 ; time < 250 ; time++)\n		{\n			double mid = (lb + ub)/2;\n			int p = 1;\n			\n			for(int i = 0 ; i < n ; i++)\n				if(p*1L*h <= mid*lemmings[i][1])\n					p++;\n			\n			if(p > k)\n				ub = mid;\n			else\n				lb = mid;\n		}\n		\n		int p = 1;\n		for(int i = 0 ; p <= k && i < n ; i++)\n			if(p*h <= ub*lemmings[i][1])\n			{\n				writer.print((1+lemmings[i][2])+"" "");\n				p++;\n			}\n		writer.println();\n		\n		writer.flush();\n		writer.close();\n		\n	}\n}",binary search
"import java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n\npublic class Main\n{\n	static class dian implements Comparable<dian>\n	{\n		int m;\n		double v;\n		int x;\n		public dian (int m,int x)\n		{\n			this.m=m;\n			this.x=x;\n		}\n		@Override\n		public int compareTo(dian o)\n		{\n			if (this.m!=o.m)return o.m-this.m;\n			if (o.v>this.v)return 1;\n			else if (o.v<this.v)return -1;\n			else return 0;\n		}\n	}\n	public static void main(String[] args) throws IOException\n	{\n		Scanner sc=new Scanner(System.in);\n		int n=ini();\n		int m=ini();\n		double h=ini();\n		dian sz[]=new dian [n+1];\n		for (int i=1;i<=n;i++)\n		{\n			sz[i]=new dian(ini(),i);\n		}\n		for (int i=1;i<=n;i++)\n		{\n			sz[i].v=ini();\n		}\n		Arrays.sort(sz,1,n+1);\n		double l=0,r=1000000000;\n		for (int j=1;j<=200;j++)\n		{\n			double mid=(l+r)/2.0;//代表时间\n			int q=m;\n			for (int i=1;i<=n;i++)\n			{\n				if (sz[i].v*mid/h>=q)//现在我能上的台阶\n				{\n					q--;\n				}\n			}\n			if (q<=0)r=mid;\n			else l=mid;\n			//System.out.println(l+"" ""+r);\n		}\n		//System.out.println(l+"" ""+r);\n		int q=m;\n		int ans[]=new int [q];\n		for (int i=1;i<=n;i++)\n		{\n			//System.out.println(sz[i].v*l+"" ""+sz[i].x);\n			if (sz[i].v*r/h>=q)//现在我能上的台阶\n			{\n				ans[--q]=sz[i].x;\n				if (q==0)break;\n			}\n		}\n		for (int i=0;i<m;i++)\n		{\n			if (i==0)out.print(ans[i]);\n			else out.print("" ""+ans[i]);\n		}\n		out.flush();\n	}\n	\n\n/*\n\n\n\n\n*/\n	\n	static StreamTokenizer in=new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n	static PrintWriter out=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n	static int ini() throws IOException\n	{\n		in.nextToken();\n		return (int)in.nval;\n	}\n	static String ins() throws IOException\n	{\n		in.nextToken();\n		return in.sval;\n	}\n}\n      	 		  		   	    			  		",binary search
"import java.io.*;\nimport java.util.*;\n\npublic class Main{\n	static int[] p, rank, setSize;\n	static int numSets,N;\n	public static int findSet(int i) { return p[i] == i ? i : (p[i] = findSet(p[i])); }\n\n	public static boolean isSameSet(int i, int j) { return findSet(i) == findSet(j); }\n\n	public static boolean unionSet(int i, int j) \n	{ \n		if (isSameSet(i, j)) \n			return false;\n		numSets--; \n		int x = findSet(i), y = findSet(j);\n		if(rank[x] > rank[y]) { p[y] = x; setSize[x] += setSize[y]; }\n		else\n		{	p[x] = y; setSize[y] += setSize[x];\n			if(rank[x] == rank[y]) rank[y]++; \n		} \n		return true;\n	}\n	\n	\n	static ArrayList<Integer>[] adjList;\n	static int[] dfs_low, dfs_num, parent;\n	static int V, counter, root, rootChildren;\n\n	static void findArtPointsAndBridges()	//O(V + E)\n	{\n		dfs_low=new int[V];\n		dfs_num=new int[V];\n		parent=new int[V];\n		for(int i = 0; i < V; ++i)\n			if(dfs_num[i] == 0)\n			{\n				root = i;\n				rootChildren = 0;\n				dfs(i);\n			}\n	}\n	\n	static void dfs(int u)\n	{\n		dfs_num[u] = dfs_low[u] = ++counter;\n		int o=0;\n		for(int v: adjList[u])\n			if(dfs_num[v] == 0)\n			{\n				parent[v] = u;\n				if(u == root)\n					++rootChildren;\n				dfs(v);\n				if(dfs_low[v] > dfs_num[u])\n					ans[mapEdges.get(new int[] {u,v})]=2;//bridge\n				dfs_low[u] = Math.min(dfs_low[v], dfs_low[u]);\n			}\n			else {\n				if(parent[u] != v || o>0)\n					dfs_low[u] = Math.min(dfs_low[u], dfs_num[v]);\n				else {\n					o++;\n				}\n			}\n	}\n	static int[]ans;\n	static TreeMap<int[], Integer>mapEdges;\n	public static void main(String[] args) throws Exception{\n		PrintWriter pw=new PrintWriter(System.out);\n		MScanner sc = new MScanner(System.in);\n		int n=N=sc.nextInt(),m=sc.nextInt();\n		\n		p = new int[numSets = N];\n		rank = new int[N];\n		setSize = new int[N];\n		for (int i = 0; i < N; i++) {  p[i] = i; setSize[i] = 1; }\n		int[][]edges=new int[m][];\n		\n		for(int i=0;i<m;i++) {\n			int x=sc.nextInt()-1,y=sc.nextInt()-1,c=sc.nextInt();\n			edges[i]=new int[] {x,y,c,i};\n		}\n		Arrays.sort(edges,(x,y)->x[2]-y[2]);\n		ans=new int[m];\n		Arrays.fill(ans, -1);\n		int i=0;\n		while(i<m) {\n			int tmpi=i;\n			HashMap<Integer, Integer>map=new HashMap<>();\n			mapEdges=new TreeMap<int[],Integer>((x,y)->x[0]==y[0]?x[1]-y[1]:x[0]-y[0]);\n			int c=0;\n			while(tmpi<m && edges[tmpi][2]==edges[i][2]) {\n				int x=edges[tmpi][0],y=edges[tmpi][1];\n				if(isSameSet(x, y)) {\n					ans[edges[tmpi][3]]=0;\n					tmpi++;\n					continue;\n				}\n				if(!map.containsKey(findSet(x))) {\n					map.put(findSet(x), c++);\n				}\n				if(!map.containsKey(findSet(y))) {\n					map.put(findSet(y), c++);\n				}\n				tmpi++;\n			}\n			tmpi=i;\n			adjList=new ArrayList[V=c];\n			for(int j=0;j<c;j++)adjList[j]=new ArrayList<>();\n			\n			while(i<m && edges[tmpi][2]==edges[i][2]) {\n				int x=edges[i][0],y=edges[i][1];\n				if(isSameSet(x, y)) {\n					i++;\n					continue;\n					\n				}\n				int nodex=map.get(findSet(x)),nodey=map.get(findSet(y));\n				adjList[nodex].add(nodey);\n				adjList[nodey].add(nodex);\n				mapEdges.put(new int[] {nodex,nodey}, edges[i][3]);\n				mapEdges.put(new int[] {nodey,nodex}, edges[i][3]);\n				i++;\n			}\n			findArtPointsAndBridges();\n			while(tmpi<i) {\n				unionSet(edges[tmpi][0], edges[tmpi][1]);\n				if(ans[edges[tmpi][3]]==-1) {\n					ans[edges[tmpi][3]]=1;\n				}\n				tmpi++;\n			}\n			if(numSets==1)break;\n		}\n		while(i<m) {\n			ans[edges[i][3]]=0;\n			i++;\n		}\n		String[]print=new String[] {""none"",""at least one"",""any""};\n		for(int j:ans)pw.println(print[j]);\n		pw.flush();\n	}\n	static class MScanner {\n		StringTokenizer st;\n		BufferedReader br;\n		public MScanner(InputStream system) {\n			br = new BufferedReader(new InputStreamReader(system));\n		}\n \n		public MScanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n \n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n		public int[] intArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public long[] longArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public int[] intSortedArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		public long[] longSortedArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		static void shuffle(int[]in) {\n			for(int i=0;i<in.length;i++) {\n				int idx=(int)(Math.random()*in.length);\n				int tmp=in[i];\n				in[i]=in[idx];\n				in[idx]=tmp;\n			}\n		}\n		static void shuffle(long[]in) {\n			for(int i=0;i<in.length;i++) {\n				int idx=(int)(Math.random()*in.length);\n				long tmp=in[i];\n				in[i]=in[idx];\n				in[idx]=tmp;\n			}\n		}\n		public Integer[] IntegerArr(int n) throws IOException {\n	        Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public Long[] LongArr(int n) throws IOException {\n	        Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n \n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n \n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n \n		public char nextChar() throws IOException {\n			return next().charAt(0);\n		}\n \n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n \n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n \n		public void waitForInput() throws InterruptedException {\n			Thread.sleep(3000);\n		}\n	}\n	static void addX(int[]in,int x) {\n		for(int i=0;i<in.length;i++)in[i]+=x;\n	}\n	static void addX(long[]in,int x) {\n		for(int i=0;i<in.length;i++)in[i]+=x;\n	}\n}","dfs and similar,dsu,graphs,sortings"
"import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic final class edges_in_mst\n{\n    static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n	static FastScanner sc=new FastScanner(br);\n    static PrintWriter out=new PrintWriter(System.out);\n	static Random rnd=new Random();\n	static Node[][] al;\n	static int[] a,b,c,parent,cnt;\n	static int maxn=(int)(1e6+6);\n	static Map<Integer,Integer> m1;\n	static ArrayList<Node>[] al2;\n	static int time;\n	static int[] tin,fup;\n	static boolean[] v;\n	static String[] arr=new String[]{""at least one"",""any"",""none""};\n	\n	static int getParent(int u)\n	{\n		if(u==parent[u])\n		{\n			return u;\n		}\n		else\n		{\n			parent[u]=getParent(parent[u]);return parent[u];\n		}\n	}\n	\n	static void merge(int u,int v)\n	{\n		parent[v]=u;\n	}\n	\n	static void dfs(int u,int p)\n	{\n		tin[u]=fup[u]=++time;v[u]=true;\n		\n		for(Node x:al2[u])\n		{\n			if(x.idx==p) continue;\n			\n			if(v[x.u]) // back edge\n			{\n				fup[u]=Math.min(fup[u],tin[x.u]);\n			}\n			\n			else\n			{\n				dfs(x.u,x.idx);\n				\n				fup[u]=Math.min(fup[u],fup[x.u]);\n			}\n		}\n	}\n	\n	@SuppressWarnings(""unchecked"")\n    public static void main(String args[]) throws Exception\n    {\n		int n=sc.nextInt(),m=sc.nextInt();cnt=new int[maxn];a=new int[m];b=new int[m];c=new int[m];\n		\n		for(int i=0;i<m;i++)\n		{\n			int u=sc.nextInt()-1,v=sc.nextInt()-1,cost=sc.nextInt();\n			\n			cnt[cost]++;\n			\n			a[i]=u;b[i]=v;c[i]=cost;\n		}\n		\n		al=new Node[maxn][];\n		\n		for(int i=0;i<maxn;i++)\n		{\n			al[i]=new Node[cnt[i]];cnt[i]=0;\n		}\n		\n		for(int i=0;i<m;i++)\n		{\n			int u=a[i],v=b[i],cost=c[i];\n			\n			al[cost][cnt[cost]++]=new Node(i,u,v);\n		}\n		\n		parent=new int[n];al2=new ArrayList[n];\n		\n		for(int i=0;i<n;i++)\n		{\n			parent[i]=i;\n			\n			al2[i]=new ArrayList<Node>();\n		}\n		\n		int[] res=new int[m];tin=new int[n];fup=new int[n];v=new boolean[n];\n		\n		for(int i=1;i<maxn;i++)\n		{\n			m1=new HashMap<>();time=0;\n			\n			for(int j=0;j<al[i].length;j++)\n			{\n				int x=getParent(al[i][j].u),y=getParent(al[i][j].v);\n				\n				if(x==y)\n				{\n					res[al[i][j].idx]=2;\n				}\n				else\n				{\n					al2[x].add(new Node(al[i][j].idx,y,-1));al2[y].add(new Node(al[i][j].idx,x,-1));m1.put(x,1);m1.put(y,1);\n				}\n			}\n			\n			for(int x:m1.keySet())\n			{\n				if(!v[x])\n				{\n					dfs(x,-1);\n				}\n			}\n			\n			for(int j=0;j<al[i].length;j++)\n			{\n				if(res[al[i][j].idx]!=2)\n				{\n					int u=getParent(al[i][j].u),v=getParent(al[i][j].v);\n					\n					int p=tin[u]<tin[v]?u:v,c=tin[u]<tin[v]?v:u;\n					\n					res[al[i][j].idx]=fup[c]>tin[p]?1:0;\n				}\n			}\n			\n			for(int x:m1.keySet())\n			{\n				al2[x].clear();tin[x]=fup[x]=0;v[x]=false;\n			}\n			\n			for(int j=0;j<al[i].length;j++)\n			{\n				if(res[al[i][j].idx]!=2)\n				{\n					int x=getParent(al[i][j].u),y=getParent(al[i][j].v);\n					\n					merge(x,y);\n				}\n			}\n		}\n		\n		for(int i=0;i<m;i++)\n		{\n			out.println(arr[res[i]]);\n		}\n		\n		out.close();\n    }\n}\n\nclass Node\n{\n	int idx,u,v;\n	\n	public Node(int idx,int u,int v)\n	{\n		this.idx=idx;this.u=u;this.v=v;\n	}\n}\n\n\nclass FastScanner\n{\n    BufferedReader in;\n    StringTokenizer st;\n\n    public FastScanner(BufferedReader in) {\n        this.in = in;\n    }\n	\n    public String nextToken() throws Exception {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n	\n	public String next() throws Exception {\n		return nextToken().toString();\n	}\n	\n    public int nextInt() throws Exception {\n        return Integer.parseInt(nextToken());\n    }\n\n    public long nextLong() throws Exception {\n        return Long.parseLong(nextToken());\n    }\n\n    public double nextDouble() throws Exception {\n        return Double.parseDouble(nextToken());\n    }\n}","dfs and similar,dsu,graphs,sortings"
"import java.io.*;\nimport java.util.*;\npublic class EdgesInMST {\n	static String[] ans;\n	static ArrayList<Pair>[] adj;\n	static int[] num, low;\n	static boolean[] visited;\n	static int time;\n	public static void bridge(int n)\n	{\n		time=0;\n		num= new int[n];\n		visited = new boolean[n];\n		low = new int[n];\n		for (int i = 0; i < adj.length; i++) {\n			if(!visited[i])\n			{\n				dfs(i, -1);\n			}\n		}\n	}\n	public static void dfs(int vertex, int parentEdge)\n	{\n        visited[vertex] = true; \n		num[vertex]=low[vertex]=time++;\n		for(Pair p: adj[vertex])\n		{\n			if(!visited[p.vertex])\n			{\n				dfs(p.vertex, p.indx);\n				low[vertex]=Math.min(low[vertex], low[p.vertex]);\n				if(num[vertex]<low[p.vertex])\n					ans[p.indx]=""any"";\n			}\n			else if(p.indx!=parentEdge)\n			{\n				low[vertex]=Math.min(low[vertex], num[p.vertex]);\n			}\n			\n		}\n	}\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter pw = new PrintWriter(System.out);\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int n= Integer.parseInt(st.nextToken());\n		int m= Integer.parseInt(st.nextToken());\n		//kruskal's algorithm\n		ArrayList<Edge> arr = new ArrayList<Edge>();\n		for (int i = 0; i < m; i++) {\n			st = new StringTokenizer(br.readLine());\n			int u = Integer.parseInt(st.nextToken())-1;\n			int v= Integer.parseInt(st.nextToken())-1;\n			int w = Integer.parseInt(st.nextToken());\n			arr.add(new Edge(u, v, w,i));\n		}\n		Collections.sort(arr);\n		DSU d = new DSU(n);\n		ans = new String[m];\n		for (int i = 0; i < arr.size(); i++) {\n			int nr=0;\n			HashMap<Integer, Integer> reps= new HashMap<Integer, Integer>();\n			for (int j = i; j < arr.size(); j++) {\n				int repU=d.findSet(arr.get(j).u);\n				int repV=d.findSet(arr.get(j).v);\n				if(repU!=repV)\n				{\n					if(!reps.containsKey(repU))\n					{\n						reps.put(repU, nr++);\n					}\n					if(!reps.containsKey(repV))\n					{\n						reps.put(repV, nr++);\n					}\n				}\n				if(j==arr.size()-1 || arr.get(j).w!=arr.get(j+1).w)break;\n			}\n			adj= new ArrayList[nr];\n			for (int j = 0; j < adj.length; j++) {\n				adj[j]=new ArrayList<EdgesInMST.Pair>();\n			}\n			for (int j = i; j < arr.size(); j++) {\n				int repU=d.findSet(arr.get(j).u);\n				int repV=d.findSet(arr.get(j).v);\n				if(repU==repV)\n				{\n					ans[arr.get(j).indx]=""none"";\n				}\n				else\n				{\n					adj[reps.get(repU)].add(new Pair(arr.get(j).indx, reps.get(repV)));\n					adj[reps.get(repV)].add(new Pair(arr.get(j).indx, reps.get(repU)));\n				}\n				if(j==arr.size()-1 || arr.get(j).w!=arr.get(j+1).w)break;\n			}\n			bridge(nr);\n			for (int j = i; j < arr.size(); j++) {\n				if(!d.isSameSet(arr.get(j).u, arr.get(j).v))\n				{\n					d.union(arr.get(j).u, arr.get(j).v);\n				}\n				if(j==arr.size()-1 || arr.get(j).w!=arr.get(j+1).w){i=j;break;}\n			}\n		}\n		for (int i = 0; i < ans.length; i++) {\n			pw.println(ans[i]==null?""at least one"":ans[i]);\n		}\n		pw.close();\n	}\n	static class Edge implements Comparable<Edge>\n	{\n		int indx, u, v,w;\n		public Edge(int u, int v, int w, int indx)\n		{\n			this.indx=indx; this.u=u; this.v=v; this.w=w;\n		}\n		public int compareTo(Edge e) {\n			return this.w-e.w;\n		}	\n	}\n	static class Pair\n	{\n		int indx,vertex;\n		public Pair(int indx, int vertex)\n		{\n			this.indx=indx;\n			this.vertex=vertex;\n		}	\n	}\n	static class DSU {\n		int[] parent,size;\n		\n		public DSU(int N) {\n			parent = new int[N];\n			size = new int[N];\n			for (int i = 0; i < parent.length; i++) {\n				parent[i]=i;\n				size[i]=1;\n			}\n		}\n		\n		public int findSet(int i)\n		{\n			if(parent[i]==i)return i;\n			return parent[i]=findSet(parent[i]);\n		}\n		\n		public boolean isSameSet(int i, int j)\n		{\n			return findSet(i)==findSet(j);\n		}\n		\n		public int size(int i)\n		{\n			return size[findSet(i)];\n		}\n		\n		public void union(int i, int j)\n		{\n			if(isSameSet(i, j))return;\n			int I = findSet(i);\n			int J = findSet(j);\n			if(size[I]<=size[J])\n			{\n				size[J]+=size[I];\n				parent[I]=parent[J];\n			}\n			else\n			{\n				size[I]+=size[J];\n				parent[J]=parent[I];\n			}\n		}\n	}\n}\n\n	 	  	  	 		  			 	  	   		  	","dfs and similar,dsu,graphs,sortings"
"import java.io.*;\nimport java.util.*;\npublic class EdgesInMST {\n	static String[] ans;\n	static ArrayList<Pair>[] adj;\n	static int[] num, low;\n	static boolean[] visited;\n	static int time;\n	public static void bridge(int n)\n	{\n		time=0;\n		num= new int[n];\n		visited = new boolean[n];\n		low = new int[n];\n		for (int i = 0; i < adj.length; i++) {\n			if(!visited[i])\n			{\n				dfs(i, -1);\n			}\n		}\n	}\n	public static void dfs(int vertex, int parentEdge)\n	{\n        visited[vertex] = true; \n		num[vertex]=low[vertex]=time++;\n		for(Pair p: adj[vertex])\n		{\n			if(!visited[p.vertex])\n			{\n				dfs(p.vertex, p.indx);\n				low[vertex]=Math.min(low[vertex], low[p.vertex]);\n				if(num[vertex]<low[p.vertex])\n					ans[p.indx]=""any"";\n			}\n			else if(p.indx!=parentEdge)\n			{\n				low[vertex]=Math.min(low[vertex], num[p.vertex]);\n			}\n			\n		}\n	}\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter pw = new PrintWriter(System.out);\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int n= Integer.parseInt(st.nextToken());\n		int m= Integer.parseInt(st.nextToken());\n		//kruskal's algorithm\n		ArrayList<Edge> arr = new ArrayList<Edge>();\n		for (int i = 0; i < m; i++) {\n			st = new StringTokenizer(br.readLine());\n			int u = Integer.parseInt(st.nextToken())-1;\n			int v= Integer.parseInt(st.nextToken())-1;\n			int w = Integer.parseInt(st.nextToken());\n			arr.add(new Edge(u, v, w,i));\n		}\n		Collections.sort(arr);\n		DSU d = new DSU(n);\n		ans = new String[m];\n		for (int i = 0; i < arr.size(); i++) {\n			int nr=0;\n			HashMap<Integer, Integer> reps= new HashMap<Integer, Integer>();\n			for (int j = i; j < arr.size(); j++) {\n				int repU=d.findSet(arr.get(j).u);\n				int repV=d.findSet(arr.get(j).v);\n				if(repU!=repV)\n				{\n					if(!reps.containsKey(repU))\n					{\n						reps.put(repU, nr++);\n					}\n					if(!reps.containsKey(repV))\n					{\n						reps.put(repV, nr++);\n					}\n				}\n				if(j==arr.size()-1 || arr.get(j).w!=arr.get(j+1).w)break;\n			}\n			adj= new ArrayList[nr];\n			for (int j = 0; j < adj.length; j++) {\n				adj[j]=new ArrayList<EdgesInMST.Pair>();\n			}\n			for (int j = i; j < arr.size(); j++) {\n				int repU=d.findSet(arr.get(j).u);\n				int repV=d.findSet(arr.get(j).v);\n				if(repU==repV)\n				{\n					ans[arr.get(j).indx]=""none"";\n				}\n				else\n				{\n					adj[reps.get(repU)].add(new Pair(arr.get(j).indx, reps.get(repV)));\n					adj[reps.get(repV)].add(new Pair(arr.get(j).indx, reps.get(repU)));\n				}\n				if(j==arr.size()-1 || arr.get(j).w!=arr.get(j+1).w)break;\n			}\n			bridge(nr);\n			for (int j = i; j < arr.size(); j++) {\n				if(!d.isSameSet(arr.get(j).u, arr.get(j).v))\n				{\n					d.union(arr.get(j).u, arr.get(j).v);\n				}\n				if(j==arr.size()-1 || arr.get(j).w!=arr.get(j+1).w){i=j;break;}\n			}\n		}\n		for (int i = 0; i < ans.length; i++) {\n			pw.println(ans[i]==null?""at least one"":ans[i]);\n		}\n		pw.close();\n	}\n	static class Edge implements Comparable<Edge>\n	{\n		int indx, u, v,w;\n		public Edge(int u, int v, int w, int indx)\n		{\n			this.indx=indx; this.u=u; this.v=v; this.w=w;\n		}\n		public int compareTo(Edge e) {\n			return this.w-e.w;\n		}	\n	}\n	static class Pair\n	{\n		int indx,vertex;\n		public Pair(int indx, int vertex)\n		{\n			this.indx=indx;\n			this.vertex=vertex;\n		}	\n	}\n	static class DSU {\n		int[] parent,size;\n		\n		public DSU(int N) {\n			parent = new int[N];\n			size = new int[N];\n			for (int i = 0; i < parent.length; i++) {\n				parent[i]=i;\n				size[i]=1;\n			}\n		}\n		\n		public int findSet(int i)\n		{\n			if(parent[i]==i)return i;\n			return parent[i]=findSet(parent[i]);\n		}\n		\n		public boolean isSameSet(int i, int j)\n		{\n			return findSet(i)==findSet(j);\n		}\n		\n		public int size(int i)\n		{\n			return size[findSet(i)];\n		}\n		\n		public void union(int i, int j)\n		{\n			if(isSameSet(i, j))return;\n			int I = findSet(i);\n			int J = findSet(j);\n			if(size[I]<=size[J])\n			{\n				size[J]+=size[I];\n				parent[I]=parent[J];\n			}\n			else\n			{\n				size[I]+=size[J];\n				parent[J]=parent[I];\n			}\n		}\n	}\n}\n","dfs and similar,dsu,graphs,sortings"
"\n/**\n * @author egaeus\n * @mail sebegaeusprogram@gmail.com\n * @veredict Accepted\n * @url <https://codeforces.com/problemset/problem/158/D>\n * @category implementation\n * @date 28/10/2019\n **/\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Integer.parseInt;\n\npublic class CF158D {\n    public static void main(String args[]) throws Throwable {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        for (String ln; (ln = in.readLine()) != null; ) {\n            int N = parseInt(ln);\n            int[] arr = new int[N];\n            int max = Integer.MIN_VALUE;\n            int[] sums = new int[N];\n            StringTokenizer st = new StringTokenizer(in.readLine());\n            for (int i = 0; i < N; i++)\n                arr[i] = parseInt(st.nextToken());\n            for (int i = 1; i <= N / 3; i++) {\n                if(N%i==0) {\n                    for (int j = 0; j < N; j++) {\n                        if (j < i) sums[j] = arr[j];\n                        else sums[j] = sums[j - i] + arr[j];\n                        if (j + i >= N) max = Math.max(sums[j], max);\n                    }\n                }\n            }\n            System.out.println(max);\n        }\n    }\n}\n","*special,brute force,number theory"
"import java.util.Scanner;\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int n = s.nextInt();\n        int[] ice = new int[n+1];\n        int defaultSum = 0;\n        for (int i = 1; i <= n; ++i){\n            ice[i] = s.nextInt();\n            defaultSum += ice[i];\n        }\n        int[] skip = new int[n];\n        int pointer = 0;\n        for (int i = 2; i < n; ++i){\n            if (n % i == 0){\n                if (n / i >= 3){\n                    skip[pointer] = i;\n                    pointer++;\n                }\n            }\n        }\n        int[][][] dp = new int[n+1][pointer][2];\n        // [i][j][0] -> the number of skips\n        // [i][j][1] -> the sum of previous\n        int max = Integer.MIN_VALUE;\n        for (int i = 1; i <= n; ++i){\n            for (int sk = 0; sk < pointer; ++sk){\n                if (i-skip[sk] <= 0){\n                   // System.out.println(i+"" - ""+skip[sk]);\n                   dp[i][sk][0] = 1;\n                   dp[i][sk][1] = ice[i];\n                }else{\n                   dp[i][sk][0] = 1+dp[i-skip[sk]][sk][0];\n                   dp[i][sk][1] = ice[i]+dp[i-skip[sk]][sk][1];\n                   if (n / skip[sk] == dp[i][sk][0]){\n                       max = Math.max(max, dp[i][sk][1]);\n                   }\n                }\n            }\n        }\n        System.out.println(Math.max(defaultSum, max));\n\n    }\n}","*special,brute force,number theory"
"import java.util.*;\nimport java.io.*;\n\npublic class IceSculptures {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = """";\n\n    void solve() throws IOException {\n        int n= ni();\n        int[] arr= new int[n];\n        for (int i = 0; i < n; i++)\n            arr[i]= ni();\n\n        int ans= Integer.MIN_VALUE;\n        for(int i=1;i<=n/3;i++)\n        {\n            if(n%i!= 0) continue;\n            for(int j=1;j<=i+1;j++)\n            {\n                int val= 0;\n                for(int k=j;k<j+n;k+=i)\n                    val+= arr[k%n];\n\n                ans= Math.max(ans, val);\n            }\n        }\n\n        out.println(ans);\n    }\n\n    void run() throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n\n        solve();\n        out.flush();\n    }\n\n    public static void main(String[] args) throws Exception {\n        new IceSculptures().run();\n    }\n\n    private byte[] inbuf = new byte[1024];\n    public int lenbuf = 0, ptrbuf = 0;\n\n    private int readByte() {\n        if (lenbuf == -1) throw new InputMismatchException();\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {\n                lenbuf = is.read(inbuf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (lenbuf <= 0) return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private boolean isSpaceChar(int c) {\n        return !(c >= 33 && c <= 126);\n    }\n\n    private int skip() {\n        int b;\n        while ((b = readByte()) != -1 && isSpaceChar(b)) ;\n        return b;\n    }\n\n    private double nd() {\n        return Double.parseDouble(ns());\n    }\n\n    private char nc() {\n        return (char) skip();\n    }\n\n    private String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b))) {\n            buf[p++] = (char) b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    private char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for (int i = 0; i < n; i++) map[i] = ns(m);\n        return map;\n    }\n\n    private int[] na(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = ni();\n        return a;\n    }\n\n    private int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    private long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    private void tr(Object... o) {\n        if (INPUT.length() > 0) System.out.println(Arrays.deepToString(o));\n    }\n}\n\n","*special,brute force,number theory"
"import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class Main{\n	static int mod = (int)(1e9+7);\n	public static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));\n	public static void main(String sp[])throws IOException{\n		//Scanner sc = new Scanner(System.in);\n		FastReader sc = new FastReader();\n		int n = sc.nextInt();\n		long arr[] = new long[n+1];\n		for(int i=1;i<=n;i++)\n			arr[i] = sc.nextLong();\n		ArrayList<Long> al = new ArrayList<>();\n		long sqrt = (long)Math.sqrt(n);\n		for(long i=1;i<=sqrt;i++){\n			if(n%i==0){\n				if(n/i==i){\n					al.add(i);\n				}else{\n					al.add(i);\n					al.add((long)(n/i));\n				}\n			}\n		}\n		Collections.sort(al);\n		int len = al.size();\n		long total = Long.MIN_VALUE;\n		for(int i=0;i<len;i++){\n			long val = al.get(i);\n			for(int k=1;k<=val;k++){\n				int o =0 ;\n				long temp = 0;\n				for(int j=k;j<=n;){\n					temp+=arr[j];\n					o++;\n					j+=(val);\n				}\n				if(temp>total && o>=3){\n					total = temp;\n				}\n			}\n		}\n		System.out.println(total);\n	}\n	\n	public static boolean prime(int n){\n		int sq = (int)Math.sqrt(n);\n		for(int i=2;i<=sq;i++){\n			if(n%i==0)\n				return false;\n		}\n		return true;\n	}\n	public static class pair{\n		long bal;\n		long wt;\n		long diff;\n	}\n	\n	public static class comp implements Comparator<pair>{\n		public int compare(pair o1, pair o2){\n			return Long.valueOf(o1.diff).compareTo(Long.valueOf(o2.diff));\n		}\n	}\n		\n	static class FastReader \n		{ \n		final private int BUFFER_SIZE = 1 << 16; \n		private DataInputStream din; \n		private byte[] buffer; \n		private int bufferPointer, bytesRead; \n  \n		public FastReader() \n		{ \n			din = new DataInputStream(System.in); \n			buffer = new byte[BUFFER_SIZE]; \n			bufferPointer = bytesRead = 0; \n		} \n  \n		public FastReader(String file_name) throws IOException \n		{ \n			din = new DataInputStream(new FileInputStream(file_name)); \n			buffer = new byte[BUFFER_SIZE]; \n			bufferPointer = bytesRead = 0; \n		} \n  \n		public String readLine() throws IOException \n		{ \n			byte[] buf = new byte[64]; // line length \n			int cnt = 0, c; \n			while ((c = read()) != -1) \n			{ \n				if (c == '\n') \n					break; \n				buf[cnt++] = (byte) c; \n			} \n			return new String(buf, 0, cnt); \n		} \n  \n		public int nextInt() throws IOException \n		{ \n			int ret = 0; \n			byte c = read(); \n			while (c <= ' ') \n				c = read(); \n			boolean neg = (c == '-'); \n			if (neg) \n				c = read(); \n			do\n			{ \n				ret = ret * 10 + c - '0'; \n			}  while ((c = read()) >= '0' && c <= '9'); \n  \n			if (neg) \n				return -ret; \n			return ret; \n		} \n  \n		public long nextLong() throws IOException \n		{ \n			long ret = 0; \n			byte c = read(); \n			while (c <= ' ') \n				c = read(); \n			boolean neg = (c == '-'); \n			if (neg) \n				c = read(); \n			do { \n				ret = ret * 10 + c - '0'; \n			} \n			while ((c = read()) >= '0' && c <= '9'); \n			if (neg) \n				return -ret; \n			return ret; \n		} \n  \n		public double nextDouble() throws IOException \n		{ \n			double ret = 0, div = 1; \n			byte c = read(); \n			while (c <= ' ') \n				c = read(); \n			boolean neg = (c == '-'); \n			if (neg) \n				c = read(); \n  \n			do { \n				ret = ret * 10 + c - '0'; \n			} \n			while ((c = read()) >= '0' && c <= '9'); \n  \n			if (c == '.') \n			{ \n				while ((c = read()) >= '0' && c <= '9') \n				{ \n					ret += (c - '0') / (div *= 10); \n				} \n			} \n  \n			if (neg) \n				return -ret; \n			return ret; \n		} \n  \n		private void fillBuffer() throws IOException \n		{ \n			bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n			if (bytesRead == -1) \n				buffer[0] = -1; \n		} \n  \n		private byte read() throws IOException \n		{ \n			if (bufferPointer == bytesRead) \n				fillBuffer(); \n			return buffer[bufferPointer++]; \n		} \n  \n		public void close() throws IOException \n		{ \n			if (din == null) \n				return; \n			din.close(); \n		} \n	} \n}\n\n","*special,brute force,number theory"
"import java.io.*;\nimport java.util.*;\npublic class Main\n{\n	\n	private void solve()throws Exception\n	{\n		String s=nextLine();\n		String revs=reverse(s);\n		int n=nextInt();\n		int ans=0;\n		while(n-->0)\n		{\n			String p=nextLine();\n			String rev=reverse(p);\n			int m=p.length();\n			int pref[]=new int[m+1];\n			int suff[]=new int[m+1];\n\n			int z[]=new Z_function(p+""#""+s).z;\n			for(int i=m+2;i<=m+s.length()+1;i++)\n				if(z[i]!=0)\n				{\n					for(int j=z[i];j>0 && pref[j]==0;j--)\n						pref[j]=i-m-1;\n				}\n\n			z=new Z_function(rev+""#""+revs).z;\n			for(int i=m+2;i<=m+s.length()+1;i++)\n				if(z[i]!=0)\n				{\n					for(int j=z[i];j>0 && suff[m-j+1]==0;j--)\n						suff[m-j+1]=s.length()-(i+j-1-m-1)+1;\n				}\n\n\n			for(int i=2;i<=m;i++)\n				if(pref[i-1]>0 && suff[i]>0 && pref[i-1]+i-2<suff[i])\n				{\n					ans++;\n					break;\n				}\n		}	\n		out.println(ans);\n	}\n	String reverse(String s)\n	{\n		StringBuilder sb=new StringBuilder();\n		for(int i=s.length()-1;i>=0;i--)\n			sb.append(s.charAt(i));\n		return sb.toString();\n	}\n	class Z_function\n	{\n		int z[],n;\n		String s;\n		Z_function(String s)\n		{\n			this.s="" ""+s;\n			n=s.length();\n			z=new int[n+1];\n			build();\n		}\n		void build()\n		{\n			for(int i=2,l=0,r=0;i<=n;i++)\n			{\n				if(i<=r)\n					z[i]=Math.min(r-i+1,z[i-l+1]);\n				while(i+z[i]<=n && s.charAt(i+z[i])==s.charAt(z[i]+1))\n					z[i]++;\n				if(z[i]>0 && i+z[i]-1>r)\n				{\n					l=i;\n					r=i+z[i]-1;\n				}\n			}\n		}\n	}\n\n	 \n	///////////////////////////////////////////////////////////\n\n	public void run()throws Exception\n	{\n		br=new BufferedReader(new InputStreamReader(System.in));\n		st=null;\n		out=new PrintWriter(System.out);\n\n		solve();\n		\n		br.close();\n		out.close();\n	}\n	public static void main(String args[])throws Exception{\n		new Main().run();\n	}\n	BufferedReader br;\n	StringTokenizer st;\n	PrintWriter out;\n	String nextToken()throws Exception{\n		while(st==null || !st.hasMoreTokens())\n		st=new StringTokenizer(br.readLine());\n		return st.nextToken();\n	}\n	String nextLine()throws Exception{\n		return br.readLine();\n	}\n	int nextInt()throws Exception{\n		return Integer.parseInt(nextToken());\n	}\n	long nextLong()throws Exception{\n		return Long.parseLong(nextToken());\n	}\n	double nextDouble()throws Exception{\n		return Double.parseDouble(nextToken());\n	}\n}","string suffix structures,strings"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF149E extends PrintWriter {\n	CF149E() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF149E o = new CF149E(); o.main(); o.flush();\n	}\n\n	void reverse(byte[] aa, int n) {\n		for (int i = 0, j = n - 1; i < j; i++, j--) {\n			byte tmp = aa[i]; aa[i] = aa[j]; aa[j] = tmp;\n		}\n	}\n	void prepare(byte[] aa, int n, byte[] bb, int m, int[] ff, int[] pp) {\n		ff[0] = -1;\n		for (int i = 0, j = 1; j < m; i++, j++) {\n			while (bb[i] != bb[j]) {\n				if (i == 0) {\n					i = -1;\n					break;\n				}\n				i = ff[i - 1] + 1;\n			}\n			ff[j] = i;\n		}\n		for (int i = 0, j = 0; i < n; i++, j++) {\n			while (j == m || aa[i] != bb[j]) {\n				if (j == 0) {\n					j = -1;\n					break;\n				}\n				j = ff[j - 1] + 1;\n			}\n			pp[i] = j + 1;\n		}\n		for (int i = 1; i < n; i++)\n			pp[i] = Math.max(pp[i], pp[i - 1]);\n	}\n	boolean check(byte[] aa, int n, byte[] bb, int m) {\n		int[] ff = new int[m];\n		int[] pp = new int[n];\n		prepare(aa, n, bb, m, ff, pp);\n		int[] qq = new int[n];\n		reverse(aa, n);\n		reverse(bb, m);\n		prepare(aa, n, bb, m, ff, qq);\n		reverse(aa, n);\n		if (pp[n - 1] == m || qq[n - 1] == m)\n			return true;\n		for (int i = 0; i + 1 < n; i++)\n			if (pp[i] + qq[n - 1 - (i + 1)] >= m)\n				return true;\n		return false;\n	}\n	void main() {\n		byte[] aa = sc.next().getBytes();\n		int n = aa.length;\n		int q = sc.nextInt();\n		int cnt = 0;\n		while (q-- > 0) {\n			byte[] bb = sc.next().getBytes();\n			int m = bb.length;\n			if (m > 1 && check(aa, n, bb, m))\n				cnt++;\n		}\n		println(cnt);\n	}\n}\n","string suffix structures,strings"
"import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    static int[] prefFunc(String s) {\n        int pref[] = new int[s.length()];\n        pref[0] = 0;\n        int j = 0;\n        for(int i = 1; i < s.length(); ++i) {\n            while (j > 0 && s.charAt(i) != s.charAt(j))\n                j = pref[j-1];\n            if (s.charAt(i) == s.charAt(j))\n                ++j;\n            pref[i] = j;\n        }\n        return pref;\n    }\n\n    static String reverse(String s) {\n        return new StringBuilder(s).reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        String s = in.next();\n        int q = in.nextInt(), ans = 0;\n        for(int iq = 0; iq < q; ++iq) {\n            String t = in.next();\n            int pL[] = prefFunc(t+""#""+s);\n            int pR[] = prefFunc(reverse(t)+""#""+reverse(s));\n\n            int fL[] = new int[s.length()];\n            for(int i = 0; i < s.length(); ++i) {\n                fL[i] = pL[i+t.length()+1];\n                if (i > 0)\n                    fL[i] = Math.max(fL[i-1], fL[i]);\n            }\n\n            int fR[] = new int[s.length()];\n            for(int i = s.length()-1; i >= 0; --i) {\n                fR[i] = pR[s.length()-i+t.length()];\n                if (i < s.length()-1)\n                    fR[i] = Math.max(fR[i+1], fR[i]);\n            }\n\n//            for(int i = 0; i < s.length(); ++i)\n//                out.printf(""%d %d\n"", fL[i], fR[i]);\n\n            boolean found = (fL[s.length()-1] == t.length());\n            for(int i = 0; i < s.length()-1; ++i)\n                if (fL[i]+fR[i+1] >= t.length())\n                    found = true;\n            if (t.length() > 1 && found)\n                ++ans;\n        }\n        out.println(ans);\n        out.close();\n    }\n}\n","string suffix structures,strings"
"import java.io.*;\nimport java.util.*;\n\npublic class E\n{\n    public static void main(String[] args) throws IOException\n    {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter writer = new PrintWriter(new OutputStreamWriter(System.out));\n\n        String str = reader.readLine();\n        String rStr = new StringBuilder(str).reverse().toString();\n        int n = str.length();\n        int wc = Integer.parseInt(reader.readLine());\n\n        int [] z, rz, max = new int[n+1];\n        int res = 0;\n        for(int i = 0 ; i < wc ; i++)\n        {\n            String word = reader.readLine();\n            if(word.length() == 1)\n                continue;\n            z = zFunction(word, str);\n            rz = zFunction(new StringBuilder(word).reverse().toString(), rStr);\n            for(int k = 0 ; k < n/2 ; k++)\n            {\n                int t = rz[k];\n                rz[k] = rz[n-k-1];\n                rz[n-k-1] = t;\n            }\n            for(int k = n-1 ; k >= 0 ; k--)\n                max[k] = Math.max(max[k+1], rz[k]);\n\n            for(int k = 0 ; k < n ; k++)\n            {\n                if(k + word.length() - 1 < n && z[k] + max[k+word.length()-1] >= word.length() && z[k] > 0 && max[k+word.length()-1] > 0)\n                {\n                    res++;\n                    break;\n                }\n            }\n        }\n\n        System.out.println(res);\n\n\n\n    }\n\n    private static int[] zFunction(String a, String b)\n    {\n        String _str = a+""$""+b;\n        char [] s = _str.toCharArray();\n        int n = s.length;\n        int [] _z = new int[n];\n\n\n        int L = 0, R = 0;\n        for (int i = 1; i < n; i++)\n        {\n            if (i > R)\n            {\n                L = R = i;\n                while (R < n && s[R-L] == s[R])\n                    R++;\n                _z[i] = R-L;\n                R--;\n            }\n            else\n            {\n                int k = i-L;\n                if (_z[k] < R-i+1)\n                    _z[i] = _z[k];\n                else\n                {\n                    L = i;\n                    while (R < n && s[R-L] == s[R])\n                        R++;\n                    _z[i] = R-L;\n                    R--;\n                }\n            }\n        }\n\n        int [] z = new int[b.length()];\n        for(int i = 0 ; i < z.length ; i++)\n            z[i] = _z[i+a.length()+1];\n\n        return z;\n    }\n}","string suffix structures,strings"
