"fun main() {    repeat(readLine()!!.toInt()) {        val s = readLine()!!        var answer = s.endsWith(""B"")        var delta = 0        for (letter in s) {            when (letter) {                'A' -> delta++                'B' -> delta--            }            if (delta < 0) {                answer = false            }        }        println(if (answer) ""yEs"" else ""nO"")    }}","constructive algorithms,implementation"
"fun main() {    repeat(readLine()!!.toInt()) {        val s = readLine()!!        if (s.last() == 'A') {            println(""NO"")            return@repeat        }        var countA = 0        var countB = 0        for (c in s) {            if (c == 'A') {                countA++            } else {                countB++            }            if (countA < countB) {                println(""NO"")                return@repeat            }        }        println(""YES"")    }}","constructive algorithms,implementation"
"import java.io.BufferedReader fun main() {    val br = System.`in`.bufferedReader()    val bw = System.out.bufferedWriter()    val t = br.readInt()    repeat(t) {        var aCt = 0        var bCt = 0        var good = true        val s = br.readLine()        for (c in s) {            if (c == 'A') {                aCt++            } else if (bCt == aCt) {                good = false            } else {                bCt++            }        }        if(s.last() == 'A') good = false        if(good) {            bw.appendLine(""YES"")        } else {            bw.appendLine(""NO"")        }    }    bw.flush()} private const val SPACE_INT = ' '.toInt()private const val ZERO_INT = '0'.toInt()private const val NL_INT = '\n'.toInt() private fun BufferedReader.readInt(): Int {    var ret = read()    while (ret <= SPACE_INT) {        ret = read()    }    val neg = ret == '-'.toInt()    if (neg) {        ret = read()    }    ret -= ZERO_INT    var read = read()    while (read >= ZERO_INT) {        ret *= 10        ret += read - ZERO_INT        read = read()    }     while (read <= SPACE_INT && read != -1 && read != NL_INT) {        mark(1)        read = read()    }    if (read > SPACE_INT) {        reset()    }    return if (neg) -ret else ret}","constructive algorithms,implementation"
"import java.io.*import java.util.* private var out = PrintWriter(BufferedOutputStream(System.out))private var sc = FastReader()var posInf = Int.MAX_VALUEvar negInf = Int.MIN_VALUE fun main() {    var test = 1    test = sc.nextInt()    for (i in 1..test) {//            fw.print(""Case #""+i+"": "")        out.println(if (solve()) ""YES"" else ""NO"")    }    out.flush()    out.close()} fun solve(): Boolean {    val s = sc.next()    /*    * the bound:    * len(s) > 1    * s doesn't end with A    * for each existing B, there need at least an A before it    * (s doesn't start with B)    * ??    * */    if (s.length == 1) return false    if (s[s.length - 1] == 'A') return false    var curAs = 0    for (i in s.indices) {        if (s[i] == 'A') curAs++        else curAs--        if (curAs < 0) return false    }    return true} //==================================== End of Solver ==================================  //================================== Library Functions ================================ class FastReader {    private var br: BufferedReader = BufferedReader(InputStreamReader(System.`in`))    private var st: StringTokenizer? = null     operator fun next(): String {        while (st == null || !st!!.hasMoreElements()) {            try {                st = StringTokenizer(br.readLine())            } catch (e: IOException) {                e.printStackTrace()            }        }        return st!!.nextToken()    }     fun nextInt(): Int {        return next().toInt()    }     private fun nextLong(): Long {        return next().toLong()    }     fun nextDouble(): Double {        return next().toDouble()    }     fun nextLine(): String {        var str = """"        try {            str = br.readLine()        } catch (e: IOException) {            e.printStackTrace()        }        return str    }     fun readInts(n: Int): IntArray {        val a = IntArray(n)        for (i in 0 until n) {            a[i] = nextInt()        }        return a    }     fun read2dInts(r: Int, c: Int): Array<IntArray> {        val a = Array(r) { IntArray(c) }        for (i in 0 until r) {            for (j in 0 until c) {                a[i][j] = nextInt()            }        }        return a    }     fun readLongs(n: Int): LongArray {        val a = LongArray(n)        for (i in 0 until n) {            a[i] = nextLong()        }        return a    }} fun sort(a: IntArray) {    val ls = ArrayList<Int>()    for (x in a) ls.add(x)    ls.sort()    for (i in a.indices) a[i] = ls[i]} fun sort(a: LongArray) {    val ls = ArrayList<Long>()    for (x in a) ls.add(x)    ls.sort()    for (i in a.indices) a[i] = ls[i]}","constructive algorithms,implementation"
"import java.util.*import kotlin.math.*  fun main(args: Array<String>) {     val number = readLine()!!.toInt()     for(i in 0 until number){      val str = readLine()!!.split("" "")     val m = str[0].toInt()     val n = str[1].toInt()     if(n == 1){         if(m > 2) {             println(""-1"")         }else{             println(m-1)         }         continue     }else if(m == 1){         if(n > 2) {             println(""-1"")         }else{             println(n-1)         }         continue     }        var result = (min(n,m)-1)*2 + (max(n,m)-min(n,m)-1)*2        if((max(n,m)-min(n,m)) % 2 == 0){            result+=2        }else{            result++        }        println(result)     }}","implementation,math"
"import java.util.*import java.io.*import java.math.* fun main(args : Array<String>) {    repeat(readInt()) {        val (n,m) = readLongs()        val a = minOf(n,m)        val b = maxOf(n,m)        val res = if (a == 1L) {            when (b) {                1L -> 0                2L -> 1                else -> -1            }        } else {            val c = (b - a) % 2            (a-1) * 2 + ((b-a) / 2) * 4 + c        }        println(res)    }}private val inp = System.`in`.bufferedReader()//private val inp = File(""e.in"").reader().buffered()private fun readLn() = inp.readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "").filter { !it.isBlank() }private fun readLongs() = readStrings().map { it.toLong() }private fun readInts() = readStrings().map { it.toInt() }","implementation,math"
"import java.io.*import java.util.*import kotlin.math.* val INPUT = System.`in`!!val OUTPUT = System.out!!val reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun line() = reader.readLine()!!var st: StringTokenizer = StringTokenizer("""")fun read(): String {    while (st.hasMoreTokens().not())        st = StringTokenizer(reader.readLine() ?: return """", "" "")    return st.nextToken()}fun int() = read().toInt()fun ints(n: Int) = List(n) { read().toInt() }fun intArray(n: Int) = IntArray(n) { read().toInt() }val writer = PrintWriter(OUTPUT, false)fun main() { writer.solve(); writer.flush() }fun PrintWriter.solve() {    var tt = 1    tt = int()    while (tt-- > 0) {        val (n, m) = ints(2)        if(n == 1) {            if(m <= 2) {                println(m - 1)            }            else println(-1)        }        else if(m == 1) {            if(n <= 2) {                println(n - 1)            }            else println(-1)        }        else {            val x = abs(n - m)            println(n + m - 2 + if(x % 2 == 0) x else x - 1)        }    }}","implementation,math"
"fun readStr() = readLine()!!fun readInt() = readLine()!!.toInt()fun readLong() = readLine()!!.toLong()fun readIntPair() = readLine()!!.split("" "").let { it[0].toInt() to it[1].toInt() }fun readIntList() = readLine()!!.split("" "").map { it.toInt() }fun readLongList() = readLine()!!.split("" "").map { it.toLong() }fun readIntArr() = readIntList().toIntArray()fun readDoubleList() = readLine()!!.split("" "").map { it.toDouble() }fun Boolean.toAns() = if (this) ""yes"" else ""no""fun StringBuilder.prl(x: Any) = appendLine(x)fun StringBuilder.pr(x: Any) = append(x) fun go(read: Boolean = true, ansBuilder: StringBuilder.() -> Unit) {    val sb = StringBuilder()    val t = if (read) readInt() else 1    repeat(t) { sb.ansBuilder() }    println(sb.toString())} fun main() = go {    val (n, m) = readIntPair()    if (n == 1) {        if (m <= 2) {            prl(m - 1)        } else {            prl(-1)        }    } else if (m == 1) {        if (n <= 2) {            prl(n - 1)        } else {            prl(-1)        }    } else {        if (m < n) {            val ans = 2*(m - 1) + 3 *((n - m) / 2) + (n - m - (n - m)/2)            prl(ans)        } else {            val ans = 2*(n - 1) + 3 * ((m - n) / 2) + (m - n - (m - n) / 2)            prl(ans)        }    }} /** * 1 1 1 1 * 1 1 1 1 * * * * 1 1 * 2 4 * 3 5 * 4 8 */  ","implementation,math"
"// 2022-04-13, Wed, 16:14import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.system.measureTimeMillisimport java.util.TreeMapimport java.util.TreeSet inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        val S = fakein.toString()        println(""New Case "")        println(S.take(80))        println(""..."")        fakein.clear()        IN = BufferedInputStream(S.byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} val getintfast:Int get() = IO.nextInt()val getint:Int get(){ val ans = getlong ; if(ans > Int.MAX_VALUE) IntArray(1000000000); return ans.toInt() }val getlong:Long get() = IO.nextLong()val getstr:String get() = IO.nextString()fun getline(n:Int):IntArray{    return IntArray(n){getint}}fun getlineL(n:Int):LongArray{    return LongArray(n){getlong}}fun getbinary(n:Int, asTrue:Char):BooleanArray{    val str = getstr    return BooleanArray(n){str[it] == asTrue}} val List<Char>.ret:Stringget() = this.joinToString("""")var dmark = -1infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    dmark++    var str = ""<${dmark}>   ""    debug()    if(this is String){ str += this    }else if(this is Int){ str += this.toString()    }else if(this is Long){ str += this.toString()    }else{ str += this.toString()}    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is BooleanArray){ println(""$str :${a.map{if(it)'1' else '0'}.joinToString("" "")}"")    }else if(a is Array<*>){        println(""$str : "")        for(c in a){if(c is IntArray){println(c.joinToString("" ""))}        else if(c is LongArray){println(c.joinToString("" ""))}        else if(c is BooleanArray){println(c.map { if(it) '1' else '0' }.joinToString(""""))        }         }        println()    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){    throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){        throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    fun cases(onecase:()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint} else if(mode == solveMode.tc){1 } else randCount        //safety checks        if(pI != 998_244_353 && pI != 1_000_000_007){            throw Exception(""Modding a wrong prime!"")        }        if(withBruteForce){            println(""Brute force is active"")        }         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            onecase()        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }}inline fun<T> T.alsoBrute(cal:() -> T){    if(!withBruteForce) return    val also = cal()    if(this != also){        println(""Checking failed: Got ${this} Brute ${also}"")        crash()    }}// 1. Moddedconst val p = 998244353Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}infix fun Int.modM(b:Int):Int{ return ((this.toLong() * b) % pI).toInt() }infix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }fun intPow(x:Int,e:Int,m:Int):Int{    var X = x ; var E =e ; var Y = 1    while(E > 0){        if(E and 1 == 0){            X = ((1L * X * X) % m).toInt()            E = E shr 1        }else{            Y = ((1L * X * Y) % m).toInt()            E -= 1        }    }    return Y}// 2. DP initial valuesconst val plarge = 998244353Lconst val nlarge = -plargeconst val phuge = 2_727_000_000_000_000_000Lconst val nhuge = -phuge// 3. conveniecen conversionsval Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionval Char.code :Int get() = this.toInt() -  'a'.toInt()//3. hard to write stufffun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val mint:MutableList<Int> get() = mutableListOf<Int>()val mong:MutableList<Long> get() = mutableListOf<Long>()//4. more outputsfun List<Char>.conca():String = this.joinToString("""")val CharArray.conca :String get() = this.joinToString("""")val IntArray.conca :String get() = this.joinToString("" "")@JvmName(""concaInt"")fun List<Int>.conca():String = this.joinToString("" "")val LongArray.conca:String get() = this.joinToString("" "")@JvmName(""concaLong"")fun List<Long>.conca():String = this.joinToString("" "")//5. Pair of intsconst val longmask = (1L shl 32) - 1fun makepair(a:Int, b:Int):Long = (a.toLong() shl 32) xor (longmask and b.toLong()) // remember positev sonlyval Long.first get() = (this ushr 32).toInt()val Long.second get() = this.toInt()//6. stringsval String.size get() = this.lengthconst val randCount = 100//7. bitsfun Int.has(i:Int):Boolean = (this and (1 shl i) != 0)    infix fun Int.divceil(b:Int):Int{    //Positives numbers only!    if(this == 0) {        return 0    }    return (this-1)/b + 1}infix fun Long.divceil(b:Long):Long{    //Positives numbers only!    if(this == 0L) {        return 0    }    return (this-1)/b + 1} infix fun Long.modM(b:Long):Long{    return (this * b) % p}//infix fun Int.modPlus(b:Int):Int{//    val ans = this + b//    return if(ans >= pI) ans - pI else ans//}infix fun Int.modMinus(b:Int):Int{    val ans = this - b    return if(ans < 0) ans + pI else ans}infix fun Int.modDivide(b:Int):Int{    return this modM (b.inverse())}fun Int.additiveInverse():Int{    return if(this == 0) 0 else pI - this} fun intPowEXP(x:Int,e:Long,m:Int):Int{    var X = x    var E =e    var Y = 1    while(E > 0){        if(E % 2 == 0L){            X = ((1L * X * X) % m).toInt()            E = E shr 1        }else{            Y = ((1L * X * Y) % m).toInt()            E -= 1        }    }    return Y} fun pow(x:Long,e:Long,m:Long):Long{    var X = x    var E =e    var Y = 1L    while(E > 0){        if(E % 2 == 0L){            X = (X * X) % m            E /= 2        }else{            Y = (X * Y) % m            E -= 1        }    }    return Y}fun Long.inverse():Long{    return pow(this,p-2,p)}fun Int.inverse():Int{    return intPow(this,pI-2,pI)}fun min_rem(m:Int, r:Int, c:Int):Int {    if(c < 1){        return Int.MIN_VALUE    }else if(r == 0){        return 0    }else{        val step = m % r        val mx = ((1L * c * r) /m ).toInt()        val t = max_rem(r,step,mx)        return r- t    }}fun max_rem(m:Int, r:Int, c:Int):Int {    if(r == 0|| c <= m/r){        return r * c    }else{        val step =  m % r        val mx = ((1L * (c+1) * r )/m).toInt()        val t = min_rem(r,step,mx)        return  m - t    }}fun Int.reconstruct():String{    val num = min_rem(pI,this, 10000)    val denom = (this modDivide num).inverse()    return ""$num / $denom""} //make this int insteadclass FACT{    companion object {        var store = IntArray(0)        var invStore = IntArray(0)         var slowStore:IntArray = IntArray(0)         fun preCal(upto:Int){            store = IntArray(upto+1)            invStore = IntArray(upto + 1 )            store[0] = 1            invStore[0] = 1             for(i in 1..upto) {                store[i] = store[i-1] modM i                invStore[i] = invStore[i-1] modM (i.inverse())            }        }        fun choose(n:Int,r:Int):Int{            if(r < 0 || r > n) return 0            val a = store[n]            val b = invStore[n-r]            val c = invStore[r]            return (a modM b) modM c        }         fun bigChoose(n:Int,r:Int):Int{            var ret = 1            for(i in 0 until r){                ret = ret modM (n - i)            }            ret = ret modM (invStore[r])            return ret        }     }} fun debug(){}const val withBruteForce = falseconst val singleCase = falsefun main(){    FACT.preCal(5003)     solve.cases{        val n = getint        val L = getline(n)//        val halfn = n /2        L.shuffle()        L.sort()         val below = IntArray(n)         for(i in 0 until n){            if(i == 0 || L[i] != L[i-1]){                below[i] = i            }else{                below[i] = below[i-1]             }        }        val counts = IntArray(n+3)        for(a in L){            counts[a] ++        }        var prod = 1        for(i in counts.indices){            if(counts[i] != 0){                prod = prod modM FACT.store[counts[i]]            }        }         val lastdifferent = IntArray(n){-1}        for(i in 1 until n){            if(L[i] != L[i-1]){                lastdifferent[i] = i-1             }else{                lastdifferent[i] = lastdifferent[i-1]            }        }         val have = Array(n + 1 ){IntArray(n+1)}        have[0][0] = 1        for(p in 0 until n){            val key = (p == 0 || (p >= 3 && p %2 == 1 ))            if(!key){                for(lead in 1..n){                    have[p+1][lead] = have[p][lead] modM (below[lead-1] - (p -1))                }            }else{                val prefixsum = IntArray(n+1)                for(lead in 0 until n) {                    prefixsum[lead] = have[p][lead] modPlus (if(lead > 0) prefixsum[lead-1] else 0)                }                for(lead in 1..n){                    val upto = lastdifferent[lead-1]                    have[p+1][lead] = prefixsum[upto + 1]                }            }        }        put(have.last().last() modDivide prod)        }    done()}/* n m   3 46 7 */   ","combinatorics,dp,implementation"
"fun readStr() = readLine()!!fun readInt() = readLine()!!.toInt()fun readLong() = readLine()!!.toLong()fun readIntPair() = readLine()!!.split("" "").let { it[0].toInt() to it[1].toInt() }fun readIntList() = readLine()!!.split("" "").map { it.toInt() }fun readLongList() = readLine()!!.split("" "").map { it.toLong() }fun readIntArr() = readIntList().toIntArray()fun readDoubleList() = readLine()!!.split("" "").map { it.toDouble() }fun Boolean.toAns() = if (this) ""yes"" else ""no"" fun go(ansBuilder: StringBuilder.() -> Unit) {    val sb = StringBuilder()    val t = readInt()    repeat(t) { sb.ansBuilder() }    println(sb.toString())} fun main() = go {    val n = readInt()    val s = readStr()    val diff = Array(n) { IntArray(n) }    val repl = Array(n) { IntArray(n) }    for (i in 0 until n) {        var repls = 0        var minusesInRow = 0        var d = 0        for (j in i until n) {            if (s[j] == '-') {                minusesInRow++                d++            }            else {                d--                repls += minusesInRow / 2                minusesInRow = 0            }            diff[i][j] = d            repl[i][j] = repls + minusesInRow / 2        }        repls += minusesInRow / 2    }    var cnt = 0    for (i in 0 until n) {        for (j in i until n) {            if (0 <= diff[i][j] && diff[i][j] <= 3 * repl[i][j] && diff[i][j] % 3 == 0) cnt++        }    }    appendLine(cnt)}    ","brute force,implementation,math,strings"
"import java.io.PrintWriterimport java.util.StringTokenizerimport kotlin.math.powimport kotlin.math.sqrt //private val INPUT = File(""input.txt"").inputStream()//private val OUTPUT = File(""output.txt"").outputStream()private val INPUT = System.`in`private val OUTPUT = System.out private val bufferedReader = INPUT.bufferedReader()private val outputWriter = PrintWriter(OUTPUT, false)private fun readLn() = bufferedReader.readLine()!! private fun readList() = readLn().split(' ')private var tokenizer = StringTokenizer("""")private fun read(): String {    while (tokenizer.hasMoreTokens().not()) tokenizer = StringTokenizer(readLn(), "" "")    return tokenizer.nextToken()} private fun readInt() = read().toInt()private fun readLong() = read().toLong()private fun readDouble() = read().toDouble() private fun readIntList() = readList().map { it.toInt() }private fun readLongList() = readList().map { it.toLong() }private fun readDoubleList() = readList().map { it.toDouble() } private fun readIntArray(n: Int = 0) =    if (n == 0) readList().run { IntArray(size) { get(it).toInt() } } else IntArray(n) { readInt() } private fun readLongArray(n: Int = 0) =    if (n == 0) readList().run { LongArray(size) { get(it).toLong() } } else LongArray(n) { readLong() } private fun readDoubleArray(n: Int = 0) =    if (n == 0) readList().run { DoubleArray(size) { get(it).toDouble() } } else DoubleArray(n) { readDouble() }  private fun Int.modPositive(other: Int): Int = if (this % other < 0) ((this % other) + other) else (this % other)  private class Main {    fun solveTestCase(): Int {        val n = readInt()        val s = readLn()        val v = s.map {if (it=='-') 1 else -1}            .scan(0, Int::plus).drop(1).toIntArray()        var cnt=0        for (i in 0..n-1)            for (j in i+1..n-1) {                var x = v[j];                if (i>0) x-=v[i-1]                if (x>=0 && x%3==0) ++cnt            }        return cnt    }} fun main(args: Array<String>) {    repeat(readInt()) {        //TODO: Read in each Test Case         outputWriter.println(            Main()                .solveTestCase()        )    }     outputWriter.flush()}","brute force,implementation,math,strings"
"import java.io.PrintWriterimport java.math.BigDecimalimport java.util.StringTokenizerimport java.util.*import kotlin.math.absimport kotlin.math.absoluteValueimport kotlin.math.powimport kotlin.math.sqrt private val INPUT = System.`in`private val OUTPUT = System.out private val bufferedReader = INPUT.bufferedReader()private val outputWriter = PrintWriter(OUTPUT, false)private fun readLn() = bufferedReader.readLine()!! private fun readList() = readLn().split(' ')private var tokenizer = StringTokenizer("""")private fun read(): String {    while (tokenizer.hasMoreTokens().not()) tokenizer = StringTokenizer(readLn(), "" "")    return tokenizer.nextToken()} private fun readInt() = read().toInt()private fun readLong() = read().toLong()private fun readDouble() = read().toDouble() private fun readIntList() = readList().map { it.toInt() }private fun readLongList() = readList().map { it.toLong() }private fun readDoubleList() = readList().map { it.toDouble() } private fun readIntArray(n: Int = 0) =    if (n == 0) readList().run { IntArray(size) { get(it).toInt() } } else IntArray(n) { readInt() } private fun readLongArray(n: Int = 0) =    if (n == 0) readList().run { LongArray(size) { get(it).toLong() } } else LongArray(n) { readLong() } private fun readDoubleArray(n: Int = 0) =    if (n == 0) readList().run { DoubleArray(size) { get(it).toDouble() } } else DoubleArray(n) { readDouble() }  private fun Int.modPositive(other: Int): Int = if (this % other < 0) ((this % other) + other) else (this % other) data class Item(val x:Int, val cnt: Int): Comparable<Item> {    override fun compareTo(other: Item): Int {        return cnt - other.cnt    }} private class Main {    fun solveTestCase() {        val n = readInt()        val s = read()        val arr = IntArray(n+1)        for (i in 1..n) {            arr[i] = arr[i-1] + if (s[i-1]=='-') 1 else -1        }        var ans = 0        for (i in 1..n) {            for (j in i..n) {                val v = arr[j]-arr[i-1]                if (v>=0 && v%3==0)                    ++ans            }        }        outputWriter.println(ans)    }} fun main(args: Array<String>) {    repeat(readInt()) {        Main().solveTestCase()    }     outputWriter.flush()}","brute force,implementation,math,strings"
"private fun readLn() = readLine()!!.trim() // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }private fun readLongs() = readStrings().map { it.toLong() } fun main() = P1660F.solve() object P1660F {     fun solve() {         repeat(readInt()) {            val n = readInt()            val s = readLn()            val acc = IntArray(n+1)            acc[0] = 0            repeat(n) { i ->                acc[i+1] = acc[i] + if (s[i] == '+') 1 else -1            }             var res = 0            (1 until n).forEach { i ->                (i+1..n).forEach { j ->                    val diff = acc[j] - acc[i-1]                    if (diff == 0 || (diff < 0 && -diff %3 == 0)) { res++ }                }            }            println(res)        }    }} ","brute force,implementation,math,strings"
"fun main() {    val out = StringBuilder()    repeat(readLine()!!.toInt()) {        val (n, k) = readLine()!!.split("" "").map { it.toInt() }        val xs = readLine()!!.split("" "").map { it.toInt() }.toSet()        out.appendln(if (xs.any { it + k in xs }) ""yEs"" else ""nO"")    }    print(out)}","data structures,greedy,math,two pointers"
"import java.io.Fileimport java.util.* fun main() {//    val sc = Scanner(File(""input-b.txt""))    val sc = Scanner(System.`in`)    val tt = sc.nextInt()    for (i in 0 until tt) {        SolutionB().doSolve(sc)    }} class SolutionB {    fun doSolve(sc: Scanner) {        val N = sc.nextInt()        val K = sc.nextInt()        val h = HashSet<Int>()        val a = IntArray(N)        for (i in 0 until N) {            a[i] = sc.nextInt()            h += a[i]        }        var found = false        for (i in 0 until N) {            val goal = a[i] + K            if (h.contains(goal)) {                found = true                break            }        }         println(if (found) ""YES"" else ""NO"")    }}","data structures,greedy,math,two pointers"
"private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readLong() = readLn().toLong()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }private fun readLongs() = readStrings().map { it.toLong() } fun main() {     repeat(readInt()) {        println(solve())    } } private fun solve(): String {    val (_, k) = readInts()    val xs = readInts()     return when (isPossible(xs, k)) {        true -> ""YES""        false -> ""NO""    }} private fun isPossible(xs: List<Int>, k: Int): Boolean {    val values = xs.groupingBy { it }.eachCount()    return values.any { (x, n) ->        when (val toFind = k + x) {            x -> n > 1            else -> toFind in values        }    }}","data structures,greedy,math,two pointers"
"import java.io.BufferedReader fun main() {    val br = System.`in`.bufferedReader()    val bw = System.out.bufferedWriter()    val t = br.readInt()    repeat(t) {        val n = br.readInt()        val k = br.readInt()        val nums = IntArray(n) {            val num = br.readInt()            num        }.sorted().toIntArray()        var good = false        var i = 0        for(j in 0 until n) {            while (i < n && nums[i] - nums[j] < k) {                i++            }            if(i < n && nums[i] - nums[j] == k) good = true        }         if(good) {            bw.append(""YES\n"")        } else {            bw.append(""NO\n"")        }    }    bw.flush()} private const val SPACE_INT = ' '.toInt()private const val ZERO_INT = '0'.toInt()private const val NL_INT = '\n'.toInt() private fun BufferedReader.readInt(): Int {    var ret = read()    while (ret <= SPACE_INT) {        ret = read()    }    val neg = ret == '-'.toInt()    if (neg) {        ret = read()    }    ret -= ZERO_INT    var read = read()    while (read >= ZERO_INT) {        ret *= 10        ret += read - ZERO_INT        read = read()    }     while (read <= SPACE_INT && read != -1 && read != NL_INT) {        mark(1)        read = read()    }    if (read > SPACE_INT) {        reset()    }    return if (neg) -ret else ret}","data structures,greedy,math,two pointers"
"fun main() {    val T = readLine()!!.toInt()    repeat(T) {        val n = readLine()!!.toLong()        var factorials = mutableListOf<Long>()         var prod = 6L        var begin = 4        while(true) {            if(prod > n) {                break            }            factorials.add(prod)            prod *= begin            begin++        }         var ans = Long.MAX_VALUE        for(mask in 0 until ((1 shl factorials.size))) {            var sum = n.toLong()            for(i in 0 until factorials.size) {                if((mask and(1 shl i)) != 0) sum -= factorials[i]            }            if(sum < 0) continue            Long            ans = kotlin.math.min(Integer.bitCount(mask).toLong() + java.lang.Long.bitCount(sum), ans)        }        println(ans)    }} ","bitmasks,brute force,constructive algorithms,dp,math"
"import java.util.Collections.min fun main() {    val T = readLine()!!.toInt()    repeat(T) {        val n = readLine()!!.toLong()        var factorials = mutableListOf<Long>()         var prod = 6L        var begin = 4        while(true) {            if(prod > n) {                break            }            factorials.add(prod)            prod *= begin            begin++        }         var ans = Long.MAX_VALUE        for(mask in 0 until (1 shl factorials.size)) {            var sum = n.toLong()            for(i in 0 until factorials.size) {                if(mask and (1 shl i) != 0) sum -= factorials[i]            }            if(sum < 0) continue             ans = kotlin.math.min(ans, Integer.bitCount(mask).toLong() + java.lang.Long.bitCount(sum))        }        println(ans)    }} ","bitmasks,brute force,constructive algorithms,dp,math"
"fun readStr() = readLine()!!fun readInt() = readLine()!!.toInt()fun readLong() = readLine()!!.toLong()fun readIntPair() = readLine()!!.split("" "").let { it[0].toInt() to it[1].toInt() }fun readIntList() = readLine()!!.split("" "").map { it.toInt() }fun readLongList() = readLine()!!.split("" "").map { it.toLong() }fun readIntArr() = readIntList().toIntArray()fun readDoubleList() = readLine()!!.split("" "").map { it.toDouble() }fun Boolean.toAns() = if (this) ""yes"" else ""no"" fun go(ansBuilder: StringBuilder.() -> Unit) {    val sb = StringBuilder()    val t = readInt()    repeat(t) { sb.ansBuilder() }    println(sb.toString())} fun main() = go {    val n = readLong()    var (fact, next) = 1L to 2L    val facts = mutableListOf<Long>()    while (fact <= n) {        facts.add(fact)        fact *= next++    }    val factsArr = facts.toLongArray()    var ans = n.bitCount()    for (m in 0 until (1 shl factsArr.size)) {        var cur = 0L        var used = 0        for (i in factsArr.indices) {            if ((1 shl i) and m > 0 && cur + facts[i] <= n) {                cur += facts[i]                used++            }        }        ans = minOf(ans, used + (n - cur).bitCount())    }    appendLine(ans)} tailrec fun Long.bitCount(acc: Long = 0L): Long =    if (this == 0L) acc else (this shr 1).bitCount(acc + (this and 1)) ","bitmasks,brute force,constructive algorithms,dp,math"
"import java.io.*import java.util.*import kotlin.math.* val INPUT = System.`in`!!val OUTPUT = System.out!!val reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun line() = reader.readLine()!!var st: StringTokenizer = StringTokenizer("""")fun read(): String {    while (st.hasMoreTokens().not())        st = StringTokenizer(reader.readLine() ?: return """", "" "")    return st.nextToken()}fun int() = read().toInt()fun ints(n: Int) = List(n) { read().toInt() }fun intArray(n: Int) = IntArray(n) { read().toInt() }fun long() = read().toLong()fun longs(n: Int) = List(n) { read().toLong() }fun longArray(n: Int) = LongArray(n) { read().toLong() }val writer = PrintWriter(OUTPUT, false)fun main() { writer.solve(); writer.flush() }fun csb(n : Long) : Int {    var count = 0    for(i in n.toString(2)) {        if(i == '1') count++    }    return count}fun PrintWriter.solve() {    var tt = 1    tt = int()    while (tt-- > 0) {        val n = long()        var x = 1L; var counter = 2        val fact = ArrayList<Long>()        while(x <= n) {            fact.add(x)            x *= counter++        }        var min = 100        for(i in 0 until (1 shl fact.size)) {            var y = i            var sum = 0L            for(j in fact.indices) {                if(y % 2 == 1) {                    sum += fact[j]                }                y /= 2            }            if(n - sum >= 0) {                min = min(min, csb(i + 0L) + csb(n - sum))            }        }        println(min)    }}","bitmasks,brute force,constructive algorithms,dp,math"
"import kotlin.math.abs private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readInts() = readLn().split(' ').map { it.toInt() }private fun readLongs() = readLn().split(' ').map { it.toLong() } fun check(k : Int) : Boolean {    return k != -1} private fun solve() {    var n = readInt()    var arr = mutableListOf<Int>()     for (i in n downTo  1) {        arr.add(i)    }     for (i in 0 until n) {        print(""${arr[i]} "")    }    println()     var ind = n-1    while (ind > 0) {        var tmp = arr[ind - 1]        arr[ind - 1] = arr[ind]        arr[ind] = tmp        ind--        for (i in 0 until n) {            print(""${arr[i]} "")        }        println()    } }  fun main() {     var tt = readInt()    while (tt > 0) {        tt--        solve()    }   }","brute force,constructive algorithms,implementation"
"fun readStr() = readLine()!!fun readInt() = readLine()!!.toInt()fun readLong() = readLine()!!.toLong()fun readIntPair() = readLine()!!.split("" "").let { it[0].toInt() to it[1].toInt() }fun readIntList() = readLine()!!.split("" "").map { it.toInt() }fun readLongList() = readLine()!!.split("" "").map { it.toLong() }fun readIntArr() = readIntList().toIntArray()fun readDoubleList() = readLine()!!.split("" "").map { it.toDouble() }fun Boolean.toAns() = if (this) ""yes"" else ""no"" fun go(ansBuilder: StringBuilder.() -> Unit) {    val sb = StringBuilder()    val t = readInt()    repeat(t) { sb.ansBuilder() }    println(sb.toString())} fun main() = go {    val n = readInt()    if (n == 3) {        appendLine(""3 2 1"")        appendLine(""3 1 2"")        appendLine(""2 3 1"")    } else {        val perms = Array(n) { i ->            (i downTo 1) + (n downTo i + 1)        }        perms.joinToString(""\n"") { it.joinToString("" "") }.let(::appendLine)    }} ","brute force,constructive algorithms,implementation"
"import java.io.*import java.util.*import kotlin.math.*/************************************ IO *********************************************************/@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out@JvmField val _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() }/*****************************************************************************************************/fun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b,a%b)fun gcd(a: Long, b: Long): Long = if (b == 0L) a else gcd(b,a%b)fun Boolean.toInt() = if (this) 1 else 0val INF = 0x3f3f3f3fval MOD = 1000000007fun main() { Thread(null, {newmain()}, ""JiKuai"", 1 shl 28).start() }fun assert(x: Boolean) {if(!x) throw AssertionError(); }/************************************ From wiwi_ho ********************************************/fun <T> List<T>.binarySearchWith(condition: (T) -> Boolean): Int {    return binarySearch {        if(condition(it)) 1        else -1    }.let { -(it + 1) }}fun List<Int>.lowerBound(i: Int) = binarySearchWith { it >= i }fun List<Int>.upperBound(i: Int) = binarySearchWith { it > i }fun List<Long>.lowerBound(i: Long) = binarySearchWith { it >= i }fun List<Long>.upperBound(i: Long) = binarySearchWith { it > i }/***********************************************************************************************/ fun newmain() {    println(Array(readInt()) {        val n = readInt()        var arr = IntArray(n) { n - it }        Array(n) {            if(it > 0)                arr[n - it - 1] = arr[n - it].also { _ -> arr[n - it] = arr[n - it - 1] }            arr.joinToString("" "")        }.joinToString(""\n"")    }.joinToString(""\n""))}","brute force,constructive algorithms,implementation"
"import java.io.*import java.util.*import kotlin.math.absoluteValueimport kotlin.system.measureTimeMillis // @formatter:off val local = System.getProperty(""ONLINE_JUDGE"") == null//val local = false val INPUT: InputStream = if (local) FileInputStream(""input.txt"") else System.`in`//val INPUT: InputStream = System.`in` //val OUTPUT: PrintStream = if (local) PrintStream(""output.txt"") else System.outval OUTPUT: PrintStream = System.out val _reader = INPUT.bufferedReader()var _tokenizer = StringTokenizer("""") fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!!fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()} fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readStrings() = readLn().split("" "")fun readInts() = readStrings().map { it.toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() }fun PrintWriter.yesNo(p: Boolean) {    if (p) this.println(""YES"") else this.println(""NO"")} @JvmFieldval _writer = PrintWriter(OUTPUT, true)// @formatter:on fun solve(n: Int): List<IntArray> {    val used = BooleanArray(n + 1)    val res = mutableListOf<IntArray>()    val p = IntArray(n)     fun check(p: IntArray): Boolean {        for (i in 2 until n) {            if (p[i] == p[i - 1] + p[i - 2]) {                return false            }        }        return true    }     fun gen(idx: Int) {        if (idx == n) {            if (check(p)) {                res.add(p.toList().toIntArray())            }            return        }         for (i in n downTo 1) {            if (!used[i]) {                p[idx] = i                used[i] = true                gen(idx + 1)                used[i] = false                if (res.size == n) {                    break                }            }         }    }     gen(0)    return res} fun PrintWriter.solve() {    var tcs = 1    tcs = readInt()     for (tc in 1..tcs) {        val n = readInt()        val res = solve(n)        for (p in res) {            println(p.joinToString("" "") { it.toString() })        }    }} fun main() {     val elapsedMs = measureTimeMillis {        _writer.solve()        _writer.flush()    }    if (local) {        println(""\n\nElapsed $elapsedMs ms"")    }}","brute force,constructive algorithms,implementation"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.lang.AssertionErrorimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007 data class Square(val row: Int, val col: Int)data class Ans(val p: Square, val color: Int)class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  private val reader = BufferedReader(InputStreamReader(stream), 32768)   private val N = ni()  private val M = ni()  private val g = Array(N){(na(M))} // 0はwildcard  private val ans = mutableListOf<Ans>()  private val que = ArrayDeque<Square>()  private val removed = Array(N){BooleanArray(M) }   private inline fun colorOf(row: Int, col: Int): Int {    var found = 0    for (i in row .. row + 1) {      for (j in col .. col + 1) {        val c = g[i][j]        if (c != 0) {          if (found == 0) {            found = c          } else if (found != c){            return -1          }        }      }    }    return found  }   /**   * 引数はSquare   * ケチりたいのでInt   */  private inline fun check(row: Int, col: Int) {    if (removed[row][col]) return     val c = colorOf(row, col)    if (c == -1) return     removed[row][col] = true    if (c > 0) {      val s = Square(row, col)      que += s      ans += Ans(s, c)    }  }    /**   * 引数はSquareでなくてPoint   */  private inline fun notice(row: Int, col: Int) {    for (i in max(0, row - 1) .. min(row, N - 2)) {      for (j in max(0, col - 1) .. min(col, M - 2)) {        check(i, j)      }    }  }   private inline fun remove(s: Square) {    for (i in s.row .. s.row + 1) {      for (j in s.col..s.col + 1) {        g[i][j] = 0      }    }     for (i in s.row .. s.row + 1) {      for (j in s.col .. s.col + 1) {        notice(i, j)      }    }  }   fun isSuccess(): Boolean {    for (i in 0 until N) {      for (j in 0 until M) {        if (g[i][j] != 0) return false      }    }    return true  }   fun solve() {    for (i in 0 until N - 1) {      for (j in 0 until M - 1) {        check(i, j)      }    }     while(que.isNotEmpty()) {      val s = que.pop()      debug{""$s""}      remove(s)    }     if (!isSuccess()) {      out.println(-1)      return    }     out.println(ans.size)    for (i in ans.reversed()) {      out.println(""${i.p.row + 1} ${i.p.col + 1} ${i.color}"")    }  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return IntArray(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   /**   * コーナーケースでエラー出たりするので、debug(dp[1])のように添え字付きの場合はdebug{}をつかうこと   */  private inline fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: BooleanArray) {    debug { toString(a) }  }   private inline fun toString(a: BooleanArray) = run{a.map { if (it) 1 else 0 }.joinToString("""")}   private inline fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<BooleanArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }   private inline fun assert(b: Boolean) = run{if (!b) throw AssertionError()}  private inline fun assert(b: Boolean, f: () -> String) = run{if (!b) throw AssertionError(f())}   companion object {    // TestRunnerから呼びたいので単純なmainじゃだめ    fun main() {      val out = java.io.PrintWriter(System.out)      Solver(System.`in`, out).solve()      out.flush()    }  }} /** * judgeから呼ばれる */fun main() = Solver.main()","constructive algorithms,data structures,greedy,implementation"
"import java.io.BufferedReaderimport java.io.BufferedWriterimport java.lang.IllegalArgumentExceptionimport java.util.*import java.util.stream.Collectors class Coloring(val x: Int, val y: Int, val color: Int) class ProblemD {    private fun BufferedReader.readInt(): Int = this.readLine().toInt()    private fun BufferedReader.readIntArray(delimiter: String = "" "") =        this.readLine().split(delimiter).map { it.toInt() }.toIntArray()     private fun BufferedWriter.writeLine(s: String) {        this.write(s)        this.newLine()    }     private fun IntArray.swap(i: Int, j: Int) {        val tmp = this[i]        this[i] = this[j]        this[j] = tmp    }     private var grid: Array<IntArray> = arrayOf()    private var colorings = mutableListOf<Coloring>()    private var n: Int = 0    private var m: Int = 0    private inline fun canColored(x: Int, y: Int): Int {        if (x > grid.size - 2 || y > grid[0].size - 2 || x < 0 || y < 0) return -2        val colors = mutableSetOf<Int>()        for (dx in 0..1) {            for (dy in 0..1) {                val c = grid[x + dx][y + dy]                if (c != -1) {                    colors.add(c)                }            }        }        if (colors.size != 1) return -2        return colors.first()    }      private fun checkDone(): Boolean {        for (i in grid.indices) {            for (j in grid[0].indices) {                if (grid[i][j] != -1) return false            }        }        return true    }      fun solve(input: BufferedReader, output: BufferedWriter) {        val gridSize = input.readIntArray()        n = gridSize[0]        m = gridSize[1]        grid = input.readLines().parallelStream().map { line -> line.split("" "")            .map { it.toInt() }.toIntArray() }.collect(Collectors.toList()).toTypedArray()        colorings = mutableListOf()        val queue = LinkedList<Coloring>()        val used = (0 until n).map { BooleanArray(m) }        for (i in 0 until n - 1) {            for (j in 0 until m - 1) {                val colored = canColored(i, j)                if (colored > 0) {                    queue.add(Coloring(i, j, color = colored))                    used[i][j] = true                }            }        }        var remaining = n*m        val dx = intArrayOf(-1, -1, 1, 1, 0, 0, -1, 1)        val dy = intArrayOf(-1, 1, -1, 1, -1, 1, 0, 0)         while (queue.isNotEmpty() && remaining > 0) {            val q = queue.removeFirst()            colorings.add(q)            for (i in 0..1) {                for (j in 0..1) {                    val c = grid[i + q.x][j + q.y]                    if(c != -1) {                        grid[i+q.x][j+q.y] = -1                        remaining -= 1                    }                }            }             for (index in dx.indices) {                val xx = dx[index] + q.x                val yy = dy[index] + q.y                val colored = canColored(xx, yy)                if (colored < 0) continue                if (used[xx][yy]) continue                used[xx][yy] = true                queue.add(Coloring(xx, yy, colored))            }        }        if (!checkDone()) {            output.writeLine(""-1"")        } else {            output.writeLine(colorings.size.toString())            for (c in colorings.reversed()) {                output.writeLine(""${c.x + 1} ${c.y + 1} ${c.color}"")            }        }        input.close()        output.close()    } } fun main() {    val solution = ProblemD()    solution.solve(System.`in`.bufferedReader(), System.out.bufferedWriter())}","constructive algorithms,data structures,greedy,implementation"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.io.PrintWriterimport java.util.*import kotlin.math.absimport kotlin.system.measureNanoTime typealias IPair = Pair<Int, Int>typealias LPair = Pair<Long, Long>typealias ILPair = Pair<Int, Long>typealias List<E> = MutableList<E>typealias LList<E> = List<List<E>>typealias LLList<E> = List<LList<E>>typealias LLLList<E> = List<LLList<E>> val writer: PrintWriter = PrintWriter(System.out, false)const val iinf: Int = 0x3fffffffconst val inf: Long = 0x1fffffffffffffffconst val eps: Double = 1e-9const val mod: Int = 1000000007 fun solve() {    val h = In.nextInt()    val w = In.nextInt()    val a = In.nextIntMatrix(h, w)    val deque: Deque<Pos> = ArrayDeque()    val visited: LList<Boolean> = list(h, w, false)    val ans = mutableListOf<Pair<Pos, Int>>()    var c = h * w    for (i in 0 until h - 1) {        for (j in 0 until w - 1) {            val v1 = a[i][j]            val v2 = a[i + 1][j]            val v3 = a[i][j + 1]            val v4 = a[i + 1][j + 1]            if (v1 == v2 && v1 == v3 && v1 == v4) {                deque.add(Pos(j, i))                ans.add(Pos(j, i) to v1)                if (!visited[i][j]) c--                if (!visited[i + 1][j]) c--                if (!visited[i][j + 1]) c--                if (!visited[i + 1][j + 1]) c--                visited[i][j] = true                visited[i + 1][j] = true                visited[i][j + 1] = true                visited[i + 1][j + 1] = true            }        }    }    Pos.size = h - 1 to w - 1    while (deque.isNotEmpty()) {        val pos = deque.remove()        for (i in 0 until 8) {            val nei = pos.moved(i)            if (!nei.inner()) {                continue            }            val p = ArrayList<Pos>(4)            nei.let { if (!visited[it.y][it.x]) p.add(it) }            nei.moved(0, 1).let { if (!visited[it.y][it.x]) p.add(it) }            nei.moved(1, 0).let { if (!visited[it.y][it.x]) p.add(it) }            nei.moved(1, 1).let { if (!visited[it.y][it.x]) p.add(it) }            if (p.isNotEmpty() && p.all { a[it.y][it.x] == a[p[0].y][p[0].x] }) {                visited[nei.y][nei.x] = true                visited[nei.y + 1][nei.x] = true                visited[nei.y][nei.x + 1] = true                visited[nei.y + 1][nei.x + 1] = true                c -= p.size                ans.add(nei to a[p[0].y][p[0].x])                deque.add(nei)            }        }    }    if (c != 0) {        println(-1)        return    }    ans.reverse()    println(ans.size)    ans.forEach { println(""${it.first.y + 1} ${it.first.x + 1} ${it.second}"") }} class Pos(val x: Int, val y: Int): Comparable<Pos> {    companion object {        private val da = intArrayOf(-1, 0, 1, 0, -1, 1, 1, -1, -1)        lateinit var size: IPair    }     fun moved(dir: Int): Pos = Pos(x + da[dir], y + da[dir + 1])    fun moved(dx: Int, dy: Int): Pos = Pos(x + dx, y + dy)    fun manhattan(point: Pos): Int = abs(x - point.x) + abs(y - point.y)    fun inner(): Boolean = x in 0 until size.second && y in 0 until size.first    fun neighbors4(): List<Pos> = (0 until 4).map { moved(it) }.filter { it.inner() }.toMutableList()    fun neighbors8(): List<Pos> = (0 until 8).map { moved(it) }.filter { it.inner() }.toMutableList()    fun direction(o: Pos): Int = (0 until 8).find { moved(it) == o } ?: -1    fun around(dist: Int): List<Pos> {        val list: MutableList<Pos> = mutableListOf()        for (i in 0 until dist) {            Pos(x + i, y + dist - i).let { if (it.inner()) list.add(it) }            Pos(x + dist - i, y - i).let { if (it.inner()) list.add(it) }            Pos(x - i, y - dist + i).let { if (it.inner()) list.add(it) }            Pos(x - dist + i, y + i).let { if (it.inner()) list.add(it) }        }        return list    }     operator fun component1(): Int = x    operator fun component2(): Int = y    override operator fun compareTo(other: Pos): Int = if (x == other.x) y.compareTo(other.y) else x.compareTo(other.x)    override fun equals(other: Any?): Boolean = other is Pos && x == other.x && y == other.y    override fun hashCode(): Int = y * size.second + x    override fun toString(): String = ""($x, $y)""} fun main() {    System.err.printf(""%.1f ms"", measureNanoTime {        solve()        writer.flush()    } / 1000000.0)} fun <T> list(n1: Int, init: T): List<T> = MutableList(n1) { init }fun <T> list(n1: Int, n2: Int, init: T): LList<T> = MutableList(n1) { list(n2, init) }fun <T> list(n1: Int, n2: Int, n3: Int, init: T): LLList<T> = MutableList(n1) { list(n2, n3, init) }fun <T> list(n1: Int, n2: Int, n3: Int, n4: Int, init: T): LLLList<T> = MutableList(n1) { list(n2, n3, n4, init) }fun <T> list(n1: Int, init: (Int) -> T): List<T> = MutableList(n1) { i1 -> init(i1) }fun <T> list(n1: Int, n2: Int, init: (Int, Int) -> T): LList<T> = MutableList(n1) { i1 -> MutableList(n2) { i2 -> init(i1, i2) } }fun <T> list(n1: Int, n2: Int, n3: Int, init: (Int, Int, Int) -> T): LLList<T> = MutableList(n1) { i1 -> MutableList(n2) { i2 -> MutableList(n3) { i3 -> init(i1, i2, i3) } } }fun <T> list(n1: Int, n2: Int, n3: Int, n4: Int, init: (Int, Int, Int, Int) -> T): LLLList<T> = MutableList(n1) { i1 -> MutableList(n2) { i2 -> MutableList(n3) { i3 -> MutableList(n4) { i4 -> init(i1, i2, i3, i4) } } } }fun <T: Comparable<T>> minmax(a: T, b: T) = if (a <= b) Pair(a, b) else Pair(b, a)fun min(vararg a: Int) = a.minOrNull()!!fun max(vararg a: Int) = a.maxOrNull()!!fun min(vararg a: Long) = a.minOrNull()!!fun max(vararg a: Long) = a.maxOrNull()!!fun <T: Comparable<T>> min(vararg a: T) = a.minOrNull()!!fun <T: Comparable<T>> max(vararg a: T) = a.maxOrNull()!!fun <T> println(list: LList<T>) = writer.println(list.joinToString(""\n""))fun println(vararg args: Any?) = writer.println(args.joinToString("" "")) object ExtensionFunctions {    fun String.toDigitArray() = map { it - '0' }.toMutableList()     fun List<Long>.accumulate(): List<Long> {        val s = MutableList(size + 1) { 0L }        for ((i, v) in this.withIndex()) {            s[i + 1] = s[i] + v        }        return s    }     fun Int.testbit(i: Int) = this shr i and 1 == 1     fun Long.testbit(i: Int) = this shr i and 1 == 1L     fun Int.bitLength() = 32 - Integer.numberOfLeadingZeros(this)     fun Long.bitLength() = 64 - java.lang.Long.numberOfLeadingZeros(this)     fun Int.clamp(l: Int, r: Int) = coerceIn(l, r)     fun Long.clamp(l: Long, r: Long) = coerceIn(l, r)     operator fun String.times(n: Int) = repeat(n)     fun Long.pow(p: Int): Long {        var p = p        var a = this        var x = 1L        while (p > 0) {            if (p and 1 == 1) {                x *= a            }            a *= a            p = p shr 1        }        return x    }     fun <T> List<T>.swap(i: Int, j: Int) {        val temp = this[j]        this[j] = this[i]        this[i] = temp    }     fun <T> List<T>.runLengthEncoding(): List<Pair<T, Int>> {        val encoded: List<Pair<T, Int>> = mutableListOf()        var count = 1        for (i in 1..size) {            if (i < size && this[i - 1] == this[i]) {                count++            } else {                encoded.add(this[i - 1] to count)                count = 1            }        }        return encoded    }} object In {    private val reader = BufferedReader(InputStreamReader(System.`in`), 0x10000)    private var tokenizer: StringTokenizer? = null     fun next(): String {        while (tokenizer?.hasMoreTokens() != true) {            tokenizer = StringTokenizer(reader.readLine())        }        return tokenizer!!.nextToken()    }     fun nextInt() = next().toInt()    fun nextLong() = next().toLong()    fun nextDouble() = next().toDouble()    fun nextCharArray() = next().toCharArray().toMutableList()    fun nextCharGrid(n: Int, m: Int) = MutableList(n) { nextCharArray() }    fun nextStringArray(n: Int, op: (String) -> String = { it }) = MutableList(n) { op(next()) }    fun nextIntArray(n: Int, op: (Int) -> Int = { it }) = MutableList(n) { op(nextInt()) }    fun nextIntMatrix(h: Int, w: Int, op: (Int) -> Int = { it }) = MutableList(h) { nextIntArray(w, op) }    fun nextLongArray(n: Int, op: (Long) -> Long = { it }) = MutableList(n) { op(nextLong()) }    fun nextLongMatrix(h: Int, w: Int, op: (Long) -> Long = { it }) = MutableList(h) { nextLongArray(w, op) }    fun nextGraph(n: Int, m: Int, directed: Boolean = false): List<List<Int>> {        val res: LList<Int> = list(n, 0, 0)        for (i in 0 until m) {            val u = nextInt() - 1            val v = nextInt() - 1            res[u].add(v)            if (!directed) {                res[v].add(u)            }        }        return res    }}","constructive algorithms,data structures,greedy,implementation"
"val sc = java.util.Scanner(System.`in`)fun main() {    val t = sc.nextInt()    for (i in 0 until t) {        val n = sc.nextInt()        val s = sc.next()        if (n == 1 || n == 2 && s[0] != s[1]) println(""YES"")        else println(""NO"")    }}",implementation
"fun main(args: Array<String>) {    var t = readLine()!!.toInt()    while (t-- > 0) {        readLine()        val s = readLine()!!                if (s == ""0"" || s == ""1"" || s == ""01"" || s == ""10"") {            println(""YES"")        } else {            println(""NO"")        }    }}   	 		   		 		    		 	   	",implementation
"import java.io.BufferedReader val bin = System.`in`.bufferedReader()fun BufferedReader.readInt() = this.readLine()!!.toInt() fun main() {    repeat(bin.readInt()) {        bin.readInt()        val s = bin.readLine()!!        val ok = s == ""0"" || s == ""1"" || s == ""01"" || s == ""10""        println(if (ok) ""YES"" else ""NO"")    }}",implementation
"fun main() {    val k = readLine()?.toInt() ?: return    for (i in 1..k) {        val n = readLine()?.toInt() ?: return        val line = readLine() ?: """"        when (n) {            0, 1 -> println(""YES"")            2 ->                if (line[0] == line[1])                    println(""NO"")                else                    println(""YES"")            else -> println(""NO"")        }    }}",implementation
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.lang.AssertionErrorimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007 class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  private val reader = BufferedReader(InputStreamReader(stream), 32768)   fun solve() {    for (t in 0 until ni()) {      val (N, M) = na(2)      val phones = Array(N){ns()}      val dest = ns()       fun toCode(s: String, l: Int, r: Int): Int {        var code = 0        val len = r - l        for (i in 0 until len) {          if (i > 0) code *= 10          code += s[l + i] - '0'        }        if (len == 2) code += 1000        return code      }            val segments = arrayOfNulls<String>(2000)      for (i in 0 until N) {        for (j in 0 until M) {          fun add(n: Int) {            if (j + n <= M) {              val code = toCode(phones[i], j, j + n)              segments[code] = ""${j+1} ${j+n} ${i+1}""            }          }           add(2)          add(3)        }      }      debug{segments.joinToString("" "")}            val dp = BooleanArray(M + 1)      dp[0] = true      val trace = IntArray(M + 1){-1}       for (i in 0 .. M) {        if (!dp[i]) continue         fun trans(n: Int) {          if (i + n <= M) {            val code = toCode(dest, i, i + n)            if (segments[code] != null) {              trace[i + n] = code              dp[i + n] = true            }          }        }         trans(2)        trans(3)      }      debug(dp)       if (!dp[M]) {        out.println(-1)      }      else {        val ans = mutableListOf<String>()        var i = M        while(i > 0) {          ans += segments[trace[i]]!!          i -= if (trace[i] >= 1000) 2 else 3        }         ans.reverse()        out.println(ans.size)        ans.forEach(out::println)      }    }  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return IntArray(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   /**   * コーナーケースでエラー出たりするので、debug(dp[1])のように添え字付きの場合はdebug{}をつかうこと   */  private inline fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: BooleanArray) {    debug { toString(a) }  }   private inline fun toString(a: BooleanArray) = run{a.map { if (it) 1 else 0 }.joinToString("""")}   private inline fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<BooleanArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }   private inline fun assert(b: Boolean) = run{if (!b) throw AssertionError()}  private inline fun assert(b: Boolean, f: () -> String) = run{if (!b) throw AssertionError(f())}   companion object {    // TestRunnerから呼びたいので単純なmainじゃだめ    fun main() {      val out = java.io.PrintWriter(System.out)      Solver(System.`in`, out).solve()      out.flush()    }  }} /** * judgeから呼ばれる */fun main() = Solver.main()","brute force,constructive algorithms,dp,hashing,implementation,strings"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"", ""DEPRECATION"") import java.io.PrintWriterimport java.util.*import kotlin.math.*import kotlin.random.* @JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out @JvmField val reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun readLn() = reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readString() = readStrings(1)[0]fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int = 2) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int = 2) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmFieldval writer = PrintWriter(OUTPUT, true) // ---------------------------------------------------------------------------- class UnionFind {     private val parents = mutableMapOf<Int, Int>()    private val sizes = mutableMapOf<Int, Int>()     fun union(a: Int, b: Int) {        val fa = find(a)        val fb = find(b)        if (fa != fb) {            parents[fa] = fb            sizes[fb] = (sizes[fb] ?: 1) + (sizes[fa] ?: 1)        }    }     fun find(a: Int): Int {        fun getOrDefault(value: Int) = parents.getOrDefault(value, value)         var parent = getOrDefault(a)        while (parent != getOrDefault(parent)) {            parents[parent] = getOrDefault(getOrDefault(parent))            parent = parents[parent]!!        }        return parent    }     fun connected(a: Int, b: Int): Boolean {        return find(a) == find(b)    }     fun getSize(a: Int): Int {        return sizes[find(a)] ?: 1    }} class UnionFindArray(private val n: Int) {     private val parents = IntArray(n + 1) { it }     fun union(a: Int, b: Int) {        val fa = find(a)        val fb = find(b)        if (fa != fb) {            parents[fa] = fb        }    }     fun find(a: Int): Int {        var parent = parents[a]        while (parent != parents[parent]) {            parents[parent] = parents[parents[parent]]            parent = parents[parent]        }        return parent    }     fun connected(a: Int, b: Int): Boolean {        return find(a) == find(b)    }} class Trie() {     /** Initialize your data structure here. */    private val root = Node()     /** Inserts a word into the trie. */    fun insert(word: String) {        var node = root        for (char in word) {            if (!node.children.contains(char)) {                node.children[char] = Node()            }            node = node.children[char]!!        }        node.hasWord = true    }     /** Returns if the word is in the trie. */    fun search(word: String): Boolean {        return findNode(word)?.hasWord ?: false    }     /** Returns if there is any word in the trie that starts with the given prefix. */    fun startsWith(prefix: String): Boolean {        return findNode(prefix) != null    }     private fun findNode(prefix: String): Node? {        var node = root        for (char in prefix) {            node = node.children[char] ?: return null        }        return node    }     private class Node(        var hasWord: Boolean = false,        val children: MutableMap<Char, Node> = mutableMapOf<Char, Node>()    )} // 所有函数的下标从 0 开始// query(index): sum[0, index]class BinaryIndexedTree {     private val bit: IntArray     constructor(n: Int) {        this.bit = IntArray(n + 1)    }     constructor(nums: IntArray) {        this.bit = IntArray(nums.size + 1)        val prefix = IntArray(bit.size)        for (i in 1 until nums.size + 1) {            prefix[i] = prefix[i - 1] + nums[i - 1]            bit[i] = prefix[i] - prefix[i - lowbit(i)]        }    }     fun query(index: Int): Int {        var result = 0        var i = index + 1        while (i > 0) {            result += bit[i]            i -= lowbit(i)        }        return result    }     fun update(index: Int, x: Int) {        val value = query(index) - query(index - 1)        add(index, x - value)    }     fun add(index: Int, x: Int) {        var i = index + 1        while (i < bit.size) {            bit[i] += x            i += lowbit(i)        }    }     private fun lowbit(x: Int): Int {        return x.and(-x)    }} // 所有函数的下标从 0 开始// query(index): max[0, index]// udpate(index, x): 更新 [0, index] 之间的最大值，只能越来越大class BinaryIndexedTreeMax {     private val bit: IntArray     constructor(n: Int) {        this.bit = IntArray(n + 1)    }     fun query(index: Int): Int {        var result = 0        var i = index + 1        while (i > 0) {            result = Math.max(result, bit[i])            i -= lowbit(i)        }        return result    }     fun update(index: Int, x: Int) {        var i = index + 1        while (i < bit.size) {            bit[i] = Math.max(bit[i], x)            i += lowbit(i)        }    }     private fun lowbit(x: Int): Int {        return x.and(-x)    }} class SparseTableMax(private val nums: IntArray) {     private val st: Array<IntArray>     init {        val n = nums.size        val logN = Integer.numberOfTrailingZeros(Integer.highestOneBit(n))        this.st = Array(n * 2) { IntArray(logN + 1) }        for (i in 0 until n) {            st[i][0] = nums[i]        }        for (j in 1 until logN + 1) {            for (i in 0 until n) {                st[i][j] = st[i][j - 1]                if (i + 1.shl(j - 1) < n) {                    st[i][j] = Math.max(st[i][j], st[i + 1.shl(j - 1)][j - 1])                }            }        }    }     fun query(left: Int, right: Int): Int {        if (left > right) {            return -1        }        val len = right - left + 1        val k = Integer.numberOfTrailingZeros(Integer.highestOneBit(len))        return Math.max(st[left][k], st[right - 1.shl(k) + 1][k])    }} class SparseTableMin(private val nums: IntArray) {     private val st: Array<IntArray>     init {        val n = nums.size        val logN = Integer.numberOfTrailingZeros(Integer.highestOneBit(n))        this.st = Array(n * 2) { IntArray(logN + 1) { Int.MAX_VALUE / 2 } }        for (i in 0 until n) {            st[i][0] = nums[i]        }        for (j in 1 until logN + 1) {            for (i in 0 until n) {                st[i][j] = st[i][j - 1]                if (i + 1.shl(j - 1) < n) {                    st[i][j] = Math.min(st[i][j], st[i + 1.shl(j - 1)][j - 1])                }            }        }    }     fun query(left: Int, right: Int): Int {        if (left > right) {            return -1        }        val len = right - left + 1        val k = Integer.numberOfTrailingZeros(Integer.highestOneBit(len))        return Math.min(st[left][k], st[right - 1.shl(k) + 1][k])    }} class PrefixSum2D(private val grid: Array<IntArray>) {     private val prefix: Array<IntArray>     init {        val (m, n) = Pair(grid.size, grid[0].size)        prefix = Array(m + 1) { IntArray(n + 1) }        for (i in 0 until m) {            var row = 0            for (j in 0 until n) {                row += grid[i][j]                prefix[i + 1][j + 1] = prefix[i][j + 1] + row            }        }    }     fun query(up: Int, left: Int, bottom: Int, right: Int): Int {        return prefix[up][left] + prefix[bottom + 1][right + 1] -            prefix[bottom + 1][left] - prefix[up][right + 1]    }} // ---------------------------------------------------------------------------- private fun PrintWriter.printNums(nums: List<Int>) {    for (i in 0 until nums.size - 1) {        print(nums[i])        print(' ')    }    println(nums.last())} private fun lengthOfLIS(numsInput: List<Int>): Int {    val nums = unify(numsInput)    val bit = BinaryIndexedTreeMax(nums.size + 1)    var result = 0    for (num in nums) {        val len = bit.query(num - 1) + 1        bit.update(num, len)        result = Math.max(result, len)    }    return result} private fun unify(nums: List<Int>): List<Int> {    val numToIndex = nums.sorted().mapIndexed { index, num -> num to index }.toMap()    return nums.map { numToIndex[it]!! }} private fun fastPow(a: Long, exp: Long, mod: Long): Long {    var result = 1L % mod    var base = a % mod    var remain = exp    while (remain != 0L) {        if (remain % 2L == 1L) {            result = (result * base) % mod        }        base = (base * base) % mod        remain /= 2L    }    return result} private fun gcd(a: Int, b: Int): Int {    return if (b == 0) a else gcd(b, a % b)} private fun gcdL(a: Long, b: Long): Long {    return if (b == 0L) a else gcdL(b, a % b)} private fun lcm(a: Int, b: Int): Int {    return ((a.toLong() * b.toLong()) / gcd(a, b)).toInt()} private fun lcmL(a: Long, b: Long): Long {    return (a * b) / gcdL(a, b)} private fun wordToCharCount(word: String): IntArray {    val charCount = IntArray(26)    for (char in word) {        charCount[char.toIndex()]++    }    return charCount} private fun Char.toIndex(): Int {    return this.toInt() - 'a'.toInt()} private fun Char.toDigit(): Int {    return this.toInt() - '0'.toInt()} private fun Boolean.toYesNo(upper: Boolean = false): String {    val yesNo = if (this) ""Yes"" else ""No""    return if (upper) yesNo.toUpperCase() else yesNo} private fun LongArray.modSum(mod: Long = MODL): Long {    var sum = 0L    for (num in this) {        sum = (sum + num) % mod    }    return sum} private fun <T> List<T>.toArrayDeque(): ArrayDeque<T> {    return ArrayDeque(this)} private fun <T> List<T>.listEquals(other: List<T>): Boolean {    return (0 until this.size).all { this[it] == other[it] }} private fun <T : Comparable<T>> List<T>.isSorted(): Boolean {    return this.listEquals(this.sorted())} private val DIR = listOf(    listOf(0, 1), listOf(1, 0), listOf(0, -1), listOf(-1, 0)) private const val MOD = 998244353private const val MODL = 998244353L// private const val MOD = 1000000007// private const val MODL = 1000000007Lprivate const val EPS = 0.000001 // ---------------------------------------------------------------------------- fun main() {    val go: Runnable = Runnable {        writer.solve()        writer.flush()    }    Thread(null, go, ""thread"", 1L.shl(28)).start()} private fun PrintWriter.solve() {    val t = readInt()    for (tx in 1 until t + 1) {        // print(""Case #$tx: "")        val n = readInts()[0]        val strs = Array(n) { readString() }        val target = readString()        val result = masha(strs, target)        if (result.isEmpty()) {            println(-1)        } else {            println(result.size)            result.forEach { printNums(it) }        }    }} private fun masha(strs: Array<String>, target: String): List<List<Int>> {    val n = strs.size    val m = strs[0].length    val dp2 = Array(10) { Array(10) { Pair(-1, -1) } }    val dp3 = Array(10) { Array(10) { Array(10) { Pair(-1, -1) } } }    for (i in 0 until n) {        val nums = strs[i].map { it.toDigit() }        for (j in 0 until m - 1) {            dp2[nums[j]][nums[j + 1]] = Pair(j + 1, i + 1)            if (j < m - 2) {                dp3[nums[j]][nums[j + 1]][nums[j + 2]] = Pair(j + 1, i + 1)            }        }    }     val nums = target.map { it.toDigit() }    val dp = IntArray(m)    for (i in 0 until m - 1) {        if (i > 0 && dp[i - 1] == 0) {            continue        }        if (dp2[nums[i]][nums[i + 1]].first >= 0) {            dp[i + 1] = 2        }        if (i < m - 2 && dp3[nums[i]][nums[i + 1]][nums[i + 2]].first >= 0) {            dp[i + 2] = 3        }    }    // println(dp.toList())     val result = mutableListOf<List<Int>>()    var i = m - 1    while (i >= 0) {        if (dp[i] == 0) {            return emptyList()        }        if (dp[i] == 2) {            val (left, index) = dp2[nums[i - 1]][nums[i]]            result.add(listOf(left, left + 1, index))            i -= 2        } else {            val (left, index) = dp3[nums[i - 2]][nums[i - 1]][nums[i]]            result.add(listOf(left, left + 2, index))            i -= 3        }    }    return result.reversed()}","brute force,constructive algorithms,dp,hashing,implementation,strings"
"fun main() {  repeat(readLine()!!.toInt()) {    readLine()!!     val (n, m) = readLine()!!.split("" "").map { it.toInt() }    val phones = Array(n) { readLine()!! }     val goal = readLine()!!    val doubles = mutableMapOf<String, Period>()    val triples = mutableMapOf<String, Period>()     for (i in 0 until n) {      for (j in 0..m - 2) doubles[phones[i].substring(j, j + 2)] = Period(j + 1, j + 2, i + 1)      for (j in 0..m - 3) triples[phones[i].substring(j, j + 3)] = Period(j + 1, j + 3, i + 1)    }     val dp = Array<Period?>(m + 1) { null }    dp[0] = Period(0, 0, 0)     for (i in 0..m) {      if (dp[i] == null) continue       if (i + 2 <= m) {        val double = goal.substring(i, i + 2)        if (doubles.containsKey(double)) dp[i + 2] = doubles[double]      }      if (i + 3 <= m) {        val triple = goal.substring(i, i + 3)        if (triples.containsKey(triple)) dp[i + 3] = triples[triple]      }    }     if (dp[m] == null) println(-1)    else {      val res = mutableListOf<Period>()      var x = m      while (x > 0) {        val period = dp[x]!!        res.add(period)        x -= period.length      }      println(res.size)      println(res.reversed().joinToString(""\n"") { ""${it.start} ${it.end} ${it.phone}"" })    }  }} data class Period(val start: Int, val end: Int, val phone: Int) {  val length: Int = end - start + 1}","brute force,constructive algorithms,dp,hashing,implementation,strings"
"import kotlin.collections.ArrayListimport kotlin.collections.HashMap fun main(args: Array<String>) {    val t = readLine()!!.trim().toInt()    repeat(t) {        readLine()        val (n, m) = readLine()!!.split("" "").map { it.toInt() }        val arr = ArrayList<String>()        repeat(n) {            val num = readLine()!!            arr.add(num)        }        val map = HashMap<String, Triple<Int, Int, Int>>()        for (i in arr.indices) {            for (j in arr[i].indices) {                for (k in j + 2..minOf(j + 3, arr[i].length)) {                    map[arr[i].substring(j, k)] = Triple(j + 1, k, i + 1)                }            }        }        val target = readLine()!!        val dp = IntArray(target.length + 1) { -1 }        dp[0] = 0        for (i in target.indices) {            if (i + 2 <= target.length && target.substring(i, i + 2) in map.keys) {                if (dp[i] != -1) {                    dp[i + 2] = i                }            }            if (i + 3 <= target.length && target.substring(i, i + 3) in map.keys) {                if (dp[i] != -1) {                    dp[i + 3] = i                }            }        }//        dp.print()        if (dp.last() == -1) {            println(-1)        } else {            val ans = ArrayList<Triple<Int, Int, Int>>()            var left = dp.last()            var right = target.length            while (right != 0) {                ans.add(map[target.substring(left, right)]!!)                right = left                left = dp[left]            }            println(ans.size)            val output = StringBuilder()            ans.reversed().forEach {                output.appendLine(""${it.first} ${it.second} ${it.third}"")            }            print(output)        }    }}","brute force,constructive algorithms,dp,hashing,implementation,strings"
"fun main() {    val (n, m) = readLine()!!.split("" "").map { it.toInt() }    val grid = Array(n + 1) { y -> if (y == n) IntArray(m + 1) else (readLine()!! + ""W"").map { if (it == 'W') 0 else 1 }.toIntArray() }    var answer = 0    for (y in 0 until n) {        for (x in 0 until m) {            grid[y][x] = grid[y][x] xor grid[y + 1][x] xor grid[y][x + 1] xor grid[y + 1][x + 1]            if (grid[y][x] == 1) {                answer++            }        }    }    var found = false    for (y in 0 until n - 1) {        for (x in 0 until m - 1) {            if (grid[y][x] == 1 && grid[n - 1][x] == 1 && grid[y][m - 1] == 1 && grid[n - 1][m - 1] == 1) {                found = true            }        }    }    if (found) {        answer--    }    println(answer)}","constructive algorithms,greedy"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.*import java.lang.AssertionErrorimport kotlin.collections.ArrayListimport kotlin.math.* val input = BufferedReader(InputStreamReader(System.`in`))val output = StringBuilder() fun main() {    var (h, w) = ints()    var a = Array<IntArray>(h) { IntArray(w) }    var b = Array<IntArray>(h) { IntArray(w) }    for (i in 0..h - 1) {        var s = string()        for (j in 0..w - 1) {            if (s[j] == 'B') {                a[i][j] = 1            }        }    }    for (i in 0..h - 1) {        for (j in 0..w - 1) {            if (i != 0) {                a[i][j] = a[i][j] xor b[i - 1][j]                b[i][j] = b[i][j] xor b[i - 1][j]            }            if (j != 0) {                a[i][j] = a[i][j] xor b[i][j - 1]                b[i][j] = b[i][j] xor b[i][j - 1]            }            if (i != 0 && j != 0) {                a[i][j] = a[i][j] xor b[i - 1][j - 1]                b[i][j] = b[i][j] xor b[i - 1][j - 1]            }            if (a[i][j] == 1) {                b[i][j] = b[i][j] xor 1            }        }    }    var ans = 0    for (i in 1..h - 1) {        for (j in 1..w - 1) {            if (a[i][j] == 1) {                a[0][0] = a[0][0] xor 1                a[0][j] = a[0][j] xor 1                a[i][0] = a[i][0] xor 1                ans++            }        }    }    for (i in 1..h - 1) {        if (a[i][0] == 1) {            ans++            a[0][0] = a[0][0] xor 1        }    }    for (j in 1..w - 1) {        if (a[0][j] == 1) {            ans++            a[0][0] = a[0][0] xor 1        }    }    if (a[0][0] == 1) {        for (i in 1..h - 1) {            for (j in 1..w - 1) {                if (a[i][j] == 1 && a[0][j] == 1 && a[i][0] == 1) {                    a[0][0] = 0                }            }        }        ans += a[0][0]    }    cout(ans)    print(output)} fun string() = input.readLine()fun int() = string().toInt()fun long() = string().toLong()fun strings() = ArrayList(string().split("" ""))fun ints() = ArrayList(string().split("" "").map { it.toInt() })fun longs() = ArrayList(string().split("" "").map { it.toLong() })fun cout(s: String) = output.appendLine(s)fun <T> cout(s: T) = output.appendLine(s.toString())fun cout(s: IntArray) = output.appendLine(s.joinToString("" ""))fun cout(s: LongArray) = output.appendLine(s.joinToString("" ""))fun <T> cout(s: Array<T>) = output.appendLine(s.joinToString("" ""))fun <T> cout(s: Iterable<T>) = output.appendLine(s.joinToString("" ""))fun assert(x: Boolean) {    if (!x) throw AssertionError()}","constructive algorithms,greedy"
"import kotlin.math.min fun main() {    repeat(readLine()!!.toInt()) {        readLine()        val ay = readLine()!!.split("" "").map { it.toInt() }        var j = 0        val xix = mutableMapOf<Int, Int>()        for (x in ay.toSet().sorted()) {            j++            xix[x] = j        }        val bit = BinaryIndexTree(1, j)        var answer = 0L        for (x in ay) {            val k = xix[x]!!            answer += min(bit[1, k - 1], bit[k + 1, j])            bit.update(k, 1L)        }        println(answer)    }} class BinaryIndexTree(val treeFrom: Int, treeTo: Int) {    val value = LongArray(treeTo - treeFrom + 2)     fun update(index: Int, delta: Long) {        var i = index + 1 - treeFrom        while (i < value.size) {            value[i] += delta            i += i and -i        }    }     fun query(to: Int): Long {        var res = 0L        var i = to + 1 - treeFrom        while (i > 0) {            res += value[i]            i -= i and -i        }        return res    }     operator fun get(from: Int, to: Int) = if (to < from) 0L else query(to) - query(from - 1)}","data structures,greedy"
"fun main() {    val t = readInt()    repeat(t) {        val n = readInt()        val a = readInts()        val b = a.sorted().distinct()        val f = IntArray(b.size)        fun add(i: Int, v: Int) {            var x = i            while (x < b.size) {                f[x] += v                x = (x or (x + 1))            }        }        fun sum(i: Int): Int {            var x = i            var s = 0            while (x >= 0) {                s += f[x]                x = (x and (x + 1)) - 1            }            return s        }        var ans = 0L        for (i in 0 until n) {            val j = b.binarySearch(a[i])            val c1 = sum(j - 1)            val c2 = sum(b.size - 1) - sum(j)            ans += minOf(c1, c2)            add(j, 1)        }        println(ans)    }} private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readLong() = readLn().toLong()private fun readDouble() = readLn().toDouble()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }private fun readLongs() = readStrings().map { it.toLong() }private fun readDoubles() = readStrings().map { it.toDouble() } ","data structures,greedy"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.*import java.lang.AssertionErrorimport kotlin.collections.ArrayListimport kotlin.math.* val input = BufferedReader(InputStreamReader(System.`in`))val output = StringBuilder() fun main() {    var tt = int()    while (tt-- > 0) {        var n = int()        var a = ints()        var b = a.toSet().toIntArray()        b.sort()        for (i in 0..n - 1) {            a[i] = b.binarySearch(a[i])        }        var ans = 0L        var ft = fenwick(b.size + 3)        for (i in 0..n - 1) {            var v = ft.get(a[i])            var w = ft.get(b.size + 2) - ft.get(a[i] + 1)            ans += minOf(v, w)            ft.add(a[i] + 1, 1)        }        cout(ans)    }    print(output)} class fenwick(_n: Int) {    val n = _n    val node = LongArray(n)    fun add(_x: Int, v: Long) {        var x = _x        while (x < n) {            node[x] += v            x = (x or (x + 1))        }    }     fun get(_x: Int): Long {        var x = _x        var v = 0L        while (x >= 0) {            v += node[x]            x = (x and (x + 1)) - 1        }        return v    }} fun string() = input.readLine()fun int() = string().toInt()fun long() = string().toLong()fun strings() = ArrayList(string().split("" ""))fun ints() = ArrayList(string().split("" "").map { it.toInt() })fun longs() = ArrayList(string().split("" "").map { it.toLong() })fun cout(s: String) = output.appendLine(s)fun <T> cout(s: T) = output.appendLine(s.toString())fun cout(s: IntArray) = output.appendLine(s.joinToString("" ""))fun cout(s: LongArray) = output.appendLine(s.joinToString("" ""))fun <T> cout(s: Array<T>) = output.appendLine(s.joinToString("" ""))fun <T> cout(s: Iterable<T>) = output.appendLine(s.joinToString("" ""))fun assert(x: Boolean) {    if (!x) throw AssertionError()}","data structures,greedy"
"import java.io.PrintWriterimport java.util.*import kotlin.collections.ArrayList val CONST1: Long = 998244353fun main() {    var t = 1    t = readInt()    output {        repeat(t) {            solve(it, this)        }    }}lateinit var bit:IntArrayfun getSum(ind:Int):Int{    var sum=0    var tt=ind    while(tt>0){        sum+=bit[tt]        tt -= (tt and (-tt))    }    return sum}fun update(int:Int){    var t=int    while(t<bit.size){        bit[t]++        t += (t and (-t))    }}fun solve(it: Int, out: PrintWriter) {    var n=readInt()    var arr=readInts()    bit=IntArray(2*n){0}    var temp=ArrayList<Pair<Int,Int>>()    for ((ind,i) in arr.withIndex()){        temp.add(Pair(ind,i))    }    temp.sortBy { it.second }    var ind=0    for (i in temp.indices){        if(i==0 || temp[i-1].second!=temp[i].second){            ind++        }        arr[temp[i].first]=ind    }    var count=IntArray(2*n+1){0}    var ans=0L    for ((indd,i) in arr.withIndex()){        var t=getSum(i-1)        var tt=(indd)-t-count[i]        ans+=minOf(t,tt)        count[i]++        update(i)    }    println(ans)} @JvmFieldval INPUT = System.`in` @JvmFieldval OUTPUT = System.out @JvmFieldval _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!! @JvmFieldvar _tokenizer: StringTokenizer = StringTokenizer("""") @JvmFieldval _writer = PrintWriter(OUTPUT, false)inline fun output(block: PrintWriter.() -> Unit) {    _writer.apply(block).flush()} fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()} private fun readInt() = readLn().toInt() // single intprivate fun readLong() = readLn().toLong()  // single longprivate fun readDouble() = readLn().toDouble() // single doubleprivate fun readStrings() = readLn().trim().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } as ArrayList<Int>// list of intsprivate fun readLongs() = readStrings().map { it.toLong() } as ArrayList<Long>// list of longsprivate fun readDoubles() = readStrings().map { it.toDouble() } as ArrayList<Double> // list of doubles","data structures,greedy"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.lang.reflect.Typeimport java.util.*import kotlin.math.maximport kotlin.math.minimport kotlin.reflect.typeOf fun main() {    val read = BufferedReader(InputStreamReader(System.`in`))    val n = read.readLine().toInt()    var a = read.readLine().split("" "").map { e -> e.toLong() }.toMutableList()    a.sort()    var sm = a.sum()    var m = read.readLine().toInt()    while (m-- > 0) {        var (x, y) = read.readLine().split("" "").map { e -> e.toLong() }        var l = 0        var r = n        while (l + 1 < r) {            var md = (l + r) / 2            if (a[md] <= x) {                l = md            } else {                r = md            }        }        var ans1 = max(x - a[l], 0) + max(y - (sm - a[l]), 0)        var ans2 = -1L        if (l != n - 1) {            ans2 = max(x - a[l + 1], 0) + max(y - (sm - a[l + 1]), 0)            println(min(ans1, ans2))        } else {            println(ans1)        }    }}","binary search,greedy,sortings,ternary search"
"import java.io.* fun main() {    val br = BufferedReader(InputStreamReader(System.`in`))    val bw = BufferedWriter(OutputStreamWriter(System.out))     val n = br.readLine().toInt()    val heroes = br.readLine().split("" "").map { it.toLong() }.sorted()    val sum = heroes.sum()    val m = br.readLine().toInt()    repeat(m) {        var tmp = 0L        val (x, y) = br.readLine().split("" "").map { it.toLong() }         var start = 0        var end = n - 1         while (start < end) {            val mid = (start + end) / 2            if (heroes[mid] <= x) {                start = mid + 1            } else {                end = mid            }        }        var target = start         tmp = maxOf(0, x - heroes[target]) + maxOf(0, y - (sum - heroes[target]))         if (target > 0) {            val second = target - 1            tmp = minOf(tmp, maxOf(0L, x - heroes[second]) + maxOf(0, y - (sum - heroes[second])))        }         bw.write(""$tmp"")        bw.newLine()    }     bw.flush()    bw.close()}","binary search,greedy,sortings,ternary search"
"  fun main() {    val n = readLine()!!.trim().toInt()    val heroes = readLine()!!.trim().split(' ').map(String::toLong).sorted()    val m = readLine()!!.trim().toInt()    val dragons = List(m){        val (x, y) = readLine()!!.trim().split( ' ').map(String::toLong)        x to y    }    val result = solve(heroes, dragons)    println(result.joinToString(""\n""))} fun List<Long>.lowerBound(value: Long): Int {    var min = 0    var max = size    while (min < max) {        val mid = (min + max) shr 1        if (this[mid] < value) {            min = mid + 1        }else {            max = mid        }    }    return max}fun solve(heroes: List<Long>, dragons: List<Pair<Long, Long>>): List<Long> {    val sum = heroes.sum()    val result = dragons.map{(x, y) ->        val strong = heroes.lowerBound(x)        var min = Long.MAX_VALUE        if (strong in heroes.indices) {            min = minOf(min, y - (sum - heroes[strong]))        }        val weak = strong - 1        if (weak in heroes.indices) {            min = minOf(min, maxOf(0, y - (sum - heroes[weak])) + x - heroes[weak])        }        maxOf(0, min)    }    return result}","binary search,greedy,sortings,ternary search"
"import java.io.BufferedReaderimport kotlin.math.maximport kotlin.math.min val bin = System.`in`.bufferedReader()fun BufferedReader.readInt() = this.readLine()!!.toInt()fun BufferedReader.readLongs() = this.readLine()!!.split(' ').map { it.toLong() }.toLongArray() fun main() {    bin.readInt()    val vs = bin.readLongs().sorted()    val sum = vs.sum()     val out = StringBuilder()    repeat(bin.readInt()) {        val (x, y) = bin.readLongs()         fun cost(attack: Long): Long {            val defence = sum-attack            return max(0, x-attack) + max(0, y-defence)        }         val pl = binarySearchRightmost(vs.indices) { vs[it] < x }        val opt1 = if (pl == null) Long.MAX_VALUE else cost(vs[pl])        val pr = binarySearchLeftmost(vs.indices) { vs[it] >= x }        val opt2 = if (pr == null) Long.MAX_VALUE else cost(vs[pr])        out.appendLine(min(opt1, opt2))    }    println(out)} /** * TTTTFFFF pattern, finds rightmost true value */fun binarySearchRightmost(range: IntRange, check: (Int) -> Boolean): Int? {    var l = range.first    var r = range.last+1    while (l < r) {        val m = (l + r) / 2         if (check(m)) {            l = m+1        } else {            r = m        }    }    return if (r-1 in range) r-1 else null} /** * FFFFTTTTT pattern, finds leftmost true value */fun binarySearchLeftmost(range: IntRange, check: (Int) -> Boolean): Int? {    val res = binarySearchRightmost(range) { !check(it) }    return when {        res == null -> range.first        res+1 in range -> res+1        else -> null    }}","binary search,greedy,sortings,ternary search"
"private fun solve() {	val (hei, wid) = readInts()	val a = readInts()	var ans = 0L	for (i in a.indices) {		for (j in 0 until i) {			if (a[j] < a[i]) ans++		}	}	println(ans)} fun main() = repeat(readInt()) { solve() } private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","data structures,greedy,sortings"
"import java.io.BufferedReaderimport java.io.PrintWriter val bin = System.`in`.bufferedReader()fun BufferedReader.readInt() = this.readLine()!!.toInt()fun BufferedReader.readInts() = this.readLine()!!.split(' ').map { it.toInt() }.toIntArray() fun main() {    repeat(bin.readInt()) {        val (_, m) = bin.readInts()        val vs = bin.readInts()        println(solve(vs))    }} fun solve(vs: IntArray): Int {    val seated = mutableListOf<Int>()    var res = 0    for (v in vs) {        res += seated.count { it < v }        seated.add(v)    }    return res}","data structures,greedy,sortings"
"import java.util.* fun main() {    val t = readLine()!!.toInt()    repeat(t) {        val (n, m) = readLine()!!.split("" "").map{it.toInt()}        // n rows, m columns        val a = readLine()!!.split("" "").map{it.toInt()} // size n*m        println(solve(n, m, a))    }} fun solve(n: Int, m: Int, a: List<Int>): Int {    // pair (person index i (0-), sight (a_i))    val p = List<Pair<Int, Int>>(n * m) {        Pair(it, a[it])    }    // person i's seat index    val seats = p.sortedWith { p1, p2 ->        when {            p1.second != p2.second -> p1.second - p2.second            else -> p2.first - p1.first        }    }.map { it.first }    // count    var total = 0    val set = TreeSet<Int>()    seats.forEach {        set.add(it)        total += set.indexOf(it)    }    return total}","data structures,greedy,sortings"
"import java.util.* fun main() {    repeat(readLine()!!.toInt()) {        val (n, m) = readLine()!!.split("" "").map { it.toInt() }        val sightLevels = readLine()!!.split("" "").map { it.toInt() }        val disp = mutableMapOf<Int, ArrayDeque<Int>>()        val people = (0 until n * m).sortedBy { sightLevels[it] }        for (y in 0 until n) {            for (x in m - 1 downTo 0) {                val k = (m * y) + x                disp.computeIfAbsent(sightLevels[people[k]]) { ArrayDeque() }.addLast(k)            }        }        val rows = Array(n) { ArrayDeque<Int>() }        var answer = 0        for (k in 0 until n * m) {            val seat = disp[sightLevels[k]]!!.removeFirst()            for (alreadyThere in rows[seat / m]) {                if (alreadyThere < seat) {                    answer++                }            }            rows[seat / m].add(seat)        }        println(answer)    }}","data structures,greedy,sortings"
"import java.util.*import kotlin.math.maximport kotlin.math.min fun main() {    repeat(readLine()!!.toInt()) {        val (W, H) = readLine()!!.split("" "").map { it.toInt() }        val (x1, y1, x2, y2) = readLine()!!.split("" "").map { it.toInt() }        val (w, h) = readLine()!!.split("" "").map { it.toInt() }         val totalWidth = x2 - x1 + w        val totalHeight = y2 - y1 + h         var res = Int.MAX_VALUE         if (totalHeight <= H) {            res = min(res, min(max(h - H + y2, 0), max(h - y1, 0)))        }         if (totalWidth <= W) {            res = min(res, min(max(w - W + x2, 0), max(w - x1, 0)))        }         println(if (res == Int.MAX_VALUE) -1 else res )    }}",brute force
"import java.util.* fun main() {    repeat(readLine()!!.toInt()) {        val (W, H) = readLine()!!.split("" "").map { it.toDouble() }        val (x1, y1, x2, y2) = readLine()!!.split("" "").map { it.toDouble() }        val (w, h) = readLine()!!.split("" "").map { it.toDouble() }         val totalWidth = x2 - x1 + w        val totalHeight = y2 - y1 + h        val moveVertical = minOf(maxOf(h - H + y2, 0.0), maxOf(h - y1, 0.0))        val moveHorizontal = minOf(maxOf(w - W + x2, 0.0), maxOf(w - x1, 0.0))        when {            totalWidth > W && totalHeight > H -> {                println(-1)            }            totalWidth > W -> {                println(moveVertical)            }            totalHeight > H -> {                println(moveHorizontal)            }            else -> {                println(minOf(moveVertical, moveHorizontal))            }        }    }}",brute force
"import java.io.BufferedReaderimport java.io.PrintWriterimport kotlin.math.maximport kotlin.math.min val bin = System.`in`.bufferedReader()fun BufferedReader.readInt() = this.readLine()!!.toInt()fun BufferedReader.readInts() = this.readLine()!!.split(' ').map { it.toInt() }.toIntArray() fun main() {    repeat(bin.readInt()) {        val (rw, rh) = bin.readInts()        val (x1, y1, x2, y2) = bin.readInts()        val (tw, th) = bin.readInts()        val totalW = tw + (x2-x1)        val totalH = th + (y2-y1)         val opts = mutableListOf<Int>()        if (totalW <= rw) {            // left            opts.add(max(0, tw - x1))            // right            opts.add(max(0, tw - (rw - x2)))        }        if (totalH <= rh) {            // up            opts.add(max(0, th - y1))            // down            opts.add(max(0, th - (rh - y2)))        }         println(opts.minOrNull() ?: -1)    }}",brute force
"import kotlin.math.min fun main() {    repeat(readLine()!!.toInt()) {        val (w, h) = readLine()!!.split("" "").map { it.toInt() }        val (x1, y1, x2, y2) = readLine()!!.split("" "").map { it.toInt() }        val (a, b) = readLine()!!.split("" "").map { it.toInt() }        var answer = Int.MAX_VALUE        if (x1 > a) {            answer = 0        } else if (x2 + (a - x1) <= w) {            answer = min(answer, a - x1)        }        if (y1 > b) {            answer = 0        } else if (y2 + (b - y1) <= h) {            answer = min(answer, b - y1)        }        if (x2 + a <= w) {            answer = 0        } else if (x1 - (a - (w - x2)) >= 0) {            answer = min(answer, a - (w - x2))        }        if (y2 + b <= h) {            answer = 0        } else if (y1 - (b - (h - y2)) >= 0) {            answer = min(answer, b - (h - y2))        }        if (answer == Int.MAX_VALUE) {            answer = -1        }        println(answer)    }}",brute force
"fun main() {  Array(readLine()!!.toInt()) {    val (moreThanOne, single) = readLine()!!.groupingBy { it }.eachCount().entries.partition { it.value > 1 }     moreThanOne.size + single.size / 2  }.forEach { println(it) }}","greedy,strings"
import java.util.* fun main(args: Array<String>) = with(Scanner(System.`in`)) {    val t = nextInt()//    val t = 1    repeat(t) {        val chars = next().groupingBy { it }.eachCount().values        val multiples = chars.filter { it > 1 }.size        val res = multiples + (chars.size - multiples) / 2        println(res)    }} ,"greedy,strings"
fun main(){    var t  = readLine()!!.toInt()    var s:String    var len:Int    var arr: IntArray    while(t-->0){        arr  = IntArray(128){0}        s = readLine()!!        len = s.length        for(i in s){            if(arr[i.toInt()]<2)                arr[i.toInt()]++            else                len--        }        println(len/2)    }},"greedy,strings"
fun main() {    repeat(readLine()!!.toInt()) {        val s = readLine()!!        val cnt = IntArray(26)        for (c in s) cnt[c - 'a']++        val cnt1 = cnt.indices.count { cnt[it] == 1 }        val cnt2 = cnt.indices.count { cnt[it] > 1 }        for (hint in 26 downTo 0) {            if (cnt1 >= 2 * (hint - cnt2)) return@repeat println(hint)        }    }},"greedy,strings"
"fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()        println(""${(n / 3) + (if (n % 3 == 1) 1 else 0)} ${(n / 3) + (if (n % 3 == 2) 1 else 0)}"")    }}","greedy,math"
"fun main() {    repeat(readLine()!!. toInt())    {        var x= readLine()!!. toInt()        var n: Int =x/3        var m= n        if(x%3==1)            n++        else if(x%3==2)            m++        println(""$n $m"")    }}","greedy,math"
"fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()        when (n % 3) {            0 -> println(""${n / 3} ${n / 3}"")            1 -> println(""${n / 3 + 1} ${n / 3}"")            2 -> println(""${n / 3} ${n / 3 + 1}"")        }    }}","greedy,math"
"fun main() {  Array(readLine()!!.toInt()) {    val amount = readLine()!!.toInt()     val count = amount / 3    when (amount - (3 * count)) {      0 -> ""$count $count""      1 -> ""${count + 1} $count""      else -> ""$count ${count + 1}""    }  }.forEach { println(it) }}","greedy,math"
"import java.io.BufferedInputStreamimport java.util.* fun main() {    val jin = FastScanner()    val out = StringBuilder()    repeat(jin.nextInt()) {        val n = jin.nextInt()        val adj = Array(1 shl n) { mutableListOf<Int>() }        repeat(n * (1 shl (n - 1))) {            val a = jin.nextInt()            val b = jin.nextInt()            adj[a].add(b)            adj[b].add(a)        }        val position = IntArray(1 shl n)        val dist = IntArray(1 shl n) { -1 }        dist[0] = 0        val q = LinkedList<Int>()        q.add(0)        var disp = 1        val permutation = IntArray(1 shl n)        while (q.isNotEmpty()) {            val a = q.remove()            permutation[position[a]] = a            for (b in adj[a]) {                if (dist[b] == -1 || dist[b] == dist[a] + 1) {                    if (dist[b] == -1) {                        dist[b] = dist[a] + 1                        q.add(b)                    }                    if (a == 0) {                        position[b] = disp                        disp *= 2                    } else {                        position[b] = position[b] or position[a]                    }                }            }        }        out.appendln(permutation.joinToString("" ""))        if ((1 shl n) % n == 0) {            val coloring = IntArray(1 shl n)            for (mask in 0 until (1 shl n)) {                val position = (mask - (mask and 1)) + (Integer.bitCount(mask) and 1)                var color = 0                for (j in 1 until n) {                    if ((mask shr j) and 1 == 1) {                        color = color xor j                    }                }                coloring[permutation[position]] = color            }            out.appendln(coloring.joinToString("" ""))        } else {            out.appendln(-1)        }    }    print(out)} class FastScanner {    private val BS = 1 shl 16    private val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC    private var `in`: BufferedInputStream? = null     constructor() {        `in` = BufferedInputStream(System.`in`, BS)    }     private val char: Char        private get() {            while (bId == size) {                size = try {                    `in`!!.read(buf)                } catch (e: Exception) {                    return NC                }                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c >= '0' && c <= '9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }}","bitmasks,constructive algorithms,divide and conquer,graphs,greedy,math"
"import java.util.*import kotlin.math.* const val mod = 1_000_000_007 fun solve() {    val n = readLine()!!.toInt()    val inv = LongArray(n + 1) { 1L }    val fact = LongArray(n + 1) { 1L }    val invfact = LongArray(n + 1) { 1L }    for (i in 2..n) {        inv[i] = mod - inv[mod % i] * (mod / i) % mod        fact[i] = fact[i - 1] * i % mod        invfact[i] = invfact[i - 1] * inv[i] % mod    }     fun choose(n: Int, k: Int): Long = fact[n] * invfact[k] % mod * invfact[n - k] % mod    var ans = 0L    if (n % 2 == 0) {        ans += 2 * fact[n]    }    for (k in (2 - n%2)..(n/2) step 2) {        ans += (choose(n - k, k) + choose(n - 1 - k, k - 1)) * 2 % mod * fact[n - k] % mod    }    println(ans % mod)} fun main() {    val t = 1 // readLine()!!.toInt()    repeat (t) {        solve()    }}","chinese remainder theorem,combinatorics,constructive algorithms,fft,games,geometry,math,meet-in-the-middle,string suffix structures"
"const val MOD = 1000000007L fun main() {    val n = readLine()!!.toInt()    val factorial = LongArray(n + 1)    factorial[0] = 1L    for (j in 1..n) {        factorial[j] = (j.toLong() * factorial[j - 1]) % MOD    }    val invFactorial = LongArray(n + 1)    invFactorial[n] = factorial[n] pow -1    for (j in n - 1 downTo 0) {        invFactorial[j] = ((j + 1).toLong() * invFactorial[j + 1]) % MOD    }    fun choose(a: Int, b: Int) = if (b in 0..a) ((factorial[a] * ((invFactorial[b] * invFactorial[a - b]) % MOD)) % MOD) else 0L    var answer = 0L    for (k in 0..n step 2) {        answer += factorial[k] * (choose(k, n - k) + choose(k - 1, n - k - 1))        answer %= MOD    }    answer *= 2L    answer %= MOD    println(answer)} const val MOD_TOTIENT = MOD.toInt() - 1 infix fun Long.pow(power: Int): Long {    var e = power    e %= MOD_TOTIENT    if (e < 0) {        e += MOD_TOTIENT    }    if (e == 0 && this == 0L) {        return this    }    var b = this % MOD    var res = 1L    while (e > 0) {        if (e and 1 != 0) {            res *= b            res %= MOD        }        b *= b        b %= MOD        e = e shr 1    }    return res}","chinese remainder theorem,combinatorics,constructive algorithms,fft,games,geometry,math,meet-in-the-middle,string suffix structures"
"const val MOD = 1000000007L fun main() {    val n = readLine()!!.toInt()    val factorial = LongArray(n + 1)    factorial[0] = 1L    for (j in 1..n) {        factorial[j] = (j.toLong() * factorial[j - 1]) % MOD    }    val invFactorial = LongArray(n + 1)    invFactorial[n] = factorial[n] pow -1    for (j in n - 1 downTo 0) {        invFactorial[j] = ((j + 1).toLong() * invFactorial[j + 1]) % MOD    }    fun choose(a: Int, b: Int) = if (b in 0..a) ((factorial[a] * ((invFactorial[b] * invFactorial[a - b]) % MOD)) % MOD) else 0L    var answer = 0L    for (k in 0..n step 2) {        answer += factorial[k] * (choose(k, n - k) + choose(k - 1, n - k - 1))        answer %= MOD    }    answer *= 2L    answer %= MOD    println(answer)} object Factorials {    val factorials = mutableListOf<Long>()    val invFactorials = mutableListOf<Long>()     var amt = 0     init {        factorials.add(1L)        invFactorials.add(1L)    }     fun update(newAMT: Int) {        if (newAMT > amt) {            for (k in amt + 1..newAMT) {                factorials.add((k.toLong() * factorials[k - 1]) % MOD)                invFactorials.add(0L)            }            invFactorials[newAMT] = factorials[newAMT] pow -1            for (k in newAMT - 1 downTo amt + 1) {                invFactorials[k] = ((k + 1).toLong() * invFactorials[k + 1]) % MOD            }        }    }} fun factorial(k: Int): Long {    Factorials.update(k)    return Factorials.factorials[k]} fun invFactorial(k: Int): Long {    Factorials.update(k)    return Factorials.invFactorials[k]} fun choose(a: Int, b: Int) = if (b in 0..a) (factorial(a) * ((factorial(b) * factorial(a - b)) % MOD)) % MOD else 0L const val MOD_TOTIENT = MOD.toInt() - 1 infix fun Long.pow(power: Int): Long {    var e = power    e %= MOD_TOTIENT    if (e < 0) {        e += MOD_TOTIENT    }    if (e == 0 && this == 0L) {        return this    }    var b = this % MOD    var res = 1L    while (e > 0) {        if (e and 1 != 0) {            res *= b            res %= MOD        }        b *= b        b %= MOD        e = e shr 1    }    return res}","chinese remainder theorem,combinatorics,constructive algorithms,fft,games,geometry,math,meet-in-the-middle,string suffix structures"
"// 2022-05-2, Mon, 23:33import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.system.measureTimeMillis // 1. Moddedconst val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}infix fun Int.modM(b:Int):Int{ return ((this.toLong() * b) % pI).toInt() }infix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }fun intPow(x:Int,e:Int,m:Int):Int{    var X = x ; var E =e ; var Y = 1    while(E > 0){        if(E and 1 == 0){            X = ((1L * X * X) % m).toInt()            E = E shr 1        }else{            Y = ((1L * X * Y) % m).toInt()            E -= 1        }    }    return Y}// 2. DP initial valuesconst val plarge = 1_000_000_727const val nlarge = -plargeconst val phuge = 2_727_000_000_000_000_000Lconst val nhuge = -phuge// 3. conveniecen conversionsval Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionval Char.code :Int get() = this.toInt() -  'a'.toInt()//3. hard to write stufffun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val mint:MutableList<Int> get() = mutableListOf<Int>()val mong:MutableList<Long> get() = mutableListOf<Long>()//4. more outputsfun List<Char>.conca():String = this.joinToString("""")val CharArray.conca :String get() = this.joinToString("""")val IntArray.conca :String get() = this.joinToString("" "")@JvmName(""concaInt"")fun List<Int>.conca():String = this.joinToString("" "")val LongArray.conca:String get() = this.joinToString("" "")@JvmName(""concaLong"")fun List<Long>.conca():String = this.joinToString("" "")//5. Pair of intsconst val longmask = (1L shl 32) - 1fun makepair(a:Int, b:Int):Long = (a.toLong() shl 32) xor (longmask and b.toLong()) // remember positev sonlyval Long.first get() = (this ushr 32).toInt()val Long.second get() = this.toInt()//6. stringsval String.size get() = this.lengthconst val randCount = 100//7. bitsfun Int.has(i:Int):Boolean = (this and (1 shl i) != 0)//8 TIMEinline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")}object Reader{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""Custom test enabled"")            println(""Custom test enabled"")            warningActive = false        }        val S = fakein.toString()        println(""New Case "")        println(S.take(80))        println(""..."")        fakein.clear()        IN = BufferedInputStream(S.byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ Reader.OUT.println(aa)}fun done(){ Reader.OUT.close() }fun share(aa:Any){    if(aa is IntArray){Reader.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){Reader.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){Reader.fakein.append(aa.toString())}    else{Reader.fakein.append(aa.toString())}    Reader.fakein.append(""\n"")} val getintfast:Int get() = Reader.nextInt()val getint:Int get(){ val ans = getlong ; if(ans > Int.MAX_VALUE) IntArray(1000000000); return ans.toInt() }val getlong:Long get() = Reader.nextLong()val getstr:String get() = Reader.nextString()fun getline(n:Int):IntArray{    return IntArray(n){getint}}fun getlineL(n:Int):LongArray{    return LongArray(n){getlong}}var dmark = -1infix fun Any.dei(a:Any){    dmark++    var str = ""<${dmark}>   ""    debug()    if(this is String){ str += this    }else if(this is Int){ str += this.toString()    }else if(this is Long){ str += this.toString()    }else{ str += this.toString()}    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is BooleanArray){ println(""$str :${a.map{if(it)'1' else '0'}.joinToString("" "")}"")    }else if(a is Array<*>){        println(""$str : "")        for(c in a){if(c is IntArray){println(c.joinToString("" ""))}        else if(c is LongArray){println(c.joinToString("" ""))}        else if(c is BooleanArray){println(c.map { if(it) '1' else '0' }.joinToString(""""))        }        }        println()    }else{ println(""$str : $a"")    }}val just = "" ""fun crash(){    throw Exception(""Bad programme"")}fun assert(a:Boolean){    if(!a){        throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var tn:Long = 0    fun cases(onecase:()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint} else if(mode == solveMode.tc){1 } else randCount        if(pI != 998_244_353 && pI != 1_000_000_007){            throw Exception(""Not usual primes!"")        }        if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                Reader.rerouteInput()            }else if(mode == solveMode.rand){                rand()                Reader.rerouteInput()            }            onecase()        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }}infix fun Int.divceil(b:Int):Int{    //Positives numbers only!    if(this == 0) {        return 0    }    return (this-1)/b + 1}infix fun Long.divceil(b:Long):Long{    //Positives numbers only!    if(this == 0L) {        return 0    }    return (this-1)/b + 1} infix fun Long.modM(b:Long):Long{    return (this * b) % p}//infix fun Int.modPlus(b:Int):Int{//    val ans = this + b//    return if(ans >= pI) ans - pI else ans//}infix fun Int.modMinus(b:Int):Int{    val ans = this - b    return if(ans < 0) ans + pI else ans}infix fun Int.modDivide(b:Int):Int{    return this modM (b.inverse())}fun Int.additiveInverse():Int{    return if(this == 0) 0 else pI - this} fun intPowEXP(x:Int,e:Long,m:Int):Int{    var X = x    var E =e    var Y = 1    while(E > 0){        if(E % 2 == 0L){            X = ((1L * X * X) % m).toInt()            E = E shr 1        }else{            Y = ((1L * X * Y) % m).toInt()            E -= 1        }    }    return Y} fun pow(x:Long,e:Long,m:Long):Long{    var X = x    var E =e    var Y = 1L    while(E > 0){        if(E % 2 == 0L){            X = (X * X) % m            E /= 2        }else{            Y = (X * Y) % m            E -= 1        }    }    return Y}fun Long.inverse():Long{    return pow(this,p-2,p)}fun Int.inverse():Int{    return intPow(this,pI-2,pI)}fun min_rem(m:Int, r:Int, c:Int):Int {    if(c < 1){        return Int.MIN_VALUE    }else if(r == 0){        return 0    }else{        val step = m % r        val mx = ((1L * c * r) /m ).toInt()        val t = max_rem(r,step,mx)        return r- t    }}fun max_rem(m:Int, r:Int, c:Int):Int {    if(r == 0|| c <= m/r){        return r * c    }else{        val step =  m % r        val mx = ((1L * (c+1) * r )/m).toInt()        val t = min_rem(r,step,mx)        return  m - t    }}fun Int.reconstruct():String{    val num = min_rem(pI,this, 10000)    val denom = (this modDivide num).inverse()    return ""$num / $denom""} //make this int insteadclass FACT{    companion object {        var store = IntArray(0)        var invStore = IntArray(0)         var slowStore:IntArray = IntArray(0)         fun preCal(upto:Int){            store = IntArray(upto+1)            invStore = IntArray(upto + 1 )            store[0] = 1            invStore[0] = 1             for(i in 1..upto) {                store[i] = store[i-1] modM i                invStore[i] = invStore[i-1] modM (i.inverse())            }        }        fun choose(n:Int,r:Int):Int{            if(r < 0 || r > n) return 0            val a = store[n]            val b = invStore[n-r]            val c = invStore[r]            return (a modM b) modM c        }         fun bigChoose(n:Int,r:Int):Int{            var ret = 1            for(i in 0 until r){                ret = ret modM (n - i)            }            ret = ret modM (invStore[r])            return ret        }     }} fun debug(){}const val singleCase = truefun main(){    FACT.preCal(1000005)     solve.cases{        val n = getint         var ret = 0        for(space in 0..n){            val chars = n - space            if(chars <= 0) continue            if(chars %2 != 0 ) continue            if(chars < space) continue            val have = FACT.choose(chars,space) modM FACT.store[chars - 1]            ret = ret modPlus have        }        put(ret modM 2 modM n) //        var DP = IntArray(4)//        DP[0] = 1//        repeat(n){//            val (a,b,a_,b_) = DP//            val new = intArrayOf(a + a_, b + b_, a, b)//            DP = new//        }//        val ans = DP[0]          }    done()}   ","chinese remainder theorem,combinatorics,constructive algorithms,fft,games,geometry,math,meet-in-the-middle,string suffix structures"
"import kotlin.math.min fun main() {    val (q, x1, y1) = readLine()!!.split("" "").map { it.toInt() }    val tons = LongArray(q + 2)    val costs = LongArray(q + 2)    tons[1] = x1.toLong()    costs[1] = y1.toLong()    val ancestors = Array(q + 2) { IntArray(19) }    val depth = IntArray(q + 2)    fun ancestor(a: Int, d: Int): Int {        var res = a        for (j in 18 downTo 0) {            if (1 shl j <= depth[res] - d) {                res = ancestors[res][j]            }        }        return res    }    fun highestAncestorDepth(a: Int): Int {        var a = a        for (j in 18 downTo 0) {            if (tons[ancestors[a][j]] > 0L) {                a = ancestors[a][j]            }        }        return depth[a]    }    for (a in 2..q + 1) {        val line = readLine()!!.split("" "").map { it.toInt() }        if (line[0] == 1) {            val (_, parent, x, y) = line            ancestors[a][0] = parent + 1            for (j in 1..18) {                ancestors[a][j] = ancestors[ancestors[a][j - 1]][j - 1]            }            depth[a] = depth[parent + 1] + 1            tons[a] = x.toLong()            costs[a] = y.toLong()        } else {            var (_, b, w) = line            b++            var amt = w.toLong()            var amtBought = 0L            var spent = 0L            for (d in highestAncestorDepth(b)..depth[b]) {                val c = ancestor(b, d)                val here = min(amt, tons[c])                amt -= here                tons[c] -= here                amtBought += here                spent += costs[c] * here                if (amt == 0L) {                    break                }            }            println(""$amtBought $spent"")        }    }}","binary search,data structures,dp,greedy,interactive,trees"
"import java.lang.AssertionErrorimport java.math.BigIntegerimport java.util.* val readQueue = ArrayDeque<String>()fun getInput(): String {    if (readQueue.isEmpty()) readLine()!!.split(' ', '\n').let{ readQueue.addAll(it) }    return readQueue.pop()} fun getInt() = getInput().toInt()fun getLong() = getInput().toLong()fun getString() = getInput() const val MOD107 = 1000000007Lconst val MOD998 = 998244353Lfun myAssert(b : Boolean) {    if (!b) throw AssertionError()} fun main() {    var q = getInt()     var nodes = MutableList<Array<Int>>(q + 1) { arrayOf(0, 0) }    nodes[0] = arrayOf(getInt(), getInt())     val MAXJ = 20    var jump = MutableList<MutableList<Int>>(MAXJ) { MutableList<Int>(q + 1) { -1 } }     fun find(u : Int) : Int {        var ans = u        for (i in MAXJ - 1 downTo 0)            if (jump[i][ans] != -1 && nodes[jump[i][ans]][0] > 0)                ans = jump[i][ans]         return ans    }     for (qry in 1 .. q) {        var cmd = getInt()        if (cmd == 1) {            jump[0][qry] = getInt()            for (i in 1 until MAXJ)                if (jump[i - 1][qry] != -1)                    jump[i][qry] = jump[i - 1][jump[i - 1][qry]]             nodes[qry] = arrayOf(getInt(), getInt())        }        else if (cmd == 2) {            var (u, w) = arrayOf(getInt(), getInt())            var ans = 0L            var cnt = 0            while (nodes[u][0] > 0 && w > 0) {                var v = find(u)                var take = minOf(w, nodes[v][0])                w -= take                nodes[v][0] -= take                cnt += take                 ans += 1L * take * nodes[v][1]            }             println(""$cnt $ans"")        }        else myAssert(false)    }}","binary search,data structures,dp,greedy,interactive,trees"
"import kotlin.math.min fun main() {    val (q, x1, y1) = readLine()!!.split("" "").map { it.toInt() }    val tons = LongArray(q + 2)    val costs = LongArray(q + 2)    tons[1] = x1.toLong()    costs[1] = y1.toLong()    val ancestors = Array(q + 2) { IntArray(19) }    val depth = IntArray(q + 2)    fun ancestor(a: Int, d: Int): Int {        var res = a        for (j in 18 downTo 0) {            if (1 shl j <= depth[res] - d) {                res = ancestors[res][j]            }        }        return res    }    fun highestAncestorDepth(a: Int): Int {        var a = a        for (j in 18 downTo 0) {            if (tons[ancestors[a][j]] > 0L) {                a = ancestors[a][j]            }        }        return depth[a]    }    for (a in 2..q + 1) {        val line = readLine()!!.split("" "").map { it.toInt() }        if (line[0] == 1) {            val (_, parent, x, y) = line            ancestors[a][0] = parent + 1            for (j in 1..18) {                ancestors[a][j] = ancestors[ancestors[a][j - 1]][j - 1]            }            depth[a] = depth[parent + 1] + 1            tons[a] = x.toLong()            costs[a] = y.toLong()        } else {            var (_, b, w) = line            b++            var amt = w.toLong()            var amtBought = 0L            var spent = 0L            for (d in highestAncestorDepth(b)..depth[b]) {                val c = ancestor(b, d)                val here = min(amt, tons[c])                amt -= here                tons[c] -= here                amtBought += here                spent += costs[c] * here                if (amt == 0L) {                    break                }            }            println(""$amtBought $spent"")        }    }}","binary search,data structures,dp,greedy,interactive,trees"
"import kotlin.math.*import kotlin.collections.* fun readLn() = readLine()!!fun readStrings() = readLn().split("" "")fun readInt() = readLn().toInt()fun readInts() = readStrings().map { it.toInt() }fun readLong() = readLn().toLong()fun readLongs() = readStrings().map { it.toLong() } fun gcd(a: Long, b: Long): Long {    if (b == 0L) {        return a    }    return gcd(b, a%b)} var N = 300300var LG = 19var par = Array<IntArray>(N, {_ -> IntArray(LG)})var c = LongArray(N)var a = LongArray(N)var dep = IntArray(N)//var totalCount = LongArray(N)//var totalCost = LongArray(N)var adj = Array<ArrayList<Int>>(N, {_ -> ArrayList<Int>()}) fun addBelow(u: Int, p: Int, ai: Long, ci: Long) {    par[u][0] = p    for (l in 0..(LG-2)) {        par[u][l+1] = par[par[u][l]][l]    }    dep[u] = dep[p]+1;    c[u] = ci    a[u] = ai    //totalCount[u] = totalCount[p] + ai    //totalCost[u] = totalCost[p] + ai*ci} fun main() {    var (q, a0, c0) = readInts()    addBelow(1, 0, a0.toLong(), c0.toLong())    for (qidx in 2..(q+1)) {        var vals = readInts()        when (vals[0]) {            1 -> {                var (_, pi, ai, ci) = vals                addBelow(qidx, pi+1, ai.toLong(), ci.toLong())            }            2 -> {                var (_, vi, wi) = vals                ++vi                var taken = 0                var totcost = 0L                while (taken < wi) {                    var u = vi                    for (l in (LG-1) downTo 0) {                        if (a[par[u][l]] != 0L) {                            u = par[u][l]                        }                    }                    var take = min(a[u].toInt(), wi-taken)                    taken += take                    a[u] -= take.toLong()                    totcost += take*c[u]                    if (u == vi) {                        break                    }                }                println(""$taken $totcost"")            }        }    }}","binary search,data structures,dp,greedy,interactive,trees"
"import java.util.* fun main() {    val (n, k) = readLine()!!.split("" "").map { it.toInt() }    if (n % 2 == 1 && k % 2 == 0) {        println(-1)    } else {        var answer = 0        fun query(indexes: Iterable<Int>) {            println(""? ${indexes.joinToString("" "")}"")            answer = answer xor readLine()!!.toInt()        }        val amts = IntArray(n + 1) { 1 }        if (n % k != 0) {            var total = n            outer@for (m in 3..n step 2) {                for (j in 1..n) {                    amts[j] = m                    total += 2                    if (total % k == 0 && m <= total / k) {                        break@outer                    }                }            }        }        val pq = PriorityQueue<Int>(compareByDescending { amts[it] })        pq.addAll(1..n)        while (pq.isNotEmpty()) {            val query = mutableListOf<Int>()            repeat(k) {                val j = pq.remove()                amts[j]--                query.add(j)            }            query(query)            for (j in query) {                if (amts[j] > 0) {                    pq.add(j)                }            }        }        println(""! $answer"")    }}","graphs,greedy,interactive,shortest paths"
"fun main() {    val br = System.`in`.bufferedReader()    val (n, k) = br.readLine().split("" "").map { it.toInt() }    val processed = BooleanArray(n + 1)    val prev = IntArray(n + 1) { -1 }    val queue = ArrayDeque<Int>()    queue.addLast(0)    processed[0] = true    while (queue.isNotEmpty()) {        val numKnown = queue.removeFirst()        val numUnknown = n - numKnown        for (x in 0..k) {            if (x > numKnown || (k - x) > numUnknown) continue            val newState = numKnown + k - 2 * x            if (!processed[newState]) {                processed[newState] = true                queue.addLast(newState)                prev[newState] = numKnown            }        }    }    if (processed.last()) {        var ans = 0        val unknownIdx = MutableList(n) { x -> x + 1 }        val knownIdx = mutableListOf<Int>()        while (unknownIdx.isNotEmpty()) {            val prevUnknown = prev[unknownIdx.size]            val (unknownToQuery, knownToQuery) = if (prevUnknown - unknownIdx.size > 0) {                val shared = (k - prevUnknown + unknownIdx.size) shr 1                shared to shared + prevUnknown - unknownIdx.size            } else {                val shared = (k + prevUnknown - unknownIdx.size) shr 1                shared + unknownIdx.size - prevUnknown to shared            }            val toQueryA = mutableListOf<Int>()            val toQueryB = mutableListOf<Int>()            repeat(unknownToQuery) {                toQueryA += unknownIdx.removeLast()            }            repeat(knownToQuery) {                toQueryB += knownIdx.removeLast()            }            println(""? ${toQueryA.joinToString("" "")} ${toQueryB.joinToString("" "")}"")            ans = ans xor br.readLine().toInt()            unknownIdx.addAll(toQueryB)            knownIdx.addAll(toQueryA)        }        println(""! $ans"")    } else {        println(-1)    } }","graphs,greedy,interactive,shortest paths"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"")@file:OptIn(ExperimentalUnsignedTypes::class, ExperimentalStdlibApi::class) import java.io.PrintWriterimport java.lang.StringBuilderimport java.util.Arraysimport java.util.NoSuchElementExceptionimport java.util.TreeSetimport kotlin.math.*import kotlin.random.Randomimport kotlin.system.exitProcessimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {//    val startTime = System.nanoTime()     val numCases = 1//readInt()     case@ for(case in 1..numCases) {    //    print(""Case #$case: "")         object {            val n = readInt()            val k = readInt()             fun ask(b: IntList): Int {                print('?')                for(e in b) {                    print(' ')                    print(e+1)                }                println()                flush()                 return readInt()            }             fun f(j: Int) = k - j - j             init {                val D = IntArray(n+1) { inf }                D[0] = 0                val P = IntArray(n+1)                 val q = IntDeque()                q.add(0)                bfs@ while(q.isNotEmpty()) {                    val u = q.remove()                    for(j in max(0, u+k-n)..min(u,k)) {                        val v = u + f(j)                        if(D.setMin(v, D[u]+1)) {                            P[v] = j                            if(v == n) break@bfs                            q.add(v)                        }                    }                }                 if(D[n] == inf) println(-1)                else {                    val J = IntList()                    var c = n                    while(c != 0) {                        val j = P[c]                        J.add(j)                        c -= f(j)                    }                    J.reverse()                     var ans = 0                    val in_ = IntList(n)                    val out = IntList(n) { it }                     for(j in J) {                        val b = IntList(k)                        repeat(j) { b.add(in_.pop()) }                        repeat(k-j) { b.add(out.pop()) }                         ans = ans xor ask(b)                         repeat(k-j) { in_.add(b.pop()) }                        repeat(j) { out.add(b.pop()) }                    }                     print(""! "")                    println(ans)                }            }        }     } //    iprintln(""Time: ${(System.nanoTime() - startTime) / 1000000} ms"")} const val inf = Int.MAX_VALUE fun IntArray.setMin(i: Int, v: Int) = if(v < get(i)) { set(i, v); true } else false class IntList(initialCapacity: Int = 12) {    private var arr = IntArray(initialCapacity)    val _arr get() = arr    private val capacity get() = arr.size    var size = 0        private set    inline val lastIndex get() = size - 1    inline val indices get() = 0 until size     constructor(copyFrom: IntArray): this(copyFrom.size) { copyFrom.copyInto(arr); size = copyFrom.size }    constructor(copyFrom: Collection<Int>): this(copyFrom.size) { arr = copyFrom.toIntArray(); size = copyFrom.size }     fun contentEquals(other: IntList): Boolean {        return this === other || size == other.size && indices.all { this[it] == other[it] }    }     private fun grow(minCapacity: Int = 8) {        val newCapacity = maxOf(minCapacity, capacity + (capacity shr 1))        arr = arr.copyOf(newCapacity)    }     fun ensureCapacity(minCapacity: Int) { if(capacity < minCapacity) grow(minCapacity) }     operator fun get(index: Int): Int {        require(index in 0 until size)        return arr[index]    }     operator fun set(index: Int, value: Int) {        require(index in 0 until size)        arr[index] = value    }     fun add(value: Int) {        if(size == capacity) grow()        arr[size++] = value    }     fun addAll(list: IntList) {        ensureCapacity(size + list.size)        list.arr.copyInto(arr, size, 0, list.size)        size += list.size    }     fun add(index: Int, element: Int) {        if(size == capacity) grow()        arr.copyInto(arr, index + 1, index, size)        size++        set(index, element)    }     fun clear() { size = 0 }     fun removeAt(index: Int): Int {        val e = get(index)        arr.copyInto(arr, index, index + 1, size)        size--        return e    }     fun indexOf(e: Int): Int {        for(i in 0 until size) if(this[i] == e) return i        return -1    }     fun remove(e: Int): Boolean {        val i = indexOf(e)        if(i == -1) return false        removeAt(i)        return true    }     operator fun iterator() = object: IntIterator() {        private var pos = 0        override fun hasNext() = pos < size        override fun nextInt() = get(pos++)    }     inline fun isEmpty() = size == 0    inline fun isNotEmpty() = size != 0     fun pop() = arr[--size]     fun popToSize(s: Int) {        require(s >= 0)        if(s < size) size = s    }     fun swap(i: Int, j: Int) { val t = this[i]; this[i] = this[j]; this[j] = t }    fun reverse() {        for(i in 0 until size / 2) swap(i, lastIndex - i)    }     fun shuffle(rnd: Random = random) { for(i in lastIndex downTo 1) swap(i, rnd.nextInt(i+1)) }     inline fun sortWith(cmp: (Int, Int) -> Int) { _mergeSort(_arr, size, IntArray(size), IntArray::get, IntArray::set, cmp) }    inline fun <T: Comparable<T>> sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }    inline fun <T: Comparable<T>> sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }    fun sort() { sortBy { it } }    fun sortDescending() { sortByDescending { it } }     fun joinToString(separator: CharSequence) = if(size == 0) """" else let {        buildString {            append(it[0])            for (i in 1 until size) {                append(separator).append(it[i])            }        }    }     override fun toString() = ""["" + joinToString("", "") + ""]""     fun toIntArray() = arr.copyOf(size)    fun toList() = List(size, ::get)     inline fun first() = get(0)    inline fun last() = get(lastIndex)} inline fun IntList(size: Int, init: (Int) -> Int) = IntList(size).apply {    for(i in 0 until size) { add(init(i)) }}inline fun IntArray.toIntList() = IntList(this)inline fun Collection<Int>.toIntList() = IntList(this)inline fun intListOf(vararg values: Int) = IntList(values) fun IntList.max() = (1 until size).fold(this[0]) { acc, i -> max(acc, this[i]) }fun IntList.min() = (1 until size).fold(this[0]) { acc, i -> min(acc, this[i]) }fun IntList.getOrNull(i: Int) = if(i in indices) get(i) else nullinline fun IntList.count(predicate: (Int) -> Boolean) = indices.count { predicate(this[it]) }fun IntList.copyOf() = IntList(size, ::get) class IntDeque(capacity: Int = 8) {    private var arr = IntArray(Integer.highestOneBit(capacity.shl(1) - 1))    var size = 0        private set    inline val lastIndex get() = size - 1    inline val indices get() = 0 until size     private inline val capacity get() = arr.size     inline fun isEmpty() = size == 0    inline fun isNotEmpty() = size != 0     private var head = 0     private fun grow() {        val newCapacity = capacity shl 1        val new = IntArray(newCapacity)        for(i in 0 until size) new[i] = get(i)        arr = new        head = 0    }     private fun incHead() {        head = head + 1 and capacity - 1    }     private fun decHead() {        head = head - 1 and capacity - 1    }     private fun index(i: Int) = (head + i).and(capacity-1)     fun add(index: Int, element: Int) {        if(size == capacity) grow()        if(index < size / 2) {            decHead()            size++            for(i in 0 until index) {                set(i, get(i+1))            }        } else {            size++            for(i in size - 2 downTo index) {                set(i+1, get(i))            }        }        set(index, element)    }     fun addLast(e: Int) {        if(size == capacity) grow()        arr[index(size)] = e        size++    }    inline fun add(e: Int) = addLast(e)     val first get() = get(0)    val last get() = get(lastIndex)     fun removeFirst(): Int {        val e = get(0)        incHead()        size--        return e    }    inline fun remove() = removeFirst()    fun removeLast(): Int {        val e = get(lastIndex)        size--        return e    }     fun addFirst(e: Int) {        if(size == capacity) grow()        decHead()        arr[head] = e        size++    }     operator fun get(index: Int): Int {        require(index in 0 until size)        return arr[index(index)]    }     fun removeAt(index: Int): Int {        val e = get(index)        if(index < size / 2) {            for(i in index - 1 downTo 0) {                set(i+1, get(i))            }            incHead()        } else {            for(i in index until size - 1) {                set(i, get(i+1))            }        }        size--        return e    }     operator fun set(index: Int, element: Int): Int {        val old = get(index)        arr[index(index)] = element        return old    }     operator fun iterator() = object: IntIterator() {        var i = 0        override fun hasNext(): Boolean = i < size        override fun nextInt(): Int = get(i++)    }     fun clear() { size = 0 }} /** IO *///@JvmField val ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null//const val PATH = ""src/main/resources/""//@JvmField val INPUT = File(PATH + ""input.txt"").inputStream()//@JvmField val OUTPUT = File(PATH + ""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar() else c    }} /** @param skipNext Whether to skip the next character (usually whitespace), defaults to true */fun readCharArray(n: Int, skipNext: Boolean = true): CharArray {    val res = CharArray(n) { readChar() }    if(skipNext) readChar()    return res} fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(c != '\n' && c != Char.MIN_VALUE) {            append(c)            c = readChar()        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /**  sort overrides to avoid quicksort attacks */ @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } inline fun <A, T> _mergeSort(a0: A, n: Int, tmp0: A, get: A.(Int) -> T, set: A.(Int, T) -> Unit, cmp: (T, T) -> Int) {    var a = a0    var tmp = tmp0    var len = 1    while(len < n) {        var l = 0        while(true) {            val m = l + len            if(m >= n) break            val r = min(n, m + len)            var i = l            var j = m            for(k in l until r) {                if(i != m && (j == r || cmp(a.get(i), a.get(j)) <= 0)) {                    tmp.set(k, a.get(i++))                } else tmp.set(k, a.get(j++))            }            l = r        }        for(i in l until n) tmp.set(i, a.get(i))        val t = a; a = tmp; tmp = t        len += len    }    if(a !== a0) for(i in 0 until n) a0.set(i, tmp0.get(i))} inline fun IntArray.sortWith(cmp: (Int, Int) -> Int) { _mergeSort(this, size, IntArray(size), IntArray::get, IntArray::set, cmp) }inline fun <T: Comparable<T>> IntArray.sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> IntArray.sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun IntArray.sort() { sortBy { it } }fun IntArray.sortDescending() { sortByDescending { it } } inline fun LongArray.sortWith(cmp: (Long, Long) -> Int) { _mergeSort(this, size, LongArray(size), LongArray::get, LongArray::set, cmp) }inline fun <T: Comparable<T>> LongArray.sortBy(func: (Long) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> LongArray.sortByDescending(func: (Long) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun LongArray.sort() { sortBy { it } }fun LongArray.sortDescending() { sortByDescending { it } } inline fun DoubleArray.sortWith(cmp: (Double, Double) -> Int) { _mergeSort(this, size, DoubleArray(size), DoubleArray::get, DoubleArray::set, cmp) }inline fun <T: Comparable<T>> DoubleArray.sortBy(func: (Double) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> DoubleArray.sortByDescending(func: (Double) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun DoubleArray.sort() { sortBy { it } }fun DoubleArray.sortDescending() { sortByDescending { it } } inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T : Comparable<T>> Array<out T>.sort() = _sort()inline fun <T : Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T : Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T : Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() // import preserving junk function@Suppress(""NonAsciiCharacters"") fun 雪花飄飄北風嘯嘯天地一片蒼茫() { iprintln(max(1, 2)) } fun IntArray.sumLong() = sumOf { it.toLong() } fun IntArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun IntArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun LongArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun LongArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun DoubleArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun DoubleArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> Array<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> Array<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> List<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> List<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) } // max/min Kotlin 1.6 -> 1.4 shimfun IntArray.max() = maxOf { it }fun IntArray.min() = minOf { it }fun LongArray.max() = maxOf { it }fun LongArray.min() = minOf { it }fun CharArray.max() = maxOf { it }fun CharArray.min() = minOf { it }fun <T : Comparable<T>> Iterable<T>.max() = maxOf { it }fun <T : Comparable<T>> Iterable<T>.min() = minOf { it }fun <T : Comparable<T>> Sequence<T>.max() = maxOf { it }fun <T : Comparable<T>> Sequence<T>.min() = minOf { it }","graphs,greedy,interactive,shortest paths"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"")@file:OptIn(ExperimentalUnsignedTypes::class, ExperimentalStdlibApi::class) import java.io.PrintWriterimport java.lang.StringBuilderimport java.util.Arraysimport java.util.NoSuchElementExceptionimport java.util.TreeSetimport kotlin.math.*import kotlin.random.Randomimport kotlin.system.exitProcessimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {//    val startTime = System.nanoTime()     val numCases = 1//readInt()     case@ for(case in 1..numCases) {    //    print(""Case #$case: "")         object {            val n = readInt()            val k = readInt()             fun ask(b: IntList): Int {                print('?')                for(e in b) {                    print(' ')                    print(e+1)                }                println()                flush()                 return readInt()            }             fun f(j: Int) = k - j - j             init {                val D = IntArray(n+1) { inf }                D[0] = 0                val P = IntArray(n+1)                 val q = IntDeque()                q.add(0)                bfs@ while(q.isNotEmpty()) {                    val u = q.remove()                    for(j in max(0, u+k-n)..min(u,k)) {                        val v = u + f(j)                        if(v in 0..n && D.setMin(v, D[u]+1)) {                            P[v] = j                            if(v == n) break@bfs                            q.add(v)                        }                    }                }                 if(D[n] == inf) println(-1)                else {                    val J = IntList()                    var c = n                    while(c != 0) {                        val j = P[c]                        J.add(j)                        c -= f(j)                    }                    J.reverse()                     var ans = 0                    val in_ = IntList(n)                    val out = IntList(n) { it }                     for(j in J) {                        val b = IntList(k)                        repeat(j) { b.add(in_.pop()) }                        repeat(k-j) { b.add(out.pop()) }                         ans = ans xor ask(b)                         repeat(k-j) { in_.add(b.pop()) }                        repeat(j) { out.add(b.pop()) }                    }                     print(""! "")                    println(ans)                }            }        }     } //    iprintln(""Time: ${(System.nanoTime() - startTime) / 1000000} ms"")} const val inf = Int.MAX_VALUE fun IntArray.setMin(i: Int, v: Int) = if(v < get(i)) { set(i, v); true } else false class IntList(initialCapacity: Int = 12) {    private var arr = IntArray(initialCapacity)    val _arr get() = arr    private val capacity get() = arr.size    var size = 0        private set    inline val lastIndex get() = size - 1    inline val indices get() = 0 until size     constructor(copyFrom: IntArray): this(copyFrom.size) { copyFrom.copyInto(arr); size = copyFrom.size }    constructor(copyFrom: Collection<Int>): this(copyFrom.size) { arr = copyFrom.toIntArray(); size = copyFrom.size }     fun contentEquals(other: IntList): Boolean {        return this === other || size == other.size && indices.all { this[it] == other[it] }    }     private fun grow(minCapacity: Int = 8) {        val newCapacity = maxOf(minCapacity, capacity + (capacity shr 1))        arr = arr.copyOf(newCapacity)    }     fun ensureCapacity(minCapacity: Int) { if(capacity < minCapacity) grow(minCapacity) }     operator fun get(index: Int): Int {        require(index in 0 until size)        return arr[index]    }     operator fun set(index: Int, value: Int) {        require(index in 0 until size)        arr[index] = value    }     fun add(value: Int) {        if(size == capacity) grow()        arr[size++] = value    }     fun addAll(list: IntList) {        ensureCapacity(size + list.size)        list.arr.copyInto(arr, size, 0, list.size)        size += list.size    }     fun add(index: Int, element: Int) {        if(size == capacity) grow()        arr.copyInto(arr, index + 1, index, size)        size++        set(index, element)    }     fun clear() { size = 0 }     fun removeAt(index: Int): Int {        val e = get(index)        arr.copyInto(arr, index, index + 1, size)        size--        return e    }     fun indexOf(e: Int): Int {        for(i in 0 until size) if(this[i] == e) return i        return -1    }     fun remove(e: Int): Boolean {        val i = indexOf(e)        if(i == -1) return false        removeAt(i)        return true    }     operator fun iterator() = object: IntIterator() {        private var pos = 0        override fun hasNext() = pos < size        override fun nextInt() = get(pos++)    }     inline fun isEmpty() = size == 0    inline fun isNotEmpty() = size != 0     fun pop() = arr[--size]     fun popToSize(s: Int) {        require(s >= 0)        if(s < size) size = s    }     fun swap(i: Int, j: Int) { val t = this[i]; this[i] = this[j]; this[j] = t }    fun reverse() {        for(i in 0 until size / 2) swap(i, lastIndex - i)    }     fun shuffle(rnd: Random = random) { for(i in lastIndex downTo 1) swap(i, rnd.nextInt(i+1)) }     inline fun sortWith(cmp: (Int, Int) -> Int) { _mergeSort(_arr, size, IntArray(size), IntArray::get, IntArray::set, cmp) }    inline fun <T: Comparable<T>> sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }    inline fun <T: Comparable<T>> sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }    fun sort() { sortBy { it } }    fun sortDescending() { sortByDescending { it } }     fun joinToString(separator: CharSequence) = if(size == 0) """" else let {        buildString {            append(it[0])            for (i in 1 until size) {                append(separator).append(it[i])            }        }    }     override fun toString() = ""["" + joinToString("", "") + ""]""     fun toIntArray() = arr.copyOf(size)    fun toList() = List(size, ::get)     inline fun first() = get(0)    inline fun last() = get(lastIndex)} inline fun IntList(size: Int, init: (Int) -> Int) = IntList(size).apply {    for(i in 0 until size) { add(init(i)) }}inline fun IntArray.toIntList() = IntList(this)inline fun Collection<Int>.toIntList() = IntList(this)inline fun intListOf(vararg values: Int) = IntList(values) fun IntList.max() = (1 until size).fold(this[0]) { acc, i -> max(acc, this[i]) }fun IntList.min() = (1 until size).fold(this[0]) { acc, i -> min(acc, this[i]) }fun IntList.getOrNull(i: Int) = if(i in indices) get(i) else nullinline fun IntList.count(predicate: (Int) -> Boolean) = indices.count { predicate(this[it]) }fun IntList.copyOf() = IntList(size, ::get) class IntDeque(capacity: Int = 8) {    private var arr = IntArray(Integer.highestOneBit(capacity.shl(1) - 1))    var size = 0        private set    inline val lastIndex get() = size - 1    inline val indices get() = 0 until size     private inline val capacity get() = arr.size     inline fun isEmpty() = size == 0    inline fun isNotEmpty() = size != 0     private var head = 0     private fun grow() {        val newCapacity = capacity shl 1        val new = IntArray(newCapacity)        for(i in 0 until size) new[i] = get(i)        arr = new        head = 0    }     private fun incHead() {        head = head + 1 and capacity - 1    }     private fun decHead() {        head = head - 1 and capacity - 1    }     private fun index(i: Int) = (head + i).and(capacity-1)     fun add(index: Int, element: Int) {        if(size == capacity) grow()        if(index < size / 2) {            decHead()            size++            for(i in 0 until index) {                set(i, get(i+1))            }        } else {            size++            for(i in size - 2 downTo index) {                set(i+1, get(i))            }        }        set(index, element)    }     fun addLast(e: Int) {        if(size == capacity) grow()        arr[index(size)] = e        size++    }    inline fun add(e: Int) = addLast(e)     val first get() = get(0)    val last get() = get(lastIndex)     fun removeFirst(): Int {        val e = get(0)        incHead()        size--        return e    }    inline fun remove() = removeFirst()    fun removeLast(): Int {        val e = get(lastIndex)        size--        return e    }     fun addFirst(e: Int) {        if(size == capacity) grow()        decHead()        arr[head] = e        size++    }     operator fun get(index: Int): Int {        require(index in 0 until size)        return arr[index(index)]    }     fun removeAt(index: Int): Int {        val e = get(index)        if(index < size / 2) {            for(i in index - 1 downTo 0) {                set(i+1, get(i))            }            incHead()        } else {            for(i in index until size - 1) {                set(i, get(i+1))            }        }        size--        return e    }     operator fun set(index: Int, element: Int): Int {        val old = get(index)        arr[index(index)] = element        return old    }     operator fun iterator() = object: IntIterator() {        var i = 0        override fun hasNext(): Boolean = i < size        override fun nextInt(): Int = get(i++)    }     fun clear() { size = 0 }} /** IO *///@JvmField val ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null//const val PATH = ""src/main/resources/""//@JvmField val INPUT = File(PATH + ""input.txt"").inputStream()//@JvmField val OUTPUT = File(PATH + ""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar() else c    }} /** @param skipNext Whether to skip the next character (usually whitespace), defaults to true */fun readCharArray(n: Int, skipNext: Boolean = true): CharArray {    val res = CharArray(n) { readChar() }    if(skipNext) readChar()    return res} fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(c != '\n' && c != Char.MIN_VALUE) {            append(c)            c = readChar()        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /**  sort overrides to avoid quicksort attacks */ @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } inline fun <A, T> _mergeSort(a0: A, n: Int, tmp0: A, get: A.(Int) -> T, set: A.(Int, T) -> Unit, cmp: (T, T) -> Int) {    var a = a0    var tmp = tmp0    var len = 1    while(len < n) {        var l = 0        while(true) {            val m = l + len            if(m >= n) break            val r = min(n, m + len)            var i = l            var j = m            for(k in l until r) {                if(i != m && (j == r || cmp(a.get(i), a.get(j)) <= 0)) {                    tmp.set(k, a.get(i++))                } else tmp.set(k, a.get(j++))            }            l = r        }        for(i in l until n) tmp.set(i, a.get(i))        val t = a; a = tmp; tmp = t        len += len    }    if(a !== a0) for(i in 0 until n) a0.set(i, tmp0.get(i))} inline fun IntArray.sortWith(cmp: (Int, Int) -> Int) { _mergeSort(this, size, IntArray(size), IntArray::get, IntArray::set, cmp) }inline fun <T: Comparable<T>> IntArray.sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> IntArray.sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun IntArray.sort() { sortBy { it } }fun IntArray.sortDescending() { sortByDescending { it } } inline fun LongArray.sortWith(cmp: (Long, Long) -> Int) { _mergeSort(this, size, LongArray(size), LongArray::get, LongArray::set, cmp) }inline fun <T: Comparable<T>> LongArray.sortBy(func: (Long) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> LongArray.sortByDescending(func: (Long) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun LongArray.sort() { sortBy { it } }fun LongArray.sortDescending() { sortByDescending { it } } inline fun DoubleArray.sortWith(cmp: (Double, Double) -> Int) { _mergeSort(this, size, DoubleArray(size), DoubleArray::get, DoubleArray::set, cmp) }inline fun <T: Comparable<T>> DoubleArray.sortBy(func: (Double) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> DoubleArray.sortByDescending(func: (Double) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun DoubleArray.sort() { sortBy { it } }fun DoubleArray.sortDescending() { sortByDescending { it } } inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T : Comparable<T>> Array<out T>.sort() = _sort()inline fun <T : Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T : Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T : Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() // import preserving junk function@Suppress(""NonAsciiCharacters"") fun 雪花飄飄北風嘯嘯天地一片蒼茫() { iprintln(max(1, 2)) } fun IntArray.sumLong() = sumOf { it.toLong() } fun IntArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun IntArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun LongArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun LongArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun DoubleArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun DoubleArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> Array<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> Array<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> List<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> List<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) } // max/min Kotlin 1.6 -> 1.4 shimfun IntArray.max() = maxOf { it }fun IntArray.min() = minOf { it }fun LongArray.max() = maxOf { it }fun LongArray.min() = minOf { it }fun CharArray.max() = maxOf { it }fun CharArray.min() = minOf { it }fun <T : Comparable<T>> Iterable<T>.max() = maxOf { it }fun <T : Comparable<T>> Iterable<T>.min() = minOf { it }fun <T : Comparable<T>> Sequence<T>.max() = maxOf { it }fun <T : Comparable<T>> Sequence<T>.min() = minOf { it }","graphs,greedy,interactive,shortest paths"
"import kotlin.math.absimport kotlin.math.max fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()        val hs = listOf(0L) + readLine()!!.split("" "").map { it.toLong() } + listOf(0L)        var answer = 0L        for (j in 1..n + 1) {            answer += abs(hs[j] - hs[j - 1])        }        for (j in 1..n) {            if (hs[j] > max(hs[j - 1], hs[j + 1])) {                answer -= hs[j] - max(hs[j - 1], hs[j + 1])            }        }        println(answer)    }}","greedy,implementation,math"
"import kotlin.math.absimport kotlin.math.max fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()        val hs = listOf(0L) + readLine()!!.split("" "").map { it.toLong() } + listOf(0L)        var answer = 0L        for (j in 1..n + 1) {            answer += abs(hs[j] - hs[j - 1])        }        for (j in 1..n) {            if (hs[j] > max(hs[j - 1], hs[j + 1])) {                answer -= hs[j] - max(hs[j - 1], hs[j + 1])            }        }        println(answer)    }}","greedy,implementation,math"
"import java.io.*import java.util.*import kotlin.math.* fun main(){	val f = BufferedReader(InputStreamReader(System.`in`)) 	for(q in 1..f.readLine().toInt()){		val n = f.readLine().toInt() 		val array = LongArray(1){0L} + f.readLine().split("" "").map{it.toLong()}.toLongArray() + LongArray(1){0L} 		var subs : Long = 0L		for(k in 1..n){			val diff = max(0L,array[k]-max(array[k-1],array[k+1]))			subs += diff 			array[k] -= diff		} 		var height : Long = 0L		for(k in 1..n){			height += max(0L,array[k]-array[k-1])			height += max(0L,array[k]-array[k+1])		} 		println(subs+height)	}}","greedy,implementation,math"
"import java.io.BufferedReaderimport kotlin.math.absimport kotlin.math.max val bin = System.`in`.bufferedReader()fun BufferedReader.readInt() = this.readLine()!!.toInt()fun BufferedReader.readInts() = this.readLine()!!.split(' ').map { it.toInt() }.toIntArray() fun main() {    repeat(bin.readInt()) {        bin.readInt()        val vs = bin.readInts()        println(solve(vs))    }} fun solve(vs: IntArray): Long {    var res = vs.last().toLong()    var prev = 0    for (v in vs) {        res += abs(v-prev)        prev = v    }     prev = 0    for ((i, v) in vs.withIndex()) {        val next = if (i+1 in vs.indices) vs[i+1] else 0        val delta = v - max(prev, next)        if (delta > 0) res -= delta        prev = v    }     return res}","greedy,implementation,math"
fun main() {    val n = readLine()!!.toInt()    val listPS = List(n * 2 - 2) { readLine()!! }    val maxPS = listPS.filter { it.length == n - 1 }    var prefixes = List(n - 1) { maxPS[0].take(it + 1) }.toMutableSet()    val intersect = listPS.toSet() intersect prefixes    val ps = if (intersect.size == n - 1 && maxPS[0].drop(1) == maxPS[1].dropLast(1))        'P' to 'S'    else {        prefixes = List(n - 1) { maxPS[0].drop(it) }.toMutableSet()        'S' to 'P'    }    for (s in listPS) if (s in prefixes) {        prefixes.minusAssign(s)        print(ps.first)    } else        print(ps.second)},"*special,strings"
fun main() {    val n = readLine()!!.toInt()    val listPS = List(n * 2 - 2) { readLine()!! }    val maxPS = listPS.filter { it.length == n - 1 }    var prefixes = List(n - 1) { maxPS[0].take(it + 1) }.toMutableSet()    val intersect = listPS.toSet() intersect prefixes    val ps = if (intersect.size == n - 1 && maxPS[0].drop(1) == maxPS[1].dropLast(1))        'P' to 'S'    else {        prefixes = List(n - 1) { maxPS[0].drop(it) }.toMutableSet()        'S' to 'P'    }    for (s in listPS) if (s in prefixes) {        prefixes.minusAssign(s)        print(ps.first)    } else        print(ps.second)},"*special,strings"
fun main() {    val n = readLine()!!.toInt()    val listPS = List(n * 2 - 2) { readLine()!! }    val maxPS = listPS.filter { it.length == n - 1 }    var prefixes = List(n - 1) { maxPS[0].take(it + 1) }.toMutableSet()    val intersect = listPS.toSet() intersect prefixes    val ps = if (intersect.size == n - 1 && maxPS[0].drop(1) == maxPS[1].dropLast(1))        'P' to 'S'    else {        prefixes = List(n - 1) { maxPS[0].drop(it) }.toMutableSet()        'S' to 'P'    }    for (s in listPS) if (s in prefixes) {        prefixes.minusAssign(s)        print(ps.first)    } else        print(ps.second)},"*special,strings"
fun main() {    val n = readLine()!!.toInt()    val listPS = List(n * 2 - 2) { readLine()!! }    val maxPS = listPS.filter { it.length == n - 1 }    var prefixes = List(n - 1) { maxPS[0].take(it + 1) }.toMutableSet()    val intersect = listPS.toSet() intersect prefixes    val ps = if (intersect.size == n - 1 && maxPS[0].drop(1) == maxPS[1].dropLast(1))        'P' to 'S'    else {        prefixes = List(n - 1) { maxPS[0].drop(it) }.toMutableSet()        'S' to 'P'    }    for (s in listPS) if (s in prefixes) {        prefixes.minusAssign(s)        print(ps.first)    } else        print(ps.second)},"*special,strings"
"fun main() {    val number = readLine()!!.toInt()    val pairs = mutableListOf<Pair<Int, Int>>()    var total = 0    repeat(number) { it ->        val (w, h) = readLine()!!.split(' ')        val wI = w.toInt()        val hI = h.toInt()        if (it != 0) {            val c = pairs.count { it.first == wI || it.first == hI || it.second == wI || it.second == hI }            total += c        }        pairs.add(wI to hI)    }    println(total)}","*special,*special"
"fun main(args: Array<String>) {    val n = readLine()!!.toInt()    val ws: MutableList<Int> = mutableListOf()    val hs: MutableList<Int> = mutableListOf()    for (i in 1..n) {        val (w, h) = readLine()!!.split(' ').map{ it -> it.toInt()}        ws.add(w)        hs.add(h)    }    var pairs = 0    for (i in 0..(n - 1)) {        for (j in (i + 1)..(n - 1)) {            if (ws[i] == ws[j] || ws[i] == hs[j] ||            hs[i] == ws[j] || hs[i] == hs[j])                pairs++        }    }    print(pairs)}","*special,*special"
"import kotlin.math.* fun main() {  val have = mutableMapOf<Int, Int>()  val have2 = mutableMapOf<Pair<Int, Int>, Int>()  var ans = 0L  repeat(readLine()!!.toInt()) {    val (w, h) = readLine()!!.split("" "").map(String::toInt)    ans += have.getOrPut(w) { 0 }    have.merge(w, 1, Int::plus)    if (h != w) {      ans += have.getOrPut(h) { 0 }      have.merge(h, 1, Int::plus)      val sortedPair = min(w, h) to max(w, h)      ans -= have2.getOrPut(sortedPair) { 0 }      have2.merge(sortedPair, 1, Int::plus)    }  }  println(ans)}","*special,*special"
"import java.io.BufferedReaderimport java.io.InputStreamReader fun main(args: Array<String>) {  val reader = BufferedReader(InputStreamReader(System.`in`))  val size = reader.readLine().toInt()  val map = (0 until size).map {    val input = reader.readLine()    val array = input.split("" "")     array[0].toInt() to array[1].toInt()  }  var count = 0   for (i in map.indices) {    for (n in (i+1) until map.size) {      val left = map[i]      val right = map[n]       if (left.first == right.first || left.second == right.second || left.first == right.second || left.second == right.first) {        count++      }    }  }   println(count)}","*special,*special"
"fun main() {    val out = StringBuilder()    repeat(readLine()!!.toInt()) {        val freqs = IntArray(26)        val s = readLine()!!        for (letter in s) {            freqs[letter - 'a']++        }        fun freq(letter: Char) = freqs[letter - 'a']        fun output(letter: Char, amt: Int) {            out.append(letter.toString().repeat(amt))            freqs[letter - 'a'] -= amt        }        val letters = ('a'..'z').filter { freq(it) > 0 }        if (letters.size == 1) {            out.append(s)        } else if (letters.any { freq(it) == 1 }) {            val firstLetter = letters.filter { freq(it) == 1 }.min()!!            out.append(firstLetter)            out.append(s.replace(firstLetter.toString(), """").toList().sorted().toCharArray())        } else if (freq(letters[0]) - 2 <= freqs.sum() - freq(letters[0])) {            output(letters[0], 2)            for (letter in s.replace(letters[0].toString(), """").toList().sorted()) {                output(letter, 1)                if (freq(letters[0]) > 0) {                    output(letters[0], 1)                }            }        } else {            output(letters[0], 1)            output(letters[1], 1)            if (letters.size > 2) {                output(letters[0], freq(letters[0]))                output(letters[2], 1)                for (letter in letters) {                    output(letter, freq(letter))                    out.append(letter.toString().repeat(freq(letter)))                }            } else {                output(letters[1], freq(letters[1]))                output(letters[0], freq(letters[0]))            }        }        out.appendln()    }    print(out)}","constructive algorithms,greedy,strings"
"fun main() {    repeat(readLine()!!.toInt()) {        val s = readLine()!!.toList().sorted()        val n = s.size        val cnt = IntArray(26)        for (c in s) cnt[c - 'a']++        if (cnt.any { it == 1 }) {            val smallestChar = 'a' + cnt.indices.find { cnt[it] == 1 }!!            print(smallestChar)            println(s.filter { it != smallestChar }.joinToString(""""))            return@repeat        }        if (cnt.count { it != 0 } == 1) return@repeat println(s.joinToString(""""))         val a = cnt.indices.find { cnt[it] != 0 }!!        if (cnt[a] <= (n + 2) / 2) {            val first = s.filter { it == 'a' + a }.drop(2)            val other = s.filter { it != 'a' + a }            val ans = MutableList(2) { 'a' + a }            for (i in other.indices) {                ans.add(other[i])                if (i < first.size) ans.add(first[i])            }            println(ans.joinToString(""""))            return@repeat        }         if (cnt.count { it > 0 } == 2) {            print('a' + a)            print(s.filter { it != 'a' + a }.joinToString(""""))            println(s.filter { it == 'a' + a }.drop(1).joinToString(""""))            return@repeat        }         val nonZero = cnt.indices.filter { cnt[it] != 0 }        print('a' + nonZero[0])        print('a' + nonZero[1])        print(s.filter { it == 'a' + a }.drop(1).joinToString(""""))        print('a' + nonZero[2])        val rem = s.filter { it != 'a' + a }.toMutableList()        rem.removeAt(rem.indices.find { rem[it] == 'a' + nonZero[1] }!!)        rem.removeAt(rem.indices.find { rem[it] == 'a' + nonZero[2] }!!)        println(rem.joinToString(""""))    }}","constructive algorithms,greedy,strings"
"import java.io.Fileimport java.util.* fun main() {    val sc = Scanner(System.`in`)//    val sc = Scanner(File(""e.in""))    val t = sc.nextLine().toInt()    for (i in 1..t) solveE(sc)} fun solveE(sc: Scanner) {    val s = sc.nextLine()    val let = IntArray(26)    for (c in s) {        let[c - 'a']++    }     // сначала проверяем, сколько разных букв у нас есть    var different = 0    for (c in 'a'..'z') {        if (let[c - 'a'] > 0) different++    }    if (different == 1) {        // если все одинаковые, то просто выводим        println(s)        return    }     // если есть уникальная буква — возможен ответ 0    for (c in 'a'..'z') {        if (let[c - 'a'] == 1) {            // нашли первую по алфавиту уникальную букву!            print(c)            let[c - 'a']--            printAllRemainingLexicographically(let)             return        }    }     // пробуем вариант 'aab'. для него должно быть, чтобы количество 'a' было максимум на 2 больше чем остальных букв в сумме    var firstLetter = 'z'    for (c in 'a'..'z') {        if (let[c - 'a'] > 0) {            firstLetter = c            break        }    }    if (let[firstLetter - 'a'] - 2 <= s.length - let[firstLetter - 'a']) {        // подходит!        var nextLetter = firstLetter + 1         print(firstLetter)        let[firstLetter - 'a']--        print(firstLetter)        let[firstLetter - 'a']--         while (true) {            // ищем следующую непервую букву и выводим            findAndPrintFirstStartingFrom(let, nextLetter)             // выводим 'a'            if (let[firstLetter - 'a'] > 0) {                print(firstLetter)                let[firstLetter - 'a']--            } else {                // буквы 'a' закончились. просто выводим слово до конца и выходим                printAllRemainingLexicographically(let)                return            }        }    }     // пробуем последний вариант: 'ab'     // 'a'    print(firstLetter)    let[firstLetter - 'a']--     // 'b'    val secondLetter = findAndPrintFirstStartingFrom(let, firstLetter + 1)!!     if (different > 2) {        // подвариант 1: есть 'c'         // все 'a' до конца        while (let[firstLetter - 'a'] > 0) {            print(firstLetter)            let[firstLetter - 'a']--        }         // 'c'        findAndPrintFirstStartingFrom(let, secondLetter + 1)         // всё что осталось по алфавиту        printAllRemainingLexicographically(let)        return    } else {        // подвариант 2: только 2 буквы существует         // все 'b' до конца        while (let[secondLetter - 'a'] > 0) {            print(secondLetter)            let[secondLetter - 'a']--        }         // всё что осталось по алфавиту        printAllRemainingLexicographically(let)        return    }} /** * Возвращает, какую букву удалось вывести, если удалось */private fun findAndPrintFirstStartingFrom(let: IntArray, startFromLetter: Char): Char? {    var nextLetter = startFromLetter    while (let[nextLetter - 'a'] == 0) {        nextLetter++        if (nextLetter > 'z') break    }    if (nextLetter <= 'z') {        // нашли. выводим        print(nextLetter)        let[nextLetter - 'a']--        return nextLetter    }    return null} private fun printAllRemainingLexicographically(let: IntArray) {    for (c1 in 'a'..'z') {        print(c1.toString().repeat(let[c1 - 'a']))    }    println()}","constructive algorithms,greedy,strings"
import java.io.BufferedReader fun main() {    val br = System.`in`.bufferedReader()    val sb = StringBuilder()    val t = br.readInt()    repeat(t) {        val s = br.readLine()        val n = s.length        val counts = IntArray(26)        for (c in s) {            counts[c - 'a']++        }        var bestC = 'a'        var bestScore = 2        for (x in 0 until 26) {            if (counts[x] == 0) {                continue            } else if (counts[x] == 1) {                bestScore = 0                bestC = 'a' + x                sb.append(bestC)                counts[x]--                break            } else if (counts[x] < n && bestScore == 2) {                bestScore = 1                bestC = 'a' + x            }        }        if (bestScore == 2) {            sb.appendLine(s)        } else if (bestScore == 0) {            for (x in 0 until 26) {                if (counts[x] != 0) {                    val c = 'a' + x                    sb.append(c.toString().repeat(counts[x]))                }            }            sb.appendLine()        } else {            val bestIdx = bestC - 'a'            counts[bestIdx]--            sb.append(bestC)            if (counts[bestIdx] shl 1 <= n) {                sb.append(bestC)                counts[bestIdx]--                var idx = bestIdx + 1                while (counts[bestIdx] > 0) {                    while (counts[idx] == 0) {                        idx++                    }                    sb.append('a' + idx)                    counts[idx]--                    sb.append(bestC)                    counts[bestIdx]--                }                for (x in idx until 26) {                    if (counts[x] != 0) {                        val c = 'a' + x                        sb.append(c.toString().repeat(counts[x]))                    }                }                sb.appendLine()            } else {                var numOthers = 0                var firstOther = -1                var secondOther = -1                for (x in bestIdx + 1 until 26) {                    if (counts[x] != 0) {                        numOthers++                        if (numOthers == 1) {                            firstOther = x                        } else if (numOthers == 2) {                            secondOther = x                        }                    }                }                if (numOthers >= 2) {                    sb.append('a' + firstOther)                    counts[firstOther]--                    sb.append(bestC.toString().repeat(counts[bestIdx]))                    sb.append('a' + secondOther)                    counts[secondOther]--                    for (x in (bestIdx + 1) until 26) {                        if (counts[x] != 0) {                            val c = 'a' + x                            sb.append(c.toString().repeat(counts[x]))                        }                    }                    sb.appendLine()                } else {                    sb.append(('a' + firstOther).toString().repeat(counts[firstOther]))                    sb.appendLine(bestC.toString().repeat(counts[bestIdx]))                }            }        }    }    print(sb)} private const val SPACE_INT = ' '.toInt()private const val ZERO_INT = '0'.toInt()private const val NL_INT = '\n'.toInt() private fun BufferedReader.readInt(): Int {    var ret = read()    while (ret <= SPACE_INT) {        ret = read()    }    val neg = ret == '-'.toInt()    if (neg) {        ret = read()    }    ret -= ZERO_INT    var read = read()    while (read >= ZERO_INT) {        ret *= 10        ret += read - ZERO_INT        read = read()    }     while (read <= SPACE_INT && read != -1 && read != NL_INT) {        mark(1)        read = read()    }    if (read > SPACE_INT) {        reset()    }    return if (neg) -ret else ret},"constructive algorithms,greedy,strings"
"import kotlin.math.min const val MOD = 1000000007L fun main() {    val factorial = LongArray(100001)    factorial[0] = 1L    for (j in 1..100000) {        factorial[j] = (j.toLong() * factorial[j - 1]) % MOD    }    val invFactorial = LongArray(100001)    invFactorial[100000] = factorial[100000] pow -1    for (j in 99999 downTo 0) {        invFactorial[j] = ((j + 1).toLong() * invFactorial[j + 1]) % MOD    }    fun choose(a: Int, b: Int) = if (b in 0..a) (factorial[a] * ((invFactorial[b] * invFactorial[a - b]) % MOD)) % MOD else 0L    repeat(readLine()!!.toInt()) {        val (n, k) = readLine()!!.split("" "").map { it.toInt() }        if (k == 1) {            println(n)        } else {            var answer = 0L            for (j in 2..min(n, (n / (k - 1)) + 3)) {                val x = (((((j - 1).toLong() * (choose(n - ((j - 2) * (k - 1)), j) - choose(n - ((j - 1) * (k - 1)), j))) % MOD)))                answer += j.toLong() * (((((j - 1).toLong() * (choose(n - ((j - 2) * (k - 1)), j) - choose(n - ((j - 1) * (k - 1)), j))) % MOD) * ((2L * factorial[j - 1] * factorial[n - j]) % MOD)) % MOD)                answer %= MOD            }            for (j in 3..min(n, (n / (k - 1)) + 3)) {                var y = (choose(n - ((j - 3) * (k - 1)), j) - (2L * choose(n - ((j - 2) * (k - 1)), j)) + choose(n - ((j - 1) * (k - 1)), j)) % MOD                for (s in 1..k - 2) {                    y -= s.toLong() * choose(n - ((j - 3) * (k - 1)) - s - 1, j - 2)                    y %= MOD                }                answer += j.toLong() * (((((j - 2).toLong() * y) % MOD) * ((factorial[j - 1] * factorial[n - j]) % MOD)) % MOD)                answer %= MOD            }            answer *= invFactorial[n]            answer %= MOD            answer += MOD            answer %= MOD            println(answer)        }    }} const val MOD_TOTIENT = MOD.toInt() - 1 infix fun Long.pow(power: Int): Long {    var e = power    e %= MOD_TOTIENT    if (e < 0) {        e += MOD_TOTIENT    }    if (e == 0 && this == 0L) {        return this    }    var b = this % MOD    var res = 1L    while (e > 0) {        if (e and 1 != 0) {            res *= b            res %= MOD        }        b *= b        b %= MOD        e = e shr 1    }    return res}","combinatorics,dp,math,probabilities"
"// 2022-05-2, Mon, 00:15import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.system.measureTimeMillis // 1. Moddedconst val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}infix fun Int.modM(b:Int):Int{ return ((this.toLong() * b) % pI).toInt() }infix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }fun intPow(x:Int,e:Int,m:Int):Int{    var X = x ; var E =e ; var Y = 1    while(E > 0){        if(E and 1 == 0){            X = ((1L * X * X) % m).toInt()            E = E shr 1        }else{            Y = ((1L * X * Y) % m).toInt()            E -= 1        }    }    return Y}// 2. DP initial valuesconst val plarge = 1_000_000_727const val nlarge = -plargeconst val phuge = 2_727_000_000_000_000_000Lconst val nhuge = -phuge// 3. conveniecen conversionsval Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionval Char.code :Int get() = this.toInt() -  'a'.toInt()//3. hard to write stufffun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val mint:MutableList<Int> get() = mutableListOf<Int>()val mong:MutableList<Long> get() = mutableListOf<Long>()//4. more outputsfun List<Char>.conca():String = this.joinToString("""")val CharArray.conca :String get() = this.joinToString("""")val IntArray.conca :String get() = this.joinToString("" "")@JvmName(""concaInt"")fun List<Int>.conca():String = this.joinToString("" "")val LongArray.conca:String get() = this.joinToString("" "")@JvmName(""concaLong"")fun List<Long>.conca():String = this.joinToString("" "")//5. Pair of intsconst val longmask = (1L shl 32) - 1fun makepair(a:Int, b:Int):Long = (a.toLong() shl 32) xor (longmask and b.toLong()) // remember positev sonlyval Long.first get() = (this ushr 32).toInt()val Long.second get() = this.toInt()//6. stringsval String.size get() = this.lengthconst val randCount = 100//7. bitsfun Int.has(i:Int):Boolean = (this and (1 shl i) != 0)//8 TIMEinline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")}object Reader{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""Custom test enabled"")            println(""Custom test enabled"")            warningActive = false        }        val S = fakein.toString()        println(""New Case "")        println(S.take(80))        println(""..."")        fakein.clear()        IN = BufferedInputStream(S.byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ Reader.OUT.println(aa)}fun done(){ Reader.OUT.close() }fun share(aa:Any){    if(aa is IntArray){Reader.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){Reader.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){Reader.fakein.append(aa.toString())}    else{Reader.fakein.append(aa.toString())}    Reader.fakein.append(""\n"")} val getintfast:Int get() = Reader.nextInt()val getint:Int get(){ val ans = getlong ; if(ans > Int.MAX_VALUE) IntArray(1000000000); return ans.toInt() }val getlong:Long get() = Reader.nextLong()val getstr:String get() = Reader.nextString()fun getline(n:Int):IntArray{    return IntArray(n){getint}}fun getlineL(n:Int):LongArray{    return LongArray(n){getlong}}var dmark = -1infix fun Any.dei(a:Any){    dmark++    var str = ""<${dmark}>   ""    debug()    if(this is String){ str += this    }else if(this is Int){ str += this.toString()    }else if(this is Long){ str += this.toString()    }else{ str += this.toString()}    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is BooleanArray){ println(""$str :${a.map{if(it)'1' else '0'}.joinToString("" "")}"")    }else if(a is Array<*>){        println(""$str : "")        for(c in a){if(c is IntArray){println(c.joinToString("" ""))}        else if(c is LongArray){println(c.joinToString("" ""))}        else if(c is BooleanArray){println(c.map { if(it) '1' else '0' }.joinToString(""""))        }        }        println()    }else{ println(""$str : $a"")    }}val just = "" ""fun crash(){    throw Exception(""Bad programme"")}fun assert(a:Boolean){    if(!a){        throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var tn:Long = 0    fun cases(onecase:()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint} else if(mode == solveMode.tc){1 } else randCount        if(pI != 998_244_353 && pI != 1_000_000_007){            throw Exception(""Not usual primes!"")        }        if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                Reader.rerouteInput()            }else if(mode == solveMode.rand){                rand()                Reader.rerouteInput()            }            onecase()        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }}infix fun Int.divceil(b:Int):Int{    //Positives numbers only!    if(this == 0) {        return 0    }    return (this-1)/b + 1}infix fun Long.divceil(b:Long):Long{    //Positives numbers only!    if(this == 0L) {        return 0    }    return (this-1)/b + 1} infix fun Long.modM(b:Long):Long{    return (this * b) % p}//infix fun Int.modPlus(b:Int):Int{//    val ans = this + b//    return if(ans >= pI) ans - pI else ans//}infix fun Int.modMinus(b:Int):Int{    val ans = this - b    return if(ans < 0) ans + pI else ans}infix fun Int.modDivide(b:Int):Int{    return this modM (b.inverse())}fun Int.additiveInverse():Int{    return if(this == 0) 0 else pI - this} fun intPowEXP(x:Int,e:Long,m:Int):Int{    var X = x    var E =e    var Y = 1    while(E > 0){        if(E % 2 == 0L){            X = ((1L * X * X) % m).toInt()            E = E shr 1        }else{            Y = ((1L * X * Y) % m).toInt()            E -= 1        }    }    return Y} fun pow(x:Long,e:Long,m:Long):Long{    var X = x    var E =e    var Y = 1L    while(E > 0){        if(E % 2 == 0L){            X = (X * X) % m            E /= 2        }else{            Y = (X * Y) % m            E -= 1        }    }    return Y}fun Long.inverse():Long{    return pow(this,p-2,p)}fun Int.inverse():Int{    return intPow(this,pI-2,pI)}fun min_rem(m:Int, r:Int, c:Int):Int {    if(c < 1){        return Int.MIN_VALUE    }else if(r == 0){        return 0    }else{        val step = m % r        val mx = ((1L * c * r) /m ).toInt()        val t = max_rem(r,step,mx)        return r- t    }}fun max_rem(m:Int, r:Int, c:Int):Int {    if(r == 0|| c <= m/r){        return r * c    }else{        val step =  m % r        val mx = ((1L * (c+1) * r )/m).toInt()        val t = min_rem(r,step,mx)        return  m - t    }}fun Int.reconstruct():String{    val num = min_rem(pI,this, 10000)    val denom = (this modDivide num).inverse()    return ""$num / $denom""} //make this int insteadclass FACT{    companion object {        var store = IntArray(0)        var invStore = IntArray(0)         var slowStore:IntArray = IntArray(0)         fun preCal(upto:Int){            store = IntArray(upto+1)            invStore = IntArray(upto + 1 )            store[0] = 1            invStore[0] = 1             for(i in 1..upto) {                store[i] = store[i-1] modM i                invStore[i] = invStore[i-1] modM (i.inverse())            }        }        fun choose(n:Int,r:Int):Int{            if(r < 0 || r > n) return 0            val a = store[n]            val b = invStore[n-r]            val c = invStore[r]            return (a modM b) modM c        }        fun invchoose(n:Int,r:Int):Int{            if(r < 0 || r > n) return 0            val a = invStore[n]            val b = store[n-r]            val c = store[r]            return (a modM b) modM c        }         fun bigChoose(n:Int,r:Int):Int{            var ret = 1            for(i in 0 until r){                ret = ret modM (n - i)            }            ret = ret modM (invStore[r])            return ret        }     }} fun debug(){}const val singleCase = falsefun main(){    FACT.preCal(300005)    solve.cases{        val n= getint        val k = getint         var ret = 0        for(lights in 0..n){            val fullzero = n + (k-1) - k.toLong() * lights            if(fullzero < 0 ) continue            val fz = fullzero.toInt()            val counts = FACT.choose(fz + lights,lights)            val odds = FACT.invchoose(n,lights)            ret = ret modPlus (odds modM counts)        }        put(ret)         }    done()}    ","combinatorics,dp,math,probabilities"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"")@file:OptIn(ExperimentalUnsignedTypes::class, ExperimentalStdlibApi::class) import java.io.PrintWriterimport java.lang.StringBuilderimport java.util.TreeSetimport kotlin.math.*import kotlin.random.Randomimport kotlin.system.exitProcessimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {//    val startTime = System.nanoTime()     val numCases = readInt()     val mc = ArrayModCombinatorics(1e5.toInt())     case@ for(case in 1..numCases) {    //    print(""Case #$case: "")         val n = readInt()        val k = readInt()         var ans = ModInt(1)        for(p in 1..n.divCeil(k)) {            ans += mc.C(n - (k-1) * (p-1), p) * mc.invC(n, p)        }         println(ans.int)    } //    iprintln(""Time: ${(System.nanoTime() - startTime) / 1000000} ms"")} infix fun Int.divCeil(other: Int) =    (this / other).let { if(xor(other) >= 0 && it * other != this) it+1 else it } class ArrayModCombinatorics(val maxn: Int) {    val factorial = ModIntArray(maxn + 1).also {        it[0] = ModInt(1)        for(i in 1 .. maxn) {            it[i] = it[i-1] * i        }    }     val invf = ModIntArray(maxn + 1).also {        it[maxn] = factorial[maxn].inv_unmemoized()        for(i in maxn downTo 1) {            it[i-1] = it[i] * i        }    }     fun P(n: Int, k: Int) = if(k > n || k < 0) ModInt(0) else factorial[n] * invf[n-k]    fun C(n: Int, k: Int) = if(k > n || k < 0) ModInt(0) else factorial[n] * invf[k] * invf[n-k]    fun invC(n: Int, k: Int) = invf[n] * factorial[k] * factorial[n-k]     // multi-choose, be sure to adjust maxn accordingly    fun M(n: Int, k: Int) = if(k == 0) ModInt(1) else C(n + k - 1, k)} const val BILLION7 = 1e9.toInt() + 7const val MOD = BILLION7const val TOTIENT = MOD - 1 // assumes MOD is prime infix fun Int.modulo(mod: Int): Int = (this % mod).let { (it shr Int.SIZE_BITS - 1 and mod) + it }infix fun Long.modulo(mod: Long) = (this % mod).let { (it shr Long.SIZE_BITS - 1 and mod) + it }infix fun Long.modulo(mod: Int) = modulo(mod.toLong()).toInt() fun Int.mulMod(other: Int, mod: Int) = toLong() * other modulo mod fun Int.powMod(exponent: Long, mod: Int): Int {    if(exponent < 0) error(""Inverse not implemented"")    if(mod == 1) return 0    var res = 1L    var e = exponent    var b = modulo(mod).toLong()     while(e > 0) {        if(e and 1 == 1L) {            res = res * b % mod        }        e = e shr 1        b = b * b % mod    }    return res.toInt()}fun Int.powMod(exponent: Int, mod: Int) = powMod(exponent.toLong(), mod)fun Int.modPowArray(n: Int, mod: Int): IntArray {    val res = IntArray(n+1)    res[0] = 1    for(i in 1..n) res[i] = mulMod(res[i-1], mod)    return res} inline fun Int.toModInt() = ModInt(this modulo MOD)inline fun Long.toModInt() = ModInt(this modulo MOD) /** note: Only use constructor for int within modulo range, otherwise use toModInt **/inline class ModInt(val int: Int) {    companion object {        /** can't seem to make these private or inlined without causing compiler issues */        @JvmField val _invMemo = HashMap<ModInt, ModInt>()        fun _invMemoized(m: ModInt) = _invMemo.getOrPut(m) { m.inv_unmemoized() }    }     // normalizes an integer that's within range [-MOD, MOD) without branching    private inline fun normalize(int: Int) = ModInt((int shr Int.SIZE_BITS - 1 and MOD) + int)     operator fun plus(other: ModInt) = normalize(int + other.int - MOD) // overflow-safe even if MOD >= 2^30    inline operator fun plus(other: Int) = plus(other.toModInt())    operator fun inc() = normalize(int + (1 - MOD))     operator fun minus(other: ModInt) = normalize(int - other.int)    inline operator fun minus(other: Int) = minus(other.toModInt())    operator fun dec() = normalize(int - 1)    operator fun unaryMinus() = normalize(-int)     operator fun times(other: ModInt) = ModInt((int.toLong() * other.int % MOD).toInt())    inline operator fun times(other: Int) = ModInt(int.mulMod(other, MOD))     fun pow(exponent: Int): ModInt {        val e = if(exponent < 0) {            require(int != 0) { ""Can't invert/divide by 0"" }            exponent modulo TOTIENT        } else exponent        return ModInt(int.powMod(e, MOD))    }     fun pow(exponent: Long) = if(int == 0) when {        exponent > 0 -> this        exponent == 0L -> ModInt(1)        else -> error(""Can't invert/divide by 0"")    } else pow(exponent modulo TOTIENT)     inline fun inverse() = inv_unmemoized() /** NOTE: Change if necessary */     fun inv_unmemoized(): ModInt {        require(int != 0) { ""Can't invert/divide by 0"" }        return pow(TOTIENT - 1)    }    inline fun inv_memoized() = _invMemoized(this)     operator fun div(other: ModInt) = times(other.inverse())    inline operator fun div(other: Int) = div(other.toModInt())     override inline fun toString() = int.toString()} inline operator fun Int.plus(modInt: ModInt) = modInt + thisinline operator fun Int.minus(modInt: ModInt) = toModInt() - modIntinline operator fun Int.times(modInt: ModInt) = modInt * thisinline operator fun Int.div(modInt: ModInt) = modInt.inverse() * this inline class ModIntArray(val intArray: IntArray): Collection<ModInt> {    inline operator fun get(i: Int) = ModInt(intArray[i])    inline operator fun set(i: Int, v: ModInt) { intArray[i] = v.int }     override inline val size: Int get() = intArray.size    inline val lastIndex get() = intArray.lastIndex    inline val indices get() = intArray.indices     override inline fun contains(element: ModInt): Boolean = element.int in intArray     override fun containsAll(elements: Collection<ModInt>): Boolean = elements.all(::contains)     override inline fun isEmpty(): Boolean = intArray.isEmpty()     override fun iterator(): Iterator<ModInt> = object: Iterator<ModInt> {        var index = 0        override fun hasNext(): Boolean = index < size        override fun next(): ModInt = get(index++)    }     fun copyOf(newSize: Int) = ModIntArray(intArray.copyOf(newSize))    fun copyOf() = copyOf(size)}fun ModIntArray.copyInto(destination: ModIntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size) =    ModIntArray(intArray.copyInto(destination.intArray, destinationOffset, startIndex, endIndex))inline fun ModIntArray(size: Int) = ModIntArray(IntArray(size))inline fun ModIntArray(size: Int, init: (Int) -> ModInt) = ModIntArray(IntArray(size) { init(it).int }) fun ModInt.powArray(n: Int) = ModIntArray(int.modPowArray(n, MOD)) inline fun ModIntArray.first() = get(0)inline fun ModIntArray.last() = get(lastIndex)inline fun ModIntArray.joinToString(separator: CharSequence) = intArray.joinToString(separator)inline fun <R> ModIntArray.fold(init: R, op: (acc: R, ModInt) -> R) = intArray.fold(init) { acc, i -> op(acc, ModInt(i)) }inline fun <R> ModIntArray.foldRight(init: R, op: (ModInt, acc: R) -> R) = intArray.foldRight(init) { i, acc -> op(ModInt(i), acc) }fun ModIntArray.sum() = fold(ModInt(0), ModInt::plus)fun ModIntArray.product() = fold(ModInt(1), ModInt::times) inline fun <T> Iterable<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Iterable<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }inline fun <T> Sequence<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Sequence<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }inline fun <T> Array<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Array<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }fun Iterable<ModInt>.sum() = sumByModInt { it }fun Sequence<ModInt>.sum() = sumByModInt { it }fun Iterable<ModInt>.product() = productByModInt { it }fun Sequence<ModInt>.product() = productByModInt { it }fun Collection<ModInt>.toModIntArray() = ModIntArray(size).also { var i = 0; for(e in this) { it[i++] = e } } /** IO *///@JvmField val ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null//const val PATH = ""src/main/resources/""//@JvmField val INPUT = File(PATH + ""input.txt"").inputStream()//@JvmField val OUTPUT = File(PATH + ""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar() else c    }} /** @param skipNext Whether to skip the next character (usually whitespace), defaults to true */fun readCharArray(n: Int, skipNext: Boolean = true): CharArray {    val res = CharArray(n) { readChar() }    if(skipNext) readChar()    return res} fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(c != '\n' && c != Char.MIN_VALUE) {            append(c)            c = readChar()        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /**  sort overrides to avoid quicksort attacks */ @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } inline fun <A, T> _mergeSort(a0: A, n: Int, tmp0: A, get: A.(Int) -> T, set: A.(Int, T) -> Unit, cmp: (T, T) -> Int) {    var a = a0    var tmp = tmp0    var len = 1    while(len < n) {        var l = 0        while(true) {            val m = l + len            if(m >= n) break            val r = min(n, m + len)            var i = l            var j = m            for(k in l until r) {                if(i != m && (j == r || cmp(a.get(i), a.get(j)) <= 0)) {                    tmp.set(k, a.get(i++))                } else tmp.set(k, a.get(j++))            }            l = r        }        for(i in l until n) tmp.set(i, a.get(i))        val t = a; a = tmp; tmp = t        len += len    }    if(a !== a0) for(i in 0 until n) a0.set(i, tmp0.get(i))} inline fun IntArray.sortWith(cmp: (Int, Int) -> Int) { _mergeSort(this, size, IntArray(size), IntArray::get, IntArray::set, cmp) }inline fun <T: Comparable<T>> IntArray.sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> IntArray.sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun IntArray.sort() { sortBy { it } }fun IntArray.sortDescending() { sortByDescending { it } } inline fun LongArray.sortWith(cmp: (Long, Long) -> Int) { _mergeSort(this, size, LongArray(size), LongArray::get, LongArray::set, cmp) }inline fun <T: Comparable<T>> LongArray.sortBy(func: (Long) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> LongArray.sortByDescending(func: (Long) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun LongArray.sort() { sortBy { it } }fun LongArray.sortDescending() { sortByDescending { it } } inline fun DoubleArray.sortWith(cmp: (Double, Double) -> Int) { _mergeSort(this, size, DoubleArray(size), DoubleArray::get, DoubleArray::set, cmp) }inline fun <T: Comparable<T>> DoubleArray.sortBy(func: (Double) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> DoubleArray.sortByDescending(func: (Double) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun DoubleArray.sort() { sortBy { it } }fun DoubleArray.sortDescending() { sortByDescending { it } } inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T : Comparable<T>> Array<out T>.sort() = _sort()inline fun <T : Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T : Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T : Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() // import preserving junk function@Suppress(""NonAsciiCharacters"") fun 雪花飄飄北風嘯嘯天地一片蒼茫() { iprintln(max(1, 2)) } fun IntArray.sumLong() = sumOf { it.toLong() } fun IntArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun IntArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun LongArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun LongArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun DoubleArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun DoubleArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> Array<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> Array<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> List<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> List<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) } // max/min Kotlin 1.6 -> 1.4 shimfun IntArray.max() = maxOf { it }fun IntArray.min() = minOf { it }fun LongArray.max() = maxOf { it }fun LongArray.min() = minOf { it }fun CharArray.max() = maxOf { it }fun CharArray.min() = minOf { it }fun <T : Comparable<T>> Iterable<T>.max() = maxOf { it }fun <T : Comparable<T>> Iterable<T>.min() = minOf { it }fun <T : Comparable<T>> Sequence<T>.max() = maxOf { it }fun <T : Comparable<T>> Sequence<T>.min() = minOf { it }","combinatorics,dp,math,probabilities"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"")@file:OptIn(ExperimentalUnsignedTypes::class, ExperimentalStdlibApi::class) import java.io.PrintWriterimport java.lang.StringBuilderimport java.util.TreeSetimport kotlin.math.*import kotlin.random.Randomimport kotlin.system.exitProcessimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {//    val startTime = System.nanoTime()     val numCases = readInt()     val mc = ArrayModCombinatorics(1e5.toInt())     case@ for(case in 1..numCases) {    //    print(""Case #$case: "")         val n = readInt()        val k = readInt()         var ans = ModInt(1)        for(p in 1..n.divCeil(k)) {            val x = n - (k-1) * (p-1)            ans += with(mc) { factorial[x] * invf[x-p] * invf[n] * factorial[n-p] }        }         println(ans.int)    } //    iprintln(""Time: ${(System.nanoTime() - startTime) / 1000000} ms"")} infix fun Int.divCeil(other: Int) =    (this / other).let { if(xor(other) >= 0 && it * other != this) it+1 else it } class ArrayModCombinatorics(val maxn: Int) {    val factorial = ModIntArray(maxn + 1).also {        it[0] = ModInt(1)        for(i in 1 .. maxn) {            it[i] = it[i-1] * i        }    }     val invf = ModIntArray(maxn + 1).also {        it[maxn] = factorial[maxn].inv_unmemoized()        for(i in maxn downTo 1) {            it[i-1] = it[i] * i        }    }     fun P(n: Int, k: Int) = if(k > n || k < 0) ModInt(0) else factorial[n] * invf[n-k]    fun C(n: Int, k: Int) = if(k > n || k < 0) ModInt(0) else factorial[n] * invf[k] * invf[n-k]    fun invC(n: Int, k: Int) = invf[n] * factorial[k] * factorial[n-k]     // multi-choose, be sure to adjust maxn accordingly    fun M(n: Int, k: Int) = if(k == 0) ModInt(1) else C(n + k - 1, k)} const val BILLION7 = 1e9.toInt() + 7const val MOD = BILLION7const val TOTIENT = MOD - 1 // assumes MOD is prime infix fun Int.modulo(mod: Int): Int = (this % mod).let { (it shr Int.SIZE_BITS - 1 and mod) + it }infix fun Long.modulo(mod: Long) = (this % mod).let { (it shr Long.SIZE_BITS - 1 and mod) + it }infix fun Long.modulo(mod: Int) = modulo(mod.toLong()).toInt() fun Int.mulMod(other: Int, mod: Int) = toLong() * other modulo mod fun Int.powMod(exponent: Long, mod: Int): Int {    if(exponent < 0) error(""Inverse not implemented"")    if(mod == 1) return 0    var res = 1L    var e = exponent    var b = modulo(mod).toLong()     while(e > 0) {        if(e and 1 == 1L) {            res = res * b % mod        }        e = e shr 1        b = b * b % mod    }    return res.toInt()}fun Int.powMod(exponent: Int, mod: Int) = powMod(exponent.toLong(), mod)fun Int.modPowArray(n: Int, mod: Int): IntArray {    val res = IntArray(n+1)    res[0] = 1    for(i in 1..n) res[i] = mulMod(res[i-1], mod)    return res} inline fun Int.toModInt() = ModInt(this modulo MOD)inline fun Long.toModInt() = ModInt(this modulo MOD) /** note: Only use constructor for int within modulo range, otherwise use toModInt **/inline class ModInt(val int: Int) {    companion object {        /** can't seem to make these private or inlined without causing compiler issues */        @JvmField val _invMemo = HashMap<ModInt, ModInt>()        fun _invMemoized(m: ModInt) = _invMemo.getOrPut(m) { m.inv_unmemoized() }    }     // normalizes an integer that's within range [-MOD, MOD) without branching    private inline fun normalize(int: Int) = ModInt((int shr Int.SIZE_BITS - 1 and MOD) + int)     operator fun plus(other: ModInt) = normalize(int + other.int - MOD) // overflow-safe even if MOD >= 2^30    inline operator fun plus(other: Int) = plus(other.toModInt())    operator fun inc() = normalize(int + (1 - MOD))     operator fun minus(other: ModInt) = normalize(int - other.int)    inline operator fun minus(other: Int) = minus(other.toModInt())    operator fun dec() = normalize(int - 1)    operator fun unaryMinus() = normalize(-int)     operator fun times(other: ModInt) = ModInt((int.toLong() * other.int % MOD).toInt())    inline operator fun times(other: Int) = ModInt(int.mulMod(other, MOD))     fun pow(exponent: Int): ModInt {        val e = if(exponent < 0) {            require(int != 0) { ""Can't invert/divide by 0"" }            exponent modulo TOTIENT        } else exponent        return ModInt(int.powMod(e, MOD))    }     fun pow(exponent: Long) = if(int == 0) when {        exponent > 0 -> this        exponent == 0L -> ModInt(1)        else -> error(""Can't invert/divide by 0"")    } else pow(exponent modulo TOTIENT)     inline fun inverse() = inv_unmemoized() /** NOTE: Change if necessary */     fun inv_unmemoized(): ModInt {        require(int != 0) { ""Can't invert/divide by 0"" }        return pow(TOTIENT - 1)    }    inline fun inv_memoized() = _invMemoized(this)     operator fun div(other: ModInt) = times(other.inverse())    inline operator fun div(other: Int) = div(other.toModInt())     override inline fun toString() = int.toString()} inline operator fun Int.plus(modInt: ModInt) = modInt + thisinline operator fun Int.minus(modInt: ModInt) = toModInt() - modIntinline operator fun Int.times(modInt: ModInt) = modInt * thisinline operator fun Int.div(modInt: ModInt) = modInt.inverse() * this inline class ModIntArray(val intArray: IntArray): Collection<ModInt> {    inline operator fun get(i: Int) = ModInt(intArray[i])    inline operator fun set(i: Int, v: ModInt) { intArray[i] = v.int }     override inline val size: Int get() = intArray.size    inline val lastIndex get() = intArray.lastIndex    inline val indices get() = intArray.indices     override inline fun contains(element: ModInt): Boolean = element.int in intArray     override fun containsAll(elements: Collection<ModInt>): Boolean = elements.all(::contains)     override inline fun isEmpty(): Boolean = intArray.isEmpty()     override fun iterator(): Iterator<ModInt> = object: Iterator<ModInt> {        var index = 0        override fun hasNext(): Boolean = index < size        override fun next(): ModInt = get(index++)    }     fun copyOf(newSize: Int) = ModIntArray(intArray.copyOf(newSize))    fun copyOf() = copyOf(size)}fun ModIntArray.copyInto(destination: ModIntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size) =    ModIntArray(intArray.copyInto(destination.intArray, destinationOffset, startIndex, endIndex))inline fun ModIntArray(size: Int) = ModIntArray(IntArray(size))inline fun ModIntArray(size: Int, init: (Int) -> ModInt) = ModIntArray(IntArray(size) { init(it).int }) fun ModInt.powArray(n: Int) = ModIntArray(int.modPowArray(n, MOD)) inline fun ModIntArray.first() = get(0)inline fun ModIntArray.last() = get(lastIndex)inline fun ModIntArray.joinToString(separator: CharSequence) = intArray.joinToString(separator)inline fun <R> ModIntArray.fold(init: R, op: (acc: R, ModInt) -> R) = intArray.fold(init) { acc, i -> op(acc, ModInt(i)) }inline fun <R> ModIntArray.foldRight(init: R, op: (ModInt, acc: R) -> R) = intArray.foldRight(init) { i, acc -> op(ModInt(i), acc) }fun ModIntArray.sum() = fold(ModInt(0), ModInt::plus)fun ModIntArray.product() = fold(ModInt(1), ModInt::times) inline fun <T> Iterable<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Iterable<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }inline fun <T> Sequence<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Sequence<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }inline fun <T> Array<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Array<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }fun Iterable<ModInt>.sum() = sumByModInt { it }fun Sequence<ModInt>.sum() = sumByModInt { it }fun Iterable<ModInt>.product() = productByModInt { it }fun Sequence<ModInt>.product() = productByModInt { it }fun Collection<ModInt>.toModIntArray() = ModIntArray(size).also { var i = 0; for(e in this) { it[i++] = e } } /** IO *///@JvmField val ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null//const val PATH = ""src/main/resources/""//@JvmField val INPUT = File(PATH + ""input.txt"").inputStream()//@JvmField val OUTPUT = File(PATH + ""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar() else c    }} /** @param skipNext Whether to skip the next character (usually whitespace), defaults to true */fun readCharArray(n: Int, skipNext: Boolean = true): CharArray {    val res = CharArray(n) { readChar() }    if(skipNext) readChar()    return res} fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(c != '\n' && c != Char.MIN_VALUE) {            append(c)            c = readChar()        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /**  sort overrides to avoid quicksort attacks */ @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } inline fun <A, T> _mergeSort(a0: A, n: Int, tmp0: A, get: A.(Int) -> T, set: A.(Int, T) -> Unit, cmp: (T, T) -> Int) {    var a = a0    var tmp = tmp0    var len = 1    while(len < n) {        var l = 0        while(true) {            val m = l + len            if(m >= n) break            val r = min(n, m + len)            var i = l            var j = m            for(k in l until r) {                if(i != m && (j == r || cmp(a.get(i), a.get(j)) <= 0)) {                    tmp.set(k, a.get(i++))                } else tmp.set(k, a.get(j++))            }            l = r        }        for(i in l until n) tmp.set(i, a.get(i))        val t = a; a = tmp; tmp = t        len += len    }    if(a !== a0) for(i in 0 until n) a0.set(i, tmp0.get(i))} inline fun IntArray.sortWith(cmp: (Int, Int) -> Int) { _mergeSort(this, size, IntArray(size), IntArray::get, IntArray::set, cmp) }inline fun <T: Comparable<T>> IntArray.sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> IntArray.sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun IntArray.sort() { sortBy { it } }fun IntArray.sortDescending() { sortByDescending { it } } inline fun LongArray.sortWith(cmp: (Long, Long) -> Int) { _mergeSort(this, size, LongArray(size), LongArray::get, LongArray::set, cmp) }inline fun <T: Comparable<T>> LongArray.sortBy(func: (Long) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> LongArray.sortByDescending(func: (Long) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun LongArray.sort() { sortBy { it } }fun LongArray.sortDescending() { sortByDescending { it } } inline fun DoubleArray.sortWith(cmp: (Double, Double) -> Int) { _mergeSort(this, size, DoubleArray(size), DoubleArray::get, DoubleArray::set, cmp) }inline fun <T: Comparable<T>> DoubleArray.sortBy(func: (Double) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> DoubleArray.sortByDescending(func: (Double) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun DoubleArray.sort() { sortBy { it } }fun DoubleArray.sortDescending() { sortByDescending { it } } inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T : Comparable<T>> Array<out T>.sort() = _sort()inline fun <T : Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T : Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T : Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() // import preserving junk function@Suppress(""NonAsciiCharacters"") fun 雪花飄飄北風嘯嘯天地一片蒼茫() { iprintln(max(1, 2)) } fun IntArray.sumLong() = sumOf { it.toLong() } fun IntArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun IntArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun LongArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun LongArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun DoubleArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun DoubleArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> Array<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> Array<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> List<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> List<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) } // max/min Kotlin 1.6 -> 1.4 shimfun IntArray.max() = maxOf { it }fun IntArray.min() = minOf { it }fun LongArray.max() = maxOf { it }fun LongArray.min() = minOf { it }fun CharArray.max() = maxOf { it }fun CharArray.min() = minOf { it }fun <T : Comparable<T>> Iterable<T>.max() = maxOf { it }fun <T : Comparable<T>> Iterable<T>.min() = minOf { it }fun <T : Comparable<T>> Sequence<T>.max() = maxOf { it }fun <T : Comparable<T>> Sequence<T>.min() = minOf { it }","combinatorics,dp,math,probabilities"
"fun find1(n: Int): Int {    val two = mutableListOf<Int>()    for (i in 1 until n step 2) {        println(""? 2 $i ${i + 1} 1"")        val res = readLine()!!.trim().toInt()        if (res == 1) {            return i        }        if (res == 2) {            println(""? 2 ${i + 1} $i 1"")            val res2 = readLine()!!.trim().toInt()            if (res2 == 1) {                return i + 1            }        }    }    return n} fun main() {    repeat(readLine()!!.trim().toInt()){        val n = readLine()!!.trim().toInt()        val one = find1(n)        val result = IntArray(n).also{it[one - 1] = 1}        for (i in 1 .. n) {            if (i == one) continue            println(""? 1 $one $i ${n - 1}"")            val res = readLine()!!.trim().toInt()            result[i - 1] = res        }        println(result.joinToString("" "", prefix = ""! ""))    }}","constructive algorithms,interactive"
"fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()        fun query(t: Int, j: Int, k: Int, x: Int): Int {            println(""? $t $j $k $x"")            return readLine()!!.toInt()        }        val important = mutableListOf<Int>()        for (j in 1..n step 2) {            val r = query(2, j, if (j == n) 1 else (j + 1), 1)            if (r <= 2) {                important.add(j)                if (j != n) {                    important.add(j + 1)                }            }        }        var k = 0        for (j in important) {            if (query(2, j, if (j == n) 1 else (j + 1), 1) == 1) {                k = j            }        }        val answer = IntArray(n + 1)        answer[k] = 1        for (j in 1..n) {            if (j != k) {                answer[j] = query(1, k, j, n - 1)            }        }        println(""! "" + answer.joinToString("" "").substring(2))    }}","constructive algorithms,interactive"
"import java.util.* val scanner = Scanner(System.`in`) fun main() {    var t = scanner.nextInt()    while (t-- != 0) {        val n = scanner.nextInt()        val positionOne = findOne(n)        val ans = IntArray(n)        ans[positionOne] = 1        for (i in 0 until n) {            if (i == positionOne) continue            ans[i] = sendFirstQuery(positionOne + 1, i + 1, n - 1)        }        print(""! "")        for (item in ans) {            print(""$item "")        }        println()        System.out.flush()    }} fun findOne(n: Int): Int {    for (i in 0 until (n / 2)) {        val ans = sendSecondQuery(i * 2 + 1, i * 2 + 2, 1)        if (ans == 1) {            return i * 2        }        if (ans == 2) {            if (sendSecondQuery(i * 2 + 2, i * 2 + 1, 1) == 1)                return i * 2 + 1        }    }    return n - 1} fun sendSecondQuery(i: Int, j: Int, x: Int): Int {    println(""? 2 $i $j $x"")    System.out.flush()    return scanner.nextInt()}  fun sendFirstQuery(i: Int, j: Int, x: Int): Int {    println(""? 1 $i $j $x"")    System.out.flush()    return scanner.nextInt()}","constructive algorithms,interactive"
"fun main() {    val T=readLine()!!.toInt()    repeat(T){        val n= readLine()!!.toInt()        val arr=IntArray(n)        var i=1        var j=2        var x=1        var t=2        var ans:Int=0        while (j<=n){            println(""? $t $i $j $x"")            System.out.flush()            ans= readLine()!!.toInt()            if (ans==-1)return            if (ans==1){                arr[i-1]=1                break            }else if (ans==2){                x=j                j=i                i=x                x=1                println(""? $t $i $j $x"")                System.out.flush()                ans= readLine()!!.toInt()                if (ans==-1)return                if (ans==1) {                    arr[i - 1] = 1                    break                }                x=j                j=i                i=x                x=1            }            i+=2            j+=2        }        if (ans!=1){            arr[n-1]=1            i=n        }        t=1        x=n-1        for (index in 1..n){            if (i==index)continue            println(""? $t $i $index $x"")            System.out.flush()            ans= readLine()!!.toInt()            if (ans==-1)return            arr[index-1]=ans        }        println(arr.joinToString (separator = "" "",prefix = ""! ""))    }}","constructive algorithms,interactive"
"fun main() {    val (n, t) = readLine()!!.split("" "").map { it.toInt() }    val k = readLine()!!.toInt()    fun query(from: Int, to: Int): Int {        println(""? $from $to"")        return (to - from + 1) - readLine()!!.toInt()    }    var lower = 1    var upper = n    while (upper > lower) {        val mid = (upper + lower) / 2        if (query(1, mid) >= k) {            upper = mid        } else {            lower = mid + 1        }    }    println(""! $lower"")}","binary search,interactive"
"fun main() {    fun readInt() = readLine()!!.toInt()    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val (numElements, _) = readInts()    var goal = readInt()    var left = 1    var right = numElements    while (left < right) {        val middle = left + ((right - left) ushr 1)        println(""? $left $middle"")        val numZeros = middle - left + 1 - readInt()        if (numZeros < goal) {            left = middle + 1            goal -= numZeros        } else {            right = middle        }    }    println(""! $left"")}","binary search,interactive"
"import java.io.BufferedReaderimport java.io.PrintWriter val bin = System.`in`.bufferedReader()val out = PrintWriter(System.out, true)fun BufferedReader.readInt() = this.readLine()!!.toInt()fun BufferedReader.readInts() = this.readLine()!!.split(' ').map { it.toInt() } fun main() {    val (n, _) = bin.readInts()    val k = bin.readInt()    val pos = findPos(n, k)    out.println(""! ${pos+1}"")} fun ask(l: Int, r: Int): Int {    out.println(""? ${l+1} ${r+1}"")    return bin.readInt()} fun findPos(n: Int, k_in: Int): Int {    var k = k_in    var l = 0    var r = n-1     while (l != r) {        val m = (l + r) / 2        val sum = ask(l, m)        val numZeros = m - l + 1 - sum         if (numZeros >= k) {            r = m        } else {            l = m+1            k -= numZeros        }    }     return l}","binary search,interactive"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.* fun main() {    fun solve() {        val n = Parser.parseInt()        val t = Parser.parseInt()         for(i in 0 until t) {            val k = Parser.parseInt()             var l = 0            var r = n + 1             while(l + 1 < r) {                val m = (l + r) / 2                println(""? 1 $m"")                System.out.flush()                val o = Parser.parseInt()                if(m - o < k) l = m                else r = m            }            println(""! $r"")            System.out.flush()        }    }     val t = 1    for (i in 0 until t) {        solve()    }} sealed class Parser {    companion object {        private val reader = BufferedReader(InputStreamReader(System.`in`))        private var tokenizer: StringTokenizer? = null         fun parseInt(): Int {            fill()            return tokenizer!!.nextToken().toInt()        }         fun parseLong(): Long {            fill()            return tokenizer!!.nextToken().toLong()        }         fun parseDouble(): Double {            fill()            return tokenizer!!.nextToken().toDouble()        }         fun parseString(): String {            fill()            return tokenizer!!.nextToken().toString()        }         fun parseLine(): String {            return readLine()!!        }         private fun fill() {            while (tokenizer == null || !tokenizer!!.hasMoreElements()) {                tokenizer = StringTokenizer(reader.readLine())            }        }    }}","binary search,interactive"
"import java.util.* fun main() {    for (c in 1..readLine()!!.toInt()) {        val n = readLine()!!.toInt()        fun query1(a: Int, b: Int): Boolean {            println(""1 $a $b"")            return readLine() == ""1""        }        fun query2(a: Int, bs: List<Int>): Boolean {            println(""2 $a ${bs.size} ${bs.joinToString("" "")}"")            return readLine() == ""1""        }        fun sort(nodes: List<Int>): List<Int> {            if (nodes.size == 1) {                return nodes            } else {                val left = sort(nodes.subList(0, nodes.size / 2))                val right = sort(nodes.subList(nodes.size / 2, nodes.size))                val res = mutableListOf<Int>()                var j = 0                var k = 0                while (j < left.size && k < right.size) {                    if (query1(left[j], right[k])) {                        res.add(left[j])                        j++                    } else {                        res.add(right[k])                        k++                    }                }                while (j < left.size) {                    res.add(left[j])                    j++                }                while (k < right.size) {                    res.add(right[k])                    k++                }                return res            }        }        val sorted = sort((0 until n).toList())        val stack = Stack<List<Int>>()        for (a in sorted) {            val component = mutableListOf(a)            while (stack.isNotEmpty()) {                val queried = mutableListOf<Int>()                for (other in stack) {                    queried.addAll(other)                }                if (query2(a, queried)) {                    component.addAll(stack.pop())                } else {                    break                }            }            stack.push(component)        }        val position = IntArray(n)        for ((j, component) in stack.withIndex()) {            for (a in component) {                position[a] = j            }        }        println(3)        for (a in 0 until n) {            println(CharArray(n) { b -> if (position[a] <= position[b]) '1' else '0' })        }        if (readLine() == ""-1"" ) {            return        }    }}","binary search,graphs,interactive,sortings,two pointers"
"import java.io.BufferedReader val bin = System.`in`.bufferedReader()fun BufferedReader.readInt() = this.readLine()!!.toInt()fun BufferedReader.readLongs() = this.readLine()!!.split(' ').map { it.toLong() } fun main() {    repeat(bin.readInt()) {        bin.readInt()        val vs = solve(bin.readLongs().sorted())        println(vs?.joinToString(separator="" "") ?: ""-1"")    }} fun solve(vs: List<Long>): List<Long>? {    val n = vs.size    val sum = vs.sum()    for (i in vs.indices) {        val x = vs[i]        if ((sum - x) % 2 == 1L) continue        val s = (sum - x) / 2        val idx = if (i != n-1 && vs[n-1] == s) n-1 else if (i != n-2 && vs[n-2] == s) n-2 else null        if (idx != null) {            return vs.filterIndexed { index, _ -> index != i && index != idx }        }    }    return null}","constructive algorithms,data structures,greedy"
"import java.lang.RuntimeExceptionimport java.util.* fun main(args: Array<String>) = with(Scanner(System.`in`)) {    val t = nextInt()//    val t = 1    repeat(t) {        val n = nextInt()        val a = (0 until n + 2).map { nextLong() }.sorted()        // 1 2 3 1 6        val totalSum = a.sum()        val last = a.last()        var r = -1        var rr = -1        if (totalSum - last - a[a.size - 2] == a[a.size - 2]) {            r = a.size - 1            rr = a.size - 2        } else {            for (i in 0 until a.size - 1) {                if (totalSum - a[i] - last == last) {                    r = i                    rr = a.size - 1                    break                }            }        }        if (r < 0) {            println(-1)        } else {            println(a.filterIndexed { index, l -> index != r && index != rr }.joinToString("" ""))        }    }}","constructive algorithms,data structures,greedy"
"import java.io.BufferedReaderimport java.io.InputStreamReader fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val out = StringBuilder()    cases@for (c in 1..jin.readLine().toInt()) {        val n = jin.readLine().toInt()        val xs = jin.readLine().split("" "").map { it.toLong() }        val freq = mutableMapOf<Long, Int>()        for (x in xs) {            freq[x] = (freq[x] ?: 0) + 1        }        val sum = xs.sum()        for (x in xs) {            freq[x] = freq[x]!! - 1            if ((sum - x) % 2L == 0L && freq[(sum - x) / 2L] ?: 0 != 0) {                val answer = xs.toMutableList()                answer.remove(x)                answer.sort()                answer.removeAt(answer.lastIndex)                out.appendln(answer.joinToString("" ""))                continue@cases            }            freq[x] = freq[x]!! + 1        }        out.appendln(-1)    }    print(out)}","constructive algorithms,data structures,greedy"
"fun main() {    val t = readLine()!!.toInt()     repeat(t) {        val n = readLine()!!.toInt()        val array = readLine()!!.trim().split("" "").map { it.toLong() }.toMutableList()        array.sort()         var sum = 0L        for (i in 0 until n) {            sum += array[i]        }         if (sum > array[n + 1]) {            println(-1)            return@repeat        }         if (sum == array[n] || sum == array[n + 1]) {            for (i in 0 until n) {                print(""${array[i]} "")            }            println()            return@repeat        }         val neededValue = array[n] - (array[n + 1] - sum)         if (neededValue <= 0) {            println(-1)            return@repeat        }         val found = array.binarySearch(neededValue, fromIndex = 0, toIndex = n)        if (found < 0 || array[found] != neededValue) {            println(-1)            return@repeat        } else {            for (i in 0..n) {                if (i == found) continue                 print(""${array[i]} "")            }            println()        }    }}","constructive algorithms,data structures,greedy"
"import kotlin.math.* fun main() {    val t = readLine()!!.toInt()    for (i in 0 until t) {        val n = readLine()!!.toInt()        val tally = readLine()!!.split("" "").groupingBy { it.toInt() }.eachCount()        println(max(n % 2, 2 * tally.values.maxOf { it } - n))    }}","constructive algorithms,data structures,greedy"
"fun main() {    val T=readLine()!!.toInt();    repeat(T) {        val n=readLine()!!.toInt();        val a=readLine()!!.split("" "").map { it.toInt() };        val map=HashMap<Int, Int>();        var maxCount=0;        a.forEach{            map[it]=map.getOrDefault(it, 0)+1;            maxCount=Math.max(maxCount, map[it]!!);        }        println(Math.max(n%2, n-2*(n-maxCount)));    }}","constructive algorithms,data structures,greedy"
"import java.util.*;import java.io.*;fun main() {    val t = readLine()!!.toInt();    repeat(t){        val n = readLine()!!.toInt();        val a = readLine()!!.split("" "").map { it.toInt() }        val map = HashMap<Int,Int>();        a.forEach{            map[it] = map.getOrDefault(it,0)+1;        }        var max = Integer.MIN_VALUE;        map.forEach{            max = Math.max(max,it.value);        }        println(Math.max(max-(n-max),n%2));    }}","constructive algorithms,data structures,greedy"
import java.util.* fun main() {	val T = readLine()!!.trim().toInt() 	for (t in 0 until T) {		val n= readLine()!!.trim().toInt()		val a = readLine()!!.trim().split(' ').map(String::toInt) 		val map = a.groupBy { it }.mapValues { it.value.size } 		val pq = PriorityQueue<Int>(reverseOrder())		for (v in map.values) pq.offer(v) 		while (pq.size > 1) {			val a = pq.poll()!!			val b = pq.poll()!! 			if (b == 0) {				pq.offer(a)				break			} 			pq.offer(a - 1)			pq.offer(b - 1)		} 		println(pq.poll())	}},"constructive algorithms,data structures,greedy"
"import java.util.* fun main() {    repeat(readLine()!!.toInt()) {        val (n, W) = readLine()!!.split("" "").map { it.toInt() }         val w = readLine()!!.split("" "").mapIndexed { index, s -> Rect(index, s.toInt()) }        val order = TreeSet<Rect>(compareBy({ it.w }, { it.n })).apply { addAll(w) }         var count = 0        var rest = 0        while (order.size > 0) {            val x = order.floor(Rect(n + 1, rest))            if (x == null) {                count += 1                rest = W            } else {                order.remove(x)                rest -= x.w            }        }        println(count)    }} private data class Rect(val n: Int, val w: Int)","binary search,bitmasks,data structures,greedy"
"import java.util.PriorityQueueprivate fun readLn() = readLine()!! private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "") private fun readInts() = readStrings().map { it.toInt() }   fun main() {    var tc = readInt()     repeat(tc) {        var(n,l) = readInts()         var arr = readInts().toMutableList()          arr.sort()         // print(arr)        var ans = 0 ;        var temp : Int ;         var lo = PriorityQueue<Int>(compareBy { -it })        lo.add(0)        for(i in n-1 downTo 0) {            temp = lo.poll()             if(arr[i] > temp) {                lo.add(temp)                lo.add(l-arr[i])                 ans += 1             }            else {                lo.add(temp-arr[i])             }         }        println(ans)    }}","binary search,bitmasks,data structures,greedy"
"fun main() {   repeat(readLine()!!.toInt()) {       val (n,W) = readLine()!!.split("" "").map { it.toInt() }       val w = readLine()!!.split("" "").map { it.toInt() }        val map = w.groupingBy { it }.eachCount().toSortedMap(reverseOrder()).toMutableMap()        var curr = W       var ans = 0         while(hasRectangles(map)) {           var rectangleSet = false           for ((k,v) in map) {               if (v > 0 && curr >= k) {                   curr -=k                   map[k]=map[k]!!-1                   rectangleSet = true                   break               }           }           if(!rectangleSet) {               ans++               curr = W           }        }        println(ans+1)    } } fun hasRectangles(map: MutableMap<Int, Int>): Boolean {    return map.any { it.value > 0 }}    ","binary search,bitmasks,data structures,greedy"
"fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main() {    repeat(readInt()) {        val (_, w) = readInts()        val vs = readInts()        println(solve(Multiset(vs), w))    }} fun solve(boxes: Multiset<Int>, w: Int): Int {    var res = 1    var left = w    while (!boxes.isEmpty()) {        val options = boxes.vs.keys.filter { it <= left }        if (options.isEmpty()) {            left = w            res++        } else {            val next = options.max()!!            boxes.remove(next)            left -= next        }    }     return res} class Multiset<T>(initial: Collection<T>) {    // value -> # of copies    val vs = mutableMapOf<T, Int>()     init {        initial.forEach { add(it) }    }     fun add(elt: T) {        vs.merge(elt, 1, Int::plus)    }     fun remove(elt: T) {        vs[elt] = vs[elt]!! - 1        if (vs[elt] == 0) {            vs.remove(elt)        }    }     fun contains(i: T): Boolean = vs.containsKey(i)     fun isEmpty(): Boolean = vs.isEmpty()}","binary search,bitmasks,data structures,greedy"
"fun main() {    repeat(readLine()!!.toInt()) {        val (p, a, b, c) = readLine()!!.split("" "").map { it.toLong() }         println(listOf(a, b, c).map { (it - p % it) % it }.min())    }}",math
"fun main() {    for (c in 1..readLine()!!.toInt()) {        val line = readLine()!!.split("" "").map { it.toLong() }        println(line.subList(1, 4).map { it * ((line[0] + it - 1L) / it) }.min()!! - line[0])    }}",math
"fun main(){    var t = readLine()!!.toLong()    for(_t in 1..t){        var arr = readLine()!!.split("" "").map{ it.toLong() }        println(arr.subList(1 , 4).map{ it * ((arr[0] + it - 1L)/it) }.min()!! - arr[0])    }}",math
"fun main() {    repeat(readLine()!!.toInt()) {        val d0 = readLine()!!.split("" "").map { it.toLong() }        val p = d0[0]        val d = d0.drop(1)        val ans = d.minOf { a -> a - (p - 1) % a - 1 }        println(ans)    }}",math
"import java.io.BufferedInputStreamimport java.util.*import kotlin.math.max const val BLOCK = 320 fun main() {    val jin = FastScanner()    val n = jin.nextInt()    val q = jin.nextInt()    val parent = IntArray(n + 1)    for (a in 2..n) {        parent[a] = jin.nextInt()    }    val nextAncestor = IntArray(n + 1)    parent[1] = 1    nextAncestor[1] = 1    val rem = IntArray(n + 1)    val delta = IntArray((n / BLOCK) + 1)    for (a in 2..n) {        if (parent[a] / BLOCK == a / BLOCK) {            nextAncestor[a] = nextAncestor[parent[a]]            rem[a / BLOCK]++        } else {            nextAncestor[a] = parent[a]        }    }    val isBoundary = BooleanArray(n + 1)    for (a in 0..n step BLOCK) {        isBoundary[a] = true    }    val out = StringBuilder()    fun getParent(a: Int) = max(1, parent[a] - delta[a / BLOCK])    fun getNextAncestor(a: Int) = if (getParent(a) / BLOCK == a / BLOCK) nextAncestor[a] else getParent(a)    for (j in 1..q) {        if (jin.nextInt() == 1) {            val from = jin.nextInt()            val to = jin.nextInt()            val x = jin.nextInt()            var a = from            while (a <= n && (a <= to || !isBoundary[a])) {                if (a <= to) {                    if (isBoundary[a] && a + BLOCK - 1 <= to && rem[a / BLOCK] == 0) {                        delta[a / BLOCK] += x                        a += BLOCK                    } else {                        if (parent[a] / BLOCK == a / BLOCK) {                            parent[a] -= x                            parent[a] = max(1, parent[a])                            if (parent[a] / BLOCK == a / BLOCK) {                                nextAncestor[a] = getNextAncestor(parent[a])                            } else {                                rem[a / BLOCK]--                            }                        } else {                            parent[a] -= x                        }                        a++                    }                } else {                    if (parent[a] / BLOCK == a / BLOCK) {                        nextAncestor[a] = getNextAncestor(parent[a])                    }                    a++                }            }        } else {            var a = jin.nextInt()            var b = jin.nextInt()            var c = a            var d = b            while (c != d) {                if (c > d) {                    a = c                    c = getNextAncestor(c)                } else {                    b = d                    d = getNextAncestor(d)                }            }            while (a != b) {                if (a > b) {                    a = getParent(a)                } else {                    b = getParent(b)                }            }            out.appendln(a)        }    }    print(out)} class FastScanner {    private val BS = 1 shl 16    private val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC    private var `in`: BufferedInputStream? = null     constructor() {        `in` = BufferedInputStream(System.`in`, BS)    }     private val char: Char        private get() {            while (bId == size) {                size = try {                    `in`!!.read(buf)                } catch (e: Exception) {                    return NC                }                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c >= '0' && c <= '9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }}","data structures,trees"
"fun main() {    repeat(readLine()!!.toInt()) {        val (x, y) = readLine()!!.split(' ').map { it.toInt() }        println((1 until 100_000).takeWhile { r -> r * (r + 2) <= x && r + 1 <= y }.map { r ->            minOf(y - r, x / r - r - 1).toLong()        }.fold(0L) { a, b -> a + b })    }}","binary search,brute force,math,number theory"
"fun solve(){    var (x, y) = readLine()!!.split("" "").map { it.toLong() }    var ans = 0L    for(i in 1 until 100000) {        var l = i + 1        var r = x/i - 1        if(r > y) r = y        if(l <= r) ans += r - l + 1    }    println(ans)} fun main() {    var t = readLine()!!.toInt()    for (i in 0 until t) {        solve()    }}","binary search,brute force,math,number theory"
"import kotlin.math.maximport kotlin.math.min fun main() {    repeat(readLine()!!.toInt()) {        val (x, y) = readLine()!!.split("" "").map { it.toInt() }         var i = 1        var sum = 0L        while (i * i <= x) {            val m = min((x - i) / i, y)            sum += max(0, m - i)            i++        }        println(sum)    }}","binary search,brute force,math,number theory"
"import kotlin.math.min fun readInt() = readLine()!!.toInt()fun readLongs() = readLine()!!.split(' ').map { it.toLong() } fun main() {    repeat(readInt()) {        val (x, y) = readLongs()        var res = 0L        for (i in 1..y) {            val b = i+1            val minA = i*b + i            if (minA > x) break            res += min(y-i, 1 + (x-minA) / i)        }        println(res)    }}","binary search,brute force,math,number theory"
"import java.io.BufferedInputStreamimport kotlin.math.max const val MOD = 998244853 fun main() {    val jin = FastScanner()    val n = jin.nextInt()    val x = jin.nextInt()    val children = Array(n + 1) { mutableListOf<Int>() }    for (a in 2..n) {        children[jin.nextInt()].add(a)    }    val depth = IntArray(n + 1)    val freq = IntArray(n)    val maxDepth = IntArray(n + 1) { 1 }    maxDepth[0] = 0    fun dfs(a: Int) {        for (b in children[a]) {            depth[b] = depth[a] + 1            dfs(b)            maxDepth[a] = max(maxDepth[a], maxDepth[b] + 1)        }        freq[depth[a]]++    }    dfs(1)    val freqs = IntArray(n + 1)    for (d in 0 until n) {        freqs[freq[d]]++    }    val ways = Array(2) { IntArray(n + 1) }    ways[0][0] = 1    for (f in 1..n) {        if (freqs[f] > 0) {            for (j in 0..n) {                ways[1][j] = ways[0][j]                if (j >= f) {                    ways[1][j] += ways[1][j - f]                }                if (j >= f * freqs[f]) {                    ways[1][j] -= ways[0][j - (f * freqs[f])]                }                if (ways[1][j] >= MOD) {                    ways[1][j] -= MOD                } else if (ways[1][j] < 0) {                    ways[1][j] += MOD                }            }            for (j in 0..n) {                ways[0][j] = ways[1][j]                if (j >= f) {                    ways[0][j] += ways[1][j - f]                    if (ways[0][j] >= MOD) {                        ways[0][j] -= MOD                    }                }            }        }    }    //println(ways[0].contentToString())    val dummy = IntArray(0)    val waysReduced = Array(n + 1) { dummy }    for (f in 1..n) {        if (freqs[f] > 0) {            waysReduced[f] = IntArray(n + 1)            for (j in 0..n) {                waysReduced[f][j] = ways[0][j]                if (j >= f) {                    waysReduced[f][j] -= waysReduced[f][j - f]                }                if (waysReduced[f][j] < 0) {                    waysReduced[f][j] += MOD                }            }            //println(""waysReduced[$f] = ${waysReduced[f].contentToString()}"")        }    }    //println(ways[q].contentToString())    val eachDepth = Array(n) { mutableListOf(0) }    for (a in 1..n) {        eachDepth[depth[a]].add(a)    }    fun checkPossible(j: Int, notIncluding: Int) = j in 0..n && waysReduced[freq[notIncluding]][j] != 0    var optimal = n + 1    var optimalD = 0    var optimalJ = 0    var optimalDir = true    for (d in 0 until n) {        if (freq[d] > 0) {            eachDepth[d].sortBy { a -> maxDepth[a] }            for ((j, a) in eachDepth[d].withIndex()) {                //println(""d = $d, freq = ${freq[d]}, j = $j, a = $a"")                if (maxDepth[a] < optimal) {                    if (checkPossible(x - j, d)) {                        optimal = maxDepth[a]                        optimalD = d                        optimalJ = j                        optimalDir = false                    } else if (checkPossible(x + j - freq[d], d)) {                        optimal = maxDepth[a]                        optimalD = d                        optimalJ = j                        optimalDir = true                    }                }            }        }    }    //println(""penalty = $optimal, d =  $optimalD, j = $optimalJ, dir = $optimalDir"")    freqs[freq[optimalD]]--    val prev = IntArray(n + 1) { -1 }    val usedF = IntArray(n + 1)    prev[0] = -2    for (f in 1..n) {        if (freqs[f] > 0) {            for (j in f..n) {                if (prev[j] == -1 && prev[j - f] != -1) {                    if (usedF[j - f] != f) {                        prev[j] = j - f                        usedF[j] = f                    } else if (prev[j - f] >= j - (f * freqs[f])) {                        prev[j] = prev[j - f]                        usedF[j] = f                    }                }            }        }    }    val answer = CharArray(n + 1) { 'b' }    var k = if (optimalDir) (x + optimalJ - freq[optimalD]) else (x - optimalJ)    val buckets = Array(n) { mutableListOf<Int>() }    for (d in 0 until n) {        if (d != optimalD) {            for (a in eachDepth[d]) {                if (a != 0) {                    buckets[freq[d]].add(a)                }            }        }    }    //println(buckets.contentToString())    while (k != 0) {        //println(""k = $k, prev = ${prev[k]}, usedF = ${usedF[k]},"")        for (j in 0 until k - prev[k]) {            answer[buckets[usedF[k]][j]] = 'a'        }        k = prev[k]    }    for (j in 1 until eachDepth[optimalD].size) {        if (j > optimalJ == optimalDir) {            answer[eachDepth[optimalD][j]] = 'a'        }    }    println(maxDepth[1] + optimal)    println(String(answer).substring(1))} class FastScanner {    private val BS = 1 shl 16    private val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC    private var `in`: BufferedInputStream? = null     constructor() {        `in` = BufferedInputStream(System.`in`, BS)    }     private val char: Char        private get() {            while (bId == size) {                size = try {                    `in`!!.read(buf)                } catch (e: Exception) {                    return NC                }                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c >= '0' && c <= '9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }} /*9 21 1 1 3 4 2 4 3  */","dp,greedy,trees"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"")@file:OptIn(ExperimentalUnsignedTypes::class, ExperimentalStdlibApi::class) import java.io.PrintWriterimport kotlin.math.*import kotlin.random.Randomimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {//    val startTime = System.nanoTime()     val numCases = 1//readInt()    case@ for(case in 1..numCases) {        //print(""Case #$case: "")         val n = readInt()        val x = readInt()         val G = Array(n) { IntList() }        //val par = IntArray(n)        for(i in 1 until n) {            val p = readInt() - 1            //par[i] = p            G[p].add(i)        }         val depth = IntArray(n)        val stk = intListOf(0)        while(stk.isNotEmpty()) {            val u = stk.pop()            for(v in G[u]) {                depth[v] = depth[u] + 1                stk.add(v)            }        }         val h = depth.max() + 1        val nodesByDepth = Array(h) { IntList() }        for(i in 0 until n) nodesByDepth[depth[i]].add(i)         val sorted = nodesByDepth.sortedBy { it.size }         val dp = arrayOfNulls<IntList>(x+1)        dp[0] = IntList()        var runI = 0        for(runJ in 1..h) if(runJ == h || sorted[runJ].size != sorted[runI].size) {            val v = sorted[runI].size            val f = runJ - runI             for(r in x-v+1 .. x) {                var j = x                for(i in r downTo 0 step v) if(dp[i] != null) {                    var p = runI                    for(k in i+v .. min(j, i+v*f) step v) {                        dp[k] = sorted[p++]                    }                    j = i-1                }            }             if(dp[x] != null) break             runI = runJ        }         val ans = CharArray(n) { 'b' }        val score = if(dp[x] != null) {            var p = x            while(p > 0) {                val d = dp[p]!!                for(u in d) ans[u] = 'a'                p -= d.size            }             h        } else {            var y = x            var m = n             for(i in 0 until h) {                val nodes = nodesByDepth[i]                val a = nodes.size                when {                    a <= y -> {                        for(u in nodes) ans[u] = 'a'                        y -= a                    }                    a > m-y -> {                        var l = 0                        for(u in nodes) if(G[u].isEmpty()) l++                         val ch = if(l >= y) 'a' else 'b'                        if(ch == 'b') {                            for(j in i until h) for(u in nodesByDepth[j]) ans[u] = 'a'                            y = m-y                        }                         for(u in nodes) if(G[u].isEmpty()) {                            ans[u] = ch                            if(--y == 0) break                        }                         break                    }                }                 m -= a            }             h+1        }         println(score)        println(ans)    } //    iprintln(""Time: ${(System.nanoTime() - startTime) / 1000000} ms"")} class IntList(initialCapacity: Int = 12) {    private var arr = IntArray(initialCapacity)    val _arr get() = arr    private val capacity get() = arr.size    var size = 0        private set    inline val lastIndex get() = size - 1    inline val indices get() = 0 until size     constructor(copyFrom: IntArray): this(copyFrom.size) { copyFrom.copyInto(arr); size = copyFrom.size }    constructor(copyFrom: Collection<Int>): this(copyFrom.size) { arr = copyFrom.toIntArray(); size = copyFrom.size }     fun contentEquals(other: IntList): Boolean {        return this === other || size == other.size && indices.all { this[it] == other[it] }    }     private fun grow(minCapacity: Int = 8) {        val newCapacity = maxOf(minCapacity, capacity + (capacity shr 1))        arr = arr.copyOf(newCapacity)    }     fun ensureCapacity(minCapacity: Int) { if(capacity < minCapacity) grow(minCapacity) }     operator fun get(index: Int): Int {        require(index in 0 until size)        return arr[index]    }     operator fun set(index: Int, value: Int) {        require(index in 0 until size)        arr[index] = value    }     fun add(value: Int) {        if(size == capacity) grow()        arr[size++] = value    }     fun addAll(list: IntList) {        ensureCapacity(size + list.size)        list.arr.copyInto(arr, size, 0, list.size)        size += list.size    }     fun add(index: Int, element: Int) {        if(size == capacity) grow()        arr.copyInto(arr, index + 1, index, size)        size++        set(index, element)    }     fun clear() { size = 0 }     fun removeAt(index: Int): Int {        val e = get(index)        arr.copyInto(arr, index, index + 1, size)        size--        return e    }     fun indexOf(e: Int): Int {        for(i in 0 until size) if(this[i] == e) return i        return -1    }     fun remove(e: Int): Boolean {        val i = indexOf(e)        if(i == -1) return false        removeAt(i)        return true    }     operator fun iterator() = object: IntIterator() {        private var pos = 0        override fun hasNext() = pos < size        override fun nextInt() = get(pos++)    }     inline fun isEmpty() = size == 0    inline fun isNotEmpty() = size != 0     fun pop() = arr[--size]     fun popToSize(s: Int) {        require(s >= 0)        if(s < size) size = s    }     fun swap(i: Int, j: Int) { val t = this[i]; this[i] = this[j]; this[j] = t }    fun reverse() {        for(i in 0 until size / 2) swap(i, lastIndex - i)    }     fun shuffle(rnd: Random = random) { for(i in lastIndex downTo 1) swap(i, rnd.nextInt(i+1)) }     inline fun sortWith(cmp: (Int, Int) -> Int) { _mergeSort(_arr, size, IntArray(size), IntArray::get, IntArray::set, cmp) }    inline fun <T: Comparable<T>> sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }    inline fun <T: Comparable<T>> sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }    fun sort() { sortBy { it } }    fun sortDescending() { sortByDescending { it } }     fun joinToString(separator: CharSequence) = if(size == 0) """" else let {        buildString {            append(it[0])            for (i in 1 until size) {                append(separator).append(it[i])            }        }    }     override fun toString() = ""["" + joinToString("", "") + ""]""     fun toIntArray() = arr.copyOf(size)    fun toList() = List(size, ::get)     inline fun first() = get(0)    inline fun last() = get(lastIndex)} inline fun IntList(size: Int, init: (Int) -> Int) = IntList(size).apply {    for(i in 0 until size) { add(init(i)) }}inline fun IntArray.toIntList() = IntList(this)inline fun Collection<Int>.toIntList() = IntList(this)inline fun intListOf(vararg values: Int) = IntList(values) fun IntList.max() = (1 until size).fold(this[0]) { acc, i -> max(acc, this[i]) }fun IntList.min() = (1 until size).fold(this[0]) { acc, i -> min(acc, this[i]) }fun IntList.getOrNull(i: Int) = if(i in indices) get(i) else nullinline fun IntList.count(predicate: (Int) -> Boolean) = indices.count { predicate(this[it]) }fun IntList.copyOf() = IntList(size, ::get)  /** IO *///@JvmField val ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null//const val PATH = ""src/main/resources/""//@JvmField val INPUT = File(PATH + ""input.txt"").inputStream()//@JvmField val OUTPUT = File(PATH + ""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar() else c    }} /** @param skipNext Whether to skip the next character (usually whitespace), defaults to true */fun readCharArray(n: Int, skipNext: Boolean = true): CharArray {    val res = CharArray(n) { readChar() }    if(skipNext) readChar()    return res} fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(c != '\n' && c != Char.MIN_VALUE) {            append(c)            c = readChar()        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /**  sort overrides to avoid quicksort attacks */ @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } inline fun <A, T> _mergeSort(a0: A, n: Int, tmp0: A, get: A.(Int) -> T, set: A.(Int, T) -> Unit, cmp: (T, T) -> Int) {    var a = a0    var tmp = tmp0    var len = 1    while(len < n) {        var l = 0        while(true) {            val m = l + len            if(m >= n) break            val r = min(n, m + len)            var i = l            var j = m            for(k in l until r) {                if(i != m && (j == r || cmp(a.get(i), a.get(j)) <= 0)) {                    tmp.set(k, a.get(i++))                } else tmp.set(k, a.get(j++))            }            l = r        }        for(i in l until n) tmp.set(i, a.get(i))        val t = a; a = tmp; tmp = t        len += len    }    if(a !== a0) for(i in 0 until n) a0.set(i, tmp0.get(i))} inline fun IntArray.sortWith(cmp: (Int, Int) -> Int) { _mergeSort(this, size, IntArray(size), IntArray::get, IntArray::set, cmp) }inline fun <T: Comparable<T>> IntArray.sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> IntArray.sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun IntArray.sort() { sortBy { it } }fun IntArray.sortDescending() { sortByDescending { it } } inline fun LongArray.sortWith(cmp: (Long, Long) -> Int) { _mergeSort(this, size, LongArray(size), LongArray::get, LongArray::set, cmp) }inline fun <T: Comparable<T>> LongArray.sortBy(func: (Long) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> LongArray.sortByDescending(func: (Long) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun LongArray.sort() { sortBy { it } }fun LongArray.sortDescending() { sortByDescending { it } } inline fun DoubleArray.sortWith(cmp: (Double, Double) -> Int) { _mergeSort(this, size, DoubleArray(size), DoubleArray::get, DoubleArray::set, cmp) }inline fun <T: Comparable<T>> DoubleArray.sortBy(func: (Double) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> DoubleArray.sortByDescending(func: (Double) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun DoubleArray.sort() { sortBy { it } }fun DoubleArray.sortDescending() { sortByDescending { it } } inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T : Comparable<T>> Array<out T>.sort() = _sort()inline fun <T : Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T : Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T : Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() // import preserving junk function@Suppress(""NonAsciiCharacters"") fun 雪花飄飄北風嘯嘯天地一片蒼茫() { iprintln(max(1, 2)) } fun IntArray.sumLong() = sumOf { it.toLong() } fun IntArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun IntArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun LongArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun LongArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun DoubleArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun DoubleArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> Array<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> Array<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> List<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> List<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) } // max/min Kotlin 1.6 -> 1.4 shimfun IntArray.max() = maxOf { it }fun IntArray.min() = minOf { it }fun LongArray.max() = maxOf { it }fun LongArray.min() = minOf { it }fun CharArray.max() = maxOf { it }fun CharArray.min() = minOf { it }fun <T : Comparable<T>> Iterable<T>.max() = maxOf { it }fun <T : Comparable<T>> Iterable<T>.min() = minOf { it }fun <T : Comparable<T>> Sequence<T>.max() = maxOf { it }fun <T : Comparable<T>> Sequence<T>.min() = minOf { it }","dp,greedy,trees"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"")@file:OptIn(ExperimentalUnsignedTypes::class, ExperimentalStdlibApi::class) import java.io.PrintWriterimport kotlin.math.*import kotlin.random.Randomimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {//    val startTime = System.nanoTime()     val numCases = 1//readInt()    case@ for(case in 1..numCases) {        //print(""Case #$case: "")         val n = readInt()        var x = readInt()        val rev = x+x > n        if(rev) x = n-x         val G = Array(n) { IntList() }        //val par = IntArray(n)        for(i in 1 until n) {            val p = readInt() - 1            //par[i] = p            G[p].add(i)        }         val depth = IntArray(n)        val stk = intListOf(0)        while(stk.isNotEmpty()) {            val u = stk.pop()            for(v in G[u]) {                depth[v] = depth[u] + 1                stk.add(v)            }        }         val h = depth.max() + 1        val nodesByDepth = Array(h) { IntList() }        for(i in 0 until n) nodesByDepth[depth[i]].add(i)         val sorted = nodesByDepth.sortedBy { it.size }         val dp = arrayOfNulls<IntList>(x+1)        dp[0] = IntList()        var runI = 0        for(runJ in 1..h) if(runJ == h || sorted[runJ].size != sorted[runI].size) {            val v = sorted[runI].size            val f = runJ - runI             for(r in x-v+1 .. x) {                var j = x                for(i in r downTo 0 step v) if(dp[i] != null) {                    var p = runI                    for(k in i+v .. min(j, i+v*f) step v) {                        dp[k] = sorted[p++]                    }                    j = i-1                }            }             if(dp[x] != null) break             runI = runJ        }         val ans = CharArray(n) { 'b' }        val score = if(dp[x] != null) {            var p = x            while(p > 0) {                val d = dp[p]!!                for(u in d) ans[u] = 'a'                p -= d.size            }             h        } else {            var y = x            var m = n             for(i in 0 until h) {                val nodes = nodesByDepth[i]                val a = nodes.size                when {                    a <= y -> {                        for(u in nodes) ans[u] = 'a'                        y -= a                    }                    a > m-y -> {                        var l = 0                        for(u in nodes) if(G[u].isEmpty()) l++                         val ch = if(l >= y) 'a' else 'b'                        if(ch == 'b') {                            for(j in i until h) for(u in nodesByDepth[j]) ans[u] = 'a'                            y = m-y                        }                         for(u in nodes) if(G[u].isEmpty()) {                            ans[u] = ch                            if(--y == 0) break                        }                         break                    }                }                 m -= a            }             h+1        }         if(rev) for(i in 0 until n) ans[i] = if(ans[i] == 'a') 'b' else 'a'         println(score)        println(ans)    } //    iprintln(""Time: ${(System.nanoTime() - startTime) / 1000000} ms"")} class IntList(initialCapacity: Int = 12) {    private var arr = IntArray(initialCapacity)    val _arr get() = arr    private val capacity get() = arr.size    var size = 0        private set    inline val lastIndex get() = size - 1    inline val indices get() = 0 until size     constructor(copyFrom: IntArray): this(copyFrom.size) { copyFrom.copyInto(arr); size = copyFrom.size }    constructor(copyFrom: Collection<Int>): this(copyFrom.size) { arr = copyFrom.toIntArray(); size = copyFrom.size }     fun contentEquals(other: IntList): Boolean {        return this === other || size == other.size && indices.all { this[it] == other[it] }    }     private fun grow(minCapacity: Int = 8) {        val newCapacity = maxOf(minCapacity, capacity + (capacity shr 1))        arr = arr.copyOf(newCapacity)    }     fun ensureCapacity(minCapacity: Int) { if(capacity < minCapacity) grow(minCapacity) }     operator fun get(index: Int): Int {        require(index in 0 until size)        return arr[index]    }     operator fun set(index: Int, value: Int) {        require(index in 0 until size)        arr[index] = value    }     fun add(value: Int) {        if(size == capacity) grow()        arr[size++] = value    }     fun addAll(list: IntList) {        ensureCapacity(size + list.size)        list.arr.copyInto(arr, size, 0, list.size)        size += list.size    }     fun add(index: Int, element: Int) {        if(size == capacity) grow()        arr.copyInto(arr, index + 1, index, size)        size++        set(index, element)    }     fun clear() { size = 0 }     fun removeAt(index: Int): Int {        val e = get(index)        arr.copyInto(arr, index, index + 1, size)        size--        return e    }     fun indexOf(e: Int): Int {        for(i in 0 until size) if(this[i] == e) return i        return -1    }     fun remove(e: Int): Boolean {        val i = indexOf(e)        if(i == -1) return false        removeAt(i)        return true    }     operator fun iterator() = object: IntIterator() {        private var pos = 0        override fun hasNext() = pos < size        override fun nextInt() = get(pos++)    }     inline fun isEmpty() = size == 0    inline fun isNotEmpty() = size != 0     fun pop() = arr[--size]     fun popToSize(s: Int) {        require(s >= 0)        if(s < size) size = s    }     fun swap(i: Int, j: Int) { val t = this[i]; this[i] = this[j]; this[j] = t }    fun reverse() {        for(i in 0 until size / 2) swap(i, lastIndex - i)    }     fun shuffle(rnd: Random = random) { for(i in lastIndex downTo 1) swap(i, rnd.nextInt(i+1)) }     inline fun sortWith(cmp: (Int, Int) -> Int) { _mergeSort(_arr, size, IntArray(size), IntArray::get, IntArray::set, cmp) }    inline fun <T: Comparable<T>> sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }    inline fun <T: Comparable<T>> sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }    fun sort() { sortBy { it } }    fun sortDescending() { sortByDescending { it } }     fun joinToString(separator: CharSequence) = if(size == 0) """" else let {        buildString {            append(it[0])            for (i in 1 until size) {                append(separator).append(it[i])            }        }    }     override fun toString() = ""["" + joinToString("", "") + ""]""     fun toIntArray() = arr.copyOf(size)    fun toList() = List(size, ::get)     inline fun first() = get(0)    inline fun last() = get(lastIndex)} inline fun IntList(size: Int, init: (Int) -> Int) = IntList(size).apply {    for(i in 0 until size) { add(init(i)) }}inline fun IntArray.toIntList() = IntList(this)inline fun Collection<Int>.toIntList() = IntList(this)inline fun intListOf(vararg values: Int) = IntList(values) fun IntList.max() = (1 until size).fold(this[0]) { acc, i -> max(acc, this[i]) }fun IntList.min() = (1 until size).fold(this[0]) { acc, i -> min(acc, this[i]) }fun IntList.getOrNull(i: Int) = if(i in indices) get(i) else nullinline fun IntList.count(predicate: (Int) -> Boolean) = indices.count { predicate(this[it]) }fun IntList.copyOf() = IntList(size, ::get)  /** IO *///@JvmField val ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null//const val PATH = ""src/main/resources/""//@JvmField val INPUT = File(PATH + ""input.txt"").inputStream()//@JvmField val OUTPUT = File(PATH + ""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar() else c    }} /** @param skipNext Whether to skip the next character (usually whitespace), defaults to true */fun readCharArray(n: Int, skipNext: Boolean = true): CharArray {    val res = CharArray(n) { readChar() }    if(skipNext) readChar()    return res} fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(c != '\n' && c != Char.MIN_VALUE) {            append(c)            c = readChar()        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /**  sort overrides to avoid quicksort attacks */ @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } inline fun <A, T> _mergeSort(a0: A, n: Int, tmp0: A, get: A.(Int) -> T, set: A.(Int, T) -> Unit, cmp: (T, T) -> Int) {    var a = a0    var tmp = tmp0    var len = 1    while(len < n) {        var l = 0        while(true) {            val m = l + len            if(m >= n) break            val r = min(n, m + len)            var i = l            var j = m            for(k in l until r) {                if(i != m && (j == r || cmp(a.get(i), a.get(j)) <= 0)) {                    tmp.set(k, a.get(i++))                } else tmp.set(k, a.get(j++))            }            l = r        }        for(i in l until n) tmp.set(i, a.get(i))        val t = a; a = tmp; tmp = t        len += len    }    if(a !== a0) for(i in 0 until n) a0.set(i, tmp0.get(i))} inline fun IntArray.sortWith(cmp: (Int, Int) -> Int) { _mergeSort(this, size, IntArray(size), IntArray::get, IntArray::set, cmp) }inline fun <T: Comparable<T>> IntArray.sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> IntArray.sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun IntArray.sort() { sortBy { it } }fun IntArray.sortDescending() { sortByDescending { it } } inline fun LongArray.sortWith(cmp: (Long, Long) -> Int) { _mergeSort(this, size, LongArray(size), LongArray::get, LongArray::set, cmp) }inline fun <T: Comparable<T>> LongArray.sortBy(func: (Long) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> LongArray.sortByDescending(func: (Long) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun LongArray.sort() { sortBy { it } }fun LongArray.sortDescending() { sortByDescending { it } } inline fun DoubleArray.sortWith(cmp: (Double, Double) -> Int) { _mergeSort(this, size, DoubleArray(size), DoubleArray::get, DoubleArray::set, cmp) }inline fun <T: Comparable<T>> DoubleArray.sortBy(func: (Double) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> DoubleArray.sortByDescending(func: (Double) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun DoubleArray.sort() { sortBy { it } }fun DoubleArray.sortDescending() { sortByDescending { it } } inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T : Comparable<T>> Array<out T>.sort() = _sort()inline fun <T : Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T : Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T : Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() // import preserving junk function@Suppress(""NonAsciiCharacters"") fun 雪花飄飄北風嘯嘯天地一片蒼茫() { iprintln(max(1, 2)) } fun IntArray.sumLong() = sumOf { it.toLong() } fun IntArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun IntArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun LongArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun LongArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun DoubleArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun DoubleArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> Array<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> Array<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> List<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> List<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) } // max/min Kotlin 1.6 -> 1.4 shimfun IntArray.max() = maxOf { it }fun IntArray.min() = minOf { it }fun LongArray.max() = maxOf { it }fun LongArray.min() = minOf { it }fun CharArray.max() = maxOf { it }fun CharArray.min() = minOf { it }fun <T : Comparable<T>> Iterable<T>.max() = maxOf { it }fun <T : Comparable<T>> Iterable<T>.min() = minOf { it }fun <T : Comparable<T>> Sequence<T>.max() = maxOf { it }fun <T : Comparable<T>> Sequence<T>.min() = minOf { it }","dp,greedy,trees"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport kotlin.math.max fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val n = jin.readLine().toInt()    val seen = BooleanArray(n + 1)    val rem = IntArray(n + 1)    val books = jin.readLine().split("" "").map { it.toInt() }    for (color in books) {        rem[color]++    }    var mexico = 0    var curr = 0    val dp = IntArray(n + 1)    for (color in books) {        mexico = max(mexico, curr + rem[color])        if (!seen[color]) {            seen[color] = true            dp[color] = curr + rem[color]        }        rem[color]--        if (rem[color] == 0) {            curr = max(curr, dp[color])        }    }    println(n - mexico)}","data structures,dp,greedy"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"")@file:OptIn(ExperimentalUnsignedTypes::class, ExperimentalStdlibApi::class) import java.io.PrintWriterimport kotlin.math.*import kotlin.random.Randomimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {//    val startTime = System.nanoTime()     val numCases = 1//readInt()    case@ for(case in 1..numCases) {        //print(""Case #$case: "")         val n = readInt()        val A = IntArray(n) { readInt()-1 }         val fst = IntArray(n) { -1 }        val lst = IntArray(n) { -1 }         for(i in 0 until n) {            val a = A[i]            if(fst[a] == -1) fst[a] = i            lst[a] = i        }         val cf = IntArray(n)        val D = IntArray(n+1)        for(i in n-1 downTo 0) {            D.setMax(i, D[i+1])            val a = A[i]            cf[a]++            if(fst[a] == i) D.setMax(i, D[lst[a] + 1] + cf[a]) else D.setMax(i, cf[a])        }         val ans = n - D[0]        println(ans)    } //    iprintln(""Time: ${(System.nanoTime() - startTime) / 1000000} ms"")} fun IntArray.setMax(i: Int, v: Int) = if(v > get(i)) { set(i, v); true } else falsefun IntArray.setMin(i: Int, v: Int) = if(v < get(i)) { set(i, v); true } else false /** IO *///@JvmField val ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null//const val PATH = ""src/main/resources/""//@JvmField val INPUT = File(PATH + ""input.txt"").inputStream()//@JvmField val OUTPUT = File(PATH + ""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar() else c    }} /** @param skipNext Whether to skip the next character (usually whitespace), defaults to true */fun readCharArray(n: Int, skipNext: Boolean = true): CharArray {    val res = CharArray(n) { readChar() }    if(skipNext) readChar()    return res} fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(c != '\n' && c != Char.MIN_VALUE) {            append(c)            c = readChar()        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /**  sort overrides to avoid quicksort attacks */ @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } inline fun <A, T> _mergeSort(a0: A, n: Int, tmp0: A, get: A.(Int) -> T, set: A.(Int, T) -> Unit, cmp: (T, T) -> Int) {    var a = a0    var tmp = tmp0    var len = 1    while(len < n) {        var l = 0        while(true) {            val m = l + len            if(m >= n) break            val r = min(n, m + len)            var i = l            var j = m            for(k in l until r) {                if(i != m && (j == r || cmp(a.get(i), a.get(j)) <= 0)) {                    tmp.set(k, a.get(i++))                } else tmp.set(k, a.get(j++))            }            l = r        }        for(i in l until n) tmp.set(i, a.get(i))        val t = a; a = tmp; tmp = t        len += len    }    if(a !== a0) for(i in 0 until n) a0.set(i, tmp0.get(i))} inline fun IntArray.sortWith(cmp: (Int, Int) -> Int) { _mergeSort(this, size, IntArray(size), IntArray::get, IntArray::set, cmp) }inline fun <T: Comparable<T>> IntArray.sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> IntArray.sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun IntArray.sort() { sortBy { it } }fun IntArray.sortDescending() { sortByDescending { it } } inline fun LongArray.sortWith(cmp: (Long, Long) -> Int) { _mergeSort(this, size, LongArray(size), LongArray::get, LongArray::set, cmp) }inline fun <T: Comparable<T>> LongArray.sortBy(func: (Long) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> LongArray.sortByDescending(func: (Long) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun LongArray.sort() { sortBy { it } }fun LongArray.sortDescending() { sortByDescending { it } } inline fun DoubleArray.sortWith(cmp: (Double, Double) -> Int) { _mergeSort(this, size, DoubleArray(size), DoubleArray::get, DoubleArray::set, cmp) }inline fun <T: Comparable<T>> DoubleArray.sortBy(func: (Double) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> DoubleArray.sortByDescending(func: (Double) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun DoubleArray.sort() { sortBy { it } }fun DoubleArray.sortDescending() { sortByDescending { it } } inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T : Comparable<T>> Array<out T>.sort() = _sort()inline fun <T : Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T : Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T : Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() // import preserving junk function@Suppress(""NonAsciiCharacters"") fun 雪花飄飄北風嘯嘯天地一片蒼茫() { iprintln(max(1, 2)) } fun IntArray.sumLong() = sumOf { it.toLong() } fun IntArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun IntArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun LongArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun LongArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun DoubleArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun DoubleArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> Array<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> Array<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> List<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> List<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) } // max/min Kotlin 1.6 -> 1.4 shimfun IntArray.max() = maxOf { it }fun IntArray.min() = minOf { it }fun LongArray.max() = maxOf { it }fun LongArray.min() = minOf { it }fun CharArray.max() = maxOf { it }fun CharArray.min() = minOf { it }fun <T : Comparable<T>> Iterable<T>.max() = maxOf { it }fun <T : Comparable<T>> Iterable<T>.min() = minOf { it }fun <T : Comparable<T>> Sequence<T>.max() = maxOf { it }fun <T : Comparable<T>> Sequence<T>.min() = minOf { it }","data structures,dp,greedy"
"// 2022-04-17, Sun, 17:47import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.system.measureTimeMillisimport java.util.TreeMapimport java.util.TreeSet inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        val S = fakein.toString()        println(""New Case "")        println(S.take(80))        println(""..."")        fakein.clear()        IN = BufferedInputStream(S.byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} val getintfast:Int get() = IO.nextInt()val getint:Int get(){ val ans = getlong ; if(ans > Int.MAX_VALUE) IntArray(1000000000); return ans.toInt() }val getlong:Long get() = IO.nextLong()val getstr:String get() = IO.nextString()fun getline(n:Int):IntArray{    return IntArray(n){getint}}fun getlineL(n:Int):LongArray{    return LongArray(n){getlong}}fun getbinary(n:Int, asTrue:Char):BooleanArray{    val str = getstr    return BooleanArray(n){str[it] == asTrue}} val List<Char>.ret:Stringget() = this.joinToString("""")var dmark = -1infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    dmark++    var str = ""<${dmark}>   ""    debug()    if(this is String){ str += this    }else if(this is Int){ str += this.toString()    }else if(this is Long){ str += this.toString()    }else{ str += this.toString()}    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is BooleanArray){ println(""$str :${a.map{if(it)'1' else '0'}.joinToString("" "")}"")    }else if(a is Array<*>){        println(""$str : "")        for(c in a){if(c is IntArray){println(c.joinToString("" ""))}        else if(c is LongArray){println(c.joinToString("" ""))}        else if(c is BooleanArray){println(c.map { if(it) '1' else '0' }.joinToString(""""))        }         }        println()    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){    throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){        throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    fun cases(onecase:()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint} else if(mode == solveMode.tc){1 } else randCount        //safety checks        if(pI != 998_244_353 && pI != 1_000_000_007){            throw Exception(""Modding a wrong prime!"")        }        if(withBruteForce){            println(""Brute force is active"")        }         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            onecase()        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }}inline fun<T> T.alsoBrute(cal:() -> T){    if(!withBruteForce) return    val also = cal()    if(this != also){        println(""Checking failed: Got ${this} Brute ${also}"")        crash()    }}// 1. Moddedconst val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}infix fun Int.modM(b:Int):Int{ return ((this.toLong() * b) % pI).toInt() }infix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }fun intPow(x:Int,e:Int,m:Int):Int{    var X = x ; var E =e ; var Y = 1    while(E > 0){        if(E and 1 == 0){            X = ((1L * X * X) % m).toInt()            E = E shr 1        }else{            Y = ((1L * X * Y) % m).toInt()            E -= 1        }    }    return Y}// 2. DP initial valuesconst val plarge = 1_000_000_727const val nlarge = -plargeconst val phuge = 2_727_000_000_000_000_000Lconst val nhuge = -phuge// 3. conveniecen conversionsval Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionval Char.code :Int get() = this.toInt() -  'a'.toInt()//3. hard to write stufffun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val mint:MutableList<Int> get() = mutableListOf<Int>()val mong:MutableList<Long> get() = mutableListOf<Long>()//4. more outputsfun List<Char>.conca():String = this.joinToString("""")val CharArray.conca :String get() = this.joinToString("""")val IntArray.conca :String get() = this.joinToString("" "")@JvmName(""concaInt"")fun List<Int>.conca():String = this.joinToString("" "")val LongArray.conca:String get() = this.joinToString("" "")@JvmName(""concaLong"")fun List<Long>.conca():String = this.joinToString("" "")//5. Pair of intsconst val longmask = (1L shl 32) - 1fun makepair(a:Int, b:Int):Long = (a.toLong() shl 32) xor (longmask and b.toLong()) // remember positev sonlyval Long.first get() = (this ushr 32).toInt()val Long.second get() = this.toInt()//6. stringsval String.size get() = this.lengthconst val randCount = 100//7. bitsfun Int.has(i:Int):Boolean = (this and (1 shl i) != 0)  val IntArray.n:Int get() = this.sizefun IntArray.indexofrightmost():IntArray{    val ret = IntArray(n+1){-1}    for (i in 0 until n) {        ret[this[i]] = i    }    return ret}fun IntArray.indexofleftmost():IntArray{    val ret = IntArray(n+1){-1}    for (i in n-1 downTo 0) {        ret[this[i]] = i    }    return ret}fun IntArray.nextequal():IntArray{    val last = IntArray(n+1){-1}    val ret = IntArray(n){-1}    for(i in n-1 downTo 0){        val v = this[i]        if(last[v] != -1){            ret[i] = last[v]        }        last[v] = i    }    return last}fun IntArray.previousequal():IntArray{    val last = IntArray(n+1){-1}    val ret = IntArray(n){-1}    for(i in 0 until n){        val v = this[i]        if(last[v] != -1){            ret[i] = last[v]        }        last[v] = i    }    return last} fun IntArray.counts():IntArray{    val ret = IntArray(n+1)    for(a in this){        ret[a] ++    }    return ret} fun debug(){}const val withBruteForce = falseconst val singleCase = truefun main(){    solve.cases{        val n = getint        val L = getline(n)         val counts = L.counts()        val first = L.indexofleftmost()        val last = L.indexofrightmost()        val DP = IntArray(n+1)        DP[0] = 0        for(i in 0 until n){            val v = L[i]            if(i == first[v]){                DP[last[v] +1] = maxOf(DP[last[v]+1], DP[i] + counts[v])            }            DP[i+1] = maxOf(DP[i], DP[i+1])        }         val maxbonus = IntArray(n+1)        val tempcounts = IntArray(n+1)        var max = 0        for(i in n downTo 0){            if(i < n){                val v = L[i]                tempcounts[v] ++                max = maxOf(tempcounts[v], max)            }            maxbonus[i] = max        }        var ans =0        for(i in 0..n){            ans =maxOf(ans, maxbonus[i] + DP[i])        }        put(n - ans)        }    done()}   ","data structures,dp,greedy"
"/*81 1 2 1 1 2 1 1 */fun main() {    val n = readLine()!!.toInt();    val a=readLine()!!.split("" "").map{it.toInt()};    var count=0;    var top=-1;    var bottom=-1;    for (i in a) {        if (i==top) {            if (i==bottom) {                continue;            }            bottom=i;            count++;        }        else if (i==bottom) {            top=i;            count++;        }        else {            if (top!=bottom) {                bottom=-1;                top=i;            }            else {                top=i;            }            count++;        }    }    println(count);}","constructive algorithms,data structures,dp,greedy,implementation"
"private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readLong() = readLn().toLong()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }private fun readLongs() = readStrings().map { it.toLong() }  fun main() = repeat(1, ::solve)fun solve(case : Int) {    val n = readInt()    val a = readInts()    var ans = 0    var a0Tail = 0    var a1Tail = 0    for (i in 0 until n) {        if (a0Tail == a[i] && a1Tail == a[i]) continue         if (a0Tail == a[i]) a1Tail = a[i]        else if (a1Tail == a[i]) a0Tail = a[i]        else if (a0Tail == a1Tail) a0Tail = a[i]        else {            a0Tail = a[i]// could be preva0Tail or a[i]            a1Tail = 0 // could be preva1Tail or a[i]        }        ans++    }    println(ans)}","constructive algorithms,data structures,dp,greedy,implementation"
fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main() {    val n = readInt()    val vs = readInts()     var last = -1    var count = 0    var res = 0    var double = -1    var neutral = 0     for (v in vs) {        when {            v == last -> count++            else -> {                last = v                count = 1            }        }        when {            count == 1 -> {                res++                if (double == v) neutral-- else neutral++                if (neutral == 2) {                    double = -1                    neutral = 0                }            }            count == 2 && double != v -> {                double = v                neutral = 0                res++            }        }    }    println(res)},"constructive algorithms,data structures,dp,greedy,implementation"
"fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main() {    val n = readInt()    val vs = readInts() + listOf(0) // sentinel     val vPos = IntArray(n+1) { n }    val next = IntArray(n+1)    for ((i, v) in vs.withIndex().reversed()) {        next[i] = vPos[v]        vPos[v] = i    }     var il = n    var ir = n    var score = 0    for ((i, v) in vs.dropLast(1).withIndex()) {        val pickLeft = when {            v == vs[il] -> false            v == vs[ir] -> true            next[il] < next[ir] -> true            else -> false        }        score += when {            pickLeft && vs[il] != v -> 1            !pickLeft && vs[ir] != v -> 1            else -> 0        }        if (pickLeft) {            il = i        } else {            ir = i        }    }     println(score)}","constructive algorithms,data structures,dp,greedy,implementation"
"fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()        val a = readLine()!!.split("" "").map { it.toInt() }         val count = a.groupBy { it }.mapValues { it.value.size }        println(count.values.max())    }}","brute force,greedy"
fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main() {    repeat(readInt()) {        readInt()        val vs = readInts()        val res = vs.toSet().map { v -> vs.count { it == v } }.max()!!        println(res)    }},"brute force,greedy"
"fun main() {    for (tt in 1..readLine()!!.toInt()) {        readLine();        val a = readLine()!!.split("" "").map { it.toInt() }        val counts:HashMap<Int, Int> = HashMap<Int, Int>()        for (i: Int in a) counts[i] = (counts[i]?:0)+1        println(counts.values.max())    }}","brute force,greedy"
"fun main() {     val t = readLine()!!.toInt()    repeat (t) {         val n = readLine()!!.toInt()        val ans = readLine()!!            .split("" "")            .map { it.toInt() }            .groupingBy { it }            .eachCount()            .maxOf { it.value }                println(ans)    } }","brute force,greedy"
"import java.io.PrintWriterimport java.util.*import kotlin.math.* fun PrintWriter.solve() {    val n = nextInt()    val pos = Array(n) { nextLong() to nextLong() }    val p = mutableListOf(0)    val used = BooleanArray(n) { false }    used[0] = true    var prev = 0    repeat(n - 1) {        var max_d = 0L        var max_ind = -1        for (i in 0 until n) {            if (!used[i]) {                val (x1, y1) = pos[i]                val (x2, y2) = pos[prev]                val d = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)                if (max_d < d) {                    max_d = d                    max_ind = i                }            }        }        p.add(max_ind)        used[max_ind] = true        prev = max_ind    }    println(p.map { it + 1 }.joinToString("" ""))} fun main() {    val writer = PrintWriter(System.out, false)    writer.solve()    writer.flush()} // region Scannerprivate var st = StringTokenizer("""")private val br = System.`in`.bufferedReader() fun next(): String {    while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())    return st.nextToken()} fun nextInt() = next().toInt()fun nextLong() = next().toLong()fun nextLine() = br.readLine()!!fun nextDouble() = next().toDouble()// endregion","constructive algorithms,geometry,greedy,math,sortings"
"import java.io.FileInputStream fun main() {//    changeStandardInput()    var q = 1     while (q-- > 0) {        val n = readIntLn()        val ans: MutableList<Int> = ArrayList(n)        val pp: MutableList<LongPair> = ArrayList(n)        for (i in 0 until n) {            val (x, y) = readLongs()            pp += LongPair(x, y)        }         ans += 0        val used = BooleanArray(n);        used[0] = true        var lastIndex = 0        for (i in 1 until n) {            var mx = -1L            var index = lastIndex            for (j in 0 until n) {                if (used[j]) continue                val dist = sqr(pp[lastIndex].x - pp[j].x) + sqr(pp[lastIndex].y - pp[j].y)                if (dist > mx) {                    mx = dist                    index = j                }            }            lastIndex = index            used[index] = true            ans += index        }        println(ans.joinToString("" "") { (it + 1).toString() })    }} private fun sqr(x: Long) = x * x  private data class LongPair(    val x: Long,    val y: Long) : Comparable<LongPair> {    override fun compareTo(other: LongPair): Int {        val cmp = x.compareTo(other.x)        return if (cmp == 0) y.compareTo(other.y) else cmp    }}  private fun readLn() = readLine()!!private fun readIntLn() = readLn().toInt()private fun readLongLn() = readLn().toLong()private fun readDoubleLn() = readLn().toDouble()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }private fun readLongs() = readStrings().map { it.toLong() }  private fun changeStandardInput() {    System.setIn(FileInputStream(""input.txt""))}","constructive algorithms,geometry,greedy,math,sortings"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"")@file:OptIn(ExperimentalUnsignedTypes::class, ExperimentalStdlibApi::class) import java.io.PrintWriterimport java.util.PriorityQueueimport java.util.TreeSetimport kotlin.math.*import kotlin.random.Randomimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {//    val startTime = System.nanoTime()     val numCases = 1//readInt()    case@ for(case in 1..numCases) {        //print(""Case #$case: "")         val n = readInt()         val X = LongArray(n)        val Y = LongArray(n) {            X[it] = readLong()            readLong()        }         val ans = IntArray(n)        val vis = BooleanArray(n)        for(i in 0 until n-1) {            val curr = ans[i]            vis[curr] = true            var best_d = 0L            var best_i = curr             for(j in 1 until n) if(!vis[j]) {                val d = (X[j] - X[curr]).let { it * it } + (Y[j] - Y[curr]).let { it * it }                 if(d > best_d) {                    best_d = d                    best_i = j                }            }             ans[i+1] = best_i        }         for(i in 0 until n) ans[i]++        println(ans.joinToString("" ""))    } //    iprintln(""Time: ${(System.nanoTime() - startTime) / 1000000} ms"")}  /** IO *///@JvmField val ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null//const val PATH = ""src/main/resources/""//@JvmField val INPUT = File(PATH + ""input.txt"").inputStream()//@JvmField val OUTPUT = File(PATH + ""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar() else c    }} /** @param skipNext Whether to skip the next character (usually whitespace), defaults to true */fun readCharArray(n: Int, skipNext: Boolean = true): CharArray {    val res = CharArray(n) { readChar() }    if(skipNext) readChar()    return res} fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(c != '\n' && c != Char.MIN_VALUE) {            append(c)            c = readChar()        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /**  sort overrides to avoid quicksort attacks */ @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } inline fun <A, T> _mergeSort(a0: A, n: Int, tmp0: A, get: A.(Int) -> T, set: A.(Int, T) -> Unit, cmp: (T, T) -> Int) {    var a = a0    var tmp = tmp0    var len = 1    while(len < n) {        var l = 0        while(true) {            val m = l + len            if(m >= n) break            val r = min(n, m + len)            var i = l            var j = m            for(k in l until r) {                if(i != m && (j == r || cmp(a.get(i), a.get(j)) <= 0)) {                    tmp.set(k, a.get(i++))                } else tmp.set(k, a.get(j++))            }            l = r        }        for(i in l until n) tmp.set(i, a.get(i))        val t = a; a = tmp; tmp = t        len += len    }    if(a !== a0) for(i in 0 until n) a0.set(i, tmp0.get(i))} inline fun IntArray.sortWith(cmp: (Int, Int) -> Int) { _mergeSort(this, size, IntArray(size), IntArray::get, IntArray::set, cmp) }inline fun <T: Comparable<T>> IntArray.sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> IntArray.sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun IntArray.sort() { sortBy { it } }fun IntArray.sortDescending() { sortByDescending { it } } inline fun LongArray.sortWith(cmp: (Long, Long) -> Int) { _mergeSort(this, size, LongArray(size), LongArray::get, LongArray::set, cmp) }inline fun <T: Comparable<T>> LongArray.sortBy(func: (Long) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> LongArray.sortByDescending(func: (Long) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun LongArray.sort() { sortBy { it } }fun LongArray.sortDescending() { sortByDescending { it } } inline fun DoubleArray.sortWith(cmp: (Double, Double) -> Int) { _mergeSort(this, size, DoubleArray(size), DoubleArray::get, DoubleArray::set, cmp) }inline fun <T: Comparable<T>> DoubleArray.sortBy(func: (Double) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> DoubleArray.sortByDescending(func: (Double) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun DoubleArray.sort() { sortBy { it } }fun DoubleArray.sortDescending() { sortByDescending { it } } inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T : Comparable<T>> Array<out T>.sort() = _sort()inline fun <T : Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T : Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T : Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() // import preserving junk function@Suppress(""NonAsciiCharacters"") fun 雪花飄飄北風嘯嘯天地一片蒼茫() { iprintln(max(1, 2)) } fun IntArray.sumLong() = sumOf { it.toLong() } fun IntArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun IntArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun LongArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun LongArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun DoubleArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun DoubleArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> Array<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> Array<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> List<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> List<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) } // max/min Kotlin 1.6 -> 1.4 shimfun IntArray.max() = maxOf { it }fun IntArray.min() = minOf { it }fun LongArray.max() = maxOf { it }fun LongArray.min() = minOf { it }fun CharArray.max() = maxOf { it }fun CharArray.min() = minOf { it }fun <T : Comparable<T>> Iterable<T>.max() = maxOf { it }fun <T : Comparable<T>> Iterable<T>.min() = minOf { it }fun <T : Comparable<T>> Sequence<T>.max() = maxOf { it }fun <T : Comparable<T>> Sequence<T>.min() = minOf { it }","constructive algorithms,geometry,greedy,math,sortings"
"import kotlin.math.maximport kotlin.math.min fun readInt() = readLine()!!.toInt()fun readLongs() = readLine()!!.split(' ').map { it.toLong() } fun main() {    repeat(readInt()) {        readInt()        val cs = readLongs()        val ps = readLongs()        val qs = readLongs()         var res = 0L        var open = 0L         for (i in cs.indices) {            if (i == 0) continue             val beg = min(ps[i], qs[i])            val end = max(ps[i], qs[i])             open = 2L + if (beg == end) {                0L            } else {                val cont = if (i == 1) 0L else open + (beg - 1) + (cs[i-1] - end)                val restart = end - beg                max(cont, restart)            }            res = max(res, open + cs[i] - 1)        }         println(res)    }}","dp,graphs,greedy"
"/** * Accomplished using the EduTools plugin by JetBrains https://plugins.jetbrains.com/plugin/10081-edutools */import kotlin.math.absimport kotlin.math.maximport kotlin.math.min fun main() {    // Write your solution here    val t = readInt()    repeat(t) {        val n = readInt()        val c = readInts()        val a = readInts()        val b = readInts()        println(solve(n, c, a, b))    }} fun solve(n: Int, c: List<Long>, a: List<Long>, b: List<Long>): Long {    var max = 0L    var curr = 0L    for (i in 1 until n) {        val f = a[i]        val l = b[i]        if (f != l) {            curr += if (i == 1) {                abs(l - f) + 1            } else {                min(f, l) + c[i - 1] - max(f, l) + 1            }            curr = max(curr, abs(l - f) + 1)        } else {            curr = 1        }        max = max(max, curr + c[i])    }    return max}/*1  12  23  34  45  5   6 */ private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toLong() }","dp,graphs,greedy"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport kotlin.math.maximport kotlin.math.min fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    for (c in 1..jin.readLine().toInt()) {        val n = jin.readLine().toInt()        val chains = jin.readLine().split("" "").map { it.toLong() }        val ay = jin.readLine().split("" "").map { it.toLong() }.toLongArray()        val by = jin.readLine().split("" "").map { it.toLong() }.toLongArray()        for (j in 1 until n) {            if (by[j] < ay[j] && j < n - 1) {                ay[j + 1] = chains[j] - ay[j + 1] + 1L                by[j + 1] = chains[j] - by[j + 1] + 1L            }            val a = min(ay[j], by[j])            val b = max(ay[j], by[j])            ay[j] = a            by[j] = b        }        val dpForward = LongArray(n)        var answer = 0L        for (j in 1 until n) {            if (j > 0) {                dpForward[j] = 2L + (by[j] - ay[j])                if (j > 1 && ay[j] < by[j]) {                    dpForward[j] = max(dpForward[j], 2L + ay[j] - 1L + chains[j - 1] - by[j] + dpForward[j - 1])                }                answer = max(answer, dpForward[j] + chains[j] - 1L)            }        }        println(answer)    }}","dp,graphs,greedy"
"import java.io.PrintWriterimport java.util.*import kotlin.math.* fun PrintWriter.solve() {    val numCases = nextInt()    case@ for (_i in 0 until numCases) {        val n = nextInt()        val c = Array(n) { nextLong() }        val a = Array(n) { nextInt() }        val b = Array(n) { nextInt() }        val dp0 = Array(n + 1) { 0L }        val dp1 = Array(n + 1) { 0L }        for (i in 1 until n) {            val middle = min(a[i] + c[i - 1] + 1 - b[i], b[i] + c[i - 1] + 1 - a[i])            if (a[i] != b[i]) {                if (i == 1) {                    dp0[i] = abs(a[i] - b[i]) + 1L                } else {                    dp0[i] = max(abs(a[i] - b[i]) + 1L, dp0[i - 1] + middle)                }            } else {                dp0[i] = 1            }        }        for (i in 2..n) {            dp1[i] = dp0[i - 1] + c[i - 1]        }        println(dp1.max()!!)    }} fun main() {    val writer = PrintWriter(System.out, false)    writer.solve()    writer.flush()} // region Scannerprivate var st = StringTokenizer("""")private val br = System.`in`.bufferedReader() fun next(): String {    while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())    return st.nextToken()} fun nextInt() = next().toInt()fun nextLong() = next().toLong()fun nextLine() = br.readLine()!!fun nextDouble() = next().toDouble()// endregion","dp,graphs,greedy"
"fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()        val a = readLine()!!.split(' ').map { it.toInt() }.toIntArray()        val d = LongArray(n) { 0L }        d[0] = a[0].toLong()        for (i in 1 until n) {            d[i] = a[i] - d[i - 1]        }        if (d.all { it >= 0 } && d.last() == 0L) return@repeat println(""YES"")        if (d.any { it < 0 } && d.last() == 0L) return@repeat println(""NO"")        val suffixMin = LongArray(d.size)        suffixMin[d.size - 1] = d[d.size - 1]        suffixMin[d.size - 2] = d[d.size - 2]        for (i in (0 until d.size - 2).reversed()) {            suffixMin[i] = minOf(suffixMin[i + 2], d[i])        }        for (i in 0..((0..n - 2).find { d[it] < 0 } ?: n - 2)) {            if (2L * (a[i + 1] - a[i]) == d.last() * if ((n - i) % 2 == 1) -1 else 1) {                if (suffixMin[i + 1] - 2 * (a[i + 1] - a[i]) >= 0) {                    if (i + 2 == n || suffixMin[i + 2] + 2 * (a[i + 1] - a[i]) >= 0) {                        if (a[i + 1] - (if (i == 0) 0 else d[i - 1]) >= 0) return@repeat println(""YES"")                    }                }            }        }        println(""NO"")    }}","data structures,dp,greedy,math"
"fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main() {    repeat(readInt()) {        readInt()        val vs = readInts()        println(if (solve(vs)) ""YES"" else ""NO"")    }} fun solve(vs: List<Int>): Boolean {    val n = vs.size     val l = Array<Int?>(n) { null }    l[0] = vs.first()    for (i in 1 until n) {        val prev = l[i-1]        if (prev != null && vs[i] >= prev) {            l[i] = vs[i]-prev        } else {            break        }    }     val r = Array<Int?>(n) { null }    r[n-1] = vs.last()    for (i in n-2 downTo 0) {        val prev = r[i+1]        if (prev != null && vs[i] >= prev) {            r[i] = vs[i]-prev        } else {            break        }    }     fun solveWithSwap(i: Int): Boolean {        val v1 = if (i == 0) 0 else l[i-1]        val v4 = if (i+2 == n) 0 else r[i+2]        if (v1 == null || v4 == null) return false        val v2 = vs[i+1]        val v3 = vs[i]         if (v2 < v1) return false        val n2 = v2 - v1        if (v3 < n2) return false        val n3 = v3 - n2        if (v3 < n3) return false        val n4 = v4 - n3        return n4 == 0    }     return when {        l.last() == 0 -> true        r.first() == 0 -> true        else -> (0..n-2).any { solveWithSwap(it) }    }}","data structures,dp,greedy,math"
"import java.io.BufferedInputStreamimport kotlin.math.min fun main() {    val jin = FastScanner()    val out = StringBuilder()    cases@for (c in 1..jin.nextInt()) {        val n = jin.nextInt()        val piles = LongArray(n + 1) { if (it == 0) 0L else jin.nextInt().toLong() }        val oddSegtree = LazySegmentTree(1, n)        val evenSegtree = LazySegmentTree(1, n)        fun update(j: Int, delta: Long) {            var signedDelta = if (j % 2 == 0) delta else -delta            evenSegtree.update(j, n, signedDelta)            oddSegtree.update(j, n, -signedDelta)        }        fun works() = evenSegtree[1, n] >= 0L && oddSegtree[1, n] >= 0L && (if (n % 2 == 0) evenSegtree[n, n] else oddSegtree[n, n]) == 0L        for (j in 1..n) {            update(j, piles[j])            if (j % 2 == 0) {                oddSegtree.update(j, j, 1000000000000000L)            } else {                evenSegtree.update(j, j, 1000000000000000L)            }        }        if (works()) {            out.appendln(""YES"")            continue@cases        }        for (j in 2..n) {            update(j - 1, piles[j] - piles[j - 1])            update(j, piles[j - 1] - piles[j])            if (works()) {                out.appendln(""YES"")                continue@cases            }            update(j - 1, piles[j - 1] - piles[j])            update(j, piles[j] - piles[j - 1])        }        out.appendln(""NO"")    }    print(out)} class LazySegmentTree(val treeFrom: Int, val treeTo: Int) {    val value: LongArray    val lazy: LongArray     init {        val length = treeTo - treeFrom + 1        var e = 0        while (1 shl e < length) {            e++        }        value = LongArray(1 shl (e + 1))        lazy = LongArray(1 shl (e + 1))    }     fun update(from: Int, to: Int, delta: Long) {        update(from, to, treeFrom, treeTo, 1, delta)    }     fun update(from: Int, to: Int, segFrom: Int, segTo: Int, node: Int, delta: Long): Long {        if (from > segTo || to < segFrom) {         } else if (from <= segFrom && to >= segTo) {            value[node] += delta            lazy[node] += delta        } else {            val mid = (segFrom + segTo) / 2            value[node] = lazy[node] + min(                    update(from, to, segFrom, mid, 2 * node, delta),                    update(from, to, mid + 1, segTo, (2 * node) + 1, delta)            )        }        return value[node]    }     operator fun get(from: Int, to: Int) = query(from, to, treeFrom, treeTo, 1)     fun query(from: Int, to: Int, segFrom: Int, segTo: Int, node: Int): Long {        if (from > segTo || to < segFrom) {            return Long.MAX_VALUE        } else if (from <= segFrom && to >= segTo) {            return value[node]        } else {            val mid = (segFrom + segTo) / 2            return lazy[node] + min(                    query(from, to, segFrom, mid, 2 * node),                    query(from, to, mid + 1, segTo, (2 * node) + 1)            )        }    }} class FastScanner {    private val BS = 1 shl 16    private val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC    private var `in`: BufferedInputStream? = null     constructor() {        `in` = BufferedInputStream(System.`in`, BS)    }     private val char: Char        private get() {            while (bId == size) {                size = try {                    `in`!!.read(buf)                } catch (e: Exception) {                    return NC                }                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c >= '0' && c <= '9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }}","data structures,dp,greedy,math"
"import java.io.*import java.util.*import kotlin.system.measureTimeMillis // @formatter:off val local = System.getProperty(""ONLINE_JUDGE"") == nullval INPUT: InputStream = if (local) FileInputStream(""input.txt"") else System.`in` //val OUTPUT: PrintStream = if (local) PrintStream(""output.txt"") else System.outval OUTPUT: PrintStream = System.out val _reader = INPUT.bufferedReader()var _tokenizer = StringTokenizer("""") fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!!fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()} fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readStrings() = readLn().split("" "")fun readInts() = readStrings().map { it.toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() }fun PrintWriter.yesNo(p: Boolean) {if (p) this.println(""YES"") else this.println(""NO"")}fun<T> MutableList<T>.swap(i: Int, j: Int) {val t=this[i]; this[i]=this[j]; this[j]=t;}fun<T> Array<T>.swap(i: Int, j: Int) {val t=this[i]; this[i]=this[j]; this[j]=t;}// @formatter:on  @JvmFieldval _writer = PrintWriter(OUTPUT, local) class PList<T>(list: List<T>) {    private var list: MutableList<T>     init {        this.list = list.toMutableList()    }     val ops: MutableList<Pair<Int, T>> = mutableListOf()     operator fun set(index: Int, value: T) {        ops.add(index to list[index])        list[index] = value    }     operator fun get(index: Int): T = list[index]     fun rollback() {        for (p in ops.asReversed()) {            val (idx, value) = p            list[idx] = value        }        ops.clear()    }     fun swap(i: Int, j: Int) {        val t = this[i]        this[i] = this[j]        this[j] = t    }}  fun foo(a: List<Int>): List<Int> {    val n = a.size    val res = MutableList(n) { 0 }    res[0] = a[0]    for (i in 1 until n) {        if (res[i - 1] == -1) {            res[i] = -1        } else {            res[i] = a[i] - res[i - 1]            if (res[i] < 0) {                res[i] = -1            }        }    }     return res} fun solve(ar: List<Int>): Boolean {    val l = foo(ar)    val r = foo(ar.reversed()).reversed()     if (l.last() == 0) {        return true    }     val pl = PList(l)    val pr = PList(r)    val pa = PList(ar)     val n = ar.size     for (i in 0 until n - 1) {        pa.swap(i, i + 1)         for (j in i - 1..i) {            if (j < 0) continue             if (j == 0) {                pl[j] = pa[j]                continue            }             if (pl[j - 1] == -1) {                pl[j] = -1            } else {                pl[j] = pa[j] - pl[j - 1]                if (pl[j] < 0) {                    pl[j] = -1                }            }        }         for (j in i + 1 downTo i) {            if (j >= n) continue            if (j == n - 1) {                pr[j] = pa[j]                continue            }             if (pr[j + 1] == -1) {                pr[j] = -1            } else {                pr[j] = pa[j] - pr[j + 1]                if (pr[j] < 0) {                    pr[j] = -1                }            }        }         if (pl[i]==pr[i+1] && pl[i]!=-1) {            return true        }         pa.rollback()        pl.rollback()        pr.rollback()    }     return false} fun PrintWriter.solve() {    val tcs = readInt()    repeat(tcs) {        val n = readInt()        val ar = readInts()        val res = solve(ar)        yesNo(res)    }}  fun main() {    val elapsedMs = measureTimeMillis {        _writer.solve()        _writer.flush()    }    if (local) {        println(""\n\nelapsed $elapsedMs ms"")    }}","data structures,dp,greedy,math"
"fun main() {    repeat(readLine()!!.toInt()) {        val s = readLine()!!        val t = readLine()!!        for (times in 1 .. t.length) {            val lcm = s * times            if (t * (lcm.length / t.length) == lcm) return@repeat println(lcm)        }        println(-1)    }} operator fun String.times(t: Int) = Array(t) { this }.joinToString("""")","brute force,math,number theory,strings"
fun main() {    cases@for (c in 1..readLine()!!.toInt()) {        val s = readLine()!!        val t = readLine()!!        for (a in 1..t.length) {            for (b in 1..s.length) {                if (s.repeat(a) == t.repeat(b)) {                    println(s.repeat(a))                    continue@cases                }            }        }        println(-1)    }},"brute force,math,number theory,strings"
"fun main() {    repeat(readLine()!!.toInt()) {        val s = readLine()!!        val t = readLine()!!        val x = lcm(s.length, t.length)         if (s.repeat(x / s.length) == t.repeat(x / t.length)) println(s.repeat(x / s.length))        else println(-1)    }} fun lcm(a: Int, b: Int): Int = a * b / gcd(a, b) fun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)","brute force,math,number theory,strings"
"fun main() {    repeat(readLine()!!.toInt()) {       val s = readLine()!!       val t = readLine()!!       solve(s, t)   }} private fun solve(s: String, t: String) {    for (i in 1..20) {        val x = s.repeat(i)        for (j in 1..20) {            if (x == t.repeat(j)) {                println(x)                return            }        }    }    println(-1)}","brute force,math,number theory,strings"
"fun main() {    repeat(readLine()!!.toInt()) {        val c = readLine()!!.toInt()        val a = readLine()!!.split(' ').map{it.toInt()}.reduce {acc, i ->  acc + i}        println( if (a % 2 == 0 && (c % 2 == 0 || a / c < 2)) ""YES"" else ""NO"" )    }}","dp,greedy,math"
"fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()        val a = readLine()!!.split(' ').map { it.toInt() }.toIntArray()        val sum = a.sum()        println(if (sum % 4 == 0 || sum % 2 == 0 && a.find { it == 1 } != null) ""YES"" else ""NO"")    }}","dp,greedy,math"
"fun main() {    repeat(readLine()!!.toInt()){        readLine()        val a = readLine()!!.split("" "").map{it.toInt()}        val s = a.sum()        if(s%4==0) println(""YES"")        else if(s%2==0){            if(a.contains(1)) println(""YES"")            else println(""NO"")        }else println(""NO"")    }}","dp,greedy,math"
"fun main(){    repeat(readLine()!!.toInt()){        var k = readLine()!!.toInt()        var a = readLine()!!.split(' ').map{it.toInt()}        var x = a.count{it== 1}        if((x==0 && (k - x) % 2 == 0) || (x%2 == 0 && x>0))            println(""YES"")        else            println(""NO"")             } }","dp,greedy,math"
"import java.io.BufferedInputStreamimport java.util.* fun main() {    val jin = FastScanner()    val out = StringBuilder()    for (c in 1..jin.nextInt()) {        val n = jin.nextInt()        val m = jin.nextInt()        val adj = Array(n + 1) { ArrayDeque<Int>(4) }        for (j in 1..m) {            val a = jin.nextInt()            val b = jin.nextInt()            adj[a].add(b)            adj[b].add(a)        }        val seen = IntArray(n + 1)        val answer = mutableListOf<Int>()        fun recur(a: Int) {            if (seen[a] == 1) {                answer.add(a)                val next = mutableListOf<Int>()                for (b in adj[a]) {                    if (seen[b] == 0) {                        seen[b] = -1                        next.add(b)                    }                }                for (b in next) {                    recur(b)                }            } else {                for (b in adj[a]) {                    if (seen[b] == 0) {                        seen[b] = 1                        recur(b)                    }                }            }        }        recur(1)        seen[0] = 2        if (seen.all { it != 0 }) {            out.appendln(""YES"").appendln(answer.size).appendln(answer.joinToString("" ""))        } else {            out.appendln(""NO"")        }    }    print(out)} class FastScanner {    private val BS = 1 shl 16    private val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC    private var `in`: BufferedInputStream? = null     constructor() {        `in` = BufferedInputStream(System.`in`, BS)    }     private val char: Char        private get() {            while (bId == size) {                size = try {                    `in`!!.read(buf)                } catch (e: Exception) {                    return NC                }                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c >= '0' && c <= '9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }}","constructive algorithms,dfs and similar,graph matchings,graphs,greedy"
"import java.io.InputStreamimport java.io.PrintStreamimport java.io.PrintWriterimport java.util.* /** IO code start *///@JvmField val INPUT = File(""input.txt"").inputStream()//@JvmField val OUTPUT = File(""output.txt"").outputStream()@JvmField val INPUT: InputStream = System.`in`@JvmField val OUTPUT: PrintStream = System.out @JvmField val reader = INPUT.bufferedReader()private fun readLine(): String? = reader.readLine()private fun readLn() = reader.readLine()!!@JvmField var tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (tokenizer.hasMoreTokens().not()) tokenizer = StringTokenizer(reader.readLine() ?: return """", "" "")    return tokenizer.nextToken()}private fun readInt() = read().toInt()private fun readDouble() = read().toDouble()private fun readLong() = read().toLong()private fun readStrings(n: Int) = List(n) { read() }private fun readLines(n: Int) = List(n) { readLn() }private fun readInts(n: Int) = List(n) { read().toInt() }private fun readIntArray(n: Int) = IntArray(n) { read().toInt() }private fun readDoubles(n: Int) = List(n) { read().toDouble() }private fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }private fun readLongs(n: Int) = List(n) { read().toLong() }private fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val writer = PrintWriter(OUTPUT, false)private const val M = 1000005 fun main() {        writer.solve()        writer.flush()} fun PrintWriter.solve() {    val t = readInt()    val final = StringBuilder()    (0 until t).forEach { _ ->        val n = readInt()        val m = readInt()        val g = Array<Vector<Int>>(n + 1) { Vector(0) }        val teacher = IntArray(n + 1)        val visited = IntArray(n + 1)        (0 until m).forEach { _ ->            val u = readInt()            val v = readInt()            g[u].add(v)            g[v].add(u)        }        teacher[1] = 1        g[1].forEach {            teacher[it] = -1        }        fun dfs(source: Int) {            visited[source] = 1            if (teacher[source] == -1) {                g[source].forEach {                    if (teacher[it] == 0) {                        teacher[it] = 1                    }                }            }            if (teacher[source] == 1) {                g[source].forEach {                    teacher[it] = -1                }            }            g[source].forEach {                if (visited[it] == 0)                    dfs(it)            }        }        dfs(1)        val ans = StringBuilder()        var flag = true        var count = 0        (1..n).forEach {            if (visited[it] == 0)                flag = false            if (teacher[it] == 1) {                ans.append(it).append(' ')                count++            }        }        if (flag) {            final.append(""YES\n"").append(count).append('\n').append(ans).append('\n')        } else            final.append(""NO\n"")    }    print(final)}","constructive algorithms,dfs and similar,graph matchings,graphs,greedy"
"import java.io.BufferedInputStreamimport java.lang.StringBuilderimport java.util.*import kotlin.collections.ArrayDequeimport kotlin.collections.ArrayListimport kotlin.collections.HashMap private val scanner = FastScanner()private val size = 100_000 + 10 private var n: Int = 0 private lateinit var Int: BooleanArrayprivate lateinit var edges: Array<ArrayDeque<Int>> var debug = false fun main() {    scanner.apply {        val T = nextInt()         val stringResult = StringBuilder()         for (TEST in 1..T) {            initB()            stringResult.appendLine(runTestB(T, TEST))        }         print(stringResult)    }} class FastScanner {    private val BS = 1 shl 16    private val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC    private var `in`: BufferedInputStream? = null     private val char: Char        get() {            while (bId == size) {                size = try {                    `in`!!.read(buf)                } catch (e: Exception) {                    return NC                }                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c >= '0' && c <= '9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }     init {        `in` = BufferedInputStream(System.`in`, BS)    }} fun initB() {} fun runTestB(T: Int, t: Int): String {    scanner.apply {        n = nextInt()        val m = nextInt()         val visited = IntArray(n + 1)        edges = Array(n + 1) { ArrayDeque() }         for (i in 1..m) {            val a = nextInt()            val b = nextInt()            edges[a].add(b)            edges[b].add(a)        }         val next = ArrayDeque<Int>(n + 1)        next.addLast(1)        var blacks = 0        var seen = 0        val result = ArrayList<Int>(n)        while (!next.isEmpty()) {            val v = next.removeFirst()            if (visited[v] and 2 != 0) {                continue            }            visited[v] = visited[v] or 2            val isCurrentWhite = visited[v] and 1 != 0            if (!isCurrentWhite) {                result.add(v)                blacks++            }            seen++            if (edges[v].isEmpty())                break            val neighbours = edges[v]            while (!neighbours.isEmpty()) {                val u = neighbours.removeLast()                if (!isCurrentWhite) {                    visited[u] = visited[u] or 1                    next.addLast(u)                } else {                    next.addFirst(u)                }            }        }         if (seen == n) {            return StringBuilder().append(""YES\n$blacks\n"").append(result.joinToString("" "")).toString()        } else {            return ""NO""        }    }} fun solveB(str: String, k: Int) {}","constructive algorithms,dfs and similar,graph matchings,graphs,greedy"
"import java.io.BufferedInputStreamimport java.lang.StringBuilderimport java.util.*import kotlin.collections.ArrayDequeimport kotlin.collections.ArrayListimport kotlin.collections.HashMap private val scanner = FastScanner()private val size = 100_000 + 10 private var n: Int = 0 private lateinit var Int: BooleanArrayprivate lateinit var edges: HashMap<Int, ArrayDeque<Int>> var debug = false fun main() {    scanner.apply {        val T = nextInt()         for (TEST in 1..T) {            initB()            runTestB(T, TEST)        }    }} class FastScanner {    private val BS = 1 shl 16    private val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC    private var `in`: BufferedInputStream? = null     private val char: Char        get() {            while (bId == size) {                size = try {                    `in`!!.read(buf)                } catch (e: Exception) {                    return NC                }                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c >= '0' && c <= '9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }     init {        `in` = BufferedInputStream(System.`in`, BS)    }} fun initB() {    edges = HashMap()} fun runTestB(T: Int, t: Int) {    scanner.apply {        n = nextInt()        val m = nextInt()         val visited = IntArray(n + 1)         for (i in 1..m) {            val a = nextInt()            val b = nextInt()            if (!edges.containsKey(a)) {                edges[a] = ArrayDeque()            }            edges[a]!!.add(b)            if (!edges.containsKey(b)) {                edges[b] = ArrayDeque()            }            edges[b]!!.add(a)        }         val next = ArrayDeque<Int>(n + 1)        next.addLast(1)        var blacks = 0        var seen = 0        val result = ArrayList<Int>(n)        while (!next.isEmpty()) {            val v = next.removeFirst()            if (visited[v] and 2 != 0) {                continue            }            visited[v] = visited[v] or 2            val isCurrentWhite = visited[v] and 1 != 0            if (!isCurrentWhite) {                result.add(v)                blacks++            }            seen++            if (!edges.containsKey(v))                break            val neighbours = edges[v]!!            while (!neighbours.isEmpty()) {                val u = neighbours.removeFirst()                if (!isCurrentWhite) {                    visited[u] = visited[u] or 1                    next.addLast(u)                } else {                    next.addFirst(u)                }            }        }         if (seen == n) {            println(""YES\n$blacks\n"" + result.joinToString("" ""))        } else {            println(""NO"")        }    }} fun solveB(str: String, k: Int) {}","constructive algorithms,dfs and similar,graph matchings,graphs,greedy"
"import java.util.*import kotlin.math.abs fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readLong() = readLn().toLong()fun readInts() = readLn().split("" "").map{it.toInt() }fun readLongs() = readLn().split("" "").map { it.toLong() } class DSU(var n:Int){    var p = IntArray(n){it}    fun get(x:Int):Int {        return if( p[x] == x) x        else {            p[x] = get(p[x])            p[x]        }    }     fun unite(a: Int, b: Int) {        p[get(a)] = get(b)    }} data class Edge(var a:Int, var b:Int, var c: Int)   fun main(args: Array<String>) {    var t = readInt()    repeat(t) {        var (n,m,k) = readInts()        fun getCost(s:Int) = if (s<=k) 0 else (s-k)        var edges = Array(m){            var (x,y,s) = readInts()            x-=1            y-=1            Edge(x,y, s)        }.sortedBy { getCost(it.c) }        var dsu = DSU(n)        var res = 0L        for(i in edges) {            if(dsu.get(i.a) != dsu.get(i.b)) {                res+=getCost(i.c)                dsu.unite(i.a, i.b)            }        }        if(res == 0L)        {            res = abs(edges[0].c-k).toLong()            for(i in edges)                res = minOf(res, abs(i.c-k).toLong())        }        println(res)    }}","dsu,graphs,greedy"
"import java.io.PrintWriterimport java.io.Fileimport java.util.StringTokenizerimport kotlin.math.abs fun PrintWriter.solve() {    data class Edge (        var startNode: Int,         var endNode: Int,         var weight: Int    )    repeat(readInt()) {        var (n,m,k) = readInts(3)        var rank = IntArray(n) { 0 }        var root = IntArray(n)        for(i in 0..n-1) {            root[i] = i        }        var edges = Array<Edge>(m) {            var (x,y,s) = readInts(3)            Edge(x-1,y-1,s)        }.sortedBy{ it.weight }        var changeCount: Long = 0L        for(i in 0..m-1) {            var start = edges[i].startNode            var end = edges[i].endNode            while(root[start] != start) {                start = root[start]            }            while(root[end] != end) {                end = root[end]            }            if(start == end) continue            if(rank[start] < rank[end]) {                start = end.also { end = start }            }            else if(rank[start] == rank[end]) {                rank[start]++            }            root[end] = start            changeCount += maxOf(0L, (edges[i].weight - k).toLong())        }        if(changeCount == 0L) {            changeCount = 1000000007L            for(i in 0..m-1) {                changeCount = minOf(changeCount, abs(edges[i].weight - k).toLong())            }        }        printf(""%d\n"",changeCount)    }} //I/O template @JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out @JvmField val _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false)inline fun output(block: PrintWriter.() -> Unit) { _writer.apply(block).flush() } fun main(args: Array<String>) { _writer.solve(); _writer.flush() }","dsu,graphs,greedy"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"")@file:OptIn(ExperimentalUnsignedTypes::class, ExperimentalStdlibApi::class) import java.io.PrintWriterimport java.util.PriorityQueueimport kotlin.math.*import kotlin.random.Randomimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {//    val startTime = System.nanoTime()     val numCases = readInt()    case@ for(case in 1..numCases) {        //print(""Case #$case: "")         val n = readInt()        val m = readInt()        val k = readInt()         val U = IntArray(m)        val V = IntArray(m)        val W = IntArray(m) { i ->            U[i] = readInt()-1            V[i] = readInt()-1            readInt()        }         val J = W.sortedIndices()         val t = J.indexOfFirst { i -> W[i] > k }.let { if(it < 0) m else it }         val dsu = DSU(n)        var cmp = n         val ans = run ans@{            for (i in 0 until t) {                val j = J[i]                if (dsu.join(U[j], V[j])) {                    cmp--                    if(cmp == 1) {                        val a = if(t == 0) Int.MAX_VALUE else k - W[J[t-1]]                        val b = if(t == m) Int.MAX_VALUE else W[J[t]] - k                         return@ans min(a, b).toLong()                    }                }            }             var ans = 0L             for(i in t until m) {                val j = J[i]                if (dsu.join(U[j], V[j])) {                    ans += W[j] - k                    cmp--                    if(cmp == 1) break                }            }             ans        }         println(ans)    } //    iprintln(""Time: ${(System.nanoTime() - startTime) / 1000000} ms"")} class DSU(n: Int) {    private val id = IntArray(n) { it }    private val sz = IntArray(n) { 1 }     tailrec fun root(v: Int): Int =        if(id[v] == v) v else {            id[v] = id[id[v]]            root(id[v])        }     /** @return false if the two vertices are already joined, true if the join operation is successful */    fun join(u: Int, v: Int): Boolean {        var ru = root(u)        var rv = root(v)        if(ru == rv) return false        if(sz[ru] < sz[rv]) ru = rv.also { rv = ru }        id[rv] = ru        sz[ru] += sz[rv]        return true    }     fun isJoined(u: Int, v: Int) = root(u) == root(v)     fun size(v: Int) = sz[root(v)]} class IntList(initialCapacity: Int = 12) {    private var arr = IntArray(initialCapacity)    val _arr get() = arr    private val capacity get() = arr.size    var size = 0        private set    inline val lastIndex get() = size - 1    inline val indices get() = 0 until size     constructor(copyFrom: IntArray): this(copyFrom.size) { copyFrom.copyInto(arr); size = copyFrom.size }    constructor(copyFrom: Collection<Int>): this(copyFrom.size) { arr = copyFrom.toIntArray(); size = copyFrom.size }     fun contentEquals(other: IntList): Boolean {        return this === other || size == other.size && indices.all { this[it] == other[it] }    }     private fun grow(minCapacity: Int = 8) {        val newCapacity = maxOf(minCapacity, capacity + (capacity shr 1))        arr = arr.copyOf(newCapacity)    }     fun ensureCapacity(minCapacity: Int) { if(capacity < minCapacity) grow(minCapacity) }     operator fun get(index: Int): Int {        require(index in 0 until size)        return arr[index]    }     operator fun set(index: Int, value: Int) {        require(index in 0 until size)        arr[index] = value    }     fun add(value: Int) {        if(size == capacity) grow()        arr[size++] = value    }     fun addAll(list: IntList) {        ensureCapacity(size + list.size)        list.arr.copyInto(arr, size, 0, list.size)        size += list.size    }     fun add(index: Int, element: Int) {        if(size == capacity) grow()        arr.copyInto(arr, index + 1, index, size)        size++        set(index, element)    }     fun clear() { size = 0 }     fun removeAt(index: Int): Int {        val e = get(index)        arr.copyInto(arr, index, index + 1, size)        size--        return e    }     fun indexOf(e: Int): Int {        for(i in 0 until size) if(this[i] == e) return i        return -1    }     fun remove(e: Int): Boolean {        val i = indexOf(e)        if(i == -1) return false        removeAt(i)        return true    }     operator fun iterator() = object: IntIterator() {        private var pos = 0        override fun hasNext() = pos < size        override fun nextInt() = get(pos++)    }     inline fun isEmpty() = size == 0    inline fun isNotEmpty() = size != 0     fun pop() = arr[--size]     fun popToSize(s: Int) {        require(s >= 0)        if(s < size) size = s    }     fun swap(i: Int, j: Int) { val t = this[i]; this[i] = this[j]; this[j] = t }    fun reverse() {        for(i in 0 until size / 2) swap(i, lastIndex - i)    }     fun shuffle(rnd: Random = random) { for(i in lastIndex downTo 1) swap(i, rnd.nextInt(i+1)) }     inline fun sortWith(cmp: (Int, Int) -> Int) { _mergeSort(_arr, size, IntArray(size), IntArray::get, IntArray::set, cmp) }    inline fun <T: Comparable<T>> sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }    inline fun <T: Comparable<T>> sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }    fun sort() { sortBy { it } }    fun sortDescending() { sortByDescending { it } }     fun joinToString(separator: CharSequence) = if(size == 0) """" else let {        buildString {            append(it[0])            for (i in 1 until size) {                append(separator).append(it[i])            }        }    }     override fun toString() = ""["" + joinToString("", "") + ""]""     fun toIntArray() = arr.copyOf(size)    fun toList() = List(size, ::get)     inline fun first() = get(0)    inline fun last() = get(lastIndex)} inline fun IntList(size: Int, init: (Int) -> Int) = IntList(size).apply {    for(i in 0 until size) { add(init(i)) }}inline fun IntArray.toIntList() = IntList(this)inline fun Collection<Int>.toIntList() = IntList(this)inline fun intListOf(vararg values: Int) = IntList(values) fun IntList.max() = (1 until size).fold(this[0]) { acc, i -> max(acc, this[i]) }fun IntList.min() = (1 until size).fold(this[0]) { acc, i -> min(acc, this[i]) }fun IntList.getOrNull(i: Int) = if(i in indices) get(i) else nullinline fun IntList.count(predicate: (Int) -> Boolean) = indices.count { predicate(this[it]) }fun IntList.copyOf() = IntList(size, ::get)  /** IO *///@JvmField val ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null//const val PATH = ""src/main/resources/""//@JvmField val INPUT = File(PATH + ""input.txt"").inputStream()//@JvmField val OUTPUT = File(PATH + ""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar() else c    }} /** @param skipNext Whether to skip the next character (usually whitespace), defaults to true */fun readCharArray(n: Int, skipNext: Boolean = true): CharArray {    val res = CharArray(n) { readChar() }    if(skipNext) readChar()    return res} fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(c != '\n' && c != Char.MIN_VALUE) {            append(c)            c = readChar()        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /**  sort overrides to avoid quicksort attacks */ @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } inline fun <A, T> _mergeSort(a0: A, n: Int, tmp0: A, get: A.(Int) -> T, set: A.(Int, T) -> Unit, cmp: (T, T) -> Int) {    var a = a0    var tmp = tmp0    var len = 1    while(len < n) {        var l = 0        while(true) {            val m = l + len            if(m >= n) break            val r = min(n, m + len)            var i = l            var j = m            for(k in l until r) {                if(i != m && (j == r || cmp(a.get(i), a.get(j)) <= 0)) {                    tmp.set(k, a.get(i++))                } else tmp.set(k, a.get(j++))            }            l = r        }        for(i in l until n) tmp.set(i, a.get(i))        val t = a; a = tmp; tmp = t        len += len    }    if(a !== a0) for(i in 0 until n) a0.set(i, tmp0.get(i))} inline fun IntArray.sortWith(cmp: (Int, Int) -> Int) { _mergeSort(this, size, IntArray(size), IntArray::get, IntArray::set, cmp) }inline fun <T: Comparable<T>> IntArray.sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> IntArray.sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun IntArray.sort() { sortBy { it } }fun IntArray.sortDescending() { sortByDescending { it } } inline fun LongArray.sortWith(cmp: (Long, Long) -> Int) { _mergeSort(this, size, LongArray(size), LongArray::get, LongArray::set, cmp) }inline fun <T: Comparable<T>> LongArray.sortBy(func: (Long) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> LongArray.sortByDescending(func: (Long) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun LongArray.sort() { sortBy { it } }fun LongArray.sortDescending() { sortByDescending { it } } inline fun DoubleArray.sortWith(cmp: (Double, Double) -> Int) { _mergeSort(this, size, DoubleArray(size), DoubleArray::get, DoubleArray::set, cmp) }inline fun <T: Comparable<T>> DoubleArray.sortBy(func: (Double) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> DoubleArray.sortByDescending(func: (Double) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun DoubleArray.sort() { sortBy { it } }fun DoubleArray.sortDescending() { sortByDescending { it } } inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T : Comparable<T>> Array<out T>.sort() = _sort()inline fun <T : Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T : Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T : Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() // import preserving junk function@Suppress(""NonAsciiCharacters"") fun 雪花飄飄北風嘯嘯天地一片蒼茫() { iprintln(max(1, 2)) } fun IntArray.sumLong() = sumOf { it.toLong() } fun IntArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun IntArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun LongArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun LongArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun DoubleArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun DoubleArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> Array<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> Array<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> List<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> List<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) } // max/min Kotlin 1.6 -> 1.4 shimfun IntArray.max() = maxOf { it }fun IntArray.min() = minOf { it }fun LongArray.max() = maxOf { it }fun LongArray.min() = minOf { it }fun CharArray.max() = maxOf { it }fun CharArray.min() = minOf { it }fun <T : Comparable<T>> Iterable<T>.max() = maxOf { it }fun <T : Comparable<T>> Iterable<T>.min() = minOf { it }fun <T : Comparable<T>> Sequence<T>.max() = maxOf { it }fun <T : Comparable<T>> Sequence<T>.min() = minOf { it }","dsu,graphs,greedy"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"")@file:OptIn(ExperimentalUnsignedTypes::class, ExperimentalStdlibApi::class) import java.io.PrintWriterimport java.util.PriorityQueueimport kotlin.math.*import kotlin.random.Randomimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {//    val startTime = System.nanoTime()     val numCases = readInt()    case@ for(case in 1..numCases) {        //print(""Case #$case: "")         val n = readInt()        val m = readInt()        val k = readInt()         val U = IntArray(m)        val V = IntArray(m)        val W = IntArray(m) { i ->            U[i] = readInt()-1            V[i] = readInt()-1            readInt()        }         val J = W.sortedIndices()         val dsu = DSU(n)        var cmp = n         val ans = run ans@{            var ans = 0L             for(i in 0 until m) {                val j = J[i]                if (dsu.join(U[j], V[j])) {                    ans += max(0, W[j] - k)                    cmp--                    if(cmp == 1) {                        if(W[j] >= k) return@ans ans                        val t = bsFirst(i, m-1) { W[J[it]] > k }                        val a = k - W[J[t-1]]                        val b = if(t == m) Int.MAX_VALUE else W[J[t]] - k                        return@ans min(a, b).toLong()                    }                }            }             error("""")        }         println(ans)    } //    iprintln(""Time: ${(System.nanoTime() - startTime) / 1000000} ms"")} inline fun bsFirst(first: Int, last: Int, predicate: (Int) -> Boolean): Int {    var low = first    var high = last     while (low <= high) {        val mid = low.and(high) + low.xor(high).shr(1)        if(predicate(mid)) high = mid - 1        else low = mid + 1    }    return low}inline fun IntRange.bsFirst(predicate: (Int) -> Boolean) = bsFirst(first, last, predicate) inline fun bsLast(first: Int, last: Int, predicate: (Int) -> Boolean) = bsFirst(first, last) { !predicate(it) } - 1inline fun IntRange.bsLast(predicate: (Int) -> Boolean) = bsLast(first, last, predicate) class DSU(n: Int) {    private val id = IntArray(n) { it }    private val sz = IntArray(n) { 1 }     tailrec fun root(v: Int): Int =        if(id[v] == v) v else {            id[v] = id[id[v]]            root(id[v])        }     /** @return false if the two vertices are already joined, true if the join operation is successful */    fun join(u: Int, v: Int): Boolean {        var ru = root(u)        var rv = root(v)        if(ru == rv) return false        if(sz[ru] < sz[rv]) ru = rv.also { rv = ru }        id[rv] = ru        sz[ru] += sz[rv]        return true    }     fun isJoined(u: Int, v: Int) = root(u) == root(v)     fun size(v: Int) = sz[root(v)]} class IntList(initialCapacity: Int = 12) {    private var arr = IntArray(initialCapacity)    val _arr get() = arr    private val capacity get() = arr.size    var size = 0        private set    inline val lastIndex get() = size - 1    inline val indices get() = 0 until size     constructor(copyFrom: IntArray): this(copyFrom.size) { copyFrom.copyInto(arr); size = copyFrom.size }    constructor(copyFrom: Collection<Int>): this(copyFrom.size) { arr = copyFrom.toIntArray(); size = copyFrom.size }     fun contentEquals(other: IntList): Boolean {        return this === other || size == other.size && indices.all { this[it] == other[it] }    }     private fun grow(minCapacity: Int = 8) {        val newCapacity = maxOf(minCapacity, capacity + (capacity shr 1))        arr = arr.copyOf(newCapacity)    }     fun ensureCapacity(minCapacity: Int) { if(capacity < minCapacity) grow(minCapacity) }     operator fun get(index: Int): Int {        require(index in 0 until size)        return arr[index]    }     operator fun set(index: Int, value: Int) {        require(index in 0 until size)        arr[index] = value    }     fun add(value: Int) {        if(size == capacity) grow()        arr[size++] = value    }     fun addAll(list: IntList) {        ensureCapacity(size + list.size)        list.arr.copyInto(arr, size, 0, list.size)        size += list.size    }     fun add(index: Int, element: Int) {        if(size == capacity) grow()        arr.copyInto(arr, index + 1, index, size)        size++        set(index, element)    }     fun clear() { size = 0 }     fun removeAt(index: Int): Int {        val e = get(index)        arr.copyInto(arr, index, index + 1, size)        size--        return e    }     fun indexOf(e: Int): Int {        for(i in 0 until size) if(this[i] == e) return i        return -1    }     fun remove(e: Int): Boolean {        val i = indexOf(e)        if(i == -1) return false        removeAt(i)        return true    }     operator fun iterator() = object: IntIterator() {        private var pos = 0        override fun hasNext() = pos < size        override fun nextInt() = get(pos++)    }     inline fun isEmpty() = size == 0    inline fun isNotEmpty() = size != 0     fun pop() = arr[--size]     fun popToSize(s: Int) {        require(s >= 0)        if(s < size) size = s    }     fun swap(i: Int, j: Int) { val t = this[i]; this[i] = this[j]; this[j] = t }    fun reverse() {        for(i in 0 until size / 2) swap(i, lastIndex - i)    }     fun shuffle(rnd: Random = random) { for(i in lastIndex downTo 1) swap(i, rnd.nextInt(i+1)) }     inline fun sortWith(cmp: (Int, Int) -> Int) { _mergeSort(_arr, size, IntArray(size), IntArray::get, IntArray::set, cmp) }    inline fun <T: Comparable<T>> sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }    inline fun <T: Comparable<T>> sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }    fun sort() { sortBy { it } }    fun sortDescending() { sortByDescending { it } }     fun joinToString(separator: CharSequence) = if(size == 0) """" else let {        buildString {            append(it[0])            for (i in 1 until size) {                append(separator).append(it[i])            }        }    }     override fun toString() = ""["" + joinToString("", "") + ""]""     fun toIntArray() = arr.copyOf(size)    fun toList() = List(size, ::get)     inline fun first() = get(0)    inline fun last() = get(lastIndex)} inline fun IntList(size: Int, init: (Int) -> Int) = IntList(size).apply {    for(i in 0 until size) { add(init(i)) }}inline fun IntArray.toIntList() = IntList(this)inline fun Collection<Int>.toIntList() = IntList(this)inline fun intListOf(vararg values: Int) = IntList(values) fun IntList.max() = (1 until size).fold(this[0]) { acc, i -> max(acc, this[i]) }fun IntList.min() = (1 until size).fold(this[0]) { acc, i -> min(acc, this[i]) }fun IntList.getOrNull(i: Int) = if(i in indices) get(i) else nullinline fun IntList.count(predicate: (Int) -> Boolean) = indices.count { predicate(this[it]) }fun IntList.copyOf() = IntList(size, ::get)  /** IO *///@JvmField val ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null//const val PATH = ""src/main/resources/""//@JvmField val INPUT = File(PATH + ""input.txt"").inputStream()//@JvmField val OUTPUT = File(PATH + ""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar() else c    }} /** @param skipNext Whether to skip the next character (usually whitespace), defaults to true */fun readCharArray(n: Int, skipNext: Boolean = true): CharArray {    val res = CharArray(n) { readChar() }    if(skipNext) readChar()    return res} fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(c != '\n' && c != Char.MIN_VALUE) {            append(c)            c = readChar()        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /**  sort overrides to avoid quicksort attacks */ @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } inline fun <A, T> _mergeSort(a0: A, n: Int, tmp0: A, get: A.(Int) -> T, set: A.(Int, T) -> Unit, cmp: (T, T) -> Int) {    var a = a0    var tmp = tmp0    var len = 1    while(len < n) {        var l = 0        while(true) {            val m = l + len            if(m >= n) break            val r = min(n, m + len)            var i = l            var j = m            for(k in l until r) {                if(i != m && (j == r || cmp(a.get(i), a.get(j)) <= 0)) {                    tmp.set(k, a.get(i++))                } else tmp.set(k, a.get(j++))            }            l = r        }        for(i in l until n) tmp.set(i, a.get(i))        val t = a; a = tmp; tmp = t        len += len    }    if(a !== a0) for(i in 0 until n) a0.set(i, tmp0.get(i))} inline fun IntArray.sortWith(cmp: (Int, Int) -> Int) { _mergeSort(this, size, IntArray(size), IntArray::get, IntArray::set, cmp) }inline fun <T: Comparable<T>> IntArray.sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> IntArray.sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun IntArray.sort() { sortBy { it } }fun IntArray.sortDescending() { sortByDescending { it } } inline fun LongArray.sortWith(cmp: (Long, Long) -> Int) { _mergeSort(this, size, LongArray(size), LongArray::get, LongArray::set, cmp) }inline fun <T: Comparable<T>> LongArray.sortBy(func: (Long) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> LongArray.sortByDescending(func: (Long) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun LongArray.sort() { sortBy { it } }fun LongArray.sortDescending() { sortByDescending { it } } inline fun DoubleArray.sortWith(cmp: (Double, Double) -> Int) { _mergeSort(this, size, DoubleArray(size), DoubleArray::get, DoubleArray::set, cmp) }inline fun <T: Comparable<T>> DoubleArray.sortBy(func: (Double) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> DoubleArray.sortByDescending(func: (Double) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun DoubleArray.sort() { sortBy { it } }fun DoubleArray.sortDescending() { sortByDescending { it } } inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T : Comparable<T>> Array<out T>.sort() = _sort()inline fun <T : Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T : Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T : Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() // import preserving junk function@Suppress(""NonAsciiCharacters"") fun 雪花飄飄北風嘯嘯天地一片蒼茫() { iprintln(max(1, 2)) } fun IntArray.sumLong() = sumOf { it.toLong() } fun IntArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun IntArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun LongArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun LongArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun DoubleArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun DoubleArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> Array<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> Array<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> List<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> List<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) } // max/min Kotlin 1.6 -> 1.4 shimfun IntArray.max() = maxOf { it }fun IntArray.min() = minOf { it }fun LongArray.max() = maxOf { it }fun LongArray.min() = minOf { it }fun CharArray.max() = maxOf { it }fun CharArray.min() = minOf { it }fun <T : Comparable<T>> Iterable<T>.max() = maxOf { it }fun <T : Comparable<T>> Iterable<T>.min() = minOf { it }fun <T : Comparable<T>> Sequence<T>.max() = maxOf { it }fun <T : Comparable<T>> Sequence<T>.min() = minOf { it }","dsu,graphs,greedy"
"fun main() {    val t = readLine()!!.toInt()    repeat(t) {        val n = readLine()!!.toInt()        val a = readLine()!!.split("" "").map { it.toInt() }        val mp = mutableMapOf<Int,Int>()        mp[a[0]] = 1        for (i in 1 until n) {            if (a[i] != a[i-1]) {                mp[a[i]] = (mp[a[i]] ?: 1) + 1            }        }        mp[a.last()] = mp[a.last()]!! - 1        val c = mp.minBy { it.value }?.value ?: 0        println(c)    }}","greedy,implementation"
"import java.util.*import kotlin.collections.HashMap val inp = Scanner(System.`in`) fun main() {    repeat(inp.nextInt(), ::solveCase)} fun solveCase(i: Int) {    val inp = List(inp.nextInt()) { inp.nextInt() }     var last = Integer.MIN_VALUE     val counts = HashMap<Int, Int>()    for (i in inp) {        if (last != i) {            last = i            counts[i] = counts.getOrDefault(i, 0) + 1        }    }     counts[inp.first()] = counts[inp.first()]!! - 1    counts[inp.last()] = counts[inp.last()]!! - 1     println(counts.minBy { it.value }!!.value + 1)}","greedy,implementation"
"import java.util.*fun main() {    val inp=Scanner(System.`in`)   repeat(inp.nextInt()){       val n=inp.nextInt()       val a=IntArray(n){inp.nextInt()}       val b= mutableMapOf<Int,Int>()       b[a[0]]=0       for (i in 1 until n){           if (a[i]!=a[i-1]){               if (b.containsKey(a[i])){                   b[a[i]]=b.getValue(a[i])+1               }               else b[a[i]]=1           }       }       b[a[n-1]]=b.getValue(a[n-1])-1       var min=b[a[0]]       b.forEach{(_,s)->           if (min!!>s) min=s       }       println(min!!+1)   }}","greedy,implementation"
"fun main() {    val t = readLine()!!.toInt()    for (i in 0 until t) {        testCase()    }} fun testCase() {    val n = readLine()!!.toInt()    val a = readLine()!!.split("" "").map { it.toInt() }    val b = mutableMapOf<Int, Int>()    var prev = a[0]    b[prev] = 0    for (i in 1 until n) {        val current = a[i]        if (prev != current) {            b[prev] = (b[prev] ?: 0) + 1            if ((b[current] ?: 0) == 0)                b[current] = 1            prev = current        }    }    val min = b.minBy { it.value }    println(min?.value ?: 0)}","greedy,implementation"
"fun main() {    repeat(readLine()!!.toInt()) {        val t = readLine()!!.toLong()        if (t % 2 == 1L) return@repeat println(-1)        val bits = (1 until 63).filter { bit -> t and (1L shl bit) != 0L }.map { it - 2 }        val stages = mutableListOf<Int>()        for (bit in bits) {            if (bit == -1) continue            stages.add(1)            repeat(bit) { stages.add(0) }        }        repeat(bits.size) { stages.add(1) }        println(stages.size)        println(stages.joinToString("" ""))    }}","brute force,constructive algorithms,greedy,math,probabilities"
"fun main() {    for (c in 1..readLine()!!.toInt()) {        var k = readLine()!!.toLong()        if (k % 2L == 1L) {            println(-1)        } else {            val answer = mutableListOf<Char>()            for (h in 58 downTo 1) {                while (k >= (1L shl (h + 1)) - 2L) {                    k -= (1L shl (h + 1)) - 2L                    answer.add('1')                    for (j in 2..h) {                        answer.add('0')                    }                }            }            println(answer.size)            println(answer.joinToString("" ""))        }    }}","brute force,constructive algorithms,greedy,math,probabilities"
"fun readInt() = readLine()!!.toInt()fun readLong() = readLine()!!.toLong() fun main() {    val ps = LongArray(62)     var c = 0L    var p = 1L    for (i in 0 until 62) {        p *= 2        c += p        ps[i] = c    }     repeat(readInt()) {        val n = readLong()        val s = solve(n, ps)        if (s == null) {            println(-1)        } else {            println(s.size)            println(s.map { if (it) 1 else 0 }.joinToString(separator="" ""))        }    }} fun solve(n_in: Long, ps: LongArray): List<Boolean>? {    var p = ps.size-1    var n = n_in - 2    if (n < 0) return null    val s = mutableListOf<Boolean>(true)     while (n > 0) {        if (n > ps[p]) return null        while (p >= 0 && ps[p] > n) p--        if (p == -1) return null        n -= ps[p]        s.addAll((0 until p).map { false })        s.add(true)    }     return s}","brute force,constructive algorithms,greedy,math,probabilities"
"private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readLong() = readLn().toLong() // single longprivate fun readDouble() = readLn().toDouble() // single doubleprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of intsprivate fun readLongs() = readStrings().map { it.toLong() } // list of longsprivate fun readDoubles() = readStrings().map { it.toDouble() } // list of doubles  fun main() {    repeat(readInt()) {        var k = readLong()        if (k % 2 == 1L) println(-1)        else {            val ans = mutableListOf<Int>()            while (k > 0) {                var i = 1                while ((1L shl i + 1) - 2L <= k) i++                ans += 1                for (j in 2 until i) ans += 0                k -= (1L shl i) - 2L            }            println(ans.size)            println(ans.joinToString("" ""))        }    }}","brute force,constructive algorithms,greedy,math,probabilities"
"fun main() = repeat(readLine()!!.toInt()) {    val (x, y) = readLine()!!.split("" "").map { it.toInt() }    println(2 * maxOf(x, y) - if (x != y) 1 else 0)}",math
"fun main() = repeat(readLine()!!.toInt()) {    val (x, y) = readLine()!!.split("" "").map { it.toInt() }    println(2 * maxOf(x, y) - if (x != y) 1 else 0)}",math
"import kotlin.math.max fun main() {    for (c in 1..readLine()!!.toInt()) {        val (x, y) = readLine()!!.split("" "").map { it.toInt() }.sorted()        println(max(x + y, (2 * y) - 1))    }}",math
"import kotlin.math.max fun solve(){    var a = readLine()!!.split("" "").map { s -> s.toInt() }    println(a[0] + a[1] + max(max(a[0] - a[1] - 1, a[1] - a[0] - 1), 0))} fun main() {    var t = readLine()!!.toInt()    for (i in 0 until t) {        solve()    }}",math
"import java.util.* fun main() {    val n = readInt()    fun ask(op: String, i: Int, j: Int): Int {        println(""$op ${i+1} ${j+1}"")        System.out.flush()        return readInt().takeIf { it >= 0 }!!    }    // n-1    val xors = IntArray(n) { 0 }    for (i in 1 until n) {        xors[i] = ask(""XOR"", 0, i)    }    val res = IntArray(n) { 0 }    val sameXors = xors.withIndex().groupBy { it.value }.entries.find { it.value.size >= 2 }?.value?.map { it.index }    if (sameXors != null) {        val (x, y) = sameXors        res[x] = ask(""AND"", x, y)        res[0] = res[x] xor xors[x]    } else {        val i1 = xors.indices.find { xors[it] == 1 }!!        res[i1] = ask(""AND"", 0, i1)        val i2 = xors.indices.find { xors[it] == 2 }!!        res[i2] = ask(""AND"", 0, i2)        res[i1] += 1 - (res[i2] % 2)        res[0] = res[i1] xor xors[i1]    }    for (i in 1 until n) {        res[i] = res[0] xor xors[i]    }    println(""! ${res.joinToString("" "")}"")}private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "").filter { !it.isBlank() }private fun readLongs() = readStrings().map { it.toLong() }private fun readInts() = readStrings().map { it.toInt() }","bitmasks,constructive algorithms,interactive,math"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.*import kotlin.math.floorimport kotlin.math.sqrt fun main() {    Scanner(BufferedReader(InputStreamReader(System.`in`))).use { scanner ->        val n = scanner.nextInt()        val xors = IntArray(n + 10)         val xorsMap = IntArray(n + 10)        val answer = IntArray(n + 10)        var flag = false        var equal1 = 0        var equal2 = 0        xorsMap[0] = 1        for (i in 2..n) {            println(""XOR 1 $i"")            System.out.flush()            val x = scanner.nextInt()            xors[i] = x            if (x == 0 || xorsMap[x] != 0) {                flag = true                equal1 = i                equal2 = xorsMap[x]            }            xorsMap[x] = i        }         val z : Int        if (flag) {            println(""AND $equal1 $equal2"")            System.out.flush()             val x = scanner.nextInt()            z = x xor xors[equal1]        } else {            println(""AND 1 ${xorsMap[1]}"")            System.out.flush()            val q = scanner.nextInt()            println(""AND 1 ${xorsMap[2]}"")            System.out.flush()            val t = scanner.nextInt()            z = q + (t and 1)        }         print(""! "")        for (i in 1..n) {            print(z xor xors[i])            print(' ')        }        System.out.flush()    }}","bitmasks,constructive algorithms,interactive,math"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.io.PrintWriterimport java.util.* fun PrintWriter.solve(sc: FastScanner) {    val n = sc.nextInt()    val a = Array(n) { 0 }    println(""XOR 1 2"")    val x1 = sc.nextInt()    println(""XOR 2 3"")    val x2 = sc.nextInt()    val x3 = x1 xor x2    println(""AND 1 2"")    val y1 = sc.nextInt()    println(""AND 2 3"")    val y2 = sc.nextInt()    println(""AND 1 3"")    val y3 = sc.nextInt()    val z1 = x1 + 2 * y1 // a0+a1    val z2 = x2 + 2 * y2 // a1+a2    val z3 = x3 + 2 * y3 // a0+a2    a[0] = (z1 - z2 + z3) / 2    a[1] = a[0] xor x1    a[2] = a[1] xor x2    for (i in 3 until n) {        println(""XOR 1 ${i + 1}"")        val x = sc.nextInt()        a[i] = a[0] xor x    }    println(""! ${a.joinToString("" "")}"")} fun main() {    val writer = PrintWriter(System.out, !false)    writer.solve(FastScanner(System.`in`))    writer.flush()} class FastScanner(s: InputStream) {    private var st = StringTokenizer("""")    private val br = BufferedReader(InputStreamReader(s))     fun next(): String {        while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun nextInt() = next().toInt()    fun nextLong() = next().toLong()    fun nextLine() = br.readLine()    fun nextDouble() = next().toDouble()    fun ready() = br.ready()}","bitmasks,constructive algorithms,interactive,math"
"import java.lang.IllegalStateException fun main() {    val n = readLine()!!.toInt()    fun query(type: String, a: Int, b: Int): Int {        println(""$type ${a + 1} ${b + 1}"")        return readLine()!!.toInt()    }    val xors = IntArray(n) { if (it == 0) 0 else query(""XOR"", 0, it) }    val answer = IntArray(n)    val ix = IntArray(n)    val time = IntArray(n)    var t = 0    var found = false    for (mask in 0 until (n / 2)) {        t++        var a = Pair(-1, -1)        for (j in 0 until n) {            val x = mask and xors[j]            if (time[x] == t) {                a = Pair(ix[x], j)                break            } else {                time[x] = t                ix[x] = j            }        }        if (a.first != -1) {            t++            var b = Pair(-1, -1)            val nask = (n - 1) xor mask            for (j in 0 until n) {                val x = nask and xors[j]                if (time[x] == t) {                    b = Pair(ix[x], j)                    break                } else {                    time[x] = t                    ix[x] = j                }            }            if (b.first != -1) {                val y = query(""AND"", a.first, a.second) and mask                val z = query(""AND"", b.first, b.second) and nask                for (j in 0 until n) {                    answer[j] = ((xors[j] xor xors[a.first] xor y) and mask) + ((xors[j] xor xors[b.first] xor z) and nask)                }                found = true                break            }        }    }    if (!found) {        throw IllegalStateException()    }    println(""! "" + answer.joinToString("" ""))}","bitmasks,constructive algorithms,interactive,math"
"import java.io.BufferedReaderimport java.io.InputStreamReader fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val out = StringBuilder()    for (c in 1..jin.readLine().toInt()) {        val n = jin.readLine().toInt()        val ay = jin.readLine().split("" "").map { it.toInt() }        val occs = Array(n + 1) { mutableListOf<Int>() }        for (j in 0 until n) {            occs[ay[j]].add(j)        }        var j = 1        var from = 0        var to = n - 1        while (j <= n && occs[j].size == 1 && (occs[j][0] == from || occs[j][0] == to)) {            if (occs[j][0] == from) {                from++            } else {                to--            }            j++        }        if (j <= n && occs[j].isNotEmpty()) {            j++        }        val answer = CharArray(n + 1) { if (it >= n + 2 - j) '1' else '0' }        if ((1..n).all { occs[it].isNotEmpty() }) {            answer[1] = '1'        }        out.appendln(String(answer).substring(1))    }    print(out)}","binary search,data structures,greedy,implementation,two pointers"
"import java.util.* private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrs() = readLn().split(' ')private fun readInts() = readStrs().map(String::toInt)private fun readLongs() = readStrs().map(String::toLong) private val counter = TreeMap<Int, Int>() private fun add(x: Int) {    counter[x] = (counter[x] ?: 0) + 1} private fun remove(x: Int) {    val t = (counter[x] ?: 0) - 1    if (t <= 0) counter.remove(x) else counter[x] = t} private fun run() {    val n = readInt()    val v = readInts()    counter.clear()    v.forEach { add(it) }     var L = 0    var R = n - 1    val sb = StringBuilder(n)    var flag = false    while (L <= R) {        val cur = sb.length + 1        if (counter.firstKey() == cur) sb.append('1') else break        if (counter[cur]!! > 1) break        if (v[L] == cur) {            L += 1        } else if (v[R] == cur) {            R -= 1        } else {            flag = (cur..n).toList() == v.subList(L, R + 1).sorted()            break        }        remove(cur)    }    while (sb.length < n) {        if (sb.length == n - 1 && flag) sb.append('1')        else sb.append(0)    }    println(sb.reverse().toString())} fun main() {    repeat(readInt()) { run() }}","binary search,data structures,greedy,implementation,two pointers"
"fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main() {    repeat(readInt()) {        val n = readInt()        val vs = readInts()         val available = MultisetInt(vs)        val happy = Array(n) { false }        happy[0] = (1..n).all { available.contains(it) }        happy[n-1] = available.contains(1)         var l = 0        var r = n-1        var ok = true        for (i in 1..n-2) {            when {                vs[l] == i -> l++                vs[r] == i -> r--                else -> ok = false            }             if (ok) {                available.remove(i)                ok = ok && available.min() == i+1            }            happy[n-i-1] = ok        }         println(happy.map { if (it) '1' else '0' }.joinToString(separator=""""))    }} /** * Multiset of int values. */class MultisetInt(init: Collection<Int>) {    // value -> # of copies    val vs = sortedMapOf<Int, Int>()     init {        init.forEach { add(it) }    }     fun add(elt: Int) {        vs.merge(elt, 1, Int::plus)    }     fun remove(elt: Int) {        vs[elt] = vs[elt]!! - 1        if (vs[elt] == 0) {            vs.remove(elt)        }    }     fun contains(i: Int): Boolean = vs.containsKey(i)     fun isEmpty(): Boolean = vs.isEmpty()     fun min(): Int = vs.firstKey()     fun max(): Int = vs.lastKey()}","binary search,data structures,greedy,implementation,two pointers"
"fun main() {    repeat(ri()) {        val n = ri()        val a = ria()         val available = MultiSetInt(a)        val happy = Array(n) { false }        happy[0] = (1..n).all { available.contains(it) }        happy[n-1] = available.contains(1)         var l = 0        var r = n-1        var ok = true        for (i in 1..n-2) {            when (i) {                a[l] -> l++                a[r] -> r--                else -> ok = false            }             if (ok) {                available.remove(i)                ok = ok && available.min() == i+1            }            happy[n-i-1] = ok        }         println(happy.map { if (it) '1' else '0' }.joinToString(separator=""""))    }} private fun prm(a: List<CharArray>) {    println(a.joinToString(separator = ""\n"") { it.joinToString(separator = """") })} private fun rim(n: Int) = (1..n).map { ria() }private fun ria() = r().split("" "").map { it.toInt() }private fun ri() = r().toInt()private fun rd() = r().toDouble()private fun r() = readLine()!!private fun rchM(n: Int) = (1..n).map { r().toCharArray() } class MultiSetInt(init: Collection<Int>) {    val vs = sortedMapOf<Int, Int>()     init {        init.forEach { add(it) }    }     fun add(elt: Int) {        vs.merge(elt, 1, Int::plus)    }     fun remove(elt: Int) {        vs[elt] = vs[elt]!! - 1        if (vs[elt] == 0) {            vs.remove(elt)        }    }     fun contains(i: Int): Boolean = vs.containsKey(i)     fun isEmpty(): Boolean = vs.isEmpty()     fun min(): Int = vs.firstKey()     fun max(): Int = vs.lastKey()}","binary search,data structures,greedy,implementation,two pointers"
"import java.util.*import kotlin.math.* fun rs()=readLine()!!fun ri()=rs().toInt()fun rl()=rs().toLong()fun rd()=rs().toDouble()fun ris()=rs().split("" "").map{it.toInt()}fun rls()=rs().split("" "").map{it.toLong()}fun rds()=rs().split("" "").map{it.toDouble()} val out=mutableListOf<String>()fun pln(s:String){out.add(s)}fun pln(i:Int)=pln(i.toString())fun pln(l:Long)=pln(l.toString())fun pln(d:Double,precision:Int=12)=pln((""%.""+precision.toString()+""f"").format(d))fun pln(a:IntArray)=pln(a.joinToString("" ""))fun pln(a:LongArray)=pln(a.joinToString("" ""))fun<T> pln(a:Array<T>)=pln(a.joinToString("" ""))fun<T> pln(a:ArrayList<T>)=pln(a.joinToString("" ""))fun output(){println(out.joinToString(""\n""))} fun main(){    val(n,m)=ris()    val E=Array(n){0};val S=Array(1 shl n){0}    data class Edge(val v:Int,val w:Int)    val G=Array(n){ArrayList<Edge>()}    for(i in 0 until m){        val(u,v,w)=ris()        E[u-1]=E[u-1] or (1 shl (v-1))        G[v-1].add(Edge(u-1,w))    }    for(i in 0 until n)S[1 shl i]=E[i]    for(i in 1 until (1 shl n)){        val bit=i and (-i)        S[i]=S[i-bit] or S[bit]    }    val a=Array(n){0}    val dp=Array(1 shl n){-1}    val best=Array(1 shl n){-1}    val inf=1e9.toInt()    for(mask in 1 until (1 shl n)){        var sub=mask;var ans=inf;var sum=0        for(i in 0 until n)if((mask shr i) and 1 == 1)for(e in G[i])if((mask shr e.v) and 1 == 0)sum+=e.w        while(sub!=0){            val out=S[sub]            val other=mask xor sub            if(out and (other xor ((1 shl n)-1)) == 0){                val now=dp[other]                if(ans>now){ans=now;best[mask]=other}            }            sub=(sub-1) and mask        }        dp[mask]=ans+sum    }    var mask=(1 shl n)-1    var dep=n    while(mask!=0){        val sub=mask xor best[mask]        for(i in 0 until n)if((sub shr i) and 1 == 1)a[i]=dep        mask=best[mask];dep--    }    pln(a)    output()}","bitmasks,dfs and similar,dp,flows,graphs,math"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport kotlin.math.maximport kotlin.math.min const val IMPOSSIBLE = -100000000000000000L fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val k = jin.readLine().toInt()    val fs = jin.readLine().split("" "").map { it.toLong() }    val m = jin.readLine().toInt()    var dpPrev = LongArray(2) { IMPOSSIBLE }    dpPrev[0] = 0L    val segTrees = Array(3) { SegmentTree(0, 100000) }    for (e in 5 downTo 0) {        val n = (""1"" + ""0"".repeat(6 - e)).toInt()        for (t in 0..2) {            segTrees[t].value.fill(IMPOSSIBLE)        }        for (j in 0..n / 10) {            segTrees[j % 3][j] = dpPrev[j] - (((10 * j) / 3).toLong() * fs[e])        }        val dp = LongArray(n + 1) { IMPOSSIBLE }        for (j in 0..n) {            for (t in 0..2) {                val correction = if ((j % 3) >= t) 0L else -1L                dp[j] = max(dp[j], segTrees[t][(j - (9 * (k - 1)) + 9) / 10, j / 10] + (fs[e] * ((j / 3).toLong() + correction)))                for (j2 in j - (9 * k) until j - (9 * (k - 1))) {                    if (j2 >= 0 && j2 % 10 == 0) {                        if ((j - j2) % 3 == 0) {                            dp[j] = max(dp[j], segTrees[t][j2 / 10] + (fs[e] * ((j / 3).toLong() + correction)))                        } else {                            val cancel = ((j - (9 * (k - 1)) - j2) / 3).toLong()                            dp[j] = max(dp[j], segTrees[t][j2 / 10] + (fs[e] * ((j / 3).toLong() + correction - cancel)))                        }                    }                }            }            if (dp[j] < 0L) {                dp[j] = IMPOSSIBLE            }        }        dpPrev = dp    }    val out = StringBuilder()    for (j in 1..m) {        out.appendln(dpPrev[jin.readLine().toInt()])    }    println(out)} class SegmentTree(val treeFrom: Int, val treeTo: Int) {    val value: LongArray    val length: Int     init {        var e = 0        while (1 shl e < treeTo - treeFrom + 1) {            e++        }        value = LongArray(1 shl (e + 1))        length = 1 shl e    }     operator fun set(index: Int, delta: Long) {        var node = index - treeFrom + length        value[node] = delta        node = node shr 1        while (node > 0) {            value[node] = max(value[node shl 1], value[(node shl 1) + 1])            node = node shr 1        }    }     operator fun get(index: Int) = value[index - treeFrom + length]     operator fun get(fromIndex: Int, toIndex: Int): Long {        if (toIndex < fromIndex) {            return IMPOSSIBLE        }         var from = max(treeFrom, fromIndex) + length - treeFrom        var to = min(treeTo, toIndex) + length - treeFrom + 1        var res = IMPOSSIBLE        while (from + (from and -from) <= to) {            res = max(res, value[from / (from and -from)])            from += from and -from        }        while (to - (to and -to) >= from) {            res = max(res, value[(to - (to and -to)) / (to and -to)])            to -= to and -to        }        return res    }}","dp,greedy"
"fun main() {    data class D(val j: Int, var m: Int) {        fun right() = j + m    }    val n = readLine()!!.toInt()    val s = readLine()!!    var sum = 0L    var ss = 0L    val b = ArrayList<D>()    for (i in 0 until n) {        if (s[i] == '1') {            if (b.isEmpty() || b.last().right() < i) {                val p = b.lastOrNull()?.right() ?: 0                ss += i - p + 1                if (b.lastOrNull()?.m == 1) b.removeLast()                b += D(i, 1)            } else {                val last = b.removeLast()                val p = b.lastOrNull()?.right()?.minus(last.m) ?: 0                ss += i - p + 1                last.m++                if (b.lastOrNull()?.m == last.m) b.removeLast()                b += last            }        }        sum += ss    }    println(sum)}","binary search,data structures,divide and conquer,dp,two pointers"
"import kotlin.math.max fun main() {    val n = readLine()!!.toInt()    val s = readLine()!!    var answer = 0L    val longest = LongArray(n)    fun recur(from: Int, to: Int) {        if (from > to) {            return        }        var mid = (from + to) / 2        while (mid > from && s[mid] == '1') {            mid--        }        if (s[mid] == '1') {            mid = (from + to) / 2            while (mid < to && s[mid] == '1') {                mid++            }        }        if (s[mid] == '1') {            val lambda = (to - from + 1).toLong()            answer += (lambda * (lambda + 1L) * (lambda + 2L)) / 6L        } else {            var curr = 0L            longest[mid] = 0L            for (j in mid - 1 downTo from) {                if (s[j] == '1') {                    curr++                } else {                    curr = 0L                }                longest[j] = max(curr, longest[j + 1])            }            curr = 0L            longest[mid] = 0L            for (j in mid + 1..to) {                if (s[j] == '1') {                    curr++                } else {                    curr = 0L                }                longest[j] = max(curr, longest[j - 1])            }            var k = mid            for (j in mid downTo from) {                while (k <= to && longest[k] <= longest[j]) {                    k++                }                answer += longest[j] * (k - mid).toLong()            }            k = mid            for (j in mid..to) {                while (k >= from && longest[k] < longest[j]) {                    k--                }                answer += longest[j] * (mid - k).toLong()            }            recur(from, mid - 1)            recur(mid + 1, to)        }    }    recur(0, n - 1)    println(answer)}","binary search,data structures,divide and conquer,dp,two pointers"
"import java.io.BufferedOutputStreamimport java.io.BufferedReaderimport java.io.InputStreamReaderimport java.io.PrintStreamimport java.util.*import kotlin.random.Random.Default.nextIntimport kotlin.time.ExperimentalTime @ExperimentalStdlibApi@ExperimentalTime@ExperimentalUnsignedTypesclass Task {     @Suppress(""unused"", ""MemberVisibilityCanBePrivate"")    private class FastReader {        private val br = BufferedReader(InputStreamReader(System.`in`))        private var st = StringTokenizer("""")         fun readString(): String {            while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())            return st.nextToken()        }         fun readInt() = readString().toInt()        fun readLong() = readString().toLong()        fun readDouble() = readString().toDouble()         fun readStringArray(n: Int) = Array(n) { readString() }        fun readIntArray(n: Int) = IntArray(n) { readInt() }        fun readLongArray(n: Int) = LongArray(n) { readLong() }        fun readDoubleArray(n: Int) = DoubleArray(n) { readDouble() }    }     private val fin: FastReader = FastReader()     companion object {        fun <T> Array<T>.swap(i: Int, j: Int) {            val x = this[i]            this[i] = this[j]            this[j] = x        }         fun <T> MutableList<T>.swap(i: Int, j: Int) {            val x = this[i]            this[i] = this[j]            this[j] = x        }         fun IntArray.swap(i: Int, j: Int) {            val x = this[i]            this[i] = this[j]            this[j] = x        }         fun LongArray.swap(i: Int, j: Int) {            val x = this[i]            this[i] = this[j]            this[j] = x        }         fun DoubleArray.swap(i: Int, j: Int) {            val x = this[i]            this[i] = this[j]            this[j] = x            sort()        }         fun IntArray.shuffleSort() {            for (i in 1 until size) swap(i, nextInt(i + 1))            sort()        }         fun LongArray.shuffleSort() {            for (i in 1 until size) swap(i, nextInt(i + 1))            sort()        }         fun DoubleArray.shuffleSort() {            for (i in 1 until size) swap(i, nextInt(i + 1))            sort()        }         fun println(a: IntArray) {            if (a.isNotEmpty()) {                print(a[0])                for (i in 1 until a.size) {                    print(' ')                    print(a[i])                }            }            println()        }         fun println(a: LongArray) {            if (a.isNotEmpty()) {                print(a[0])                for (i in 1 until a.size) {                    print(' ')                    print(a[i])                }            }            println()        }         fun println(a: Array<*>) {            if (a.isNotEmpty()) {                print(a[0])                for (i in 1 until a.size) {                    print(' ')                    print(a[i])                }            }            println()        }         fun println(a: List<*>) {            if (a.isNotEmpty()) {                print(a[0])                for (i in 1 until a.size) {                    print(' ')                    print(a[i])                }            }            println()        }         fun println(a: Iterable<*>) {            val it = a.iterator()            if (it.hasNext()) {                print(it.next())                while (it.hasNext()) {                    print(' ')                    print(it.next())                }            }            println()        }         inline fun binarySearch(from: Int, to: Int, f: (Int) -> Boolean): Int {            var l = from            var r = to + 1            while (r - l > 1) {                val m = (l + r) / 2                if (f(m)) l = m                else r = m            }            return l        }         inline fun binarySearch(f: (Int) -> Boolean): Int {            var r = 1            while (f(r)) r *= 2            return binarySearch(r / 2, r, f)        }         fun <T : Comparable<T>> MutableList<T>.makeDistinct() {            if (size <= 1) return            sort()            var sz = 1            for (i in 1 until size) {                if (this[i] != this[i - 1]) {                    this[sz++] = this[i]                }            }            while (size > sz) removeAt(size - 1)        }         inline fun ternary(from: Int, to: Int, lim: Int, f: (Int) -> Long): Long {            var l = from            var r = to            while (r - l > lim) {                val m1 = l + (r - l) / 3                val m2 = r - (r - l) / 3                if (f(m1) < f(m2)) r = m2                else l = m1            }            return minOf(                (from..minOf(to, from + lim)).minOf(f),                (maxOf(from, to - lim)..to).minOf(f),                (l..r).minOf(f)            )        }    }     fun sum(n: Int) = n * (n + 1L) / 2     fun f(a: Int, b: Int, k: Int): Long {        return a * (b + k).toLong() + (b + k).toLong() * k - sum(k)    }     fun solve() {        val n = fin.readInt()        val s = fin.readString()        val a = mutableListOf<Pair<Int, Int>>()        var i = 0        while (i < n) {            if (s[i] == '0') {                i++                continue            }            var j = i            while (j + 1 < n && s[j + 1] == '1') j++            a += Pair(i, j)            i = j + 1        }        var size = a.size        fun fix(minLen: Int) {            var sz = 0            for (i in 0 until size) {                if (a[i].second - a[i].first + 1 >= minLen) {                    a[sz++] = a[i]                }            }            size = sz        }        val counts = LongArray(n + 1)        counts[0] = sum(n)        for (len in 1..n) {            fix(len)            var start = 0            for (j in 0 until size) {                counts[len] += f(a[j].first - start + 1, n - a[j].second, a[j].second - a[j].first + 1 - len)                start = a[j].second + 1 - len + 1            }        }        val ans = (1..n).sumOf { (counts[it - 1] - counts[it]) * (it - 1L) } + if (s.all { it == '1' }) n else 0        println(ans)    }} @ExperimentalStdlibApi@ExperimentalTime@ExperimentalUnsignedTypesfun main() {    if (System.getProperty(""ONLINE_JUDGE"") != null)        System.setOut(PrintStream(BufferedOutputStream(System.out)))    Task().solve()    System.out.flush()}","binary search,data structures,divide and conquer,dp,two pointers"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"")@file:OptIn(ExperimentalStdlibApi::class) import java.io.PrintWriterimport java.lang.StringBuilderimport java.util.PriorityQueueimport kotlin.math.*import kotlin.random.Randomimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {//    val startTime = System.nanoTime()     val numCases = 1//readInt()    case@ for(case in 1..numCases) {//        print(""Case #$case: "")         object {            val n = readInt()            val s = readCharArray(n)             val st = mutableListOf<Block>()            var sum = 0L             fun stAdd(b: Block) {                st.add(b)                sum += b.w            }            fun stPop(): Block {                val b = st.removeLast()                sum -= b.w                return b            }             var last = ' '            var run = 0            var ans = 0L             init {                for(i in 0 until n) {                    if(s[i] == last) run++ else {                        if(last == '0') {                            stAdd(Rect(run, 1))                        }                        run = 1                    }                     if(s[i] == '1') {                        if(st.isNotEmpty() && st.last() is Wedge) stPop()                        var repl = 0                        while(st.isNotEmpty()) {                            val top = st.last()                            when(top) {                                is Rect -> {                                    if(top.h >= run) break                                    repl += top.l                                    stPop()                                }                                is Wedge -> {                                    if(top.h1 >= run) break                                    stPop()                                    if(top.h0 <= run) repl += top.h0 - top.h1                                    else {                                        repl += run - top.h1                                        stAdd(Wedge(top.h0, run))                                        break                                    }                                }                            }                        }                        if(repl > 0) stAdd(Rect(repl, run))                        stAdd(Wedge(run, 0))                    }                     ans += sum                    last = s[i]                }                println(ans)            }        }    } //    iprintln(""Time: ${(System.nanoTime() - startTime) / 1000000} ms"")} sealed class Block {    abstract val w: Long} data class Rect(val l: Int, val h: Int): Block() {    override val w: Long        get() = l.toLong() * h} data class Wedge(val h0: Int, val h1: Int): Block() {    override val w: Long        get() = h0.tr - h1.tr} val Int.tr get() = this * plus(1L) / 2 infix fun Int.divCeil(other: Int) =    (this / other).let { if(xor(other) >= 0 && it * other != this) it+1 else it } inline infix fun Int.divFloor(other: Int) = Math.floorDiv(this, other) infix fun Long.divCeil(other: Long) =    (this / other).let { if(xor(other) >= 0 && it * other != this) it+1 else it }inline infix fun Long.divCeil(other: Int) = divCeil(other.toLong()) inline infix fun Long.divFloor(other: Long) = Math.floorDiv(this, other) /** IO *///const val PATH = ""src/main/resources/""//@JvmField val INPUT = File(PATH + ""input.txt"").inputStream()//@JvmField val OUTPUT = File(PATH + ""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar()        else c    }} /** @param skipNext Whether to skip the next character (usually whitespace), defaults to true */fun readCharArray(n: Int, skipNext: Boolean = true): CharArray {    val res = CharArray(n) { readChar() }    if(skipNext) readChar()    return res} fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(c != '\n' && c != Char.MIN_VALUE) {            append(c)            c = readChar()        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /**  sort overrides to avoid quicksort attacks */ @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } fun IntArray.sort() { shuffle(random); _sort() }fun IntArray.sortDescending() { shuffle(random); _sortDescending() } fun LongArray.sort() { shuffle(random); _sort() }fun LongArray.sortDescending() { shuffle(random); _sortDescending() } fun DoubleArray.sort() { shuffle(random); _sort() }fun DoubleArray.sortDescending() { shuffle(random); _sortDescending() } inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T : Comparable<T>> Array<out T>.sort() = _sort()inline fun <T : Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T : Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T : Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() // import preserving junk function@Suppress(""NonAsciiCharacters"") fun 雪花飄飄北風嘯嘯天地一片蒼茫() { iprintln(max(1, 2)) } fun IntArray.sumLong() = sumOf { it.toLong() } // max/min Kotlin 1.6 -> 1.4 shimfun IntArray.max() = maxOf { it }fun IntArray.min() = minOf { it }fun LongArray.max() = maxOf { it }fun LongArray.min() = minOf { it }fun CharArray.max() = maxOf { it }fun CharArray.min() = minOf { it }fun <T : Comparable<T>> Iterable<T>.max() = maxOf { it }fun <T : Comparable<T>> Iterable<T>.min() = minOf { it }fun <T : Comparable<T>> Sequence<T>.max() = maxOf { it }fun <T : Comparable<T>> Sequence<T>.min() = minOf { it }","binary search,data structures,divide and conquer,dp,two pointers"
"fun main() {	val M = 998244353	val (n, m) = readInts()	val d = readInts().sorted()	val sum = d.sumOf { it.toLong() }	val ab = List(m) { readInts() }.withIndex().sortedBy { -it.value[1] }	var i = n - 1	var large = 0	var sumLarge = 0L	val ans = IntArray(m)	for (p in ab) {		val (a, b) = p.value		while (i >= 0 && d[i] >= b) {			large++			sumLarge += d[i]			i--		}//		val large = d.count { it >= b }//		val sumLarge = d.filter { it >= b }.sumOf { it.toLong() }		val sumSmall = sum - sumLarge		val pLarge = if (large == 0) 0 else (1 - minOf(a, large).toLong() * modInverse(large, M)) % M		val pSmall = (1 - minOf(a, large + 1).toLong() * modInverse(large + 1, M)) % M		ans[p.index] = (((sumLarge % M * pLarge + sumSmall % M * pSmall) % M + M) % M).toInt()	}	println(ans.joinToString(""\n""))} fun gcdExtended(a: Int, b: Int, xy: IntArray): Int {	if (a == 0) {		xy[0] = 0		xy[1] = 1		return b	}	val d = gcdExtended(b % a, a, xy)	val t = xy[0]	xy[0] = xy[1] - b / a * xy[0]	xy[1] = t	return d} fun modInverse(x: Int, p: Int): Int {	val xy = IntArray(2)	val gcd = gcdExtended(x, p, xy)	require(gcd == 1) { ""$x, $p"" }	var result = xy[0] % p	if (result < 0) {		result += p	}	return result} private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","binary search,combinatorics,probabilities"
"import java.util.* val MOD = 998244353L val cache = LongArray(2e5.toInt() + 5)fun main() {    val scanner = Scanner(System.`in`)//    val scanner = Scanner(File(""input.txt""))     val n = scanner.nextInt()    val m = scanner.nextInt()     val power = IntArray(n)    for (i in 0 until n) power[i] = scanner.nextInt()    power.sort()     val totalPower = LongArray(n + 1)    for (i in 0 until n) totalPower[i + 1] = totalPower[i] + power[i]     val results = LongArray(m);    repeat(m) {        val a = scanner.nextInt()        val b = scanner.nextInt()         val index = power.lowerBoundIndex(b)        val k = n - index         var result: Long = 0        if (k > a) {            result += ((((k - a).toLong() * inv(k)) % MOD) * ((totalPower[n] - totalPower[index]) % MOD))        }         if (k + 1 > a) {            result += ((((k + 1 - a).toLong() * inv((k + 1))) % MOD) * ((totalPower[index]) % MOD))        }         result %= MOD        results[it] = result    }     System.out.print(results.joinToString(""\n""))} fun IntArray.lowerBoundIndex(x: Int): Int {    var start = 0    var finish = size - 1     while (start != finish) {        val mid = (start + finish) / 2        if (this[mid] < x) start = mid + 1        else finish = mid    }     return start} fun pow2(x: Long, p: Long): Long {    var power = p    var a = x    var res = 1L    while (power > 0)        if (power % 2 == 0L) {            a = (a * a) % MOD            power /= 2        } else {            res = (res * a) % MOD            power--        }     return res} fun inv(x: Int): Long {    if (cache[x] != 0L) return cache[x]    cache[x] = pow2(x.toLong(), MOD - 2L)    return cache[x]} ","binary search,combinatorics,probabilities"
"/** * Accomplished using the EduTools plugin by JetBrains https://plugins.jetbrains.com/plugin/10081-edutools */const val M = 998244353 fun main() {	val (_, m) = readInts()	val monsters = readInts().sorted().toMutableList()	val sum = monsters.sumOf { it.toLong() }	data class Shield(val durability: Int, val defense: Int, val id: Int)	val shields = List(m) { id -> readInts().let { Shield(it[0], it[1], id) } }	var strong = 0	var sumStrong = 0L	val answers = IntArray(m)	for (shield in shields.sortedByDescending { it.defense }) {		while (monsters.isNotEmpty() && monsters.last() >= shield.defense) {			strong++			sumStrong += monsters.removeLast()		}		if (strong == 0) continue		val pStrong = Modular(maxOf(strong - shield.durability, 0)) / strong		val pWeak = Modular(maxOf(strong + 1 - shield.durability, 0)) / (strong + 1)		val sumWeak = sum - sumStrong		answers[shield.id] = (pStrong * (sumStrong % M) + pWeak * (sumWeak % M)).toInt()	}	println(answers.joinToString(""\n""))} class Modular(private val value: Int) : Number() {	operator fun plus(that: Number) = Modular((value + that.toInt()) % M)	operator fun times(that: Number) = Modular(((value.toLong() * that.toInt()) % M).toInt())	operator fun div(that: Number) = this * that.toInt().toBigInteger().modInverse(M.toBigInteger())	override fun toInt() = value 	override fun toByte(): Byte {		TODO(""Not yet implemented"")	} 	override fun toChar(): Char {		TODO(""Not yet implemented"")	} 	override fun toDouble(): Double {		TODO(""Not yet implemented"")	} 	override fun toFloat(): Float {		TODO(""Not yet implemented"")	} 	override fun toLong(): Long {		TODO(""Not yet implemented"")	} 	override fun toShort(): Short {		TODO(""Not yet implemented"")	}} private fun readInts() = readLine()!!.split("" "").map { it.toInt() }","binary search,combinatorics,probabilities"
"import java.util.* val MOD = 998244353L val cache = LongArray(2e5.toInt() + 5)fun main() {    val scanner = Scanner(System.`in`)//    val scanner = Scanner(File(""input.txt""))     val n = scanner.nextInt()    val m = scanner.nextInt()     val power = IntArray(n)    for (i in 0 until n) power[i] = scanner.nextInt()    power.sort()     val totalPower = LongArray(n + 1)    for (i in 0 until n) {        totalPower[i + 1] = totalPower[i] + power[i]        while (totalPower[i + 1] >= MOD) {            totalPower[i + 1] -= MOD        }    }     val results = LongArray(m);     val a = IntArray(m);    val b = IntArray(m);     for (i in 0 until m) {        a[i] = scanner.nextInt()        b[i] = scanner.nextInt()    }     repeat(m) {        val a = a[it]        val b = b[it]         val index = power.lowerBoundIndex(b)        val k = n - index         var result: Long = 0        if (k > a) {            result += ((((k - a).toLong() * inv(k)) % MOD) * ((totalPower[n] - totalPower[index]) + MOD))        }         if (k + 1 > a) {            result += ((((k + 1 - a).toLong() * inv((k + 1))) % MOD) * ((totalPower[index])))        }         result %= MOD        results[it] = result    }     System.out.print(results.joinToString(""\n""))} fun IntArray.lowerBoundIndex(x: Int): Int {    var start = 0    var finish = size - 1     while (start != finish) {        val mid = (start + finish) / 2        if (this[mid] < x) start = mid + 1        else finish = mid    }     return start} fun pow2(x: Long, p: Long): Long {    var power = p    var a = x    var res = 1L    while (power > 0)        if (power % 2 == 0L) {            a = (a * a) % MOD            power /= 2        } else {            res = (res * a) % MOD            power--        }     return res} fun inv(x: Int): Long {    if (cache[x] != 0L) return cache[x]    cache[x] = pow2(x.toLong(), MOD - 2L)    return cache[x]} ","binary search,combinatorics,probabilities"
"import java.io.BufferedReaderimport java.io.InputStreamReader fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val out = StringBuilder()    for (c in 1..jin.readLine().toInt()) {        val (n, m) = jin.readLine().split("" "").map { it.toInt() }        val rooks = IntArray(n + 1)        for (j in 1..m) {            val (x, y) = jin.readLine().split("" "").map { it.toInt() }            rooks[x] = y        }        var answer = rooks.withIndex().count { (x, y) -> y != 0 && y != x }        for (x in 1..n) {            if (rooks[x] != 0 && rooks[x] != x) {                var y = rooks[x]                rooks[x] = 0                while (y != x && y != 0) {                    val prev = y                    y = rooks[y]                    rooks[prev] = 0                }                if (y == x) {                    answer++                }            }        }        out.appendln(answer)    }    print(out)}","dfs and similar,dsu,graphs"
"import java.util.Scanner; class DSU(n: Int) {    var parent = Array(n) { it }    var size = Array(n) { 1 }    fun find(x: Int): Int {        if (parent[x] != x) {            parent[x] = find(parent[x])        }        return parent[x];    }     fun union(X: Int, Y: Int) {        var x = find(X); var y = find(Y);        if (x == y) {            return;        }        if (size[x] > size[y]) {            size[x] += size[y];            parent[y] = x;        } else {            size[y] += size[x];            parent[x] = y;        }    }} fun main() {    val scan = Scanner(System.`in`);    var t = scan.nextInt();    for (tt in 0 until t) {        var n = scan.nextInt();        var m = scan.nextInt();        var dsu = DSU(n);        var ans = m;        for (i in 0 until m) {            var x = scan.nextInt();            var y = scan.nextInt();            x--;            y--;            if (x == y) {                ans--;            } else {                if (dsu.find(x) == dsu.find(y)){                    ans++;                }                dsu.union(x, y);            }        }        println(ans);    }}","dfs and similar,dsu,graphs"
"import java.util.*import kotlin.collections.HashMap fun main() {    val get = Scanner(System.`in`)    var t = get.nextInt()    while(--t >= 0) {        val n = get.nextInt()        val m = get.nextInt()        val map = HashMap<Int,Int>(m)        var p = 0        var c = 0         for(i in 1..m) {            val x = get.nextInt()            val y = get.nextInt()             if(x==y)                ++p            else                map[x] = y        }         val data = map.keys.toIntArray()         for(k in data.indices) {             var tempKey = data[k]             if(map[data[k]] == null)                continue             var tempValue = map[data[k]]             while(data[k] != tempValue) {                map.remove(tempKey)                 if (tempValue != null) {                    tempKey = tempValue                }                 if(map[tempValue] != null)                    tempValue = map[tempValue]!!                else {                    map.remove(tempValue)                    break                }            }             if (tempValue == data[k]) {                map.remove(tempKey)                ++c            }        }         println(m-p+c)    }}","dfs and similar,dsu,graphs"
"import java.util.* fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() } data class Rook(val idx: Int, val deps: Int) fun main() {    repeat(readInt()) {        val (_, m) = readInts()        val xs = mutableMapOf<Int, Int>()        val ys = mutableMapOf<Int, Int>()        val ps = (0 until m).map { idx ->            val (x, y) = readInts()            xs[x] = idx            ys[y] = idx            Pair(x, y)        }         val alive = (0 until m).filter {            val (x, y) = ps[it]            x != y        }.toMutableSet()         fun createRook(idx: Int): Rook {            val (x, y) = ps[idx]            return Rook(idx, (if (ys[x] != null) 1 else 0) + (if (xs[y] != null) 1 else 0))        }         val rooks = PriorityQueue<Rook>(compareBy { it.deps })        rooks.addAll(alive.map { createRook(it) })         var res = 0        while (rooks.isNotEmpty()) {            val r = rooks.poll()            if (!alive.contains(r.idx)) continue             if (r.deps == 2) {                res += 2            } else {                res++            }             val (x, y) = ps[r.idx]            alive.remove(r.idx)            val idx1 = ys[x]            val idx2 = xs[y]            xs.remove(x)            ys.remove(y)             val regen = mutableSetOf<Int>()            if (idx1 != null) regen.add(idx1)            if (idx2 != null) regen.add(idx2)            rooks.addAll(regen.map { createRook(it) })        }         println(res)    }}","dfs and similar,dsu,graphs"
"fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()        val a = readLine()!!.split("" "").map { it.toInt() }        val b = readLine()!!.split("" "").map { it.toInt() }        val c = readLine()!!.split("" "").map { it.toInt() }        val d = IntArray(n)        d[0] = a[0]        for (i in 1 until n - 1) {            d[i] = listOf(a[i], b[i], c[i]).minus(d[i - 1]).first()        }        d[n - 1] = listOf(a[n - 1], b[n - 1], c[n - 1]).minus(d[n - 2]).minus(d[0]).first()        println(d.joinToString("" ""))    }}",constructive algorithms
"fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main() {    repeat(readInt()) {        val n = readInt()        val v1 = readInts()        val v2 = readInts()        val v3 = readInts()        val ps = IntArray(n)         ps[0] = v1[0]        for (i in 1 until n) {            val a = v1[i]            val b = v2[i]            val c = v3[i]            val p = ps[i-1]            ps[i] = when {                i == n-1 && a != p && a != ps[0] -> a                i == n-1 && b != p && b != ps[0] -> b                i == n-1 -> c                a != p -> a                b != p -> b                else -> c            }        }        println(ps.joinToString(separator = "" ""))    }}",constructive algorithms
"fun main() {    val t = readInt()     repeat(t) {        val n = readInt()        val arrays = mapOf(""a"" to readInts(), ""b"" to readInts(), ""c"" to readInts())         val p = IntArray(n) { 200 }        p[0] = (arrays[""a""] ?: error(""""))[0]        for (i in 1 until n) {            val j = (n + i - 1) % n            val k = (i + 1) % n            for (arr in listOf(""a"", ""b"", ""c"")) {                val value = (arrays[arr] ?: error(""""))[i]                if (p[j] != value && p[k] != value) {                    p[i] = value                    break                }            }        }         println(p.joinToString("" ""))    }} // Input Readerprivate fun readLn() = readLine()!! private fun readStrings() = readLn().trim().split("" "")private fun readInt() = readLn().toInt()private fun readInts() = readStrings().map { it.toInt() }",constructive algorithms
"fun main() {    fun readInt() = readLine()!!.toInt()    fun readInts() = readLine()!!.split("" "").map(String::toInt)     repeat(readInt()) {        val sb = StringBuilder()        val length = readInt()        val matrix = mutableListOf<List<Int>>()        matrix.add(readInts())        matrix.add(readInts())        matrix.add(readInts())        sb.append(""${matrix[0][0]} "")        var last = matrix[0][0]        nextColumn@ for (pos in 1 until length - 1)            for (row in 0..2)                if (matrix[row][pos] != last) {                    last = matrix[row][pos]                    sb.append(""${matrix[row][pos]} "")                    continue@nextColumn                }        for (row in 0..2)            if (matrix[row][length - 1] != last && matrix[row][length - 1] != matrix[0][0]) {                sb.append(""${matrix[row][length - 1]} "")                break            }        println(sb)    }}",constructive algorithms
"fun main() {    fun readInt() = readLine()!!.toInt()    fun readInts() = readLine()!!.split("" "").map(String::toInt)     nextCase@ for (testCase in 1..readInt()) {        val length = readInt()        val arr = readInts()        val min = arr.minOrNull()!!        val sorted = arr.sorted()        for (pos in 0 until length) if(arr[pos] != sorted[pos]) if (arr[pos] % min != 0 || sorted[pos] % min != 0) {            println(""NO"")            continue@nextCase        }        println(""YES"")    }}","constructive algorithms,math,number theory,sortings"
"fun main(args: Array<String>) {    var t = readInt()    nextCase@  while (t-- > 0){        val n = readInt()        val a = readInts()        val sorted = a.toMutableList().sorted()        val min = a.minOrNull()        for (i in 0 until n){            if (a[i] != sorted[i] && a[i] % min!! != 0 ){                println(""NO"")                continue@nextCase            }        }        println(""YES"")     }   }     fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split("" "").map(String::toInt)","constructive algorithms,math,number theory,sortings"
"fun gcd(a: Int, b: Int): Int = when {    a < b -> gcd(b, a)    b == 0 -> a    else -> gcd(b, a % b)} fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main() {    val t = readInt()    for (i in 1..t) {        readInt()        val vs = readInts()        println(if (solve(vs)) ""YES"" else ""NO"")    }} fun solve(vs: List<Int>): Boolean {    val min = vs.min()!!    val t = vs.sorted()     for (i in vs.indices) {        if (vs[i] != t[i] && gcd(vs[i], min) != min) return false    }     return true}","constructive algorithms,math,number theory,sortings"
"fun main(args : Array<String>){    val t = readLine()!!.toInt()    repeat(t){        val n = readLine()!!.toInt()        val input = readLine()!!.split(' ').map { it.toInt() }        val sorted = input.sorted()        val min = input.min()!!        var possible  = true        for(i in 0 until n){            if(input[i] != sorted[i]){                if(input[i]%min != 0){                    possible = false                    break                }            }        }        if(possible){            println(""YES"")        }else{            println(""NO"")        }     }}","constructive algorithms,math,number theory,sortings"
"import java.io.BufferedReaderimport java.io.InputStreamReader const val MOD = 998244353L fun main() {    val factorial = LongArray(300001)    factorial[0] = 1L    for (j in 1..300000) {        factorial[j] = (j.toLong() * factorial[j - 1]) % MOD    }    val factInv = LongArray(300001)    factInv[300000] = factorial[300000] pow -1    for (j in 299999 downTo 0) {        factInv[j] = ((j + 1).toLong() * factInv[j + 1]) % MOD    }    fun choose(a: Int, b: Int) = if (a < 0 || b < 0 || b > a) 0L else (factorial[a] * ((factInv[b] * factInv[a - b]) % MOD)) % MOD    val jin = BufferedReader(InputStreamReader(System.`in`))    val (n, m) = jin.readLine().split("" "").map { it.toInt() }    val mercsAdd = Array(n) {        val (l, r) = jin.readLine().split("" "").map { it.toInt() }        Mercenary(it + 1, l, r)    }    val important = mutableSetOf<Int>()    val prohibido = Array(m) {        val (a, b) = jin.readLine().split("" "").map { it.toInt() }        important.add(a)        important.add(b)        Pair(a, b)    }    val importantPlace = mutableMapOf<Int, Int>()    for ((ix, j) in important.toList().withIndex()) {        importantPlace[j] = ix    }    val covered = LongArray(1 shl m)    for (e in prohibido.indices) {        val (a, b) = prohibido[e]        covered[1 shl e] = (1L shl importantPlace[a]!!) + (1L shl importantPlace[b]!!)    }    for (mask in covered.indices) {        for (e in 0 until m) {            covered[mask or (1 shl e)] = covered[mask or (1 shl e)] or covered[mask]        }    }    val corrections = Array(41) { IntArray(1 shl m) }    for (mask in covered.indices) {        var coveredAMT = 0        for (e in 0..39) {            if (covered[mask] and (1L shl e) != 0L) {                coveredAMT++            }        }        corrections[coveredAMT][mask] += 1 - (2 * (Integer.bitCount(mask) % 2))    }    for (e in 0 until m) {        for (mask in covered.indices) {            val next = mask or (1 shl e)            if (next != mask) {                for (j in corrections.indices) {                    corrections[j][next] += corrections[j][mask]                }            }        }    }    val inside = BooleanArray(n + 1)    val mercsRemove = Array(n) { mercsAdd[it] }    mercsAdd.sortBy { it.from }    mercsRemove.sortBy { it.to }    var currMask = 0    var currAMT = 0    var answer = 0L    var j1 = 0    var j2 = 0    for (k in 1..n) {        while (j1 < n && mercsAdd[j1].from == k) {            currAMT++            inside[mercsAdd[j1].ix] = true            for (e in 0 until m) {                if (mercsAdd[j1].ix in prohibido[e] && inside[prohibido[e].first] && inside[prohibido[e].second]) {                    currMask += 1 shl e                }            }            j1++        }        while (j2 < n && mercsRemove[j2].to == k - 1) {            for (e in 0 until m) {                if (mercsRemove[j2].ix in prohibido[e] && inside[prohibido[e].first] && inside[prohibido[e].second]) {                    currMask -= 1 shl e                }            }            inside[mercsRemove[j2].ix] = false            currAMT--            j2++        }        for (d in corrections.indices) {            answer += corrections[d][currMask].toLong() * choose(currAMT - d, k - d)            answer %= MOD        }    }    answer += MOD    answer %= MOD    println(answer)} data class Mercenary(val ix: Int, val from: Int, val to: Int) operator fun <A> Pair<A, A>.contains(elem: A) = elem == this.first || elem == this.second const val MOD_TOTIENT = MOD.toInt() - 1 infix fun Long.pow(power: Int): Long {    var e = power    e %= MOD_TOTIENT    if (e < 0) {        e += MOD_TOTIENT    }    if (e == 0 && this == 0L) {        return this    }    var b = this % MOD    var res = 1L    while (e > 0) {        if (e and 1 != 0) {            res *= b            res %= MOD        }        b *= b        b %= MOD        e = e shr 1    }    return res}","bitmasks,brute force,combinatorics,dp,dsu,math,two pointers"
"import NativeModInt.Companion.addimport NativeModInt.Companion.invimport NativeModInt.Companion.mulimport Utils.ArrayUtils.Companion.makeDistinctimport Utils.ArrayUtils.Prints.Companion.printlnimport Utils.ArrayUtils.Sorts.Companion.shuffleSortimport Utils.ArrayUtils.Swaps.Companion.swapimport Utils.BinarySearchUtils.Companion.binarySearchimport Utils.BinarySearchUtils.Companion.binarySearchDoubleimport Utils.BinarySearchUtils.Companion.binarySearchLongimport Utils.FastReaderimport Utils.GeneralUtils.Companion.gcdimport Utils.GeneralUtils.Companion.lengthimport Utils.GeneralUtils.Companion.rndimport java.io.*import java.util.*import kotlin.collections.ArrayDequeimport kotlin.random.Randomimport kotlin.random.Random.Default.nextIntimport kotlin.time.ExperimentalTime @ExperimentalStdlibApi@ExperimentalTime@ExperimentalUnsignedTypesfun main() {    Locale.setDefault(Locale.US)    if (System.getProperty(""ONLINE_JUDGE"") != null) {        System.setOut(PrintStream(BufferedOutputStream(System.out)))    }    Task().solve()    System.out.flush()} operator fun Pair<Int, Int>.contains(x: Int) = x in first..second @ExperimentalStdlibApi@ExperimentalTime@ExperimentalUnsignedTypesclass Task(private val fin: FastReader = FastReader()) {    fun solve() {        val n = fin.readInt()        val m = fin.readInt()        val lr = Array(n) { Pair(fin.readInt(), fin.readInt()) }        val restrictedPairs = Array(m) { Pair(fin.readInt() - 1, fin.readInt() - 1) }         val bad = restrictedPairs.flatMap { listOf(it.first, it.second) }.toSortedSet().toIntArray()        fun getDPS(sz: Int): IntArray {            val allBad = bad.filter { sz in lr[it] }.toIntArray()             val g = Array(allBad.size) { mutableListOf<Int>() }            for (i in allBad.indices) {                val cur = allBad[i]                for ((a, b) in restrictedPairs) {                    if (a == cur && b in allBad) g[i].add(allBad.binarySearch(b))                    if (b == cur && a in allBad) g[i].add(allBad.binarySearch(a))                }            }             val used = BooleanArray(allBad.size)            val groups = mutableListOf<MutableList<Int>>()            fun dfs(v: Int, p: Int) {                if (used[v]) return                used[v] = true                groups.last().add(v)                for (to in g[v]) if (to != p) dfs(to, v)            }            for (i in allBad.indices) if (!used[i]) {                groups.add(mutableListOf())                dfs(i, -1)            }             val dps = groups.map { group ->                group.sort()                val restricted = BooleanArray(1 shl group.size)                for ((a, b) in restrictedPairs) {                    val x = group.binarySearch(allBad.binarySearch(a))                    val y = group.binarySearch(allBad.binarySearch(b))                    if (x >= 0 && y >= 0) restricted[(1 shl x) or (1 shl y)] = true                }                IntArray(n + 1).apply {                    for (mask in 0 until (1 shl group.size)) {                        if (restricted[mask]) {                            for (i in 0 until group.size) {                                restricted[mask or (1 shl i)] = true                            }                        } else {                            this[mask.countOneBits()]++                        }                    }                }            }            return dps.fold(IntArray(allBad.size + 1).apply { this[0] = 1 }) { acc, dp ->                IntArray(allBad.size + 1).apply {                    for (i in acc.indices) {                        val was = acc[i]                        if (was != 0) {                            for (j in dp.indices) {                                val plus = dp[j]                                if (plus != 0) {                                    this[i + j] = add(this[i + j], mul(was, plus))                                }                            }                        }                    }                }            }        }         val fact = (1..n).scan(1) { acc, i -> mul(acc, i) }.toIntArray()        val invFact = IntArray(n + 1).apply {            this[n] = inv(fact[n])            for (i in n - 1 downTo 0) this[i] = mul(this[i + 1], i + 1)        }        fun c(n: Int, k: Int) = if (n < 0 || k > n) 0 else mul(fact[n], mul(invFact[k], invFact[n - k]))         val goodCounts = run {            val good = (0 until n).filter { it !in bad }            val goodCounts = IntArray(n + 2)            for (i in good) {                goodCounts[lr[i].first]++                goodCounts[lr[i].second + 1]--            }            var s = 0            for (i in 0..n) {                s += goodCounts[i]                goodCounts[i] = s            }            goodCounts        }         val changes = bad            .flatMap { listOf(lr[it].first, lr[it].second + 1) }            .toSortedSet()            .toIntArray()        var dps = getDPS(1)        var ans = 0        for (full in 1..n) {            if (full in changes) dps = getDPS(full)            var extra = 0            for (takeBad in 0..minOf(dps.size - 1, full)) {                val takeGood = full - takeBad                extra = add(extra, mul(dps[takeBad], c(goodCounts[full], takeGood)))            }            ans = add(ans, extra)        }        println(ans)    }} @Suppress(""MemberVisibilityCanBePrivate"", ""unused"")@ExperimentalStdlibApi@ExperimentalTime@ExperimentalUnsignedTypesclass Utils {    class GeneralUtils {        companion object {            tailrec fun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)            tailrec fun gcd(a: Long, b: Long): Long = if (b == 0L) a else gcd(b, a % b)            fun gcd(a: Int, b: Int, c: Int): Int = gcd(gcd(a, b), c)            fun gcd(a: Long, b: Long, c: Long): Long = gcd(gcd(a, b), c)            val rnd = Random(239)            val IntRange.length get() = last - first + 1        }    }     class ArrayUtils {        companion object {            fun <T : Comparable<T>> MutableList<T>.makeDistinct() {                if (size <= 1) return                sort()                var sz = 1                for (i in 1 until size) {                    if (this[i] != this[i - 1]) {                        this[sz++] = this[i]                    }                }                while (size > sz) removeAt(lastIndex)            }        }         class Swaps {            companion object {                fun <T> Array<T>.swap(i: Int, j: Int) {                    val x = this[i]                    this[i] = this[j]                    this[j] = x                }                 fun <T> MutableList<T>.swap(i: Int, j: Int) {                    val x = this[i]                    this[i] = this[j]                    this[j] = x                }                 fun IntArray.swap(i: Int, j: Int) {                    val x = this[i]                    this[i] = this[j]                    this[j] = x                }                 fun LongArray.swap(i: Int, j: Int) {                    val x = this[i]                    this[i] = this[j]                    this[j] = x                }                 fun DoubleArray.swap(i: Int, j: Int) {                    val x = this[i]                    this[i] = this[j]                    this[j] = x                    sort()                }                 fun CharArray.swap(i: Int, j: Int) {                    val x = this[i]                    this[i] = this[j]                    this[j] = x                    sort()                }            }        }         class Sorts {            companion object {                fun IntArray.shuffleSort() {                    for (i in 1 until size) swap(i, nextInt(i + 1))                    sort()                }                 fun LongArray.shuffleSort() {                    for (i in 1 until size) swap(i, nextInt(i + 1))                    sort()                }                 fun DoubleArray.shuffleSort() {                    for (i in 1 until size) swap(i, nextInt(i + 1))                    sort()                }                 fun CharArray.shuffleSort() {                    for (i in 1 until size) swap(i, nextInt(i + 1))                    sort()                }            }        }         class Prints {            companion object {                fun println(a: IntArray) {                    if (a.isNotEmpty()) {                        print(a[0])                        for (i in 1 until a.size) {                            print(' ')                            print(a[i])                        }                    }                    println()                }                 fun println(a: LongArray) {                    if (a.isNotEmpty()) {                        print(a[0])                        for (i in 1 until a.size) {                            print(' ')                            print(a[i])                        }                    }                    println()                }                 fun println(a: CharArray, printSpace: Boolean = false) {                    if (a.isNotEmpty()) {                        print(a[0])                        for (i in 1 until a.size) {                            if (printSpace) print(' ')                            print(a[i])                        }                    }                    println()                }                 fun println(a: Array<*>) {                    if (a.isNotEmpty()) {                        print(a[0])                        for (i in 1 until a.size) {                            print(' ')                            print(a[i])                        }                    }                    println()                }                 fun println(a: List<*>) {                    if (a.isNotEmpty()) {                        print(a[0])                        for (i in 1 until a.size) {                            print(' ')                            print(a[i])                        }                    }                    println()                }                 fun println(a: Iterable<*>) {                    val it = a.iterator()                    if (it.hasNext()) {                        print(it.next())                        while (it.hasNext()) {                            print(' ')                            print(it.next())                        }                    }                    println()                }            }        }    }     class BinarySearchUtils {        companion object {            @Suppress(""DuplicatedCode"")            inline fun binarySearch(from: Int, to: Int, f: (Int) -> Boolean): Int {                var l = from                var r = to + 1                while (r - l > 1) {                    val m = (l + r) / 2                    if (f(m)) l = m                    else r = m                }                return l            }             inline fun binarySearch(from: Int = 0, f: (Int) -> Boolean): Int {                var len = 1                while (f(from + len)) len *= 2                return binarySearch(from + len / 2, from + len - 1, f)            }             @Suppress(""DuplicatedCode"")            inline fun binarySearchLong(from: Long, to: Long, f: (Long) -> Boolean): Long {                var l = from                var r = to + 1                while (r - l > 1) {                    val m = (l + r) / 2                    if (f(m)) l = m                    else r = m                }                return l            }             inline fun binarySearchLong(from: Long = 0, f: (Long) -> Boolean): Long {                var len = 1L                while (f(from + len)) len *= 2                return binarySearchLong(from + len / 2, from + len - 1, f)            }             inline fun binarySearchDouble(from: Double, to: Double, times: Int = 200, f: (Double) -> Boolean): Double {                var l = from                var r = to                repeat(times) {                    val m = (l + r) / 2                    if (f(m)) l = m                    else r = m                }                return l            }             inline fun binarySearchDouble(from: Double = 0.0, times: Int = 200, f: (Double) -> Boolean): Double {                var len = 1.0                while (f(from + len)) len *= 2                return binarySearchDouble(from, from + len, times, f)            }        }    }     class UtilsImports {        fun importDependencies() {            check(gcd(4, 6) == 2)            check(rnd.nextInt(10) in 0 until 10)            check(mutableListOf(1, 3, 2, 2, 1).apply { makeDistinct() } == listOf(1, 2, 3))            check((5..10).length == 6)            check(intArrayOf(3, 4).apply { swap(0, 1) }.contentEquals(intArrayOf(4, 3)))            check(intArrayOf(5, 6, 2, 1, 5).apply { shuffleSort() }.contentEquals(intArrayOf(1, 2, 5, 5, 6)))            check(binarySearch { it < 10 } == 9)            check(binarySearchLong { it < 1e13.toLong() } == 1e13.toLong() - 1)            binarySearchDouble { true }            println(intArrayOf())            ArrayDeque<Int>()        }    }     class FastReader(fileName: String? = null) {        @JvmField        val br = BufferedReader(if (fileName != null) FileReader(fileName) else InputStreamReader(System.`in`))         @JvmField        var st = StringTokenizer("""")         fun readString(): String {            while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())            return st.nextToken()        }         fun readInt() = readString().toInt()        fun readLong() = readString().toLong()        fun readDouble() = readString().toDouble()         fun readIntArray(n: Int) = IntArray(n) { readInt() }        fun readLongArray(n: Int) = LongArray(n) { readLong() }        fun readStringArray(n: Int) = Array(n) { readString() }        fun readDoubleArray(n: Int) = DoubleArray(n) { readDouble() }         fun readInts(n: Int) = MutableList(n) { readInt() }        fun readLongs(n: Int) = MutableList(n) { readLong() }        fun readStrings(n: Int) = MutableList(n) { readString() }        fun readDoubles(n: Int) = MutableList(n) { readDouble() }    }} @Suppress(""MemberVisibilityCanBePrivate"", ""unused"")@ExperimentalStdlibApi@ExperimentalTime@ExperimentalUnsignedTypesinline class ModInt(private val x: Int) {    companion object {        private const val mod = 998_244_353         //        const val mod = 1e9.toInt() + 7        fun Int.toModInt() = ModInt(this)        fun Int.toModIntSafe() = ModInt((this % mod + mod) % mod)        fun Long.toModIntSafe() = ModInt(((this % mod + mod) % mod).toInt())        val ZERO = ModInt(0)        val ONE = ModInt(1)        val TWO = ModInt(2)        val TEN = ModInt(10)    }     operator fun plus(k: ModInt) = ModInt((x + k.x).let { if (it >= mod) it - mod else it })    operator fun minus(k: ModInt) = ModInt((x - k.x).let { if (it < 0) it + mod else it })    operator fun times(k: ModInt) = ModInt((x * k.x.toLong() % mod).toInt())    operator fun div(k: ModInt) = this * k.inv()    operator fun unaryMinus() = if (x == 0) this else ModInt(mod - x)    fun inv() = pow(mod - 2)    fun pow(p: Int): ModInt = if (p == 0) ONE else pow(p / 2).let { if (p % 2 == 1) it * it * this else it * it }    fun toInt() = x    override fun toString() = x.toString()} @ExperimentalStdlibApi@ExperimentalTime@ExperimentalUnsignedTypesclass NativeModInt {    companion object {        private const val mod = 998_244_353        fun add(a: Int, b: Int) = (a + b).let { if (it >= mod) it - mod else it }        fun sub(a: Int, b: Int) = (a - b).let { if (it < 0) it + mod else it }        fun mul(a: Int, b: Int) = (a.toLong() * b % mod).toInt()        fun pow(a: Int, p: Int): Int = if (p == 0) 1 else pow(a, p / 2).let { if (p % 2 == 1) mul(mul(it, it), a) else mul(it, it) }        fun inv(a: Int) = pow(a, mod - 2)        fun div(a: Int, b: Int) = mul(a, inv(b))    }}","bitmasks,brute force,combinatorics,dp,dsu,math,two pointers"
"import ModInt.Companion.ONEimport ModInt.Companion.ZEROimport ModInt.Companion.sumimport ModInt.Companion.sumOfimport ModInt.Companion.toModIntimport Utils.ArrayUtils.Companion.makeDistinctimport Utils.ArrayUtils.Prints.Companion.printlnimport Utils.ArrayUtils.Sorts.Companion.shuffleSortimport Utils.ArrayUtils.Swaps.Companion.swapimport Utils.BinarySearchUtils.Companion.binarySearchimport Utils.BinarySearchUtils.Companion.binarySearchDoubleimport Utils.BinarySearchUtils.Companion.binarySearchLongimport Utils.FastReaderimport Utils.GeneralUtils.Companion.gcdimport Utils.GeneralUtils.Companion.lengthimport Utils.GeneralUtils.Companion.rndimport java.io.*import java.util.*import kotlin.collections.ArrayDequeimport kotlin.random.Randomimport kotlin.random.Random.Default.nextIntimport kotlin.time.ExperimentalTime @ExperimentalStdlibApi@ExperimentalTime@ExperimentalUnsignedTypesfun main() {    Locale.setDefault(Locale.US)    if (System.getProperty(""ONLINE_JUDGE"") != null) {        System.setOut(PrintStream(BufferedOutputStream(System.out)))    }    Task().solve()    System.out.flush()} operator fun Pair<Int, Int>.contains(x: Int) = x in first..second @ExperimentalStdlibApi@ExperimentalTime@ExperimentalUnsignedTypesclass Task(private val fin: FastReader = FastReader()) {    fun solve() {        val n = fin.readInt()        val m = fin.readInt()        val lr = Array(n) { Pair(fin.readInt(), fin.readInt()) }        val restrictedPairs = Array(m) { Pair(fin.readInt() - 1, fin.readInt() - 1) }         val bad = restrictedPairs.flatMap { listOf(it.first, it.second) }.toSortedSet().toIntArray()        fun getDPS(sz: Int): Array<ModInt> {            val allBad = bad.filter { sz in lr[it] }            val g = Array(allBad.size) { i ->                val cur = allBad[i]                buildList {                    for ((a, b) in restrictedPairs) {                        if (a == cur && b in allBad) add(allBad.binarySearch(b))                        if (b == cur && a in allBad) add(allBad.binarySearch(a))                    }                }            }              val used = BooleanArray(allBad.size)            val groups = mutableListOf<MutableList<Int>>()            fun dfs(v: Int, p: Int) {                if (used[v]) return                used[v] = true                groups.last().add(v)                for (to in g[v]) if (to != p) dfs(to, v)            }            for (i in allBad.indices) if (!used[i]) {                groups.add(mutableListOf())                dfs(i, -1)            }             val dps = groups.map { group ->                group.sort()                val restricted = BooleanArray(1 shl group.size).apply {                    for ((a, b) in restrictedPairs) {                        val x = group.binarySearch(allBad.binarySearch(a))                        val y = group.binarySearch(allBad.binarySearch(b))                        if (x >= 0 && y >= 0) this[(1 shl x) or (1 shl y)] = true                    }                }                IntArray(n + 1).apply {                    for (mask in 0 until (1 shl group.size)) {                        if (restricted[mask]) {                            for (i in 0 until group.size) {                                restricted[mask or (1 shl i)] = true                            }                        } else {                            this[mask.countOneBits()]++                        }                    }                }            }            return dps.fold(Array(allBad.size + 1) { ZERO }.apply { this[0] = ONE }) { acc, dp ->                Array(allBad.size + 1) { ZERO }.apply {                    for (i in acc.indices) {                        if (acc[i] != ZERO) {                            for (j in dp.indices) {                                if (dp[j] != 0) {                                    this[i + j] += acc[i] * dp[j].toModInt()                                }                            }                        }                    }                }            }        }         val fact = (1..n).scan(ONE) { acc, i -> acc * ModInt(i) }.toTypedArray()        val invFact = (arrayOfNulls<ModInt>(n + 1) as Array<ModInt>).apply {            this[n] = fact[n].inv()            for (i in n - 1 downTo 0) this[i] = this[i + 1] * ModInt(i + 1)        }         fun c(n: Int, k: Int) = if (n < 0 || k > n) ZERO else fact[n] * invFact[k] * invFact[n - k]         val goodCounts = run {            val good = (0 until n).filter { it !in bad }            val goodCounts = IntArray(n + 2)            for (i in good) {                goodCounts[lr[i].first]++                goodCounts[lr[i].second + 1]--            }            var s = 0            for (i in 0..n) {                s += goodCounts[i]                goodCounts[i] = s            }            goodCounts        }         val changes = (bad.flatMap { listOf(lr[it].first, lr[it].second + 1) } + listOf(1, n + 1))            .toSortedSet().toList()        val ans = changes.zipWithNext { a, b ->            val dps = getDPS(a)            (a until b).sumOf { full ->                (0..minOf(dps.size - 1, full)).sumOf { takeBad ->                    dps[takeBad] * c(goodCounts[full], full - takeBad)                }            }        }.sum()        println(ans)    }} @Suppress(""MemberVisibilityCanBePrivate"", ""unused"")@ExperimentalStdlibApi@ExperimentalTime@ExperimentalUnsignedTypesclass Utils {    class GeneralUtils {        companion object {            tailrec fun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)            tailrec fun gcd(a: Long, b: Long): Long = if (b == 0L) a else gcd(b, a % b)            fun gcd(a: Int, b: Int, c: Int): Int = gcd(gcd(a, b), c)            fun gcd(a: Long, b: Long, c: Long): Long = gcd(gcd(a, b), c)            val rnd = Random(239)            val IntRange.length get() = last - first + 1        }    }     class ArrayUtils {        companion object {            fun <T : Comparable<T>> MutableList<T>.makeDistinct() {                if (size <= 1) return                sort()                var sz = 1                for (i in 1 until size) {                    if (this[i] != this[i - 1]) {                        this[sz++] = this[i]                    }                }                while (size > sz) removeAt(lastIndex)            }        }         class Swaps {            companion object {                fun <T> Array<T>.swap(i: Int, j: Int) {                    val x = this[i]                    this[i] = this[j]                    this[j] = x                }                 fun <T> MutableList<T>.swap(i: Int, j: Int) {                    val x = this[i]                    this[i] = this[j]                    this[j] = x                }                 fun IntArray.swap(i: Int, j: Int) {                    val x = this[i]                    this[i] = this[j]                    this[j] = x                }                 fun LongArray.swap(i: Int, j: Int) {                    val x = this[i]                    this[i] = this[j]                    this[j] = x                }                 fun DoubleArray.swap(i: Int, j: Int) {                    val x = this[i]                    this[i] = this[j]                    this[j] = x                    sort()                }                 fun CharArray.swap(i: Int, j: Int) {                    val x = this[i]                    this[i] = this[j]                    this[j] = x                    sort()                }            }        }         class Sorts {            companion object {                fun IntArray.shuffleSort() {                    for (i in 1 until size) swap(i, nextInt(i + 1))                    sort()                }                 fun LongArray.shuffleSort() {                    for (i in 1 until size) swap(i, nextInt(i + 1))                    sort()                }                 fun DoubleArray.shuffleSort() {                    for (i in 1 until size) swap(i, nextInt(i + 1))                    sort()                }                 fun CharArray.shuffleSort() {                    for (i in 1 until size) swap(i, nextInt(i + 1))                    sort()                }            }        }         class Prints {            companion object {                fun println(a: IntArray) {                    if (a.isNotEmpty()) {                        print(a[0])                        for (i in 1 until a.size) {                            print(' ')                            print(a[i])                        }                    }                    println()                }                 fun println(a: LongArray) {                    if (a.isNotEmpty()) {                        print(a[0])                        for (i in 1 until a.size) {                            print(' ')                            print(a[i])                        }                    }                    println()                }                 fun println(a: CharArray, printSpace: Boolean = false) {                    if (a.isNotEmpty()) {                        print(a[0])                        for (i in 1 until a.size) {                            if (printSpace) print(' ')                            print(a[i])                        }                    }                    println()                }                 fun println(a: Array<*>) {                    if (a.isNotEmpty()) {                        print(a[0])                        for (i in 1 until a.size) {                            print(' ')                            print(a[i])                        }                    }                    println()                }                 fun println(a: List<*>) {                    if (a.isNotEmpty()) {                        print(a[0])                        for (i in 1 until a.size) {                            print(' ')                            print(a[i])                        }                    }                    println()                }                 fun println(a: Iterable<*>) {                    val it = a.iterator()                    if (it.hasNext()) {                        print(it.next())                        while (it.hasNext()) {                            print(' ')                            print(it.next())                        }                    }                    println()                }            }        }    }     class BinarySearchUtils {        companion object {            @Suppress(""DuplicatedCode"")            inline fun binarySearch(from: Int, to: Int, f: (Int) -> Boolean): Int {                var l = from                var r = to + 1                while (r - l > 1) {                    val m = (l + r) / 2                    if (f(m)) l = m                    else r = m                }                return l            }             inline fun binarySearch(from: Int = 0, f: (Int) -> Boolean): Int {                var len = 1                while (f(from + len)) len *= 2                return binarySearch(from + len / 2, from + len - 1, f)            }             @Suppress(""DuplicatedCode"")            inline fun binarySearchLong(from: Long, to: Long, f: (Long) -> Boolean): Long {                var l = from                var r = to + 1                while (r - l > 1) {                    val m = (l + r) / 2                    if (f(m)) l = m                    else r = m                }                return l            }             inline fun binarySearchLong(from: Long = 0, f: (Long) -> Boolean): Long {                var len = 1L                while (f(from + len)) len *= 2                return binarySearchLong(from + len / 2, from + len - 1, f)            }             inline fun binarySearchDouble(from: Double, to: Double, times: Int = 200, f: (Double) -> Boolean): Double {                var l = from                var r = to                repeat(times) {                    val m = (l + r) / 2                    if (f(m)) l = m                    else r = m                }                return l            }             inline fun binarySearchDouble(from: Double = 0.0, times: Int = 200, f: (Double) -> Boolean): Double {                var len = 1.0                while (f(from + len)) len *= 2                return binarySearchDouble(from, from + len, times, f)            }        }    }     class UtilsImports {        fun importDependencies() {            check(gcd(4, 6) == 2)            check(rnd.nextInt(10) in 0 until 10)            check(mutableListOf(1, 3, 2, 2, 1).apply { makeDistinct() } == listOf(1, 2, 3))            check((5..10).length == 6)            check(intArrayOf(3, 4).apply { swap(0, 1) }.contentEquals(intArrayOf(4, 3)))            check(intArrayOf(5, 6, 2, 1, 5).apply { shuffleSort() }.contentEquals(intArrayOf(1, 2, 5, 5, 6)))            check(binarySearch { it < 10 } == 9)            check(binarySearchLong { it < 1e13.toLong() } == 1e13.toLong() - 1)            binarySearchDouble { true }            println(intArrayOf())            ArrayDeque<Int>()            listOf(ZERO).sum()            (0..1).sumOf { it.toModInt() }        }    }     class FastReader(fileName: String? = null) {        @JvmField        val br = BufferedReader(if (fileName != null) FileReader(fileName) else InputStreamReader(System.`in`))         @JvmField        var st = StringTokenizer("""")         fun readString(): String {            while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())            return st.nextToken()        }         fun readInt() = readString().toInt()        fun readLong() = readString().toLong()        fun readDouble() = readString().toDouble()         fun readIntArray(n: Int) = IntArray(n) { readInt() }        fun readLongArray(n: Int) = LongArray(n) { readLong() }        fun readStringArray(n: Int) = Array(n) { readString() }        fun readDoubleArray(n: Int) = DoubleArray(n) { readDouble() }         fun readInts(n: Int) = MutableList(n) { readInt() }        fun readLongs(n: Int) = MutableList(n) { readLong() }        fun readStrings(n: Int) = MutableList(n) { readString() }        fun readDoubles(n: Int) = MutableList(n) { readDouble() }    }} @Suppress(""MemberVisibilityCanBePrivate"", ""unused"")@ExperimentalStdlibApi@ExperimentalTime@ExperimentalUnsignedTypesinline class ModInt(private val x: Int) {    companion object {        private const val mod = 998_244_353         //        const val mod = 1e9.toInt() + 7        fun Int.toModInt() = ModInt(this)        fun Int.toModIntSafe() = ModInt((this % mod + mod) % mod)        fun Long.toModIntSafe() = ModInt(((this % mod + mod) % mod).toInt())        val ZERO = ModInt(0)        val ONE = ModInt(1)        val TWO = ModInt(2)        val TEN = ModInt(10)         fun Iterable<ModInt>.sum() = fold(ZERO, ModInt::plus)        fun Array<ModInt>.sum() = fold(ZERO, ModInt::plus)         inline fun <T> Iterable<T>.sumOf(f: (T) -> ModInt) = fold(ZERO) { acc, i -> acc + f(i) }        inline fun <T> Array<T>.sumOf(f: (T) -> ModInt) = fold(ZERO) { acc, i -> acc + f(i) }        inline fun IntRange.sumOf(f: (Int) -> ModInt) = fold(ZERO) { acc, i -> acc + f(i) }    }     operator fun plus(k: ModInt) = ModInt((x + k.x).let { if (it >= mod) it - mod else it })    operator fun minus(k: ModInt) = ModInt((x - k.x).let { if (it < 0) it + mod else it })    operator fun times(k: ModInt) = ModInt((x * k.x.toLong() % mod).toInt())    operator fun div(k: ModInt) = this * k.inv()    operator fun unaryMinus() = if (x == 0) this else ModInt(mod - x)    fun inv() = pow(mod - 2)    fun pow(p: Int): ModInt = if (p == 0) ONE else pow(p / 2).let { if (p % 2 == 1) it * it * this else it * it }    fun toInt() = x    override fun toString() = x.toString()} @ExperimentalStdlibApi@ExperimentalTime@ExperimentalUnsignedTypesclass NativeModInt {    companion object {        private const val mod = 998_244_353        fun add(a: Int, b: Int) = (a + b).let { if (it >= mod) it - mod else it }        fun sub(a: Int, b: Int) = (a - b).let { if (it < 0) it + mod else it }        fun mul(a: Int, b: Int) = (a.toLong() * b % mod).toInt()        fun pow(a: Int, p: Int): Int =            if (p == 0) 1 else pow(a, p / 2).let { if (p % 2 == 1) mul(mul(it, it), a) else mul(it, it) }         fun inv(a: Int) = pow(a, mod - 2)        fun div(a: Int, b: Int) = mul(a, inv(b))    }}","bitmasks,brute force,combinatorics,dp,dsu,math,two pointers"
"import ModInt.Companion.ONEimport ModInt.Companion.ZEROimport ModInt.Companion.sumimport ModInt.Companion.sumOfimport ModInt.Companion.toModIntimport Utils.ArrayUtils.Companion.makeDistinctimport Utils.ArrayUtils.Prints.Companion.printlnimport Utils.ArrayUtils.Sorts.Companion.shuffleSortimport Utils.ArrayUtils.Swaps.Companion.swapimport Utils.BinarySearchUtils.Companion.binarySearchimport Utils.BinarySearchUtils.Companion.binarySearchDoubleimport Utils.BinarySearchUtils.Companion.binarySearchLongimport Utils.FastReaderimport Utils.GeneralUtils.Companion.gcdimport Utils.GeneralUtils.Companion.lengthimport Utils.GeneralUtils.Companion.rndimport java.io.*import java.util.*import kotlin.collections.ArrayDequeimport kotlin.random.Randomimport kotlin.random.Random.Default.nextIntimport kotlin.time.ExperimentalTime @ExperimentalStdlibApi@ExperimentalTime@ExperimentalUnsignedTypesfun main() {    Locale.setDefault(Locale.US)    if (System.getProperty(""ONLINE_JUDGE"") != null) {        System.setOut(PrintStream(BufferedOutputStream(System.out)))    }    Task().solve()    System.out.flush()} operator fun Pair<Int, Int>.contains(x: Int) = x in first..second @ExperimentalStdlibApi@ExperimentalTime@ExperimentalUnsignedTypesclass Task(private val fin: FastReader = FastReader()) {    fun solve() {        val n = fin.readInt()        val m = fin.readInt()        val lr = Array(n) { Pair(fin.readInt(), fin.readInt()) }        val restrictedPairs = Array(m) { Pair(fin.readInt() - 1, fin.readInt() - 1) }         val bad = restrictedPairs.flatMap { listOf(it.first, it.second) }.toSortedSet().toIntArray()        fun getDPS(sz: Int): Array<ModInt> {            val allBad = bad.filter { sz in lr[it] }            val g = Array(allBad.size) { i ->                buildList {                    val cur = allBad[i]                    for ((a, b) in restrictedPairs) {                        if (a == cur && b in allBad) add(allBad.binarySearch(b))                        if (b == cur && a in allBad) add(allBad.binarySearch(a))                    }                }            }             val groups = run {                val used = BooleanArray(allBad.size)                fun createGroup(v: Int): IntArray {                    val group = mutableListOf<Int>()                    fun dfs(v: Int, p: Int) {                        if (used[v]) return                        used[v] = true                        group += v                        for (to in g[v]) if (to != p) dfs(to, v)                    }                    dfs(v, -1)                    group.sort()                    return group.toIntArray()                }                allBad.indices.asSequence().filterNot(used::get).map(::createGroup)            }             val dps = groups.map { group ->                IntArray(n + 1).apply {                    val restricted = BooleanArray(1 shl group.size).apply {                        for ((a, b) in restrictedPairs) {                            val x = group.indexOf(allBad.indexOf(a))                            val y = group.indexOf(allBad.indexOf(b))                            if (x >= 0 && y >= 0) this[(1 shl x) or (1 shl y)] = true                        }                    }                    for (mask in 0 until (1 shl group.size)) {                        if (restricted[mask]) {                            for (i in group.indices) {                                restricted[mask or (1 shl i)] = true                            }                        } else {                            this[mask.countOneBits()]++                        }                    }                }            }            return dps.fold(Array(allBad.size + 1) { ZERO }.apply { this[0] = ONE }) { acc, dp ->                Array(allBad.size + 1) { ZERO }.apply {                    for (i in acc.indices) {                        if (acc[i] != ZERO) {                            for (j in dp.indices) {                                if (dp[j] != 0) {                                    this[i + j] += acc[i] * dp[j].toModInt()                                }                            }                        }                    }                }            }        }         val fact = (1..n).scan(ONE) { acc, i -> acc * ModInt(i) }.toTypedArray()        val invFact = (arrayOfNulls<ModInt>(n + 1) as Array<ModInt>).apply {            this[n] = fact[n].inv()            for (i in n - 1 downTo 0) this[i] = this[i + 1] * ModInt(i + 1)        }         fun c(n: Int, k: Int) = if (n < 0 || k > n) ZERO else fact[n] * invFact[k] * invFact[n - k]         val goodCounts = IntArray(n + 2).apply {            val good = (0 until n).filter { it !in bad }            for (i in good) {                this[lr[i].first]++                this[lr[i].second + 1]--            }            var s = 0            for (i in 0..n) {                s += this[i]                this[i] = s            }        }         val changes = (bad.flatMap { listOf(lr[it].first, lr[it].second + 1) } + listOf(1, n + 1))            .toSortedSet().toList()        val ans = changes.zipWithNext { a, b ->            val dps = getDPS(a)            (a until b).sumOf { full ->                (0..minOf(dps.size - 1, full)).sumOf { takeBad ->                    dps[takeBad] * c(goodCounts[full], full - takeBad)                }            }        }.sum()        println(ans)    }} @Suppress(""MemberVisibilityCanBePrivate"", ""unused"")@ExperimentalStdlibApi@ExperimentalTime@ExperimentalUnsignedTypesclass Utils {    class GeneralUtils {        companion object {            tailrec fun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)            tailrec fun gcd(a: Long, b: Long): Long = if (b == 0L) a else gcd(b, a % b)            fun gcd(a: Int, b: Int, c: Int): Int = gcd(gcd(a, b), c)            fun gcd(a: Long, b: Long, c: Long): Long = gcd(gcd(a, b), c)            val rnd = Random(239)            val IntRange.length get() = last - first + 1        }    }     class ArrayUtils {        companion object {            fun <T : Comparable<T>> MutableList<T>.makeDistinct() {                if (size <= 1) return                sort()                var sz = 1                for (i in 1 until size) {                    if (this[i] != this[i - 1]) {                        this[sz++] = this[i]                    }                }                while (size > sz) removeAt(lastIndex)            }        }         class Swaps {            companion object {                fun <T> Array<T>.swap(i: Int, j: Int) {                    val x = this[i]                    this[i] = this[j]                    this[j] = x                }                 fun <T> MutableList<T>.swap(i: Int, j: Int) {                    val x = this[i]                    this[i] = this[j]                    this[j] = x                }                 fun IntArray.swap(i: Int, j: Int) {                    val x = this[i]                    this[i] = this[j]                    this[j] = x                }                 fun LongArray.swap(i: Int, j: Int) {                    val x = this[i]                    this[i] = this[j]                    this[j] = x                }                 fun DoubleArray.swap(i: Int, j: Int) {                    val x = this[i]                    this[i] = this[j]                    this[j] = x                    sort()                }                 fun CharArray.swap(i: Int, j: Int) {                    val x = this[i]                    this[i] = this[j]                    this[j] = x                    sort()                }            }        }         class Sorts {            companion object {                fun IntArray.shuffleSort() {                    for (i in 1 until size) swap(i, nextInt(i + 1))                    sort()                }                 fun LongArray.shuffleSort() {                    for (i in 1 until size) swap(i, nextInt(i + 1))                    sort()                }                 fun DoubleArray.shuffleSort() {                    for (i in 1 until size) swap(i, nextInt(i + 1))                    sort()                }                 fun CharArray.shuffleSort() {                    for (i in 1 until size) swap(i, nextInt(i + 1))                    sort()                }            }        }         class Prints {            companion object {                fun println(a: IntArray) {                    if (a.isNotEmpty()) {                        print(a[0])                        for (i in 1 until a.size) {                            print(' ')                            print(a[i])                        }                    }                    println()                }                 fun println(a: LongArray) {                    if (a.isNotEmpty()) {                        print(a[0])                        for (i in 1 until a.size) {                            print(' ')                            print(a[i])                        }                    }                    println()                }                 fun println(a: CharArray, printSpace: Boolean = false) {                    if (a.isNotEmpty()) {                        print(a[0])                        for (i in 1 until a.size) {                            if (printSpace) print(' ')                            print(a[i])                        }                    }                    println()                }                 fun println(a: Array<*>) {                    if (a.isNotEmpty()) {                        print(a[0])                        for (i in 1 until a.size) {                            print(' ')                            print(a[i])                        }                    }                    println()                }                 fun println(a: List<*>) {                    if (a.isNotEmpty()) {                        print(a[0])                        for (i in 1 until a.size) {                            print(' ')                            print(a[i])                        }                    }                    println()                }                 fun println(a: Iterable<*>) {                    val it = a.iterator()                    if (it.hasNext()) {                        print(it.next())                        while (it.hasNext()) {                            print(' ')                            print(it.next())                        }                    }                    println()                }            }        }    }     class BinarySearchUtils {        companion object {            @Suppress(""DuplicatedCode"")            inline fun binarySearch(from: Int, to: Int, f: (Int) -> Boolean): Int {                var l = from                var r = to + 1                while (r - l > 1) {                    val m = (l + r) / 2                    if (f(m)) l = m                    else r = m                }                return l            }             inline fun binarySearch(from: Int = 0, f: (Int) -> Boolean): Int {                var len = 1                while (f(from + len)) len *= 2                return binarySearch(from + len / 2, from + len - 1, f)            }             @Suppress(""DuplicatedCode"")            inline fun binarySearchLong(from: Long, to: Long, f: (Long) -> Boolean): Long {                var l = from                var r = to + 1                while (r - l > 1) {                    val m = (l + r) / 2                    if (f(m)) l = m                    else r = m                }                return l            }             inline fun binarySearchLong(from: Long = 0, f: (Long) -> Boolean): Long {                var len = 1L                while (f(from + len)) len *= 2                return binarySearchLong(from + len / 2, from + len - 1, f)            }             inline fun binarySearchDouble(from: Double, to: Double, times: Int = 200, f: (Double) -> Boolean): Double {                var l = from                var r = to                repeat(times) {                    val m = (l + r) / 2                    if (f(m)) l = m                    else r = m                }                return l            }             inline fun binarySearchDouble(from: Double = 0.0, times: Int = 200, f: (Double) -> Boolean): Double {                var len = 1.0                while (f(from + len)) len *= 2                return binarySearchDouble(from, from + len, times, f)            }        }    }     class UtilsImports {        fun importDependencies() {            check(gcd(4, 6) == 2)            check(rnd.nextInt(10) in 0 until 10)            check(mutableListOf(1, 3, 2, 2, 1).apply { makeDistinct() } == listOf(1, 2, 3))            check((5..10).length == 6)            check(intArrayOf(3, 4).apply { swap(0, 1) }.contentEquals(intArrayOf(4, 3)))            check(intArrayOf(5, 6, 2, 1, 5).apply { shuffleSort() }.contentEquals(intArrayOf(1, 2, 5, 5, 6)))            check(binarySearch { it < 10 } == 9)            check(binarySearchLong { it < 1e13.toLong() } == 1e13.toLong() - 1)            binarySearchDouble { true }            println(intArrayOf())            ArrayDeque<Int>()            listOf(ZERO).sum()            (0..1).sumOf { it.toModInt() }        }    }     class FastReader(fileName: String? = null) {        @JvmField        val br = BufferedReader(if (fileName != null) FileReader(fileName) else InputStreamReader(System.`in`))         @JvmField        var st = StringTokenizer("""")         fun readString(): String {            while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())            return st.nextToken()        }         fun readInt() = readString().toInt()        fun readLong() = readString().toLong()        fun readDouble() = readString().toDouble()         fun readIntArray(n: Int) = IntArray(n) { readInt() }        fun readLongArray(n: Int) = LongArray(n) { readLong() }        fun readStringArray(n: Int) = Array(n) { readString() }        fun readDoubleArray(n: Int) = DoubleArray(n) { readDouble() }         fun readInts(n: Int) = MutableList(n) { readInt() }        fun readLongs(n: Int) = MutableList(n) { readLong() }        fun readStrings(n: Int) = MutableList(n) { readString() }        fun readDoubles(n: Int) = MutableList(n) { readDouble() }    }} @Suppress(""MemberVisibilityCanBePrivate"", ""unused"")@ExperimentalStdlibApi@ExperimentalTime@ExperimentalUnsignedTypesinline class ModInt(private val x: Int) {    companion object {        private const val mod = 998_244_353         //        const val mod = 1e9.toInt() + 7        fun Int.toModInt() = ModInt(this)        fun Int.toModIntSafe() = ModInt((this % mod + mod) % mod)        fun Long.toModIntSafe() = ModInt(((this % mod + mod) % mod).toInt())        val ZERO = ModInt(0)        val ONE = ModInt(1)        val TWO = ModInt(2)        val TEN = ModInt(10)         fun Iterable<ModInt>.sum() = fold(ZERO, ModInt::plus)        fun Array<ModInt>.sum() = fold(ZERO, ModInt::plus)         inline fun <T> Iterable<T>.sumOf(f: (T) -> ModInt) = fold(ZERO) { acc, i -> acc + f(i) }        inline fun <T> Array<T>.sumOf(f: (T) -> ModInt) = fold(ZERO) { acc, i -> acc + f(i) }        inline fun IntRange.sumOf(f: (Int) -> ModInt) = fold(ZERO) { acc, i -> acc + f(i) }    }     operator fun plus(k: ModInt) = ModInt((x + k.x).let { if (it >= mod) it - mod else it })    operator fun minus(k: ModInt) = ModInt((x - k.x).let { if (it < 0) it + mod else it })    operator fun times(k: ModInt) = ModInt((x * k.x.toLong() % mod).toInt())    operator fun div(k: ModInt) = this * k.inv()    operator fun unaryMinus() = if (x == 0) this else ModInt(mod - x)    fun inv() = pow(mod - 2)    fun pow(p: Int): ModInt = if (p == 0) ONE else pow(p / 2).let { if (p % 2 == 1) it * it * this else it * it }    fun toInt() = x    override fun toString() = x.toString()} @ExperimentalStdlibApi@ExperimentalTime@ExperimentalUnsignedTypesclass NativeModInt {    companion object {        private const val mod = 998_244_353        fun add(a: Int, b: Int) = (a + b).let { if (it >= mod) it - mod else it }        fun sub(a: Int, b: Int) = (a - b).let { if (it < 0) it + mod else it }        fun mul(a: Int, b: Int) = (a.toLong() * b % mod).toInt()        fun pow(a: Int, p: Int): Int =            if (p == 0) 1 else pow(a, p / 2).let { if (p % 2 == 1) mul(mul(it, it), a) else mul(it, it) }         fun inv(a: Int) = pow(a, mod - 2)        fun div(a: Int, b: Int) = mul(a, inv(b))    }}","bitmasks,brute force,combinatorics,dp,dsu,math,two pointers"
fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()        val a = readLine()!!.split(' ').map { it.toInt() - 1 }.toIntArray()         val cntLeft = IntArray(n) { 0 }        val cntRight = IntArray(n) { 0 }         var ans = 0L        for (j in a.indices) {            cntRight.fill(0)            for (k in n - 1 downTo j + 1) {                ans += cntLeft[a[k]] * cntRight[a[j]]                cntRight[a[k]]++            }            cntLeft[a[j]]++        }        println(ans)    }},"brute force,combinatorics,data structures,math,two pointers"
fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()        val a = readLine()!!.split(' ').map { it.toInt() - 1 }.toIntArray()         val cntLeft = IntArray(n) { 0 }        val cntRight = IntArray(n) { 0 }         var ans = 0L        for (j in a.indices) {            cntRight.fill(0)            for (k in n - 1 downTo j + 1) {                ans += cntLeft[a[k]] * cntRight[a[j]]                cntRight[a[k]]++            }            cntLeft[a[j]]++        }        println(ans)    }},"brute force,combinatorics,data structures,math,two pointers"
fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()        val a = readLine()!!.split(' ').map { it.toInt() - 1 }.toIntArray()         val cntLeft = IntArray(n) { 0 }        val cntRight = IntArray(n) { 0 }         var ans = 0L        for (j in a.indices) {            cntRight.fill(0)            for (k in n - 1 downTo j + 1) {                ans += cntLeft[a[k]] * cntRight[a[j]]                cntRight[a[k]]++            }            cntLeft[a[j]]++        }        println(ans)    }},"brute force,combinatorics,data structures,math,two pointers"
fun main(args: Array<String>) {    val t = readLine()!!.toInt()    for (z in 0 until t) {        val n = readLine()!!.toInt()        val a = readLine()!!.split(' ').map { it.toInt() }         val left = IntArray(3001)        var right = IntArray(3001)         left[a[0]]++        var ans = 0L         for (j in 1 until n - 2) {            right = IntArray(3001)            for (k in n - 1 downTo j + 1) {                ans += left[a[k]] * right[a[j]]                right[a[k]]++            }            left[a[j]]++        }        println(ans)    }},"brute force,combinatorics,data structures,math,two pointers"
fun solve() {	var n = readLine()!!.toInt()	var w = readLine()!!.split(' ').map { it.toInt() }.toIntArray()	var maxK = 0	for(s in 2..2 * n) {		var used = Array(n) { false }		var curK = 0		for(i in 0 until n - 1)			if(!used[i])				for(j in i + 1 until n)					if(!used[j] && w[i] + w[j] == s) {						curK++						used[i] = true						used[j] = true						break					}		if(curK > maxK)			maxK = curK	}	println(maxK)} fun main() {	repeat(readLine()!!.toInt()) {		solve()	}},"brute force,greedy,two pointers"
"import java.io.*import java.util.*import kotlin.math.* fun main(){	val f = BufferedReader(InputStreamReader(System.`in`)) 	for(q in 1..f.readLine().toInt()){		val n = f.readLine().toInt()		val array = f.readLine().split("" "").map{it.toInt()} 		fun calc(s : Int) : Int{			//make frequency table			val freq = IntArray(51)			for(k in 0 until n) freq[array[k]]++ 			var ret = 0			for(k in 0 until (s+1)/2){				if(s-k > 50) continue				ret += min(freq[k],freq[s-k])			} 			if(s%2 == 0){				ret += freq[s/2]/2			} 			return ret		} 		var answer = 0		for(k in 2..100){			answer = max(answer,calc(k))		} 		println(answer)	}}","brute force,greedy,two pointers"
fun solve() {    val n = readLine()!!.toInt()    val w = readLine()!!.split(' ').map { it.toInt() }.toIntArray()    var maxK = 0    for(s in 2..2 * n) {        val used = Array(n) { false }        var curK = 0        for(i in 0 until n - 1)            if(!used[i])                for(j in i + 1 until n)                    if(!used[j] && w[i] + w[j] == s) {                        curK++                        used[i] = true                        used[j] = true                        break                    }        if(curK > maxK)            maxK = curK    }    println(maxK)} fun main() {    repeat(readLine()!!.toInt()) {        solve()    }},"brute force,greedy,two pointers"
"import kotlin.math.* fun main() {    val t = readLine()!!.toInt()    repeat(t) {        val n = readLine()!!.toInt()        val w = readLine()!!.split("" "").map{ it.toInt() }        var ans = 0        var a = IntArray(100)                for(i in 0 .. n - 1){            a[w[i]]++        }                for(i in 2 .. 100){            var sum = 0            for(j in 1 .. 50){                if(j < i - j){                    sum += min(a[j], a[i - j])                }                else if(j == i - j){                    sum += a[j] / 2                }            }            ans = max(ans, sum)        }                println(ans)    }}  ","brute force,greedy,two pointers"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.*import kotlin.math.maximport kotlin.math.min fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val nu = jin.readLine().toInt()    val strings = Array(nu) {        val s = jin.readLine()        String(it, s.count { it == 'B' }, s.count { it == 'N' })    }    val minB = strings.minBy { it.b }!!.b    val maxB = strings.maxBy { it.b }!!.b    val minN = strings.minBy { it.n }!!.n    val maxN = strings.maxBy { it.n }!!.n    strings.sortBy { it.b }    var k = 0    var answer = Int.MAX_VALUE    var bestB = 0    var bestN = 0    val below = TreeSet<String>(compareBy({ it.b - it.n }, { it.ix }))    val above = TreeSet<String>(compareBy({ it.b - it.n }, { it.ix }))    above.addAll(strings)    for (b in minB..maxB) {        while (k < nu && strings[k].b <= b) {            above.remove(strings[k])            below.add(strings[k])            k++        }        val last = if (above.isEmpty()) null else above.last()        val limBelow = if (last == null) minN else min(minN, b - last.b + last.n)        val first = if (below.isEmpty()) null else below.first()        val limAbove = if (first == null) maxN else max(maxN, b - first.b + first.n)        val pos = max(max(0, (limAbove - limBelow + 1) / 2), max(b - minB, maxB - b))        if (pos < answer && (b != 0 || (limBelow + limAbove + 1) / 2 != 0)) {            answer = pos            bestB = b            bestN = (limBelow + limAbove + 1) / 2        }    }    println(answer)    println(""B"".repeat(bestB) + ""N"".repeat(bestN))} data class String(val ix: Int, val b: Int, val n: Int)","binary search,geometry,ternary search"
"import java.io.BufferedReaderimport kotlin.math.maximport kotlin.math.min fun main() {    val br = System.`in`.bufferedReader()//    val sb = StringBuilder()    val n = br.readInt()    val bCt = IntArray(n)    val nCt = IntArray(n)    var minB = Int.MAX_VALUE    var maxB = 0    var minN = Int.MAX_VALUE    var maxN = 0    var maxBNDif = 0    var maxNBDif = 0    for(x in 0 until n){        val s = br.readLine()         for (c in s) {            if (c == 'B') {                bCt[x]++            } else {                nCt[x]++            }        }        minB = min(minB, bCt[x])        maxB = max(maxB, bCt[x])        minN = min(minN, nCt[x])        maxN = max(maxN, nCt[x])    }    var bestB = maxB    var bestN = maxN    fun check(t: Int): Boolean{        var lowB = 0        var highB = Int.MAX_VALUE        var lowN = 0        var highN = Int.MAX_VALUE        var lowDif = Int.MIN_VALUE        var highDif = Int.MAX_VALUE        for(x in 0 until n){            lowB = max(lowB, bCt[x] - t)            highB = min(highB, bCt[x] + t)            lowN = max(lowN, nCt[x] - t)            highN = min(highN, nCt[x] + t)            lowDif = max(lowDif, bCt[x] - nCt[x] - t)            highDif = min(highDif, bCt[x] - nCt[x] + t)        }         highB = min(highB, highN + highDif)        lowB = max(lowB, lowN + lowDif)        highN = min(highN, highB - lowDif)        lowN = max(lowN, lowB - highDif)        highDif = min(highDif, highB - lowN)        lowDif = max(lowDif, lowB - highN)        if(lowB > highB || lowN > highN || lowDif > highDif) return false        bestB = lowB        bestN = lowN        return true    }      var high = max(maxB - minB, maxN - minN)    var low = 0    var mid = (high + low) shr 1    while (low != high){        if(check(mid)){            high = mid        } else {            low = mid + 1        }        mid = (high + low) shr 1    }    println(mid)    print(""B"".repeat(bestB))    print(""N"".repeat(bestN))} private const val SPACE_INT = ' '.toInt()private const val ZERO_INT = '0'.toInt()private const val NL_INT = '\n'.toInt() private fun BufferedReader.readInt(): Int {    var ret = read()    while (ret <= SPACE_INT) {        ret = read()    }    val neg = ret == '-'.toInt()    if (neg) {        ret = read()    }    ret -= ZERO_INT    var read = read()    while (read >= ZERO_INT) {        ret *= 10        ret += read - ZERO_INT        read = read()    }     while (read <= SPACE_INT && read != -1 && read != NL_INT) {        mark(1)        read = read()    }    if (read > SPACE_INT) {        reset()    }    return if (neg) -ret else ret}","binary search,geometry,ternary search"
"import java.io.BufferedReaderimport kotlin.math.maximport kotlin.math.min fun main() {    val br = System.`in`.bufferedReader()//    val sb = StringBuilder()    val n = br.readInt()    val bCt = IntArray(n)    val nCt = IntArray(n)    var minB = Int.MAX_VALUE    var maxB = 0    var minN = Int.MAX_VALUE    var maxN = 0    var maxBNDif = 0    var maxNBDif = 0    for (x in 0 until n) {        val s = br.readLine()         for (c in s) {            if (c == 'B') {                bCt[x]++            } else {                nCt[x]++            }        }        minB = min(minB, bCt[x])        maxB = max(maxB, bCt[x])        minN = min(minN, nCt[x])        maxN = max(maxN, nCt[x])    }    var bestB = maxB    var bestN = maxN    fun check(t: Int): Boolean {        var lowB = 0        var highB = Int.MAX_VALUE        var lowN = 0        var highN = Int.MAX_VALUE        var lowDif = Int.MIN_VALUE        var highDif = Int.MAX_VALUE        for (x in 0 until n) {            lowB = max(lowB, bCt[x] - t)            highB = min(highB, bCt[x] + t)            lowN = max(lowN, nCt[x] - t)            highN = min(highN, nCt[x] + t)            lowDif = max(lowDif, bCt[x] - nCt[x] - t)            highDif = min(highDif, bCt[x] - nCt[x] + t)        }         highB = min(highB, highN + highDif)        lowB = max(lowB, lowN + lowDif)        highN = min(highN, highB - lowDif)        lowN = max(lowN, lowB - highDif)        highDif = min(highDif, highB - lowN)        lowDif = max(lowDif, lowB - highN)        if (lowB > highB || lowN > highN || lowDif > highDif) return false        bestB = highB        bestN = highN        return true    }      var high = max(maxB - minB, maxN - minN)    var low = 0    var mid = (high + low) shr 1    while (low != high) {        if (check(mid)) {            high = mid        } else {            low = mid + 1        }        mid = (high + low) shr 1    }    println(mid)    print(""B"".repeat(bestB))    print(""N"".repeat(bestN))} private const val SPACE_INT = ' '.toInt()private const val ZERO_INT = '0'.toInt()private const val NL_INT = '\n'.toInt() private fun BufferedReader.readInt(): Int {    var ret = read()    while (ret <= SPACE_INT) {        ret = read()    }    val neg = ret == '-'.toInt()    if (neg) {        ret = read()    }    ret -= ZERO_INT    var read = read()    while (read >= ZERO_INT) {        ret *= 10        ret += read - ZERO_INT        read = read()    }     while (read <= SPACE_INT && read != -1 && read != NL_INT) {        mark(1)        read = read()    }    if (read > SPACE_INT) {        reset()    }    return if (neg) -ret else ret}","binary search,geometry,ternary search"
"// 2022-04-11, Mon, 18:11import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.system.measureTimeMillisimport java.util.TreeMapimport java.util.TreeSet inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        val S = fakein.toString()        println(""New Case "")        println(S.take(80))        println(""..."")        fakein.clear()        IN = BufferedInputStream(S.byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} val getintfast:Int get() = IO.nextInt()val getint:Int get(){ val ans = getlong ; if(ans > Int.MAX_VALUE) IntArray(1000000000); return ans.toInt() }val getlong:Long get() = IO.nextLong()val getstr:String get() = IO.nextString()fun getline(n:Int):IntArray{    return IntArray(n){getint}}fun getlineL(n:Int):LongArray{    return LongArray(n){getlong}}fun getbinary(n:Int, asTrue:Char):BooleanArray{    val str = getstr    return BooleanArray(n){str[it] == asTrue}} val List<Char>.ret:Stringget() = this.joinToString("""")var dmark = -1infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    dmark++    var str = ""<${dmark}>   ""    debug()    if(this is String){ str += this    }else if(this is Int){ str += this.toString()    }else if(this is Long){ str += this.toString()    }else{ str += this.toString()}    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is BooleanArray){ println(""$str :${a.map{if(it)'1' else '0'}.joinToString("" "")}"")    }else if(a is Array<*>){        println(""$str : "")        for(c in a){if(c is IntArray){println(c.joinToString("" ""))}        else if(c is LongArray){println(c.joinToString("" ""))}        else if(c is BooleanArray){println(c.map { if(it) '1' else '0' }.joinToString(""""))        }         }        println()    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){    throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){        throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    fun cases(onecase:()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint} else if(mode == solveMode.tc){1 } else randCount        //safety checks        if(pI != 998_244_353 && pI != 1_000_000_007){            throw Exception(""Modding a wrong prime!"")        }        if(withBruteForce){            println(""Brute force is active"")        }         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            onecase()        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }}inline fun<T> T.alsoBrute(cal:() -> T){    if(!withBruteForce) return    val also = cal()    if(this != also){        println(""Checking failed: Got ${this} Brute ${also}"")        crash()    }}// 1. Moddedconst val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}infix fun Int.modM(b:Int):Int{ return ((this.toLong() * b) % pI).toInt() }infix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }fun intPow(x:Int,e:Int,m:Int):Int{    var X = x ; var E =e ; var Y = 1    while(E > 0){        if(E and 1 == 0){            X = ((1L * X * X) % m).toInt()            E = E shr 1        }else{            Y = ((1L * X * Y) % m).toInt()            E -= 1        }    }    return Y}// 2. DP initial valuesconst val plarge = 1_000_000_727const val nlarge = -plargeconst val phuge = 2_727_000_000_000_000_000Lconst val nhuge = -phuge// 3. conveniecen conversionsval Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionval Char.code :Int get() = this.toInt() -  'a'.toInt()//3. hard to write stufffun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val mint:MutableList<Int> get() = mutableListOf<Int>()val mong:MutableList<Long> get() = mutableListOf<Long>()//4. more outputsfun List<Char>.conca():String = this.joinToString("""")val CharArray.conca :String get() = this.joinToString("""")val IntArray.conca :String get() = this.joinToString("" "")@JvmName(""concaInt"")fun List<Int>.conca():String = this.joinToString("" "")val LongArray.conca:String get() = this.joinToString("" "")@JvmName(""concaLong"")fun List<Long>.conca():String = this.joinToString("" "")//5. Pair of intsconst val longmask = (1L shl 32) - 1fun makepair(a:Int, b:Int):Long = (a.toLong() shl 32) xor (longmask and b.toLong()) // remember positev sonlyval Long.first get() = (this ushr 32).toInt()val Long.second get() = this.toInt()//6. stringsval String.size get() = this.lengthconst val randCount = 100//7. bitsfun Int.has(i:Int):Boolean = (this and (1 shl i) != 0)     inline fun BinarySearchFirstTrue(l:Int,r:Int,isTrue:(Int)->Boolean):Int?{    //inclusive    var L = l    var R = r    while(L<R){        val m = (L + R) shr 1        if(isTrue(m)){            R = m        }else{            L = m + 1        }    }    return if(isTrue(L)){        L    }else{        if(L == r){            null        }else{            L + 1        }    }} inline fun BinarySearchLastTrue(l:Int,r:Int,isTrue:(Int)->Boolean):Int?{    //inclusive    var L = l    var R = r    while(L<R){       val m = ((L + R) shr 1) + 1        if(isTrue(m)){ L = m }else{ R = m - 1 }    }    return if(isTrue(L)){ L }else{ null }} fun debug(){}const val withBruteForce = falseconst val singleCase = truefun main(){    solve.cases{		val n = getint		val A = IntArray(n)		val B = IntArray(n)		repeat(n){			val str = getstr			var aa = str.count{it == 'B'}			val bb = str.count{it == 'N'}			A[it] = aa			B[it] = bb		} 		fun solve(t:Int):Pair<Int,Int>?{			var maxx = plarge			var maxy = plarge			var maxd = plarge			var minx = 0			var miny = 0			var mind = nlarge			for(i in 0 until n){				val a = A[i]				val b = B[i]				maxx = minOf(maxx, a + t)				maxy = minOf(maxy, b + t)				maxd = minOf(maxd, b-a + t)				minx = maxOf(minx, a -t)				miny = maxOf(miny , b- t)				mind = maxOf(mind, b-a-t)			}			if(maxx < minx || maxy < miny || maxd < mind) {				return null			}			for(x in minx..maxx) {				var aminy = if(x == 0) 1 else 0				var amaxy = plarge				aminy = maxOf(aminy, miny )				amaxy = minOf(amaxy, maxy )				aminy = maxOf(aminy, mind + x )				amaxy = minOf(amaxy, maxd + x)				if(aminy <= amaxy){					return Pair(x,aminy)				}			}			return null		} 		val x = solve(1)		val d = BinarySearchFirstTrue(0,500000){			solve(it)!= null		}!! 		val ans = solve(d)!! 		val ret = mutableListOf<Char>()		val (a,b) = ans		repeat(a){			ret.add('B')		}		repeat(b) {			ret.add('N')		}		put(d)		put(ret.conca())       }    done()}/*19 minutes of coding  */   ","binary search,geometry,ternary search"
"import java.util.* const val MOD = 1000000007L fun main() {    val s = readLine()!!    if (s.all { it == '0' }) {        println(s.length)    } else {        val stack = ArrayDeque<Pair<Int, Long>>()        stack.push(Pair(0, 1L))        var currBlock = 0        for (k in s.indexOf('1') + 1 until s.length) {            if (s[k] == '0') {                currBlock++            } else {                var higher = 0L                var here = 0L                while (stack.isNotEmpty() && stack.peek().first <= currBlock) {                    val (j, x) = stack.pop()                    higher += x                    higher %= MOD                    here += (currBlock - j + 1).toLong() * x                    here %= MOD                }                stack.push(Pair(currBlock + 1, higher))                stack.push(Pair(0, here))                currBlock = 0            }        }        val answer = ((stack.map { it.second }.sum() % MOD) * (((s.indexOf('1') + 1).toLong() * (s.length - s.lastIndexOf('1')).toLong()) % MOD)) % MOD        println(answer)    }}","combinatorics,data structures,dp"
"fun ok(n : Int, k : Int, x : Int, mod : Int, a : List<Int>) : Boolean {    var (res, cur) = intArrayOf(0, mod)    for (i in 0 until n)        if (cur == 0 || a[i] <= x) {            res++            cur = 1 - cur        }    return res >= k}fun main() {    val (n, k) = readLine()!!.split("" "").map { it.toInt() }    val a = readLine()!!.split("" "").map { it.toInt() }    var (l, r) = intArrayOf(1, 1E9.toInt())    while (r > l) {        val m = (l + r) / 2        if (ok(n, k, m, 0, a) || ok(n, k, m, 1, a))            r = m        else            l = m + 1    }    println(l)}","binary search,dp,dsu,greedy,implementation"
"fun main() {    val (n, k) = readLine()!!.split("" "").map { it.toInt() }    val a = readLine()!!.split("" "").map { it.toInt() }    fun c(i0: Int, i1: Int, m: Int, lim: Int): Boolean {        var c = 0        var i = i0        while (i < i1) {            if (a[i] <= m) {                c++                if (c >= lim) return true                i += 2            } else {                i++            }        }        return false    }    var l = 0    var r = a.max()!!    val k0 = (k + 1) / 2    val k1 = k / 2    val io = k % 2    val ie = 1 - io    while (l < r - 1) {        val m = (l + r) / 2        if (c(0, n - ie, m, k0) || c(1, n - io, m, k1)) {            r = m        } else {            l = m        }    }    println(r)}","binary search,dp,dsu,greedy,implementation"
"import java.io.*import java.util.*import kotlin.math.*//semi-tfun main(){	val f = BufferedReader(InputStreamReader(System.`in`)) 	val (n,m) = f.readLine().split("" "").map{it.toInt()}	val array = f.readLine().split("" "").map{it.toInt()} 	fun check(x : Int) : Boolean{ 		val dp = Array(n){IntArray(2){0}}		if(array[0] <= x){			dp[0][0] = 1		}		dp[0][1] = 1 		for(k in 1 until n){			if(array[k] <= x){				dp[k][0] = max(dp[k-1][0],dp[k-1][1]+1)			} else {				dp[k][0] = dp[k-1][0]			}			dp[k][1] = dp[k-1][0]+1		} 		return max(dp[n-1][0],dp[n-1][1]) >= m 	} 	var l = 1	var r = 1000000000	var ans = 1000000000 	while(l <= r){		val mid = l + (r-l)/2 		if(check(mid)){			r = mid-1			ans = mid		} else {			l = mid+1		}	} 	println(ans)}","binary search,dp,dsu,greedy,implementation"
"import kotlin.math.min fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main() {    val (n, k) = readInts()    val vs = readInts()     val evenL = k/2    val oddL = evenL + if (k % 2 == 0) 0 else 1     println(min(            solve(vs.subList(0, vs.size - if (evenL == oddL) 1 else 0), oddL),            solve(vs.subList(1, vs.size - if (evenL == oddL) 0 else 1), evenL)    ))} fun solve(vs: List<Int>, len: Int): Int {    var l = 0    var r = vs.max()!!     while (l < r) {        val m = (l + r) / 2        if (!can(vs, len, m)) {            l = m + 1        } else {            r = m        }    }     return l} fun can(vs: List<Int>, len: Int, max: Int): Boolean {    var taken = 0    var lastTaken = false    for (v in vs) {        if (lastTaken) {            lastTaken = false        } else {            if (v <= max) {                taken++                lastTaken= true            }        }    }    return taken >= len}","binary search,dp,dsu,greedy,implementation"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.* fun main() {    val primeFactor = IntArray(10000001) { it }    for (p in 2..10000) {        if (primeFactor[p] == p) {            var k = p * p            while (k <= 10000000) {                primeFactor[k] = p                k += p            }        }    }    val jin = BufferedReader(InputStreamReader(System.`in`))    val n = jin.readLine().toInt()    val tokenizer = StringTokenizer(jin.readLine())    val answer1 = IntArray(n)    val answer2 = IntArray(n)    for (j in 0 until n) {        var k = tokenizer.nextToken().toInt()        val p = primeFactor[k]        while (k % p == 0) {            k /= p        }        if (k == 1) {            answer1[j] = -1            answer2[j] = -1        } else {            answer1[j] = k            answer2[j] = p        }    }    println(answer1.joinToString("" ""))    println(answer2.joinToString("" ""))}","constructive algorithms,math,number theory"
"fun main() {    val n = readLine()!!.toInt()    val a = readLine()!!.split(' ').map { it.toInt() }     val minDiv = IntArray(1e7.toInt() + 2) { it }    for (i in 2 until minDiv.size) {        if (minDiv[i] != i)            continue        for (j in i until minDiv.size step i)            minDiv[j] = minOf(minDiv[j], i)    }     fun getPrimeDivisors(v: Int): ArrayList<Int> {        val ans = ArrayList<Int>()        var curVal = v        while (curVal != 1) {            if (ans.isEmpty() || ans.last() != minDiv[curVal])                ans.add(minDiv[curVal])            curVal /= minDiv[curVal]        }        return ans    }     val d1 = IntArray(n)    val d2 = IntArray(n)    for (id in a.indices) {        val list = getPrimeDivisors(a[id])        if (list.size < 2) {            d1[id] = -1            d2[id] = -1        } else {            d1[id] = list[0]            list.removeAt(0)            d2[id] = list.reduce { s, t -> s * t }        }    }    println(d1.joinToString("" ""))    println(d2.joinToString("" ""))}","constructive algorithms,math,number theory"
"fun main() {    val n = readLine()!!.toInt()    val a = readLine()!!.split(' ').map { it.toInt() }     val minDiv = IntArray(1e7.toInt() + 2) { it }    for (i in 2 until minDiv.size) {        if (minDiv[i] != i)            continue        for (j in i until minDiv.size step i)            minDiv[j] = minOf(minDiv[j], i)    }     fun getPrimeDivisors(v: Int): ArrayList<Int> {        val ans = ArrayList<Int>()        var curVal = v        while (curVal != 1) {            if (ans.isEmpty() || ans.last() != minDiv[curVal])                ans.add(minDiv[curVal])            curVal /= minDiv[curVal]        }        return ans    }     val d1 = IntArray(n)    val d2 = IntArray(n)    for (id in a.indices) {        val list = getPrimeDivisors(a[id])        if (list.size < 2) {            d1[id] = -1            d2[id] = -1        } else {            d1[id] = list[0]            list.removeAt(0)            d2[id] = list.reduce { s, t -> s * t }        }    }    println(d1.joinToString("" ""))    println(d2.joinToString("" ""))}","constructive algorithms,math,number theory"
"fun main() {    val n = readLine()!!.toInt()    val a = readLine()!!.split(' ').map { it.toInt() }     val minDiv = IntArray(1e7.toInt() + 2) { it }    for (i in 2 until minDiv.size) {        if (minDiv[i] != i)            continue        for (j in i until minDiv.size step i)            minDiv[j] = minOf(minDiv[j], i)    }     fun getPrimeDivisors(v: Int): ArrayList<Int> {        val ans = ArrayList<Int>()        var curVal = v        while (curVal != 1) {            if (ans.isEmpty() || ans.last() != minDiv[curVal])                ans.add(minDiv[curVal])            curVal /= minDiv[curVal]        }        return ans    }     val d1 = IntArray(n)    val d2 = IntArray(n)    for (id in a.indices) {        val list = getPrimeDivisors(a[id])        if (list.size < 2) {            d1[id] = -1            d2[id] = -1        } else {            d1[id] = list[0]            list.removeAt(0)            d2[id] = list.reduce { s, t -> s * t }        }    }    println(d1.joinToString("" ""))    println(d2.joinToString("" ""))}","constructive algorithms,math,number theory"
"fun main() {    val t = readLine()!!.toInt()     for(i in 1..t) {        var n = readLine()!!.toInt()        var a = readLine()!!.split("" "").map { it.toInt() }         a = a.sorted()        while(n > 0 && a[n - 1] > n) {            n--        }         println(1 + n)    }}","greedy,sortings"
fun main(){    val t = readLine()!!.toInt()    repeat(t)    {        val n = readLine()!!.toInt()        var arr:MutableList<Int> = readLine()!!.split(' ').map(String::toInt).toMutableList()        arr.sort()        var mx = 1        for (i in 0..n-1)            if (arr.get(i)<i+2) mx = i+2        println(mx)    }    },"greedy,sortings"
"fun main(){    repeat(readLine()!!.toInt()){        val n = readLine()!!.toInt()        val a = readLine()!!.split(' ').map(String::toInt).sorted()        var ans = 1        var per = 1        for(i in 0 until n){            if(per >= a[i])                ans = maxOf(ans, per + 1)            per += 1        }        println(ans)    }}","greedy,sortings"
"fun main(){    val a = readLine()!!.toInt()    repeat(a){        readLine()        var count = 0        val list= readLine()!!.split("" "").map{it.toInt()}.sorted()        for(i in list.lastIndex downTo 0){            if(list[i]<=i+1) {                count = i+1                break            }        }        println(count+1)    }}","greedy,sortings"
"import java.util.*import java.math.*import kotlin.math.* fun readLn()=readLine()!!fun readInt()=readLn().toInt()fun readInts()=readLn().split("" "").map{it.toInt()}fun readLong()=readLn().toLong()fun readLongs()=readLn().split("" "").map{it.toLong()} val out=mutableListOf<String>()fun printLine(s:String){out.add(s)}fun output(){println(out.joinToString(""\n""))} val inf=(-1e18).toLong() fun main(){    val (n,k)=readInts()    val dp=Array(n+1){Array(k){false}}    var sum=0L    dp[0][0]=true    for(i in 1..n){        val (a,b)=readInts()        for(j in 0 until k){            if(!dp[i-1][j])continue            var bl=(a+b)%k            for(rd in 0 until k){                if(rd<=a && bl<=b){                    var jj=rd+j                    if(jj>=k)jj-=k                    dp[i][jj]=true                }                bl--                if(bl<0)bl+=k            }        }        sum+=a+b    }    var ans=0L    for(i in 0 until k)if(dp[n][i])ans=max(ans,(sum-i)/k)    printLine(""$ans"")    output()}","brute force,dp,greedy,math"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport kotlin.math.max fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    var line = jin.readLine().split("" "")    val n = line[0].toInt()    val k = line[1].toInt()    val kl = k.toLong()    var total = 0L    val dp = Array(n + 1) { BooleanArray(k) }    dp[0][0] = true    for (j1 in 1..n) {        line = jin.readLine().split("" "")        val red = line[0].toLong()        val blue = line[1].toLong()        val rb = ((red + blue) % kl).toInt()        total += red + blue        for (j2 in 0 until k) {            for (j3 in 0 until k) {                if (dp[j1 - 1][j3]) {                    var remBlue = j2 - j3                    if (remBlue < 0) {                        remBlue += k                    }                    var remRed = rb - remBlue                    if (remRed < 0) {                        remRed += k                    }                    if (remBlue <= blue && remRed <= red) {                        dp[j1][j2] = true                        break                    }                }            }        }    }    var answer = 0L    for (j2 in 0 until k) {        if (dp[n][j2]) {            answer = max(answer, (total - j2.toLong()) / kl)        }    }    println(answer)}","brute force,dp,greedy,math"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.io.PrintWriterimport java.util.* fun PrintWriter.solve(sc: FastScanner) {    val n = sc.nextInt()    val k = sc.nextInt()    val a = Array(n) { 0L }    val b = Array(n) { 0L }    for (i in 0 until n) {        a[i] = sc.nextLong()        b[i] = sc.nextLong()    }    val sumA = a.sum()    val sumB = b.sum()    val dp = Array(n + 1) { Array(k) { false } }    dp[0][0] = true    for (i in 0 until n) {        for (j in 0 until k) {            val j2 = ((j - a[i] % k + k) % k).toInt()            dp[i + 1][j] = dp[i][j2]            val max = minOf(k - 1L, a[i]).toInt()            for (l in 0..max) {                if ((a[i] - l) % k + b[i] >= k) {                    dp[i + 1][j] = dp[i + 1][j] or dp[i][(j - l + k) % k]                }            }        }    }    var ans = 0L    for (i in 0 until k) {        if (dp[n][i]) {            ans = maxOf(ans, (sumA + sumB - i) / k)        }    }    println(ans)} fun main() {    val writer = PrintWriter(System.out, false)    writer.solve(FastScanner(System.`in`))    writer.flush()} class FastScanner(s: InputStream) {    private var st = StringTokenizer("""")    private val br = BufferedReader(InputStreamReader(s))     fun next(): String {        while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun nextInt() = next().toInt()    fun nextLong() = next().toLong()    fun nextLine() = br.readLine()    fun nextDouble() = next().toDouble()    fun ready() = br.ready()}","brute force,dp,greedy,math"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.io.PrintWriterimport java.util.* fun PrintWriter.solve(sc: FastScanner) {    val n = sc.nextInt()    val k = sc.nextInt()    val a = Array(n) { 0L }    val b = Array(n) { 0L }    for (i in 0 until n) {        a[i] = sc.nextLong()        b[i] = sc.nextLong()    }    val sumA = a.sum()    val sumB = b.sum()    var dp = BooleanArray(k)    dp[0] = true    for (i in 0 until n) {        val newdp = BooleanArray(k)        for (j in 0 until k) {            val j2 = ((j - a[i] % k + k) % k).toInt()            newdp[j] = dp[j2]            val max = minOf(k - 1L, a[i]).toInt()            for (l in 0..max) {                if ((a[i] - l) % k + b[i] >= k) {                    newdp[j] = newdp[j] or dp[(j - l + k) % k]                }            }        }        dp = newdp    }    var ans = 0L    for (i in 0 until k) {        if (dp[i]) {            ans = maxOf(ans, (sumA + sumB - i) / k)        }    }    println(ans)} fun main() {    val writer = PrintWriter(System.out, false)    writer.solve(FastScanner(System.`in`))    writer.flush()} class FastScanner(s: InputStream) {    private var st = StringTokenizer("""")    private val br = BufferedReader(InputStreamReader(s))     fun next(): String {        while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun nextInt() = next().toInt()    fun nextLong() = next().toLong()    fun nextLine() = br.readLine()    fun nextDouble() = next().toDouble()    fun ready() = br.ready()}","brute force,dp,greedy,math"
"fun main() {    val t = readLine()!!.toInt()    for (tc in 1..t) {        val a = readLine()!!        println(a.toCharArray().distinct().joinToString("""").repeat(a.length))    }}","constructive algorithms,strings"
"fun main() {    val T = readLine()!!.toInt()    for (tc in 1..T) {        val t = readLine()!!         val s = t.toCharArray().distinct().joinToString("""").repeat(t.length)        println(s)    }}","constructive algorithms,strings"
"fun main() {    val T = readLine()!!.toInt()    for (tc in 1..T) {        val t = readLine()!!         val s = t.toCharArray().distinct().joinToString("""").repeat(t.length)        println(s)    }}","constructive algorithms,strings"
"fun main() {    val T = readLine()!!.toInt()    for (tc in 1..T) {        val t = readLine()!!         val s = t.toCharArray().distinct().joinToString("""").repeat(t.length)        println(s)    }}","constructive algorithms,strings"
"  fun main(){    val t = readLine()!!.toInt()    repeat(t){        val n = readLine()!!.toInt()        val a = readLine()!!.split("" "").map { it.toInt() }        val b = readLine()!!.split("" "").map { it.toInt() }        var up = false        var down = false        var flag = true        for (i in 0 until n){            flag = ((a[i]==b[i]) || (b[i]<a[i] && down) || (b[i]>a[i] && up)) && flag            if(a[i]==1) up = true            if(a[i]==-1) down = true        }        if(flag) println(""YES"")        else println(""NO"")    }}","greedy,implementation"
"fun main() {    cycle@ for (i in 1..readLine()!!.toInt()) {        val n = readLine()!!.toInt()        val a = readLine()!!.split("" "").map { it.toInt() }        val b = readLine()!!.split("" "").map { it.toInt() }         var minus = false        var plus = false        for (j in 0 until n) {            if ((b[j] > a[j] && !plus) || (b[j] < a[j] && !minus)) {                println(""NO"")                continue@cycle            }            if (a[j] == -1) {                minus = true            }            if (a[j] == +1) {                plus = true            }        }        println(""YES"")    }}","greedy,implementation"
"fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main() {    repeat(readInt()) {        val n = readInt()        val vs = readInts()        val ys = readInts()        val ok = solve(vs, ys)        println(if (ok) ""YES"" else ""NO"")    }} fun solve(vs: List<Int>, ys: List<Int>): Boolean {    val n = vs.size    var up = false    var down = false    for (i in 0 until n) {        val v = vs[i]        val y = ys[i]        if (v > y && !down) return false        if (v < y && !up) return false        if (v == 1) up = true        if (v == -1) down = true    }    return true}","greedy,implementation"
"fun main(args : Array<String>){    var t = readLine()!!.toInt()    while (t!=0){        t--        val n = readLine()!!.toInt()        val a = readLine()!!.split(' ').map { it.toInt() }        val b = readLine()!!.split(' ').map { it.toInt() }        var isMinusFound = false        var isPlusFound = false        var ans = true        for (i in 0 until n){            if (a[i] > b[i] && !isMinusFound || a[i] < b[i] && !isPlusFound){                ans = false                break            }            if (a[i] == 1) isPlusFound = true            if (a[i] == -1) isMinusFound = true        }        if (ans) println(""YES"") else println(""NO"")    }}","greedy,implementation"
"fun main(args : Array<String>) {//    val input = Scanner(System.`in`)    var t = readLine()!!.toInt()    repeat(t) {        var n = readLine()!!.toInt()         val a = readLine()!!.split(' ').map { it.toInt() }         val curNums = sortedSetOf<Int>()         val lefts = mutableListOf<Int>()        val rights = mutableListOf<Int>()         for (i in 0 until a.size) {            if (curNums.contains(a[i])) {                break            }            curNums.add(a[i])            if(curNums.size == curNums.last()) {                lefts.add(i + 1)            }        }        curNums.clear()        for (i in a.size-1 downTo 0) {            if (curNums.contains(a[i])) {                break            }            curNums.add(a[i])            if(curNums.size == curNums.last()) {                rights.add(i)            }        }        val res = lefts.intersect(rights.reversed())        println(res.size)        for (r in res){            println(""${r} ${n-r}"")        }    }  }","implementation,math"
"import java.util.* //04/04/2020fun main(args: Array<String>) = with(Scanner(System.`in`)) {  repeat(nextInt()) {    val n = nextInt()    val nn = (0 until n).map { nextInt() }    val frequencies = nn.groupingBy { it }.eachCount()    val max = nn.max()!!     var f1 = -1    var f2 = -1    if (nn.subList(0, max).isPermutation(max) && nn.subList(max, nn.size).isPermutation(nn.size - max)) {      f1 = max    }    if (nn.subList(0, nn.size - max).isPermutation(nn.size - max) && nn.subList(nn.size - max, nn.size).isPermutation(max)) {      f2 = nn.size - max    }      if (f1 >= 0 && f2 >= 0 && f1 != f2) {      println(2)      pp(f1, nn)      pp(f2, nn)    } else if (f1 >= 0) {      println(1)      pp(f1, nn)    } else if (f2 >= 0) {      println(1)      pp(f2, nn)    } else {      println(0)    }  }} private fun List<Int>.isPermutation(l: Int): Boolean {  val toSet = (1..l).toSet()  return size == toSet.size && toSet() == toSet} private fun pp(f1: Int, nn: List<Int>) {  println(""$f1 ${nn.size - f1}"")}","implementation,math"
"import java.io.BufferedReaderimport java.io.InputStreamReader fun isPermutation (i: Int, j: Int, len: Int, a: List<Int>): Boolean{    val used = HashMap<Int, Int>()    for (k in i until j){        used[a[k]] = 1 + used.getOrDefault(a[k], 0)    }    //println(""Array Range: ${i until j}. Permutation Range: ${1 .. len}"")    //(1 .. len).forEach{x -> println(""$x ${used[x] == 1}"")}    return (1 .. len).dropWhile { it in used && used[it] == 1 }.isEmpty()} fun main (){    val br = BufferedReader(InputStreamReader(System.`in`))    val t = br.readLine().toInt()     for (i in 1 .. t){        val n = br.readLine().toInt()        val a = br.readLine().split("" "").map { it.toInt() }        val max = a.max()!!        val firstCase = isPermutation(0, max, max, a) && isPermutation(max, n, n - max, a)        val secondCase = isPermutation(0, n - max, n - max, a) && isPermutation(n - max, n, max, a)        if (firstCase && secondCase && n - max != max){            println(2)            println(""${n - max} ${max}"")            println(""${max} ${n - max}"")        } else if (firstCase){            println(1)            println(""${max} ${n - max}"")        } else if (secondCase){            println(1)            println(""${n - max} ${max}"")        } else{            println(0)        }    }}","implementation,math"
"import kotlin.math.max fun main() {    val br = System.`in`.bufferedReader()    val numCases = br.readLine().toInt()    val sb = StringBuilder()    repeat(numCases) {        val numNums = br.readLine().toInt()        val nums = br.readLine().split(' ').map(String::toInt)        val max = nums.max()!!        val possible = HashSet<Int>()        possible.add(max)        possible.add(numNums - max)        val sb2 = StringBuilder()        var numSols = 0                 possible.forEach {            var maxSeenStart = 0            var maxSeenEnd = 0            val numSetStart = HashSet<Int>()            val numSetEnd = HashSet<Int>()            for (x in 0 until it) {                val num = nums[x]                maxSeenStart = max(maxSeenStart, num)                numSetStart += num            }            for (x in it until numNums) {                val num = nums[x]                maxSeenEnd = max(maxSeenEnd, num)                numSetEnd += num            }            if (it == maxSeenStart && maxSeenStart == numSetStart.size && numNums - it == maxSeenEnd && maxSeenEnd == numSetEnd.size) {                numSols++                sb2.append(it)                sb2.append(' ')                sb2.append(numNums - it)                sb2.append('\n')            }        }        sb.append(numSols)        sb.append('\n')        sb.append(sb2)    }    print(sb)}","implementation,math"
"fun main(){    val t = readLine()!!.toInt()    for (i in 1..t){        val a = readLine()!!        var length = 0        var max = 0        for (ch in a){            length++            if (ch=='R') {                max = maxOf(max, length)                length=0            }        }        max= maxOf(max, length+1)        println(max)    }}","binary search,data structures,dfs and similar,greedy,implementation"
fun main() {    val n = readLine()!!.toInt()    (1..n).forEach { _ ->        val s = readLine()!!        var maxC = 0        var c = 0        for (l in s) {            if (l == 'L') {                c++                if (c > maxC) {                    maxC = c                }            } else {                c = 0            }        }        println(maxC+1)    }},"binary search,data structures,dfs and similar,greedy,implementation"
"private fun nextLine() = readLine()!!private fun nextInt() = nextLine().toInt() fun solve() {    val s = nextLine()    var ans = 0    var last = 0    for ((i, c) in s.withIndex()) {        if (c == 'R') {            ans = maxOf(i + 1 - last, ans)            last = i + 1        }    }    ans = maxOf(s.length + 1 - last, ans)    println(ans)} fun main() = (1..nextInt()).forEach{ solve() }","binary search,data structures,dfs and similar,greedy,implementation"
"fun main() {    val testCaseCount = readInt()     repeat(testCaseCount) {        val letters = readString()         println(minimumJumpDistance(letters))    }} fun minimumJumpDistance(letters: String): Int =    (Regex(""L+"")        .findAll(letters)        .map { it.value.length }        .max() ?: 0) +            1  fun readInt(): Int = readLine()?.toInt() ?: 0fun readString(): String = readLine() ?: """"","binary search,data structures,dfs and similar,greedy,implementation"
"fun main(){    val (n, p, k) = readLine()!!.split(' ').map { it.toInt() }    val A = readLine()!!.split(' ').map { it.toLong() }     var X = Array(n){ readLine()!!.split(' ').map { it.toLong() }}     for (i in 0..n-1){        X[i] = X[i].plus(A[i])    }     X.sortByDescending { it.last() }     var DP= Array(1.shl(p)){-1000000000000000}    DP[0]=0     for (i in 0.. n-1){        for (j in 1.shl(p) -1 downTo 0 step 1){            var used = 0            for (l in 0..p-1){                if (1.shl(l) and j != 0){                    used+=1                    continue                }                 if (DP[j or 1.shl(l)]<DP[j]+X[i][l]){                    DP[j or 1.shl(l)]=DP[j]+X[i][l]                }             }             if (i-used<k){                DP[j]+=X[i][p]            }        }    }    println(DP[1.shl(p) -1]) }","bitmasks,dp,greedy,sortings"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.math.max  fun main(args: Array<String>) {    val sc = FastScanner(System.`in`)    val n = sc.nextInt()    val p = sc.nextInt()    val k = sc.nextInt()    val a = Array(n) { sc.nextLong() }    val sk = Array(n) { Array(p) { sc.nextLong() } }     val people = mutableListOf<People>()    for (i in 0 until n) {        people.add(People(a[i], sk[i]))    }    people.sortByDescending { it.a }     val dp = Array(2) { Array(1 shl p) { 0L } }     var cur = 1    for (pi in people.indices) {        cur = (cur + 1) % 2        val prev = (cur + 1) % 2        val pe = people[pi]         for (mask in 0 until (1 shl p)) {            val teamSize = mask.popCount()            dp[cur][mask] = dp[prev][mask] + if (teamSize <= pi && pi - teamSize < k) pe.a else 0        }        for (mask in 0 until (1 shl p)) {            for (myP in 0 until p) {                if (mask and (1 shl myP) != 0) continue                 dp[cur][mask or (1 shl myP)] = max(dp[cur][mask or (1 shl myP)], dp[prev][mask] + pe.skill[myP])            }        }    }     println(dp[cur][(1 shl p) - 1])} private fun Int.popCount(): Int = (0..8).count { this and (1 shl it) != 0 } data class People(val a: Long, val skill: Array<Long>) class FastScanner(s: InputStream) {    private var st = StringTokenizer("""")    private val br = BufferedReader(InputStreamReader(s))     fun next(): String {        while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun nextInt() = next().toInt()    fun nextLong() = next().toLong()    fun nextLine() = br.readLine()    fun nextDouble() = next().toDouble()    fun ready() = br.ready()}","bitmasks,dp,greedy,sortings"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.math.max  fun main(args: Array<String>) {    val sc = FastScanner(System.`in`)    val n = sc.nextInt()    val p = sc.nextInt()    val k = sc.nextInt()    val a = Array(n) { sc.nextLong() }    val sk = Array(n) { Array(p) { sc.nextLong() } }     val people = mutableListOf<People>()    for (i in 0 until n) {        people.add(People(a[i], sk[i]))    }    people.sortByDescending { it.a }     val dp = Array(2) { Array(1 shl p) { 0L } }     var cur = 1    for (pi in people.indices) {        cur = (cur + 1) % 2        val prev = (cur + 1) % 2        val pe = people[pi]         for (mask in 0 until (1 shl p)) {            val teamSize = mask.popCount()            dp[cur][mask] = dp[prev][mask] + if (teamSize <= pi && pi - teamSize < k) pe.a else 0        }        for (mask in 0 until (1 shl p)) {            for (myP in 0 until p) {                if (mask and (1 shl myP) != 0) continue                val nMask = mask or (1 shl myP)                dp[cur][nMask] = max(dp[cur][nMask], dp[prev][mask] + pe.skill[myP])            }        }    }     println(dp[cur][(1 shl p) - 1])} private fun Int.popCount(): Int = Integer.bitCount(this)  data class People(val a: Long, val skill: Array<Long>) class FastScanner(s: InputStream) {    private var st = StringTokenizer("""")    private val br = BufferedReader(InputStreamReader(s))     fun next(): String {        while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun nextInt() = next().toInt()    fun nextLong() = next().toLong()    fun nextLine() = br.readLine()    fun nextDouble() = next().toDouble()    fun ready() = br.ready()}","bitmasks,dp,greedy,sortings"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.math.max  fun main(args: Array<String>) {    val sc = FastScanner(System.`in`)    val n = sc.nextInt()    val p = sc.nextInt()    val k = sc.nextInt()    val a = Array(n) { sc.nextLong() }    val sk = Array(n) { Array(p) { sc.nextLong() } }     val people = mutableListOf<People>()    for (i in 0 until n) {        people.add(People(a[i], sk[i]))    }    people.sortByDescending { it.a }     val dp = Array(2) { Array(1 shl p) { 0L } }     var cur = 1    for (pi in people.indices) {        cur = (cur + 1) % 2        val prev = (cur + 1) % 2        val pe = people[pi]         for (mask in 0 until (1 shl p)) {            val teamSize = mask.popCount()            dp[cur][mask] = dp[prev][mask] + if (teamSize <= pi && pi - teamSize < k) pe.a else 0        }        for (mask in 0 until (1 shl p)) {            for (myP in 0 until p) {                val nMask = mask or (1 shl myP)                val use = 1 - (mask shr myP) and 1                dp[cur][nMask] = max(dp[cur][nMask], (dp[prev][mask] + pe.skill[myP]) * use)            }        }    }     println(dp[cur][(1 shl p) - 1])} private fun Int.popCount(): Int = Integer.bitCount(this) data class People(val a: Long, val skill: Array<Long>) class FastScanner(s: InputStream) {    private var st = StringTokenizer("""")    private val br = BufferedReader(InputStreamReader(s))     fun next(): String {        while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun nextInt() = next().toInt()    fun nextLong() = next().toLong()    fun nextLine() = br.readLine()    fun nextDouble() = next().toDouble()    fun ready() = br.ready()}","bitmasks,dp,greedy,sortings"
"import java.util.* fun main() {    for (c in 1..readLine()!!.toInt()) {        val line = readLine()!!        val six = line.indexOf(' ')        val n = line.substring(0, six).toInt()        val k = line.substring(six + 1).toLong()        val tokenizer = StringTokenizer(readLine()!!)        val freq = LongArray(60)        for (j in 1..n) {            var a = tokenizer.nextToken().toLong()            var e = 0            while (a != 0L) {                freq[e] += a % k                e++                a /= k            }        }        println(if (freq.all { it <= 1L }) ""yEs"" else ""nO"")    }}","bitmasks,greedy,implementation,math,number theory,ternary search"
"fun main(){    repeat(readLine()!!.toInt()){        val (n,k) = readLine()!!.split(' ').map { it.toLong() }        val arr = readLine()!!.split(' ').map { it.toLong() }.toLongArray()         var maxP = 1L        while(maxP<1e16){            maxP*=k        }        while(maxP>0){            val pos = arr.withIndex().filter { it.value >= maxP}.map { it.index }            if(pos.isNotEmpty()) {                if(pos.size>1){                    break                }                arr[pos[0]]-=maxP            }            maxP/=k        }        if(arr.maxOrNull()!! >0){            println(""NO"")        }        else{            println(""YES"")        }    }} ","bitmasks,greedy,implementation,math,number theory,ternary search"
"fun getMask(a: Long, k: Long): Long? {    var (tmp, res) = listOf(a, 0L)    var cnt = 0    while (tmp > 0) {        if (tmp % k > 1)            return null        res = res or ((tmp % k) shl cnt)        tmp /= k        cnt++    }    return res} fun main() {    val T = readLine()!!.toInt()    for (tc in 1..T) {        val (n, k) = readLine()!!.split(' ').map { it.toLong() }        val a = readLine()!!.split(' ').map { getMask(it.toLong(), k) }        val b = a.filterNotNull()        if (b.size < n) {            println(""NO"")            continue        } else {            val res = b.reduce { acc, l -> if (acc < 0 || (acc and l) > 0) -1 else acc or l }            println(if (res < 0) ""NO"" else ""YES"")        }    }}","bitmasks,greedy,implementation,math,number theory,ternary search"
"fun getMask(a: Long, k: Long): Long? {    var (tmp, res) = listOf(a, 0L)    var cnt = 0    while (tmp > 0) {        if (tmp % k > 1)            return null        res = res or ((tmp % k) shl cnt)        tmp /= k        cnt++    }    return res} fun main() {    val T = readLine()!!.toInt()    for (tc in 1..T) {        val (n, k) = readLine()!!.split(' ').map { it.toLong() }        val a = readLine()!!.split(' ').map { getMask(it.toLong(), k) }        val b = a.filterNotNull()        if (b.size < n) {            println(""NO"")            continue        } else {            val res = b.reduce { acc, l -> if (acc < 0 || (acc and l) > 0) -1 else acc or l }            println(if (res < 0) ""NO"" else ""YES"")        }    }}","bitmasks,greedy,implementation,math,number theory,ternary search"
"import kotlin.math.*private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of intsprivate fun readIntArray() = readInts().toIntArray() fun bins(a : List<Int>, v : Int) : Int {    var k = 1    while (k < a.size)        k += k    var j = 0    while (k > 0) {        var jj = j + k        if (jj < a.size && a[jj] <= v)            j = jj        k = k / 2    }    if (a[j] <= v)        return j    else        return -1} class FenwickTree(n_ : Int) {    val n = n_    val f = LongArray(n + 1)    fun lowbit(i : Int) = i and -i     fun add(x : Int, v : Long) {        var i = x        while (i <= n) {            f[i] += v            i += lowbit(i)        }    }    fun sum(x : Int) : Long {        var i = x        var ret: Long = 0        while (i > 0) {            ret += f[i]            i -= lowbit(i)        }        return ret    }} /*val N = 20005val d = Array(N, { mutableListOf<Int>() } ) val a = readIntArray()println(a.joinToString("" "")) a = b.also { b = a } // swap a bap.sortWith(compareBy({it.first}, {it.second})) // sort pairval vx = x.sorted().distinct() // sort and unique*/ fun main() {    val n = readInt()    val x = readIntArray()    val v = readIntArray()    val ap = Array(n, {i -> Pair(v[i], x[i])})    ap.sortWith(compareBy({it.first}, {it.second}))    val vx = x.sorted().distinct()    val fn = FenwickTree(n)    val fs = FenwickTree(n)    var ans : Long = 0    for (i in 0..n-1) {        val j = bins(vx, ap[i].second) + 1        ans += fn.sum(j) * ap[i].second - fs.sum(j)        fn.add(j, 1)        fs.add(j, ap[i].second.toLong())    }    println(ans)}","data structures,divide and conquer,implementation,sortings"
"import java.util.* fun main() {    val n = readLine()!!.toInt()    var tokenizer = StringTokenizer(readLine()!!)    val xs = IntArray(n) { tokenizer.nextToken().toInt() }    tokenizer = StringTokenizer(readLine()!!)    val ps = Array(n) { Pair(xs[it], tokenizer.nextToken().toInt()) }    ps.sortBy { it.first }    val ts1 = TrieSum(-100000001, 100000001)    val ts2 = TrieSum(-100000001, 100000001)    var answer = 0L    for (p in ps) {        //println(""p = $p, answer = $answer"")        answer += (p.first.toLong() * ts1.sumAtMost(p.second)) - ts2.sumAtMost(p.second)        ts1.add(p.second, 1)        ts2.add(p.second, p.first.toLong())    }    println(answer)} class TrieSum(val treeFrom: Int, treeTo: Int) {    val root = Node()    val height: Int    fun add(k: Int, delta: Long) {        var k = k        k -= treeFrom        var node: Node? = root        for (e in height - 1 downTo 0) {            if (k shr e and 1 == 0) {                if (node!!.left == null) {                    node.left = Node()                }                node = node.left            } else {                if (node!!.right == null) {                    node.right = Node()                }                node = node.right            }            node!!.subTreeSum += delta        }    }     fun sumAtMost(k: Int): Long {        var k = k        var res: Long = 0        k -= treeFrom        var node: Node? = root        var e = height - 1        while (e >= 0 && node != null) {            if (k shr e and 1 == 0) {                node = node.left            } else {                if (node.left != null) {                    res += node.left!!.subTreeSum                }                node = node.right            }            e--        }        if (node != null) {            res += node.subTreeSum        }        return res    }     fun sumAtLeast(k: Int): Long {        var k = k        var res: Long = 0        k -= treeFrom        var node: Node? = root        var e = height - 1        while (e >= 0 && node != null) {            if (k shr e and 1 == 0) {                if (node.right != null) {                    res += node.right!!.subTreeSum                }                node = node.left            } else {                node = node.right            }            e--        }        if (node != null) {            res += node.subTreeSum        }        return res    }     class Node {        var left: Node? = null        var right: Node? = null        var subTreeSum: Long = 0    }     init {        val size = treeTo - treeFrom + 1        var height = 0        while (1 shl height < size) {            height++        }        this.height = height    }}","data structures,divide and conquer,implementation,sortings"
"import java.util.* fun main() {    val n = readLine()!!.toInt()    var tokenizer = StringTokenizer(readLine()!!)    val xs = IntArray(n) { tokenizer.nextToken().toInt() }    tokenizer = StringTokenizer(readLine()!!)    val ps = Array(n) { Pair(xs[it], tokenizer.nextToken().toInt()) }    ps.sortBy { it.first }    val ts1 = TrieSum(-100000001, 100000001)    val ts2 = TrieSum(-100000001, 100000001)    var answer = 0L    for (p in ps) {        //println(""p = $p, answer = $answer"")        answer += (p.first.toLong() * ts1.sumAtMost(p.second)) - ts2.sumAtMost(p.second)        ts1.add(p.second, 1)        ts2.add(p.second, p.first.toLong())    }    println(answer)} class TrieSum(val treeFrom: Int, treeTo: Int) {    val root = Node()    val height: Int    fun add(k: Int, delta: Long) {        var k = k        k -= treeFrom        var node: Node? = root        for (e in height - 1 downTo 0) {            if (k shr e and 1 == 0) {                if (node!!.left == null) {                    node.left = Node()                }                node = node.left            } else {                if (node!!.right == null) {                    node.right = Node()                }                node = node.right            }            node!!.subTreeSum += delta        }    }     fun sumAtMost(k: Int): Long {        var k = k        var res: Long = 0        k -= treeFrom        var node: Node? = root        var e = height - 1        while (e >= 0 && node != null) {            if (k shr e and 1 == 0) {                node = node.left            } else {                if (node.left != null) {                    res += node.left!!.subTreeSum                }                node = node.right            }            e--        }        if (node != null) {            res += node.subTreeSum        }        return res    }     fun sumAtLeast(k: Int): Long {        var k = k        var res: Long = 0        k -= treeFrom        var node: Node? = root        var e = height - 1        while (e >= 0 && node != null) {            if (k shr e and 1 == 0) {                if (node.right != null) {                    res += node.right!!.subTreeSum                }                node = node.left            } else {                node = node.right            }            e--        }        if (node != null) {            res += node.subTreeSum        }        return res    }     class Node {        var left: Node? = null        var right: Node? = null        var subTreeSum: Long = 0    }     init {        val size = treeTo - treeFrom + 1        var height = 0        while (1 shl height < size) {            height++        }        this.height = height    }}","data structures,divide and conquer,implementation,sortings"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007 class BIT(n: Int) {  private val N =    if (Integer.highestOneBit(n) == n) n    else Integer.highestOneBit(n) shl 1   private val bit = LongArray(N + 1)   fun sum(i: Int): Long {    var x = i    var s = 0L    while(x > 0) {      s += bit[x]      x -= x and -x    }    return s  }   fun add(i: Int, a: Long) {    var x = i + 1    while(x <= N) {      bit[x] += a      x += x and -x    }  }} class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  fun solve() {    val N = ni()    val X = na(N)    val V = na(N)    zip(V)    val E = Array(N){Entry(X[it], V[it])}    E.sortBy { it.x }    val sum = BIT(N)    val cnt = BIT(N)    var ans = 0L    for (i in 0 until N) {      cnt.add(E[i].v, 1)      sum.add(E[i].v,  E[i].x.toLong())      // 同じスピードは含める      val s = sum.sum(E[i].v + 1)      val c = cnt.sum(E[i].v + 1)      ans += c * E[i].x - s    }    out.println(ans)  }   data class Entry(val x: Int, val v: Int)   fun zip(a: IntArray) {    val ids = a.distinct() as MutableList<Int>    ids.sort()    for (i in a.indices) {      a[i] = lowerBound(ids, 0, a[i])    }  }   fun lowerBound(A: MutableList<Int>, s: Int, x: Int): Int {    var l = s - 1    var h = A.size    while(h - l > 1) {      val m = (h + l) / 2      if (A[m] >= x) h = m      else l = m    }    return h  }                                              private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private val reader = BufferedReader(InputStreamReader(stream), 32768)  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return map(n) { ni() + offset }  }   private inline fun map(n: Int, f: (Int) -> Int): IntArray {    val res = IntArray(n)    for (i in 0 until n) {      res[i] = f(i)    }    return res  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: BooleanArray) {    debug { a.map { if (it) 1 else 0 }.joinToString("""") }  }   private fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }} fun <A, B> pair(a: A, b: B) = RPair(a, b)data class RPair<A, B>(val _1: A, val _2: B) fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","data structures,divide and conquer,implementation,sortings"
"import kotlin.math.abs fun main() {    val t = readLine()!!.toInt()    val o = ArrayList<String>()    (1..t).forEach {        val (a, b, c) = readLine()!!.split(' ').map{it.toInt()}        var ans = 30000        var ansa = 0        var ansb = 0        var ansc = 0        for (i in 1..20000) for (j in i..20000 step i) for (k in j..20000 step j) {            val anss = abs(a-i) + abs(b-j) + abs(c-k)            if (anss < ans) {                ans = anss                ansa = i                ansb = j                ansc = k            }        }        o.add(""$ans"")        o.add(""$ansa $ansb $ansc"")    }    println(o.joinToString(""\n""))}","brute force,math"
"import java.lang.Math.abs fun main(){    fun readInt() = readLine()!!.toInt()    fun readIntArray() = readLine()!!.split(' ').map{it.toInt()}.toIntArray()    repeat(readInt()){        val (a, b, c) = readIntArray()        var (ans, aa, bb, cc) = IntArray(4){30000}        for(i in 1..20000)            for(j in i..20000 step i)                for(k in j..20000 step j) {                    val pans = abs(a - i) + abs(b - j) + abs(c - k)                    if(pans < ans){                        ans = pans                        aa = i                        bb = j                        cc = k                    }                }        println(ans)        println(""$aa $bb $cc"")    }}","brute force,math"
"import java.util.*import kotlin.math.sqrt fun main(s: Array<String>) {    val t = readLine()!!.toInt()    for (_i in 0 until t) {        val (a, b, c) = readLine()!!.split(' ').map { it.toInt() }        var min = Int.MAX_VALUE        var ans = arrayOf(a, b, c)        for (A in 1..20000) {            for (B in A..20000 step A) {                val x = Math.max(1, c / B)                for (i in 0..1) {                    val C = B * (x + i)                    val num = Math.abs(A - a) + Math.abs(B - b) + Math.abs(C - c)                    if (min > num) {                        min = num                        ans = arrayOf(A, B, C)                    }                }            }        }        println(min)        println(ans.joinToString("" ""))    }}","brute force,math"
"fun readint()=readLine()!!.toInt()fun readll()=readLine()!!.toLong()fun readline_int()=(readLine()!!.split("" "").map{it.toInt()}).toIntArray()fun readline_ll()=(readLine()!!.split("" "").map{it.toLong()}).toLongArray()fun main(){	var t=readint()	while(t-->0)	{		var tmp=readline_int()		var a=tmp[0]		var b=tmp[1]		var c=tmp[2]		var ans=1000000000		var x=a		var y=b		var z=c		var i=1		while(i<=2*a)		{			var j=i			while(j<=2*b)			{				var k=j				while(k<=2*c)				{					var now=0					if(a-i>=0) now+=a-i					else now-=a-i					if(b-j>=0) now+=b-j					else now-=b-j					if(c-k>=0) now+=c-k					else now-=c-k					if(now<ans)					{						ans=now						x=i						y=j						z=k					}					k+=j				}				j+=i			}			i++		}		println(""${ans}"")		println(""${x} ${y} ${z}"")	}}","brute force,math"
"//package codeforces.ozon2020 fun main() {	val n = readInt()	val nei = List(n) { mutableListOf<Int>() }	repeat(n - 1) {		val (u, v) = readInts().map { it - 1 }		nei[u].add(v); nei[v].add(u)	}	val possible = nei.indices.toMutableSet()	while (possible.size > 1) {		val uv = possible.filter { nei[it].intersect(possible).size == 1 }.take(2)		println(""? ${uv.map { it + 1 }.joinToString("" "")}"")		val w = readInt() - 1		if (w in uv) {			possible.clear(); possible.add(w)			break		}		possible.removeAll(uv)	}	println(""! ${possible.first() + 1}"")} private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","constructive algorithms,dfs and similar,interactive,trees"
"//package codeforces.ozon2020 fun main() {	val n = readInt()	val nei = List(n) { mutableListOf<Int>() }	repeat(n - 1) {		val (u, v) = readInts().map { it - 1 }		nei[u].add(v); nei[v].add(u)	}	val possible = nei.indices.toMutableSet()	while (possible.size > 1) {		val (u, v) = possible.filter { nei[it].intersect(possible).size == 1 }.take(2)		println(""? ${u + 1} ${v + 1}"")		val w = readInt() - 1		if (w == u || w == v) {			possible.clear(); possible.add(w)			break		}		possible.removeAll(listOf(u, v))	}	println(""! ${possible.first() + 1}"")} private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","constructive algorithms,dfs and similar,interactive,trees"
"fun main() {	val n = readInt()	val nei = List(n) { mutableListOf<Int>() }	val poss = MutableList(n) { true }	repeat(n - 1) {		val (u, v) = readInts().map { it - 1 }		nei[u].add(v); nei[v].add(u)	}	while (poss.count { it } != 1) {		val nice = nei.indices.filter { u ->			poss[u] && (nei[u].count { poss[it] } == 1)		}		val (u, v) = nice.take(2)		println(""? ${u + 1} ${v + 1}"")		System.out.flush()		val w = readInt() - 1		if (w == u || w == v) {			poss.fill(false)			poss[w] = true			break		}		poss[u] = false		poss[v] = false	}	println(""! ${poss.indexOf(true) + 1}"")	System.out.flush()} private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","constructive algorithms,dfs and similar,interactive,trees"
"fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun <T> printlnFlush(x: T) {    println(x)    System.out.flush()} fun getLCA(u: Int, v: Int): Int {    printlnFlush(""? ${u + 1} ${v + 1}"")    return readInt() - 1} fun main(unused: Array<String>) {    val n = readInt()     val edges = List(n) { mutableSetOf<Int>() }    for (i in 1 until n) {        val (x, y) = readInts().map { it - 1 }         edges[x] += y        edges[y] += x    }     var u = 0    while (edges[u].size > 0) {        if (edges[u].size == 1) {            val v = edges[u].single()             if (edges[v].size == 1) {                u = getLCA(u, v)                edges[u].clear()            } else                u = v        } else {            val (v, w) = edges[u].take(2)             val lca = getLCA(v, w)            if (lca == u) {                edges[u].remove(v)                edges[u].remove(w)            } else {                edges[lca].remove(u)                u = lca            }        }    }     printlnFlush(""! ${u + 1}"")}","constructive algorithms,dfs and similar,interactive,trees"
"fun readInt() = readLine()!!.toInt()fun readInts() = readLine()!!.split(' ').map { it.toInt() } fun main(unused: Array<String>) {    for (t in 1..readInt()) {        readInt()        println(readInts().sorted().joinToString("" ""))        println(readInts().sorted().joinToString("" ""))    }}","brute force,constructive algorithms,greedy,sortings"
"fun main() {    fun readInt() = readLine()!!.toInt()    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val numQueries = readInt()    for (query in 0 until numQueries) {        readLine()        println(readInts().sorted().joinToString("" ""))        println(readInts().sorted().joinToString("" ""))    }}","brute force,constructive algorithms,greedy,sortings"
"fun main() {    repeat(readLine()!!.toInt()) {        val n = readLine()!!.toInt()        val first = readLine()!!.split("" "").map { it.toInt() }        val second = readLine()!!.split("" "").map { it.toInt() }        println(first.sorted().joinToString("" ""))        println(second.sorted().joinToString("" ""))    }}","brute force,constructive algorithms,greedy,sortings"
"fun solve() {    val n = readLine()!!.toInt()    val a = readLine()!!.split(' ').map { it.toInt() }.sorted()    val b = readLine()!!.split(' ').map { it.toInt() }.sorted()    println(a.joinToString("" ""))    println(b.joinToString("" ""))} fun main() {    val t = readLine()!!.toInt()    repeat(t) { solve() }}","brute force,constructive algorithms,greedy,sortings"
"fun main() = repeat(readLine()!!.toInt()){    val a = readLine()!!.split("" "").map{it.toInt()}    println(""${if ((a[1]-a[0])%(a[2]+a[3]) == 0) (a[1]-a[0])/(a[2]+a[3]) else -1}"")}",math
"fun main() {    val t = readLine()!!.toInt()    (1..t).forEach {        val (x, y, a, b) = readLine()!!.split("" "").map { it.toInt() }        val u = y - x        val v = a + b        println( if ( u % v > 0 ) -1 else u / v)    }}",math
"fun main() {  var nt = readLine()!!.toInt()  while(nt-- > 0) {    var (x, y, a, b) = readLine()!!.split(""""""\s+"""""".toRegex()).map { it.toInt()}    val res = (y-x)/(a+b)    val rem = (y-x) % (a+b)    println(if(rem == 0) res else -1)  }}",math
"import java.util.* fun main(s: Array<String>) {    val t = readLine()!!.toInt()    for (_i in 0 until t) {        val (x, y, a, b) = readLine()!!.split(' ').map { it.toInt() }        println(if ((y - x) % (a + b) == 0) (y - x) / (a + b) else -1)    }}",math
"//package codeforces.round614 fun main() {	val n = readInt()	val nei = List(n) { mutableListOf<Int>() }	repeat(n - 1) {		val (a, b) = readInts().map { it - 1 }		nei[a].add(b); nei[b].add(a)	}	val par = List(n) { IntArray(n) { -1 } }	val count = List(n) { IntArray(n) { 1 } }	for (root in nei.indices) {		fun dfs(u: Int, p: Int) {			par[root][u] = p			for (v in nei[u]) if (v != p) {				dfs(v, u)				count[root][u] += count[root][v]			}		}		dfs(root, -1)	}	val a = List(n) { LongArray(n) { -1 } }	fun solve(u: Int, v: Int): Long {		if (u == v) return 0		if (a[u][v] == -1L) a[u][v] = maxOf(solve(par[v][u], v), solve(u, par[u][v])) + count[v][u] * count[u][v]		return a[u][v]	}	println(nei.indices.map { u -> nei.indices.map { v -> solve(u, v) }.max()!! }.max())} private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","combinatorics,dfs and similar,dp,greedy,trees"
"fun main() {	val n = readInt()	val nei = List(n) { mutableListOf<Int>() }	repeat(n - 1) {		val (a, b) = readInts().map { it - 1 }		nei[a].add(b); nei[b].add(a)	}	val par = List(n) { IntArray(n) { 0 } }	val count = List(n) { IntArray(n) { 1 } }	fun dfs(root: Int, u: Int, p: Int = -1) {		par[root][u] = p		for (v in nei[u]) {			if (v == p) continue			dfs(root, v, u)			count[root][u] += count[root][v]		}	}	for (u in nei.indices) {		dfs(u, u)	}	val solve = List(n) { LongArray(n) { -1 } }	fun solve(u: Int, v: Int) {		if (u == v) solve[u][v] = 0		if (solve[u][v] != -1L) return		val uu = par[v][u]; val vv = par[u][v]		solve(uu, v); solve(u, vv)		solve[u][v] = maxOf(solve[uu][v], solve[u][vv]) + count[v][u] * count[u][v]	}	var best = 0L	for (u in nei.indices) {		for (v in nei.indices) {			solve(u, v)			best = maxOf(best, solve[u][v])		}	}	println(best)} private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","combinatorics,dfs and similar,dp,greedy,trees"
"//package codeforces.round614 fun main() {	val n = readInt()	val nei = List(n) { mutableListOf<Int>() }	repeat(n - 1) {		val (a, b) = readInts().map { it - 1 }		nei[a].add(b); nei[b].add(a)	}	val par = List(n) { IntArray(n) { -1 } }	val count = List(n) { IntArray(n) { 1 } }	for (root in nei.indices) {		fun dfs(u: Int) {			for (v in nei[u]) if (v != par[root][u]) {				par[root][v] = u				dfs(v)				count[root][u] += count[root][v]			}		}		dfs(root)	}	val solve = List(n) { LongArray(n) { -1 } }	fun solve(u: Int, v: Int) {		if (u == v) solve[u][v] = 0		if (solve[u][v] != -1L) return		val uu = par[v][u]; val vv = par[u][v]		solve(uu, v); solve(u, vv)		solve[u][v] = maxOf(solve[uu][v], solve[u][vv]) + count[v][u] * count[u][v]	}	var best = 0L	for (u in nei.indices) {		for (v in nei.indices) {			solve(u, v)			best = maxOf(best, solve[u][v])		}	}	println(best)} private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","combinatorics,dfs and similar,dp,greedy,trees"
"//package codeforces.round614 fun main() {	val n = readInt()	val nei = List(n) { mutableListOf<Int>() }	repeat(n - 1) {		val (a, b) = readInts().map { it - 1 }		nei[a].add(b); nei[b].add(a)	}	val par = List(n) { IntArray(n) { -1 } }	val count = List(n) { IntArray(n) { 1 } }	for (root in nei.indices) {		fun dfs(u: Int, p: Int) {			par[root][u] = p			for (v in nei[u]) if (v != p) {				dfs(v, u)				count[root][u] += count[root][v]			}		}		dfs(root, -1)	}	val solve = List(n) { LongArray(n) { -1 } }	fun solve(u: Int, v: Int) {		if (u == v) solve[u][v] = 0		if (solve[u][v] != -1L) return		val uu = par[v][u]; val vv = par[u][v]		solve(uu, v); solve(u, vv)		solve[u][v] = maxOf(solve[uu][v], solve[u][vv]) + count[v][u] * count[u][v]	}	var best = 0L	for (u in nei.indices) {		for (v in nei.indices) {			solve(u, v)			best = maxOf(best, solve[u][v])		}	}	println(best)} private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","combinatorics,dfs and similar,dp,greedy,trees"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"")@file:OptIn(ExperimentalStdlibApi::class) import java.io.PrintWriterimport java.util.PriorityQueueimport kotlin.math.*import kotlin.random.Randomimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {//    val startTime = System.nanoTime()     val numCases = 1//readInt()    case@ for(case in 1..numCases) {//        print(""Case #$case: "")         val n1 = readInt()        val n2 = readInt()        val m = readInt()        val r = readInt()        val b = readInt()         // colors of vertices        val L = read()        val R = read()         val s = n1+n2        val t = s+1        val sp = t+1        val tp = sp+1        val G = MinCostFlow(tp+1)         // edges from input => two trans-edges in MCF        // index i+i for red (L->R), i+i+1 for blue (L<-R)         repeat(m) {            val u = readInt()-1            val v = n1 + readInt()-1             G.addEdge(u, v, 1, r)            G.addEdge(v, u, 1, b)        }         var reqs = 0        var reqt = 0         // source and sink edges        // https://cp-algorithms.com/graph/flow_with_demands.html        for(i in 0 until n1) {            when(L[i]) {                'R' -> {                    G.addEdge(sp, i, 1, 0)                    reqs++                    G.addEdge(s, i, inf-1, 0)                }                'B' -> {                    G.addEdge(i, tp, 1, 0)                    reqt++                    G.addEdge(i, t, inf-1, 0)                }                else -> {                    G.addEdge(s, i, inf, 0)                    G.addEdge(i, t, inf, 0)                }            }        }         for(i in n1 until n1+n2) {            when(R[i-n1]) {                'B' -> {                    G.addEdge(sp, i, 1, 0)                    reqs++                    G.addEdge(s, i, inf-1, 0)                }                'R' -> {                    G.addEdge(i, tp, 1, 0)                    reqt++                    G.addEdge(i, t, inf-1, 0)                }                else -> {                    G.addEdge(s, i, inf, 0)                    G.addEdge(i, t, inf, 0)                }            }        }         G.addEdge(t, s, inf, 0)        G.addEdge(s, tp, reqs, 0)        G.addEdge(sp, t, reqt, 0)        val req = reqs + reqt         val (flow, cost) = G.flow(sp, tp, req)        val ok = flow == req         if(!ok) println(-1)        else {            println(cost)             val ans = CharArray(m) { i ->                when {                    G.getEdge(i+i).flow != 0 -> 'R'                    G.getEdge(i+i+1).flow != 0 -> 'B'                    else -> 'U'                }            }             println(ans)        }    } //    iprintln(""Time: ${(System.nanoTime() - startTime) / 1000000} ms"")} const val inf = Int.MAX_VALUE / 2 typealias Cap = Inttypealias Cost = Int typealias CostArray = IntArray const val Cap_MAX = Cap.MAX_VALUEconst val Cost_MAX = Cost.MAX_VALUEconst val Cap_0: Cap = 0const val Cost_0: Cost = 0 class MinCostFlow(val n: Int) {     data class Edge(val from: Int, val to: Int, val cap: Cap, val flow: Cap, val cost: Cost)    data class FlowResult(val flow: Cap, val cost: Cost)     private class _Edge(val to: Int, var cap: Cap, val cost: Cost) {        lateinit var rev: _Edge    }    private data class Q(val key: Cost, val to: Int): Comparable<Q> {        override fun compareTo(other: Q): Int = key.compareTo(other.key)    }     private val edges = mutableListOf<_Edge>()    private val g = Array(n) { mutableListOf<_Edge>() }     fun addEdge(from: Int, to: Int, cap: Cap, cost: Cost): Int {        val m = edges.size        val e = _Edge(to, cap, cost)        val re = _Edge(from, Cap_0, -cost)        e.rev = re        re.rev = e        edges.add(e)        g[from].add(e)        g[to].add(re)        return m    }     fun getEdge(i: Int): Edge {        val e = edges[i]        val re = e.rev        return Edge(re.to, e.to, e.cap + re.cap, re.cap, e.cost)    }     val numEdges get() = edges.size    fun edges(): List<Edge> = List(numEdges) { getEdge(it) }     fun flow(s: Int, t: Int, flowLimit: Cap = Cap_MAX) = slope(s, t, flowLimit).last()     fun slope(s: Int, t: Int, flowLimit: Cap = Cap_MAX): List<FlowResult> {        // variants (C = maxcost):        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge         val dual = CostArray(n)         var flow = Cap_0        var cost = Cost_0        var prevCostPerFlow = Cost_0-1        val result = mutableListOf(FlowResult(flow, cost))        while(flow < flowLimit) {            val pv = IntArray(n) { -1 }            val pe = arrayOfNulls<_Edge>(n)             val dualRef = run {                val dist = CostArray(n) { Cost_MAX }                val vis = BooleanArray(n) { false }                 val que = PriorityQueue<Q>()                dist[s] = Cost_0                que.add(Q(Cost_0, s))                while(que.isNotEmpty()) {                    val v = que.remove().to                    if(vis[v]) continue                    vis[v] = true                    if(v == t) break                    // dist[v] = shortest(s, v) + dual[s] - dual[v]                    // dist[v] >= 0 (all reduced cost are positive)                    // dist[v] <= (n-1)C                    for(e in g[v]) {                        if(vis[e.to] || e.cap == Cap_0) continue                        // |-dual[e.to] + dual[v]| <= (n-1)C                        // cost <= C - -(n-1)C + 0 = nC                        @Suppress(""NAME_SHADOWING"")                        val cost = e.cost - dual[e.to] + dual[v]                        if(dist[e.to] - dist[v] > cost) {                            dist[e.to] = dist[v] + cost                            pv[e.to] = v                            pe[e.to] = e                            que.add(Q(dist[e.to], e.to))                        }                    }                }                if (!vis[t]) return@run false                 // dual[v] = dual[v] - dist[t] + dist[v]                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])                //         = - shortest(s, t) + dual[t] + shortest(s, v)                //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C                for (v in 0 until n) if(vis[v]) dual[v] -= dist[t] - dist[v]                 true            }            if(!dualRef) break            var c = flowLimit - flow            var v = t            while(v != s) {                c = min(c, pe[v]!!.cap)                v = pv[v]            }            v = t            while(v != s) {                val e = pe[v]!!                e.cap -= c                e.rev.cap += c                v = pv[v]            }            val d = -dual[s]            flow += c            cost += c * d            if(prevCostPerFlow == d) {                result.removeAt(result.lastIndex)            }            result.add(FlowResult(flow, cost))            prevCostPerFlow = d        }         return result    }} /** IO *///const val PATH = ""src/main/resources/""//@JvmField val INPUT = File(PATH + ""input.txt"").inputStream()//@JvmField val OUTPUT = File(PATH + ""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar()        else c    }} fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(c != '\n' && c != Char.MIN_VALUE) {            append(c)            c = readChar()        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /**  sort overrides to avoid quicksort attacks */ @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } fun IntArray.sort() { shuffle(random); _sort() }fun IntArray.sortDescending() { shuffle(random); _sortDescending() } fun LongArray.sort() { shuffle(random); _sort() }fun LongArray.sortDescending() { shuffle(random); _sortDescending() } fun DoubleArray.sort() { shuffle(random); _sort() }fun DoubleArray.sortDescending() { shuffle(random); _sortDescending() } inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T: Comparable<T>> Array<out T>.sort() = _sort()inline fun <T: Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T: Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T: Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() fun `please stop removing these imports IntelliJ`() { iprintln(max(1, 2)) }","constructive algorithms,flows"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"")@file:OptIn(ExperimentalStdlibApi::class) import java.io.PrintWriterimport java.util.PriorityQueueimport kotlin.math.*import kotlin.random.Randomimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {//    val startTime = System.nanoTime()     val numCases = 1//readInt()    case@ for(case in 1..numCases) {//        print(""Case #$case: "")         val n1 = readInt()        val n2 = readInt()        val m = readInt()        val r = readInt()        val b = readInt()         // colors of vertices        val L = read()        val R = read()         val s = n1+n2        val t = s+1        val sp = t+1        val tp = sp+1        val G = MinCostFlow(tp+1)         // edges from input => two trans-edges in MCF        // index i+i for red (L->R), i+i+1 for blue (L<-R)         repeat(m) {            val u = readInt()-1            val v = n1 + readInt()-1             G.addEdge(u, v, 1, r)            G.addEdge(v, u, 1, b)        }         var req = 0         // source and sink edges        // https://cp-algorithms.com/graph/flow_with_demands.html        for(i in 0 until n1) {            when(L[i]) {                'R' -> {                    G.addEdge(sp, i, 1, 0)                    G.addEdge(s, tp, 1, 0)                    req++                    G.addEdge(s, i, inf-1, 0)                }                'B' -> {                    G.addEdge(sp, t, 1, 0)                    G.addEdge(i, tp, 1, 0)                    req++                    G.addEdge(i, t, inf-1, 0)                }                else -> {                    G.addEdge(s, i, inf, 0)                    G.addEdge(i, t, inf, 0)                }            }        }         for(i in n1 until n1+n2) {            when(R[i-n1]) {                'B' -> {                    G.addEdge(sp, i, 1, 0)                    G.addEdge(s, tp, 1, 0)                    req++                    G.addEdge(s, i, inf-1, 0)                }                'R' -> {                    G.addEdge(sp, t, 1, 0)                    G.addEdge(i, tp, 1, 0)                    req++                    G.addEdge(i, t, inf-1, 0)                }                else -> {                    G.addEdge(s, i, inf, 0)                    G.addEdge(i, t, inf, 0)                }            }        }         G.addEdge(t, s, inf, 0)          val (flow, cost) = G.flow(sp, tp, req)        val ok = flow == req         if(!ok) println(-1)        else {            println(cost)             val ans = CharArray(m) { 'U' }            for(i in 0 until m) {                if(G.getEdge(i+i).flow != 0) ans[i] = 'R'                else if(G.getEdge(i+i+1).flow != 0) ans[i] = 'B'            }             println(ans)        }    } //    iprintln(""Time: ${(System.nanoTime() - startTime) / 1000000} ms"")} const val inf = Int.MAX_VALUE / 2 typealias Cap = Inttypealias Cost = Int typealias CostArray = IntArray const val Cap_MAX = Cap.MAX_VALUEconst val Cost_MAX = Cost.MAX_VALUEconst val Cap_0: Cap = 0const val Cost_0: Cost = 0 class MinCostFlow(val n: Int) {     data class Edge(val from: Int, val to: Int, val cap: Cap, val flow: Cap, val cost: Cost)    data class FlowResult(val flow: Cap, val cost: Cost)     private class _Edge(val to: Int, var cap: Cap, val cost: Cost) {        lateinit var rev: _Edge    }    private data class Q(val key: Cost, val to: Int): Comparable<Q> {        override fun compareTo(other: Q): Int = key.compareTo(other.key)    }     private val edges = mutableListOf<_Edge>()    private val g = Array(n) { mutableListOf<_Edge>() }     fun addEdge(from: Int, to: Int, cap: Cap, cost: Cost): Int {        val m = edges.size        val e = _Edge(to, cap, cost)        val re = _Edge(from, Cap_0, -cost)        e.rev = re        re.rev = e        edges.add(e)        g[from].add(e)        g[to].add(re)        return m    }     fun getEdge(i: Int): Edge {        val e = edges[i]        val re = e.rev        return Edge(re.to, e.to, e.cap + re.cap, re.cap, e.cost)    }     val numEdges get() = edges.size    fun edges(): List<Edge> = List(numEdges) { getEdge(it) }     fun flow(s: Int, t: Int, flowLimit: Cap = Cap_MAX) = slope(s, t, flowLimit).last()     fun slope(s: Int, t: Int, flowLimit: Cap = Cap_MAX): List<FlowResult> {        // variants (C = maxcost):        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge         val dual = CostArray(n)         var flow = Cap_0        var cost = Cost_0        var prevCostPerFlow = Cost_0-1        val result = mutableListOf(FlowResult(flow, cost))        while(flow < flowLimit) {            val pv = IntArray(n) { -1 }            val pe = arrayOfNulls<_Edge>(n)             val dualRef = run {                val dist = CostArray(n) { Cost_MAX }                val vis = BooleanArray(n) { false }                 val que = PriorityQueue<Q>()                dist[s] = Cost_0                que.add(Q(Cost_0, s))                while(que.isNotEmpty()) {                    val v = que.remove().to                    if(vis[v]) continue                    vis[v] = true                    if(v == t) break                    // dist[v] = shortest(s, v) + dual[s] - dual[v]                    // dist[v] >= 0 (all reduced cost are positive)                    // dist[v] <= (n-1)C                    for(e in g[v]) {                        if(vis[e.to] || e.cap == Cap_0) continue                        // |-dual[e.to] + dual[v]| <= (n-1)C                        // cost <= C - -(n-1)C + 0 = nC                        @Suppress(""NAME_SHADOWING"")                        val cost = e.cost - dual[e.to] + dual[v]                        if(dist[e.to] - dist[v] > cost) {                            dist[e.to] = dist[v] + cost                            pv[e.to] = v                            pe[e.to] = e                            que.add(Q(dist[e.to], e.to))                        }                    }                }                if (!vis[t]) return@run false                 // dual[v] = dual[v] - dist[t] + dist[v]                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])                //         = - shortest(s, t) + dual[t] + shortest(s, v)                //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C                for (v in 0 until n) if(vis[v]) dual[v] -= dist[t] - dist[v]                 true            }            if(!dualRef) break            var c = flowLimit - flow            var v = t            while(v != s) {                c = min(c, pe[v]!!.cap)                v = pv[v]            }            v = t            while(v != s) {                val e = pe[v]!!                e.cap -= c                e.rev.cap += c                v = pv[v]            }            val d = -dual[s]            flow += c            cost += c * d            if(prevCostPerFlow == d) {                result.removeAt(result.lastIndex)            }            result.add(FlowResult(flow, cost))            prevCostPerFlow = d        }         return result    }} /** IO *///const val PATH = ""src/main/resources/""//@JvmField val INPUT = File(PATH + ""input.txt"").inputStream()//@JvmField val OUTPUT = File(PATH + ""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar()        else c    }} fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(c != '\n' && c != Char.MIN_VALUE) {            append(c)            c = readChar()        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /**  sort overrides to avoid quicksort attacks */ @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } fun IntArray.sort() { shuffle(random); _sort() }fun IntArray.sortDescending() { shuffle(random); _sortDescending() } fun LongArray.sort() { shuffle(random); _sort() }fun LongArray.sortDescending() { shuffle(random); _sortDescending() } fun DoubleArray.sort() { shuffle(random); _sort() }fun DoubleArray.sortDescending() { shuffle(random); _sortDescending() } inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T: Comparable<T>> Array<out T>.sort() = _sort()inline fun <T: Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T: Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T: Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() fun `please stop removing these imports IntelliJ`() { iprintln(max(1, 2)) }","constructive algorithms,flows"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"")@file:OptIn(ExperimentalStdlibApi::class) import java.io.PrintWriterimport java.util.PriorityQueueimport kotlin.math.*import kotlin.random.Randomimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {//    val startTime = System.nanoTime()     val numCases = 1//readInt()    case@ for(case in 1..numCases) {//        print(""Case #$case: "")         val n1 = readInt()        val n2 = readInt()        val m = readInt()        val r = readInt()        val b = readInt()         // colors of vertices        val L = read()        val R = read()         val s = n1+n2        val t = s+1        val sp = t+1        val tp = sp+1        val G = MinCostFlow(tp+1)         // edges from input => two trans-edges in MCF        // index i+i for red (L->R), i+i+1 for blue (L<-R)         repeat(m) {            val u = readInt()-1            val v = n1 + readInt()-1             G.addEdge(u, v, 1, r)            G.addEdge(v, u, 1, b)        }         var req = 0         // source and sink edges        // https://cp-algorithms.com/graph/flow_with_demands.html        for(i in 0 until n1) {            when(L[i]) {                'R' -> {                    G.addEdge(sp, i, 1, 0)                    G.addEdge(s, tp, 1, 0)                    req++                    G.addEdge(s, i, inf-1, 0)                }                'B' -> {                    G.addEdge(sp, t, 1, 0)                    G.addEdge(i, tp, 1, 0)                    req++                    G.addEdge(i, t, inf-1, 0)                }                else -> {                    G.addEdge(s, i, inf, 0)                    G.addEdge(i, t, inf, 0)                }            }        }         for(i in n1 until n1+n2) {            when(R[i-n1]) {                'B' -> {                    G.addEdge(sp, i, 1, 0)                    G.addEdge(s, tp, 1, 0)                    req++                    G.addEdge(s, i, inf-1, 0)                }                'R' -> {                    G.addEdge(sp, t, 1, 0)                    G.addEdge(i, tp, 1, 0)                    req++                    G.addEdge(i, t, inf-1, 0)                }                else -> {                    G.addEdge(s, i, inf, 0)                    G.addEdge(i, t, inf, 0)                }            }        }         G.addEdge(t, s, inf, 0)          val (flow, cost) = G.flow(sp, tp, req)        val ok = flow == req         if(!ok) println(-1)        else {            println(cost)             val ans = CharArray(m) { i ->                when {                    G.getEdge(i+i).flow != 0 -> 'R'                    G.getEdge(i+i+1).flow != 0 -> 'B'                    else -> 'U'                }            }             println(ans)        }    } //    iprintln(""Time: ${(System.nanoTime() - startTime) / 1000000} ms"")} const val inf = Int.MAX_VALUE / 2 typealias Cap = Inttypealias Cost = Int typealias CostArray = IntArray const val Cap_MAX = Cap.MAX_VALUEconst val Cost_MAX = Cost.MAX_VALUEconst val Cap_0: Cap = 0const val Cost_0: Cost = 0 class MinCostFlow(val n: Int) {     data class Edge(val from: Int, val to: Int, val cap: Cap, val flow: Cap, val cost: Cost)    data class FlowResult(val flow: Cap, val cost: Cost)     private class _Edge(val to: Int, var cap: Cap, val cost: Cost) {        lateinit var rev: _Edge    }    private data class Q(val key: Cost, val to: Int): Comparable<Q> {        override fun compareTo(other: Q): Int = key.compareTo(other.key)    }     private val edges = mutableListOf<_Edge>()    private val g = Array(n) { mutableListOf<_Edge>() }     fun addEdge(from: Int, to: Int, cap: Cap, cost: Cost): Int {        val m = edges.size        val e = _Edge(to, cap, cost)        val re = _Edge(from, Cap_0, -cost)        e.rev = re        re.rev = e        edges.add(e)        g[from].add(e)        g[to].add(re)        return m    }     fun getEdge(i: Int): Edge {        val e = edges[i]        val re = e.rev        return Edge(re.to, e.to, e.cap + re.cap, re.cap, e.cost)    }     val numEdges get() = edges.size    fun edges(): List<Edge> = List(numEdges) { getEdge(it) }     fun flow(s: Int, t: Int, flowLimit: Cap = Cap_MAX) = slope(s, t, flowLimit).last()     fun slope(s: Int, t: Int, flowLimit: Cap = Cap_MAX): List<FlowResult> {        // variants (C = maxcost):        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge         val dual = CostArray(n)         var flow = Cap_0        var cost = Cost_0        var prevCostPerFlow = Cost_0-1        val result = mutableListOf(FlowResult(flow, cost))        while(flow < flowLimit) {            val pv = IntArray(n) { -1 }            val pe = arrayOfNulls<_Edge>(n)             val dualRef = run {                val dist = CostArray(n) { Cost_MAX }                val vis = BooleanArray(n) { false }                 val que = PriorityQueue<Q>()                dist[s] = Cost_0                que.add(Q(Cost_0, s))                while(que.isNotEmpty()) {                    val v = que.remove().to                    if(vis[v]) continue                    vis[v] = true                    if(v == t) break                    // dist[v] = shortest(s, v) + dual[s] - dual[v]                    // dist[v] >= 0 (all reduced cost are positive)                    // dist[v] <= (n-1)C                    for(e in g[v]) {                        if(vis[e.to] || e.cap == Cap_0) continue                        // |-dual[e.to] + dual[v]| <= (n-1)C                        // cost <= C - -(n-1)C + 0 = nC                        @Suppress(""NAME_SHADOWING"")                        val cost = e.cost - dual[e.to] + dual[v]                        if(dist[e.to] - dist[v] > cost) {                            dist[e.to] = dist[v] + cost                            pv[e.to] = v                            pe[e.to] = e                            que.add(Q(dist[e.to], e.to))                        }                    }                }                if (!vis[t]) return@run false                 // dual[v] = dual[v] - dist[t] + dist[v]                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])                //         = - shortest(s, t) + dual[t] + shortest(s, v)                //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C                for (v in 0 until n) if(vis[v]) dual[v] -= dist[t] - dist[v]                 true            }            if(!dualRef) break            var c = flowLimit - flow            var v = t            while(v != s) {                c = min(c, pe[v]!!.cap)                v = pv[v]            }            v = t            while(v != s) {                val e = pe[v]!!                e.cap -= c                e.rev.cap += c                v = pv[v]            }            val d = -dual[s]            flow += c            cost += c * d            if(prevCostPerFlow == d) {                result.removeAt(result.lastIndex)            }            result.add(FlowResult(flow, cost))            prevCostPerFlow = d        }         return result    }} /** IO *///const val PATH = ""src/main/resources/""//@JvmField val INPUT = File(PATH + ""input.txt"").inputStream()//@JvmField val OUTPUT = File(PATH + ""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar()        else c    }} fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(c != '\n' && c != Char.MIN_VALUE) {            append(c)            c = readChar()        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /**  sort overrides to avoid quicksort attacks */ @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } fun IntArray.sort() { shuffle(random); _sort() }fun IntArray.sortDescending() { shuffle(random); _sortDescending() } fun LongArray.sort() { shuffle(random); _sort() }fun LongArray.sortDescending() { shuffle(random); _sortDescending() } fun DoubleArray.sort() { shuffle(random); _sort() }fun DoubleArray.sortDescending() { shuffle(random); _sortDescending() } inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T: Comparable<T>> Array<out T>.sort() = _sort()inline fun <T: Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T: Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T: Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() fun `please stop removing these imports IntelliJ`() { iprintln(max(1, 2)) }","constructive algorithms,flows"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"")@file:OptIn(ExperimentalStdlibApi::class) import java.io.PrintWriterimport java.util.PriorityQueueimport kotlin.math.*import kotlin.random.Randomimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {//    val startTime = System.nanoTime()     val numCases = 1//readInt()    case@ for(case in 1..numCases) {//        print(""Case #$case: "")         val n1 = readInt()        val n2 = readInt()        val m = readInt()        val r = readInt()        val b = readInt()         // colors of vertices        val L = read()        val R = read()         val s = n1+n2        val t = s+1        val sp = t+1        val tp = sp+1        val G = MinCostFlow(tp+1)         // edges from input => two trans-edges in MCF        // index i+i for red (L->R), i+i+1 for blue (L<-R)         repeat(m) {            val u = readInt()-1            val v = n1 + readInt()-1             G.addEdge(u, v, 1, r)            G.addEdge(v, u, 1, b)        }         var req = 0         // source and sink edges        // https://cp-algorithms.com/graph/flow_with_demands.html        for(i in 0 until n1) {            when(L[i]) {                'R' -> {                    G.addEdge(sp, i, 1, 0)                    G.addEdge(s, tp, 1, 0)                    req++                    G.addEdge(s, i, inf-1, 0)                }                'B' -> {                    G.addEdge(sp, t, 1, 0)                    G.addEdge(i, tp, 1, 0)                    req++                    G.addEdge(i, t, inf-1, 0)                }                else -> {                    G.addEdge(s, i, inf, 0)                    G.addEdge(i, t, inf, 0)                }            }        }         for(i in n1 until n1+n2) {            when(R[i-n1]) {                'B' -> {                    G.addEdge(sp, i, 1, 0)                    G.addEdge(s, tp, 1, 0)                    req++                    G.addEdge(s, i, inf-1, 0)                }                'R' -> {                    G.addEdge(sp, t, 1, 0)                    G.addEdge(i, tp, 1, 0)                    req++                    G.addEdge(i, t, inf-1, 0)                }                else -> {                    G.addEdge(s, i, inf, 0)                    G.addEdge(i, t, inf, 0)                }            }        }         G.addEdge(t, s, inf, 0)          val (flow, cost) = G.flow(sp, tp, req)        val ok = flow == req         if(!ok) println(-1)        else {            println(cost)             val ans = CharArray(m) { 'U' }            for(i in 0 until m) {                if(G.getEdge(i+i).flow != 0) ans[i] = 'R'                else if(G.getEdge(i+i+1).flow != 0) ans[i] = 'B'            }             println(ans)        }    } //    iprintln(""Time: ${(System.nanoTime() - startTime) / 1000000} ms"")} const val inf = Int.MAX_VALUE / 2 typealias Cap = Inttypealias Cost = Int typealias CostArray = IntArray const val Cap_MAX = Cap.MAX_VALUEconst val Cost_MAX = Cost.MAX_VALUEconst val Cap_0: Cap = 0const val Cost_0: Cost = 0 class MinCostFlow(val n: Int) {     data class Edge(val from: Int, val to: Int, val cap: Cap, val flow: Cap, val cost: Cost)    data class FlowResult(val flow: Cap, val cost: Cost)     private class _Edge(val from: Int, val to: Int, var cap: Cap, val cost: Cost) {        lateinit var rev: _Edge    }    private data class Q(val key: Cost, val to: Int): Comparable<Q> {        override fun compareTo(other: Q): Int = key.compareTo(other.key)    }     private val edges = mutableListOf<_Edge>()    private val g = Array(n) { mutableListOf<_Edge>() }     fun addEdge(from: Int, to: Int, cap: Cap, cost: Cost): Int {        val m = edges.size        val e = _Edge(from, to, cap, cost)        val re = _Edge(to, from, Cap_0, -cost)        e.rev = re        re.rev = e        edges.add(e)        g[from].add(e)        g[to].add(re)        return m    }     fun getEdge(i: Int): Edge {        val e = edges[i]        val re = e.rev        return Edge(e.from, e.to, e.cap + re.cap, re.cap, e.cost)    }     val numEdges get() = edges.size    fun edges(): List<Edge> = List(numEdges) { getEdge(it) }     fun flow(s: Int, t: Int, flowLimit: Cap = Cap_MAX) = slope(s, t, flowLimit).last()     fun slope(s: Int, t: Int, flowLimit: Cap = Cap_MAX): List<FlowResult> {        // variants (C = maxcost):        // -(n-1)C <= dual[s] <= dual[i] <= dual[t] = 0        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) >= 0 for all edge         val dual = CostArray(n)        val dist = CostArray(n)        val pv = IntArray(n)        val pe = IntArray(n)        val vis = BooleanArray(n)         var flow = Cap_0        var cost = Cost_0        var prevCostPerFlow = Cost_0-1        val result = mutableListOf(FlowResult(flow, cost))        while(flow < flowLimit) {            val dualRef = run {                dist.fill(Cost_MAX)                pv.fill(-1)                pe.fill(-1)                vis.fill(false)                 val que = PriorityQueue<Q>()                dist[s] = Cost_0                que.add(Q(Cost_0, s))                while(que.isNotEmpty()) {                    val v = que.remove().to                    if(vis[v]) continue                    vis[v] = true                    if(v == t) break                    // dist[v] = shortest(s, v) + dual[s] - dual[v]                    // dist[v] >= 0 (all reduced cost are positive)                    // dist[v] <= (n-1)C                    for(i in g[v].indices) {                        val e = g[v][i]                        if(vis[e.to] || e.cap == Cap_0) continue                        // |-dual[e.to] + dual[v]| <= (n-1)C                        // cost <= C - -(n-1)C + 0 = nC                        @Suppress(""NAME_SHADOWING"")                        val cost = e.cost - dual[e.to] + dual[v]                        if(dist[e.to] - dist[v] > cost) {                            dist[e.to] = dist[v] + cost                            pv[e.to] = v                            pe[e.to] = i                            que.add(Q(dist[e.to], e.to))                        }                    }                }                if (!vis[t]) return@run false                 // dual[v] = dual[v] - dist[t] + dist[v]                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) + (shortest(s, v) + dual[s] - dual[v])                //         = - shortest(s, t) + dual[t] + shortest(s, v)                //         = shortest(s, v) - shortest(s, t) >= 0 - (n-1)C                for (v in 0 until n) if(vis[v]) dual[v] -= dist[t] - dist[v]                 true            }            if(!dualRef) break            var c = flowLimit - flow            var v = t            while(v != s) {                c = min(c, g[pv[v]][pe[v]].cap)                v = pv[v]            }            v = t            while(v != s) {                val e = g[pv[v]][pe[v]]                e.cap -= c                e.rev.cap += c                v = pv[v]            }            val d = -dual[s]            flow += c            cost += c * d            if(prevCostPerFlow == d) {                result.removeAt(result.lastIndex)            }            result.add(FlowResult(flow, cost))            prevCostPerFlow = d        }         return result    }} /** IO *///const val PATH = ""src/main/resources/""//@JvmField val INPUT = File(PATH + ""input.txt"").inputStream()//@JvmField val OUTPUT = File(PATH + ""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar()        else c    }} fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(c != '\n' && c != Char.MIN_VALUE) {            append(c)            c = readChar()        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /**  sort overrides to avoid quicksort attacks */ @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } fun IntArray.sort() { shuffle(random); _sort() }fun IntArray.sortDescending() { shuffle(random); _sortDescending() } fun LongArray.sort() { shuffle(random); _sort() }fun LongArray.sortDescending() { shuffle(random); _sortDescending() } fun DoubleArray.sort() { shuffle(random); _sort() }fun DoubleArray.sortDescending() { shuffle(random); _sortDescending() } inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T: Comparable<T>> Array<out T>.sort() = _sort()inline fun <T: Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T: Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T: Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() fun `please stop removing these imports IntelliJ`() { iprintln(max(1, 2)) }","constructive algorithms,flows"
"import kotlin.math.max fun main() {    val t = readInt()     repeat(t) {        readInts()        val nums = readInts()        val indices = nums.mapIndexed { index, num -> num to index }.toMap()        val toRemove = readInts()        var maxRemoved = 0        var removedSoFar = 0        var steps = 0L        toRemove.forEach { num ->            val index = indices[num] ?: error(""o o"")            if (index < maxRemoved) steps++            else steps += 2*(index - removedSoFar) + 1            maxRemoved = max(index, maxRemoved)            removedSoFar++        }         println(steps)    }} // Input Readerprivate fun readLn() = readLine()!! private fun readStrings() = readLn().split("" "")private fun readInt() = readLn().toInt()private fun readInts() = readStrings().map { it.toInt() }","data structures,implementation"
"fun main() {    fun readInt() = readLine()!!.toInt()    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val numQueries = readInt()    val sols = LongArray(numQueries)    for (query in 0 until numQueries) {        readLine()        val presents = readInts()        var start = 0        val presentsToSend = readInts()        val sorted = mutableSetOf<Int>()        for (presentToSend in presentsToSend) {            if (presentToSend in sorted) {                sols[query] += 1L                sorted.remove(presentToSend)            } else {                start--                while(presents[++start] != presentToSend)                    sorted.add(presents[start])                sols[query] += 2L * sorted.size + 1                start++            }        }    }    print(sols.joinToString(System.lineSeparator()))}","data structures,implementation"
import java.lang.Math.ceilimport java.lang.Math.sqrtimport java.util.*import kotlin.math.sign fun main() {    val reader = Scanner(System.`in`)     val t = reader.nextLong()     for (i in 0 until t) {        val n = reader.nextInt()        val m = reader.nextInt()         val a = IntArray(n) { reader.nextInt() }        val b = IntArray(m) { reader.nextInt() }         var totalTime = 0L        var j = 0        val sorted = mutableSetOf<Int>()        for (item in b) {            // Find item            if (sorted.contains(item)) {                sorted.remove(item)                ++totalTime                continue            }            totalTime += sorted.size * 2            while (a[j] != item) {                sorted.add(a[j])                totalTime += 2                ++j            }            totalTime += 1            ++j        }        println(totalTime)    }} ,"data structures,implementation"
"import java.lang.StringBuilderimport java.math.BigIntegerimport java.util.*import kotlin.collections.HashMapimport kotlin.math.min fun main() {    val t = readLine()!!.toInt()     val builder = StringBuilder()     for (p in 0 until t) {        var (n, m) = readLine()!!.split(' ').map { it.toInt() }         val a = readLine()!!.split(' ').map { it.toInt() - 1 }.toIntArray()         val b = readLine()!!.split(' ').map { it.toInt() - 1 }.toIntArray()         val cache = HashMap<Int, Int>()         for (i in 0 until n) {            cache[a[i]] = i        }         var result = 0.toBigInteger()        var i = 0        var mx = -1         while (i < m) {            val curr = cache[b[i]]!!             if(curr > mx) {                mx = curr                result += (2 * (curr - i) + 1).toBigInteger()            } else {                result++            }             i++        }         builder.append(result, '\n')    }     println(builder.toString())}","data structures,implementation"
"import java.util.* fun main() {     val n = readInt()    val a = readInts()    val g = Array<MutableList<Int>>(n) { mutableListOf() }    val (even, odd) = a.mapIndexed { index, num -> Pair(index, num) }.partition { it .second % 2 == 0 }    for (i in 0 until n) {        val left = i - a[i]        val right = i + a[i]        if (left in a.indices) g[left].add(i)        if (right in a.indices) g[right].add(i)    }     val ans = IntArray(n) { -1 }     fun bfs(start: List<Pair<Int, Int>>, end: List<Pair<Int, Int>>) {        val d = IntArray(n) { Int.MAX_VALUE }        val queue = LinkedList<Int>()        start.forEach { pair ->            d[pair.first] = 0            queue.add(pair.first)        }         while (queue.isNotEmpty()) {            val curr = queue.removeFirst()            for (v in g[curr]) {                if (d[v] == Int.MAX_VALUE) {                    d[v] = 1 + d[curr]                    queue.add(v)                }            }        }         end.forEach { pair ->            if (d[pair.first] != Int.MAX_VALUE) {                ans[pair.first] = d[pair.first]            }        }    }     bfs(odd, even)    bfs(even, odd)    println(ans.joinToString("" ""))} // Input Readerprivate fun readLn() = readLine()!! private fun readStrings() = readLn().trim().split("" "")private fun readInt() = readLn().toInt()private fun readInts() = readStrings().map { it.toInt() }","dfs and similar,graphs,shortest paths"
"import java.util.*import kotlin.collections.ArrayList data class Vertex (val neighbours: ArrayList<Int> = arrayListOf()) data class Graph(val n: Int) {    private val vertices = Array(n) { Vertex() }     private fun validVertex(a: Int) = a in 0 until n     fun addEdge(a: Int, b: Int) {        if(!validVertex(a) || !validVertex(b)) return        vertices[b].neighbours.add(a)    }     fun bfs(dist: IntArray) {        val q = LinkedList<Int>()         for(i in dist.indices) if(dist[i] == 0) q.addLast(i)         while(q.isNotEmpty()) {            val u = q.pollFirst()            for(v in vertices[u].neighbours) {                if(dist[u] + 1 < dist[v]) {                    dist[v] = dist[u] + 1                    q.addLast(v)                }            }        }    }} const val INF = 1_000_000_000 fun castToAnswer(a: Int, b: Int): String = if(a == INF || b == INF) ""-1"" else Math.max(a, b).toString() fun main() {    val n = readLine()!!.toInt()    val a = readLine()!!.split("" "").map { it.toInt() }    val g = Graph(n)     for (i in 0 until n) {        g.addEdge(i, i+a[i])        g.addEdge(i, i-a[i])    }     val pars_dist = a.map { if(it % 2 == 0) 0 else INF}.toIntArray()    val impars_dist = a.map { if(it % 2 == 0) INF else 0}.toIntArray()     g.bfs(pars_dist)    g.bfs(impars_dist)     val ans = (pars_dist zip impars_dist).map { castToAnswer(it.first, it.second) }.joinToString("" "")    println(ans)}","dfs and similar,graphs,shortest paths"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.*import kotlin.collections.ArrayListimport kotlin.collections.HashMap fun sameParity (x: Int, y: Int): Boolean = x and 1 == y and 1 fun bfs (a: List<Int>, G: HashMap<Int, ArrayList<Int>>): Array<Int> {    val n = a.size    val queue: Queue<Int> = LinkedList()    val ans = Array(n){-1}    for ((a_i, i) in a.zip(a.indices)) {        if (i + a_i < n && !sameParity(a_i, a[i + a_i]) ||            i - a_i >= 0 && !sameParity(a_i, a[i - a_i])){            ans[i] = 1            queue.add(i)        }    }     while (queue.isNotEmpty()) {        val v = queue.remove()        if (G.containsKey(v)){            for (u in G[v]!!) {                if (ans[u] == -1) {                    ans[u] = ans[v] + 1                    queue.add(u)                }            }        }    }    return ans} fun main () {    val br = BufferedReader(InputStreamReader(System.`in`))    val n = br.readLine().toInt()    val a = br.readLine().split("" "").map { it.toInt() }    val G = HashMap<Int, ArrayList<Int>>()     for ((a_i, i) in a.zip(a.indices)) {        if (i + a_i < n && sameParity(a_i, a[i + a_i])){            G[i + a_i] = G.getOrDefault(i + a_i, ArrayList()).apply { add(i) }        }        if (i - a_i >= 0 && sameParity(a_i, a[i - a_i])) {            G[i - a_i] = G.getOrDefault(i - a_i, ArrayList()).apply { add(i) }        }    }     println(bfs(a, G).joinToString("" ""))}","dfs and similar,graphs,shortest paths"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.* fun main(args: Array<String>) {    val sc = FastScanner(System.`in`)    val n = sc.nextInt()    val tree = Array(n) { Vertex(it) }     repeat(n) { i ->        val v = tree[i]        v.a = sc.nextInt()        if (i - v.a in tree.indices) {            v.to.add(tree[i - v.a])            tree[i - v.a].from.add(v)        }        if (i + v.a in tree.indices) {            v.to.add(tree[i + v.a])            tree[i + v.a].from.add(v)        }    }     val bfs = LinkedList<Vertex>()    for (v in tree) {        for (u in v.to) {            if ((v.a + u.a) % 2 == 1) {                v.solution = 1                bfs.add(v)            }        }    }    while(!bfs.isEmpty()) {        val v = bfs.poll()        for(u in v.from) {            if(u.solution == -1) {                u.solution = v.solution + 1                bfs.add(u)            }        }    }     println(tree.joinToString("" "") { it.solution.toString() })} class Vertex(val n: Int) {    var solution: Int = -1     var a: Int = 0    val to = mutableSetOf<Vertex>()    val from = mutableSetOf<Vertex>()} class FastScanner(s: InputStream) {    private var st = StringTokenizer("""")    private val br = BufferedReader(InputStreamReader(s))     fun next(): String {        while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun nextInt() = next().toInt()    fun nextLong() = next().toLong()    fun nextLine() = br.readLine()    fun nextDouble() = next().toDouble()    fun ready() = br.ready()}","dfs and similar,graphs,shortest paths"
"import java.io.PrintWriterimport java.util.*import kotlin.math.* fun PrintWriter.solve() {    val s = nextLine()    val n = s.length    val dp = Array(n) { Array(n) { ModInt(0) } }    val calculated = Array(n) { BooleanArray(n) { false } }    val pow2 = Array(n + 1) { ModInt(1) }    val q = IntArray(n + 1) { 0 }    for (i in 0 until n) {        pow2[i + 1] = pow2[i] * ModInt(2)    }    for (i in 0 until n) {        q[i + 1] = q[i] + if (s[i] == '?') 1 else 0    }    fun f(i: Int, j: Int): ModInt {        if (i >= j) {            return ModInt(0)        }        if (calculated[i][j]) {            return dp[i][j]        }        var ret = ModInt(0)        if (s[i] != '(') {            ret += f(i + 1, j)        }        if (s[j] != ')') {            ret += f(i, j - 1)        }        if (s[i] != '(' && s[j] != ')') {            ret -= f(i + 1, j - 1)        }        if (s[i] != ')' && s[j] != '(') {            ret += f(i + 1, j - 1) + pow2[q[j] - q[i + 1]]        }        dp[i][j] = ret        calculated[i][j] = true        return ret    }    println(f(0, n - 1))} // region ModIntclass ModInt(x: Long) {    companion object {        //const val MOD = 1000000007L        const val MOD = 998244353L    }     constructor(y: Int) : this(y.toLong())     val x = (x % MOD + MOD) % MOD     operator fun plus(other: ModInt): ModInt {        return ModInt(x + other.x)    }     operator fun minus(other: ModInt): ModInt {        return ModInt(x - other.x)    }     operator fun times(other: ModInt): ModInt {        return ModInt(x * other.x)    }     operator fun div(other: ModInt): ModInt {        return this * other.inv()    }     fun pow(exp: Long): ModInt {        if (exp == 0L) return ModInt(1L)        var a = pow(exp shr 1)        a *= a        if (exp and 1L == 0L) return a        return this * a    }     fun inv(): ModInt {        return this.pow(MOD - 2)    }     override fun equals(other: Any?): Boolean {        if (this === other) return true        if (javaClass != other?.javaClass) return false         other as ModInt         if (x != other.x) return false         return true    }     override fun hashCode(): Int {        return x.hashCode()    }     override fun toString(): String {        return ""$x""    }} fun Long.toModInt(): ModInt {    return ModInt(this)} fun Int.toModInt(): ModInt {    return ModInt(this)} fun binomSimple(n: Long, k: Long): ModInt {    var numer = ModInt(1)    var denom = ModInt(1)    for (i in 0 until k) {        numer *= ModInt(n - i)        denom *= ModInt(k - i)    }    return numer / denom}// endregion fun main() {    Thread(null, {        val writer = PrintWriter(System.out, false)        writer.solve()        writer.flush()    }, ""solve"", 1.shl(26))        .apply { setUncaughtExceptionHandler { _, e -> e.printStackTrace(); kotlin.system.exitProcess(1) } }        .apply { start() }.join()} // region Scannerprivate var st = StringTokenizer("""")private val br = System.`in`.bufferedReader() fun next(): String {    while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())    return st.nextToken()} fun nextInt() = next().toInt()fun nextLong() = next().toLong()fun nextLine() = br.readLine()fun nextDouble() = next().toDouble()// endregion","combinatorics,dp,probabilities"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"") import java.io.PrintWriterimport java.util.StringTokenizerimport kotlin.math.*import kotlin.random.*import kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() {    output {        val a = readLn()        val n = a.length        val D = List(n) { ModIntArray(n - it + 1) }        val K = IntArray(n+1)        for(i in 0 until n) {            K[i+1] = K[i]            if(a[i] == '?') K[i+1]++        }         for (len in 2..n) {            for (i in 0..n-len) {                val al = a[i]                val ar = a[i + len - 1]                 if(al != '(') D[i][len] += D[i+1][len-1]                if(ar != ')') D[i][len] += D[i][len-1]                if(al != '(' && ar != ')') D[i][len] -= D[i+1][len-2]                if(al != ')' && ar != '(') D[i][len] += D[i+1][len-2] + ModInt(2).pow(K[i+len-1] - K[i+1])            }        }         val ans = D[0][n]        println(ans.int)    }} const val MODINT_BASE = 998244353const val MODINT_TOTIENT = MODINT_BASE - 1 // assumes MODINT_BASE is prime inline infix fun Int.umod(base: Int) = Math.floorMod(this, base)inline infix fun Long.umod(base: Long) = Math.floorMod(this, base)inline infix fun Long.umod(base: Int) = Math.floorMod(this, base.toLong()).toInt() fun Int.mulMod(other: Int, mod: Int) = (toLong() * other).umod(mod) fun Int.powMod(exponent: Int, mod: Int): Int {    if(exponent < 0) error(""Inverse not implemented"")    var res = 1L    var e = exponent    var b = umod(mod).toLong()     while(e > 0) {        if(e and 1 == 1) {            res = res * b % mod        }        e = e shr 1        b = b * b % mod    }    return res.toInt()} inline fun Int.toModInt() = ModInt(this umod MODINT_BASE)inline fun Long.toModInt() = ModInt(this umod MODINT_BASE) /** note: Only use constructor for int within modulo range, otherwise use toModInt **/inline class ModInt( val int: Int) {    companion object {        /** can't seem to make these private or inlined without causing compiler issues */        @JvmField val _invMemo = HashMap<ModInt, ModInt>()        fun _invMemoized(m: ModInt) = _invMemo.getOrPut(m) { m.inv_unmemoized() }    }     operator fun plus(other: ModInt) = // MODINT_BASE < 2^30        (int + other.int).let { if(it >= MODINT_BASE) ModInt(it - MODINT_BASE) else ModInt(it) }    inline operator fun plus(other: Int) = plus(other.toModInt())    operator fun inc() = if(int == MODINT_BASE - 1) ModInt(0) else ModInt(int + 1)     operator fun minus(other: ModInt) =        (int - other.int).let { if(it < 0) ModInt(it + MODINT_BASE) else ModInt(it) }    inline operator fun minus(other: Int) = minus(other.toModInt())    operator fun dec() = if(int == 0) ModInt(MODINT_BASE - 1) else ModInt(int - 1)    operator fun unaryMinus() = if(int == 0) this else ModInt(MODINT_BASE - int)     inline operator fun times(other: ModInt) = times(other.int)    inline operator fun times(other: Int) = ModInt(int.mulMod(other, MODINT_BASE))     fun pow(exponent: Int): ModInt {        val e = if(exponent < 0) {            require(int != 0) { ""Can't invert/divide by 0"" }            exponent umod MODINT_TOTIENT        } else exponent        return ModInt(int.powMod(e, MODINT_BASE))    }     fun pow(exponent: Long) = if(int == 0) when {        exponent > 0 -> this        exponent == 0L -> ModInt(1)        else -> error(""Can't invert/divide by 0"")    } else pow(exponent umod MODINT_TOTIENT)     inline fun inverse() = inv_memoized() /** NOTE: Change if necessary */     fun inv_unmemoized(): ModInt {        require(int != 0) { ""Can't invert/divide by 0"" }        return pow(MODINT_TOTIENT - 1)    }    inline fun inv_memoized() = _invMemoized(this)     operator fun div(other: ModInt) = times(other.inverse())    inline operator fun div(other: Int) = div(other.toModInt())     override inline fun toString() = int.toString()} inline class ModIntArray(val intArray: IntArray): Collection<ModInt> {    inline operator fun get(i: Int) = ModInt(intArray[i])    inline operator fun set(i: Int, v: ModInt) { intArray[i] = v.int }     override inline val size: Int get() = intArray.size    inline val lastIndex get() = intArray.lastIndex    inline val indices get() = intArray.indices     override inline fun contains(element: ModInt): Boolean = element.int in intArray     override fun containsAll(elements: Collection<ModInt>): Boolean = elements.all(::contains)     override inline fun isEmpty(): Boolean = intArray.isEmpty()     override fun iterator(): Iterator<ModInt> = object: Iterator<ModInt> {        var index = 0        override fun hasNext(): Boolean = index < size        override fun next(): ModInt = get(index++)    }     fun sum() = indices.sumByModInt(::get)    fun product() = indices.productByModInt(::get)}fun ModIntArray(capacity: Int) = ModIntArray(IntArray(capacity))inline fun ModIntArray(capacity: Int, init: (Int) -> ModInt) =    ModIntArray(IntArray(capacity) { init(it).int }) inline fun <T> Iterable<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Iterable<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }inline fun <T> Sequence<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Sequence<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }fun Iterable<ModInt>.sum() = sumByModInt { it }fun Sequence<ModInt>.sum() = sumByModInt { it }fun Iterable<ModInt>.product() = productByModInt { it }fun Sequence<ModInt>.product() = productByModInt { it } /** IO code start *///@JvmField val INPUT = File(""input.txt"").inputStream()//@JvmField val OUTPUT = File(""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out @JvmField val _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false)inline fun output(block: PrintWriter.() -> Unit) { _writer.apply(block).flush() } /** shuffles and sort overrides to avoid quicksort attacks */private inline fun <R, V> R._shuffle(rnd: Random, get: R.(Int) -> V, set: R.(Int, V) -> Unit, size: Int) {    // Fisher-Yates shuffle algorithm    for (i in size - 1 downTo 1) {        val j = rnd.nextInt(i + 1)        val temp = get(i)        set(i, get(j))        set(j, temp)    }} @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } fun IntArray.shuffle(rnd: Random = random) = _shuffle(rnd, IntArray::get, IntArray::set, size)fun IntArray.sort() { shuffle(); _sort() }fun IntArray.sortDescending() { shuffle(); _sortDescending() } fun LongArray.shuffle(rnd: Random = random) = _shuffle(rnd, LongArray::get, LongArray::set, size)fun LongArray.sort() { shuffle(); _sort() }fun LongArray.sortDescending() { shuffle(); _sortDescending() } fun DoubleArray.shuffle(rnd: Random = random) = _shuffle(rnd, DoubleArray::get, DoubleArray::set, size)fun DoubleArray.sort() { shuffle(); _sort() }fun DoubleArray.sortDescending() { shuffle(); _sortDescending() } fun CharArray.shuffle(rnd: Random = random) = _shuffle(rnd, CharArray::get, CharArray::set, size)inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T: Comparable<T>> Array<out T>.sort() = _sort()inline fun <T: Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T: Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T: Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() fun `please stop removing these imports IntelliJ`() {    iprintln(max(1, 2))}","combinatorics,dp,probabilities"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"") import java.io.PrintWriterimport java.util.StringTokenizerimport java.util.TreeSetimport kotlin.math.*import kotlin.random.*import kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() {    output {        val a = readLn()        val n = a.length        val D = List(n) { ModIntArray(n - it + 1) }        val K = IntArray(n+1)        for(i in 0 until n) {            K[i+1] = K[i]            if(a[i] == '?') K[i+1]++        }         val twoPow = ModIntArray(n+1)        twoPow[0] = ModInt(1)        for(i in 1..n) twoPow[i] = twoPow[i-1] * 2         for (len in 2..n) {            for (i in 0..n-len) {                val al = a[i]                val ar = a[i + len - 1]                 if(al != '(') D[i][len] += D[i+1][len-1]                if(ar != ')') D[i][len] += D[i][len-1]                if(al != '(' && ar != ')') D[i][len] -= D[i+1][len-2]                if(al != ')' && ar != '(') D[i][len] += D[i+1][len-2] + twoPow[K[i+len-1] - K[i+1]]            }        }         val ans = D[0][n]        println(ans.int)    }} const val MODINT_BASE = 998244353const val MODINT_TOTIENT = MODINT_BASE - 1 // assumes MODINT_BASE is prime inline infix fun Int.umod(base: Int) = Math.floorMod(this, base)inline infix fun Long.umod(base: Long) = Math.floorMod(this, base)inline infix fun Long.umod(base: Int) = Math.floorMod(this, base.toLong()).toInt() fun Int.mulMod(other: Int, mod: Int) = (toLong() * other).umod(mod) fun Int.powMod(exponent: Int, mod: Int): Int {    if(exponent < 0) error(""Inverse not implemented"")    var res = 1L    var e = exponent    var b = umod(mod).toLong()     while(e > 0) {        if(e and 1 == 1) {            res = res * b % mod        }        e = e shr 1        b = b * b % mod    }    return res.toInt()} inline fun Int.toModInt() = ModInt(this umod MODINT_BASE)inline fun Long.toModInt() = ModInt(this umod MODINT_BASE) /** note: Only use constructor for int within modulo range, otherwise use toModInt **/inline class ModInt( val int: Int) {    companion object {        /** can't seem to make these private or inlined without causing compiler issues */        @JvmField val _invMemo = HashMap<ModInt, ModInt>()        fun _invMemoized(m: ModInt) = _invMemo.getOrPut(m) { m.inv_unmemoized() }    }     operator fun plus(other: ModInt) = // MODINT_BASE < 2^30        (int + other.int).let { if(it >= MODINT_BASE) ModInt(it - MODINT_BASE) else ModInt(it) }    inline operator fun plus(other: Int) = plus(other.toModInt())    operator fun inc() = if(int == MODINT_BASE - 1) ModInt(0) else ModInt(int + 1)     operator fun minus(other: ModInt) =        (int - other.int).let { if(it < 0) ModInt(it + MODINT_BASE) else ModInt(it) }    inline operator fun minus(other: Int) = minus(other.toModInt())    operator fun dec() = if(int == 0) ModInt(MODINT_BASE - 1) else ModInt(int - 1)    operator fun unaryMinus() = if(int == 0) this else ModInt(MODINT_BASE - int)     inline operator fun times(other: ModInt) = times(other.int)    inline operator fun times(other: Int) = ModInt(int.mulMod(other, MODINT_BASE))     fun pow(exponent: Int): ModInt {        val e = if(exponent < 0) {            require(int != 0) { ""Can't invert/divide by 0"" }            exponent umod MODINT_TOTIENT        } else exponent        return ModInt(int.powMod(e, MODINT_BASE))    }     fun pow(exponent: Long) = if(int == 0) when {        exponent > 0 -> this        exponent == 0L -> ModInt(1)        else -> error(""Can't invert/divide by 0"")    } else pow(exponent umod MODINT_TOTIENT)     inline fun inverse() = inv_memoized() /** NOTE: Change if necessary */     fun inv_unmemoized(): ModInt {        require(int != 0) { ""Can't invert/divide by 0"" }        return pow(MODINT_TOTIENT - 1)    }    inline fun inv_memoized() = _invMemoized(this)     operator fun div(other: ModInt) = times(other.inverse())    inline operator fun div(other: Int) = div(other.toModInt())     override inline fun toString() = int.toString()} inline class ModIntArray(val intArray: IntArray): Collection<ModInt> {    inline operator fun get(i: Int) = ModInt(intArray[i])    inline operator fun set(i: Int, v: ModInt) { intArray[i] = v.int }     override inline val size: Int get() = intArray.size    inline val lastIndex get() = intArray.lastIndex    inline val indices get() = intArray.indices     override inline fun contains(element: ModInt): Boolean = element.int in intArray     override fun containsAll(elements: Collection<ModInt>): Boolean = elements.all(::contains)     override inline fun isEmpty(): Boolean = intArray.isEmpty()     override fun iterator(): Iterator<ModInt> = object: Iterator<ModInt> {        var index = 0        override fun hasNext(): Boolean = index < size        override fun next(): ModInt = get(index++)    }     fun sum() = indices.sumByModInt(::get)    fun product() = indices.productByModInt(::get)}fun ModIntArray(capacity: Int) = ModIntArray(IntArray(capacity))inline fun ModIntArray(capacity: Int, init: (Int) -> ModInt) =    ModIntArray(IntArray(capacity) { init(it).int }) inline fun <T> Iterable<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Iterable<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }inline fun <T> Sequence<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Sequence<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }fun Iterable<ModInt>.sum() = sumByModInt { it }fun Sequence<ModInt>.sum() = sumByModInt { it }fun Iterable<ModInt>.product() = productByModInt { it }fun Sequence<ModInt>.product() = productByModInt { it } /** IO code start *///@JvmField val INPUT = File(""input.txt"").inputStream()//@JvmField val OUTPUT = File(""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out @JvmField val _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false)inline fun output(block: PrintWriter.() -> Unit) { _writer.apply(block).flush() } /** shuffles and sort overrides to avoid quicksort attacks */private inline fun <R, V> R._shuffle(rnd: Random, get: R.(Int) -> V, set: R.(Int, V) -> Unit, size: Int) {    // Fisher-Yates shuffle algorithm    for (i in size - 1 downTo 1) {        val j = rnd.nextInt(i + 1)        val temp = get(i)        set(i, get(j))        set(j, temp)    }} @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } fun IntArray.shuffle(rnd: Random = random) = _shuffle(rnd, IntArray::get, IntArray::set, size)fun IntArray.sort() { shuffle(); _sort() }fun IntArray.sortDescending() { shuffle(); _sortDescending() } fun LongArray.shuffle(rnd: Random = random) = _shuffle(rnd, LongArray::get, LongArray::set, size)fun LongArray.sort() { shuffle(); _sort() }fun LongArray.sortDescending() { shuffle(); _sortDescending() } fun DoubleArray.shuffle(rnd: Random = random) = _shuffle(rnd, DoubleArray::get, DoubleArray::set, size)fun DoubleArray.sort() { shuffle(); _sort() }fun DoubleArray.sortDescending() { shuffle(); _sortDescending() } fun CharArray.shuffle(rnd: Random = random) = _shuffle(rnd, CharArray::get, CharArray::set, size)inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T: Comparable<T>> Array<out T>.sort() = _sort()inline fun <T: Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T: Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T: Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() fun `please stop removing these imports IntelliJ`() {    iprintln(max(1, 2))}","combinatorics,dp,probabilities"
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.random.Randomimport kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        IN = BufferedInputStream(fakein.toString().byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} fun getint():Int{ return IO.nextInt() }fun getlong():Long{ return IO.nextLong() }fun getline(n:Int):List<Int>{ return (1..n).map{IO.nextInt()} }fun getlineL(n:Int):List<Long>{return (1..n).map{IO.nextLong()} }fun getstr():String{ return IO.nextString() }fun MutableList<Int>.streamint(n:Int){ repeat(n){this.add(getint())}}fun MutableList<Long>.streamlong(n:Int){ repeat(n){this.add(getlong())}}inline fun cases(ask:()->Unit){ val t = getint();repeat(t){ ask() }} val List<Char>.ret:Stringget() = this.joinToString("""")infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    var str = """"    if(this is String){ str = this    }else if(this is Int){ str = this.toString()    }else if(this is Long){ str = this.toString()    }    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    inline fun cases(a:solve.()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint()} else if(mode == solveMode.tc){1 } else randCount         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            currentAnswer = null            currentBruteAnswer = null            a()        }        if(withBruteForce){            put(""Checked ${answersChecked}"")        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    inline fun brute(a:()->Unit){        if(withBruteForce){            a()        }    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }      var currentAnswer:String? = null    var currentBruteAnswer:String? = null    fun answer(a:Any){        currentAnswer = a.toString()        if(currentBruteAnswer != null){            checkAnswer()        }    }    fun put2(a:Any){answer(a);put(a) }     fun bruteAnswer(a:Any){        currentBruteAnswer = a.toString()        if(currentAnswer != null){            checkAnswer()        }    }    fun checkAnswer(){        if(currentAnswer != currentBruteAnswer){            throw Exception(""Failed Test: BF $currentBruteAnswer Current $currentAnswer"")        }        answersChecked ++    }}fun Int2(a:Int,b:Int) = List(a){IntArray(b)}fun Int3(a:Int,b:Int,c:Int) = List(a){List(b){IntArray(c)}}const val p = 998244353Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionconst val funny = -777222777 // start array with this to be safe, WYSIval Char.code :Int get() = this.toInt() -  'a'.toInt() class rsqArr(val arr:IntArray) {    val ps = arr.runningFold(0L, { a,b->a+b.toLong()} )    fun sumQuery(l:Int,r:Int):Long{        val ll = maxOf(l,0)        val rr = minOf(arr.lastIndex,r) + 1        return ps[rr] - ps[ll]    }} infix fun Int.divCeil(b:Int):Int{    //Positives numbers only!    if(this == 0) {        return 0    }    return (this-1)/b + 1}infix fun Long.divCeil(b:Long):Long{    //Positives numbers only!    if(this == 0L) {        return 0    }    return (this-1)/b + 1} infix fun Long.modM(b:Long):Long{    return (this * b) % p}infix fun Int.modM(b:Int):Int{    return ((this * 1L * b) % p).toInt()}infix fun Int.modPlus(b:Int):Int{    return (this + b).adjust()}infix fun Int.modMinus(b:Int):Int{    return (this - b).adjust()}fun Int.additiveInverse():Int{    return if(this == 0) 0 else pI - this}  fun intPow(x:Int,e:Int,m:Int):Int{    var X = x    var E =e    var Y = 1    while(E > 0){        if(E % 2 == 0){            X = ((1L * X * X) % m).toInt()            E /= 2        }else{            Y = ((1L * X * Y) % m).toInt()            E -= 1        }    }    return Y} fun pow(x:Long,e:Long,m:Long):Long{    var X = x    var E =e    var Y = 1L    while(E > 0){        if(E % 2 == 0L){            X = (X * X) % m            E /= 2        }else{            Y = (X * Y) % m            E -= 1        }    }    return Y}fun Long.inverse():Long{    return pow(this,p-2,p)}fun Int.inverse():Int{    return intPow(this,pI-2,pI)}//make this int insteadclass FACT{    companion object {        var store = IntArray(0)        var invStore = IntArray(0)         var slowStore:IntArray = IntArray(0)         fun preCal(upto:Int){            store = IntArray(upto+1)            invStore = IntArray(upto + 1 )            store[0] = 1            invStore[0] = 1             for(i in 1..upto) {                store[i] = store[i-1] modM i                invStore[i] = invStore[i-1] modM (i.inverse())            }        }        fun choose(n:Int,r:Int):Int{            if(r < 0 || r > n) return 0            val a = store[n]            val b = invStore[n-r]            val c = invStore[r]            return (a modM b) modM c        }         fun bigChoose(n:Int,r:Int):Int{            var ret = 1            for(i in 0 until r){                ret = ret modM (n - i)            }            for(i in 1..r){                ret = ret modM (invStore[i])            }            return ret        }     }} const val singleCase = trueconst val withBruteForce = falseconst val randCount = 100fun main(){    solve.cases{        val str = getstr()        val DP = Array(str.length){IntArray(str.length)}        val free = IntArray(str.length){if(str[it] == '?') 1 else 0}        val rsq = rsqArr(free)        val n = str.length        for(d in 0 until str.length){            for(left in str.indices){                val right = d + left                if(! str.indices.contains(right)){                    continue                }                val leftmove = if(left < str.lastIndex) DP[left+1][right] else 0                val rightmove = if(right > 0) DP[left][right-1] else 0                if(str[left] == ')'){                    DP[left][right] = leftmove                }else if(str[right] == '('){                    DP[left][right] = rightmove                }else if(left == right) {                    DP[left][right] = 0                }else{                    var ret = if(left <= right -2) DP[left+1][right-1] else 0                    val counts = if(left <= right -2) rsq.sumQuery(left+1,right-1).toInt() else 0                    ret = (ret + intPow(2,counts,pI)).adjust()                    val freeA = str[left] == '?'                    val freeB = str[right] == '?'                    if(freeA) ret = (ret + leftmove).adjust()                    if(freeB) ret = (ret + rightmove).adjust()                    if(freeA && freeB) ret = (ret - if(left <= right -2) DP[left+1][right-1] else 0).adjust()                    DP[left][right] = ret                }            }        }        put(DP[0][n-1])    }    done()}/* double counted(()()( )))))()(((((    */","combinatorics,dp,probabilities"
"private val reader = System.`in`.bufferedReader()private fun readLn() = reader.readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readLong() = readLn().toLong()private fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of intsprivate fun readLongs() = readStrings().map { it.toLong() }private val writer = System.out.bufferedWriter()//private fun write(i: Int) = writer.write(i)private fun write(any: Any) = writer.write(any.toString())private fun flush() = writer.flush() fun main() {    val n = readInt()    val s = readLn()    var cursor = 0    val line = CharArray(n) { 0.toChar() }    var balance = 0    val every = IntArray(4 * n) { 0 }    val max = IntArray(4 * n) { 0 }    val min = IntArray(4 * n) { 0 }     fun push(root: Int) {        if (every[root] != 0) {            val left = (root shl 1) + 1            val right = (root shl 1) + 2             max[left] += every[root]            min[left] += every[root]            every[left] += every[root]             max[right] += every[root]            min[right] += every[root]            every[right] += every[root]             every[root] = 0        }    }     fun update(root: Int, low: Int, high: Int, qLow: Int, qHigh: Int, delta: Int) {        if (qHigh <= low || high <= qLow) {            return        }        if (qLow <= low && high <= qHigh) {            max[root] += delta            min[root] += delta            every[root] += delta            return        }        push(root)        val left = (root shl 1) + 1        val right = (root shl 1) + 2        val mid = (low + high) shr 1        update(left, low, mid, qLow, qHigh, delta)        update(right, mid, high, qLow, qHigh, delta)        max[root] = maxOf(max[left], max[right])        min[root] = minOf(min[left], min[right])    }     fun answer(): Int {        if (balance != 0) {//            print(""[bal=$balance,cursor=$cursor]"")            return -1        }        if (min[0] < 0) {//            print(""[min=${min[0]},cursor=$cursor]"")            return -1        }//        print(""[normal,cursor=$cursor]"")        return max[0]    }     for (i in s.indices) {        when (s[i]) {            'L' -> {                if (cursor > 0) {                    cursor--                }            }            'R' -> {                cursor++            }            '(' -> {                when (line[cursor]) {                    '(' -> {                    }                    ')' -> {                        update(0, 0, n, cursor, n, 2)                        balance += 2                    }                    else -> {                        update(0, 0, n, cursor, n, 1)                        balance++                    }                }                line[cursor] = '('            }            ')' -> {                when (line[cursor]) {                    ')' -> {                    }                    '(' -> {                        update(0, 0, n, cursor, n, -2)                        balance -= 2                    }                    else -> {                        update(0, 0, n, cursor, n, -1)                        balance--                    }                }                line[cursor] = ')'            }            else -> {                when (line[cursor]) {                    '(' -> {                        update(0, 0, n, cursor, n, -1)                        balance--                    }                    ')' -> {                        update(0, 0, n, cursor, n, 1)                        balance++                    }                    else -> {                    }                }                line[cursor] = s[i]            }        }        write(answer())        write(' ')//        print(answer())//        print(' ')    }//    println()//    println(line)    flush()}","data structures,implementation"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min class DelayMergeTree(n: Int) {   private val N =    if (Integer.highestOneBit(n) == n) n    else Integer.highestOneBit(n) shl 1   private val mnVal = IntArray(N * 2)  private val mxVal = IntArray(N * 2)  private val delay = IntArray(N * 2)   private fun push(k: Int) {    if (k < N) {      mnVal[k * 2] += delay[k]      mnVal[k * 2 + 1] += delay[k]      mxVal[k * 2] += delay[k]      mxVal[k * 2 + 1] += delay[k]      delay[k * 2] += delay[k]      delay[k * 2 + 1] += delay[k]      delay[k] = 0    }  }   /**   * [a, b)   */  fun add(a: Int, b: Int, x: Int, k: Int = 1, l: Int = 0, r: Int = N) {    if (a >= r || l >= b) return // ノードが範囲からはずれてる    if (a <= l && r <= b) { // ノードが完全に範囲に含まれる      mnVal[k] += x      mxVal[k] += x      delay[k] += x      return    }     push(k)    val m = (l + r) / 2    val lft = k * 2    val rgt = lft + 1    add(a, b, x, lft, l, m)    add(a, b, x, rgt, m, r)    mnVal[k] = min(mnVal[lft], mnVal[rgt])    mxVal[k] = max(mxVal[lft], mxVal[rgt])  }   fun max(): Int {    _eval(1)    return mxVal[1]  }   fun min(): Int {    _eval(1)    return mnVal[1]  }   fun eval(i: Int): Int {    _eval(N + i)    return mnVal[N + i]  }   fun _eval(k: Int) {    if (k > 1) {      _eval(k / 2)    }    push(k)  }}class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  fun solve() {    val N = ni()    val command = ns()    val S = CharArray(N){'a'}    var cur = 0     fun diff(c: Char): Int {      return when(c) {        '(' -> 1        ')' -> -1        else -> 0      }    }     var mxCur = 0    for (c in command) {      when(c) {        'L' -> cur = max(0, cur - 1)        'R' -> cur++        else -> {}      }      mxCur = max(mxCur, cur)    }    val n = mxCur + 1    cur = 0    debug{""n:$n""}    val t = DelayMergeTree(n)     val ans = IntArray(N)    for (i in 0 until N) {      val c = command[i]      when(c) {        'L' -> cur = max(0, cur - 1)        'R' -> cur++        else -> {          val add = diff(c) - diff(S[cur])          debug{""$i $c $add""}          if (add != 0) {            t.add(cur, n, add)          }          S[cur] = c        }      }       ans[i] = if (t.eval(n - 1) != 0) {        -1      } else if (t.min() < 0) {        -1      } else {        t.max()      }    }     out.println(ans.joinToString("" ""))  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private val reader = BufferedReader(InputStreamReader(stream), 32768)  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return map(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun map(n: Int, f: (Int) -> Int): IntArray {    val res = IntArray(n)    for (i in 0 until n) {      res[i] = f(i)    }    return res  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: BooleanArray) {    debug { a.map { if (it) 1 else 0 }.joinToString("""") }  }   private fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","data structures,implementation"
"import java.lang.StringBuilderimport java.util.*import kotlin.math.maximport kotlin.math.min fun main() {    val jin = Scanner(System.`in`)    val minST = LazyMinSegmentTree(1, 1000000)    val maxST = LazyMaxSegmentTree(1, 1000000)    var j = 1    var sum = 0    val joiner = StringJoiner("" "")    jin.nextInt()    val text = IntArray(1000001)    for (command in jin.next()) {        if (command == 'L') {            j = max(1, j - 1)        } else if (command == 'R') {            j++        } else {            val d = when (command) {                '(' -> 1                ')' -> -1                else -> 0            } - text[j]            text[j] += d            sum += d            minST.update(j, 1000000, d.toLong())            maxST.update(j, 1000000, d.toLong())        }        if (sum != 0 || minST.query(1, 1000000) != 0L) {            joiner.add(""-1"")        } else {            joiner.add(maxST.query(1, 1000000).toString())        }    }    println(joiner)} class LazyMinSegmentTree(val treeFrom: Int, val treeTo: Int) {    val `val`: LongArray    val lazy: LongArray    fun combine(a: Long, b: Long): Long {        return min(a, b)    }     fun propagate(node: Int) {        `val`[node] += lazy[node]        if (node shl 1 < `val`.size) {            lazy[node shl 1] += lazy[node]            lazy[(node shl 1) + 1] += lazy[node]        }        lazy[node] = 0    }     fun eval(node: Int): Long {        return `val`[node] + lazy[node]    }     fun update(from: Int, to: Int, delta: Long) {        update(1, treeFrom, treeTo, from, to, delta)    }     fun update(node: Int, segFrom: Int, segTo: Int, from: Int, to: Int, delta: Long) {        if (segTo < from || segFrom > to) return        if (segFrom >= from && segTo <= to) {            lazy[node] += delta            return        }        propagate(node)        val mid = segFrom + segTo shr 1        update(node shl 1, segFrom, mid, from, to, delta)        update((node shl 1) + 1, mid + 1, segTo, from, to, delta)        `val`[node] = combine(eval(node shl 1), eval((node shl 1) + 1))    }     fun query(from: Int, to: Int): Long {        return query(1, treeFrom, treeTo, from, to)    }     fun query(node: Int, segFrom: Int, segTo: Int, from: Int, to: Int): Long {        if (segTo < from || segFrom > to) return IDENTITY        if (segFrom >= from && segTo <= to) {            return eval(node)        }        propagate(node)        val mid = segFrom + segTo shr 1        val res = combine(                query(node shl 1, segFrom, mid, from, to),                query((node shl 1) + 1, mid + 1, segTo, from, to)        )        `val`[node] = combine(eval(node shl 1), eval((node shl 1) + 1))        return res    }     companion object {        const val IDENTITY = Long.MAX_VALUE    }     init {        val length = treeTo - treeFrom + 1        var l: Int        l = 0        while (1 shl l < length) {            l++        }        `val` = LongArray(1 shl l + 1)        lazy = LongArray(1 shl l + 1)    }} class LazyMaxSegmentTree(val treeFrom: Int, val treeTo: Int) {    val `val`: LongArray    val lazy: LongArray    fun combine(a: Long, b: Long): Long {        return a.coerceAtLeast(b)    }     fun propagate(node: Int) {        `val`[node] += lazy[node]        if (node shl 1 < `val`.size) {            lazy[node shl 1] += lazy[node]            lazy[(node shl 1) + 1] += lazy[node]        }        lazy[node] = 0    }     fun eval(node: Int): Long {        return `val`[node] + lazy[node]    }     fun update(from: Int, to: Int, delta: Long) {        update(1, treeFrom, treeTo, from, to, delta)    }     fun update(node: Int, segFrom: Int, segTo: Int, from: Int, to: Int, delta: Long) {        if (segTo < from || segFrom > to) return        if (segFrom >= from && segTo <= to) {            lazy[node] += delta            return        }        propagate(node)        val mid = segFrom + segTo shr 1        update(node shl 1, segFrom, mid, from, to, delta)        update((node shl 1) + 1, mid + 1, segTo, from, to, delta)        `val`[node] = combine(eval(node shl 1), eval((node shl 1) + 1))    }     fun query(from: Int, to: Int): Long {        return query(1, treeFrom, treeTo, from, to)    }     fun query(node: Int, segFrom: Int, segTo: Int, from: Int, to: Int): Long {        if (segTo < from || segFrom > to) return IDENTITY        if (segFrom >= from && segTo <= to) {            return eval(node)        }        propagate(node)        val mid = segFrom + segTo shr 1        val res = combine(                query(node shl 1, segFrom, mid, from, to),                query((node shl 1) + 1, mid + 1, segTo, from, to)        )        `val`[node] = combine(eval(node shl 1), eval((node shl 1) + 1))        return res    }     companion object {        const val IDENTITY = Long.MIN_VALUE    }     init {        val length = treeTo - treeFrom + 1        var l: Int        l = 0        while (1 shl l < length) {            l++        }        `val` = LongArray(1 shl l + 1)        lazy = LongArray(1 shl l + 1)    }}","data structures,implementation"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"") import java.io.PrintWriterimport java.util.StringTokenizerimport kotlin.math.*import kotlin.random.*import kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() {    output {        val n = readInt()        val s = readLn()         val T = SegmentTree(n, Entry.I, Entry::combine)         var i = 0         val ans = IntArray(n) { j ->            val c = s[j]            when(c) {                'L' -> i = max(0, i-1)                'R' -> i++                '(' -> T[i] = Entry.L                ')' -> T[i] = Entry.R                else -> T[i] = Entry.I            }             val (sum, max, min) = T[0, n]            if(sum == 0 && min >= 0) max else -1        }         println(ans.joinToString("" ""))    }} data class Entry(val sum: Int, val max: Int = sum, val min: Int = sum) {    fun combine(other: Entry) = Entry(sum + other.sum, maxOf(max, sum + other.max), minOf(min, sum + other.min))     companion object {        val L = Entry(1)        val R = Entry(-1)        val I = Entry(0)    }} class SegmentTree<T>(    val size: Int,    val identityValue: T,    val combiner: (T, T) -> T) {     /* degenericization helpers    val identityValue: T = TODO()    fun combiner(a: T, b: T): T = TODO()    */     @Suppress(""UNCHECKED_CAST"")    private val array = Array<Any?>(2 * size) { identityValue } as Array<T>     val lastIndex get() = size - 1    val indices get() = 0 until size    val asList: List<T> by lazy {        object : AbstractList<T>() {            override val size: Int get() = this@SegmentTree.size            override fun get(index: Int): T = this@SegmentTree[index]        }    }     /** instantiates values from an iterable, O(n) time */    fun copyFrom(iterable: Iterable<T>) {        run {            iterable.forEachIndexed { i, t ->                if(i > lastIndex) return@run                array[i + size] = t            }        }        for(i in size-1 downTo 1) {            array[i] = combiner(array[i shl 1], array[i shl 1 or 1])        }    }     /** Updates a value, O(log n) time */    operator fun set(index: Int, value: T) {        require(index in indices)        var i = index + size        array[i] = value        while(true) {            i = i shr 1            if(i <= 0) break            array[i] = combiner(array[i shl 1], array[i shl 1 or 1])        }    }     /** Gets a value by its index, O(1) time */    operator fun get(index: Int): T {        require(index in indices)        return array[index + size]    }     /** gets the result of applying the monoid operation to the values in the index range, O(log n) time */    operator fun get(start: Int, endExclusive: Int): T {        var l = maxOf(start, 0) + size        var r = minOf(endExclusive, size) + size         // two accumulators to support non-commutative monoids        var lAcc = identityValue        var rAcc = identityValue         while(l < r) {            if(l and 1 == 1) {                lAcc = combiner(lAcc, array[l++])            }            if(r and 1 == 1) {                rAcc = combiner(array[--r], rAcc)            }             l = l shr 1            r = r shr 1        }         return combiner(lAcc, rAcc)    }} /** IO code start *///@JvmField val INPUT = File(""input.txt"").inputStream()//@JvmField val OUTPUT = File(""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out @JvmField val _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false)inline fun output(block: PrintWriter.() -> Unit) { _writer.apply(block).flush() } /** shuffles and sort overrides to avoid quicksort attacks */private inline fun <R, V> R._shuffle(rnd: Random, get: R.(Int) -> V, set: R.(Int, V) -> Unit, size: Int) {    // Fisher-Yates shuffle algorithm    for (i in size - 1 downTo 1) {        val j = rnd.nextInt(i + 1)        val temp = get(i)        set(i, get(j))        set(j, temp)    }} @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } fun IntArray.shuffle(rnd: Random = random) = _shuffle(rnd, IntArray::get, IntArray::set, size)fun IntArray.sort() { shuffle(); _sort() }fun IntArray.sortDescending() { shuffle(); _sortDescending() } fun LongArray.shuffle(rnd: Random = random) = _shuffle(rnd, LongArray::get, LongArray::set, size)fun LongArray.sort() { shuffle(); _sort() }fun LongArray.sortDescending() { shuffle(); _sortDescending() } fun DoubleArray.shuffle(rnd: Random = random) = _shuffle(rnd, DoubleArray::get, DoubleArray::set, size)fun DoubleArray.sort() { shuffle(); _sort() }fun DoubleArray.sortDescending() { shuffle(); _sortDescending() } fun CharArray.shuffle(rnd: Random = random) = _shuffle(rnd, CharArray::get, CharArray::set, size)inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T: Comparable<T>> Array<out T>.sort() = _sort()inline fun <T: Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T: Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T: Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() fun `please stop removing these imports IntelliJ`() {    iprintln(max(1, 2))}","data structures,implementation"
,"brute force,dp"
,"brute force,dp"
"fun readInts(): List<Int> {    return readLine()!!.split("" "").map(String::toInt)} const val MAXN = 200000 fun main() {    val (n, k) = readInts()    val l = mutableListOf<Int>()    val r = mutableListOf<Int>()    val startAt = Array(MAXN + 1) { mutableListOf<Int>() }    val endAt = Array(MAXN + 1) { mutableListOf<Int>() }    for (i in 0 until n) {        val (li, ri) = readInts()        l.add(li)        r.add(ri)        startAt[li].add(i)        endAt[ri].add(i)    }    val pq = sortedSetOf(compareByDescending<Pair<Int, Int>> { it.first }.thenBy { it.second })    val ans = mutableListOf<Int>()    for (i in 1 until MAXN + 1) {        for (seg in startAt[i])            pq.add(Pair(r[seg], seg))        while (pq.size > k) {            val longest = pq.first()            pq.remove(longest)            ans.add(longest.second)        }        for (seg in endAt[i])            pq.remove(Pair(r[seg], seg))    }    println(ans.size)    println(ans.map { it + 1 }.joinToString("" ""))}","data structures,greedy,sortings"
"import java.util.* const val MAXN = 200100 fun main() {    var (n, k) = readLine()!!.split(' ').map { it.toInt() }    var a = MutableList(n) {        val (l, r) = readLine()!!.split(' ').map { it.toInt() }        l to r    }    var g = MutableList(MAXN) { MutableList(0) { 0 to 0 } }    for (i in 0 until n) {        g[a[i].first].add(a[i].second to i)    }    var setik = sortedSetOf(Comparator<Pair<Int, Int>> { p0, p1 ->        if (p0!!.first == p1!!.first) {            p0.second - p1.second        } else {            p0.first - p1.first        }    })    var ans = MutableList(0) {0}    for (i in 0 until MAXN) {        for (p in g[i]) {            setik.add(p.first to p.second)        }        while (setik.size > k) {            ans.add(setik.last().second)            setik.remove(setik.last())        }        while (setik.size > 0) {            if (setik.first().first != i) {                break            }            setik.remove(setik.first())        }    }    println(ans.size)    ans.forEach() {        print(""${it + 1} "")    }}","data structures,greedy,sortings"
"import java.util.* fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     data class Segment(val pos: Int, val left: Int, val right: Int)     val (numSegments, maxCovered) = readInts()    val removed = mutableSetOf<Segment>()    val intersect = TreeSet<Segment>(compareBy(Segment::right, Segment::pos))    val open = mutableListOf<Segment>()    val close = mutableListOf<Segment>()    for (pos in 1..numSegments) {        val (l, r) = readInts()        val segment = Segment(pos, l, r + 1)        open.add(segment)        close.add(segment)    }    open.sortBy { it.left }    close.sortBy { it.right }    var openPos = 0    var closePos = 0    while (openPos < numSegments) {        if (close[closePos].right <= open[openPos].left) {            intersect.remove(close[closePos])            closePos++        } else {            intersect.add(open[openPos])            if (intersect.size > maxCovered) {                removed.add(intersect.pollLast()!!)            }            openPos++        }    }    println(removed.size)    print(removed.joinToString(separator = "" "") { it.pos.toString() })}","data structures,greedy,sortings"
"import java.io.*import java.util.* private fun rl() = readLine()!!private fun ri() = rl().toInt()private fun readStrings() = rl().split("" "")private fun ris() = readStrings().map { it.toInt() } fun main() {  val _re = Regex(""\\s+"")  val r = BufferedReader(InputStreamReader(System.`in`))    .lineSequence()    .flatMap { it.split(_re).asSequence().filterNot { it.isEmpty () } }    .iterator()  val o = PrintWriter(System.out)  fun ri() = r.next().toInt()  val n = ri()  val k = ri()  //semiintervals  val a = Array(n) { ri() to ri() + 1}  val idx = Array(n){ 0 }  for (i in 0 until n) {    idx[i] = i  }  idx.sortBy ( { (a[it].first.toLong () shl 32) + a[it].second })  //System.err.println(a.joinToString())  var ss = sortedSetOf<Pair<Int,Int>>(compareBy { (it.first.toLong () shl 32) + it.second })  var t = 0  val d = BooleanArray(n)  var ans = 0  for (i in a.indices) {    //System.err.println(ss.joinToString())    val (left, right) = a[idx[i]]    while (!ss.isEmpty ()) {      val x = ss.first ()      if (x.first <= left) {        ss.pollFirst ()        t -= 1      } else {        break      }    }    ss.add (right to idx[i])    t += 1    while (t > k) {      val e = ss.pollLast ()      t -= 1      d[e.second] = true      ans += 1    }  }  o.println(ans)  var f = true  for (i in d.indices) {    if (d[i]) {      if (f) {        f = false      } else {        o.print (' ')      }      o.print(i + 1)    }  }  o.println ()  o.close()}","data structures,greedy,sortings"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.io.PrintWriterimport java.util.* fun PrintWriter.solve(sc: FastScanner) {    val n = sc.nextInt()    var k = sc.nextLong()    val a = Array(n) { sc.nextInt() }    a.sort()    val b = (0 until n - 1).map { a[it + 1] - a[it] }.toTypedArray()    var ans = (a.last() - a.first()).toLong()    var l = 0    var r = n - 2    var p = 1L    while (l < r) {        val take = minOf(k, (b[l]+b[r]) * p)        ans -= take / p        k -= take        p++        l++        r--    }    if (l == r) {        val take = minOf(k, b[l] * p)        ans -= take / p        k -= take    }    println(ans)} fun main() {    val writer = PrintWriter(System.out, false)    writer.solve(FastScanner(System.`in`))    writer.flush()} class FastScanner(s: InputStream) {    private var st = StringTokenizer("""")    private val br = BufferedReader(InputStreamReader(s))     fun next(): String {        while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun nextInt() = next().toInt()    fun nextLong() = next().toLong()    fun nextLine() = br.readLine()    fun nextDouble() = next().toDouble()    fun ready() = br.ready()}","binary search,constructive algorithms,greedy,sortings,ternary search,two pointers"
"fun main() {    fun readInt() = readLine()!!.toInt()    fun readLong() = readLine()!!.toLong()    fun readInts() = readLine()!!.split("" "").map(String::toInt)    fun readLongs() = readLine()!!.split("" "").map(String::toLong)     var (n, k) = readLongs()    val arr = readLongs().sorted()//    val elements = ArrayDeque<Pair<Int, Int>>()    val elements = mutableListOf<Pair<Long, Long>>()    var element = arr[0]    var occ = 0L    for (a in arr)        if (a == element) occ++ else {            elements.add(element to occ)            occ = 1            element = a        }    elements.add(element to occ)    var firstPos = 0    var lastPos = elements.lastIndex    while (k > 0L && lastPos != firstPos) {        if (elements[firstPos].second <= elements[lastPos].second) {            val current = elements[firstPos]            val next = elements[firstPos + 1]            val deltaToNext = next.first - current.first            if (deltaToNext * current.second <= k) {                elements[firstPos + 1] = next.first to next.second + current.second                k -= deltaToNext * current.second                firstPos++            } else {                elements[firstPos] = current.first + k / current.second to current.second                k = 0            }        } else {            val current = elements[lastPos]            val previous = elements[lastPos - 1]            val deltaToPrevious = current.first - previous.first            if (deltaToPrevious * current.second <= k) {                elements[lastPos - 1] = previous.first to previous.second + current.second                k -= deltaToPrevious * current.second                lastPos--            } else {                elements[lastPos] = current.first - k / current.second to current.second                k = 0            }        }    }    print(elements[lastPos].first - elements[firstPos].first)}","binary search,constructive algorithms,greedy,sortings,ternary search,two pointers"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007L class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  fun solve() {    val N = ni()    var K = nl()    val A = na(N).toMutableList()    A.sort()    var l = 1    var r = 1    var Al = A[0]    var Ar = A[N - 1]    while(K >= min(l, r) && Ar > Al) {      if (l < r) {        val move = min(K / l, (A[l] - A[l - 1]).toLong()).toInt()        Al += move        K -= move.toLong() * l        if (Al == A[l]) l++      } else {        val move = min(K / r, (A[N - r] - A[N - r - 1]).toLong()).toInt()        Ar -= move        K -= move.toLong() * r        if (Ar == A[N - r - 1]) r++      }    }    out.println(Ar - Al)  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private val reader = BufferedReader(InputStreamReader(stream), 32768)  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return map(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun map(n: Int, f: (Int) -> Int): IntArray {    val res = IntArray(n)    for (i in 0 until n) {      res[i] = f(i)    }    return res  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: BooleanArray) {    debug { a.map { if (it) 1 else 0 }.joinToString("""") }  }   private fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","binary search,constructive algorithms,greedy,sortings,ternary search,two pointers"
"import java.io.*import java.util.*import kotlin.collections.ArrayListimport kotlin.collections.HashMap data class Number(var value: Long, var count: Long = 1) fun main() {    val inputStream = System.`in`    val inputReader = InputReader(inputStream)     val n = inputReader.nextInt()    var k = inputReader.nextLong()    val list = ArrayList<Number>(n)    val map = HashMap<Long, Number>()    for (i in 0 until n) {        val value = inputReader.nextLong()        if (map.containsKey(value)) {            val number = map[value]            if (number != null) {                number.count++            }        } else {            val number = Number(value)            map[value] = number            list.add(number)        }    }    list.sortWith(kotlin.Comparator { o1, o2 -> if (o1.value < o2.value) -1 else if (o1.value > o2.value) 1 else 0 })     var minIndex = 0    var maxIndex = list.size - 1    while (minIndex < maxIndex && k > 0) {        if (list[minIndex].count <= list[maxIndex].count && list[minIndex].count <= k) {            val maxDx = list[minIndex + 1].value - list[minIndex].value            val cost: Long = if (maxDx * list[minIndex].count <= k) {                maxDx * list[minIndex].count            } else {                k / list[minIndex].count * list[minIndex].count            }            k -= cost            list[minIndex].value += cost / list[minIndex].count            if (minIndex + 1 < list.size && list[minIndex].value == list[minIndex + 1].value) {                list[minIndex + 1].count += list[minIndex].count                minIndex++            }        } else if (list[maxIndex].count <= list[minIndex].count && list[maxIndex].count <= k) {            val maxDx = list[maxIndex].value - list[maxIndex - 1].value            val cost: Long = if (maxDx * list[maxIndex].count <= k) {                maxDx * list[maxIndex].count            } else {                k / list[maxIndex].count * list[maxIndex].count            }            k -= cost            list[maxIndex].value -= cost / list[maxIndex].count            if (maxIndex - 1 >= 0 && list[maxIndex].value == list[maxIndex - 1].value) {                list[maxIndex - 1].count += list[maxIndex].count                maxIndex--            }        } else {            break        }    }     val min = list[minIndex].value    val max = list[maxIndex].value    println(max - min)} class InputReader(stream: InputStream) {    private var reader: BufferedReader = BufferedReader(InputStreamReader(stream))    private var tokenizer = StringTokenizer("""")     /** get next word  */    @Throws(IOException::class)    operator fun next(): String {        while (!tokenizer.hasMoreTokens()) {            //TODO add check for eof if necessary            tokenizer = StringTokenizer(                reader.readLine()            )        }        return tokenizer.nextToken()    }     fun nextLong() = next().toLong()    fun nextInt() = next().toInt()    fun nextDouble() = next().toDouble()    fun nextFloat() = next().toFloat()}			 	  		  			   		 		 	  		 	","binary search,constructive algorithms,greedy,sortings,ternary search,two pointers"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.io.PrintWriterimport java.util.* fun PrintWriter.solve(sc: FastScanner) {    val n = sc.nextInt()    val c = Array(3) { Array(n) { sc.nextLong() } }    val adj = Array(n) { mutableSetOf<Int>() }    for (i in 0 until n - 1) {        val v1 = sc.nextInt() - 1        val v2 = sc.nextInt() - 1        adj[v1].add(v2)        adj[v2].add(v1)    }    if ((0 until n).any { adj[it].count() >= 3 }) {        println(-1)        return    }    val leaf = (0 until n).first { adj[it].count() == 1 }    val pp = listOf(listOf(0, 1, 2), listOf(0, 2, 1), listOf(1, 0, 2), listOf(1, 2, 0), listOf(2, 0, 1), listOf(2, 1, 0))    val cost = Array(6) { 0L }    val color = Array(6) { Array(n) { 0 } }    for (i in 0 until 6) {        val p = pp[i]        var prev = -1        var v = leaf        for (j in 0 until n) {            cost[i] += c[p[j % 3]][v]            color[i][v] = p[j % 3] + 1            for (w in adj[v]) {                if (w != prev) {                    prev = v                    v = w                    break                }            }        }    }    val min = cost.min()    println(min)    for (i in 0 until 6) {        if (cost[i] == min) {            println(color[i].joinToString("" ""))            break        }    }} fun main() {    val writer = PrintWriter(System.out, false)    writer.solve(FastScanner(System.`in`))    writer.flush()} class FastScanner(s: InputStream) {    private var st = StringTokenizer("""")    private val br = BufferedReader(InputStreamReader(s))     fun next(): String {        while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun nextInt() = next().toInt()    fun nextLong() = next().toLong()    fun nextLine() = br.readLine()    fun nextDouble() = next().toDouble()    fun ready() = br.ready()}","brute force,constructive algorithms,dp,graphs,implementation,trees"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.io.PrintWriterimport java.util.* fun PrintWriter.solve(sc: FastScanner) {    val n = sc.nextInt()    val c = Array(3) { LongArray(n) { sc.nextLong() } }    val adj = Array(n) { mutableSetOf<Int>() }    for (i in 0 until n - 1) {        val v1 = sc.nextInt() - 1        val v2 = sc.nextInt() - 1        adj[v1].add(v2)        adj[v2].add(v1)    }    if ((0 until n).any { adj[it].count() >= 3 }) {        println(-1)        return    }    val leaf = (0 until n).first { adj[it].count() == 1 }    val pp = listOf(listOf(0, 1, 2), listOf(0, 2, 1), listOf(1, 0, 2), listOf(1, 2, 0), listOf(2, 0, 1), listOf(2, 1, 0))    val cost = Array(6) { 0L }    val color = Array(6) { IntArray(n) { 0 } }    for (i in 0 until 6) {        val p = pp[i]        var prev = -1        var v = leaf        for (j in 0 until n) {            cost[i] += c[p[j % 3]][v]            color[i][v] = p[j % 3] + 1            for (w in adj[v]) {                if (w != prev) {                    prev = v                    v = w                    break                }            }        }    }    val min = cost.min()    println(min)    for (i in 0 until 6) {        if (cost[i] == min) {            println(color[i].joinToString("" ""))            break        }    }} fun main() {    val writer = PrintWriter(System.out, false)    writer.solve(FastScanner(System.`in`))    writer.flush()} class FastScanner(s: InputStream) {    private var st = StringTokenizer("""")    private val br = BufferedReader(InputStreamReader(s))     fun next(): String {        while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun nextInt() = next().toInt()    fun nextLong() = next().toLong()    fun nextLine() = br.readLine()    fun nextDouble() = next().toDouble()    fun ready() = br.ready()}","brute force,constructive algorithms,dp,graphs,implementation,trees"
"import java.lang.Long.minimport java.util.*import kotlin.collections.ArrayList fun main() {    var n = readLine()!!.toInt()    var c = MutableList(3) {        val it =  MutableList(0) { 0 }        it    }    c[0] = readLine()!!.split(' ').map{ it.toInt() }.toMutableList()    c[1] = readLine()!!.split(' ').map{ it.toInt() }.toMutableList()    c[2] = readLine()!!.split(' ').map{ it.toInt() }.toMutableList()     var d = List(n) {        val it = ArrayList<Int>()        it    }     for (i in 0 until n-1) {        var (u, v) = readLine()!!.split(' ').map{ it.toInt() - 1 }        d[v].add(u)        d[u].add(v)    }     for (i in 0 until n) {        if (d[i].size > 2) {            println(-1)            return        }    }     var start = 0    for (i in 0 until n) {        if (d[i].size == 1) {            start = i        }    }    var rez = MutableList(2) {        val it = MutableList(0) { 0 }        it    }    rez[0] = dfs(d, start, 1)    rez[1] = dfs(d, start, 2)    var ans = Long.MAX_VALUE    var pos = 0    var arr = 0    for (k in 0..1) {        for (i in 0..2) {            var cur = 0L            for (j in 0 until n)                cur += c[(rez[k][j] + i) % 3][j].toLong()            if (cur < ans) {                arr = k                pos = i            }            ans = min(cur, ans)        }    }    println(ans)    for (i in 0 until n) {        print(((rez[arr][i] + pos) % 3 + 1).toString() + "" "")    }} fun dfs(    d: List<ArrayList<Int>>,    start: Int,    add: Int): MutableList<Int> {    var q = LinkedList<Int>()    var used = MutableList(d.size) { 0 }    var rez = MutableList(d.size) { 0 }    q.push(start)    used[start] = 1    rez[0] = 0    while(q.size > 0) {        var curr = q.first        q.pop()        used[curr] = 1        for (i in 0 until d[curr].size) {            if (used[d[curr][i]] != 1) {                q.push(d[curr][i])                rez[d[curr][i]] = (rez[curr] + add) % 3            }        }    }    return rez}","brute force,constructive algorithms,dp,graphs,implementation,trees"
"fun main() {    solve()} fun solve() {    val n = inReader.nextInt()     val prices = Array(n) { IntArray(3) }    for (i in 0..2) {        for (j in 0 until n) {            prices[j][i] = inReader.nextInt()        }    }     val verteces = Array(n) { mutableListOf<Int>() }    val degree = IntArray(n)     for (i in 1 until n) {        val v1 = inReader.nextInt() - 1        val v2 = inReader.nextInt() - 1         verteces[v1].add(v2)        verteces[v2].add(v1)         degree[v1]++        degree[v2]++    }     val start = degree.indexOf(1)    if (start == -1) {        println(-1)        return    }    if (degree.count { it == 1 } != 2 && degree.count { it == 2 } != n - 2) {        println(-1)        return    }     val tree = mutableListOf<Int>()    dfs(start, verteces, BooleanArray(n), tree)     var res = Long.MAX_VALUE    var answer = IntArray(3)     for (c1 in 0..2) {        for (c2 in 0..2) {            for (c3 in 0..2) {                if (c1 != c2 && c2 != c3 && c3 != c1) {                    val colors = intArrayOf(c1, c2, c3)                    var i = 0                    var cur = 0L                    for (v in tree) {                        cur += prices[v][colors[i % 3]]                        i++                    }                    if (cur < res) {                        res = cur                        answer = colors                    }                }            }        }    }     println(res)     val colors = IntArray(n)    var i = 0    for (v in tree) {        colors[v] = answer[i % 3] + 1        i++    }     println(colors.joinToString("" ""))} fun dfs(v: Int, vertexes: Array<MutableList<Int>>, visited: BooleanArray, tree: MutableList<Int>) {    visited[v] = true     for (next in vertexes[v]) {        if (!visited[next]) {            dfs(next, vertexes, visited, tree)        }    }    tree += v} object inReader {    private var words: List<String> = listOf()    private var pos = 0     fun next(): String {        if (pos == words.size) {            words = readLine()!!.split("" "")            pos = 0        }         return words[pos++]    }     fun nextLine(): String {        return readLine()!!    }     fun nextInt() = next().toInt()     fun nextLong() = next().toLong()     fun nextDouble() = next().toDouble()}","brute force,constructive algorithms,dp,graphs,implementation,trees"
"import kotlin.math.maximport kotlin.math.min fun readints() = readLine()!!.split("" "").map { it.toInt() }fun readstrs() = readLine()!!.split("" "") fun main() {    val (k) = readints()    repeat(k) {        val (n) = readints()        val s = readLine()!!.toMutableList()        val t = readLine()!!.toMutableList()        val ans = mutableListOf<String>()        var can = true        for (i in 0 until n) {            if (s[i] == t[i]) {                continue            }            var jj = -1            for (j in i + 1 until n) {                if (s[j] == s[i]) {                    jj = j                    break                }            }            if (jj != -1) {                ans.add(""${jj + 1} ${i + 1}"")                s[jj] = t[i]                continue            }            jj = -1            for (j in i + 1 until n) {                if (t[j] == s[i]) {                    jj = j                    break                }            }            if (jj != -1) {                ans.add(""${jj + 1} ${jj + 1}"")                t[jj] = s[jj]                ans.add(""${jj + 1} ${i + 1}"")                s[jj] = t[i]                continue            }            can = false            break        }        if (can) {            println(""Yes"")            println(ans.size)            ans.forEach(::println)        } else {            println(""No"")        }    }}",strings
"import java.io.*import java.util.*import kotlin.math.* val INPUT = System.`in`!!val OUTPUT = System.out!!const val yes = ""YES""const val no = ""NO""val reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun line() = reader.readLine()!!var st: StringTokenizer = StringTokenizer("""")fun read(): String {    while (st.hasMoreTokens().not())        st = StringTokenizer(reader.readLine() ?: return """", "" "")    return st.nextToken()}fun int() = read().toInt()fun ints(n: Int) = List(n) { read().toInt() }fun intArray(n: Int) = IntArray(n) { read().toInt() }val writer = PrintWriter(OUTPUT, false)fun main() { writer.solve(); writer.flush() }fun PrintWriter.solve() {    var tt = 1    tt = int()    while (tt-- > 0) {        val n = int()        val s = line().toCharArray()        val t = line().toCharArray()        val hash = IntArray(26)        for(i in s) hash[i - 'a']++        for(i in t) hash[i - 'a']++        var flag = true        for(i in hash) {            flag = flag && (i % 2 == 0)        }        if(!flag) println(no)        else {            println(yes)            val list = ArrayList<Pair<Int, Int>>()            for(i in 0 until n) {                if(s[i] != t[i]) {                    for(j in i + 1 until n) {                        if(s[j] == s[i]) {                            list.add(Pair(j + 1, i + 1))                            val c = t[i]                            t[i] = s[j]                            s[j] = c                            break                        }                    }                }                if(s[i] != t[i]) {                    for(j in i + 1 until n) {                        if(t[j] == s[i]) {                            list.add(Pair(n, j + 1))                            list.add(Pair(n, i + 1))                            var c = t[j]                            t[j] = s[n - 1]                            s[n - 1] = c                            c = s[n - 1]                            s[n - 1] = t[i]                            t[i] = c                            break                        }                    }                }            }            println(list.size)            for(i in list) println(""${i.first} ${i.second} "")        }    }}",strings
"fun main() {    val k = readLine()!!.toInt()     val resultBuilder = StringBuilder()     for (z in 0 until k) {        val n = readLine()!!.toInt()         val s = readLine()!!.toCharArray().toMutableList()        val t = readLine()!!.toCharArray().toMutableList()         val w1 = ArrayList<Char>()        val w2 = ArrayList<Char>()         val size = s.size         for (j in 0 until size) {            if (s[j] != t[j]) {                w1.add(s[j])                w2.add(t[j])            }        }         val all = ArrayList<Char>()        all.addAll(w1)        all.addAll(w2)         val checkMap = all.associateBy({it}, {all.count{char -> char == it}})         if (checkMap.values.any { it % 2 == 1 }) {            resultBuilder.append(""No\n"")        }        else {            val steps: ArrayList<Pair<Int, Int>> = ArrayList()             for (i in 0 until s.size) {                if (s[i] == t[i]) {                    continue                }                 if (customCount(s, i, s[i]) > 1) {                    var pos = 0                     for (j in i until s.size) {                        if (s[i] == s[j] && pos == 1) {                            steps.add(Pair(j, i))                             val swap = s[j]                            s[j] = t[i]                            t[i] = swap                                                        break                        } else if (s[i] == s[j]) {                            pos++                        }                    }                 } else {                    for (j in i until t.size) {                        if (s[i] == t[j] && i < s.size - 1) {                            steps.add(Pair(i + 1, j))                            steps.add(Pair(i + 1, i))                             val swap = s[i + 1]                            s[i + 1] = t[i]                            t[i] = s[i]                            t[j] = swap                             break                        }                    }                }            }             resultBuilder.append(""Yes\n"")             resultBuilder.append(steps.size)            resultBuilder.append('\n')             for (step in steps) {                resultBuilder.append((step.first + 1).toString() + ' ' + (step.second + 1).toString())                resultBuilder.append('\n')            }             resultBuilder.trimEnd('\n')        }    }     println(resultBuilder.toString())} fun customCount (a: MutableList<Char>, start: Int, char: Char) : Int {    var result = 0     for (i in start until a.size) {        if (a[i] == char) {            result++        }    }     return result}",strings
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007L class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  fun solve() {    for (i in 0 until ni()) {      solve2()    }  }   fun solve2() {    val N = ni()    val S = ns().map{it - 'a'}.toIntArray()    val T = ns().map{it - 'a'}.toIntArray()    val C = IntArray(26)    for (i in 0 until N) {      C[S[i]]++      C[T[i]]++    }    if (C.any{it % 2 == 1}) {      out.println(""No"")      return    }     out.println(""Yes"")    val ans = mutableListOf<Pair<Int, Int>>()    fun swap(i: Int, j: Int) {      ans += Pair(i + 1, j + 1)      val tmp = S[i]      S[i] = T[j]      T[j] = tmp    }     for (i in 0 until N) {      if (S[i] != T[i]) {        for (j in i + 1 until N) {          if (S[i] == S[j]) {            swap(j, i)            break          }          if (T[i] == T[j]) {            swap(i, j)            break          }          if (S[i] == T[j]) {            swap(j, j)            swap(j, i)            break          }          if (T[i] == S[j]) {            swap(j, j)            swap(i, j)            break          }        }      }    }      out.println(ans.size)    ans.forEach{out.println(""${it.first} ${it.second}"")}  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private val reader = BufferedReader(InputStreamReader(stream), 32768)  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return map(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun map(n: Int, f: (Int) -> Int): IntArray {    val res = IntArray(n)    for (i in 0 until n) {      res[i] = f(i)    }    return res  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: BooleanArray) {    debug { a.map { if (it) 1 else 0 }.joinToString("""") }  }   private fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}",strings
"import java.util.* val s = Scanner(System.`in`) fun main() {    val n = s.nextInt()    val k = s.nextInt()     val c = ArrayDeque<Long>()    val showing = hashMapOf<Long, Boolean>()    for (i in 0 until n) {        val id = s.nextLong()        if (showing[id] == true)            continue        if (c.size == k) {            showing[c.removeLast()] = false        }        c.addFirst(id)        showing[id] = true    }     println(c.size)    c.forEach { print(""$it "") }}","data structures,implementation"
"fun main() {    val r = System.`in`.bufferedReader()    val s1 = StringBuilder()    val (n, k) = r.readLine()!!.split("" "").map { it.toInt() }    val mes = mutableSetOf<Int>()    val v = r.readLine()!!.split("" "").map { it.toInt() }    v.forEach {        if (it !in mes){            if (mes.size<k) mes += it            else {                mes.remove(mes.elementAt(0))                mes.add(it)            }        }    }    println(mes.size)    println(mes.reversed().joinToString("" ""))}","data structures,implementation"
"import java.util.*import kotlin.collections.HashSetimport kotlin.math.*fun main() {    val (n, k) = readLine()!!.split("" "").map(String::toInt)    val id = readLine()!!.split("" "").map(String::toInt)    val list = LinkedList<Int>()    val set = HashSet<Int>()    for (i in 0 until n) {        if (!set.contains(id[i])) {            list.add(id[i])            set.add(id[i])        }        if (list.size > k) {            set.remove(list.first)            list.removeFirst()        }    }    println(list.size)    println(list.reversed().joinToString("" ""))}","data structures,implementation"
"import java.util.*import kotlin.collections.HashSet  fun main(args: Array<String>) {     val sc = Scanner(System.`in`)     val n = sc.nextInt()    val k = sc.nextInt()     val set = HashSet<Int>()    val list = LinkedList<Int>()     for (i in 1..n) {        val aux = sc.nextInt()         if (set.size == k && !set.contains(aux)) {            val toRemove = list.peekLast()            set.remove(toRemove)            list.removeLast()            set.add(aux)            list.addFirst(aux)        } else if (!set.contains(aux)) {            set.add(aux)            list.addFirst(aux)        }    }     val size = Math.min(list.size, k)    println(size)    list.stream().limit(size.toLong()).forEach{ print(""$it "") }}","data structures,implementation"
"import java.util.*import kotlin.math.sqrt const val mod = 1000000007L fun main() {    val s = Scanner(System.`in`)    val x = s.nextLong()    val n = s.nextLong()     var ans = 1L    val primes = getPrimes(x)    primes.forEach {        var itt = it        var cnt = 0L        while (true) {            cnt += n / itt            if (itt <= n / it) // 如果直接itt*=it再判断itt<=n会爆Long                itt *= it            else                break        }        ans = ans * fpow(it, cnt) % mod    }    print(ans)} fun getPrimes(x: Long): Set<Long> {    val primes = MutableList(0) { 0L }     val sqrtx = sqrt(x.toDouble()).toLong() + 5    var xx = x    var i = 2L    while (xx > 1) {        if (xx % i == 0L)            primes.add(i)        while (xx % i == 0L)            xx /= i        if (++i > sqrtx)            break    }    if (xx > 1)        primes.add(xx)     return primes.toSet()}fun fpow(x: Long, n: Long, m: Long = mod): Long {    if (n == 0L)        return 1    var ans = 1L    var xx = x % mod    var nn = n    while (nn > 1) {        if (nn % 2 == 1L)            ans = ans * xx % mod        nn /= 2        xx = xx * xx % mod    }    return ans * xx % mod}","math,number theory"
"import kotlin.math.sqrt fun main() {    val (x, n) = readLongs()    val primes = primes(x.toInt())    var result = 1L    for (prime in primes) {        var num = n        var count = 0L        while (num >= prime) {            count += num / prime            num /= prime        }        result = (result * pow(prime.toLong(), count)) % 1000000007    }    println(result)} fun primes(x: Int): IntArray {    var num = x    val result = mutableListOf<Int>()    for (i in 2..sqrt(x.toDouble()).toInt()) {        if (num % i == 0) {            result.add(i)            num /= i            while (num % i == 0) {                num /= i            }        }    }    if (num != 1) {        result.add(num)    }    return result.toIntArray()} fun pow(x: Long, n: Long): Long {    var num = x    var count = n    var result = 1L    while (count > 0) {        if (count and 1L == 1L) {            result = (result * num) % 1000000007        }        num = (num * num) % 1000000007        count = count shr 1    }    return result} private fun readString() = readLine()!! private fun readInt() = readString().toInt() private fun readInts() = readString().split("" "").map { it.toInt() } private fun readLong() = readString().toLong() private fun readLongs() = readString().split("" "").map { it.toLong() }","math,number theory"
"import java.util.*import kotlin.collections.HashSetimport kotlin.math.max fun readInts() = readLine()!!.split("" "").map { it.toInt() }fun readLongs() = readLine()!!.split("" "").map { it.toLong() }fun readInt() = readLine()!!.toInt()fun readLong() = readLine()!!.toLong()fun readLenAndInts() = readLine()!!.split("" "").drop(1).map { it.toInt() } fun divisors(xx : Int) : List<Int> {    var x = xx    val res = mutableListOf<Int>()    fun tryDiv(div : Int) {        if (x % div == 0) {            res.add(div)            do {                x /= div            } while (x % div == 0)        }    }    tryDiv(2)    var div = 3    while(div * div <= x) {        tryDiv(div)        div += 2    }    if (x != 1) {        res.add(x)    }    return res} val mod = 1000000007Lfun fastExp(a : Long, b : Long) : Long {    //(a ^ b) % mod    var res = 1L    var x   = a    var e   = b    while(e > 0) {        if (e % 2L == 1L) {            res *= x            res %= mod        }        x *= x        x %= mod        e /= 2    }    return res} fun main() {    var (x,n) = readLongs()    var res = 1L    for(div in divisors(x.toInt())) {        var times = 0L        var nn = n        while (nn > 0) {            nn /= div            times += nn        }        res *= fastExp(div.toLong(),times)        res %= mod    }    println(res)}","math,number theory"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.collections.ArrayListimport kotlin.math.sqrt  fun main() {    val sc = Scanner.sysIn     val x = sc.nextInt()    val n = sc.nextLong()     val primes = ArrayList<Int>()     fun isPrime(k: Int): Boolean {        if (k == 1) return false        if (k == 2 || k == 3) return true        for (i in 2..sqrt(k.toDouble()).toInt()) {            if (k % i == 0) {                return false            }        }        return true     }     for (i in 2..sqrt(x.toDouble()).toInt()) {        if (x % i == 0) {            if (isPrime(i) && !primes.contains(x / i))                primes += i            if (isPrime(x / i) && !primes.contains(x / i))                primes += x / i        }    }    if (isPrime(x)) primes += x     //primes.forEach { println(it) }     val mod = 1000000007    fun power(x: Long, p: Long): Long = when {        p == 0L -> 1        p == 1L -> x % mod        p % 2 == 0L -> {            val cur = power(x, p / 2)            (cur * cur) % mod        }        else -> (power(x, p - 1) * x) % mod    }     var ans = 1L     for (p in primes) {        var curP = p.toLong()        while (n / curP > 0) {            //println(curP)            ans = (ans * power(p.toLong(), n / curP)) % mod            if ((curP * p) / p != curP) break            curP *= p        }    }     println(ans)} class Scanner(s: InputStream) {    var st: StringTokenizer? = null    val br: BufferedReader = BufferedReader(InputStreamReader(s))     operator fun next(): String {        while (st == null || !st!!.hasMoreTokens())            st = StringTokenizer(br.readLine())        return st!!.nextToken()    }     fun nextInt(): Int {        return Integer.parseInt(next())    }     fun nextLong(): Long {        return java.lang.Long.parseLong(next())    }     fun nextLine(): String {        return br.readLine()    }     fun nextDouble(): Double {        return java.lang.Double.parseDouble(next())    }     companion object {        val sysIn = Scanner(System.`in`)    } } val rnd = Random()fun IntArray.sort() {    val n = this.size    for (i in 0 until n - 1) {        val randomPos = i + rnd.nextInt(n - i - 1) + 1        this[i] = this[i] xor this[randomPos]        this[randomPos] = this[randomPos] xor this[i]        this[i] = this[i] xor this[randomPos]    }    Arrays.sort(this)} fun LongArray.sort() {    val n = this.size    for (i in 0 until n - 1) {        val randomPos = i + rnd.nextInt(n - i - 1) + 1        this[i] = this[i] xor this[randomPos]        this[randomPos] = this[randomPos] xor this[i]        this[i] = this[i] xor this[randomPos]    }    Arrays.sort(this)}","math,number theory"
"fun main(args: Array<String>) {    val n = readLine()!!.toInt()    println( (1..n).map { i ->            (1..n).map { k -> if ( (i+k)%2 > 0 ) ""W"" else ""B"" }.joinToString("""")        }.joinToString(""\n"")    )}","constructive algorithms,greedy"
"fun readInts() = readLine()!!.split("" "").map { it.toInt() } fun main() {    val n = readLine()!!.toInt()    val s = ""WB""    repeat(n) { r ->        repeat(n) { print(s[(r + it) % 2]) }        println()    }}","constructive algorithms,greedy"
"fun main() {    val n = readLine()!!.toInt()     val w = ""WB"".repeat(n / 2) + if (n % 2 == 1) ""W"" else """"    val b = ""BW"".repeat(n / 2) + if (n % 2 == 1) ""B"" else """"     repeat(n) {        println(if (it % 2 == 1) b else w)    }}","constructive algorithms,greedy"
"fun main() {    val n = readLine()!!.toInt()    val input = ""WB""    println(        buildString {            for (i in 0 until n) {                for (j in 0 until n) {                    append(input[(i + j) % 2])                }                appendln()            }        }    )}","constructive algorithms,greedy"
"import kotlin.math.minfun main(){    val n = readLine()!!.toInt()    val a = readLine()!!.split("" "").map{it.toInt()}    val c = a.count{it%2==0}    println(min(c, n-c))}",math
"fun main(args: Array<String>) {    val n = readLine()!!.toInt()    val x = readLine()!!.split(' ').map{ it.toInt() }    val odd = x.sumBy { it % 2 }    print(minOf(odd, n-odd))}    ",math
"import java.util.* fun main() {    val sc = Scanner(System.`in`)     val a = mutableListOf(0,0)    repeat(sc.nextInt()){        a[Math.abs(sc.nextInt()%2)]++    }    println(a.min())}  ",math
"fun main() {    val n = readLine()!!.toInt()    var ans = 0    readLine()!!.split("" "").forEach {        if (it.toInt() % 2 == 0)            ++ans    }    ans = minOf(ans, n - ans)    println(""$ans"")}",math
"private fun solve() {	val n = readInt()	val flag = readInts()	val want = readInts()	val changed = flag.zip(want) { a, b -> a != b }	val nei = List(n) { mutableListOf<Int>() }	repeat(n - 1) {		val (a, b) = readInts().map { it - 1 }		nei[a].add(b)		nei[b].add(a)	}	val w = changed.indexOfFirst { it }	if (w == -1) return println(""Yes\n0"")	val p = MutableList(n) { 0 }	val u = dfs(nei, p, changed, w, -1).second	val v = dfs(nei, p, changed, u, -1).second	val path = mutableListOf(v)	while (path.last() != u) path.add(p[path.last()])	println(check(flag, want, path) ?: check(flag, want, path.reversed()) ?: ""No"")} private fun check(flag: List<Int>, want: List<Int>, path: List<Int>): String? {	val f = flag.toMutableList()	val save = f[path.first()]	for ((a, b) in path.zipWithNext()) {		f[a] = f[b]	}	f[path.last()] = save	return ""Yes\n${path.size}\n${path.map { it + 1 }.joinToString("" "")}"".takeIf { f == want }} private fun dfs(nei: List<List<Int>>, p: MutableList<Int>, cool: List<Boolean>, v: Int, parent: Int): Pair<Int, Int> {	var best = if (cool[v]) 0 to v else -nei.size to -1	p[v] = parent	for (u in nei[v].minus(parent)) {		val (dist, vertex) = dfs(nei, p, cool, u, v)		if (dist + 1 > best.first) best = dist + 1 to vertex	}	return best} fun main() = repeat(readInt()) { solve() } private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","*special,math,trees"
"private fun solve() { val n = readInt() val flag = readInts() val want = readInts() val changed = flag.zip(want) { a, b -> a != b } val nei = List(n) { mutableListOf<Int>() } repeat(n - 1) {  val (a, b) = readInts().map { it - 1 }  nei[a].add(b)  nei[b].add(a) } val w = changed.indexOfFirst { it } if (w == -1) return println(""Yes\n0"") val p = MutableList(n) { 0 } val u = dfs(nei, p, changed, w, -1).second val v = dfs(nei, p, changed, u, -1).second val path = mutableListOf(v) while (path.last() != u) path.add(p[path.last()]) println(check(flag, want, path) ?: check(flag, want, path.reversed()) ?: ""No"")} private fun check(flag: List<Int>, want: List<Int>, path: List<Int>): String? { val f = flag.toMutableList() val save = f[path.first()] for ((a, b) in path.zipWithNext()) {  f[a] = f[b] } f[path.last()] = save return ""Yes\n${path.size}\n${path.map { it + 1 }.joinToString("" "")}"".takeIf { f == want }} private fun dfs(nei: List<List<Int>>, p: MutableList<Int>, cool: List<Boolean>, v: Int, parent: Int): Pair<Int, Int> { var best = if (cool[v]) 0 to v else -nei.size to -1 p[v] = parent for (u in nei[v].minus(parent)) {  val (dist, vertex) = dfs(nei, p, cool, u, v)  if (dist + 1 > best.first) best = dist + 1 to vertex } return best} fun main() = repeat(readInt()) { solve() } private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","*special,math,trees"
"private fun solve() {	val n = readInt()	val flag = readInts()	val want = readInts()	val changed = flag.zip(want) { a, b -> a != b }	val nei = List(n) { mutableListOf<Int>() }	repeat(n - 1) {		val (a, b) = readInts().map { it - 1 }		nei[a].add(b)		nei[b].add(a)	}	val w = changed.indexOfFirst { it }	if (w == -1) return println(""Yes\n0"")	val p = MutableList(n) { 0 }	val u = dfs(nei, p, changed, w, -1).second	val v = dfs(nei, p, changed, u, -1).second	val path = mutableListOf(v)	while (path.last() != u) path.add(p[path.last()])	println(check(flag, want, path) ?: check(flag, want, path.reversed()) ?: ""No"")} private fun check(flag: List<Int>, want: List<Int>, path: List<Int>): String? {	val f = flag.toMutableList()	val save = f[path.first()]	for ((a, b) in path.zipWithNext()) {		f[a] = f[b]	}	f[path.last()] = save	return ""Yes\n${path.size}\n${path.map { it + 1 }.joinToString("" "")}"".takeIf { f == want }} private fun dfs(nei: List<List<Int>>, p: MutableList<Int>, cool: List<Boolean>, v: Int, parent: Int): Pair<Int, Int> {	var best = if (cool[v]) 0 to v else -nei.size to -1	p[v] = parent	for (u in nei[v].minus(parent)) {		val (dist, vertex) = dfs(nei, p, cool, u, v)		if (dist + 1 > best.first) best = dist + 1 to vertex	}	return best} fun main() = repeat(readInt()) { solve() } private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","*special,math,trees"
"private fun solve() {	val n = readInt()	val flag = readInts()	val want = readInts()	val changed = flag.zip(want) { a, b -> a != b }	val nei = List(n) { mutableListOf<Int>() }	repeat(n - 1) {		val (a, b) = readInts().map { it - 1 }		nei[a].add(b)		nei[b].add(a)	}	val w = changed.indexOfFirst { it }	if (w == -1) return println(""Yes\n0"")	val p = MutableList(n) { 0 }	val u = dfs(nei, p, changed, w, -1).second	val v = dfs(nei, p, changed, u, -1).second	val path = mutableListOf(v)	while (path.last() != u) path.add(p[path.last()])	println(check(flag, want, path) ?: check(flag, want, path.reversed()) ?: ""No"")} private fun check(flag: List<Int>, want: List<Int>, path: List<Int>): String? {	val f = flag.toMutableList()	val save = f[path.first()]	for ((a, b) in path.zipWithNext()) {		f[a] = f[b]	}	f[path.last()] = save	return ""Yes\n${path.size}\n${path.map { it + 1 }.joinToString("" "")}"".takeIf { f == want }} private fun dfs(nei: List<List<Int>>, p: MutableList<Int>, cool: List<Boolean>, v: Int, parent: Int): Pair<Int, Int> {	var best = if (cool[v]) 0 to v else -nei.size to -1	p[v] = parent	for (u in nei[v].minus(parent)) {		val (dist, vertex) = dfs(nei, p, cool, u, v)		if (dist + 1 > best.first) best = dist + 1 to vertex	}	return best} fun main() = repeat(readInt()) { solve() } private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() }","*special,math,trees"
"//package codeforces.round580 fun main() {	readLine()	val a = readLine()!!.split("" "").map { it.toLong() }	val perBit = List(Long.SIZE_BITS) { i -> a.filter { (it shr i) and 1 != 0L } }	if (perBit.any { it.size >= 3 }) {		println(3)		return	}	val vertices = perBit.flatten().toSet()	val edges = perBit.filter { it.size == 2 }.map { pair -> pair.map { vertices.indexOf(it) } }	val inf = vertices.size + 1	val eOriginal = List(vertices.size) { IntArray(vertices.size) { inf } }	for ((u, v) in edges) {		eOriginal[u][v] = 1		eOriginal[v][u] = 1	}	val ans = edges.map { (u, v) ->		val e = eOriginal.map { it.clone() }		e[u][v] = inf		e[v][u] = inf		floyd(e)		e[u][v] + 1	}.min() ?: inf	println(if (ans < inf) ans else -1)} private fun floyd(e: List<IntArray>) {	for (k in e.indices) {		for (i in e.indices) {			for (j in e.indices) {				e[i][j] = minOf(e[i][j], e[i][k] + e[k][j])			}		}	}}","bitmasks,brute force,graphs,shortest paths"
"fun main() {	val n = readInt()	val a = readLongs()	val perBit = List(Long.SIZE_BITS) { mutableListOf<Long>() }	for (x in a) {		for (i in perBit.indices) {			if ((x shr i) and 1 == 0L) continue			perBit[i].add(x)		}	}	if (perBit.map { it.size }.max()!! >= 3) {		println(3)		return	}	val v = perBit.flatten().toSet().sorted()	val inf = v.size + 1	val edges = List(v.size) { IntArray(v.size) { inf } }	for (group in perBit) {		if (group.size != 2) continue		val (a, b) = group.map { v.indexOf(it) }		edges[a][b] = 1		edges[b][a] = 1	}	var ans = inf	for (a in v.indices) {		for (b in v.indices) {			if (edges[a][b] != 1) continue			val e = List(v.size) { edges[it].clone() }			e[a][b] = inf			e[b][a] = inf			for (k in v.indices) {				for (i in v.indices) {					for (j in v.indices) {						e[i][j] = minOf(e[i][j], e[i][k] + e[k][j])					}				}			}			ans = minOf(ans, e[a][b] + 1)		}	}	println(if (ans < inf) ans else -1)} private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readLongs() = readStrings().map { it.toLong() }","bitmasks,brute force,graphs,shortest paths"
"import java.util.* // http://codeforces.com/contest/1205/submission/59042855 const val INF = 1 shl 20 fun solve(): Int {  val _n = readLine()!!.toInt()  val a = readLine()!!.split("" "").map(String::toLong).filter { it != 0L }.toLongArray()  val n = a.size  /*  for ((i, v) in a.withIndex()) {    debug(String.format(""%60s : %d, %d"", v.toString(2), i, v))  }  */  val cnt = IntArray(64)  for (v in a) {    for (i in 0..60) {      if ((v ushr i) and 1 > 0) {        cnt[i]++      }    }  }  if (cnt.max()!! >= 3) {    return 3  }  val dist = Array(n) { IntArray(n) { n + 1 } }  for ((i, v) in a.withIndex()) {    for ((j, w) in a.withIndex()) {      if (i == j) {        continue      }      if (v and w > 0) {        dist[i][j] = 1      }    }  }  val link = dist.map { it.clone() }  var ans = INF  for (k in 0 until n) {    for (i in 0 until k) {      for (j in i + 1 until n) {        ans = minOf(ans, link[i][k] + dist[i][j] + link[k][j])      }    }    for (i in 0 until n) {      for (j in 0 until n) {        if (i == j)          continue        dist[i][j] = minOf(dist[i][j], dist[i][k] + dist[k][j])      }    }  }  return if (ans > n) -1 else ans} fun main(args: Array<String>) {  println(solve())} fun debug(vararg objs: Any) {  System.err.println(Arrays.deepToString((objs)))}	  	 		 						    	 	 		  		","bitmasks,brute force,graphs,shortest paths"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.*import kotlin.collections.HashMapimport kotlin.collections.HashSet fun main(args: Array<String>) {    val input = BufferedReader(InputStreamReader(System.`in`))    val n = input.readLine().toInt()    val a = input.readLine().split("" "").map{it.toLong()}.filter { it > 0 }     val counts = IntArray(64) {0}     a.forEach {        (0 until 64).forEach { bit ->            counts[bit] += (it shr bit).toInt() and 1        }    }     if (counts.any { it >= 3 }) {        println(3)        return    }      val g = HashMap<Int, MutableList<Int>>()     a.forEachIndexed() { i, x ->        a.forEachIndexed() { j, y ->            if ( i != j && (x and y) != 0L) {                g.getOrPut(i, {                    mutableListOf()                }).add(j)            }        }    }     val f = g.map { (i, mutableList) ->        mutableList.map {j ->            bfs(g, i, j) ?: Int.MAX_VALUE        }.min() ?:Int.MAX_VALUE    }.min() ?: Int.MAX_VALUE     if (f < Int.MAX_VALUE) {        println(f+1)    } else {        println(-1)    }  } fun bfs(g: HashMap<Int, MutableList<Int>>, i: Int, j: Int): Int? {    val q = ArrayDeque<Int>()    q.add(i)     val visited = HashSet<Int>()    val dist = hashMapOf(i to 0)     while ( !q.isEmpty() ) {        val e = q.pop()        if (visited.contains(e)) {            continue        }        visited.add(e)         g[e].orEmpty().forEach {            if (e == i && it == j) {                return@forEach            }            q.add(it)            dist[it] = dist[it] ?: ((dist[e] ?: 0) + 1)        }    }    return dist[j]}   ","bitmasks,brute force,graphs,shortest paths"
fun main(){    val s = readLine()!!    val x = s.length    val res = StringBuilder()    var e = 0    for(i in x-1 downTo 0)    {        if(s[i]=='0')        {            e=e+1            res.append('0')        }        else         if(e>0)        {            e=e-1            res.append('1')        }        else        {            res.append('0')        }    }    val ee=res.reversed()    print(ee)},"brute force,greedy,strings"
"import java.io.BufferedReaderimport java.io.IOExceptionimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.math.* const val INF = 10000000class InputReader(stream: InputStream) {    var reader: BufferedReader = BufferedReader(InputStreamReader(stream))    var tokenizer = StringTokenizer("""")     /** get next word  */    @Throws(IOException::class)    operator fun next(): String {        while (!tokenizer.hasMoreTokens()) {            //TODO add check for eof if necessary            tokenizer = StringTokenizer(                    reader.readLine()            )        }        return tokenizer.nextToken()    }    fun nextLong() = next().toLong()    fun nextInt() = next().toInt()    fun nextDouble() = next().toDouble()    fun nextFloat() = next().toFloat()}fun floyd(dis: Array<IntArray>, n: Int) {    for (i in 1 .. n) {        for (j in 1 .. n) {            for (k in 1.. n) {                dis[j][k] = min(dis[j][i] + dis[i][k], dis[j][k])            }        }    }    for (i in 1 .. n) dis[i][i] = 0} fun print(dis: Array<IntArray>, n: Int) {    for (i in 1.. n) {        for (j in 1.. n) {            print(""${dis[i][j]} "")        }        println("""")    }} fun main(args: Array<String>) {    val cin = Scanner(System.`in`)    var str = cin.nextLine().toCharArray()    var i = str.size - 1    var ans = 0    while (true) {        if (str[i] == '0') ans ++        else {            if (ans > 0) ans --            else str[i] = '0'        }        i --        if (i < 0) break    }    println(str)}    		  	 		 	 	  		 				 					","brute force,greedy,strings"
"fun main() {    val s = readLn()    val n = s.length     val t = IntArray(n) { s[it] - '0' }     val ls = IntArray(n+1)    val os = IntArray(n+1)     for (i in n-1 downTo 0) {        os[i] = os[i + 1]        ls[i] = ls[i + 1]         when(t[i]) {            0 -> {                ls[i]++            }            1 -> {                os[i]++                ls.checkMax(i, os[i])            }        }    }     val L = ls[0]    var lp = 0    var zp = 0    for(i in 0 until n) {        when(t[i]) {            0 -> {                zp++                if(lp < zp) lp = zp            }            1 -> {                if(maxOf(lp + os[i+1], zp + 1 + ls[i+1]) == L) {                    t[i] = 0                    zp++                }                lp++            }        }    }     println(t.joinToString(""""))} fun IntArray.checkMax(i: Int, v: Int) { if(v > this[i]) this[i] = v } fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readDouble() = readLn().toDouble()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readStringSeq() = readLn().splitToSequence(' ')fun readInts() = readStrings().map { it.toInt() }fun readIntSeq() = readStringSeq().map { it.toInt() }fun readDoubles() = readStrings().map { it.toDouble() }fun readDoubleSeq() = readStringSeq().map { it.toDouble() }fun readLongs() = readStrings().map { it.toLong() }fun readLongSeq() = readStringSeq().map { it.toLong() } class Output {    val outputSb = StringBuilder()    fun print(o: Any?) { outputSb.append(o) }    fun println() { outputSb.append('\n') }    fun println(o: Any?) { outputSb.append(o).append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(outputSb) }}inline fun output(block: Output.()->Unit) { Output().apply(block).nowPrint() }","brute force,greedy,strings"
"fun main() {    val s = readLn()    val n = s.length     val t = IntArray(n) { s[it] - '0' }     val lp = IntArray(n+1)    val zp = IntArray(n+1)     for (i in 1..n) {        zp[i] = zp[i - 1]        lp[i] = lp[i - 1]         when(t[i-1]) {            0 -> {                zp[i]++                lp.checkMax(i, zp[i])            }            1 -> {                lp[i]++            }        }    }     val ls = IntArray(n+1)    val os = IntArray(n+1)     for (i in n-1 downTo 0) {        os[i] = os[i + 1]        ls[i] = ls[i + 1]         when(t[i]) {            0 -> {                ls[i]++            }            1 -> {                os[i]++                ls.checkMax(i, os[i])            }        }    }     val L = ls[0]    var z = 1    for(i in 0 until n) {        if(t[i] == 0) continue        if(maxOf(lp[i] + os[i+1], zp[i] + z + ls[i+1]) == L) {            t[i] = 0            z++        }    }     println(t.joinToString(""""))} fun IntArray.checkMax(i: Int, v: Int) { if(v > this[i]) this[i] = v } fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readDouble() = readLn().toDouble()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readStringSeq() = readLn().splitToSequence(' ')fun readInts() = readStrings().map { it.toInt() }fun readIntSeq() = readStringSeq().map { it.toInt() }fun readDoubles() = readStrings().map { it.toDouble() }fun readDoubleSeq() = readStringSeq().map { it.toDouble() }fun readLongs() = readStrings().map { it.toLong() }fun readLongSeq() = readStringSeq().map { it.toLong() } class Output {    val outputSb = StringBuilder()    fun print(o: Any?) { outputSb.append(o) }    fun println() { outputSb.append('\n') }    fun println(o: Any?) { outputSb.append(o).append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(outputSb) }}inline fun output(block: Output.()->Unit) { Output().apply(block).nowPrint() }","brute force,greedy,strings"
"import kotlin.math.max fun main() {    val s = readLine()!!    val t = readLine()!!    val earliest = IntArray(t.length + 1)    val latest = IntArray(t.length + 1)    var k = 0    for (j in 1..s.length) {        if (s[j - 1] == t[k]) {            k++            earliest[k] = j            if (k == t.length) {                break            }        }    }    k = t.length    latest[t.length] = s.length    for (j in s.length - 1 downTo 0) {        if (s[j] == t[k - 1]) {            k--            latest[k] = j            if (k == 0) {                break            }        }    }    var answer = 0    for (j in 0..t.length) {        answer = max(answer, latest[j] - earliest[j])    }    println(answer)}","greedy,implementation"
"private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of ints  fun main(args: Array<String>) {    var s =readLn()    var t = readLn()    var furthest = IntArray(t.length){i->0}     var crr = t.length-1    for (i in s.length-1 downTo 0)        if (s[i].equals(t[crr])){              furthest [crr] = i              crr --              if (crr <0 ) break        }     var maxi = 0     crr = 0    for (i in 0..s.length-1)    if (s[i].equals(t[crr])){        if (crr <t.length-1)        {            maxi = Math.max (maxi, furthest[crr+1]-i-1)            crr ++        }        else {            maxi  = Math.max (maxi,s.length-1-i)            break        }    }    maxi = Math.max  (maxi, furthest[0])     println (maxi)}","greedy,implementation"
"import java.io.*import java.util.*import kotlin.math.* val INPUT = System.`in`!!val OUTPUT = System.out!!val reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun line() = reader.readLine()!!var st: StringTokenizer = StringTokenizer("""")fun read(): String {    while (st.hasMoreTokens().not())        st = StringTokenizer(reader.readLine() ?: return """", "" "")    return st.nextToken()}fun int() = read().toInt()fun ints(n: Int) = List(n) { read().toInt() }fun intArray(n: Int) = IntArray(n) { read().toInt() }val writer = PrintWriter(OUTPUT, false)fun main() { writer.solve(); writer.flush() }fun works(s : String, t : String) : Boolean {    var i = 0; var j = 0    while(i < s.length && j < t.length) {        if(s[i] == t[j]) {            j++        }        i++    }    return j == t.length}fun PrintWriter.solve() {    var tt = 1    //tt = int()    while (tt-- > 0) {        val s = line()        val t = line()        val n = s.length        var max = 0        for(i in 0 until n) {            for(j in i until n) {                val new = s.substring(0, i) + s.substring(j + 1, n)                if(works(new, t)) {                    max = max(max, j - i + 1)                }            }        }        println(max)    }}","greedy,implementation"
"private fun readLn() = readLine()!!private fun readString() = readLn().trim()private fun readInt() = readLn().toInt()private fun readLong() = readLn().toLong()private val regSpace = ""\\s+"".toRegex()private fun readSomeInts(): List<Int> {    return readLn().trim().split(regSpace).map { it.toInt() }}private fun readSomeLongs(): List<Long> {    return readLn().trim().split(regSpace).map { it.toLong() }} fun main() {     val s = readString()    val t = readString()     val result = calcMaxLen(s, t)    println(""$result"")}  fun calcMaxLen(s: String, t: String): Int {    val sLen = s.length    val tLen = t.length    if (sLen == tLen)        return 0     val relIdxs: MutableList<MutableList<Int>> = mutableListOf()    for (j: Int in 0 until tLen) {        val c = t[j]        val idxs = s.withIndex().filter { it.value == c }.map { it.index }        relIdxs.add(idxs.toMutableList())    }     var prevBgnIdx = -1    for (j: Int in 0 until tLen) {        relIdxs[j].removeAll { it <= prevBgnIdx }        prevBgnIdx = relIdxs[j][0]    }     var prevEndIdx = sLen    for (j: Int in tLen - 1 downTo 0) {        relIdxs[j].removeAll { it >= prevEndIdx }        prevEndIdx = relIdxs[j].last()    }     val m0 = relIdxs[0].last()    val mz = sLen - relIdxs.last().first() - 1    val m0z = if (mz > m0) mz else m0      val mp = relIdxs.fold(Pair(m0z, relIdxs[0])) {            (z, prev), xs ->        val mx = xs.last() - prev.first() - 1        Pair(if (mx > z) mx else z, xs)    }     return mp.first}","greedy,implementation"
"from itertools import*for _ in[0]*int(input()):print('YNEOS'[any(a!=b or len([*g])>len([*h])for(a,g),(b,h)in zip_longest(*map(groupby,(input(),input())),fillvalue=(0,0)))::2])","implementation,strings"
"from itertools import*for _ in[0]*int(input()):print('YNEOS'[any(a!=b or len([*g])>len([*h])for(a,g),(b,h)in zip_longest(*map(groupby,(input(),input())),fillvalue=(0,())))::2])","implementation,strings"
"from itertools import*for _ in[0]*int(input()):print('YNEOS'[any(a!=b or len([*g])>len([*h])for(a,g),(b,h)in zip_longest(*map(groupby,(input(),input())),fillvalue=(0,0)))::2])			  		  		 	 		 	    	 	  	","implementation,strings"
"#include<cstdio>char s1[1000005],s2[1000005];int main(){int n;scanf(""%d"",&n);while(n--){scanf(""%s%s"",s1,s2);int p1,p2;for(p1=p2=0;s2[p2];++p2){if(s1[p1]==s2[p2])++p1;else if(!p2||s2[p2]!=s2[p2-1])break;}puts(s2[p2]||s1[p1] ? ""NO"" : ""YES"");}return 0;}","implementation,strings"
"import kotlin.math.min fun main() {    val maxn = 1005    val (n, m) = readLine()!!.split("" "").map { it.toInt() }    var s =  Array(maxn){""""}    for (i in 0 until n) {        s[i] = readLine()!!    }     var dp1 = Array(maxn){Array(maxn){1}}    for (i in 0 until n) {        for (j in 1 until m) {            if (s[i][j] == s[i][j - 1]) dp1[i][j] = dp1[i][j - 1] + 1        }    }    var dp2 = Array(maxn){Array(maxn){1}}    for (i in 0 until m) {        for (j in 1 until n) {            if (s[j][i] == s[j - 1][i]) dp2[j][i] = dp2[j - 1][i] + 1        }    }    var dp3 = Array(maxn){Array(maxn){0}}    for (i in 0 until n) {        for (j in 0 until m) {            if (dp2[i][j] == 1) dp3[i][j] = dp1[i][j]            else dp3[i][j] = min(dp1[i][j], dp3[i - 1][j])        }    }     var ans = 0L    for (i in 2 until n) {        for (j in 0 until m) {            val h1 = i            val h2 = h1 - dp2[h1][j]            if (h2 < 0) continue            val h3 = h2 - dp2[h2][j]            if (h3 < 0) continue            if (dp2[h1][j] != dp2[h2][j] || dp2[h2][j] > dp2[h3][j]) continue            var xx = dp1[h3][j]            for (i in 0 until dp2[h1][j]) xx = min(xx, dp1[h3 - i][j])            val d = min(dp3[h1][j], min(dp3[h2][j], xx))            ans += d * 1L        }    }    println(ans)}","brute force,combinatorics,dp,implementation"
"fun main() {    val (n, m) = readInts()    val arr = Array(n) { readLine()!! }     val rows = Array(n) { IntArray(m) }    for (i in (0 until n)) {        var cnt = 1        var ch = arr[i][m - 1]        rows[i][m - 1] = cnt        for (j in (0 until (m - 1)).reversed()) {            if (arr[i][j] == ch) {                cnt++            } else {                cnt = 1                ch = arr[i][j]            }            rows[i][j] = cnt        }    }     val cols = Array(n) { IntArray(m) }    for (j in (0 until m)) {        var cnt = 1        var ch = arr[n - 1][j]        cols[n - 1][j] = cnt        for (i in (0 until (n - 1)).reversed()) {            if (arr[i][j] == ch) {                cnt++            } else {                cnt = 1                ch = arr[i][j]            }            cols[i][j] = cnt        }    }     var result = 0    for (i in 0 until n) {        for (j in 0 until m) {            val c = cols[i][j]            if (i + c * 3 > n || cols[i + c][j] != c || cols[i + c + c][j] < c) continue            var minW = rows[i][j]            for (k in (i + 1) until (i + c * 3)) {                minW = minOf(minW, rows[k][j])            }            result += minW        }    }    println(result)} private fun readInt() = readLine()!!.toInt() private fun readInts() = readLine()!!.split("" "").map { it.toInt() } private fun readLongs() = readLine()!!.split("" "").map { it.toLong() }","brute force,combinatorics,dp,implementation"
"fun main() {    val (n, m) = readInts()    val G = List(n) { readLn() }     var D = arrayOfNulls<DPEntry>(n)    var ans = 0     for(c in 0 until m) {        val Dc = arrayOfNulls<DPEntry>(n)         val runs = mutableListOf(Run(G[0][c], 1)).asReversed()         for(r in 1 until n) {            val color = G[r][c]            if(color == runs[0].c) {                runs[0].n++            } else {                runs.add(0, Run(color, 1))            }             val l = runs[0].n             if(                runs.size >= 3 &&                l == runs[1].n &&                l <= runs[2].n            ) {                val flag = Flag(l, runs[2].c, runs[1].c, runs[0].c)                var w = 1                if(flag == D[r]?.flag) w += D[r]!!.w                Dc[r] = DPEntry(flag, w)                ans += w            }        }         D = Dc    }     println(ans)} data class Flag(val l: Int, val c1: Char, val c2: Char, val c3: Char)data class DPEntry(val flag: Flag, val w: Int)data class Run(val c: Char, var n: Int) fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readDouble() = readLn().toDouble()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readStringSeq() = readLn().splitToSequence(' ')fun readInts() = readStrings().map { it.toInt() }fun readIntSeq() = readStringSeq().map { it.toInt() }fun readDoubles() = readStrings().map { it.toDouble() }fun readDoubleSeq() = readStringSeq().map { it.toDouble() }fun readLongs() = readStrings().map { it.toLong() }fun readLongSeq() = readStringSeq().map { it.toLong() } class Output {    val outputSb = StringBuilder()    fun print(o: Any?) { outputSb.append(o) }    fun println() { outputSb.append('\n') }    fun println(o: Any?) { outputSb.append(o).append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(outputSb) }}inline fun output(block: Output.()->Unit) { Output().apply(block).nowPrint() }","brute force,combinatorics,dp,implementation"
"fun main() {    val (n, m) = readInts()    val G = List(n) { readLn() }     var D = arrayOfNulls<DPEntry>(n)    var ans = 0     for(c in 0 until m) {        val Dc = arrayOfNulls<DPEntry>(n)         val runs = mutableListOf<Run>().asReversed()         runs.add(Run(G[0][c], 1))         for(r in 1 until n) {            val color = G[r][c]            if(color == runs[0].c) {                runs[0].n++            } else {                runs.add(0, Run(color, 1))            }             val l = runs[0].n             if(                runs.size >= 3 &&                l == runs[1].n &&                l <= runs[2].n            ) {                val flag = Flag(l, runs[2].c, runs[1].c, runs[0].c)                var w = 1                if(flag == D[r]?.flag) w += D[r]!!.w                Dc[r] = DPEntry(flag, w)                ans += w            }        }         D = Dc    }     println(ans)} data class Flag(val l: Int, val c1: Char, val c2: Char, val c3: Char)data class DPEntry(val flag: Flag, val w: Int)data class Run(val c: Char, var n: Int) fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readDouble() = readLn().toDouble()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readStringSeq() = readLn().splitToSequence(' ')fun readInts() = readStrings().map { it.toInt() }fun readIntSeq() = readStringSeq().map { it.toInt() }fun readDoubles() = readStrings().map { it.toDouble() }fun readDoubleSeq() = readStringSeq().map { it.toDouble() }fun readLongs() = readStrings().map { it.toLong() }fun readLongSeq() = readStringSeq().map { it.toLong() } class Output {    val outputSb = StringBuilder()    fun print(o: Any?) { outputSb.append(o) }    fun println() { outputSb.append('\n') }    fun println(o: Any?) { outputSb.append(o).append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(outputSb) }}inline fun output(block: Output.()->Unit) { Output().apply(block).nowPrint() }","brute force,combinatorics,dp,implementation"
import java.util.* fun main() {    val jin = Scanner(System.`in`)    val n = jin.nextInt()    val strip = IntArray(n + 1) { jin.nextInt() }    val dp = Array(n + 2) { Array(n + 2) { M1 } }    for (l in n downTo 1) {        var leastColor = n + 1        var leastColorIx = -1        for (r in l..n) {            if (strip[r] < leastColor) {                leastColor = strip[r]                leastColorIx = r            }            var leftSum = M0            for (a in l..leastColorIx) {                leftSum += dp[l][a - 1] * dp[a][leastColorIx - 1]            }            var rightSum = M0            for (b in leastColorIx..r) {                rightSum += dp[leastColorIx + 1][b] * dp[b + 1][r]            }            dp[l][r] = leftSum * rightSum        }    }    println(dp[1][n])} val M0 = Mint(0)val M1 = Mint(1)val M2 = Mint(2) val MOD: Long = 998244353val MOD_TOTIENT = (MOD - 1).toInt() fun mint(num: Long) = Mint(num % MOD)fun mint(num: Int) = Mint(num % MOD) inline class Mint(val num: Long) {     operator fun plus(k: Mint) = mint(num + k.num)    operator fun minus(k: Mint) = mint(num + MOD - k.num)    operator fun times(k: Mint) = mint(num * k.num)    operator fun div(k: Mint) = this * (k pow -1)     operator fun unaryMinus() = mint(MOD - num)    operator fun inc() = this + M1    operator fun dec() = this - M1     infix fun pow(power: Int): Mint {        var e = power        e %= MOD_TOTIENT        if (e < 0) {            e += MOD_TOTIENT        }        if (e == 0 && num == 0L) {            return this        }        var b = this        var res = Mint(1)        while (e > 0) {            if (e and 1 != 0) {                res *= b            }            b *= b            e = e shr 1        }        return res    }     override fun toString(): String = num.toString()},"combinatorics,dfs and similar,dp"
"fun main() {    val (n, m) = readInts()     val c = readInts()     val D = Array(m+1) { ModIntArray(m+1) { ModInt(1) } }     for(l in 1..m) {        for(a in 0..m - l) {            val j = (0 until l).minBy { c[a + it] }!!             val left = (0..j).fold(ModInt(0)) { acc: ModInt, i: Int ->                acc + D[a][i] * D[a+i][j-i]            }            val right = (j+1..l).fold(ModInt(0)) { acc: ModInt, i: Int ->                acc + D[a+j+1][i-j-1] * D[a+i][l-i]            }             D[a][l] = left * right        }    }     println(D[0][m])} infix fun Int.umod(base: Int) =    (this % base).let { if(it >= 0) it else it + base } infix fun Long.umod(base: Long) =    (this % base).let { if(it >= 0) it else it + base } infix fun Long.umod(base: Int) =    (this % base).let { if(it >= 0) it else it + base } fun Int.mulMod(other: Int, mod: Int) = (toLong() * other).umod(mod).toInt() fun Int.powMod(exponent: Int, mod: Int): Int {    var res = 1    var e = exponent    var b = this     while(e > 0) {        if(e and 1 == 1) {            res = res.mulMod(b, mod)        }        e = e shr 1        b = b.mulMod(b, mod)    }    return res} /** modint inline class, requires hardcoded mod base **/const val MODBASE = 998244353 fun Int.toModInt() = ModInt(this umod MODBASE)fun Long.toModInt() = ModInt((this umod MODBASE).toInt()) /** note: Only use constructor for int within modulo range, otherwise use toModInt **/inline class ModInt(val int: Int) {    operator fun plus(other: ModInt) = plus(other.int) // MODBASE < 2^30    operator fun plus(other: Int) =  (int + other).toModInt() // careful of possible overflow    operator fun inc() = plus(1)     operator fun minus(other: ModInt) = minus(other.int)    operator fun minus(other: Int) = (int - other).toModInt()    operator fun dec() = minus(1)    operator fun unaryMinus() = if(int == 0) this else ModInt(MODBASE - int)     operator fun times(other: ModInt) = times(other.int)    operator fun times(other: Int) = ModInt(int.mulMod(other, MODBASE))     fun pow(exponent: Int): ModInt {        val e = if(exponent < 0) exponent umod MODBASE - 1 else exponent // assumes MODBASE is prime        return ModInt(int.powMod(e, MODBASE))    }     fun inv() = pow(MODBASE - 2) // assumes MODBASE is prime     operator fun div(other: ModInt) = times(other.inv())    operator fun div(other: Int) = div(other.toModInt())     override fun toString() = int.toString()} inline class ModIntArray(val intArray: IntArray): Collection<ModInt> {    operator fun get(i: Int) = ModInt(intArray[i])    operator fun set(i: Int, v: ModInt) { intArray[i] = v.int }     override val size: Int get() = intArray.size     override fun contains(element: ModInt): Boolean = indices.any { get(it) == element }     override fun containsAll(elements: Collection<ModInt>): Boolean = elements.all { contains(it) }     override fun isEmpty(): Boolean = size == 0     override fun iterator(): Iterator<ModInt> = object: Iterator<ModInt> {        var index = 0        override fun hasNext(): Boolean = index < size        override fun next(): ModInt = ModInt(intArray[index++])    }}fun ModIntArray(capacity: Int) = ModIntArray(IntArray(capacity))inline fun ModIntArray(capacity: Int, init: (Int) -> ModInt) =    ModIntArray(IntArray(capacity) { init(it).int }) fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readDouble() = readLn().toDouble()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readInts() = readStrings().map { it.toInt() }fun readDoubles() = readStrings().map { it.toDouble() }fun readLongs() = readStrings().map { it.toLong() } class Output {    private val sb = StringBuilder()    fun print(o: Any?) { sb.append(o) }    fun println() { sb.append('\n') }    fun println(o: Any?) { sb.append(o).append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(sb) }}inline fun output(block: Output.()->Unit)    { Output().apply(block).nowPrint() }","combinatorics,dfs and similar,dp"
"fun main() {    val (n, m) = readInts()     val c = readInts()     val D = Array(m+1) { ModIntArray(m+1-it) { ModInt(1) } }     for(l in 2..m) {        for(a in 0..m - l) {            val j = (0 until l).minBy { c[a + it] }!!             val left = (0..j).fold(ModInt(0)) { acc: ModInt, i: Int ->                acc + D[a][i] * D[a+i][j-i]            }            val right = (j+1..l).fold(ModInt(0)) { acc: ModInt, i: Int ->                acc + D[a+j+1][i-j-1] * D[a+i][l-i]            }             D[a][l] = left * right        }    }     println(D[0][m])} infix fun Int.umod(base: Int) =    (this % base).let { if(it >= 0) it else it + base } infix fun Long.umod(base: Long) =    (this % base).let { if(it >= 0) it else it + base } infix fun Long.umod(base: Int) =    (this % base).let { if(it >= 0) it else it + base } fun Int.mulMod(other: Int, mod: Int) = (toLong() * other).umod(mod).toInt() fun Int.powMod(exponent: Int, mod: Int): Int {    var res = 1    var e = exponent    var b = this     while(e > 0) {        if(e and 1 == 1) {            res = res.mulMod(b, mod)        }        e = e shr 1        b = b.mulMod(b, mod)    }    return res} /** modint inline class, requires hardcoded mod base **/const val MODBASE = 998244353 fun Int.toModInt() = ModInt(this umod MODBASE)fun Long.toModInt() = ModInt((this umod MODBASE).toInt()) /** note: Only use constructor for int within modulo range, otherwise use toModInt **/inline class ModInt(val int: Int) {    operator fun plus(other: ModInt) = plus(other.int) // MODBASE < 2^30    operator fun plus(other: Int) =  (int + other).toModInt() // careful of possible overflow    operator fun inc() = plus(1)     operator fun minus(other: ModInt) = minus(other.int)    operator fun minus(other: Int) = (int - other).toModInt()    operator fun dec() = minus(1)    operator fun unaryMinus() = if(int == 0) this else ModInt(MODBASE - int)     operator fun times(other: ModInt) = times(other.int)    operator fun times(other: Int) = ModInt(int.mulMod(other, MODBASE))     fun pow(exponent: Int): ModInt {        val e = if(exponent < 0) exponent umod MODBASE - 1 else exponent // assumes MODBASE is prime        return ModInt(int.powMod(e, MODBASE))    }     fun inv() = pow(MODBASE - 2) // assumes MODBASE is prime     operator fun div(other: ModInt) = times(other.inv())    operator fun div(other: Int) = div(other.toModInt())     override fun toString() = int.toString()} inline class ModIntArray(val intArray: IntArray): Collection<ModInt> {    operator fun get(i: Int) = ModInt(intArray[i])    operator fun set(i: Int, v: ModInt) { intArray[i] = v.int }     override val size: Int get() = intArray.size     override fun contains(element: ModInt): Boolean = indices.any { get(it) == element }     override fun containsAll(elements: Collection<ModInt>): Boolean = elements.all { contains(it) }     override fun isEmpty(): Boolean = size == 0     override fun iterator(): Iterator<ModInt> = object: Iterator<ModInt> {        var index = 0        override fun hasNext(): Boolean = index < size        override fun next(): ModInt = ModInt(intArray[index++])    }}fun ModIntArray(capacity: Int) = ModIntArray(IntArray(capacity))inline fun ModIntArray(capacity: Int, init: (Int) -> ModInt) =    ModIntArray(IntArray(capacity) { init(it).int }) fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readDouble() = readLn().toDouble()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readInts() = readStrings().map { it.toInt() }fun readDoubles() = readStrings().map { it.toDouble() }fun readLongs() = readStrings().map { it.toLong() } class Output {    private val sb = StringBuilder()    fun print(o: Any?) { sb.append(o) }    fun println() { sb.append('\n') }    fun println(o: Any?) { sb.append(o).append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(sb) }}inline fun output(block: Output.()->Unit)    { Output().apply(block).nowPrint() }","combinatorics,dfs and similar,dp"
"fun main() {    val (n, m) = readInts()     val c = readInts()    val lo = IntArray(m) { it }     val D = Array(m+1) { ModIntArray(m+1-it) { ModInt(1) } }     for(l in 2..m) {        for(a in 0..m - l) {            if(c[lo[a+1]] < c[lo[a]]) lo[a] = lo[a+1]            val j = lo[a] - a             val left = (0..j).fold(ModInt(0)) { acc: ModInt, i: Int ->                acc + D[a][i] * D[a+i][j-i]            }            val right = (j+1..l).fold(ModInt(0)) { acc: ModInt, i: Int ->                acc + D[a+j+1][i-(j+1)] * D[a+i][l-i]            }             D[a][l] = left * right        }    }     println(D[0][m])} infix fun Int.umod(base: Int) =    (this % base).let { if(it >= 0) it else it + base } infix fun Long.umod(base: Long) =    (this % base).let { if(it >= 0) it else it + base } infix fun Long.umod(base: Int) =    (this % base).let { if(it >= 0) it else it + base } fun Int.mulMod(other: Int, mod: Int) = (toLong() * other).umod(mod).toInt() fun Int.powMod(exponent: Int, mod: Int): Int {    var res = 1    var e = exponent    var b = this     while(e > 0) {        if(e and 1 == 1) {            res = res.mulMod(b, mod)        }        e = e shr 1        b = b.mulMod(b, mod)    }    return res} /** modint inline class, requires hardcoded mod base **/const val MODBASE = 998244353 fun Int.toModInt() = ModInt(this umod MODBASE)fun Long.toModInt() = ModInt((this umod MODBASE).toInt()) /** note: Only use constructor for int within modulo range, otherwise use toModInt **/inline class ModInt(val int: Int) {    operator fun plus(other: ModInt) = plus(other.int) // MODBASE < 2^30    operator fun plus(other: Int) =  (int + other).toModInt() // careful of possible overflow    operator fun inc() = plus(1)     operator fun minus(other: ModInt) = minus(other.int)    operator fun minus(other: Int) = (int - other).toModInt()    operator fun dec() = minus(1)    operator fun unaryMinus() = if(int == 0) this else ModInt(MODBASE - int)     operator fun times(other: ModInt) = times(other.int)    operator fun times(other: Int) = ModInt(int.mulMod(other, MODBASE))     fun pow(exponent: Int): ModInt {        val e = if(exponent < 0) exponent umod MODBASE - 1 else exponent // assumes MODBASE is prime        return ModInt(int.powMod(e, MODBASE))    }     fun inv() = pow(MODBASE - 2) // assumes MODBASE is prime     operator fun div(other: ModInt) = times(other.inv())    operator fun div(other: Int) = div(other.toModInt())     override fun toString() = int.toString()} inline class ModIntArray(val intArray: IntArray): Collection<ModInt> {    operator fun get(i: Int) = ModInt(intArray[i])    operator fun set(i: Int, v: ModInt) { intArray[i] = v.int }     override val size: Int get() = intArray.size     override fun contains(element: ModInt): Boolean = indices.any { get(it) == element }     override fun containsAll(elements: Collection<ModInt>): Boolean = elements.all { contains(it) }     override fun isEmpty(): Boolean = size == 0     override fun iterator(): Iterator<ModInt> = object: Iterator<ModInt> {        var index = 0        override fun hasNext(): Boolean = index < size        override fun next(): ModInt = ModInt(intArray[index++])    }}fun ModIntArray(capacity: Int) = ModIntArray(IntArray(capacity))inline fun ModIntArray(capacity: Int, init: (Int) -> ModInt) =    ModIntArray(IntArray(capacity) { init(it).int }) fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readDouble() = readLn().toDouble()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readInts() = readStrings().map { it.toInt() }fun readDoubles() = readStrings().map { it.toDouble() }fun readLongs() = readStrings().map { it.toLong() } class Output {    private val sb = StringBuilder()    fun print(o: Any?) { sb.append(o) }    fun println() { sb.append('\n') }    fun println(o: Any?) { sb.append(o).append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(sb) }}inline fun output(block: Output.()->Unit)    { Output().apply(block).nowPrint() }","combinatorics,dfs and similar,dp"
"fun suffics(a: List<Int>): Int {    var j = 0     for (i in 0..a.size - 1) {        if (a[i] == 1) {            j = i            break        }    }     for (i in j..a.size - 2) {        if (a[i + 1] != a[i] + 1) {            return -1        }    }     return j}  fun main() {    var n = readLine()!!.toInt()     var a = readLine()!!.split("" "").map { it.toInt() }    var b = readLine()!!.split("" "").map { it.toInt() }     var max = 0     for (i in 0..n - 1) {        if (a[i] != 0)            max = maxOf(max, n - a[i] + 1)    }     for (i in 0..n - 1) {        if (b[i] != 0)            max = maxOf(max, i + 1 + n - b[i] + 1)    }     var res = suffics(b)     if (res == -1) {        println(max)        return    }     var max1 = 0     for (i in 0..n - 1) {        if (a[i] != 0)            max1 = maxOf(max1, n - a[i] + 1)    }     for (i in 0..res - 1) {        if (b[i] != 0)            max1 = maxOf(max1, i + 1 + n - b[i] + 1)    }     if(max1 <= res) println(max1)    else println(max)      }","greedy,implementation"
"fun fastReadInts(n: Int): IntArray {  val xs = IntArray(n)  val s = readLine()!!  var currentValue = 0  var isNegative = false  var currentIndex = 0  for (c in s) {    if (c == ' ') {      xs[currentIndex] = currentValue * if (isNegative) -1 else 1      currentValue = 0      isNegative = false      currentIndex++    } else if (c == '-') {      isNegative = true    } else {      currentValue *= 10      currentValue += c - '0'    }  }  xs[currentIndex] = currentValue * if (isNegative) -1 else 1  return xs} fun main(args: Array<String>) {  val n = readLine()!!.toInt()  val hs = fastReadInts(n)  val ps = fastReadInts(n)   val xs = IntArray(n + 1)  for (i in 0 until n) {    xs[ps[i]] = i + 1  }   var ans = 2 * n  val ans1 = (1..n).map { xs[it] + n + 1 - it }.max()!!  ans = Math.min(ans, ans1)  if (ps.contains(1)) {    val s = ps.indexOf(1)    val isValidSuffix = (s until n).all { ps[it] == it - s + 1 }    if (isValidSuffix) {      val m = ps.last()      val isValid = ((m + 1)..n).all { xs[it] <= it - (m + 1) }      if (isValid) {        val ans2 = n - m        ans = Math.min(ans, ans2)      }    }  }   println(ans)}","greedy,implementation"
"import kotlin.math.* fun main() {    val n = readLine()!!.toInt()    val a = readLine()!!.splitToIntArray() // hand    val b = readLine()!!.splitToIntArray() // pile    println(solveArr(n, b, a))} private fun solveArr(n: Int, b: IntArray, a: IntArray): Int {    val start = findStart(b, n)    val hs = BooleanArray(n + 1)    for (x in a) if (x != 0) hs[x] = true    var ok = true    for (step in 0 until start) {        val next = n - start + 1 + step        if (!hs[next]) {            ok = false            break        }        hs[b[step]] = true    }    if (ok) return start    var maxD = 0    for (i in 0 until n) {        if (b[i] != 0) {            val d = 2 + i - b[i]            if (d > maxD) {                maxD = d            }        }    }    return maxD + n} fun findStart(b: IntArray, n: Int): Int {    val i = b.indexOf(1)    if (i < 0) return n    var j = i    while (j < n && b[j] == j - i + 1) {        j++    }    return if (j == n) i else n} private fun String.splitToIntArray(): IntArray {    val n = length    if (n == 0) return IntArray(0) // EMPTY    var res = IntArray(4)    var m = 0    var i = 0    while (true) {        var cur = 0        var neg = false        var c = get(i) // expecting number, IOOB if there is no number        if (c == '-') {            neg = true            i++            c = get(i) // expecting number, IOOB if there is no number        }        while (true) {            val d = c.toInt() - '0'.toInt()            require(d in 0..9) { ""Unexpected character '$c' at $i"" }            require(cur >= Integer.MIN_VALUE / 10) { ""Overflow at $i"" }            cur = cur * 10 - d            require(cur <= 0) { ""Overflow at $i"" }            i++            if (i >= n) break            c = get(i)            if (c == ' ') break        }        if (m >= res.size) res = res.copyOf(res.size * 2)        res[m++] = if (neg) cur else (-cur).also { require(it >= 0) { ""Overflow at $i"" } }        if (i >= n) break        i++    }    if (m < res.size) res = res.copyOf(m)    return res}","greedy,implementation"
"import java.io.PrintWriterimport kotlin.math.* fun main() {    io.apply done@{         val n = int        val hand = ints(n)        val pile = ints(n)         if (pile[n - 1] != 0) {            var ok = true            var v = pile[n - 1] - 1            var ix = n - 2            while (v > 0) {                if (pile[ix] != v) {                    ok = false                    break                }                v--                ix--            }            if (ok) {                var t = pile[n - 1]                for (i in 0 until (n - t)) {                    if (pile[i] != 0 && pile[i] <= t + i + 1) {                        ok = false                        break                    }                }            }            if (ok) {                cout .. (n - pile[n - 1]) .. nl                return@done            }        }        var ans = n        for (i in 0 until n) {            if (pile[i] != 0) {                ans = max(ans, 2 + i + (n - pile[i]))            }        }        cout .. ans .. nl      }.cout.flush()} // @formatter:offprivate val io = object {    private val `in` = System.`in`    private fun ll(): Long {        var x: Int; var q = false; var n = 0L; do x = `in`.read() while (x < 33); if (x == 45) { q = true; x = `in`.read() }        do { n = n * 10 - x + 48; x = `in`.read() } while (x > 32); return if (q) n else -n    }    val int get() = ll().toInt(); val long get() = ll()    fun ints(n: Int = int): IntArray { return IntArray(n) { int } }    fun ints1(n: Int = int): IntArray { return IntArray(n) { int - 1 } }    val cout = PrintWriter(System.out); val nl = ""\n""    operator fun PrintWriter.rangeTo(a: Int): PrintWriter { print(a); print("" ""); return this }    operator fun PrintWriter.rangeTo(a: Long): PrintWriter { print(a); print("" ""); return this }    operator fun PrintWriter.rangeTo(a: IntArray): PrintWriter { a.forEach { print(it); print("" "") }; return this }    operator fun PrintWriter.rangeTo(a: String): PrintWriter { write(a); return this }} // @formatter:on /* ----------- */ ","greedy,implementation"
"import java.io.*import java.util.* val reader = BufferedReader(InputStreamReader(System.`in`))val writer = PrintWriter(System.out) const val maxN = 100100 var connected = Array(maxN) { TreeSet<Int>() }var goodConnections = Array(maxN) { TreeSet<Int>() }var lastColorConnection = Array(maxN) { TreeMap<Int, Int>() }var parent = IntArray(maxN) fun merge(x: Int, y: Int) {    var a = parent[x]    var b = parent[y]    if (a == b) return    if (connected[a].size < connected[b].size) {        var tmp = a        a = b        b = tmp    }    for (v in goodConnections[b]) {        goodConnections[a].add(v)        parent[v] = a    }    for (v in connected[b]) {        connected[a].add(v)    }} fun addEdge(x: Int, y: Int, z: Int) {    var pa = parent[x]    var pb = parent[y]    connected[pa].add(y)    connected[pb].add(x)    if (lastColorConnection[x][z] != null) {        merge(y, lastColorConnection[x][z]!!.toInt())    }    if (lastColorConnection[y][z] != null) {        merge(x, lastColorConnection[y][z]!!.toInt())    }    lastColorConnection[x][z] = y    lastColorConnection[y][z] = x} fun main() {    var (n, m, c, q) = reader.readLine()!!.split("" "").map { it.toInt() }    n += c * 0    for (i in 1..n) {        goodConnections[i].add(i)        parent[i] = i        connected[i].add(i)    }    for (i in 1..m) {        var (x, y, z) = reader.readLine()!!.split("" "").map { it.toInt() }        addEdge(x, y, z)    }     for (i in 1..q) {        var st = StringTokenizer(reader.readLine())        if (st.nextToken()!![0] == '+') {            var x = st.nextToken()!!.toInt()            var y = st.nextToken()!!.toInt()            var z = st.nextToken()!!.toInt()            addEdge(x, y, z)        } else {            var from = st.nextToken()!!.toInt()            var to = st.nextToken()!!.toInt()            from = parent[from]            if (connected[from].contains(to)) {                writer.print(""Yes\n"")            } else {                writer.print(""No\n"")            }        }    }     writer.close()}","data structures,dsu,graphs,hashing"
"import java.io.*import java.util.* val reader = BufferedReader(InputStreamReader(System.`in`))val writer = PrintWriter(System.out) const val maxN = 100100 var connected = Array(maxN) { HashSet<Int>() }var goodConnections = Array(maxN) { HashSet<Int>() }var lastColorConnection = Array(maxN) { HashMap<Int, Int>() }var parent = IntArray(maxN) fun merge(x: Int, y: Int) {    var a = parent[x]    var b = parent[y]    if (a == b) return    if (connected[a].size < connected[b].size) {        var tmp = a        a = b        b = tmp    }    for (v in goodConnections[b]) {        goodConnections[a].add(v)        parent[v] = a    }    for (v in connected[b]) {        connected[a].add(v)    }} fun addEdge(x: Int, y: Int, z: Int) {    var pa = parent[x]    var pb = parent[y]    connected[pa].add(y)    connected[pb].add(x)    if (lastColorConnection[x][z] != null) {        merge(y, lastColorConnection[x][z]!!.toInt())    }    if (lastColorConnection[y][z] != null) {        merge(x, lastColorConnection[y][z]!!.toInt())    }    lastColorConnection[x][z] = y    lastColorConnection[y][z] = x} fun main() {    var (n, m, c, q) = reader.readLine()!!.split("" "").map { it.toInt() }    n += c * 0    for (i in 1..n) {        goodConnections[i].add(i)        parent[i] = i        connected[i].add(i)    }    for (i in 1..m) {        var (x, y, z) = reader.readLine()!!.split("" "").map { it.toInt() }        addEdge(x, y, z)    }     for (i in 1..q) {        var st = StringTokenizer(reader.readLine())        if (st.nextToken()!![0] == '+') {            var x = st.nextToken()!!.toInt()            var y = st.nextToken()!!.toInt()            var z = st.nextToken()!!.toInt()            addEdge(x, y, z)        } else {            var from = st.nextToken()!!.toInt()            var to = st.nextToken()!!.toInt()            from = parent[from]            if (connected[from].contains(to)) {                writer.print(""Yes\n"")            } else {                writer.print(""No\n"")            }        }    }     writer.close()}","data structures,dsu,graphs,hashing"
"fun main() {    val n = readInt()    val cnt = IntArray(n)    for(ai in readIntSeq()) { cnt[ai-1]++ }     var pWin = ModInt(0)    var D = ModIntArray(n) { ModInt(cnt[it]) / n }     for(t in 1 until n) {        val cardsLeft = n - t        val Dt = ModIntArray(n)        var ps = ModInt(0)        for(i in t-1 until n) {             pWin += D[i] * (cnt[i] - 1) / cardsLeft             Dt[i] = ps * cnt[i] / cardsLeft             ps += D[i]        }        D = Dt    }     println(pWin)} infix fun Int.umod(base: Int) =    (this % base).let { if(it >= 0) it else it + base } infix fun Long.umod(base: Long) =    (this % base).let { if(it >= 0) it else it + base } infix fun Long.umod(base: Int) =    (this % base).let { if(it >= 0) it else it + base } fun Int.mulMod(other: Int, mod: Int) = (toLong() * other).umod(mod).toInt() fun Int.powMod(exponent: Int, mod: Int): Int {    var res = 1    var e = exponent    var b = this     while(e > 0) {        if(e and 1 == 1) {            res = res.mulMod(b, mod)        }        e = e shr 1        b = b.mulMod(b, mod)    }    return res} /** modint inline class, requires hardcoded mod base **/const val MODBASE = 998244353 inline fun Int.toModInt() = ModInt(this umod MODBASE)inline fun Long.toModInt() = ModInt((this umod MODBASE).toInt()) /** note: Only use constructor for int within modulo range, otherwise use toModInt **/inline class ModInt(val int: Int) {    companion object {        val _invMemo = HashMap<ModInt, ModInt>()    }     inline operator fun plus(other: ModInt) = plus(other.int) // MODBASE < 2^30    inline operator fun plus(other: Int) =  (int + other).toModInt() // careful of possible overflow    inline operator fun inc() = plus(1)     inline operator fun minus(other: ModInt) = minus(other.int)    inline operator fun minus(other: Int) = (int - other).toModInt()    inline operator fun dec() = minus(1)    operator fun unaryMinus() = if(int == 0) this else ModInt(MODBASE - int)     inline operator fun times(other: ModInt) = times(other.int)    inline operator fun times(other: Int) = ModInt(int.mulMod(other, MODBASE))     fun pow(exponent: Int): ModInt {        val e = if(exponent < 0) exponent umod MODBASE - 1 else exponent // assumes MODBASE is prime        return ModInt(int.powMod(e, MODBASE))    }     inline fun inv() = inv_memoized() /** NOTE: Change if necessary */     fun inv_unmemoized() = pow(MODBASE - 2) // assumes MODBASE is prime    fun inv_memoized() = _invMemo.getOrPut(this, ::inv_unmemoized)     operator fun div(other: ModInt) = times(other.inv())    inline operator fun div(other: Int) = div(other.toModInt())     override fun toString() = int.toString()} inline class ModIntArray(val intArray: IntArray): Collection<ModInt> {    inline operator fun get(i: Int) = ModInt(intArray[i])    inline operator fun set(i: Int, v: ModInt) { intArray[i] = v.int }     override val size: Int get() = intArray.size     override fun contains(element: ModInt): Boolean = any { it == element }     override fun containsAll(elements: Collection<ModInt>): Boolean = elements.all(::contains)     override fun isEmpty(): Boolean = size == 0     override fun iterator(): Iterator<ModInt> = object: Iterator<ModInt> {        var index = 0        override fun hasNext(): Boolean = index < size        override fun next(): ModInt = get(index++)    }}fun ModIntArray(capacity: Int) = ModIntArray(IntArray(capacity))inline fun ModIntArray(capacity: Int, init: (Int) -> ModInt) =    ModIntArray(IntArray(capacity) { init(it).int }) fun Iterable<ModInt>.sum() = fold(ModInt(0), ModInt::plus)fun Sequence<ModInt>.sum() = fold(ModInt(0), ModInt::plus)fun Iterable<ModInt>.product() = fold(ModInt(1), ModInt::times)fun Sequence<ModInt>.product() = fold(ModInt(1), ModInt::times) fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readDouble() = readLn().toDouble()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readStringSeq() = readLn().splitToSequence(' ')fun readInts() = readStrings().map { it.toInt() }fun readIntSeq() = readStringSeq().map { it.toInt() }fun readIntArray(size: Int) = readIntSeq().iterator().let { i -> IntArray(size) { i.next() } }fun readDoubles() = readStrings().map { it.toDouble() }fun readDoubleSeq() = readStringSeq().map { it.toDouble() }fun readDoubleArray(size: Int) = readDoubleSeq().iterator().let { i -> DoubleArray(size) { i.next() } }fun readLongs() = readStrings().map { it.toLong() }fun readLongSeq() = readStringSeq().map { it.toLong() }fun readLongArray(size: Int) = readLongSeq().iterator().let { i -> LongArray(size) { i.next() } } class Output {    private val sb = StringBuilder()    fun print(o: Any?) { sb.append(o) }    fun println() { sb.append('\n') }    fun println(o: Any?) { sb.append(o).append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(sb) }}inline fun output(block: Output.()->Unit) { Output().apply(block).nowPrint() }","dp,math,probabilities"
"fun main() {    val n = readInt()    val cnt = IntArray(n)    for(ai in readIntSeq()) { cnt[ai-1]++ }     var pWin = ModInt(0)    var D = ModIntArray(n) { ModInt(cnt[it]) / n }     for(t in 1 until n) {        val cardsLeft = n - t        val Dt = ModIntArray(n)        var ps = ModInt(0)        for(i in t-1 until n) {            if(cnt[i] == 0) continue             pWin += D[i] * (cnt[i] - 1) / cardsLeft             Dt[i] = ps * cnt[i] / cardsLeft             ps += D[i]        }        D = Dt    }     println(pWin)} infix fun Int.umod(base: Int) =    (this % base).let { if(it >= 0) it else it + base } infix fun Long.umod(base: Long) =    (this % base).let { if(it >= 0) it else it + base } infix fun Long.umod(base: Int) =    (this % base).let { if(it >= 0) it else it + base } fun Int.mulMod(other: Int, mod: Int) = (toLong() * other).umod(mod).toInt() fun Int.powMod(exponent: Int, mod: Int): Int {    var res = 1    var e = exponent    var b = this     while(e > 0) {        if(e and 1 == 1) {            res = res.mulMod(b, mod)        }        e = e shr 1        b = b.mulMod(b, mod)    }    return res} /** modint inline class, requires hardcoded mod base **/const val MODBASE = 998244353 inline fun Int.toModInt() = ModInt(this umod MODBASE)inline fun Long.toModInt() = ModInt((this umod MODBASE).toInt()) /** note: Only use constructor for int within modulo range, otherwise use toModInt **/inline class ModInt(val int: Int) {    companion object {        val _invMemo = HashMap<ModInt, ModInt>()    }     inline operator fun plus(other: ModInt) = plus(other.int) // MODBASE < 2^30    inline operator fun plus(other: Int) =  (int + other).toModInt() // careful of possible overflow    inline operator fun inc() = plus(1)     inline operator fun minus(other: ModInt) = minus(other.int)    inline operator fun minus(other: Int) = (int - other).toModInt()    inline operator fun dec() = minus(1)    operator fun unaryMinus() = if(int == 0) this else ModInt(MODBASE - int)     inline operator fun times(other: ModInt) = times(other.int)    inline operator fun times(other: Int) = ModInt(int.mulMod(other, MODBASE))     fun pow(exponent: Int): ModInt {        val e = if(exponent < 0) exponent umod MODBASE - 1 else exponent // assumes MODBASE is prime        return ModInt(int.powMod(e, MODBASE))    }     inline fun inv() = inv_memoized() /** NOTE: Change if necessary */     fun inv_unmemoized() = pow(MODBASE - 2) // assumes MODBASE is prime    fun inv_memoized() = _invMemo.getOrPut(this, ::inv_unmemoized)     operator fun div(other: ModInt) = times(other.inv())    inline operator fun div(other: Int) = div(other.toModInt())     override fun toString() = int.toString()} inline class ModIntArray(val intArray: IntArray): Collection<ModInt> {    inline operator fun get(i: Int) = ModInt(intArray[i])    inline operator fun set(i: Int, v: ModInt) { intArray[i] = v.int }     override val size: Int get() = intArray.size     override fun contains(element: ModInt): Boolean = any { it == element }     override fun containsAll(elements: Collection<ModInt>): Boolean = elements.all(::contains)     override fun isEmpty(): Boolean = size == 0     override fun iterator(): Iterator<ModInt> = object: Iterator<ModInt> {        var index = 0        override fun hasNext(): Boolean = index < size        override fun next(): ModInt = get(index++)    }}fun ModIntArray(capacity: Int) = ModIntArray(IntArray(capacity))inline fun ModIntArray(capacity: Int, init: (Int) -> ModInt) =    ModIntArray(IntArray(capacity) { init(it).int }) fun Iterable<ModInt>.sum() = fold(ModInt(0), ModInt::plus)fun Sequence<ModInt>.sum() = fold(ModInt(0), ModInt::plus)fun Iterable<ModInt>.product() = fold(ModInt(1), ModInt::times)fun Sequence<ModInt>.product() = fold(ModInt(1), ModInt::times) fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readDouble() = readLn().toDouble()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readStringSeq() = readLn().splitToSequence(' ')fun readInts() = readStrings().map { it.toInt() }fun readIntSeq() = readStringSeq().map { it.toInt() }fun readIntArray(size: Int) = readIntSeq().iterator().let { i -> IntArray(size) { i.next() } }fun readDoubles() = readStrings().map { it.toDouble() }fun readDoubleSeq() = readStringSeq().map { it.toDouble() }fun readDoubleArray(size: Int) = readDoubleSeq().iterator().let { i -> DoubleArray(size) { i.next() } }fun readLongs() = readStrings().map { it.toLong() }fun readLongSeq() = readStringSeq().map { it.toLong() }fun readLongArray(size: Int) = readLongSeq().iterator().let { i -> LongArray(size) { i.next() } } class Output {    private val sb = StringBuilder()    fun print(o: Any?) { sb.append(o) }    fun println() { sb.append('\n') }    fun println(o: Any?) { sb.append(o).append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(sb) }}inline fun output(block: Output.()->Unit) { Output().apply(block).nowPrint() }","dp,math,probabilities"
"fun main() {    val n = readInt()    val cnt0 = IntArray(n)    for(ai in readIntSeq()) { cnt0[ai-1]++ }     val cnt = cnt0.filter { it != 0 }    val m = cnt.size     var pWin = ModInt(0)    var D = ModIntArray(m) { ModInt(cnt[it]) / n }     for(t in 1 .. minOf(n-1, m)) {        val cardsLeft = n - t        val Dt = ModIntArray(m)        var ps = ModInt(0)        for(i in t-1 until m) {            pWin += D[i] * (cnt[i] - 1) / cardsLeft             Dt[i] = ps * cnt[i] / cardsLeft             ps += D[i]        }        D = Dt    }     println(pWin)} infix fun Int.umod(base: Int) =    (this % base).let { if(it >= 0) it else it + base } infix fun Long.umod(base: Long) =    (this % base).let { if(it >= 0) it else it + base } infix fun Long.umod(base: Int) =    (this % base).let { if(it >= 0) it else it + base } fun Int.mulMod(other: Int, mod: Int) = (toLong() * other).umod(mod).toInt() fun Int.powMod(exponent: Int, mod: Int): Int {    var res = 1    var e = exponent    var b = this     while(e > 0) {        if(e and 1 == 1) {            res = res.mulMod(b, mod)        }        e = e shr 1        b = b.mulMod(b, mod)    }    return res} /** modint inline class, requires hardcoded mod base **/const val MODBASE = 998244353 inline fun Int.toModInt() = ModInt(this umod MODBASE)inline fun Long.toModInt() = ModInt((this umod MODBASE).toInt()) /** note: Only use constructor for int within modulo range, otherwise use toModInt **/inline class ModInt(val int: Int) {    companion object {        val _invMemo = HashMap<ModInt, ModInt>()    }     inline operator fun plus(other: ModInt) = plus(other.int) // MODBASE < 2^30    inline operator fun plus(other: Int) =  (int + other).toModInt() // careful of possible overflow    inline operator fun inc() = plus(1)     inline operator fun minus(other: ModInt) = minus(other.int)    inline operator fun minus(other: Int) = (int - other).toModInt()    inline operator fun dec() = minus(1)    operator fun unaryMinus() = if(int == 0) this else ModInt(MODBASE - int)     inline operator fun times(other: ModInt) = times(other.int)    inline operator fun times(other: Int) = ModInt(int.mulMod(other, MODBASE))     fun pow(exponent: Int): ModInt {        val e = if(exponent < 0) exponent umod MODBASE - 1 else exponent // assumes MODBASE is prime        return ModInt(int.powMod(e, MODBASE))    }     inline fun inv() = inv_memoized() /** NOTE: Change if necessary */     fun inv_unmemoized() = pow(MODBASE - 2) // assumes MODBASE is prime    fun inv_memoized() = _invMemo.getOrPut(this, ::inv_unmemoized)     operator fun div(other: ModInt) = times(other.inv())    inline operator fun div(other: Int) = div(other.toModInt())     override fun toString() = int.toString()} inline class ModIntArray(val intArray: IntArray): Collection<ModInt> {    inline operator fun get(i: Int) = ModInt(intArray[i])    inline operator fun set(i: Int, v: ModInt) { intArray[i] = v.int }     override val size: Int get() = intArray.size     override fun contains(element: ModInt): Boolean = any { it == element }     override fun containsAll(elements: Collection<ModInt>): Boolean = elements.all(::contains)     override fun isEmpty(): Boolean = size == 0     override fun iterator(): Iterator<ModInt> = object: Iterator<ModInt> {        var index = 0        override fun hasNext(): Boolean = index < size        override fun next(): ModInt = get(index++)    }}fun ModIntArray(capacity: Int) = ModIntArray(IntArray(capacity))inline fun ModIntArray(capacity: Int, init: (Int) -> ModInt) =    ModIntArray(IntArray(capacity) { init(it).int }) fun Iterable<ModInt>.sum() = fold(ModInt(0), ModInt::plus)fun Sequence<ModInt>.sum() = fold(ModInt(0), ModInt::plus)fun Iterable<ModInt>.product() = fold(ModInt(1), ModInt::times)fun Sequence<ModInt>.product() = fold(ModInt(1), ModInt::times) fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readDouble() = readLn().toDouble()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readStringSeq() = readLn().splitToSequence(' ')fun readInts() = readStrings().map { it.toInt() }fun readIntSeq() = readStringSeq().map { it.toInt() }fun readIntArray(size: Int) = readIntSeq().iterator().let { i -> IntArray(size) { i.next() } }fun readDoubles() = readStrings().map { it.toDouble() }fun readDoubleSeq() = readStringSeq().map { it.toDouble() }fun readDoubleArray(size: Int) = readDoubleSeq().iterator().let { i -> DoubleArray(size) { i.next() } }fun readLongs() = readStrings().map { it.toLong() }fun readLongSeq() = readStringSeq().map { it.toLong() }fun readLongArray(size: Int) = readLongSeq().iterator().let { i -> LongArray(size) { i.next() } } class Output {    private val sb = StringBuilder()    fun print(o: Any?) { sb.append(o) }    fun println() { sb.append('\n') }    fun println(o: Any?) { sb.append(o).append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(sb) }}inline fun output(block: Output.()->Unit) { Output().apply(block).nowPrint() }","dp,math,probabilities"
"import java.io.PrintWriterimport java.util.StringTokenizerimport kotlin.math.* fun main() {    val n = readInt()    val cnt0 = IntArray(n)    repeat(n) { cnt0[readInt()-1]++ }     val cnt = cnt0.filter { it != 0 }    val m = cnt.size     if(m == n) {        println(0)        return    }     var pWin = ModInt(0)    var D = ModIntArray(m) { ModInt(cnt[it]) / n }     for(t in 1..m) {        val cardsLeft = n - t        val Dt = ModIntArray(m)        var ps = ModInt(0)        for(i in t-1 until m) {            pWin += D[i] * (cnt[i] - 1) / cardsLeft             Dt[i] = ps * cnt[i] / cardsLeft             ps += D[i]        }        D = Dt    }     println(pWin)} const val BILLION7 = 1e9.toInt() + 7const val MODINT_BASE = 998244353 infix fun Int.umod(base: Int) =    (this % base).let { if(it >= 0) it else it + base } infix fun Long.umod(base: Long) =    (this % base).let { if(it >= 0) it else it + base } infix fun Long.umod(base: Int) =    (this % base).let { if(it >= 0) it else it + base } fun Int.mulMod(other: Int, mod: Int) = (toLong() * other).umod(mod).toInt() fun Int.powMod(exponent: Int, mod: Int): Int {    var res = 1L    var e = exponent    var b = umod(mod).toLong()     while(e > 0) {        if(e and 1 == 1) {            res = res * b % mod        }        e = e shr 1        b = b * b % mod    }    return res.toInt()}  inline fun Int.toModInt() = ModInt(this umod MODINT_BASE)inline fun Long.toModInt() = ModInt((this umod MODINT_BASE).toInt()) /** note: Only use constructor for int within modulo range, otherwise use toModInt **/inline class ModInt(val int: Int) {    companion object {        /** can't seem to make these private or inlined without causing compiler issues */        @JvmField val _invMemo = HashMap<ModInt, ModInt>()        fun _invMemoized(m: ModInt) = _invMemo.getOrPut(m) { m.inv_unmemoized() }    }     inline operator fun plus(other: ModInt) = plus(other.int) // MODINT_BASE < 2^30    operator fun plus(other: Int) =  (int + other).toModInt() // careful of possible overflow    inline operator fun inc() = plus(1)     inline operator fun minus(other: ModInt) = minus(other.int)    operator fun minus(other: Int) = (int - other).toModInt()    inline operator fun dec() = minus(1)    operator fun unaryMinus() = if(int == 0) this else ModInt(MODINT_BASE - int)     inline operator fun times(other: ModInt) = times(other.int)    operator fun times(other: Int) = ModInt(int.mulMod(other, MODINT_BASE))     fun pow(exponent: Int): ModInt {        val e = if(exponent < 0) exponent umod MODINT_BASE - 1 else exponent // assumes MODINT_BASE is prime        return ModInt(int.powMod(e, MODINT_BASE))    }     inline fun inverse() = inv_memoized() /** NOTE: Change if necessary */     fun inv_unmemoized(): ModInt {        require(int != 0) { ""Can't invert/divide by 0"" }        return pow(MODINT_BASE - 2) // assumes MODINT_BASE is prime    }    fun inv_memoized() = _invMemoized(this)     operator fun div(other: ModInt) = times(other.inverse())    operator fun div(other: Int) = div(other.toModInt())     override fun toString() = int.toString()} inline class ModIntArray(val intArray: IntArray): Collection<ModInt> {    inline operator fun get(i: Int) = ModInt(intArray[i])    inline operator fun set(i: Int, v: ModInt) { intArray[i] = v.int }     override val size: Int get() = intArray.size     override fun contains(element: ModInt): Boolean = any { it == element }     override fun containsAll(elements: Collection<ModInt>): Boolean = elements.all(::contains)     override fun isEmpty(): Boolean = size == 0     override fun iterator(): Iterator<ModInt> = object: Iterator<ModInt> {        var index = 0        override fun hasNext(): Boolean = index < size        override fun next(): ModInt = get(index++)    }}fun ModIntArray(capacity: Int) = ModIntArray(IntArray(capacity))inline fun ModIntArray(capacity: Int, init: (Int) -> ModInt) =    ModIntArray(IntArray(capacity) { init(it).int }) fun Iterable<ModInt>.sum() = fold(ModInt(0), ModInt::plus)fun Sequence<ModInt>.sum() = fold(ModInt(0), ModInt::plus)fun Iterable<ModInt>.product() = fold(ModInt(1), ModInt::times)fun Sequence<ModInt>.product() = fold(ModInt(1), ModInt::times) /** IO code start */@JvmField val _reader = System.`in`.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readInts(n: Int) = List(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() } @JvmField val _writer = PrintWriter(System.out, false)inline fun output(block: PrintWriter.()->Unit) { _writer.apply(block).flush() }fun iprintln(o: Any?) { println(o) } // immediate println for interactive, bypasses output{} blocks","dp,math,probabilities"
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        IN = BufferedInputStream(fakein.toString().byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} fun getint():Int{ return IO.nextInt() }fun getlong():Long{ return IO.nextLong() }fun getline(n:Int):IntArray{    val ret = IntArray(n);repeat(n){ret[it] = getint()};return ret}fun getlineL(n:Int):LongArray{    val ret = LongArray(n);repeat(n){ret[it] = getlong()};return ret}fun getstr():String{ return IO.nextString() }fun MutableList<Int>.streamint(n:Int){ repeat(n){this.add(getint())}}fun MutableList<Long>.streamlong(n:Int){ repeat(n){this.add(getlong())}}inline fun cases(ask:()->Unit){ val t = getint();repeat(t){ ask() }} val List<Char>.ret:Stringget() = this.joinToString("""")infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    var str = """"    if(this is String){ str = this    }else if(this is Int){ str = this.toString()    }else if(this is Long){ str = this.toString()    }    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    inline fun cases(a:solve.()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint()} else if(mode == solveMode.tc){1 } else randCount        //safety checks        if(pI != 998_244_353 && pI != 1_000_000_007){            throw Exception(""Modding a wrong prime!"")        }         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            currentAnswer = null            currentBruteAnswer = null            a()        }        if(withBruteForce){            put(""Checked ${answersChecked}"")        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    inline fun brute(a:()->Unit){        if(withBruteForce){            a()        }    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }      var currentAnswer:String? = null    var currentBruteAnswer:String? = null    fun answer(a:Any){        currentAnswer = a.toString()        if(currentBruteAnswer != null){            checkAnswer()        }    }    fun put2(a:Any){answer(a);put(a) }     fun bruteAnswer(a:Any){        currentBruteAnswer = a.toString()        if(currentAnswer != null){            checkAnswer()        }    }    fun checkAnswer(){        if(currentAnswer != currentBruteAnswer){            throw Exception(""Failed Test: BF $currentBruteAnswer Current $currentAnswer"")        }        answersChecked ++    }}// 1. Moddedconst val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}infix fun Int.modM(b:Int):Int{ return ((this * 1L * b) % pI).toInt() }infix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }fun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val Boolean.chi:Int get() = if(this) 1 else 0 //characteristic function// 2. DP initial valuesconst val plarge = 1_000_000_727const val nlarge = -plargeconst val phuge = 2_727_000_000_000_000_000Lconst val nhuge = -phugeval Char.code :Int get() = this.toInt() -  'a'.toInt()    const val withBruteForce = falseconst val randCount = 100fun main(){    solve.cases{        val n = getint()         val L = getline(n)        val max = 10_000_005        val all = IntArray(max){-1}        var ret = Long.MAX_VALUE        var id1 = -1        var id2 = -1        for((i,c) in L.withIndex()){            if(all[c] != -1){                val new = c                if(new < ret){                    ret = new.toLong()                    id1 = all[c]                    id2 = i                }            }            all[c] = i        }           first@for(d in 1 until max){            var found1 = -1            var found1i = -1             for(s in d until max step d){                if(all[s] >= 0){                    if(found1 == -1){                        found1 = s						found1i = all[s]                    }else{                        val new = 1L * found1 *s /d                        if(new < ret){                            ret = new                            id1 = found1i                            id2 = all[s]                        }                        continue@first                    }                }            }        }        put(minOf(id1,id2) + 1)        put(maxOf(id1,id2) + 1)    }    done()}const val singleCase = true","brute force,greedy,math,number theory"
"import java.io.PrintWriter val ouf = PrintWriter(System.out) data class A(val i: Int, val a: Int) fun main() {    val n = readLine()!!.toInt()    val s = readLine()!!.split(' ').mapIndexed { i, q -> A(i + 1, q.toInt()) }.sortedBy { it.a }    val t = readLine()!!.split(' ').mapIndexed { i, q -> A(i + 1, q.toInt()) }.sortedBy { it.a }    var sumPos = 0L    var sumNeg = 0L    val d = IntArray(n) {        val dd = t[it].a - s[it].a        if (dd > 0) sumPos += dd        if (dd < 0) sumNeg -= dd        dd    }    if (sumPos != sumNeg) {        ouf.println(""NO"")    } else {        val ans = ArrayList<Triple<Int, Int, Int>>()        var fPos = d.indexOfFirst { it > 0 }        var fNeg = d.indexOfFirst { it < 0 }        if (fPos == -1) fPos = n        if (fNeg == -1) fNeg = n        while (fPos != n && fNeg != n && fPos < fNeg) {            val dd = minOf(d[fPos], -d[fNeg])            ans.add(Triple(s[fPos].i, s[fNeg].i, dd))            d[fPos] -= dd            d[fNeg] += dd            while (fPos < n && d[fPos] <= 0) fPos++            while (fNeg < n && d[fNeg] >= 0) fNeg++        }        if (fPos == n && fNeg == n) {            ouf.println(""YES"")            ouf.println(ans.size)            ans.forEach {                ouf.println(""${it.first} ${it.second} ${it.third}"")            }        } else {            ouf.println(""NO"")        }    }     ouf.close()}","constructive algorithms,greedy,math,sortings,two pointers"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"") import java.io.PrintWriterimport java.util.StringTokenizerimport kotlin.math.*import kotlin.random.*import kotlin.system.exitProcessimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() {    output {        val n = readInt()         val S = Array(n) { Stone(it+1, readInt()) }        val T = readIntArray(n)         S.sortBy { it.pos }        T.sort()         val stack = mutableListOf<Entry>()        val ans = mutableListOf<String>()        fun op(i: Int, j: Int, d: Int) {            ans.add(""$i $j $d"")        }         for(i in 0 until n) {            var diff = T[i] - S[i].pos            if(diff > 0) {                stack.add(Entry(S[i].id, diff))            } else while(diff < 0) {                if(stack.isEmpty()) fail()                val sj = stack.last()                val d = min(-diff, sj.diff)                op(sj.id, S[i].id, d)                sj.diff -= d                diff += d                if(sj.diff == 0) stack.removeAt(stack.lastIndex)            }        }         if(stack.isNotEmpty()) fail()         println(""YES"")        println(ans.size)        ans.forEach(::println)    }} data class Stone(val id: Int, val pos: Int)data class Entry(val id: Int, var diff: Int) fun fail(): Nothing {    iprintln(""NO"")    exitProcess(0)} /** IO code start *///@JvmField val INPUT = File(""input.txt"").inputStream()//@JvmField val OUTPUT = File(""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out @JvmField val _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false)inline fun output(block: PrintWriter.() -> Unit) { _writer.apply(block).flush() } /** shuffles and sort overrides to avoid quicksort attacks */private inline fun <R, V> R._shuffle(rnd: Random, get: R.(Int) -> V, set: R.(Int, V) -> Unit, size: Int) {    // Fisher-Yates shuffle algorithm    for (i in size - 1 downTo 1) {        val j = rnd.nextInt(i + 1)        val temp = get(i)        set(i, get(j))        set(j, temp)    }} @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } fun IntArray.shuffle(rnd: Random = random) = _shuffle(rnd, IntArray::get, IntArray::set, size)fun IntArray.sort() { shuffle(); _sort() }fun IntArray.sortDescending() { shuffle(); _sortDescending() } fun LongArray.shuffle(rnd: Random = random) = _shuffle(rnd, LongArray::get, LongArray::set, size)fun LongArray.sort() { shuffle(); _sort() }fun LongArray.sortDescending() { shuffle(); _sortDescending() } fun DoubleArray.shuffle(rnd: Random = random) = _shuffle(rnd, DoubleArray::get, DoubleArray::set, size)fun DoubleArray.sort() { shuffle(); _sort() }fun DoubleArray.sortDescending() { shuffle(); _sortDescending() } fun CharArray.shuffle(rnd: Random = random) = _shuffle(rnd, CharArray::get, CharArray::set, size)inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T: Comparable<T>> Array<out T>.sort() = _sort()inline fun <T: Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T: Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T: Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() fun `please stop removing these imports IntelliJ`() {    iprintln(max(1, 2))}","constructive algorithms,greedy,math,sortings,two pointers"
"fun main(args: Array<String>) {    readLine()    val a = readLine()!!.split("" "").map(String::toInt)    println(go(a))} fun go(a: List<Int>): Int {    val n = a.size    if (n==1 || a.sorted() == a) return n     return maxOf(go(a.subList(0, n/2)), go(a.subList(n/2, n)))}",implementation
"fun go(a: List<Int>): Int {    val n = a.size    if (n == 1 || a.sorted() == a) return n    return maxOf(go(a.subList(0, n / 2)), go(a.subList(n / 2, n)))} fun main(args: Array<String>) {    readLine()    // val n = readLine()!!.toInt()    val a = readLine()!!.split("" "").map(String::toInt)    println(go(a))}",implementation
"fun max(nums: List<Int>): Int {    val size = nums.size     if (size == 1 || nums.sorted() == nums) return size    return maxOf(max(nums.subList(0, size / 2)), max(nums.subList(size / 2, size)))} fun main(arrays: Array<String>) {    val n = readLine()    val nums = readLine()!!.split("" "").map(String::toInt)     println(max(nums))}",implementation
"fun main(args: Array<String>) {    val maxLength = readLine()!!.toInt()    if (maxLength <= 1) println(1)    else {        val list = readLine()!!.split("" "").map(String::toInt)        println(findMax(list))    }} fun findMax(list: List<Int>): Int {    val n = list.size    if (list.sorted() == list) return n     return maxOf(findMax(list.subList(0, n/2)), findMax(list.subList(n/2, n)))}",implementation
import java.util.* const val N = 2 * 100000 + 1const val CHARS = ('z' - 'a' + 1) fun main() {    val scanner = Scanner(System.`in`)    val n = scanner.nextInt()    scanner.nextLine()    val s1 = scanner.nextLine()    val s2 = scanner.nextLine()     val s = IntArray(n)    var r = 0    for (i in n - 1 downTo 0) {        val c1 = s1[i]        val c2 = s2[i]        var sum = (c1 - 'a') + (c2 - 'a') + r        if (sum >= CHARS) {            r = 1            sum -= CHARS        } else {            r = 0        }        s[i] = sum    }    for (i in 0 until n) {        val sum = s[i] + r * CHARS        r = sum % 2        print('a' + sum / 2)    }    println()},"bitmasks,math,number theory,strings"
import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.* fun main() {    val tokenizer = BufferedReader(InputStreamReader(System.`in`)).use { StringTokenizer(it.readText()) }    val n = tokenizer.nextInt()    val s = tokenizer.nextToken()    val t = tokenizer.nextToken()    var r = 0    val c = CharArray(n)    (0 until n).forEach {        val now = (s[it] - 'a') + (t[it] - 'a') + r        r = (now % 2) * 26        c[it] = 'a' + now / 2    }    (n - 1 downTo 1).forEach {        if (c[it] > 'z') {            c[it] = c[it] - 26            c[it - 1]++        }    }    println(c)} fun StringTokenizer.nextInt() = nextToken().toInt()fun StringTokenizer.nextLong() = nextToken().toLong(),"bitmasks,math,number theory,strings"
"import java.lang.String.formatimport java.util.*import kotlin.math.*import kotlin.system.exitProcess private fun readLn()=readLine()!! // string lineprivate fun readInt()=readLn().toInt() // single intprivate fun readLong()=readLn().toLong() // single longprivate fun readDouble()=readLn().toDouble() // single doubleprivate fun readStrings()=readLn().split("" "") // list of stringsprivate fun readInts()=readStrings().map { it.toInt() } // list of intsprivate fun readLongs()=readStrings().map { it.toLong() } // list of longsprivate fun readDoubles()=readStrings().map { it.toDouble() } // list of doublesfun main(){    val reader=Scanner(System.`in`)    var k=readInt()    var s=readLn()    var t=readLn()    var bit=Array<Int>(k+2){0}    var cur=0    for(i in k-1 downTo 0){        bit[cur]=s[i].toInt()-97        cur++    }    cur=0    for(i in k-1 downTo 0){        bit[cur]+=t[i].toInt()-97        if(bit[cur]>25){            bit[cur]-=26            bit[cur+1]++        }        cur++;    }    for(i in k downTo 0){        var rem=bit[i]%2        bit[i]/=2        if(i>0&&rem>0){            bit[i-1]+=26        }    }    for(i in k-1 downTo 0){        print(""${(97+bit[i]).toChar()}"")    }}","bitmasks,math,number theory,strings"
"fun main() {     var n= readInt();    var s = readLn();    var t = readLn();     var a=IntArray(n+1);    var c: Boolean=false;    for(i in n-1 downTo 0){         var cur: Int = s[i].toDigit()+ t[i].toDigit() + if(c) 1 else 0;        c= cur>=26        a[i+1]=cur%26;    }    a[0]=if(c) 1 else 0;     var rem=a[0];    var res : String ="""";    for(i in 1 .. n){       var cur=26*rem+a[i];        print('a'+cur/2);         rem=cur%2;     }     print(""\n"");    } fun Char.toDigit() = this - 'a'  fun readLn() = readLine()!!fun readInt() = readLn().toInt()fun readDouble() = readLn().toDouble()fun readLong() = readLn().toLong()fun readStrings() = readLn().split(' ')fun readStringSeq() = readLn().splitToSequence(' ')fun readInts() = readStrings().map { it.toInt() }fun readIntSeq() = readStringSeq().map { it.toInt() }fun readDoubles() = readStrings().map { it.toDouble() }fun readDoubleSeq() = readStringSeq().map { it.toDouble() }fun readLongs() = readStrings().map { it.toLong() }fun readLongSeq() = readStringSeq().map { it.toLong() } class Output {    private val sb = StringBuilder()    fun print(o: Any?) { sb.append(o) }    fun println() { sb.append('\n') }    fun println(o: Any?) { sb.append(o).append('\n') }    @JvmName(""_print"") fun Any?.print() = print(this)    @JvmName(""_println"") fun Any?.println() = println(this)    fun nowPrint() { kotlin.io.print(sb) }}inline fun output(block: Output.()->Unit) { Output().apply(block).nowPrint() }  ","bitmasks,math,number theory,strings"
import java.util.Scanner fun main () {    val cin = Scanner(System.`in`)    val n = cin.nextInt()    val r = LongArray(n) {cin.nextLong()}    var a = r.filter{ it % 2L == 0L }.sorted()    var b = r.filter{ it % 2L == 1L }.sorted()    if (a.size < b.size) { val t = a; a = b; b = t }    println( a.dropLast(b.size+1).sum() )},"greedy,implementation,sortings"
"fun main(args: Array<String>) {    val n = readLine()    val a = readLine()!!.split("" "").map { it.toInt() }    var (long, short) = a.partition { it % 2 == 0 }    if (long.size < short.size) {        val t = short        short = long        long = t    }    println(long.sorted().take(maxOf(long.size - short.size - 1, 0)).sum())}","greedy,implementation,sortings"
"fun main() {    readLine()    val arr = readLine()!!.split("" "").map(String::toInt)    val odds = arr.filter { it and 1 == 1 }.sorted()    val evens = arr.filter { it and 1 == 0 }.sorted()    print(        when {            odds.size - evens.size > 1 -> odds.subList(0, odds.size - evens.size - 1).sum()            evens.size - odds.size > 1 -> evens.subList(0, evens.size - odds.size - 1).sum()            else -> 0        }    )}","greedy,implementation,sortings"
"fun inp (): List<Long> = readLine()!!    .split(' ')    .filter { it != """" }    .map { it.toLong() } fun solve() {    val (_) = inp()    val r = inp()    var a = r.filter { it % 2L == 0L } .sortedBy {it}    var b = r.filter { it % 2L == 1L } .sortedBy {it}    if (a.size < b.size) {        println( b.dropLast( a.size+1 ).toLongArray().sum() )    } else {        println( a.dropLast( b.size+1 ).toLongArray().sum() )    }} fun main () {    //val (t) = inp()    val t = 1L    for ( i in 1L..t) {        solve()    }}","greedy,implementation,sortings"
import java.util.* fun main(args: Array<String>) = with(Scanner(System.`in`)) {    val l = nextInt()    val p = nextInt()    val m = nextInt()    val r = nextInt()    println(if (l == r && (m == 0 || l != 0)) 1 else 0)},"greedy,implementation"
fun main() {    fun readInt() = readLine()!!.toInt()     val open = readInt()    readLine()    val closeOpen = readInt()    val close = readInt()    if (open == 0 && closeOpen > 0) return print(0)    print(if (open == close) 1 else 0)},"greedy,implementation"
"import java.util.*  fun main(args: Array<String>) {    val scanner = Scanner(System.`in`)    val cntA = scanner.nextInt()    val cntB = scanner.nextInt()    var cntC = scanner.nextInt()    val cntD = scanner.nextInt()     if (cntA == cntD && (cntA != 0 || cntC <= 0)) {        print(""1"")    }    else {        print(""0"")    }}","greedy,implementation"
"import java.util.Scanner fun solve(a:Int, c:Int, d:Int): Int {    if(a==d && (c==0 || a>0)){        return 1    }    else {        return 0    }} fun main() {    val read = Scanner(System.`in`)    val  a = read.nextInt()    val  b = read.nextInt()    val  c = read.nextInt()    val  d = read.nextInt()    println(solve(a,c,d))}","greedy,implementation"
"import java.util.*import kotlin.math.*private fun readLn() = readLine()!! // stringprivate fun readInt() = readLn().toInt() // single intprivate fun readLong() = readLn().toLong() //longprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of intsprivate fun readLongs() = readStrings().map {it.toLong()} // list of longs val N = 1e5.toInt()+5   //1e9.toInt() + 7 fun getd(n :Int, m: Int) : Int{    val t = m*100    var prc = t/n    val mo = t % n    if(n%2 == 0)    {        if(mo>=n/2) prc++    }else    {        if(mo>n/2) prc++    }    return prc} fun main() {    val (n,k) = readInts()    val a = readInts()    var m = 0    var i = 0    val run = Array(k,{i->Pair(-1,-1)})    val inter = Array(n,{i->0})    var mfin = 0    while(n != mfin)    {        for(j in 0..k-1)        {            if(run[j].first == -1 && i != n)            {                run[j] = Pair(i,0)                i++            }            if(run[j].first == -1) continue            if(getd(n,mfin) == run[j].second+1) inter[run[j].first] = 1            if(run[j].second<a[run[j].first]-1) run[j] = Pair(run[j].first,run[j].second+1)            else            {                run[j] = Pair(-1,-1)                m++            }        }        mfin = m    }    var sum = 0    for(i in 0..n-1) sum += inter[i]    println(sum)}",implementation
"fun main(args :Array<String>) {    val (n, k) = readLine()!!.split("" "").map(String::toInt)    val tests = readLine()!!.split("" "").map(String::toInt)     var completed = 0    val statuses = IntArray(k)    val progs = IntArray(k) {-1}    var head = 0     for (i in 0 until Math.min(n, k)) {        progs[i] = head        statuses[i] = 1        head++    }     val useful = Array(n){false}    while (head != n) {        for (i in 0 until k) {            if (progs[i] != -1) {                if (statuses[i] == tests[progs[i]]) {                    completed++                    if (head != n) { progs[i] = head++ } else { progs[i] = -1 }                    statuses[i] = 0                }                statuses[i]++            }        }         val compP = (100.0 * completed / n + 0.5).toInt()        for (i in 0 until k) {             if (progs[i] != -1) {                if (statuses[i] == compP) {                    useful[progs[i]] = true                }            }        }    }     while (true) {        var flag = true        for (i in 0 until k) {            if (progs[i] != -1) {                if (statuses[i] == tests[progs[i]]) {                    completed++                    if (head != n) { progs[i] = head++ } else { progs[i] = -1 }                    statuses[i] = 1                }                statuses[i]++            }        }         val compP = (100.0 * completed / n + 0.5).toInt()        for (i in 0 until k) {             if (progs[i] != -1) {                if (statuses[i] == compP) {                    useful[progs[i]] = true                }                flag = false            }        }         if (flag) { break }    }     println(useful.count{it})}",implementation
"fun main(args: Array<String>) {    val q = readLine()!!.toInt()    for (i in 0 until q) {        readLine()        val s = readLine()!!        val a = s.substring(0, 1)        val b = s.substring(1)        if (b.length > 1 || a.toInt() < b.toInt()) {            println(""YES"")            println(2)            println(""$a $b"")        } else {            println(""NO"")        }    }}","greedy,strings"
"fun readInts(separator: Char = ' ') = readLine()!!.split(separator).map(String::toInt) fun main() {    val (q) = readInts()    for(i in 0 until q){        val (n) = readInts()        val s = readLine()!!        if (n!=2 || s[0]<s[1]){            println(""YES"")            println(""2"")            println(""${s[0]} ${s.substring(1)}"")        }else{            println(""NO"")        }    }}","greedy,strings"
"fun main() {    fun readInt() = readLine()!!.toInt()     val numQueries = readInt()    nextQuery@ for (query in 0 until numQueries) {        val numDigits = readInt()        val s = readLine()!!        println(            if (numDigits == 2 && s[0] >= s[1]) ""NO""            else ""YES${System.lineSeparator()}"" +                    ""2${System.lineSeparator()}"" +                    ""${s[0]} ${s.substring(1, s.length)}""        )    }}","greedy,strings"
"fun main() {    var q = readLine()!!.toInt()     repeat(q) {        readLine()        var list = readLine()        if (list!!.length > 2) {            println(""YES"")            println(2)            var fi = list.substring(0, 1)            var se = list.substring(1, list.length)            println(""$fi $se"")        } else {            if (list[0].toInt() >= list[1].toInt()) {                println(""NO"")            } else {                println(""YES"")                println(2)                println(""${list[0]} ${list[1]}"")            }        }     }}","greedy,strings"
"fun main(args: Array<String>) {    readLine()    val a = readLine()!!.split("" "").map(String::toInt).sorted()    var answer = 0L    for (i in 0 until a.size / 2) {        val x = a[i]        val y = a[a.size - 1 - i]        answer += (x + y) * (x + y)    }    println(answer)}","greedy,implementation,math,sortings"
fun main() {    var n = readLine()!!.toInt()    var list = readLine()!!.split(' ').map { it.toInt() }.sortedDescending()    var sum = 0L    var mid = 0    while (mid < n / 2) {        var sumOfTwo:Long = (list[mid] + list[n - 1 - mid]).toLong()        sum += (sumOfTwo * sumOfTwo)        mid++    }    println(sum)},"greedy,implementation,math,sortings"
"fun main() {    fun readInt() = readLine()!!.toInt()    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val n = readInt()    val arr = readInts().sorted()    var left = -1    var right = arr.size    var sol = 0L    while (++left < --right)        sol += (arr[left] + arr[right]).toLong() * (arr[left] + arr[right])    print(sol)}","greedy,implementation,math,sortings"
"fun main() {    val r = System.`in`.bufferedReader()    val s1 = StringBuilder()    val n = r.readLine()!!.toInt()    //var (n, m) = r.readLine()!!.split("" "").map { it.toInt() }    val v = r.readLine()!!.split("" "").map { it.toLong() }.sorted()    val ans = (0..n/2-1).fold(0L){acc, i -> acc + (v[i]+v[n-1-i])*(v[i]+v[n-1-i]) }    println(ans)}","greedy,implementation,math,sortings"
"import kotlin.math.*fun main(arg: Array<String>){	val (n, k) = readLine()!!.split("" "").map{it.toInt()}	val A = readLine()!!.split("" "").map{it.toInt()}	var maxColor = 0	var curSame = 0	val Ad = A.distinct().size	val Am = mutableMapOf<Int,Int>()	var res = """"	var z = 0	for(i in A){		z++		if(i in Am.keys){			if(Am.get(i) == k){				println(""NO"")				return			}		Am.set(i,max(Am.get(i)!!.toInt()+1,k-n+z))		res += ""${Am.get(i)} ""		}else{			val zz = max(1,k-n+z)			Am.set(i,zz)			res += ""$zz ""		}	}	println(""YES"")	println(res)}","greedy,sortings"
"import java.io.BufferedReaderimport java.io.InputStreamReader fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val (n, k) = jin.readLine().split("" "").map { it.toInt() }    val ay = jin.readLine().split("" "").map { it.toInt() }    val freq = IntArray(5001)    for (a in ay) {        freq[a]++    }    if (freq.max()!! > k) {        println(""NO"")    } else {        val ixs = (0 until n).sortedBy { ay[it] }        val answer = IntArray(n)        for (j in 0 until n) {            answer[ixs[j]] = (j % k) + 1        }        println(""YES"")        println(answer.joinToString("" ""))    }}","greedy,sortings"
"fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val (arrLength, numColors) = readInts()    if (arrLength < numColors) return print(""NO"")    val arr = readInts()    val freqs = mutableMapOf<Int, Int>().withDefault { 0 }    for (a in arr) freqs[a] = freqs.getValue(a) + 1    if (freqs.values.max()!! > numColors) return print(""NO"")    var color = 0    val sol = IntArray(arrLength)    for (element in arr.mapIndexed { index, i -> i to index }.sortedBy { it.first }) {        sol[element.second] = color + 1        color = (color + 1) % numColors    }    println(""YES"")    print(sol.joinToString("" ""))}","greedy,sortings"
"fun main() {	val (n, k) = readLine()!!.split(' ').map {it -> it.toInt()};	val list = readLine()!!.split(' ').map {it -> it.toInt()};		var map = HashMap <Int, ArrayList <Int>>();	for (i in 1..5000) map.set(i, ArrayList <Int>());		for ((pos, x) in list.withIndex()) {		map[x]!!.add(pos);	}		var ans = MutableList(n) {_ -> 0};	var counter = 0;	for (i in 1..5000) {		if (map[i]!!.size > 0) {			if (map[i]!!.size > k) {				println(""NO"");				return;			}			for (pos in map[i]!!) {				ans[pos] = (counter % k) + 1;				counter++;			}		}	}		if (counter < k) {		println(""NO"");		return;	}	println(""YES"");	println(ans.joinToString("" ""));} /*C:\Users\kenne\OneDrive\Desktop\competitive_programming\kotlinmain.kt*/","greedy,sortings"
"fun main(){val q = readLine()!!.toInt() repeat(q){val (a, b, c) = readLine()!!.split("" "").map(){it.toInt()}     if (c < a){    println(c)    } else {    println( ((b / c) + 1) * c)    }   } }",math
"fun main() {    val q = readLine()!!.toInt()    repeat(q) {        val (l, r, d) = readLine()!!.split("" "").map { it.toLong() }        if (d < l) {            println(d)        } else {            println((r / d + 1) * d)        }    }}",math
"fun minInt(l:Int,r:Int, d:Int) = if( d >= l) r+(d-(r%d)) else d  fun main(args:Array<String>){    val q = readLine()!!.toInt()      for(i in 0 until q){        val s = readLine()!!.split("" "")        println(""${minInt(s[0].toInt(), s[1].toInt(), s[2].toInt())}"")    }} ",math
"fun main() {    val numQueries =  readLine()!!.toInt()    val sol = IntArray(numQueries)    for (query in 0 until numQueries) {        val (l, r, d) = readLine()!!.split("" "").map(String::toInt)        sol[query] = if (d < l) d else (r / d) * d + d    }    print(sol.joinToString(System.lineSeparator()))}",math
"const val mod = 998244353 fun main(args: Array<String>) {    val input = System.`in`.bufferedReader()    val n = input.readLine().toInt()    val s = input.readLine()     var l = 0    var r = n - 1    while (s[l] == s[0]) l++    while (s[r] == s[0]) r--    var suf = n - 1    while (s[suf] == s[n - 1]) suf--    //println(""$l..$r $suf $s"")    println(((n - r).toLong() * l + (n - suf)) % mod)}","combinatorics,math,strings"
fun main() {    val n = readLine()!!.toLong()    val s = readLine()!!    val left = s[0]    var sumLeft = 0L    for (c in s) if (c == left) sumLeft++ else break    if (sumLeft == n) {        print((n * 2) % 998244353)        return    }    val right = s[(n - 1).toInt()]    var sumRight = 0L    for (c in s.reversed()) if (c == right) sumRight++ else break    if (left != right) print((sumLeft + sumRight + 1) % 998244353) else print(((sumLeft + 1) * (sumRight + 1)) % 998244353)},"combinatorics,math,strings"
import java.util.* /** * @author Avto * @email avto.bolashvili@maxinai.com */ fun main(args: Array<String>) {    val scanner = Scanner(System.`in`)     val n = scanner.nextInt()     val str = scanner.next()     println(solve(str))} private fun solve(str: String): Long {    val l = str[0]    val r = str.last()     var numL: Long = 0    var numR: Long = 0    var res: Long = 0     for (c in str) {        if (c != l)            break        numL ++    }     for (c in str.reversed()) {        if (c != r)            break        numR ++    }     if (l != r) {        return (numL + numR + 1).rem(998244353)    }     for (i in numL.downTo(1)) {        res += (numR + 1).rem(998244353)    }     return (res + numR + 1).rem(998244353)},"combinatorics,math,strings"
"import java.io.*import java.util.* fun main(args: Array<String>) {    solve(System.`in`, System.out)} val MAX_N = (1e6 + 10).toInt()val INF = (1e9 + 7).toInt()val MOD = (1e9 + 7).toInt()val INF_F = 1e-6 fun solve(input: InputStream, output: OutputStream) {    val reader = InputReader(BufferedInputStream(input))    val writer = PrintWriter(BufferedOutputStream(output))     solve(reader, writer)    writer.close()} fun solve(reader: InputReader, writer: PrintWriter) {    val n = reader.nextInt()    val s = reader.next()     var j = n - 1    while (j > 0 && s[j] == s[0]) {        j--    }    val countSuf = n - j - 1     var ans = 0L    for (i in 0 until n) {        if (s[i] != s[0]) {            break        }         ans = (ans + countSuf + 1) % 998244353    }     j = n - 1    while (s[j] == s[n - 1]) {        ans = (ans + 1) % 998244353        j--    }    ans = (ans + 1) % 998244353    writer.println(ans)} fun gcd(a: Int, b: Int): Int {    return if (b == 0) a else gcd(b, a % b)} class InputReader(stream: InputStream) {    private val reader = BufferedReader(InputStreamReader(stream), 32768)    private var tokenizer: StringTokenizer? = null     operator fun next(): String {        while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {            try {                tokenizer = StringTokenizer(reader.readLine())            } catch (e: IOException) {                throw RuntimeException(e)            }         }        return tokenizer!!.nextToken()    }     fun nextInt(): Int {        return Integer.parseInt(next())    }     fun nextLong(): Long {        return java.lang.Long.parseLong(next())    }     fun nextArrayInt(count: Int): IntArray {        return nextArrayInt(0, count)    }     fun nextArrayInt(start: Int, count: Int): IntArray {        val a = IntArray(start + count)        for (i in start until start + count) {            a[i] = nextInt()        }        return a    }     fun nextArrayLong(count: Int): LongArray {        val a = LongArray(count)        for (i in 0 until count) {            a[i] = nextLong()        }        return a    }}","combinatorics,math,strings"
"private fun readLn() = readLine()!!private fun readInt() = readLn().toInt() private val regSpace = ""\\s+"".toRegex() private fun readSomeInts(): List<Int> =    readLn().trim().split(regSpace).map { it.toInt() } fun main() {     val n = readInt()    val ds = readSomeInts()    check(n == ds.size)     val cnts = ds.groupingBy { it }.eachCount().values.sortedDescending()    val maxcnt = cnts[0]     val progression = mutableListOf(1).apply {        var prev = last()        var accsum = prev        while (accsum <= maxcnt) {            prev *= 2            accsum += prev            add(accsum)        }    }     var zmax = maxcnt    var half = maxcnt / 2    for (i in 1 until cnts.size) {        val cnt = cnts[i]        val myhalf = minOf(cnt, half)        if (myhalf == 0)            break         half = myhalf / 2         val mymax = progression[i] * myhalf        if (mymax > zmax)            zmax = mymax    }     println(""$zmax"")}","greedy,sortings"
"private fun readLn() = readLine()!!private fun readInt() = readLn().toInt() private val regSpace = ""\\s+"".toRegex() private fun readSomeInts(): List<Int> =    readLn().trim().split(regSpace).map { it.toInt() } fun main() {     val n = readInt()    val ds = readSomeInts()    check(n == ds.size)     val cnts = ds.groupingBy { it }.eachCount().values.sortedDescending()    val maxcnt = cnts[0]     val progression = mutableListOf(1).apply {        var prev = last()        var acc = prev        while (acc <= maxcnt * 2) {            prev *= 2            acc += prev            add(acc)        }    }     data class XAcc (val idx: Int, val mx: Int, val half: Int)     val (_, zcount, _) = cnts.drop(1).foldIndexed(XAcc(0, maxcnt, maxcnt / 2)) { index, (previdx, prevmax, half), b ->        val pos = index + 1        val myhalf = minOf(b, half)        val nxthalf = myhalf / 2        if (myhalf == 0) {            XAcc(previdx, prevmax, nxthalf)        } else {            val mymax = progression[pos] * myhalf            if (mymax > prevmax)                XAcc(pos, mymax, nxthalf)            else                XAcc(previdx, prevmax, nxthalf)        }    }     println(""$zcount"")}","greedy,sortings"
"import java.io.PrintWriterimport java.util.*import kotlin.collections.ArrayListimport kotlin.collections.HashMapimport kotlin.math.ceilimport kotlin.math.logimport kotlin.math.pow lateinit var sieve: Array<Int> const val CONST: Long = 1000000000 + 7 var max = Int.MIN_VALUEvar min = Int.MAX_VALUEvar rc = 0lateinit var count: Array<Int>lateinit var fans: HashSet<Int>lateinit var hs: HashMap<Pair<Int, Int>, Int> fun main(args: Array<String>) {    var n=readInt()    var arr=readInts()    var count=countArr(arr)    var countarr=count.values.sorted().reversed()    var nn=(log(n.toDouble(),2.0)).toInt()    var ans=IntArray(nn+3){0}    ans[1]=countarr[0]    for (i in 2 .. countarr.size){        ans[i]=minOf(ans[i-1]/2,countarr[i-1])        if(ans[i]==0){            break        }    }    var annss=Int.MIN_VALUE    for (i in ans.indices){        annss=maxOf(annss,ans[i]*(2.0.pow(i)-1).toInt())    }    println(annss)}  class Triple<T1, T2, T3>(var first: T1, var second: T2, var third: T3)class Pair<T1, T2>(var first: T1, var second: T2) class Quadraple<T1, T2, T3, T4>(var first: T1, var second: T2, var third: T3, var forth: T4) fun indices(arr: ArrayList<Long>): Map<Long, ArrayList<Long>> {    var map = HashMap<Long, ArrayList<Long>>()    for (i in arr.indices) {        if (arr[i] in map) {            map[arr[i]]?.add(i.toLong())        } else {            map[arr[i]] = ArrayList<Long>()            map[arr[i]]?.add(i.toLong())        }    }    return map} fun <T> countArr(arr: ArrayList<T>): HashMap<T, Int> {    var map = HashMap<T, Int>()    for (i in arr.indices) {        if (arr[i] in map) {            map[arr[i]] = map[arr[i]]!! + 1        } else {            map[arr[i]] = 1        }    }    return map} @JvmFieldval INPUT = System.`in` @JvmFieldval OUTPUT = System.out @JvmFieldval _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!! @JvmFieldvar _tokenizer: StringTokenizer = StringTokenizer("""") @JvmFieldval _writer = PrintWriter(OUTPUT, false)inline fun output(block: PrintWriter.() -> Unit) {    _writer.apply(block).flush()} fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()} private fun readInt() = readLn().toInt() // single intprivate fun readLong() = readLn().toLong()  // single longprivate fun readDouble() = readLn().toDouble() // single doubleprivate fun readStrings() = readLn().trim().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } as ArrayList<Int>// list of intsprivate fun readLongs() = readStrings().map { it.toLong() } as ArrayList<Long>// list of longsprivate fun readDoubles() = readStrings().map { it.toDouble() } as ArrayList<Double> // list of doubles","greedy,sortings"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"") import java.io.PrintWriterimport java.util.StringTokenizerimport kotlin.math.*import kotlin.random.*import kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {    val n = readInt()    val A = readInts(n).groupingBy { it }.eachCount().values.sortedByDescending { it }     var ans = 0    var x = Int.MAX_VALUE    var m = 1     for(a in A) {        x = min(x/2, a)        if(x == 0) break        ans = max(ans, x * m)        m = m * 2 + 1    }     println(ans)} /** IO code start *///@JvmField val INPUT = File(""input.txt"").inputStream()//@JvmField val OUTPUT = File(""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out @JvmField val _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /** shuffles and sort overrides to avoid quicksort attacks */private inline fun <T> _shuffle(rnd: Random, get: (Int) -> T, set: (Int, T) -> Unit, size: Int) {    // Fisher-Yates shuffle algorithm    for (i in size - 1 downTo 1) {        val j = rnd.nextInt(i + 1)        val temp = get(i)        set(i, get(j))        set(j, temp)    }} @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } fun IntArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)fun IntArray.sort() { shuffle(); _sort() }fun IntArray.sortDescending() { shuffle(); _sortDescending() } fun LongArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)fun LongArray.sort() { shuffle(); _sort() }fun LongArray.sortDescending() { shuffle(); _sortDescending() } fun DoubleArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)fun DoubleArray.sort() { shuffle(); _sort() }fun DoubleArray.sortDescending() { shuffle(); _sortDescending() } fun CharArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T: Comparable<T>> Array<out T>.sort() = _sort()inline fun <T: Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T: Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T: Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() fun `please stop removing these imports IntelliJ`() {    iprintln(max(1, 2))}","greedy,sortings"
"fun main(){    val l = readLine().toString().toInt()    var mas = readLine().toString().split(' ').map { it.toLong() }.toTypedArray()    var resmas = mutableListOf<Int>()    var sum = mas.sum()    var cmas = Array(1000001, {0})    for (i in mas){        cmas[i.toInt()] += 1    }    for (i in mas.indices){        var a = mas[i]        cmas[a.toInt()] -= 1        sum -= a        if ((sum / 2 > 0) && (sum / 2 <= 1000000) && (sum % 2.toLong() == 0.toLong()) && (cmas[(sum / 2.toLong()).toInt()] > 0)){            resmas.add(i)        }        sum += a        cmas[a.toInt()] += 1    }    println(resmas.size)    for (i in resmas)        print((i + 1).toString() + ' ') }",
"import kotlin.math.* fun main() {    var n = readLine()!!.toInt()    val arr = readLine()!!.split("" "").map(String::toLong)    var nn = n    var max_f = 0L    var max_s = 0L    var sumAll = 0L    var max_i = 0    while (nn --> 0) {        if (arr[nn] > max_f) {            max_f = arr[nn]            max_i = nn        }        sumAll += arr[nn]    }    nn = n    while (nn --> 0) {        if (nn != max_i) {            max_s = max(arr[nn], max_s)        }    }    var ans = ArrayList<Int>()    nn = n    while (nn --> 0) {        if (arr[nn] == max_f) {            if (sumAll - arr[nn] - max_s == max_s) {                ans.add(nn + 1)            }        } else {            if (sumAll - arr[nn] - max_f == max_f) {                ans.add(nn + 1)            }        }    }    println(ans.size)    println(ans.joinToString("" ""))}",
"private fun readLn() = readLine() ?: """"private fun readLns() = readLn().split("" "")private fun readInt() = readLn().toInt()private fun readInts() = readLns().map { it.toInt() }private fun readLong() = readLn().toLong()private fun readLongs() = readLns().map { it.toLong() }private fun readDouble() = readLn().toDouble()private fun readDoubles() = readLns().map { it.toDouble() } fun main() {    val n = readInt()    val arr = readLongs()    var sum = arr.sum()    val freq = hashMapOf<Long, Int>()    for (ele in arr) freq[ele] = (freq[ele] ?: 0) + 1    val ans = mutableListOf<Int>()    for (i in arr.indices) {        sum -= arr[i]        freq[arr[i]] = (freq[arr[i]] ?: 0) - 1        if (sum % 2 == 0L && (freq[sum / 2L] ?: 0) > 0) {            ans.add(i + 1)        }        sum += arr[i]        freq[arr[i]] = (freq[arr[i]] ?: 0) + 1    }    println(ans.size)    for (ele in ans) print(""$ele "")}",
"/** Codeforces contest * Kotlin compiler * @author MrFoxyGmFr */const val debug = falseval scan = java.util.Scanner(if (debug) java.io.FileInputStream(""input.txt"") else System.`in`)const val MOD = 2147483647/**--- CONST ---**/const val MAXN = 1000100 fun main(args: Array<String>) {    val n = scan.nextInt()    val a = IntArray(MAXN, { 0 })    val arr = IntArray(MAXN, { 0 })    var sum = 0L    for (i in 1..n) {        arr[i] = scan.nextInt()        a[arr[i]]++        sum += arr[i]    }     val ans = IntArray(MAXN, { 0 })    var count = 0    for (i in 1..n) {        val t = (sum - arr[i])        if (t % 2 == 1L || t / 2 > MAXN)            continue        val tmp = (t / 2).toInt()        if ((tmp != arr[i] && a[tmp] > 0) || (a[tmp] > 1))            ans[count++] = i    }     println(count)    for (i in 0..(count - 1))        print(""${ans[i]} "")} fun debug(vararg info: Any) { if (debug) { print(""DEBUG:""); info.forEach { print("" $it"") } } }",
"import java.io.PrintWriterimport java.util.* lateinit var sieve: Array<Int> var CONST: Long = 1000000000 + 7lateinit var dp: Array<IntArray>lateinit var realdp: Array<BooleanArray> fun main() {    var (n, q) = readInts()    var arr = readLn().map { it.toString().toInt() }    var prefix = ArrayList<Int>()    prefix.add(0)    arr.forEach { prefix.add(prefix.last() + it) }    repeat(q){        var (a,b)=readInts()        a--        b--        var noOfOnes=prefix[b+1]-prefix[a]        var noOfZeros=b-a+1-noOfOnes        var ans1=power(2L,noOfOnes.toLong(),CONST)-1        ans1+=(ans1*(power(2L,noOfZeros.toLong(),CONST)-1))%CONST        println(ans1%CONST)    }}fun power(x: Long, y: Long, p: Long): Long {    var x = x    var y = y    var res = 1L     x %= p    if (x == 0L) return 0 // In case x is divisible by p;    while (y > 0) {        // If y is odd, multiply x        // with result        if (y and 1 == 1L) res = res * x % p         // y must be even now        // y = y / 2        y = y shr 1        x = x * x % p    }    return res} @JvmFieldval INPUT = System.`in` @JvmFieldval OUTPUT = System.out @JvmFieldval _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!! @JvmFieldvar _tokenizer: StringTokenizer = StringTokenizer("""") @JvmFieldval _writer = PrintWriter(OUTPUT, false)inline fun output(block: PrintWriter.() -> Unit) {    _writer.apply(block).flush()} fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()} private fun readInt() = readLn().toInt() // single intprivate fun readLong() = readLn().toLong()  // single longprivate fun readDouble() = readLn().toDouble() // single doubleprivate fun readStrings() = readLn().trim().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } as ArrayList<Int>// list of intsprivate fun readLongs() = readStrings().map { it.toLong() } as ArrayList<Long>// list of longsprivate fun readDoubles() = readStrings().map { it.toDouble() } as ArrayList<Double> // list of doubles","greedy,implementation,math"
"import java.io.PrintWriterimport java.lang.StringBuilderimport kotlin.math.* fun main() {    io.apply {         val M = 1_000_000_007        val (n, q) = int to int         val p2 = IntArray(n + 1)         p2[0] = 1        for (i in 1..n) {            p2[i] = (p2[i - 1] * 2) % M        }         val data = str(n)         val pSum = IntArray(n + 1)         for (i in 1 .. n) {            pSum[i] = pSum[i - 1] + (if (data[i - 1] == '1') 1 else 0)        }         repeat(q) {            val l = int - 1            val r = int            val len = r - l            val numOnes = pSum[r] - pSum[l]            val numZeros = len - numOnes            var ans = p2[numOnes] - 1            if (ans < 0) ans += M            val mul = p2[numZeros].toLong()            cout .. (ans * mul) % M .. nl         }        }.cout.flush()} // @formatter:offprivate val io = object {    private val `in` = System.`in`    private fun ll(): Long {        var x: Int; var q = false; var n = 0L; do x = `in`.read() while (x < 33); if (x == 45) { q = true; x = `in`.read() }        do { n = n * 10 - x + 48; x = `in`.read() } while (x > 32); return if (q) n else -n    }    val int get() = ll().toInt(); val long get() = ll()    fun ints(n: Int = int): IntArray { return IntArray(n) { int } }    fun ints1(n: Int = int): IntArray { return IntArray(n) { int - 1 } }    val cout = PrintWriter(System.out); val nl = ""\n""    private var buf = CharArray(32)    private var bufSize = 32    fun str(expect: Int = 32): String {        var ix = 0        var x: Int        if (bufSize < expect)            buf = CharArray(expect)        do x = `in`.read() while (x < 33)        do {            if (ix == bufSize) { bufSize *= 2; buf = buf.copyOf(bufSize) }            buf[ix++] = x.toChar()            x = `in`.read()        } while (x > 32)        return java.lang.String.copyValueOf(buf, 0, ix)    }    operator fun PrintWriter.rangeTo(a: Int): PrintWriter { print(a); print("" ""); return this }    operator fun PrintWriter.rangeTo(a: Long): PrintWriter { print(a); print("" ""); return this }    operator fun PrintWriter.rangeTo(a: IntArray): PrintWriter { a.forEach { print(it); print("" "") }; return this }    operator fun PrintWriter.rangeTo(a: String): PrintWriter { write(a); return this }} // @formatter:on /* ----------- */ ","greedy,implementation,math"
"import java.lang.Math.maximport java.util.* fun readInt(): Int{return readLine()!!.toInt()}fun readLong(): Long{return readLine()!!.toLong()}fun readList(): MutableList<Int> {return readLine()!!.split(' ').map{it.toInt()}.toMutableList()}fun readListL(): MutableList<Long> {return readLine()!!.split(' ').map{it.toLong()}.toMutableList()}fun less(x: Pair<Int, Int>, y: Pair<Int, Int>): Boolean{return x.first < y.first || x.first == y.first && x.second < y.second}fun comp(x: Pair<Int, Int>, y: Pair<Int, Int>): Int{return when{less(x, y) -> -1; less(y, x) -> 1 else -> 0}}fun toInt(x: Boolean): Int{return when{x -> 1 else -> 0}}fun toLong(x: Boolean): Long{return when{x -> 1 else -> 0}}const val INF = 1000000001const val C = 1000000007 fun main() {    val (n, k) = readList()    val s = readLine()!!    val (pref, deg) = Pair(mutableListOf(0), mutableListOf(1L))    for (q in s) {        pref.add(pref.last()+(q-'0'))        deg.add(deg.last()*2 % C)    }    for (q in 1..k) {        var (l, r) = readList()        l--        val sum1 = pref[r]-pref[l]        println((deg[sum1]-1)*deg[r-l-sum1] % C)    }}","greedy,implementation,math"
import java.util.* fun main(args: Array<String>) {    val sc = Scanner(System.`in`)     val n = sc.nextInt()    val m = sc.nextInt()    val arr = Array(n) {        sc.nextLong()    }    val sum = arr.sum()    arr.sort()     var h = 0    for (i in 0 until arr.size) {        if (arr[i] > h) {            h++        }    }    println(sum - n - (arr.max()!! - h))},"greedy,implementation,sortings"
"import java.util.*import kotlin.collections.*import kotlin.math.* val read = Scanner(System.`in`) fun main(){    var n = read.nextInt()    var m = read.nextInt()    var a = Array<Long>(n){0L}    var sum: Long = 0L    for (i in a.indices){        a[i] = read.nextLong()        sum += a[i]    }    a.sort()    var take: Long = 0L    var cur: Long = 0L    for (i in 0 until  n){        cur = min(cur + 1, a[i])        take += 1 + if (i < n - 1) 0L else a[i] - cur    }    print(sum - take)}","greedy,implementation,sortings"
import java.util.* fun main() {    var tokenizer = StringTokenizer(readLine()!!)    val n = tokenizer.nextToken().toInt()    val m = tokenizer.nextToken().toLong()    tokenizer = StringTokenizer(readLine()!!)    val heights = Array(n) { tokenizer.nextToken().toLong() }    heights.sortDescending()    var answer = heights.sum() - n.toLong()    var k = heights[0]    for (h in heights) {        if (k > h) {            answer -= k - h            k = h        }        k--    }    if (k > 0L) {        answer -= k    }    println(answer)},"greedy,implementation,sortings"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.io.PrintWriterimport java.util.StringTokenizerimport kotlin.math.max fun main() {    val br = BufferedReader(InputStreamReader(System.`in`))    val pw = PrintWriter(System.out)    fun StringTokenizer.readInt() = nextToken().toInt()    fun readInts(numElements: Int): IntArray {        val st = StringTokenizer(br.readLine())        return IntArray(numElements) { st.readInt() }    }     val st = StringTokenizer(br.readLine())    val numCols = st.readInt()    val heights = readInts(numCols)    heights.sortDescending()    var sum = heights.first() - 1L    var toCover = heights.first() - 1    for (pos in 1 until heights.size) {        val delta = toCover + 1 - heights[pos]        val toPlace = max(1, delta)        sum += heights[pos] - toPlace        toCover -= toPlace    }    if (toCover > 0)        sum -= toCover    pw.print(sum)    pw.close()}","greedy,implementation,sortings"
"fun main(args: Array<String>) {    val n = readLine()!!.toInt()    if (n == 1) {        println(1)    } else {        val p = readLine()!!.split("" "").map { it.toInt() }        val count: IntArray = IntArray(n) { 0 }        for (i in p.size - 1 downTo 0) {            if (count[i + 1] == 0) {                count[i + 1]++            }            count[p[i] - 1] += count[i + 1]        }        println(count.sorted().map { it.toString() }.joinToString("" ""))    }} ","constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.io.PrintWriterimport java.util.* val inf = BufferedReader(InputStreamReader(System.`in`))val ouf = PrintWriter(System.out) fun main(args: Array<String>) {    val (n) = inf.readLine()!!.split(' ').map(String::toInt)    val tree = Array(n) { ArrayList<Int>() }    inf.readLine()!!.split(' ').filter(String::isNotEmpty).map(String::toInt).forEachIndexed { i, p -> tree[p - 1].add(i + 1) }    val a = IntArray(n)     fun dfs(q: Int, p: Int): Int {        a[q] = 0        var isLeaf = true        tree[q].filter { it != p }.forEach {            a[q] += dfs(it, q)            isLeaf = false        }        if (isLeaf) a[q]++        return a[q]    }     dfs(0, -1)    a.sort()    ouf.println(a.joinToString(separator = "" ""))     ouf.close()}","constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees"
"import java.io.*import java.lang.Math.absimport java.util.*import kotlin.collections.HashSet   fun solve(cin: FastReader, out: PrintWriter) {    val n = cin.int()    val graph = Array(n) {ArrayList<Int>()}     for (i in 1 until n) {        val p = cin.int()        graph[p - 1].add(i)    }     val cnt = IntArray(n) {0}     fun dfs(v: Int): Int {        var num = if (graph[v].isEmpty()) 1 else 0        num += graph[v].sumBy { dfs(it) }         cnt[v] = num        return num    }     dfs(0)     cnt.sorted().forEach {out.print(""$it "")}}   class FastReader(input: InputStream) {    private val br = BufferedReader(InputStreamReader(input))    private var st = StringTokenizer("""")     fun next(): String {        while (!st.hasMoreTokens())            st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun int(): Int {        return next().toInt()    }     fun double(): Double {        return next().toDouble()    }     fun long(): Long {        return next().toLong()    }     /**     * Warning! Use carefully!     */    fun nextLine(): String {        return br.readLine()    }} fun main(args: Array<String>) {    val cin = FastReader(System.`in`)    val out = PrintWriter(BufferedOutputStream(System.out))    /*val cin = Scanner(System.`in`)    val out = PrintWriter(System.out)*/    solve(cin, out)    out.flush()}","constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees"
"import java.io.*import java.lang.Math.absimport java.util.*import kotlin.collections.HashSet   fun solve(cin: FastReader, out: PrintWriter) {    val n = cin.int()    val graph = Array(n) {ArrayList<Int>()}     for (i in 1 until n) {        val p = cin.int()        graph[p - 1].add(i)    }     val cnt = IntArray(n) {0}     fun dfs(v: Int): Int {        var num = if (graph[v].isEmpty()) 1 else 0        for (x in graph[v])            num += dfs(x)         cnt[v] = num        return num    }     dfs(0)     cnt.sorted().forEach {out.print(""$it "")}}   class FastReader(input: InputStream) {    private val br = BufferedReader(InputStreamReader(input))    private var st = StringTokenizer("""")     fun next(): String {        while (!st.hasMoreTokens())            st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun int(): Int {        return next().toInt()    }     fun double(): Double {        return next().toDouble()    }     fun long(): Long {        return next().toLong()    }     /**     * Warning! Use carefully!     */    fun nextLine(): String {        return br.readLine()    }} fun main(args: Array<String>) {    val cin = FastReader(System.`in`)    val out = PrintWriter(BufferedOutputStream(System.out))    /*val cin = Scanner(System.`in`)    val out = PrintWriter(System.out)*/    solve(cin, out)    out.flush()}","constructive algorithms,dfs and similar,dp,graphs,greedy,sortings,trees"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport kotlin.math.maximport kotlin.math.min fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val n = jin.readLine().toInt()    var minX = Int.MAX_VALUE    var maxX = Int.MIN_VALUE    var minY = Int.MAX_VALUE    var maxY = Int.MIN_VALUE    val points = Array(n) {        val (x, y) = jin.readLine().split("" "").map { it.toInt() }        minX = min(minX, x)        maxX = max(maxX, x)        minY = min(minY, y)        maxY = max(maxY, y)        Point(x, y)    }    var answer3 = 0    for (p in points) {        answer3 = max(answer3, max(p.x - minX, maxX - p.x) + max(p.y - minY, maxY - p.y))    }    print(2 * answer3)    println("" ${2 * (maxX - minX + maxY - minY)}"".repeat(n - 3))} data class Point(val x: Int, val y: Int)","dp,geometry"
"import kotlin.math.*import kotlin.collections.*import java.util.StringTokenizerimport java.io.PrintWriter @JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out @JvmField val _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false)inline fun output(block: PrintWriter.() -> Unit) { _writer.apply(block).flush() } fun gcd(a: Long, b: Long): Long {    if (b == 0L) {        return a    }    return gcd(b, a%b)} var MOD = (1e9+7).toLong()private var N = 300300//private var N = 20 fun modpow(_b: Long, _p: Long): Long {    var b = _b    var p = _p    var ans = 1L    while (p!= 0L) {        if (p%2 == 1L) {            ans = ans * b % MOD        }        b = b*b % MOD        p /= 2    }    return ans} var fac = LongArray(N)var ifac = LongArray(N)fun setup() {    fac[0] = 1L    ifac[0] = 1L    for (i in 1..(N-1)) {        fac[i] = fac[i-1]*i%MOD    }    ifac[N-1] = modpow(fac[N-1], MOD-2)    for (i in (N-2) downTo 1) {        ifac[i] = ifac[i+1] * (i+1)%MOD    }}fun choose(n: Int, k: Int): Long {    return fac[n] * ifac[k] % MOD * ifac[n-k] % MOD} var valsAt = IntArray(N)var a = IntArray(N)var cnt = IntArray(N)var dp = Array<LongArray>(8, {_ -> LongArray(N)})var n = 0 fun build() {    for (i in 1..(N-1)) {        for (j in i..(N-1) step i) {            cnt[i] += valsAt[j]        }    }} fun main() { output{    setup()    n = readInt()    for (i in 1..n) {        a[i] = readInt()        valsAt[a[i]]++    }    build()    var ans = -1    for (i in 1..7) {        for (j in (N-1) downTo 1) {            if (i > cnt[j]) {                continue            }            dp[i][j] = choose(cnt[j], i)            for (k in (j*2)..(N-1) step j) {                dp[i][j] -= dp[i][k]            }            dp[i][j] = (dp[i][j]%MOD + MOD)%MOD            //println("" dp $i $j : ${dp[i][j]}"")        }        if (dp[i][1] != 0L) {            ans = i            break        }    }    println(ans)}}","bitmasks,combinatorics,dp,math,number theory,shortest paths"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.* const val MOD = 998244353L fun main() {    val factorial = LongArray(1000001)    factorial[0] = 1L    for (k in 1..1000000) {        factorial[k] = (k.toLong() * factorial[k - 1]) % MOD    }    val invFactorial = LongArray(1000001)    invFactorial[1000000] = 490058372L    for (k in 999999 downTo 0) {        invFactorial[k] = ((k + 1).toLong() * invFactorial[k + 1]) % MOD    }    val inv = LongArray(1000001)    for (k in 1..1000000) {        inv[k] = (factorial[k - 1] * invFactorial[k]) % MOD    }    val jin = BufferedReader(InputStreamReader(System.`in`))    val (n, m) = jin.readLine().split("" "").map { it.toInt() }    val cells = mutableListOf<Cell>()    for (y in 0 until n) {        val tokenizer = StringTokenizer(jin.readLine())        for (x in 0 until m) {            cells.add(Cell(y, x, tokenizer.nextToken().toInt()))        }    }    cells.sortBy { it.rank }    var k = 0    val dp = Array(n) { LongArray(m) }    var ySum = 0L    var y2Sum = 0L    var xSum = 0L    var x2Sum = 0L    var dpSum = 0L    for ((y, x, r) in cells) {        while (k < n * m && cells[k].rank < r) {            val (v, u) = cells[k]            ySum += v.toLong()            y2Sum += (v * v).toLong()            y2Sum %= MOD            xSum += u.toLong()            x2Sum += (u * u).toLong()            x2Sum %= MOD            dpSum += dp[v][u]            dpSum %= MOD            k++        }        if (k > 0) {            dp[y][x] = (((y * y) + (x * x)).toLong() + (((dpSum - (2L * ySum * y.toLong()) + y2Sum - (2L * xSum * x.toLong()) + x2Sum) % MOD) * inv[k])) % MOD        }    }    val (y, x) = jin.readLine().split("" "").map { it.toInt() - 1 }    println((dp[y][x] + MOD) % MOD)} data class Cell(val y: Int, val x: Int, val rank: Int)","dp,math,probabilities"
"fun main(args: Array<String>) {    val (n, k) = readLine()!!.split("" "").map { it.toInt() }    val s = readLine()!!    val count = IntArray(k)    s.forEach { count[it - 'A']++ }    println(k * count.min()!!)}","implementation,strings"
"import java.util.Scanner fun main() {    val (n, k) = readLine()!!.split(' ').map(String::toInt)    val str = readLine()!!     val grouped = str.groupBy { it }    if(grouped.size != k) {        println(0)    } else {        println(grouped.values.map { it.size }.min()!! * k)    } }","implementation,strings"
"fun main() {    val r = System.`in`.bufferedReader()    val s1 = StringBuilder()    //val n = r.readLine()!!.toInt()    val (n, k) = r.readLine()!!.split("" "").map { it.toInt() }    val str = r.readLine()!!.split("""").filter { it.isNotEmpty() }        .groupBy { it }.map { (k, v) -> v.size }    if (str.size!=k) println(0)    else println(str.min()!!*k)}","implementation,strings"
"import java.util.*import kotlin.collections.HashMap fun main(args: Array<String>) {    val sc = Scanner(System.`in`)    val cnt = sc.nextLine().split("" "")[1].toInt()    val str = sc.nextLine()    val map = HashMap<Char, Int>()    for (c in str) {        map[c] = map.getOrDefault(c, 0) + 1    }    if(map.keys.size != cnt) {        println(0)        return    }    val min = map.values.min()!!.toInt()    println(min * map.keys.size) }","implementation,strings"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.* fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val n = jin.readLine().toInt()    val adj = Array(n + 1) { mutableSetOf<Int>() }    for (j in 2..n) {        val (a, b) = jin.readLine().split("" "").map { it.toInt() }        adj[a].add(b)        adj[b].add(a)    }    val sequence = jin.readLine().split("" "").map { it.toInt() }    if (sequence[0] == 1) {        var j = 1        val q = LinkedList<Int>()        q.add(1)        while (q.isNotEmpty()) {            val a = q.remove()            while (j < n && sequence[j] in adj[a]) {                adj[a].remove(sequence[j])                adj[sequence[j]].remove(a)                q.add(sequence[j])                j++            }            if (adj[a].isNotEmpty()) {                println(""nO"")                return            }        }        println(""yEs"")    } else {        println(""nO"")    }}","dfs and similar,graphs,shortest paths,trees"
"import java.util.*import kotlin.collections.ArrayDeque   fun main() {    val n = readLine()!!.toInt()    val b = mutableListOf<MutableList<Int>>()    val visited = IntArray(n+1)    var relations = IntArray(n+1)    val ans = mutableListOf<Int>()    for (i in 1..n+1) {        b.add(mutableListOf())    }     for (i in 1 until n) {        val (x,y) = readLine()!!.split("" "").map { it.toInt() }        b[x].add(y)        b[y].add(x)    }     val a = readLine()!!.split("" "").map { it.toInt() }     for (i in 0 until n) {        relations[a[i]]=i    }    val comp = Comparator { a: Int, b: Int -> relations[a]-relations[b] }    for (i in 1..n) {        b[i].sortWith(comp)    }     val queue: Queue<Int> = LinkedList()    queue.add(1)    visited[1]=1    var curr= 1    ans.add(1)     while(queue.isNotEmpty()) {        curr++        val v = queue.remove()        for (u in b[v]) {            if(visited[u] != 1) {                visited[u]=1                queue.add(u)                ans.add(u)            }        }    }     for (i in 0 until n) {        if(ans[i] != a[i]) {            println(""No"")            return        }    }    println(""Yes"")    }","dfs and similar,graphs,shortest paths,trees"
"import java.util.* const val SIZE = 200002var n: Int = 0val m: HashMap<Int, HashSet<Int>> = HashMap()var visit: Array<Boolean> = Array(SIZE) { false }var arr: List<Int>? = null fun main(args: Array<String>) {    input()    solve()} fun input() {    n = readLine()!!.toInt()    (1..n).forEach { m[it] = HashSet() }    for (i in 1 until n) {        var a: Int        var b: Int        readLine()?.let {            val v = it.split("" "")            a = v[0].toInt()            b = v[1].toInt()            m[a]!!.add(b)            m[b]!!.add(a)        }    }     readLine()?.let {        arr = it.split("" "").map { s -> s.toInt() }.toList()    }} fun solve() {    val q: Queue<Int> = ArrayDeque<Int>()    q.add(1)    visit[1] = true    var pointer = 1 // skip root     while (q.isNotEmpty()) {        val parent = q.poll()        val children = m[parent]!!.filter { !visit[it] }.toSet()        if (!ok(children, pointer)) {            println(""No"")            return        }         (0 until children.size)                .map { arr!![it + pointer] }                .forEach {                    q.add(it)                    visit[it] = true                }        pointer += children.size    }     println(""Yes"")} fun ok(children: Set<Int>, pointer: Int) =    (0 until children.size)            .map { it + pointer }            .map { arr!![it] }            .all { children.contains(it) }","dfs and similar,graphs,shortest paths,trees"
"import java.util.* const val SIZE = 200002var n: Int = 0val m: HashMap<Int, HashSet<Int>> = HashMap()var visit: Array<Boolean> = Array(SIZE) { false }var arr: List<Int>? = null fun main(args: Array<String>) {    input()    solve()} fun input() {    n = readLine()!!.toInt()    (1..n).forEach { m[it] = HashSet() }    for (i in 1 until n) {        var a: Int        var b: Int        readLine()?.let {            val v = it.split("" "")            a = v[0].toInt()            b = v[1].toInt()            m[a]!!.add(b)            m[b]!!.add(a)        }    }     readLine()?.let {        arr = it.split("" "").map { s -> s.toInt() }.toList()    }} fun solve() {    val q: Queue<Int> = ArrayDeque<Int>()    q.add(1)    visit[1] = true    var pointer = 1 // skip root     while (q.isNotEmpty()) {        val parent = q.poll()        val children = m[parent]!!.filter { !visit[it] }.toSet()        if (!ok(children, pointer)) {            println(""No"")            return        }         (0 until children.size)                .map { arr!![it + pointer] }                .forEach { q.add(it) }         children.forEach {            q.add(it)            visit[it] = true        }        pointer += children.size    }     println(""Yes"")} fun ok(children: Set<Int>, pointer: Int) =    (0 until children.size)            .map { it + pointer }            .map { arr!![it] }            .all { children.contains(it) }","dfs and similar,graphs,shortest paths,trees"
"import java.io.*import java.math.*import java.util.* class Reader {    private val BUFFER_SIZE: Int = 1 shl 12    private var LENGTH: Int = -1    private val din: DataInputStream     private val buffer: ByteArray = ByteArray(BUFFER_SIZE)    private var bufferPointer: Int = 0    private var bytesRead: Int = 0     constructor(inputStream: InputStream) {        din = DataInputStream(inputStream)    }     constructor(fileName: String) {        din = DataInputStream(FileInputStream(fileName))    }     fun nextInt(): Int {        var ret: Int = 0        var c: Byte        do {            c = read()        } while (c <= 32)        var neg: Boolean = c == 45.toByte()        if (neg) c = read()        do {            ret = ret * 10 + c - 48            c = read()        } while (c >= 48)        if (neg) return -ret        return ret    }     fun nextLong(): Long {        var ret: Long = 0L        var c: Byte        do {            c = read()        } while (c <= 32)        var neg: Boolean = c == 45.toByte()        if (neg) c = read()        do {            ret = ret * 10 + c - 48            c = read()        } while (c >= 48)        if (neg) return -ret        return ret    }     fun nextDouble(): Double {        var ret: Double = 0.0        var div: Double = 1.0        var c: Byte        do {            c = read()        } while (c <= 32)        var neg: Boolean = c == 45.toByte()        if (neg) c = read()        do {            ret = ret * 10 + c - 48            c = read()        } while (c >= 48)        if (c == 46.toByte()) {            c = read()            while (c >= 48) {                div *= 10                ret += (c - 48) / div                c = read()            }        }        if (neg) return -ret        return ret    }     fun nextChar(): Char {        var c: Byte        do {            c = read()        } while (c <= 32)        return c.toChar()    }     fun next(): String {        val buf: CharArray = CharArray(LENGTH)        var c: Byte        var cnt: Int = 0        do {            c = read()        } while (c <= 32)        do {            buf[cnt++] = c.toChar()            c = read()        } while (c > 32)        return String(buf, 0, cnt)    }     fun nextLine(): String {        val buf: CharArray = CharArray(LENGTH)        var c: Byte        var cnt: Int = 0        do {            c = read()        } while (c <= 32)        do {            buf[cnt++] = c.toChar()            c = read()        } while (c >= 32)        return String(buf, 0, cnt)    }     fun setLength(length: Int) {        LENGTH = length    }     fun hasNext(): Boolean {        while (peek() > -1 && peek() <= 32) read()        return peek() > -1    }     private fun fillBuffer() {        bufferPointer = 0        bytesRead = din.read(buffer, bufferPointer, BUFFER_SIZE)        if (bytesRead == -1) buffer[0] = -1    }     private fun read(): Byte {        if (bufferPointer == bytesRead) fillBuffer()        return buffer[bufferPointer++]    }     private fun peek(): Byte {        if (bufferPointer == bytesRead) fillBuffer()        return buffer[bufferPointer]    }     fun close() {        din.close()    }} var NUM_OF_TEST_CASES: Int = 1 // TODO CHANGE NUMBER OF TEST CASES // TODO CHANGE FILE NAMESval INPUT_FILE_NAME = ""input.txt""val OUTPUT_FILE_NAME = ""output.txt"" val stdIn: Boolean = trueval stdOut: Boolean = trueval crash: Boolean = trueval flush: Boolean = false val In: Reader = if (stdIn) Reader(System.`in`) else Reader(INPUT_FILE_NAME)val Out: PrintWriter = if (stdOut) PrintWriter(System.out) else PrintWriter(OUTPUT_FILE_NAME) fun main(args: Array<String>) {    for (i in 1..NUM_OF_TEST_CASES) {        try {            run(i)        } catch (e: Exception) {            System.err.println(""Exception thrown on test case "")            e.printStackTrace(System.err)            Out.flush()            if (crash) throw Exception()        }        if (flush) Out.flush()    }    In.close()    Out.close()} fun run(testCaseNum: Int) {    data class Point(val x: Long, val y: Long)    fun ccw(a: Point, b: Point, c: Point): Int {        val area2 = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)        return if (area2 < 0) -1 else if (area2 > 0) 1 else 0     }    fun onSegment(p: Point, q: Point, r: Point): Boolean = p.x <= Math.max(q.x, r.x) && p.x >= Math.min(q.x, r.x) && p.y <= Math.max(q.y, r.y) && p.y >= Math.min(q.y, r.y)    fun intersects(p1: Point, q1: Point, p2: Point, q2: Point): Boolean {        val o1 = ccw(p1, q1, p2)        val o2 = ccw(p1, q1, q2)        val o3 = ccw(p2, q2, p1)        val o4 = ccw(p2, q2, q1)        if (o1 != o2 && o3 != o4) return true        if (o1 == 0 && onSegment(p2, p1, q1)) return true        if (o2 == 0 && onSegment(q2, p1, q1)) return true        if (o3 == 0 && onSegment(p1, p2, q2)) return true        if (o4 == 0 && onSegment(q1, p2, q2)) return true        return false    }    fun intersection(p1: Point, q1: Point, p2: Point, q2: Point): Point? {        val A1 = q1.y - p1.y        val B1 = p1.x - q1.x        val C1 = A1 * p1.x + B1 * p1.y        val A2 = q2.y - p2.y        val B2 = p2.x - q2.x        val C2 = A2 * p2.x + B2 * p2.y        val det = A1 * B2 - A2 * B1        if (det == 0L) throw Exception(""Lines do not intersect"")        if ((B2 * C1 - B1 * C2) % det != 0L || (A1 * C2 - A2 * C1) % det != 0L) return null        else return Point((B2 * C1 - B1 * C2) / det, (A1 * C2 - A2 * C1) / det)    }    fun gcd(a: Long, b: Long): Long = if (b == 0L) Math.abs(a) else gcd(b, a % b)    val L = Array(In.nextInt(), {Pair(Point(In.nextLong(), In.nextLong()), Point(In.nextLong(), In.nextLong()))})    val HS = HashSet<Point>()    var ans = 0L    for (i in 0 until L.size) {        ans += gcd(Math.abs(L[i].first.x - L[i].second.x), Math.abs(L[i].first.y - L[i].second.y)) + 1        val H = HashSet<Point>()        for (j in 0 until L.size) {            if (i == j || !intersects(L[i].first, L[i].second, L[j].first, L[j].second)) continue            val poi = intersection(L[i].first, L[i].second, L[j].first, L[j].second)            if (poi != null) H.add(poi)        }        ans -= H.size        HS.addAll(H)    }    Out.println(ans + HS.size)}","fft,geometry,number theory"
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport javax.swing.text.Segmentimport kotlin.math.absimport kotlin.math.absoluteValueimport kotlin.math.roundToIntimport kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        val S = fakein.toString()        println(""New Case "")        println(S.take(80))        println(""..."")        fakein.clear()        IN = BufferedInputStream(S.byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} val getint:Int get() = IO.nextInt()val getlong:Long get() = IO.nextLong()val getstr:String get() = IO.nextString()fun getline(n:Int):IntArray{    return IntArray(n){getint}}fun getlineL(n:Int):LongArray{    return LongArray(n){getlong}}fun getbinary(n:Int):BooleanArray{    val str = getstr    return BooleanArray(n){str[it] == '1'}} val List<Char>.ret:Stringget() = this.joinToString("""")infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    var str = """"    if(this is String){ str = this    }else if(this is Int){ str = this.toString()    }else if(this is Long){ str = this.toString()    }    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is Array<*>){        println(""$str : "")        for(c in a){if(c is IntArray){println(c.joinToString("" ""))}        else if(c is LongArray){println(c.joinToString("" ""))}        else if(c is BooleanArray){println(c.map { if(it) '1' else '0' }.joinToString(""""))        }         }        println()    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){    throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){        throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}const val withBruteForce = falseconst val randCount = 100object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    fun cases(onecase:()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint} else if(mode == solveMode.tc){1 } else randCount        //safety checks        if(pI != 998_244_353 && pI != 1_000_000_007){            throw Exception(""Modding a wrong prime!"")        }         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            currentAnswer = null            currentBruteAnswer = null            onecase()        }        if(withBruteForce){            put(""Checked ${answersChecked}"")        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    inline fun brute(a:()->Unit){        if(withBruteForce){            a()        }    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }      var currentAnswer:String? = null    var currentBruteAnswer:String? = null    fun answer(a:Any){        currentAnswer = a.toString()        if(currentBruteAnswer != null){            checkAnswer()        }    }    fun put2(a:Any){answer(a);put(a) }     fun bruteAnswer(a:Any){        currentBruteAnswer = a.toString()        if(currentAnswer != null){            checkAnswer()        }    }    fun checkAnswer(){        if(currentAnswer != currentBruteAnswer){            throw Exception(""Failed Test: BF $currentBruteAnswer Current $currentAnswer"")        }        answersChecked ++    }}// 1. Moddedconst val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}infix fun Int.modM(b:Int):Int{ return ((this * 1L * b) % pI).toInt() }infix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }// 2. DP initial valuesconst val plarge = 1_000_000_727const val nlarge = -plargeconst val phuge = 2_727_000_000_000_000_000Lconst val nhuge = -phuge// 3. conveniecen conversionsval Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionval Char.code :Int get() = this.toInt() -  'a'.toInt()//3. hard to write stufffun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val mint:MutableList<Int> get() = mutableListOf<Int>()val mong:MutableList<Long> get() = mutableListOf<Long>()//4. more outputsfun List<Char>.conca():String = this.joinToString("""")val CharArray.conca :String get() = this.joinToString("""")val IntArray.conca :String get() = this.joinToString("" "")@JvmName(""concaInt"")fun List<Int>.conca():String = this.joinToString("" "")val LongArray.conca:String get() = this.joinToString("" "")@JvmName(""concaLong"")fun List<Long>.conca():String = this.joinToString("" "")//5. Pair of intsfun makepair(a:Int, b:Int):Long = (a.toLong() shl 32) xor b.toLong()val Long.first get() = (this shr 32).toInt()val Long.second get() = this.toInt() tailrec fun gcd(a: Int, b: Int): Int {    if(b == 0) return a.absoluteValue    return if (a % b == 0) abs(b) else gcd(b, a % b)}tailrec fun gcd(a: Long, b: Long): Long {    return if (a % b == 0L) Math.abs(b) else gcd(b, a % b)}class Point(val x: Int, val y: Int) : Comparable<Point> {    companion object{        const val mode:Int = 0        //0: Compare by x coordinate then y        // 1 : half circle , through origin        //2: By vecotr, (0,1) is the largest, then clockwise sorting        var origin:Point? = null        // null: compare by x coordinate        // any point: compare by 180 degrees cone, undefined at origin    }    operator fun component1() = x    operator fun component2() = y    override fun compareTo(other: Point):Int {        if (mode == 0) {            if(this.x != other.x){                return this.x.compareTo(other.x)            }            return this.y.compareTo(other.y)        } else if(mode == 1){            val origin = origin!!            val x1 =  x - origin.x            val x2 = other.x - origin.x            val y1 = y - origin.y            val y2 = other.y - origin.y            if(x1 == 0 && y1 == 0){                return -1            }else if(x2 == 0 && y2 == 0){                return 1            }            val f1 = (x1 < 0 || (x1 == 0 && y1 < 0))            val f2 = (x2 < 0 || (x2 == 0 && y2 < 0))            val ret = (1L * x1 * y2 - 1L * x2 * y1).compareTo(0)            return if(f1 xor f2) -ret else ret        }else{            if(this.sector != other.sector){                return (this.sector.compareTo(other.sector))            }            return (1L * x * other.y - 1L * y * other.x).compareTo(0L)        }    }     override fun toString() = ""($x, $y)""    operator fun plus(other: Point): Point {        return Point(this.x + other.x, this.y + other.y)    }     operator fun minus(other: Point): Point {        return Point(this.x - other.x, this.y - other.y)    }    fun clockwise():Point{        return Point(this.y, -this.x)    }    fun antiClockwise():Point{        return Point(-this.y,this.x)    }    fun reduced():Point{        val d = gcd(x,y)        return Point(x/d,y/d)    }    infix fun dot(other: Point):Long{        return (1L * x * other.x + 1L * y * other.y)    }    infix fun cross(other:Point):Long{        return (1L * x * other.y - 1L * other.x * y)    }    fun makeCounterClockwise(from:Point, to:Point):Boolean{        // in this order: this is the center: clock direction goes in from, to        return (1L * (from.x - this.x) * (to.y - this.y)) > ((from.y - this.y) * (to.x - this.x))    }    fun makeClockwiseTurn(from:Point, to:Point):Boolean{        return !makeCounterClockwise(from,to)    }    fun orientation(second:Point, third:Point):Int{        val ori = (1L * (second.x - this.x) * (third.y - this.y)) - (1L * (second.y - this.y) * (third.x - this.x))        return if(ori > 0L) 1 else if(ori < 0L) -1 else 0    }    fun sortPoints(pts:List<Point>): List<Point> {        // Make sure they are in the same halfplanes        // assume leftmost and top to Bottom        return pts.sortedWith(Comparator { a, b -> if(makeCounterClockwise(a,b)) 1 else -1  })    }    override fun equals(other: Any?): Boolean {        if (this === other) return true        if (javaClass != other?.javaClass) return false         other as Point         if (x != other.x) return false        if (y != other.y) return false         return true    }    fun linesThrough(pts:List<Point>,act:(List<Point>)->Unit){        // for each lines through it, output it , n log n        origin = this        var now = mutableListOf<Point>()        val ps = pts.sorted()        for (i in 1 until ps.size){            val p = ps[i]            if(now.isEmpty()){                now.add(p)            }else if(now.last().compareTo(p) == 0){                now.add(p)            }else{                act(now)                now.clear()                now.add(p)            }        }        if(now.isNotEmpty()){            act(now)        }    }     override fun hashCode(): Int {        var result = x        result = 31 * result + y        return result    }      // 0 for positeve y axis, 1 for rhs, 2 for down , 3 for lhs    val sector:Int get() =        if(this.x == 0){            if(this.y > 0) 0 else 2        }else{            if(x > 0) 1 else 3        }     val hash:Long get() = makepair(this.x, this.y)  }data class doublePoint(val x:Double,val y:Double){ }fun Point.asDouble() = doublePoint(this.x.toDouble(),this.y.toDouble()) class segment (val a:Point, val b:Point){    fun containsPoint(c:Point):Boolean{        return a.orientation(b,c) == 0 && containsPoint_rect(c)    }     fun containsPoint_rect(c:Point):Boolean{        if (c.x <= Math.max(a.x, b.x) && c.x >= Math.min(a.x, b.x) &&            c.y <= Math.max(a.y, b.y) && c.y >= Math.min(a.y, b.y))            return true;         return false;    }    fun intersect(other:segment): Boolean {        val c = other.a        val d = other.b         val o1 = a.orientation(b,c)        val o2 = a.orientation(b,d)        val o3 = c.orientation(d,a)        val o4 = c.orientation(d,b)         if(o1 != o2 && o3 != o4) return true        if(o1 == 0 && this.containsPoint_rect(c)) return true        if( o2 == 0 && this.containsPoint_rect(d)) return true        if(o3 == 0 && other.containsPoint_rect(a)) return true        if(o4 == 0 && other.containsPoint_rect(b)) return true        return false    }     fun intersectionPoint(other:segment): doublePoint? {        if(!intersect(other)){            return null        }        val p1 = this.a.asDouble()        val q1 = this.b.asDouble()        val p2 = other.a.asDouble()        val q2 = other.b.asDouble()         return if (p1.x === q1.x) {            val m: Double = (q2.y - p2.y) * 1.0 / (q2.x - p2.x)            val c: Double = q2.y - q2.x * m            return doublePoint(p1.x, m * p1.x + c)        } else if (p2.x === q2.x) {            val m: Double = (q1.y - p1.y) * 1.0 / (q1.x - p1.x)            val c: Double = q1.y - q1.x * m            return doublePoint(p2.x, m * p2.x + c)        } else {            val m1: Double = (q1.y - p1.y) * 1.0 / (q1.x - p1.x)            val c1: Double = q1.y - q1.x * m1            val m2: Double = (q2.y - p2.y) * 1.0 / (q2.x - p2.x)            val c2: Double = q2.y - q2.x * m2            val finx = (c2 - c1) * 1.0 / (m1 - m2)            val finy = finx * m1 + c1            return doublePoint(finx, finy)        }     }    fun intersectInteger(other:segment):Point?{        val trythis = intersectionPoint(other) ?: return null        val p = Point(trythis.x.roundToInt(), trythis.y.roundToInt())        return if(containsPoint(p) && other.containsPoint(p)) p else null    }    fun integerPoints():Int{        if(this.a == this.b){            return 1        }else {            return gcd((this.a.x - this.b.x).absoluteValue, (this.a.y - this.b.y).absoluteValue) + 1        }    }}const val singleCase = truefun main(){    solve.cases{		val n = getint        val all = List(n){            segment(Point(getint, getint),Point(getint,getint))        }         var ret = 0L        for(s in all){            ret += s.integerPoints()        }         val IP = mutableMapOf<Long,MutableSet<Int>>()        for(i in all.indices){            for(j in i+1 until all.size){                val s1 = all[i]                val s2 = all[j]                val p = s1.intersectInteger(s2)                if(p == null) continue                if(IP[p.hash] == null) IP[p.hash] = mutableSetOf()                IP[p.hash]!!.add(i)                IP[p.hash]!!.add(j)                ret --            }        }        val extra = IntArray(1003){v ->            if(v <= 2) 0            else (v - (v * (v-1))/2 - 1)        }        for((i,v) in IP){            ret -= extra[v.size]        }        put(ret)    }    done()}    /*2454379 373644 -454379 -373644-665078 -385892 665078 385892  */","fft,geometry,number theory"
"import java.util.* fun main(args: Array<String>) {    val sc = Scanner(System.`in`)    val t = sc.nextInt()    repeat(t) {        val a = sc.nextBigInteger()        val b = sc.nextBigInteger()        if ((a * a - b * b).isProbablePrime(100)) {            println(""YES"")        }else{            println(""NO"")        }    }}","math,number theory"
"fun check(a: Long, b: Long): Boolean {    if (a - b > 1) return false    val res = a + b    for (i in 2..Math.sqrt(res.toDouble()).toInt()) {        if (res % i == 0L) {            return false        }    }    return true} fun main(args: Array<String>) {    val t = readLine()!!.toInt()    for (test in 0 until t) {        val (a, b) = readLine()!!.split("" "").map{it.toLong()}        if (check(a, b)) println(""YES"") else println(""NO"")    }}","math,number theory"
"import java.io.FileInputStreamimport java.util.* object programkt {  @JvmStatic fun main(args: Array<String>) {    if (args.size == 1)      System.setIn(FileInputStream(args[0]))    val sc = Scanner(System.`in`)    val t = Integer.parseInt(sc.nextLine())    IntRange(1, t).forEach {      val a = sc.nextLong()      val b = sc.nextLong()      println(if (a - b == 1L && isPrime(a+b)) ""YES"" else ""NO"")    }  }   private fun isPrime(n: Long): Boolean {    var i = 2L    while (i * i <= n) {      if (n % i == 0L)        return false      i++    }    return true  }}","math,number theory"
"import kotlin.math.sqrt fun main() {    repeat(readLine()!!.toInt()) {        val (a,b)= readLine()!!.split("" "").map { it.toLong() }        if(a - b > 1) {            println(""NO"")        } else {            var isPrime = true            for (i in 3..sqrt((a+b).toDouble()).toInt() step 2) {                if((a+b).rem(i) == 0L) {                    isPrime = false                    break                }            }            if(isPrime) {                println(""YES"")            } else {                println(""NO"")            }         }      }    }  ","math,number theory"
"fun check(a: Int, b: Int, c: Int): Boolean {    return (a < c && b < c) || (a > c && b > c)} fun main(args: Array<String>) {    readLine()    val (ax, ay) = readLine()!!.split("" "").map{it.toInt()}    val (bx, by) = readLine()!!.split("" "").map{it.toInt()}    val (cx, cy) = readLine()!!.split("" "").map{it.toInt()}    if (check(bx, cx, ax) && check(by, cy, ay)) println(""YES"") else println(""NO"")}","dfs and similar,graphs,implementation"
"fun main(args: Array<String>) {    readLine()    val (ax, ay) = (readLine()!!.split("" "")).map { it.toInt() }    val (bx, by) = (readLine()!!.split("" "")).map { it.toInt() }    val (cx, cy) = (readLine()!!.split("" "")).map { it.toInt() }    val ans = !(ax in cx..bx            || ax in bx..cx            || ay in by..cy            || ay in cy..by)    if (ans) {        println(""YES"")    } else {        println(""NO"")    }}","dfs and similar,graphs,implementation"
"fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     readLine()    val queen = readInts()    val king = readInts()    val goal = readInts()    val (rowMin, rowMax) = if (king[0] <= goal[0]) king[0] to goal[0] else goal[0] to king[0]    val (colMin, colMax) = if (king[1] <= goal[1]) king[1] to goal[1] else goal[1] to king[1]    print(if (queen[0] in rowMin..rowMax || queen[1] in colMin..colMax) ""NO"" else ""YES"")}","dfs and similar,graphs,implementation"
"import java.io.FileInputStreamimport java.util.* object programkt {  @JvmStatic fun main(args: Array<String>) {    if (args.size == 1)      System.setIn(FileInputStream(args[0]))    val sc = Scanner(System.`in`)    sc.nextLine()    val ax = sc.nextInt()    val ay = sc.nextInt()    val bx = sc.nextInt()    val by = sc.nextInt()    val cx = sc.nextInt()    val cy = sc.nextInt()     val xOk = !(bx > ax).xor(cx > ax)    val yOk = !(by > ay).xor(cy > ay)    println(if (xOk && yOk) ""YES"" else ""NO"")  }}","dfs and similar,graphs,implementation"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.*import kotlin.collections.ArrayListimport kotlin.math.maximport kotlin.math.min fun main(args: Array<String>) {    val tokenizer = BufferedReader(InputStreamReader(System.`in`)).use { StringTokenizer(it.readText()) }    val n = tokenizer.nextInt()    val list = Array(n) { Rect(tokenizer.nextInt(), tokenizer.nextInt(), tokenizer.nextInt(), tokenizer.nextInt()) }    val order = listOf({ rect: Rect -> rect.minX }, { rect: Rect -> rect.minY }, { rect: Rect -> rect.maxX }, { rect: Rect -> rect.maxY })    val result = ArrayList<Rect>()    result.add(Rect(Int.MIN_VALUE, Int.MIN_VALUE, Int.MAX_VALUE, Int.MAX_VALUE))    for (i in 0..3) {        if (i in 0..1) {            list.sortByDescending(order[i])        } else {            list.sortBy(order[i])        }        if (order[i](list[0]) != order[i](list[1]))            result.add(list[0])    }    var ans: Rect? = null    for (r in result) {        val temp = Rect(Int.MIN_VALUE, Int.MIN_VALUE, Int.MAX_VALUE, Int.MAX_VALUE)        for (i in list) {            if (i !== r)                temp.clip(i)        }        if (temp.check()) {            ans = temp            break        }    }    if (ans != null)        println(""${ans.minX} ${ans.minY}"")    else        println(-1)} data class Rect(var minX: Int, var minY: Int, var maxX: Int, var maxY: Int) {    fun check() = minX <= maxX && minY <= maxY    fun clip(o: Rect) {        minX = max(minX, o.minX)        maxX = min(maxX, o.maxX)        minY = max(minY, o.minY)        maxY = min(maxY, o.maxY)    }} fun StringTokenizer.nextInt() = Integer.parseInt(nextToken()) ","geometry,implementation,sortings"
"fun main(args: Array<String>) {    var in1 = readLine()!!    val n = in1.split("" "")[0].toLong()    val q = in1.split("" "")[1].toInt()    for (i in 1..q)    {       in1 = readLine()!!        val a = in1.split("" "")[0].toLong()        val b = in1.split("" "")[1].toLong()        val sira : Long = (a-1)*n + b-1        var yaz : Long        if((a+b)%2 == 0L)            yaz = sira/2+1        else        {            yaz = n*n/2 + sira/2 + 1            if(n%2 == 1L)                yaz++        }        println(yaz)    }}","implementation,math"
"var n: Long = 0var halfPower: Long = 0 fun main(args: Array<String>) {    val data = readLine()!!.split("" "")    n = data[0].toLong()    halfPower = n * n/2 + n % 2    val q = data[1].toInt()    for (i in 0 until q) {        val init = readLine()!!.split("" "")        val ans = solve(init[0].toInt(), init[1].toInt())        println(ans)    }} fun solve(i: Int, j:Int): Long {    val length = (i-1)*n + j    val even = ((i+j) % 2) == 0    val halfLength = length / 2 + length % 2    val res = if (even) halfLength else halfPower + halfLength    return res}","implementation,math"
"var n: Long = 0var halfPower: Long = 0 fun main(args: Array<String>) {    val data = readLine()!!.split("" "")    n = data[0].toLong()    halfPower = n * n/2 + n % 2//    println(halfPower)    val q = data[1].toInt()    for (i in 0 until q) {        val init = readLine()!!.split("" "")        val ans = solve(init[0].toInt(), init[1].toInt())        println(ans)    }} fun solve(i: Int, j:Int): Long {    val length = (i-1)*n + j//    println(length)    val even = ((i+j) % 2) == 0    val halfLength = length / 2 + length % 2//    println(halfLength)    val res = if (even) halfLength else halfPower + halfLength    return res}","implementation,math"
"fun main(args: Array<String>) {    val (n, q) = readLine()!!.split("" "").map { it.toInt() }    val a = LongArray(q) {        val (x, y) = readLine()!!.split("" "").map { it.toLong() }        queryBoard(x, y, n.toLong())    }    println(a.joinToString(""\n""))} fun queryBoard(x: Long, y: Long, n: Long): Long {    return if ((x + y) % 2 == 0L) {        if (x % 2 != 0L) {            x / 2 * n + y / 2 + 1        } else {            (x - 1) / 2 * n + (y - 1) / 2 + (n + 1) / 2 + 1        }    } else {        val b = (n * n + 1) / 2 + 1        if (x % 2 != 0L) {            x / 2 * n + (y - 1) / 2 + b        } else {            (x - 1) / 2 * n + (y - 1) / 2 + n / 2 + b        }    }}","implementation,math"
"import kotlin.math.*import java.io.*import kotlin.concurrent.threadimport java.io.IOExceptionimport java.util.StringTokenizerimport java.io.BufferedReaderimport java.io.InputStreamimport kotlin.*import java.*import java.io.OutputStreamimport java.io.PrintWriter       private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of ints fun main(){    val inputStream = System.`in`    val outputStream = System.out    val `in` = InputReader(inputStream)    val out = PrintWriter(outputStream)      val n = `in`.nextInt()    val k = `in`.nextInt()    val m = `in`.nextInt()    var rest = k    val g = Array(n + 1) { ArrayList<G>() }    val cl = List(k) {        val a =`in`.nextInt()        val b =`in`.nextInt()        val c = 1000000007        g[a].add(G(a, b, c))        g[b].add(G(b, a, c))        G(a, b, c)    }    val el = List(m) {        val a =`in`.nextInt()        val b =`in`.nextInt()        val w =`in`.nextInt()        G(a, b, -w)    }    val parent = IntArray(n + 1) { it }    val rank = IntArray(n + 1)    tailrec fun xparent(i: Int): Int {        val q = parent[i]        if (q == i) return i        return xparent(q)    }     for ((a, b, _) in cl) {        val pa = xparent(a)        val pb = xparent(b)        if (pa == pb) continue        when {            rank[pa] < rank[pb] -> parent[pa] = pb            rank[pb] < rank[pa] -> parent[pb] = pa            else -> {                parent[pb] = pa                rank[pa]++            }        }    }     for ((a, b, c) in el) {        val pa = xparent(a)        val pb = xparent(b)         if (pa == pb) continue        when {            rank[pa] < rank[pb] -> parent[pa] = pb            rank[pb] < rank[pa] -> parent[pb] = pa            else -> {                parent[pb] = pa                rank[pa]++            }        }        g[a].add(G(a,b,c))        g[b].add(G(b,a,c))        //println(a.toString()+"" ""+b)    }    val grparent = Array(n+1,{it->G(0,0,0)})    val tin = IntArray(n + 1)    val tout = IntArray(n + 1)    val collapsed = IntArray(n + 1){it}    //val collapsedRank = IntArray(n + 1){0}     tailrec fun collapsedParent(i: Int): Int {        val q = collapsed[i]        if (q == i) return i        return collapsedParent(q)    }     /*fun collapse(a: Int,b: Int){        val pa = collapsedParent(a)        val pb = collapsedParent(b)         if (pa == pb) return        when {            collapsedRank[pa] < collapsedRank[pb] -> collapsed[pa] = pb            collapsedRank[pb] < collapsedRank[pa] -> collapsed[pb] = pa            else -> {                collapsed[pb] = pa                collapsedRank[pa]++            }        }    }*/     var time = 0    fun dfs(u:Int, p:Int)    {        tin[u]=time++        for ((a,v,b) in g[u])        {            if (v!=p) {                grparent[v]=G(v,a,b)                dfs(v, u)            }        }        tout[u]=time++    }    fun upper(a: Int,b: Int):Boolean    {        return tin[a]<=tin[b] && tout[a]>=tout[b]    }    dfs(1,1)     var ans = 0L     for ((a,b,c) in el)    {        val pa = collapsedParent(a)        val pb = collapsedParent(b)        if (pa==pb)            continue        var lca = pa        while (!upper(lca,pb))            lca=collapsedParent(grparent[lca].b)         var i = pa        while(i!=lca)        {            collapsed[i]=lca            if (grparent[i].c==1000000007)            {                ans += c.toLong()                grparent[i].c=c                --rest            }            i=collapsedParent(grparent[i].b)        }        i = pb        while(i!=lca)        {            collapsed[i]=lca            if (grparent[i].c==1000000007)            {                ans += c.toLong()                grparent[i].c=c                --rest            }            i=collapsedParent(grparent[i].b)        }    }    if (rest>0)        println(-1)    else        println(-ans)} data class G(val a: Int, val b: Int, var c: Int) internal class InputReader(stream: InputStream) {    var reader: BufferedReader    var tokenizer: StringTokenizer? = null     init {        reader = BufferedReader(InputStreamReader(stream), 32768)        tokenizer = null    }     operator fun next(): String {        while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {            try {                tokenizer = StringTokenizer(reader.readLine())            } catch (e: IOException) {                throw RuntimeException(e)            }         }        return tokenizer!!.nextToken()    }     fun nextInt(): Int {        return Integer.parseInt(next())    } }","dfs and similar,dsu,graphs,trees"
"import kotlin.math.* fun main(args: Array<String>) {	val (n, h, a, b, k) = readLine()!!.split(' ').map(String::toInt)		for (i in 1 .. k ) {		val (t1, f1, t2, f2) = readLine()!!.split(' ').map(String::toInt)		var ans : Int = abs(t1-t2) + abs(f1-f2)		if (t1 != t2) { 			ans += 2 * when {				min(f1,f2) > b -> min(f1,f2) - b				max(f1,f2) < a -> a - max(f1,f2)				else -> 0			}		}		println(ans)	}}   ",math
"import kotlin.math.absoluteValue fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val (_, _, a, b, numQueries) = readInts()    val sols = IntArray(numQueries)    for (query in 0 until numQueries) {        val (towerFrom, floorFrom, towerTo, floorTo) = readInts()        if (towerFrom == towerTo) {            sols[query] = (floorFrom - floorTo).absoluteValue            continue        }        var (sol, floor) = when {            floorFrom > b -> floorFrom - b to b            floorFrom < a -> a - floorFrom to a            else -> 0 to floorFrom        }        sol += (towerFrom - towerTo).absoluteValue        sol += (floor - floorTo).absoluteValue        sols[query] = sol    }    print(sols.joinToString(System.lineSeparator()))}",math
import java.io.BufferedInputStreamimport java.util.* fun main(args: Array<String>) {    val scanner = Scanner(BufferedInputStream(System.`in`))     val n = scanner.nextInt()    val h = scanner.nextInt()    val a = scanner.nextInt()    val b = scanner.nextInt()    val k = scanner.nextInt()    repeat(k) {        val ta = scanner.nextInt()        val fa = scanner.nextInt()        val tb = scanner.nextInt()        val fb = scanner.nextInt()         val towerDiff = Math.abs(ta - tb)        if (ta == tb) {            println(Math.abs(fa - fb))            return@repeat        }        if (fa in a..b || fb in a..b || (fa < a && fb > b) || (fa > b && fb < a)) {            println(towerDiff + Math.abs(fa - fb))            return@repeat        } else if (fa < a && fb < a) {            println(towerDiff + Math.abs(fa + fb - a - a))            return@repeat        } else if (fa > b && fb > b) {            println(towerDiff + Math.abs(fa + fb - b - b))            return@repeat        }    }},math
"import java.io.BufferedReaderimport java.io.BufferedWriter class ProblemA {    private fun BufferedReader.readInt() : Int = this.readLine().toInt()    private fun BufferedReader.readIntArray(delimiter: String = "" "") =        this.readLine().split(delimiter).map { it.toInt() }.toIntArray()    private fun BufferedReader.readLongArray(delimiter: String = "" "") =        this.readLine().split(delimiter).map { it.toLong() }.toLongArray()     private fun BufferedWriter.writeLine(s: String) {        this.write(s)        this.newLine()    }     private fun IntArray.swap(i: Int, j:Int) {        val tmp = this[i]        this[i] = this[j]        this[j] = tmp    }    private fun solveTest(input: BufferedReader, output: BufferedWriter) {        val (n,h,a,b, k) = input.readIntArray()        for(i in 1..k) {            val query = input.readLongArray()            var tot = kotlin.math.abs(query.first() - query[2])            val mx = maxOf(query[1], query[3])            val mn = minOf(query[1], query[3])            tot += if(query[0] == query[2] || a in mn..mx || b in mn..mx || mn in a..b || mx in a..b) {                mx-mn            } else if(mx <=a){                a-mx + a-mn            } else if(mn >= b) {                mn + mx - 2 * b            } else {                throw IllegalStateException(""$mn $mx -> $a $b"")            }            output.writeLine(tot.toString())        }    }     fun solve(input: BufferedReader, output: BufferedWriter) {        solveTest(input, output)        input.close()        output.close()    } } fun main() {    val solution = ProblemA()    solution.solve(System.`in`.bufferedReader(), System.out.bufferedWriter())}",math
"fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val (numParticipants, numFoods) = readInts()    val types = readInts()    val typeToAmount = mutableMapOf<Int, Int>().withDefault { 0 }    for (type in types) typeToAmount[type] = typeToAmount.getValue(type) + 1    for (amountPerPerson in 1..numFoods) {        val numFeedable =            typeToAmount.entries.fold(0) { acc, mutableEntry -> acc + mutableEntry.value / amountPerPerson }        if (numFeedable < numParticipants) return print(amountPerPerson - 1)    }    print(numFoods)}","binary search,brute force,implementation"
"import java.io.BufferedInputStreamimport java.util.* fun main(args: Array<String>) {    val scanner = Scanner(BufferedInputStream(System.`in`))     val n = scanner.nextInt()    val m = scanner.nextInt()     val foods = mutableMapOf<Int, Int>()    repeat (m) {        val food = scanner.nextInt()        foods[food] = foods.getOrDefault(food, 0) + 1    }     var left = 0    var right = m / n    while (left < right) {        val mid = (left + right + 1) / 2        val canSurviveMid = canSurvive(mid, n, foods)        if (canSurviveMid) {            left = mid        } else {            right = mid - 1        }    }    println(left)} fun canSurvive(day: Int, people: Int, foods: MutableMap<Int, Int>): Boolean {    var sumPeople = 0L    for (food in foods) {        sumPeople += food.value / day    }     return sumPeople >= people}","binary search,brute force,implementation"
"import java.util.*  fun main(args: Array<String>) {    val sc = Scanner(System.`in`)    val people = sc.nextInt()    val food = sc.nextInt()    val typescnt = 101     val types = IntArray(typescnt, {0})    for (i in 1..food) {        types[sc.nextInt()] += 1    }     val eating = IntArray(typescnt, {0})     for (i in 1..people) {        var maxk = -1        var maxkj = -1        for (j in 1 until typescnt) {            if (types[j] == 0)                continue            val coef = types[j] / (eating[j] + 1)            if (coef > maxk) {                maxk = coef                maxkj = j            }        }        if (maxkj != -1) {            eating[maxkj] += 1        }    }     var mind = 1000000     for (i in 1 until typescnt) {        if (eating[i] != 0) {            val v = types[i] / eating[i]            if (v < mind)                mind = v        }    }     if (mind == 1000000) {        println(""0"")    } else {        println(mind)    }     val a = 2 } ","binary search,brute force,implementation"
"import java.util.*; private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readDouble() = readLn().toDouble() // single intprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of intsprivate fun readDoubles() = readStrings().map { it.toDouble() } // list of ints fun main(args: Array<String>) {    solve()    /*    val t = readInt()    repeat(t) {        solve()    }    */} fun solve() {    val (k, n) = readInts()    val l = IntArray(101)    for(x in readInts()) {        l[x]++    }    var lhs = 0    var rhs = 10000    while(lhs != rhs) {        val mid = (lhs + rhs + 1) / 2        var can = 0        for(x in l) {            can += x / mid        }        if(can >= k) lhs = mid        else rhs = mid - 1    }    println(lhs)} /*useful things:to read in multiple ints in one lineval (n, m, k) = readInts() Java: int[] dx = new int[]{-1,1,0,0}Kotlin: val dx = arrayOf(-1, 1, 0, 0)*/","binary search,brute force,implementation"
"fun main(args: Array<String>) {    val (n, m) = readLine()!!.split("" "").map { it.toInt() }    val g = solveGraph(n, m)    if (g == null) {        println(""Impossible"")    } else {        println(""Possible"")        g.forEach { (u, v) ->            println(""$u $v"")        }    }} fun solveGraph(n: Int, m: Int): List<Pair<Int, Int>>? {    if (m < n - 1) return null    val g = ArrayList<Pair<Int, Int>>(m)    for (i in 1..n) {        for (j in i + 1..n) {            if (gcd(i, j) != 1) continue            g += Pair(i, j)            if (g.size == m) return g        }    }    return null} tailrec fun gcd(x: Int, y: Int): Int = if (x == 0) y else gcd(y % x, x) ","brute force,constructive algorithms,graphs,greedy,math"
"import java.io.BufferedInputStreamimport java.util.* fun main(args: Array<String>) {    val scanner = Scanner(BufferedInputStream(System.`in`))     val n = scanner.nextInt() // Vertices    val m = scanner.nextInt() // Edges     if (m < n - 1) {        println(""Impossible"")        return    }    val primeDivisorsList = Array(n + 1) { it.primeDivisors }     val result = mutableListOf<String>()     loop@for (i in 1..(n-1)) {        for (j in (i + 1)..n) {            if ((primeDivisorsList[i] intersect primeDivisorsList[j]).isEmpty()) {                result.add(""$i $j"")            }            if (result.size >= m) {                break@loop            }        }    }     if (result.size < m) {        println(""Impossible"")        return    }     println(""Possible"")    for (i in 0 until m) {        println(result[i])    } } val Int.primeDivisors: Set<Int>    get() {        val result = mutableSetOf<Int>()        var t = this        var i = 2        while (i * i <= t) {            if (t % i == 0) {                result.add(i)                while (t % i == 0) {                    t /= i                }            }            i++        }        if (t > 1) {            result.add(t)        }        return result    }","brute force,constructive algorithms,graphs,greedy,math"
"import java.io.*import java.util.* fun gcd(aa: Int, bb: Int): Int {    var a = aa    var b = bb     while (b != 0) {        a %= b         val tmp = a        a = b        b = tmp    }     return a} fun solve(inn: InputReader, out: PrintWriter) {    val N = inn.readInt()    val M = inn.readInt()     if (M < N - 1) {        out.print(""Impossible"")        return    }     val result = mutableListOf<Pair<Int, Int>>()    for (i in 1..N) {        for (j in i + 1..N) {            if (gcd(i, j) == 1) {                result.add(Pair(i, j))                if (result.size == M) {                    out.println(""Possible"")                    for ((a, b) in result) {                        out.print(a)                        out.print(' ')                        out.println(b)                    }                    return                }            }        }    }     out.print(""Impossible"")} fun main(args: Array<String>) {    val inn = InputReader(System.`in`)//    val inn = InputReader(FileInputStream(""1.txt""))    val out = PrintWriter(System.out)     solve(inn, out)     inn.close()    out.close()} class InputReader(inputStream: InputStream) {    val mReader = inputStream.bufferedReader()    var mTokenizer: StringTokenizer? = null     fun close() = mReader.close()     fun readString(): String {        if (mTokenizer == null || !mTokenizer!!.hasMoreTokens()) {            mTokenizer = StringTokenizer(mReader.readLine())        }         return mTokenizer!!.nextToken()    }     fun readInt(): Int = readString().toInt()}","brute force,constructive algorithms,graphs,greedy,math"
"import java.io.*import java.util.*import kotlin.collections.ArrayList fun main(args: Array<String>) {    solve(System.`in`, System.out)} val MAX_N = (1e6 + 10).toInt()val INF = (1e9 + 7).toInt()val MOD = (1e9 + 7).toInt()val INF_F = 1e-6 fun solve(input: InputStream, output: OutputStream) {    val reader = InputReader(BufferedInputStream(input))    val writer = PrintWriter(BufferedOutputStream(output))     solve(reader, writer)    writer.close()} fun solve(reader: InputReader, writer: PrintWriter) {    val n = reader.nextInt()    val m = reader.nextInt()     if (m < n - 1 || m.toLong() > n.toLong() * (n - 1) / 2) {        writer.println(""Impossible"")        return    }     val ans: MutableList<Pair<Int, Int>> = ArrayList()    for (i in 1..n) {        for (j in i + 1..n) {            if (gcd(i, j) == 1) {                ans.add(i to j)                if (ans.size == m) {                    break                }            }        }        if (ans.size == m) {            break        }    }    if (ans.size < m) {        writer.println(""Impossible"")        return    }    writer.println(""Possible"")    ans.forEach { (u, v) -> writer.println(""$u $v"") }} fun gcd(a: Int, b: Int): Int {    return if (b == 0) a else gcd(b, a % b)} class InputReader(stream: InputStream) {    private val reader = BufferedReader(InputStreamReader(stream), 32768)    private var tokenizer: StringTokenizer? = null     operator fun next(): String {        while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {            try {                tokenizer = StringTokenizer(reader.readLine())            } catch (e: IOException) {                throw RuntimeException(e)            }         }        return tokenizer!!.nextToken()    }     fun nextInt(): Int {        return Integer.parseInt(next())    }     fun nextLong(): Long {        return java.lang.Long.parseLong(next())    }     fun nextArrayInt(count: Int): IntArray {        return nextArrayInt(0, count)    }     fun nextArrayInt(start: Int, count: Int): IntArray {        val a = IntArray(start + count)        for (i in start until start + count) {            a[i] = nextInt()        }        return a    }     fun nextArrayLong(count: Int): LongArray {        val a = LongArray(count)        for (i in 0 until count) {            a[i] = nextLong()        }        return a    }}","brute force,constructive algorithms,graphs,greedy,math"
"fun main(){    val (n, k) = readLine()!!.split(' ').map { it.toInt() }    val values = readLine()!!.split(' ').map { it.toInt() }.toIntArray()    val diff = MutableList(n) {0}    val index = values.indexOf(k)    val dict = mutableMapOf<Int, Int>()    dict[0] = 1    for (i in index+1 until n){        diff[i] = if(values[i] > k) diff[i-1] + 1 else diff[i-1] - 1        val new = dict.getOrDefault(diff[i], 0) + 1        dict[diff[i]] = new    }    for (i in index-1 downTo 0){        diff[i] = if(values[i] > k) diff[i+1] + 1 else diff[i+1] - 1    }    var result = 0L    for (i in 0..index){        result += dict.getOrDefault(-diff[i], 0)        result += dict.getOrDefault(1-diff[i], 0)    }    println(result)}",sortings
"import kotlin.math.sign fun main(args:Array<String>){    val (_,m) = readLine()!!.split(' ').map{it.toInt()}    val list = readLine()!!.split(' ').map { it.toInt() }    val s = list.indexOf(m)    val l = list.subList(0,s+1).reversed().map { (it-m).sign }            .prefixSum()    val r = list.subList(s,list.size).map { (it-m).sign }            .prefixSum()     val mapL = mutableMapOf<Int,Int>()    val mapR = mutableMapOf<Int,Int>()    l.forEach { x -> mapL[x] = (mapL[x]?:0) + 1 }    r.forEach { x -> mapR[x] = (mapR[x]?:0) + 1 }    val ans = mapL.map { (k,v) -> ((mapR[-k]?:0) + (mapR[1-k]?:0)).toLong() * v }.sum()    println(ans)} fun List<Int>.prefixSum():List<Int>{    if(this.isEmpty()) return listOf()    val ret = mutableListOf<Int>()    for ((i,x) in this.withIndex())        ret.add(x + if(i==0) 0 else ret[i-1])    return ret}",sortings
"import kotlin.math.sign fun main(args:Array<String>){    val (n,m) = readLine()!!.split(' ').map{it.toInt()}    val list = readLine()!!.split(' ').map { it.toInt() }    val s = list.indexOf(m)    val l = list.subList(0,s+1).reversed().map { (it-m).sign }            .prefixSum()    val r = list.subList(s,list.size).map { (it-m).sign }            .prefixSum()     val mapL = mutableMapOf<Int,Int>()    val mapR = mutableMapOf<Int,Int>()    l.forEach { x -> mapL[x] = (mapL[x]?:0) + 1 }    r.forEach { x -> mapR[x] = (mapR[x]?:0) + 1 }    val ans = mapL.toList().sumByLong { (k,v) -> ((mapR[-k]?:0) + (mapR[1-k]?:0)).toLong() * v }    println(ans)} fun List<Int>.prefixSum():List<Int>{    if(this.isEmpty()) return listOf()    val ret = mutableListOf<Int>()    for ((i,x) in this.withIndex())        ret.add(x + if(i==0) 0 else ret[i-1])    return ret} inline fun <T> Iterable<T>.sumByLong(selector: (T) -> Long): Long {    var sum: Long = 0    for (element in this) {        sum += selector(element)    }    return sum}",sortings
"import java.io.BufferedReaderimport java.io.InputStreamReader fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val (n, m) = jin.readLine().split("" "").map { it.toInt() }    val ay = listOf(0) + jin.readLine().split("" "").map { it.toInt() }    var answer = (n.toLong() * (n + 1).toLong()) / 2L    val bit = BinaryIndexTree(-100000, 200000)    var curr = 0    bit.update(0, 1L)    for (j in 1..n) {        if (ay[j] < m) {            curr++        }        if (j % 2 == 1) {            curr--        }        answer -= bit.query(curr)        if (j % 2 == 0) {            bit.update(curr, 1L)        }    }    bit.value.fill(0L)    curr = 0    for (j in 1..n) {        if (ay[j] < m) {            curr++        }        if (j % 2 == 0) {            curr--        }        answer -= bit.query(curr)        if (j % 2 == 1) {            bit.update(curr, 1L)        }    }    bit.value.fill(0L)    curr = 0    bit.update(0, 1L)    for (j in 1..n) {        if (ay[j] > m) {            curr++        }        if (j % 2 == 0) {            curr--        }        answer -= bit.query(curr - 1)        if (j % 2 == 0) {            bit.update(curr, 1L)        }    }    bit.value.fill(0L)    curr = 0    for (j in 1..n) {        if (ay[j] > m) {            curr++        }        if (j % 2 == 1) {            curr--        }        answer -= bit.query(curr - 1)        if (j % 2 == 1) {            bit.update(curr, 1L)        }    }    println(answer)} class BinaryIndexTree(val treeFrom: Int, treeTo: Int) {    val value = LongArray(treeTo - treeFrom + 2)     fun update(index: Int, delta: Long) {        var i = index + 1 - treeFrom        while (i < value.size) {            value[i] += delta            i += i and -i        }    }     fun query(to: Int): Long {        var res = 0L        var i = to + 1 - treeFrom        while (i > 0) {            res += value[i]            i -= i and -i        }        return res    }     operator fun get(from: Int, to: Int) = if (to < from) 0L else query(to) - query(from - 1)}",sortings
"import kotlin.math.* fun main(args: Array<String>) {    System.`in`.bufferedReader().use {        val n = it.readLine().toInt()        val parts = it.readLine().split(' ')        val a = IntArray(n, { parts[it].toInt() })         val left = IntArray(100005, { Int.MAX_VALUE - 1 })        val right = IntArray(100005, { Int.MIN_VALUE })        for (i in 0 until n) {            val now = a[i]            left[now] = min(left[now], i)            right[now] = max(right[now], i)        }         left.sort()        right.sort()         var ans = 0L        for (item in left) {            var p = right.binarySearch(item + 1)            if (p < 0)                p = -p - 1             ans += right.size - p        }         println(ans)    }}","constructive algorithms,implementation"
import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.io.PrintWriterimport java.util.StringTokenizer fun main() {    val br = BufferedReader(InputStreamReader(System.`in`))    val pw = PrintWriter(System.out)    fun readInt() = br.readLine().toInt()    fun StringTokenizer.readInt() = nextToken().toInt()    fun readInts(numElements: Int): IntArray {        val st = StringTokenizer(br.readLine())        return IntArray(numElements) { st.readInt() }    }     val numElements = readInt()    val elements = readInts(numElements)    val different = IntArray(numElements)    val visited = mutableSetOf<Int>()    for (pos in different.lastIndex downTo 0) {        visited.add(elements[pos])        different[pos] = visited.size    }    visited.clear()    var sol = 0L    for (pos in 0 until elements.lastIndex) {        if (elements[pos] !in visited) {            visited.add(elements[pos])            sol += different[pos + 1]        }    }    pw.print(sol)    pw.close()},"constructive algorithms,implementation"
"import java.io.BufferedReaderimport java.io.IOExceptionimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.collections.HashSetimport kotlin.math.absimport kotlin.math.maximport kotlin.math.minfun main(args : Array<String>) {    Thread { run() }.start()} fun run() {     val scanner = Scanner(System.`in`)    val n = scanner.nextInt()    val arr = IntArray(n) { scanner.nextInt() }    val set = HashSet<Int>()    val Q1 = IntArray(n)    for (i in n - 2 downTo 0) {        Q1[i] = Q1[i + 1];        if (!set.contains(arr[i + 1])) {            Q1[i]++            set.add(arr[i + 1])        }    }    var res = 0L    set.clear()    for (i in 0 until n) {        if (!set.contains(arr[i])) {            res += Q1[i];            set.add(arr[i]);        }    }    println(res) } class Scanner(s: InputStream) {    var st: StringTokenizer? = null    var br: BufferedReader = BufferedReader(InputStreamReader(s))    @Throws(IOException::class)    operator fun next(): String {        while (st == null || !st!!.hasMoreTokens())            st = StringTokenizer(br.readLine())        return st!!.nextToken()    }    @Throws(IOException::class)    fun nextInt(): Int {        return Integer.parseInt(next())    }    @Throws(IOException::class)    fun nextLong(): Long {        return java.lang.Long.parseLong(next())    }    @Throws(IOException::class)    fun nextLine(): String {        return br.readLine()    }    @Throws(IOException::class)    fun nextDouble(): Double {        return java.lang.Double.parseDouble(next())    }    @Throws(IOException::class)    fun ready(): Boolean {        return br.ready()    }}fun IntArray.print() {    println(Arrays.toString(this))}fun Array<IntArray>.print() {    for (i in this)        i.print()}fun LongArray.print() {    println(Arrays.toString(this))}fun Array<LongArray>.print() {    for (i in this)        i.print()}fun BooleanArray.print() {    println(Arrays.toString(this))}fun nod(a: Long, b: Long): Long {    var a1 = a    var b1 = b    while (a1 != 0L && b1 != 0L) {        if (a1 < b1)            b1 %= a1        else            a1 %= b1    }    return a1 + b1}fun nok(a: Long, b: Long): Long = a * b / nod(a, b)fun min(a: Char, b: Char): Int {    if (a < b)        return a.toInt()    return b.toInt()}fun max(a: Char, b: Char): Int {    if (a > b)        return a.toInt()    return b.toInt()}","constructive algorithms,implementation"
"private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() } var adj = MutableList(5005, {mutableListOf<Int>()})var radj = MutableList(5005, {mutableListOf<Int>()}) var visited = MutableList(5005, {false})var bagian = MutableList(5005, {-1})var inDegree = MutableList(5005, {0}) var order = mutableListOf<Int>() fun topo(id: Int, u: Int) {	bagian[u] = id 	var neighbor = if (id == 0) adj[u] else radj[u] 	for (v in neighbor) {		if (id == 0) {			if (bagian[v] == 0) continue;			topo(id, v)		} else {			if (bagian[v] != 0) continue;			topo(id, v)		}	} 	if (id == 0) {		order.add(u)	}} fun jangkau(u: Int) {	visited[u] = true	inDegree[bagian[u]]++ 	for (v in adj[u]) {		if (visited[v]) continue		jangkau(v)	}} fun main() {	var (n, m, root) = readInts() 	for (i in 1..m) {		var (u, v) = readInts() 		adj[u].add(v)		radj[v].add(u)	} 	for (i in 1..n) {		if (bagian[i] == -1) {			topo(0, i)		}	} 	var cnt = 0;	for (i in order.reversed()) {		if (bagian[i] == 0) {			topo(++cnt, i)		}	} 	for (u in 1..n) {		for (v in adj[u]) {			if (bagian[u] == bagian[v]) continue			inDegree[bagian[v]]++		}	} 	jangkau(root) 	var ans = 0	for (i in 1..cnt) {		ans += if (inDegree[i] == 0) 1 else 0	} 	println(ans)}			  			  	   			 	      	 			","dfs and similar,graphs,greedy"
"import java.io.BufferedReaderimport java.io.IOExceptionimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.collections.ArrayListimport kotlin.math.ceilimport kotlin.math.floorimport kotlin.math.log2import kotlin.math.sqrt val scanner = Scanner(System.`in`)val n = scanner.nextInt()val m = scanner.nextInt()val s = scanner.nextInt() - 1val was = BooleanArray(n)val w = Array<Pair<Int, Int>>(n) { Pair(0, 0) }val ch = Array<ArrayList<Int>>(n) { ArrayList() } fun main(args: Array<String>) {     for (i in 0 until m)        ch[scanner.nextInt() - 1].add(scanner.nextInt() - 1)    for (i in 0 until n) {        w[i] = Pair(dfs1(i), i)        Arrays.fill(was, false)    }    w.sortBy { -it.first }    var res = 0    dfs2(s)    for (i in 0 until n) {        if (was[w[i].second])            continue        res++        dfs2(w[i].second)    }    println(res) } fun dfs2(v: Int) {    if (was[v])        return    was[v] = true    for (i in ch[v])        dfs2(i)} fun dfs1(v: Int): Int {    if (was[v])        return 0    was[v] = true;    var res = 1    for (i in ch[v])        res += dfs1(i)    return res}   class Scanner(s: InputStream) {    var st: StringTokenizer? = null    var br: BufferedReader = BufferedReader(InputStreamReader(s))    @Throws(IOException::class)    operator fun next(): String {        while (st == null || !st!!.hasMoreTokens())            st = StringTokenizer(br.readLine())        return st!!.nextToken()    }    @Throws(IOException::class)    fun nextInt(): Int {        return Integer.parseInt(next())    }    @Throws(IOException::class)    fun nextLong(): Long {        return java.lang.Long.parseLong(next())    }    @Throws(IOException::class)    fun nextLine(): String {        return br.readLine()    }    @Throws(IOException::class)    fun nextDouble(): Double {        return java.lang.Double.parseDouble(next())    }    @Throws(IOException::class)    fun ready(): Boolean {        return br.ready()    }}//class Pair(var a: Int, var b: Int): Comparable<Pair> {//    override fun compareTo(other: Pair): Int {//        return b - a - other.b + other.a//    }//}","dfs and similar,graphs,greedy"
"fun main(args: Array<String>) {    val n = readLine()!!.toInt()    val a = readLine()!!.split("" "").map { it.toInt() }.toIntArray()    var sum = 0    for (i in 0 until a.size step 2) {        val c = a[i]        var j = i + 1        while (a[j] != c) j++        val len = j - i - 1        sum += len        System.arraycopy(a, i + 1, a, i + 2, len)    }    println(sum)}","greedy,implementation,math"
fun main(args: Array<String>) {    val n = readLine()!!.toInt()     val people = readLine()!!.split(' ').map { it.toInt() }.toMutableList()     var ans = 0    var l = 0     while (l in people.indices) {        val nowPeason = people[l]        val r = people.lastIndexOf(nowPeason)         for (i in r downTo l + 2) {            people[i - 1] = people[i].also { people[i] = people[i - 1] }            ++ans        }         l += 2    }     println(ans)},"greedy,implementation,math"
"fun main(args: Array<String>) {  val n = readLine()!!.toInt()  val xs = readLine()!!.split("" "").map { it.toInt() }.toIntArray()  var count = 0  for (i in 0 until n) {    if (xs[2 * i] == xs[2 * i + 1]) {      // Do nothing    } else {      val x = xs[2 * i]      val i2 = xs.lastIndexOf(x)      for (k in i2 downTo 2 * i + 2) {        val v1 = xs[k]        val v2 = xs[k - 1]        xs[k] = v2        xs[k - 1] = v1        count++      }      // println(xs.asList())    }  }  println(count)}","greedy,implementation,math"
" fun main(args: Array<String>) {    val numPairs = readLine()!!.toInt()    val numbers = readLine()!!.split("" "").map { it.toInt() }.toMutableList()    var changes = 0    val size = numPairs * 2    var i = 0    var j: Int    while (i < size) {        j = i + 1        if (numbers[i] != numbers[j]) {            // finding pair for i            while (numbers[i] != numbers[j]) {                j++            }            // changes before pair will be together            while (j > i + 1) {                // goes back with founded pair                val tmp = numbers[j]                numbers[j] = numbers[j-1]                numbers[j-1] =  tmp                j--                changes++            }        }        // next pair        i += 2    }    println(changes)}","greedy,implementation,math"
"fun main(args : Array<String>) {    var (n, k) = readLine()!!.split("" "")!!.map { it.toInt() }    val set = mutableSetOf<String>()    val solution = arrayListOf<Int>()    for((index, v) in readLine()!!.split("" "").withIndex()) {        if(v !in set) set.add(v).also { solution.add(index + 1) }        if(solution.size >= k) break    }    if(solution.size < k) println(""NO"") else println(""YES\n${solution.joinToString("" "")}"")}","brute force,implementation"
"import java.util.* fun main(args: Array<String>) {    val reader = Scanner(System.`in`)    val numberOfStudents = reader.nextInt()    val kStudents = reader.nextInt()     val complexity = mutableMapOf<Int, Int>()    for (i in 0 until numberOfStudents) {        complexity[reader.nextInt()] = i+1    }    if (complexity.size < kStudents) {        println(""NO"")        return    }    println(""YES"")    complexity.values.take(kStudents).toList().forEach {        println(it)    }}","brute force,implementation"
"import java.util.*import kotlin.collections.ArrayList fun main(args: Array<String>) = with(Scanner(System.`in`)) {    val n = nextInt()    val k = nextInt()     val t = ArrayList<Int>()    val i = ArrayList<Int>()     for (c in 1..n) {        val x = nextInt()        if (!t.contains(x)) {            t += x            i += c        }        if (t.size == k) break    }     if (t.size == k) {        println(""YES"")        println(i.joinToString("" ""))    } else {        println(""NO"")    }}","brute force,implementation"
"fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val (_, k) = readInts()    val students = readInts()    val selected = mutableSetOf<Int>()    val positions = IntArray(k)    for ((pos, student) in students.withIndex()) {        if (student !in selected) {            positions[selected.size] = pos + 1            selected.add(student)        }        if (selected.size == k) {            println(""YES"")            print(positions.joinToString("" ""))            return        }    }    print(""NO"")}","brute force,implementation"
"import java.util.* private val scan = Scanner(System.`in`) private var ans = 0 fun main(args: Array<String>) {    val n = scan.nextInt()    val a = Array(n) { mutableListOf<Int>() }    (1 until n).map {        val x = scan.nextInt() - 1        val y = scan.nextInt() - 1        a[x].add(y)        a[y].add(x)    }     if (n % 2 == 1) {        println(-1)        return    }     dfs(a, 0, -1)     println(ans - 1)} fun dfs(a: Array<out List<Int>>, node: Int, visited: Int): Int {    val sum = a[node]            .filter { it != visited }            .map { dfs(a, it, node) }            .sum() + 1    if (sum % 2 == 0) {        ans++    }     return sum}","dfs and similar,dp,graphs,greedy,trees"
"import java.util.* private val scan = Scanner(System.`in`) private var ans = 0 fun main(args: Array<String>) {    val n = scan.nextInt()     if (n % 2 == 1) {        println(-1)        return    }     val a = Array(n) { mutableListOf<Int>() }    (1 until n).map {        val x = scan.nextInt() - 1        val y = scan.nextInt() - 1        a[x].add(y)        a[y].add(x)    }     dfs(a, 0, -1)     println(ans - 1)} fun dfs(a: Array<out List<Int>>, node: Int, visited: Int): Int {    val sum = a[node]            .filter { it != visited }            .map { dfs(a, it, node) }            .sum() + 1    if (sum % 2 == 0) {        ans++    }     return sum}","dfs and similar,dp,graphs,greedy,trees"
"val graph = Array(100_001 , { i -> mutableListOf<Int>() })val bool = Array(100_001 , { i -> true })var count = 0 fun main() {     var current = 0    val n = readLine()!!.toInt()    for(i in 1..(n - 1)){        val (x , y) = readLine()!!.split("" "").map { it.toInt() }         graph[x].add(y)        graph[y].add(x)        current = x    }      val c = rec(current)     if(c != 0)        println(-1)    else        println(count - 1) } fun rec(current: Int): Int{    bool[current] = false    var response = 1     graph[current].forEach {        if(bool[it])        response += rec(it)    }     if(response % 2 == 0){        count ++        response = 0    }     return response}","dfs and similar,dp,graphs,greedy,trees"
"import java.util.* private val scan = Scanner(System.`in`) private var ans = 0 fun main(args: Array<String>) {    val n = scan.nextInt()    val a = Array(n) { mutableListOf<Int>() }    (1 until n).map {        val x = scan.nextInt() - 1        val y = scan.nextInt() - 1        a[x].add(y)        a[y].add(x)    }     if (n % 2 == 1) {        println(-1)        return    }     for (i in 0 until n) {        if (a[i].size == 1) {            dfs(a, 0, -1)            break        }    }     println(ans - 1)} fun dfs(a: Array<out List<Int>>, node: Int, visited: Int): Int {    val sum = a[node]            .filter { it != visited }            .map { dfs(a, it, node) }            .sum() + 1    if (sum % 2 == 0) {        ans++    }     return sum}","dfs and similar,dp,graphs,greedy,trees"
"fun main() {    val necklace = readLine()!!    val numPearls = necklace.count { it == 'o' }    if (numPearls == 0) return print(""YES"")    print(if ((necklace.length - numPearls) % numPearls == 0) ""YES"" else ""NO"")}","implementation,math"
"fun main(args: Array<String>) {    val (links, pearls) = readLine()!!.partition { it == '-' }    if (pearls.isEmpty()) {        println(""YES"")    } else {        println(if (links.length % pearls.length == 0) ""YES"" else ""NO"")    }}","implementation,math"
"fun main(args: Array<String>) {    val a = readLine()!!    val b = a.count{it=='o'}    val n = a.count{it=='-'}    // --o--o--o    if(n == 0 || b == 0) {        print(""YES"")    } else print(            if(n % b == 0) ""YES"" else ""NO""    )}      ","implementation,math"
"fun main() {    val r = System.`in`.bufferedReader()    val sb = StringBuilder()    val s = r.readLine()    var a = 0    var b = 0    s.forEach {        when(it){            '-' ->a++            'o' ->b++        }    }    sb.appendln(if (b==0||a%b==0) ""YES"" else ""NO"")    print(sb)}","implementation,math"
"import java.io.StreamTokenizerimport kotlin.math.sign fun main(args: Array<String>) {    val tokenizer = StreamTokenizer(System.`in`.reader())    tokenizer.ordinaryChars('0'.toInt(), '9'.toInt())    tokenizer.wordChars('0'.toInt(), '9'.toInt())     val n = tokenizer.nextLong().toInt()    val q = tokenizer.nextLong().toInt()     val a = (0 until n).map { tokenizer.nextLong() }    var sum = 0L    val na = (0 until n).map {        sum += a[it]        sum    }    val k = (0 until q).map { tokenizer.nextLong() }     var now = 0L    (0 until q).forEach {        now = if (now >= sum) k[it] else now + k[it]        var v = na.binarySearch { (it - now).sign }        v = if (v < 0) n + v + 1 else n - v - 1        println(if (v == 0) n else v)    }} fun StreamTokenizer.nextLong(): Long {    return if (nextToken() != StreamTokenizer.TT_EOF) sval.toLong() else -1}",binary search
"import java.io.StreamTokenizerimport kotlin.math.sign fun main(args: Array<String>) {    val tokenizer = StreamTokenizer(System.`in`.reader().buffered())    tokenizer.ordinaryChars('0'.toInt(), '9'.toInt())    tokenizer.wordChars('0'.toInt(), '9'.toInt())     val n = tokenizer.nextLong().toInt()    val q = tokenizer.nextLong().toInt()     val a = (0 until n).map { tokenizer.nextLong() }    var sum = 0L    val na = (0 until n).map {        sum += a[it]        sum    }    val k = (0 until q).map { tokenizer.nextLong() }     var now = 0L    (0 until q).forEach {        now = if (now >= sum) k[it] else now + k[it]        var v = na.binarySearch { (it - now).sign }        v = if (v < 0) n + v + 1 else n - v - 1        println(if (v == 0) n else v)    }} fun StreamTokenizer.nextLong(): Long {    return if (nextToken() != StreamTokenizer.TT_EOF) sval.toLong() else -1}",binary search
"fun main(args: Array<String>) {    val n = readLine()!!        (Math.sqrt(n.toDouble()).toInt() downTo 1).forEach{         val regex = Regex((it*it).toString().map { ""$it.*"" }.joinToString (separator = """"))          if (  n.contains(regex)){            println(n.length - (it*it).toString().length)            return         }    }     println(-1) }","brute force,implementation,math"
"import kotlin.math.* fun procrust(inp: String): List<String>{		val retList = mutableListOf<String>()		for (j in 0..inp.length-1){			val tmpS = inp.substring(0..j-1) + inp.substring(j+1)			if (tmpS[0] != '0') retList.add(tmpS)		}		return retList	} fun main(args: Array<String>){	fun checkQ(inp: String): Int{		var reslt: Int		val cand = sqrt(inp.toDouble()).roundToInt()		if (inp.toInt() == cand*cand){			reslt = inp.length		//	println(""Found $reslt for $inp and $cand"")		}else{			if (inp.length > 1) {				reslt = procrust(inp).map{checkQ(it)}.max()!!.toInt()				//println(reslt)			}else{				reslt = -1			}		}		//println(reslt)		return reslt	} 	var inp = readLine().toString()	val initL = inp.length	val checked = checkQ(inp)	if (checked == -1) println(-1) else println(initL-checked)}","brute force,implementation,math"
"import java.util.ArrayListimport java.util.Scanner  val squares = ArrayList<String>() fun main(args: Array<String>) {    val reader = Scanner(System.`in`)    val n = reader.nextInt()     val max: Int = Math.sqrt(n.toDouble()).toInt()    for (i in 1..max) {        squares.add((i*i).toString())    }     println(containsSubstring(n.toString()))} fun containsSubstring(n: String): String {     for (square in squares.reversed()) {        var indexOf = 0         var winner = true        for (char in square.toCharArray()) {            indexOf = n.indexOf(char, indexOf, true) + 1            if (indexOf == 0){                winner = false                break            }        }        if (winner) {            return (n.length - square.length).toString()        }    }     return ""-1""}","brute force,implementation,math"
"import java.util.* fun main() {     var a : String? = readLine();     var ans: Int=0;     var  state: Boolean=false;    for ( i  in 1..1.shl(a?.length!!)) {         var temp: StringBuilder = StringBuilder()         for (j in a.indices)        {            if ((i.and((1.shl(j)))) > 0) temp.append(a[j])        }             if (temp.length > 0) {                for ( j in a.indices) {                    if (temp.length<=0)break                    if (temp[0] == '0') {                        temp.deleteCharAt(0)                    } else break;                }                if (temp.length > 0) {                    var s :Int= Integer.parseInt (temp.toString());                    var sqr:Int = Math.sqrt (1.0*s).toInt()                    if ((sqr * sqr).equals(s)) {                        ans = Math.max(ans, temp.length)                        state = true;                    }                }             }        }    println(if (state)a.length-ans else -1)    }   ","brute force,implementation,math"
"import java.io.PrintWriterimport java.util.*import kotlin.collections.ArrayListimport kotlin.collections.HashMapimport kotlin.math.ceilimport kotlin.math.sqrt const val CONST: Long = 1000000000 + 7lateinit var dp: Array<Array<Long>>lateinit var graph: Array<Array<Int>>lateinit var visited: Array<Boolean>fun main() {    var s = readLn().toCharArray()    var arr = ArrayList<ArrayList<Int>>()    var zeros = ArrayList<Int>()    var ones = ArrayList<Int>()    var k=0    for ((ind, i) in s.withIndex()) {        if (i == '1') {            if (zeros.size > 0) {                arr[zeros.last()].add(ind)                ones.add(zeros.removeLast())            } else {                k=-1                break            }        } else {            if (ones.size > 0) {                arr[ones.last()].add(ind)                zeros.add(ones.removeLast())            }            else{                arr.add(ArrayList())                arr.last().add(ind)                zeros.add(arr.size-1)            }        }    }    if(k==-1 || ones.size>0){        println(-1)    }    else{        println(arr.size)        for (i in arr.indices){            for (j in arr[i].indices){                arr[i][j]++            }        }        output {            for (i in arr){                this.println(""${i.size} ${i.joinToString("" "")} "")            }        }     }} fun nextt(zeros: ArrayList<Int>, z: Int, to: Int): Int {    for (i in z until zeros.size) {        if (zeros[i] > to) {            return i        }    }    return -1} fun hasLoop(i: Int): Int {     if (visited[i - 1]) {        return 1    }    visited[i - 1] = true    if (graph[i - 1][1] == -1) {        return 0    }    return 1 + hasLoop(graph[i - 1][1])} fun digits(n: Long): ArrayList<Int> {    val arr = ArrayList<Int>()    var a = n    while (a > 0) {        arr.add((a % 10).toInt())        a /= 10    }    return arr}  fun maxSubarray(arr: ArrayList<Long>, k: Int): Long? {    var sum: Long = 0    for (i in 0 until k) {        sum += arr[i]    }    val sumarr = ArrayList<Long>()    sumarr.add(sum)    for (i in 1 until arr.size - k + 1) {        sumarr.add(sumarr.last() - arr[i - 1] + arr[i + k - 1])    }    return sumarr.maxOrNull()} fun not(a: Int): Int {    if (a == 1) {        return 0    }    return 1} fun rotate(s: String, n: Int): String {    return s.substring(n) + s.substring(0, n)} fun nC3(n: Long): Long {    val long = n * (n - 1) * (n - 2)    return long / 6} fun gcd(a: Long, b: Long): Long {    if (b.toInt() == 0)        return a;    return gcd(b, a % b);} fun arrayGcd(arr: ArrayList<Long>): Long {    var result: Long = 0    for (element in arr) {        result = gcd(result, element)        if (result.toInt() == 1) {            return 1        }    }     return result} fun indices(arr: ArrayList<Long>): Map<Long, ArrayList<Long>> {    var map = HashMap<Long, ArrayList<Long>>()    for (i in arr.indices) {        if (arr[i] in map) {            map[arr[i]]?.add(i.toLong())        } else {            map[arr[i]] = ArrayList<Long>()            map[arr[i]]?.add(i.toLong())        }    }    return map} fun countArr(arr: ArrayList<Long>): Map<Long, Long> {    var map = HashMap<Long, Long>()    for (i in arr.indices) {        if (arr[i] in map) {            map[arr[i]] = map[arr[i]] as Long + 1        } else {            map[arr[i]] = 1        }    }    return map} fun factor(a: Long): ArrayList<Long> {    val arr = ArrayList<Long>()    arr.add(1)    arr.add(a)    val b = ceil(sqrt(a.toDouble())).toLong()    for (i in 2..b.toInt()) {        if ((a % i).toInt() == 0) {            arr.add(i.toLong())            arr.add(a / i)        }    }    return arr} @JvmFieldval INPUT = System.`in` @JvmFieldval OUTPUT = System.out @JvmFieldval _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!! @JvmFieldvar _tokenizer: StringTokenizer = StringTokenizer("""") @JvmField val _writer = PrintWriter(OUTPUT, false)inline fun output(block: PrintWriter.() -> Unit) { _writer.apply(block).flush() }fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()} private fun readInt() = readLn().toInt() // single intprivate fun readLong() = readLn().toLong()  // single longprivate fun readDouble() = readLn().toDouble() // single doubleprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } as ArrayList<Int>// list of intsprivate fun readLongs() = readStrings().map { it.toLong() } as ArrayList<Long>// list of longsprivate fun readDoubles() = readStrings().map { it.toDouble() } as ArrayList<Double> // list of doublesclass Node(var data: Int) {    var parent: Node? = null    var child: Node? = null    var visied: Boolean = false}",greedy
"import kotlin.math.absoluteValue fun main() {    readLine()    print(readLine()!!.split("" "").map { it.toInt().absoluteValue }.sum())}",greedy
import kotlin.math.abs fun main(args: Array<String>) {    val z = java.util.Scanner(System.`in`)    val n = z.nextInt()    var sum = 0    var a = 0    for (i in 1..n)        sum+=abs(z.nextInt())    println(sum)},greedy
fun main(args: Array<String>){    val n = readLine()!!.toInt()    val inp = readLine()!!.split(' ').map(String::toInt)    val sneg = inp.filter({i -> i < 0}).sum()    val spos = inp.filter({i -> i > 0}).sum()    println(spos - sneg)},greedy
"fun main() {    val r = System.`in`.bufferedReader()    val s1 = StringBuilder()    val n = r.readLine()!!.toInt()    //val (m, n) = r.readLine()!!.split("" "").map { it.toInt() }    val v = r.readLine()!!.split("" "").map { it.toInt() }.map { if (it<0) -it else it }.sum()    println(v) }",greedy
"import java.io.PrintWriterimport java.lang.StringBuilderimport java.util.StringTokenizer fun main() {     fun PrintWriter.solve() {        val n = nextInt()        val k = nextInt()        val s = next()         val set = sortedSetOf<Char>()        set.addAll(s.toMutableList())         val res: StringBuilder        if ( k > n){            res = StringBuilder(s)            res.append(set.first().toString().repeat(k-n))        }        else{            res = StringBuilder(s.substring(0,k))            for (i in res.indices.reversed()){                if (res[i] != set.last()){                    res[i] = set.higher(res[i])!!                    break                }                res[i] = set.first()            }        }         println(res)      }     writer.solve()    writer.flush()  }  private val reader = System.`in`.bufferedReader()private val writer = PrintWriter(System.out, false) private var tokenizer: StringTokenizer = StringTokenizer("""") private fun next(): String {    while (tokenizer.hasMoreTokens().not()) tokenizer = StringTokenizer(reader.readLine())    return tokenizer.nextToken()} private fun nextInt() = next().toInt()private fun nextLong() = next().toLong()private fun nextDouble() = next().toDouble()private fun nextLine() = reader.readLine() ","constructive algorithms,implementation,strings"
"import java.util.* /** * Точки на прямой */fun taskA() {    val s = Scanner(System.`in`)    val n = s.nextInt()    val desiredDiameter = s.nextInt()    val numbers = Array(n, { _ -> 0 })     for (i in 0..n - 1) {        numbers[i] = s.nextInt()    }     numbers.sort()     var from = 0    var to = 0    var optimalRemoved = Int.MAX_VALUE    while (to <= numbers.lastIndex) {        val d = numbers[to] - numbers[from]         if (d <= desiredDiameter) {            optimalRemoved = minOf(from + (numbers.size - to - 1), optimalRemoved)        }         if (d <= desiredDiameter) {            to++        } else {            from++        }    }     println(optimalRemoved)} /** * Наша Таня громко плачет */fun taskB() {    val s = Scanner(System.`in`)    val n = s.nextLong()    val k = s.nextLong()    val subPrice = s.nextLong()    val divPrice = s.nextLong()     var curN = n    var totalPrice = 0L    while (curN != 1L) {        val r = curN % k        when {            k == 1L -> {                totalPrice = (curN - 1L) * subPrice                curN = 1L            }            r == 0L -> {                val subTotal = subPrice * (curN / k) * (k - 1)                if (subTotal < divPrice) {                    totalPrice += subTotal                } else {                    totalPrice += divPrice                }                curN /= k            }            else -> {                totalPrice += subPrice * r                curN -= r                 // ugly check if curN under k so we could get zero                if (curN == 0L) {                    curN = 1                    totalPrice -= subPrice                }            }        }    }    println(totalPrice)} /** * Телефонные номера */fun taskC() {    val s = Scanner(System.`in`)    s.nextInt()    val desiredLen = s.nextInt()    val str = s.next()!!     val chars = str.toSortedSet()     val result =            if (desiredLen > str.length) {                str + chars.first().toString().repeat(desiredLen - str.length)            } else {                val arr = str.substring(0..desiredLen - 1).toCharArray()                 for (i in arr.lastIndex downTo 0) {                    if (chars.last() != arr[i]) {                        arr[i] = chars.elementAt(chars.indexOf(arr[i]) + 1)                        break                    } else {                        arr[i] = chars.first()                    }                }                 arr.joinToString(separator = """")            }     println(result)} fun main(args: Array<String>) {    taskC()}","constructive algorithms,implementation,strings"
"import java.util.* fun main(args: Array<String>) {    val s = Scanner(System.`in`)    val n = s.nextInt()    val desiredDiameter = s.nextInt()    val numbers = Array(n, { _ -> 0 })     for (i in 0..n-1) {        numbers[i] = s.nextInt()    }     numbers.sort()     var from = 0    var to = 0    var optimalRemoved = Int.MAX_VALUE    while (to <= numbers.lastIndex) {        val d = numbers[to] - numbers[from]         if (d <= desiredDiameter) {            optimalRemoved = minOf(from + (numbers.size - to - 1), optimalRemoved)        }         if (d <= desiredDiameter) {            to++        } else {            from++        }    }     println(optimalRemoved)}","brute force,greedy,sortings"
"fun main(args:Array<String>) {  val (m,n) = readLine()!!.split("" "").map(String::toInt)   val target = readLine()!!.split("" "").map(String::toInt).sorted()   val ansbox = mutableListOf<Pair<Int,Int>>()    for( start in (0..target.size-1) ) {    for( end in (start..target.size-1) ) {      val delta = target[end] - target[start]      if( n >= delta ) {        val ans = target.size - (end-start + 1)        ansbox.add(Pair(delta, ans))      }    }  }  //println(ansbox)  if(ansbox.minBy{ it.second } == null)    if( m <= n )       println(0)    else if( n >= 1 )       println(target.size - 1)    else      println(0)  else    println(ansbox.minBy{ it.second }!!.second)}","brute force,greedy,sortings"
"fun main(args: Array<String>){	val string1: String = readLine().toString()	var mnozh: List<Int> = readLine().toString().split("" "").map{x -> x.toInt()}	val N = string1.split("" "")[0].toInt()	val expD = string1.split("" "")[1].toInt()	mnozh = mnozh.sorted()	val D = mnozh.last() - mnozh.first()	if (D <= expD){		println(0)	}else{		//println(""Expected: $expD, real: $D"")		var realD: Int		var minDropped = 101		var dropped: Int		for (i in 0..N-1){			for (j in i..N-1){				realD = mnozh[j]-mnozh[i]				dropped = N - (j - i + 1)				if((realD <= expD) and (dropped <= minDropped)){					minDropped = dropped					//println(""i: $i, j: $j, Distance: $realD, dropped: $dropped"")				}			}		}		println(minDropped)			}}","brute force,greedy,sortings"
"fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     fun List<Int>.bsRight(value: Int): Int {        var left = 0        var right = this.lastIndex        var pivot: Int        while (left <= right) {            pivot = (left + right) / 2            if (this[pivot] > value) right = pivot - 1 else left = pivot + 1        }        return left - 1    }     val (numPoints, diameter) = readInts()    val arr = readInts().sorted()    val stop = arr.last() - diameter    if (stop <= arr[0]) {        print(0)        return    }    var result = Integer.MAX_VALUE    var left = -1    var right: Int    while (++left < numPoints && arr[left] <= stop) {        right = arr.bsRight(arr[left] + diameter)        val candidate = numPoints - right + left - 1        if (candidate < result) result = candidate    }    if(left < numPoints) {        right = arr.bsRight(arr[left] + diameter)        val candidate = numPoints - right + left - 1        if (candidate < result) result = candidate    }    print(result)}","brute force,greedy,sortings"
fun main(args:Array<String>){    val n= readLine()!!.toInt()    println((2..n).filter{n%it==0}.size)},"brute force,implementation"
fun main() {    val e = readLine()!!.toInt()    print((1..e/2).asSequence().filter { e % it == 0}.count())},"brute force,implementation"
fun main() {    val n = readLine()!!.toInt()    print(    (1 .. n).filter{        (n%it==0&&n!=it)    }.size    ) },"brute force,implementation"
fun main(args: Array<String>) {	val n = readLine()!!.toInt()	var temp = 0	for(i in 1..n-1){	if((n - i) % i == 0) temp++	}	println(temp)},"brute force,implementation"
"import kotlin.math.max fun main(args:Array<String>){    readLine()     val ans=IntArray(4){0}    readLine()!!.split(' ').map { it.toInt()-1 }.forEach {        //0->0+  1->0*1+    2->0*1*0+   3->0*1*0*1+        if (it==0){            ++ans[0]            ans[2] = max(ans[2],ans[1])+1        } else {            ans[1] = max(ans[1],ans[0])+1            ans[3] = max(ans[3],ans[2])+1        }    }    println(ans.max()!!)}",dp
"import java.io.PrintWriterimport java.util.*import kotlin.collections.HashSet lateinit var sieve: Array<Int> var CONST: Long = 1000000000 + 7lateinit var dpp: Array<Array<Array<Boolean?>>>var CONST1: Long = 998244353lateinit var realdp: Array<BooleanArray> fun main() {    var n = readInt()    var arr = readInts()    var longest1s = 0    var longest12s = 0    var longest121s = 0    var longest1212s=0    for (i in 0 until arr.size){        if(arr[i]==1){            longest1s=longest1s+1            longest12s=longest12s            longest121s=maxOf(longest121s,longest12s)+1            longest1212s=longest1212s        }        else{            longest1s=longest1s            longest12s=maxOf(longest12s,longest1s)+1            longest121s=longest121s            longest1212s=maxOf(longest1212s,longest121s)+1        }    }    println(maxOf(longest1212s,longest121s,longest12s,longest12s)) } fun calculateAns(arr: MutableList<Int>): Int {    var ans = 1    var fans = 1    for (i in 1 until arr.size) {        if (arr[i] >= arr[i - 1]) {            ans++        } else {            ans = 1        }        fans = maxOf(fans, ans)    }    return fans} fun MutableList<Int>.reverse(l: Int, r: Int) {    for (i in l..(l + r) / 2) {        var t = this[i]        this[i] = this[r - i]        this[r - i] = t    }} fun check(x: Int, arr: ArrayList<Int>, brr: ArrayList<Int>): Boolean {    var crr = HashSet<Int>()    for (i in arr) {        crr.add(x + i)    }    for (i in brr) {        if (!crr.contains(i)) {            return false        }    }    return true} @JvmFieldval INPUT = System.`in` @JvmFieldval OUTPUT = System.out @JvmFieldval _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!! @JvmFieldvar _tokenizer: StringTokenizer = StringTokenizer("""") @JvmFieldval _writer = PrintWriter(OUTPUT, false)inline fun output(block: PrintWriter.() -> Unit) {    _writer.apply(block).flush()} fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()} private fun readInt() = readLn().toInt() // single intprivate fun readLong() = readLn().toLong()  // single longprivate fun readDouble() = readLn().toDouble() // single doubleprivate fun readStrings() = readLn().trim().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } as ArrayList<Int>// list of intsprivate fun readLongs() = readStrings().map { it.toLong() } as ArrayList<Long>// list of longsprivate fun readDoubles() = readStrings().map { it.toDouble() } as ArrayList<Double> // list of doubles",dp
"import java.io.PrintWriterimport java.util.*import kotlin.collections.HashSet lateinit var sieve: Array<Int> var CONST: Long = 1000000000 + 7lateinit var dpp: Array<Array<Array<Boolean?>>>var CONST1: Long = 998244353lateinit var realdp: Array<BooleanArray> fun main() {    var n = readInt()    var arr = readInts()    var longest1s = IntArray(n + 1)    var longest12s = IntArray(n + 1)    var longest121s = IntArray(n + 1) { 0 }    var longest1212s=IntArray(n+1){0}    for (i in 0 until arr.size){        if(arr[i]==1){            longest1s[i+1]=longest1s[i]+1            longest12s[i+1]=longest12s[i]            longest121s[i+1]=maxOf(longest121s[i],longest12s[i])+1            longest1212s[i+1]=longest1212s[i]        }        else{            longest1s[i+1]=longest1s[i]            longest12s[i+1]=maxOf(longest12s[i],longest1s[i])+1            longest121s[i+1]=longest121s[i]            longest1212s[i+1]=maxOf(longest1212s[i],longest121s[i])+1        }    }    println(maxOf(longest1212s.last(),longest121s.last(),longest12s.last(),longest12s.last())) } fun calculateAns(arr: MutableList<Int>): Int {    var ans = 1    var fans = 1    for (i in 1 until arr.size) {        if (arr[i] >= arr[i - 1]) {            ans++        } else {            ans = 1        }        fans = maxOf(fans, ans)    }    return fans} fun MutableList<Int>.reverse(l: Int, r: Int) {    for (i in l..(l + r) / 2) {        var t = this[i]        this[i] = this[r - i]        this[r - i] = t    }} fun check(x: Int, arr: ArrayList<Int>, brr: ArrayList<Int>): Boolean {    var crr = HashSet<Int>()    for (i in arr) {        crr.add(x + i)    }    for (i in brr) {        if (!crr.contains(i)) {            return false        }    }    return true} @JvmFieldval INPUT = System.`in` @JvmFieldval OUTPUT = System.out @JvmFieldval _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!! @JvmFieldvar _tokenizer: StringTokenizer = StringTokenizer("""") @JvmFieldval _writer = PrintWriter(OUTPUT, false)inline fun output(block: PrintWriter.() -> Unit) {    _writer.apply(block).flush()} fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()} private fun readInt() = readLn().toInt() // single intprivate fun readLong() = readLn().toLong()  // single longprivate fun readDouble() = readLn().toDouble() // single doubleprivate fun readStrings() = readLn().trim().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } as ArrayList<Int>// list of intsprivate fun readLongs() = readStrings().map { it.toLong() } as ArrayList<Long>// list of longsprivate fun readDoubles() = readStrings().map { it.toDouble() } as ArrayList<Double> // list of doubles",dp
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport java.util.*import kotlin.collections.ArrayDequeimport kotlin.random.Randomimport kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        IN = BufferedInputStream(fakein.toString().byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} fun getint():Int{ return IO.nextInt() }fun getlong():Long{ return IO.nextLong() }fun getline(n:Int):IntArray{    val ret = IntArray(n);repeat(n){ret[it] = getint()};return ret}fun getlineL(n:Int):LongArray{    val ret = LongArray(n);repeat(n){ret[it] = getlong()};return ret}fun getstr():String{ return IO.nextString() }fun MutableList<Int>.streamint(n:Int){ repeat(n){this.add(getint())}}fun MutableList<Long>.streamlong(n:Int){ repeat(n){this.add(getlong())}}inline fun cases(ask:()->Unit){ val t = getint();repeat(t){ ask() }} val List<Char>.ret:String    get() = this.joinToString("""")infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    var str = """"    if(this is String){ str = this    }else if(this is Int){ str = this.toString()    }else if(this is Long){ str = this.toString()    }    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    inline fun cases(a:solve.()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint()} else if(mode == solveMode.tc){1 } else randCount         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            currentAnswer = null            currentBruteAnswer = null            a()        }        if(withBruteForce){            put(""Checked ${answersChecked}"")        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    inline fun brute(a:()->Unit){        if(withBruteForce){            a()        }    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }      var currentAnswer:String? = null    var currentBruteAnswer:String? = null    fun answer(a:Any){        currentAnswer = a.toString()        if(currentBruteAnswer != null){            checkAnswer()        }    }    fun put2(a:Any){answer(a);put(a) }     fun bruteAnswer(a:Any){        currentBruteAnswer = a.toString()        if(currentAnswer != null){            checkAnswer()        }    }    fun checkAnswer(){        if(currentAnswer != currentBruteAnswer){            throw Exception(""Failed Test: BF $currentBruteAnswer Current $currentAnswer"")        }        answersChecked ++    }}fun Int2(a:Int,b:Int) = List(a){IntArray(b)}fun Int3(a:Int,b:Int,c:Int) = List(a){List(b){IntArray(c)}}const val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}fun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionconst val funny = -777222777 // start array with this to be safe, WYSIconst val huge = 2_727_000_000_000_000_000L // used for seg tree thingsval Char.code :Int get() = this.toInt() -  'a'.toInt() internal class LiChaoNode(var s: Int, var e: Int, l: Line?) {    var m: Int    var cur: Line?    var lt: LiChaoNode? = null    var rt: LiChaoNode? = null     init {        m = s + e shr 1        cur = l    }     fun insert(l: Line) {        var l = l        if (cur == null) {            cur = l            return        }        val b1 = l.eval(s.toLong()) < cur!!.eval(s.toLong())        val b2 = l.eval(m.toLong()) < cur!!.eval(m.toLong())        if (b2) {            val t = l            l = cur!!            cur = t        }        if (s == e) return        if (b1 != b2) {            if (lt == null) lt = LiChaoNode(s, m, l) else lt!!.insert(l)        } else {            if (rt == null) rt = LiChaoNode(m + 1, e, l) else rt!!.insert(l)        }    }     fun query(x: Int): Long {        var y = cur!!.eval(x.toLong())        if (x < m && lt != null) y = y.coerceAtMost(lt!!.query(x))        if (x > m && rt != null) y = y.coerceAtMost(rt!!.query(x))        return y    }    internal class Line(var m: Long, var c: Long) {        fun eval(x: Long): Long {            return m * x + c        }    }}  internal class CHT_full() {    companion object{        const val type:Int = -1        var query:Boolean = false    }    var hull:TreeSet<Line> = TreeSet()     fun add(m: Long, b: Long) {        add(Line(m, b))    }     fun add(a: Line) {        val LR = arrayOf(hull.lower(a), hull.ceiling(a))        for (i in 0..1) if (LR[i] != null && LR[i].m == a.m) {            if (type == 1 && LR[i].b >= a.b) return            if (type == -1 && LR[i].b <= a.b) return            remove(LR[i])        }        hull.add(a)        var L = hull.lower(a)        var R = hull.higher(a)        if (L != null && R != null && a.inter(R) <= R.left) {            hull.remove(a)            return        }        var LL = if (L != null) hull.lower(L) else null        var RR = if (R != null) hull.higher(R) else null        if (L != null) a.left = a.inter(L)        if (R != null) R.left = a.inter(R)        while (LL != null && L.left >= a.inter(LL)) {            remove(L)            a.left = a.inter(LL.also { L = it })            LL = hull.lower(L)        }        while (RR != null && R.inter(RR) <= a.inter(RR)) {            remove(R)            RR.left = a.inter(RR.also { R = it })            RR = hull.higher(R)        }    }     fun query(x: Long):Long? {        val temp = Line(0, 0, 0)        temp.left = x.toDouble()        query = true        val ans = hull.floor(temp)?.eval(x)        query = false        return ans    }     fun addAll(other:CHT_full){        for(l in other.hull){            add(l)        }    }     private fun remove(x: Line) {        hull.remove(x)    }     fun size(): Int {        return hull.size    }  }internal class Line:Comparable<Line> {    var m: Long    var b: Long    var left = Long.MIN_VALUE.toDouble()     constructor(mm: Long, x: Long, y: Long) {        m = mm        b = -m * x + y    }     constructor(mm: Long, bb: Long) {        m = mm        b = bb    }     fun eval(x: Long): Long {        return m * x + b    }     fun inter(x: Line): Double {        return (x.b - b).toDouble() / (m - x.m).toDouble()    }     override fun compareTo(other: Line): Int {        if(!CHT_full.query){            return CHT_full.type * this.m.compareTo(other.m)        }        if(this.left == other.left){            return this.m.compareTo(other.m)        }        return this.left.compareTo(other.left)     }} // convert all to 0 based  class Graph(val n:Int, val directed:Boolean){    val E = Array<MutableList<Int>>(n) { mutableListOf() }    val indices = 0 until n//    val invE = Array<MutableList<Int>>(n) { mutableListOf() }     fun add(a:Int,b:Int){        E[a].add(b)//        invE[b].add(a)        if(!directed){            E[b].add(a)//            invE[a].add(b)        }    }    inline fun NS(from:Int,act:(Int)->Unit){        for(v in E[from]){            act(v)        }    }    inline fun everyEdge(act:(Int,Int)->Unit){        for((i,v) in E.withIndex()){            for(to in v){                act(i,to)            }        }    }      // maintaining by adjaceny matrix//    val E = List(n+1){BooleanArray(n+1)}//    fun add(a:Int,b:Int){//        E[a][b] = true//        if(!directed){//            E[b][a] = true//        }//    }//    fun remove(a:Int,b:Int){//        E[a][b] = false//        if(!directed){//            E[b][a] = false//        }//    }//    inline fun NS(from:Int,act:(Int)->Unit){//        for(j in 0..n){//            if(E[from][j]){//                act(j)//            }//        }//    }      fun streamEdges(m:Int){//        repeat(m){//            val x = getint()//            val y = getint()//            add(x,y)//        }    }    inline fun BFS(reached:(Int,Int)->Unit){        val root = 0        val toDo = ArrayDeque<Int>()        val explored = IntArray(n+1){-1} // also store parents        toDo.add(root)        explored[root] = -2         while(toDo.size > 0){            val x = toDo.removeFirst()            reached(x,explored[x])            NS(x){ a->                if(explored[a] == -1){                    explored[a] = x                    toDo.addLast(a)                }            }        }    }    val basic_active = true    val basic_setup = if(basic_active) n else 0     val parent = IntArray(basic_setup)//    val depth = IntArray(basic_setup)    val sizes = IntArray(basic_setup)//    val subs = List(basic_setup){mutableListOf<Int>()}    fun setup(){        DFS_long(0,{ v ->            sizes[v]++            if(v != 0) sizes[parent[v]] += sizes[v]        }){                from,to ->            parent[to] = from//            depth[to] = depth[from] + 1//            subs[from].add(to)        }    }     inline fun DFS(dfsOrder:(Int)->Unit){        DFS_long(0,dfsOrder,{_,_->})    }    //    inline fun DFS_long_Exhaust( dfsOrder: (Int) -> Unit, long: (Int, Int) -> Unit){    // crash()//        val done = BooleanArray(n)//        var pointer = 0//        val stack = IntArray(n+1)//        for(i in 0 until n){//           if(done[i]) continue//            stack[0] = i//            pointer = 0//            while(pointer >= 0){//                val now = stack[pointer]//                if(done[now]){//                    dfsOrder(now)//                    pointer--//                }else{//                    done[now] = true//                    NS(now){//                        if(!done[it]){//                            pointer++//                            stack[pointer] = it//                            long(now,it)//                        }//                    }//                }//            }//        }//    }////    inline fun DFS_Long_2(root:Int,dfsOrder:(Int)->Unit,long:(Int,Int)->Unit){    // crash()//        val done = BooleanArray(n)//        var pointer = 0//        val stack = IntArray(n+1)//        stack[0] = root//        pointer = 0//        while(pointer >= 0){//            val now = stack[pointer]//            if(done[now]){//                dfsOrder(now)//                pointer--//            }else{//                done[now] = true//                NS(now){//                    if(!done[it]){//                        pointer++//                        stack[pointer] = it//                        long(now,it)//                    }//                }//            }//        }//    }     inline fun DFS_long(root:Int,dfsOrder:(Int)->Unit,long:(parent:Int,here:Int)->Unit){        //Long: (from,to) i.e. (parent, child)        var pointer = 0        val toDo = IntArray(n+1)         val explored = BooleanArray(n+1)        val secondTime = BooleanArray(n+1)        toDo[0] = root        explored[root] = true         while(pointer >= 0){            val x = toDo[pointer]            if(secondTime[x]){                dfsOrder(x)                pointer--                continue            }            //move here for top down order            secondTime[x] = true            NS(x){ a->                if(!explored[a]){                    explored[a] = true                    pointer++                    long(x,a)                    toDo[pointer] = a                }            }        }    }    inline fun DFS_Long_Exhaust(dfsOrder:(Int)->Unit,newroot:(Int)->Unit = {},long:(p:Int,into:Int,root:Int)->Unit = {_,_,_ ->}){        //Long: (from,to) i.e. (parent, child)        var pointer:Int        val toDo = IntArray(n)         val explored = BooleanArray(n)        val secondTime = BooleanArray(n)         var exploredCount = 0        var exploredPointer = 0         while(exploredCount < n){            while(explored[exploredPointer]){                exploredPointer ++            }            val root = exploredPointer            newroot(root)            explored[root] = true            exploredCount ++            toDo[0] = root            pointer = 0            while(pointer >= 0){                val x = toDo[pointer]                if(secondTime[x]){                    dfsOrder(x)                    pointer--                    continue                }                //move here for top down order                secondTime[x] = true                NS(x){ a->                    if(!explored[a]){                        explored[a] = true                        exploredCount ++                        pointer++                        long(x,a,root)                        toDo[pointer] = a                    }                }            }        }    }    fun topologicalSort(): List<Int> {        //backwards, start from outdegree 0 vertex        val ret = mutableListOf<Int>()        DFS_Long_Exhaust({ret.add(it)},{}){a,b,_ ->}        return ret    } }   const val withBruteForce = falseconst val randCount = 100fun main(){    solve.cases{        val n = getint()        val A = getlineL(n)        val B = getlineL(n)        val G = Graph(n,false)         repeat(n-1){            G.add(getint() - 1 , getint() - 1 )        }         G.setup()        val ret = LongArray(n)         fun Graph.dfs(v:Int, parent:Int):CHT_full{            var all = mutableListOf<CHT_full>()            NS(v){w ->                if(w == parent){                    return@NS                }                all.add(dfs(w,v))            }            val largest = all.maxByOrNull { it.hull.size } ?: CHT_full()            for(a in all){                if(a != largest){                    largest.addAll(a)                }            }            val value = largest.query(A[v]) ?: 0L            ret[v] = value            largest.add(B[v],value)            return largest        }        G.dfs(0,-1)        put(ret.joinToString("" ""))    }    done()}const val singleCase = true","data structures,dp,geometry"
"import java.io.BufferedReaderimport java.io.InputStreamReader const val MAX_LEN = 300_000 + 1 fun main(args: Array<String>) {    val arkady = Arkady()    var answer = 0    BufferedReader(InputStreamReader(System.`in`)).useLines { lines ->        lines.forEach {            answer += arkady.writeLine(it)        }    }    println(answer)} private class Arkady {    private val root = 0    private val trie = Array(26) { IntArray(MAX_LEN) { -1 } }    private val suffix = IntArray(MAX_LEN) { -1 }    private val autocomplete = ArrayList<CharSequence>()     private var size = 1     fun writeLine(line: String): Int {        var click = 0        var ptr = root        while (ptr < line.length) {            var wordEnd = ptr            while (wordEnd < line.length && line[wordEnd] in 'a'..'z') {                ++wordEnd            }            if (ptr < wordEnd) {                click += writeWord(line.subSequence(ptr, wordEnd))                ptr = wordEnd            } else {                click++                ptr++            }        }        return click + 1 // plus line ending    }     private fun writeWord(word: CharSequence): Int {        require(word.isNotEmpty())        var clicks = word.length        var current = root        var ptr = 0        while (ptr < word.length && trie[word[ptr].encode()][current] != -1) {            current = trie[word[ptr].encode()][current]            ptr++        }        if (ptr == word.length) {            if (suffix[current] >= 0) {                mergeSuffixes(current, """")            }            return clicks        }        val wordSuffix = word.drop(ptr)        if (suffix[current] >= 0) {            val suggest = autocomplete[suffix[current]]            assert(suggest.isNotEmpty())            if (wordSuffix.startsWith(suggest)) {                clicks -= suggest.length - 1                if (suggest.length < wordSuffix.length) {                    mergeSuffixes(current, wordSuffix)                }            } else {                mergeSuffixes(current, wordSuffix)            }        } else {            val next = allocate()            trie[wordSuffix[0].encode()][current] = next            if (wordSuffix.length > 1) {                saveAutocomplete(next, wordSuffix.drop(1))            }        }        return clicks    }     private fun mergeSuffixes(vertex: Int, theirSuffix: CharSequence) {        require(suffix[vertex] >= 0 && autocomplete[suffix[vertex]].isNotEmpty())        var current = vertex        var suffixIndex = suffix[current]        suffix[current] = -1        val ourSuffix = autocomplete[suffixIndex]        var i = 0        while (i < ourSuffix.length && i < theirSuffix.length) {            if (ourSuffix[i] != theirSuffix[i]) {                break            }            val next = allocate()            trie[ourSuffix[i].encode()][current] = next            current = next            i++        }        for (suf in arrayOf(ourSuffix, theirSuffix)) {            if (i < suf.length) {                val next = allocate()                trie[suf[i].encode()][current] = next                if (i + 1 < suf.length) {                    saveAutocomplete(next, suf.drop(i + 1), suffixIndex)                    suffixIndex = -1                }            }        }    }     private fun saveAutocomplete(vertex: Int, wordSuffix: CharSequence, index: Int = -1) {        require(wordSuffix.isNotEmpty())        if (index == -1) {            suffix[vertex] = autocomplete.size            autocomplete.add(wordSuffix)        } else {            suffix[vertex] = index            autocomplete[index] = wordSuffix        }    }     private fun allocate(): Int = size++     private fun Char.encode(): Int = this - 'a'} ","*special,strings,trees"
"import kotlin.math.max fun main() {    val (numRows, numCols, numFriends) = readLine()!!.split("" "").map(String::toInt)    val classroom = Array<String>(numRows) {""""}    var solution = 0    for (row in 0 until numRows)        classroom[row] = readLine()!!    for (row in 0 until numRows) {        var candidate = 0        for (column in 0 until numCols) {            if (classroom[row][column] == '.') {                candidate++            } else {                solution += max(0, candidate - numFriends + 1)                candidate = 0            }        }        solution += max(0, candidate - numFriends + 1)    }    for (column in 0 until numCols) {        var candidate = 0        for (row in 0 until numRows) {            if (classroom[row][column] == '.') {                candidate++            } else {                solution += max(0, candidate - numFriends + 1)                candidate = 0            }        }        solution += max(0, candidate - numFriends + 1)    }    if (numFriends == 1) solution /= 2    print(solution)}","brute force,implementation"
"import java.util.*; private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readDouble() = readLn().toDouble() // single intprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of intsprivate fun readDoubles() = readStrings().map { it.toDouble() } // list of ints fun main(args: Array<String>) {    solve()    /*    val t = readInt()    repeat(t) {        solve()    }    */} fun solve() {    val (n, m, k) = readInts()    val l = ArrayList<String>()    repeat(n) {        l.add(readLn())    }    var ret = 0    for(i in 0 until n) {        var curr = 0        for(j in 0 until m) {            if(l[i][j] == '*') curr = 0            else curr++            if(curr >= k) ret++        }    }    if(k > 1) {        for(i in 0 until m) {            var curr = 0            for (j in 0 until n) {                if (l[j][i] == '*') curr = 0                else curr++                if (curr >= k) ret++            }        }    }    println(ret)} /*useful things:to read in multiple ints in one lineval (n, m, k) = readInts() Java: int[] dx = new int[]{-1,1,0,0}Kotlin: val dx = arrayOf(-1, 1, 0, 0)*/","brute force,implementation"
"import kotlin.math.maximport kotlin.math.min // If using closures make sure to do return@c instead of returnfun main() = printingClosure c@{     val (rows, columns, consecutiveSeats) = readInts()     val rowData = arrayListOf<String>()    var combinations = 0L     val emptyRegex = Regex(""\\.+"")     repeat(rows) {        rowData.add(readLine()!!)        val emptyLengths = emptyRegex.findAll(rowData.last()).map { it.value.length }        for (length in emptyLengths) {            combinations += max(length - consecutiveSeats + 1, 0)        }    }     if (consecutiveSeats == 1) return@c combinations     for (column in 0 until columns) {         val string = buildString {            for (row in 0 until rows) append(rowData[row][column])        }         val emptyLengths = emptyRegex.findAll(string).map { it.value.length }        for (length in emptyLengths) {            combinations += max(length - consecutiveSeats + 1, 0)        }    }     return@c combinations} private fun withPrintingTrials(function: () -> Any) {    for (i in 0 until readInt()) println(function())} private fun printingClosure(function: () -> Any) = println(function()) private fun String.toNumbers() = map { it - '0' } private fun readInt() = readLine()!!.toInt() private fun readInts() = readLine()!!.split("" "").map { it.toInt() } private fun gcf(num1: Int, num2: Int) = greatestCommonFactor(num1, num2) private fun greatestCommonFactor(num1: Int, num2: Int): Int {     var max = max(num1, num2)    var min = min(num1, num2)     var remaining = max % min     while (remaining != 0) {         max = min        min = remaining        remaining = max % min    }     return min} private fun <T> List<T>.countInstances(): MutableMap<T, Int> {     val map = HashMap<T, Int>()    for (value in this) map[value] = map.getOrDefault(value, 0) + 1     return map} /** * Assumes only positive int values */private fun Int.isPrime(): Boolean {     if (this == 2) return true     for (i in 2..shr((32 - countLeadingZeroBits()) / 2).takeHighestOneBit() * 2) {        if (this % i == 0) return false    }     return true} private fun Int.isEven() = this % 2 == 0 private fun Int.isOdd() = !isEven()","brute force,implementation"
"import java.util.* fun main(args: Array<String>) {    val list = arrayOf(1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987)    for (i in 1..readLine()!!.toInt()) print(if (i in list) ""O"" else ""o"")}","brute force,implementation"
"fun main(args:Array<String>){    val n=readLine()!!.toInt()    val fib = Array(n){it+1}    (2 until n).forEach { fib[it]=fib[it-1]+fib[it-2] }    println(Array(n){ if(fib.contains(it+1)) 'O' else 'o' }.joinToString(""""))}","brute force,implementation"
fun main() {    val numCharacters = readLine()!!.toInt()    var pf = 1    var f = 1    val sb = StringBuilder()    for (pos in 1..numCharacters) {        if (pos == f) {            sb.append('O')            val nf = pf + f            pf = f            f = nf        } else {            sb.append('o')        }    }    print(sb.toString())},"brute force,implementation"
"fun main(args: Array<String>) {   val fib =           generateSequence(Pair(1,1)) {Pair(it.second, it.first+it.second)}                   .takeWhile {it.first<=1000  }                   .map {it.first}                   .toSet()    val n = readLine()!!.trim().toInt()    val r = (1..n).map { if (it in fib) 'O' else 'o' }            .joinToString("""")    println(r)}","brute force,implementation"
"fun main() {    val (name, surname) = readLine()!!.split("" "")    val sol = StringBuilder()    for ((pos, c) in name.withIndex()) {        if (c < surname.first() || pos == 0) sol.append(c)        else break    }    sol.append(surname.first())    print(sol.toString())}","brute force,greedy,sortings"
"fun main() {    var (f, l) = readLine()!!.split("" "")    var j = 0    var ans = f[0].toString()    for (i in 1 until f.length) {        if (f[i].toInt() < l[j].toInt()) {            ans += f[i]        }else{            ans+=l[j]            println(ans)            return        }    }    ans+=l[j]    println(ans)}","brute force,greedy,sortings"
"fun main(args: Array<String>) {    var (a, b) = readLine()!!.split(' ')    var ans = """"    var i = 1    ans = ans.plus(a.get(0))    var found: Boolean = false    while (i < a.length) {        if(a.get(i) < b.get(0)){            ans = ans.plus(a.get(i))        }        else{            ans = ans.plus(b.get(0))            found = true            break        }        i++    }    if (!found){        ans = ans.plus(b.get(0))    }    println(ans)}","brute force,greedy,sortings"
"import java.util.* fun main(args: Array<String>) = with(Scanner(System.`in`)) {    val s = nextLine().split(("" "").toRegex()).dropLastWhile({ it.isEmpty() }).toTypedArray()    val c = s[0].toCharArray()    val fchar = s[1].get(0)    val sb = StringBuilder("""")    sb.append(c[0])    for (i in 1 until c.size) {        val a = c[i].toInt()        val b = fchar.toInt()        if (a < b) sb.append(a.toChar())        else break    }    sb.append(fchar)    println(sb)}","brute force,greedy,sortings"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.* fun main() {    val jin = BufferedReader(InputStreamReader(System.`in`))    val n = jin.readLine().toInt()    val array = listOf(0) + jin.readLine().split("" "").map { it.toInt() } + listOf(-1)    val prev = IntArray(n + 2)    val next = IntArray(n + 2)    val length = IntArray(n + 2)    val treeSet = TreeSet<Int>(compareBy({ -length[it] }, { it }))    var l = 1    while (l <= n) {        var r = l        while (array[r] == array[l]) {            r++        }        next[l] = r        prev[r] = l        length[l] = r - l        treeSet.add(l)        l = r    }    var answer = 0    while (treeSet.isNotEmpty()) {        answer++        l = treeSet.first()        treeSet.remove(l)        if (array[prev[l]] == array[next[l]]) {            treeSet.remove(prev[l])            treeSet.remove(next[l])            length[prev[l]] += length[next[l]]            next[prev[l]] = next[next[l]]            prev[next[next[l]]] = prev[l]            treeSet.add(prev[l])        } else {            next[prev[l]] = next[l]            prev[next[l]] = prev[l]        }    }    println(answer)} /*135 5 6 6 7 7 7 7 6 5 5 5 5  */","data structures,dsu,flows,implementation,two pointers"
"import java.io.*import java.util.* val maxn = 201010val err = System.errval bf = BufferedReader(InputStreamReader(System.`in`))var st = StringTokenizer("""") fun nxtstring(): String {  while (!st.hasMoreTokens()) st = StringTokenizer(bf.readLine())  return st.nextToken()} fun nxtint() = nxtstring().toInt() data class Dat(var len: Int, var pos: Int)var se = TreeSet<Dat>(object: Comparator<Dat> {  override fun compare(a: Dat, b: Dat): Int {    if (a.len == b.len) return a.pos - b.pos    return b.len - a.len  }}) var n = 0val a = IntArray(maxn)val dsu = IntArray(maxn)val len = IntArray(maxn)val last = IntArray(maxn)val pre= IntArray(maxn)val nxt = IntArray(maxn)fun findp(u: Int): Int = if (u == dsu[u]) dsu[u] else findp(dsu[u])fun join(cu: Int, cv: Int) {  var u = findp(cu)  var v = findp(cv)  if (u == v) return  if (u > v) u = v.also {v = u}  //err.println(""join $u $v"")  se.remove(Dat(len[u], u))  se.remove(Dat(len[v], v))  len[u] += len[v]  dsu[v] = dsu[u]  last[u] = last[v]  se.add(Dat(len[u], u))} fun rem() {  val t = se.pollFirst()  var head = t.pos  var tail = last[head]  //err.printf(""%d %d %d\n"", len[head], head, tail)  var u = pre[head]  var v = nxt[tail]  if (u != -1) nxt[u] = v  if (v != n) pre[v] = u  if (u == -1 || v == n) return  if (a[u] != a[v]) return  join(u, v)} fun main(args: Array<String>) {  n = nxtint()  for (i in 0 until n) {    a[i] = nxtint()    dsu[i] = i    len[i] = 1    last[i] = i    se.add(Dat(1, i))  }  nxt[n - 1] = n  pre[0] = -1  for (i in 0 until n - 1) {    nxt[i] = i + 1    pre[i + 1] = i  }  for (i in 0 until n - 1) {    if (a[i] != a[i + 1]) continue    join(i, i + 1)  }  var ans = 0  while (!se.isEmpty()) {    rem()    ++ans  }  println(ans)}","data structures,dsu,flows,implementation,two pointers"
"//region TEMPLATE@file:Suppress(""CanBeVal"") import com.sun.xml.internal.fastinfoset.util.StringArrayimport java.io.*;import java.io.BufferedReaderimport java.lang.Integer.maximport java.lang.Integer.minimport java.lang.Math.absimport java.util.*import javax.swing.tree.TreeCellEditorimport kotlin.collections.ArrayListimport kotlin.math.maximport kotlin.math.minimport kotlin.random.Random fun main(args: Array<String>) {    if (args.isNotEmpty() && args.first() == ""file"") {        out = PrintWriter(FileWriter(""output.txt""))        reader = BufferedReader(FileReader(""input.txt""))        do {            solve()            out.println(""\n"")            out.flush()        } while (reader.readLine() != null)    } else {        reader = BufferedReader(InputStreamReader(System.`in`))        out = PrintWriter(OutputStreamWriter(System.out))        solve()    }    reader.close()    out.close()} lateinit var out: PrintWriterlateinit var reader: BufferedReadervar tokenizer: StringTokenizer? = nullfun read(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {        tokenizer = StringTokenizer(readLn())    }    return tokenizer!!.nextToken()} fun readInt() = read().toInt()fun readLong() = read().toLong()fun readLn() = reader.readLine()!!fun readInts() = readLn().split("" "").map { it.toInt() }fun readInts(sz: Int) = Array(sz) { readInt() }fun readLongs() = readLn().split("" "").map { it.toLong() }fun readLongs(sz: Int) = Array(sz) { readLong() }fun print(b: Boolean) = out.print(b)fun print(i: Int) = out.print(i)fun print(d: Double) = out.print(d)fun print(l: Long) = out.print(l)fun print(s: String) = out.print(s)fun print(message: Any?) = out.print(message)fun print(a: Array<Int>) = a.forEach { print(""$it "") }fun <T> print(a: Array<out T>) = a.forEach { print(""$it "") }fun <T> print(a: Collection<T>) = a.forEach { print(""$it "") }fun println(b: Boolean) = out.println(b)fun println(i: Int) = out.println(i)fun println(d: Double) = out.println(d)fun println(l: Long) = out.println(l)fun println(s: String) = out.println(s)fun println() = out.println()fun println(message: Any?) = out.println(message)fun <T> println(a: Array<out T>) {    a.forEach { print(""$it "") }    println()} fun println(a: IntArray) {    a.forEach { print(""$it "") }    println()} fun <T> println(a: Collection<T>) {    a.forEach { print(""$it "") }    println()} const val M7 = 1000000007Lconst val M9 = 1000000009Lconst val MFFT = 998244353Lfun zero(sz: Int) = IntArray(sz)fun zeroL(sz: Int) = LongArray(sz)fun <T> init(vararg elements: T) = elementsfun VI(n: Int = 0, init: Int = 0) = MutableList(n) { init }fun VVI(n: Int = 0, m: Int = 0, init: Int = 0) = MutableList(n) { VI(m, init) }fun <T1 : Comparable<T1>, T2 : Comparable<T2>> pairCmp(): Comparator<Pair<T1, T2>> {    return Comparator { a, b ->        val res = a.first.compareTo(b.first)        if (res == 0) a.second.compareTo(b.second) else res    }}//endregion  fun solve() {    var n = readInt()    var a = readInts(n)      var segByInd = TreeSet<Pair<Int, Int>>(compareBy { it.first })    var segByLen = TreeSet<Pair<Int, Int>>(compareBy({ -it.second }, { it.first }))    run {        var i = 0        while (i < n) {            var j = i            while (j < n && a[j] == a[i]) {                j++            }            var seg = Pair(i, j - i)            segByInd.add(seg)            segByLen.add(seg)            i = j        }    }    var ans = 0    while (segByLen.isNotEmpty()) {        ans++        var tr = segByLen.first()        segByLen.remove(tr)        segByInd.remove(tr)         var leftSeg = segByInd.lower(tr)        var rightSeg = segByInd.higher(tr)        if (leftSeg != null && rightSeg != null && a[leftSeg.first] == a[rightSeg.first]) {            segByInd.remove(leftSeg)            segByInd.remove(rightSeg)            segByLen.remove(leftSeg)            segByLen.remove(rightSeg)            var nseg = Pair(leftSeg.first, leftSeg.second + rightSeg.second)            segByInd.add(nseg)            segByLen.add(nseg)        }    }    println(ans) }","data structures,dsu,flows,implementation,two pointers"
"//region TEMPLATE@file:Suppress(""CanBeVal"") import com.sun.xml.internal.fastinfoset.util.StringArrayimport java.io.*;import java.io.BufferedReaderimport java.lang.Integer.maximport java.lang.Integer.minimport java.lang.Math.absimport java.util.*import javax.swing.tree.TreeCellEditorimport kotlin.collections.ArrayListimport kotlin.math.maximport kotlin.math.minimport kotlin.random.Random fun main(args: Array<String>) {    if (args.isNotEmpty() && args.first() == ""file"") {        out = PrintWriter(FileWriter(""output.txt""))        reader = BufferedReader(FileReader(""input.txt""))        do {            solve()            out.println(""\n"")            out.flush()        } while (reader.readLine() != null)    } else {        reader = BufferedReader(InputStreamReader(System.`in`))        out = PrintWriter(OutputStreamWriter(System.out))        solve()    }    reader.close()    out.close()} lateinit var out: PrintWriterlateinit var reader: BufferedReadervar tokenizer: StringTokenizer? = nullfun read(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {        tokenizer = StringTokenizer(readLn())    }    return tokenizer!!.nextToken()} fun readInt() = read().toInt()fun readLong() = read().toLong()fun readLn() = reader.readLine()!!fun readInts() = readLn().split("" "").map { it.toInt() }fun readInts(sz: Int) = Array(sz) { readInt() }fun readLongs() = readLn().split("" "").map { it.toLong() }fun readLongs(sz: Int) = Array(sz) { readLong() }fun print(b: Boolean) = out.print(b)fun print(i: Int) = out.print(i)fun print(d: Double) = out.print(d)fun print(l: Long) = out.print(l)fun print(s: String) = out.print(s)fun print(message: Any?) = out.print(message)fun print(a: Array<Int>) = a.forEach { print(""$it "") }fun <T> print(a: Array<out T>) = a.forEach { print(""$it "") }fun <T> print(a: Collection<T>) = a.forEach { print(""$it "") }fun println(b: Boolean) = out.println(b)fun println(i: Int) = out.println(i)fun println(d: Double) = out.println(d)fun println(l: Long) = out.println(l)fun println(s: String) = out.println(s)fun println() = out.println()fun println(message: Any?) = out.println(message)fun <T> println(a: Array<out T>) {    a.forEach { print(""$it "") }    println()} fun println(a: IntArray) {    a.forEach { print(""$it "") }    println()} fun <T> println(a: Collection<T>) {    a.forEach { print(""$it "") }    println()} const val M7 = 1000000007Lconst val M9 = 1000000009Lconst val MFFT = 998244353Lfun zero(sz: Int) = IntArray(sz)fun zeroL(sz: Int) = LongArray(sz)fun <T> init(vararg elements: T) = elementsfun VI(n: Int = 0, init: Int = 0) = MutableList(n) { init }fun VVI(n: Int = 0, m: Int = 0, init: Int = 0) = MutableList(n) { VI(m, init) }fun <T1 : Comparable<T1>, T2 : Comparable<T2>> pairCmp(): Comparator<Pair<T1, T2>> {    return Comparator { a, b ->        val res = a.first.compareTo(b.first)        if (res == 0) a.second.compareTo(b.second) else res    }}//endregion  fun solve() {    var n = readInt()    var a = readInts(n)     data class Segment(var l: Int = 0, var len: Int = 0)     var segByInd = TreeSet<Segment>(compareBy { it.l })    var segByLen = TreeSet<Segment>(compareBy({ -it.len }, { it.l }))    run {        var i = 0        while (i < n) {            var j = i            while (j < n && a[j] == a[i]) {                j++            }            var seg = Segment(i, j - i)            segByInd.add(seg)            segByLen.add(seg)            i = j        }    }    var ans = 0    while (segByLen.isNotEmpty()) {        ans++        var tr = segByLen.first()        segByLen.remove(tr)        segByInd.remove(tr)         var leftSeg = segByInd.lower(tr)        var rightSeg = segByInd.higher(tr)        if (leftSeg != null && rightSeg != null && a[leftSeg.l] == a[rightSeg.l]) {            segByInd.remove(leftSeg)            segByInd.remove(rightSeg)            segByLen.remove(leftSeg)            segByLen.remove(rightSeg)            var nseg = Segment(leftSeg.l, leftSeg.len + rightSeg.len)            segByInd.add(nseg)            segByLen.add(nseg)        }    }    println(ans) }","data structures,dsu,flows,implementation,two pointers"
"import kotlin.math.min private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of ints fun NineNine (n:Int):Long{    var x= 0L    var res = 0L    while (x - n <= n){        res = x        x= x*10+9    }    return res}var res = 0Lfun count (n:Int,nine:Long){    var digit = 1L    while (digit <= nine) digit*=10     for (x in 0..8){        var start = ((x*digit)+nine)/2 +1         if (start > n ) return         res += min(n.toLong(),(x*digit)+nine)-start+1        if ((x*digit)+nine <=n)            res --    }}fun main(args: Array<String>) {    var n = readInt()     if (n >= 5)        count(n,NineNine(n))    else res = (n*(n-1)/2).toLong()        println(res)}","constructive algorithms,math"
"import java.io.*import java.util.StringTokenizer val err = System.errval bf = BufferedReader(InputStreamReader(System.`in`))var st = StringTokenizer("""") fun nxtstring(): String {  while (!st.hasMoreTokens()) st = StringTokenizer(bf.readLine())  return st.nextToken()} fun nxtint() = nxtstring().toInt() var n: Long = 0val p10 = LongArray(11) fun findmax9(): Int {  var ans = 0  var num = 0L  while (true) {    val ldn = n / p10[ans] % 10    val od = 9 - ldn    num += p10[ans] * od    if (num > n) break    ++ans  }  return ans} fun main(args: Array<String>) {  n = nxtint().toLong()  p10[0] = 1  for (i in 1..10) p10[i] = p10[i - 1] * 10  val max9 = findmax9()  if (max9 == 0) {    println(n * (n - 1) / 2)    return  }  var t = 0  var ans = 0L  while (true) {    var num = p10[max9] * t + p10[max9] - 1    ++t    var l = 1    var r = n.toInt()    while (l < r) {      var mid: Int = l + (r - l) / 2      if (num - mid > n) l = mid + 1      else r = mid    }    //err.printf(""%d %d\n"", num, l)    if (num - l <= l || num - l > n) break    val cnt: Long = num - l - l + 1    ans += cnt / 2  }  println(ans)}","constructive algorithms,math"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.lang.Math.*import java.util.* fun main(args: Array<String>) {    val sc = FastScanner(System.`in`)     val n = sc.nextLong()     var nine = 0L    while (true) {        if (2 * n - 1 < nine * 10 + 9) break        nine = nine * 10 + 9    }     if (nine == 0L) {        println(n * (n - 1) / 2)        return    }     val nines = (0 until 9).map { (nine + 1) * it + nine }    val sum = nines.map { count(it, n) }.sum()     println(sum / 2)} fun count(nine: Long, n: Long): Long {    val r1 = 1..n    val r2 = (nine - n)..(nine - 1)     return max(0, min(r1.endInclusive, r2.endInclusive) - max(r1.start, r2.start) + 1)}  class FastScanner(s: InputStream) {    private var st = StringTokenizer("""")    private val br = BufferedReader(InputStreamReader(s))     fun next(): String {        while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun nextInt() = next().toInt()    fun nextLong() = next().toLong()    fun nextLine() = br.readLine()    fun nextDouble() = next().toDouble()    fun ready() = br.ready()}","constructive algorithms,math"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.* fun main(args: Array<String>) {    val sc = FastScanner(System.`in`)     val n = sc.nextLong()     var nine = 0L     while (true) {        if (2 * n - 1 < nine * 10 + 9) break        nine = nine * 10 + 9    }     if (nine == 0L) {        println(n * (n - 1) / 2)        return    }     var sum = 0L    for (z in 0 until 9) {        sum += count((nine + 1) * z + nine, n)    }     println(sum / 2)  } fun count(nine: Long, n: Long): Long {    val a = 1L    val b = n     val c = nine - n    val d = nine - 1     if (b < c) return 0    if (d < a) return 0     return Math.min(b, d) - Math.max(a, c) + 1}  class FastScanner(s: InputStream) {    private var st = StringTokenizer("""")    private val br = BufferedReader(InputStreamReader(s))     fun next(): String {        while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun nextInt() = next().toInt()    fun nextLong() = next().toLong()    fun nextLine() = br.readLine()    fun nextDouble() = next().toDouble()    fun ready() = br.ready()}  ","constructive algorithms,math"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.lang.AssertionErrorimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007 class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  private val reader = BufferedReader(InputStreamReader(stream), 32768)   private val N = ni()  private val M = ni()  private val C = ni()  fun solve() {    val sheet = IntArray(N){-1}    while(sheet.indexOf(-1) != -1) {      val x = ni() - 1      var i = -1      if (x < C/2) {        i = 0        while (i < N) {          if (sheet[i] == -1 || sheet[i] > x) {            sheet[i] = x            break          }          i++        }        assert(i < N)      }      else {        i = N - 1        while (i >= 0) {          if (sheet[i] == -1 || sheet[i] < x) {            sheet[i] = x            break          }          i--        }        assert(i >= 0)      }      out.println(i + 1)      out.flush()       debug{""x:$x i:$i""}      debug(sheet)    }  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return IntArray(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private inline fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: BooleanArray) {    debug { toString(a) }  }   private inline fun toString(a: BooleanArray) = run{a.map { if (it) 1 else 0 }.joinToString("""")}   private inline fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<BooleanArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }   private inline fun assert(b: Boolean) = run{if (!b) throw AssertionError()}} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","binary search,constructive algorithms,games,greedy,interactive"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"") import java.io.PrintWriterimport java.util.StringTokenizerimport kotlin.math.*import kotlin.random.*import kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {    val n = readInt()    val m = readInt()    val c = readInt()        val head = IntList()    val tail = IntList()        repeat(m) {        val p = readInt()         if(p <= c/2) {            val i = head.bsIndexOfFirst { it > p }            if(i == head.size) head.add(p) else head[i] = p            iprintln(i+1)        } else {            val i = tail.bsIndexOfFirst { it < p }            if(i == tail.size) tail.add(p) else tail[i] = p            iprintln(n-i)        }         if(head.size + tail.size == n) return    }} class IntList(initialCapacity: Int = 12) {    private var _arr = IntArray(initialCapacity)    private val capacity get() = _arr.size    var size = 0        private set    inline val lastIndex get() = size - 1    inline val indices get() = 0 until size     private fun grow(minCapacity: Int = 8) {        val newCapacity = maxOf(minCapacity, capacity + (capacity shr 1))        _arr = _arr.copyOf(newCapacity)    }     fun ensureCapacity(minCapacity: Int) { if(capacity < minCapacity) grow(minCapacity) }     operator fun get(index: Int): Int {        require(index in 0 until size)        return _arr[index]    }     operator fun set(index: Int, value: Int) {        require(index in 0 until size)        _arr[index] = value    }     fun add(value: Int) {        if(size == capacity) grow()        _arr[size++] = value    }     fun clear() { size = 0 }     operator fun iterator() = object: IntIterator() {        private var pos = 0        override fun hasNext() = pos < size        override fun nextInt() = get(pos++)    }     fun isEmpty() = size == 0    fun isNotEmpty() = size != 0     fun pop() = _arr[--size]     fun swap(i: Int, j: Int) { this[i] = this[j].also { this[j] = this[i]} }    fun reverse() {        for(i in 0 until size / 2) swap(i, lastIndex - i)    }     fun shuffle(rnd: Random = random) = _shuffle(rnd, _arr::get, _arr::set, size)    fun sort() { shuffle(); _arr._sort(0, size) }    fun sortDescending() { sort(); reverse() }     fun joinToString(separator: String) = if(size == 0) """" else let {        buildString {            append(it[0])            for (i in 1 until size) {                append(separator).append(it[i])            }        }    }     override fun toString() = ""["" + joinToString("", "") + ""]""} inline fun IntList(size: Int, init: (Int) -> Int) = IntList(size).apply {    for(i in 0 until size) { add(init(i)) }} fun IntList.max() = (1 until size).fold(this[0]) { acc, i -> max(acc, this[i]) }fun IntList.min() = (1 until size).fold(this[0]) { acc, i -> min(acc, this[i]) } inline fun IntRange.bsFirst(predicate: (Int) -> Boolean): Int {    var low = start    var high = endInclusive     while (low <= high) {        val mid = low.and(high) + low.xor(high).shr(1)        if(predicate(mid)) high = mid - 1        else low = mid + 1    }    return low} inline fun IntRange.bsLast(predicate: (Int) -> Boolean) = bsFirst { !predicate(it) } - 1 inline fun IntList.bsIndexOfFirst(predicate: (Int) -> Boolean) = indices.bsFirst { predicate(get(it)) } /** IO code start *///@JvmField val INPUT = File(""input.txt"").inputStream()//@JvmField val OUTPUT = File(""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out @JvmField val _reader = INPUT.bufferedReader()fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!!@JvmField var _tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /** shuffles and sort overrides to avoid quicksort attacks */private inline fun <T> _shuffle(rnd: Random, get: (Int) -> T, set: (Int, T) -> Unit, size: Int) {    // Fisher-Yates shuffle algorithm    for (i in size - 1 downTo 1) {        val j = rnd.nextInt(i + 1)        val temp = get(i)        set(i, get(j))        set(j, temp)    }} @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } fun IntArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)fun IntArray.sort() { shuffle(); _sort() }fun IntArray.sortDescending() { shuffle(); _sortDescending() } fun LongArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)fun LongArray.sort() { shuffle(); _sort() }fun LongArray.sortDescending() { shuffle(); _sortDescending() } fun DoubleArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)fun DoubleArray.sort() { shuffle(); _sort() }fun DoubleArray.sortDescending() { shuffle(); _sortDescending() } fun CharArray.shuffle(rnd: Random = random) = _shuffle(rnd, ::get, ::set, size)inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T: Comparable<T>> Array<out T>.sort() = _sort()inline fun <T: Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T: Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T: Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() fun `please stop removing these imports IntelliJ`() {    iprintln(max(1, 2))}","binary search,constructive algorithms,games,greedy,interactive"
"import java.io.PrintWriterimport java.util.* fun main() {     fun PrintWriter.solve() {        val n = nextInt()        val s = next()         var knownChar = s.toCharArray().toMutableSet().minus('*')         var list = s.withIndex().filter { it.value == '*' }.map { it.index }         val wordList = mutableListOf<String>()        repeat(nextInt()) {            var str = next()            wordList.add(str)             for (idx in 0 until n) {                if (s[idx] == '*'){                    if(str[idx] in knownChar) {                        wordList.removeAt(wordList.lastIndex)                        return@repeat                    }                }                else{                    if(s[idx] != str[idx]) {                        wordList.removeAt(wordList.lastIndex)                        return@repeat                    }                }             }        }          var res = 0          outer@ for (c in 'a'..'z') {            if (c in knownChar) continue             for (str in wordList) {                val charList = list.map { str[it] }                if (!charList.contains(c)) continue@outer            }             if(wordList.isEmpty().not())res++         }          println(res)     }     writer.solve()    writer.flush()  }  private val reader = System.`in`.bufferedReader()private val writer = PrintWriter(System.out, false) private var tokenizer: StringTokenizer = StringTokenizer("""") private fun next(): String {    while (tokenizer.hasMoreTokens().not()) tokenizer = StringTokenizer(reader.readLine())    return tokenizer.nextToken()} private fun nextInt() = next().toInt()private fun nextLong() = next().toLong()private fun nextDouble() = next().toDouble()private fun nextLine() = reader.readLine()private fun readInts() = nextLine().split("" "").map { it.toInt() } ","implementation,strings"
"var _debug = false;fun <T> debug(vararg vals: T): Unit {    if (!_debug) { return }    for (v in vals) { System.err.print(v); System.err.print("" "") }    System.err.println()} data class State(var len: Int, var first: Int, var last: Int) {    fun m(): Int { return first + l2()}    fun l2(): Int { return len / 2}}fun <T: Comparable<T>> bound0(xs: List<T>, func : (State) -> Unit) : Int {    var state = State(len = xs.size, first = 0, last = xs.size);    while (state.len != 0) { func(state) }    return state.first}fun <T: Comparable<T>> bound1(xs: List<T>, pred: (T) -> Boolean): Int {    val func : (State) -> Unit = { s: State ->        if (pred(xs[s.m()])) {            s.first = s.m() + 1; s.len -= s.l2() + 1        } else {            s.len = s.l2()        }    }    return bound0(xs, func)}fun <T: Comparable<T>> lowerBoundShort(xs: List<T>, x0: T) = bound1(xs, { t: T -> t < x0 })fun <T: Comparable<T>> upperBoundShort(xs: List<T>, x0: T) = bound1(xs, { t: T -> t <= x0 })fun <T: Comparable<T>> equalRangeShort(xs: List<T>, x0: T) = Pair(lowerBoundShort(xs, x0), upperBoundShort(xs, x0)) fun merge(groups : List<Group>, grp: Group) : Group {    //val newLows = grp.lows.toMutableList()    //val newHighs = grp.highs.toMutableList()    val newLows = grp.lows    val newHighs = grp.highs    var size = grp.size     debug(""merge"", newLows, size)     for (group in groups) {        for (i in newLows.indices) {            newLows[i] = minOf(newLows[i], group.lows[i])            newHighs[i] = maxOf(newHighs[i], group.highs[i])        }        size += group.size    }    return Group(size=size, highs=newHighs, lows=newLows)} fun someTwo(a1: IntArray, a2: IntArray, pred: (Int, Int) -> Boolean) : Boolean {    for (i in a1.indices) {        if (pred(a1[i], a2[i])) {            return true        }    }    return false} // http://codeforces.com/contest/878/submission/31775120data class Group(val highs: IntArray, val lows: IntArray, val size: Int = 1) : Comparable<Group> {    operator fun plus(other: Group) : Group {        val newLows = (lows zip other.lows).map {minOf(it.first, it.second)}        val newHighs = (highs zip other.highs).map {maxOf(it.first, it.second)}        return Group(size =this.size + other.size, highs =newHighs.toIntArray(), lows =newLows.toIntArray())    }     override fun compareTo(other: Group) : Int {        val some_larger = someTwo(highs, other.lows, {x: Int, y:Int -> x > y})        val some_smaller = someTwo(lows, other.highs, {x: Int, y:Int -> x < y})        //val some_larger = (highs zip other.lows).any {it.first > it.second}        //val some_smaller = (lows zip other.highs).any {it.first < it.second}        return if (some_larger && some_smaller) {            //debug(""equal"", this, other)            0        } else if (some_larger) {            //debug(""larger"", this, other)            1        } else {            //debug(""smaller"", this, other)            -1        }    }}  fun main(args: Array<String>) {    if (args.size > 0 && args[0] == ""-d"") {        _debug = true;    }     var groups = mutableListOf<Group>()     val (numTournaments, numSports) = readLine()!!.split(' ').map(String::toLong)     for (i in 1..numTournaments) {        val strengths = readLine()!!.split(' ').map(String::toInt).toIntArray()        val grp = Group(strengths, strengths, 1)         if (groups.size == 0) {            groups.add(grp)            println(1)            debug(""init"")            continue        }         val i0 = lowerBoundShort(groups, grp)        var i1 = upperBoundShort(groups, grp)         //debug(""is"", i0, i1, ""grp"", grp)        val merged_groups = groups.subList(i0, i1).fold(grp) {sum, el -> sum + el}         //val merged_groups = if (i0 < i1) merge(groups.subList(i0, i1), grp) else grp//        while (i0 < i1) {//            //merged_groups += groups[i0]//            groups.removeAt(i1-1)//            i1 -= 1//        }        groups.subList(i0, i1).clear()        groups.add(i0, merged_groups)         //val pre_groups = groups.subList(0, i0)        //val post_groups = groups.subList(i1, groups.size)         //groups = pre_groups + merged_groups + post_groups        //debug(""merged"",pre_groups, merged_groups, post_groups, groups)        println(groups.last().size)    }}","data structures,graphs"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007L data class Contestant(val v: Long, val cnt: Long)class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  fun solve() {    val N = ni()    val S = nl()     var sum = 0L    val C = MutableList(N){      val s = nl()      val a = nl()      val b = nl()      sum += a * s      Contestant(b - a, s)    }     val lst = C.map{it.cnt}.sum() % S    debug{""sum:$sum all:${C.map{it.cnt}.sum()} lst:$lst""}     if (lst > 0) C += Contestant(0, S - lst)     C.sortBy { - it.v }    debug{C.joinToString("" "")}     var ans = sum    var eaten = 0L    var toGain = 0L    for (i in C) {      var cnt = i.cnt       fun eatUntil(a: Long) {        if (eaten < a  && cnt >= a - eaten) {          val eat = a - eaten          sum += toGain + eat * i.v          ans = max(sum, ans)          eaten = 0          toGain = 0          cnt -= eat          debug{""eat($a) $toGain $eaten $sum""}        }      }       eatUntil(S)       if (eaten == 0L) {        val c = cnt / S        sum += c * S * i.v        ans = max(sum, ans)        cnt -= c * S      }       if (cnt > 0) {        eaten += cnt        toGain += cnt * i.v      }       debug{""$toGain $eaten $sum""}    }    out.println(ans)  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private val reader = BufferedReader(InputStreamReader(stream), 32768)  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return map(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun map(n: Int, f: (Int) -> Int): IntArray {    val res = IntArray(n)    for (i in 0 until n) {      res[i] = f(i)    }    return res  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: BooleanArray) {    debug { a.map { if (it) 1 else 0 }.joinToString("""") }  }   private fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","binary search,sortings,ternary search"
"import kotlin.math.abs fun main() {    val r = System.`in`.bufferedReader()    val sb = StringBuilder()    val n = r.readLine().toInt()    val visited = BooleanArray(n){false}    val adj = List(n) { mutableListOf<Int>() }    var odd = 0L    var even = 0L    fun dfs(i:Int, thisisodd:Boolean){        visited[i] = true        if (thisisodd) odd++        else even++        for (neigh in adj[i]){            if (!visited[neigh]){                dfs(neigh, !thisisodd)            }        }    }    when {        n <= 3 -> {            repeat(n - 1) {                r.readLine()            }            sb.appendln(0)        }        else -> {            repeat(n - 1) {                val (a, b) = r.readLine().split("" "").map { it.toInt()-1 }                adj[a]+=b                adj[b]+=a            }            dfs(0, true)            sb.appendln(odd*even-(n-1))        }    }    print(sb)}","dfs and similar,graphs,trees"
"import java.util.* fun main() {    fun readInt() = readLine()!!.toInt()    fun readLong() = readLine()!!.toLong()    fun readInts() = readLine()!!.split("" "").map(String::toInt)    fun readLongs() = readLine()!!.split("" "").map(String::toLong)     val left = mutableSetOf<Int>()    val right = mutableSetOf<Int>()    val toDo = mutableMapOf<Int, MutableList<Int>>()    val orderQueue = ArrayDeque<Int>()    val numNodes = readInt()    val (u, v) = readInts()    left.add(u)    right.add(v)    repeat(numNodes - 2) {        val (u, v) = readInts()        when {            u in left -> {                right.add(v)                if (v in toDo) orderQueue.add(v)            }            u in right -> {                left.add(v)                if (v in toDo) orderQueue.add(v)            }            v in left -> {                right.add(u)                if (u in toDo) orderQueue.add(u)            }            v in right -> {                left.add(u)                if (u in toDo) orderQueue.add(u)            }            else -> {                toDo.getOrPut(u) { mutableListOf() }.add(v)                toDo.getOrPut(v) { mutableListOf() }.add(u)            }        }    }     while (orderQueue.isNotEmpty()) {        val current = orderQueue.poll()        val correctSet = if (current in left) right else left        if (current in toDo) {            toDo[current]!!.forEach {                correctSet.add(it)                if (it in toDo) orderQueue.add(it)            }            toDo.remove(current)        }    }     print(left.size.toLong() * right.size.toLong() - numNodes + 1)}","dfs and similar,graphs,trees"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.io.PrintWriterimport java.lang.StringBuilderimport java.util.* class UnionFind(n: Int) {    private val rank = IntArray(n) { 0 }    private val parent = IntArray(n) { -1 }     fun find(x: Int): Int {        if (parent[x] < 0) {            return x        }        parent[x] = find(parent[x])        return parent[x]    }     fun unite(x: Int, y: Int) {        val x1 = find(x)        val y1 = find(y)        if (x1 == y1) {            return        }        if (rank[x1] < rank[y1]) {            parent[y1] += parent[x1]            parent[x1] = y1        } else {            parent[x1] += parent[y1]            parent[y1] = x1            if (rank[x1] == rank[y1]) {                rank[x1]++            }        }    }     fun same(x: Int, y: Int): Boolean {        return find(x) == find(y)    }     fun size(x: Int): Int {        return -parent[find(x)]    }} fun PrintWriter.solve(sc: FastScanner) {    val n = sc.nextInt()    val adj = Array(n) { mutableSetOf<Int>() }    for (i in 0 until n - 1) {        val u = sc.nextInt() - 1        val v = sc.nextInt() - 1        adj[u].add(v)        adj[v].add(u)    }    val que: Queue<Pair<Int, Int>> = ArrayDeque()    que.add(0 to 0)    val visited = Array(n) { false }    visited[0] = true    var side0 = 0L    var side1 = 0L    while (que.count() > 0) {        val (v, step) = que.poll()        if (step % 2 == 0) {            side0++        } else {            side1++        }        for (w in adj[v]) {            if (!visited[w]) {                visited[w] = true                que.add(w to step + 1)            }        }    }    println(side0 * side1 - n + 1)} fun main(args: Array<String>) {    val writer = PrintWriter(System.out, false)    writer.solve(FastScanner(System.`in`))    writer.flush()} class FastScanner(s: InputStream) {    private var st = StringTokenizer("""")    private val br = BufferedReader(InputStreamReader(s))     fun next(): String {        while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun nextInt() = next().toInt()    fun nextLong() = next().toLong()    fun nextLine() = br.readLine()    fun nextDouble() = next().toDouble()    fun ready() = br.ready()}","dfs and similar,graphs,trees"
"import java.io.*import java.util.*import kotlin.math.* val INPUT = System.`in`!!val OUTPUT = System.out!!const val mod = 1_000_000_007Lconst val mini = Int.MIN_VALUEconst val maxi = Int.MAX_VALUEconst val yes = ""YES""const val no = ""NO""val reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun line() = reader.readLine()!!var tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (tokenizer.hasMoreTokens().not()) tokenizer = StringTokenizer(reader.readLine() ?: return """", "" "")    return tokenizer.nextToken()}fun sort(a: IntArray) {    val l = ArrayList<Int>()    for (value in a) {        l.add(value)    }    l.sort()    for (i in l.indices) a[i] = l[i]}fun sort(a: LongArray) {    val l = ArrayList<Long>()    for (value in a) {        l.add(value)    }    l.sort()    for (i in l.indices) a[i] = l[i]}fun int() = read().toInt()fun double() = read().toDouble()fun long() = read().toLong()fun strings(n: Int) = List(n) { read() }fun lines(n: Int) = List(n) { line() }fun ints(n: Int) = List(n) { read().toInt() }fun intArray(n: Int) = IntArray(n) { read().toInt() }fun doubles(n: Int) = List(n) { read().toDouble() }fun doubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun longs(n: Int) = List(n) { read().toLong() }fun longArray(n: Int) = LongArray(n) { read().toLong() }val writer = PrintWriter(OUTPUT, true)fun main() { writer.solve(); writer.flush() }fun gcd(a: Long, b: Long): Long {    if (b == 0L) return a    return gcd(b, a % b)}fun ceil(a: Long, b: Long): Long {    return if (a % b == 0L) a / b else (a / b) + 1}class Pair(var x: Int, var cost: Int)fun dfs(arr : Array<ArrayList<Int>>, hash : BooleanArray, type : BooleanArray, x : Int, flag : Boolean) {    if(hash[x]) return    hash[x] = true    for(i in arr[x]) {        type[i] = flag        dfs(arr, hash, type, i, !flag)    }}// Your approach might be wrong, are you sure you can extend it for// bigger test cases// Try some other approach// Don't get stuck on one approach// Don't overcomplicate stuff// Don't overcomplicate stufffun PrintWriter.solve() {    // var tt = int()    var tt = 1    while (tt-- > 0) {        val n = int()        val arr = Array(n + 1) { ArrayList<Int>() }        val hash = BooleanArray(n + 1)        val type = BooleanArray(n + 1)        repeat(n - 1) {            val (u, v) = ints(2)            arr[u].add(v)            arr[v].add(u)        }        dfs(arr, hash, type, 1, true)        var white = 0        var count = 0L        for(i in type) if(i) white++        for(i in 1..n) {            if(!type[i]) {                count += (white - arr[i].size)            }        }        println(count)    }}","dfs and similar,graphs,trees"
"data class Dancer(val x0: Int, val y0: Int, val t: Int, val pos: Int) {    init {        require((x0 == 0) != (y0 == 0))    }    val potential: Int = x0 + y0 - t    val vertical: Boolean = x0 == 0} data class Point(val x: Int, val y: Int) fun solve(n: Int, w: Int, h: Int, dancers: List<Dancer>): List<Point> {    val ans = Array<Point?>(n, { null })     val groupsByPotential: Map<Int, List<Dancer>> = dancers.groupBy { dancer -> dancer.potential }    groupsByPotential.values.forEach({ group ->        val curDancers: List<Dancer> = group.sortedBy { dancer ->  dancer.x0 - dancer.y0 }        val resPoints = curDancers.map { dancer ->            when (dancer.vertical) {                true  -> Point(w, dancer.y0)                false -> Point(dancer.x0, h)            }        }.sortedWith(compareBy<Point>{ p -> p.x }.thenBy { p -> -p.y} )        curDancers.zip(resPoints, {dancer, point ->            ans[dancer.pos] = point            kotlin.Unit        })    })    return ans.map { point -> point!! }} fun main(args: Array<String>) {    val (n: Int, w: Int, h: Int) = readLine()!!.split("" "").map(String::toInt)    val dancers: List<Dancer> = (0 until n).map { i ->        val (g: Int, p: Int, t: Int) =  readLine()!!.split("" "").map(String::toInt)        val (x, y) = when(g) {            1 -> Pair(p, 0)            2 -> Pair(0, p)            else -> throw RuntimeException(""g=${g} not in {1, 2}"")        }        Dancer(x, y, t, i)    }.toList()    val res: List<Point> = solve(n, w, h, dancers)    res.forEach { point -> println(""${point.x} ${point.y}"") }}","constructive algorithms,data structures,geometry,implementation,sortings,two pointers"
"data class Dancer(val x0: Int, val y0: Int, val t: Int, val pos: Int) {    init {        require((x0 == 0) != (y0 == 0))    }    val potential: Int = x0 + y0 - t    val vertical: Boolean = x0 == 0} data class Point(val x: Int, val y: Int) fun solve(n: Int, w: Int, h: Int, dancers: List<Dancer>): List<Point> {    val ans = Array<Point?>(n, { null })     val groupsByPotential: Map<Int, List<Dancer>> = dancers.groupBy { dancer -> dancer.potential }    groupsByPotential.values.forEach({ group ->        val curDancers: List<Dancer> = group.sortedBy { dancer ->  dancer.x0 - dancer.y0 }                val resPoints = curDancers.map { dancer ->            when (dancer.vertical) {                true  -> Point(w, dancer.y0)                false -> Point(dancer.x0, h)            }        }.sortedWith(compareBy<Point>{ p -> p.x }.thenByDescending { p -> p.y})                curDancers.zip(resPoints, {dancer, point ->            ans[dancer.pos] = point            kotlin.Unit        })    })    return ans.map { point -> point!! }} fun main(args: Array<String>) {    val (n: Int, w: Int, h: Int) = readLine()!!.split("" "").map(String::toInt)    val dancers: List<Dancer> = (0 until n).map { i ->        val (g: Int, p: Int, t: Int) =  readLine()!!.split("" "").map(String::toInt)        val (x, y) = when(g) {            1 -> Pair(p, 0)            2 -> Pair(0, p)            else -> throw RuntimeException(""g=${g} not in {1, 2}"")        }        Dancer(x, y, t, i)    }.toList()    val res: List<Point> = solve(n, w, h, dancers)    res.forEach { point -> println(""${point.x} ${point.y}"") }}","constructive algorithms,data structures,geometry,implementation,sortings,two pointers"
"data class Dancer(val x0: Int, val y0: Int, val t: Int, val pos: Int) {    init {        require((x0 == 0) != (y0 == 0))    }     val potential: Int = x0 + y0 - t    val vertical: Boolean = x0 == 0} data class Point(val x: Int, val y: Int, val pos: Int) fun solve(w: Int, h: Int, dancers: List<Dancer>): List<Point> {    val groupsByPotential: Map<Int, List<Dancer>> = dancers.groupBy { dancer -> dancer.potential }     return groupsByPotential.values.flatMap { group ->        val curDancers: List<Dancer> = group                .sortedWith(compareBy<Dancer> { dancer -> dancer.x0 }.thenByDescending { dancer -> dancer.y0 })         val resPoints = curDancers.map { dancer ->            when (dancer.vertical) {                true -> Point(w, dancer.y0, dancer.pos)                false -> Point(dancer.x0, h, dancer.pos)            }        }.sortedWith(compareBy<Point> { p -> p.x }.thenByDescending { p -> p.y })         curDancers.zip(resPoints, { dancer, point -> Point(point.x, point.y, dancer.pos) })    }.sortedBy { point -> point.pos }} fun main(args: Array<String>) {    val (n: Int, w: Int, h: Int) = readLine()!!.split("" "").map(String::toInt)    val dancers: List<Dancer> = (0 until n).map { i ->        val (g: Int, p: Int, t: Int) = readLine()!!.split("" "").map(String::toInt)        val (x, y) = when (g) {            1 -> Pair(p, 0)            2 -> Pair(0, p)            else -> throw RuntimeException(""g=${g} isn't in {1, 2}"")        }        Dancer(x, y, t, i)    }.toList()    val res: List<Point> = solve(w, h, dancers)    res.forEach { point -> println(""${point.x} ${point.y}"") }}","constructive algorithms,data structures,geometry,implementation,sortings,two pointers"
"data class Dancer(val x0: Int, val y0: Int, val t: Int, val pos: Int) {    init {        require((x0 == 0) != (y0 == 0))    }    val potential: Int = x0 + y0 - t    val vertical: Boolean = x0 == 0} data class Point(val x: Int, val y: Int, val pos: Int) fun solve(w: Int, h: Int, dancers: List<Dancer>): List<Point> {    val groupsByPotential: Map<Int, List<Dancer>> = dancers.groupBy { dancer -> dancer.potential }     return groupsByPotential.values.flatMap { group ->        val curDancers: List<Dancer> = group                .sortedWith(compareBy<Dancer> { dancer ->  dancer.x0 } .thenByDescending { dancer -> dancer.y0 })         val resPoints = curDancers.map { dancer ->            when (dancer.vertical) {                true  -> Point(w, dancer.y0, dancer.pos)                false -> Point(dancer.x0, h, dancer.pos)            }        }.sortedWith(compareBy<Point> { p -> p.x } .thenByDescending { p -> p.y})         curDancers.zip(resPoints, {dancer, point ->            Point(point.x, point.y, dancer.pos)        })    } .sortedBy { point -> point.pos }} fun main(args: Array<String>) {    val (n: Int, w: Int, h: Int) = readLine()!!.split("" "").map(String::toInt)    val dancers: List<Dancer> = (0 until n).map { i ->        val (g: Int, p: Int, t: Int) =  readLine()!!.split("" "").map(String::toInt)        val (x, y) = when(g) {            1 -> Pair(p, 0)            2 -> Pair(0, p)            else -> throw RuntimeException(""g=${g} not in {1, 2}"")        }        Dancer(x, y, t, i)    }.toList()    val res: List<Point> = solve(w, h, dancers)    res.forEach { point -> println(""${point.x} ${point.y}"") }}","constructive algorithms,data structures,geometry,implementation,sortings,two pointers"
"fun readB() {    val (n, k, m) = readLine()!!.split("" "").map { it.toInt() }    val times = readLine()!!.split("" "").map { it.toInt() }    val res = solveB(n, m, times)    println(res)} fun solveB(n: Int, m: Int, timesRaw: List<Int>): Int {    val times = timesRaw.sorted()    val fullTaskTime = times.sum()    val fullTaskScore = times.size + 1    return (0..n).map { fullTasksCount ->        val timeForFullTasks = fullTaskTime * fullTasksCount        var timeLeft = m - timeForFullTasks        var score = fullTasksCount * fullTaskScore        if (timeLeft < 0) {            0        } else {            val tasksLeft = n - fullTasksCount            var currentSubTask = 0            outer@ while (currentSubTask < times.size) {                var currentTask = 0                while (currentTask < tasksLeft) {                    val timeSpent = times[currentSubTask]                    val scoreToAdd = if (currentSubTask == times.size - 1) 2 else 1                    if (timeSpent <= timeLeft) {                        score += scoreToAdd                        timeLeft -= timeSpent                    } else {                        break@outer                    }                    currentTask++                }                currentSubTask++            }            score        }    }.max()!!} fun main(args: Array<String>) {    readB()} ","brute force,greedy"
"import kotlin.math.max fun main() {    val s = readLine()!!    val k = readLine()!!.toInt()    print(if (k > s.length) ""impossible"" else max(0, k - s.toSet().size))}","greedy,implementation,strings"
"fun main() {    val input = readLine()!!    val size = input.toCharArray().distinct().size    val desired = readLine()!!.toInt()    if (desired > input.length) {        println(""impossible"")    } else {        val ans = (desired - size).coerceAtLeast(0)        println(ans)    }}","greedy,implementation,strings"
"fun main() {    var str = readLine()!!    var n = readLine()!!.toInt()     if (str.length>=n){        var set = HashSet<Char>()        for (i in str){            set.add(i)        }        if (set.size>=n){            println(0)        }else{            println(n-set.size)        }    }else{        println(""impossible"")    } }","greedy,implementation,strings"
"import java.util.Scanner val checker: (String, Int) -> Boolean = {str, int -> str.length < int}val diffvals= {str:String -> str.chars().distinct().count()} fun main(args: Array<String>) {    val inp = Scanner(System.`in`)    var word = inp.next()    var diffs = inp.nextInt()        if(checker(word, diffs)) {        println(""impossible"")    } else {        var result = if(diffs - diffvals(word)< 0) 0 else (diffs - diffvals(word))        println(""$result"")    }}","greedy,implementation,strings"
"import java.util.* fun main(vararg args: String) {     // polyfill for Kotlin 1.0    fun <T> T.takeIf(predicate: (T) -> Boolean): T? = if (predicate(this)) this else null    fun Long.coerceAtMost(value: Long?) = if (value != null && this > value) value else this    fun Long.coerceAtLeast(value: Long?) = if (value != null && this < value) value else this     // TODO: SO    fun <T, R> Collection<T>.mapPairs(transform: (T, T) -> R): List<R> {        if (size <= 1) return emptyList()        val r = ArrayList<R>(size - 1)        reduce { a, b -> r += transform(a, b); b }        return r    }     // TODO: implements MutableSet<T>    class RangeSet {        private val map: NavigableMap<Long, LongRange> = TreeMap()         private operator fun NavigableMap<Long, LongRange>.plusAssign(e: LongRange) {            this.put(e.start, e)        }         operator fun plusAssign(r: LongRange) {            val sm = map.subMap(                    map.lowerEntry(r.start)?.value?.takeIf { it.endInclusive >= r.start - 1 }?.start ?: r.start, true,                    r.endInclusive + 1, true)            val nr = r.start.coerceAtMost(sm.firstEntry()?.value?.start)..r.endInclusive.coerceAtLeast(sm.lastEntry()?.value?.endInclusive)            sm.clear()            map += nr        }         operator fun minusAssign(r: LongRange) {            val sm = map.subMap(                    map.lowerEntry(r.start)?.value?.takeIf { it.endInclusive >= r.start }?.start ?: r.start, true,                    r.endInclusive, true)            val f = sm.firstEntry()?.value            val l = sm.lastEntry()?.value            sm.clear()            if (f != null && f.start < r.start) map += f.start until r.start            if (l != null && r.endInclusive < l.endInclusive) map += r.endInclusive.inc()..l.endInclusive        }         operator fun timesAssign(r: LongRange) {            val sm = map.subMap(                    map.lowerEntry(r.start)?.value?.takeIf { it.endInclusive >= r.start - 1 }?.start ?: r.start, true,                    r.endInclusive + 1, true)            var nr = sm.values.mapPairs { a, b -> a.endInclusive + 1 until b.start }            val aux = mutableListOf<LongRange>()            val f = sm.firstEntry()?.value            when {                f == null -> null                f.endInclusive == r.start - 1 -> {                    aux += f.start.rangeTo(sm.higherEntry(r.start)?.value?.start?.dec() ?: r.endInclusive)                    if (nr.isNotEmpty()) nr = nr.subList(1, nr.size)                }                f.start < r.start -> {                    aux += f.start until r.start                }                f.start in r.start.inc()..r.endInclusive -> {                    aux += r.start until f.start                }            }            val l = sm.lastEntry()?.value            when {                l == null -> null                l.start == r.endInclusive + 1 -> {                    aux += (sm.lowerEntry(r.endInclusive)?.value?.endInclusive?.inc() ?: r.start).rangeTo(l.endInclusive)                    if (nr.isNotEmpty()) nr = nr.subList(0, nr.size - 1)                }                l.endInclusive > r.endInclusive -> {                    aux += r.endInclusive.inc().rangeTo(l.endInclusive)                }                l.endInclusive in r.start until r.endInclusive -> {                    aux += l.endInclusive.inc().rangeTo(r.endInclusive)                }            }            if (f == null && l == null) aux += r            sm.clear()            nr.forEach {                 map += it            }            aux.forEach {                map += it            }        }         fun mex() = map.firstEntry()?.value.let { if (it != null && it.start == 1L) it.endInclusive + 1 else 1 }         override fun toString() = map.values.joinToString()    }     with(Scanner(System.`in`)) {        val n = nextInt()        val s = RangeSet()        repeat(n) {            val op = nextInt()            val lr = nextLong()..nextLong()            when (op) {                1 -> s += lr                2 -> s -= lr                3 -> s *= lr            }//            println(s)            println(s.mex())        }    }}  ","binary search,data structures,trees"
"fun main(args: Array<String>) {	val (l,r) = readLine()!!.split(' ').map(String::toInt)		val res = if ( r==l) l else 2;	println(res)	}","greedy,math"
"fun main(args: Array<String>) {    val (l, r) = readLine()!!.split(' ').map(String::toInt)    if (l == r)        print(""$l\n"")    else        print(""2\n"")}","greedy,math"
import java.util.* fun main(args: Array<String>){    var sc = Scanner(System.`in`)    var l = sc.nextInt()    var r = sc.nextInt()    println(if(l == r) l else 2)},"greedy,math"
"import kotlin.math.abs fun main() {    var (l, r) = readLine()!!.split(' ').map { it.toInt() }    if (abs(l-r)==0){        println(l)    }else{        println(2)    }}","greedy,math"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"")@file:OptIn(ExperimentalUnsignedTypes::class, ExperimentalStdlibApi::class) import java.io.PrintWriterimport kotlin.math.*import kotlin.random.Randomimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {//    val startTime = System.nanoTime()     val numCases = 1//readInt()    case@ for(case in 1..numCases) {        //print(""Case #$case: "")         val n = readInt()         val G = Array(n) { IntList() }        val V = ModIntArray(n)        repeat(n-1) {            val u = readInt()            val v = readInt()            val c = readInt()             G[u].add(v)            V[u] = V[u] + c            G[v].add(u)            V[v] = V[v] + c        }         val S = ModIntArray(IntArray(n) { G[it].size })         val par = IntArray(n)         val stk = intListOf(0)         while(stk.isNotEmpty()) {            var u = stk.pop()             if(u >= 0) {                stk.add(u.inv())                val g = G[u]                 for(v in g) if(par[u] != v) {                    par[v] = u                    stk.add(v)                }            } else {                u = u.inv()                val g = G[u]                 if(g.size == 1) {                    V[u] = ModInt(0)                } else {                    val d = S[u].inverse()                    V[u] *= d                     if(u != 0) {                        val v = par[u]                         S[v] -= d                        V[v] += V[u]                    }                }            }        }         val ans = V[0]        println(ans.int)    } //    iprintln(""Time: ${(System.nanoTime() - startTime) / 1000000} ms"")} const val BILLION7 = 1e9.toInt() + 7const val MOD = BILLION7const val TOTIENT = MOD - 1 // assumes MOD is prime infix fun Int.modulo(mod: Int): Int = (this % mod).let { (it shr Int.SIZE_BITS - 1 and mod) + it }infix fun Long.modulo(mod: Long) = (this % mod).let { (it shr Long.SIZE_BITS - 1 and mod) + it }infix fun Long.modulo(mod: Int) = modulo(mod.toLong()).toInt() fun Int.mulMod(other: Int, mod: Int) = toLong() * other modulo mod fun Int.powMod(exponent: Long, mod: Int): Int {    if(exponent < 0) error(""Inverse not implemented"")    var res = 1L    var e = exponent    var b = modulo(mod).toLong()     while(e > 0) {        if(e and 1 == 1L) {            res = res * b % mod        }        e = e shr 1        b = b * b % mod    }    return res.toInt()}fun Int.powMod(exponent: Int, mod: Int) = powMod(exponent.toLong(), mod)fun Int.modPowArray(n: Int, mod: Int): IntArray {    val res = IntArray(n+1)    res[0] = 1    for(i in 1..n) res[i] = mulMod(res[i-1], mod)    return res} inline fun Int.toModInt() = ModInt(this modulo MOD)inline fun Long.toModInt() = ModInt(this modulo MOD) /** note: Only use constructor for int within modulo range, otherwise use toModInt **/inline class ModInt(val int: Int) {    companion object {        /** can't seem to make these private or inlined without causing compiler issues */        @JvmField val _invMemo = HashMap<ModInt, ModInt>()        fun _invMemoized(m: ModInt) = _invMemo.getOrPut(m) { m.inv_unmemoized() }    }     // normalizes an integer that's within range [-MOD, MOD) without branching    private inline fun normalize(int: Int) = ModInt((int shr Int.SIZE_BITS - 1 and MOD) + int)     operator fun plus(other: ModInt) = normalize(int + other.int - MOD) // overflow-safe even if MOD >= 2^30    inline operator fun plus(other: Int) = plus(other.toModInt())    operator fun inc() = normalize(int + (1 - MOD))     operator fun minus(other: ModInt) = normalize(int - other.int)    inline operator fun minus(other: Int) = minus(other.toModInt())    operator fun dec() = normalize(int - 1)    operator fun unaryMinus() = normalize(-int)     operator fun times(other: ModInt) = ModInt((int.toLong() * other.int % MOD).toInt())    inline operator fun times(other: Int) = ModInt(int.mulMod(other, MOD))     fun pow(exponent: Int): ModInt {        val e = if(exponent < 0) {            require(int != 0) { ""Can't invert/divide by 0"" }            exponent modulo TOTIENT        } else exponent        return ModInt(int.powMod(e, MOD))    }     fun pow(exponent: Long) = if(int == 0) when {        exponent > 0 -> this        exponent == 0L -> ModInt(1)        else -> error(""Can't invert/divide by 0"")    } else pow(exponent modulo TOTIENT)     inline fun inverse() = inv_unmemoized() /** NOTE: Change if necessary */     fun inv_unmemoized(): ModInt {        require(int != 0) { ""Can't invert/divide by 0"" }        return pow(TOTIENT - 1)    }    inline fun inv_memoized() = _invMemoized(this)     operator fun div(other: ModInt) = times(other.inverse())    inline operator fun div(other: Int) = div(other.toModInt())     override inline fun toString() = int.toString()} inline operator fun Int.plus(modInt: ModInt) = modInt + thisinline operator fun Int.minus(modInt: ModInt) = toModInt() - modIntinline operator fun Int.times(modInt: ModInt) = modInt * thisinline operator fun Int.div(modInt: ModInt) = modInt.inverse() * this inline class ModIntArray(val intArray: IntArray): Collection<ModInt> {    inline operator fun get(i: Int) = ModInt(intArray[i])    inline operator fun set(i: Int, v: ModInt) { intArray[i] = v.int }     override inline val size: Int get() = intArray.size    inline val lastIndex get() = intArray.lastIndex    inline val indices get() = intArray.indices     override inline fun contains(element: ModInt): Boolean = element.int in intArray     override fun containsAll(elements: Collection<ModInt>): Boolean = elements.all(::contains)     override inline fun isEmpty(): Boolean = intArray.isEmpty()     override fun iterator(): Iterator<ModInt> = object: Iterator<ModInt> {        var index = 0        override fun hasNext(): Boolean = index < size        override fun next(): ModInt = get(index++)    }     fun copyOf(newSize: Int) = ModIntArray(intArray.copyOf(newSize))    fun copyOf() = copyOf(size)}fun ModIntArray.copyInto(destination: ModIntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size) =    ModIntArray(intArray.copyInto(destination.intArray, destinationOffset, startIndex, endIndex))inline fun ModIntArray(size: Int) = ModIntArray(IntArray(size))inline fun ModIntArray(size: Int, init: (Int) -> ModInt) = ModIntArray(IntArray(size) { init(it).int }) fun ModInt.powArray(n: Int) = ModIntArray(int.modPowArray(n, MOD)) inline fun ModIntArray.first() = get(0)inline fun ModIntArray.last() = get(lastIndex)inline fun ModIntArray.joinToString(separator: CharSequence) = intArray.joinToString(separator)inline fun <R> ModIntArray.fold(init: R, op: (acc: R, ModInt) -> R) = intArray.fold(init) { acc, i -> op(acc, ModInt(i)) }inline fun <R> ModIntArray.foldRight(init: R, op: (ModInt, acc: R) -> R) = intArray.foldRight(init) { i, acc -> op(ModInt(i), acc) }fun ModIntArray.sum() = fold(ModInt(0), ModInt::plus)fun ModIntArray.product() = fold(ModInt(1), ModInt::times) inline fun <T> Iterable<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Iterable<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }inline fun <T> Sequence<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Sequence<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }inline fun <T> Array<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Array<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }fun Iterable<ModInt>.sum() = sumByModInt { it }fun Sequence<ModInt>.sum() = sumByModInt { it }fun Iterable<ModInt>.product() = productByModInt { it }fun Sequence<ModInt>.product() = productByModInt { it }fun Collection<ModInt>.toModIntArray() = ModIntArray(size).also { var i = 0; for(e in this) { it[i++] = e } } class IntList(initialCapacity: Int = 12) {    private var arr = IntArray(initialCapacity)    val _arr get() = arr    private val capacity get() = arr.size    var size = 0        private set    inline val lastIndex get() = size - 1    inline val indices get() = 0 until size     constructor(copyFrom: IntArray): this(copyFrom.size) { copyFrom.copyInto(arr); size = copyFrom.size }    constructor(copyFrom: Collection<Int>): this(copyFrom.size) { arr = copyFrom.toIntArray(); size = copyFrom.size }     fun contentEquals(other: IntList): Boolean {        return this === other || size == other.size && indices.all { this[it] == other[it] }    }     private fun grow(minCapacity: Int = 8) {        val newCapacity = maxOf(minCapacity, capacity + (capacity shr 1))        arr = arr.copyOf(newCapacity)    }     fun ensureCapacity(minCapacity: Int) { if(capacity < minCapacity) grow(minCapacity) }     operator fun get(index: Int): Int {        require(index in 0 until size)        return arr[index]    }     operator fun set(index: Int, value: Int) {        require(index in 0 until size)        arr[index] = value    }     fun add(value: Int) {        if(size == capacity) grow()        arr[size++] = value    }     fun addAll(list: IntList) {        ensureCapacity(size + list.size)        list.arr.copyInto(arr, size, 0, list.size)        size += list.size    }     fun add(index: Int, element: Int) {        if(size == capacity) grow()        arr.copyInto(arr, index + 1, index, size)        size++        set(index, element)    }     fun clear() { size = 0 }     fun removeAt(index: Int): Int {        val e = get(index)        arr.copyInto(arr, index, index + 1, size)        size--        return e    }     fun indexOf(e: Int): Int {        for(i in 0 until size) if(this[i] == e) return i        return -1    }     fun remove(e: Int): Boolean {        val i = indexOf(e)        if(i == -1) return false        removeAt(i)        return true    }     operator fun iterator() = object: IntIterator() {        private var pos = 0        override fun hasNext() = pos < size        override fun nextInt() = get(pos++)    }     inline fun isEmpty() = size == 0    inline fun isNotEmpty() = size != 0     fun pop() = arr[--size]     fun popToSize(s: Int) {        require(s >= 0)        if(s < size) size = s    }     fun swap(i: Int, j: Int) { val t = this[i]; this[i] = this[j]; this[j] = t }    fun reverse() {        for(i in 0 until size / 2) swap(i, lastIndex - i)    }     fun shuffle(rnd: Random = random) { for(i in lastIndex downTo 1) swap(i, rnd.nextInt(i+1)) }     inline fun sortWith(cmp: (Int, Int) -> Int) { _mergeSort(_arr, size, IntArray(size), IntArray::get, IntArray::set, cmp) }    inline fun <T: Comparable<T>> sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }    inline fun <T: Comparable<T>> sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }    fun sort() { sortBy { it } }    fun sortDescending() { sortByDescending { it } }     fun joinToString(separator: CharSequence) = if(size == 0) """" else let {        buildString {            append(it[0])            for (i in 1 until size) {                append(separator).append(it[i])            }        }    }     override fun toString() = ""["" + joinToString("", "") + ""]""     fun toIntArray() = arr.copyOf(size)    fun toList() = List(size, ::get)     inline fun first() = get(0)    inline fun last() = get(lastIndex)} inline fun IntList(size: Int, init: (Int) -> Int) = IntList(size).apply {    for(i in 0 until size) { add(init(i)) }}inline fun IntArray.toIntList() = IntList(this)inline fun Collection<Int>.toIntList() = IntList(this)inline fun intListOf(vararg values: Int) = IntList(values) fun IntList.max() = (1 until size).fold(this[0]) { acc, i -> max(acc, this[i]) }fun IntList.min() = (1 until size).fold(this[0]) { acc, i -> min(acc, this[i]) }fun IntList.getOrNull(i: Int) = if(i in indices) get(i) else nullinline fun IntList.count(predicate: (Int) -> Boolean) = indices.count { predicate(this[it]) }fun IntList.copyOf() = IntList(size, ::get)  /** IO *///@JvmField val ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null//const val PATH = ""src/main/resources/""//@JvmField val INPUT = File(PATH + ""input.txt"").inputStream()//@JvmField val OUTPUT = File(PATH + ""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar() else c    }} /** @param skipNext Whether to skip the next character (usually whitespace), defaults to true */fun readCharArray(n: Int, skipNext: Boolean = true): CharArray {    val res = CharArray(n) { readChar() }    if(skipNext) readChar()    return res} fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(c != '\n' && c != Char.MIN_VALUE) {            append(c)            c = readChar()        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /**  sort overrides to avoid quicksort attacks */ @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } inline fun <A, T> _mergeSort(a0: A, n: Int, tmp0: A, get: A.(Int) -> T, set: A.(Int, T) -> Unit, cmp: (T, T) -> Int) {    var a = a0    var tmp = tmp0    var len = 1    while(len < n) {        var l = 0        while(true) {            val m = l + len            if(m >= n) break            val r = min(n, m + len)            var i = l            var j = m            for(k in l until r) {                if(i != m && (j == r || cmp(a.get(i), a.get(j)) <= 0)) {                    tmp.set(k, a.get(i++))                } else tmp.set(k, a.get(j++))            }            l = r        }        for(i in l until n) tmp.set(i, a.get(i))        val t = a; a = tmp; tmp = t        len += len    }    if(a !== a0) for(i in 0 until n) a0.set(i, tmp0.get(i))} inline fun IntArray.sortWith(cmp: (Int, Int) -> Int) { _mergeSort(this, size, IntArray(size), IntArray::get, IntArray::set, cmp) }inline fun <T: Comparable<T>> IntArray.sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> IntArray.sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun IntArray.sort() { sortBy { it } }fun IntArray.sortDescending() { sortByDescending { it } } inline fun LongArray.sortWith(cmp: (Long, Long) -> Int) { _mergeSort(this, size, LongArray(size), LongArray::get, LongArray::set, cmp) }inline fun <T: Comparable<T>> LongArray.sortBy(func: (Long) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> LongArray.sortByDescending(func: (Long) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun LongArray.sort() { sortBy { it } }fun LongArray.sortDescending() { sortByDescending { it } } inline fun DoubleArray.sortWith(cmp: (Double, Double) -> Int) { _mergeSort(this, size, DoubleArray(size), DoubleArray::get, DoubleArray::set, cmp) }inline fun <T: Comparable<T>> DoubleArray.sortBy(func: (Double) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> DoubleArray.sortByDescending(func: (Double) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun DoubleArray.sort() { sortBy { it } }fun DoubleArray.sortDescending() { sortByDescending { it } } inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T : Comparable<T>> Array<out T>.sort() = _sort()inline fun <T : Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T : Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T : Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() // import preserving junk function@Suppress(""NonAsciiCharacters"") fun 雪花飄飄北風嘯嘯天地一片蒼茫() { iprintln(max(1, 2)) } fun IntArray.sumLong() = sumOf { it.toLong() } fun IntArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun IntArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun LongArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun LongArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun DoubleArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun DoubleArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> Array<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> Array<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> List<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> List<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) } // max/min Kotlin 1.6 -> 1.4 shimfun IntArray.max() = maxOf { it }fun IntArray.min() = minOf { it }fun LongArray.max() = maxOf { it }fun LongArray.min() = minOf { it }fun CharArray.max() = maxOf { it }fun CharArray.min() = minOf { it }fun <T : Comparable<T>> Iterable<T>.max() = maxOf { it }fun <T : Comparable<T>> Iterable<T>.min() = minOf { it }fun <T : Comparable<T>> Sequence<T>.max() = maxOf { it }fun <T : Comparable<T>> Sequence<T>.min() = minOf { it }","dfs and similar,dp,math,trees"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"")@file:OptIn(ExperimentalUnsignedTypes::class, ExperimentalStdlibApi::class) import java.io.PrintWriterimport kotlin.math.*import kotlin.random.Randomimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {//    val startTime = System.nanoTime()     val numCases = 1//readInt()    case@ for(case in 1..numCases) {        //print(""Case #$case: "")         val n = readInt()         val G = Array(n) { IntList() }        val V = ModIntArray(n)        repeat(n-1) {            val u = readInt()            val v = readInt()            val c = readInt()             G[u].add(v)            V[u] = V[u] + c            G[v].add(u)            V[v] = V[v] + c        }         val S = ModIntArray(IntArray(n) { G[it].size })         val par = IntArray(n)         val stk = intListOf(0)         while(stk.isNotEmpty()) {            var u = stk.pop()             if(u >= 0) {                stk.add(u.inv())                val g = G[u]                g.sort()                 for(v in g) if(par[u] != v) {                    par[v] = u                    stk.add(v)                }            } else {                u = u.inv()                val g = G[u]                 if(g.size == 1) {                    V[u] = ModInt(0)                } else {                    val d = S[u].inverse()                    V[u] *= d                     if(u != 0) {                        val v = par[u]                         S[v] -= d                        V[v] += V[u]                    }                }            }        }         val ans = V[0]        println(ans.int)    } //    iprintln(""Time: ${(System.nanoTime() - startTime) / 1000000} ms"")} fun IntList.lowerBound(value: Int): Int {    var bit = Integer.highestOneBit(size)    var pos = 0     while(bit > 0) {        val npos = pos or bit        if(npos <= size && this[npos-1] < value) pos = npos        bit = bit shr 1    }    return pos} const val BILLION7 = 1e9.toInt() + 7const val MOD = BILLION7const val TOTIENT = MOD - 1 // assumes MOD is prime infix fun Int.modulo(mod: Int): Int = (this % mod).let { (it shr Int.SIZE_BITS - 1 and mod) + it }infix fun Long.modulo(mod: Long) = (this % mod).let { (it shr Long.SIZE_BITS - 1 and mod) + it }infix fun Long.modulo(mod: Int) = modulo(mod.toLong()).toInt() fun Int.mulMod(other: Int, mod: Int) = toLong() * other modulo mod fun Int.powMod(exponent: Long, mod: Int): Int {    if(exponent < 0) error(""Inverse not implemented"")    var res = 1L    var e = exponent    var b = modulo(mod).toLong()     while(e > 0) {        if(e and 1 == 1L) {            res = res * b % mod        }        e = e shr 1        b = b * b % mod    }    return res.toInt()}fun Int.powMod(exponent: Int, mod: Int) = powMod(exponent.toLong(), mod)fun Int.modPowArray(n: Int, mod: Int): IntArray {    val res = IntArray(n+1)    res[0] = 1    for(i in 1..n) res[i] = mulMod(res[i-1], mod)    return res} inline fun Int.toModInt() = ModInt(this modulo MOD)inline fun Long.toModInt() = ModInt(this modulo MOD) /** note: Only use constructor for int within modulo range, otherwise use toModInt **/inline class ModInt(val int: Int) {    companion object {        /** can't seem to make these private or inlined without causing compiler issues */        @JvmField val _invMemo = HashMap<ModInt, ModInt>()        fun _invMemoized(m: ModInt) = _invMemo.getOrPut(m) { m.inv_unmemoized() }    }     // normalizes an integer that's within range [-MOD, MOD) without branching    private inline fun normalize(int: Int) = ModInt((int shr Int.SIZE_BITS - 1 and MOD) + int)     operator fun plus(other: ModInt) = normalize(int + other.int - MOD) // overflow-safe even if MOD >= 2^30    inline operator fun plus(other: Int) = plus(other.toModInt())    operator fun inc() = normalize(int + (1 - MOD))     operator fun minus(other: ModInt) = normalize(int - other.int)    inline operator fun minus(other: Int) = minus(other.toModInt())    operator fun dec() = normalize(int - 1)    operator fun unaryMinus() = normalize(-int)     operator fun times(other: ModInt) = ModInt((int.toLong() * other.int % MOD).toInt())    inline operator fun times(other: Int) = ModInt(int.mulMod(other, MOD))     fun pow(exponent: Int): ModInt {        val e = if(exponent < 0) {            require(int != 0) { ""Can't invert/divide by 0"" }            exponent modulo TOTIENT        } else exponent        return ModInt(int.powMod(e, MOD))    }     fun pow(exponent: Long) = if(int == 0) when {        exponent > 0 -> this        exponent == 0L -> ModInt(1)        else -> error(""Can't invert/divide by 0"")    } else pow(exponent modulo TOTIENT)     inline fun inverse() = inv_unmemoized() /** NOTE: Change if necessary */     fun inv_unmemoized(): ModInt {        require(int != 0) { ""Can't invert/divide by 0"" }        return pow(TOTIENT - 1)    }    inline fun inv_memoized() = _invMemoized(this)     operator fun div(other: ModInt) = times(other.inverse())    inline operator fun div(other: Int) = div(other.toModInt())     override inline fun toString() = int.toString()} inline operator fun Int.plus(modInt: ModInt) = modInt + thisinline operator fun Int.minus(modInt: ModInt) = toModInt() - modIntinline operator fun Int.times(modInt: ModInt) = modInt * thisinline operator fun Int.div(modInt: ModInt) = modInt.inverse() * this inline class ModIntArray(val intArray: IntArray): Collection<ModInt> {    inline operator fun get(i: Int) = ModInt(intArray[i])    inline operator fun set(i: Int, v: ModInt) { intArray[i] = v.int }     override inline val size: Int get() = intArray.size    inline val lastIndex get() = intArray.lastIndex    inline val indices get() = intArray.indices     override inline fun contains(element: ModInt): Boolean = element.int in intArray     override fun containsAll(elements: Collection<ModInt>): Boolean = elements.all(::contains)     override inline fun isEmpty(): Boolean = intArray.isEmpty()     override fun iterator(): Iterator<ModInt> = object: Iterator<ModInt> {        var index = 0        override fun hasNext(): Boolean = index < size        override fun next(): ModInt = get(index++)    }     fun copyOf(newSize: Int) = ModIntArray(intArray.copyOf(newSize))    fun copyOf() = copyOf(size)}fun ModIntArray.copyInto(destination: ModIntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size) =    ModIntArray(intArray.copyInto(destination.intArray, destinationOffset, startIndex, endIndex))inline fun ModIntArray(size: Int) = ModIntArray(IntArray(size))inline fun ModIntArray(size: Int, init: (Int) -> ModInt) = ModIntArray(IntArray(size) { init(it).int }) fun ModInt.powArray(n: Int) = ModIntArray(int.modPowArray(n, MOD)) inline fun ModIntArray.first() = get(0)inline fun ModIntArray.last() = get(lastIndex)inline fun ModIntArray.joinToString(separator: CharSequence) = intArray.joinToString(separator)inline fun <R> ModIntArray.fold(init: R, op: (acc: R, ModInt) -> R) = intArray.fold(init) { acc, i -> op(acc, ModInt(i)) }inline fun <R> ModIntArray.foldRight(init: R, op: (ModInt, acc: R) -> R) = intArray.foldRight(init) { i, acc -> op(ModInt(i), acc) }fun ModIntArray.sum() = fold(ModInt(0), ModInt::plus)fun ModIntArray.product() = fold(ModInt(1), ModInt::times) inline fun <T> Iterable<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Iterable<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }inline fun <T> Sequence<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Sequence<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }inline fun <T> Array<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Array<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }fun Iterable<ModInt>.sum() = sumByModInt { it }fun Sequence<ModInt>.sum() = sumByModInt { it }fun Iterable<ModInt>.product() = productByModInt { it }fun Sequence<ModInt>.product() = productByModInt { it }fun Collection<ModInt>.toModIntArray() = ModIntArray(size).also { var i = 0; for(e in this) { it[i++] = e } } class IntList(initialCapacity: Int = 12) {    private var arr = IntArray(initialCapacity)    val _arr get() = arr    private val capacity get() = arr.size    var size = 0        private set    inline val lastIndex get() = size - 1    inline val indices get() = 0 until size     constructor(copyFrom: IntArray): this(copyFrom.size) { copyFrom.copyInto(arr); size = copyFrom.size }    constructor(copyFrom: Collection<Int>): this(copyFrom.size) { arr = copyFrom.toIntArray(); size = copyFrom.size }     fun contentEquals(other: IntList): Boolean {        return this === other || size == other.size && indices.all { this[it] == other[it] }    }     private fun grow(minCapacity: Int = 8) {        val newCapacity = maxOf(minCapacity, capacity + (capacity shr 1))        arr = arr.copyOf(newCapacity)    }     fun ensureCapacity(minCapacity: Int) { if(capacity < minCapacity) grow(minCapacity) }     operator fun get(index: Int): Int {        require(index in 0 until size)        return arr[index]    }     operator fun set(index: Int, value: Int) {        require(index in 0 until size)        arr[index] = value    }     fun add(value: Int) {        if(size == capacity) grow()        arr[size++] = value    }     fun addAll(list: IntList) {        ensureCapacity(size + list.size)        list.arr.copyInto(arr, size, 0, list.size)        size += list.size    }     fun add(index: Int, element: Int) {        if(size == capacity) grow()        arr.copyInto(arr, index + 1, index, size)        size++        set(index, element)    }     fun clear() { size = 0 }     fun removeAt(index: Int): Int {        val e = get(index)        arr.copyInto(arr, index, index + 1, size)        size--        return e    }     fun indexOf(e: Int): Int {        for(i in 0 until size) if(this[i] == e) return i        return -1    }     fun remove(e: Int): Boolean {        val i = indexOf(e)        if(i == -1) return false        removeAt(i)        return true    }     operator fun iterator() = object: IntIterator() {        private var pos = 0        override fun hasNext() = pos < size        override fun nextInt() = get(pos++)    }     inline fun isEmpty() = size == 0    inline fun isNotEmpty() = size != 0     fun pop() = arr[--size]     fun popToSize(s: Int) {        require(s >= 0)        if(s < size) size = s    }     fun swap(i: Int, j: Int) { val t = this[i]; this[i] = this[j]; this[j] = t }    fun reverse() {        for(i in 0 until size / 2) swap(i, lastIndex - i)    }     fun shuffle(rnd: Random = random) { for(i in lastIndex downTo 1) swap(i, rnd.nextInt(i+1)) }     inline fun sortWith(cmp: (Int, Int) -> Int) { _mergeSort(_arr, size, IntArray(size), IntArray::get, IntArray::set, cmp) }    inline fun <T: Comparable<T>> sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }    inline fun <T: Comparable<T>> sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }    fun sort() { sortBy { it } }    fun sortDescending() { sortByDescending { it } }     fun joinToString(separator: CharSequence) = if(size == 0) """" else let {        buildString {            append(it[0])            for (i in 1 until size) {                append(separator).append(it[i])            }        }    }     override fun toString() = ""["" + joinToString("", "") + ""]""     fun toIntArray() = arr.copyOf(size)    fun toList() = List(size, ::get)     inline fun first() = get(0)    inline fun last() = get(lastIndex)} inline fun IntList(size: Int, init: (Int) -> Int) = IntList(size).apply {    for(i in 0 until size) { add(init(i)) }}inline fun IntArray.toIntList() = IntList(this)inline fun Collection<Int>.toIntList() = IntList(this)inline fun intListOf(vararg values: Int) = IntList(values) fun IntList.max() = (1 until size).fold(this[0]) { acc, i -> max(acc, this[i]) }fun IntList.min() = (1 until size).fold(this[0]) { acc, i -> min(acc, this[i]) }fun IntList.getOrNull(i: Int) = if(i in indices) get(i) else nullinline fun IntList.count(predicate: (Int) -> Boolean) = indices.count { predicate(this[it]) }fun IntList.copyOf() = IntList(size, ::get)  /** IO *///@JvmField val ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null//const val PATH = ""src/main/resources/""//@JvmField val INPUT = File(PATH + ""input.txt"").inputStream()//@JvmField val OUTPUT = File(PATH + ""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar() else c    }} /** @param skipNext Whether to skip the next character (usually whitespace), defaults to true */fun readCharArray(n: Int, skipNext: Boolean = true): CharArray {    val res = CharArray(n) { readChar() }    if(skipNext) readChar()    return res} fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(c != '\n' && c != Char.MIN_VALUE) {            append(c)            c = readChar()        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /**  sort overrides to avoid quicksort attacks */ @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } inline fun <A, T> _mergeSort(a0: A, n: Int, tmp0: A, get: A.(Int) -> T, set: A.(Int, T) -> Unit, cmp: (T, T) -> Int) {    var a = a0    var tmp = tmp0    var len = 1    while(len < n) {        var l = 0        while(true) {            val m = l + len            if(m >= n) break            val r = min(n, m + len)            var i = l            var j = m            for(k in l until r) {                if(i != m && (j == r || cmp(a.get(i), a.get(j)) <= 0)) {                    tmp.set(k, a.get(i++))                } else tmp.set(k, a.get(j++))            }            l = r        }        for(i in l until n) tmp.set(i, a.get(i))        val t = a; a = tmp; tmp = t        len += len    }    if(a !== a0) for(i in 0 until n) a0.set(i, tmp0.get(i))} inline fun IntArray.sortWith(cmp: (Int, Int) -> Int) { _mergeSort(this, size, IntArray(size), IntArray::get, IntArray::set, cmp) }inline fun <T: Comparable<T>> IntArray.sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> IntArray.sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun IntArray.sort() { sortBy { it } }fun IntArray.sortDescending() { sortByDescending { it } } inline fun LongArray.sortWith(cmp: (Long, Long) -> Int) { _mergeSort(this, size, LongArray(size), LongArray::get, LongArray::set, cmp) }inline fun <T: Comparable<T>> LongArray.sortBy(func: (Long) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> LongArray.sortByDescending(func: (Long) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun LongArray.sort() { sortBy { it } }fun LongArray.sortDescending() { sortByDescending { it } } inline fun DoubleArray.sortWith(cmp: (Double, Double) -> Int) { _mergeSort(this, size, DoubleArray(size), DoubleArray::get, DoubleArray::set, cmp) }inline fun <T: Comparable<T>> DoubleArray.sortBy(func: (Double) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> DoubleArray.sortByDescending(func: (Double) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun DoubleArray.sort() { sortBy { it } }fun DoubleArray.sortDescending() { sortByDescending { it } } inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T : Comparable<T>> Array<out T>.sort() = _sort()inline fun <T : Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T : Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T : Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() // import preserving junk function@Suppress(""NonAsciiCharacters"") fun 雪花飄飄北風嘯嘯天地一片蒼茫() { iprintln(max(1, 2)) } fun IntArray.sumLong() = sumOf { it.toLong() } fun IntArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun IntArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun LongArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun LongArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun DoubleArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun DoubleArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> Array<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> Array<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> List<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> List<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) } // max/min Kotlin 1.6 -> 1.4 shimfun IntArray.max() = maxOf { it }fun IntArray.min() = minOf { it }fun LongArray.max() = maxOf { it }fun LongArray.min() = minOf { it }fun CharArray.max() = maxOf { it }fun CharArray.min() = minOf { it }fun <T : Comparable<T>> Iterable<T>.max() = maxOf { it }fun <T : Comparable<T>> Iterable<T>.min() = minOf { it }fun <T : Comparable<T>> Sequence<T>.max() = maxOf { it }fun <T : Comparable<T>> Sequence<T>.min() = minOf { it }","dfs and similar,dp,math,trees"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"")@file:OptIn(ExperimentalUnsignedTypes::class, ExperimentalStdlibApi::class) import java.io.PrintWriterimport kotlin.math.*import kotlin.random.Randomimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {//    val startTime = System.nanoTime()     val numCases = 1//readInt()    case@ for(case in 1..numCases) {        //print(""Case #$case: "")         val n = readInt()         val G = Array(n) { IntList() }        val V = ModIntArray(n)        repeat(n-1) {            val u = readInt()            val v = readInt()            val c = readInt()             G[u].add(v)            V[u] = V[u] + c            G[v].add(u)            V[v] = V[v] + c        }         val S = ModIntArray(IntArray(n) { G[it].size })         val par = IntArray(n)         val stk = intListOf(0)         while(stk.isNotEmpty()) {            var u = stk.pop()             if(u >= 0) {                stk.add(u.inv())                val g = G[u]                g.sort()                 for(v in g) if(par[u] != v) {                    par[v] = u                    stk.add(v)                }            } else {                u = u.inv()                val g = G[u]                 val cpar: ModInt                 if(g.size == 1) {                    cpar = ModInt(0)                    V[u] = ModInt(0)                } else {                    val d = S[u].inverse()                    cpar = -d                    V[u] *= d                }                 if(u != 0) {                    val v = par[u]                     S[v] += cpar                    V[v] += V[u]                }            }        }         val ans = V[0]        println(ans.int)    } //    iprintln(""Time: ${(System.nanoTime() - startTime) / 1000000} ms"")} fun IntList.lowerBound(value: Int): Int {    var bit = Integer.highestOneBit(size)    var pos = 0     while(bit > 0) {        val npos = pos or bit        if(npos <= size && this[npos-1] < value) pos = npos        bit = bit shr 1    }    return pos} const val BILLION7 = 1e9.toInt() + 7const val MOD = BILLION7const val TOTIENT = MOD - 1 // assumes MOD is prime infix fun Int.modulo(mod: Int): Int = (this % mod).let { (it shr Int.SIZE_BITS - 1 and mod) + it }infix fun Long.modulo(mod: Long) = (this % mod).let { (it shr Long.SIZE_BITS - 1 and mod) + it }infix fun Long.modulo(mod: Int) = modulo(mod.toLong()).toInt() fun Int.mulMod(other: Int, mod: Int) = toLong() * other modulo mod fun Int.powMod(exponent: Long, mod: Int): Int {    if(exponent < 0) error(""Inverse not implemented"")    var res = 1L    var e = exponent    var b = modulo(mod).toLong()     while(e > 0) {        if(e and 1 == 1L) {            res = res * b % mod        }        e = e shr 1        b = b * b % mod    }    return res.toInt()}fun Int.powMod(exponent: Int, mod: Int) = powMod(exponent.toLong(), mod)fun Int.modPowArray(n: Int, mod: Int): IntArray {    val res = IntArray(n+1)    res[0] = 1    for(i in 1..n) res[i] = mulMod(res[i-1], mod)    return res} inline fun Int.toModInt() = ModInt(this modulo MOD)inline fun Long.toModInt() = ModInt(this modulo MOD) /** note: Only use constructor for int within modulo range, otherwise use toModInt **/inline class ModInt(val int: Int) {    companion object {        /** can't seem to make these private or inlined without causing compiler issues */        @JvmField val _invMemo = HashMap<ModInt, ModInt>()        fun _invMemoized(m: ModInt) = _invMemo.getOrPut(m) { m.inv_unmemoized() }    }     // normalizes an integer that's within range [-MOD, MOD) without branching    private inline fun normalize(int: Int) = ModInt((int shr Int.SIZE_BITS - 1 and MOD) + int)     operator fun plus(other: ModInt) = normalize(int + other.int - MOD) // overflow-safe even if MOD >= 2^30    inline operator fun plus(other: Int) = plus(other.toModInt())    operator fun inc() = normalize(int + (1 - MOD))     operator fun minus(other: ModInt) = normalize(int - other.int)    inline operator fun minus(other: Int) = minus(other.toModInt())    operator fun dec() = normalize(int - 1)    operator fun unaryMinus() = normalize(-int)     operator fun times(other: ModInt) = ModInt((int.toLong() * other.int % MOD).toInt())    inline operator fun times(other: Int) = ModInt(int.mulMod(other, MOD))     fun pow(exponent: Int): ModInt {        val e = if(exponent < 0) {            require(int != 0) { ""Can't invert/divide by 0"" }            exponent modulo TOTIENT        } else exponent        return ModInt(int.powMod(e, MOD))    }     fun pow(exponent: Long) = if(int == 0) when {        exponent > 0 -> this        exponent == 0L -> ModInt(1)        else -> error(""Can't invert/divide by 0"")    } else pow(exponent modulo TOTIENT)     inline fun inverse() = inv_unmemoized() /** NOTE: Change if necessary */     fun inv_unmemoized(): ModInt {        require(int != 0) { ""Can't invert/divide by 0"" }        return pow(TOTIENT - 1)    }    inline fun inv_memoized() = _invMemoized(this)     operator fun div(other: ModInt) = times(other.inverse())    inline operator fun div(other: Int) = div(other.toModInt())     override inline fun toString() = int.toString()} inline operator fun Int.plus(modInt: ModInt) = modInt + thisinline operator fun Int.minus(modInt: ModInt) = toModInt() - modIntinline operator fun Int.times(modInt: ModInt) = modInt * thisinline operator fun Int.div(modInt: ModInt) = modInt.inverse() * this inline class ModIntArray(val intArray: IntArray): Collection<ModInt> {    inline operator fun get(i: Int) = ModInt(intArray[i])    inline operator fun set(i: Int, v: ModInt) { intArray[i] = v.int }     override inline val size: Int get() = intArray.size    inline val lastIndex get() = intArray.lastIndex    inline val indices get() = intArray.indices     override inline fun contains(element: ModInt): Boolean = element.int in intArray     override fun containsAll(elements: Collection<ModInt>): Boolean = elements.all(::contains)     override inline fun isEmpty(): Boolean = intArray.isEmpty()     override fun iterator(): Iterator<ModInt> = object: Iterator<ModInt> {        var index = 0        override fun hasNext(): Boolean = index < size        override fun next(): ModInt = get(index++)    }     fun copyOf(newSize: Int) = ModIntArray(intArray.copyOf(newSize))    fun copyOf() = copyOf(size)}fun ModIntArray.copyInto(destination: ModIntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size) =    ModIntArray(intArray.copyInto(destination.intArray, destinationOffset, startIndex, endIndex))inline fun ModIntArray(size: Int) = ModIntArray(IntArray(size))inline fun ModIntArray(size: Int, init: (Int) -> ModInt) = ModIntArray(IntArray(size) { init(it).int }) fun ModInt.powArray(n: Int) = ModIntArray(int.modPowArray(n, MOD)) inline fun ModIntArray.first() = get(0)inline fun ModIntArray.last() = get(lastIndex)inline fun ModIntArray.joinToString(separator: CharSequence) = intArray.joinToString(separator)inline fun <R> ModIntArray.fold(init: R, op: (acc: R, ModInt) -> R) = intArray.fold(init) { acc, i -> op(acc, ModInt(i)) }inline fun <R> ModIntArray.foldRight(init: R, op: (ModInt, acc: R) -> R) = intArray.foldRight(init) { i, acc -> op(ModInt(i), acc) }fun ModIntArray.sum() = fold(ModInt(0), ModInt::plus)fun ModIntArray.product() = fold(ModInt(1), ModInt::times) inline fun <T> Iterable<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Iterable<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }inline fun <T> Sequence<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Sequence<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }inline fun <T> Array<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Array<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }fun Iterable<ModInt>.sum() = sumByModInt { it }fun Sequence<ModInt>.sum() = sumByModInt { it }fun Iterable<ModInt>.product() = productByModInt { it }fun Sequence<ModInt>.product() = productByModInt { it }fun Collection<ModInt>.toModIntArray() = ModIntArray(size).also { var i = 0; for(e in this) { it[i++] = e } } class IntList(initialCapacity: Int = 12) {    private var arr = IntArray(initialCapacity)    val _arr get() = arr    private val capacity get() = arr.size    var size = 0        private set    inline val lastIndex get() = size - 1    inline val indices get() = 0 until size     constructor(copyFrom: IntArray): this(copyFrom.size) { copyFrom.copyInto(arr); size = copyFrom.size }    constructor(copyFrom: Collection<Int>): this(copyFrom.size) { arr = copyFrom.toIntArray(); size = copyFrom.size }     fun contentEquals(other: IntList): Boolean {        return this === other || size == other.size && indices.all { this[it] == other[it] }    }     private fun grow(minCapacity: Int = 8) {        val newCapacity = maxOf(minCapacity, capacity + (capacity shr 1))        arr = arr.copyOf(newCapacity)    }     fun ensureCapacity(minCapacity: Int) { if(capacity < minCapacity) grow(minCapacity) }     operator fun get(index: Int): Int {        require(index in 0 until size)        return arr[index]    }     operator fun set(index: Int, value: Int) {        require(index in 0 until size)        arr[index] = value    }     fun add(value: Int) {        if(size == capacity) grow()        arr[size++] = value    }     fun addAll(list: IntList) {        ensureCapacity(size + list.size)        list.arr.copyInto(arr, size, 0, list.size)        size += list.size    }     fun add(index: Int, element: Int) {        if(size == capacity) grow()        arr.copyInto(arr, index + 1, index, size)        size++        set(index, element)    }     fun clear() { size = 0 }     fun removeAt(index: Int): Int {        val e = get(index)        arr.copyInto(arr, index, index + 1, size)        size--        return e    }     fun indexOf(e: Int): Int {        for(i in 0 until size) if(this[i] == e) return i        return -1    }     fun remove(e: Int): Boolean {        val i = indexOf(e)        if(i == -1) return false        removeAt(i)        return true    }     operator fun iterator() = object: IntIterator() {        private var pos = 0        override fun hasNext() = pos < size        override fun nextInt() = get(pos++)    }     inline fun isEmpty() = size == 0    inline fun isNotEmpty() = size != 0     fun pop() = arr[--size]     fun popToSize(s: Int) {        require(s >= 0)        if(s < size) size = s    }     fun swap(i: Int, j: Int) { val t = this[i]; this[i] = this[j]; this[j] = t }    fun reverse() {        for(i in 0 until size / 2) swap(i, lastIndex - i)    }     fun shuffle(rnd: Random = random) { for(i in lastIndex downTo 1) swap(i, rnd.nextInt(i+1)) }     inline fun sortWith(cmp: (Int, Int) -> Int) { _mergeSort(_arr, size, IntArray(size), IntArray::get, IntArray::set, cmp) }    inline fun <T: Comparable<T>> sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }    inline fun <T: Comparable<T>> sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }    fun sort() { sortBy { it } }    fun sortDescending() { sortByDescending { it } }     fun joinToString(separator: CharSequence) = if(size == 0) """" else let {        buildString {            append(it[0])            for (i in 1 until size) {                append(separator).append(it[i])            }        }    }     override fun toString() = ""["" + joinToString("", "") + ""]""     fun toIntArray() = arr.copyOf(size)    fun toList() = List(size, ::get)     inline fun first() = get(0)    inline fun last() = get(lastIndex)} inline fun IntList(size: Int, init: (Int) -> Int) = IntList(size).apply {    for(i in 0 until size) { add(init(i)) }}inline fun IntArray.toIntList() = IntList(this)inline fun Collection<Int>.toIntList() = IntList(this)inline fun intListOf(vararg values: Int) = IntList(values) fun IntList.max() = (1 until size).fold(this[0]) { acc, i -> max(acc, this[i]) }fun IntList.min() = (1 until size).fold(this[0]) { acc, i -> min(acc, this[i]) }fun IntList.getOrNull(i: Int) = if(i in indices) get(i) else nullinline fun IntList.count(predicate: (Int) -> Boolean) = indices.count { predicate(this[it]) }fun IntList.copyOf() = IntList(size, ::get)  /** IO *///@JvmField val ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null//const val PATH = ""src/main/resources/""//@JvmField val INPUT = File(PATH + ""input.txt"").inputStream()//@JvmField val OUTPUT = File(PATH + ""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar() else c    }} /** @param skipNext Whether to skip the next character (usually whitespace), defaults to true */fun readCharArray(n: Int, skipNext: Boolean = true): CharArray {    val res = CharArray(n) { readChar() }    if(skipNext) readChar()    return res} fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(c != '\n' && c != Char.MIN_VALUE) {            append(c)            c = readChar()        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /**  sort overrides to avoid quicksort attacks */ @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } inline fun <A, T> _mergeSort(a0: A, n: Int, tmp0: A, get: A.(Int) -> T, set: A.(Int, T) -> Unit, cmp: (T, T) -> Int) {    var a = a0    var tmp = tmp0    var len = 1    while(len < n) {        var l = 0        while(true) {            val m = l + len            if(m >= n) break            val r = min(n, m + len)            var i = l            var j = m            for(k in l until r) {                if(i != m && (j == r || cmp(a.get(i), a.get(j)) <= 0)) {                    tmp.set(k, a.get(i++))                } else tmp.set(k, a.get(j++))            }            l = r        }        for(i in l until n) tmp.set(i, a.get(i))        val t = a; a = tmp; tmp = t        len += len    }    if(a !== a0) for(i in 0 until n) a0.set(i, tmp0.get(i))} inline fun IntArray.sortWith(cmp: (Int, Int) -> Int) { _mergeSort(this, size, IntArray(size), IntArray::get, IntArray::set, cmp) }inline fun <T: Comparable<T>> IntArray.sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> IntArray.sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun IntArray.sort() { sortBy { it } }fun IntArray.sortDescending() { sortByDescending { it } } inline fun LongArray.sortWith(cmp: (Long, Long) -> Int) { _mergeSort(this, size, LongArray(size), LongArray::get, LongArray::set, cmp) }inline fun <T: Comparable<T>> LongArray.sortBy(func: (Long) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> LongArray.sortByDescending(func: (Long) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun LongArray.sort() { sortBy { it } }fun LongArray.sortDescending() { sortByDescending { it } } inline fun DoubleArray.sortWith(cmp: (Double, Double) -> Int) { _mergeSort(this, size, DoubleArray(size), DoubleArray::get, DoubleArray::set, cmp) }inline fun <T: Comparable<T>> DoubleArray.sortBy(func: (Double) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> DoubleArray.sortByDescending(func: (Double) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun DoubleArray.sort() { sortBy { it } }fun DoubleArray.sortDescending() { sortByDescending { it } } inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T : Comparable<T>> Array<out T>.sort() = _sort()inline fun <T : Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T : Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T : Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() // import preserving junk function@Suppress(""NonAsciiCharacters"") fun 雪花飄飄北風嘯嘯天地一片蒼茫() { iprintln(max(1, 2)) } fun IntArray.sumLong() = sumOf { it.toLong() } fun IntArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun IntArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun LongArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun LongArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun DoubleArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun DoubleArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> Array<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> Array<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> List<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> List<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) } // max/min Kotlin 1.6 -> 1.4 shimfun IntArray.max() = maxOf { it }fun IntArray.min() = minOf { it }fun LongArray.max() = maxOf { it }fun LongArray.min() = minOf { it }fun CharArray.max() = maxOf { it }fun CharArray.min() = minOf { it }fun <T : Comparable<T>> Iterable<T>.max() = maxOf { it }fun <T : Comparable<T>> Iterable<T>.min() = minOf { it }fun <T : Comparable<T>> Sequence<T>.max() = maxOf { it }fun <T : Comparable<T>> Sequence<T>.min() = minOf { it }","dfs and similar,dp,math,trees"
"@file:Suppress(""NOTHING_TO_INLINE"", ""EXPERIMENTAL_FEATURE_WARNING"", ""OVERRIDE_BY_INLINE"")@file:OptIn(ExperimentalUnsignedTypes::class, ExperimentalStdlibApi::class) import java.io.PrintWriterimport kotlin.math.*import kotlin.random.Randomimport kotlin.collections.sort as _sortimport kotlin.collections.sortDescending as _sortDescendingimport kotlin.io.println as iprintln /** @author Spheniscine */fun main() { _writer.solve(); _writer.flush() }fun PrintWriter.solve() {//    val startTime = System.nanoTime()     val numCases = 1//readInt()    case@ for(case in 1..numCases) {        //print(""Case #$case: "")         val n = readInt()         val G = Array(n) { IntList() }        val V = ModIntArray(n)        repeat(n-1) {            val u = readInt()            val v = readInt()            val c = readInt()             G[u].add(v)            V[u] = V[u] + c            G[v].add(u)            V[v] = V[v] + c        }         val S = ModIntArray(IntArray(n) { G[it].size })        val C = Array(n) { ModIntArray(IntArray(G[it].size) { MOD - 1 }) }         val par = IntArray(n)         val stk = intListOf(0)         while(stk.isNotEmpty()) {            var u = stk.pop()             if(u >= 0) {                stk.add(u.inv())                val g = G[u]                g.sort()                 for(v in g) if(par[u] != v) {                    par[v] = u                    stk.add(v)                }            } else {                u = u.inv()                val g = G[u]                 var cpar = C[u][g.lowerBound(par[u])]                 if(g.size == 1) {                    cpar = ModInt(0)                    V[u] = ModInt(0)                } else {                    val d = S[u].inverse()                    cpar *= d                    V[u] *= d                }                 if(u != 0) {                    val v = par[u]                    val m = -C[v][G[v].lowerBound(u)]                     S[v] += cpar * m                    V[v] += V[u] * m                }            }        }         val ans = V[0]        println(ans.int)    } //    iprintln(""Time: ${(System.nanoTime() - startTime) / 1000000} ms"")} fun IntList.lowerBound(value: Int): Int {    var bit = Integer.highestOneBit(size)    var pos = 0     while(bit > 0) {        val npos = pos or bit        if(npos <= size && this[npos-1] < value) pos = npos        bit = bit shr 1    }    return pos} const val BILLION7 = 1e9.toInt() + 7const val MOD = BILLION7const val TOTIENT = MOD - 1 // assumes MOD is prime infix fun Int.modulo(mod: Int): Int = (this % mod).let { (it shr Int.SIZE_BITS - 1 and mod) + it }infix fun Long.modulo(mod: Long) = (this % mod).let { (it shr Long.SIZE_BITS - 1 and mod) + it }infix fun Long.modulo(mod: Int) = modulo(mod.toLong()).toInt() fun Int.mulMod(other: Int, mod: Int) = toLong() * other modulo mod fun Int.powMod(exponent: Long, mod: Int): Int {    if(exponent < 0) error(""Inverse not implemented"")    var res = 1L    var e = exponent    var b = modulo(mod).toLong()     while(e > 0) {        if(e and 1 == 1L) {            res = res * b % mod        }        e = e shr 1        b = b * b % mod    }    return res.toInt()}fun Int.powMod(exponent: Int, mod: Int) = powMod(exponent.toLong(), mod)fun Int.modPowArray(n: Int, mod: Int): IntArray {    val res = IntArray(n+1)    res[0] = 1    for(i in 1..n) res[i] = mulMod(res[i-1], mod)    return res} inline fun Int.toModInt() = ModInt(this modulo MOD)inline fun Long.toModInt() = ModInt(this modulo MOD) /** note: Only use constructor for int within modulo range, otherwise use toModInt **/inline class ModInt(val int: Int) {    companion object {        /** can't seem to make these private or inlined without causing compiler issues */        @JvmField val _invMemo = HashMap<ModInt, ModInt>()        fun _invMemoized(m: ModInt) = _invMemo.getOrPut(m) { m.inv_unmemoized() }    }     // normalizes an integer that's within range [-MOD, MOD) without branching    private inline fun normalize(int: Int) = ModInt((int shr Int.SIZE_BITS - 1 and MOD) + int)     operator fun plus(other: ModInt) = normalize(int + other.int - MOD) // overflow-safe even if MOD >= 2^30    inline operator fun plus(other: Int) = plus(other.toModInt())    operator fun inc() = normalize(int + (1 - MOD))     operator fun minus(other: ModInt) = normalize(int - other.int)    inline operator fun minus(other: Int) = minus(other.toModInt())    operator fun dec() = normalize(int - 1)    operator fun unaryMinus() = normalize(-int)     operator fun times(other: ModInt) = ModInt((int.toLong() * other.int % MOD).toInt())    inline operator fun times(other: Int) = ModInt(int.mulMod(other, MOD))     fun pow(exponent: Int): ModInt {        val e = if(exponent < 0) {            require(int != 0) { ""Can't invert/divide by 0"" }            exponent modulo TOTIENT        } else exponent        return ModInt(int.powMod(e, MOD))    }     fun pow(exponent: Long) = if(int == 0) when {        exponent > 0 -> this        exponent == 0L -> ModInt(1)        else -> error(""Can't invert/divide by 0"")    } else pow(exponent modulo TOTIENT)     inline fun inverse() = inv_unmemoized() /** NOTE: Change if necessary */     fun inv_unmemoized(): ModInt {        require(int != 0) { ""Can't invert/divide by 0"" }        return pow(TOTIENT - 1)    }    inline fun inv_memoized() = _invMemoized(this)     operator fun div(other: ModInt) = times(other.inverse())    inline operator fun div(other: Int) = div(other.toModInt())     override inline fun toString() = int.toString()} inline operator fun Int.plus(modInt: ModInt) = modInt + thisinline operator fun Int.minus(modInt: ModInt) = toModInt() - modIntinline operator fun Int.times(modInt: ModInt) = modInt * thisinline operator fun Int.div(modInt: ModInt) = modInt.inverse() * this inline class ModIntArray(val intArray: IntArray): Collection<ModInt> {    inline operator fun get(i: Int) = ModInt(intArray[i])    inline operator fun set(i: Int, v: ModInt) { intArray[i] = v.int }     override inline val size: Int get() = intArray.size    inline val lastIndex get() = intArray.lastIndex    inline val indices get() = intArray.indices     override inline fun contains(element: ModInt): Boolean = element.int in intArray     override fun containsAll(elements: Collection<ModInt>): Boolean = elements.all(::contains)     override inline fun isEmpty(): Boolean = intArray.isEmpty()     override fun iterator(): Iterator<ModInt> = object: Iterator<ModInt> {        var index = 0        override fun hasNext(): Boolean = index < size        override fun next(): ModInt = get(index++)    }     fun copyOf(newSize: Int) = ModIntArray(intArray.copyOf(newSize))    fun copyOf() = copyOf(size)}fun ModIntArray.copyInto(destination: ModIntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size) =    ModIntArray(intArray.copyInto(destination.intArray, destinationOffset, startIndex, endIndex))inline fun ModIntArray(size: Int) = ModIntArray(IntArray(size))inline fun ModIntArray(size: Int, init: (Int) -> ModInt) = ModIntArray(IntArray(size) { init(it).int }) fun ModInt.powArray(n: Int) = ModIntArray(int.modPowArray(n, MOD)) inline fun ModIntArray.first() = get(0)inline fun ModIntArray.last() = get(lastIndex)inline fun ModIntArray.joinToString(separator: CharSequence) = intArray.joinToString(separator)inline fun <R> ModIntArray.fold(init: R, op: (acc: R, ModInt) -> R) = intArray.fold(init) { acc, i -> op(acc, ModInt(i)) }inline fun <R> ModIntArray.foldRight(init: R, op: (ModInt, acc: R) -> R) = intArray.foldRight(init) { i, acc -> op(ModInt(i), acc) }fun ModIntArray.sum() = fold(ModInt(0), ModInt::plus)fun ModIntArray.product() = fold(ModInt(1), ModInt::times) inline fun <T> Iterable<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Iterable<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }inline fun <T> Sequence<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Sequence<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }inline fun <T> Array<T>.sumByModInt(func: (T) -> ModInt) = fold(ModInt(0)) { acc, t -> acc + func(t) }inline fun <T> Array<T>.productByModInt(func: (T) -> ModInt) = fold(ModInt(1)) { acc, t -> acc * func(t) }fun Iterable<ModInt>.sum() = sumByModInt { it }fun Sequence<ModInt>.sum() = sumByModInt { it }fun Iterable<ModInt>.product() = productByModInt { it }fun Sequence<ModInt>.product() = productByModInt { it }fun Collection<ModInt>.toModIntArray() = ModIntArray(size).also { var i = 0; for(e in this) { it[i++] = e } } class IntList(initialCapacity: Int = 12) {    private var arr = IntArray(initialCapacity)    val _arr get() = arr    private val capacity get() = arr.size    var size = 0        private set    inline val lastIndex get() = size - 1    inline val indices get() = 0 until size     constructor(copyFrom: IntArray): this(copyFrom.size) { copyFrom.copyInto(arr); size = copyFrom.size }    constructor(copyFrom: Collection<Int>): this(copyFrom.size) { arr = copyFrom.toIntArray(); size = copyFrom.size }     fun contentEquals(other: IntList): Boolean {        return this === other || size == other.size && indices.all { this[it] == other[it] }    }     private fun grow(minCapacity: Int = 8) {        val newCapacity = maxOf(minCapacity, capacity + (capacity shr 1))        arr = arr.copyOf(newCapacity)    }     fun ensureCapacity(minCapacity: Int) { if(capacity < minCapacity) grow(minCapacity) }     operator fun get(index: Int): Int {        require(index in 0 until size)        return arr[index]    }     operator fun set(index: Int, value: Int) {        require(index in 0 until size)        arr[index] = value    }     fun add(value: Int) {        if(size == capacity) grow()        arr[size++] = value    }     fun addAll(list: IntList) {        ensureCapacity(size + list.size)        list.arr.copyInto(arr, size, 0, list.size)        size += list.size    }     fun add(index: Int, element: Int) {        if(size == capacity) grow()        arr.copyInto(arr, index + 1, index, size)        size++        set(index, element)    }     fun clear() { size = 0 }     fun removeAt(index: Int): Int {        val e = get(index)        arr.copyInto(arr, index, index + 1, size)        size--        return e    }     fun indexOf(e: Int): Int {        for(i in 0 until size) if(this[i] == e) return i        return -1    }     fun remove(e: Int): Boolean {        val i = indexOf(e)        if(i == -1) return false        removeAt(i)        return true    }     operator fun iterator() = object: IntIterator() {        private var pos = 0        override fun hasNext() = pos < size        override fun nextInt() = get(pos++)    }     inline fun isEmpty() = size == 0    inline fun isNotEmpty() = size != 0     fun pop() = arr[--size]     fun popToSize(s: Int) {        require(s >= 0)        if(s < size) size = s    }     fun swap(i: Int, j: Int) { val t = this[i]; this[i] = this[j]; this[j] = t }    fun reverse() {        for(i in 0 until size / 2) swap(i, lastIndex - i)    }     fun shuffle(rnd: Random = random) { for(i in lastIndex downTo 1) swap(i, rnd.nextInt(i+1)) }     inline fun sortWith(cmp: (Int, Int) -> Int) { _mergeSort(_arr, size, IntArray(size), IntArray::get, IntArray::set, cmp) }    inline fun <T: Comparable<T>> sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }    inline fun <T: Comparable<T>> sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }    fun sort() { sortBy { it } }    fun sortDescending() { sortByDescending { it } }     fun joinToString(separator: CharSequence) = if(size == 0) """" else let {        buildString {            append(it[0])            for (i in 1 until size) {                append(separator).append(it[i])            }        }    }     override fun toString() = ""["" + joinToString("", "") + ""]""     fun toIntArray() = arr.copyOf(size)    fun toList() = List(size, ::get)     inline fun first() = get(0)    inline fun last() = get(lastIndex)} inline fun IntList(size: Int, init: (Int) -> Int) = IntList(size).apply {    for(i in 0 until size) { add(init(i)) }}inline fun IntArray.toIntList() = IntList(this)inline fun Collection<Int>.toIntList() = IntList(this)inline fun intListOf(vararg values: Int) = IntList(values) fun IntList.max() = (1 until size).fold(this[0]) { acc, i -> max(acc, this[i]) }fun IntList.min() = (1 until size).fold(this[0]) { acc, i -> min(acc, this[i]) }fun IntList.getOrNull(i: Int) = if(i in indices) get(i) else nullinline fun IntList.count(predicate: (Int) -> Boolean) = indices.count { predicate(this[it]) }fun IntList.copyOf() = IntList(size, ::get)  /** IO *///@JvmField val ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null//const val PATH = ""src/main/resources/""//@JvmField val INPUT = File(PATH + ""input.txt"").inputStream()//@JvmField val OUTPUT = File(PATH + ""output.txt"").outputStream()@JvmField val INPUT = System.`in`@JvmField val OUTPUT = System.out const val _BUFFER_SIZE = 1 shl 16@JvmField val _buffer = ByteArray(_BUFFER_SIZE)@JvmField var _bufferPt = 0@JvmField var _bytesRead = 0 tailrec fun readChar(): Char {    if(_bufferPt == _bytesRead) {        _bufferPt = 0        _bytesRead = INPUT.read(_buffer, 0, _BUFFER_SIZE)    }    return if(_bytesRead < 0) Char.MIN_VALUE    else {        val c = _buffer[_bufferPt++].toChar()        if (c == '\r') readChar() else c    }} /** @param skipNext Whether to skip the next character (usually whitespace), defaults to true */fun readCharArray(n: Int, skipNext: Boolean = true): CharArray {    val res = CharArray(n) { readChar() }    if(skipNext) readChar()    return res} fun readLine(): String? {    var c = readChar()    return if(c == Char.MIN_VALUE) null    else buildString {        while(c != '\n' && c != Char.MIN_VALUE) {            append(c)            c = readChar()        }    }}fun readLn() = readLine()!! fun read() = buildString {    var c = readChar()    while(c <= ' ') {        if(c == Char.MIN_VALUE) return@buildString        c = readChar()    }    do {        append(c)        c = readChar()    } while(c > ' ')}fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() } @JvmField val _writer = PrintWriter(OUTPUT, false) /**  sort overrides to avoid quicksort attacks */ @JvmField var _random: Random? = nullval random get() = _random ?: Random(0x594E215C123 * System.nanoTime()).also { _random = it } inline fun <A, T> _mergeSort(a0: A, n: Int, tmp0: A, get: A.(Int) -> T, set: A.(Int, T) -> Unit, cmp: (T, T) -> Int) {    var a = a0    var tmp = tmp0    var len = 1    while(len < n) {        var l = 0        while(true) {            val m = l + len            if(m >= n) break            val r = min(n, m + len)            var i = l            var j = m            for(k in l until r) {                if(i != m && (j == r || cmp(a.get(i), a.get(j)) <= 0)) {                    tmp.set(k, a.get(i++))                } else tmp.set(k, a.get(j++))            }            l = r        }        for(i in l until n) tmp.set(i, a.get(i))        val t = a; a = tmp; tmp = t        len += len    }    if(a !== a0) for(i in 0 until n) a0.set(i, tmp0.get(i))} inline fun IntArray.sortWith(cmp: (Int, Int) -> Int) { _mergeSort(this, size, IntArray(size), IntArray::get, IntArray::set, cmp) }inline fun <T: Comparable<T>> IntArray.sortBy(func: (Int) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> IntArray.sortByDescending(func: (Int) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun IntArray.sort() { sortBy { it } }fun IntArray.sortDescending() { sortByDescending { it } } inline fun LongArray.sortWith(cmp: (Long, Long) -> Int) { _mergeSort(this, size, LongArray(size), LongArray::get, LongArray::set, cmp) }inline fun <T: Comparable<T>> LongArray.sortBy(func: (Long) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> LongArray.sortByDescending(func: (Long) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun LongArray.sort() { sortBy { it } }fun LongArray.sortDescending() { sortByDescending { it } } inline fun DoubleArray.sortWith(cmp: (Double, Double) -> Int) { _mergeSort(this, size, DoubleArray(size), DoubleArray::get, DoubleArray::set, cmp) }inline fun <T: Comparable<T>> DoubleArray.sortBy(func: (Double) -> T) { sortWith { a, b -> func(a).compareTo(func(b)) } }inline fun <T: Comparable<T>> DoubleArray.sortByDescending(func: (Double) -> T) { sortWith { a, b -> func(b).compareTo(func(a)) } }fun DoubleArray.sort() { sortBy { it } }fun DoubleArray.sortDescending() { sortByDescending { it } } inline fun CharArray.sort() { _sort() }inline fun CharArray.sortDescending() { _sortDescending() } inline fun <T : Comparable<T>> Array<out T>.sort() = _sort()inline fun <T : Comparable<T>> Array<out T>.sortDescending() = _sortDescending()inline fun <T : Comparable<T>> MutableList<out T>.sort() = _sort()inline fun <T : Comparable<T>> MutableList<out T>.sortDescending() = _sortDescending() // import preserving junk function@Suppress(""NonAsciiCharacters"") fun 雪花飄飄北風嘯嘯天地一片蒼茫() { iprintln(max(1, 2)) } fun IntArray.sumLong() = sumOf { it.toLong() } fun IntArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun IntArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun LongArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun LongArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun DoubleArray.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun DoubleArray.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> Array<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> Array<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) }fun <T: Comparable<T>> List<T>.sortedIndices() = IntArray(size) { it }.also { it.sortBy(::get) }fun <T: Comparable<T>> List<T>.sortedIndicesDescending() = IntArray(size) { it }.also { it.sortByDescending(::get) } // max/min Kotlin 1.6 -> 1.4 shimfun IntArray.max() = maxOf { it }fun IntArray.min() = minOf { it }fun LongArray.max() = maxOf { it }fun LongArray.min() = minOf { it }fun CharArray.max() = maxOf { it }fun CharArray.min() = minOf { it }fun <T : Comparable<T>> Iterable<T>.max() = maxOf { it }fun <T : Comparable<T>> Iterable<T>.min() = minOf { it }fun <T : Comparable<T>> Sequence<T>.max() = maxOf { it }fun <T : Comparable<T>> Sequence<T>.min() = minOf { it }","dfs and similar,dp,math,trees"
"/** * http://codeforces.com/contest/794/problem/C * * -> 第10个测试用例超时了 *      我猜肯定是这个slice太耗时了, 需要一个更好的方法, 避免这种new的形式-> 想想 * -> 避免使用slice, 避免使用map, 最后避免使用readline, 不过最后的结果还是很悲剧, 还是会超时, 搞不懂, 一直卡在#10测试用例 * Created by chaozhong on 5/31/17. */ import java.io.InputStreamimport java.math.BigDecimalimport java.math.BigIntegerimport java.util.* /** * [nth] -> 都是从0算的index */class Solution_794C_Person(tokens: CharArray, slicesize: Int, front: Boolean) {    val array: CharArray    init {        Arrays.sort(tokens)        if (front) {            array = tokens.copyOfRange(0, slicesize)        } else {            array = tokens.copyOfRange(tokens.size-slicesize, tokens.size)        }    }     var left = 0    var right = array.size-1     fun getMin(): Char {        return array[left]    }     fun getMax(): Char {        return array[right]    }     fun takeMin(): Char {        return array[left++]    }     fun takeMax(): Char {        return array[right--]    }     fun empty(): Boolean {        return left > right    }} fun main(args: Array<String>) {     input.run {        val startTime = System.currentTimeMillis()        val olegWords = nextCharArray()        val igorWords = nextCharArray()        val n = olegWords.size         val oleg = Solution_794C_Person(olegWords, n/2 + n%2, true)        val igor = Solution_794C_Person(igorWords, n/2, false) //        println(oleg.array.joinToString())//        println(igor.array.joinToString())         // 结果        val sb = StringBuilder(n)        sb.setLength(n)        var firstIndex = 0        var lastIndex = n-1         var i = 0        while (i++ < n) {            if (i % 2 == 1) {                // oleg round                if (igor.empty() || oleg.getMin() < igor.getMax()) {                    sb[firstIndex++] = oleg.takeMin()                } else {                    sb[lastIndex--] = oleg.takeMax()                }            } else {                // igor round                if (oleg.empty() || igor.getMax() > oleg.getMin()) {                    sb[firstIndex++] = igor.takeMax()                } else {                    sb[lastIndex--] = igor.takeMin()                }            }        }         println(sb.toString())    } //    println(olegWords.joinToString())//    println(igorWords.joinToString())//    println(olegWords.sliceArray(1..3).joinToString())//    oleg.print()//    oleg.takeMin(0)//    oleg.print()//    oleg.takeMin(0)//    oleg.print()//    oleg.takeMin(3)//    oleg.print() } val input = FastScanner() fun String.toBigInteger() = BigInteger(this)fun String.toBigDecimal() = BigDecimal(this) class FastScanner(private val input: InputStream = System.`in`) {    private val sb = StringBuilder()    private val buffer = ByteArray(4096)    private var pos = 0    private var size = 0     fun nextString(): String? {        var c = skipWhitespace()        if (c < 0) return null         return sb.run {            setLength(0)             do {                append(c.toChar())                c = read()            } while (c > ' '.toInt())             toString()        }    }     fun nextCharArray(): CharArray {        return nextString()!!.toCharArray()    }     fun nextLine(): String? {        var c = read()        if (c < 0) return null         return sb.run {            setLength(0)             while (c >= 0 && c != '\n'.toInt()) {                append(c.toChar())                c = read()            }             toString()        }    }     fun nextLong(): Long {        var c = skipWhitespace()         val sign = if (c == '-'.toInt()) {            c = read()            -1        } else 1         var ans = 0L         while (c > ' '.toInt()) {            ans = ans * 10 + c - '0'.toInt()            c = read()        }         return sign * ans    }     fun nextInt() = nextLong().toInt()    fun nextDouble() = nextString()?.toDouble() ?: 0.0    fun nextBigInteger(): BigInteger = nextString()?.toBigInteger() ?: BigInteger.ZERO    fun nextBigDecimal(): BigDecimal = nextString()?.toBigDecimal() ?: BigDecimal.ZERO     fun nextStrings(n: Int) = Array<String>(n) { nextString() ?: """" }    fun nextInts(n: Int) = IntArray(n) { nextInt() }    fun nextLongs(n: Int) = LongArray(n) { nextLong() }    fun nextDoubles(n: Int) = DoubleArray(n) { nextDouble() }    fun nextBigIntegers(n: Int) = Array<BigInteger>(n) { nextBigInteger() }    fun nextBigDecimals(n: Int) = Array<BigDecimal>(n) { nextBigDecimal() }     fun nextStrings(n: Int, m: Int) = Array(n) { nextStrings(m) }    fun nextInts(n: Int, m: Int) = Array(n) { nextInts(m) }    fun nextLongs(n: Int, m: Int) = Array(n) { nextLongs(m) }    fun nextDoubles(n: Int, m: Int) = Array(n) { nextDoubles(m) }    fun nextBigIntegers(n: Int, m: Int) = Array(n) { nextBigIntegers(m) }    fun nextBigDecimals(n: Int, m: Int) = Array(n) { nextBigDecimals(m) }     private fun skipWhitespace(): Int {        while (true) {            val c = read()            if (c > ' '.toInt() || c < 0) return c        }    }     private fun read(): Int {        while (pos >= size) {            if (size < 0) return -1            size = input.read(buffer, 0, buffer.size)            pos = 0        }        return buffer[pos++].toInt()    }}","games,greedy,sortings"
"fun main() {    readLine()    val socks = readLine()!!.split("" "").map(String::toInt)    val table = mutableSetOf<Int>()    var sol = 0    for (sock in socks) {        if (sock in table) table.remove(sock) else table.add(sock)        if (table.size > sol) sol = table.size    }    print(sol)}",implementation
"import java.util.TreeSet fun main(args: Array<String>) {    val n = readLine()!!.toInt()    val a = readLine()!!.split("" "").map(String::toInt)    var maxAns = 0    val set = TreeSet<Int>()    for (i in 0..n * 2 - 1) {        if (set.contains(a[i])) {            set.remove(a[i])        } else {            set.add(a[i])        }        maxAns = Math.max(maxAns, set.size)    }    println(maxAns)}",implementation
"import java.util.* fun main(args: Array<String>) {     val array = BooleanArray(200000, { false })    val scanner = Scanner(System.`in`)     var maxPairs = 0    var currentPairs = 0     val pairs = scanner.nextInt()    for (i in 0 until pairs * 2) {        val sock = scanner.nextInt()        val value = array[sock]        if (value)            currentPairs--        else {            array[sock] = true            currentPairs++            if (currentPairs > maxPairs) maxPairs = currentPairs        }    }    print(maxPairs)    }",implementation
"fun main() {    val r = System.`in`.bufferedReader()    val sb = StringBuilder()    val n = r.readLine().toInt()    val v = r.readLine().split("" "").map { it.toInt() }    val set = mutableSetOf<Int>()    var max = 0    v.forEach {        if (it !in set){            set.add(it)            max = maxOf(max, set.size)        }else{            set.remove(it)        }    }    print(max)} /*// Hakiobo's code for faster reading inputprivate const val SPACE_INT = ' '.toInt()private const val ZERO_INT = '0'.toInt()private const val NL_INT = '\n'.toInt() private fun BufferedReader.readInt(): Int {    var ret = read()    while (ret <= SPACE_INT) {        ret = read()    }    val neg = ret == '-'.toInt()    if (neg) {        ret = read()    }    ret -= ZERO_INT    var read = read()    while (read >= ZERO_INT) {        ret *= 10        ret += read - ZERO_INT        read = read()    }     while (read <= SPACE_INT && read != -1 && read != NL_INT) {        mark(1)        read = read()    }    if (read > SPACE_INT) {        reset()    }    return if (neg) -ret else ret}*/",implementation
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.random.Randomimport kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        IN = BufferedInputStream(fakein.toString().byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} fun getint():Int{ return IO.nextInt() }fun getlong():Long{ return IO.nextLong() }fun getline(n:Int):IntArray{    val ret = IntArray(n);repeat(n){ret[it] = getint()};return ret}fun getlineL(n:Int):LongArray{    val ret = LongArray(n);repeat(n){ret[it] = getlong()};return ret}fun getstr():String{ return IO.nextString() }fun MutableList<Int>.streamint(n:Int){ repeat(n){this.add(getint())}}fun MutableList<Long>.streamlong(n:Int){ repeat(n){this.add(getlong())}}inline fun cases(ask:()->Unit){ val t = getint();repeat(t){ ask() }} val List<Char>.ret:Stringget() = this.joinToString("""")infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    var str = """"    if(this is String){ str = this    }else if(this is Int){ str = this.toString()    }else if(this is Long){ str = this.toString()    }    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    inline fun cases(a:solve.()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint()} else if(mode == solveMode.tc){1 } else randCount        //safety checks          if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            currentAnswer = null            currentBruteAnswer = null            a()        }        if(withBruteForce){            put(""Checked ${answersChecked}"")        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    inline fun brute(a:()->Unit){        if(withBruteForce){            a()        }    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }      var currentAnswer:String? = null    var currentBruteAnswer:String? = null    fun answer(a:Any){        currentAnswer = a.toString()        if(currentBruteAnswer != null){            checkAnswer()        }    }    fun put2(a:Any){answer(a);put(a) }     fun bruteAnswer(a:Any){        currentBruteAnswer = a.toString()        if(currentAnswer != null){            checkAnswer()        }    }    fun checkAnswer(){        if(currentAnswer != currentBruteAnswer){            throw Exception(""Failed Test: BF $currentBruteAnswer Current $currentAnswer"")        }        answersChecked ++    }}infix fun Int.modMinus(b:Int):Int{    val ans = this - b    return if(ans < 0) ans + pI else ans}// 1. Modded//const val p = 1000000007Lvar pI = 0fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}infix fun Int.modM(b:Int):Int{ return ((this * 1L * b) % pI).toInt() }infix fun Int.modPlus(b:Int):Int{ val ans = this + b;return if(ans >= pI) ans - pI else ans }fun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val Boolean.chi:Int get() = if(this) 1 else 0 //characteristic function// 2. DP initial valuesconst val plarge = 1_000_000_727const val nlarge = -plargeconst val phuge = 2_727_000_000_000_000_000Lconst val nhuge = -phugeval Char.code :Int get() = this.toInt() -  'a'.toInt()  fun solve(things:IntArray):Pair<Int,Int>{    things.shuffle()    val n  = things.size    val all = things.toMutableSet()    if( n == 0){        return Pair(0,1)    }    val root = things[0]        if(n == 1 || n == 0){        return Pair(root,1)    }    if(pI == n){        return Pair(0,1)    }    for(i in 1 until n) {        val test = things[i]        val d = test modMinus root        var now = root        var total = 1        while(true) {            now = now modPlus d            if(now != root && all.contains(now)) {                total++                continue            } else {                break            }        }        now = root        while(true) {            now = now modMinus d            if(now != root && all.contains(now)) {                total++                continue            } else {                break            }        }        if(total == n) {            return Pair(now modPlus d,d)        }    }    return Pair(-1,-1)}  const val withBruteForce = falseconst val randCount = 100fun main(){    solve.cases{        pI = getint()        val n = getint()        val things = getline(n)         if(n >= pI /2){            val all = IntArray(pI){1}            for(a in things){                all[a]--            }            val newall = (0 until pI).filter{all[it] == 1}.toIntArray()            val ans = solve(newall)            if(ans.first == -1){                put(-1)            }else{                val (a,b) = ans                put(a modMinus b )                put(if(b == 0) 0 else pI - b)            }        }else{            val ans = solve(things)            if(ans.first == -1){                put(-1)            }else{                put(ans.first)                put(ans.second)            }        }     }    done()}const val singleCase = true","brute force,implementation,math,number theory"
"import java.util.* fun main() {    cases@for (c in 1..readLine()!!.toInt()) {        val h = readLine()!!.toInt()        val cache = mutableMapOf<Int, List<Int>>()        var answer = 0        var queries = 0        fun query(a: Int): List<Int> {            if (a !in cache) {                if (queries == 16) {                    answer = a                    return listOf()                }                queries++                println(""? $a"")                readLine()                val res = readLine()!!.split("" "").map { it.toInt() }                if (res.size == 2) {                    answer = a                    return listOf()                }                cache[a] = res            }            return cache[a]!!        }        val order = mutableListOf<Int>()        fun dfs(a: Int) {            var a = a            while (true) {                order.add(a)                var b = 0                for (c in query(a)) {                    if (c !in cache) {                        b = c                        break                    }                }                if (answer != 0) {                    return                }                if (b == 0) {                    return                }                a = b            }        }        dfs(1)        if (answer != 0) {            println(""! $answer"")            continue@cases        }        order.reverse()        order.removeAt(order.size - 1)        dfs(1)        if (answer != 0) {            println(""! $answer"")            continue@cases        }        while ((order.size / 2) < h - 4) {            val y = order.size / 2            while (order.size > y + 1) {                order.removeAt(order.size - 1)            }            var a = 0            for (c in query(order.last())) {                if (c !in cache) {                    a = c                    break                }            }            dfs(a)            if (answer != 0) {                println(""! $answer"")                continue@cases            }        }        val q = LinkedList<Int>()        q.add(order[order.size / 2])        while (q.isNotEmpty()) {            val a = q.remove()            for (b in query(a)) {                if (b !in cache) {                    q.add(b)                }            }            if (answer != 0) {                println(""! $answer"")                continue@cases            }        }    }}","constructive algorithms,implementation,interactive,trees"
"//New Year and Finding Rootsimport java.io.*import java.util.*import kotlin.math.*import kotlin.random.*//small hint, fixes the 1 extra query casefun main(){	val f = BufferedReader(InputStreamReader(System.`in`)) 	val random = Random(54321)   	for(q in 1..f.readLine().toInt()){		val n = f.readLine().toInt()  		var answer = -1		//store queries		val queries = HashMap<Int,List<Int>>()		//val seen = BooleanArray((1 shl (n+1)) + 2){false} 		fun query(i : Int) : List<Int>{			if(queries.containsKey(i)) return queries[i]!!			//seen[i] = true			println(""? $i"")			System.out.flush() 			val size = f.readLine().toInt()			queries[i] = f.readLine().split("" "").map{it.toInt()}.toMutableList()			return queries[i]!!		}   		if(n <= 4){			//query every node			for(k in 1 until (1 shl n)){				if(query(k).size == 2){					answer = k					break				}			}			println(""! $answer"")			System.out.flush()			continue		}    		fun test(i : Int, pa : Int, d : Int) : Boolean{			var cur = i			var p = pa			for(k in 0 until d-2){				val neis = query(cur)				if(neis.size == 1) return false				if(neis.size == 2){					answer = cur					return true				}				//pick next				for(nei in neis){					if(nei == p) continue					p = cur					cur = nei					break				}			} 			val last = query(cur)			if(last.size == 2){				answer = cur				return true			}			return last.size == 1		} 		//pick first node		val first = random.nextInt(1,1 shl n) 		val initial = mutableListOf<Int>()		initial.add(first) 		//query first		val initialneis = query(first) 		if(initialneis.size == 2){			println(""! $first"")			System.out.flush()			continue		}  		if(initialneis.size == 1){			var p = first			var i = initialneis[0] 			while(true){				initial.add(i)				val cur = query(i)				if(cur.size == 1){					break				}				if(cur.size == 2){					answer = i					break				}				//get next				for(nei in cur){					if(nei == p) continue					p = i					i = nei					break				}			}		} else {			//size is 3			//do one path			var p = first			var i = initialneis[0] 			while(answer == -1){				initial.add(0,i)				val cur = query(i)				if(cur.size == 1){					break				}				if(cur.size == 2){					answer = i					break				}				//get next				for(nei in cur){					if(nei == p) continue					p = i					i = nei					break				}			} 			p = first			i = initialneis[1] 			while(answer == -1){				initial.add(i)				val cur = query(i)				if(cur.size == 1){					break				}				if(cur.size == 2){					answer = i					break				}				//get next				for(nei in cur){					if(nei == p) continue					p = i					i = nei					break				}			} 		} 		if(answer != -1){			println(""! $answer"")			System.out.flush()			continue		} 		//get initial peak and initial depth		//println(initial.joinToString("" ""))		val ipeak = initial[initial.size/2]		val idepth = (initial.size+1)/2 		var next = -1		for(posnext in queries[ipeak]!!){			//if(posnext == initial[initial.size/2-1] || posnext == initial[initial.size/2+1]) continue			if(queries.containsKey(posnext)) continue			next = posnext			break		} 		var depth = idepth+1		//println(""$depth $next"")		if(depth == n){			answer = next		} else if(depth == n-1){			val nextneis1 = query(next)			for(nextnei in nextneis1){				if(query(nextnei).size == 2){					answer = nextnei					break				}			}		} 		if(answer != -1){			println(""! $answer"")			System.out.flush()			continue		} 		var parent = ipeak		while(depth < n-2 && answer == -1){			//go depth-1 times from next			val nextnei = query(next)			if(nextnei.size == 2){				answer = next				break			} 			//should have size 3			//pick one			var try1 = -1			var try2 = -1			for(posnei in nextnei){				if(posnei == parent) continue				if(try1 == -1) try1 = posnei				else try2 = posnei			}			//println(""$try1 $try2"")			//see if try1 works			if(!test(try1,next,depth)){				parent = next				next = try1			} else {				parent = next				next = try2			}  			depth++		}		if(answer != -1){			println(""! $answer"")			System.out.flush()			continue		}		//on depth 5, ,		//get the two nodes 		var n1 = -1		var n2 = -1 		var nextneis = query(next)		for(neis in nextneis){			if(neis == parent) continue			if(n1 == -1) n1 = neis			else n2 = neis		} 		val possibilities = mutableListOf<Int>()		val n1neis = query(n1)		val n2neis = query(n2) 		for(n1nei in n1neis){			if(n1nei == next) continue			possibilities.add(n1nei)		}		for(n2nei in n2neis){			if(n2nei == next) continue			possibilities.add(n2nei)		} 		for(k in 0 until 3){			if(query(possibilities[k]).size == 2){				answer = possibilities[k]				break			}		} 		if(answer == -1) answer = possibilities[3] 		println(""! $answer"")		System.out.flush()  	}}","constructive algorithms,implementation,interactive,trees"
"fun main(args: Array<String>) {    var (n, k) = readLine()!!.split("" "").map(String::toLong)    var i = 1    while (k % 2 == 0L) {        i++        k /= 2    }    println(i)}","binary search,bitmasks,constructive algorithms,implementation"
"fun main(args: Array<String>) {    var (n, k) = readLine()!!.split(' ').map { s -> s.toLong() }    val size = (1L shl n.toInt()) - 1    var l = 1L    var r = size    var pos = (l + r) / 2    while (pos != k) {        if (k > pos) {            l = pos            pos = (pos + r + 1) / 2        } else {            r = pos            pos = (l + pos) / 2        }        n--    }    println(n)}","binary search,bitmasks,constructive algorithms,implementation"
"import kotlin.math.absimport kotlin.math.sqrt fun main() {    val r = System.`in`.bufferedReader()    val sb = StringBuilder()    val (n, k) = r.readLine().split("" "").map { it.toLong() }    fun pow(int: Int): Long {        var num = int        var res = 1L        while (num > 0) {            res *= 2            num--        }        return res    }     // 1->3   2->7  3-> 15    fun f(n: Int, k: Long): Int {        val p = pow(n + 1)        when {            k == p / 2 -> return n + 1            k < p / 2 -> return f(n-1, k)            else -> return f(n-1, k-p/2)        }    }    sb.appendln(f(n.toInt(), k))    print(sb)}","binary search,bitmasks,constructive algorithms,implementation"
"import java.util.* fun main(args: Array<String>) = with(Scanner(System.`in`)){    val n = nextInt()    val k = nextLong()    val arrSize = getArrSize(n.toLong())    println(findTargetIndex(n.toLong(), arrSize, k - 1))  }fun findTargetIndex(step: Long, size: Long, targetIndex: Long): Long{    if(size == 1L) {        return 1L    }    val next = size / 2        if(next == targetIndex) {        return step    }    if(targetIndex > next) {        return findTargetIndex(step - 1, next, targetIndex - next - 1)    }        return findTargetIndex(step - 1, next, targetIndex)} fun getArrSize(step: Long): Long {     if(step <= 1L) {        return 1    }    return (2 * getArrSize(step - 1)) + 1}","binary search,bitmasks,constructive algorithms,implementation"
"import java.io.BufferedInputStreamimport java.io.BufferedReaderimport java.io.InputStreamReaderimport java.io.PrintWriterimport java.util.*import kotlin.math.abs val powersOfTwo =	intArrayOf(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144) class DisjointUnionSets(n:Int) {	var rank:IntArray	var parent:IntArray	var n:Int 	fun makeSet() {		for(i in 0 until n) {			parent[i] = i		}	} 	fun find(x:Int):Int {		if(parent[x] != x) {			parent[x] = find(parent[x])		}		return parent[x]	} 	fun union(x:Int, y:Int) {		val xRoot = find(x)		val yRoot = find(y)		if(xRoot == yRoot) return		if(rank[xRoot] < rank[yRoot])			parent[xRoot] = yRoot else if(rank[yRoot] < rank[xRoot])			parent[yRoot] = xRoot else {			parent[yRoot] = xRoot			rank[xRoot] = rank[xRoot] + 1		}	} 	init {		rank = IntArray(n)		parent = IntArray(n)		this.n = n		makeSet()	}} class FastScanner {	private val BS = 1 shl 16	private val NC = 0.toChar()	private val buf = ByteArray(BS)	private var bId = 0	private var size = 0	private var c = NC	private var `in`:BufferedInputStream? = null 	constructor() {		`in` = BufferedInputStream(System.`in`, BS)	} 	private val char:Char		private get() {			while(bId == size) {				size = try {					`in`!!.read(buf)				} catch(e:Exception) {					return NC				}				if(size == -1) return NC				bId = 0			}			return buf[bId++].toChar()		} 	fun nextInt():Int {		var neg = false		if(c == NC) c = char		while(c < '0' || c > '9') {			if(c == '-') neg = true			c = char		}		var res = 0		while(c >= '0' && c <= '9') {			res = (res shl 3) + (res shl 1) + (c - '0')			c = char		}		return if(neg) -res else res	} 	fun nextLong():Long {		var neg = false		if(c == NC) c = char		while(c < '0' || c > '9') {			if(c == '-') neg = true			c = char		}		var res = 0L		while(c >= '0' && c <= '9') {			res = (res shl 3) + (res shl 1) + (c - '0')			c = char		}		return if(neg) -res else res	} 	fun nextString():String {		if(c == NC) c = char		val ret = StringBuilder()		while(true) {			c = char			if(!isWhitespace(c)) {				break			}		}		ret.appendCodePoint(c.toInt())		while(true) {			c = char			if(isWhitespace(c)) {				break			}			ret.appendCodePoint(c.toInt());		}		return ret.toString()	} 	fun isWhitespace(c:Char):Boolean {		return c == ' ' || c == '\n' || c == '\r' || c == '\t'	}} class reading {	companion object {		var jin = FastScanner()		var pw = PrintWriter(System.out)	}} fun put(aa:Any) {	reading.pw.println(aa)} fun done() {	reading.pw.close()} fun getint():Int {	return reading.jin.nextInt()} fun getlong():Long {	return reading.jin.nextLong()} fun getline(n:Int):List<Int> {	return (1..n).map { reading.jin.nextInt() }} fun getlineL(n:Int):List<Long> {	return (1..n).map { reading.jin.nextLong() }} fun getstr():String {	return reading.jin.nextString()} inline fun cases(ask:() -> Unit) {	val t = getint()	repeat(t) {		ask()	}} fun just(a:Boolean) {	put(if(a) ""YES"" else ""NO"")} fun List<Int>.out() {	put(this.joinToString("" ""))} val List<Char>.ret:String	get() = this.joinToString("""") infix fun Long.divCeil(b:Long):Long{	//Positives numbers only!	if(this == 0L) {		return 0	}	return (this-1)/b + 1}fun main() {	val n = getint()	val arr = mutableListOf<Int>()	val D = mutableListOf<Int>() 	repeat(n){		arr.add(getint())		D.add(getint())	} 	val large = 1000	val oldScore = (0 until n).map{ large * arr[it] - it }	val newScore = (0 until n).map{		large * (arr[it] + D[it] ) - it	} 	val up = (0 until n).filter{newScore[it] >= oldScore[it]}	val down =  (0 until n).filter{newScore[it] < oldScore[it]} 	val upstart = up.map{Pair(it,oldScore[it])}	val downStart = down.map{Pair(it,oldScore[it])} 	val upResult = upstart.sortedBy { it.second }	val downResult = downStart.sortedByDescending { it.second } 	val finalReslts  = mutableListOf<Int>()	for((a,v) in upResult){		finalReslts.add(a)	}	for((b,v) in downResult){		finalReslts.add(b)	} //	println(finalReslts)	val st = TreeSet<Int>() 	for(i in oldScore){		st.add(i)	} 	var ret = 0	for(a in finalReslts){		val old = oldScore[a]		val new = newScore[a] 		val oldRank = st.subSet(old,Int.MAX_VALUE).size		st.remove(old)		st.add(new)		val newRank = st.subSet(new,Int.MAX_VALUE).size		ret += abs(newRank - oldRank) 	}	put(ret)	done()}","greedy,implementation"
"fun main(args: Array<String>) {    val n = readLine()!!.toInt()    for(i in 0 until n) {        val count = readLine()!!.toInt()        val midCount = if(count % 2 != 0) count / 2 + 1 else count / 2        val minSet = Array(midCount){0}        val maxSet = Array(midCount){0}        for(j in 0 until midCount) {            if(j*2+2 <= count) {                println(""? ${j*2+1} ${j*2+2}"")                val answer = readLine()                when(answer) {                    "">"" -> {                        minSet[j] = j*2+2                        maxSet[j] = j*2+1                    }                    else -> {                        maxSet[j] = j*2+2                        minSet[j] = j*2+1                    }                }            } else {                maxSet[j] = j*2+1                minSet[j] = j*2+1            }            System.out.flush()        }        var min = minSet[0]        var max = maxSet[0]        for(j in 0 until minSet.size - 1) {            println(""? $min ${minSet[j+1]}"")            val answer1 = readLine()            when (answer1) {                "">"" -> min = minSet[j+1]            }            System.out.flush()             println(""? $max ${maxSet[j+1]}"")            val answer2 = readLine()            when (answer2) {                ""<"" -> max = maxSet[j+1]            }            System.out.flush()        }        println(""! $min $max"")        System.out.flush()    }}","constructive algorithms,interactive"
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.random.Randomimport kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        IN = BufferedInputStream(fakein.toString().byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} fun getint():Int{ return IO.nextInt() }fun getlong():Long{ return IO.nextLong() }fun getline(n:Int):IntArray{    val ret = IntArray(n);repeat(n){ret[it] = getint()};return ret}fun getlineL(n:Int):LongArray{    val ret = LongArray(n);repeat(n){ret[it] = getlong()};return ret}fun getstr():String{ return IO.nextString() }fun MutableList<Int>.streamint(n:Int){ repeat(n){this.add(getint())}}fun MutableList<Long>.streamlong(n:Int){ repeat(n){this.add(getlong())}}inline fun cases(ask:()->Unit){ val t = getint();repeat(t){ ask() }} val List<Char>.ret:Stringget() = this.joinToString("""")infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    var str = """"    if(this is String){ str = this    }else if(this is Int){ str = this.toString()    }else if(this is Long){ str = this.toString()    }    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    inline fun cases(a:solve.()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint()} else if(mode == solveMode.tc){1 } else randCount         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            currentAnswer = null            currentBruteAnswer = null            a()        }        if(withBruteForce){            put(""Checked ${answersChecked}"")        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    inline fun brute(a:()->Unit){        if(withBruteForce){            a()        }    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }      var currentAnswer:String? = null    var currentBruteAnswer:String? = null    fun answer(a:Any){        currentAnswer = a.toString()        if(currentBruteAnswer != null){            checkAnswer()        }    }    fun put2(a:Any){answer(a);put(a) }     fun bruteAnswer(a:Any){        currentBruteAnswer = a.toString()        if(currentAnswer != null){            checkAnswer()        }    }    fun checkAnswer(){        if(currentAnswer != currentBruteAnswer){            throw Exception(""Failed Test: BF $currentBruteAnswer Current $currentAnswer"")        }        answersChecked ++    }}fun Int2(a:Int,b:Int) = List(a){IntArray(b)}fun Int3(a:Int,b:Int,c:Int) = List(a){List(b){IntArray(c)}}const val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}fun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionconst val funny = -777222777 // start array with this to be safe, WYSIconst val huge = Long.MAX_VALUE - 1_000_000_000_000_000L // used for seg tree thingsval Char.code :Int get() = this.toInt() -  'a'.toInt()  const val withBruteForce = falseconst val randCount = 100fun main(){    solve.cases{        val n = getint()        val c = getlong()         val U = getline(n)        val D = getline(n)         var DP = LongArray(n+1){huge}        DP[0] = 0L        var newDP = LongArray(n+1){huge}        for(s in 0 until n){            newDP.fill(huge)            val d = D[s]            val u = U[s]            for(i in 0 until n){                newDP[i+1] = minOf(newDP[i+1], DP[i] + d)            }            for(i in 0 until n){                newDP[i] = minOf(newDP[i], DP[i] + u + i * c)            }            val temp = newDP            newDP = DP            DP = temp//            just dei DP        }         put(DP.minOrNull()!!)    }    done()}const val singleCase = true  /*forgot initial conditoons of having 0bad variabln swap (newDP and DP)up and down sawp ( started off thinkign numbre of up, then become numbre of down halfway through) forgetting taking min  no single variable names!    - only indices are allowed    stupid overflow  */","dp,flows,greedy"
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.random.Randomimport kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        IN = BufferedInputStream(fakein.toString().byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} fun getint():Int{ return IO.nextInt() }fun getlong():Long{ return IO.nextLong() }fun getline(n:Int):IntArray{    val ret = IntArray(n);repeat(n){ret[it] = getint()};return ret}fun getlineL(n:Int):LongArray{    val ret = LongArray(n);repeat(n){ret[it] = getlong()};return ret}fun getstr():String{ return IO.nextString() }fun MutableList<Int>.streamint(n:Int){ repeat(n){this.add(getint())}}fun MutableList<Long>.streamlong(n:Int){ repeat(n){this.add(getlong())}}inline fun cases(ask:()->Unit){ val t = getint();repeat(t){ ask() }} val List<Char>.ret:Stringget() = this.joinToString("""")infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    var str = """"    if(this is String){ str = this    }else if(this is Int){ str = this.toString()    }else if(this is Long){ str = this.toString()    }    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    inline fun cases(a:solve.()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint()} else if(mode == solveMode.tc){1 } else randCount         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            currentAnswer = null            currentBruteAnswer = null            a()        }        if(withBruteForce){            put(""Checked ${answersChecked}"")        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    inline fun brute(a:()->Unit){        if(withBruteForce){            a()        }    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }      var currentAnswer:String? = null    var currentBruteAnswer:String? = null    fun answer(a:Any){        currentAnswer = a.toString()        if(currentBruteAnswer != null){            checkAnswer()        }    }    fun put2(a:Any){answer(a);put(a) }     fun bruteAnswer(a:Any){        currentBruteAnswer = a.toString()        if(currentAnswer != null){            checkAnswer()        }    }    fun checkAnswer(){        if(currentAnswer != currentBruteAnswer){            throw Exception(""Failed Test: BF $currentBruteAnswer Current $currentAnswer"")        }        answersChecked ++    }}fun Int2(a:Int,b:Int) = List(a){IntArray(b)}fun Int3(a:Int,b:Int,c:Int) = List(a){List(b){IntArray(c)}}const val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}fun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionconst val funny = -777222777 // start array with this to be safe, WYSIconst val huge = Long.MAX_VALUE - 1_000_000_000_000_000L // used for seg tree thingsval Char.code :Int get() = this.toInt() -  'a'.toInt()  const val withBruteForce = falseconst val randCount = 100fun main(){    solve.cases{        val n = getint()        val c = getlong()         val U = getline(n)        val D = getline(n)         var DP = LongArray(n+1){huge}        DP[0] = 0L        var newDP = LongArray(n+1){huge}        for(s in 0 until n){            val d = D[s]            val u = U[s]            newDP[0] = huge            for(i in 0..s){                newDP[i+1] = DP[i] + d            }            var res = u.toLong()            for(i in 0..s){                newDP[i] = minOf(newDP[i], DP[i] + res)                res += c            }            val temp = newDP            newDP = DP            DP = temp//            just dei DP        }         put(DP.minOrNull()!!)    }    done()}const val singleCase = true  /*forgot initial conditoons of having 0bad variabln swap (newDP and DP)up and down sawp ( started off thinkign numbre of up, then become numbre of down halfway through) forgetting taking min  no single variable names!    - only indices are allowed stupid overflow */","dp,flows,greedy"
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.random.Randomimport kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        IN = BufferedInputStream(fakein.toString().byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} fun getint():Int{ return IO.nextInt() }fun getlong():Long{ return IO.nextLong() }fun getline(n:Int):IntArray{    val ret = IntArray(n);repeat(n){ret[it] = getint()};return ret}fun getlineL(n:Int):LongArray{    val ret = LongArray(n);repeat(n){ret[it] = getlong()};return ret}fun getstr():String{ return IO.nextString() }fun MutableList<Int>.streamint(n:Int){ repeat(n){this.add(getint())}}fun MutableList<Long>.streamlong(n:Int){ repeat(n){this.add(getlong())}}inline fun cases(ask:()->Unit){ val t = getint();repeat(t){ ask() }} val List<Char>.ret:Stringget() = this.joinToString("""")infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    var str = """"    if(this is String){ str = this    }else if(this is Int){ str = this.toString()    }else if(this is Long){ str = this.toString()    }    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    inline fun cases(a:solve.()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint()} else if(mode == solveMode.tc){1 } else randCount         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            currentAnswer = null            currentBruteAnswer = null            a()        }        if(withBruteForce){            put(""Checked ${answersChecked}"")        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    inline fun brute(a:()->Unit){        if(withBruteForce){            a()        }    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }      var currentAnswer:String? = null    var currentBruteAnswer:String? = null    fun answer(a:Any){        currentAnswer = a.toString()        if(currentBruteAnswer != null){            checkAnswer()        }    }    fun put2(a:Any){answer(a);put(a) }     fun bruteAnswer(a:Any){        currentBruteAnswer = a.toString()        if(currentAnswer != null){            checkAnswer()        }    }    fun checkAnswer(){        if(currentAnswer != currentBruteAnswer){            throw Exception(""Failed Test: BF $currentBruteAnswer Current $currentAnswer"")        }        answersChecked ++    }}fun Int2(a:Int,b:Int) = List(a){IntArray(b)}fun Int3(a:Int,b:Int,c:Int) = List(a){List(b){IntArray(c)}}const val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}fun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionconst val funny = -777222777 // start array with this to be safe, WYSIconst val huge = Long.MAX_VALUE - 1_000_000_000_000_000L // used for seg tree thingsval Char.code :Int get() = this.toInt() -  'a'.toInt()  const val withBruteForce = falseconst val randCount = 100fun main(){    solve.cases{        val n = getint()        val c = getlong()         val U = getline(n)        val D = getline(n)         var DP = LongArray(n+1){huge}        DP[0] = 0L        var newDP = LongArray(n+1){huge}        for(s in 0 until n){            newDP.fill(huge,0,s+2)            val d = D[s]            val u = U[s]            for(i in 0..s){                newDP[i+1] = minOf(newDP[i+1], DP[i] + d)            }            var res = u.toLong()            for(i in 0..s){                newDP[i] = minOf(newDP[i], DP[i] + res)                res += c            }            val temp = newDP            newDP = DP            DP = temp//            just dei DP        }         put(DP.minOrNull()!!)    }    done()}const val singleCase = true  /*forgot initial conditoons of having 0bad variabln swap (newDP and DP)up and down sawp ( started off thinkign numbre of up, then become numbre of down halfway through) forgetting taking min  no single variable names!    - only indices are allowed stupid overflow */","dp,flows,greedy"
"import java.io.BufferedInputStreamimport java.io.Fileimport java.io.PrintWriterimport kotlin.random.Randomimport kotlin.system.measureTimeMillis inline fun TIME(f:()->Unit){    val t = measureTimeMillis(){        f()    }    println(""$t ms"")} object IO{    private const val BS = 1 shl 16    private const val NC = 0.toChar()    private val buf = ByteArray(BS)    private var bId = 0    private var size = 0    private var c = NC     var warningActive = true    var fakein = StringBuilder()     private var IN: BufferedInputStream = BufferedInputStream(System.`in`, BS)    val OUT: PrintWriter = PrintWriter(System.out)     private val char: Char        get() {            while (bId == size) {                size = IN.read(buf) // no need for checked exceptions                if (size == -1) return NC                bId = 0            }            return buf[bId++].toChar()        }     fun nextInt(): Int {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextLong(): Long {        var neg = false        if (c == NC) c = char        while (c < '0' || c > '9') {            if (c == '-') neg = true            c = char        }        var res = 0L        while (c in '0'..'9') {            res = (res shl 3) + (res shl 1) + (c - '0')            c = char        }        return if (neg) -res else res    }    fun nextString():String{        val ret = StringBuilder()        while (true){            c = char            if(!isWhitespace(c)){ break}        }        ret.append(c)        while (true){            c = char            if(isWhitespace(c)){ break}            ret.append(c)        }        return ret.toString()    }    fun isWhitespace(c:Char):Boolean{        return c == ' ' || c == '\n' || c == '\r' || c == '\t'    }    fun rerouteInput(){        if(warningActive){            put(""You forgot to disable tests you digital dummy!"")            println(""You forgot to disable tests you digital dummy!"")            warningActive = false        }        IN = BufferedInputStream(fakein.toString().byteInputStream(),BS)    }    fun takeFile(name:String){        IN = BufferedInputStream(File(name).inputStream(),BS)    }}fun put(aa:Any){ IO.OUT.println(aa)}fun done(){ IO.OUT.close() }fun share(aa:Any){    if(aa is IntArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is LongArray){IO.fakein.append(aa.joinToString("" ""))}    else if(aa is List<*>){IO.fakein.append(aa.toString())}    else{IO.fakein.append(aa.toString())}    IO.fakein.append(""\n"")} fun getint():Int{ return IO.nextInt() }fun getlong():Long{ return IO.nextLong() }fun getline(n:Int):IntArray{    val ret = IntArray(n);repeat(n){ret[it] = getint()};return ret}fun getlineL(n:Int):LongArray{    val ret = LongArray(n);repeat(n){ret[it] = getlong()};return ret}fun getstr():String{ return IO.nextString() }fun MutableList<Int>.streamint(n:Int){ repeat(n){this.add(getint())}}fun MutableList<Long>.streamlong(n:Int){ repeat(n){this.add(getlong())}}inline fun cases(ask:()->Unit){ val t = getint();repeat(t){ ask() }} val List<Char>.ret:Stringget() = this.joinToString("""")infix fun Any.dei(a:Any){    //does not stand for anything it is just easy to type, have to be infix because kotlin does not have custom prefix operators    var str = """"    if(this is String){ str = this    }else if(this is Int){ str = this.toString()    }else if(this is Long){ str = this.toString()    }    if(a is List<*>){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is IntArray){ println(""$str : ${a.joinToString("" "")}"")    }else if(a is LongArray){ println(""$str : ${a.joinToString("" "")}"")    }else{ println(""$str : $a"")    }}val just = "" "" // usage: just dei x , where x is the debug variablefun crash(){throw Exception(""Bad programme"")} // because assertion does not workfun assert(a:Boolean){    if(!a){throw Exception(""Failed Assertion"")    }}enum class solveMode {    real, rand, tc}object solve{    var mode:solveMode = solveMode.real    var tcNum:Int = 0    var rand:()->Unit = {}    var TC:MutableMap<Int,()->Unit> = mutableMapOf()    var answersChecked = 0    var tn:Long = 0    inline fun cases(a:solve.()->Unit){        val t = if(mode == solveMode.real){if(singleCase) 1 else getint()} else if(mode == solveMode.tc){1 } else randCount         if(t == 1 && mode != solveMode.real){            tn = System.currentTimeMillis()        }        repeat(t){            if(mode == solveMode.tc){                TC[tcNum]?.let { it() }                IO.rerouteInput()            }else if(mode == solveMode.rand){                rand()                IO.rerouteInput()            }            currentAnswer = null            currentBruteAnswer = null            a()        }        if(withBruteForce){            put(""Checked ${answersChecked}"")        }        if(t == 1 && mode != solveMode.real){            val dt = System.currentTimeMillis() - tn            println(""Time $dt ms "")        }    }    inline fun singleCase(a:solve.()->Unit){        val t = if(mode != solveMode.rand){1} else randCount        repeat(t) { a() }    }    fun rand(a:()->Unit){        this.rand = a    }    fun tc(id:Int = 0,a:()->Unit){        TC[id] = a    }    inline fun brute(a:()->Unit){        if(withBruteForce){            a()        }    }    fun usetc(a:Int = 0 ){        this.tcNum = a        this.mode = solveMode.tc    }    fun userand(){        this.mode = solveMode.rand    }      var currentAnswer:String? = null    var currentBruteAnswer:String? = null    fun answer(a:Any){        currentAnswer = a.toString()        if(currentBruteAnswer != null){            checkAnswer()        }    }    fun put2(a:Any){answer(a);put(a) }     fun bruteAnswer(a:Any){        currentBruteAnswer = a.toString()        if(currentAnswer != null){            checkAnswer()        }    }    fun checkAnswer(){        if(currentAnswer != currentBruteAnswer){            throw Exception(""Failed Test: BF $currentBruteAnswer Current $currentAnswer"")        }        answersChecked ++    }}fun Int2(a:Int,b:Int) = List(a){IntArray(b)}fun Int3(a:Int,b:Int,c:Int) = List(a){List(b){IntArray(c)}}const val p = 1000000007Lconst val pI = p.toInt()fun Int.adjust():Int{ if(this >= pI){ return this  - pI }else if (this < 0){ return this + pI };return this }fun Int.snap():Int{ if(this >= pI){return this - pI} else return this}fun IntArray.put(i:Int,v:Int){ this[i] = (this[i] + v).adjust() }val Boolean.chi:Int get() = if(this) 1 else 0 //characteristic functionconst val funny = -777222777 // start array with this to be safe, WYSIconst val huge = Long.MAX_VALUE - 1_000_000_000_000_000L // used for seg tree thingsval Char.code :Int get() = this.toInt() -  'a'.toInt()  const val withBruteForce = falseconst val randCount = 100fun main(){    solve.cases{        val n = getint()        val c = getlong()         val U = getline(n)        val D = getline(n)         var DP = LongArray(n+1){huge}        DP[0] = 0L        var newDP = LongArray(n+1){huge}        for(s in 0 until n){            newDP.fill(huge)            val d = D[s]            val u = U[s]            for(i in 0 until n){                newDP[i+1] = minOf(newDP[i+1], DP[i] + d)            }            var res = u.toLong()            for(i in 0 until n){                newDP[i] = minOf(newDP[i], DP[i] + res)                res += c            }            val temp = newDP            newDP = DP            DP = temp//            just dei DP        }         put(DP.minOrNull()!!)    }    done()}const val singleCase = true  /*forgot initial conditoons of having 0bad variabln swap (newDP and DP)up and down sawp ( started off thinkign numbre of up, then become numbre of down halfway through) forgetting taking min  no single variable names!    - only indices are allowed stupid overflow */","dp,flows,greedy"
"fun main(vararg args: String) {    val n = readLine()!!.toInt()    val s = readLine()!!    var countInside = 0    val noPar = s.replace(""""""\((.*?)\)"""""".toRegex()) {        countInside += it.groupValues[1].splitToSequence('_').filter { it.length > 0 }.count()        ""_""    }    val maxLengthOutside = noPar.splitToSequence('_').map {it.length}.max() ?: 0    println(""$maxLengthOutside $countInside"")}","expression parsing,implementation,strings"
"import kotlin.math.max fun main() {    var insideParenthesis = false    readLine()    var countInside = 0    var maxOutside = 0    var count = 0    for (c in readLine()!!)        when (c) {            '_' -> {                if (insideParenthesis && count > 0) countInside++                count = 0            }            '(' -> {                insideParenthesis = true                count = 0            }            ')' -> {                if (count > 0) countInside++                insideParenthesis = false                count = 0            }            else -> {                count++                if (!insideParenthesis) maxOutside = max(maxOutside, count)            }        }    print(""$maxOutside $countInside"")}","expression parsing,implementation,strings"
"fun main() {    val r = System.`in`.bufferedReader()    val sb = StringBuilder()    val n = r.readLine().toInt()    val s = r.readLine()    val ss = s.toMutableList()    val left = mutableListOf<Int>()    val right = mutableListOf<Int>()    for (i in 0 until n) {        when {            s[i] == '(' -> left += i            s[i] == ')' -> right += i        }    }    val size = left.size    var ans2 = 0    for (i in 0 until size) {        ans2 += s.substring(left[i]+1..right[i]-1).split(""_"").filter { it.isNotEmpty() }.size        //println(s.substring(left[i]+1..right[i]-1).split(""_"").filter { it.isNotEmpty() })        (left[i]..right[i]).forEach { ss[it] = '_' }    }    val ans1 = ss.joinToString("""").split(""_"").filter { it.isNotEmpty() }.maxBy { it.length }?.length ?: 0    sb.appendln(""$ans1 $ans2"")    print(sb)}","expression parsing,implementation,strings"
"import java.io.BufferedReaderimport java.io.InputStreamReader fun main(args: Array<String>) {    val br = BufferedReader(InputStreamReader(System.`in`))    br.readLine()     val s = br.readLine() + ""_""     var longestWord = 0    var wordCount = 0    var inParentheses = false    var charCount = 0     fun wordSplit() {        if (charCount > 0)            if (inParentheses) {                wordCount++            } else {                longestWord = Math.max(longestWord, charCount)            }        charCount = 0    }     fun character() {        charCount++    }      s.forEach {        when (it) {            '_' -> wordSplit()            '(' -> {                wordSplit()                inParentheses = true            }            ')' -> {                wordSplit()                inParentheses = false            }            else -> character()        }    }     println(""$longestWord $wordCount"") }","expression parsing,implementation,strings"
"fun main(args: Array<String>) {    val f = readLine()!!.toInt()    var (h, m) = readLine()!!.split(':').map(String::toInt)    if (m >= 60) m = m % 10    if (f == 12) {        if (h < 1 || h > 12) {            if (h % 10 == 0) h = 10 else h %= 10        }    } else {        if (h >= 24) h %= 10    }    println(""${h / 10}${h % 10}:${m / 10}${m % 10}"")}","brute force,implementation"
"fun main(args: Array<String>) {    val n = readLine()!!.toInt()    var s = readLine()!!.split("":"").toMutableList()    if (n == 12) {        if (s[0].toInt() > 12) {            if (s[0][1] > '2') s[0] = ""0"" + s[0].drop(1)            else s[0] = ""1"" + s[0].drop(1)        } else if (s[0].toInt() == 0) s[0] = ""1"" + s[0].drop(1)    } else if (s[0].toInt() > 23) s[0] = ""0"" + s[0].drop(1)     if (s[1].toInt() >= 60) s[1] = ""0"" + s[1].drop(1)    print(s.joinToString("":""))}","brute force,implementation"
"fun main() {    val type = readLine()!!    val t = readLine()!!    val hours = t.substring(0, 2).toInt()    val minutes = t.substring(3, 5).toInt()    val sb = StringBuilder()    if (type[0] == '1') {        when {            hours == 0 -> sb.append(""01"")            hours <= 12 -> sb.append(t.substring(0, 2))            t[1] == '0' -> sb.append(""10"")            else -> sb.append(""0${t[1]}"")        }    } else {        if (hours <= 23) sb.append(t.substring(0, 2)) else sb.append(""1${t[1]}"")    }    sb.append(':')    if (minutes < 60) sb.append(t.substring(3, 5)) else sb.append(""0${t[4]}"")    print(sb.toString())}","brute force,implementation"
"import java.io.*import java.util.* fun dif(a: Int, b: Int) : Int {  val x = a - b  return (if (x / 10 == 0) 0 else 1) + (if (x % 10 == 0) 0 else 1)} fun solve(start: Int, end: Int, num: Int) : Int {  var minDif = 3  var minv = -1  for (i in start..end) {    var d = dif(i, num)    if (d < minDif) {      minDif = d      minv = i    }  }  return minv} fun main(args : Array<String>) {//  val fin = Scanner(File(""a.in""))  val fin = Scanner(System.`in`)  val form = fin.nextInt()  val sh = if (form == 12) 1 else 0  val eh = if (form == 12) 12 else 23  val sm = 0  val em = 59  val str = fin.next()  val hours = str.substring(0, 2).toInt()  val mins = str.substring(3, 5).toInt()  print(""%02d"".format(solve(sh, eh, hours)))  print("":"")  print(""%02d"".format(solve(sm, em, mins)))  fin.close()}","brute force,implementation"
"import kotlin.math.minimport kotlin.math.sqrt fun main() {    fun readInt() = readLine()!!.toInt()    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val (a, b) = readInts()    val numTaxis = readInt()    var output = Double.MAX_VALUE    repeat(numTaxis) {        val (x, y, v) = readInts()        output = min(output, sqrt(((a - x) *(a - x) + (b - y) * (b - y)).toDouble()) / v)    }    print(output)}","brute force,geometry,implementation"
"import kotlin.math.sqrt fun main() {    val r = System.`in`.bufferedReader()    val s1 = StringBuilder()    //val n = r.readLine()!!.toInt()    val (x, y) = r.readLine()!!.split("" "").map { it.toInt() }    var time = Double.MAX_VALUE    repeat(r.readLine()!!.toInt()){        val (a, b, s) = r.readLine()!!.split("" "").map { it.toDouble() }        val dis = sqrt((a-x)*(a-x)+(b-y)*(b-y))        val t = dis/s        time = minOf(time, t)    }    println(time)}","brute force,geometry,implementation"
"fun main(args: Array<String>) {    val (x0, y0) = readLine()!!.split(' ').map(String::toDouble)    var n = readLine()!!.toInt()    var ans: Double = 1e9    // print(""x0 = $x0, y0 = $y0\n"")    // print(""n = $n\n"")    while (n > 0) {        var (x, y, v) = readLine()!!.split(' ').map(String::toDouble)        x -= x0        y -= y0        val tmp = Math.sqrt(x * x + y * y) / v        ans = if (tmp < ans) tmp else ans        n--    }    val s = ""%.6f"".format(ans)    print(""$s\n"")}","brute force,geometry,implementation"
import java.util.Scanner fun main(){    val input = Scanner(System.`in`)    var home_x : Int = input.nextInt()    var home_y : Int = input.nextInt()    var cars_num : Int = input.nextInt()    var minimum_time : Double = 1000.0    for(i in 1..cars_num){        var car_x : Double = input.nextDouble()        var car_y : Double = input.nextDouble()        var car_speed : Double = input.nextDouble()        var x_distance : Double = home_x - car_x;        x_distance *= x_distance;        var y_distance : Double = home_y - car_y;        y_distance *= y_distance        var div : Double = Math.sqrt(x_distance + y_distance)        div /= car_speed        if(minimum_time > div){            minimum_time = div        }    }    print(minimum_time)},"brute force,geometry,implementation"
"import java.io.BufferedInputStreamimport java.io.BufferedReaderimport java.io.InputStreamReaderimport java.io.PrintWriterimport java.util.*import kotlin.math.absimport kotlin.system.measureTimeMillisimport java.util.*import java.math.BigInteger class FastScanner {	private val BS = 1 shl 16	private val NC = 0.toChar()	private val buf = ByteArray(BS)	private var bId = 0	private var size = 0	private var c = NC	private var `in`:BufferedInputStream? = null 	constructor() {		`in` = BufferedInputStream(System.`in`, BS)	} 	private val char:Char		private get() {			while(bId == size) {				size = try {					`in`!!.read(buf)				} catch(e:Exception) {					return NC				}				if(size == -1) return NC				bId = 0			}			return buf[bId++].toChar()		} 	fun nextInt():Int {		var neg = false		if(c == NC) c = char		while(c < '0' || c > '9') {			if(c == '-') neg = true			c = char		}		var res = 0		while(c >= '0' && c <= '9') {			res = (res shl 3) + (res shl 1) + (c - '0')			c = char		}		return if(neg) -res else res	} 	fun nextLong():Long {		var neg = false		if(c == NC) c = char		while(c < '0' || c > '9') {			if(c == '-') neg = true			c = char		}		var res = 0L		while(c >= '0' && c <= '9') {			res = (res shl 3) + (res shl 1) + (c - '0')			c = char		}		return if(neg) -res else res	} 	fun nextString():String {		if(c == NC) c = char		val ret = StringBuilder()		while(true) {			c = char			if(!isWhitespace(c)) {				break			}		}		ret.appendCodePoint(c.toInt())		while(true) {			c = char			if(isWhitespace(c)) {				break			}			ret.appendCodePoint(c.toInt());		}		return ret.toString()	} 	fun isWhitespace(c:Char):Boolean {		return c == ' ' || c == '\n' || c == '\r' || c == '\t'	}} class reading {	companion object {		var jin = FastScanner()		var pw = PrintWriter(System.out)	}} fun put(aa:Any) {	reading.pw.println(aa)} fun done() {	reading.pw.close()} fun getint():Int {	return reading.jin.nextInt()} fun getlong():Long {	return reading.jin.nextLong()} fun getline(n:Int):List<Int> {	return (1..n).map { reading.jin.nextInt() }} fun getlineL(n:Int):List<Long> {	return (1..n).map { reading.jin.nextLong() }} fun getstr():String {	return reading.jin.nextString()} fun List<Int>.out() {	put(this.joinToString("" ""))} val List<Char>.ret:String	get() = this.joinToString("""") fun just(a:Boolean) {	put(if(a) ""YES"" else ""NO"")} inline fun cases(ask:() -> Unit) {	val t = getint()	repeat(t) {		ask()	}} infix fun Long.divCeil(b:Long):Long {	//Positives numbers only!	if(this == 0L) {		return 0	}	return (this - 1) / b + 1} inline fun BinarySearchLastTrue(l:Int, r:Int, isTrue:(Int) -> Boolean):Int? {	//inclusive	var L = l	var R = r	while(L < R) {		val m = (L + R) / 2 + 1		if(isTrue(m)) {			L = m		} else {			R = m - 1		}	}	return if(isTrue(L)) {		L	} else {		null	}} inline fun BinarySearchFirstTrue(l:Int, r:Int, isTrue:(Int) -> Boolean):Int? {	//inclusive	var L = l	var R = r	while(L < R) {		val m = (L + R) / 2		if(isTrue(m)) {			R = m		} else {			L = m + 1		}	}	return if(isTrue(L)) {		L	} else {		if(L == r) {			null		} else {			L + 1		}	}} inline fun BinarySearchExact(value:Int, l:Int, r:Int, find:(Int) -> Int):Int? {	//find shoudl be increasing	var L = l	var R = r	while(L < R) {		val m = (L + R) / 2		if(value <= find(m)) {			R = m		} else {			L = m + 1		}	}	return if(find(L) == value) {		L	} else {		null	}} inline fun TIME(f:() -> Unit) {	val t = measureTimeMillis() {		f()	}	println(t)} val powersOfTwo =	intArrayOf(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144) class Graph(val n:Int, val directed:Boolean) {	val E = Array<MutableList<Int>>(n + 1) { mutableListOf() } 	fun streamEdges(m:Int) {		repeat(m) {			val x = getint()			val y = getint()			E[x].add(y)			if(!directed) {				E[y].add(x)			}		}	} 	fun BFS() {		val root = 1		val toDo:Queue<Int> = LinkedList<Int>()		val explored = IntArray(n + 1)		toDo.add(root)		explored[root] = 1 		while(toDo.size > 0) {			val x = toDo.remove()			val things = E[x]			for(a in things) {				if(explored[a] == 0) {					explored[a] = 1					toDo.add(a)				}			}		}	} 	fun DFS() {		val root = 1		val toDo = ArrayDeque<Int>()		val explored = IntArray(n + 1)		toDo.add(root)		explored[root] = 1 		while(toDo.size > 0) {			val x = toDo.removeLast()			val things = E[x]			for(a in things) {				if(explored[a] == 0) {					explored[a] = 1					toDo.addLast(a)				}			}		}	} 	val parents = IntArray(n + 1)	val depth = IntArray(n + 1)	val DFSorder = IntArray(n + 1)	var DFSPointer = 1	val treeSize = IntArray(n + 1)	val transOrder = mutableListOf<Int>()	val transCount = IntArray(n + 1)	var nes = IntArray(n + 1) 	fun reached(i:Int) {		nes[i] *= -1		transOrder.add(i)	} 	fun DFSTransversalDiTree() {		fun go(i:Int, from:Int, d:Int):Int {			depth[i] = d			DFSorder[DFSPointer] = i			DFSPointer += 1			reached(i)			var size:Int = 1			for(v in E[i]) {				if(v != from) {					size += go(v, i, d + 1)					parents[v] = i					reached(i)				}			}			if(nes[i] == -1 && i != 1) {				nes[i] = 1				nes[from] *= -1				transOrder.add(from)				transOrder.add(i)			}//            f(i)			treeSize[i] = size			return size		}		DFSPointer = 1		go(1, 0, 0)		parents[1] = 1 		if(nes[1] == -1) {			val any = E[1].first()			transOrder.add(any)			transOrder.add(1)			transOrder.add(any)		} 		println(transOrder.joinToString("" ""))	} 	fun add(a:Int, b:Int) {		E[a].add(b)		if(!directed) {			E[b].add(a)		}	} 	fun DFSrecur() {		val root = 1		val explored = IntArray(n + 1)		//        var calls = 0		fun go(i:Int, from:Int) {//            calls += 1			for(v in E[i]) {				if(v != from) {					go(v, i)				}			}		}		go(1, 0)	} 	val quickParents = mutableListOf<IntArray>()	fun calQuickPA() {		var needed = 1		var total = this.n		while(total > 1) {			total = total shr 1			needed += 1		}		quickParents.add(parents)		for(i in 1..needed) {			val previous = quickParents.last()			val new = IntArray(n + 1)			for(a in new.indices) {				new[a] = previous[previous[a]]			}			quickParents.add(new)		}	} 	fun calParent(i:Int, l:Int):Int {		var now = i		var layer = l 		for((i, p) in powersOfTwo.withIndex()) {			if(p > layer) {				break			}			if(p and layer > 0) {				now = quickParents[i][now]				layer -= p			}		}		return now	} 	fun isParent(i:Int, of:Int):Boolean {		val a = depth[i]		val b = depth[of]		if(a > b) {			return false		} else {			return calParent(of, b - a) == a		}	}} fun <K> MutableMap<K, Int>.addone(key:K) {	this[key] = this.getOrDefault(key, 0) + 1} fun <K> MutableMap<K, Int>.subone(key:K) {	val pe = this[key]	if(pe == 0 || pe == null) {		throw Exception(""Removing what is already empty "")	} else {		this[key] = pe - 1		if(pe == 1) {			this.remove(key)		}	}} fun generic2D(n:Int, m:Int):List<List<Int>> {	val thing = mutableListOf<List<Int>>()	for(i in 0 until n) {		thing.add(List(m) { it + i * m })	}	return thing} fun <T> List<List<T>>.printSquare() {	for(a in this) {		println(a.joinToString("" ""))	}}//100ms for standardfun main() {	val n = getint()	val k = getlong()	val F = getline(n)	val W = getlineL(n) 	val quickF = mutableListOf<IntArray>()	val qsum = mutableListOf<LongArray>()	val qweight = mutableListOf<LongArray>() 	quickF.add(F.toIntArray())	qsum.add(W.toLongArray())	qweight.add(W.toLongArray()) 	for(i in 1..64){		if((1L shl i) > 1e11){			break		}//		val size = 1 shl i		val last = quickF.last()		val lastSum = qsum.last()		val lastWeight = qweight.last() 		val new = IntArray(n) 		val newSum = LongArray(n)		val newWeight = LongArray(n)		for(i in 0 until n){			val a = i			val b = last[i]			val c = last[b] 			new[i] = c			newSum[i] = lastSum[a] + lastSum[b]			newWeight[i] = minOf(lastWeight[a], lastWeight[b])		}		quickF.add(new)		qsum.add(newSum)		qweight.add(newWeight)	} //	var remaining = k	var current = IntArray(n){it}	val retSum = LongArray(n)	val retWeight = LongArray(n){Long.MAX_VALUE}	for(a in 0..64){		val s = 1L shl a 		if(s > k){			break		}//		println(""$s $a"")		if(s and k == 0L){			continue		}//		println(""Proceeded $a"")		for(i in 0 until n ){			val cu = current[i]			retSum[i] += qsum[a][cu]			retWeight[i] = minOf(retWeight[i],qweight[a][cu])		}		val newCurrent = IntArray(n)		for(i in 0 until n){			newCurrent[i] = quickF[a][current[i]]		}		current = newCurrent	}	for(i in 0 until n){		put(retSum[i])		put(retWeight[i])	}	done() } tailrec fun gcd(a:Int, b:Int):Int {	return if(a % b == 0) Math.abs(b) else gcd(b, a % b)} ","data structures,graphs"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min class Cc(stream: InputStream, private val out: java.io.PrintWriter) {     var asdf: String? = ""abcdefghijklmnopqrstuvwxyz""    var ma = StringBuilder(asdf);    fun findIndex(x: Char): Int {        for (i in 0..25) {            if (ma!![i] === x) return i        }        return -1    }     var d : CharArray = CharArray(4)    var q = ArrayList<Int>();    var m =  ArrayList<Int>();     var ts = TreeSet<Long>();    var st = Stack<Long>();    var max = 4444444444      var value = -1;     fun getDigit() {        var f = 2345;        var digit = f % 10    }      fun bSearch(arr :IntArray, start: Int, end: Int) :Int {         if(start > end) return value;         var mid = (start + end) / 2;        if (arr[mid] == mid) {            value = mid            return bSearch(arr, 0, mid - 1);        }        if (arr[mid] < mid)  return bSearch(arr, mid+1, end);        if (arr[mid] > mid)  return bSearch(arr, 0, mid-1);        return value;    }    var arr = IntArray(11);    fun binarySearch() {        arr[0] = -10        arr[1] = -5        arr[2] = -2        arr[3] = 0        arr[4] = 4        arr[5] = 5        arr[6] = 6        arr[7] = 7        arr[8] = 8        arr[9] = 9        arr[10] = 10          var q =bSearch(arr, 0, 10)        System.out.println(q)    }     fun isNumber(f: Char) : Boolean {        return  Character.isDigit(f);    }     fun isUnderScore(f: Char) : Boolean {        return  ((f == '-')|| (f == '_'))    }     fun isUpperCase(f : Char) : Boolean{        return f.isUpperCase();    }     val mod = 1e9.toLong() + 7    fun pow(x: Long, p: Long): Long {        var x = x        var p = p        var ans: Long = 1        while (p > 0) {            if (p and 1 == 1L) ans = ans * x % mod            x = x * x % mod            p = p shr 1        }        return ans    }      fun solve() {        var n = ns().toCharArray()        var count = 0L;        for(m in  0 until n.size) {            var s = 0;           if(isNumber(n[m])) {               s = Integer.parseInt(n[m].toString());           }else if(isUnderScore((n[m]))) {               if((n[m] == '-')) s = 62               if((n[m] == '_')) s = 63           }else if(isUpperCase(n[m])) {                s = n[m].toInt() - 55           }else {               s = n[m].toInt() - 61           }            count+= 6-Integer.bitCount(s)        }         System.out.println(pow(3,count));       }       fun gcd(x: Int, y: Int): Int = if (y == 0) x else gcd(y, x % y)     private val isDebug = try {        System.getenv(""MY_DEBUG"") != null    } catch (t: Throwable) {        false    }     private var tokenizer: StringTokenizer? = null    private val reader = BufferedReader(InputStreamReader(stream), 32768)    private fun next(): String {        while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {            tokenizer = StringTokenizer(reader.readLine())        }        return tokenizer!!.nextToken()    }     private fun ni() = next().toInt()    private fun nl() = next().toLong()    private fun ns() = next()    private fun na(n: Int, offset: Int = 0): IntArray {        return map(n) { ni() + offset }    }    private fun nal(n: Int, offset: Int = 0): LongArray {        val res = LongArray(n)        for (i in 0 until n) {            res[i] = nl() + offset        }        return res    }     private fun na2(n: Int, offset: Int = 0): Array<IntArray> {        val a  = Array(2){IntArray(n)}        for (i in 0 until n) {            for (e in a) {                e[i] = ni() + offset            }        }        return a    }     private inline fun map(n: Int, f: (Int) -> Int): IntArray {        val res = IntArray(n)        for (i in 0 until n) {            res[i] = f(i)        }        return res    }     private inline fun debug(msg: () -> String) {        if (isDebug) System.err.println(msg())    }     private fun debug(a: LongArray) {        debug { a.joinToString("" "") }    }     private fun debug(a: IntArray) {        debug { a.joinToString("" "") }    }     private fun debug(a: BooleanArray) {        debug { a.map { if (it) 1 else 0 }.joinToString("""") }    }     private fun debugDim(A: Array<LongArray>) {        if (isDebug) {            for (a in A) {                debug(a)            }        }    }    private fun debugDim(A: Array<IntArray>) {        if (isDebug) {            for (a in A) {                debug(a)            }        }    }     private fun hoge() {        min(1, 2)        max(1, 2)        abs(-10)    }} fun main() {    val out = java.io.PrintWriter(System.out)    Cc(System.`in`, out).solve()    out.flush()}","bitmasks,combinatorics,implementation,strings"
"fun main() {    val (n, h) = readLine()!!.split("" "").map(String::toInt)    println(n + readLine()!!.split("" "").map(String::toInt).count { it > h })}",implementation
"fun main(args:Array<String>){    val (x, h) = readLine()!!.split("" "").map{it.toInt()}    print(readLine()!!.split("" "").map({if (it.toInt() > h) 2 else 1}).sum())}",implementation
"fun main() {    var (n, h) = readLine()!!.split("" "").map { it.toInt() }    val a = readLine()!!.split("" "").map { it.toInt() }    n += a.count { it > h }    print(n)}",implementation
"fun main(args : Array<String>){    val (x, h) = readLine()!!.split("" "").map { it.toInt() }    print(readLine()!!.split("" "").map({ if (it.toInt() > h) 2 else 1 }).sum())}",implementation
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.lang.AssertionErrorimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007 class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  private val reader = BufferedReader(InputStreamReader(stream), 32768)   private val N = ni()  private val K = ni()  fun solve() {    val T = ns().map { it-'a' }    val cnt = LongArray(K + 1)    val lst = IntArray(K + 1){-1}    lst[K] = 0    cnt[K] = 1    for (i in T.indices) {      val c = T[i]      cnt[c] = cnt.sum() % MOD      lst[c] = i + 1    }    debug(cnt)    debug(lst)    val inf = 1e9.toInt()    for (i in 0 until N) {      var mnIx = inf      var mnChar = -1      for (k in 0 until K) {        if (lst[k] < mnIx) {          mnIx = lst[k]          mnChar = k        }      }      cnt[mnChar] = cnt.sum() % MOD      lst[mnChar] = T.size + i + 1    }    debug(cnt)    debug(lst)     out.println(cnt.sum() % MOD)  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return IntArray(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private inline fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: BooleanArray) {    debug { toString(a) }  }   private inline fun toString(a: BooleanArray) = run{a.map { if (it) 1 else 0 }.joinToString("""")}   private inline fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<BooleanArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }   private inline fun assert(b: Boolean) = run{if (!b) throw AssertionError()}} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","dp,greedy,strings"
"import java.io.BufferedReaderimport java.io.InputStreamReaderimport java.util.*import kotlin.math.* val bf = BufferedReader(InputStreamReader(System.`in`))var stok = StringTokenizer("""") fun read(): String {    while (!stok.hasMoreTokens()) stok = StringTokenizer(bf.readLine())    return stok.nextToken()} fun main() {    val n = read().toInt()    val k = read().toInt()    val a = IntArray(n) { read().toInt() * 100 }    val c = IntArray(n) { read().toInt() }     val l2 = IntArray(n + 10)    l2[1] = 0    for (i in 2 until l2.size) l2[i] = l2[i / 2] + 1     class SparseTable(x: IntArray, val biFn: (Int, Int) -> Int) {        val tab: Array<IntArray> = Array(l2[x.size] + 1){IntArray(x.size)}         init {            tab[0] = x.copyOf()            for (i in 0 until tab.size - 1) {                for (f in 0 until x.size - (1 shl i))                    tab[i + 1][f] = biFn.invoke(tab[i][f], tab[i][f + (1 shl i)])            }        }         // [l; r)        fun get(l: Int, r: Int): Int {            val pw = l2[r - l]            return biFn.invoke(tab[pw][l], tab[pw][r - (1 shl pw)])        }    }     val max_a = SparseTable(a, ::max)    val min_c = SparseTable(c, ::min)     // [l; r)    fun get_p(l: Int, r: Int) = min(max_a.get(l, r), min_c.get(l, r))     val max_potential = IntArray(n)    for (i in 0 until n) {        var l = i + 1        var r = n        while (r - l > 1) {            val mid = l + (r - l) / 2            if (min_c.get(i, mid) < max_a.get(i, mid)) r = mid            else l = mid        }        max_potential[i] = max(get_p(i, l), get_p(i, r))//        println(""$i $l $r ${max_potential[i]} ${max_a.get(i, l)} ${min_c.get(i, l)}"")    }     max_potential.sort()    var factor = k * 1.0 / n    var ans = 0.0    for ((i, value) in max_potential.slice(0..n - k).withIndex()) {//        println(""$i $value $factor"")        ans += value * factor        val left = n - i        factor *= (left - k) * 1.0 / (left - 1)    }    print(""%.9f"".format(ans))}","binary search,constructive algorithms,data structures,probabilities,two pointers"
"import java.util.* fun binarySearch(c : Int, a : IntArray) : Int {    var lo = 0    var hi = a.size - 1    var index = -1    while(hi >= lo) {        var mid = lo + (hi - lo) / 2        if(c == a[mid]) {            index = mid            hi = mid - 1        }        else if(a[mid] < c)            lo = mid + 1        else            hi = mid - 1    }    return index;} fun main(args: Array<String>) {     var n = Integer.valueOf(readLine())    var nums = readLine()!!.split(' ').map(String::toInt).sorted().toIntArray()     data class Pair(val a : Int, val b : Int) : Comparable<Pair> {         override fun compareTo(o: Pair): Int {            if(Integer.compare(this.a,o.a) == 0)                return Integer.compare(this.b,o.b)            return Integer.compare(this.a,o.a)        }     }     var set = TreeSet<Pair>()    var res = nums.filter { i -> i == 0 }.size    var used : BooleanArray = BooleanArray(n)    var a : Int    var b : Int    var temp : Int    var cnt : Int    res = Math.max(2,res)    for (i in 0..n - 1) {        for (j in 0..n - 1) {            if (i != j && (nums[j] != 0 || nums[i] != 0) && !set.contains(Pair(nums[i],nums[j]))) {                set.add(Pair(nums[i],nums[j]))                a = nums[i]                b = nums[j]                used.fill(false)                used[i] = true                used[j] = true                temp = a + b                cnt = 2                while (true) {                    var ind = binarySearch(temp, nums)                    if(ind > -1 && used[ind]) {                        while (ind + 1 < n && used[ind + 1])                            ind++                        ind++                    }                    if(ind > -1 && ind < n && nums[ind] == temp && !used[ind]) {                        cnt++                        used[ind] = true                        a = b                        b = temp                        temp = a + b                    }else {                        res = Math.max(res,cnt)                        break                    }                }            }        }    }    println(res)}","brute force,dp,hashing,implementation,math"
"import java.util.*import kotlin.math.max fun main() {    val jin = Scanner(System.`in`)    val n = jin.nextInt()    val array = LongArray(n) { jin.nextLong() }    val accountedFor = mutableSetOf<Pair<Long, Long>>()    val freq = mutableMapOf<Long, Int>()    for (a in array) {        freq[a] = (freq[a] ?: 0) + 1    }    var answer = freq[0] ?: 0    for (a in array) {        for (b in array) {            if (accountedFor.contains(Pair(a, b))) {                continue            }            if (a == b && freq[a]!! < 2) {                continue            }            if (a == 0L && b == 0L)  {                continue            }            val sequence = LinkedList<Long>()            freq[a] = freq[a]!! - 1            freq[b] = freq[b]!! - 1            sequence.add(a)            sequence.add(b)            accountedFor.add(Pair(a, b))            while (true) {                while ((freq[sequence[1] - sequence[0]] ?: 0) > 0) {                    val c = sequence[1] - sequence[0]                    freq[c] = freq[c]!! - 1                    accountedFor.add(Pair(c, sequence[0]))                    sequence.addFirst(c)                }                //println(""sequence = $sequence"")                answer = max(answer, sequence.size)                if (sequence.size == 2) {                    break                }                while (sequence.size > 2) {                    freq[sequence.last] = freq[sequence.last]!! + 1                    sequence.removeLast()                }            }            while (true) {                while ((freq[sequence[sequence.size - 2] + sequence.last] ?: 0) > 0) {                    val c = sequence[sequence.size - 2] + sequence.last                    freq[c] = freq[c]!! - 1                    accountedFor.add(Pair(sequence.last, c))                    sequence.addLast(c)                }                //println(""sequence = $sequence"")                answer = max(answer, sequence.size)                if (sequence.size == 2) {                    break                }                while (sequence.size > 2) {                    freq[sequence[0]] = freq[sequence[0]]!! + 1                    sequence.removeFirst()                }            }            freq[sequence[0]] = freq[sequence[0]]!! + 1            freq[sequence[1]] = freq[sequence[1]]!! + 1        }    }    println(answer)}","brute force,dp,hashing,implementation,math"
"fun main() {    fun readLongs() = readLine()!!.split("" "").map(String::toLong)     readLine()    print(readLongs().reduce { acc, l -> acc or l } + readLongs().reduce { acc, l -> acc or l })}","brute force,implementation"
"import kotlin.math.* fun main() {    val n = readInt()    val a = readInts()    val b = readInts()     var maximal = 0    for (i in 0 until n) {        var sumA = a[i]        var sumB = b[i]        for (j in i until n) {            sumA = sumA or a[j]            sumB = sumB or b[j]            maximal = max(maximal, sumA+sumB)        }    }    println(maximal)} private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readLong() = readLn().toLong() // single longprivate fun readDouble() = readLn().toDouble() // single doubleprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of intsprivate fun readLongs() = readStrings().map { it.toLong() } // list of longsprivate fun readDoubles() = readStrings().map { it.toDouble() } // list of doublesprivate fun Long.pow(x: Long): Long {    var res = 1L    var a = this    var b = x    while(b > 0) {        if (b%2 == 1L) {            res *= a        }        a *= a        b = b shr 1    }    return res}private fun Long.powMod(x: Long, mod: Long): Long {    var res = 1L    var a = this%mod    var b = x    while(b > 0) {        if (b%2 == 1L) {            res = res*a % mod        }        a = a * a % mod        b = b shr 1    }    return res}private fun Long.factors(): List<Long> {    var q = listOf<Long>()    for (i in 1..sqrt(this.toDouble()).toLong()) {        if (this%i == 0L) {            q += i            q += this/i        }    }    return q}private fun gcd(first: Long, second: Long): Long {    var q = first    var p = second    while(q != 0L) {        p = q.apply { q = p%q } // swap function    }    return p}private fun Long.isCoPrime(x: Long): Boolean {    return gcd(this, x) == 1L}private fun String.sortString(): String {    val arr = this.toCharArray()    return arr.sorted().joinToString("""")}private fun unique(list: List<Long>): List<Long> {    var x = list.toSet()    return x.toList()}","brute force,implementation"
"import java.lang.Integer.max val mod: Long = 1000000007 fun main() {    val (n, m) = readLine()!!.split("" "").map { it.toInt() }    val s = readLine()!!    val (mn, mx) = s.fold(Pair(0, 0)) { pair, c ->        val (mn, mx) = pair        val t = mx + if (c == '(') 1 else -1        Pair(max(mn, -t), t)    }    val d = MutableList(3000) {MutableList(3000) {0L}}    d[0][0] = 1    for (i in 1 until 3000)        for (j in 0..i)            d[i][j] = ((if (j > 0) d[i - 1][j - 1] else 0) + (if (j < i) d[i - 1][j + 1] else 0)) % mod    var ans = 0L    for (i in 0..(n-m)) {        for (j in mn..i) {            if (n - m - i < mx + j)                continue            ans = (ans + d[i][j] * d[n - m - i][mx + j]) % mod        }    }    println(ans)}","dp,strings"
"fun main() {    fun readLongs() = readLine()!!.split("" "").map(String::toLong)     readLine()    val times = readLongs()    val used = mutableSetOf<Long>()    var sol = 0L    for (option in times)        for (i in option downTo 0)            if (i !in used) {                used.add(i)                sol += i                break            }    print(sol)}","greedy,sortings"
"fun solve(){    var n = readLine()!!.toInt()    var a = readLine()!!.split("" "").map { it.toInt() }.toIntArray()    var ans = 0L    a.sort()    var cur = a[n-1] + 1    for (i in n - 1 downTo 0) {        if (cur <= a[i]) {            a[i] = cur-1        }        if(a[i] < 0) break        ans += a[i]        cur = a[i]    }    println(ans) } fun main() {    var t = 1//readLine()!!.toInt()    for (i in 0 until t) {        solve()    }}","greedy,sortings"
"import java.io.*import java.util.*import kotlin.collections.ArrayListimport kotlin.collections.HashSet fun main() {    solve(System.`in`, System.out)} fun solve(input: InputStream, output: OutputStream) {    val reader = Reader(input) //Reader(FileInputStream(File(""portals.in"")))    val writer = PrintWriter(BufferedOutputStream(output)) //PrintWriter(FileOutputStream(File(""output.txt"")))     solve(reader, writer)    writer.close()} fun solve(ir : Reader, pw : PrintWriter) {     val n = ir.nextInt()    val a = IntArray(n)    var total: Long = 0     repeat(n) {        a[it] = ir.nextInt()    }     Arrays.sort(a)     total += a[n - 1]     for (i in (n - 2) downTo 0) {        if (a[i] >= a[i + 1])            a[i] = Math.max((a[i + 1] - 1), 0)        total += a[i]    }     pw.print(total) } private fun sort(array: IntArray, barray: IntArray, low: Int, high: Int) {     var i = low    var j = high    val x = array[low + (high - low) / 2]     do {        while (array[i] < x) ++i        while (array[j] > x) --j        if (i <= j) {            val tmp = array[i]            array[i] = array[j]            array[j] = tmp             val pmt = barray[i]            barray[i] = barray[j]            barray[j] = pmt             i++            j--        }    } while (i <= j)     if (low < j) sort(array, barray, low, j)    if (i < high) sort(array, barray, i, high) } class Reader(stream: InputStream) {    private val reader: BufferedReader = BufferedReader(InputStreamReader(stream), 32768)    private var tokenizer: StringTokenizer? = null     init {        tokenizer = null    }     operator fun next(): String {        while (tokenizer == null || !tokenizer!!.hasMoreTokens())            try {                tokenizer = StringTokenizer(reader.readLine())            } catch (e: IOException) {                throw RuntimeException(e)            }         return tokenizer!!.nextToken()    }     fun nextLine(): String? {        val fullLine: String        while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {            try {                fullLine = reader.readLine()            } catch (e: IOException) {                throw RuntimeException(e)            }             return fullLine        }        return null    }     fun toArray(): Array<String> {        return nextLine()!!.split("" "".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()    }     fun nextInt(): Int {        return Integer.parseInt(next())    }     fun nextDouble(): Double {        return java.lang.Double.parseDouble(next())    }     fun nextLong(): Long {        return java.lang.Long.parseLong(next())    } }","greedy,sortings"
"val sb = StringBuilder()val r = System.`in`.bufferedReader()private fun readInt() = r.readLine().toInt()private fun readLong() = r.readLine().toLong()private fun readInts() = r.readLine().split("" "").map { it.toInt() }private fun readLongs() = r.readLine().split("" "").map { it.toLong() } fun main() {    val leftUp = MutableList(1999) { 0 }    val rightUp = MutableList(1999) { 0 }    var cnt = 0L    repeat(readInt()) {        val (x, y) = readInts().map { it-1 }        val fir = 999 - x + y        val sec = x + y        //println(fir)        cnt += leftUp[fir]        cnt += rightUp[sec]        leftUp[fir]++        rightUp[sec]++    }    sb.appendln(cnt)    print(sb)}","combinatorics,implementation"
"import java.io.PrintWriterimport java.util.*import kotlin.math.* val INPUT = System.`in`!!val OUTPUT = System.out!!const val mod : Long = 1_000_000_007const val mini = Int.MIN_VALUEconst val maxi = Int.MAX_VALUEval reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun line() = reader.readLine()!!var tokenizer: StringTokenizer = StringTokenizer("""")fun read(): String {    while (tokenizer.hasMoreTokens().not()) tokenizer = StringTokenizer(reader.readLine() ?: return """", "" "")    return tokenizer.nextToken()}fun sort(a: IntArray) {    val l = ArrayList<Int>()    for (value in a) {        l.add(value)    }    l.sort()    for (i in l.indices) a[i] = l[i]}fun int() = read().toInt()fun double() = read().toDouble()fun long() = read().toLong()fun strings(n: Int) = List(n) { read() }fun lines(n: Int) = List(n) { line() }fun ints(n: Int) = List(n) { read().toInt() }fun intArray(n: Int) = IntArray(n) { read().toInt() }fun doubles(n: Int) = List(n) { read().toDouble() }fun doubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun longs(n: Int) = List(n) { read().toLong() }fun longArray(n: Int) = LongArray(n) { read().toLong() }val writer = PrintWriter(OUTPUT, false)fun main() { writer.solve(); writer.flush() }fun gcd(a : Int, b : Int) : Int {    if(b == 0) return a    return gcd(b, a % b)}class Pair(var a: Int, var b: Int)fun ceil(a : Long, b : Long) : Long {    return if (a % b == 0L) a / b else (a / b) + 1}fun PrintWriter.solve() {    // var tt = int()    var tt = 1    while(tt-- > 0) {        val n = int()        val neg = HashMap<Int, Int>()        val pos = HashMap<Int, Int>()        repeat(n) {            val (x, y) = ints(2)            pos[x - y] = pos.getOrDefault(x - y, 0) + 1            neg[x + y] = neg.getOrDefault(x + y, 0) + 1        }        var count = 0L        for((k, v) in pos) {            count += (v * (v - 1) / 2)        }        for((k, v) in neg) {            count += (v * (v - 1) / 2)        }        println(count)    }}","combinatorics,implementation"
"fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val (numRows, numColumns) = readInts()    val matrix = Array(numRows) { List<Int>(numColumns) { 0 } }    for (row in 0 until numRows) matrix[row] = readInts()    print(matrix.map { it.min()!! }.max()!!)}","games,greedy"
"fun main() {    var (n, m) = readLine()!!.split(' ').map { it.toInt() }    var max = 0    var index = -1    for (i in 1..n) {        var list = readLine()!!.split(' ').map { it.toInt() }.min()        if (list!! > max) {            max = list!!        }    }    println(max)}","games,greedy"
"import kotlin.math.max fun main() {    solve()} private fun solve() {    val (n, m) = readInts()    val matrix = mutableListOf<MutableList<Long>>()     var max = Long.MIN_VALUE    for (i in 0 until n) {        val minInRow = readLongs().minOrNull()        max = max(minInRow!!, max)    }    println(max)} private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readLong() = readLn().toLong() // single intprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // liprivate fun readLongs() = readStrings().map { it.toLong() } // li","games,greedy"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.io.PrintWriterimport java.util.* fun PrintWriter.solve(sc: FastScanner) {    val n = sc.nextInt()    val m = sc.nextInt()    val c = Array(n) { Array(m) { sc.nextInt() } }    val d = c.map { it.min()!! }    println(d.max()!!)} fun main() {    val writer = PrintWriter(System.out, false)    writer.solve(FastScanner(System.`in`))    writer.flush()} class FastScanner(s: InputStream) {    private var st = StringTokenizer("""")    private val br = BufferedReader(InputStreamReader(s))     fun next(): String {        while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())         return st.nextToken()    }     fun nextInt() = next().toInt()    fun nextLong() = next().toLong()    fun nextLine() = br.readLine()    fun nextDouble() = next().toDouble()    fun ready() = br.ready()}","games,greedy"
import java.util.* fun main() {    val get = Scanner(System.`in`)     val n = get.nextInt()    var m = get.nextInt()    val data = Array(n){get.nextInt()}    data.sort()     for(i in n-1 downTo 0) {        if(m-data[i] > 0) {            m-=data[i]        }        else {            print(n - i)            break        }    }},"greedy,implementation,sortings"
import kotlin.system.exitProcess fun main(args: Array<String>) {    val z = java.util.Scanner(System.`in`)    val n = z.nextInt()    val m = z.nextInt()    val a = Array(n) {z.nextInt()}    a.sortDescending()    var sum = 0    for (i in a.indices) {        sum+=a[i]        if (m <= sum) {            println(i+1)            exitProcess(0)        }    }},"greedy,implementation,sortings"
"fun main() {    fun readInt() = readLine()!!.toInt()     val numDrives = readInt()    val size = readInt()    val drivesSizes = mutableListOf<Int>()    repeat(numDrives) {        drivesSizes.add(readInt())    }    drivesSizes.sortDescending()    var sol = 0    for ((pos, drive) in drivesSizes.withIndex()) {        sol += drive        if (sol >= size) return print(pos + 1)    }}","greedy,implementation,sortings"
import java.util.Scannerimport java.util.Arraysfun main(args: Array<String>) {    val sc = Scanner(System.`in`)    val n: Int = sc.nextInt()    val a = IntArray(n)    val m: Int = sc.nextInt()    for (i in 0 until n) {        a[i] = sc.nextInt()    }    Arrays.sort(a)    var sum = 0    var count = 0    for (i in n - 1 downTo 0) {        sum += a[i]        count++        if (sum >= m) break    }    println(count)},"greedy,implementation,sortings"
"import kotlin.math.max fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val (numPassengers, topFloor) = readInts()    var arrival = 0    for (passenger in 0 until numPassengers) {        val (floor, time) = readInts()        arrival = max(arrival, max(time, topFloor - floor) + floor)    }    print(arrival)}","implementation,math"
"import java.util.* fun main(args: Array<String>) {    var (n,s) = readLine()!!.split(' ').map(String::toInt)    val map = HashMap<Int,Int>()    var time = 0    for(i in 1..n) {        val (a,b) = readLine()!!.split(' ').map(String::toInt)        map.putIfAbsent(a,b)        map.put(a,Math.max(map[a]!!,b))    }    while(s > 0) {        time = Math.max(time, when(map[s]){            null -> 0            else -> map[s]        }!!)        time++        s--    }    println(time)}","implementation,math"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.lang.AssertionErrorimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007 data class Edge(val id: Int, val w: Int, val use: Boolean)class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  private val reader = BufferedReader(InputStreamReader(stream), 32768)   private val N = ni()  private val M = ni()  fun solve() {    val E = Array(M){Edge(it, ni() - 1, ni() == 1)}    val used = E.filter { it.use }.toTypedArray()    val notUsed = E.filter { !it.use }.toTypedArray()    used.sortBy { it.w }    notUsed.sortBy { it.w } //    debug { ""${used.joinToString("""")} ${notUsed.joinToString("""")}"" }     var ptr = 0    val m = notUsed.size    val ans = Array(M){IntArray(2)}    for (i in 1 until N) {      val v = used[i - 1]      ans[v.id][0] = i - 1      ans[v.id][1] = i      for (j in i - 2 downTo 0) {        if (ptr == m || v.w > notUsed[ptr].w) break         val u = notUsed[ptr]        ans[u.id][0] = j        ans[u.id][1] = i        ptr++      }    }     if (ptr < m) {      out.println(-1)      return    }     debugDim(ans)    for (i in ans) {      out.println(""${i[0]+1} ${i[1]+1}"")    }  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return IntArray(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private inline fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: BooleanArray) {    debug { toString(a) }  }   private inline fun toString(a: BooleanArray) = run{a.map { if (it) 1 else 0 }.joinToString("""")}   private inline fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<BooleanArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }   private inline fun assert(b: Boolean) = run{if (!b) throw AssertionError()}} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","constructive algorithms,data structures,graphs"
"import kotlin.math.max fun main() {    val (numCowBells, numBoxes) = readLine()!!.split("" "").map (String::toInt)    val sizes = readLine()!!.split("" "").map (String::toInt)    if (numCowBells <= numBoxes) return print(sizes.last())    val extra = 2 * numBoxes - numCowBells    var sol = if (extra == 0) 0 else sizes.subList(numCowBells - extra, numCowBells).max()!!    val right = numCowBells - extra - 1    for (box in 0 until (numCowBells - extra) / 2)        sol = max(sol, sizes[box] + sizes[right - box])    print(sol)}","binary search,greedy"
"import java.lang.AssertionErrorimport java.lang.Math.powimport java.lang.Math.roundimport java.util.*import kotlin.collections.ArrayListimport kotlin.collections.HashMapimport java.util.Collections as JavaUtilCollections private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readLong() = readLn().toLong() // single longprivate fun readDouble() = readLn().toDouble() // single doubleprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of intsprivate fun readLongs() = readStrings().map { it.toLong() } // list of longsprivate fun readDoubles() = readStrings().map { it.toDouble() } // list of doubles private const val mod: Long = 1000000007 private fun myAssert(x: Boolean) { if (!x) { throw AssertionError() } } private fun minv(v: Long): Long { return mpow(v, mod - 2) } private fun mpow(base: Long, exp: Long): Long {	var base = base ; var exp = exp ; var res: Long = 1	while (exp > 0) {		if (exp and 1 == 1L) { res = res * base % mod }		base = base * base % mod ; exp = exp shr 1	}	return res} private fun gcd(x: Int, y: Int): Int {	if (x == 0) return y	return if (y == 0) x else gcd(y % x, x)} private fun check(): Unit {	val ( n, k ) = readInts()	val a = readInts()	var ans = a.max()!!	for( i in 0 until n - k )		ans = maxOf( ans , a[i] + a[ 2*(n -  k) - i - 1 ] )	println( ans )} fun main(){	var tt = 1//	tt = readInt()	repeat(tt){		check()	}}","binary search,greedy"
"import kotlin.math.max fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val points = intArrayOf(500, 1000, 1500, 2000, 2500)    val times = readInts()    val wrongs = readInts()    val (hacks, nonHacks) = readInts()    var sol = 0.0    for (pos in 0 until 5)        sol += max(0.3 * points[pos], (1 - times[pos] / 250.0) * points[pos] - 50 * wrongs[pos])    sol += 100 * hacks - 50 * nonHacks    print(sol.toInt())}",implementation
"import kotlin.math.maximport kotlin.math.round fun f(x:Int, m:Int, w:Int):Double {    return max(0.3 * x, (1 - m / 250.0) * x - 50 * w)}   fun main(args: Array<String>) {     val x = arrayOf(500, 1000, 1500, 2000, 2500)    var m = readLine()!!.split(' ').map { it.toInt() }    var w = readLine()!!.split(' ').map { it.toInt() }    var (h1, h2) = readLine()!!.split(' ').map { it.toInt() }     var res = 0.0     for (i in 0 until 5) {        res += f(x[i], m[i], w[i])    }     res += h1 * 100 - h2 * 50     print( res.toInt() ) }",implementation
"import java.util.*import kotlin.collections.ArrayList fun main() {    println(solve604())} fun solve604(): Int {    val max = arrayOf(500,1000,1500,2000,2500)    val inn = Scanner(System.`in`)    val listM : List<Double> = inn.nextLine().split("" "").toList().map {        it.toDouble() }    val listW : List<Double> = inn.nextLine().split("" "").toList().map {        it.toDouble() }    val listh : List<Double> = inn.nextLine().split("" "").toList().map {        it.toDouble() }     val results = ArrayList<Double>()    for(i in 0 until 5)    {        results.add(Math.max((0.3*max[i]), ((1.0-listM[i]/250)*max[i] - 50*listW[i])))    }     results.add(listh[0]*100.0)    results.add(-listh[1]*50.0)     return results.sum().toInt()}",implementation
"import java.lang.Exceptionimport java.math.*import kotlin.math.* fun solve() {    fun isInt(s: String): Boolean {        if (s == ""0"") return true        if (s == """" || s[0] == '0') return false        s.forEach {            if (it !in '0'..'9')                return false        }        return true    }     val a = MutableList(0) {""""}    val b = MutableList(0) {""""}    readln().replace("","", "";"").split("";"").forEach {        if (isInt(it))            a.add(it)        else            b.add(it)    }    arrayOf(a, b).forEach {        println(            if (it.isEmpty()) ""-"" else ""\"""" + it.joinToString("","") + ""\""""        )    }} fun main() {    var t = 1;//    t = readInt()    while (t-- != 0) {        solve()   //     t++    }} private fun readln() = readLine()!!private fun readInt() = readln().toInt()private fun readStrings() = readln().split("" "")private fun readInts() = readStrings().map { it.toInt() }class yesno(y: String, n: String) {    private val yes = y    private val no = n    operator fun invoke(ok: Boolean): String { return if (ok) this.yes else this.no }} fun prefixFunction(s: CharArray): Array<Int> {    val n = s.size    val p = Array(n) {0}    for (i in 1 until n) {        var j = p[i - 1]        while (j > 0 && s[j] != s[i])            j = p[j - 1]        if (s[i] == s[j])            j++        p[i] = j    }    return p} fun KnuthMorris(s: CharArray, t: CharArray): Int {    val p = prefixFunction(s + ""#"".toCharArray() + t)    val n = s.size    val m = t.size    for (i in n + 1 .. n + m)        if (p[i] == n)            return i - n - n    return -1}","implementation,strings"
"import java.io.*import java.util.*import kotlin.math.absoluteValueimport kotlin.system.measureTimeMillis // @formatter:off val local = System.getProperty(""ONLINE_JUDGE"") == nullval INPUT: InputStream = if (local) FileInputStream(""input.txt"") else System.`in` //val OUTPUT: PrintStream = if (local) PrintStream(""output.txt"") else System.outval OUTPUT: PrintStream = System.out val _reader = INPUT.bufferedReader()var _tokenizer = StringTokenizer("""") fun readLine(): String? = _reader.readLine()fun readLn() = _reader.readLine()!!fun read(): String {    while (_tokenizer.hasMoreTokens().not()) _tokenizer = StringTokenizer(_reader.readLine() ?: return """", "" "")    return _tokenizer.nextToken()} fun readInt() = read().toInt()fun readDouble() = read().toDouble()fun readLong() = read().toLong()fun readStrings(n: Int) = List(n) { read() }fun readLines(n: Int) = List(n) { readLn() }fun readInts(n: Int) = List(n) { read().toInt() }fun readStrings() = readLn().split("" "")fun readInts() = readStrings().map { it.toInt() }fun readIntArray(n: Int) = IntArray(n) { read().toInt() }fun readDoubles(n: Int) = List(n) { read().toDouble() }fun readDoubleArray(n: Int) = DoubleArray(n) { read().toDouble() }fun readLongs(n: Int) = List(n) { read().toLong() }fun readLongArray(n: Int) = LongArray(n) { read().toLong() }fun PrintWriter.yesNo(p: Boolean) {if (p) this.println(""YES"") else this.println(""NO"")}fun<T> MutableList<T>.swap(i: Int, j: Int) {val t=this[i]; this[i]=this[j]; this[j]=t;}fun<T> Array<T>.swap(i: Int, j: Int) {val t=this[i]; this[i]=this[j]; this[j]=t;}fun IntArray.swap(i: Int, j: Int) {val t=this[i]; this[i]=this[j]; this[j]=t;}operator fun Number.plus(y: Number): Number = when (this) {    is Int -> this + y.toInt();  is Long -> this+y.toLong();  is Double -> this + y.toDouble();    is Float -> this + y.toFloat();    else -> error(""unsupported"")}operator fun Number.minus(y: Number): Number = when (this) {    is Int -> this - y.toInt(); is Long -> this-y.toLong();   is Double -> this - y.toDouble();    is Float -> this - y.toFloat();    else -> error(""unsupported"")}operator fun Number.times(y: Number): Number = when (this) {    is Int -> this * y.toInt();  is Long -> this*y.toLong();  is Double -> this * y.toDouble();    is Float -> this * y.toFloat();    else -> error(""unsupported"")}@JvmFieldval _writer = PrintWriter(OUTPUT, local)// @formatter:on  fun PrintWriter.solve() {    val s = read()    val words = s.split( ',', ';')     val isNum: (String) -> Boolean =        { s: String -> s == ""0"" || (s.isNotEmpty() && s.all { it.isDigit() } && s[0] != '0') }       val (numbers: List<String>, notNumbers: List<String>) = words.partition(isNum)     val foo = { v: List<String> ->        if (v.isEmpty()) {            println(""-"")        } else {            println(""\""${v.joinToString("","")}\"""")        }    }     foo(numbers)    foo(notNumbers)} fun main() {    val elapsedMs = measureTimeMillis {        _writer.solve()        _writer.flush()    }    if (local) {        println(""\n\nelapsed $elapsedMs ms"")    }}","implementation,strings"
"import java.io.*import java.util.*import kotlin.properties.Delegates fun main(args: Array<String>) {    val solver = A()    solver.run()} class A {    fun init() { }     fun isNumber(word : String) : Boolean {        var result = word.all { ch -> Character.isDigit(ch) }        result = result && word.length > 0 && (word.length == 1 || word[0] != '0')         return result    }     fun printWords(words : List<String>) {        if (words.isEmpty()) {            out.println(""-"")        } else {            out.print(""\"""")             words.forEachIndexed { index, word ->                if (index > 0) out.print("","")                out.print(word)            }             out.println(""\"""")        }    }     fun solve() {        val words = readStrings("",;"", true)         val a = ArrayList<String>()        val b = ArrayList<String>()         words.forEach { word -> when {            isNumber(word) -> a.add(word)            else -> b.add(word)        } }         printWords(a)        printWords(b)    }     fun readStrings(separator: String = "" "", emptyWords: Boolean = false) : Array<String> {        val line = input.readLine()         val list = ArrayList<String>()        var builder = StringBuilder()         for (i in 0..line.length) {            if (i == line.length || separator.contains(line[i])) {                if (emptyWords || builder.isNotEmpty()) {                    list.add(builder.toString())                    builder = StringBuilder()                }            } else {                builder.append(line[i])            }        }         return list.toTypedArray()    }     fun readString(separator: String = "" "") : String = readStrings(separator)[0]     fun readInts(separator: String = "" "") : IntArray {        return readStrings(separator).map(String::toInt).toIntArray()    }     fun readInt(separator: String = "" "") : Int = readInts(separator)[0]     fun readLongs(separator: String = "" "") : LongArray {        return readStrings(separator).map(String::toLong).toLongArray()    }     fun readLong(separator: String = "" "") : Long = readLongs(separator)[0]     val ONLINE_JUDGE: Boolean = !File(""input.txt"").exists()     var input = BufferedReader(            if (ONLINE_JUDGE) InputStreamReader(System.`in`) else FileReader(""input.txt"")    )    var out =            if (ONLINE_JUDGE) PrintWriter(System.out)            else PrintWriter(""output.txt"")     fun run() {        init()        solve()        out.close()    }     class DSU {         var sizes : IntArray by Delegates.notNull()        var ranks : IntArray by Delegates.notNull()        var parents : IntArray by Delegates.notNull()         constructor(sizes : IntArray) {            val size = sizes.size            this.sizes = sizes            this.ranks = IntArray(size, { 1 } )            this.parents = IntArray(size, {i -> i} )        }         fun get(v : Int) : Int {            val parent = parents[v]            if (parent == v) return v            parents[v] = get(parent)            return parents[v]        }         fun union(aa : Int, bb : Int) {            var a = get(aa)            var b = get(bb)             if (a == b) return             if (ranks[a] < ranks[b]) {                val tmp = a                a = b                b = tmp            }             parents[b] = a            sizes[a] += sizes[b]            if (ranks[a] == ranks[b]) ++ranks[a]        }         fun size(v : Int) : Int {            return sizes[get(v)]        }    }     companion object Utils {        fun checkIndex(index : Int, size : Int) : Boolean {            return (0 <= index && index < size)        }         fun checkCell(x : Int, n : Int, y : Int, m : Int) : Boolean{            return checkIndex(x, n) && checkIndex(y, m)        }    }}","implementation,strings"
"import java.io.FileInputStreamimport java.io.FileWriterimport java.io.IOExceptionimport java.io.InputStreamimport java.io.OutputStreamimport java.io.PrintWriterimport java.util.* private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of ints /** * @author adwsingh */fun main() {    CodeforcesA600().solve()} class CodeforcesA600 {     var io = FastIO()     fun solve() {        val s = readLn().split("","", "";"")        val a = mutableListOf<String>()        val b = mutableListOf<String>()        for (word in s) {            if (word.isNotEmpty() && ((word.length == 1 && word[0] == '0') || (word[0] != '0' && word.all {                    Character.isDigit(                        it                    )                }))) {                a.add(word)            } else {                b.add(word)            }        }        println(if (a.isEmpty()) ""-"" else a.joinToString("","", ""\"""", ""\""""))        println(if (b.isEmpty()) ""-"" else b.joinToString("","", ""\"""", ""\""""))         io.close()     }    fun sort(a: IntArray) {        val l = ArrayList<Int>(a.size)        for (i in a) l.add(i)        l.sort()        for (i in a.indices) a[i] = l[i]    }     //-----------MyScanner class for faster input----------    @OptIn(kotlin.ExperimentalStdlibApi::class)    class FastIO : PrintWriter {        private var stream: InputStream        private val buf = ByteArray(1 shl 16)        private var curChar = 0        private var numChars = 0         // standard input        @JvmOverloads        constructor(i: InputStream = System.`in`, o: OutputStream? = System.out) : super(o) {            stream = i        }         // file input        constructor(i: String?, o: String?) : super(FileWriter(o)) {            stream = FileInputStream(i)        }         // throws InputMismatchException() if previously detected end of file        private fun nextByte(): Int {            if (numChars == -1) throw InputMismatchException()            if (curChar >= numChars) {                curChar = 0                numChars = try {                    stream.read(buf)                } catch (e: IOException) {                    throw InputMismatchException()                }                if (numChars == -1) return -1 // end of file            }            return buf[curChar++].toInt()        }         // to read in entire lines, replace c <= ' '        // with a function that checks whether c is a line break        operator fun next(): String {            var c: Int            do {                c = nextByte()            } while (c <= ' '.code)            val res = StringBuilder()            do {                res.appendCodePoint(c)                c = nextByte()            } while (c > ' '.code)            return res.toString()        }         fun nextLine(): String {            var c: Int            do {                c = nextByte()            } while (c < '\n'.code)            val res = StringBuilder()            do {                res.appendCodePoint(c)                c = nextByte()            } while (c > '\n'.code)            return res.toString()        }         fun nextInt(): Int { // nextLong() would be implemented similarly            var c: Int            do {                c = nextByte()            } while (c <= ' '.code)            var sgn = 1            if (c == '-'.code) {                sgn = -1                c = nextByte()            }            var res = 0            do {                if (c < '0'.code || c > '9'.code) throw InputMismatchException()                res = 10 * res + c - '0'.code                c = nextByte()            } while (c > ' '.code)            return res * sgn        }         fun nextDouble(): Double {            return next().toDouble()        }    }}//--------------------------------------------------------","implementation,strings"
//https://codeforces.com/problemset/problem/598/Aimport java.util.*fun main(){	val sc=Scanner(System.`in`)	val t=sc.nextInt()	for(i in 1..t)	{		var n:Long=sc.nextLong()		var s1:Long=n*(n+1)/2		var s2:Long=0L		var v:Long=1L		while(v<=n)		{			s2+=v			v*=2L		}		s1-=2*s2		println(s1)	}},math
fun main() {    val numQueries = readLine()!!.toInt()    for (i in 0 until numQueries) {        val n = readLine()!!.toLong()        var answer = n * (n + 1) / 2        var powerOf2 = 1L        while (powerOf2 <= n) {            answer -= 2 * powerOf2            powerOf2 *= 2        }        println(answer)    }},math
import java.util.* fun main() {    val sc = Scanner(System.`in`)    val t = sc.nextInt()    val ar = LongArray(t) {sc.nextLong()}    ar.forEach {        var sum: Long = it * (it + 1) / 2        var sum2 = 0L        var num = 1L        while(num <= it) {            sum2 += num            num *= 2        }        println(sum - sum2 * 2)    }},math
fun main() {    fun readInt() = readLine()!!.toInt()    fun readLong() = readLine()!!.toLong()     val numQueries = readInt()    for (query in 0 until numQueries) {        val n = readLong()        var toDeduct = 0L        var powerOfTwo = 1L        while (powerOfTwo <= n) {            toDeduct += powerOfTwo            powerOfTwo = powerOfTwo shl 1        }        println((n * (n + 1)) / 2 - 2 * (toDeduct))    }},math
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.lang.AssertionErrorimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007L class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  fun solve() {    val MAX = if (isDebug) 100 else 100_000    val flg = BooleanArray(MAX + 1){true}    val primes = mutableListOf<Int>()    flg[0] = false    flg[1] = false     for (i in 2 .. MAX) {      if (!flg[i]) continue      primes += i       var j = i * 2      while (j <= MAX) {        flg[j] = false        j += i      }    }     fun isPrime(a: Int): Boolean {      for (p in primes) {        if (a <= p) return true        if (a % p == 0) return false      }      return true    }     val N = ni()    if (isPrime(N)) {      out.println(1)      out.println(""$N"")      return    }     var Pn = N - 2    while(!isPrime(Pn)) {      Pn--    }     val x = N - Pn    if (isPrime(x)) {      out.println(2)      out.println(""$Pn $x"")      return    }     for (p in primes) {      if (flg[x - p]) {        out.println(3)        out.println(""$Pn $p ${x - p}"")        return      }    }  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private val reader = BufferedReader(InputStreamReader(stream), 32768)  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return map(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun map(n: Int, f: (Int) -> Int): IntArray {    val res = IntArray(n)    for (i in 0 until n) {      res[i] = f(i)    }    return res  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private inline fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private inline fun debug(a: BooleanArray) {    debug { a.map { if (it) 1 else 0 }.joinToString("""") }  }   private inline fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private inline fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }   private inline fun assert(b: Boolean) = run{if (!b) throw AssertionError()}} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","brute force,math,number theory"
"fun main() {    val (a, b) = readLine()!!.split("" "").map{ it.toInt() }    print(when {        b < 10 -> b.toString().repeat(a)        a == 1 -> -1        else   -> ""1"".repeat(a - 1) + ""0""    })}",math
"fun main(args: Array<String>) {    val (n, t) = readLine()!!.split(' ').map { it.toInt() }     if (t == 10 && n == 1) {        println(-1)    } else {        (0 until if (t < 10) n else n-1).forEach{            print(if(it == 0) t else 0)        }    }}",math
"fun main(args: Array<String>) {    val (n, t) = readLine()!!.split(' ').map { it.toInt() }    if (t == 10) {        if (n == 1)            println(-1)        else            println(""1"".repeat(n - 1) + ""0"")    } else        println(""$t"".repeat(n))}",math
"fun main(args: Array<String>) {    val (n, t) = readLine()!!.split("" "").map(String::toInt)    var answer = """"    if(t < 10) {        for(i in 1..n) answer += t    } else {        if(n > 1) {            answer += 1            for(i in 2..n) answer += 0        } else answer = ""-1""    }     println(answer)}",math
"import kotlin.math.max fun main() {    val numRecords = readLine()!!.toInt()    var sol = 0    val regNumbers = mutableSetOf<String>()    for (i in 1..numRecords) {        val (action, regNumber) = readLine()!!.split("" "")        if (action == ""+"")            regNumbers.add(regNumber)        else {            if (regNumber in regNumbers) {                sol = max(sol, regNumbers.size)                regNumbers.remove(regNumber)            } else {                sol = max(sol + 1, regNumbers.size + 1)            }        }    }    sol = max(sol, regNumbers.size)    print(sol)}",implementation
"import java.util.* fun smallest(s: String): String {    if (s.length % 2 == 1) return s    val s1 = smallest(s.substring(0, s.length / 2))    val s2 = smallest(s.substring(s.length / 2, s.length))    return if (s1 < s2) s1 + s2 else s2 + s1} fun main() {    val sc = Scanner(System.`in`)    val s = sc.next()    val t = sc.next()     if(smallest(s) == smallest(t))        println(""YES"")    else        println(""NO"") }","divide and conquer,hashing,sortings,strings"
"fun minS(a : String) : String {    if(a.length % 2 == 1)        return a     val l = minS(a.substring(0, a.length / 2))    val r = minS(a.substring(a.length / 2, a.length))     if(l < r) {        return l + r    }     return r + l} fun main(args: Array<String>) {    val a = readLine() ?: """"    val b = readLine() ?: """"        val mA = minS(a)    val mB = minS(b)     if(mA == mB) {        println(""YES"")    } else {        println(""NO"")    }}","divide and conquer,hashing,sortings,strings"
"fun main() {    val s1 = readLine()!!.toCharArray()    val s2 = readLine()!!.toCharArray()    fun sort(s: CharArray, from: Int, to: Int) {        if ((to - from) % 2 == 0) {            val mid = (from + to) / 2            sort(s, from, mid)            sort(s, mid, to)            var leq = true            for (j in 0 until mid - from) {                if (s[from + j] < s[mid + j]) {                    break                }                if (s[from + j] > s[mid + j]) {                    leq = false                    break                }            }            if (!leq) {                for (j in 0 until mid - from) {                    val a = s[from + j]                    val b = s[mid + j]                    s[from + j] = b                    s[mid + j] = a                }            }        }    }    sort(s1, 0, s1.size)    sort(s2, 0, s2.size)    println(if (String(s1) == String(s2)) ""YES"" else ""NO"")}","divide and conquer,hashing,sortings,strings"
"import java.io.BufferedReaderimport java.io.InputStreamimport java.io.InputStreamReaderimport java.util.*import kotlin.math.absimport kotlin.math.maximport kotlin.math.min val MOD = 1_000_000_007L class Solver(stream: InputStream, private val out: java.io.PrintWriter) {  fun solve() {    val S = ns().toCharArray()    val T = ns().toCharArray()    val tmp = CharArray(S.size)    var len = S.size    while(len % 2 == 0)  len /= 2     fun lte(A: CharArray, s0: Int, s1: Int, len: Int): Boolean {      for (i in 0 until len) {        if (A[s0 + i] < A[s1 + i]) return true        if (A[s0 + i] > A[s1 + i]) return false      }      return true    }     fun swap(A: CharArray, s0: Int, s1: Int, len: Int) {      for (i in 0 until len) {        tmp[i] = A[s0 + i]      }      for (i in 0 until len) {        A[s0 + i] = A[s1 + i]      }      for (i in 0 until len) {        A[s1 + i] = tmp[i]      }    }     while(len <= S.size) {      for (i in 0 until S.size / len / 2) {        if (!lte(S, i*2 * len, (i*2 + 1) * len, len)) {          swap(S, i*2 * len, (i*2 + 1) * len, len)        }        if (!lte(T, i*2 * len, (i*2 + 1) * len, len)) {          swap(T, i*2 * len, (i*2 + 1) * len, len)        }      }      len *= 2    }     val ans = if (S.contentEquals(T)) ""YES"" else ""NO""    out.println(ans)  }                                               private val isDebug = try {    // なんか本番でエラーでる    System.getenv(""MY_DEBUG"") != null  } catch (t: Throwable) {    false  }   private var tokenizer: StringTokenizer? = null  private val reader = BufferedReader(InputStreamReader(stream), 32768)  private fun next(): String {    while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {      tokenizer = StringTokenizer(reader.readLine())    }    return tokenizer!!.nextToken()  }   private fun ni() = next().toInt()  private fun nl() = next().toLong()  private fun ns() = next()  private fun na(n: Int, offset: Int = 0): IntArray {    return map(n) { ni() + offset }  }  private fun nal(n: Int, offset: Int = 0): LongArray {    val res = LongArray(n)    for (i in 0 until n) {      res[i] = nl() + offset    }    return res  }   private fun na2(n: Int, offset: Int = 0): Array<IntArray> {    val a  = Array(2){IntArray(n)}    for (i in 0 until n) {      for (e in a) {        e[i] = ni() + offset      }    }    return a  }   private inline fun map(n: Int, f: (Int) -> Int): IntArray {    val res = IntArray(n)    for (i in 0 until n) {      res[i] = f(i)    }    return res  }   private inline fun debug(msg: () -> String) {    if (isDebug) System.err.println(msg())  }   private fun debug(a: LongArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: IntArray) {    debug { a.joinToString("" "") }  }   private fun debug(a: BooleanArray) {    debug { a.map { if (it) 1 else 0 }.joinToString("""") }  }   private fun debugDim(A: Array<LongArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }  private fun debugDim(A: Array<IntArray>) {    if (isDebug) {      for (a in A) {        debug(a)      }    }  }   /**   * 勝手にimport消されるのを防ぎたい   */  private fun hoge() {    min(1, 2)    max(1, 2)    abs(-10)  }} fun main() {  val out = java.io.PrintWriter(System.out)  Solver(System.`in`, out).solve()  out.flush()}","divide and conquer,hashing,sortings,strings"
"fun main() {    val n = readLine()!!.toInt()     val freq = mutableMapOf<String, Int>()    for (i in 0 until n) {        val row = readLine()!!        freq[row] = freq.getOrDefault(row, 0) + 1    }     println(freq.values.maxOrNull())}","brute force,greedy,strings"
"fun main() {    fun readInt() = readLine()!!.toInt()     val side = readInt()    val rows = Array(side) { """" }    for (row in 0 until side) rows[row] = readLine()!!    val columnsSetToNumRows = mutableMapOf<Set<Int>, Int>().withDefault { 0 }    for (row in rows) {        val columnsToClean = row.withIndex().filter { it.value == '0' }.map { it.index }.toSet()        columnsSetToNumRows[columnsToClean] = columnsSetToNumRows.getValue(columnsToClean) + 1    }    print(columnsSetToNumRows.values.max()!!)}","brute force,greedy,strings"
"import java.io.*import java.util.* fun main() {    solve(System.`in`, System.out)} fun solve(input: InputStream, output: OutputStream) {    val reader = Reader(input) //Reader(FileInputStream(File(""portals.in"")))    val writer = PrintWriter(BufferedOutputStream(output)) //PrintWriter(FileOutputStream(File(""output.txt"")))     solve(reader, writer)    writer.close()} fun solve(ir : Reader, pw : PrintWriter) {     val n: Int = ir.nextInt()    val a = arrayOfNulls<String>(n)    var count = 0     for (i in 0 until n)        a[i] = ir.next()     for (i in 0 until n) {        var c = 0        for (j in 0 until n)            if (a[i] == a[j])                c++        count = Math.max(c, count)    }     pw.print(count) } class Reader(stream: InputStream) {    private val reader: BufferedReader = BufferedReader(InputStreamReader(stream), 32768)    private var tokenizer: StringTokenizer? = null     init {        tokenizer = null    }     operator fun next(): String {        while (tokenizer == null || !tokenizer!!.hasMoreTokens())            try {                tokenizer = StringTokenizer(reader.readLine())            } catch (e: IOException) {                throw RuntimeException(e)            }         return tokenizer!!.nextToken()    }     fun nextLine(): String? {        val fullLine: String        while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {            try {                fullLine = reader.readLine()            } catch (e: IOException) {                throw RuntimeException(e)            }             return fullLine        }        return null    }     fun toArray(): Array<String> {        return nextLine()!!.split("" "".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()    }     fun nextInt(): Int {        return Integer.parseInt(next())    }     fun nextDouble(): Double {        return java.lang.Double.parseDouble(next())    }     fun nextLong(): Long {        return java.lang.Long.parseLong(next())    } }","brute force,greedy,strings"
"import java.io.*import java.math.BigDecimalimport java.math.BigIntegerimport java.util.*  object programkt {    interface Scanner {        fun changeInputStream(inputStream: InputStream)        fun nextInt(): Int        fun nextLong(): Long        fun nextDouble(): Double        fun nextChar(): Char        fun nextString(): String        fun nextLine(): String        fun nextBigInteger(): BigInteger        fun nextBigDecimal(): BigDecimal    }     abstract class Task {        //KT Extensions        fun <T : Comparable<T>> min(a: T, b: T) = if (a > b) b else a        fun <T : Comparable<T>> max(a: T, b: T) = if (a < b) b else a        fun abs(a: Int) = if (a > 0) a else -(a)        fun abs(a: Long) = if (a > 0) a else -(a)        fun abs(a: Float) = if (a > 0) a else -(a)        fun abs(a: Double) = if (a > 0) a else -(a)        operator fun <T> Iterable<T>.invoke(function: (it: T) -> Unit) { this.forEach(function) }        private fun String.prefix(pi: Array<Int>): Array<Int> {            pi[0] = 0            (1 until this.length) {                var j = pi[it - 1]                while (j > 0 && this[it] != this[j]) {                    j = pi[j - 1]                }                if(this[it] == this[j]) {                    j++                }                pi[it] = j            }            return pi        }        private fun String.kmpFind(pattern: String): Int {            val m = pattern.length            val dfa = Array(256) { IntArray(m) }            dfa[pattern[0].toInt()][0] = 1            var x = 0            var j = 1            while (j < m) {                for (c in 0 until 256) {                    dfa[c][j] = dfa[c][x]        // Copy mismatch cases.                }                dfa[pattern[j].toInt()][j] = j + 1   // Set match case.                x = dfa[pattern[j].toInt()][x]       // Update restart state.                j++            }             val n = this.length            var i: Int = 0            j = 0            while (i < n && j < m) {                j = dfa[this[i].toInt()][j]                i++            }            if (j == m) return i - m    // found            return n                    // not found        }        fun fuckExceptions(invoker: () -> Unit) = try { invoker.invoke() } catch (_: Throwable) {}         enum class EdgeType {            DIRECTED,            UNDIRECTED        }        data class Vertex<T: Comparable<T>>(                val data: T        ) {            override fun toString(): String = ""V:$data""        }        data class Edge<T:Comparable<T>>(                var source: Vertex<T>,                var destination: Vertex<T>,                val weight: Double?        )        interface Graphable<T: Comparable<T>> {            fun createVertex(data: T): Vertex<T>            fun add(type: EdgeType, source: Vertex<T>, destination: Vertex<T>, weight: Double? = 0.0)            fun weight(source: Vertex<T>, destination: Vertex<T>): Double?            fun edges(source: Vertex<T>): MutableList<Edge<T>>?        }        class AdjacencyList<T: Comparable<T>>: Graphable<T> {            var adjacencyMap: MutableMap<Vertex<T>, MutableList<Edge<T>>> = mutableMapOf()             private fun addDirectedEdge(source: Vertex<T>, destination: Vertex<T>, weight: Double?) {                adjacencyMap[source]?.add(Edge(source = source, destination = destination, weight = weight))            }             private fun addUndirectedEdge(source: Vertex<T>, destination: Vertex<T>, weight: Double?) {                addDirectedEdge(source, destination, weight)                addDirectedEdge(destination, source, weight)            }             override fun createVertex(data: T): Vertex<T> {                val vertex = Vertex(data = data)                adjacencyMap[vertex] ?: run {                    adjacencyMap[vertex] = mutableListOf()                }                return vertex            }             override fun add(type: EdgeType, source: Vertex<T>, destination: Vertex<T>, weight: Double?) = when(type) {                EdgeType.DIRECTED -> addDirectedEdge(source, destination, weight)                EdgeType.UNDIRECTED -> addUndirectedEdge(source, destination, weight)            }             override fun weight(source: Vertex<T>, destination: Vertex<T>): Double? {                adjacencyMap[source]?.forEach {                    if(it.destination == destination) return it.weight                }                return null            }             override fun edges(source: Vertex<T>): MutableList<Edge<T>>? = adjacencyMap[source]             override fun toString(): String {                var result = """"                for ((vertex, edges) in adjacencyMap) {                    var edgeString = """"                    for ((index, edge) in edges.withIndex()) {                        edgeString += if (index != edges.count() - 1) ""${edge.destination}, ""                        else ""${edge.destination}""                    }                    result += ""$vertex ---> [ $edgeString ] \n""                }                return result            }             fun depthFirstSearch(start: Vertex<T>, end: Vertex<T>): Stack<Vertex<T>> {                val visited: HashSet<Vertex<T>> = hashSetOf()                val stack: Stack<Vertex<T>> = Stack()                stack.push(start)                visited.add(start)                 var currentVertex = stack.peek()                loop@while (currentVertex != null && currentVertex != end) {                    val neighbors = edges(currentVertex)                    if(neighbors != null && neighbors.count() > 0) {                        for(edge in neighbors) {                            if(!visited.contains(edge.destination)) {                                visited.add(edge.destination)                                stack.push(edge.destination)                                currentVertex = stack.peek()                                continue@loop                            }                        }                    } else {                        stack.pop()                        currentVertex = stack.peek()                        continue                    }                     stack.pop()                    currentVertex = stack.peek()                }                 return stack            }             fun breadthFirstSearch() {             }             fun floydWarshallAlgorythm(): Pair<Array<DoubleArray>, Array<IntArray>> {                val nVertices = this.adjacencyMap.size                 val weights = Array(nVertices) { Array(nVertices-1) { 0.0 } }                this.adjacencyMap                        .asSequence()                        .map { it.value }                        .withIndex()                        .forEach { (index, weightsOfVertex) ->                            weightsOfVertex.asSequence()                                    .withIndex()                                    .forEach { (weightIndex, weight) ->                                        weights[index][weightIndex] = weight.weight!!                                    }                        }                 val dist = Array(nVertices) { DoubleArray(nVertices) { Double.POSITIVE_INFINITY } }                for (w in weights) dist[(w[0] - 1).toInt()][(w[1] - 1).toInt()] = w[2]                val next = Array(nVertices) { IntArray(nVertices) }                for (i in 0 until next.size) {                    for (j in 0 until next.size) {                        if (i != j) next[i][j] = j + 1                    }                }                for (k in 0 until nVertices) {                    for (i in 0 until nVertices) {                        for (j in 0 until nVertices) {                            if (dist[i][k] + dist[k][j] < dist[i][j]) {                                dist[i][j] = dist[i][k] + dist[k][j]                                next[i][j] = next[i][k]                            }                        }                    }                }                return dist to next            }        }         fun <T: Comparable<T>> TreeMap<T, Array<Double>>.toAdjacencyList(type: EdgeType): AdjacencyList<T> {            val list = AdjacencyList<T>()             this.keys.forEach { list.createVertex(it) }            this.entries                    .asSequence()                    .withIndex()                    .forEach { (x, edge) ->                        val vertex = list.createVertex(edge.key)                        edge.value                                .asSequence()                                .withIndex()                                .forEach { (y, weight) ->                                    if(weight != .0 && y != x)                                        list.add(type, vertex, list.createVertex(this.keys.elementAt(y)), weight)                                }                    }            return list        }        //End KT Extensions         abstract fun solve(scanner: Scanner, printer: PrintWriter)    }     class FastScanner: Scanner {        var inputStream: InputStream? = null        override fun changeInputStream(inputStream: InputStream) {            this.inputStream = inputStream            this.bufferedReader = BufferedReader(InputStreamReader(inputStream))        }         private lateinit var bufferedReader: BufferedReader        private var stringTokenizer: StringTokenizer? = null         private fun nextToken(): String? {            while (stringTokenizer == null || !stringTokenizer!!.hasMoreTokens())                stringTokenizer = StringTokenizer(bufferedReader.readLine() ?: return null)            return stringTokenizer!!.nextToken()        }         override fun nextInt() = nextToken()!!.toInt()        override fun nextLong() = nextToken()!!.toLong()        override fun nextDouble() = nextToken()!!.toDouble()        override fun nextChar() = bufferedReader.read().toChar()        override fun nextString() = nextToken()!!        override fun nextLine() = bufferedReader.readLine()!!        override fun nextBigInteger() = BigInteger(nextToken()!!)        override fun nextBigDecimal() = BigDecimal(nextToken()!!)    }     class TaskBuilder {        private var task: Task? = null        private var inputStream: InputStream? = null        private var outputStream: OutputStream? = null        private var scanner: Scanner? = null         fun useInputSource(inputStream: InputStream): TaskBuilder {            this.inputStream = inputStream            return this        }         fun useOutputSource(outputStream: OutputStream): TaskBuilder {            this.outputStream = outputStream            return this        }         fun useInputFile(inputFileName: String): TaskBuilder {            this.inputStream = FileInputStream(File(inputFileName))            return this        }         fun useOutputFile(outputFileName: String): TaskBuilder {            this.outputStream = FileOutputStream(File(outputFileName))            return this        }         fun useScanner(scanner: Scanner): TaskBuilder {            this.scanner = scanner            return this        }          fun solveTask(task: Task): TaskBuilder {            this.task = task            return this        }         fun run() {            when {                task == null -> throw NullPointerException(""Task cannot be null!"")                inputStream == null -> throw NullPointerException(""Input cannot be null!"")                outputStream == null -> throw NullPointerException(""Output cannot be null!"")                scanner == null -> throw NullPointerException(""Scanner cannot be null!"")            }            scanner!!.changeInputStream(inputStream!!)            val printer = PrintWriter(outputStream)            TaskRunnable(task!!, scanner!!, printer).run()             inputStream!!.close()            printer.close()        }         class TaskRunnable(                private val task: Task,                private val scanner: Scanner,                private val printer: PrintWriter        ) {            fun run() {                task.solve(scanner, printer)            }        }    }     @JvmStatic    fun main(args: Array<String>) = TaskBuilder()            .useInputSource(System.`in`)            .useOutputSource(System.out)            .useScanner(FastScanner())            .solveTask(TaskD())            .run()      class TaskA: Task() {        override fun solve(scanner: Scanner, printer: PrintWriter) {            val (firstValency, secondValency, thirdValency) = scanner.nextLine()                    .split("" "")                    .map { it.toLong() }            val averageValency = (firstValency + secondValency + thirdValency) / 2             if ((firstValency + secondValency + thirdValency) % 2 != 0L ) { printer.println(""Impossible""); return }             val countOfConnectionsFirst = averageValency - thirdValency            val countOfConnectionsSecond = averageValency - firstValency            val countOfConnectionsThird = averageValency - secondValency             when {                countOfConnectionsFirst < 0 -> { printer.println(""Impossible""); return }                countOfConnectionsSecond < 0 -> { printer.println(""Impossible""); return }                countOfConnectionsThird < 0 -> { printer.println(""Impossible""); return }                else -> printer.println(""$countOfConnectionsFirst $countOfConnectionsSecond $countOfConnectionsThird"")            }        }     }     class TaskB: Task() {        override fun solve(scanner: Scanner, printer: PrintWriter) {            //тут скоро будут графы            //страшно        }     }    class TaskC: Task() {       override fun solve(scanner: Scanner, printer: PrintWriter) {           val uniqueCharSet = hashSetOf<Char>()           scanner.nextLine().forEach { uniqueCharSet.add(it) }           printer.println(if(uniqueCharSet.size % 2 == 1) ""IGNORE HIM!"" else ""CHAT WITH HER!"")       }    }    class TaskD: Task() {       override fun solve(scanner: Scanner, printer: PrintWriter) {           val roomLength = scanner.nextInt()           val roomMap = hashMapOf<String, Int>()           var allClearMax = 0           (0 until roomLength) {               val currentRoomRow = scanner.nextLine()                roomMap[currentRoomRow] = roomMap[currentRoomRow]?.plus(1) ?: 1               allClearMax = max(allClearMax, roomMap[currentRoomRow]?: 0)           }           printer.println(allClearMax)       }    }}","brute force,greedy,strings"
"fun main() {    val r = System.`in`.bufferedReader()    val sb = StringBuilder()    val n = r.readLine().toInt()    val car= mutableListOf<Int>()    repeat(n) {        val v = r.readLine().split("" "").map { it.toInt() }        if (v.all { it==-1||it==0||it==2 }) car.add(it+1)    }    sb.appendln(car.size)    sb.appendln(car.joinToString("" ""))    println(sb)}",implementation
"fun main(){    val nmk: List<Int> = readLine()!!.split("" "").map{it.toInt()}    //println(nmk)    val pixels: Array<BooleanArray> = Array(nmk[0]+2) {BooleanArray(nmk[1]+2){false}}    for (i in 1..nmk[2]) {        val tp: List<Int> = readLine()!!.split("" "").map{it.toInt()}        pixels[tp.first()][tp.last()] = true        if ((pixels[tp.first()-1][tp.last()] && ((pixels[tp.first()-1][tp.last()-1] && pixels[tp.first()][tp.last()-1]) || (pixels[tp.first()-1][tp.last()+1] && pixels[tp.first()][tp.last()+1]))) || (pixels[tp.first()+1][tp.last()] && ((pixels[tp.first()+1][tp.last()-1] && pixels[tp.first()][tp.last()-1]) || (pixels[tp.first()+1][tp.last()+1] && pixels[tp.first()][tp.last()+1])))){            println(i)            return}    }    println(0)}",brute force
"import kotlin.math.maximport kotlin.math.min fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val (numRows, numColumns, numMoves) = readInts()    val grid = Array(numRows + 1) { IntArray(numColumns + 1) }    for (i in 1..numMoves) {        val (row, column) = readInts()        if(grid[row][column] == 0) grid[row][column] = i    }    var sol = 0    for (row in 1 until numRows)        nextCell@ for (column in 1 until numColumns) {            var maximum = 0            for (r in row..row + 1)                for (c in column..column + 1) {                    if (grid[r][c] == 0) continue@nextCell                    maximum = max(maximum, grid[r][c])                }            sol = if (sol == 0) maximum else min(sol, maximum)        }    print(sol)}",brute force
//https://codeforces.com/problemset/problem/508/Aimport java.util.*fun main(){	val sc=Scanner(System.`in`)	var n=sc.nextInt()	var m=sc.nextInt()	var k=sc.nextInt()	var f=false	var arr=Array(n){Array(m){0}}	for(i in 1..k)	{		var r=sc.nextInt()		var c=sc.nextInt()		r--		c--		arr[r][c]=1		if(!f)		{			if((r-1>=0&&c-1>=0)&&(arr[r-1][c]==1&&arr[r-1][c-1]==1&&arr[r][c-1]==1))			{				f=true				println(i)			}			else if((r-1>=0&&c+1<m)&&(arr[r-1][c]==1&&arr[r-1][c+1]==1&&arr[r][c+1]==1))			{				f=true				println(i)			}			else if((r+1<n&&c+1<m)&&(arr[r+1][c]==1&&arr[r+1][c+1]==1&&arr[r][c+1]==1))			{				f=true				println(i)			}			else if((r+1<n&&c-1>=0)&&(arr[r+1][c]==1&&arr[r+1][c-1]==1&&arr[r][c-1]==1))			{				f=true				println(i)			}		}	}	if(!f)	println(0)},brute force
"import java.io.*import java.util.* fun main() {    solve(System.`in`, System.out)} fun solve(input: InputStream, output: OutputStream) {    val reader = Reader(input) //Reader(FileInputStream(File(""portals.in"")))    val writer = PrintWriter(BufferedOutputStream(output)) //PrintWriter(FileOutputStream(File(""output.txt"")))     solve(reader, writer)    writer.close()} fun solve(ir : Reader, pw : PrintWriter) {     val n = ir.nextInt()    val m = ir.nextInt()    val k = ir.nextInt()    val mem = Array(n) { BooleanArray(m) }    for (i in 0 until k) {        val i1 = ir.nextInt() - 1        val j1 = ir.nextInt() - 1        mem[i1][j1] = true        var res = false         if (i1 > 0 && j1 > 0 && mem[i1 - 1][j1 - 1] && mem[i1 - 1][j1] && mem[i1][j1 - 1])            res = true        if (i1 < n - 1 && j1 < m - 1 && mem[i1 + 1][j1 + 1] && mem[i1 + 1][j1] && mem[i1][j1 + 1])            res = true        if (i1 < n - 1 && j1 > 0 && mem[i1][j1 - 1] && mem[i1 + 1][j1 - 1] && mem[i1 + 1][j1])            res = true        if (i1 > 0 && j1 < m - 1 && mem[i1][j1 + 1] && mem[i1 - 1][j1] && mem[i1 - 1][j1 + 1])            res = true         if (res) {            pw.print(i + 1)            return        }    }    pw.print(0) } class Reader(stream: InputStream) {    private val reader: BufferedReader = BufferedReader(InputStreamReader(stream), 32768)    private var tokenizer: StringTokenizer? = null     init {        tokenizer = null    }     operator fun next(): String {        while (tokenizer == null || !tokenizer!!.hasMoreTokens())            try {                tokenizer = StringTokenizer(reader.readLine())            } catch (e: IOException) {                throw RuntimeException(e)            }         return tokenizer!!.nextToken()    }     fun nextLine(): String? {        val fullLine: String        while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {            try {                fullLine = reader.readLine()            } catch (e: IOException) {                throw RuntimeException(e)            }             return fullLine        }        return null    }     fun toArray(): Array<String> {        return nextLine()!!.split("" "".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()    }     fun nextInt(): Int {        return Integer.parseInt(next())    }     fun nextFloat(): Float {        return java.lang.Float.parseFloat(next())    }     fun nextDouble(): Double {        return java.lang.Double.parseDouble(next())    }     fun nextLong(): Long {        return java.lang.Long.parseLong(next())    } }",brute force
"import kotlin.math.powimport kotlin.math.sqrt fun main(args: Array<String>) {    val br = System.`in`.bufferedReader()    val (radius, x, y, x1, y1) = br.readLine()!!.split("" "").map { it.toDouble() }    val distance = sqrt((x-x1).pow(2)+(y-y1).pow(2))    val ans = (distance/(2*radius)).toInt() + if (distance%(2*radius)!=0.0) 1 else 0    println(ans) }","geometry,math"
"import kotlin.math.powimport kotlin.math.sqrt fun main() {    val r = System.`in`.bufferedReader()    val s = StringBuilder()    //val len = r.readLine()!!.toInt()    val (radius, x, y, x1, y1) = r.readLine()!!.split("" "").map { it.toDouble() }    val dis = sqrt((x-x1).pow(2)+(y-y1).pow(2))    val ans = (dis/(2*radius)).toInt() + if (dis%(2*radius)!=0.0) 1 else 0    println(ans)}","geometry,math"
"import kotlin.math.powimport kotlin.math.sqrt fun main() {    val r = System.`in`.bufferedReader()    val s = StringBuilder()    //val len = r.readLine()!!.toInt()    val (radius, x, y, x1, y1) = r.readLine()!!.split("" "").map { it.toDouble() }    val dis = sqrt((x-x1).pow(2)+(y-y1).pow(2))    val ans = (dis/(2*radius)).toInt() + if (dis%(2*radius)!=0.0) 1 else 0    println(ans)}","geometry,math"
"import kotlin.math.absimport kotlin.math.ceilimport kotlin.math.sqrt fun main() {    fun readInt() = readLine()!!.toInt()    fun readLong() = readLine()!!.toLong()    fun readInts() = readLine()!!.split("" "").map(String::toInt)    fun readLongs() = readLine()!!.split("" "").map(String::toLong)     val (r, x, y, x2, y2) = readLongs()    val d = sqrt(((x - x2) * (x - x2) + (y - y2) * (y - y2)).toDouble())    print(ceil(d / (r * 2)).toLong())}","geometry,math"
"fun main() {    val (n, t) = readLine()!!.split("" "").map { it.toInt() - 1 }    val a = readLine()!!.split("" "").map { it.toInt() }    var p = 0    while (p < t) p += a[p]    print(if (p == t) ""YES"" else ""NO"")}","dfs and similar,graphs,implementation"
"fun main(args: Array<String>) {    val (n,t) = read()    val a = read()    var i = 0    while(i < t-1) i+=a[i]    println(if(i == t-1) ""YES"" else ""NO"")} fun read() = readLine()!!.split(' ').map { it.toInt() }","dfs and similar,graphs,implementation"
"fun main(args: Array<String>) {    var (_, t) = readLine()!!.split(' ').map(String::toInt)    t -= 1    val arr = readLine()!!.split(' ').map(String::toInt)    var s=0    while (s<t) s += arr[s]    print(if (s==t) ""YES"" else ""NO"")}","dfs and similar,graphs,implementation"
"fun main(args: Array<String>) {    var (_, t) = readLine()!!.split(' ').map(String::toInt)    t -= 1    val arr = readLine()!!.split(' ').map(String::toInt)    var s=0    while (s<t) s += arr[s]    print(if (s==t) ""YES"" else ""NO"")}","dfs and similar,graphs,implementation"
"import java.io.*import java.util.* val scanner = StreamTokenizer(BufferedReader(InputStreamReader(System.`in`)))val printer = PrintWriter(System.out)fun StreamTokenizer.nextInt(): Int {    nextToken()    return nval.toInt()}  class Node(    val max_l: Int,    val max_r: Int,    val max_m: Int,    val all_1: Boolean) operator fun Node.plus(that: Node) = Node(    if (this.all_1) this.max_l + that.max_l else this.max_l,    if (that.all_1) this.max_r + that.max_r else that.max_r,    maxOf(this.max_m, that.max_m, this.max_r + that.max_l),    this.all_1 && that.all_1) class Tree {    val L: Tree    val R: Tree    val node: Node     constructor(node: Node) {        L = this        R = this        this.node = node    }     constructor(L: Tree, R: Tree, node: Node) {        this.L = L        this.R = R        this.node = node    }     fun modify(l: Int, r: Int, t: Int, v: Int): Tree = when {        (v <= l || r <= t) -> this        (t <= l && r <= v) -> Tree(Node(1, 1, 1, true))        else -> {            val m = (l + r) shr 1            val x = L.modify(l, m, t, v)            val y = R.modify(m, r, t, v)            val z = x.node + y.node            Tree(x, y, z)        }    }     fun query(l: Int, r: Int, t: Int, v: Int): Node = when {        (v <= l || r <= t) -> Node(0, 0, 0, true)        (t <= l && r <= v) -> node        else -> {            val m = (l + r) shr 1            val x = L.query(l, m, t, v)            val y = R.query(m, r, t, v)            x + y        }    }} const val N = 100100 val let = IntArray(N)val vec = Vector<Int>() val root = Array<Tree>(N) { Tree(Node(0, 0, 0, false)) } fun main(args: Array<String>) {    val n = scanner.nextInt()    for (i in 1..n) let[i] = scanner.nextInt()    for (i in 1..n) vec.add(i)    vec.sortByDescending { let[it] }    for (i in 1..n)        root[i] = root[i - 1].modify(1, n + 1, vec[i - 1], vec[i - 1] + 1)    val q = scanner.nextInt()    repeat(q) {        val t = scanner.nextInt()        val v = scanner.nextInt()        val x = scanner.nextInt()        var l = 0        var r = n + 1        while (l != r - 1) {            val m = (l + r) shr 1            val y = root[m].query(1, n + 1, t, v + 1)            if (y.max_m < x) {                l = m            } else {                r = m            }        }        printer.println(let[vec[l]])    }    printer.flush()}","binary search,constructive algorithms,data structures"
"fun main() {    val r = System.`in`.bufferedReader()    val s = StringBuilder()    val (m, n) = r.readLine()!!.split("" "").map { it.toLong() }    fun p(n: Long) = n*(n-1)/2    val max = p(m-n+1)    val min = m%n * p(m/n+1) + (n-(m%n))*p(m/n)    println(""$min $max"")}","combinatorics,constructive algorithms,greedy,math"
"import java.util.Scanner fun main() {    val scanner = Scanner(System.`in`)    val n: Long = scanner.nextLong()    val m: Long = scanner.nextLong()    val maxAnswer: Long = ((n - m) + 1) * (n - m) / 2    var minAnswer = ((n / m) * (n / m - 1) / 2) * (m - (n % m))    minAnswer += (n / m + 1) * (n / m) / 2 * (n % m)    println(""$minAnswer $maxAnswer"")}","combinatorics,constructive algorithms,greedy,math"
"import java.util.Scanner val scan = Scanner(System.`in`)fun main() {    val n: Long = scan.nextLong()    val m: Long = scan.nextLong()    val countInRoom = (n - (m - 1))    val max = countInRoom * (countInRoom - 1) / 2    val division = n / m    val remainder = n % m    val min = (((division + 1) * (division) ) / 2) * remainder + ((division * (division - 1)) / 2) * (m - remainder)    print(""$min $max"")}","combinatorics,constructive algorithms,greedy,math"
"fun main() {    val list = readLine()!!.split("" "").map { it.toLong() }    val q = (list[0]/list[1])    val rem = (list[0] % list[1])    val d=(list[0] - list[1])    if (list[1] == 1L) {        val a = (list[0]*(list[0] - 1)/2)        println(""$a $a"")    }    else if (d == 1L)        println(""1 1"")    else{        val max=d*(d+1)/2        val min=((list[1]-rem)*(q)*(q-1)/2)+(rem)*(q)*(q+1)/2        println(""$min $max"")    }}","combinatorics,constructive algorithms,greedy,math"
"fun main(args: Array<String>) {     val a = readLine()!!.split(' ').map { it.toInt() }.sum()    val b = readLine()!!.split(' ').map { it.toInt() }.sum()    val n  = readLine()!!.toInt()     println(if (d(a,5) + d(b, 10) <= n) ""YES"" else ""NO"")} fun d(a : Int, n : Int) = if (a%n == 0) a/n else a/n + 1",implementation
"fun main(args:Array<String>) {    val a = readLine()!!.trim().split("" "").asSequence().sumBy { s -> s.toInt() }    val b = readLine()!!.trim().split("" "").asSequence().sumBy { s -> s.toInt() }    val n = readLine()!!.toInt();    if ((a + 4) / 5 + (b + 9) / 10 <= n) print(""YES"") else print(""NO"")} ",implementation
"fun main(args: Array<String>) {    var a = 0    var b = 0    readLine()!!.split(' ').map(String::toInt).forEach {        a += it    }    readLine()!!.split(' ').map(String::toInt).forEach {        b += it    }    val n = readLine()!!.toInt()    if ((a+4)/5+(b+9)/10 <= n)        print(""YES\n"")    else        print(""NO\n"")}",implementation
"fun main() {    val r = System.`in`.bufferedReader()    val s = StringBuilder()    val s1 = r.readLine()!!.split("" "").map { it.toInt() }.sum()    val s2 = r.readLine()!!.split("" "").map { it.toInt() }.sum()    val v = r.readLine()!!.toInt()    val ans = s1 / 5 + s2 / 10 + (if (s2 % 10 != 0) 1 else 0) + (if (s1 % 5 != 0) 1 else 0)    println(if (ans <= v) ""YES"" else ""NO"")}",implementation
"fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val (numNecessaryProblems, numAvailableProblems) = readInts()    val requirements = readInts()    val available = readInts()    var reqPos = 0    var availablePos = 0    while (reqPos < numNecessaryProblems && availablePos < numAvailableProblems) {        if (requirements[reqPos] <= available[availablePos])            reqPos++        availablePos++    }    print(numNecessaryProblems - reqPos)}","brute force,greedy,two pointers"
"fun main() {    fun readInts() = readLine()!!.split("" "").map(String::toInt)     val (numNecessaryProblems, numAvailableProblems) = readInts()    val requirements = readInts().sorted()    val available = readInts().sorted()    var reqPos = 0    var availablePos = 0    while (reqPos < numNecessaryProblems && availablePos < numAvailableProblems) {        if (requirements[reqPos] <= available[availablePos])            reqPos++        availablePos++    }    print(numNecessaryProblems - reqPos)}","brute force,greedy,two pointers"
"fun main() {    val r = System.`in`.bufferedReader()    val sb = StringBuilder()    val (n, m) = r.readLine().split("" "").map { it.toInt() }    val v = r.readLine().split("" "").map { it.toInt() }.sorted()    val have = r.readLine().split("" "").map { it.toInt() }.sorted()    var ok = 0    var i = 0    var j = 0    while (i < n && j < m) {        when{            v[i]<=have[j]->{                i++                j++                ok++            }            else -> j++        }    }    sb.appendln(n-ok)    print(sb)}","brute force,greedy,two pointers"
"import java.io.*import java.util.* fun main() {    solve(System.`in`, System.out)} fun solve(input: InputStream, output: OutputStream) {    val reader = InputReader(BufferedInputStream(input))    val writer = PrintWriter(BufferedOutputStream(output))     solve(reader, writer)    writer.close()} fun solve(ir : InputReader, pw : PrintWriter) {     val n : Int = ir.nextInt()    val m : Int = ir.nextInt()    val a = IntArray(n)    val b = IntArray(m)     for (i in 0 until n)        a[i] = ir.nextInt()     for (i in 0 until m)        b[i] = ir.nextInt()     var len : Int = n    if (len > m)        len = m     for (i in len downTo 0) {        var res = true        for (j in 0 until i)            if (a[j] > b[m - i + j])                res = false         if (res) {            pw.print(n - i)            return        }    }  } class InputReader(stream: InputStream) {    private val reader: BufferedReader = BufferedReader(InputStreamReader(stream), 32768)    private var tokenizer: StringTokenizer? = null     init {        tokenizer = null    }     operator fun next(): String {        while (tokenizer == null || !tokenizer!!.hasMoreTokens())            try {                tokenizer = StringTokenizer(reader.readLine())            } catch (e: IOException) {                throw RuntimeException(e)            }         return tokenizer!!.nextToken()    }     fun nextLine(): String? {        val fullLine: String        while (tokenizer == null || !tokenizer!!.hasMoreTokens()) {            try {                fullLine = reader.readLine()            } catch (e: IOException) {                throw RuntimeException(e)            }             return fullLine        }        return null    }     fun toArray(): Array<String> {        return nextLine()!!.split("" "".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()    }     fun nextInt(): Int {        return Integer.parseInt(next())    }     fun nextDouble(): Double {        return java.lang.Double.parseDouble(next())    }     fun nextLong(): Long {        return java.lang.Long.parseLong(next())    } }","brute force,greedy,two pointers"
"private fun readLn() = readLine()!! // string lineprivate fun readInt() = readLn().toInt() // single intprivate fun readStrings() = readLn().split("" "") // list of stringsprivate fun readInts() = readStrings().map { it.toInt() } // list of ints lateinit var Tree : Array <Node>class Node (var id:Int){    var size = 1    var root = id     fun FindRoot():Int{        var temp  = id        while (Tree[temp].root != temp)            temp  =  Tree[temp].root         Tree[id].root = temp         return temp    }     fun Union (Oid:Int) {        if (Oid < id ){            Tree[id].root = Tree[Oid].FindRoot()            Tree[Tree[id].root].size ++        }        else {            Tree[Oid].root = Tree[id].FindRoot()            Tree[Tree[id].root].size ++        }    }} var  b = ArrayList<vessel>()fun fill (pos:Int,vol:Int){    var temp = vol;      var i = pos    while(temp >0 && i < b.size){         if (b[i].volume == 0)        {            i = Tree[i].FindRoot()            i = i+ Tree[i].size             continue        }         if  (temp < b[i].volume){            b[i].volume -= temp            break        }        else{            temp -= b[i].volume            b[i].volume = 0             if (i>0 && b[i-1].volume == 0)            Tree[i-1].Union(i)        }         i++    }} data class vessel (var volume:Int=0, val id:Int = 0 )fun main(args: Array<String>) {    var n = readInt()    var a = readInts() as MutableList     for (i in 0..n-1)        b.add (vessel(a[i],i))      Tree= Array<Node>(n+1){i->Node(i)}     var q = readInt()    for (i in 1..q){        var c  =readInts()        if  (c.size == 3)            fill(c[1]-1,c[2])        else {            println(a[c[1]-1]-b[c[1]-1].volume)        }    } }","data structures,dsu,implementation,trees"
"import java.io.PrintWriterimport java.util.StringTokenizer fun main() {     fun intersect(aa: Int, bb: Int, xx: Int, yy: Int): Boolean {        val (a,b) = mutableListOf(aa,bb).sorted()        val (x,y) = mutableListOf(xx,yy).sorted()         if (x in (a+1) until b)if(y > b || y < a)return true        if (y in (a+1) until b)if(x > b || x < a)return true         return false    }     fun PrintWriter.solve() {        val n = nextInt()        val arr = readInts()         for (i in 2 until n){            for (j in 1 until i){                if (intersect(arr[j-1],arr[j],arr[i-1],arr[i]))return println(""yes"")            }        }         print(""no"")      }     writer.solve()    writer.flush()  }  private val reader = System.`in`.bufferedReader()private val writer = PrintWriter(System.out, false) private var tokenizer: StringTokenizer = StringTokenizer("""") private fun next(): String {    while (tokenizer.hasMoreTokens().not()) tokenizer = StringTokenizer(reader.readLine())    return tokenizer.nextToken()} private fun nextInt() = next().toInt()private fun nextLong() = next().toLong()private fun nextDouble() = next().toDouble()private fun nextLine() = reader.readLine()private fun readInts() = nextLine().split("" "").map { it.toInt() } ","brute force,implementation"
"class Segment(x: Int, y: Int) {  private val left = minOf(x, y)  private val right = maxOf(x, y)   operator fun get(i: Int) = when (i) {    0 -> left    1 -> right    else -> throw AssertionError()  }   infix fun intersects(other: Segment) =    this[0] < other[0] && other[0] < this[1] && this[1] < other[1] ||    other[0] < this[0] && this[0] < other[1] && other[1] < this[1]} fun main() {  readLine()  val xs = readLine()!!.split("" "").map(String::toInt)  val segments = List(xs.size - 1) { i -> Segment(xs[i], xs[i + 1]) }  var intersects = false  out@ for (i in segments.indices) {    for (j in 0 until i) {      if (segments[i] intersects segments[j]) {        intersects = true        break@out      }    }  }  println(if (intersects) ""yes"" else ""no"")}","brute force,implementation"
"fun main() {    val n = readLine()!!.toInt()    val a = readLine()!!.split("" "").map(String::toInt)    var x25 = 0    var x50 = 0    a.forEach {        when (it) {            25 -> {                x25++            }            50 -> {                if (x25 > 0) {                    x25 --                    x50++                } else {                    println(""NO"")                    return                }            }            100 -> {                if (x50 > 0 && x25 > 0) {                    x50--                    x25--                } else if (x25 > 2) {                    x25 -= 3                } else {                    println(""NO"")                    return                }            }        }    }    println(""YES"")}","greedy,implementation"
"fun main() {    val r = System.`in`.bufferedReader()    val s = StringBuilder()    val n = r.readLine()!!.toInt()    val v = r.readLine()!!.split("" "").map { it.toInt() }    var tf = 0    var ft = 0    var ok = true    v.forEach {        when(it){            25 -> tf++            50 -> {                if (tf==0) ok = false                else {                    ft++                    tf--                }            }            100 -> {                when{                    ft>=1&&tf>=1 -> {                        ft--                        tf--                    }                    tf>=3 -> tf-=3                    else -> ok = false                }            }        }    }    println(if (ok) ""YES"" else ""NO"")}","greedy,implementation"
"import javax.print.attribute.standard.PrinterInfo fun main(){   // for( i in readLine()!!.split(' ').map( String::toInt ) )    val none= readLine()!! val n= readLine()!!.split(' ').map( String::toInt ) var deposit25=0 var deposit50=0  var index=0   loop@ for (i in  n){     when(i){      25->{       deposit25++      }      50->{          deposit50++          deposit25--          if (deposit25<0){              print(""NO"")              break@loop}          }       100->      {  if(deposit50>0&&deposit25>0){          deposit25--          deposit50--      }          else if(deposit25>2){          deposit25-=3      }          else {          print(""NO"")          break@loop}        }    }       if(index==n.size-1)      {          print(""YES"")      }       index++  }  }","greedy,implementation"
"import java.util.* fun main(args: Array<String>){    //val ( n, m ) = readLine()!!.split(' ').map(String::toInt)    var n = readLine()!!.toInt()    var cnt_25 = 0    var cnt_50 = 0    for( i in readLine()!!.split(' ').map( String::toInt ) ){        when( i ){            25 -> cnt_25++            50 ->{                if( cnt_25 == 0 ) {                    print(""NO"")                    return                } else{                    cnt_25--                    cnt_50++                }            }            else -> {                if( cnt_50 >= 1 && cnt_25 >= 1 ){                    cnt_50--                    cnt_25--                } else if( cnt_25 >= 3 ){                    cnt_25 -= 3                } else {                    print( ""NO"" )                    return                }            }        }    }    print( ""YES"" )}","greedy,implementation"
"import java.io.BufferedInputStreamimport java.util.* fun main(args: Array<String>) {    val scanner = Scanner(BufferedInputStream(System.`in`))     var r = scanner.nextLong()    var g = scanner.nextLong()    var b = scanner.nextLong()     var ones = Math.min(r, Math.min(g, b))    var ans = 0L    r -= ones    g -= ones    b -= ones    ans += r/3 + g/3 + b/3    r %= 3    g %= 3    b %= 3     while(ones > 0 && (r + g + b >= 4)){        --ones        r += 1        g += 1        b += 1        ans += r/3 + g/3 + b/3        r %= 3        g %= 3        b %= 3    }      //println(""$r $g $b"")    print(ans+ones)}","combinatorics,math"
"import java.util.* /** * Created by Hamza on 07/11/2017. */fun main(args: Array<String>) {    var sc = Scanner(System.`in`)     var r = sc.nextInt()    var g = sc.nextInt()    var b = sc.nextInt()//    var min = 0//    if (r <=g && r<=b ){//        min = r//    }else if (g<=r && g<=b){//        min = g//    }else min = b //    var result = min + (r-min )/ 3 + (g-min )/3+(b-min)/3     var reste_1 = if (r - 1 >= 0 && (b - 1) >= 0 && (g - 1) >= 0) (r - 1) / 3 + (g - 1) / 3 + (b - 1) / 3 + 1 else 0    var reste_2 = if (r - 2 >= 0 && (b - 2) >= 0 && (g - 2) >= 0) (r - 2) / 3 + (g - 2) / 3 + (b - 2) / 3 + 2 else 0    var result = Math.max(Math.max(r / 3 + g / 3 + b / 3, reste_2), reste_1)    println(""${result}"") }","combinatorics,math"
"import java.lang.AssertionErrorimport java.util.* val readQueue = ArrayDeque<String>()fun getInput(): String {    if (readQueue.isEmpty()) readLine()!!.split(' ', '\n').let{ readQueue.addAll(it) }    return readQueue.pop()} fun getInt() = getInput().toInt()fun getLong() = getInput().toLong()fun getString() = getInput() const val MOD107 = 1000000007Lconst val MOD998 = 998244353Lfun myAssert(b : Boolean) {    if (!b) throw AssertionError()} fun main() {    var a = readLine()!!.split("" "").map{ it.toLong() }     var ans = 0L    for (mix in 0 until 3) {        var sum = mix.toLong()        var poss = true        for (i in a)            if (i < mix)                poss = false            else                sum += (i - mix) / 3         if (poss)            ans = Math.max(ans, sum)    }     println(ans)}","combinatorics,math"
"import java.io.PrintWriterimport java.util.StringTokenizer fun main() {     fun PrintWriter.solve() {        var (r,g,b) = readInts()        var ans1 = r/3 + g/3 + b/3         var ans2 = 0        var ans3 = 0         if (minOf(r,g,b) > 0){            r--            g--            b--             ans2++            ans2 += r/3 + g/3 + b/3        }         if (minOf(r,g,b) > 0){            r--            g--            b--             ans3+=2            ans3 += r/3 + g/3 + b/3        }         println(maxOf(ans1,ans2,ans3))          }     writer.solve()    writer.flush()  }  private val reader = System.`in`.bufferedReader()private val writer = PrintWriter(System.out, false) private var tokenizer: StringTokenizer = StringTokenizer("""") private fun next(): String {    while (tokenizer.hasMoreTokens().not()) tokenizer = StringTokenizer(reader.readLine())    return tokenizer.nextToken()} private fun nextInt() = next().toInt()private fun nextLong() = next().toLong()private fun nextDouble() = next().toDouble()private fun nextLine() = reader.readLine()private fun readInts() = nextLine().split("" "").map { it.toInt() } ","combinatorics,math"
"fun main() {    val (numCandies, numFriends) = readLine()!!.split("" "").map(String::toInt)    val sol = IntArray(numFriends)    val less = numCandies / numFriends    val more = less + if (numCandies % numFriends == 0) 0 else 1    val numLess = numFriends - numCandies % numFriends    for (pos in 0 until numLess) sol[pos] = less    for (pos in numLess until numFriends) sol[pos] = more    print(sol.joinToString("" ""))}",implementation
"import java.util.*import java.io.*import kotlin.collections.HashMapimport kotlin.math.* const val DEBUG = false var output : PrintWriter = PrintWriter(BufferedOutputStream(System.out)) fun main() {    if (DEBUG) output = PrintWriter(BufferedOutputStream(FileOutputStream(""out.log"")))     solve()    output.flush()} fun solve() {    val (n,m) = _nextints()        for (i in 0 until m) {        _print(n/m + (if (i < n % m) 1 else 0))        if (i!=n-1)_print("" "")    }        _println()} val input = Input(DEBUG) fun _println(a : Any) = output.println(a)fun _println() = output.println()fun _print(a : Any) = output.print(a)fun _iprintln(a : Any) {output.println(a); output.flush()} fun _nextint() : Int = input.nextInt()fun _nextlong() : Long = input.nextLong()fun _nextline() : String = input.nextLine()fun _nextstring() : String = input.next() fun IntArray.read() : IntArray {for (i in this.indices) this[i] = _nextint(); return this}fun LongArray.read() : LongArray {for (i in this.indices) this[i] = _nextlong(); return this} fun _nextints() : ArrayList<Int> = ArrayList(_nextline().split("" "").map {it -> it.toInt()})fun _nextlongs() : ArrayList<Long> = ArrayList(_nextline().split("" "").map {it -> it.toLong()})fun _nextstrings() : ArrayList<String> = ArrayList(_nextline().split("" "")) class Input (DEBUG : Boolean) {     private val br = if (DEBUG) BufferedReader(InputStreamReader(FileInputStream(""in.log""))) else BufferedReader(InputStreamReader(System.`in`))    private var st : StringTokenizer = StringTokenizer("""")     fun next() : String {        while (st.hasMoreElements().not()) st = StringTokenizer(br.readLine() ?: return """", "" "")        return st.nextToken()    }     fun nextInt() : Int = next().toInt()    fun nextLong() : Long = next().toLong()    fun nextLine() : String = br.readLine() ?: """"}",implementation
"import java.io.*import java.text.SimpleDateFormatimport java.util.*import kotlin.Comparatorimport kotlin.math.absimport kotlin.math.maximport kotlin.math.minimport kotlin.math.roundimport kotlin.random.Randomimport kotlin.system.measureTimeMillis /** * 23.02.2020 * Main * * @author Havlong * @version v1.0 */class LineReader(tempReader: Reader) {    private val reader = BufferedReader(tempReader)    fun hasNext() = peek() != -1    private fun peek(): Int {        reader.mark(1)        return reader.read().also { reader.reset() }    }     fun skipSpaces() {        while (Character.isWhitespace(peek()))            reader.read()    }     fun readLine(): String = reader.readLine()    fun longList() = readLine().split(' ').map(String::toLong)    fun intList() = readLine().split(' ').map(String::toInt)} typealias ML = MutableList<Long>typealias MI = MutableList<Int>typealias LL = List<Long>typealias LLL = List<LL>typealias PLL = Pair<Long, Long>typealias PPLL = Pair<Long, PLL> const val M7 = 1000000007Lconst val M9 = 1000000009Lconst val MFFT = 998244353Lconst val INF = 2000000000000000000L fun lowerBound(from: Long, to: Long, comparison: (Long) -> Long): Long {    var left = from    var right = to + 1    while (left < right) {        val mid = (left + right) / 2        val result = comparison(mid)        if (result >= 0) {            right = mid        } else {            left = mid + 1        }    }    return left} fun upperBound(from: Long, to: Long, comparison: (Long) -> Long): Long {    var left = from    var right = to + 1    while (left < right) {        val mid = (left + right) / 2        val result = comparison(mid)        if (result > 0) {            right = mid        } else {            left = mid + 1        }    }    return left} fun <T : Comparable<T>> List<T>.upperBound(key: T, from: Int = 0, to: Int = size - 1): Int {    return upperBound(from.toLong(), to.toLong()) { this[it.toInt()].compareTo(key).toLong() }.toInt()} fun <T : Comparable<T>> List<T>.lowerBound(key: T, from: Int = 0, to: Int = size - 1): Int {    return lowerBound(from.toLong(), to.toLong()) { this[it.toInt()].compareTo(key).toLong() }.toInt()} fun <T : Comparable<T>> Array<T>.upperBound(key: T, from: Int = 0, to: Int = size - 1): Int {    return upperBound(from.toLong(), to.toLong()) { this[it.toInt()].compareTo(key).toLong() }.toInt()} fun <T : Comparable<T>> Array<T>.lowerBound(key: T, from: Int = 0, to: Int = size - 1): Int {    return lowerBound(from.toLong(), to.toLong()) { this[it.toInt()].compareTo(key).toLong() }.toInt()} operator fun <A : Comparable<A>, B : Comparable<B>> Pair<A, B>.compareTo(other: Pair<A, B>): Int {    return first.compareTo(other.first).let { if (it == 0) second.compareTo(other.second) else it }} fun binPow(number: Long, power: Long, mod: Long): Long {    var result = 1L    var a = number % mod    var n = power    while (n > 0) {        if (n % 2 != 0L)            result = (result * a) % mod        a = (a * a) % mod        n /= 2    }    return result} tailrec fun gcd(a: Long, b: Long): Long = if (b == 0L) a else gcd(b, a % b) fun lcm(a: Long, b: Long) = a * b / gcd(a, b) fun main(args: Array<String>) {    if (args.isNotEmpty() && args[0] == ""local"") {        val reader = LineReader(FileReader(""input.txt""))        PrintWriter(File(""output.txt"")).use {            while (reader.hasNext()) {                it.println(""\n${measureTimeMillis {                    solve(reader, it)                }} ms\n"")                reader.skipSpaces()            }        }    } else {        val reader = LineReader(InputStreamReader(System.`in`))        PrintWriter(System.out).use { solve(reader, it) }    }} fun solve(reader: LineReader, writer: PrintWriter) {    val format = SimpleDateFormat(""yyyy:MM:dd"")    val start = format.parse(reader.readLine().trim())    val end = format.parse(reader.readLine().trim())    writer.println(abs(round((end.time - start.time) / 1000.0 / 3600 / 24)).toLong())}","brute force,implementation"
"private fun readLn() = readLine()!!private fun readInt() = readLn().toInt()private fun readStrings() = readLn().split("" "")private fun readInts() = readStrings().map { it.toInt() } fun main() {    val t = readInt()    repeat(t) {        solve()    }} fun solve() {    val n = readInt()    val s = readLn()     val a = ArrayList<Int>(n)     var p = '0'    var c = 0    s.forEach {        if (it == p) {            c++        } else {            a.add(c)            c = 1            p = it        }    }     var r = 0    var i = 0    while (i < a.size) {        if (a[i] % 2 == 1) {            a[i] = a[i] - 1            if (i + 1 < a.size) {                a[i + 1] = a[i + 1] + 1            }            r++        } else i++    }     println(r)}",implementation
 fun main(args : Array<String>){     val t = readLine()!!.toInt()    repeat(t){        val n = readLine()!!.toInt()        val s = readLine()!!.toString()        var list = mutableListOf<Int>()        var last = s[0]        var count = 1        for (i in 1 until s.length){            if (s[i] == last){                count++            }else{                list.add(count)                last = s[i]                count = 1            }        }        list.add(count)        var ans = 0        var isFirst = true        for (i in 0 until list.size){            if (list[i]%2 != 0){                if (isFirst){                    ans-= i                    isFirst = false                }else{                    ans+= i                    isFirst = true                }            }        }        println(ans)    }},implementation
"import java.io.*import java.util.*import kotlin.math.* val INPUT = System.`in`!!val OUTPUT = System.out!!val reader = INPUT.bufferedReader()fun readLine(): String? = reader.readLine()fun line() = reader.readLine()!!var st: StringTokenizer = StringTokenizer("""")fun read(): String {    while (st.hasMoreTokens().not())        st = StringTokenizer(reader.readLine() ?: return """", "" "")    return st.nextToken()}fun int() = read().toInt()fun ints(n: Int) = List(n) { read().toInt() }fun intArray(n: Int) = IntArray(n) { read().toInt() }val writer = PrintWriter(OUTPUT, false)fun main() { writer.solve(); writer.flush() }fun PrintWriter.solve() {    var tt = 1    tt = int()    while (tt-- > 0) {        val n = int()        val arr = line().toCharArray()        val list = ArrayList<Int>()        var i = 0        while(i < n) {            var count = 0            while(i < n && arr[i] == '0') {                i++                count++            }            if(count > 0) list.add(count)            count = 0            while(i < n && arr[i] == '1') {                i++                count++            }            if(count > 0) list.add(count)        }        var last = -1        var count = 0        //println(list)        for(i in list.indices) {            if(list[i] % 2 == 1) {                if(last == -1) last = i                else {                    count += (i - last)                    last = -1                }            }        }        println(count)    }}",implementation
"fun solveIt(n: Int, str: String): Int {    var ans = 0    var current = str[0]    var currentCount = 1    for (i in 1 until str.length){        if(str[i] == current){            currentCount ++        }        else{            if(currentCount %2 == 1){                ans ++                currentCount = 2            }            else{                currentCount = 1            }        }        current = str[i]    }    return ans}fun main() {    // get t value    val t = readLine()!!.toInt()    // get two integers t times    repeat(t) {        val n = readLine()!!.toInt()        val array = readLine()!!        val ans = solveIt(n, array)        println(ans)    }}",implementation
