"import java.io.*;\nimport java.util.*;\n\npublic class CF1665C extends PrintWriter {\n	CF1665C() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1665C o = new CF1665C(); o.main(); o.flush();\n	}\n\n	boolean check(int[] dd, int n, int m) {\n		int k1 = 0, k2 = 0;\n		for (int i = n; i >= 0; i--) {\n			int d = dd[i];\n			if (d == 0)\n				break;\n			k1++;\n			d--;\n			if (k1 + d > m)\n				k2 += k1 + d - m;\n		}\n		return k1 + k2 <= m;\n	}\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int[] dd = new int[n + 1];\n			dd[0]++;\n			for (int h = 0; h < n - 1; h++) {\n				int p = sc.nextInt();\n				dd[p]++;\n			}\n			Arrays.sort(dd);\n			int lower = 0, upper = n;\n			while (upper - lower > 1) {\n				int m = (lower + upper) / 2;\n				if (check(dd, n, m))\n					upper = m;\n				else\n					lower = m;\n			}\n			println(upper);\n		}\n	}\n}\n","binary search,greedy,sortings,trees"
"import java.util.*;\n \npublic class Main {\n  \n    public static boolean check(int x,ArrayList<Integer> l){\n      int size=l.size();\n      int b[]=new int[size];\n      int count=0;\n      for(int i=0;i<size;i++){\n        if(l.get(i)>0){\n          b[i]=Math.max(l.get(i)-x+i,0);\n        }\n        count+=b[i];\n      }\n      if(x-count>=size){\n        return true;\n      }\n      return false;\n    }\n  \n    public static void main(String[] args) {\n        Scanner s=new Scanner(System.in);\n        int t=s.nextInt();\n        while(t-->0){\n          int n=s.nextInt();\n          int a[]=new int[n];\n          for(int i=0;i<n-1;i++){\n            int x=s.nextInt();\n            a[x-1]++;\n          }\n          ArrayList<Integer> l=new ArrayList<>();\n          for(int i=0;i<n;i++){\n            if(a[i]!=0){\n              l.add(a[i]);\n            }\n          }\n          l.add(1);\n          Collections.sort(l,Collections.reverseOrder());\n          int lo=0;\n          int hi=n;\n          int ans=n;\n          while(lo<=hi){\n            int mid=(lo+hi)/2;\n            if(check(mid,l)){\n              ans=mid;\n              hi=mid-1;\n            }\n            else{\n              lo=mid+1;\n            }\n          }\n          System.out.println(ans);\n        }\n    }\n}","binary search,greedy,sortings,trees"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport static java.lang.System.out;\n\npublic class Round_780_Div_3 {\n    static Scanner str = new Scanner(System.in);\n    static ArrayList<Integer> list;\n\n    public static void main(String[] args) throws IOException {\n        int t = str.nextInt();\n        while (t-- > 0) {\n            solve();\n        }\n    }\n\n    public static void solve() {\n        int n = str.nextInt();\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, 1);\n        for (int i = 0; i < n - 1; i++) {\n            int a = str.nextInt();\n            map.put(a, map.getOrDefault(a, 0) + 1);\n        }\n        Integer num[] = new Integer[map.size()];\n        int idx = 0;\n        for (Integer x : map.values()) {\n            num[idx++] = x;\n        }\n        Arrays.sort(num, Collections.reverseOrder());\n        int l = num.length;\n        int r = n;\n        while (l < r) {\n            int mid = l + r >> 1;\n            int cnt = 0;\n            for (int i = 0; i < num.length; i++) {\n                cnt += Math.max(0, num[i] - mid + i);\n            }\n            if (cnt + num.length <= mid) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        out.println(l);\n    }\n}","binary search,greedy,sortings,trees"
"\nimport java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int tt = Integer.parseInt(in.readLine());\n        for (int t = 1; t <= tt; t++) {\n            int n = Integer.parseInt(in.readLine());\n            int[] nums = Arrays.stream(in.readLine().split(""\\s+"")).mapToInt(Integer::parseInt).toArray();\n            Map<Integer, Integer> map = new HashMap();\n            for (int num : nums) {\n                map.put(num, map.getOrDefault(num, 0) + 1);\n            }\n            List<Integer> groups = new ArrayList<>();\n            groups.add(1);\n            groups.addAll(map.values());\n            Collections.sort(groups, (a,b) -> b - a);\n            PriorityQueue<Integer> maxQueue = new PriorityQueue<>((a, b) -> b - a);\n            int size = groups.size();\n            for (int i = 0; i < size; i++) {\n                maxQueue.add(groups.get(i) - size + i);\n            }\n            int time;\n            for (time = size; true; time++) {\n                int maxGroup = maxQueue.remove();\n                if (time - size >= maxGroup) {\n                    break;\n                }\n                maxQueue.add(maxGroup - 1);\n            }\n            System.out.println(time);\n        }\n    }\n}\n","binary search,greedy,sortings,trees"
"//package cf;\n\nimport java.util.Scanner;\n\npublic class shinju_and_the_lost_permutation {\npublic static void main(String[] args) {\n	Scanner sc=new Scanner(System.in);\n	int t=sc.nextInt();\n	while(t-->0) {\n		int n=sc.nextInt();\n		int m1[]=new int[n];\n		int num1=0;\n		for(int i=0;i<n;++i) {\n			m1[i]=sc.nextInt();\n			if(m1[i]==1)++num1;\n		}\n		if(num1!=1) {\n			System.out.println(""NO"");\n			continue;\n		}\n		int p=0;\n		while(m1[p]!=1)++p;\n		int m2[]=new int[n];\n		for(int i=0;i<n;++i) {\n			m2[i]=m1[p++];\n			if(p==n)p=0;\n		}\n		int fl=1;\n		for(int i=1;i<n;++i) {\n			if(m2[i]-m2[i-1]>1) {\n				fl=0;\n				break;\n			}\n		}\n		if(fl==0)System.out.println(""NO"");\n		else System.out.println(""YES"");\n	}\n}\n}\n","constructive algorithms,math"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1658C extends PrintWriter {\n	CF1658C() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1658C o = new CF1658C(); o.main(); o.flush();\n	}\n\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int[] cc = new int[n];\n			for (int i = 0; i < n; i++)\n				cc[i] = sc.nextInt();\n			int h = 0;\n			while (h < n && cc[h] != 1)\n				h++;\n			boolean yes;\n			if (h == n)\n				yes = false;\n			else {\n				yes = true;\n				for (int i = 1; i < n; i++) {\n					int a = cc[(h + i) % n];\n					int b = cc[(h + i - 1) % n];\n					if (a > b + 1 || a < 2) {\n						yes = false;\n						break;\n					}\n				}\n			}\n			println(yes ? ""YES"" : ""NO"");\n		}\n	}\n}\n","constructive algorithms,math"
"\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Srhossain{\n	public static void main(String[] args){\n		new Srhossain();\n	}\n	public Srhossain(){\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		for(int tc=1; tc<=t; tc++){\n			int n = sc.nextInt();\n			ArrayList<Integer> input = new ArrayList<Integer>();\n			boolean ans = true;\n			int one = 0;\n			for(int i=0; i<n; i++)input.add(sc.nextInt());\n			input.add(input.get(0));\n			for(int i=0; i<n; i++){\n				if(input.get(i+1) > input.get(i) + 1)ans = false;\n				if(input.get(i) == 1)one++;\n			}\n			if(one != 1)ans = false;\n\n			if(!ans)showln(""NO"");\n			else showln(""YES"");\n		}\n\n		\n		sc.close();\n	}\n	public void show(String s){ System.out.print(s); }\n	public void showln(String s){ System.out.println(s); }\n	\n}","constructive algorithms,math"
"import java.util.*;\npublic class Main{\n	public static void solve(){\n		int n  =at.nextInt();\n		int[]c = new int[n];\n		int index = -1;\n		int count = 0;\n		for(int i = 0;i<n;i++){\n			c[i] = at.nextInt();\n			if(c[i] == 1){\n				index = i;\n				count++;\n			}\n		}\n\n		if(count != 1){\n			System.out.println(""NO"");\n			return;\n		}\n\n\n		for(int i  = 1;i<n;i++){\n			if(i == index){\n				continue;\n			}\n			if(c[i] > c[i-1]+1 || c[i] == 1){\n				System.out.println(""NO"");\n				return;\n			}\n		}\n\n		if(c[0] != 1 && (c[0] > c[n-1]+1 || c[0] == 1)){\n			System.out.println(""NO"");\n			return;\n		}\n		System.out.println(""YES"");\n\n\n\n\n\n\n	}\n	static Scanner at = new Scanner(System.in);\n	public static void main(String[]args){\n		int t = at.nextInt();\n		while(t-->0){\n			solve();\n		}\n	}\n}","constructive algorithms,math"
//package cf;\n\nimport java.util.Scanner;\n\npublic class marin_and_Anti_coprime_Permutation {\npublic static void main(String[] args) {\n	Scanner sc=new Scanner(System.in);\n	int t=sc.nextInt();\n	while(t-->0) {\n		int n=sc.nextInt();\n		if(n%2==1) {\n			System.out.println(0);\n			continue;\n		}\n		long re=1;\n		for(int i=1;i<=n/2;++i)re=(re*(long)i)%(long)998244353;\n		for(int i=1;i<=n/2;++i)re=(re*(long)i)%(long)998244353;\n		System.out.println(re);\n	}\n}\n}\n,"combinatorics,math,number theory"
import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int t = scanner.nextInt();\n        while (t-- > 0) {\n        	int n = scanner.nextInt();\n        	long res = 1;\n        	for (int i = 1; i <= n/2; i++) {\n        		res *= i * i;\n        		res %= 998244353;\n        	}\n        	System.out.println(n%2 == 0 ? res : 0);\n        }\n    }\n},"combinatorics,math,number theory"
import java.util.*;\npublic class Program\n{\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int t = input.nextInt();\nwhile (t-- > 0)\n{\n  int n = input.nextInt();\n  int M = 998244353;\n  if( n % 2 == 1)\n  {\n    System.out.println(0);\n   }\n  else\n  {\n    long p = 1 ; \n    p %= M ;\n    for(int i = 1 ; i <= n/2 ; i++)\n    {\n      p = ((p%M)*(i%M)*(i%M))%M;\n    }\n   System.out.println(p);\n}\n}\n    }\n},"combinatorics,math,number theory"
import java.util.*;\npublic class PermBeuaty {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner s = new Scanner(System.in);\n		int t = s.nextInt();\n		int m = 998244353;\n		while (t-- > 0) {\n			int n = s.nextInt();\n			if (n % 2 == 0) {\n				long ans = 1;\n				for (int i = 2; i <= n / 2; i++) {\n					ans = ans * i % m * i % m;\n				}\n				System.out.println(ans);\n			} else {\n				System.out.println(0);\n			}\n		}\n		\n	}\n\n}\n,"combinatorics,math,number theory"
"import java.util.*;\nimport java.io.*;\npublic class Main {\n  public static void main(String[] args) throws IOException {\n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    for(int a = 0; a < t; a++) {\n      HashMap<Integer, Integer> xVals = new HashMap<Integer, Integer>();\n      HashMap<Integer, Integer> yVals = new HashMap<Integer, Integer>();\n      long ans = 1;\n      int n = sc.nextInt();\n      int m = sc.nextInt();\n      long k = sc.nextLong();\n      int q = sc.nextInt();\n      int[] xCord = new int[q];\n      int[] yCord = new int[q];\n      for(int i = 0; i < q; i++) {\n        xCord[i] = sc.nextInt();\n        yCord[i] = sc.nextInt();\n      }\n      for(int i = q - 1; i >= 0; i--) {\n        int x = xCord[i];\n        int y = yCord[i];\n        if(!xVals.containsKey(x) || !yVals.containsKey(y)) {\n          xVals.put(x, 1);\n          yVals.put(y, 1);\n          ans = ans * k % 998244353;\n        }\n        if(xVals.size() == n || yVals.size() == m) {\n          break;\n        }\n      }\n      System.out.println(ans % 998244353);\n    }\n  }\n}","data structures,implementation,math"
import java.util.*;\nimport java.io.*;\nimport java.util.HashMap;\nimport java.util.function.Consumer;\nimport java.util.Comparator;\n\n\n\n\n\npublic class FirstProject{\n	static void solve(Scanner src) {\n		int n=src.nextInt();\n		int m=src.nextInt();\n		int k=src.nextInt();\n		int q=src.nextInt();\n		long ans = 1L;\n		HashSet<Integer>row=new HashSet<>();\n		HashSet<Integer>col=new HashSet<>();\n		int op[][]=new int[q][2];\n		for(int i=0;i<q;i++) {\n			for(int j=0;j<2;j++) {\n				op[i][j]=src.nextInt();\n			}\n		}\n		for(int i=q-1;i>=0;i--) {\n			boolean flag = false;\n            if (!row.contains(op[i][0]) && col.size() != m)\n                flag = true;\n            if (!col.contains(op[i][1]) && row.size() != n)\n                flag = true;\n            row.add(op[i][0]);\n            col.add(op[i][1]);\n            if (flag) {\n                ans *= k;\n                ans %= 998244353;\n            }\n		}\n		System.out.println(ans);\n	}\n	public static void main(String[] args) throws IOException{\n		Scanner src=new Scanner(System.in);\n		int t=src.nextInt();\n		while(t-- > 0) {\n			solve(src);\n		}\n	}\n},"data structures,implementation,math"
"import java.util.*;\nimport java.io.*;\npublic class Main {\n  public static void main(String[] args) throws IOException {\n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    for(int a = 0; a < t; a++) {\n      HashMap<Integer, Integer> xVals = new HashMap<Integer, Integer>();\n      HashMap<Integer, Integer> yVals = new HashMap<Integer, Integer>();\n      long ans = 1;\n      int n = sc.nextInt();\n      int m = sc.nextInt();\n      long k = sc.nextLong();\n      int q = sc.nextInt();\n      int[] xCord = new int[q];\n      int[] yCord = new int[q];\n      for(int i = 0; i < q; i++) {\n        xCord[i] = sc.nextInt();\n        yCord[i] = sc.nextInt();\n      }\n      for(int i = q - 1; i >= 0; i--) {\n        int x = xCord[i];\n        int y = yCord[i];\n        boolean works = false;\n        if(!xVals.containsKey(x)) {\n          xVals.put(x, 1);\n          works = true;\n        }\n        if(!yVals.containsKey(y)) {\n          yVals.put(y, 1);\n          works = true;\n        }\n        if(works) {\n          ans = ans * k % 998244353;\n        }\n        if(xVals.size() == n || yVals.size() == m) {\n          break;\n        }\n      }\n      System.out.println(ans % 998244353);\n    }\n  }\n}","data structures,implementation,math"
"import java.io.*;\nimport java.util.*;\n\npublic class Codeforces\n{\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb=new StringBuilder();\n        int t=Integer.parseInt(bu.readLine());\n        while(t-->0)\n        {\n            String s[]=bu.readLine().split("" "");\n            int n=Integer.parseInt(s[0]),m=Integer.parseInt(s[1]),k=Integer.parseInt(s[2]),q=Integer.parseInt(s[3]);\n            int i,c[][]=new int[q][2];\n            for(i=0;i<q;i++)\n            {\n                s=bu.readLine().split("" "");\n                int x=Integer.parseInt(s[0]),y=Integer.parseInt(s[1]);\n                c[i][0]=x; c[i][1]=y;\n            }\n\n            long ans=1,M=998244353;\n            Set<Integer> x=new HashSet<>(),y=new HashSet<>();\n            for(i=q-1;i>=0;i--)\n            {\n                boolean okrow=y.size()!=m && !x.contains(c[i][0]);\n                boolean okcol=x.size()!=n && !y.contains(c[i][1]);\n                if(okrow || okcol) ans=ans*k%M;\n                x.add(c[i][0]); y.add(c[i][1]);\n            }\n            sb.append(ans+""\n"");\n        }\n        System.out.print(sb);\n    }\n}","data structures,implementation,math"
"\n\nimport java.util.Scanner;\n\npublic class E {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int lines = s.nextInt();\n\n        s.nextLine();\n\n        for (int i = 0; i < lines; i += 1) {\n            solve(s.nextInt(), s);\n        }\n    }\n\n\n    public static void solve(int n, Scanner s) {\n        int[][] grid = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = s.nextInt();\n            }\n        }\n\n        int xor = 0;\n\n        int startX = 0;\n        int startY = 0;\n\n        for (int i = 0; i < n / 2; i++) {\n            for (int j = 0; j <= Math.abs(startX - startY) / 2; j++) {\n                xor ^= grid[startX + j * 2][startY - j * 2];\n                xor ^= grid[n - 1 - (startX + j * 2)][startY - j * 2];\n            }\n\n            for (int j = 0; j < 4; j++) {\n                if (startY < n - 1) startY++; else startX++;\n            }\n        }\n\n        System.out.println(xor);\n    }\n}\n","constructive algorithms,greedy,implementation,interactive,math"
import java.util.*;\n\npublic class testttt {\n	\n\n	public static void main(String[] args) {\n		\n	\n		Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        while(m-->0) {\n            int n = sc.nextInt();\n            int[][] arr= new int[n][n];\n            int[][] c= new int[n][n];\n            \n            for (int i = 0; i <n; i++) {\n            	for(int j=0;j<n;j++)\n            	{\n                    arr[i][j]=sc.nextInt();\n            	}\n            }\n            \n            int res=0;\n            for (int i = 1; i <n; i=i+1) {\n            	for(int j=0;j<n;j++)\n            	{\n                    if(c[i-1][j]%2==0)\n                    {\n                    	res=res^arr[i][j];\n                    	c[i-1][j]+=1;\n                    	\n                    	if(i+1<n)\n                    		c[i+1][j]+=1;\n                    	\n                    	if(j+1<n)\n                    		c[i][j+1]+=1;\n                    	\n                    	if(j-1>=0)\n                    		c[i][j-1]+=1;\n                    	\n                    }\n            	}\n            }\n            \n            \n            System.out.println(res);\n        }\n	}\n},"constructive algorithms,greedy,implementation,interactive,math"
import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class E {\n\n	public static void main(String[] args) throws IOException {\n		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n		int inputs = Integer.parseInt(in.readLine());\n		while(inputs-->0) {\n			int n = Integer.parseInt(in.readLine());\n			\n			int[][] nums = new int[n][n];\n			for(int i = 0; i < n; i++) {\n				StringTokenizer st = new StringTokenizer(in.readLine());\n				for(int j = 0; j < n; j++) {\n					nums[i][j] = Integer.parseInt(st.nextToken());\n				}\n			}\n			int xor = 0;\n			int squareXor = 0;\n			//all squares except two main diagonals\n			for(int i = (n-1)/2; i >= 0; i--) {\n				for(int j = i; j+i < n; j++) {\n					squareXor ^= nums[i][j];\n					squareXor ^= nums[n-i-1][j];\n					squareXor ^= nums[j][i];\n					squareXor ^= nums[j][n-i-1];\n				}\n				squareXor ^= nums[i][i];\n				squareXor ^= nums[i][n-i-1];\n				squareXor ^= nums[n-i-1][i];\n				squareXor ^= nums[n-i-1][n-i-1];\n				if(i%2 == 0)\n					xor ^= squareXor;\n			}\n			//diagonals\n			for(int i = 0; i < n; i++) {\n				for(int j = 0; j < n; j++) {\n					if(i+j >= n && i%2 == 1 && j%2 == 1) {\n						xor ^= nums[i][j];\n						xor ^= nums[i][n-j-1];\n					}\n						\n				}\n			}\n			System.out.println(xor);\n		}\n\n	}\n\n}\n,"constructive algorithms,greedy,implementation,interactive,math"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class C1628 {\n\n    private static int find(int[][] x, int[][] a, int r, int c) {\n        int n = x.length;\n        if (r == 1) {\n            if (c == 0) {\n                return a[0][1] ^ x[0][0];\n            }\n            if (c == n - 1) {\n                return a[0][n - 2] ^ x[0][n - 1];\n            }\n            return a[0][c - 1] ^ a[0][c + 1] ^ x[0][c];\n        }\n        if (c == 0) {\n            return a[r - 1][1] ^ a[r - 2][0] ^ x[r - 1][0];\n        }\n        if (c == n - 1) {\n            return a[r - 1][n - 2] ^ a[r - 2][n - 1] ^ x[r - 1][n - 1];\n        }\n        return a[r - 1][c - 1] ^ a[r - 1][c + 1] ^ a[r - 2][c] ^ x[r - 1][c];\n    }\n\n    private static int findAllXor(int[][] x) {\n        int n = x.length;\n        int[][] a = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            a[0][i] = 0;\n        }\n        int res = 0;\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                a[i][j] = find(x, a, i, j);\n                res ^= a[i][j];\n            }\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader rd = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        int numTests = Integer.parseInt(rd.readLine());\n        for (int t = 0; t < numTests; t++) {\n            int n = Integer.parseInt(rd.readLine());\n            int[][] x = new int[n][n];\n            for (int i = 0; i < n; i++) {\n                StringTokenizer st = new StringTokenizer(rd.readLine());\n                for (int j = 0; j < n; j++) {\n                    x[i][j] = Integer.parseInt(st.nextToken());\n                }\n            }\n            pw.println(findAllXor(x));\n        }\n        pw.flush();\n        pw.close();\n        rd.close();\n    }\n}\n","constructive algorithms,greedy,implementation,interactive,math"
"import java.util.*;\npublic class Main{\n  public static void main(String args[]){\n      Scanner sc=new Scanner(System.in);\n      int t=sc.nextInt();\n      while(t-->0){\n        int n,m,rb,cb,rd,cd;\n        n=sc.nextInt();\n        m=sc.nextInt();\n        rb=sc.nextInt();\n        cb=sc.nextInt();\n        rd=sc.nextInt();\n        cd=sc.nextInt();\n        int ans=Math.min(rb<=rd?rd-rb:2*n-rb-rd,cb<=cd?cd-cb:2*m-cb-cd);\n        System.out.println(ans);\n      }\n    }\n  }","brute force,implementation,math"
"import java.util.*;\n\npublic class _1623a {\n\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		int t = s.nextInt();\n		while(t-->0)\n		{\n			int r = s.nextInt();\n			int c = s.nextInt();\n			int rs = s.nextInt() , cs = s.nextInt();\n			int rd = s.nextInt() , cd = s.nextInt();\n			\n			int ans1  = (rd>=rs)?(rd-rs):((rs-rd)+2*(r-rs));\n			int ans2 = (cd>=cs)?(cd-cs):((cs-cd)+2*(c-cs));\n			System.out.println(Math.min(ans2, ans1));\n		}\n		s.close();\n	}\n\n}","brute force,implementation,math"
"import java.util.*;\n \npublic class _1623a {\n \n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		int t = s.nextInt();\n		while(t-->0)\n		{\n			int r = s.nextInt();\n			int c = s.nextInt();\n			int rs = s.nextInt() , cs = s.nextInt();\n			int rd = s.nextInt() , cd = s.nextInt();\n			\n			int ans1  = (rd>=rs)?(rd-rs):((rs-rd)+2*(r-rs));\n			int ans2 = (cd>=cs)?(cd-cs):((cs-cd)+2*(c-cs));\n			System.out.println(Math.min(ans2, ans1));\n		}\n		s.close();\n	}\n \n}","brute force,implementation,math"
"import java.util.*;\n \npublic class _1623a {\n \n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		int t = s.nextInt();\n		while(t-->0)\n		{\n			int r = s.nextInt();\n			int c = s.nextInt();\n			int rs = s.nextInt() , cs = s.nextInt();\n			int rd = s.nextInt() , cd = s.nextInt();\n			\n			int ans1  = (rd>=rs)?(rd-rs):((rs-rd)+2*(r-rs));\n			int ans2 = (cd>=cs)?(cd-cs):((cs-cd)+2*(c-cs));\n			System.out.println(Math.min(ans2, ans1));\n		}\n		s.close();\n	}\n \n}","brute force,implementation,math"
"import java.util.*;\nimport java.io.*;\n\npublic class F {\n\n    static FastScanner fs = new FastScanner();\n    static PrintWriter pw = new PrintWriter(System.out);\n    static StringBuilder sb = new StringBuilder("""");\n\n    public static void main(String[] args) {\n        int t = fs.nextInt();\n        for (int tt = 0; tt < t; tt++) {\n            int n = fs.nextInt(), a = fs.nextInt();\n            int b = fs.nextInt(), c = fs.nextInt();\n            String s = fs.next();\n            ArrayList<Integer> p = new ArrayList<>();\n            for (int i = 0; i < n; i++) if (s.charAt(i) == '1') p.add(i);\n            int cnt = p.size();\n            if (cnt == 0) {\n                if (n == 1) sb.append(""0\n"");\n                else sb.append(a + ""\n"");\n            } else {\n                int A = 0, C = 0;\n                for (int i = 0; i < n; i++) {\n                    if (s.charAt(i) == '0') {\n                        if (i == 0) C++;\n                        else if (s.charAt(i-1) == '1') C++;\n                        else A++;\n                    }\n                }\n                int[] d = new int[cnt-1];\n                for (int i = 0; i < cnt-1; i++) d[i] = p.get(i+1) - p.get(i) - 1;\n                sort(d);\n                int sum = 0;\n                int nonzero = 0;\n                long ans = 0;\n                for (int i = 0; i < cnt; i++) {\n                    if (sum >= i+1) break;\n                    if (A+C < i-1) break;\n                    long res = (long) b * i;\n                    res-= (long) c * nonzero;\n                    res += (long) a * (sum - nonzero);\n                    int A2 = A - (sum - nonzero);\n                    int rem = i+1 - sum;\n                    int x = Math.min(rem, A2);\n                    res += (long) a * x;\n                    rem -= x;\n                    int R;\n                    if (i == 0) R = Math.max(rem-1, 0);\n                    else R = Math.max(rem-2, 0);\n                    res -= (long) c * R;\n                    ans = Math.max(ans, res);\n                    if (i < cnt - 1) {\n                        sum += d[i];\n                        if (d[i] > 0) nonzero++;\n                    }\n                }\n                sb.append(ans + ""\n"");\n            }\n        }\n        pw.print(sb.toString());\n        pw.close();\n    }\n    \n    static void sort(int[] a) {\n        ArrayList<Integer> al = new ArrayList<>();\n        for (int i : a)\n            al.add(i);\n        Collections.sort(al);\n        for (int i = 0; i < a.length; i++)\n            a[i] = al.get(i);\n    }\n\n    static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer("""");\n        String next() {while (!st.hasMoreTokens()) try {st = new StringTokenizer(br.readLine());} catch (IOException e) {}return st.nextToken();}\n        int nextInt() {return Integer.parseInt(next());}\n        long nextLong() {return Long.parseLong(next());}\n        double nextDouble() {return Double.parseDouble(next());}\n    }\n}","data structures,greedy,implementation"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author lucasr\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		MyScanner in = new MyScanner(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		FStrangeInstructions solver = new FStrangeInstructions();\n		int testCount = Integer.parseInt(in.next());\n		for (int i = 1; i <= testCount; i++)\n			solver.solve(i, in, out);\n		out.close();\n	}\n\n	static class FStrangeInstructions {\n		public static MyScanner sc;\n		public static PrintWriter out;\n\n		public void solve(int testNumber, MyScanner sc, PrintWriter out) {\n			FStrangeInstructions.sc = sc;\n			FStrangeInstructions.out = out;\n			int n = sc.nextInt();\n			long a = sc.nextInt();\n			long b = sc.nextInt();\n			long c = sc.nextInt();\n			char[] vals = sc.next().toCharArray();\n			int tot1 = 0, extra1 = 0;\n			List<Integer> mid0 = new ArrayList<>();\n			int singleMid0 = 0, leftBorder = 0, rightBorder = 0;\n			for (leftBorder = 0; leftBorder < n; leftBorder++) {\n				if (vals[leftBorder] != '0') break;\n			}\n			if (leftBorder == n) {\n				out.println(n > 1 ? a : 0);\n				return;\n			}\n			int from = leftBorder;\n			for (rightBorder = 0; rightBorder < n; rightBorder++) {\n				if (vals[n - rightBorder - 1] != '0') break;\n			}\n			int to = n - rightBorder;\n			int tmp = leftBorder;\n			int border = 0, extraBorder = 0;\n			if (leftBorder > 0) {\n				border++;\n				extraBorder += leftBorder - 1;\n			}\n			if (rightBorder > 0) {\n				border++;\n				extraBorder += rightBorder - 1;\n			}\n			int got = 1;\n			char last = '1';\n			for (int i = from + 1; i < to; i++) {\n				if (vals[i] == last) {\n					got++;\n				} else {\n					if (last == '1') {\n						tot1++;\n						extra1 += got - 1;\n					} else {\n						if (got > 1) {\n							mid0.add(got - 1);\n						} else {\n							singleMid0++;\n						}\n					}\n					got = 1;\n				}\n				last = vals[i];\n			}\n			tot1++;\n			extra1 += got - 1;\n			long ans = 0;\n			Collections.sort(mid0);\n			int mid0Idx = 0;\n			while (extra1 > 0 && mid0Idx < mid0.size()) {\n				int val = mid0.get(mid0Idx);\n				int min = Math.min(extra1, val);\n				extra1 -= min;\n				mid0.set(mid0Idx, val - min);\n				ans += (a + b) * min;\n				if (val - min == 0) {\n					mid0Idx++;\n					singleMid0++;\n				}\n			}\n			if (extra1 > 0 && extraBorder > 0) {\n				int min = Math.min(extra1, extraBorder);\n				extra1 -= min;\n				extraBorder -= min;\n				ans += (a + b) * min;\n			}\n			if (extra1 == 0) {\n				if (mid0Idx < mid0.size() || extraBorder > 0) {\n					ans += a;\n				}\n				ans += Math.max(0, (b - c) * singleMid0);\n			} else {\n				if (mid0Idx < mid0.size() || extraBorder > 0) {\n					throw new RuntimeException();\n				}\n				ans += b;\n				extra1--;\n				if (b > c) {\n					ans += (b - c) * singleMid0;\n					ans += (b - c) * Math.min(border, extra1);\n				}\n			}\n			out.println(ans);\n		}\n\n	}\n\n	static class MyScanner {\n		private BufferedReader br;\n		private StringTokenizer tokenizer;\n\n		public MyScanner(InputStream is) {\n			br = new BufferedReader(new InputStreamReader(is));\n		}\n\n		public String next() {\n			while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n				try {\n					tokenizer = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n			return tokenizer.nextToken();\n		}\n\n		public int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n	}\n}\n\n","data structures,greedy,implementation"
"// coached by rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1617D2 extends PrintWriter {\n	CF1617D2() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1617D2 o = new CF1617D2(); o.main(); o.flush();\n	}\n\n	int query(int i, int j, int k) {\n		println(""? "" + (i + 1) + "" "" + (j + 1) + "" "" + (k + 1));\n		return sc.nextInt();\n	}\n	int[] aa;\n	void judge(int j0, int j1, int i) {\n		if (i != j0 && i != j1 && aa[i] == -1)\n			aa[i] = query(j0, j1, i);\n	}\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			aa = new int[n]; Arrays.fill(aa, -1);\n			int[] bb = new int[n / 3];\n			for (int i = 0; i < n; i += 3)\n				bb[i / 3] = query(i, i + 1, i + 2);\n			int h0 = 0;\n			while (bb[h0] != 0)\n				h0++;\n			int h1 = 0;\n			while (bb[h1] != 1)\n				h1++;\n			int i0 = h0 * 3, i1 = h1 * 3, j0 = -1, j1 = -1;\n			if (query(i0, i1, i1 + 1) == 0) {\n				aa[j0 = i0] = 0;\n				aa[j1 = i1 + 2] = 1;\n			} else if (query(i0, i1, i1 + 2) == 0) {\n				aa[j0 = i0] = 0;\n				aa[j1 = i1 + 1] = 1;\n			} else if (query(i0, i1 + 1, i1 + 2) == 0) {\n				aa[j0 = i0] = 0;\n				aa[j1 = i1] = 1;\n			} else if (query(i0 + 1, i1, i1 + 1) == 0) {\n				aa[j0 = i0 + 1] = 0;\n				aa[j1 = i1 + 2] = 1;\n			} else if (query(i0 + 1, i1, i1 + 2) == 0) {\n				aa[j0 = i0 + 1] = 0;\n				aa[j1 = i1 + 1] = 1;\n			} else if (query(i0 + 1, i1 + 1, i1 + 2) == 0) {\n				aa[j0 = i0 + 1] = 0;\n				aa[j1 = i1] = 1;\n			} else {\n				aa[i1] = aa[i1 + 1] = aa[i1 + 2] = 1;\n				j1 = i1;\n				if (query(j1, i0, i0 + 1) == 1) {\n					aa[i0 + 2] = 0;\n					j0 = i0 + 2;\n				} else {\n					aa[i0] = aa[i0 + 1] = 0;\n					j0 = i0;\n				}\n			}\n			judge(j0, j1, i0);\n			judge(j0, j1, i0 + 1);\n			judge(j0, j1, i0 + 2);\n			judge(j0, j1, i1);\n			judge(j0, j1, i1 + 1);\n			judge(j0, j1, i1 + 2);\n			for (int h = 0; h < n / 3; h++) {\n				if (h == h0 || h == h1)\n					continue;\n				int i = h * 3;\n				if (bb[h] == 0) {\n					if (query(j1, i, i + 1) == 0) {\n						aa[i] = aa[i + 1] = 0;\n						judge(j0, j1, i + 2);\n					} else {\n						aa[i + 2] = 0;\n						judge(j0, j1, i);\n						aa[i + 1] = 1 - aa[i];\n					}\n				} else {\n					if (query(j0, i, i + 1) == 1) {\n						aa[i] = aa[i + 1] = 1;\n						judge(j0, j1, i + 2);\n					} else {\n						aa[i + 2] = 1;\n						judge(j0, j1, i);\n						aa[i + 1] = 1 - aa[i];\n					}\n				}\n			}\n			int k = 0;\n			for (int i = 0; i < n; i++)\n				if (aa[i] == 0)\n					k++;\n			print(""! "" + k);\n			for (int i = 0; i < n; i++)\n				if (aa[i] == 0)\n					print("" "" + (i + 1));\n			println();\n		}\n	}\n}\n","constructive algorithms,implementation,interactive,math"
"import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n	\n	static Scanner sc = new Scanner(System.in);\n	\n	public static void main(String[] args) {\n		\n		int T = sc.nextInt();\n		while( T > 0 ) {\n			solve();\n			T--;\n		}\n		\n	}\n	\n	static void solve() {\n		\n		int N = sc.nextInt();\n		int[] major_imp = new int[3];\n		int[] major_crew = new int[3];\n		int[] res = new int[N/3];\n		int fixed_imp = -1;\n		int fixed_crew = -1;\n		LinkedList<Integer> queue = new LinkedList<>();\n		for( int i = 0; i < N; i+=3 ) {\n			res[i/3] = query(i,i+1,i+2);\n			if( res[i/3] == 0 ) {\n				major_imp[0] = i;\n				major_imp[1] = i+1;\n				major_imp[2] = i+2;\n			}else {\n				major_crew[0] = i;\n				major_crew[1] = i+1;\n				major_crew[2] = i+2;\n			}\n		}\n		\n		for( int i = 0; i < 2; i++ ) {\n			if( query(major_crew[0],major_crew[1],major_imp[i]) == 0 ) {\n				fixed_imp = major_imp[i];\n				fixed_crew = major_crew[2];\n			}\n		}\n		\n		if( fixed_imp == -1 ) {\n			for( int i = 0; i < 2; i++ ) {\n				if( query(major_crew[0],major_crew[2],major_imp[i]) == 0 ) {\n					fixed_imp = major_imp[i];\n					fixed_crew = major_crew[1];\n				}\n			}\n			if( fixed_crew == -1 ) {\n				fixed_crew = major_crew[0];\n				if( query(major_imp[0],major_imp[1],fixed_crew) == 1 ) fixed_imp = major_imp[2];\n				else if( query(major_imp[0],major_imp[2],fixed_crew) == 1 ) fixed_imp = major_imp[1];\n				else fixed_imp = major_imp[0];\n			}\n		}\n		\n		for( int i = 0; i < N; i+=3 ) {\n			if( res[i/3] == 0 ) {\n				if( query(fixed_crew,i+1,i+2) == 1 ) {\n					queue.offer(i);\n					if( query(fixed_crew,i,i+2) == 1 ) queue.offer(i+1);\n					else queue.offer(i+2);\n				}else if( query(fixed_crew,i,i+2) == 1 ) {\n					queue.offer(i+1);\n					queue.offer(i+2);\n				}else {\n					queue.offer(i);\n					queue.offer(i+1);\n					queue.offer(i+2);\n				}\n			}else {\n				if( query(fixed_imp,i+1,i+2) == 0 ) {\n					if( query(fixed_imp,i,i+2) == 0 ) queue.offer(i+2);\n					else queue.offer(i+1);\n				}else if( query(fixed_imp,i,i+2) == 0 ) {\n					queue.offer(i);\n				}\n			}\n		}\n		\n		answer_query(queue);\n		\n	}\n	\nstatic void answer_query(LinkedList<Integer> queue) {\n		\n		System.out.print('!');\n		System.out.print(' ');\n		System.out.print(queue.size());\n		for( int ans : queue ) {\n			System.out.print(' ');\n			System.out.print(ans+1);\n		}\n		\n		System.out.println();\n		System.out.flush();\n		\n	}\n	\n	static int query(int a, int b, int c) {\n		\n		a++;\n		b++;\n		c++;\n		System.out.print('?');\n		System.out.print(' ');\n		System.out.print(a);\n		System.out.print(' ');\n		System.out.print(b);\n		System.out.print(' ');\n		System.out.println(c);\n		\n		System.out.flush();\n		\n		return sc.nextInt();\n		\n	}\n	\n}\n","constructive algorithms,implementation,interactive,math"
"import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class TooManyImpostors_Hard {\n	\n	static Scanner sc = new Scanner(System.in);\n	\n	public static void main(String[] args) {\n		\n		int T = sc.nextInt();\n		while( T > 0 ) {\n			solve();\n			T--;\n		}\n		\n	}\n	\n	static void solve() {\n		\n		int N = sc.nextInt();\n		int[] major_imp = new int[3];\n		int[] major_crew = new int[3];\n		int[] res = new int[N/3];\n		int fixed_imp = -1;\n		int fixed_crew = -1;\n		LinkedList<Integer> queue = new LinkedList<>();\n		for( int i = 0; i < N; i+=3 ) {\n			res[i/3] = query(i,i+1,i+2);\n			if( res[i/3] == 0 ) {\n				major_imp[0] = i;\n				major_imp[1] = i+1;\n				major_imp[2] = i+2;\n			}else {\n				major_crew[0] = i;\n				major_crew[1] = i+1;\n				major_crew[2] = i+2;\n			}\n		}\n		\n		for( int i = 0; i < 2; i++ ) {\n			if( query(major_crew[0],major_crew[1],major_imp[i]) == 0 ) {\n				fixed_imp = major_imp[i];\n				fixed_crew = major_crew[2];\n			}\n		}\n		\n		if( fixed_imp == -1 ) {\n			for( int i = 0; i < 2; i++ ) {\n				if( query(major_crew[0],major_crew[2],major_imp[i]) == 0 ) {\n					fixed_imp = major_imp[i];\n					fixed_crew = major_crew[1];\n				}\n			}\n			if( fixed_crew == -1 ) {\n				fixed_crew = major_crew[0];\n				if( query(major_imp[0],major_imp[1],fixed_crew) == 1 ) fixed_imp = major_imp[2];\n				else if( query(major_imp[0],major_imp[2],fixed_crew) == 1 ) fixed_imp = major_imp[1];\n				else fixed_imp = major_imp[0];\n			}\n		}\n		\n//		queue.offer(fixed_imp);\n		for( int i = 0; i < N; i+=3 ) {\n			if( res[i/3] == 0 ) {\n				if( query(fixed_crew,i+1,i+2) == 1 ) {\n					queue.offer(i);\n					if( query(fixed_crew,i,i+2) == 1 ) queue.offer(i+1);\n					else queue.offer(i+2);\n				}else if( query(fixed_crew,i,i+2) == 1 ) {\n					queue.offer(i+1);\n					queue.offer(i+2);\n				}else {\n					queue.offer(i);\n					queue.offer(i+1);\n					queue.offer(i+2);\n				}\n			}else {\n				if( query(fixed_imp,i+1,i+2) == 0 ) {\n					if( query(fixed_imp,i,i+2) == 0 ) queue.offer(i+2);\n					else queue.offer(i+1);\n				}else if( query(fixed_imp,i,i+2) == 0 ) {\n					queue.offer(i);\n				}\n			}\n//			System.out.println(queue);\n		}\n		\n		answer_query(queue);\n		\n	}\n	\n	static void answer_query(LinkedList<Integer> queue) {\n		\n		System.out.print('!');\n		System.out.print(' ');\n		System.out.print(queue.size());\n		for( int ans : queue ) {\n			System.out.print(' ');\n			System.out.print(ans+1);\n		}\n		\n		System.out.println();\n		System.out.flush();\n		\n	}\n	\n	static int query(int a, int b, int c) {\n		\n		if( b > c ) {\n			int temp = b;\n			b = c;\n			c = temp;\n		}\n		\n		if( a > b ) {\n			int temp = a;\n			a = b;\n			b = temp;\n		}\n		\n		if( b > c ) {\n			int temp = b;\n			b = c;\n			c = temp;\n		}\n		\n		a++;\n		b++;\n		c++;\n		System.out.print('?');\n		System.out.print(' ');\n		System.out.print(a);\n		System.out.print(' ');\n		System.out.print(b);\n		System.out.print(' ');\n		System.out.println(c);\n		\n		System.out.flush();\n		\n		return sc.nextInt();\n		\n	}\n	\n}\n","constructive algorithms,implementation,interactive,math"
"// Generated by Code Flattener.\n// https://plugins.jetbrains.com/plugin/9979-idea-code-flattener\n\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.IOException;\n\npublic class D {\n    public static void main(String[] args) throws IOException {\n        FastScanner scanner = new FastScanner();\n        int t = scanner.nextInt();\n        while (t-- > 0) {\n            int n = scanner.nextInt();\n            boolean[] a = new boolean[n / 3];\n            int indexTrue = -1, indexFalse = -1;\n            for (int i = 0; i < a.length; i++) {\n                int j = i * 3;\n                boolean ans = query(j, j + 1, j + 2, scanner);\n                if (ans && indexTrue == -1) {\n                    indexTrue = i;\n                } else if (!ans && indexFalse == -1) {\n                    indexFalse = i;\n                }\n                a[i] = ans;\n            }\n\n            boolean x, y;\n            indexTrue *= 3;\n            indexFalse *= 3;\n            x = query(indexTrue + 1, indexTrue + 2, indexFalse, scanner);\n            y = query(indexTrue + 2, indexFalse, indexFalse + 1, scanner);\n\n            if (x) {\n                if (y) {\n                    indexTrue += 2;\n                    indexFalse += 2;\n                } else {\n                    indexTrue += 1;\n                    indexFalse += 1;\n                }\n            }\n\n            boolean[] ones = new boolean[n];\n            int counter = n;\n            for (int i = 0; i < a.length; i++) {\n                int j = i * 3;\n                if (a[i]) {\n                    x = query(j, j + 1, indexFalse, scanner);\n                    y = query(j + 1, j + 2, indexFalse, scanner);\n                    if (x && y) {\n                        ones[j] = ones[j + 1] = ones[j + 2] = true;\n                        counter -= 3;\n                    } else if (x) {\n                        ones[j] = ones[j + 1] = true;\n                        counter -= 2;\n                    } else if (y) {\n                        ones[j + 1] = ones[j + 2] = true;\n                        counter -= 2;\n                    } else {\n                        ones[j] = ones[j + 2] = true;\n                        counter -= 2;\n                    }\n                } else {\n                    x = query(j, j + 1, indexTrue, scanner);\n                    y = query(j + 1, j + 2, indexTrue, scanner);\n                    if (x && y) {\n                        ones[j + 1] = true;\n                        counter--;\n                    } else if (x) {\n                        ones[j] = true;\n                        counter--;\n                    } else if (y) {\n                        ones[j + 2] = true;\n                        counter--;\n                    }\n                }\n            }\n\n            StringBuilder sb = new StringBuilder();\n            sb.append(""! "");\n            sb.append(counter);\n            for (int i = 0; i < n; i++)\n                if (!ones[i]) {\n                    sb.append(' ');\n                    sb.append(i + 1);\n                }\n            sb.append('\n');\n            System.out.println(sb);\n        }\n    }\n\n    private static boolean query(int a, int b, int c, FastScanner scanner) throws IOException {\n        System.out.println(""? "" + (a + 1) + "" "" + (b + 1) + "" "" + (c + 1));\n        System.out.flush();\n        return scanner.nextInt() == 1;\n    }\n\n    private static class FastScanner implements Closeable {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public FastScanner() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        @Override\n        public void close() throws IOException {\n            if (din == null) return;\n            din.close();\n        }\n    }\n}","constructive algorithms,implementation,interactive,math"
"import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Math.abs;\nimport static java.lang.Math.min;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class F {\n\n	static final int MOD = 1000000007;\n\n	static int add(int a, int b) {\n		int res = a + b;\n		return res >= MOD ? res - MOD : res;\n	}\n\n	static int mul(int a, int b) {\n		int res = (int) ((long) a * b % MOD);\n		return res < 0 ? res + MOD : res;\n	}\n\n	static void solve() throws Exception {\n		int tests = scanInt();\n		for (int test = 0; test < tests; test++) {\n			int n = scanInt();\n			String a = scanString(), b = scanString();\n			int mb = n / 2;\n			int dyncnt[] = new int[2 * mb + 1], dynans[] = new int[2 * mb + 1], ndyncnt[] = new int[2 * mb + 1], ndynans[] = new int[2 * mb + 1];\n			dyncnt[mb] = 1;\n			for (int i = 0; i < n; i++) {\n				int l = mb - min(i + 1, n - i - 1), r = mb + min(i + 1, n - i - 1);\n				char ca = a.charAt(i), cb = b.charAt(i);\n				if (ca == '?' && cb == '?') {\n					for (int j = l; j <= r; j++) {\n						int cnt = dyncnt[j], ans = dynans[j];\n						cnt = add(cnt, cnt);\n						ans = add(ans, ans);\n						if (j > mb - i) {\n							cnt = add(cnt, dyncnt[j - 1]);\n							ans = add(ans, dynans[j - 1]);\n						}\n						if (j < mb + i) {\n							cnt = add(cnt, dyncnt[j + 1]);\n							ans = add(ans, dynans[j + 1]);\n						}\n						ndyncnt[j] = cnt;\n						ndynans[j] = add(ans, mul(abs(j - mb), cnt));\n					}\n					int t[] = dyncnt;\n					dyncnt = ndyncnt;\n					ndyncnt = t;\n					t = dynans;\n					dynans = ndynans;\n					ndynans = t;\n				} else if (ca == '?' || cb == '?') {\n					if ((ca == '0' || cb == '1') ^ ((i & 1) != 0)) {\n						for (int j = l; j <= r; j++) {\n							int cnt = dyncnt[j], ans = dynans[j];\n							if (j < mb + i) {\n								cnt = add(cnt, dyncnt[j + 1]);\n								ans = add(ans, dynans[j + 1]);\n							}\n							ndyncnt[j] = cnt;\n							ndynans[j] = add(ans, mul(abs(j - mb), cnt));\n						}\n					} else {\n						for (int j = l; j <= r; j++) {\n							int cnt = dyncnt[j], ans = dynans[j];\n							if (j > mb - i) {\n								cnt = add(cnt, dyncnt[j - 1]);\n								ans = add(ans, dynans[j - 1]);\n							}\n							ndyncnt[j] = cnt;\n							ndynans[j] = add(ans, mul(abs(j - mb), cnt));\n						}\n					}\n					int t[] = dyncnt;\n					dyncnt = ndyncnt;\n					ndyncnt = t;\n					t = dynans;\n					dynans = ndynans;\n					ndynans = t;\n				} else if (ca != cb) {\n					if ((ca == '0') ^ ((i & 1) != 0)) {\n						for (int j = l; j <= r; j++) {\n							int cnt = 0, ans = 0;\n							if (j < mb + i) {\n								cnt = dyncnt[j + 1];\n								ans = dynans[j + 1];\n							}\n							ndyncnt[j] = cnt;\n							ndynans[j] = add(ans, mul(abs(j - mb), cnt));\n						}\n					} else {\n						for (int j = l; j <= r; j++) {\n							int cnt = 0, ans = 0;\n							if (j > mb - i) {\n								cnt = dyncnt[j - 1];\n								ans = dynans[j - 1];\n							}\n							ndyncnt[j] = cnt;\n							ndynans[j] = add(ans, mul(abs(j - mb), cnt));\n						}\n					}\n					int t[] = dyncnt;\n					dyncnt = ndyncnt;\n					ndyncnt = t;\n					t = dynans;\n					dynans = ndynans;\n					ndynans = t;\n				} else {\n					for (int j = l; j < n; j++) {\n						dynans[j] = add(dynans[j], mul(abs(j - mb), dyncnt[j]));\n					}\n				}\n			}\n			out.println(dynans[mb]);\n		}\n	}\n\n	static int scanInt() throws IOException {\n		return parseInt(scanString());\n	}\n\n	static long scanLong() throws IOException {\n		return parseLong(scanString());\n	}\n\n	static String scanString() throws IOException {\n		while (tok == null || !tok.hasMoreTokens()) {\n			tok = new StringTokenizer(in.readLine());\n		}\n		return tok.nextToken();\n	}\n\n	static BufferedReader in;\n	static PrintWriter out;\n	static StringTokenizer tok;\n\n	public static void main(String[] args) {\n		try {\n			in = new BufferedReader(new InputStreamReader(System.in));\n			out = new PrintWriter(System.out);\n			solve();\n			in.close();\n			out.close();\n		} catch (Throwable e) {\n			e.printStackTrace();\n			exit(1);\n		}\n	}\n}","combinatorics,dp,math"
"import java.util.*;\nimport java.io.*;\npublic class wublaba {\n	public static void main(String[] args) throws IOException {\nScanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		for(int xx=0;xx<t;xx++)\n		{\n			int x = sc.nextInt();\n			int y = sc.nextInt();\n			if((x+y)%2==0)\n				System.out.println(x/2+"" ""+(y%2==1?((y/2)+1):y/2));\n			else\n				System.out.println(-1+"" ""+(-1));\n		}\n		sc.close();\n	}\n}","brute force,constructive algorithms"
"import java.util.*;\nimport java.io.*;\n\npublic class wublaba {\n	public static void main(String[] args) throws IOException {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		for(int xx=0;xx<t;xx++)\n		{\n			int x = sc.nextInt();\n			int y = sc.nextInt();\n			if((x+y)%2==0)\n				System.out.println(x/2+"" ""+(y%2==1?((y/2)+1):y/2));\n			else\n				System.out.println(-1+"" ""+(-1));\n		}\n		sc.close();\n	}\n}","brute force,constructive algorithms"
"import java.util.*;\npublic class main {\n	public static void main(String[] args){\n		Scanner in = new Scanner(System.in);\n		int t = in.nextInt();\n		while(t-- > 0) {\n			int x,y;\n			x = in.nextInt();\n			y = in.nextInt();\n			if((x+y)%2!=0) {\n				System.out.println(""-1 -1"");\n				continue;\n			}else {\n				if(x%2==0) {\n					System.out.println(x/2+"" ""+y/2);\n				}else {\n					System.out.println(x/2+"" ""+(y/2+1));\n				}\n			}\n		}\n	}\n}\n","brute force,constructive algorithms"
"import java.util.Scanner;\n\npublic class ECR117A {\n\n	public static void main(String[] args) {\n\n		Scanner sc = new Scanner(System.in);\n		\n		int t = sc.nextInt();\n		\n		while (t-- > 0) {\n			int x = sc.nextInt(), y = sc.nextInt();\n			\n			if ((x + y) % 2 != 0) System.out.println(""-1 -1"");\n			else {\n				if (x % 2 == 0) System.out.println(x/2 + "" "" + y/2);\n				else System.out.println(x/2 + "" "" + (y+1)/2);\n			}\n		}\n		sc.close();\n	}\n}\n","brute force,constructive algorithms"
import java.util.*;\nimport java.io.*;\n\n\npublic class MakeEven {\n\n	private static int ans(int n) {\n		if(n % 2 == 0) return 0;\n		int ans = -1;\n		while(n > 0) {\n			if(n % 2 == 0) ans = 2;\n			if(n / 10 == 0 && n % 2 == 0) {\n				return 1;\n			} \n			n /= 10;\n		}\n		return ans;\n	}\n\n	public static void main(String[] args) {\n		Scanner scn = new Scanner(System.in);\n		int t = scn.nextInt();\n		while(t-- > 0) {\n			int n = scn.nextInt();\n			System.out.println(ans(n));\n		}\n		return;\n	}\n},"constructive algorithms,math"
import java.util.*;\nimport java.io.*;\n\n\npublic class MakeEven {\n\n	private static int ans(int n) {\n		if(n % 2 == 0) return 0;\n		int ans = -1;\n		while(n > 0) {\n			if(n % 2 == 0) ans = 2;\n			if(n / 10 == 0 && n % 2 == 0) {\n				return 1;\n			} \n			n /= 10;\n		}\n		return ans;\n	}\n\n	public static void main(String[] args) {\n		Scanner scn = new Scanner(System.in);\n		int t = scn.nextInt();\n		while(t-- > 0) {\n			int n = scn.nextInt();\n			System.out.println(ans(n));\n		}\n		return;\n	}\n},"constructive algorithms,math"
import java.util.*;\npublic class S{\n    public static void main(String [] args){\n	Scanner sc = new Scanner(System.in);\n	int t = sc.nextInt();\n	while(t--!=0){\n		int n = sc.nextInt();\n		System.out.println(solve(n));\n	}\n    }\n    public static int solve(int n){\n	if(n%2 == 0)return 0;\n	int i = 0;\n	String s = Integer.toString(n);\n	for(i=0;i<s.length();i++){\n		int num = Character.getNumericValue(s.charAt(i));\n		if(num%2 == 0)break;\n	}\n	if(i==0)return 1;\n	if(s.length() == i)return -1;\n	return 2;\n    }\n},"constructive algorithms,math"
import java.util.Scanner;\n\npublic class MainT {\n	public static Scanner read = new Scanner(System.in);\n	public static void main(String[] args) {\n		int t = read.nextInt();\n		while (t-->0) {\n			solve();\n		}\n	}\n\n	private static void solve() {\n		int n = read.nextInt();\n		int v =-1;\n		boolean f = true;\n		while (n>0) {\n		if (n%2==0)\n		{\n			if (f) {\n				System.out.println(0);\n				return;\n			}\n\n			if (n/10==0)\n				v=1;\n			else\n				v =2;\n		}\n			f = false;\n		n/=10;\n		}\n		System.out.println(v);\n	}\n}\n,"constructive algorithms,math"
"import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class F_fenwick {\n\n	void submit() {\n		int n = nextInt();\n//		int n = 1_000_000;\n		long[] a = new long[n];\n		int[] b = new int[n];\n		boolean[] check = new boolean[62];\n		for (int i = 0; i < n; i++) {\n			a[i] = nextLong();\n//			a[i] = i & 15;\n//			a[i] = i ^ (i >> 1);\n			b[i] = Long.bitCount(a[i]);\n			check[b[i]] = true;\n		}\n\n		int[] a0 = new int[n];\n		int[] a1 = new int[n];\n		int[] b0 = new int[n];\n		int[] b1 = new int[n];\n\n		int[] min = new int[n + 1];\n		int[] max = new int[n + 1];\n		min[0] = max[0] = -1;\n\n		long ret = 0;\n		int szMin = 1, szMax = 1;\n\n		int CUR_VAL = 0;\n\n		for (int bit = 0; bit < 62; bit++) {\n			if (!check[bit]) {\n				continue;\n			}\n			for (int j = 0; j < n; j++) {\n				long x = a[j];\n\n				// min\n				while (szMin > 1 && a[min[szMin - 1]] >= x) {\n					if (b[min[szMin - 1]] == bit) {\n						int low = min[szMin - 2];\n						int high = min[szMin - 1];\n						for (int i = high; i >= 0; i = (i & (i + 1)) - 1) {\n							CUR_VAL -= b1[i] * high + b0[i];\n						}\n						for (int i = low; i >= 0; i = (i & (i + 1)) - 1) {\n							CUR_VAL += b1[i] * low + b0[i];\n						}\n\n						for (int i = low + 1; i < n; i |= i + 1) {\n							a0[i] += low;\n							a1[i]--;\n						}\n						for (int i = high; i < n; i |= i + 1) {\n							a0[i] -= high;\n							a1[i]++;\n						}\n\n//						st.modifySegm(min[szMin - 2] + 1, min[szMin - 1] + 1, -1);\n					}\n					--szMin;\n				}\n				if (b[j] == bit) {\n					int low = min[szMin - 1];\n					int high = j;\n					for (int i = high; i >= 0; i = (i & (i + 1)) - 1) {\n						CUR_VAL += b1[i] * high + b0[i];\n					}\n					for (int i = low; i >= 0; i = (i & (i + 1)) - 1) {\n						CUR_VAL -= b1[i] * low + b0[i];\n					}\n\n					for (int i = low + 1; i < n; i |= i + 1) {\n						a0[i] -= low;\n						a1[i]++;\n					}\n					for (int i = high; i < n; i |= i + 1) {\n						a0[i] += high;\n						a1[i]--;\n					}\n\n//					st.modifySegm(min[szMin - 1] + 1, j + 1, 1);\n				}\n				min[szMin++] = j;\n\n				// max\n				while (szMax > 1 && a[max[szMax - 1]] <= x) {\n					if (b[max[szMax - 1]] == bit) {\n						int low = max[szMax - 2];\n						int high = max[szMax - 1];\n						for (int i = high; i >= 0; i = (i & (i + 1)) - 1) {\n							CUR_VAL -= a1[i] * high + a0[i];\n						}\n						for (int i = low; i >= 0; i = (i & (i + 1)) - 1) {\n							CUR_VAL += a1[i] * low + a0[i];\n						}\n\n						for (int i = low + 1; i < n; i |= i + 1) {\n							b0[i] += low;\n							b1[i]--;\n						}\n						for (int i = high; i < n; i |= i + 1) {\n							b0[i] -= high;\n							b1[i]++;\n						}\n\n//						st.modifySegm(max[szMax - 2] + 1, max[szMax - 1] + 1, -1);\n					}\n					--szMax;\n				}\n				if (b[j] == bit) {\n					int low = max[szMax - 1];\n					int high = j;\n					for (int i = high; i >= 0; i = (i & (i + 1)) - 1) {\n						CUR_VAL += a1[i] * high + a0[i];\n					}\n					for (int i = low; i >= 0; i = (i & (i + 1)) - 1) {\n						CUR_VAL -= a1[i] * low + a0[i];\n					}\n\n					for (int i = low + 1; i < n; i |= i + 1) {\n						b0[i] -= low;\n						b1[i]++;\n					}\n					for (int i = high; i < n; i |= i + 1) {\n						b0[i] += high;\n						b1[i]--;\n					}\n\n//					st.modifySegm(max[szMax - 1] + 1, j + 1, 1);\n				}\n				max[szMax++] = j;\n				\n				ret += CUR_VAL;\n			}\n\n			szMin = szMax = 1;\n			Arrays.fill(a0, 0);\n			Arrays.fill(a1, 0);\n			Arrays.fill(b0, 0);\n			Arrays.fill(b1, 0);\n\n			CUR_VAL = 0;\n		}\n		out.println(ret);\n	}\n\n	void test() {\n\n	}\n\n	void stress() {\n		for (int tst = 0;; tst++) {\n			if (false) {\n				throw new AssertionError();\n			}\n			System.err.println(tst);\n		}\n	}\n\n	F_fenwick() throws IOException {\n		is = System.in;\n		out = new PrintWriter(System.out);\n		submit();\n		// stress();\n//		 test();\n		out.close();\n	}\n\n	static final Random rng = new Random();\n	static final int C = 5;\n\n	static int rand(int l, int r) {\n		return l + rng.nextInt(r - l + 1);\n	}\n\n	public static void main(String[] args) throws IOException {\n		new F_fenwick();\n	}\n\n	private InputStream is;\n	PrintWriter out;\n\n	private byte[] buf = new byte[1 << 14];\n	private int bufSz = 0, bufPtr = 0;\n\n	private int readByte() {\n		if (bufSz == -1)\n			throw new RuntimeException(""Reading past EOF"");\n		if (bufPtr >= bufSz) {\n			bufPtr = 0;\n			try {\n				bufSz = is.read(buf);\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n			if (bufSz <= 0)\n				return -1;\n		}\n		return buf[bufPtr++];\n	}\n\n	private boolean isTrash(int c) {\n		return c < 33 || c > 126;\n	}\n\n	private int skip() {\n		int b;\n		while ((b = readByte()) != -1 && isTrash(b))\n			;\n		return b;\n	}\n\n	String nextToken() {\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b)) {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	String nextString() {\n		int b = readByte();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b) || b == ' ') {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	double nextDouble() {\n		return Double.parseDouble(nextToken());\n	}\n\n	char nextChar() {\n		return (char) skip();\n	}\n\n	int nextInt() {\n		int ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n\n	long nextLong() {\n		long ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n}","data structures,divide and conquer,meet-in-the-middle,two pointers"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1609D extends PrintWriter {\n	CF1609D() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1609D o = new CF1609D(); o.main(); o.flush();\n	}\n\n	int[] ds;\n	int find(int i) {\n		return ds[i] < 0 ? i : (ds[i] = find(ds[i]));\n	}\n	boolean join(int i, int j) {\n		i = find(i);\n		j = find(j);\n		if (i == j)\n			return false;\n		if (ds[i] > ds[j]) {\n			int tmp = i; i = j; j = tmp;\n		}\n		ds[i] += ds[j];\n		ds[j] = i;\n		return true;\n	}\n	void main() {\n		int n = sc.nextInt();\n		int d = sc.nextInt();\n		int[] xx = new int[d];\n		int[] yy = new int[d];\n		for (int h = 0; h < d; h++) {\n			xx[h] = sc.nextInt() - 1;\n			yy[h] = sc.nextInt() - 1;\n		}\n		ds = new int[n];\n		int[] kk = new int[n];\n		for (int d_ = 1; d_ <= d; d_++) {\n			int k = 0;\n			Arrays.fill(ds, -1);\n			for (int h = 0; h < d_; h++)\n				if (!join(xx[h], yy[h]))\n					k++;\n			int[] qu = new int[n]; int cnt = 0;\n			for (int i = 0; i < n; i++)\n				if (ds[i] < 0)\n					qu[cnt++] = -ds[i];\n			Arrays.sort(qu, 0, cnt);\n			int s = 0;\n			while (k >= 0) {\n				s += qu[--cnt];\n				k--;\n			}\n			println(s - 1);\n		}\n	}\n}\n","dsu,graphs,greedy,implementation,trees"
"import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class D1609 {\n    public static void main(String[] args) {\n        Scanner stdin = new Scanner(System.in);\n\n        int n=stdin.nextInt(),d=stdin.nextInt();\n\n        int[] components = new int[n]; // Component ID of person i.\n        for (int i=0;i<n;i++) components[i] = i;\n        int num_components=1;\n        while (d --> 0) {\n            int xi=stdin.nextInt()-1,yi=stdin.nextInt()-1;\n            int xi_component = components[xi];\n            int yi_component = components[yi];\n            if (xi_component==yi_component) {\n                num_components++;\n            }\n            for (int i=0;i<n;i++) {\n                if (components[i] == yi_component) components[i] = xi_component;\n            }\n            int[] components_cnt = new int[n];\n            for (int i=0;i<n;i++) components_cnt[components[i]]++;\n            int sum=0;\n            Arrays.sort(components_cnt);\n            //System.out.println(""====="");\n            //for (int cnt:components_cnt) System.out.print(cnt + "" "");\n            //System.out.println(""\n====="");\n            for (int i=n-num_components;i<n;i++) sum += components_cnt[i];\n            System.out.println(sum-1);\n        }\n    }\n}\n","dsu,graphs,greedy,implementation,trees"
"import java.util.*;\n\npublic class Main{\n\n    static int [] arr;\n    static int tmp;\n    public static int find(int x){\n        if(arr[x]<0){\n            return x;\n        }else return find(arr[x]);\n    }\n\n    public static void union(int x, int y){\n\n        int rootX = find(x);\n        int rootY = find(y);\n        if(rootX!=rootY){\n            arr[rootX] += arr[rootY];\n            arr[rootY] = rootX;\n        }else{\n            tmp++;\n        }\n    }\n\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int d = sc.nextInt();\n\n        arr = new int [n+1];\n        Arrays.fill(arr, -1);\n\n\n        for (int i = 0; i < d; i++) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n\n            union(x, y);\n\n            int max = -1;\n            for (int j =1; j < n+1; j++) {\n                arr[j]*=-1;\n            }\n\n            int [] temp = arr.clone();\n            Arrays.sort(temp);\n\n            int ans = 0;\n            for (int j = n; j >= n-tmp; j--) {\n                ans += temp[j];\n            }\n\n            for (int j = 0; j < n+1; j++) {\n                arr[j]*=-1;\n            }\n\n            System.out.println(ans-1);\n\n        }\n\n    }\n\n\n\n}\n","dsu,graphs,greedy,implementation,trees"
"import java.util.*;\n\npublic class Main{\n\n    static int [] arr;\n    static int tmp;\n    public static int find(int x){\n        if(arr[x]<0){\n            return x;\n        }else return find(arr[x]);\n    }\n\n    public static void union(int x, int y){\n\n        int rootX = find(x);\n        int rootY = find(y);\n        if(rootX!=rootY){\n            arr[rootX] += arr[rootY];\n            arr[rootY] = rootX;\n        }else{\n            tmp++;\n        }\n    }\n\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int d = sc.nextInt();\n\n        arr = new int [n+1];\n        Arrays.fill(arr, -1);\n\n\n        for (int i = 0; i < d; i++) {\n            int x = sc.nextInt();\n            int y = sc.nextInt();\n\n            union(x, y);\n\n            int max = -1;\n            for (int j =1; j < n+1; j++) {\n                arr[j]*=-1;\n            }\n\n            int [] temp = arr.clone();\n            Arrays.sort(temp);\n\n            int ans = 0;\n            for (int j = n; j >= n-tmp; j--) {\n                ans += temp[j];\n            }\n\n            for (int j = 0; j < n+1; j++) {\n                arr[j]*=-1;\n            }\n\n            System.out.println(ans-1);\n\n        }\n\n    }\n\n\n\n}\n","dsu,graphs,greedy,implementation,trees"
"import java.util.*;\npublic class solve {\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while(t-->0) {\n			int n = sc.nextInt();\n			for (int i = 1; i <= n; i++) {\n				System.out.print(2*i +1 + "" "");\n			}\n			System.out.println();\n		}\n	}\n\n}\n","constructive algorithms,math"
"import java.util.*;\npublic class    Main {\n \n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while(t-->0) {\n			int n = sc.nextInt();\n			for (int i = 1; i <= n; i++) {\n				System.out.print(2*i +1 + "" "");\n			}\n			System.out.println();\n		}\n	}\n \n}","constructive algorithms,math"
"import java.util.*;\nimport java.io.*;\n\npublic class Yoo\n{\n	public static void main(String args[])\n	{\n	   Scanner sc=new Scanner(System.in);\n	   int t=sc.nextInt();\n	  \n	   \n	   while(t-->0) {\n		   int n=sc.nextInt();\n		   \n		   for(int i=2;n-->0;i++) System.out.print(i+"" "");\n		   System.out.println();\n		   \n	  }\n	   \n}\n	}","constructive algorithms,math"
"import java.util.*;\npublic class Main {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner sc = new Scanner(System.in);\n		int tc = sc.nextInt();\n		while(tc-->0) {\n			int n = sc.nextInt();\n			for(int i =0; i<n; i++) {\n				System.out.print(i+2 + "" "");\n			}\n			System.out.println();\n		}\n	}\n\n}","constructive algorithms,math"
"import java.util.*;\nimport java.io.*;\n \npublic class cf {\n	\n	static long modulo(long a, long b, long c) {\n	    long x=1;\n	    long y=a;\n	    while(b > 0){\n	        if(b%2 == 1){\n	            x=(x*y)%c;\n	        }\n	        y = (y*y)%c; // squaring the base\n	        b /= 2;\n	    }\n	    return x%c;\n	}\n \n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		int t = Integer.parseInt(br.readLine());\n		long m = 998244353;\n		while (t-- > 0) {\n			String[] ss = br.readLine().split("" "");\n            long n = Long.parseLong(ss[0]), k = Long.parseLong(ss[1]), x = Long.parseLong(ss[2]);\n            if (x == 0) {\n            	if (n > k) {\n            		System.out.println(0);\n            	} else {\n            		long power = modulo(2, k, m);\n            		long prod = 1;\n            		long exp = 1;\n            		for (int i = 0; i < n; i++) {\n            			prod = prod * (power - exp) % m;\n            			exp = 2 * exp % m;\n            		}\n            		if (prod < 0) {\n            			prod += m;\n            		}\n            		System.out.println(prod);\n            	}\n            } else {\n            	long coeff = 1;\n            	long sum = 0;\n            	long term = modulo(2, (k - 1) * (n + 1), m);\n            	long pow = modulo(2, k - 1, m);\n            	long inv = modulo(499122177, n + 1, m);\n            	for (int i = 0; i < k; i++) {\n            		sum = (sum + term * coeff) % m;\n            		term = term * inv % m;\n            		coeff = coeff * (1 - pow) % m;\n            		pow = pow * 499122177 % m;\n            	}\n            	if (sum < 0) {\n            		sum += m;\n            	}\n            	System.out.println(sum);\n            }\n		}\n	}\n}","combinatorics,dp,implementation,math"
"import java.util.*;\nimport java.io.*;\n\npublic class cf {\n	\n	static long modulo(long a, long b, long c) {\n	    long x=1;\n	    long y=a;\n	    while(b > 0){\n	        if(b%2 == 1){\n	            x=(x*y)%c;\n	        }\n	        y = (y*y)%c; // squaring the base\n	        b /= 2;\n	    }\n	    return x%c;\n	}\n\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		int t = Integer.parseInt(br.readLine());\n		long m = 998244353;\n		while (t-- > 0) {\n			String[] ss = br.readLine().split("" "");\n            long n = Long.parseLong(ss[0]), k = Long.parseLong(ss[1]), x = Long.parseLong(ss[2]);\n            if (x == 0) {\n            	if (n > k) {\n            		System.out.println(0);\n            	} else {\n            		long power = modulo(2, k, m);\n            		long prod = 1;\n            		long exp = 1;\n            		for (int i = 0; i < n; i++) {\n            			prod = prod * (power - exp) % m;\n            			exp = 2 * exp % m;\n            		}\n            		if (prod < 0) {\n            			prod += m;\n            		}\n            		System.out.println(prod);\n            	}\n            } else {\n            	long coeff = 1;\n            	long sum = 0;\n            	long term = modulo(2, (k - 1) * (n + 1), m);\n            	long pow = modulo(2, k - 1, m);\n            	long inv = modulo(499122177, n + 1, m);\n            	for (int i = 0; i < k; i++) {\n            		sum = (sum + term * coeff) % m;\n            		term = term * inv % m;\n            		coeff = coeff * (1 - pow) % m;\n            		pow = pow * 499122177 % m;\n            	}\n            	if (sum < 0) {\n            		sum += m;\n            	}\n            	System.out.println(sum);\n            }\n		}\n	}\n}","combinatorics,dp,implementation,math"
"import java.io.*;\nimport java.util.*;\n\npublic class Main{ \n	static class Point{\n		int x,y;\n		Point(int nx, int ny){\n			x = nx; y = ny;\n		}\n		public int hashCode() {\n			return (x << 10) ^ y;\n		}\n		public boolean equals(Object o) {\n			Point p = (Point)o;\n			return p.x == x && p.y == y;\n		}\n	}\n	public static void main(String[] args) throws IOException{\n        long start = System.currentTimeMillis();\n		In in = new In();\n		in.tokenize();\n		int n = in.pint(), m = in.pint();\n		HashSet<Point> set = new HashSet<Point>();\n		for(int i = 0; i < m; i++) {\n			in.tokenize();\n            int x = in.pint(), y = in.pint();\n            set.add(new Point(x,y));\n            set.add(new Point(y,x));\n		}\n        int[] v = new int[n + 1];\n        int t = 0;\n        while(t < 500000) {\n        	t++;\n            int[] test = new int[5];\n            for(int k = 0; k < 5; k++){\n                test[k] = (int)(Math.random() * n) + 1;\n                while(v[test[k]] == t){\n                    test[k] = (int)(Math.random() * n) + 1;\n                }\n                v[test[k]] = t;\n            }\n            boolean all = true, none = true;\n            for(int i = 0; i < 4 && (all || none); i++){\n                for(int j = i + 1; j < 5 && (all || none); j++){\n                	boolean ok = set.contains(new Point(test[i], test[j]));\n                	all &= ok;\n                	none &= !ok;\n                }   \n            }\n            if(all || none){\n                for(int i : test){\n                    System.out.print(i + "" "");\n                }\n                System.out.println();\n                return;\n            }\n        }\n        System.out.println(-1);\n	}	\n}   \n\n\nclass In{\n    private BufferedReader in;\n    private StringTokenizer st = new StringTokenizer("""");\n    public In(){\n        in = new BufferedReader(new InputStreamReader(System.in));\n    }\n    \n    int pint() throws IOException{\n        if(st.hasMoreTokens()) {return Integer.parseInt(st.nextToken());}\n        else {return Integer.parseInt(in.readLine());}\n    } \n    double pdbl() throws IOException{\n        if(st.hasMoreTokens()) {return Double.parseDouble(st.nextToken());}\n        else {return Double.parseDouble(in.readLine());}\n    }\n    long plng() throws IOException{\n        if(st.hasMoreTokens()) {return Long.parseLong(st.nextToken());}\n        else {return Long.parseLong(in.readLine());}\n    }\n    char pchr() throws IOException{\n        if(st.hasMoreTokens()) {return st.nextToken().charAt(0);}\n        else {return in.readLine().charAt(0);}\n    }\n    String pstr() throws IOException{\n        if(st.hasMoreTokens()) {return st.nextToken();}\n        else {return in.readLine();} \n    }\n    String readLine() throws IOException{\n        return in.readLine();\n    }\n    boolean ready() throws IOException {return in.ready();}\n    boolean readyN() throws IOException{return in.ready() || st.hasMoreTokens();}\n    boolean hasTokens() {return st.hasMoreTokens();}\n    void tokenize() throws IOException{st = new StringTokenizer(in.readLine());}\n    void skip() throws IOException{in.readLine();}\n}","brute force,math,probabilities"
"import java.util.*;\nimport java.io.*;\n\npublic class F {\n\n	static FastScanner fs = new FastScanner();\n	static PrintWriter pw = new PrintWriter(System.out);\n	static StringBuilder sb = new StringBuilder("""");\n\n    public static void main(String[] args) {\n        int t = fs.nextInt();\n        for (int tt = 0; tt < t; tt++) {\n            long s = fs.nextLong(), n = fs.nextLong(), k = fs.nextLong();\n            if (k > s) {\n                sb.append(""NO\n"");\n            } else if (k == s) {\n                sb.append(""YES\n"");\n            } else {\n                long q = s / (k*2);\n                long r = s % (k*2);\n                long mn = q * k + Math.min(r+1, k);\n                if (mn < n+1) {\n                    sb.append(""YES\n"");\n                } else {\n                    sb.append(""NO\n"");\n                }\n            }\n        }\n        pw.print(sb.toString());\n        pw.close();\n    }\n	\n	static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer("""");\n        String next() {while (!st.hasMoreTokens()) try {st = new StringTokenizer(br.readLine());} catch (IOException e) {}return st.nextToken();}\n        int nextInt() {return Integer.parseInt(next());}\n        long nextLong() {return Long.parseLong(next());}\n        double nextDouble() {return Double.parseDouble(next());}\n    }\n}","constructive algorithms,math"
"import java.io.DataInputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\n\npublic class Main {\n\n    private static void run() throws IOException {\n        long s, n, k;\n        s = in.nextLong();\n        n = in.nextLong();\n        k = in.nextLong();\n\n        if (k > s) {\n            out.println(""NO"");\n        } else if (k == s) {\n            out.println(""YES"");\n        } else {\n            out.println(n / k * k > s - n ? ""YES"" : ""NO"");\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new Reader();\n        out = new PrintWriter(new OutputStreamWriter(System.out));\n\n        int t = in.nextInt();\n        for (int i = 0; i < t; i++) {\n            run();\n        }\n\n        out.flush();\n        in.close();\n        out.close();\n    }\n\n    private static int gcd(int a, int b) {\n        if (a == 0 || b == 0)\n            return 0;\n        while (b != 0) {\n            int tmp;\n            tmp = a % b;\n            a = b;\n            b = tmp;\n        }\n        return a;\n    }\n\n    static final long mod = 1000000007;\n\n    static long pow_mod(long a, long b) {\n        long result = 1;\n        while (b != 0) {\n            if ((b & 1) != 0) result = (result * a) % mod;\n            a = (a * a) % mod;\n            b >>= 1;\n        }\n        return result;\n    }\n\n    private static long multiplied_mod(long... longs) {\n        long ans = 1;\n        for (long now : longs) {\n            ans = (ans * now) % mod;\n        }\n        return ans;\n    }\n\n    @SuppressWarnings(""FieldCanBeLocal"")\n    private static Reader in;\n    private static PrintWriter out;\n\n    private static int[] read_int_array(int len) throws IOException {\n        int[] a = new int[len];\n        for (int i = 0; i < len; i++) {\n            a[i] = in.nextInt();\n        }\n        return a;\n    }\n\n    private static long[] read_long_array(int len) throws IOException {\n        long[] a = new long[len];\n        for (int i = 0; i < len; i++) {\n            a[i] = in.nextLong();\n        }\n        return a;\n    }\n\n    private static void print_array(int[] array) {\n        for (int now : array) {\n            out.print(now);\n            out.print(' ');\n        }\n        out.println();\n    }\n\n    private static void print_array(long[] array) {\n        for (long now : array) {\n            out.print(now);\n            out.print(' ');\n        }\n        out.println();\n    }\n\n    static class Reader {\n        private static final int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream din;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        Reader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException {\n            final byte[] buf = new byte[1024]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\n') {\n                    break;\n                }\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextSign() throws IOException {\n            byte c = read();\n            while ('+' != c && '-' != c) {\n                c = read();\n            }\n            return '+' == c ? 0 : 1;\n        }\n\n        private static boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n\n        public int skip() throws IOException {\n            int b;\n            // noinspection ALL\n            while ((b = read()) != -1 && isSpaceChar(b)) {\n                ;\n            }\n            return b;\n        }\n\n        public char nc() throws IOException {\n            return (char) skip();\n        }\n\n        public String next() throws IOException {\n            int b = skip();\n            final StringBuilder sb = new StringBuilder();\n            while (!isSpaceChar(b)) { // when nextLine, (isSpaceChar(b) && b != ' ')\n                sb.appendCodePoint(b);\n                b = read();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            final boolean neg = c == '-';\n            if (neg) {\n                c = read();\n            }\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg) {\n                return -ret;\n            }\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            final boolean neg = c == '-';\n            if (neg) {\n                c = read();\n            }\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg) {\n                return -ret;\n            }\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            final boolean neg = c == '-';\n            if (neg) {\n                c = read();\n            }\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg) {\n                return -ret;\n            }\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) {\n                buffer[0] = -1;\n            }\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) {\n                fillBuffer();\n            }\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            din.close();\n        }\n\n    }\n}","constructive algorithms,math"
"import java.io.DataInputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\n\npublic class Main {\n\n    private static void run() throws IOException {\n        long s, n, k;\n        s = in.nextLong();\n        n = in.nextLong();\n        k = in.nextLong();\n\n        if (k > s) {\n            out.println(""NO"");\n        } else if (k == s) {\n            out.println(""YES"");\n        } else {\n            out.println(n / k * k > s - n ? ""YES"" : ""NO"");\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new Reader();\n        out = new PrintWriter(new OutputStreamWriter(System.out));\n\n        int t = in.nextInt();\n        for (int i = 0; i < t; i++) {\n            run();\n        }\n\n        out.flush();\n        in.close();\n        out.close();\n    }\n\n    private static int gcd(int a, int b) {\n        if (a == 0 || b == 0)\n            return 0;\n        while (b != 0) {\n            int tmp;\n            tmp = a % b;\n            a = b;\n            b = tmp;\n        }\n        return a;\n    }\n\n    static final long mod = 1000000007;\n\n    static long pow_mod(long a, long b) {\n        long result = 1;\n        while (b != 0) {\n            if ((b & 1) != 0) result = (result * a) % mod;\n            a = (a * a) % mod;\n            b >>= 1;\n        }\n        return result;\n    }\n\n    private static long multiplied_mod(long... longs) {\n        long ans = 1;\n        for (long now : longs) {\n            ans = (ans * now) % mod;\n        }\n        return ans;\n    }\n\n    @SuppressWarnings(""FieldCanBeLocal"")\n    private static Reader in;\n    private static PrintWriter out;\n\n    private static int[] read_int_array(int len) throws IOException {\n        int[] a = new int[len];\n        for (int i = 0; i < len; i++) {\n            a[i] = in.nextInt();\n        }\n        return a;\n    }\n\n    private static long[] read_long_array(int len) throws IOException {\n        long[] a = new long[len];\n        for (int i = 0; i < len; i++) {\n            a[i] = in.nextLong();\n        }\n        return a;\n    }\n\n    private static void print_array(int[] array) {\n        for (int now : array) {\n            out.print(now);\n            out.print(' ');\n        }\n        out.println();\n    }\n\n    private static void print_array(long[] array) {\n        for (long now : array) {\n            out.print(now);\n            out.print(' ');\n        }\n        out.println();\n    }\n\n    static class Reader {\n        private static final int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream din;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        Reader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException {\n            final byte[] buf = new byte[1024]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\n') {\n                    break;\n                }\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextSign() throws IOException {\n            byte c = read();\n            while ('+' != c && '-' != c) {\n                c = read();\n            }\n            return '+' == c ? 0 : 1;\n        }\n\n        private static boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n\n        public int skip() throws IOException {\n            int b;\n            // noinspection ALL\n            while ((b = read()) != -1 && isSpaceChar(b)) {\n                ;\n            }\n            return b;\n        }\n\n        public char nc() throws IOException {\n            return (char) skip();\n        }\n\n        public String next() throws IOException {\n            int b = skip();\n            final StringBuilder sb = new StringBuilder();\n            while (!isSpaceChar(b)) { // when nextLine, (isSpaceChar(b) && b != ' ')\n                sb.appendCodePoint(b);\n                b = read();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            final boolean neg = c == '-';\n            if (neg) {\n                c = read();\n            }\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg) {\n                return -ret;\n            }\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            final boolean neg = c == '-';\n            if (neg) {\n                c = read();\n            }\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg) {\n                return -ret;\n            }\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            final boolean neg = c == '-';\n            if (neg) {\n                c = read();\n            }\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg) {\n                return -ret;\n            }\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) {\n                buffer[0] = -1;\n            }\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) {\n                fillBuffer();\n            }\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            din.close();\n        }\n\n    }\n}","constructive algorithms,math"
"import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1594f {\n\n    public static void main(String[] args) throws IOException {\n        int t = ri();\n        next: while (t --> 0) {\n            long s = rnl(), n = nl(), k = nl();\n            prYN(s == k || !(s < k || n < k || s >= n / k * k * 2 + n % k));\n        }\n        close();\n    }\n\n    static BufferedReader __i = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __o = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __r = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final long LMAX = 9223372036854775807L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);}\n    static long gcd(long a, long b) {return b == 0 ? a : gcd(b, a % b);}\n    static int[] exgcd(int a, int b) {if (b == 0) return new int[] {1, 0}; int[] y = exgcd(b, a % b); return new int[] {y[1], y[0] - y[1] * (a / b)};}\n    static long[] exgcd(long a, long b) {if (b == 0) return new long[] {1, 0}; long[] y = exgcd(b, a % b); return new long[] {y[1], y[0] - y[1] * (a / b)};}\n    static int randInt(int min, int max) {return __r.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static void ria(int[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = ni();}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static void riam1(int[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static void rla(long[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = nl();}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static void rda(double[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = nd();}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static void rcha(char[] a) throws IOException {int n = a.length, i = 0; for (char c : rline().toCharArray()) a[i++] = c;}\n    static String rline() throws IOException {return __i.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__o.print(i);}\n    static void prln(int i) {__o.println(i);}\n    static void pr(long l) {__o.print(l);}\n    static void prln(long l) {__o.println(l);}\n    static void pr(double d) {__o.print(d);}\n    static void prln(double d) {__o.println(d);}\n    static void pr(char c) {__o.print(c);}\n    static void prln(char c) {__o.println(c);}\n    static void pr(char[] s) {__o.print(new String(s));}\n    static void prln(char[] s) {__o.println(new String(s));}\n    static void pr(String s) {__o.print(s);}\n    static void prln(String s) {__o.println(s);}\n    static void pr(Object o) {__o.print(o);}\n    static void prln(Object o) {__o.println(o);}\n    static void prln() {__o.println();}\n    static void pryes() {prln(""yes"");}\n    static void pry() {prln(""Yes"");}\n    static void prY() {prln(""YES"");}\n    static void prno() {prln(""no"");}\n    static void prn() {prln(""No"");}\n    static void prN() {prln(""NO"");}\n    static boolean pryesno(boolean b) {prln(b ? ""yes"" : ""no""); return b;};\n    static boolean pryn(boolean b) {prln(b ? ""Yes"" : ""No""); return b;}\n    static boolean prYN(boolean b) {prln(b ? ""YES"" : ""NO""); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(""hlfd""); flush();}\n    static void flush() {__o.flush();}\n    static void close() {__o.close();}\n}","constructive algorithms,math"
"import java.io.*;\nimport java.util.*;\npublic class a {\n    public static FastScanner fs;\n    public static int n,m,q;\n    public static ArrayList<Integer>[] g,tree;\n    public static int[] deg;\n    public static int[][] query;\n    public static boolean[] vis;\n    public static void main(String args[])\n    {\n        fs=new FastScanner();\n        n=fs.nextInt();\n        m=fs.nextInt();\n        g=new ArrayList[n+1];\n        tree=new ArrayList[n+1];\n        deg=new int[n+1];\n        vis=new boolean[n+1];\n        Arrays.fill(deg,0);\n        Arrays.fill(vis,false);\n        for(int i=1;i<=n;i++)\n        {\n            g[i]=new ArrayList<Integer>();\n            tree[i]=new ArrayList<Integer>();\n        }\n        for(int i=1;i<=m;i++)\n        {\n            int x,y;\n            x=fs.nextInt();\n            y=fs.nextInt();\n            g[x].add(y);\n            g[y].add(x);\n        }\n        q=fs.nextInt();\n        query=new int[q+1][2];\n        for(int i=1;i<=q;i++)\n        {\n            int x,y;\n            x=fs.nextInt();\n            y=fs.nextInt();\n            query[i][0]=x;\n            query[i][1]=y;\n            deg[x] ^= 1;\n            deg[y] ^= 1;\n        }\n        int sum=0;\n        for(int i=1;i<=n;i++)\n            sum += deg[i];\n        if(sum>0)\n        {\n            System.out.println(""NO"");\n            System.out.println(sum/2);\n        }\n        else\n        {\n            System.out.println(""YES"");\n            dfstree(1);\n            for(int i=1;i<=q;i++)\n            {\n                Arrays.fill(vis,false);\n                ArrayList<Integer>path=new ArrayList<>();\n                dfspath(query[i][0],query[i][1],path);\n                System.out.println(path.size());\n                for(int it:path)\n                    System.out.print(it+"" "");\n                System.out.println("""");\n            }\n        }\n    }\n    public static void dfstree(int node)\n    {\n        vis[node]=true;\n        for(int it:g[node])\n        {\n            if(!vis[it])\n            {\n                tree[node].add(it);\n                tree[it].add(node);\n                dfstree(it);\n            }\n        }\n    }\n    public static boolean dfspath(int node,int target,ArrayList<Integer>path)\n    {\n        path.add(node);\n        vis[node]=true;\n        if(node==target)\n        {\n            return true;\n        }\n        for(int it:tree[node])\n        {\n            if(!vis[it] && dfspath(it,target,path))\n            {\n                return true;\n            }\n        }\n        path.remove(path.size()-1);\n        return false;\n    }\n    static class FastScanner{\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer("""");\n        String next()\n        {\n            while(!st.hasMoreTokens())\n            {\n                try{\n                    st=new StringTokenizer(br.readLine());\n                }\n                catch(Exception e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n    }\n}","constructive algorithms,dfs and similar,graph matchings,graphs,greedy,trees"
"import java.util.*;\nimport java.io.*;\npublic class E {\n\n	public static void main(String[] args) {\n		FastScanner sc = new FastScanner();\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		LinkedList<Integer>[] g = new LinkedList[n];\n		for(int i = 0; i < n; i++) {\n			g[i] = new LinkedList<>();\n		}\n		for(int i = 0; i < m; i++) {\n			int u = sc.nextInt()-1;\n			int v = sc.nextInt()-1;\n			g[u].add(v); g[v].add(u);\n		}\n		int[] p = new int[n];\n		Arrays.fill(p, -1);\n		LinkedList<Integer> q = new LinkedList<Integer>();\n		q.add(0);\n		p[0] = 0;\n		while(!q.isEmpty()) {\n			int u = q.removeFirst();\n			for(int v: g[u]) {\n				if(p[v] < 0) {\n					p[v] = u;\n					q.add(v);\n				}\n			}\n		}\n		gt = new HashMap[n];\n		for(int i = 0; i < n; i++) {\n			gt[i] = new HashMap<>();\n		}\n		for(int i = 1; i < n; i++) {\n			int u = i, v = p[i];\n			gt[u].put(v, 0);\n			gt[v].put(u, 0);\n		}\n		int qs = sc.nextInt();\n		LinkedList<Integer>[] qnodes = new LinkedList[qs];\n		for(int i = 0; i < qs; i++) {\n			qnodes[i] = new LinkedList<>();\n			int uq = sc.nextInt()-1;\n			int vq = sc.nextInt()-1;\n			int[] pp = new int[n];\n			Arrays.fill(pp, -1);\n			q = new LinkedList<Integer>();\n			q.add(uq);\n			pp[uq] = uq;\n 			while(!q.isEmpty()) {\n				int u = q.removeFirst();\n				for(int v: gt[u].keySet()) {\n					if(pp[v] < 0) {\n						pp[v] = u;\n						q.add(v);\n					}\n				}\n			}\n			while(vq != uq) {\n				qnodes[i].addFirst(vq);\n				int u = pp[vq];\n				int w = gt[u].get(vq);\n				gt[u].put(vq, w+1);\n				gt[vq].put(u, w+1);\n				vq = u;\n			}\n			qnodes[i].addFirst(vq);\n		}\n		open = new boolean[n];\n		count = new int[n];\n		int r = dfs(0, -1);\n		if(r == 0) {\n			StringBuilder sbres = new StringBuilder();\n			for(int i = 0; i < qs; i++) {\n				StringBuilder sb = new StringBuilder();\n				int cr = 0;\n				for(int u: qnodes[i]) {\n					sb.append((u+1)+"" ""); cr++;\n				}\n				sb.replace(sb.length()-1, sb.length(), ""\n"");\n				sbres.append(cr+""\n"");\n				sbres.append(sb);\n			}\n			PrintWriter pw = new PrintWriter(System.out);\n			pw.println(""YES"");\n			pw.print(sbres.toString());\n			pw.flush();\n		}\n		else {\n			System.out.println(""NO"");\n			System.out.println(r);\n		}\n	}\n	static boolean[] open;\n	static int[] count;\n	static HashMap<Integer, Integer>[] gt;\n	static int dfs(int u, int p) {\n		boolean leaf = true;\n		for(int v: gt[u].keySet()) {\n			if(v != p) {\n				leaf = false;\n				int w = gt[u].get(v);\n				if(w % 2 == 1) {\n					if(open[u]) open[u] = false;\n					else {\n						count[u]++; open[u] = true;\n					}\n				}\n				int a = dfs(v, u);\n				count[u] += a;\n				if(w % 2 == 1 && open[v]) {\n					count[u]--;\n				}\n			}\n		}\n		return count[u];\n	}\n	\n	\n	static class FastScanner {\n		public BufferedReader reader;\n		public StringTokenizer tokenizer;\n		public FastScanner() {\n			reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n			tokenizer = null;\n		}\n		public String next() {\n			while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n				try {\n					tokenizer = new StringTokenizer(reader.readLine());\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n			return tokenizer.nextToken();\n		}\n		public int nextInt() {\n			return Integer.parseInt(next());\n		}\n		public long nextLong() {\n			return Long.parseLong(next());\n		}\n		public double nextDouble() {\n			return Double.parseDouble(next());\n		}\n		public String nextLine() {\n			try {\n				return reader.readLine();\n			} catch(IOException e) {\n				throw new RuntimeException(e);\n			}\n		}\n	}\n\n}\n","constructive algorithms,dfs and similar,graph matchings,graphs,greedy,trees"
"import java.util.*;\nimport java.io.*;\n\npublic class _1583_E {\n    static Stack<Integer> res;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        StringTokenizer line = new StringTokenizer(in.readLine());\n        int n = Integer.parseInt(line.nextToken());\n        int m = Integer.parseInt(line.nextToken());\n        ArrayList<Integer>[] tree = new ArrayList[n];\n        int[] par = new int[n];\n        int[] rank = new int[n];\n        for (int i = 0; i < n; i++) {\n            tree[i] = new ArrayList<Integer>();\n            par[i] = i;\n        }\n        for (int i = 0; i < m; i++) {\n            line = new StringTokenizer(in.readLine());\n            int v1 = Integer.parseInt(line.nextToken()) - 1;\n            int v2 = Integer.parseInt(line.nextToken()) - 1;\n            if (find(par, v1) != find(par, v2)) {\n                union(par, rank, v1, v2);\n                tree[v1].add(v2);\n                tree[v2].add(v1);\n            }\n        }\n        int[] count = new int[n];\n        int q = Integer.parseInt(in.readLine());\n        int[][] queries = new int[q][2];\n        for (int i = 0; i < q; i++) {\n            line = new StringTokenizer(in.readLine());\n            int v1 = Integer.parseInt(line.nextToken()) - 1;\n            int v2 = Integer.parseInt(line.nextToken()) - 1;\n            queries[i] = new int[] { v1, v2 };\n            count[v1]++;\n            count[v2]++;\n        }\n        int odds = 0;\n        for (int i = 0; i < n; i++) {\n            if (count[i] % 2 == 1) {\n                odds++;\n            }\n        }\n        if (odds > 0) {\n            out.println(""NO"");\n            out.println(odds / 2);\n        } else {\n            out.println(""YES"");\n            for (int i = 0; i < q; i++) {\n                dfs(tree, new boolean[n], queries[i][0], queries[i][1], new Stack<Integer>());\n                StringBuilder sb = new StringBuilder();\n                sb.append(queries[i][0] + 1);\n                for (int j = 0; j < res.size(); j++) {\n                    sb.append(' ');\n                    sb.append(res.get(j) + 1);\n                }\n                out.println(res.size() + 1);\n                out.println(sb.toString());\n            }\n        }\n        in.close();\n        out.close();\n    }\n\n    static boolean dfs(ArrayList<Integer>[] tree, boolean[] visited, int node, int dest, Stack<Integer> path) {\n        visited[node] = true;\n        if (node == dest) {\n            res = path;\n            return true;\n        }\n        for (int nei : tree[node]) {\n            if (!visited[nei]) {\n                path.push(nei);\n                if (dfs(tree, visited, nei, dest, path)) {\n                    return true;\n                }\n                path.pop();\n            }\n        }\n        return false;\n    }\n\n    static int find(int[] parents, int node) {\n        if (parents[node] == node) {\n            return node;\n        }\n        parents[node] = find(parents, parents[node]);\n        return parents[node];\n    }\n\n    static void union(int[] parents, int[] dists, int a, int b) {\n        int roota = find(parents, a);\n        int rootb = find(parents, b);\n        if (dists[a] > dists[b]) {\n            parents[rootb] = roota;\n        } else if (dists[b] > dists[a]) {\n            parents[roota] = rootb;\n        } else {\n            parents[rootb] = roota;\n            dists[roota] += 1;\n        }\n    }\n}","constructive algorithms,dfs and similar,graph matchings,graphs,greedy,trees"
"//stan hu tao\n//come to K-expo!!!\n//watch me get carried in nct ridin\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.Math.abs;\nimport static java.lang.System.out;\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n \npublic class MomentOfBloomModel\n{\n    static ArrayDeque<Integer>[] edges;\n    static ArrayDeque<Integer>[] tree;\n    public static void main(String hi[]) throws Exception\n    {\n        BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(infile.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n        //FOR SAMPLE CASE HIDING ONLY\n        ArrayList<Integer> input = new ArrayList<Integer>();\n        input.add(N);  input.add(M);\n        edges = new ArrayDeque[N+1];\n        for(int i=1; i <= N; i++)\n            edges[i] = new ArrayDeque<Integer>();\n        for(int i=0; i < M; i++)\n        {\n            st = new StringTokenizer(infile.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            edges[a].add(b);    edges[b].add(a);\n            \n            input.add(a);   input.add(b);\n        }\n        int[] parity = new int[N+1];\n        int Q = Integer.parseInt(infile.readLine());\n        input.add(Q);\n        int[] queries = new int[2*Q];\n        for(int i=1; i < 2*Q; i+=2)\n        {\n            st = new StringTokenizer(infile.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            queries[i-1] = a;\n            queries[i] = b;\n            parity[a] ^= 1;\n            parity[b] ^= 1;\n            input.add(a);   input.add(b);\n        }\n        int countExtra = 0;\n        for(int x: parity)\n            countExtra+=x;\n        if(countExtra > 0)\n        {\n            System.out.println(""NO"");\n            System.out.println(countExtra/2);\n            return;\n        }\n        //get dfs tree\n        tree = new ArrayDeque[N+1];\n        for(int i=1; i <= N; i++)\n            tree[i] = new ArrayDeque<Integer>();\n        seen = new boolean[N+1];\n        dfs(1, 0);\n        System.out.println(""YES"");\n        StringBuilder sb = new StringBuilder();\n        for(int qq=1; qq < 2*Q; qq+=2)\n        {\n            int a = queries[qq-1];\n            int b = queries[qq];\n            //is this too slow? probably not\n            int[] parents = new int[N+1];\n            ArrayDeque<Integer> q = new ArrayDeque<Integer>();\n            q.add(a);   parents[a] = -1;\n            bfs:while(q.size() > 0)\n            {\n                int curr = q.poll();\n                for(int next: tree[curr])\n                    if(parents[next] == 0)\n                    {\n                        parents[next] = curr;\n                        if(next == b)\n                            break bfs;\n                        q.add(next);\n                    }\n            }\n            ArrayList<Integer> path = new ArrayList<Integer>();\n            int curr = b;\n            while(curr != a)\n            {\n                path.add(curr);\n                curr = parents[curr];\n            }\n            path.add(a);\n            Collections.reverse(path);\n            sb.append(path.size()+""\n"");\n            for(int x: path)\n                sb.append(x+"" "");\n            sb.append(""\n"");\n        }\n        System.out.print(sb);\n    }\n    static boolean[] seen;\n    public static void dfs(int curr, int par)\n    {\n        seen[curr] = true;\n        for(int next: edges[curr])\n            if(!seen[next])\n            {\n                tree[curr].add(next);\n                tree[next].add(curr);\n                dfs(next, curr);\n            }\n    }\n}\n","constructive algorithms,dfs and similar,graph matchings,graphs,greedy,trees"
"import java.util.*;\n\npublic class Main {\n	static Scanner sc = new Scanner(System.in);\n	public static void main(String[] args) {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			solve();\n		}\n	}\n\n	static void solve() {\n		int n = sc.nextInt(), m = sc.nextInt();\n		int[] nodes = new int[n+1];\n		\n		for (int i = 0; i < m; i++) {\n			int a = sc.nextInt(), b = sc.nextInt(), c = sc.nextInt();\n			nodes[b] = 1;\n		}\n		int x = 1;\n		while (nodes[x] == 1) x++;\n		for (int i = 1; i <= n; i++) {\n			if (i == x) continue;\n			System.out.println(x + "" "" + i);\n		}\n	}\n}\n","constructive algorithms,trees"
"import java.util.Scanner;\n\npublic class B {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		for (; t > 0; t--) {\n			int n = sc.nextInt(); int m = sc.nextInt();\n\n			boolean[] used = new boolean[n+1];\n\n			for (int i = 0; i < m; i++) {\n				int a = sc.nextInt(); int b = sc.nextInt(); int c = sc.nextInt();\n				used[b] = true;\n			}\n\n			for (int i = 1; i <= n; i++) {\n				if (!used[i]) {\n					for (int j = 1; j <= n; j++)\n						if (j != i)\n							System.out.printf(""%s %s\n"", i, j);\n\n					break;\n				}\n			}\n		}\n\n		sc.close();\n	}\n}","constructive algorithms,trees"
"import java.util.*;\n\npublic class Omkar_And_Heavenly_Dream {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while(t-->0) {\n			int n = sc.nextInt();\n			int m = sc.nextInt();\n			HashSet<Integer> vis = new HashSet<>();\n			for(int i=0;i<m;i++) {\n				int a = sc.nextInt();\n				int b = sc.nextInt();\n				int c = sc.nextInt();\n				vis.add(b);\n			}\n			int i=1;\n			for(;i<=n;i++) {\n				if(!vis.contains(i))\n					break;\n			}\n			for(int j=1;j<=n;j++) {\n				if(j==i)\n					continue;\n				System.out.println(j+"" ""+i);\n			}\n		}\n	}\n}\n","constructive algorithms,trees"
import java.util.Scanner;\n\npublic class Main {\n\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		int t = s.nextInt();\n		\n		for(int o=0;o<t;o++) {\n			\n			int n = s.nextInt();\n			int[] niz = new int[n+1];\n			int m = s.nextInt();\n			\n			for(int i=0;i<m;i++) {\n				int neba = s.nextInt();\n				int nebb = s.nextInt();\n				int nebc = s.nextInt();\n				niz[nebb]++;\n			}\n			for(int i=1;i<=n;i++) {\n				if(niz[i]==0) {\n					for(int q=1;q<=n;q++) {\n						if(q!=i) {\n						System.out.print(i);\n						System.out.print(' ');\n						System.out.println(q);\n						}\n					}\n					\n					i=n+1;\n				}\n			}\n			\n		}\n	}\n\n},"constructive algorithms,trees"
import java.util.*;\npublic class count_permutations\n{\npublic static void main(String[] args) {\n	Scanner in =new Scanner(System.in);\n	int t=in.nextInt();\n	for(int k=0;k<t;k++)\n	{\n		int n=in.nextInt();\n		long fact=1;\n		for(int i=3;i<=2*n;i++)\n		{\n			fact=(long)(fact*i)%(long)(1e9 + 7);\n		}\n		System.out.println(fact);\n	}\n}\n},"combinatorics,math,number theory"
import java.util.*;\npublic class Main{\n	public static void main(String args[]) {\n		Scanner s=new Scanner(System.in);\n		int t=s.nextInt();\n		while(t-->0) {\n			long n=s.nextLong();\n			n*=2;\n			long res=1;\n			while(n>2) {\n				res=((res%1000000007)*(n%1000000007))%1000000007;\n				n-=1;\n			}\n			System.out.println(res);\n		}\n	}\n},"combinatorics,math,number theory"
import java.util.Scanner;\n\npublic class CoForce {\n	public static void main(String args[])\n	{\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		\n		\n		while(t-->0)\n		{\n			long a=1;\n			int n=sc.nextInt();\n			\n			for(int i=3;i<=2*n;i++)\n			{\n				a=(a*i)%1000000007;\n			}\n			\n			System.out.println(a);\n		}\n			\n	}\n}\n,"combinatorics,math,number theory"
import java.util.*;\n\npublic class P1581A {\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		int t = s.nextInt();\n		while (t-- > 0) {\n			int n = s.nextInt();\n			long ans = 1;\n			for (int i = 3; i <= 2 * n; i++) {\n				ans = (long) (ans * i) % (long) (1e9 + 7);\n			}\n			System.out.println(ans);\n		}\n		s.close();\n	}\n}\n,"combinatorics,math,number theory"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1579E2 extends PrintWriter {\n	CF1579E2() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1579E2 o = new CF1579E2(); o.main(); o.flush();\n	}\n\n	int[] ft;\n	void update(int i, int n) {\n		while (i < n) {\n			ft[i]++;\n			i |= i + 1;\n		}\n	}\n	int query(int i) {\n		int a = 0;\n		while (i >= 0) {\n			a += ft[i];\n			i &= i + 1; i--;\n		}\n		return a;\n	}\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int[] aa = new int[n];\n			int[] ii = new int[n];\n			for (int i = 0; i < n; i++) {\n				aa[i] = sc.nextInt();\n				ii[i] = i;\n			}\n			ii = Arrays.stream(ii).boxed().sorted((i, j) -> aa[i] != aa[j] ? aa[i] - aa[j] : j - i).mapToInt($->$).toArray();\n			ft = new int[n];\n			int[] lt = new int[n];\n			for (int h = 0; h < n; h++) {\n				int i = ii[h];\n				lt[i] = query(i);\n				update(i, n);\n			}\n			ii = Arrays.stream(ii).boxed().sorted((i, j) -> aa[i] != aa[j] ? aa[i] - aa[j] : i - j).mapToInt($->$).toArray();\n			Arrays.fill(ft, 0);\n			int[] le = new int[n];\n			for (int h = 0; h < n; h++) {\n				int i = ii[h];\n				le[i] = query(i);\n				update(i, n);\n			}\n			long ans = 0;\n			for (int i = 0; i < n; i++)\n				ans += Math.min(lt[i], i - le[i]);\n			println(ans);\n		}\n	}\n}\n","data structures,greedy"
"import java.util.*;\npublic class Main{\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int t = in.nextInt();\n        while(t-->0){\n            int n = in.nextInt();\n            TreeSet<Integer> set = new TreeSet<>();\n            int arr[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                int x = in.nextInt();\n                arr[i] = x;\n                set.add(x);\n            }\n            HashMap<Integer,Integer> rank = new HashMap<>();\n            int k = 1;\n            for (Integer x: set){\n                rank.put(x,k++);\n            }\n            int c[] = new int[n+1];\n            long ans = 0;\n            for (int i = 0; i < n; i++) {\n                int val = rank.get(arr[i]);\n                long xiaoyu = query(val-1,c);\n                long dengyu = query(val,c) - xiaoyu;\n                long dayu = i - xiaoyu - dengyu;\n                ans += Math.min(xiaoyu,dayu);\n                update(val,1,c);\n            }\n            System.out.println(ans);\n        }\n    }\n    public static int lowbit(int x){\n        return x & -x;\n    }\n    public static void update(int x,int k,int c[]){\n        for (;x<=c.length-1;x+=lowbit(x)){\n            c[x] += k;\n        }\n    }\n    public static long query(int x,int c[]){\n        long ans = 0;\n        for (;x>=1;x-=lowbit(x)){\n            ans += c[x];\n        }\n        return ans;\n    }\n}\n\n","data structures,greedy"
"import java.io.*;\nimport java.util.*;\n\npublic class Codeforces\n{\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb=new StringBuilder();\n        int t=Integer.parseInt(bu.readLine());\n        while(t-->0)\n        {\n            int n=Integer.parseInt(bu.readLine());\n            int a[]=new int[n],i;\n            Set<Integer> set=new TreeSet<>();\n            HashMap<Integer,Integer> hm=new HashMap<>();\n            String s[]=bu.readLine().split("" "");\n            for(i=0;i<n;i++)\n            {\n                a[i]=Integer.parseInt(s[i]);\n                set.add(a[i]);\n            }\n\n            i=0;\n            for(int x:set) hm.put(x,i++);\n            int sz=i; bit=new int[sz+1];\n            update(hm.get(a[0]),sz);\n\n            long ans=0;\n            for(i=1;i<n;i++)\n            {\n                int m1=query(hm.get(a[i])-1),m2=i-query(hm.get(a[i]));\n                ans+=Math.min(m1,m2);\n                update(hm.get(a[i]),sz);\n            }\n            sb.append(ans+""\n"");\n        }\n        System.out.print(sb);\n    }\n\n    static int bit[];\n    static void update(int i,int n)\n    {\n        i++;\n        while(i<=n)\n        {\n            bit[i]++;\n            i+=i&-i;\n        }\n    }\n\n    static int query(int i)\n    {\n        i++;\n        int s=0;\n        while(i>0)\n        {\n            s+=bit[i];\n            i-=i&-i;\n        }\n        return s;\n    }\n}","data structures,greedy"
"import java.io.*;\nimport java.util.*;\n\npublic class Div31579E2 {\n\n	static int it;\n	\n	public static void main(String[] args) throws IOException {\n\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		\n		int t = Integer.parseInt(br.readLine());\n		\n		while(t --> 0) {\n			\n			int n = Integer.parseInt(br.readLine());\n			StringTokenizer st = new StringTokenizer(br.readLine());\n			\n			it = 1;\n			int[] ar = new int[n];\n			FenwickTree ft = new FenwickTree(n+2);\n			TreeMap<Integer, Integer> comp = new TreeMap<Integer, Integer>();	\n			\n			for(int i = 0; i < n; i++) {\n				\n				ar[i] = Integer.parseInt(st.nextToken());\n				comp.put(ar[i], 0);\n				\n			}\n			\n			comp.forEach((val, ind) -> {\n				\n				comp.replace(val, it);\n				it++;\n				\n			});\n						\n			long inversions = 0;\n			\n			for(int i = 0; i < n; i++) {\n				\n				long frontCost = ft.sum(comp.get(ar[i])-1);\n				long backCost = ft.sum(comp.get(ar[i])+1, n+1);\n				\n				inversions += Math.min(frontCost, backCost);\n				\n				ft.add(comp.get(ar[i]), 1);\n				\n			}\n			\n			System.out.println(inversions);\n			\n		}\n		\n	}\n\n	static class FenwickTree{\n		\n		long[] bit;\n		int n;\n		\n		public FenwickTree(int n) {\n			\n			this.n = n;\n			bit = new long[n];\n			\n		}\n		\n		public long sum(int r) {\n		\n			long ret = 0;\n	        for (; r >= 0; r = (r & (r + 1)) - 1)\n	            ret += bit[r];\n	        return ret;\n			\n		}\n\n	    public long sum(int l, int r) {\n	    	\n	        return sum(r) - sum(l - 1);\n	        \n	    }\n\n	    public void add(int idx, long delta) {\n	    	\n	        for (; idx < n; idx = idx | (idx + 1))\n	            bit[idx] += delta;\n	        \n	    }\n		\n	}\n	\n}\n","data structures,greedy"
"import java.io.*;\nimport java.util.*;\n\npublic class Codeforces\n{\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb=new StringBuilder();\n\n        char s[]=bu.readLine().toCharArray();\n        boolean x=false;\n        int n=s.length,i;\n        for(i=0;i<n;i++) x|=s[i]=='X';\n\n        int ans=0;\n        char s2[]=new char[n];\n        for(i=0;i<10;i++)\n        {\n            int j;\n            for(j=0;j<n;j++)\n            if(s[j]=='X') s2[j]=(char)('0'+i);\n            else s2[j]=s[j];\n            if(s2[0]=='0') continue;    //not possible\n\n            int dp[][]=new int[2][25],cur=1,l,k;\n            dp[0][0]=1;\n            for(j=0;j<n;j++)\n            {\n                for(k=0;k<25;k++) dp[cur][k]=0;\n                int lo=0,hi=9,nxt;\n                if(s2[j]!='_') lo=hi=(s2[j]-'0');\n                else if(s2[j]=='_' && j==0) lo++;\n\n                for(k=0;k<25;k++)\n                for(l=lo;l<=hi;l++)\n                {\n                    nxt=(k*10+l)%25;\n                    dp[cur][nxt]+=dp[cur^1][k];\n                }\n                cur^=1;\n            }\n\n            ans+=dp[cur^1][0];\n            if(!x) break;\n        }\n\n        if(n==1 && (s[0]=='_' || s[0]=='X' || s[0]=='0')) ans++;\n        System.out.println(ans);\n    }\n}","brute force,dfs and similar,dp"
"\nimport java.util.*;\n\npublic class Hello {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.nextLine().trim();\n        assert str.length() >= 1 && str.length() <= 8 : ""Length of S not in range"";\n        if (str.charAt(0) == '0') {\n            System.out.println(str.length() > 1 ? ""0"" : ""1"");\n            return;\n        }\n        int fromVal = Integer.parseInt(""1"" + ""0"".repeat(str.length() - 1));\n        if (fromVal == 1) {\n            fromVal = 0;\n        } else if (fromVal == 10) {\n            fromVal = 25;\n        }\n        int toVal = Integer.parseInt(""9"".repeat(str.length()));\n        int count = 0;\n        for (int val = fromVal; val <= toVal; val += 25) {\n            if (canFormInteger(val, str)) {\n                count++;\n            }\n        }\n        System.out.println(count);\n    }\n\n    private static boolean canFormInteger(int num, String str) {\n        String strNum = String.valueOf(num);\n        char xVal = '*';\n        for (int index = 0; index < str.length(); index++) {\n            if (str.charAt(index) == '_') {\n                continue;\n            } else if (str.charAt(index) == 'X') {\n                if (xVal != '*' && xVal != strNum.charAt(index)) {\n                    return false;\n                }\n                xVal = strNum.charAt(index);\n            } else if (str.charAt(index) != strNum.charAt(index)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n","brute force,dfs and similar,dp"
"\nimport java.util.*;\n\npublic class Hello {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.nextLine().trim();\n        assert str.length() >= 1 && str.length() <= 8 : ""Length of S not in range"";\n        if (str.charAt(0) == '0') {\n            System.out.println(str.length() > 1 ? ""0"" : ""1"");\n            return;\n        }\n        int fromVal = Integer.parseInt(""1"" + ""0"".repeat(str.length() - 1));\n        if (fromVal == 1) {\n            fromVal = 0;\n        } else if (fromVal == 10) {\n            fromVal = 25;\n        }\n        int toVal = Integer.parseInt(""9"".repeat(str.length()));\n        int count = 0;\n        for (int val = fromVal; val <= toVal; val += 25) {\n            if (canFormInteger(val, str)) {\n                count++;\n            }\n        }\n        System.out.println(count);\n    }\n\n    private static boolean canFormInteger(int num, String str) {\n        String strNum = String.valueOf(num);\n        char xVal = '*';\n        for (int index = 0; index < str.length(); index++) {\n            if (str.charAt(index) == '_') {\n                continue;\n            } else if (str.charAt(index) == 'X') {\n                if (xVal != '*' && xVal != strNum.charAt(index)) {\n                    return false;\n                }\n                xVal = strNum.charAt(index);\n            } else if (str.charAt(index) != strNum.charAt(index)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n","brute force,dfs and similar,dp"
"import java.io.*;\nimport java.util.*;\npublic class TwentyFive {\n	public static void main(String[] args) throws Exception {\n		FastIO in = new FastIO();\n		String s = in.next();\n		int ans = 0;\n		for (int i=0; i<100000000; i+=25) {\n			String test = i+"""";\n			if (test.length()!=s.length()) continue;\n			int xValue = -1;\n			boolean works = true;\n			for (int j=0; j<s.length(); j++) {\n				if (s.charAt(j)=='X') {\n					if (xValue==-1) {\n						xValue = test.charAt(j);\n					}\n					if (test.charAt(j)!=xValue) {\n						works = false;\n						break;\n					}\n				}\n				else if (s.charAt(j)!='_') {\n					if (test.charAt(j)!=s.charAt(j)) {\n						works = false;\n						break;\n					}\n				}\n			}\n			if (works) ans++;\n		}\n		System.out.println(ans);\n	}\n	static class FastIO {\n		BufferedReader br;\n	    StringTokenizer st;\n	    public FastIO() throws IOException\n	    {\n	        br = new BufferedReader(\n	            new InputStreamReader(System.in));\n\n	    }\n	    \n\n	    public String next() throws IOException\n	    {\n	        while (st == null || !st.hasMoreElements()) {\n	           \n	            st = new StringTokenizer(br.readLine());\n	        }\n	        return st.nextToken();\n	    }\n\n	    public int nextInt() throws NumberFormatException, IOException { return Integer.parseInt(next()); }\n\n	    public long nextLong() throws NumberFormatException, IOException { return Long.parseLong(next()); }\n\n	    public double nextDouble() throws NumberFormatException, IOException\n	    {\n	        return Double.parseDouble(next());\n	    }\n\n	    public String nextLine() throws IOException\n	    {\n	        String str = br.readLine();\n	        return str;\n	    }\n	}\n}\n","brute force,dfs and similar,dp"
import java.util.*;\npublic class Main{\npublic static void main(String[] args){\n Scanner sc=new Scanner(System.in);\n int t=sc.nextInt();\n while(t-->0){\n     int n=sc.nextInt();\n     int s=sc.nextInt();\n     int m=n/2 + 1;\n     System.out.println(s/m);\n }\n}\n},"binary search,greedy,math"
import java.util.*;\n\npublic class Codeforces {\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		for (int i=0;i<t;i++)\n		{\n			int n = sc.nextInt();\n			int s = sc.nextInt();\n			System.out.println(s/((n/2)+1));\n		}\n	}\n},"binary search,greedy,math"
import java.util.*;\n \npublic class Solution {\n \n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		for (int i=0;i<t;i++)\n		{\n			int n = sc.nextInt();\n			int s = sc.nextInt();\n			System.out.println(s/((n/2)+1));\n		}\n	}\n},"binary search,greedy,math"
import java.util.*;\npublic class Run {\n   	   \n	public static void main(String[] args) {	\n		\n		 Scanner sc=new Scanner(System.in);\n		 int t=sc.nextInt();\n		 while(t-->0) {\n			 long n=sc.nextLong();\n			 long s=sc.nextLong();\n			 System.out.println(s/(n/2+1));\n			}\n		 \n		}\n	\n}\n\n\n,"binary search,greedy,math"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.nio.charset.StandardCharsets;\nimport java.io.UncheckedIOException;\nimport java.util.function.Consumer;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            HDIYTree solver = new HDIYTree();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class HDIYTree {\n        Debug debug = new Debug(true);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.ri();\n            int k = in.ri();\n            int[] d = in.ri(k);\n            int n2 = n * (n - 1) / 2;\n            int ck = k * (k - 1) / 2;\n            IntegerArrayList usList = new IntegerArrayList(n2);\n            IntegerArrayList vsList = new IntegerArrayList(n2);\n            LongArrayList wsList = new LongArrayList(n2);\n            IntegerArrayList edgeList = new IntegerArrayList(ck);\n            List<Edge> outside = new ArrayList<>(n2);\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    if (i >= k && j >= k) {\n                        Edge e = new Edge(i, j, in.ri());\n                        outside.add(e);\n                    } else {\n                        usList.add(i);\n                        vsList.add(j);\n                        wsList.add(in.ri());\n                    }\n                    if (i < k && j < k) {\n                        edgeList.add(usList.size() - 1);\n                    }\n                }\n            }\n            DSU dsu = new DSU(n);\n            dsu.init();\n            outside.sort(Comparator.comparingInt(x -> x.w));\n\n            debug.debug(""size"", usList.size());\n            for (Edge e : outside) {\n                if (dsu.find(e.a) == dsu.find(e.b)) {\n                    continue;\n                }\n                dsu.merge(e.a, e.b);\n                usList.add(e.a);\n                vsList.add(e.b);\n                wsList.add(e.w);\n            }\n            int[] us = usList.toArray();\n            int[] vs = vsList.toArray();\n            long[] ws = wsList.toArray();\n            int[] edges = edgeList.toArray();\n            int m = edges.length;\n            long inf = (long) 1e9;\n            long[] wsSnapshot = ws.clone();\n            int[] type = new int[us.length];\n            for (int i = 0; i < us.length; i++) {\n                if (us[i] < k && vs[i] >= k) {\n                    type[i] = us[i];\n                } else if (vs[i] < k && us[i] >= k) {\n                    type[i] = vs[i];\n                } else {\n                    type[i] = k;\n                }\n            }\n            debug.debug(""size"", us.length);\n            long best = inf;\n            for (int i = 0; i < 1 << m; i++) {\n                boolean ok = true;\n                dsu.init();\n                System.arraycopy(wsSnapshot, 0, ws, 0, ws.length);\n                int[] cap = new int[k + 1];\n                System.arraycopy(d, 0, cap, 0, k);\n                cap[k] = n;\n                for (int j = 0; j < m; j++) {\n                    int e = edges[j];\n                    if (Bits.get(i, j) == 0) {\n                        ws[e] += inf;\n                    } else {\n                        int u = us[e];\n                        int v = vs[e];\n                        ws[e] -= inf;\n                        cap[u]--;\n                        cap[v]--;\n                        if (dsu.find(u) == dsu.find(v)) {\n                            ok = false;\n                        }\n                        dsu.merge(u, v);\n                    }\n                }\n                for (int j = 0; j < ws.length; j++) {\n                    ws[j] = -ws[j];\n                }\n                for (int j = 0; j <= k; j++) {\n                    if (cap[j] < 0) {\n                        ok = false;\n                    }\n                }\n                if (!ok) {\n                    continue;\n                }\n                MatroidIndependentSet container = MatroidIndependentSet.ofColorContainers(type, cap);\n                MatroidIndependentSet tree = MatroidIndependentSet.ofSpanningTree(n, new int[][]{us, vs});\n                MaximumWeightMatroidIntersect mi = new MaximumWeightMatroidIntersect(us.length, ws);\n                boolean[] sol = mi.intersect(container, tree);\n                long sum = 0;\n                int occur = 0;\n                for (int j = 0; j < sol.length; j++) {\n                    if (sol[j]) {\n                        occur++;\n                        sum += ws[j];\n                    }\n                }\n                sum = -sum;\n                sum += Integer.bitCount(i) * inf;\n                if (sum >= inf || occur < n - 1) {\n                    continue;\n                }\n                best = Math.min(best, sum);\n            }\n            out.println(best);\n        }\n\n    }\n\n    static class LongArrayList implements Cloneable {\n        private int size;\n        private int cap;\n        private long[] data;\n        private static final long[] EMPTY = new long[0];\n\n        public LongArrayList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new long[cap];\n            }\n        }\n\n        public LongArrayList(long[] data) {\n            this(0);\n            addAll(data);\n        }\n\n        public LongArrayList(LongArrayList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public LongArrayList() {\n            this(0);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        public void add(long x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public void addAll(long[] x) {\n            addAll(x, 0, x.length);\n        }\n\n        public void addAll(long[] x, int offset, int len) {\n            ensureSpace(size + len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(LongArrayList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public long[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof LongArrayList)) {\n                return false;\n            }\n            LongArrayList other = (LongArrayList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n        public int hashCode() {\n            int h = 1;\n            for (int i = 0; i < size; i++) {\n                h = h * 31 + Long.hashCode(data[i]);\n            }\n            return h;\n        }\n\n        public LongArrayList clone() {\n            LongArrayList ans = new LongArrayList();\n            ans.addAll(this);\n            return ans;\n        }\n\n    }\n\n    static interface IntegerDeque extends IntegerStack {\n    }\n\n    static interface IntegerStack {\n    }\n\n    static class IntegerMultiWayStack {\n        private int[] values;\n        private int[] next;\n        private int[] heads;\n        private int alloc;\n        private int stackNum;\n\n        public IntegerIterator iterator(final int queue) {\n            return new IntegerIterator() {\n                int ele = heads[queue];\n\n\n                public boolean hasNext() {\n                    return ele != 0;\n                }\n\n\n                public int next() {\n                    int ans = values[ele];\n                    ele = next[ele];\n                    return ans;\n                }\n            };\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            values = Arrays.copyOf(values, newSize);\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n        }\n\n        public void clear() {\n            alloc = 0;\n            Arrays.fill(heads, 0, stackNum, 0);\n        }\n\n        public boolean isEmpty(int qId) {\n            return heads[qId] == 0;\n        }\n\n        public IntegerMultiWayStack(int qNum, int totalCapacity) {\n            values = new int[totalCapacity + 1];\n            next = new int[totalCapacity + 1];\n            heads = new int[qNum];\n            stackNum = qNum;\n        }\n\n        public void addLast(int qId, int x) {\n            alloc();\n            values[alloc] = x;\n            next[alloc] = heads[qId];\n            heads[qId] = alloc;\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < stackNum; i++) {\n                if (isEmpty(i)) {\n                    continue;\n                }\n                builder.append(i).append("": "");\n                for (IntegerIterator iterator = iterator(i); iterator.hasNext(); ) {\n                    builder.append(iterator.next()).append("","");\n                }\n                if (builder.charAt(builder.length() - 1) == ',') {\n                    builder.setLength(builder.length() - 1);\n                }\n                builder.append('\n');\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static class MatroidIntersect {\n        protected IntegerDequeImpl dq;\n        protected int[] dists;\n        protected boolean[] added;\n        protected boolean[][] adj1;\n        protected boolean[][] adj2;\n        protected int n;\n        protected boolean[] x1;\n        protected boolean[] x2;\n        protected static int distInf = (int) 1e9;\n        protected int[] pre;\n        protected Consumer<boolean[]> callback;\n        protected static Consumer<boolean[]> nilCallback = x -> {\n        };\n\n        public void setCallback(Consumer<boolean[]> callback) {\n            if (callback == null) {\n                callback = nilCallback;\n            }\n            this.callback = callback;\n        }\n\n        public MatroidIntersect(int n) {\n            this.n = n;\n            dq = new IntegerDequeImpl(n);\n            dists = new int[n];\n            added = new boolean[n];\n            adj1 = new boolean[n][];\n            adj2 = new boolean[n][];\n            x1 = new boolean[n];\n            x2 = new boolean[n];\n            pre = new int[n];\n            setCallback(nilCallback);\n        }\n\n        protected boolean adj(int i, int j) {\n            if (added[i]) {\n                return adj1[i][j];\n            } else {\n                return adj2[j][i];\n            }\n        }\n\n        protected boolean expand(MatroidIndependentSet a, MatroidIndependentSet b, int round) {\n            Arrays.fill(x1, false);\n            Arrays.fill(x2, false);\n            a.prepare(added);\n            b.prepare(added);\n            a.extend(added, x1);\n            b.extend(added, x2);\n            for (int i = 0; i < n; i++) {\n                if (x1[i] && x2[i]) {\n                    pre[i] = -1;\n                    xorPath(i);\n                    return true;\n                }\n            }\n\n            for (int i = 0; i < n; i++) {\n                if (added[i]) {\n                    Arrays.fill(adj1[i], false);\n                    Arrays.fill(adj2[i], false);\n                }\n            }\n\n            a.computeAdj(added, adj1);\n            b.computeAdj(added, adj2);\n            Arrays.fill(dists, distInf);\n            Arrays.fill(pre, -1);\n            dq.clear();\n            for (int i = 0; i < n; i++) {\n                if (added[i]) {\n                    continue;\n                }\n                //right\n                if (x1[i]) {\n                    dists[i] = 0;\n                    dq.addLast(i);\n                }\n            }\n\n            int tail = -1;\n            while (!dq.isEmpty()) {\n                int head = dq.removeFirst();\n                if (x2[head]) {\n                    tail = head;\n                    break;\n                }\n                for (int j = 0; j < n; j++) {\n                    if (added[head] != added[j] && adj(head, j) && dists[j] > dists[head] + 1) {\n                        dists[j] = dists[head] + 1;\n                        dq.addLast(j);\n                        pre[j] = head;\n                    }\n                }\n            }\n\n            if (tail == -1) {\n                return false;\n            }\n\n            xorPath(tail);\n            return true;\n        }\n\n        protected void xorPath(int tail) {\n            boolean[] last1 = new boolean[n];\n            boolean[] last2 = new boolean[n];\n            for (boolean add = true; tail != -1; tail = pre[tail], add = !add) {\n                assert added[tail] != add;\n                added[tail] = add;\n                if (add) {\n                    adj1[tail] = last1;\n                    adj2[tail] = last2;\n                } else {\n                    last1 = adj1[tail];\n                    last2 = adj2[tail];\n                    adj1[tail] = null;\n                    adj2[tail] = null;\n                }\n            }\n        }\n\n        public boolean[] intersect(MatroidIndependentSet a, MatroidIndependentSet b) {\n            Arrays.fill(added, false);\n            int round = 0;\n            callback.accept(added);\n            while (expand(a, b, round)) {\n                round++;\n                callback.accept(added);\n            }\n            return added;\n        }\n\n    }\n\n    static class Edge {\n        int a;\n        int b;\n        int w;\n\n        public Edge(int a, int b, int w) {\n            this.a = a;\n            this.b = b;\n            this.w = w;\n        }\n\n    }\n\n    static class Bits {\n        private Bits() {\n        }\n\n        public static int get(int x, int i) {\n            return (x >>> i) & 1;\n        }\n\n    }\n\n    static interface IntegerIterator {\n        boolean hasNext();\n\n        int next();\n\n    }\n\n    static class DSU {\n        protected int[] p;\n        public int[] size;\n        protected int n;\n\n        public DSU(int n) {\n            p = new int[n];\n            size = new int[n];\n        }\n\n        public void init() {\n            init(p.length);\n        }\n\n        public void init(int n) {\n            this.n = n;\n            for (int i = 0; i < n; i++) {\n                p[i] = i;\n                size[i] = 1;\n            }\n        }\n\n        public final int find(int a) {\n            if (p[a] == p[p[a]]) {\n                return p[a];\n            }\n            find(p[a]);\n            preAccess(a);\n            return p[a] = p[p[a]];\n        }\n\n        protected void preAccess(int a) {\n\n        }\n\n        protected void preMerge(int a, int b) {\n            size[a] += size[b];\n        }\n\n        public final void merge(int a, int b) {\n            a = find(a);\n            b = find(b);\n            if (a == b) {\n                return;\n            }\n\n            if (size[a] < size[b]) {\n                int tmp = a;\n                a = b;\n                b = tmp;\n            }\n            preMerge(a, b);\n            p[b] = a;\n        }\n\n        public String toString() {\n            return Arrays.toString(Arrays.copyOf(p, n));\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 32 << 10;\n        private OutputStream writer;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n        private static Field stringBuilderValueField;\n        private char[] charBuf = new char[THRESHOLD * 2];\n        private byte[] byteBuf = new byte[THRESHOLD * 2];\n\n        static {\n            try {\n                stringBuilderValueField = StringBuilder.class.getSuperclass().getDeclaredField(""value"");\n                stringBuilderValueField.setAccessible(true);\n            } catch (Exception e) {\n                stringBuilderValueField = null;\n            }\n            stringBuilderValueField = null;\n        }\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n\n        public FastOutput(OutputStream writer) {\n            this.writer = writer;\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(long c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput println(long c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            return append('\n');\n        }\n\n        public FastOutput flush() {\n            try {\n                if (stringBuilderValueField != null) {\n                    try {\n                        byte[] value = (byte[]) stringBuilderValueField.get(cache);\n                        writer.write(value, 0, cache.length());\n                    } catch (Exception e) {\n                        stringBuilderValueField = null;\n                    }\n                }\n                if (stringBuilderValueField == null) {\n                    int n = cache.length();\n                    if (n > byteBuf.length) {\n                        //slow\n                        writer.write(cache.toString().getBytes(StandardCharsets.UTF_8));\n//                writer.append(cache);\n                    } else {\n                        cache.getChars(0, n, charBuf, 0);\n                        for (int i = 0; i < n; i++) {\n                            byteBuf[i] = (byte) charBuf[i];\n                        }\n                        writer.write(byteBuf, 0, n);\n                    }\n                }\n                writer.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                writer.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class IntegerArrayList implements Cloneable {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public int[] getData() {\n            return data;\n        }\n\n        public IntegerArrayList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntegerArrayList(int[] data) {\n            this(0);\n            addAll(data);\n        }\n\n        public IntegerArrayList(IntegerArrayList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntegerArrayList() {\n            this(0);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        public void add(int x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public void addAll(int[] x) {\n            addAll(x, 0, x.length);\n        }\n\n        public void addAll(int[] x, int offset, int len) {\n            ensureSpace(size + len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(IntegerArrayList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public void clear() {\n            size = 0;\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof IntegerArrayList)) {\n                return false;\n            }\n            IntegerArrayList other = (IntegerArrayList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n        public int hashCode() {\n            int h = 1;\n            for (int i = 0; i < size; i++) {\n                h = h * 31 + Integer.hashCode(data[i]);\n            }\n            return h;\n        }\n\n        public IntegerArrayList clone() {\n            IntegerArrayList ans = new IntegerArrayList();\n            ans.addAll(this);\n            return ans;\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static boolean equal(int[] a, int al, int ar, int[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public static boolean equal(long[] a, int al, int ar, long[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class MaximumWeightMatroidIntersect extends MatroidIntersect {\n        protected long[] weight;\n        protected long[] pathWeight;\n        protected static final long weightInf = (long) 1e18;\n        protected boolean[] inq;\n        protected long[] fixWeight;\n\n        public MaximumWeightMatroidIntersect(int n, long[] weight) {\n            super(n);\n            this.weight = weight;\n            pathWeight = new long[n];\n            inq = new boolean[n];\n            fixWeight = new long[n];\n        }\n\n        protected boolean expand(MatroidIndependentSet a, MatroidIndependentSet b, int round) {\n            a.prepare(added);\n            b.prepare(added);\n            Arrays.fill(x1, false);\n            Arrays.fill(x2, false);\n            a.extend(added, x1);\n            b.extend(added, x2);\n\n            for (int i = 0; i < n; i++) {\n                if (added[i]) {\n                    Arrays.fill(adj1[i], false);\n                    Arrays.fill(adj2[i], false);\n                    fixWeight[i] = weight[i];\n                } else {\n                    fixWeight[i] = -weight[i];\n                }\n            }\n\n            a.computeAdj(added, adj1);\n            b.computeAdj(added, adj2);\n            Arrays.fill(dists, MatroidIntersect.distInf);\n            Arrays.fill(pathWeight, weightInf);\n            Arrays.fill(pre, -1);\n            dq.clear();\n            for (int i = 0; i < n; i++) {\n                if (added[i]) {\n                    continue;\n                }\n                //right\n                if (x1[i]) {\n                    dists[i] = 0;\n                    pathWeight[i] = fixWeight[i];\n                    dq.addLast(i);\n                    inq[i] = true;\n                }\n            }\n\n            while (!dq.isEmpty()) {\n                int head = dq.removeFirst();\n                inq[head] = false;\n\n                for (int j = 0; j < n; j++) {\n                    if (added[head] != added[j] && adj(head, j)) {\n                        int comp = Long.compare(pathWeight[j], pathWeight[head] + fixWeight[j]);\n                        if (comp == 0) {\n                            comp = Integer.compare(dists[j], dists[head] + 1);\n                        }\n                        if (comp <= 0) {\n                            continue;\n                        }\n                        dists[j] = dists[head] + 1;\n                        pathWeight[j] = pathWeight[head] + fixWeight[j];\n                        pre[j] = head;\n                        if (!inq[j]) {\n                            inq[j] = true;\n                            dq.addLast(j);\n                        }\n                    }\n                }\n            }\n\n            int tail = -1;\n            for (int i = 0; i < n; i++) {\n                if (!x2[i] || !x1[i] && pre[i] == -1) {\n                    continue;\n                }\n                if (tail == -1 || pathWeight[i] < pathWeight[tail] || pathWeight[i] == pathWeight[tail] &&\n                        dists[i] < dists[tail]) {\n                    tail = i;\n                }\n            }\n            if (tail == -1) {\n                return false;\n            }\n\n            xorPath(tail);\n            return true;\n        }\n\n    }\n\n    static class IntegerDequeImpl implements IntegerDeque {\n        private int[] data;\n        private int bpos;\n        private int epos;\n        private static final int[] EMPTY = new int[0];\n        private int n;\n\n        public IntegerDequeImpl(int cap) {\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n            bpos = 0;\n            epos = 0;\n            n = cap;\n        }\n\n        private void expandSpace(int len) {\n            while (n < len) {\n                n = Math.max(n + 10, n * 2);\n            }\n            int[] newData = new int[n];\n            if (bpos <= epos) {\n                if (bpos < epos) {\n                    System.arraycopy(data, bpos, newData, 0, epos - bpos);\n                }\n            } else {\n                System.arraycopy(data, bpos, newData, 0, data.length - bpos);\n                System.arraycopy(data, 0, newData, data.length - bpos, epos);\n            }\n            epos = size();\n            bpos = 0;\n            data = newData;\n        }\n\n        public IntegerIterator iterator() {\n            return new IntegerIterator() {\n                int index = bpos;\n\n\n                public boolean hasNext() {\n                    return index != epos;\n                }\n\n\n                public int next() {\n                    int ans = data[index];\n                    index = IntegerDequeImpl.this.next(index);\n                    return ans;\n                }\n            };\n        }\n\n        public int removeFirst() {\n            int ans = data[bpos];\n            bpos = next(bpos);\n            return ans;\n        }\n\n        public void addLast(int x) {\n            ensureMore();\n            data[epos] = x;\n            epos = next(epos);\n        }\n\n        public void clear() {\n            bpos = epos = 0;\n        }\n\n        private int next(int x) {\n            return x + 1 >= n ? 0 : x + 1;\n        }\n\n        private void ensureMore() {\n            if (next(epos) == bpos) {\n                expandSpace(n + 1);\n            }\n        }\n\n        public int size() {\n            int ans = epos - bpos;\n            if (ans < 0) {\n                ans += data.length;\n            }\n            return ans;\n        }\n\n        public boolean isEmpty() {\n            return bpos == epos;\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (IntegerIterator iterator = iterator(); iterator.hasNext(); ) {\n                builder.append(iterator.next()).append(' ');\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        public void populate(int[] data) {\n            for (int i = 0; i < data.length; i++) {\n                data[i] = readInt();\n            }\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int ri() {\n            return readInt();\n        }\n\n        public int[] ri(int n) {\n            int[] ans = new int[n];\n            populate(ans);\n            return ans;\n        }\n\n        public int readInt() {\n            boolean rev = false;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                rev = next == '-';\n                next = read();\n            }\n\n            int val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 - next + '0';\n                next = read();\n            }\n\n            return rev ? val : -val;\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public Debug debug(String name, int x) {\n            if (offline) {\n                debug(name, """" + x);\n            }\n            return this;\n        }\n\n        public Debug debug(String name, String x) {\n            if (offline) {\n                out.printf(""%s=%s"", name, x);\n                out.println();\n            }\n            return this;\n        }\n\n    }\n\n    static interface MatroidIndependentSet {\n        void computeAdj(boolean[] added, boolean[][] adj);\n\n        void extend(boolean[] added, boolean[] extendable);\n\n        void prepare(boolean[] added);\n\n        static MatroidIndependentSet ofColorContainers(int[] type, int[] cap) {\n            int[] size = new int[cap.length];\n            return new MatroidIndependentSet() {\n                /**\n                 * O(rn)\n                 * @param added\n                 * @param adj\n                 */\n\n                public void computeAdj(boolean[] added, boolean[][] adj) {\n                    for (int i = 0; i < added.length; i++) {\n                        if (!added[i]) {\n                            continue;\n                        }\n                        for (int j = 0; j < added.length; j++) {\n                            if (added[j]) {\n                                continue;\n                            }\n                            if (size[type[j]] < cap[type[j]] ||\n                                    type[i] == type[j]) {\n                                adj[i][j] = true;\n                            }\n                        }\n                    }\n                }\n\n                /**\n                 * O(n)\n                 * @param added\n                 * @param extendable\n                 */\n\n                public void extend(boolean[] added, boolean[] extendable) {\n                    for (int i = 0; i < added.length; i++) {\n                        if (!added[i] && size[type[i]] < cap[type[i]]) {\n                            extendable[i] = true;\n                        }\n                    }\n                }\n\n\n                public void prepare(boolean[] added) {\n                    Arrays.fill(size, 0);\n                    for (int i = 0; i < added.length; i++) {\n                        if (added[i]) {\n                            size[type[i]]++;\n                        }\n                    }\n                }\n            };\n        }\n\n        static MatroidIndependentSet ofSpanningTree(int n, int[][] edges) {\n            return new MatroidIndependentSet() {\n                DSU dsu = new DSU(n);\n                IntegerMultiWayStack g = new IntegerMultiWayStack(n, edges[0].length);\n                IntegerArrayList inset = new IntegerArrayList(edges[0].length);\n                int[] p = new int[n];\n                int[] depth = new int[n];\n\n                public void dfs(int root, int fa, int d) {\n                    p[root] = fa;\n                    depth[root] = d;\n                    for (IntegerIterator iterator = g.iterator(root); iterator.hasNext(); ) {\n                        int e = iterator.next();\n                        if (e == fa) {\n                            continue;\n                        }\n                        dfs(opponent(e, root), e, d + 1);\n                    }\n                }\n\n                public int opponent(int i, int root) {\n                    return edges[0][i] == root ? edges[1][i] : edges[0][i];\n                }\n\n                /**\n                 * O(rn)\n                 */\n\n                public void computeAdj(boolean[] added, boolean[][] adj) {\n                    int[] insetData = inset.getData();\n                    int m = inset.size();\n                    for (int i = 0; i < added.length; i++) {\n                        if (added[i]) {\n                            continue;\n                        }\n                        if (dsu.find(edges[0][i]) != dsu.find(edges[1][i])) {\n                            for (int j = 0; j < m; j++) {\n                                adj[insetData[j]][i] = true;\n                            }\n                        } else {\n                            int a = edges[0][i];\n                            int b = edges[1][i];\n                            while (a != b) {\n                                if (depth[a] < depth[b]) {\n                                    int tmp = a;\n                                    a = b;\n                                    b = tmp;\n                                }\n                                adj[p[a]][i] = true;\n                                a = opponent(p[a], a);\n                            }\n                        }\n                    }\n                }\n\n\n                /**\n                 * O(n)\n                 */\n\n                public void extend(boolean[] added, boolean[] extendable) {\n                    for (int i = 0; i < added.length; i++) {\n                        if (!added[i]) {\n                            extendable[i] = dsu.find(edges[0][i]) != dsu.find(edges[1][i]);\n                        }\n                    }\n                }\n\n                /**\n                 * O(r+n)\n                 */\n\n                public void prepare(boolean[] added) {\n                    g.clear();\n                    dsu.init();\n                    inset.clear();\n                    for (int i = 0; i < added.length; i++) {\n                        if (added[i]) {\n                            dsu.merge(edges[0][i], edges[1][i]);\n                            g.addLast(edges[0][i], i);\n                            g.addLast(edges[1][i], i);\n                            inset.add(i);\n                        }\n                    }\n                    Arrays.fill(p, -1);\n                    for (int i = 0; i < n; i++) {\n                        if (p[i] == -1) {\n                            dfs(i, -1, 0);\n                        }\n                    }\n                }\n            };\n        }\n\n    }\n}\n\n","graphs,greedy,math,probabilities"
"import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int t = in.nextInt();\n\n    while (t-- > 0) {\n      int n = in.nextInt(), ones = 0, x = 1, a = 0, b = 0;\n\n      // 0 0 0 1 1 1\n      //\n      for (int i = 1; i <= n; i++) {\n        int mod = in.nextInt() % 2;\n\n        ones += mod;\n\n        if (mod == 1) {\n          a += Math.abs(i - 1 - x);\n          b += Math.abs(i - x);\n          x += 2;\n        }\n      }\n\n      if (Math.abs(n - 2 * ones) > 1)\n        System.out.println(-1);\n      else if (n % 2 == 0)\n        System.out.println(Math.min(a, b));\n      else if (n - ones > ones)\n        System.out.println(a);\n      else\n        System.out.println(b);\n    }\n  }\n}\n",implementation
"import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int t = in.nextInt();\n\n    while (t-- > 0) {\n      int n = in.nextInt(), ones = 0, x = 1, a = 0, b = 0;\n\n      // 0 0 0 1 1 1\n      //\n      for (int i = 1; i <= n; i++) {\n        int mod = in.nextInt() % 2;\n\n        ones += mod;\n\n        if (mod == 1) {\n          a += Math.abs(i - 1 - x);\n          b += Math.abs(i - x);\n          x += 2;\n        }\n      }\n\n      if (Math.abs(n - 2 * ones) > 1)\n        System.out.println(-1);\n      else if (n % 2 == 0)\n        System.out.println(Math.min(a, b));\n      else if (n - ones > ones)\n        System.out.println(a);\n      else\n        System.out.println(b);\n    }\n  }\n}\n",implementation
"import java.util.*;\n \npublic class Main {\n  public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int t = in.nextInt();\n \n    while (t-- > 0) {\n      int n = in.nextInt(), ones = 0, x = 1, a = 0, b = 0;\n \n      // 0 0 0 1 1 1\n      //\n      for (int i = 1; i <= n; i++) {\n        int mod = in.nextInt() % 2;\n \n        ones += mod;\n \n        if (mod == 1) {\n          a += Math.abs(i - 1 - x);\n          b += Math.abs(i - x);\n          x += 2;\n        }\n      }\n \n      if (Math.abs(n - 2 * ones) > 1)\n        System.out.println(-1);\n      else if (n % 2 == 0)\n        System.out.println(Math.min(a, b));\n      else if (n - ones > ones)\n        System.out.println(a);\n      else\n        System.out.println(b);\n    }\n  }\n}\n",implementation
"import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    static Scanner in = new Scanner(System.in);\n    static StringBuilder out = new StringBuilder();\n    \n    public static void main(String[] args) {\n        int ntc = Integer.parseInt(in.nextLine());\n        for (int tc = 1; tc <= ntc; tc++) {\n            int n = in.nextInt();\n            int noe = 0;    // number of evens\n            int[] evens = new int[n];\n            for (int i = 0; i < n; i++) {\n                int x = in.nextInt();\n                if ((x & 1) == 0) {\n                    evens[noe++] = i;\n                }\n            }\n\n            int evenFirstRes = 0, oddFirstRes = 0;\n            for (int i = 0; i < noe; i++) {\n                evenFirstRes += Math.abs(evens[i] - i*2);\n                oddFirstRes += Math.abs(evens[i] - (i*2 + 1));\n            }\n            int res = Math.abs(noe - (n-noe)) > 1 ? -1 : (n/2)*2 == n ? Math.min(evenFirstRes, oddFirstRes) : n-noe < noe ? evenFirstRes : oddFirstRes;\n            \n            out.append(res + ""\n"");\n        }\n        System.out.print(out);\n    }\n}",implementation
"// coached by kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1554D extends PrintWriter {\n	CF1554D() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1554D o = new CF1554D(); o.main(); o.flush();\n	}\n\n	void main() {\n		byte[] cc = new byte[100000];\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			for (int i = 0; i < n; i++)\n				cc[i] = 'a';\n			cc[n / 2] = 'b';\n			if (n % 2 == 1)\n				cc[n / 2 + 1] = 'c';\n			println(new String(cc, 0, n));\n		}\n	}\n}\n","constructive algorithms,greedy,strings"
"import java.util.Scanner;\n\npublic class D_1554\n{\n  public static void main(String args[])\n   {Scanner sc=new Scanner(System.in);\n   int t=sc.nextInt();\n   while(t-->0)\n   { StringBuilder sb=new StringBuilder();\n	   int n=sc.nextInt(); \n	   if(n==1)\n	   { System.out.println(""a"");\n	  continue;}\n	   \n	   for(int i=0;i<n/2;i++)\n		 sb.append(""a""); \n	   if(n%2==0)\n		   sb.append(""b""); \n	   else  sb.append(""bc""); \n	   for(int i=0;i<(n/2)-1;i++)\n		   sb.append(""a""); \n	   \n	   System.out.println(sb.toString());\n   }\n   }}\n   ","constructive algorithms,greedy,strings"
import java.util.Scanner;\n\npublic class contestD {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int t = scanner.nextInt();\n        while (t-- > 0) {\n            int n = scanner.nextInt();\n            boolean flag = n%2==1;\n            StringBuilder s = new StringBuilder();\n            n-=(n%2);\n            for(int i=0;i<n;++i) {\n                if(i==n/2) s.append('b');\n                else s.append('a');\n            }\n            if(flag) s.append('c');\n            System.out.println(s);\n        }\n    }\n}\n,"constructive algorithms,greedy,strings"
"import java.util.Scanner;\nimport java.lang.StringBuilder;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int t = in.nextInt();\n    while(t--> 0) {\n      int n = in.nextInt();\n      if(n == 1) {\n        System.out.println(""a"");\n        continue;\n      }\n      StringBuilder sb = new StringBuilder("""");\n      if(n%2==1) {\n        sb.append(""z"");\n      }\n      for(int i =0;i<n/2-1;i++) {\n        sb.append(""a"");\n      }\n      sb.append(""b"");\n      for(int i =0;i<n/2;i++) {\n        sb.append(""a"");\n      }\n      System.out.println(sb.toString());\n    }\n  }\n}","constructive algorithms,greedy,strings"
"import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class I {\n\n	static final int MOD = 998244353;\n\n	static int add(int a, int b) {\n		int res = a + b;\n		return res >= MOD ? res - MOD : res;\n	}\n\n	static int sub(int a, int b) {\n		int res = a - b;\n		return res < 0 ? res + MOD : res;\n	}\n\n	static int mul(int a, int b) {\n		int res = (int) ((long) a * b % MOD);\n		return res < 0 ? res + MOD : res;\n	}\n\n	static List<Item> pair(Item a, Item b) {\n		List<Item> res = new ArrayList<>();\n		res.add(a);\n		res.add(b);\n		return res;\n	}\n\n	static abstract class Item {\n\n		boolean haveIn, haveOut;\n		abstract void processPresence(List<Integer> elements);\n		abstract Item process(int bound);\n		abstract int count();\n	}\n\n	static class Person extends Item {\n		final int index;\n\n		Person(int index) {\n			this.index = index;\n		}\n\n		void processPresence(List<Integer> elements) {\n			boolean have = false;\n			for (int i: elements) {\n				if (i == index) {\n					have = true;\n					break;\n				}\n			}\n			haveIn = have;\n			haveOut = !have;\n		}\n\n		Item process(int bound) {\n			return this;\n		}\n\n		int count() {\n			return 1;\n		}\n\n		public String toString() {\n			return Integer.toString(index);\n		}\n	}\n\n	static abstract class MultiItem extends Item {\n		final List<Item> contents;\n\n		MultiItem(List<Item> contents) {\n			this.contents = contents;\n		}\n\n		void processPresence(List<Integer> elements) {\n			haveIn = haveOut = false;\n			for (Item i: contents) {\n				i.processPresence(elements);\n				haveIn |= i.haveIn;\n				haveOut |= i.haveOut;\n			}\n		}\n	}\n\n	static class Group extends MultiItem {\n\n		Group(List<Item> contents) {\n			super(contents);\n		}\n\n		static Item make(List<Item> items) {\n			return items.size() == 1 ? items.get(0) : new Group(items);\n		}\n\n		Item process(int bound) {\n			List<Item> full = new ArrayList<>(), partial = new ArrayList<>(), none = new ArrayList<>();\n			for (Item i: contents) {\n				if (i.haveIn) {\n					if (i.haveOut) {\n						partial.add(i);\n					} else {\n						full.add(i);\n					}\n				} else {\n					none.add(i);\n				}\n			}\n			switch (partial.size()) {\n			case 0:\n			{\n				if (full.isEmpty() || none.isEmpty()) {\n					return this;\n				}\n				Item fullItem = Group.make(full);\n				if (bound == 0) {\n					none.add(fullItem);\n					return new Group(none);\n				} else {\n					Item noneItem = Group.make(none);\n					return new Sequence(bound > 0 ? pair(fullItem, noneItem) : pair(noneItem, fullItem));\n				}\n			}\n			case 1:\n			{\n				Item p = partial.get(0);\n				if (bound == 0) {\n					if (full.isEmpty()) {\n						p = p.process(0);\n						if (p == null) {\n							return null;\n						}\n						none.add(p);\n						return new Group(none);\n					} else {\n						p = p.process(1);\n						if (p == null) {\n							return null;\n						}\n						List<Item> pi = new ArrayList<>(((Sequence) p).contents);\n						pi.add(0, Group.make(full));\n						none.add(new Sequence(pi));\n						return Group.make(none);\n					}\n				} else {\n					p = p.process(bound);\n					if (p == null) {\n						return null;\n					}\n					List<Item> res = new ArrayList<>();\n					if (!full.isEmpty()) {\n						res.add(Group.make(full));\n					}\n					List<Item> els = ((Sequence) p).contents;\n					if (bound > 0) {\n						res.addAll(els);\n					} else {\n						res.addAll(0, els);\n					}\n					if (!none.isEmpty()) {\n						if (bound > 0) {\n							res.add(Group.make(none));\n						} else {\n							res.add(0, Group.make(none));\n						}\n					}\n					return new Sequence(res);\n				}\n			}\n			case 2:\n			{\n				if (bound != 0) {\n					return null;\n				}\n				Item p1 = partial.get(0).process(-1), p2 = partial.get(1).process(1);\n				if (p1 == null || p2 == null) {\n					return null;\n				}\n				List<Item> sres = new ArrayList<>();\n				sres.addAll(((Sequence) p1).contents);\n				if (!full.isEmpty()) {\n					sres.add(Group.make(full));\n				}\n				sres.addAll(((Sequence) p2).contents);\n				none.add(new Sequence(sres));\n				return Group.make(none);\n			}\n			default:\n				return null;\n			}\n		}\n\n		int count() {\n			int res = 1;\n			for (int i = 0; i < contents.size(); i++) {\n				res = mul(mul(res, i + 1), contents.get(i).count());\n			}\n			return res;\n		}\n\n		public String toString() {\n			StringBuilder sb = new StringBuilder();\n			sb.append('{');\n			for (int i = 0; i < contents.size(); i++) {\n				if (i != 0) {\n					sb.append("", "");\n				}\n				sb.append(contents.get(i).toString());\n			}\n			sb.append('}');\n			return sb.toString();\n		}\n	}\n\n	static class Sequence extends MultiItem {\n\n		Sequence(List<Item> contents) {\n			super(contents);\n		}\n\n		Item process(int bound) {\n			List<Item> els = new ArrayList<>(contents);\n			int n = els.size();\n			int p1 = 0;\n			while (p1 < n && !els.get(p1).haveIn) {\n				++p1;\n			}\n			int p2 = p1;\n			while (p2 < n && els.get(p2).haveIn) {\n				++p2;\n			}\n			for (int i = 0; i < n; i++) {\n				Item ii = els.get(i);\n				if (ii.haveIn != (i >= p1 && i < p2)) {\n					return null;\n				}\n				if (i > p1 && i < p2 - 1 && ii.haveOut) {\n					return null;\n				}\n			}\n			if (!els.get(p1).haveOut && !els.get(p2 - 1).haveOut && (p1 == 0 || bound <= 0) && (p2 == n || bound >= 0)) {\n				return this;\n			}\n			if (p2 == p1 + 1) {\n				if (bound == 0) {\n					Item ni = els.get(p1).process(0);\n					if (ni == null) {\n						return null;\n					}\n					els.set(p1, ni);\n					return new Sequence(els);\n				} else if (p1 != 0 && p1 != n - 1) {\n					return null;\n				} else {\n					if ((p1 == 0) != (bound > 0)) {\n						Collections.reverse(els);\n						p1 = n - p1 - 1;\n					}\n					if (els.get(p1).haveOut) {\n						Item ni = els.get(p1).process(bound);\n						if (ni == null) {\n							return null;\n						}\n						els.remove(p1);\n						els.addAll(p1, ((Sequence) ni).contents);\n					}\n					return new Sequence(els);\n				}\n			}\n			if (bound != 0) {\n				boolean bad1 = p1 > 0 || els.get(p1).haveOut;\n				boolean bad2 = p2 < n || els.get(p2 - 1).haveOut;\n				if (bad1 && bad2) {\n					return null;\n				}\n				if ((bound > 0 && bad1) || (bound < 0 && bad2)) {\n					Collections.reverse(els);\n					int t = p1;\n					p1 = n - p2;\n					p2 = n - t;\n				}\n			}\n			if (els.get(p1).haveOut) {\n				Item ni = els.get(p1).process(-1);\n				if (ni == null) {\n					return null;\n				}\n				els.remove(p1);\n				els.addAll(p1, ((Sequence) ni).contents);\n				p2 += ((Sequence) ni).contents.size() - 1;\n			}\n			if (els.get(p2 - 1).haveOut) {\n				Item ni = els.get(p2 - 1).process(1);\n				if (ni == null) {\n					return null;\n				}\n				els.remove(p2 - 1);\n				els.addAll(p2 - 1, ((Sequence) ni).contents);\n			}\n			return new Sequence(els);\n		}\n\n		int count() {\n			int res = 2;\n			for (int i = 0; i < contents.size(); i++) {\n				res = mul(res, contents.get(i).count());\n			}\n			return res;\n		}\n\n		public String toString() {\n			StringBuilder sb = new StringBuilder();\n			sb.append('[');\n			for (int i = 0; i < contents.size(); i++) {\n				if (i != 0) {\n					sb.append("", "");\n				}\n				sb.append(contents.get(i).toString());\n			}\n			sb.append(']');\n			return sb.toString();\n		}\n	}\n\n	static void solve() throws Exception {\n		int n = scanInt(), m = scanInt();\n		List<Item> preRoot = new ArrayList<>();\n		for (int i = 0; i < n; i++) {\n			preRoot.add(new Person(i));\n		}\n		Item root = Group.make(preRoot);\n		for (int i = 0; i < m; i++) {\n			List<Integer> cur = new ArrayList<>();\n			int q = scanInt();\n			for (int j = 0; j < q; j++) {\n				cur.add(scanInt() - 1);\n			}\n			root.processPresence(cur);\n			root = root.process(0);\n			if (root == null) {\n				out.print(0);\n				return;\n			}\n		}\n		out.print(root.count());\n	}\n\n	static int scanInt() throws IOException {\n		return parseInt(scanString());\n	}\n\n	static long scanLong() throws IOException {\n		return parseLong(scanString());\n	}\n\n	static String scanString() throws IOException {\n		while (tok == null || !tok.hasMoreTokens()) {\n			tok = new StringTokenizer(in.readLine());\n		}\n		return tok.nextToken();\n	}\n\n	static BufferedReader in;\n	static PrintWriter out;\n	static StringTokenizer tok;\n\n	public static void main(String[] args) {\n		try {\n			in = new BufferedReader(new InputStreamReader(System.in));\n			out = new PrintWriter(System.out);\n			solve();\n			in.close();\n			out.close();\n		} catch (Throwable e) {\n			e.printStackTrace();\n			exit(1);\n		}\n	}\n}","dfs and similar,math"
"import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class cfGlobal15I {\n	\n	static final int P = 998244353;\n	\n	static PQNode[] collect(PQNode[] arr, int whatStatus) {\n		int sz = 0;\n		for (PQNode v : arr) {\n			if (v.status == whatStatus) {\n				sz++;\n			}\n		}\n\n		PQNode[] ret = new PQNode[sz];\n		int ptr = 0;\n		for (PQNode v : arr) {\n			if (v.status == whatStatus) {\n				ret[ptr++] = v;\n			}\n		}\n\n		return ret;\n	}\n\n	static PQNode makeNode(PQNode[] arr, int whatType) {\n		if (arr.length == 0) {\n			return null;\n		}\n		if (arr.length == 1) {\n			return arr[0];\n		}\n		if (arr.length == 2) {\n			whatType = PQNode.Q_NODE;\n		}\n		return new PQNode(whatType, arr);\n	}\n\n	static <T> void fullCopy(T[] src, T[] dest, int destPos) {\n		System.arraycopy(src, 0, dest, destPos, src.length);\n	}\n\n	static PQNode[] appendFirst(PQNode v, PQNode[] arr) {\n		if (v == null) {\n			return arr;\n		}\n		PQNode[] ret = new PQNode[arr.length + 1];\n		ret[0] = v;\n		fullCopy(arr, ret, 1);\n		return ret;\n	}\n\n	static PQNode[] appendLast(PQNode v, PQNode[] arr) {\n		if (v == null) {\n			return arr;\n		}\n		PQNode[] ret = new PQNode[arr.length + 1];\n		fullCopy(arr, ret, 0);\n		ret[arr.length] = v;\n		return ret;\n	}\n\n	static PQNode[] concat(PQNode[] arr1, PQNode[] arr2) {\n		PQNode[] ret = new PQNode[arr1.length + arr2.length];\n		fullCopy(arr1, ret, 0);\n		fullCopy(arr2, ret, arr1.length);\n		return ret;\n	}\n\n	static <T> void reverse(T[] a) {\n		for (int i = 0, j = a.length - 1; i < j; i++, j--) {\n			T tmp = a[i];\n			a[i] = a[j];\n			a[j] = tmp;\n		}\n	}\n\n	static class PQNode {\n		static final int P_NODE = -1;\n		static final int Q_NODE = -2;\n\n		/**\n		 * < 0 if P or Q node <br>\n		 * otherwise this node is leaf and type is number of element\n		 */\n		int type;\n		PQNode[] child;\n\n		public PQNode(int type, PQNode[] child) {\n			this.type = type;\n			this.child = child;\n		}\n\n		static final int EMPTY = 0;\n		static final int FULL = 1;\n		static final int PARTIAL = 2;\n		static final int CONTAINS_ALL = 3;\n		/**\n		 * see above for possible values <br>\n		 * in case of partial, first children are in current query, then not\n		 */\n		int status;\n\n		/**\n		 * number of leafs from current query in this subtree\n		 */\n		int count;\n\n		PQNode dfs(boolean[] b, int allQry) {\n\n			if (type >= 0) {\n				status = b[type] ? FULL : EMPTY;\n				count = b[type] ? 1 : 0;\n				return this;\n			}\n\n			count = 0;\n\n			boolean allFull = true;\n			boolean allEmpty = true;\n			int cntPartial = 0;\n			int[] idxPartial = new int[2];\n\n			for (int i = 0; i < child.length; i++) {\n				child[i] = child[i].dfs(b, allQry);\n				if (child[i] == null) {\n					return null;\n				}\n			}\n\n			for (int i = 0; i < child.length; i++) {\n				PQNode v = child[i];\n\n				if (v.status == CONTAINS_ALL) {\n					status = CONTAINS_ALL;\n					return this;\n				}\n				allFull &= v.status == FULL;\n				allEmpty &= v.status == EMPTY;\n				if (v.status == PARTIAL) {\n					if (cntPartial == 2) {\n						return null;\n					}\n					idxPartial[cntPartial++] = i;\n				}\n				count += v.count;\n			}\n\n			boolean doesContainAll = count == allQry;\n\n			if (allFull) {\n				status = FULL;\n				return this;\n			}\n\n			if (allEmpty) {\n				status = EMPTY;\n				return this;\n			}\n\n			if (cntPartial <= 1 && type == P_NODE && doesContainAll) {\n				PQNode[] fulls = collect(child, FULL);\n				PQNode[] emptys = collect(child, EMPTY);\n\n				PQNode fullNode = makeNode(fulls, P_NODE);\n\n				PQNode fullAndPartial;\n				if (cntPartial == 0) {\n					fullAndPartial = fullNode;\n				} else {\n					PQNode[] arr = appendFirst(fullNode,\n							child[idxPartial[0]].child);\n					fullAndPartial = makeNode(arr, Q_NODE);\n				}\n\n				PQNode[] arr = appendFirst(fullAndPartial, emptys);\n				PQNode ret = makeNode(arr, P_NODE);\n				ret.status = CONTAINS_ALL;\n				return ret;\n			}\n\n			if (cntPartial <= 1 && type == P_NODE && !doesContainAll) {\n				PQNode[] fulls = collect(child, FULL);\n				PQNode[] emptys = collect(child, EMPTY);\n\n				PQNode full = makeNode(fulls, P_NODE);\n				if (full != null) {\n					full.status = FULL;\n				}\n				PQNode empty = makeNode(emptys, P_NODE);\n				if (empty != null) {\n					empty.status = EMPTY;\n				}\n				\n				PQNode ret;\n				if (cntPartial == 1) {\n					PQNode[] arr = appendFirst(full,\n							appendLast(empty, child[idxPartial[0]].child));\n					ret = makeNode(arr, Q_NODE);\n				} else {\n					ret = makeNode(new PQNode[] { full, empty }, Q_NODE);\n				}\n				ret.count = count;\n				ret.status = PARTIAL;\n				return ret;\n			}\n\n			if (cntPartial == 2 && type == P_NODE && doesContainAll) {\n				PQNode[] fulls = collect(child, FULL);\n				PQNode[] emptys = collect(child, EMPTY);\n\n				PQNode fullNode = makeNode(fulls, P_NODE);\n\n				reverse(child[idxPartial[0]].child);\n\n				PQNode[] tmp = appendLast(fullNode, child[idxPartial[0]].child);\n				PQNode fullAndPartial = makeNode(\n						concat(tmp, child[idxPartial[1]].child), Q_NODE);\n\n				PQNode[] arr = appendFirst(fullAndPartial, emptys);\n				PQNode ret = makeNode(arr, P_NODE);\n				ret.status = CONTAINS_ALL;\n				return ret;\n			}\n			\n			if (type == Q_NODE) {\n				int size = child.length;\n				for (int i = 0; i < cntPartial; i++) {\n					size += child[idxPartial[i]].child.length - 1;\n				}\n				\n				PQNode[] arr = new PQNode[size];\n				int ptr = 0;\n				\n				boolean firstPartial = true;\n				for (int i = 0; i< child.length; i++) {\n					PQNode v = child[i];\n					if (v.status == PARTIAL) { \n						\n						boolean shouldRev;\n						if (cntPartial == 1) {\n							if (i == 0) {\n								shouldRev = child[i + 1].status == FULL;\n							} else {\n								shouldRev = child[i - 1].status == EMPTY;\n							}\n						} else {\n							shouldRev = firstPartial;\n							firstPartial = !firstPartial;\n						}\n						\n						if (shouldRev) {\n							reverse(v.child);\n						}\n						\n						for (PQNode u : v.child) {\n							arr[ptr++] = u;\n						}\n					} else {\n						arr[ptr++] = v;\n					}\n				}\n				\n				if (arr[arr.length - 1].status == FULL) {\n					reverse(arr);\n				}\n				\n				ptr = arr.length - 1;\n				while (ptr >= 0 && arr[ptr].status == EMPTY) {\n					ptr--;\n				}\n				while (ptr >= 0 && arr[ptr].status == FULL) {\n					ptr--;\n				}\n				\n				if (ptr == -1) {\n					PQNode ret = makeNode(arr, Q_NODE);\n					ret.count = count;\n					ret.status = doesContainAll ? CONTAINS_ALL : PARTIAL;\n					return ret;\n				}\n				\n				while (ptr >= 0 && arr[ptr].status == EMPTY) {\n					ptr--;\n				}\n				\n				if (ptr == -1 && doesContainAll) {\n					PQNode ret = makeNode(arr, Q_NODE);\n					ret.status = CONTAINS_ALL;\n					return ret;\n				}\n			}\n			\n			return null;\n		}\n\n		// not necessary methods below\n\n		void genRepr(StringBuilder sb) {\n			if (type >= 0) {\n				sb.append(type + "" "");\n				return;\n			}\n			sb.append(type == P_NODE ? ""["" : ""("");\n			for (PQNode v : child) {\n				v.genRepr(sb);\n			}\n			sb.append(type == P_NODE ? ""]"" : "")"");\n		}\n		\n		void getOrder(List<Integer> ret) {\n			if (type >= 0) {\n				ret.add(type);\n				return;\n			}\n			for (PQNode v : child) {\n				v.getOrder(ret);\n			}\n		}\n		\n		void getCounts(int[] a) {\n			if (type >= 0) {\n				return;\n			}\n			if (type == P_NODE) {\n				a[child.length]++;\n			} else {\n				a[2]++;\n			}\n			for (PQNode v : child) {\n				v.getCounts(a);\n			}\n		}\n	}\n\n	static class PQTree {\n		/**\n		 * null if there are no permutations\n		 */\n		PQNode root;\n		int n;\n\n		public PQTree(int n) {\n			this.n = n;\n			PQNode[] arr = new PQNode[n];\n			for (int i = 0; i < n; i++) {\n				arr[i] = new PQNode(i, null);\n			}\n			root = makeNode(arr, PQNode.P_NODE);\n		}\n\n		void update(boolean[] b) {\n			if (root == null) {\n				return;\n			}\n			int cnt = 0;\n			for (boolean flag : b) {\n				cnt += flag ? 1 : 0;\n			}\n			if (cnt <= 1 || cnt == b.length) {\n				return;\n			}\n			root = root.dfs(b, cnt);\n		}\n\n		// not necessary methods below\n\n		@Override\n		public String toString() {\n			if (root == null) {\n				return ""null"";\n			}\n			StringBuilder sb = new StringBuilder();\n			root.genRepr(sb);\n			return sb.toString();\n		}\n		\n		List<Integer> getOrder() {\n			List<Integer> ret = new ArrayList<>(n);\n			root.getOrder(ret);\n			return ret;\n		}\n		\n		int[] getCounts() {\n			int[] ret = new int[n + 1];\n			root.getCounts(ret);\n			return ret;\n		}\n	}\n\n	void submit() {\n		int n = nextInt();\n		int m = nextInt();\n		PQTree pq = new PQTree(n);\n		for (int i=  0;i < m; i++) {\n			boolean[] b = new boolean[n];\n			int k = nextInt();\n			while (k-- > 0) {\n				b[nextInt() - 1] = true;\n			}\n			pq.update(b);\n		}\n		\n		int[] fact = new int[n + 1];\n		fact[0] = 1;\n		for (int i = 1; i < fact.length; i++) {\n			fact[i] = (int)((long)fact[i - 1] * i % P);\n		}\n		\n		if (pq.root == null) {\n			out.println(0);\n		} else {\n			int ret = 1;\n			int[] cnt = pq.getCounts();\n			for (int i = 1; i < cnt.length; i++) {\n				for (int j = 0; j < cnt[i]; j++) {\n					ret = (int)((long)ret * fact[i] % P);\n				}\n			}\n			out.println(ret);\n		}\n	}\n\n	void test() {\n\n	}\n\n	void stress() {\n		for (int tst = 0;; tst++) {\n			if (false) {\n				throw new AssertionError();\n			}\n			System.err.println(tst);\n		}\n	}\n\n	cfGlobal15I() throws IOException {\n		is = System.in;\n		out = new PrintWriter(System.out);\n		submit();\n		// stress();\n		// test();\n		out.close();\n	}\n\n	static final Random rng = new Random();\n	static final int C = 5;\n\n	static int rand(int l, int r) {\n		return l + rng.nextInt(r - l + 1);\n	}\n\n	public static void main(String[] args) throws IOException {\n		new cfGlobal15I();\n	}\n\n	private InputStream is;\n	PrintWriter out;\n\n	private byte[] buf = new byte[1 << 14];\n	private int bufSz = 0, bufPtr = 0;\n\n	private int readByte() {\n		if (bufSz == -1)\n			throw new RuntimeException(""Reading past EOF"");\n		if (bufPtr >= bufSz) {\n			bufPtr = 0;\n			try {\n				bufSz = is.read(buf);\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n			if (bufSz <= 0)\n				return -1;\n		}\n		return buf[bufPtr++];\n	}\n\n	private boolean isTrash(int c) {\n		return c < 33 || c > 126;\n	}\n\n	private int skip() {\n		int b;\n		while ((b = readByte()) != -1 && isTrash(b))\n			;\n		return b;\n	}\n\n	String nextToken() {\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b)) {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	String nextString() {\n		int b = readByte();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b) || b == ' ') {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	double nextDouble() {\n		return Double.parseDouble(nextToken());\n	}\n\n	char nextChar() {\n		return (char) skip();\n	}\n\n	int nextInt() {\n		int ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n\n	long nextLong() {\n		long ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n}","dfs and similar,math"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.nio.charset.StandardCharsets;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            IOrganizingAMusicFestival solver = new IOrganizingAMusicFestival();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class IOrganizingAMusicFestival {\n        int mod = 998244353;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.ri();\n            int m = in.ri();\n            PQTree pqt = new PQTree(n);\n            boolean[] set = new boolean[n];\n            for (int i = 0; i < m; i++) {\n                Arrays.fill(set, false);\n                int q = in.ri();\n                for (int j = 0; j < q; j++) {\n                    set[in.ri() - 1] = true;\n                }\n                pqt.update(set);\n            }\n            if (!pqt.possible()) {\n                out.println(0);\n                return;\n            }\n            int[] res = pqt.getCounts();\n            Factorial fact = new Factorial(n, mod);\n            long ans = 1;\n            for (int i = 0; i < res.length; i++) {\n                for (int j = 0; j < res[i]; j++) {\n                    ans = ans * fact.fact(i) % mod;\n                }\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class PQTree {\n        PQTree.PQNode root;\n        int n;\n\n        public boolean possible() {\n            return root != null;\n        }\n\n        public PQTree(int n) {\n            this.n = n;\n            PQTree.PQNode[] arr = new PQTree.PQNode[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = new PQTree.PQNode(i, null);\n            }\n            root = makeNode(arr, PQTree.PQNode.P_NODE);\n        }\n\n        public void update(boolean[] b) {\n            if (root == null) {\n                return;\n            }\n            int cnt = 0;\n            for (boolean flag : b) {\n                cnt += flag ? 1 : 0;\n            }\n            if (cnt <= 1 || cnt == b.length) {\n                return;\n            }\n            root = root.dfs(b, cnt);\n        }\n\n        public String toString() {\n            if (root == null) {\n                return ""null"";\n            }\n            StringBuilder sb = new StringBuilder();\n            root.genRepr(sb);\n            return sb.toString();\n        }\n\n        public int[] getCounts() {\n            assert possible();\n            int[] ret = new int[n + 1];\n            root.getCounts(ret);\n            return ret;\n        }\n\n        static PQTree.PQNode[] collect(PQTree.PQNode[] arr, int whatStatus) {\n            int sz = 0;\n            for (PQTree.PQNode v : arr) {\n                if (v.status == whatStatus) {\n                    sz++;\n                }\n            }\n\n            PQTree.PQNode[] ret = new PQTree.PQNode[sz];\n            int ptr = 0;\n            for (PQTree.PQNode v : arr) {\n                if (v.status == whatStatus) {\n                    ret[ptr++] = v;\n                }\n            }\n\n            return ret;\n        }\n\n        static PQTree.PQNode makeNode(PQTree.PQNode[] arr, int whatType) {\n            if (arr.length == 0) {\n                return null;\n            }\n            if (arr.length == 1) {\n                return arr[0];\n            }\n            if (arr.length == 2) {\n                whatType = PQTree.PQNode.Q_NODE;\n            }\n            return new PQTree.PQNode(whatType, arr);\n        }\n\n        static <T> void fullCopy(T[] src, T[] dest, int destPos) {\n            System.arraycopy(src, 0, dest, destPos, src.length);\n        }\n\n        static PQTree.PQNode[] appendFirst(PQTree.PQNode v, PQTree.PQNode[] arr) {\n            if (v == null) {\n                return arr;\n            }\n            PQTree.PQNode[] ret = new PQTree.PQNode[arr.length + 1];\n            ret[0] = v;\n            fullCopy(arr, ret, 1);\n            return ret;\n        }\n\n        static PQTree.PQNode[] appendLast(PQTree.PQNode v, PQTree.PQNode[] arr) {\n            if (v == null) {\n                return arr;\n            }\n            PQTree.PQNode[] ret = new PQTree.PQNode[arr.length + 1];\n            fullCopy(arr, ret, 0);\n            ret[arr.length] = v;\n            return ret;\n        }\n\n        static PQTree.PQNode[] concat(PQTree.PQNode[] arr1, PQTree.PQNode[] arr2) {\n            PQTree.PQNode[] ret = new PQTree.PQNode[arr1.length + arr2.length];\n            fullCopy(arr1, ret, 0);\n            fullCopy(arr2, ret, arr1.length);\n            return ret;\n        }\n\n        static <T> void reverse(T[] a) {\n            for (int i = 0, j = a.length - 1; i < j; i++, j--) {\n                T tmp = a[i];\n                a[i] = a[j];\n                a[j] = tmp;\n            }\n        }\n\n        static class PQNode {\n            static final int P_NODE = -1;\n            static final int Q_NODE = -2;\n            int type;\n            PQTree.PQNode[] child;\n            static final int EMPTY = 0;\n            static final int FULL = 1;\n            static final int PARTIAL = 2;\n            static final int CONTAINS_ALL = 3;\n            int status;\n            int count;\n\n            public PQNode(int type, PQTree.PQNode[] child) {\n                this.type = type;\n                this.child = child;\n            }\n\n            PQTree.PQNode dfs(boolean[] b, int allQry) {\n\n                if (type >= 0) {\n                    status = b[type] ? FULL : EMPTY;\n                    count = b[type] ? 1 : 0;\n                    return this;\n                }\n\n                count = 0;\n\n                boolean allFull = true;\n                boolean allEmpty = true;\n                int cntPartial = 0;\n                int[] idxPartial = new int[2];\n\n                for (int i = 0; i < child.length; i++) {\n                    child[i] = child[i].dfs(b, allQry);\n                    if (child[i] == null) {\n                        return null;\n                    }\n                }\n\n                for (int i = 0; i < child.length; i++) {\n                    PQTree.PQNode v = child[i];\n\n                    if (v.status == CONTAINS_ALL) {\n                        status = CONTAINS_ALL;\n                        return this;\n                    }\n                    allFull &= v.status == FULL;\n                    allEmpty &= v.status == EMPTY;\n                    if (v.status == PARTIAL) {\n                        if (cntPartial == 2) {\n                            return null;\n                        }\n                        idxPartial[cntPartial++] = i;\n                    }\n                    count += v.count;\n                }\n\n                boolean doesContainAll = count == allQry;\n\n                if (allFull) {\n                    status = FULL;\n                    return this;\n                }\n\n                if (allEmpty) {\n                    status = EMPTY;\n                    return this;\n                }\n\n                if (cntPartial <= 1 && type == P_NODE && doesContainAll) {\n                    PQTree.PQNode[] fulls = collect(child, FULL);\n                    PQTree.PQNode[] emptys = collect(child, EMPTY);\n\n                    PQTree.PQNode fullNode = makeNode(fulls, P_NODE);\n\n                    PQTree.PQNode fullAndPartial;\n                    if (cntPartial == 0) {\n                        fullAndPartial = fullNode;\n                    } else {\n                        PQTree.PQNode[] arr = appendFirst(fullNode,\n                                child[idxPartial[0]].child);\n                        fullAndPartial = makeNode(arr, Q_NODE);\n                    }\n\n                    PQTree.PQNode[] arr = appendFirst(fullAndPartial, emptys);\n                    PQTree.PQNode ret = makeNode(arr, P_NODE);\n                    ret.status = CONTAINS_ALL;\n                    return ret;\n                }\n\n                if (cntPartial <= 1 && type == P_NODE && !doesContainAll) {\n                    PQTree.PQNode[] fulls = collect(child, FULL);\n                    PQTree.PQNode[] emptys = collect(child, EMPTY);\n\n                    PQTree.PQNode full = makeNode(fulls, P_NODE);\n                    if (full != null) {\n                        full.status = FULL;\n                    }\n                    PQTree.PQNode empty = makeNode(emptys, P_NODE);\n                    if (empty != null) {\n                        empty.status = EMPTY;\n                    }\n\n                    PQTree.PQNode ret;\n                    if (cntPartial == 1) {\n                        PQTree.PQNode[] arr = appendFirst(full,\n                                appendLast(empty, child[idxPartial[0]].child));\n                        ret = makeNode(arr, Q_NODE);\n                    } else {\n                        ret = makeNode(new PQTree.PQNode[]{full, empty}, Q_NODE);\n                    }\n                    ret.count = count;\n                    ret.status = PARTIAL;\n                    return ret;\n                }\n\n                if (cntPartial == 2 && type == P_NODE && doesContainAll) {\n                    PQTree.PQNode[] fulls = collect(child, FULL);\n                    PQTree.PQNode[] emptys = collect(child, EMPTY);\n\n                    PQTree.PQNode fullNode = makeNode(fulls, P_NODE);\n\n                    reverse(child[idxPartial[0]].child);\n\n                    PQTree.PQNode[] tmp = appendLast(fullNode, child[idxPartial[0]].child);\n                    PQTree.PQNode fullAndPartial = makeNode(\n                            concat(tmp, child[idxPartial[1]].child), Q_NODE);\n\n                    PQTree.PQNode[] arr = appendFirst(fullAndPartial, emptys);\n                    PQTree.PQNode ret = makeNode(arr, P_NODE);\n                    ret.status = CONTAINS_ALL;\n                    return ret;\n                }\n\n                if (type == Q_NODE) {\n                    int size = child.length;\n                    for (int i = 0; i < cntPartial; i++) {\n                        size += child[idxPartial[i]].child.length - 1;\n                    }\n\n                    PQTree.PQNode[] arr = new PQTree.PQNode[size];\n                    int ptr = 0;\n\n                    boolean firstPartial = true;\n                    for (int i = 0; i < child.length; i++) {\n                        PQTree.PQNode v = child[i];\n                        if (v.status == PARTIAL) {\n\n                            boolean shouldRev;\n                            if (cntPartial == 1) {\n                                if (i == 0) {\n                                    shouldRev = child[i + 1].status == FULL;\n                                } else {\n                                    shouldRev = child[i - 1].status == EMPTY;\n                                }\n                            } else {\n                                shouldRev = firstPartial;\n                                firstPartial = !firstPartial;\n                            }\n\n                            if (shouldRev) {\n                                reverse(v.child);\n                            }\n\n                            for (PQTree.PQNode u : v.child) {\n                                arr[ptr++] = u;\n                            }\n                        } else {\n                            arr[ptr++] = v;\n                        }\n                    }\n\n                    if (arr[arr.length - 1].status == FULL) {\n                        reverse(arr);\n                    }\n\n                    ptr = arr.length - 1;\n                    while (ptr >= 0 && arr[ptr].status == EMPTY) {\n                        ptr--;\n                    }\n                    while (ptr >= 0 && arr[ptr].status == FULL) {\n                        ptr--;\n                    }\n\n                    if (ptr == -1) {\n                        PQTree.PQNode ret = makeNode(arr, Q_NODE);\n                        ret.count = count;\n                        ret.status = doesContainAll ? CONTAINS_ALL : PARTIAL;\n                        return ret;\n                    }\n\n                    while (ptr >= 0 && arr[ptr].status == EMPTY) {\n                        ptr--;\n                    }\n\n                    if (ptr == -1 && doesContainAll) {\n                        PQTree.PQNode ret = makeNode(arr, Q_NODE);\n                        ret.status = CONTAINS_ALL;\n                        return ret;\n                    }\n                }\n\n                return null;\n            }\n\n            void genRepr(StringBuilder sb) {\n                if (type >= 0) {\n                    sb.append(type + "" "");\n                    return;\n                }\n                sb.append(type == P_NODE ? ""["" : ""("");\n                for (PQTree.PQNode v : child) {\n                    v.genRepr(sb);\n                }\n                sb.append(type == P_NODE ? ""]"" : "")"");\n            }\n\n            void getCounts(int[] a) {\n                if (type >= 0) {\n                    return;\n                }\n                if (type == P_NODE) {\n                    a[child.length]++;\n                } else {\n                    a[2]++;\n                }\n                for (PQTree.PQNode v : child) {\n                    v.getCounts(a);\n                }\n            }\n\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 32 << 10;\n        private OutputStream writer;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n        private static Field stringBuilderValueField;\n        private char[] charBuf = new char[THRESHOLD * 2];\n        private byte[] byteBuf = new byte[THRESHOLD * 2];\n\n        static {\n            try {\n                stringBuilderValueField = StringBuilder.class.getSuperclass().getDeclaredField(""value"");\n                stringBuilderValueField.setAccessible(true);\n            } catch (Exception e) {\n                stringBuilderValueField = null;\n            }\n            stringBuilderValueField = null;\n        }\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n\n        public FastOutput(OutputStream writer) {\n            this.writer = writer;\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(long c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println(long c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            return append('\n');\n        }\n\n        public FastOutput flush() {\n            try {\n                if (stringBuilderValueField != null) {\n                    try {\n                        byte[] value = (byte[]) stringBuilderValueField.get(cache);\n                        writer.write(value, 0, cache.length());\n                    } catch (Exception e) {\n                        stringBuilderValueField = null;\n                    }\n                }\n                if (stringBuilderValueField == null) {\n                    int n = cache.length();\n                    if (n > byteBuf.length) {\n                        //slow\n                        writer.write(cache.toString().getBytes(StandardCharsets.UTF_8));\n//                writer.append(cache);\n                    } else {\n                        cache.getChars(0, n, charBuf, 0);\n                        for (int i = 0; i < n; i++) {\n                            byteBuf[i] = (byte) charBuf[i];\n                        }\n                        writer.write(byteBuf, 0, n);\n                    }\n                }\n                writer.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                writer.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Factorial {\n        int[] fact;\n        int[] inv;\n        int mod;\n\n        public Factorial(int[] fact, int[] inv, int mod) {\n            this.mod = mod;\n            this.fact = fact;\n            this.inv = inv;\n            fact[0] = inv[0] = 1;\n            int n = Math.min(fact.length, mod);\n            for (int i = 1; i < n; i++) {\n                fact[i] = i;\n                fact[i] = (int) ((long) fact[i] * fact[i - 1] % mod);\n            }\n            if (n - 1 >= 0) {\n                inv[n - 1] = BigInteger.valueOf(fact[n - 1]).modInverse(BigInteger.valueOf(mod)).intValue();\n            }\n            for (int i = n - 2; i >= 1; i--) {\n                inv[i] = (int) ((long) inv[i + 1] * (i + 1) % mod);\n            }\n        }\n\n        public Factorial(int limit, int mod) {\n            this(new int[Math.min(limit + 1, mod)], new int[Math.min(limit + 1, mod)], mod);\n        }\n\n        public int fact(int n) {\n            if (n >= mod) {\n                return 0;\n            }\n            return fact[n];\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int ri() {\n            return readInt();\n        }\n\n        public int readInt() {\n            boolean rev = false;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                rev = next == '-';\n                next = read();\n            }\n\n            int val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 - next + '0';\n                next = read();\n            }\n\n            return rev ? val : -val;\n        }\n\n    }\n}\n\n","dfs and similar,math"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.nio.charset.StandardCharsets;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n    \n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            IOrganizingAMusicFestival solver = new IOrganizingAMusicFestival();\n            solver.solve(1 , in, out);\n            out.close();\n        }\n    }\n    \n    static class IOrganizingAMusicFestival {\n        int mod = 998244353;\n        \n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.ri();\n            int m = in.ri();\n            PQTree pqt = new PQTree(n);\n            boolean[] set = new boolean[n];\n            for (int i = 0; i < m; i++) {\n                Arrays.fill(set, false);\n                int q = in.ri();\n                for (int j = 0; j < q; j++) {\n                    set[in.ri() - 1] = true;\n                }\n                pqt.update(set);\n            }\n            if (!pqt.possible()) {\n                out.println(0);\n                return;\n            }\n            int[] res = pqt.getCounts();\n            Factorial fact = new Factorial(n, mod);\n            long ans = 1;\n            for (int i = 0; i < res.length; i++) {\n                for (int j = 0; j < res[i]; j++) {\n                    ans = ans * fact.fact(i) % mod;\n                }\n            }\n            out.println(ans);\n        }\n        \n    }\n    \n    static class PQTree {\n        PQTree.PQNode root;\n        int n;\n        \n        public boolean possible() {\n            return root != null;\n        }\n        \n        public PQTree(int n) {\n            this.n = n;\n            PQTree.PQNode[] arr = new PQTree.PQNode[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = new PQTree.PQNode(i, null);\n            }\n            root = makeNode(arr, PQTree.PQNode.P_NODE);\n        }\n        \n        public void update(boolean[] b) {\n            if (root == null) {\n                return;\n            }\n            int cnt = 0;\n            for (boolean flag : b) {\n                cnt += flag ? 1 : 0;\n            }\n            if (cnt <= 1 || cnt == b.length) {\n                return;\n            }\n            root = root.dfs(b, cnt);\n        }\n        \n        public String toString() {\n            if (root == null) {\n                return ""null"";\n            }\n            StringBuilder sb = new StringBuilder();\n            root.genRepr(sb);\n            return sb.toString();\n        }\n        \n        public int[] getCounts() {\n            assert possible();\n            int[] ret = new int[n + 1];\n            root.getCounts(ret);\n            return ret;\n        }\n        \n        static PQTree.PQNode[] collect(PQTree.PQNode[] arr, int whatStatus) {\n            int sz = 0;\n            for (PQTree.PQNode v : arr) {\n                if (v.status == whatStatus) {\n                    sz++;\n                }\n            }\n            \n            PQTree.PQNode[] ret = new PQTree.PQNode[sz];\n            int ptr = 0;\n            for (PQTree.PQNode v : arr) {\n                if (v.status == whatStatus) {\n                    ret[ptr++] = v;\n                }\n            }\n            \n            return ret;\n        }\n        \n        static PQTree.PQNode makeNode(PQTree.PQNode[] arr, int whatType) {\n            if (arr.length == 0) {\n                return null;\n            }\n            if (arr.length == 1) {\n                return arr[0];\n            }\n            if (arr.length == 2) {\n                whatType = PQTree.PQNode.Q_NODE;\n            }\n            return new PQTree.PQNode(whatType, arr);\n        }\n        \n        static <T> void fullCopy(T[] src, T[] dest, int destPos) {\n            System.arraycopy(src, 0, dest, destPos, src.length);\n        }\n        \n        static PQTree.PQNode[] appendFirst(PQTree.PQNode v, PQTree.PQNode[] arr) {\n            if (v == null) {\n                return arr;\n            }\n            PQTree.PQNode[] ret = new PQTree.PQNode[arr.length + 1];\n            ret[0] = v;\n            fullCopy(arr, ret, 1);\n            return ret;\n        }\n        \n        static PQTree.PQNode[] appendLast(PQTree.PQNode v, PQTree.PQNode[] arr) {\n            if (v == null) {\n                return arr;\n            }\n            PQTree.PQNode[] ret = new PQTree.PQNode[arr.length + 1];\n            fullCopy(arr, ret, 0);\n            ret[arr.length] = v;\n            return ret;\n        }\n        \n        static PQTree.PQNode[] concat(PQTree.PQNode[] arr1, PQTree.PQNode[] arr2) {\n            PQTree.PQNode[] ret = new PQTree.PQNode[arr1.length + arr2.length];\n            fullCopy(arr1, ret, 0);\n            fullCopy(arr2, ret, arr1.length);\n            return ret;\n        }\n        \n        static <T> void reverse(T[] a) {\n            for (int i = 0, j = a.length - 1; i < j; i++, j--) {\n                T tmp = a[i];\n                a[i] = a[j];\n                a[j] = tmp;\n            }\n        }\n        \n        static class PQNode {\n            static final int P_NODE = -1;\n            static final int Q_NODE = -2;\n            int type;\n            PQTree.PQNode[] child;\n            static final int EMPTY = 0;\n            static final int FULL = 1;\n            static final int PARTIAL = 2;\n            static final int CONTAINS_ALL = 3;\n            int status;\n            int count;\n            \n            public PQNode(int type, PQTree.PQNode[] child) {\n                this.type = type;\n                this.child = child;\n            }\n            \n            PQTree.PQNode dfs(boolean[] b, int allQry) {\n                \n                if (type >= 0) {\n                    status = b[type] ? FULL : EMPTY;\n                    count = b[type] ? 1 : 0;\n                    return this;\n                }\n                \n                count = 0;\n                \n                boolean allFull = true;\n                boolean allEmpty = true;\n                int cntPartial = 0;\n                int[] idxPartial = new int[2];\n                \n                for (int i = 0; i < child.length; i++) {\n                    child[i] = child[i].dfs(b, allQry);\n                    if (child[i] == null) {\n                        return null;\n                    }\n                }\n                \n                for (int i = 0; i < child.length; i++) {\n                    PQTree.PQNode v = child[i];\n                    \n                    if (v.status == CONTAINS_ALL) {\n                        status = CONTAINS_ALL;\n                        return this;\n                    }\n                    allFull &= v.status == FULL;\n                    allEmpty &= v.status == EMPTY;\n                    if (v.status == PARTIAL) {\n                        if (cntPartial == 2) {\n                            return null;\n                        }\n                        idxPartial[cntPartial++] = i;\n                    }\n                    count += v.count;\n                }\n                \n                boolean doesContainAll = count == allQry;\n                \n                if (allFull) {\n                    status = FULL;\n                    return this;\n                }\n                \n                if (allEmpty) {\n                    status = EMPTY;\n                    return this;\n                }\n                \n                if (cntPartial <= 1 && type == P_NODE && doesContainAll) {\n                    PQTree.PQNode[] fulls = collect(child, FULL);\n                    PQTree.PQNode[] emptys = collect(child, EMPTY);\n                    \n                    PQTree.PQNode fullNode = makeNode(fulls, P_NODE);\n                    \n                    PQTree.PQNode fullAndPartial;\n                    if (cntPartial == 0) {\n                        fullAndPartial = fullNode;\n                    } else {\n                        PQTree.PQNode[] arr = appendFirst(fullNode,\n                        child[idxPartial[0]].child);\n                        fullAndPartial = makeNode(arr, Q_NODE);\n                    }\n                    \n                    PQTree.PQNode[] arr = appendFirst(fullAndPartial, emptys);\n                    PQTree.PQNode ret = makeNode(arr, P_NODE);\n                    ret.status = CONTAINS_ALL;\n                    return ret;\n                }\n                \n                if (cntPartial <= 1 && type == P_NODE && !doesContainAll) {\n                    PQTree.PQNode[] fulls = collect(child, FULL);\n                    PQTree.PQNode[] emptys = collect(child, EMPTY);\n                    \n                    PQTree.PQNode full = makeNode(fulls, P_NODE);\n                    if (full != null) {\n                        full.status = FULL;\n                    }\n                    PQTree.PQNode empty = makeNode(emptys, P_NODE);\n                    if (empty != null) {\n                        empty.status = EMPTY;\n                    }\n                    \n                    PQTree.PQNode ret;\n                    if (cntPartial == 1) {\n                        PQTree.PQNode[] arr = appendFirst(full,\n                        appendLast(empty, child[idxPartial[0]].child));\n                        ret = makeNode(arr, Q_NODE);\n                    } else {\n                        ret = makeNode(new PQTree.PQNode[]{full, empty}, Q_NODE);\n                    }\n                    ret.count = count;\n                    ret.status = PARTIAL;\n                    return ret;\n                }\n                \n                if (cntPartial == 2 && type == P_NODE && doesContainAll) {\n                    PQTree.PQNode[] fulls = collect(child, FULL);\n                    PQTree.PQNode[] emptys = collect(child, EMPTY);\n                    \n                    PQTree.PQNode fullNode = makeNode(fulls, P_NODE);\n                    \n                    reverse(child[idxPartial[0]].child);\n                    \n                    PQTree.PQNode[] tmp = appendLast(fullNode, child[idxPartial[0]].child);\n                    PQTree.PQNode fullAndPartial = makeNode(\n                    concat(tmp, child[idxPartial[1]].child), Q_NODE);\n                    \n                    PQTree.PQNode[] arr = appendFirst(fullAndPartial, emptys);\n                    PQTree.PQNode ret = makeNode(arr, P_NODE);\n                    ret.status = CONTAINS_ALL;\n                    return ret;\n                }\n                \n                if (type == Q_NODE) {\n                    int size = child.length;\n                    for (int i = 0; i < cntPartial; i++) {\n                        size += child[idxPartial[i]].child.length - 1;\n                    }\n                    \n                    PQTree.PQNode[] arr = new PQTree.PQNode[size];\n                    int ptr = 0;\n                    \n                    boolean firstPartial = true;\n                    for (int i = 0; i < child.length; i++) {\n                        PQTree.PQNode v = child[i];\n                        if (v.status == PARTIAL) {\n                            \n                            boolean shouldRev;\n                            if (cntPartial == 1) {\n                                if (i == 0) {\n                                    shouldRev = child[i + 1].status == FULL;\n                                } else {\n                                    shouldRev = child[i - 1].status == EMPTY;\n                                }\n                            } else {\n                                shouldRev = firstPartial;\n                                firstPartial = !firstPartial;\n                            }\n                            \n                            if (shouldRev) {\n                                reverse(v.child);\n                            }\n                            \n                            for (PQTree.PQNode u : v.child) {\n                                arr[ptr++] = u;\n                            }\n                        } else {\n                            arr[ptr++] = v;\n                        }\n                    }\n                    \n                    if (arr[arr.length - 1].status == FULL) {\n                        reverse(arr);\n                    }\n                    \n                    ptr = arr.length - 1;\n                    while (ptr >= 0 && arr[ptr].status == EMPTY) {\n                        ptr--;\n                    }\n                    while (ptr >= 0 && arr[ptr].status == FULL) {\n                        ptr--;\n                    }\n                    \n                    if (ptr == -1) {\n                        PQTree.PQNode ret = makeNode(arr, Q_NODE);\n                        ret.count = count;\n                        ret.status = doesContainAll ? CONTAINS_ALL : PARTIAL;\n                        return ret;\n                    }\n                    \n                    while (ptr >= 0 && arr[ptr].status == EMPTY) {\n                        ptr--;\n                    }\n                    \n                    if (ptr == -1 && doesContainAll) {\n                        PQTree.PQNode ret = makeNode(arr, Q_NODE);\n                        ret.status = CONTAINS_ALL;\n                        return ret;\n                    }\n                }\n                \n                return null;\n            }\n            \n            void genRepr(StringBuilder sb) {\n                if (type >= 0) {\n                    sb.append(type + "" "");\n                    return;\n                }\n                sb.append(type == P_NODE ? ""["" : ""("");\n                for (PQTree.PQNode v : child) {\n                    v.genRepr(sb);\n                }\n                sb.append(type == P_NODE ? ""]"" : "")"");\n            }\n            \n            void getCounts(int[] a) {\n                if (type >= 0) {\n                    return;\n                }\n                if (type == P_NODE) {\n                    a[child.length]++;\n                } else {\n                    a[2]++;\n                }\n                for (PQTree.PQNode v : child) {\n                    v.getCounts(a);\n                }\n            }\n            \n        }\n        \n    }\n    \n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 32 << 10;\n        private OutputStream writer;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n        private static Field stringBuilderValueField;\n        private char[] charBuf = new char[THRESHOLD * 2];\n        private byte[] byteBuf = new byte[THRESHOLD * 2];\n        \n        static {\n            try {\n                stringBuilderValueField = StringBuilder.class.getSuperclass().getDeclaredField(""value"");\n                stringBuilderValueField.setAccessible(true);\n            } catch (Exception e) {\n                stringBuilderValueField = null;\n            }\n            stringBuilderValueField = null;\n        }\n        \n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n        \n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n        \n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n        \n        public FastOutput(OutputStream writer) {\n            this.writer = writer;\n        }\n        \n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n        \n        public FastOutput append(int c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n        \n        public FastOutput append(long c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n        \n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n        \n        public FastOutput println(long c) {\n            return append(c).println();\n        }\n        \n        public FastOutput println() {\n            return append('\n');\n        }\n        \n        public FastOutput flush() {\n            try {\n                if (stringBuilderValueField != null) {\n                    try {\n                        byte[] value = (byte[]) stringBuilderValueField.get(cache);\n                        writer.write(value, 0, cache.length());\n                    } catch (Exception e) {\n                        stringBuilderValueField = null;\n                    }\n                }\n                if (stringBuilderValueField == null) {\n                    int n = cache.length();\n                    if (n > byteBuf.length) {\n                        //slow\n                        writer.write(cache.toString().getBytes(StandardCharsets.UTF_8));\n                        //                writer.append(cache);\n                    } else {\n                        cache.getChars(0, n, charBuf, 0);\n                        for (int i = 0; i < n; i++) {\n                            byteBuf[i] = (byte) charBuf[i];\n                        }\n                        writer.write(byteBuf, 0, n);\n                    }\n                }\n                writer.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n        \n        public void close() {\n            flush();\n            try {\n                writer.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n        \n        public String toString() {\n            return cache.toString();\n        }\n        \n    }\n    \n    static class Factorial {\n        int[] fact;\n        int[] inv;\n        int mod;\n        \n        public Factorial(int[] fact, int[] inv, int mod) {\n            this.mod = mod;\n            this.fact = fact;\n            this.inv = inv;\n            fact[0] = inv[0] = 1;\n            int n = Math.min(fact.length, mod);\n            for (int i = 1; i < n; i++) {\n                fact[i] = i;\n                fact[i] = (int) ((long) fact[i] * fact[i - 1] % mod);\n            }\n            if (n - 1 >= 0) {\n                inv[n - 1] = BigInteger.valueOf(fact[n - 1]).modInverse(BigInteger.valueOf(mod)).intValue();\n            }\n            for (int i = n - 2; i >= 1; i--) {\n                inv[i] = (int) ((long) inv[i + 1] * (i + 1) % mod);\n            }\n        }\n        \n        public Factorial(int limit, int mod) {\n            this(new int[Math.min(limit + 1, mod)], new int[Math.min(limit + 1, mod)], mod);\n        }\n        \n        public int fact(int n) {\n            if (n >= mod) {\n                return 0;\n            }\n            return fact[n];\n        }\n        \n    }\n    \n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n        \n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n        \n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n        \n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n        \n        public int ri() {\n            return readInt();\n        }\n        \n        public int readInt() {\n            boolean rev = false;\n            \n            skipBlank();\n            if (next == '+' || next == '-') {\n                rev = next == '-';\n                next = read();\n            }\n            \n            int val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 - next + '0';\n                next = read();\n            }\n            \n            return rev ? val : -val;\n        }\n        \n    }\n}\n\n","dfs and similar,math"
"import java.io.*;\nimport java.util.*;\npublic class a {\n  public static int n,k,inf=100000000;\n  public static char[] s;\n  public static int[] dp=new int[1<<17];\n  public static int[][] nxt=new int[200005][17];\n        public static void main(String args[])\n        {\n          FastScanner fs=new FastScanner();\n          n=fs.nextInt();\n          k=fs.nextInt();\n          s=fs.next().toCharArray();\n          int lo=0,hi=(n/k),mid;\n          while(lo<=hi)\n          {\n            mid=(lo+hi)/2;\n            if(check(mid))\n              lo=mid+1;\n            else\n              hi=mid-1;\n          }\n          System.out.println(hi);\n        }\n        public static boolean check(int x)\n        {\n          for(int i=0;i<17;i++)\n            nxt[n][i]=inf;\n          for(int i=0;i<(1<<k);i++)\n            dp[i]=inf;\n          for(int j=0;j<17;j++)\n          {\n            int continuous=0;\n            for(int i=(n-1);i>=0;i--)\n            {\n              if((s[i]-'a')==j || s[i]=='?')\n                continuous++;\n              else\n                continuous=0;\n              nxt[i][j]=nxt[i+1][j];\n              if(continuous>=x)\n                nxt[i][j]=i+x;\n            }\n          }\n          dp[0]=0;\n          for(int i=1;i<(1<<k);i++)\n          {\n            for(int j=0;j<k;j++)\n            {\n              if((i&(1<<j))!=0 && (dp[(i^(1<<j))]<inf))\n                dp[i]=Math.min(dp[i],nxt[dp[(i^(1<<j))]][j]);\n            }\n          }\n          return dp[(1<<k)-1]<inf;\n        }\n        static class FastScanner{\n          BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n          StringTokenizer st=new StringTokenizer("""");\n          String next()\n          {\n            while(!st.hasMoreTokens())\n            {\n              try\n              {\n                st=new StringTokenizer(br.readLine());\n              }\n              catch(Exception e)\n              {\n                e.printStackTrace();\n              }\n            }\n            return st.nextToken();\n          }\n          int nextInt()\n          {\n            return Integer.parseInt(next());\n          }\n        }\n}","binary search,bitmasks,brute force,dp,strings,two pointers"
"/******************************************************************************\n\nWelcome to GDB Online.\nGDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,\nC#, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.\nCode, Compile, Run and Debug online from anywhere in world.\n\n*******************************************************************************/\n\nimport java.util.*;\npublic class Main{\n    static int n , k ;\n    static String s ;\n    public static boolean check(int d){\n        int lst[] = new int[k];\n        Arrays.fill(lst,n);\n        int pos[][] = new int[n+1][k];\n        for (int[] row : pos)\n            Arrays.fill(row, n+1);\n        for( int i = n -1 ; i>= 0 ; --i ){\n            if(s.charAt(i) != '?')\n                {\n                    lst[s.charAt(i) - 'a'] = i ;\n                }\n            int cur = n ; \n            for(int j = 0 ; j<k ; j++){\n                pos[i][j] = (i + d <= cur ? i + d : pos[i+1][j]);\n                cur = Math.min(cur, lst[j]);\n            }\n            cur =  n ; \n            for ( int j = k -1  ; j >=0 ; --j ){\n                if( i + d > cur )pos[i][j] = pos[i+1][j];\n                cur = Math.min(cur , lst[j]);\n            }\n        }\n        int dp[] = new int[1<<k];\n        Arrays.fill(dp,n+1);\n        dp[0]=0;\n        for(int mask = 0 ; mask < (1<<k) ; mask ++ ){\n            if(dp[mask]<n+1){\n                for(int i = 0 ; i < k ; i ++ ){\n                    if ( ((mask >> i) & 1) != 1 )\n                        dp[mask|(1<<i)] = Math.min(dp[mask | (1<<i)] , pos[dp[mask]][i]);\n                }\n            }\n            \n        }\n        return dp[(1 << k) - 1] <= n; \n        \n    }\n    public static void main(String args[]){\n        Scanner sc = new Scanner(System.in);\n        \n        n = sc.nextInt();\n        k = sc.nextInt();\n        // s = sc.nextLine();\n        s= sc.next();\n        int l = 1, r = n;\n    	int res = 0;\n    	while (l <= r){\n    		int m = (l + r) / 2;\n    		if (check(m)){\n    			res = m;\n    			l = m + 1;\n    		}\n    		else{\n    			r = m - 1;\n    		}\n    	}\n        System.out.println(res);\n    }\n}","binary search,bitmasks,brute force,dp,strings,two pointers"
"\n\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n\npublic class Main {\n    static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n    static PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n    private static int nextInt() {\n        try {\n            in.nextToken();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return (int) in.nval;\n    }\n\n    private static long nextLong() {\n        try {\n            in.nextToken();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return (long) in.nval;\n    }\n\n    private static String next() {\n        try {\n            in.nextToken();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return in.sval;\n    }\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(new BufferedInputStream(System.in));\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        String s = sc.next();\n        int left = 0;\n        int right = n;\n        int ans = 0;\n        char[] cs = s.toCharArray();\n        while (left<=right){\n            int mid = (left+right)/2;\n            if(check(k,cs,n,mid)){\n                ans = mid;\n                left = mid + 1;\n            }else {\n                right = mid - 1;\n            }\n        }\n        System.out.println(ans);\n    }\n    static int INF = 0x3f3f3f3f;\n    public static boolean check(int k,char[] s,int n,int limit){\n        int[][] f = new int[k][n+3];\n        for (int i = 0; i < k; i++) {\n            f[i][n+1] = f[i][n+2] = n + 2;\n            int now = 0;\n            for(int j = n; j >= 1; j--) {\n                if(s[j-1]=='?'||s[j-1]=='a'+i)now++;\n                else now = 0;\n                f[i][j] = (now>=limit?j+limit:f[i][j+1]);\n            }\n        }\n        //System.out.println(Arrays.toString(f[1]));\n        int[] dp = new int[(1<<k)];\n        Arrays.fill(dp,n+2);\n        dp[0] = 1;\n        for (int i = 0; i < (1 << k); i++) {\n            for (int j = 0; j < k; j++) {\n                if((i>>j&1)==1)continue;\n                int state = (i|(1<<j));\n                dp[state] = Math.min(dp[state],f[j][dp[i]]);\n            }\n        }\n        return dp[(1<<k)-1]<=n+1;\n    }\n}","binary search,bitmasks,brute force,dp,strings,two pointers"
"import java.util.*;\nimport java.io.*;\n\npublic class _111 {\n    static int MAX = (int) 1e7;\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int t = 1;\n        while (t-- > 0) {\n            int n = sc.nextInt();\n            int k = sc.nextInt();\n            String s = sc.next();\n            int l = 0; int r = n / k + 2;\n            while (l < r) {\n                int len = (l + r) / 2;\n                // starting from the suffix at i, how far do I have to go to create a run of length len\n                int [][] end = new int[k][n + 1];\n                for (int [] arr: end) Arrays.fill(arr, MAX);\n                for (int c = 0; c < k; c++) {\n                    int run = 0;\n                    for (int i = n - 1; i >= 0; i--) {\n                        if (s.charAt(i) == 'a' + c || s.charAt(i) == '?') ++run; else run = 0;\n                        end[c][i] = end[c][i + 1];\n                        if (run >= len) end[c][i] = i + len - 1;\n                    }\n                }\n                // length of the minimum prefix such that we can fit runs of all the bits set in mask\n                int [] dp = new int[1 << k];\n                Arrays.fill(dp, MAX);\n                dp[0] = -1;\n                for (int i = 1; i < (1 << k); i++) {\n                    for (int j = 0; j < k; j++) {\n                        if (((i >> j) & 1) == 1 && dp[i ^ (1 << j)] < MAX) {\n                            int previous = dp[i ^ (1 << j)];\n                            dp[i] = Math.min(dp[i], end[j][previous + 1]);\n                        }\n                    }\n                }\n                if (dp[(1 << k) - 1] < MAX) {\n                    l = len + 1;\n                } else {\n                    r = len;\n                }\n            }\n            out.println(l - 1);\n        }\n        out.close();\n    }\n\n\n\n\n    static void sort(int[] a) {\n        ArrayList<Integer> q = new ArrayList<>();\n        for (int i : a) q.add(i);\n        Collections.sort(q);\n        for (int i = 0; i < a.length; i++) a[i] = q.get(i);\n    }\n\n    static void sort(long[] a) {\n        ArrayList<Long> q = new ArrayList<>();\n        for (long i : a) q.add(i);\n        Collections.sort(q);\n        for (int i = 0; i < a.length; i++) a[i] = q.get(i);\n    }\n\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n\n    }\n\n}","binary search,bitmasks,brute force,dp,strings,two pointers"
"import java.util.Scanner;\nimport java.util.Arrays;\npublic class E {\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        int t=sc.nextInt();\n        while(t-- > 0){\n            int n=sc.nextInt();\n            int k=sc.nextInt();\n            int[] pos=new int[k];\n            long temp[]=new long[n+2];\n            Arrays.fill(temp,Long.MAX_VALUE-1);\n            for(int i=0;i<k;i++) pos[i]=sc.nextInt(); \n            for(int i=0;i<k;i++) temp[pos[i]]=sc.nextInt();\n            \n            for(int i=1;i<=n;i++) temp[i]=Math.min(temp[i-1]+1,temp[i]);\n            for(int i=n;i>=1;i--) temp[i]=Math.min(temp[i+1]+1,temp[i]);\n            for(int i=1;i<=n;i++) System.out.print(temp[i]+"" "");\n            System.out.println();\n        }\n        sc.close();\n    }\n    \n}\n","data structures,dp,implementation,shortest paths,sortings,two pointers"
"import java.util.*;\npublic class Sol\n{\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        while(t-->0)\n        {\n			int n = sc.nextInt();\n			int k= sc.nextInt();\n			int ac[] = new int[k];\n			int temp[] = new int[k];\n			int ans[] = new int[n+1];\n			for(int i=0;i<k;i++)\n				ac[i] = sc.nextInt();\n			for(int i=0;i<k;i++)\n				temp[i] = sc.nextInt();\n			Arrays.fill(ans,Integer.MAX_VALUE);\n			for(int i=0;i<k;i++)\n				ans[ac[i]] = temp[i];\n\n			for(int i=2;i<n+1;i++)\n				ans[i]=Math.min(ans[i],ans[i-1]==Integer.MAX_VALUE ? ans[i-1] : ans[i-1]+1);\n\n			for(int i=n-1;i>0;i--)\n				ans[i]=Math.min(ans[i],ans[i+1]+1);\n			\n			for(int i=1;i<n+1;i++)\n				System.out.print(ans[i]+"" "");\n		\n			System.out.println("" "");\n		}	\n    }\n}","data structures,dp,implementation,shortest paths,sortings,two pointers"
"import java.util.*;\npublic class j\n{\n  public static void main(String args[])\n  {\n    Scanner in=new Scanner(System.in);\n    int n=in.nextInt();\n    while(n-->0)\n    {\n      int len=in.nextInt();\n      int t=in.nextInt();\n      int pos[]=new int[t];\n      int temp[]=new int[t];\n      for(int i=0;i<t;i++)\n      pos[i]=in.nextInt();\n      for(int i=0;i<t;i++)\n      temp[i]=in.nextInt();\n      long range[]=new long[len];\n      Arrays.fill(range,Long.MAX_VALUE-10000);\n      for(int i=0;i<t;i++)\n      range[pos[i]-1]=temp[i];\n      for(int i=1;i<len;i++)\n      {\n        range[i]=Math.min(range[i],1+range[i-1]);\n      }\n      for(int i=len-2;i>=0;i--)\n      {\n      range[i]=Math.min(range[i+1]+1,range[i]);\n      }\n      for(int i=0;i<len;i++)\n      {\n        System.out.print(range[i]+"" "");\n      }System.out.println();\n    }\n  }\n}","data structures,dp,implementation,shortest paths,sortings,two pointers"
"import java.util.*;\n\npublic class Solution {\n	\n	private static Scanner in = new Scanner(System.in);\n	\n	public static void main(String[] args) {\n		\n		int t = in.nextInt();\n		while(t-- > 0)\n			solve();\n    }\n	\n	private static void solve() {\n		int n = in.nextInt();\n		int k = in.nextInt();\n		int a[] = new int[k+1];\n		for(int i=1; i<=k; i++)\n			a[i] = in.nextInt();\n		long l[] = new long[n+1];\n		long r[] = new long[n+1];\n		for(int i=1; i<=n; i++) {\n			l[i] = Integer.MAX_VALUE;\n			r[i] = Integer.MAX_VALUE;\n		}\n		for(int i=1; i<=k; i++) {\n			l[a[i]] = in.nextInt();\n			r[a[i]] = l[a[i]];\n		}\n		for(int i=2;i<=n;i++) {\n			l[i] = Math.min(l[i-1]+1, l[i]);\n		}\n		for(int i=n-1;i>=0;i--) {\n			r[i] = Math.min(r[i+1]+1, r[i]);\n		}\n		\n		for(int i=1;i<=n;i++) {\n				System.out.print(Math.min(l[i], r[i])+"" "");\n		}\n		System.out.println();\n	}\n}","data structures,dp,implementation,shortest paths,sortings,two pointers"
"import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.util.Locale;\nimport java.util.StringTokenizer;\n\npublic class Solution implements Runnable {\n	\n	public static final int MOD = 998244353;\n	\n	private PrintStream out;\n	private BufferedReader in;\n	private StringTokenizer st;\n	\n	public void solve() throws IOException {\n		long time0 = System.currentTimeMillis();\n		\n		int t = nextInt();\n		for (int test = 1; test <= t; test++) {\n			int n = nextInt();\n			int[][] a = new int[2 * n][n];\n			for (int i = 0; i < 2 * n; i++) {\n				for (int j = 0; j < n; j++) {\n					a[i][j] = nextInt() - 1;\n				}\n			}\n			String answer = solve(n, a);\n			out.println(answer);\n		}\n		\n		System.err.println(""time: "" + (System.currentTimeMillis() - time0));\n	}\n	\n	private String solve(int n, int[][] a) {\n		int[][] posnumcount = new int[n][n];\n		int[] posonescount = new int[n];\n		for (int i = 0; i < a.length; i++) {\n			add(a[i], 1, posnumcount, posonescount);\n		}\n		boolean[] killed = new boolean[2 * n];\n		int answer = 1;\n		int[] ansarr = new int[n];\n		for (int i = 0; i < n; i++) {\n			int onepos = -1;\n			for (int j = 0; j < n; j++) {\n				if (posonescount[j] > 0) {\n					onepos = j;\n					break;\n				}\n			}\n			int tokill = -1;\n			if (onepos == -1) {\n				answer = (answer * 2) % MOD;\n				for (int j = 0; j < 2 * n; j++) {\n					if (!killed[j]) {\n						tokill = j;\n						break;\n					}\n				}\n			} else {\n				for (int j = 0; j < 2 * n; j++) {\n					if (!killed[j] && posnumcount[onepos][a[j][onepos]] == 1) {\n						tokill = j;\n						break;\n					}\n				}\n			}\n			ansarr[i] = tokill;\n			for (int j = 0; j < 2 * n; j++) {\n				if (!killed[j]) {\n					for (int k = 0; k < n; k++) {\n						if (a[j][k] == a[tokill][k]) {\n							killed[j] = true;\n							add(a[j], -1, posnumcount, posonescount);\n							break;\n						}\n					}\n				}\n			}\n		}\n		StringBuilder buf = new StringBuilder();\n		buf.append(answer).append(""\n"");\n		for (int i = 0; i < n; i++) {\n			buf.append(ansarr[i] + 1).append("" "");\n		}\n		return buf.toString();\n	}\n	\n	private void add(int[] ai, int add, int[][] posnumcount, int[] posonescount) {\n		for (int j = 0; j < ai.length; j++) {\n			if (posnumcount[j][ai[j]] == 1) {\n				posonescount[j]--;\n			}\n			posnumcount[j][ai[j]] += add;\n			if (posnumcount[j][ai[j]] == 1) {\n				posonescount[j]++;\n			}\n		}\n	}\n\n	public double nextDouble() throws IOException {\n		return Double.parseDouble(next());\n	}\n	\n	public long nextLong() throws IOException {\n		return Long.parseLong(next());\n	}\n	\n	public int nextInt() throws IOException {\n		return Integer.parseInt(next());\n	}\n	\n	public String next() throws IOException {\n		while (!st.hasMoreTokens()) {\n			String line = in.readLine();\n			if (line == null) {\n				return null;\n			}\n			st = new StringTokenizer(line);\n		}\n		return st.nextToken();\n	}\n	\n	@Override\n	public void run() {\n		try {\n			solve();\n			out.close();\n		} catch (Throwable e) {\n			throw new RuntimeException(e);\n		}\n	}\n	\n	public Solution(String name) throws IOException {\n		Locale.setDefault(Locale.US);\n		if (name == null) {\n			in = new BufferedReader(new InputStreamReader(System.in));\n			out = new PrintStream(new BufferedOutputStream(System.out));\n		} else {\n			in = new BufferedReader(new InputStreamReader(new FileInputStream(name + "".in"")));\n			out = new PrintStream(new BufferedOutputStream(new FileOutputStream(name + "".out"")));\n		}\n		st = new StringTokenizer("""");\n	}\n	\n	public static void main(String[] args) throws IOException {\n		new Thread(new Solution(null)).start();\n	}\n}\n","2-sat,brute force,combinatorics,constructive algorithms,graph matchings,graphs"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.util.stream.Collectors;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.util.stream.Stream;\nimport java.io.Closeable;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            EAquaMoonAndPermutations solver = new EAquaMoonAndPermutations();\n            int testCount = Integer.parseInt(in.next());\n            for (int i = 1; i <= testCount; i++)\n                solver.solve(i, in, out);\n            out.close();\n        }\n    }\n\n    static class EAquaMoonAndPermutations {\n        int mod = 998244353;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.ri();\n            List<int[]> ps = new ArrayList<>(n * 2);\n            for (int i = 0; i < n * 2; i++) {\n                int[] p = new int[n + 1];\n                for (int j = 0; j < n; j++) {\n                    p[j] = in.ri();\n                }\n                p[n] = i;\n                ps.add(p);\n            }\n            List<Integer> res = new ArrayList<>(n);\n            int[][] cnts = new int[n + 1][n + 1];\n            long ans = 1;\n            while (!ps.isEmpty()) {\n                SequenceUtils.fill(cnts, 0);\n                for (int[] p : ps) {\n                    for (int i = 0; i < n; i++) {\n                        cnts[i][p[i]]++;\n                    }\n                }\n                int col = -1;\n                int v = -1;\n                for (int i = 0; i < n; i++) {\n                    for (int j = 1; j <= n; j++) {\n                        if (cnts[i][j] == 1) {\n                            col = i;\n                            v = j;\n                        }\n                    }\n                }\n                int[] pick = null;\n                if (col != -1) {\n                    for (int i = 0; i < ps.size(); i++) {\n                        int[] p = ps.get(i);\n                        if (p[col] == v) {\n                            //find\n                            pick = p;\n                        }\n                    }\n                } else {\n                    pick = ps.get(0);\n                    ans = ans * 2 % mod;\n                }\n                assert pick != null;\n                res.add(pick[n]);\n                int[] finalPick = pick;\n                ps = ps.stream().filter(x -> {\n                    for (int i = 0; i < n; i++) {\n                        if (x[i] == finalPick[i]) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }).collect(Collectors.toList());\n            }\n\n            res.sort(Comparator.naturalOrder());\n            out.println(ans);\n            for (int x : res) {\n                out.append(x + 1).append(' ');\n            }\n            out.println();\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static void fill(int[][] x, int val) {\n            for (int[] v : x) {\n                Arrays.fill(v, val);\n            }\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public int ri() {\n            return readInt();\n        }\n\n        public int readInt() {\n            boolean rev = false;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                rev = next == '-';\n                next = read();\n            }\n\n            int val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 - next + '0';\n                next = read();\n            }\n\n            return rev ? val : -val;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 32 << 10;\n        private OutputStream writer;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n        private static Field stringBuilderValueField;\n\n        static {\n            try {\n                stringBuilderValueField = StringBuilder.class.getSuperclass().getDeclaredField(""value"");\n                stringBuilderValueField.setAccessible(true);\n            } catch (Exception e) {\n                stringBuilderValueField = null;\n            }\n        }\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n\n        public FastOutput(OutputStream writer) {\n            this.writer = writer;\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(long c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput println(long c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            return append('\n');\n        }\n\n        public FastOutput flush() {\n            try {\n                if (stringBuilderValueField != null) {\n                    try {\n                        byte[] value = (byte[]) stringBuilderValueField.get(cache);\n                        writer.write(value, 0, cache.length());\n                    } catch (Exception e) {\n                        stringBuilderValueField = null;\n                    }\n                }\n                if (stringBuilderValueField == null) {\n                    //slow\n                    writer.write(cache.toString().getBytes(StandardCharsets.UTF_8));\n//                writer.append(cache);\n                }\n                writer.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                writer.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n}\n\n","2-sat,brute force,combinatorics,constructive algorithms,graph matchings,graphs"
"import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.List;\n import java.util.*;\n public class realfast implements Runnable \n  {\n    private static final int INF = (int) 1e9;\n    long in= 998244353;\n    long fac[]= new long[1000001];\n    long inv[]=new long[1000001];\n    public  void solve() throws IOException \n    {\n\n        \n         \n\n          int t1 = readInt();\n\n          ArrayList<Integer> val[][]=new ArrayList[510][510];\n          int arr[][]=new int[1010][510];\n          int b[][]=new int[510][510];\n        //  boolean row[]=new boolean[1000+1];\n        \n          for(int f =0;f<t1;f++)\n          {\n                   int n = readInt();\n\n                   int stack[]= new int[n*n+10];\n                   int stack2[]=new int[n*n+10];\n                   int start=0;\n                   int end =0;\n\n                   for(int i=1;i<=n;i++)\n                    for(int j=1;j<=n;j++)\n                        val[i][j]= new ArrayList<Integer>();\n                    boolean map[]=new boolean[2*n+10];\n\n                    for(int i=1;i<=n;i++)\n                    {\n                        for(int j=1;j<=n;j++)\n                        {\n                         b[i][j]=0;\n                         arr[i][j]=0;\n                        } \n                    }\n\n                //    for(int i=1;i<=n;i++)\n\n                    for(int i=1;i<=2*n;i++)\n                    {\n                        for(int j=1;j<=n;j++)\n                        {\n                            arr[i][j]= readInt();\n                            b[j][arr[i][j]]++;\n                            val[j][arr[i][j]].add(i);\n                        }\n                    }\n\n                    for(int i=1;i<=n;i++)\n                    {\n                         for(int j=1;j<=n;j++)\n                         {\n                             if(b[i][j]==1)\n                             {\n                                stack[end]=i;\n                                stack2[end]=j;\n                                end++;\n                             }\n                         }\n                    }\n                    long ans =1;\n                    ArrayList<Integer>pal = new ArrayList<Integer>();\n                    int cnt =0;\n                    while(cnt<n)\n                    {\n                       int t=-1;\n                       if(start<end)\n                       {\n                            if(b[stack[start]][stack2[start]]!=1)\n                            {\n                             start++;\n                             continue;\n                            } \n\n                            int u = stack[start];\n                            int v = stack2[start];\n                            start++;\n                            for(int j = 0;j<val[u][v].size();j++)\n                            {\n                                if(!map[val[u][v].get(j)])\n                                {\n                                    t=val[u][v].get(j);\n                                    break;\n                                }\n                            }\n                       } \n                     //  out.println(t+""  before""); \n\n                       if(t==-1)\n                       {\n                           ans = (ans*2)%in;\n                           for(int j=1;j<=2*n;j++)\n                           {\n                             if(!map[j])\n                             {\n                                t=j;\n                                break;\n                             }\n                           }\n                       }\n\n                    //   out.println(t+"" after"");\n                       if(t==-1){\n                        out.println(""nigga"");\n                        break;\n                       }\n                       if(t!=-1)\n                       map[t]= true;\n                       cnt++;\n                       if(t!=-1)\n                       pal.add(t);\n\n                       for(int i=1;i<=n;i++)\n                       {\n                          b[i][arr[t][i]]=0;\n                       }\n                       \n\n                       for(int i =1;i<=n;i++)\n                       {\n                          int p = arr[t][i];\n\n                          for(int j=0;j<val[i][p].size();j++)\n                          {\n                               int l = val[i][p].get(j);\n                               if(!map[l])\n                               {\n                                  map[l]= true;\n                                  for(int k=1;k<=n;k++)\n                                  {\n                                     b[k][arr[l][k]]--;\n                                     if(b[k][arr[l][k]]==1)\n                                     {\n                                         stack[end]= k;\n                                         stack2[end]= arr[l][k];\n                                         end++;\n                                     }\n                                  }\n                               }\n                          }\n                       }\n                      \n                      \n                    }\n\n\n\n                    out.println(ans);\n\n\n                    for(int j =0;j<pal.size();j++)\n                        out.print(pal.get(j)+"" "");\n\n                    out.println();\n     \n\n          }\n     }\n        \n\n\n\n    \n    \n    public int value (int seg[], int left , int right ,int index, int l, int r)\n    {\n            \n            if(left>right)\n            {\n              return -100000000;\n            }\n            if(right<l||left>r)\n                return -100000000;\n            if(left>=l&&right<=r)\n                return seg[index];\n            int mid = left+(right-left)/2;\n            int val = value(seg,left,mid,2*index+1,l,r);\n            int val2 = value(seg,mid+1,right,2*index+2,l,r);\n            return Math.max(val,val2);\n\n    }\n   \n    public int gcd(int a , int b )\n    {\n      if(a<b)\n      {\n        int t =a;\n        a=b;\n        b=t;\n      }\n      if(a%b==0)\n        return b ;\n      return gcd(b,a%b);\n    }\n    public long pow(long n , long p,long m)\n    {\n         if(p==0)\n            return 1;\n        long val = pow(n,p/2,m);;\n        val= (val*val)%m;\n        if(p%2==0)\n            return val;\n        else\n            return (val*n)%m;\n    }\n    \n    \n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    public static void main(String[] args) {\n        new Thread(null, new realfast(), """", 128 * (1L << 20)).start();\n    }\n \n    private static final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null;\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n    private PrintWriter out;\n \n    @Override\n    public void run() {\n        try {\n            if (ONLINE_JUDGE || !new File(""input.txt"").exists()) {\n                reader = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            } else {\n                reader = new BufferedReader(new FileReader(""input.txt""));\n                out = new PrintWriter(""output.txt"");\n            }\n            solve();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                reader.close();\n            } catch (IOException e) {\n                // nothing\n            }\n            out.close();\n        }\n    }\n \n    private String readString() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n \n    @SuppressWarnings(""unused"")\n    private int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n \n    @SuppressWarnings(""unused"")\n    private long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n \n    @SuppressWarnings(""unused"")\n    private double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n}\nclass edge implements Comparable<edge>{\n    long u ;\n    long v;\n    \n    edge(long u, long v)\n    {\n       this.u=u;\n       this.v=v;\n    }\n    public int compareTo(edge e)\n    {\n        if(this.v>=e.v)\n        return 1;\n        else\n        return -1;\n\n    }\n}","2-sat,brute force,combinatorics,constructive algorithms,graph matchings,graphs"
"import java.util.*;\n\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class C {\n	FastScanner in;\n	PrintWriter out;\n	boolean systemIO = true;\n\n	public static void quickSort(int[] a, int from, int to) {\n		if (to - from <= 1) {\n			return;\n		}\n		int i = from;\n		int j = to - 1;\n		int x = a[from + (new Random()).nextInt(to - from)];\n		while (i <= j) {\n			while (a[i] < x) {\n				i++;\n			}\n			while (a[j] > x) {\n				j--;\n			}\n			if (i <= j) {\n				int t = a[i];\n				a[i] = a[j];\n				a[j] = t;\n				i++;\n				j--;\n			}\n		}\n		quickSort(a, from, j + 1);\n		quickSort(a, j + 1, to);\n	}\n\n	public long gcd(long x, long y) {\n		if (y == 0) {\n			return x;\n		}\n		if (x == 0) {\n			return y;\n		}\n		return gcd(y, x % y);\n	}\n\n	public boolean prime(long x) {\n		for (int i = 2; i * i <= x; i++) {\n			if (x % i == 0) {\n				return false;\n			}\n		}\n		return true;\n	}\n\n	public long pow(long x, long p) {\n		if (p == 0) {\n			return 1;\n		}\n		long t = pow(x, p / 2);\n		t *= t;\n		t %= mod;\n		if (p % 2 == 1) {\n			t *= x;\n			t %= mod;\n		}\n		return t;\n	}\n\n	public class Pair implements Comparable<Pair> {\n		int x;\n		int y;\n\n		public Pair(int x, int y) {\n			this.x = x;\n			this.y = y;\n		}\n\n		public String toString() {\n			return x + "" "" + y;\n		}\n\n		@Override\n		public int compareTo(Pair o) {\n			if (x > o.x) {\n				return 1;\n			}\n			if (x < o.x) {\n				return -1;\n			}\n			if (y > o.y) {\n				return 1;\n			}\n			if (y < o.y) {\n				return -1;\n			}\n			return 0;\n		}\n	}\n\n	public class Fenvik2D {\n		long[][] t;\n		int n, m;\n\n		public Fenvik2D(int n, int m) {\n			t = new long[n][m];\n			this.n = n;\n			this.m = m;\n		}\n\n		public int sum(int x1, int y1, int x2, int y2) {\n			return sum(x2, y2) - sum(x1 - 1, y2) - sum(x2, y1 - 1) + sum(x1 - 1, y1 - 1);\n		}\n\n		public int sum(int x, int y) {\n			int result = 0;\n			for (int i = x; i >= 0; i = (i & (i + 1)) - 1) {\n				for (int j = y; j >= 0; j = (j & (j + 1)) - 1) {\n					result += t[i][j];\n				}\n			}\n			return result;\n		}\n\n		public void add(int x, int y, int delta) {\n			for (int i = x; i < n; i = (i | (i + 1))) {\n				for (int j = y; j < m; j = (j | (j + 1))) {\n					t[i][j] += delta;\n				}\n			}\n		}\n	}\n\n	public int[] prefF(int[] a) {\n		int[] p = new int[a.length];\n		for (int i = 1; i < p.length; i++) {\n			int j = p[i - 1];\n			while (j > 0) {\n				if (a[j] == a[i]) {\n					break;\n				}\n				if (j == 0) {\n					break;\n				}\n				j = p[j - 1];\n			}\n			if (a[i] == a[j]) {\n				p[i] = j + 1;\n			}\n		}\n		return p;\n	}\n\n	public class Tree {\n		long[] sum;\n		long[] min;\n		int[] alive;\n		int pow;\n		long inf = Long.MAX_VALUE / 2;\n\n		public Tree(long[] a, long[] b) {\n			pow = 1;\n			while (pow < a.length) {\n				pow *= 2;\n			}\n			sum = new long[2 * pow];\n			min = new long[2 * pow];\n			for (int i = 0; i < min.length; i++) {\n				min[i] = inf;\n			}\n			alive = new int[2 * pow];\n			for (int i = 0; i < b.length; i++) {\n				sum[pow + i] = a[i];\n				min[pow + i] = a[i] + b[i];\n				alive[pow + i] = 1;\n			}\n			for (int i = pow - 1; i > 0; i--) {\n				merge(i);\n			}\n		}\n\n		public void merge(int v) {\n			sum[v] = sum[2 * v] + sum[2 * v + 1];\n			min[v] = inf;\n			if (min[2 * v] < min[v]) {\n				min[v] = min[2 * v];\n			}\n			if (min[2 * v + 1] + sum[2 * v] < min[v]) {\n				min[v] = min[2 * v + 1] + sum[2 * v];\n			}\n			alive[v] = alive[2 * v] + alive[2 * v + 1];\n		}\n\n		public void add(long a, long b, int c) {\n			add(1, 0, pow, a, b, c - 1);\n		}\n\n		private void add(int v, int l, int r, long a, long b, int c) {\n			if (v >= pow) {\n				sum[v] = a;\n				min[v] = a + b;\n				alive[v] = 1;\n				return;\n			}\n			int m = (l + r) / 2;\n			if (c < m) {\n				add(2 * v, l, m, a, b, c);\n			} else {\n				add(2 * v + 1, m, r, a, b, c);\n			}\n			merge(v);\n		}\n\n		public int update(long x) {\n			return update(1, 0, pow, x);\n		}\n\n		private int update(int v, int l, int r, long x) {\n			if (v >= pow) {\n				if (x > min[v]) {\n					sum[v] = 0;\n					min[v] = inf;\n					alive[v] = 0;\n					return 1;\n				}\n				if (alive[v] == 1 && x >= sum[v]) {\n					return 1;\n				}\n				return 0;\n			}\n			int m = (l + r) / 2;\n			if (sum[2 * v] > x) {\n				int ans = update(2 * v, l, m, x);\n				merge(v);\n				return ans;\n			}\n			int ans = alive[2 * v] + update(2 * v + 1, m, r, x - sum[2 * v]);\n			if (x > min[2 * v]) {\n				update(2 * v, l, m, x);\n			}\n			merge(v);\n			return ans;\n		}\n	}\n\n	public class MyStack {\n		int[] st;\n		int sz;\n\n		public MyStack(int max) {\n			st = new int[max];\n			sz = 0;\n		}\n\n		public int size() {\n			return sz;\n		}\n\n		public boolean isEmpty() {\n			return sz == 0;\n		}\n\n		public int peek() {\n			return st[sz - 1];\n		}\n\n		public int pop() {\n			return st[--sz];\n		}\n\n		public void add(int x) {\n			st[sz++] = x;\n		}\n\n		public void clear() {\n			sz = 0;\n		}\n	}\n\n	public long[][] mult(long[][] a, long[][] b) {\n		long[][] c = new long[a.length][b[0].length];\n		for (int i = 0; i < c.length; i++) {\n			for (int j = 0; j < c[0].length; j++) {\n				for (int k = 0; k < b.length; k++) {\n					c[i][j] += a[i][k] * b[k][j];\n					c[i][j] %= mod;\n				}\n			}\n		}\n		return c;\n	}\n\n	int mod = 998244353;\n\n	public long[][] pow(long p, long[][] m) {\n		if (p == 0) {\n			long[][] matrix = new long[m.length][m.length];\n			for (int i = 0; i < matrix.length; i++) {\n				matrix[i][i] = 1;\n			}\n			return matrix;\n		}\n		if (p % 2 == 1) {\n			return mult(m, pow(p - 1, m));\n		}\n		long[][] cur = pow(p / 2, m);\n		return mult(cur, cur);\n	}\n\n	public void add(HashMap<Integer, Integer> map, int x) {\n		if (map.containsKey(x)) {\n			map.put(x, map.get(x) + 1);\n		} else {\n			map.put(x, 1);\n		}\n	}\n\n	public class Point implements Comparable<Point> {\n		long x;\n		long y;\n		int n;\n\n		public Point(long x, long y, int n) {\n			this.x = x;\n			this.y = y;\n			this.n = n;\n		}\n\n		public void norm() {\n			long gcd = gcd(Math.abs(x), Math.abs(y));\n			x /= gcd;\n			y /= gcd;\n		}\n\n		public int quater() {\n			if (x > 0 && y >= 0) {\n				return 0;\n			}\n			if (x <= 0 && y > 0) {\n				return 1;\n			}\n			if (x < 0) {\n				return 2;\n			}\n			return 3;\n		}\n\n		public long mod2() {\n			return x * x + y * y;\n		}\n\n		@Override\n		public int compareTo(Point o) {\n			if (quater() != o.quater()) {\n				return quater() - o.quater();\n			}\n			int s = sign(cp(o, this));\n			if (s != 0) {\n				return s;\n			}\n			return sign(mod2() - o.mod2());\n		}\n	}\n\n	public long cp(Point a, Point b) {\n		return a.x * b.y - a.y * b.x;\n	}\n\n	public int sign(long x) {\n		if (x > 0) {\n			return 1;\n		}\n		if (x < 0) {\n			return -1;\n		}\n		return 0;\n	}\n\n	public class Vector {\n		double x;\n		double y;\n\n		public Vector(double x, double y) {\n			this.x = x;\n			this.y = y;\n		}\n\n		public double norm() {\n			return Math.sqrt(norm2());\n		}\n\n		public double norm2() {\n			return x * x + y * y;\n		}\n\n		public String toString() {\n			return x + "" "" + y;\n		}\n\n		public Vector negative() {\n			return new Vector(-x, -y);\n		}\n\n		public Vector add(Vector v) {\n			return new Vector(x + v.x, y + v.y);\n		}\n\n		public Vector subtract(Vector v) {\n			return new Vector(x - v.x, y - v.y);\n		}\n\n	}\n\n	public double dp(Vector a, Vector b) {\n		return a.x * b.x + a.y * b.y;\n	}\n\n	public double cp(Vector a, Vector b) {\n		return a.x * b.y - a.y * b.x;\n	}\n\n	public class Polygon {\n		Vector[] v;\n		double s;\n\n		public Polygon(Vector[] v) {\n			this.v = v;\n			s = Math.abs(s());\n		}\n\n		public double s() {\n			double ans = 0;\n			for (int i = 1; i < v.length - 1; i++) {\n				Vector a = v[i].subtract(v[0]);\n				Vector b = v[i + 1].subtract(v[0]);\n				ans += cp(a, b);\n			}\n			return ans / 2;\n		}\n\n		public boolean intersect(Vector o, double r) {\n			for (int i = 0; i < v.length; i++) {\n				if (intersectSeg(v[i], v[(i + 1) % v.length], o, r)) {\n					return true;\n				}\n			}\n			boolean inside = false;\n			for (int i = 0; i < v.length; i++) {\n				inside ^= intersectRay(v[i], v[(i + 1) % v.length], o);\n			}\n			if (inside) {\n				System.err.println(o + "" "" + s);\n				return true;\n			}\n			return false;\n		}\n	}\n\n	public double sq(double x) {\n		return x * x;\n	}\n\n	public boolean intersectSeg(Vector a, Vector b, Vector o, double r) {\n		Vector ao = o.subtract(a);\n		Vector bo = o.subtract(b);\n		if (ao.norm2() <= r * r * (1 + eps) || bo.norm2() <= r * r * (1 + eps)) {\n			return true;\n		}\n		Vector ab = b.subtract(a);\n		if (sq(Math.abs(cp(ao, bo))) > ab.norm2() * r * r * (1 + eps)) {\n			return false;\n		}\n		if (dp(ao, ab) < -eps || dp(bo, ab) > eps) {\n			return false;\n		}\n		return true;\n	}\n\n	public boolean intersectRay(Vector a, Vector b, Vector o) {\n		if (a.y == b.y) {\n			return false;\n		}\n		if (o.y == Math.max(a.y, b.y) && o.x < Math.min(a.x, b.x)) {\n			return true;\n		}\n		if (o.y == Math.min(a.y, b.y)) {\n			return false;\n		}\n		if ((o.y - a.y) * (o.y - b.y) < 0) {\n			if (a.y < b.y) {\n				if (cp(b.subtract(a), o.subtract(a)) > 0) {\n					return true;\n				}\n			} else {\n				if (cp(b.subtract(a), o.subtract(a)) < 0) {\n					return true;\n				}\n			}\n		}\n		return false;\n	}\n\n	double eps = 0;\n\n	Random random = new Random(566);\n\n	public class SegmentTreeSet {\n		int pow;\n		long[] sum;\n		long[] max;\n		long[] min;\n		long[] delta;\n		boolean[] flag;\n\n		public SegmentTreeSet(long[] a) {\n			pow = 1;\n			while (pow < a.length) {\n				pow *= 2;\n			}\n			flag = new boolean[2 * pow];\n			sum = new long[2 * pow];\n			max = new long[2 * pow];\n			min = new long[2 * pow];\n			delta = new long[2 * pow];\n			for (int i = 0; i < a.length; i++) {\n				sum[pow + i] = a[i];\n				max[pow + i] = a[i];\n				min[pow + i] = a[i];\n			}\n			for (int i = pow - 1; i > 0; i--) {\n				sum[i] = sum[2 * i] + sum[2 * i + 1];\n				max[i] = max[2 * i];\n				min[i] = min[2 * i + 1];\n			}\n		}\n\n		public int get(int v, int tl, int tr, int l, int r) {\n			push(v, tl, tr);\n			if (l >= tr || r <= tl) {\n				return 0;\n			}\n			if (l <= tl && r >= tr) {\n				if (money >= sum[v]) {\n					money -= sum[v];\n					return tr - tl;\n				}\n				if (money < min[v]) {\n					return 0;\n				}\n			}\n			int tm = (tl + tr) / 2;\n			return get(2 * v, tl, tm, l, r) + get(2 * v + 1, tm, tr, l, r);\n		}\n\n		public void set(int v, int tl, int tr, int l, int r, long x) {\n			push(v, tl, tr);\n			if (l >= tr || r <= tl) {\n				return;\n			}\n			if (l <= tl && r >= tr) {\n				if (x >= max[v]) {\n					delta[v] = x;\n					flag[v] = true;\n					push(v, tl, tr);\n				} else if (v < pow) {\n					int tm = (tl + tr) / 2;\n					push(2 * v + 1, tm, tr);\n					if (x >= max[2 * v + 1]) {\n						delta[2 * v + 1] = x;\n						flag[2 * v + 1] = true;\n						push(2 * v + 1, tm, tr);\n						set(2 * v, tl, tm, l, r, x);\n					} else {\n						push(2 * v, tl, tm);\n						set(2 * v + 1, tm, tr, l, r, x);\n					}\n					sum[v] = (sum[2 * v] + sum[2 * v + 1]);\n					max[v] = max[2 * v];\n					min[v] = min[2 * v + 1];\n				}\n				return;\n			}\n			int tm = (tl + tr) / 2;\n			set(2 * v, tl, tm, l, r, x);\n			set(2 * v + 1, tm, tr, l, r, x);\n			sum[v] = (sum[2 * v] + sum[2 * v + 1]);\n			max[v] = max[2 * v];\n			min[v] = min[2 * v + 1];\n		}\n\n		public void push(int v, int tl, int tr) {\n			if (flag[v]) {\n				if (v < pow) {\n					flag[2 * v] = true;\n					flag[2 * v + 1] = true;\n					delta[2 * v] = delta[v];\n					delta[2 * v + 1] = delta[v];\n				}\n				flag[v] = false;\n				sum[v] = delta[v] * (tr - tl);\n				max[v] = delta[v];\n				min[v] = delta[v];\n			}\n		}\n		\n		public int f(int a, int b) {\n			return a + b;\n		}\n	}\n	\n	long money = 0;\n\n	public long[] diofant(long a, long b) {\n		long[] ans = new long[2];\n		if (b == 0) {\n			ans[0] = 1;\n			ans[1] = 0;\n			return ans;\n		}\n		long div = a / b;\n		long mod = a % b;\n		long[] get = diofant(b, mod);\n		ans[0] = get[1];\n		ans[1] = get[0] - (get[1] * div);\n		return ans;\n	}\n\n	public class Arr implements Comparable<Arr> {\n		int[] a;\n\n		public Arr(int[] a) {\n			this.a = a;\n		}\n\n		@Override\n		public int compareTo(Arr o) {\n			for (int i = 0; i < comp.length; i++) {\n				if (a[comp[i]] != o.a[comp[i]]) {\n					return a[comp[i]] - o.a[comp[i]];\n				}\n			}\n			return 0;\n		}\n		\n	}\n	\n	int[] comp;\n	\n	public void dfs(int v) {\n		boolean flag = false;\n		if (!used[v]) {\n			used[v] = true;\n			flag = true;\n			ans.add(v);\n		}\n		for (int x = 0; x < sz; x++) {\n			if (!used[x] && g[v][x]) {\n				used[x] = flag;\n				dfs(x);\n			}\n		}\n	}\n	\n	public int components() {\n		int c = 0;\n		for (int i = 0; i < sz; i++) {\n			if (!used[i]) {\n				dfs(i);\n				c++;\n			}\n		}\n		return c;\n	}\n\n	int max = 500;\n	boolean[][] g = new boolean[2 * max][2 * max];\n	boolean[] used = new boolean[2 * max];\n	int[][] value = new int[max][max];\n	int sz = -1;\n	ArrayList<Integer> ans = new ArrayList<>();\n	\n	\n	public void solve() {\n		int[] pow = new int[2 * max + 1];\n		pow[0] = 1;\n		for (int i = 0; i < pow.length - 1; i++) {\n			pow[i + 1] = pow[i] * 2 % 998244353;\n		}\n		for (int qwerty = in.nextInt(); qwerty > 0; qwerty--) {\n//		for (int qwerty = 1; qwerty > 0; qwerty--) {\n			ans.clear();\n			int n = in.nextInt();\n//			int n = 500;\n			int[][] a = new int[2 * n][n];\n			sz = 2 * n;\n			for (int i = 0; i < sz; i++) {\n				used[i] = false;\n				for (int j = 0; j < n; j++) {\n					a[i][j] = in.nextInt() - 1;\n//					a[i][j] = (i + j) % n;\n				}\n			}\n			boolean flag = false;\n			for (int i = 0; i < sz; ++i) {\n				for (int j = i + 1; j < sz; ++j) {\n					flag = false;\n					for (int k = 0; k < n; ++k) {\n						if (a[i][k] == a[j][k]) {\n							flag = true;\n							break;\n						}\n					}\n					g[i][j] = flag;\n					g[j][i] = flag;\n				}\n			}\n			for (int col = 0; col < n; ++col) {\n				for (int v = 0; v < n; ++v) {\n					value[col][v] = 0;\n				}\n				for (int i = 0; i < sz; ++i) {\n					value[col][a[i][col]]++;\n				}\n			}\n			w : while (true) {\n				for (int c = 0; c < n; ++c) {\n					for (int v = 0; v < n; ++v) {\n						if (value[c][v] == 1) {\n							for (int r = 0; r < sz; ++r) {\n								if (!used[r] && a[r][c] == v) {\n									used[r] = true;\n									for (int x = 0; x < n; ++x) {\n										value[x][a[r][x]]--;\n									}\n									ans.add(r);\n									for (int i = 0; i < sz; ++i) {\n										if (!used[i] && g[r][i]) {\n											used[i] = true;\n											for (int x = 0; x < n; ++x) {\n												value[x][a[i][x]]--;\n											}\n										}\n									}\n									continue w;\n								}\n							}\n						}\n					}\n				}\n				break;\n			}\n			out.println(pow[components()]);\n			for (int i : ans) {\n				out.print(i + 1 + "" "");\n			}\n			out.println();\n		}\n	}\n\n	public void run() {\n		try {\n			if (systemIO) {\n				in = new FastScanner(System.in);\n				out = new PrintWriter(System.out);\n			} else {\n				in = new FastScanner(new File(""input.txt""));\n				out = new PrintWriter(new File(""output.txt""));\n			}\n			solve();\n\n			out.close();\n		} catch (IOException e) {\n			e.printStackTrace();\n		}\n	}\n\n	class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		FastScanner(File f) {\n			try {\n				br = new BufferedReader(new FileReader(f));\n			} catch (FileNotFoundException e) {\n				e.printStackTrace();\n			}\n		}\n\n		FastScanner(InputStream f) {\n			br = new BufferedReader(new InputStreamReader(f));\n		}\n\n		String nextLine() {\n			try {\n				return br.readLine();\n			} catch (IOException e) {\n				return null;\n			}\n		}\n\n		String next() {\n			while (st == null || !st.hasMoreTokens()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			}\n			return st.nextToken();\n		}\n\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n\n	}\n\n	// AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n	public static void main(String[] arg) {\n		long time = System.currentTimeMillis();\n		new C().run();\n		System.err.println(System.currentTimeMillis() - time);\n	}\n}","2-sat,brute force,combinatorics,constructive algorithms,graph matchings,graphs"
"import java.util.*;\n \npublic class Solution {\n	\n	private static Scanner in = new Scanner(System.in);\n	\n	public static void main(String[] args) {\n		\n		int t = in.nextInt();\n		while(t-- > 0)\n			solve();\n    }\n	\n	private static void solve() {\n		int n = in.nextInt();\n		int a[][] = new int[n][2];\n		for(int i=0; i<n; i++) {\n			a[i][0] = in.nextInt();\n			a[i][1] = i;\n		}\n		Arrays.sort(a, new Comparator<int[]>() {\n			public int compare(int[] o1, int[] o2) {\n				return o1[0]-o2[0];\n			}\n		});\n		\n		for(int i=0;i<n;i++)\n		{\n			int oo=0,oe=0,no=0,ne=0;\n			int temp = a[i][0];\n			while(i<n && a[i][0]==temp) {\n				if(i%2==0)	oe++;\n				else	oo++;\n				if(a[i][1]%2==0) ne++;\n				else	no++;\n				i++;\n			}\n			i--;\n			if(oo!=no || oe!=ne) {\n				System.out.println(""NO"");\n				return;\n			}\n		}\n		System.out.println(""YES"");\n	}\n}",sortings
"import java.util.*;\n \npublic class Solution {\n	\n	private static Scanner in = new Scanner(System.in);\n	\n	public static void main(String[] args) {\n		\n		int t = in.nextInt();\n		while(t-- > 0)\n			solve();\n    }\n	\n	private static void solve() {\n		int n = in.nextInt();\n		int a[][] = new int[n][2];\n		for(int i=0; i<n; i++) {\n			a[i][0] = in.nextInt();\n			a[i][1] = i;\n		}\n		Arrays.sort(a, new Comparator<int[]>() {\n			public int compare(int[] o1, int[] o2) {\n				return o1[0]-o2[0];\n			}\n		});\n		\n		for(int i=0;i<n;i++)\n		{\n			int oo=0,oe=0,no=0,ne=0;\n			int temp = a[i][0];\n			while(i<n && a[i][0]==temp) {\n				if(i%2==0)	oe++;\n				else	oo++;\n				if(a[i][1]%2==0) ne++;\n				else	no++;\n				i++;\n			}\n			i--;\n			if(oo!=no || oe!=ne) {\n				System.out.println(""NO"");\n				return;\n			}\n		}\n		System.out.println(""YES"");\n	}\n}",sortings
"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class B_732 {\n\n	@SuppressWarnings(""resource"")\n	public static void main(String[] args) {\n		Scanner input = new Scanner(System.in);\n		int t = input.nextInt();\n		for(int test = 0; test < t; test++) {\n			int n = input.nextInt();\n			int[] a = new int[(n + 1) / 2];\n			int[] b = new int[(n + 1) / 2];\n			for(int i = 0; i < n / 2; i++) {\n				a[i] = input.nextInt();\n				b[i] = input.nextInt();\n			}\n			if(n % 2 == 1) {\n				a[n / 2] = input.nextInt();\n				int[] c = a;\n				a = b;\n				b = c;\n			}\n			Arrays.sort(a);\n			Arrays.sort(b);\n			boolean good = true;\n			for(int i = 0; i < a.length; i++) {\n				if(a[i] > b[i] || i < a.length - 1 && b[i] > a[i + 1]) {\n					good = false;\n					break;\n				}\n			}\n			if(good) {\n				System.out.println(""YES"");\n			}else {\n				System.out.println(""NO"");\n			}\n		}\n	}\n\n}\n",sortings
"\nimport java.util.Arrays;\nimport java.util.Scanner;\n \npublic class B_732 {\n \n	@SuppressWarnings(""resource"")\n	public static void main(String[] args) {\n		Scanner input = new Scanner(System.in);\n		int t = input.nextInt();\n		for(int test = 0; test < t; test++) {\n			int n = input.nextInt();\n			int[] a = new int[(n + 1) / 2];\n			int[] b = new int[(n + 1) / 2];\n			for(int i = 0; i < n / 2; i++) {\n				a[i] = input.nextInt();\n				b[i] = input.nextInt();\n			}\n			if(n % 2 == 1) {\n				a[n / 2] = input.nextInt();\n				int[] c = a;\n				a = b;\n				b = c;\n			}\n			Arrays.sort(a);\n			Arrays.sort(b);\n			boolean good = true;\n			for(int i = 0; i < a.length; i++) {\n				if(a[i] > b[i] || i < a.length - 1 && b[i] > a[i + 1]) {\n					good = false;\n					break;\n				}\n			}\n			if(good) {\n				System.out.println(""YES"");\n			}else {\n				System.out.println(""NO"");\n			}\n		}\n	}\n \n}",sortings
"import java.util.*;\npublic class Main{\npublic static void main(String [] args){  \n Scanner sc = new Scanner(System.in);\nint t = sc.nextInt();\n\nwhile(t-->0)\n{\nint n = sc.nextInt();\nint a[] = new int[n];\nfor(int i=0;i<n;i++){\na[i] = sc.nextInt();\n}\nint cnt = 0;\n\nfor(int i=0;i<n;i++){\nfor(int j=i+1;j<n;j++){\nif(gcd(a[i],2*a[j])>1 || gcd(a[j],2*a[i])>1)cnt++;\n\n}\n}\n\nSystem.out.println(cnt);\n}\n\n}\nstatic int gcd(int a,int b){\nif(b==0) return a;\nelse return gcd(b,a%b);\n}\n}","brute force,greedy,math,number theory,sortings"
"import java.util.*;\npublic class Main{\npublic static void main(String [] args){  \n Scanner sc = new Scanner(System.in);\nint t = sc.nextInt();\n \nwhile(t-->0)\n{\nint n = sc.nextInt();\nint a[] = new int[n];\nfor(int i=0;i<n;i++){\na[i] = sc.nextInt();\n}\nint cnt = 0;\n \nfor(int i=0;i<n;i++){\nfor(int j=i+1;j<n;j++){\nif(gcd(a[i],2*a[j])>1 || gcd(a[j],2*a[i])>1)cnt++;\n \n}\n}\n \nSystem.out.println(cnt);\n}\n \n}\nstatic int gcd(int a,int b){\nif(b==0) return a;\nelse return gcd(b,a%b);\n}\n}","brute force,greedy,math,number theory,sortings"
"import java.util.Scanner;\n \npublic class Main\n{\n	public static int gcd(int a,int b)\n	{\n		if(b==0)\n			return a;\n		return gcd(b, a%b);\n	}\n	\n	public static void main(String[] args)\n	{\n		Scanner sc=new Scanner(System.in);\n		int[] a=new int[2005];\n		int t=sc.nextInt();\n		while(t-->0)\n		{\n			int s=0;\n			int n=sc.nextInt();\n			for(int i=0;i<n;i++)\n				a[i]=sc.nextInt();\n			for(int i=0;i<n-1;i++)\n				for(int j=i+1;j<n;j++)\n					if(gcd(a[i], 2*a[j])>1 || gcd(2*a[i], a[j])>1)\n						s++;\n			System.out.println(s);\n		}\n    }\n}","brute force,greedy,math,number theory,sortings"
"import java.io.*;\nimport java.util.*;\npublic class Solution {\n	static int gcd(int a, int b)\n    {\n      if (b == 0)\n        return a;\n      return gcd(b, a % b);\n    }\n	public static void main(String[] args){\nScanner sc=new Scanner(System.in);\nint T=sc.nextInt();\nwhile(T-->0) {\n		int n=sc.nextInt();\n		int[] a=new int[n];\n		for(int i=0;i<n;i++) a[i]=sc.nextInt();\n		int s=0;\n		for(int i=0;i<n-1;i++)\n			for(int j=i+1;j<n;j++)\n				if(gcd(a[i], 2*a[j])>1 || gcd(2*a[i], a[j])>1)\n					s++;\n		System.out.println(s);\n			  \n}\n	}}","brute force,greedy,math,number theory,sortings"
"import java.util.*;\npublic class poly\n{\n	public static void main(String[] args) {\n		int t,j,i;\n		Scanner sc = new Scanner(System.in);\n		t=sc.nextInt();\n		for(j=0;j<t;j++)\n		{\n			int a[]=new int[4];\n			for(i=0;i<4;i++)\n			{\n				a[i]=sc.nextInt();\n			}\n			if(Math.min(a[0],a[1])>Math.max(a[2],a[3])|| Math.min(a[2],a[3])>Math.max(a[0],a[1]))\n				System.out.println(""NO"");\n			else\n				System.out.println(""YES"");\n\n			\n		}\n	}\n}","brute force,implementation"
"import java.util.*;\npublic class codeforce\n{ \npublic static void main (String args[])\n{\nScanner in=new Scanner (System.in);\nint n=in.nextInt();\nwhile(n-->0)\n{\nint a=in.nextInt();\nint b=in.nextInt();\nint c=in.nextInt();\nint d=in.nextInt();\nint max1=Math.max(a,b);\nint min1=Math.min(a,b);\nint max2=Math.max(c,d);\nint min2=Math.min(c,d);\nif(max1>min2&&max2>min1)\nSystem.out.println(""Yes"");\nelse\nSystem.out.println(""No"");\n}\n}\n}","brute force,implementation"
"import java.util.*;\npublic class a{\n	public static void main(String args[])\n	{\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0){\n			int a=sc.nextInt();\n			int b=sc.nextInt();\n			int c=sc.nextInt();\n			int d=sc.nextInt();\n			int ar[]=new int[]{a,b,c,d};\n			Arrays.sort(ar);\n			if(Math.max(a,b)+Math.max(c,d)==ar[2]+ar[3]){\n				System.out.println(""YES"");\n			}\n			else{\n				System.out.println(""NO"");\n			}\n		}\n	}\n}","brute force,implementation"
"import java.util.*;\npublic class Main{\npublic static void main(String [] args){  \n Scanner sc = new Scanner(System.in);\nint t = sc.nextInt();\n\nwhile(t-->0)\n{\nint a = sc.nextInt();\nint b = sc.nextInt();\nint c = sc.nextInt();\nint d = sc.nextInt();\nint max1 = Math.max(a,b);\nint min1 = Math.min(a,b);\nint max2 = Math.max(c,d);\nint min2 = Math.min(c,d);\nif(max1>min2 && max2>min1) System.out.println(""YES"");\nelse System.out.println(""NO"");\n}\n\n}\n}","brute force,implementation"
"import java.util.Scanner;\n\npublic class Main\n{\n	public static void main(String[] args)\n	{\n		Scanner sc=new Scanner(System.in);\n		String[] s=new String[55];\n		char[] cc= {'R','W'};\n		int t=sc.nextInt();\n		while(t-->0)\n		{\n			int n=sc.nextInt();\n			int m=sc.nextInt();\n			int[] r=new int[2];\n			int[] w=new int[2];\n			for(int i=0;i<n;i++)\n			{\n				s[i]=sc.next();\n				for(int j=0;j<m;j++)\n				{\n					char c=s[i].charAt(j);\n					if(c=='R')\n						r[i+j&1]=1;\n					else if(c=='W')\n						w[i+j&1]=1;\n				}\n			}\n			int v=r[1] | w[0];\n			int vv=r[0] | w[1];\n			if((v & vv)==1)\n			{\n				System.out.println(""NO"");\n				continue;\n			}\n			System.out.println(""YES"");\n			for(int i=0;i<n;i++)\n			{\n				for(int j=0;j<m;j++)\n				{\n					char c=cc[i+j+v&1];\n					System.out.print(c);\n				}\n				System.out.println();\n			}\n		}\n    }\n}","brute force,implementation"
"import java.util.*;\npublic class ColourFlag {\n	\n// https://codeforces.com/problemset/problem/1534/A\n	static Scanner scn = new Scanner(System.in);\n	public static void solve() {\n		int h = scn.nextInt() , w = scn.nextInt();\n		boolean f1 = false , f2 = false;\n		char[][] board = new char[h][];\n		for(int i=0 ; i<h ; i++) {\n			board[i] = scn.next().toCharArray();\n		}\n		for(int x = 0 ; x<w ; x++) {\n			for(int y = 0 ; y<h ; y++) {\n				if(board[y][x] != '.') {\n					if(board[y][x]=='W' == ((x+y)%2==0))\n						f1 = true;\n					else\n						f2 = true;\n				}\n			}\n			\n		}\n		if(f1&&f2)\n			System.out.println(""No"");\n		else {\n			System.out.println(""Yes"");\n			if(f1) {\n				for(int y=0 ; y<h ; y++) {\n					for(int x = 0 ; x<w ; x++) {\n						System.out.print((x+y)%2==0?""W"":""R"");\n					}\n					System.out.println();\n				}\n			}\n			else {\n				for (int y=0; y<h; y++) {\n					for (int x=0; x<w; x++) {\n						System.out.print((x+y)%2!=0?""W"":""R"");\n					}\n					System.out.println();\n				}\n			}\n		}\n	}\n	\n	public static void main(String[] args) {\n		\n		\n		int t = scn.nextInt();\n		while(t-->0) {\n			solve();\n		}\n	}\n}\n","brute force,implementation"
"import java.util.*;\n \npublic class practice {\n\n\n    public static void main(String[] args) {\n \n		Scanner scan = new Scanner(System.in);\n\n        int t = scan.nextInt();\n\n        while (t --> 0) {\n\n            int n = scan.nextInt();\n            int m = scan.nextInt();\n\n            char[][] arr = new char[n][m];\n            boolean w1 = false, w2 = false;\n\n            for (int i = 0; i < n; i++) arr[i] = scan.next().toCharArray();\n\n            for (int i = 0; i < n; i++) {\n\n                for (int j = 0; j < m; j++) {\n\n                    if (arr[i][j] != '.') {\n\n                        if (arr[i][j] == 'W' == ((i + j) % 2 == 0)) w1 = true;\n                        else w2 = true;\n                    }\n                }\n            }\n\n            if (w1 && w2) System.out.println(""No"");\n            else {\n\n                System.out.println(""Yes"");\n\n                if (w1) {\n\n                    for (int i = 0; i < n; i++) {\n\n                        for (int j = 0; j < m; j++) System.out.print((i + j) % 2 == 0 ? ""W"" : ""R"");\n                        System.out.println();\n                    }\n                } else {\n\n                    for (int i = 0; i < n; i++) {\n\n                        for (int j = 0; j < m; j++) System.out.print((i + j) % 2 != 0 ? ""W"" : ""R"");\n                        System.out.println();\n                    }\n                }\n            }\n        }\n\n        scan.close();\n    }\n}","brute force,implementation"
"import java.util.*;\npublic class j\n{\n  static class Cell\n  {\n    int r;int c;\n    char ch;\n    Cell(int r,int c,char ch)\n    {\n      this.r=r;this.c=c;this.ch=ch;\n    }\n  }\n  public static void main(String args[])\n  {\n    Scanner in=new Scanner(System.in);\n    int t=in.nextInt();\n    while(t-->0)\n    {\n      int m=in.nextInt();\n      int n=in.nextInt();\n      int flag=0;\n      char mat[][]=new char[m][n];\n      for(int i=0;i<m;i++)\n      {String ss=in.next();\n        for(int j=0;j<n;j++)\n        mat[i][j]=ss.charAt(j);\n      }int one_or_two=0;\n      for(int i21=0;i21<2;i21++)\n      {int ttt=0;\n        for(int i=0;i<m;i++)\n        {\n          for(int j=0;j<n;j++)\n          {\n            int tt=(i+j+i21)%2;\n            char ch=tt%2==0?'R':'W';\n          //  System.out.print(ch);\n            if(mat[i][j]!='.' && ch!=mat[i][j]){\n          ttt=1;\n            break;\n            }\n          }\n          if(ttt==1)\n          break;\n         // System.out.println();\n        }\n        if(ttt==0){\n        flag=1;one_or_two=i21;break;\n        }\n      }\n      if(flag==1)\n      {\n      System.out.println(""YES"");\n      for(int i=0;i<m;i++)\n      {\n       for(int j=0;j<n;j++)\n       {\n         int e=(i+j+one_or_two)%2;\n         if(e%2==0)\n         System.out.print(""R"");\n         else\n         System.out.print(""W"");\n       }\n       System.out.println();\n      }\n      }else\n      System.out.println(""NO"");\n      }\n  }\n}","brute force,implementation"
"import java.util.*;\npublic class Main\n{\n	public static void main(String[] args) {\n		Scanner s=new Scanner(System.in);\n		int t=s.nextInt();\n		while(t-->0){\n		    int n=s.nextInt(); s.nextLine();\n		    int c=0;\n		    String S=s.nextLine();\n		    for(int i=0;i<n;i++)\n		    if(S.charAt(i)=='0') c++;\n		    if(c==1||c%2==0) System.out.println(""BOB"");\n		    else System.out.println(""ALICE"");\n		}\n	}\n}","constructive algorithms,games"
"import java.io.*;\nimport java.util.*;\n\n\npublic class palindrome_easy {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0) {\n			int n=sc.nextInt();\n			String a=sc.next();\n			if(a.length()-a.replace(""0"", """").length()==1||(a.length()-a.replace(""0"", """").length())%2==0) {\n				System.out.println(""BOB"");\n			}else System.out.println(""ALICE"");\n		}\n	}\n}\n","constructive algorithms,games"
"import java.util.Scanner;\n\npublic class Main\n{\n\n	public static void main(String[] args)\n	{\n		Scanner sc = new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0)\n		{\n			int n=sc.nextInt();\n			String a=sc.next();\n			if(a.length()-a.replace(""0"", """").length()==1||(a.length()-a.replace(""0"", """").length())%2==0)\n			{\n				System.out.println(""BOB"");\n			}else System.out.println(""ALICE"");\n		}\n	}\n\n}","constructive algorithms,games"
"import java.util.Scanner;\n \npublic class Main\n{\n \n	public static void main(String[] args)\n	{\n		Scanner sc = new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0)\n		{\n			int n=sc.nextInt();\n			String a=sc.next();\n			if(a.length()-a.replace(""0"", """").length()==1||(a.length()-a.replace(""0"", """").length())%2==0)\n			{\n				System.out.println(""BOB"");\n			}else System.out.println(""ALICE"");\n		}\n	}\n \n}","constructive algorithms,games"
import java.util.*;\npublic class Main{\npublic static void main(String [] args){  //.c.d.f.r.c.s\n\n Scanner sc = new Scanner(System.in);\n\nint t = sc.nextInt();\nwhile(t-->0){\nint  n = sc.nextInt(); \nSystem.out.println(solve(n));\n}\n}\nstatic int solve(int n){\nint ans =0;\nfor(int j=1;j<=n;j=j*10+1){\nfor(int i=1;i<=9;i++){\nif(j*i<=n) ans++;\n}\n}\nreturn ans;\n}\n},"brute force,math,number theory"
import java.util.*;\npublic class Main{\npublic static void main(String [] args){  //.c.d.f.r.c.s\n \n Scanner sc = new Scanner(System.in);\n \nint t = sc.nextInt();\nwhile(t-->0){\nint  n = sc.nextInt(); \nSystem.out.println(solve(n));\n}\n}\nstatic int solve(int n){\nint ans =0;\nfor(int j=1;j<=n;j=j*10+1){\nfor(int i=1;i<=9;i++){\nif(j*i<=n) ans++;\n}\n}\nreturn ans;\n}\n},"brute force,math,number theory"
"\nimport java.util.Scanner;\nimport java.lang.Math;\npublic class hl{\npublic static void main(String[] args) {\n	Scanner s= new Scanner(System.in);\n	int t=s.nextInt();\n	while(t!=0) {	\n	int n=s.nextInt();\n	int c=0,m=0,d=n;\n	while(n!=0) {\n		n=n/10;\n		c++;\n		m+= Math.pow(10,c-1);\n	}\n//	System.out.println(n+"" ""+m);\n	\n	System.out.println(d/m+9*(c-1));\n	t--;\n	}\n}\n}","brute force,math,number theory"
"import java.util.Scanner;\nimport java.lang.String;\npublic class B{\n   public static void main(String[]args){\n    Scanner sc= new Scanner(System.in);\n    int t= sc.nextInt();\n    while(t-->0){\n     int n= sc.nextInt();\n      int k=(int)Math.log10(n);\n      String one=""1"";\n      int mul=Integer.parseInt(one.repeat(k+1));\n      System.out.println(k*9+n/mul);\n    }\n  }\n}","brute force,math,number theory"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1516C extends PrintWriter {\n	CF1516C() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1516C o = new CF1516C(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int[] aa = new int[n];\n		int s = 0;\n		for (int i = 0; i < n; i++)\n			s += aa[i] = sc.nextInt();\n		if (s % 2 == 1) {\n			println(0);\n			return;\n		}\n		s /= 2;\n		boolean[] yes = new boolean[s + 1]; yes[0] = true;\n		for (int i = 0; i < n; i++) {\n			int a = aa[i];\n			for (int r = s; r >= a; r--)\n				if (yes[r - a])\n					yes[r] = true;\n		}\n		if (!yes[s]) {\n			println(0);\n			return;\n		}\n		for (int h = 0; h < 11; h++)\n			for (int i = 0; i < n; i++)\n				if ((aa[i] & 1 << h) != 0) {\n					println(1);\n					println(i + 1);\n					return;\n				}\n	}\n}\n","bitmasks,constructive algorithms,dp,math"
"import java.util.*;\npublic class Solve{\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        int[] k=new int[200002];\n           int n=sc.nextInt();\n           int[] ar=new int[n]; int sum=0;\n           for(int i=0;i<n;i++){ar[i]=sc.nextInt();sum+=ar[i];}\n           k[0]=1;\n        for(int i=0;i<n;i++){\n            for(int j=k.length-1;j>=0;j--){\n                if(j+ar[i]<k.length)if(k[j]==1)k[j+ar[i]]=1;\n               }\n            }\n            if(sum%2==1 || k[sum/2]==0)System.out.println(""0"");\n             else{ int ans=31;\n                 int pos=0;\n                 for(int i=0;i<n;i++){\n                    int x=Integer.numberOfTrailingZeros(ar[i]);\n                     if(ans>x){\n                         ans=x;\n                         pos=i;\n                     }\n                 }\n                 pos++;\n                 System.out.println(""1\n""+pos);\n             }\n    }\n}","bitmasks,constructive algorithms,dp,math"
"import java.io.*;\nimport java.util.*;\n\npublic class Codeforces\n{\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb=new StringBuilder();\n        int n=Integer.parseInt(bu.readLine());\n        String s[]=bu.readLine().split("" "");\n        int i,sum=0,a[]=new int[n],j;\n        for(i=0;i<n;i++)\n        {\n            a[i]=Integer.parseInt(s[i]);\n            sum+=a[i];\n        }\n        if(sum%2==1) {System.out.println(0); return;}\n\n        boolean dp[][]=new boolean[n+1][sum+1];\n        dp[0][0]=true;\n        for(i=1;i<=n;i++)\n        for(j=0;j<=sum;j++)\n        if(j<a[i-1]) dp[i][j]=dp[i-1][j];\n        else dp[i][j]=dp[i-1][j] | dp[i-1][j-a[i-1]];\n\n        if(!dp[n][sum/2]) {System.out.println(0); return;}\n\n        sb.append(""1\n"");\n        int f=-1;\n        while(f==-1)\n        {\n            for(i=0;i<n;i++)\n            if(a[i]%2==1) {f=i+1; break;}\n            else a[i]/=2;\n        }\n\n        sb.append(f+""\n"");\n        System.out.print(sb);\n    }\n}","bitmasks,constructive algorithms,dp,math"
import java.util.*;\npublic class Problem1516c {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        int s = 0;\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n            s += a[i];\n        }\n        if (s % 2 == 1) {\n            System.out.println(0);\n            return;\n        }\n        s /= 2;\n        boolean[] flag = new boolean[s + 1];\n        flag[0] = true;\n        for (int i = 0; i < n; i++) {\n            int aa = a[i];\n            for (int r = s; r >= aa; r--) {\n                if (flag[r - aa]) {\n                    flag[r] = true;\n                }\n            }\n        }\n        if (!flag[s]) {\n            System.out.println(0);\n            return;\n        }\n        for (int h = 0; h < 11; h++) {\n            for (int i = 0; i < n; i++) {\n                if ((a[i] & 1 << h) != 0) {\n                    System.out.println(1);\n                    System.out.println(i + 1);\n                    return;\n                }\n            }\n        }\n    }\n},"bitmasks,constructive algorithms,dp,math"
"import java.util.Scanner;\nimport java.util.Arrays;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while(t-->0) {\n			int n = sc.nextInt();\n			Long b[] = new Long[n+2];\n			for(int i=0;i<=n+1;i++) {\n				b[i] = sc.nextLong();\n			}\n			Arrays.sort(b);\n			long sum = 0;\n			for(int i=0;i<=n;i++) {\n				sum+=b[i];\n			}\n			int id = -1;\n			for(int i=0;i<=n;i++) {\n				if((sum-b[i])==b[n+1]) {\n					id=i;\n					break;\n				}\n			}\n			if(id==-1) {\n				sum-=b[n];\n				if(sum==b[n]) {\n					id = n;\n				}\n			}\n			if(id == -1) {\n				System.out.println(-1);\n			}else {\n				for(int i=0;i<=n;i++) {\n					if(i!=id) System.out.print(b[i]+"" "");\n				}\n				System.out.println();\n			}\n		}\n	}\n}","constructive algorithms,data structures,greedy"
"import java.util.Scanner;\nimport java.util.Arrays;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while(t-->0) {\n			int n = sc.nextInt();\n			Long b[] = new Long[n+2];\n			for(int i=0;i<=n+1;i++) {\n				b[i] = sc.nextLong();\n			}\n			Arrays.sort(b);\n			long sum = 0;\n			for(int i=0;i<=n;i++) {\n				sum+=b[i];\n			}\n			int id = -1;\n			for(int i=0;i<=n;i++) {\n				if((sum-b[i])==b[n+1]) {\n					id=i;\n					break;\n				}\n			}\n			if(id==-1) {\n				sum-=b[n];\n				if(sum==b[n]) {\n					id = n;\n				}\n			}\n			if(id == -1) {\n				System.out.println(-1);\n			}else {\n				for(int i=0;i<=n;i++) {\n					if(i!=id) System.out.print(b[i]+"" "");\n				}\n				System.out.println();\n			}\n		}\n	}\n}","constructive algorithms,data structures,greedy"
"import java.util.Scanner;\nimport java.util.Arrays;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while(t-->0) {\n			int n = sc.nextInt();\n			Long b[] = new Long[n+2];\n			for(int i=0;i<=n+1;i++) {\n				b[i] = sc.nextLong();\n			}\n			Arrays.sort(b);\n			long sum = 0;\n			for(int i=0;i<=n;i++) {\n				sum+=b[i];\n			}\n			int id = -1;\n			for(int i=0;i<=n;i++) {\n				if((sum-b[i])==b[n+1]) {\n					id=i;\n					break;\n				}\n			}\n			if(id==-1) {\n				sum-=b[n];\n				if(sum==b[n]) {\n					id = n;\n				}\n			}\n			if(id == -1) {\n				System.out.println(-1);\n			}else {\n				for(int i=0;i<=n;i++) {\n					if(i!=id) System.out.print(b[i]+"" "");\n				}\n				System.out.println();\n			}\n		}\n	}\n}","constructive algorithms,data structures,greedy"
"import java.util.Scanner;\nimport java.util.Arrays;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while(t-->0) {\n			int n = sc.nextInt();\n			Long b[] = new Long[n+2];\n			for(int i=0;i<=n+1;i++) {\n				b[i] = sc.nextLong();\n			}\n			Arrays.sort(b);\n			long sum = 0;\n			for(int i=0;i<=n;i++) {\n				sum+=b[i];\n			}\n			int id = -1;\n			for(int i=0;i<=n;i++) {\n				if((sum-b[i])==b[n+1]) {\n					id=i;\n					break;\n				}\n			}\n			if(id==-1) {\n				sum-=b[n];\n				if(sum==b[n]) {\n					id = n;\n				}\n			}\n			if(id == -1) {\n				System.out.println(-1);\n			}else {\n				for(int i=0;i<=n;i++) {\n					if(i!=id) System.out.print(b[i]+"" "");\n				}\n				System.out.println();\n			}\n		}\n	}\n}","constructive algorithms,data structures,greedy"
"import java.io.*;\nimport java.util.*;\n\npublic class Main{\n	static void main() throws Exception{\n		int n=sc.nextInt(),m=sc.nextInt();\n		int[]pref=new int[m];\n		for(int i=0;i<n;i++) {\n			pref[sc.nextInt()-1]^=1;\n		}\n		for(int i=1;i<m;i++)pref[i]^=pref[i-1];\n		int[][]xor=new int[m][20];\n		for(int i=1,len=2;len<=m;i++,len<<=1) {\n			for(int j=0;j<m;j++) {\n				int left=xor[j][i-1],right=j+(len>>1)>=m?0:xor[j+(len>>1)][i-1];\n				xor[j][i]=left^right;\n				int odd=j+(len>>1)<m && (pref[Math.min(m-1, j+len-1)]^pref[j+(len>>1)-1])==1?1:0;\n				xor[j][i]^=(odd)*(len>>1);\n			}\n		}\n		char[]ans= {'B','A'};\n		int q=sc.nextInt();\n		while(q-->0) {\n			int l=sc.nextInt()-1,r=sc.nextInt()-1;\n			int curxor=0;\n			for(int i=19,len=1<<i;i>0;i--,len>>=1) {\n				if(l+len-1>r)continue;\n				curxor^=xor[l][i];\n				int odd=(pref[r]^pref[l+(len)-1]);\n				curxor^=(odd)*(len);\n				l+=len;\n			}\n			pw.print(ans[Math.min(curxor, 1)]);\n		}\n		pw.println();\n    }\n    public static void main(String[] args) throws Exception{\n    	sc=new MScanner(System.in);\n    	pw = new PrintWriter(System.out);\n        int tc=1;\n//        tc=sc.nextInt();\n        for(int i=1;i<=tc;i++) {\n//            pw.printf(""Case #%d:"", i);\n            main();\n        }\n        pw.flush();\n    }\n    static PrintWriter pw;\n    static MScanner sc;\n    static class MScanner {\n        StringTokenizer st;\n        BufferedReader br;\n        public MScanner(InputStream system) {\n            br = new BufferedReader(new InputStreamReader(system));\n        }\n     \n        public MScanner(String file) throws Exception {\n            br = new BufferedReader(new FileReader(file));\n        }\n     \n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        public int[] intArr(int n) throws IOException {\n            int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n            return in;\n        }\n        public long[] longArr(int n) throws IOException {\n            long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n            return in;\n        }\n        public int[] intSortedArr(int n) throws IOException {\n            int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n            shuffle(in);\n            Arrays.sort(in);\n            return in;\n        }\n        public long[] longSortedArr(int n) throws IOException {\n            long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n            shuffle(in);\n            Arrays.sort(in);\n            return in;\n        }\n        public Integer[] IntegerArr(int n) throws IOException {\n            Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n            return in;\n        }\n        public Long[] LongArr(int n) throws IOException {\n            Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n            return in;\n        }\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n     \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n     \n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n     \n        public char nextChar() throws IOException {\n            return next().charAt(0);\n        }\n     \n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n     \n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n     \n        public void waitForInput() throws InterruptedException {\n            Thread.sleep(3000);\n        }\n        \n    }\n    static void shuffle(int[]in) {\n        for(int i=0;i<in.length;i++) {\n            int idx=(int)(Math.random()*in.length);\n            int tmp=in[i];\n            in[i]=in[idx];\n            in[idx]=tmp;\n        }\n    }\n    static void shuffle(long[]in) {\n        for(int i=0;i<in.length;i++) {\n            int idx=(int)(Math.random()*in.length);\n            long tmp=in[i];\n            in[i]=in[idx];\n            in[idx]=tmp;\n        }\n    }\n}","bitmasks,brute force,data structures,dp,games,two pointers"
"//package round715;\nimport java.io.*;\nimport java.util.*;\n\npublic class E {\n	InputStream is;\n	FastWriter out;\n	String INPUT = """";\n\n	void solve()\n	{\n		int n = ni();\n		int[] a = na(n);\n		int[] from = new int[n - 1];\n		int[] to = new int[n - 1];\n		for (int i = 0; i < n - 1; i++) {\n			from[i] = ni() - 1;\n			to[i] = ni() - 1;\n		}\n		int[][] g = packU(n, from, to);\n		int[][] pars = parents(g, 0);\n		int[] par = pars[0], ord = pars[1], dep = pars[2];\n\n		HeavyLightDecomposition hld = new HeavyLightDecomposition(g, par, ord, dep);\n		Node[] nodes = new Node[n];\n		Node[] roots = new Node[hld.m];\n		int[][] fts = new int[hld.m][];\n		int[] lclus = new int[n];\n		for(int i = 0;i < hld.m;i++){\n			fts[i] = new int[hld.cluspath[i].length + 3];\n			Node root = null;\n			for(int j = 0;j < hld.cluspath[i].length;j++){\n				nodes[a[hld.cluspath[i][j]]-1] = new Node(a[hld.cluspath[i][j]]-1);\n				lclus[a[hld.cluspath[i][j]]-1] = i;\n				root = merge(root, nodes[a[hld.cluspath[i][j]]-1]);\n			}\n			roots[i] = root;\n		}\n\n		long age = 0;\n		boolean first = true;\n		for(int i = n-1;i >= 0;i--){\n			Node tar = nodes[i];\n//			tr(tar);\n\n			addFenwick(fts[lclus[i]], index(tar), 1);\n			long nm = 0;\n			boolean allmore = true;\n			int vtar = hld.cluspath[lclus[i]][index(tar)];\n//			tr(vtar);\n			Deque<int[]> dq = new ArrayDeque<>();\n			for(int x = vtar;;){\n				int cx = hld.clus[x];\n				int l = 0;\n				int r = hld.clusiind[x];\n				dq.add(new int[]{cx, r});\n\n				int more = sumFenwick(fts[cx], r);\n				if(more != r+1) {\n					allmore = false;\n				}\n				nm += more;\n\n				if(cx == 0)break;\n				x = par[hld.cluspath[cx][0]];\n			}\n//			tr(i, nm, allmore, lclus[i]);\n			if(nm != 1 && !allmore){\n				out.println(""NO"");\n				return;\n			}\n			if(nm == 1)continue;\n			assert allmore;\n\n			if(!first){\n				if(next(tar) != null){\n					out.println(""NO"");\n					return;\n				}\n				if(g[vtar].length != 1){\n					out.println(""NO"");\n					return;\n				}\n			}\n			Node nex = null;\n			while(!dq.isEmpty()){\n				int[] cur = dq.pollLast();\n				int cl = cur[0], r = cur[1];\n\n				Node[] lm_r = split(roots[cl], r+1);\n				Node[] l_m = split(lm_r[0], r);\n				roots[cl] = merge(l_m[0], lm_r[1]);\n				if(nex != null){\n					lclus[nex.v] = cl;\n					roots[cl] = merge(nex, roots[cl]);\n				}\n				nex = l_m[1];\n			}\n			roots[0] = merge(nex, roots[0]);\n			assert i == nex.v;\n			lclus[i] = 0;\n\n			age += dep[vtar];\n\n			first = true;\n		}\n\n		int[] anss = new int[n];\n		for(int i = 0;i < n;i++){\n			Node tar = nodes[i];\n			int vtar = hld.cluspath[lclus[i]][index(tar)];\n			anss[vtar] = i+1;\n		}\n		int[] mins = new int[n];\n		int[] maxs = new int[n];\n		int[] des = new int[n];\n		Arrays.fill(des, 1);\n		for(int i = n-1;i >= 1;i--){\n			des[par[ord[i]]] += des[ord[i]];\n		}\n		Arrays.fill(mins, 9999999);\n		for(int i = n-1;i >= 0;i--){\n			int cur = ord[i];\n			for(int e : g[cur]){\n				if(par[cur] == e)continue;\n				mins[cur] = Math.min(mins[cur], mins[e]);\n				maxs[cur] = Math.max(maxs[cur], maxs[e]);\n			}\n			if(des[cur] != 1 && mins[cur] != anss[cur] + 1){\n				out.println(""NO"");\n				return;\n			}\n			mins[cur] = Math.min(mins[cur], anss[cur]);\n			maxs[cur] = Math.max(maxs[cur], anss[cur]);\n			if(maxs[cur] - mins[cur] + 1 != des[cur]){\n				out.println(""NO"");\n				return;\n			}\n		}\n		out.println(""YES"");\n		out.println(age);\n		out.println(anss);\n	}\n	public static int sumFenwick(int[] ft, int i)\n	{\n		int sum = 0;\n		for(i++;i > 0;i -= i&-i)sum += ft[i];\n		return sum;\n	}\n\n	public static void addFenwick(int[] ft, int l, int r, int v)\n	{\n		addFenwick(ft, l, v);\n		addFenwick(ft, r, -v);\n	}\n\n	public static void addFenwick(int[] ft, int i, int v)\n	{\n		if(v == 0 || i < 0)return;\n		int n = ft.length;\n		for(i++;i < n;i += i&-i)ft[i] += v;\n	}\n\n\n\n	public static Random gen = new Random();\n\n	static public class Node\n	{\n		public int v; // value\n		public long priority;\n		public Node left, right, parent;\n\n		public int count;\n\n		public Node(int v)\n		{\n			this.v = v;\n			priority = gen.nextLong();\n			update(this);\n		}\n\n		@Override\n		public String toString() {\n			StringBuilder builder = new StringBuilder();\n			builder.append(""Node [v="");\n			builder.append(v);\n			builder.append("", count="");\n			builder.append(count);\n			builder.append("", parent="");\n			builder.append(parent != null ? parent.v : ""null"");\n			builder.append(""]"");\n			return builder.toString();\n		}\n	}\n\n	public static Node update(Node a)\n	{\n		if(a == null)return null;\n		a.count = 1;\n		if(a.left != null)a.count += a.left.count;\n		if(a.right != null)a.count += a.right.count;\n\n		// TODO\n		return a;\n	}\n\n	public static void propagate(Node x)\n	{\n		for(;x != null;x = x.parent)update(x);\n	}\n\n	public static Node disconnect(Node a)\n	{\n		if(a == null)return null;\n		a.left = a.right = a.parent = null;\n		return update(a);\n	}\n\n	public static Node root(Node x)\n	{\n		if(x == null)return null;\n		while(x.parent != null)x = x.parent;\n		return x;\n	}\n\n	public static int count(Node a)\n	{\n		return a == null ? 0 : a.count;\n	}\n\n	public static void setParent(Node a, Node par)\n	{\n		if(a != null)a.parent = par;\n	}\n\n	public static Node merge(Node a, Node b, Node... c)\n	{\n		Node x = merge(a, b);\n		for(Node n : c)x = merge(x, n);\n		return x;\n	}\n\n	public static Node merge(Node a, Node b)\n	{\n		if(b == null)return a;\n		if(a == null)return b;\n		if(a.priority > b.priority){\n			setParent(a.right, null);\n			setParent(b, null);\n			a.right = merge(a.right, b);\n			setParent(a.right, a);\n			return update(a);\n		}else{\n			setParent(a, null);\n			setParent(b.left, null);\n			b.left = merge(a, b.left);\n			setParent(b.left, b);\n			return update(b);\n		}\n	}\n\n	public static Node[] split(Node x)\n	{\n		if(x == null)return new Node[]{null, null};\n		if(x.left != null)x.left.parent = null;\n		Node[] sp = new Node[]{x.left, x};\n		x.left = null;\n		update(x);\n		while(x.parent != null){\n			Node p = x.parent;\n			x.parent = null;\n			if(x == p.left){\n				p.left = sp[1];\n				if(sp[1] != null)sp[1].parent = p;\n				sp[1] = p;\n			}else{\n				p.right = sp[0];\n				if(sp[0] != null)sp[0].parent = p;\n				sp[0] = p;\n			}\n			update(p);\n			x = p;\n		}\n		return sp;\n	}\n\n	public static Node[] split(Node a, int... ks)\n	{\n		int n = ks.length;\n		if(n == 0)return new Node[]{a};\n		for(int i = 0;i < n-1;i++){\n			if(ks[i] > ks[i+1])throw new IllegalArgumentException(Arrays.toString(ks));\n		}\n\n		Node[] ns = new Node[n+1];\n		Node cur = a;\n		for(int i = n-1;i >= 0;i--){\n			Node[] sp = split(cur, ks[i]);\n			cur = sp[0];\n			ns[i] = sp[0];\n			ns[i+1] = sp[1];\n		}\n		return ns;\n	}\n\n	// [0,K),[K,N)\n	public static Node[] split(Node a, int K)\n	{\n		if(a == null)return new Node[]{null, null};\n		if(K <= count(a.left)){\n			setParent(a.left, null);\n			Node[] s = split(a.left, K);\n			a.left = s[1];\n			setParent(a.left, a);\n			s[1] = update(a);\n			return s;\n		}else{\n			setParent(a.right, null);\n			Node[] s = split(a.right, K-count(a.left)-1);\n			a.right = s[0];\n			setParent(a.right, a);\n			s[0] = update(a);\n			return s;\n		}\n	}\n\n	public static Node insertb(Node root, Node x)\n	{\n		int ind = lowerBound(root, x.v);\n		return insert(root, ind, x);\n	}\n\n	public static Node insert(Node a, int K, Node b)\n	{\n		if(a == null)return b;\n		if(b.priority < a.priority){\n			if(K <= count(a.left)){\n				a.left = insert(a.left, K, b);\n				setParent(a.left, a);\n			}else{\n				a.right = insert(a.right, K-count(a.left)-1, b);\n				setParent(a.right, a);\n			}\n			return update(a);\n		}else{\n			Node[] ch = split(a, K);\n			b.left = ch[0]; b.right = ch[1];\n			setParent(b.left, b);\n			setParent(b.right, b);\n			return update(b);\n		}\n	}\n\n	// delete K-th\n	public static Node erase(Node a, int K)\n	{\n		if(a == null)return null;\n		if(K < count(a.left)){\n			a.left = erase(a.left, K);\n			setParent(a.left, a);\n			return update(a);\n		}else if(K == count(a.left)){\n			setParent(a.left, null);\n			setParent(a.right, null);\n			Node aa = merge(a.left, a.right);\n			disconnect(a);\n			return aa;\n		}else{\n			a.right = erase(a.right, K-count(a.left)-1);\n			setParent(a.right, a);\n			return update(a);\n		}\n	}\n\n	public static Node get(Node a, int K)\n	{\n		while(a != null){\n			if(K < count(a.left)){\n				a = a.left;\n			}else if(K == count(a.left)){\n				break;\n			}else{\n				K = K - count(a.left)-1;\n				a = a.right;\n			}\n		}\n		return a;\n	}\n\n	public static int index(Node a)\n	{\n		if(a == null)return -1;\n		int ind = count(a.left);\n		while(a != null){\n			Node par = a.parent;\n			if(par != null && par.right == a){\n				ind += count(par.left) + 1;\n			}\n			a = par;\n		}\n		return ind;\n	}\n\n	public static Node mergeTechnically(Node x, Node y)\n	{\n		if(count(x) > count(y)){\n			Node d = x; x = y; y = d;\n		}\n		// |x|<=|y|\n		for(Node cur : nodesdfs(x))y = insertb(y, disconnect(cur));\n		return y;\n	}\n\n	public static int lowerBound(Node a, int q)\n	{\n		int lcount = 0;\n		while(a != null){\n			if(a.v >= q){\n				a = a.left;\n			}else{\n				lcount += count(a.left) + 1;\n				a = a.right;\n			}\n		}\n		return lcount;\n	}\n\n	public static int search(Node a, int q)\n	{\n		int lcount = 0;\n		while(a != null){\n			if(a.v == q){\n				lcount += count(a.left);\n				break;\n			}\n			if(q < a.v){\n				a = a.left;\n			}else{\n				lcount += count(a.left) + 1;\n				a = a.right;\n			}\n		}\n		return a == null ? -(lcount+1) : lcount;\n	}\n\n	public static Node next(Node x)\n	{\n		if(x == null)return null;\n		if(x.right != null){\n			x = x.right;\n			while(x.left != null)x = x.left;\n			return x;\n		}else{\n			while(true){\n				Node p = x.parent;\n				if(p == null)return null;\n				if(p.left == x)return p;\n				x = p;\n			}\n		}\n	}\n\n	public static Node prev(Node x)\n	{\n		if(x == null)return null;\n		if(x.left != null){\n			x = x.left;\n			while(x.right != null)x = x.right;\n			return x;\n		}else{\n			while(true){\n				Node p = x.parent;\n				if(p == null)return null;\n				if(p.right == x)return p;\n				x = p;\n			}\n		}\n	}\n\n	public static Node build(int[] a, int l, int r)\n	{\n		if(l >= r)return null;\n\n		int h = l+r>>1;\n		Node root = new Node(a[h]);\n\n		Node L = build(a, l, h);\n		root.left = L;\n		if(L != null)L.parent = root;\n\n		Node R = build(a, h+1, r);\n		root.right = R;\n		if(R != null)R.parent = root;\n\n		return update(root);\n	}\n\n\n	public static Node[] nodes(Node a) { return nodes(a, new Node[count(a)], 0, count(a)); }\n	public static Node[] nodes(Node a, Node[] ns, int L, int R)\n	{\n		if(a == null)return ns;\n		nodes(a.left, ns, L, L+count(a.left));\n		ns[L+count(a.left)] = a;\n		nodes(a.right, ns, R-count(a.right), R);\n		return ns;\n	}\n\n	// faster than nodes but inconsistent\n	public static Node[] nodesdfs(Node a) { return nodesdfs(a, new Node[a.count], new int[]{0}); }\n	public static Node[] nodesdfs(Node a, Node[] ns, int[] pos)\n	{\n		if(a == null)return ns;\n		ns[pos[0]++] = a;\n		nodesdfs(a.left, ns, pos);\n		nodesdfs(a.right, ns, pos);\n		return ns;\n	}\n\n	public static String toString(Node a, String indent)\n	{\n		if(a == null)return """";\n		StringBuilder sb = new StringBuilder();\n		sb.append(toString(a.left, indent + ""  ""));\n		sb.append(indent).append(a).append(""\n"");\n		sb.append(toString(a.right, indent + ""  ""));\n		return sb.toString();\n	}\n\n\n	public static class HeavyLightDecomposition {\n		public int[][] g;\n		public int[] clus;\n		public int[][] cluspath;\n		public int[] clusiind;\n		public int[] par, dep;\n		public int m;\n\n		public HeavyLightDecomposition(int[][] g, int[] par, int[] ord, int[] dep)\n		{\n			init(g, par, ord, dep);\n		}\n\n		public void init(int[][] g, int[] par, int[] ord, int[] dep)\n		{\n			clus = decomposeToHeavyLight(g, par, ord);\n			cluspath = clusPaths(clus, ord);\n			clusiind = clusIInd(cluspath, g.length);\n			this.m = cluspath.length;\n			this.par = par;\n			this.dep = dep;\n			this.g = g;\n		}\n\n		public static int[] decomposeToHeavyLight(int[][] g, int[] par, int[] ord)\n		{\n			int n = g.length;\n			int[] size = new int[n];\n			Arrays.fill(size, 1);\n			for(int i = n-1;i > 0;i--)size[par[ord[i]]] += size[ord[i]];\n\n			int[] clus = new int[n];\n			Arrays.fill(clus, -1);\n			int p = 0;\n			for(int i = 0;i < n;i++){\n				int u = ord[i];\n				if(clus[u] == -1)clus[u] = p++;\n				// centroid path (not heavy path)\n				int argmax = -1;\n				for(int v : g[u]){\n					if(par[u] != v && (argmax == -1 || size[v] > size[argmax]))argmax = v;\n				}\n				if(argmax != -1)clus[argmax] = clus[u];\n			}\n			return clus;\n		}\n\n		public static int[][] clusPaths(int[] clus, int[] ord)\n		{\n			int n = clus.length;\n			int[] rp = new int[n];\n			int sup = 0;\n			for(int i = 0;i < n;i++){\n				rp[clus[i]]++;\n				sup = Math.max(sup, clus[i]);\n			}\n			sup++;\n\n			int[][] row = new int[sup][];\n			for(int i = 0;i < sup;i++)row[i] = new int[rp[i]];\n\n			for(int i = n-1;i >= 0;i--){\n				row[clus[ord[i]]][--rp[clus[ord[i]]]] = ord[i];\n			}\n			return row;\n		}\n\n		public static int[] clusIInd(int[][] clusPath, int n)\n		{\n			int[] iind = new int[n];\n			for(int[] path : clusPath){\n				for(int i = 0;i < path.length;i++){\n					iind[path[i]] = i;\n				}\n			}\n			return iind;\n		}\n\n		public int lca(int x, int y)\n		{\n			int rx = cluspath[clus[x]][0];\n			int ry = cluspath[clus[y]][0];\n			while(clus[x] != clus[y]){\n				if(dep[rx] > dep[ry]){\n					x = par[rx];\n					rx = cluspath[clus[x]][0];\n				}else{\n					y = par[ry];\n					ry = cluspath[clus[y]][0];\n				}\n			}\n			return clusiind[x] > clusiind[y] ? y : x;\n		}\n\n		public int ancestor(int x, int v)\n		{\n			while(x != -1){\n				if(v <= clusiind[x])return cluspath[clus[x]][clusiind[x]-v];\n				v -= clusiind[x]+1;\n				x = par[cluspath[clus[x]][0]];\n			}\n			return x;\n		}\n\n		// [iord[x], right[x])\n		public int[][] makeRights()\n		{\n			int root = -1;\n			int n = g.length;\n			for(int i = 0;i < n;i++)if(par[i] == -1)root = i;\n\n			int[] ord = new int[n];\n			int[] right = new int[n];\n\n			int[] curs = new int[n];\n			int[] inds = new int[n];\n			int sp = 0, p = 0;\n			curs[sp++] = root;\n			while(sp > 0){\n				int cur = curs[sp-1];\n				int ind = inds[sp-1];\n				inds[sp-1]++;\n				if(ind == 0){\n					ord[p++] = cur;\n					for(int e : g[cur]){\n						if(par[cur] == e)continue;\n						if(clus[cur] == clus[e]){\n							curs[sp] = e;\n							inds[sp] = 0;\n							sp++;\n							break;\n						}\n					}\n				}else if(ind-1 < g[cur].length){\n					int e = g[cur][ind-1];\n					if(e == par[cur])continue;\n					if(clus[cur] == clus[e])continue;\n					curs[sp] = e;\n					inds[sp] = 0;\n					sp++;\n				}else{\n					right[cur] = p;\n					sp--;\n				}\n			}\n			int[] iord = new int[n];\n			for(int i = 0;i < n;i++)iord[ord[i]] = i;\n			return new int[][]{ord, iord, right};\n		}\n\n		///// templates\n\n\n\n		public void queryNew(int u, int anc, int v)\n		{\n		}\n\n	}\n\n\n	public static int[][] parents(int[][] g, int root) {\n		int n = g.length;\n		int[] par = new int[n];\n		Arrays.fill(par, -1);\n\n		int[] depth = new int[n];\n		depth[0] = 0;\n\n		int[] q = new int[n];\n		q[0] = root;\n		for (int p = 0, r = 1; p < r; p++) {\n			int cur = q[p];\n			for (int nex : g[cur]) {\n				if (par[cur] != nex) {\n					q[r++] = nex;\n					par[nex] = cur;\n					depth[nex] = depth[cur] + 1;\n				}\n			}\n		}\n		return new int[][]{par, q, depth};\n	}\n\n\n	public static int[][] packU(int n, int[] from, int[] to) {\n		return packU(n, from, to, from.length);\n	}\n\n	public static int[][] packU(int n, int[] from, int[] to, int sup) {\n		int[][] g = new int[n][];\n		int[] p = new int[n];\n		for (int i = 0; i < sup; i++) p[from[i]]++;\n		for (int i = 0; i < sup; i++) p[to[i]]++;\n		for (int i = 0; i < n; i++) g[i] = new int[p[i]];\n		for (int i = 0; i < sup; i++) {\n			g[from[i]][--p[from[i]]] = to[i];\n			g[to[i]][--p[to[i]]] = from[i];\n		}\n		return g;\n	}\n\n\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new FastWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new E().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n\n	private long[] nal(int n)\n	{\n		long[] a = new long[n];\n		for(int i = 0;i < n;i++)a[i] = nl();\n		return a;\n	}\n\n	private char[][] nm(int n, int m) {\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n\n	private int[][] nmi(int n, int m) {\n		int[][] map = new int[n][];\n		for(int i = 0;i < n;i++)map[i] = na(m);\n		return map;\n	}\n\n	private int ni() { return (int)nl(); }\n\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n\n	public static class FastWriter\n	{\n		private static final int BUF_SIZE = 1<<13;\n		private final byte[] buf = new byte[BUF_SIZE];\n		private final OutputStream out;\n		private int ptr = 0;\n\n		private FastWriter(){out = null;}\n\n		public FastWriter(OutputStream os)\n		{\n			this.out = os;\n		}\n\n		public FastWriter(String path)\n		{\n			try {\n				this.out = new FileOutputStream(path);\n			} catch (FileNotFoundException e) {\n				throw new RuntimeException(""FastWriter"");\n			}\n		}\n\n		public FastWriter write(byte b)\n		{\n			buf[ptr++] = b;\n			if(ptr == BUF_SIZE)innerflush();\n			return this;\n		}\n\n		public FastWriter write(char c)\n		{\n			return write((byte)c);\n		}\n\n		public FastWriter write(char[] s)\n		{\n			for(char c : s){\n				buf[ptr++] = (byte)c;\n				if(ptr == BUF_SIZE)innerflush();\n			}\n			return this;\n		}\n\n		public FastWriter write(String s)\n		{\n			s.chars().forEach(c -> {\n				buf[ptr++] = (byte)c;\n				if(ptr == BUF_SIZE)innerflush();\n			});\n			return this;\n		}\n\n		private static int countDigits(int l) {\n			if (l >= 1000000000) return 10;\n			if (l >= 100000000) return 9;\n			if (l >= 10000000) return 8;\n			if (l >= 1000000) return 7;\n			if (l >= 100000) return 6;\n			if (l >= 10000) return 5;\n			if (l >= 1000) return 4;\n			if (l >= 100) return 3;\n			if (l >= 10) return 2;\n			return 1;\n		}\n\n		public FastWriter write(int x)\n		{\n			if(x == Integer.MIN_VALUE){\n				return write((long)x);\n			}\n			if(ptr + 12 >= BUF_SIZE)innerflush();\n			if(x < 0){\n				write((byte)'-');\n				x = -x;\n			}\n			int d = countDigits(x);\n			for(int i = ptr + d - 1;i >= ptr;i--){\n				buf[i] = (byte)('0'+x%10);\n				x /= 10;\n			}\n			ptr += d;\n			return this;\n		}\n\n		private static int countDigits(long l) {\n			if (l >= 1000000000000000000L) return 19;\n			if (l >= 100000000000000000L) return 18;\n			if (l >= 10000000000000000L) return 17;\n			if (l >= 1000000000000000L) return 16;\n			if (l >= 100000000000000L) return 15;\n			if (l >= 10000000000000L) return 14;\n			if (l >= 1000000000000L) return 13;\n			if (l >= 100000000000L) return 12;\n			if (l >= 10000000000L) return 11;\n			if (l >= 1000000000L) return 10;\n			if (l >= 100000000L) return 9;\n			if (l >= 10000000L) return 8;\n			if (l >= 1000000L) return 7;\n			if (l >= 100000L) return 6;\n			if (l >= 10000L) return 5;\n			if (l >= 1000L) return 4;\n			if (l >= 100L) return 3;\n			if (l >= 10L) return 2;\n			return 1;\n		}\n\n		public FastWriter write(long x)\n		{\n			if(x == Long.MIN_VALUE){\n				return write("""" + x);\n			}\n			if(ptr + 21 >= BUF_SIZE)innerflush();\n			if(x < 0){\n				write((byte)'-');\n				x = -x;\n			}\n			int d = countDigits(x);\n			for(int i = ptr + d - 1;i >= ptr;i--){\n				buf[i] = (byte)('0'+x%10);\n				x /= 10;\n			}\n			ptr += d;\n			return this;\n		}\n\n		public FastWriter write(double x, int precision)\n		{\n			if(x < 0){\n				write('-');\n				x = -x;\n			}\n			x += Math.pow(10, -precision)/2;\n			//		if(x < 0){ x = 0; }\n			write((long)x).write(""."");\n			x -= (long)x;\n			for(int i = 0;i < precision;i++){\n				x *= 10;\n				write((char)('0'+(int)x));\n				x -= (int)x;\n			}\n			return this;\n		}\n\n		public FastWriter writeln(char c){\n			return write(c).writeln();\n		}\n\n		public FastWriter writeln(int x){\n			return write(x).writeln();\n		}\n\n		public FastWriter writeln(long x){\n			return write(x).writeln();\n		}\n\n		public FastWriter writeln(double x, int precision){\n			return write(x, precision).writeln();\n		}\n\n		public FastWriter write(int... xs)\n		{\n			boolean first = true;\n			for(int x : xs) {\n				if (!first) write(' ');\n				first = false;\n				write(x);\n			}\n			return this;\n		}\n\n		public FastWriter write(long... xs)\n		{\n			boolean first = true;\n			for(long x : xs) {\n				if (!first) write(' ');\n				first = false;\n				write(x);\n			}\n			return this;\n		}\n\n		public FastWriter writeln()\n		{\n			return write((byte)'\n');\n		}\n\n		public FastWriter writeln(int... xs)\n		{\n			return write(xs).writeln();\n		}\n\n		public FastWriter writeln(long... xs)\n		{\n			return write(xs).writeln();\n		}\n\n		public FastWriter writeln(char[] line)\n		{\n			return write(line).writeln();\n		}\n\n		public FastWriter writeln(char[]... map)\n		{\n			for(char[] line : map)write(line).writeln();\n			return this;\n		}\n\n		public FastWriter writeln(String s)\n		{\n			return write(s).writeln();\n		}\n\n		private void innerflush()\n		{\n			try {\n				out.write(buf, 0, ptr);\n				ptr = 0;\n			} catch (IOException e) {\n				throw new RuntimeException(""innerflush"");\n			}\n		}\n\n		public void flush()\n		{\n			innerflush();\n			try {\n				out.flush();\n			} catch (IOException e) {\n				throw new RuntimeException(""flush"");\n			}\n		}\n\n		public FastWriter print(byte b) { return write(b); }\n		public FastWriter print(char c) { return write(c); }\n		public FastWriter print(char[] s) { return write(s); }\n		public FastWriter print(String s) { return write(s); }\n		public FastWriter print(int x) { return write(x); }\n		public FastWriter print(long x) { return write(x); }\n		public FastWriter print(double x, int precision) { return write(x, precision); }\n		public FastWriter println(char c){ return writeln(c); }\n		public FastWriter println(int x){ return writeln(x); }\n		public FastWriter println(long x){ return writeln(x); }\n		public FastWriter println(double x, int precision){ return writeln(x, precision); }\n		public FastWriter print(int... xs) { return write(xs); }\n		public FastWriter print(long... xs) { return write(xs); }\n		public FastWriter println(int... xs) { return writeln(xs); }\n		public FastWriter println(long... xs) { return writeln(xs); }\n		public FastWriter println(char[] line) { return writeln(line); }\n		public FastWriter println(char[]... map) { return writeln(map); }\n		public FastWriter println(String s) { return writeln(s); }\n		public FastWriter println() { return writeln(); }\n	}\n\n	public void trnz(int... o)\n	{\n		for(int i = 0;i < o.length;i++)if(o[i] != 0)System.out.print(i+"":""+o[i]+"" "");\n		System.out.println();\n	}\n\n	// print ids which are 1\n	public void trt(long... o)\n	{\n		Queue<Integer> stands = new ArrayDeque<>();\n		for(int i = 0;i < o.length;i++){\n			for(long x = o[i];x != 0;x &= x-1)stands.add(i<<6|Long.numberOfTrailingZeros(x));\n		}\n		System.out.println(stands);\n	}\n\n	public void tf(boolean... r)\n	{\n		for(boolean x : r)System.out.print(x?'#':'.');\n		System.out.println();\n	}\n\n	public void tf(boolean[]... b)\n	{\n		for(boolean[] r : b) {\n			for(boolean x : r)System.out.print(x?'#':'.');\n			System.out.println();\n		}\n		System.out.println();\n	}\n\n	public void tf(long[]... b)\n	{\n		if(INPUT.length() != 0) {\n			for (long[] r : b) {\n				for (long x : r) {\n					for (int i = 0; i < 64; i++) {\n						System.out.print(x << ~i < 0 ? '#' : '.');\n					}\n				}\n				System.out.println();\n			}\n			System.out.println();\n		}\n	}\n\n	public void tf(long... b)\n	{\n		if(INPUT.length() != 0) {\n			for (long x : b) {\n				for (int i = 0; i < 64; i++) {\n					System.out.print(x << ~i < 0 ? '#' : '.');\n				}\n			}\n			System.out.println();\n		}\n	}\n\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","brute force,constructive algorithms,data structures,dfs and similar,sortings,trees"
\nimport java.util.*;\n\npublic class Main{\n		public static void main(String[] args) {\n			Scanner in = new Scanner(System.in);\n			int T = in.nextInt();\n			for (int i = 0; i < T; i ++ )\n			{\n					int n = in.nextInt();\n					int w = in.nextInt();\n					PriorityQueue<Integer> q = new PriorityQueue<>(Collections.reverseOrder());\n					for (int i1 = 0; i1 < n; i1 ++ ){\n						q.add(in.nextInt());\n					}\n					PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\n					pq.add(w - q.remove());\n					while (q.size()> 0){\n						int n1 = q.remove();\n						if (pq.peek() >= n1){\n							int x = pq.remove();\n							pq.add(x - n1);\n						}\n						else {\n							pq.add(w - n1);\n						}\n					}\n					System.out.println(pq.size());\n			}\n		}\n},"binary search,bitmasks,data structures,greedy"
\nimport java.util.*;\n\npublic class Main{\n		public static void main(String[] args) {\n			Scanner in = new Scanner(System.in);\n			int T = in.nextInt();\n			for (int i = 0; i < T; i ++ )\n			{\n					int n = in.nextInt();\n					int w = in.nextInt();\n					PriorityQueue<Integer> q = new PriorityQueue<>(Collections.reverseOrder());\n					for (int i1 = 0; i1 < n; i1 ++ ){\n						q.add(in.nextInt());\n					}\n					PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\n					pq.add(w - q.remove());\n					while (q.size()> 0){\n						int n1 = q.remove();\n						if (pq.peek() >= n1){\n							int x = pq.remove();\n							pq.add(x - n1);\n						}\n						else {\n							pq.add(w - n1);\n						}\n					}\n					System.out.println(pq.size());\n			}\n		}\n},"binary search,bitmasks,data structures,greedy"
import java.util.*;\npublic class p711B {\n    public static void main(String[] args) {\n        Scanner scn=new Scanner(System.in);\n        int t=scn.nextInt();\n        for(int i=0;i<t;i++){\n            int n=scn.nextInt();\n            int w=scn.nextInt();\n            PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\n            for(int i1=0;i1<n;i1++){\n                pq.add(scn.nextInt());\n            }\n            PriorityQueue<Integer> pq1=new PriorityQueue<>(Collections.reverseOrder());\n            pq1.add(w-pq.remove());\n            while(pq.size()>0){\n                int n1=pq.remove();\n                if(pq1.peek()>=n1){\n                    int x=pq1.remove();\n                    pq1.add(x-n1);\n                }\n                else{\n                    pq1.add(w-n1);\n                }\n            }\n            System.out.println(pq1.size());\n\n        }\n    }\n}\n,"binary search,bitmasks,data structures,greedy"
import java.util.*;\npublic class BoxFitting {\n    public static void main(String[] args) {\n        Scanner scn=new Scanner(System.in);\n        int t=scn.nextInt();\n        for(int i=0;i<t;i++){\n            int n=scn.nextInt();\n            int w=scn.nextInt();\n            PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\n            for(int i1=0;i1<n;i1++){\n                pq.add(scn.nextInt());\n            }\n            PriorityQueue<Integer> pq1=new PriorityQueue<>(Collections.reverseOrder());\n            pq1.add(w-pq.remove());\n            while(pq.size()>0){\n                int n1=pq.remove();\n                if(pq1.peek()>=n1){\n                    int x=pq1.remove();\n                    pq1.add(x-n1);\n                }\n                else{\n                    pq1.add(w-n1);\n                }\n            }\n            System.out.println(pq1.size());\n\n        }\n    }\n}\n,"binary search,bitmasks,data structures,greedy"
"import java.util.*;\npublic class Demo {\n \n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner st=new Scanner(System.in);\n		int t=st.nextInt();\n		while(t-->0) {\n			long n=st.nextLong();\n			while(gcd(n,sumd(n))==1) n+=1;\n			System.out.println(n);\n		}\n	}\n	\n	public static long sumd(long n) {\n		long s=0;\n		while(n!=0) {\n			s+=n%10;\n			n/=10;\n		}\n		return s;\n	}\n	public static long gcd(long a,long b) {\n		return b==0?a:gcd(b,a%b);\n	}\n \n}","brute force,math"
"import java.util.*;\npublic class Demo {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner st=new Scanner(System.in);\n		int t=st.nextInt();\n		while(t-->0) {\n			long n=st.nextLong();\n			while(gcd(n,sumd(n))==1) n+=1;\n			System.out.println(n);\n		}\n	}\n	\n	public static long sumd(long n) {\n		long s=0;\n		while(n!=0) {\n			s+=n%10;\n			n/=10;\n		}\n		return s;\n	}\n	public static long gcd(long a,long b) {\n		return b==0?a:gcd(b,a%b);\n	}\n\n}\n\n","brute force,math"
"import java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class gcdsum {\n	static long gcd(long n1,long n2){\n		if (n2==0)\n			return n1;\n		return gcd(n2,n1%n2);\n	}\n	static long Sum(long n1){\n		long n2;\n		long c=n1;\n		for (n2=0;c>0;n2+=c%10,c/=10);\n		if (gcd(n1,n2)==1){\n			return(Sum(n1+1));\n		}\n	return n1;\n	}\n	public static void main (String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		for (int i=0; i<t; i++){\n			long n1 = sc.nextLong();\n			System.out.println(Sum(n1));\n		}\n	}\n}\n\n","brute force,math"
"import java.util.*;\n\npublic class Main\n{\n		public static void main(String[] args)\n		{\n				Scanner in = new Scanner(System.in);\n				int T = in.nextInt();\n				while (T -- > 0)\n				{\n						long n = in.nextLong();\n						while (gcd(n, sumd(n)) == 1) n += 1;\n						System.out.println(n);\n				}\n		}\n		\n		public static long sumd(long n)\n		{\n				long s = 0;\n				while (n != 0)\n				{\n						s += n % 10;\n						n /= 10;\n				}\n				return s;\n		}\n		\n		public static long gcd(long a, long b)\n		{\n				return b == 0 ? a : gcd(b, a % b);\n		}\n}\n","brute force,math"
import java.io.*;\nimport java.util.*;\n\npublic class Q6_try2 {\n\n	static Scanner sc = new Scanner(System.in);\n	public static void main(String[] args) {\n		int t = sc.nextInt();\n		while(t-->0) {\n			solve();\n		}\n	}\n	\n	public static void solve() {\n		\n		int n = sc.nextInt();\n		int k = sc.nextInt();\n		\n		int[] arr = new int[n];\n		for(int i= 0;i < n;i++) {\n			int v = sc.nextInt();\n			arr[i] = operate(v);\n		}\n		\n		HashSet<Integer> set = new HashSet<>();\n		\n		set.add(arr[0]);\n		int ans = 1;\n		\n		for(int i = 1;i < n;i++) {\n			\n			int v = arr[i];\n			if(set.contains(v)) {\n				set.clear();\n				set.add(v);\n				ans++;\n			}\n			\n			else set.add(v);\n		}\n		\n		System.out.println(ans);\n	}\n	\n	public static int operate(int a) {\n		\n		for(int i = 2;i * i <= a;i++) {\n			\n			int c = i * i;\n			while(a % c == 0)a = a/c;\n		}\n		\n		return a;\n	}\n}\n,"data structures,dp,greedy,math,number theory,two pointers"
"import java.util.*;\npublic class Problem1497e1 {\n    static int[] p = new int[10000007];\n\n    static void solve() {\n        for (int i = 0; i < p.length; i++) {\n            p[i] = i;\n        }\n        for (int i = 2; i * i < p.length; i++) {\n            int t = i * i;\n            for (int j = t; j < p.length; j += t) {\n                p[j] = j / t;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        solve();\n        int t = sc.nextInt();\n        while (t-- > 0) {\n            int n = sc.nextInt(), k = sc.nextInt(), ans = 1;\n            HashSet<Integer> set = new HashSet<Integer>();\n            for (int i = 0; i < n; i++) {\n                k = p[sc.nextInt()];\n                if (set.contains(k)) {\n                    set.clear();\n                    ans++;\n                }\n                set.add(k);\n            }\n            System.out.println(ans + """");\n        }\n    }\n}","data structures,dp,greedy,math,number theory,two pointers"
"import java.util.*;\nimport java.io.*;\n\npublic class square_free_division_easy {\n	\n	static int[] p = new int[10000007];\n	 \n    static void solve() {\n        for (int i = 0; i < p.length; i++) {\n            p[i] = i;\n        }\n        for (int i = 2; i * i < p.length; i++) {\n            int t = i * i;\n            for (int j = t; j < p.length; j += t) {\n                p[j] = j / t;\n            }\n        }\n    }\n \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        solve();\n        int t = sc.nextInt();\n        while (t-- > 0) {\n            int n = sc.nextInt(), k = sc.nextInt(), ans = 1;\n            HashSet<Integer> set = new HashSet<Integer>();\n            for (int i = 0; i < n; i++) {\n                k = p[sc.nextInt()];\n                if (set.contains(k)) {\n                    set.clear();\n                    ans++;\n                }\n                set.add(k);\n            }\n            System.out.println(ans + """");\n        }\n    }\n\n}\n","data structures,dp,greedy,math,number theory,two pointers"
import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class SquareFreeDivision1 {\n\n	static int mainarr[] = new int[10000007];\n\n	public static void Starting() {\n		for (int i = 0; i < mainarr.length; i++) {\n			mainarr[i] = i;\n		}\n		for (int j = 2; j * j < mainarr.length; j++) {\n			int var = j*j;\n			for (int k = var; k < mainarr.length; k += var) {\n				mainarr[k] = k / (var);\n			}\n		}\n	}\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner s = new Scanner(System.in);\n		Starting();\n\n		int tt = s.nextInt();\n\n		for (int pp = 0; pp < tt; pp++) {\n\n			int n = s.nextInt();\n			int k = s.nextInt();\n			HashSet<Integer> set = new HashSet<>();\n\n			ArrayList<Integer> arr = new ArrayList<>();\n\n			int ans = 1;\n	\n\n			for (int i = 0; i < n; i++) {\n				arr.add(s.nextInt());\n			}\n\n			for (int i = 0; i < n; i++) {\n				if (set.contains(mainarr[arr.get(i)]) == false) {\n					set.add(mainarr[arr.get(i)]);\n				} else {\n					set.clear();\n					set.add(mainarr[arr.get(i)]);\n					ans++;\n				}\n			}\n			System.out.println(ans);\n		}\n	}\n}\n,"data structures,dp,greedy,math,number theory,two pointers"
"import java.util.*;\n\npublic class Exercise {\n\n\n		\n\n	public static void main (String []args) {\n		Scanner sc= new Scanner(System.in);\n		int t = sc.nextInt();\n		for(int i=0;i<t;i++) {\n			String inp= sc.next();\n			if(inp.charAt(inp.length()-1)==inp.charAt(0))System.out.println(""NO"");\n			else {\n			int f=0;\n			int l=0;\n			boolean flag1= true, flag2=true;\n			for(int j =0;j<inp.length();j++ ) {\n				if(inp.charAt(j)==inp.charAt(0)) {\n					l++;\n					f++;\n				\n				}\n				else if (inp.charAt(inp.length()-1)==inp.charAt(j)) {\n					l--;\n					f--;\n				}\n				else {\n					l--;\n					f++;\n				}\n				if(l<0 )flag1= false;\n				if(f<0 )flag2= false;\n			}\n			if( (l ==0 &&flag1) || (f==0 && flag2))System.out.println(""YES"");\n			else System.out.println(""NO"");\n		}\n\n	}\n}\n}","bitmasks,brute force,implementation"
"import java.util.*;\nimport java.util.Map.Entry;\n\npublic class CR572B {\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		int t=s.nextInt();\n		\n		while(t-->0) {\n			String str=s.next();\n			int n=str.length();\n			int i1=0;\n					int i2=0;\n			\n			boolean pd1=true;\n			boolean pd2=true;\n			\n			\n			if(str.charAt(0)==str.charAt(n-1)) {\n				System.out.println(""NO"");\n			}\n			else {\n				for(int i=0;i<n;i++) {\n					if(str.charAt(i)==str.charAt(0)) {\n						i1++;\n						i2++;\n					}\n					else if(str.charAt(i)==str.charAt(n-1)) {\n						i1--;\n						i2--;\n					}else {\n						i1++;\n						i2--;\n					}\n					\n					if(i1<0) pd1=false;\n					if(i2<0) pd2=false;\n				}\n				if(i1!=0) pd1=false;\n				if(i2!=0) pd2=false;\n				\n				if(pd1||pd2) System.out.println(""YES"");\n				else System.out.println(""NO"");\n			}\n	\n		}\n	\n	}\n}","bitmasks,brute force,implementation"
"import java.util.*;\nimport java.util.Map.Entry;\n \npublic class CR572B {\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		int t=s.nextInt();\n		\n		while(t-->0) {\n			String str=s.next();\n			int n=str.length();\n			int i1=0;\n					int i2=0;\n			\n			boolean pd1=true;\n			boolean pd2=true;\n			\n			\n			if(str.charAt(0)==str.charAt(n-1)) {\n				System.out.println(""NO"");\n			}\n			else {\n				for(int i=0;i<n;i++) {\n					if(str.charAt(i)==str.charAt(0)) {\n						i1++;\n						i2++;\n					}\n					else if(str.charAt(i)==str.charAt(n-1)) {\n						i1--;\n						i2--;\n					}else {\n						i1++;\n						i2--;\n					}\n					\n					if(i1<0) pd1=false;\n					if(i2<0) pd2=false;\n				}\n				if(i1!=0) pd1=false;\n				if(i2!=0) pd2=false;\n				\n				if(pd1||pd2) System.out.println(""YES"");\n				else System.out.println(""NO"");\n			}\n	\n		}\n	\n	}\n}","bitmasks,brute force,implementation"
"import java.util.*;\nimport java.util.Map.Entry;\n \npublic class CR572B {\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		int t=s.nextInt();\n		\n		while(t-->0) {\n			String str=s.next();\n			int n=str.length();\n			int i1=0;\n					int i2=0;\n			\n			boolean pd1=true;\n			boolean pd2=true;\n			\n			\n			if(str.charAt(0)==str.charAt(n-1)) {\n				System.out.println(""NO"");\n			}\n			else {\n				for(int i=0;i<n;i++) {\n					if(str.charAt(i)==str.charAt(0)) {\n						i1++;\n						i2++;\n					}\n					else if(str.charAt(i)==str.charAt(n-1)) {\n						i1--;\n						i2--;\n					}else {\n						i1++;\n						i2--;\n					}\n					\n					if(i1<0) pd1=false;\n					if(i2<0) pd2=false;\n				}\n				if(i1!=0) pd1=false;\n				if(i2!=0) pd2=false;\n				\n				if(pd1||pd2) System.out.println(""YES"");\n				else System.out.println(""NO"");\n			}\n	\n		}\n	\n	}\n}","bitmasks,brute force,implementation"
"import java.util.Scanner;\npublic class p1492D {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int a=sc.nextInt(),b=sc.nextInt(),k=sc.nextInt();\n        if(k==0) {\n            String s=""1"".repeat(b)+""0"".repeat(a);\n            System.out.println(""YES ""+s+"" ""+s);\n        }else if(a==0||b==1||a+b<=k+1) System.out.println(""NO"");\n        else {\n            int i=a+b-k-1;\n            String s=""1"".repeat(b-1)+""0"".repeat(a-1),x=s.substring(0,i),y=s.substring(i,s.length());\n            System.out.println(""YES ""+x+1+y+0+"" ""+x+0+y+1);\n        }\n    }\n}","bitmasks,constructive algorithms,greedy,math"
"import java.io.*;\nimport java.util.*;\n\npublic class genius_gambit {\n	public static void main(String[] args) \n	{\n			Scanner sc=new Scanner(System.in);\n			int a=sc.nextInt(),b=sc.nextInt(),k=sc.nextInt();\n			if(b==1)\n			{\n				if(k!=0)\n				System.out.println(""NO"");\n				else\n				{\n					String x="""";\n					x=""1""+""0"".repeat(a);\n					System.out.println(""YES\n""+x+""\n""+x);\n				}\n			}\n			else if(k<=a)\n			{\n				System.out.println(""YES"");\n				String x="""",y="""";\n				x=""1"".repeat(b-1)+""0"".repeat(a-k)+""1""+""0"".repeat(k);\n				y=""1"".repeat(b-1)+""0"".repeat(a)+""1"";\n				System.out.println(x+""\n""+y);\n			}\n			else if(k>a && (k-a+2)<=b &&  a>=1)\n			{\n				String x="""",y="""";\n				x=""1"".repeat(b)+""0"".repeat(a);\n				y=""1"".repeat(a+b-k-1)+""0""+""1"".repeat(k-a)+""0"".repeat(a-1)+""1"";\n				System.out.println(""YES\n""+x+""\n""+y);\n			}\n			else\n				System.out.println(""NO"");\n	}\n}\n","bitmasks,constructive algorithms,greedy,math"
"import java.util.*;\npublic class testJava{\n    Scanner sc;\n    testJava(){\n        sc=new Scanner(System.in); \n    }\n    public static void main(String args[]){\n        testJava tj=new testJava();\n        tj.problem();\n    }\n    public void problem(){\n        int a=sc.nextInt(),b=sc.nextInt(),k=sc.nextInt();\n        if(k>0 && (k>a+b-2 || b<2 || a==0)){\n            System.out.println(""No"");\n            return;\n        }\n        System.out.println(""Yes"");\n        StringBuilder a1=new StringBuilder();\n        for(int i=0;i<b;i++)\n            a1.append(""1"");\n        for(int i=0;i<a;i++)\n            a1.append(""0"");\n        System.out.println(a1);\n        if(k!=0){\n            a1.setCharAt(b+Math.min(k,a)-1,'1');\n            k=Math.max(0,k-a);\n            a1.setCharAt(b-1-k,'0');\n        }\n        System.out.println(a1);\n            \n    }\n}","bitmasks,constructive algorithms,greedy,math"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1492D extends PrintWriter {\n	CF1492D() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1492D o = new CF1492D(); o.main(); o.flush();\n	}\n\n	void main() {\n		int a = sc.nextInt();\n		int b = sc.nextInt();\n		int k = sc.nextInt();\n		if (k > 0 && (a == 0 || b == 1 || k > a + b - 2)) {\n			println(""No"");\n			return;\n		}\n		int n = a + b;\n		byte[] xx = new byte[n]; Arrays.fill(xx, (byte) '0');\n		byte[] yy = new byte[n]; Arrays.fill(yy, (byte) '0');\n		xx[0] = yy[0] = '1'; b--;\n		if (b > 0) {\n			int j = n - 1, i = j - k;\n			xx[i] = yy[j] = '1'; b--;\n			for (int h = 1; h < n && b > 0; h++)\n				if (h != i && h != j) {\n					xx[h] = yy[h] = '1'; b--;\n				}\n		}\n		println(""Yes"");\n		println(new String(xx));\n		println(new String(yy));\n	}\n}\n","bitmasks,constructive algorithms,greedy,math"
"//package ecr104;\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Queue;\n\npublic class G3 {\n	InputStream is;\n	FastWriter out;\n	String INPUT = """";\n\n	void solve()\n	{\n		final int mod = 998244353;\n		int n = ni();\n		int[] a = na(26);\n		long all = 26 * 26 * pow(25, n-2, mod) % mod;\n\n		long[][][] dp = new long[3][n+1][n+1];\n		dp[0][1][0] = 1;\n		dp[1][0][1] = 1;\n		dp[2][0][0] = 1;\n		for(int i = 0;i < n-1;i++){\n			long[][][] ndp = new long[3][n+1][n+1];\n			if(i == (n+1)/2-1){\n				for (int j = 0; j <= n; j++) {\n					for (int k = 0; j+k <= n; k++) {\n						if (j + 1 <= n) {\n							ndp[0][j + 1][k] += dp[0][j][k] + dp[1][j][k] + dp[2][j][k] * 24;\n							ndp[0][j + 1][k] %= mod;\n						}\n						if (k + 1 <= n) {\n							ndp[1][j][k + 1] += dp[0][j][k] + dp[1][j][k] + dp[2][j][k] * 24;\n							ndp[1][j][k + 1] %= mod;\n						}\n						ndp[2][j][k] += dp[0][j][k] + dp[1][j][k] + dp[2][j][k] * 24;\n						ndp[2][j][k] %= mod;\n					}\n				}\n			}else {\n				for (int j = 0; j <= n; j++) {\n					for (int k = 0; j+k <= n; k++) {\n						if (j + 1 <= n) {\n							ndp[0][j + 1][k] += dp[1][j][k] + dp[2][j][k] * 24;\n							ndp[0][j + 1][k] %= mod;\n						}\n						if (k + 1 <= n) {\n							ndp[1][j][k + 1] += dp[0][j][k] + dp[2][j][k] * 24;\n							ndp[1][j][k + 1] %= mod;\n						}\n						ndp[2][j][k] += dp[0][j][k] + dp[1][j][k] + dp[2][j][k] * 23;\n						ndp[2][j][k] %= mod;\n					}\n				}\n\n			}\n			dp = ndp;\n		}\n\n		long[] sdp = new long[n+1];\n		for(int i = 0;i <= n;i++){\n			for(int j = 0;j <= n;j++){\n				sdp[i] += dp[0][i][j] + dp[1][i][j] + dp[2][i][j] * 24;\n			}\n			sdp[i] %= mod;\n		}\n\n		for(int i = 0;i < 26;i++){\n			for(int k = a[i]+1;k <= n;k++){\n				all -= sdp[k];\n			}\n		}\n\n		for(int i = 0;i < 26;i++){\n			for(int j = i+1;j < 26;j++){\n				for(int k = a[i]+1;k <= n;k++){\n					for(int l = a[j]+1;l+k <= n;l++){\n						all += (dp[0][k][l] + dp[1][k][l] + dp[2][k][l] * 24);\n					}\n				}\n				all %= mod;\n			}\n		}\n		all %= mod;\n\n		if(all < 0)all += mod;\n		out.println(all);\n	}\n\n	public static long pow(long a, long n, long mod) {\n		//		a %= mod;\n		long ret = 1;\n		int x = 63 - Long.numberOfLeadingZeros(n);\n		for (; x >= 0; x--) {\n			ret = ret * ret % mod;\n			if (n << 63 - x < 0) ret = ret * a % mod;\n		}\n		return ret;\n	}\n\n\n	public static long invl(long a, long mod) {\n		long b = mod;\n		long p = 1, q = 0;\n		while (b > 0) {\n			long c = a / b;\n			long d;\n			d = a;\n			a = b;\n			b = d % b;\n			d = p;\n			p = q;\n			q = d - c * q;\n		}\n		return p < 0 ? p + mod : p;\n	}\n\n\n	public static long C(int n, int r, int mod, int[][] fif) {\n		if (n < 0 || r < 0 || r > n) return 0;\n		return (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n	}\n\n\n	public static int[][] enumFIF(int n, int mod) {\n		int[] f = new int[n + 1];\n		int[] invf = new int[n + 1];\n		f[0] = 1;\n		for (int i = 1; i <= n; i++) {\n			f[i] = (int) ((long) f[i - 1] * i % mod);\n		}\n		long a = f[n];\n		long b = mod;\n		long p = 1, q = 0;\n		while (b > 0) {\n			long c = a / b;\n			long d;\n			d = a;\n			a = b;\n			b = d % b;\n			d = p;\n			p = q;\n			q = d - c * q;\n		}\n		invf[n] = (int) (p < 0 ? p + mod : p);\n		for (int i = n - 1; i >= 0; i--) {\n			invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n		}\n		return new int[][]{f, invf};\n	}\n\n\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new FastWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new G3().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n\n	private long[] nal(int n)\n	{\n		long[] a = new long[n];\n		for(int i = 0;i < n;i++)a[i] = nl();\n		return a;\n	}\n\n	private char[][] nm(int n, int m) {\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n\n	private int[][] nmi(int n, int m) {\n		int[][] map = new int[n][];\n		for(int i = 0;i < n;i++)map[i] = na(m);\n		return map;\n	}\n\n	private int ni() { return (int)nl(); }\n\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n\n	public static class FastWriter\n	{\n		private static final int BUF_SIZE = 1<<13;\n		private final byte[] buf = new byte[BUF_SIZE];\n		private final OutputStream out;\n		private int ptr = 0;\n\n		private FastWriter(){out = null;}\n\n		public FastWriter(OutputStream os)\n		{\n			this.out = os;\n		}\n\n		public FastWriter(String path)\n		{\n			try {\n				this.out = new FileOutputStream(path);\n			} catch (FileNotFoundException e) {\n				throw new RuntimeException(""FastWriter"");\n			}\n		}\n\n		public FastWriter write(byte b)\n		{\n			buf[ptr++] = b;\n			if(ptr == BUF_SIZE)innerflush();\n			return this;\n		}\n\n		public FastWriter write(char c)\n		{\n			return write((byte)c);\n		}\n\n		public FastWriter write(char[] s)\n		{\n			for(char c : s){\n				buf[ptr++] = (byte)c;\n				if(ptr == BUF_SIZE)innerflush();\n			}\n			return this;\n		}\n\n		public FastWriter write(String s)\n		{\n			s.chars().forEach(c -> {\n				buf[ptr++] = (byte)c;\n				if(ptr == BUF_SIZE)innerflush();\n			});\n			return this;\n		}\n\n		private static int countDigits(int l) {\n			if (l >= 1000000000) return 10;\n			if (l >= 100000000) return 9;\n			if (l >= 10000000) return 8;\n			if (l >= 1000000) return 7;\n			if (l >= 100000) return 6;\n			if (l >= 10000) return 5;\n			if (l >= 1000) return 4;\n			if (l >= 100) return 3;\n			if (l >= 10) return 2;\n			return 1;\n		}\n\n		public FastWriter write(int x)\n		{\n			if(x == Integer.MIN_VALUE){\n				return write((long)x);\n			}\n			if(ptr + 12 >= BUF_SIZE)innerflush();\n			if(x < 0){\n				write((byte)'-');\n				x = -x;\n			}\n			int d = countDigits(x);\n			for(int i = ptr + d - 1;i >= ptr;i--){\n				buf[i] = (byte)('0'+x%10);\n				x /= 10;\n			}\n			ptr += d;\n			return this;\n		}\n\n		private static int countDigits(long l) {\n			if (l >= 1000000000000000000L) return 19;\n			if (l >= 100000000000000000L) return 18;\n			if (l >= 10000000000000000L) return 17;\n			if (l >= 1000000000000000L) return 16;\n			if (l >= 100000000000000L) return 15;\n			if (l >= 10000000000000L) return 14;\n			if (l >= 1000000000000L) return 13;\n			if (l >= 100000000000L) return 12;\n			if (l >= 10000000000L) return 11;\n			if (l >= 1000000000L) return 10;\n			if (l >= 100000000L) return 9;\n			if (l >= 10000000L) return 8;\n			if (l >= 1000000L) return 7;\n			if (l >= 100000L) return 6;\n			if (l >= 10000L) return 5;\n			if (l >= 1000L) return 4;\n			if (l >= 100L) return 3;\n			if (l >= 10L) return 2;\n			return 1;\n		}\n\n		public FastWriter write(long x)\n		{\n			if(x == Long.MIN_VALUE){\n				return write("""" + x);\n			}\n			if(ptr + 21 >= BUF_SIZE)innerflush();\n			if(x < 0){\n				write((byte)'-');\n				x = -x;\n			}\n			int d = countDigits(x);\n			for(int i = ptr + d - 1;i >= ptr;i--){\n				buf[i] = (byte)('0'+x%10);\n				x /= 10;\n			}\n			ptr += d;\n			return this;\n		}\n\n		public FastWriter write(double x, int precision)\n		{\n			if(x < 0){\n				write('-');\n				x = -x;\n			}\n			x += Math.pow(10, -precision)/2;\n			//		if(x < 0){ x = 0; }\n			write((long)x).write(""."");\n			x -= (long)x;\n			for(int i = 0;i < precision;i++){\n				x *= 10;\n				write((char)('0'+(int)x));\n				x -= (int)x;\n			}\n			return this;\n		}\n\n		public FastWriter writeln(char c){\n			return write(c).writeln();\n		}\n\n		public FastWriter writeln(int x){\n			return write(x).writeln();\n		}\n\n		public FastWriter writeln(long x){\n			return write(x).writeln();\n		}\n\n		public FastWriter writeln(double x, int precision){\n			return write(x, precision).writeln();\n		}\n\n		public FastWriter write(int... xs)\n		{\n			boolean first = true;\n			for(int x : xs) {\n				if (!first) write(' ');\n				first = false;\n				write(x);\n			}\n			return this;\n		}\n\n		public FastWriter write(long... xs)\n		{\n			boolean first = true;\n			for(long x : xs) {\n				if (!first) write(' ');\n				first = false;\n				write(x);\n			}\n			return this;\n		}\n\n		public FastWriter writeln()\n		{\n			return write((byte)'\n');\n		}\n\n		public FastWriter writeln(int... xs)\n		{\n			return write(xs).writeln();\n		}\n\n		public FastWriter writeln(long... xs)\n		{\n			return write(xs).writeln();\n		}\n\n		public FastWriter writeln(char[] line)\n		{\n			return write(line).writeln();\n		}\n\n		public FastWriter writeln(char[]... map)\n		{\n			for(char[] line : map)write(line).writeln();\n			return this;\n		}\n\n		public FastWriter writeln(String s)\n		{\n			return write(s).writeln();\n		}\n\n		private void innerflush()\n		{\n			try {\n				out.write(buf, 0, ptr);\n				ptr = 0;\n			} catch (IOException e) {\n				throw new RuntimeException(""innerflush"");\n			}\n		}\n\n		public void flush()\n		{\n			innerflush();\n			try {\n				out.flush();\n			} catch (IOException e) {\n				throw new RuntimeException(""flush"");\n			}\n		}\n\n		public FastWriter print(byte b) { return write(b); }\n		public FastWriter print(char c) { return write(c); }\n		public FastWriter print(char[] s) { return write(s); }\n		public FastWriter print(String s) { return write(s); }\n		public FastWriter print(int x) { return write(x); }\n		public FastWriter print(long x) { return write(x); }\n		public FastWriter print(double x, int precision) { return write(x, precision); }\n		public FastWriter println(char c){ return writeln(c); }\n		public FastWriter println(int x){ return writeln(x); }\n		public FastWriter println(long x){ return writeln(x); }\n		public FastWriter println(double x, int precision){ return writeln(x, precision); }\n		public FastWriter print(int... xs) { return write(xs); }\n		public FastWriter print(long... xs) { return write(xs); }\n		public FastWriter println(int... xs) { return writeln(xs); }\n		public FastWriter println(long... xs) { return writeln(xs); }\n		public FastWriter println(char[] line) { return writeln(line); }\n		public FastWriter println(char[]... map) { return writeln(map); }\n		public FastWriter println(String s) { return writeln(s); }\n		public FastWriter println() { return writeln(); }\n	}\n\n	public void trnz(int... o)\n	{\n		for(int i = 0;i < o.length;i++)if(o[i] != 0)System.out.print(i+"":""+o[i]+"" "");\n		System.out.println();\n	}\n\n	// print ids which are 1\n	public void trt(long... o)\n	{\n		Queue<Integer> stands = new ArrayDeque<>();\n		for(int i = 0;i < o.length;i++){\n			for(long x = o[i];x != 0;x &= x-1)stands.add(i<<6|Long.numberOfTrailingZeros(x));\n		}\n		System.out.println(stands);\n	}\n\n	public void tf(boolean... r)\n	{\n		for(boolean x : r)System.out.print(x?'#':'.');\n		System.out.println();\n	}\n\n	public void tf(boolean[]... b)\n	{\n		for(boolean[] r : b) {\n			for(boolean x : r)System.out.print(x?'#':'.');\n			System.out.println();\n		}\n		System.out.println();\n	}\n\n	public void tf(long[]... b)\n	{\n		if(INPUT.length() != 0) {\n			for (long[] r : b) {\n				for (long x : r) {\n					for (int i = 0; i < 64; i++) {\n						System.out.print(x << ~i < 0 ? '#' : '.');\n					}\n				}\n				System.out.println();\n			}\n			System.out.println();\n		}\n	}\n\n	public void tf(long... b)\n	{\n		if(INPUT.length() != 0) {\n			for (long x : b) {\n				for (int i = 0; i < 64; i++) {\n					System.out.print(x << ~i < 0 ? '#' : '.');\n				}\n			}\n			System.out.println();\n		}\n	}\n\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","combinatorics,dp,fft,math"
"//package ecr104;\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Queue;\n \npublic class G3 {\n	InputStream is;\n	FastWriter out;\n	String INPUT = """";\n \n	void solve()\n	{\n		final int mod = 998244353;\n		int n = ni();\n		int[] a = na(26);\n		long all = 26 * 26 * pow(25, n-2, mod) % mod;\n \n		long[][][] dp = new long[3][n+1][n+1];\n		dp[0][1][0] = 1;\n		dp[1][0][1] = 1;\n		dp[2][0][0] = 1;\n		for(int i = 0;i < n-1;i++){\n			long[][][] ndp = new long[3][n+1][n+1];\n			if(i == (n+1)/2-1){\n				for (int j = 0; j <= n; j++) {\n					for (int k = 0; j+k <= n; k++) {\n						if (j + 1 <= n) {\n							ndp[0][j + 1][k] += dp[0][j][k] + dp[1][j][k] + dp[2][j][k] * 24;\n							ndp[0][j + 1][k] %= mod;\n						}\n						if (k + 1 <= n) {\n							ndp[1][j][k + 1] += dp[0][j][k] + dp[1][j][k] + dp[2][j][k] * 24;\n							ndp[1][j][k + 1] %= mod;\n						}\n						ndp[2][j][k] += dp[0][j][k] + dp[1][j][k] + dp[2][j][k] * 24;\n						ndp[2][j][k] %= mod;\n					}\n				}\n			}else {\n				for (int j = 0; j <= n; j++) {\n					for (int k = 0; j+k <= n; k++) {\n						if (j + 1 <= n) {\n							ndp[0][j + 1][k] += dp[1][j][k] + dp[2][j][k] * 24;\n							ndp[0][j + 1][k] %= mod;\n						}\n						if (k + 1 <= n) {\n							ndp[1][j][k + 1] += dp[0][j][k] + dp[2][j][k] * 24;\n							ndp[1][j][k + 1] %= mod;\n						}\n						ndp[2][j][k] += dp[0][j][k] + dp[1][j][k] + dp[2][j][k] * 23;\n						ndp[2][j][k] %= mod;\n					}\n				}\n \n			}\n			dp = ndp;\n		}\n \n		long[] sdp = new long[n+1];\n		for(int i = 0;i <= n;i++){\n			for(int j = 0;j <= n;j++){\n				sdp[i] += dp[0][i][j] + dp[1][i][j] + dp[2][i][j] * 24;\n			}\n			sdp[i] %= mod;\n		}\n \n		for(int i = 0;i < 26;i++){\n			for(int k = a[i]+1;k <= n;k++){\n				all -= sdp[k];\n			}\n		}\n \n		for(int i = 0;i < 26;i++){\n			for(int j = i+1;j < 26;j++){\n				for(int k = a[i]+1;k <= n;k++){\n					for(int l = a[j]+1;l+k <= n;l++){\n						all += (dp[0][k][l] + dp[1][k][l] + dp[2][k][l] * 24);\n					}\n				}\n				all %= mod;\n			}\n		}\n		all %= mod;\n \n		if(all < 0)all += mod;\n		out.println(all);\n	}\n \n	public static long pow(long a, long n, long mod) {\n		//		a %= mod;\n		long ret = 1;\n		int x = 63 - Long.numberOfLeadingZeros(n);\n		for (; x >= 0; x--) {\n			ret = ret * ret % mod;\n			if (n << 63 - x < 0) ret = ret * a % mod;\n		}\n		return ret;\n	}\n \n \n	public static long invl(long a, long mod) {\n		long b = mod;\n		long p = 1, q = 0;\n		while (b > 0) {\n			long c = a / b;\n			long d;\n			d = a;\n			a = b;\n			b = d % b;\n			d = p;\n			p = q;\n			q = d - c * q;\n		}\n		return p < 0 ? p + mod : p;\n	}\n \n \n	public static long C(int n, int r, int mod, int[][] fif) {\n		if (n < 0 || r < 0 || r > n) return 0;\n		return (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n	}\n \n \n	public static int[][] enumFIF(int n, int mod) {\n		int[] f = new int[n + 1];\n		int[] invf = new int[n + 1];\n		f[0] = 1;\n		for (int i = 1; i <= n; i++) {\n			f[i] = (int) ((long) f[i - 1] * i % mod);\n		}\n		long a = f[n];\n		long b = mod;\n		long p = 1, q = 0;\n		while (b > 0) {\n			long c = a / b;\n			long d;\n			d = a;\n			a = b;\n			b = d % b;\n			d = p;\n			p = q;\n			q = d - c * q;\n		}\n		invf[n] = (int) (p < 0 ? p + mod : p);\n		for (int i = n - 1; i >= 0; i--) {\n			invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n		}\n		return new int[][]{f, invf};\n	}\n \n \n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new FastWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new G3().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n \n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n \n	private long[] nal(int n)\n	{\n		long[] a = new long[n];\n		for(int i = 0;i < n;i++)a[i] = nl();\n		return a;\n	}\n \n	private char[][] nm(int n, int m) {\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n \n	private int[][] nmi(int n, int m) {\n		int[][] map = new int[n][];\n		for(int i = 0;i < n;i++)map[i] = na(m);\n		return map;\n	}\n \n	private int ni() { return (int)nl(); }\n \n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n \n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n \n	public static class FastWriter\n	{\n		private static final int BUF_SIZE = 1<<13;\n		private final byte[] buf = new byte[BUF_SIZE];\n		private final OutputStream out;\n		private int ptr = 0;\n \n		private FastWriter(){out = null;}\n \n		public FastWriter(OutputStream os)\n		{\n			this.out = os;\n		}\n \n		public FastWriter(String path)\n		{\n			try {\n				this.out = new FileOutputStream(path);\n			} catch (FileNotFoundException e) {\n				throw new RuntimeException(""FastWriter"");\n			}\n		}\n \n		public FastWriter write(byte b)\n		{\n			buf[ptr++] = b;\n			if(ptr == BUF_SIZE)innerflush();\n			return this;\n		}\n \n		public FastWriter write(char c)\n		{\n			return write((byte)c);\n		}\n \n		public FastWriter write(char[] s)\n		{\n			for(char c : s){\n				buf[ptr++] = (byte)c;\n				if(ptr == BUF_SIZE)innerflush();\n			}\n			return this;\n		}\n \n		public FastWriter write(String s)\n		{\n			s.chars().forEach(c -> {\n				buf[ptr++] = (byte)c;\n				if(ptr == BUF_SIZE)innerflush();\n			});\n			return this;\n		}\n \n		private static int countDigits(int l) {\n			if (l >= 1000000000) return 10;\n			if (l >= 100000000) return 9;\n			if (l >= 10000000) return 8;\n			if (l >= 1000000) return 7;\n			if (l >= 100000) return 6;\n			if (l >= 10000) return 5;\n			if (l >= 1000) return 4;\n			if (l >= 100) return 3;\n			if (l >= 10) return 2;\n			return 1;\n		}\n \n		public FastWriter write(int x)\n		{\n			if(x == Integer.MIN_VALUE){\n				return write((long)x);\n			}\n			if(ptr + 12 >= BUF_SIZE)innerflush();\n			if(x < 0){\n				write((byte)'-');\n				x = -x;\n			}\n			int d = countDigits(x);\n			for(int i = ptr + d - 1;i >= ptr;i--){\n				buf[i] = (byte)('0'+x%10);\n				x /= 10;\n			}\n			ptr += d;\n			return this;\n		}\n \n		private static int countDigits(long l) {\n			if (l >= 1000000000000000000L) return 19;\n			if (l >= 100000000000000000L) return 18;\n			if (l >= 10000000000000000L) return 17;\n			if (l >= 1000000000000000L) return 16;\n			if (l >= 100000000000000L) return 15;\n			if (l >= 10000000000000L) return 14;\n			if (l >= 1000000000000L) return 13;\n			if (l >= 100000000000L) return 12;\n			if (l >= 10000000000L) return 11;\n			if (l >= 1000000000L) return 10;\n			if (l >= 100000000L) return 9;\n			if (l >= 10000000L) return 8;\n			if (l >= 1000000L) return 7;\n			if (l >= 100000L) return 6;\n			if (l >= 10000L) return 5;\n			if (l >= 1000L) return 4;\n			if (l >= 100L) return 3;\n			if (l >= 10L) return 2;\n			return 1;\n		}\n \n		public FastWriter write(long x)\n		{\n			if(x == Long.MIN_VALUE){\n				return write("""" + x);\n			}\n			if(ptr + 21 >= BUF_SIZE)innerflush();\n			if(x < 0){\n				write((byte)'-');\n				x = -x;\n			}\n			int d = countDigits(x);\n			for(int i = ptr + d - 1;i >= ptr;i--){\n				buf[i] = (byte)('0'+x%10);\n				x /= 10;\n			}\n			ptr += d;\n			return this;\n		}\n \n		public FastWriter write(double x, int precision)\n		{\n			if(x < 0){\n				write('-');\n				x = -x;\n			}\n			x += Math.pow(10, -precision)/2;\n			//		if(x < 0){ x = 0; }\n			write((long)x).write(""."");\n			x -= (long)x;\n			for(int i = 0;i < precision;i++){\n				x *= 10;\n				write((char)('0'+(int)x));\n				x -= (int)x;\n			}\n			return this;\n		}\n \n		public FastWriter writeln(char c){\n			return write(c).writeln();\n		}\n \n		public FastWriter writeln(int x){\n			return write(x).writeln();\n		}\n \n		public FastWriter writeln(long x){\n			return write(x).writeln();\n		}\n \n		public FastWriter writeln(double x, int precision){\n			return write(x, precision).writeln();\n		}\n \n		public FastWriter write(int... xs)\n		{\n			boolean first = true;\n			for(int x : xs) {\n				if (!first) write(' ');\n				first = false;\n				write(x);\n			}\n			return this;\n		}\n \n		public FastWriter write(long... xs)\n		{\n			boolean first = true;\n			for(long x : xs) {\n				if (!first) write(' ');\n				first = false;\n				write(x);\n			}\n			return this;\n		}\n \n		public FastWriter writeln()\n		{\n			return write((byte)'\n');\n		}\n \n		public FastWriter writeln(int... xs)\n		{\n			return write(xs).writeln();\n		}\n \n		public FastWriter writeln(long... xs)\n		{\n			return write(xs).writeln();\n		}\n \n		public FastWriter writeln(char[] line)\n		{\n			return write(line).writeln();\n		}\n \n		public FastWriter writeln(char[]... map)\n		{\n			for(char[] line : map)write(line).writeln();\n			return this;\n		}\n \n		public FastWriter writeln(String s)\n		{\n			return write(s).writeln();\n		}\n \n		private void innerflush()\n		{\n			try {\n				out.write(buf, 0, ptr);\n				ptr = 0;\n			} catch (IOException e) {\n				throw new RuntimeException(""innerflush"");\n			}\n		}\n \n		public void flush()\n		{\n			innerflush();\n			try {\n				out.flush();\n			} catch (IOException e) {\n				throw new RuntimeException(""flush"");\n			}\n		}\n \n		public FastWriter print(byte b) { return write(b); }\n		public FastWriter print(char c) { return write(c); }\n		public FastWriter print(char[] s) { return write(s); }\n		public FastWriter print(String s) { return write(s); }\n		public FastWriter print(int x) { return write(x); }\n		public FastWriter print(long x) { return write(x); }\n		public FastWriter print(double x, int precision) { return write(x, precision); }\n		public FastWriter println(char c){ return writeln(c); }\n		public FastWriter println(int x){ return writeln(x); }\n		public FastWriter println(long x){ return writeln(x); }\n		public FastWriter println(double x, int precision){ return writeln(x, precision); }\n		public FastWriter print(int... xs) { return write(xs); }\n		public FastWriter print(long... xs) { return write(xs); }\n		public FastWriter println(int... xs) { return writeln(xs); }\n		public FastWriter println(long... xs) { return writeln(xs); }\n		public FastWriter println(char[] line) { return writeln(line); }\n		public FastWriter println(char[]... map) { return writeln(map); }\n		public FastWriter println(String s) { return writeln(s); }\n		public FastWriter println() { return writeln(); }\n	}\n \n	public void trnz(int... o)\n	{\n		for(int i = 0;i < o.length;i++)if(o[i] != 0)System.out.print(i+"":""+o[i]+"" "");\n		System.out.println();\n	}\n \n	// print ids which are 1\n	public void trt(long... o)\n	{\n		Queue<Integer> stands = new ArrayDeque<>();\n		for(int i = 0;i < o.length;i++){\n			for(long x = o[i];x != 0;x &= x-1)stands.add(i<<6|Long.numberOfTrailingZeros(x));\n		}\n		System.out.println(stands);\n	}\n \n	public void tf(boolean... r)\n	{\n		for(boolean x : r)System.out.print(x?'#':'.');\n		System.out.println();\n	}\n \n	public void tf(boolean[]... b)\n	{\n		for(boolean[] r : b) {\n			for(boolean x : r)System.out.print(x?'#':'.');\n			System.out.println();\n		}\n		System.out.println();\n	}\n \n	public void tf(long[]... b)\n	{\n		if(INPUT.length() != 0) {\n			for (long[] r : b) {\n				for (long x : r) {\n					for (int i = 0; i < 64; i++) {\n						System.out.print(x << ~i < 0 ? '#' : '.');\n					}\n				}\n				System.out.println();\n			}\n			System.out.println();\n		}\n	}\n \n	public void tf(long... b)\n	{\n		if(INPUT.length() != 0) {\n			for (long x : b) {\n				for (int i = 0; i < 64; i++) {\n					System.out.print(x << ~i < 0 ? '#' : '.');\n				}\n			}\n			System.out.println();\n		}\n	}\n \n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","combinatorics,dp,fft,math"
"import java.util.*;\npublic class t{\n	static Scanner sc = new Scanner(System.in);\n	static void solve()\n	{\n		int a = sc.nextInt(), b = sc.nextInt();\n		b--;\n		int mid = a/2;\n		System.out.println(((b+((a%2)*(b/mid)))%a)+1);\n	}\n	public static void main(String args[])\n	{\n		int t = sc.nextInt();\n		for(int i=0;i<t;i++)\n			solve();\n	}\n}\n","math,number theory"
import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        int t=sc.nextInt();\n        while(t-->0){\n            int n=sc.nextInt();\n            int k=sc.nextInt();\n            k--;\n            int f=n/2;\n            int ans=(k+(n%2)*(k/f))%n;\n            System.out.println(ans+1);\n        }\n    }\n},"math,number theory"
import java.util.Scanner;\n\npublic class EC104_B {\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while (t > 0) {\n			int n = sc.nextInt();\n			int k = sc.nextInt();\n			int mid = n/2;\n			int pos = n%2==0?k:k%mid==0?k+(k/mid)-1:k+(k/mid);\n			System.out.println(pos%n == 0?n:pos%n);\n			t--;			\n		}\n		sc.close();\n	}\n}\n,"math,number theory"
"import java.util.*;\n\n\npublic class A {\n	public static void main(String[] args) {\n		Scanner input = new Scanner(System.in);\n		int t = input.nextInt();\n		for(int tt = 0; tt < t; ++tt) {\n			int n,k;\n			n = input.nextInt();\n			k = input.nextInt();\n			k--;\n			int f = n / 2;\n		//	System.out.println(f);\n			System.out.println(((k + (n%2)*(k/f))%n) + 1);\n		}\n		\n		input.close();\n	}\n}","math,number theory"
import java.io.*;\nimport java.util.*;\n\npublic class eastern_exhibition {\n	static Scanner in = new Scanner(System.in);\n\n	\n	static void solve() {\n		int a= in.nextInt();\n		long[] x = new long[a];\n		long[] y = new long[a];\n		for(int i = 0;i< a;i++ ) {\n			x[i] = in.nextInt();\n			y[i] = in.nextInt();\n		}\n		Arrays.sort(x);\n		Arrays.sort(y);\n		long g = x[a/2] - x[(a-1)/2] + 1;\n		long h = y[a/2] - y[(a-1)/2] + 1;\n		System.out.println(g*h);\n	}\n	\n	\n	\n	\n	public static void main(String[] args) {\n		int t = in.nextInt();\n		for(int i = 0;i< t;i++ ) {\n			solve();\n		}\n	}\n}\n,"binary search,geometry,shortest paths,sortings"
import java.io.*;\nimport java.util.*;\n\npublic class eastern_exhibition {\n	static Scanner in = new Scanner(System.in);\n\n	\n	static void solve() {\n		int a= in.nextInt();\n		long[] x = new long[a];\n		long[] y = new long[a];\n		for(int i = 0;i< a;i++ ) {\n			x[i] = in.nextInt();\n			y[i] = in.nextInt();\n		}\n		Arrays.sort(x);\n		Arrays.sort(y);\n		long g = x[a/2] - x[(a-1)/2] + 1;\n		long h = y[a/2] - y[(a-1)/2] + 1;\n		System.out.println(g*h);\n	}\n	\n	\n	\n	\n	public static void main(String[] args) {\n		int t = in.nextInt();\n		for(int i = 0;i< t;i++ ) {\n			solve();\n		}\n	}\n}\n,"binary search,geometry,shortest paths,sortings"
\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Round703_2 {\npublic static void main(String[] args) {\n	Scanner o=new Scanner(System.in);\n	int t=o.nextInt();	\n	while(t>0) {\n		int n=o.nextInt();\n		int arx[]=new int[n];\n		int ary[]=new int[n];\n		long s=0;\n		for(int i=0;i<n;i++) {\n			arx[i]=o.nextInt();\n			ary[i]=o.nextInt();\n		}\n		\n		Arrays.sort(arx);\n		Arrays.sort(ary);\n		if(n%2==1)\n			System.out.println(1);\n		else {\n			long x=arx[n/2]-arx[(n-2)/2]+1;\n			long y=ary[n/2]-ary[(n-2)/2]+1;\n			long val=x*y;\n			System.out.println(val);\n		}\n		t--;\n	}\n}\n}\n,"binary search,geometry,shortest paths,sortings"
import java.util.Scanner;\nimport java.util.Arrays;\n\n//Thanks be to Lord and Mary\npublic class sol {\n	\n	\n	\n	static Scanner in = new Scanner(System.in);\n	\n	\n	\n	static void solve() {\n	int a= in.nextInt();\n	long[] x = new long[a];\n	long[] y = new long[a];\n	for(int i = 0;i< a;i++ ) {\n	x[i] = in.nextInt();\n	y[i] = in.nextInt();\n	}\n	Arrays.sort(x);\n	Arrays.sort(y);\n	long g = x[a/2] - x[(a-1)/2] + 1;\n	long h = y[a/2] - y[(a-1)/2] + 1;\n	System.out.println(g*h);\n	}\n	\n	\n	\n	\n	public static void main(String[] args) {\n	int t = in.nextInt();\n	for(int i = 0;i< t;i++ ) {\n	solve();\n	}\n	}\n\n\n\n},"binary search,geometry,shortest paths,sortings"
"import java.util.*;\npublic class Pracise1 {\n	public static void main(String[] args) {\n		 Scanner sc = new Scanner(System.in);\n		 int t=sc.nextInt();\nwhile(t-->0) {\n\n	int n=sc.nextInt();\n	long ar[]=new long[n];\n	long sum=0;\n	\n	for(int i=0;i<n;i++)\n	{\n		ar[i]=sc.nextLong();		\n	}\n	long flag=0,d=0;\n	if(n>=2)\n	{\n		d=ar[1]-ar[0];\n	}\n	for(int i=0;i<n-1;i++)\n	{\n			\n			if(ar[i+1]-ar[i]!=d)\n			{\n				flag=1;\n				break;\n			}\n \n	}\n	if(n==1||n==2||flag==0)\n	{\n		System.out.println(""0"");\n		\n	}\n	else \n	{\n		long m=0;flag=0;\n		d=0;\n \n		for(int i=1;i<n-1;i++)\n		{\n			if(ar[i]<ar[i-1] && ar[i]<ar[i+1])\n			{\n				d=ar[i+1]-ar[i];\n		        m=ar[i-1]+d-ar[i];\n		        break;\n			}\n			else if(ar[i]>ar[i-1] && ar[i]>ar[i+1])\n			{\n				d=ar[i]-ar[i-1];\n				m=ar[i]+d-ar[i+1];\n				break;\n			}\n		}\n		if(m!=0)\n		for(int i=0;i<n-1;i++)\n		{\n			if(ar[i+1]!=(ar[i]+d)%m)\n			{\n				flag=1;\n				\n				break;\n			}\n \n		}\n		if(ar[0]>=m)\n		{\n			flag=1;\n		}\n		if(flag==1 || m==0)\n		{\n			System.out.println(""-1"");\n		}\n		else\n			System.out.println(m+"" ""+d);\n \n	}\n}\n	}\n}\n\n","implementation,math"
"import java.util.*;\npublic class b {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		\n		while(t-->0)\n		{\n			int n = sc.nextInt();\n			int[] a = new int[n];\n			\n			for(int i = 0; i < n; i++)\n			{\n				a[i] = sc.nextInt();\n			}\n			\n			TreeSet<Integer> tr = new TreeSet<>();\n			boolean same = false;\n			int c = 0;\n			for(int i = 1; i < n; i++)\n			{\n				if(a[i]>a[i-1])\n				{\n					c = a[i]-a[i-1];\n				}\n				\n				tr.add(a[i-1]-a[i]);\n				\n			}\n			\n			\n			if(tr.size()<2)\n				System.out.println(0);\n			else if(tr.size()>2)\n				System.out.println(-1);\n			else\n			{\n				int min = tr.pollFirst();\n				int max = tr.pollFirst();\n				int m = Math.abs(max) +Math.abs(min);\n				if(min>=0 || m<=a[0] || max<=0)\n					System.out.println(-1);\n				else\n				{\n					boolean ans = true;\n					\n					for(int i = 1; i < n; i++)\n					{\n						long an = a[i-1]+c;\n						an%=m;\n						\n						if(an!=a[i])\n						{\n							ans = false;\n							break;\n						}\n					}\n					\n					if(ans)\n						System.out.println(m+"" ""+c);\n					else\n						System.out.println(-1);\n					\n				}\n				\n			}\n			\n		}\n	}\n\n}\n","implementation,math"
"//package codeforces;\nimport java.util.*;\n//import java.io.PrintWriter;\n\npublic class solution {\n	\n    public static void main(String args[]){ \n        Scanner s=new Scanner(System.in);\n        int tt=s.nextInt();\n        for(int t=0;t<tt;t++) {\n        	int n=s.nextInt();\n        	int c=-1,d=-1,max=0,a=s.nextInt();\n        	boolean an=true;\n        	max=a;\n        	for(int i=1;i<n;i++) {\n        		int b=s.nextInt();\n        		if(a<=b) {\n        			if(c>=0 && b-a!=c) {\n        				an=false;\n        			}\n        			c=b-a;\n        		}\n        		if(a>=b) {\n        			if(d>=0 && a-b!=d) {\n        				an=false;\n        			}\n        			d=a-b;\n        		}\n        		a=b;\n        		max=Math.max(max,a);\n        	}\n        	if(!an) {\n        		System.out.println(-1);\n        	}else if(c<=0 || d<=0) {\n        		System.out.println(0);\n        	}else if(c+d<=max) {\n        		System.out.println(-1);\n        	}else {\n        		System.out.println(c+d+"" ""+c);\n        	}\n        }\n        s.close();\n    } \n	static void sort(int[] a) {\n		ArrayList<Integer> l=new ArrayList<>();\n		for (int i:a) l.add(i);\n		Collections.sort(l);\n		for (int i=0; i<a.length; i++) a[i]=l.get(i);\n	}\n	\n}\n\n","implementation,math"
"import java.util.*;\npublic class b {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		\n		while(t-->0)\n		{\n			int n = sc.nextInt();\n			int[] a = new int[n];\n			\n			for(int i = 0; i < n; i++)\n			{\n				a[i] = sc.nextInt();\n			}\n			\n			TreeSet<Integer> tr = new TreeSet<>();\n			boolean same = false;\n			int c = 0;\n			for(int i = 1; i < n; i++)\n			{\n				if(a[i]>a[i-1])\n				{\n					c = a[i]-a[i-1];\n				}\n				\n				tr.add(a[i-1]-a[i]);\n				\n			}\n			\n			\n			if(tr.size()<2)\n				System.out.println(0);\n			else if(tr.size()>2)\n				System.out.println(-1);\n			else\n			{\n				int min = tr.pollFirst();\n				int max = tr.pollFirst();\n				int m = Math.abs(max) +Math.abs(min);\n				if(min>=0 || m<=a[0] || max<=0)\n					System.out.println(-1);\n				else\n				{\n					boolean ans = true;\n					\n					for(int i = 1; i < n; i++)\n					{\n						long an = a[i-1]+c;\n						an%=m;\n						\n						if(an!=a[i])\n						{\n							ans = false;\n							break;\n						}\n					}\n					\n					if(ans)\n						System.out.println(m+"" ""+c);\n					else\n						System.out.println(-1);\n					\n				}\n				\n			}\n			\n		}\n	}\n\n}\n","implementation,math"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1474D extends PrintWriter {\n	CF1474D() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1474D o = new CF1474D(); o.main(); o.flush();\n	}\n\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int[] aa = new int[n + 2];\n			for (int i = 1; i <= n; i++)\n				aa[i] = sc.nextInt();\n			int[] pp = new int[n + 2];\n			int[] qq = new int[n + 2];\n			for (int i = 1; i <= n; i++)\n				pp[i] = pp[i - 1] < 0 ? -1 : aa[i] - pp[i - 1];\n			for (int i = n; i >= 1; i--)\n				qq[i] = qq[i + 1] < 0 ? -1 : aa[i] - qq[i + 1];\n			boolean yes = false;\n			for (int i = 1; i < n; i++) {\n				int a = aa[i], b = aa[i + 1];\n				int p = pp[i - 1], q = qq[i + 2];\n				if (p < 0 || q < 0)\n					continue;\n				if (a >= p && b >= q && a - p == b - q) {\n					yes = true;\n					break;\n				}\n				int tmp = a; a = b; b = tmp;\n				if (a >= p && b >= q && a - p == b - q) {\n					yes = true;\n					break;\n				}\n			}\n			println(yes ? ""YES"" : ""NO"");\n		}\n	}\n}\n","data structures,dp,greedy,math"
"import java.util.Scanner;\n\npublic class Main1 {\n    static int[] a;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        for (int i = 0; i < t; i++) {\n            a = new int[sc.nextInt()];\n            for (int j = 0; j < a.length; j++) {\n                a[j] = sc.nextInt();\n            }\n            if (canClean()) {\n                System.out.println(""YES"");\n            } else {\n                System.out.println(""NO"");\n            }\n        }\n    }\n\n    private static boolean canClean() {\n        int[] pref = new int[a.length];\n        pref[0] = a[0];\n        for (int i = 1; i < a.length; i++) {\n            if (pref[i - 1] < 0) pref[i] = -1;\n            else pref[i] = a[i] - pref[i - 1];\n        }\n\n        int[] suff = new int[a.length + 1];\n        suff[a.length - 1] = a[a.length - 1];\n        for (int i = a.length - 2; i >= 0; i--) {\n            if (suff[i + 1] < 0) suff[i] = -1;\n            else suff[i] = a[i] - suff[i + 1];\n        }\n//        System.out.println(""pref: "" + Arrays.toString(pref));\n//        System.out.println(""suff: "" + Arrays.toString(suff));\n        if (pref[pref.length - 1] == 0) return true;\n\n        for (int i = 0; i < a.length - 1; i++) {\n            if (getPrefIMinusOne(pref, i) >= 0 && suff[i + 2] >= 0\n                    && a[i + 1] - getPrefIMinusOne(pref, i) >= 0\n                    && a[i] - a[i + 1] + getPrefIMinusOne(pref, i) == suff[i + 2]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    static int getPrefIMinusOne(int[] pref, int i) {\n        if (i == 0) return 0;\n        return pref[i - 1];\n    }\n\n\n}\n","data structures,dp,greedy,math"
"\nimport java.io.*;\nimport java.util.*;\n\npublic class randoms {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int T = Integer.parseInt(br.readLine());\n        for(int t = 0; t<T; t++){\n            int N = Integer.parseInt(br.readLine());\n            int[] nums = new int[N+2];\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            for(int i = 1; i<=N; i++){\n                nums[i] = Integer.parseInt(st.nextToken());\n            }\n            pw.println(solve(nums) ? ""YES"" : ""NO"");\n        }\n        pw.close();\n        br.close();\n    }\n    \n    static boolean solve(int[] nums){\n        int[] pref = new int[nums.length];\n        int[] suf = new int[nums.length];\n        Arrays.fill(pref, -1); Arrays.fill(suf, -1);\n        pref[0] = suf[suf.length-1] = 0;\n        for(int i = 1; i<pref.length-1; i++){\n            pref[i] = nums[i] - pref[i-1]; if(pref[i] < 0) break;\n        }\n        if(pref[pref.length-2] == 0) return true;\n        for(int i = suf.length-2; i>=0; i--){\n            suf[i] = nums[i] - suf[i+1]; if(suf[i] < 0) break;\n        }\n        for(int i = 1; i+2 < suf.length; i++){\n            if(pref[i-1] <0 || suf[i+2] < 0) continue;\n            if(nums[i] - pref[i-1] >= 0 && nums[i+1] - suf[i+2] >= 0 && nums[i] - pref[i-1] == nums[i+1] - suf[i+2]) return true;\n            if( \n                    (nums[i+1] - pref[i-1] >= 0 && nums[i] - suf[i+2] >= 0) \n                    && \n                    (nums[i+1] - pref[i-1] == nums[i] - suf[i+2])){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n","data structures,dp,greedy,math"
"import java.util.Scanner;\n\npublic class Main1 {\n    static int[] a;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        for (int i = 0; i < t; i++) {\n            a = new int[sc.nextInt()];\n            for (int j = 0; j < a.length; j++) {\n                a[j] = sc.nextInt();\n            }\n            if (canClean()) {\n                System.out.println(""YES"");\n            } else {\n                System.out.println(""NO"");\n            }\n        }\n    }\n\n    private static boolean canClean() {\n        int[] pref = new int[a.length];\n        pref[0] = a[0];\n        for (int i = 1; i < a.length; i++) {\n            if (pref[i - 1] < 0) pref[i] = -1;\n            else pref[i] = a[i] - pref[i - 1];\n        }\n\n        int[] suff = new int[a.length];\n        suff[suff.length - 1] = a[a.length - 1];\n        for (int i = suff.length - 2; i >= 0; i--) {\n            if (suff[i + 1] < 0) suff[i] = -1;\n            else suff[i] = a[i] - suff[i + 1];\n        }\n//        System.out.println(""pref: "" + Arrays.toString(pref));\n//        System.out.println(""suff: "" + Arrays.toString(suff));\n        if (pref[pref.length - 1] == 0) return true;\n\n        for (int i = 0; i < a.length - 1; i++) {\n            if (getPrefIMinusOne(pref, i) >= 0 && getSuffIPlusTwo(suff, i) >= 0\n                    && a[i + 1] - getPrefIMinusOne(pref, i) >= 0\n                    && a[i] - a[i + 1] + getPrefIMinusOne(pref, i) == getSuffIPlusTwo(suff, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    static int getPrefIMinusOne(int[] pref, int i) {\n        if (i == 0) return 0;\n        return pref[i - 1];\n    }\n\n    static int getSuffIPlusTwo(int[] suff, int i) {\n        if (i >= suff.length - 2) return 0;\n        return suff[i + 2];\n    }\n\n\n}\n","data structures,dp,greedy,math"
"import java.io.*;\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\npublic class template {\n	public static void main(String[] args) throws Exception {\n		new template().run();\n	}\n	public void run() throws Exception {\n		FastScanner f = new FastScanner();\n		PrintWriter out = new PrintWriter(System.out);\n		int n = f.nextInt(), k = f.nextInt();\n		Integer[] arr = new Integer[n];\n		for(int i = 0; i < n; i++) arr[i] = f.nextInt();\n		Arrays.sort(arr);\n		seg = new long[4*SZ];\n		lz = new long[4*SZ];\n		int best = 2147483647;\n		add(0,1);\n		for(int asdf = n-1; asdf >= 0; asdf--) {\n			int i = find(1)+1;\n			add(i, -1);\n			int a = arr[asdf];\n			add(i+2, i+2+(a-1)/2, 2);\n			if(a%2 == 0) add(i+2+(a-1)/2, 1);\n			best = Math.min(best, find(k)+1);\n		}\n		out.println(best == 2147483647 ? -1 : best);\n		out.flush();\n	}\n	long[] seg, lz;\n	int SZ = 1_000_000;\n	public void add(int i, long v) { add(1, 0, SZ, i, i+1, v); }\n	public void add(int l, int r, long v) {add(1, 0, SZ, l, r, v); }\n	public void add(int i, int l, int r, int ql, int qr, long v) {\n		if(qr <= l || r <= ql) return;\n		if(ql <= l && r <= qr) {\n			lz[i] += v;\n			return;\n		}\n		qr = Math.min(r, qr); ql = Math.max(l, ql);\n		seg[i] += (r-l)*lz[i] + (qr-ql)*v;\n		lz[2*i] += lz[i];\n		lz[2*i+1] += lz[i];\n		lz[i] = 0;\n		int m = (l+r)/2;\n		add(2*i, l, m, ql, qr, v);\n		add(2*i+1, m, r, ql, qr, v);\n	}\n	public int find(long v) { return find(1, 0, SZ, v, 0); }\n	public int find(int i, int l, int r, long v, long cur) {\n		if(cur + seg[i] + lz[i]*(r-l) < v) return 2147483646;\n		if(l == r-1) {\n			seg[i] += lz[i];\n			lz[i] = 0;\n			if(cur + seg[i] >= v) return l-1;\n			return l;\n		}\n		seg[i] += (r-l)*lz[i];\n		lz[2*i] += lz[i];\n		lz[2*i+1] += lz[i];\n		lz[i] = 0;\n		int m = (l+r)/2;\n		if(seg[2*i] + (m-l)*lz[2*i] + cur < v) return find(2*i+1, m, r, v, seg[2*i] + (m-l)*lz[2*i] + cur);\n		else return find(2*i, l, m, v, cur);\n	}\n///\n	static class FastScanner {\n		public BufferedReader reader;\n		public StringTokenizer tokenizer;\n		public FastScanner() {\n			reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n			tokenizer = null;\n		}\n		public String next() {\n			while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n				try {\n					tokenizer = new StringTokenizer(reader.readLine());\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n			return tokenizer.nextToken();\n		}\n		public int nextInt() {\n			return Integer.parseInt(next());\n		}\n		public long nextLong() {\n			return Long.parseLong(next());\n		}\n		public double nextDouble() {\n			return Double.parseDouble(next());\n		}\n		public String nextLine() {\n			try {\n				return reader.readLine();\n			} catch(IOException e) {\n				throw new RuntimeException(e);\n			}\n		}\n	}\n}","binary search,data structures,greedy"
"import java.io.*;\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\npublic class template {\n	public static void main(String[] args) throws Exception {\n		new template().run();\n	}\n	public void run() throws Exception {\n		FastScanner f = new FastScanner();\n		PrintWriter out = new PrintWriter(System.out);\n		int n = f.nextInt(), k = f.nextInt();\n		Integer[] arr = new Integer[n];\n		for(int i = 0; i < n; i++) arr[i] = f.nextInt();\n		Arrays.sort(arr);\n		seg = new long[4*SZ];\n		lz = new long[4*SZ];\n		int best = 2147483647;\n		add(0,1);\n		for(int asdf = n-1; asdf >= 0; asdf--) {\n			int i = find(1)+1;\n			add(i, -1);\n			int a = arr[asdf];\n			add(i+2, i+2+(a-1)/2, 2);\n			if(a%2 == 0) add(i+2+(a-1)/2, 1);\n			best = Math.min(best, find(k)+1);\n		}\n		out.println(best == 2147483647 ? -1 : best);\n		out.flush();\n	}\n	long[] seg, lz;\n	int SZ = 1_000_000;\n	public void add(int i, long v) { add(1, 0, SZ, i, i+1, v); }\n	public void add(int l, int r, long v) {add(1, 0, SZ, l, r, v); }\n	public void add(int i, int l, int r, int ql, int qr, long v) {\n		if(qr <= l || r <= ql) return;\n		if(ql <= l && r <= qr) {\n			lz[i] += v;\n			return;\n		}\n		qr = Math.min(r, qr); ql = Math.max(l, ql);\n		seg[i] += (r-l)*lz[i] + (qr-ql)*v;\n		lz[2*i] += lz[i];\n		lz[2*i+1] += lz[i];\n		lz[i] = 0;\n		int m = (l+r)/2;\n		add(2*i, l, m, ql, qr, v);\n		add(2*i+1, m, r, ql, qr, v);\n	}\n	public int find(long v) { return find(1, 0, SZ, v, 0); }\n	public int find(int i, int l, int r, long v, long cur) {\n		if(cur + seg[i] + lz[i]*(r-l) < v) return 2147483646;\n		if(l == r-1) {\n			seg[i] += lz[i];\n			lz[i] = 0;\n			if(cur + seg[i] >= v) return l-1;\n			return l;\n		}\n		seg[i] += (r-l)*lz[i];\n		lz[2*i] += lz[i];\n		lz[2*i+1] += lz[i];\n		lz[i] = 0;\n		int m = (l+r)/2;\n		if(seg[2*i] + (m-l)*lz[2*i] + cur < v) return find(2*i+1, m, r, v, seg[2*i] + (m-l)*lz[2*i] + cur);\n		else return find(2*i, l, m, v, cur);\n	}\n///\n	static class FastScanner {\n		public BufferedReader reader;\n		public StringTokenizer tokenizer;\n		public FastScanner() {\n			reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n			tokenizer = null;\n		}\n		public String next() {\n			while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n				try {\n					tokenizer = new StringTokenizer(reader.readLine());\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n			return tokenizer.nextToken();\n		}\n		public int nextInt() {\n			return Integer.parseInt(next());\n		}\n		public long nextLong() {\n			return Long.parseLong(next());\n		}\n		public double nextDouble() {\n			return Double.parseDouble(next());\n		}\n		public String nextLine() {\n			try {\n				return reader.readLine();\n			} catch(IOException e) {\n				throw new RuntimeException(e);\n			}\n		}\n	}\n}\n","binary search,data structures,greedy"
"import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n  static int MAXN = 200000;\n  public static void solve(BufferedReader br) throws IOException {\n    // greedy;\n    // 1. it is always optimal to pick the longest chain to attach to current tree;\n    // 2. it is always optimal to attach the middle node of the new chain\n    // 3. it is always optimal to attach the new chain to the closest white node so far in the tree\n    // notice that whenever we add a chain to the tree, we increase our white node of (new_l + tree_l - 2)\n    // we sort the chains by length decreasingly and find first distance such that number of nodes with distance\n    // smaller than d is greater than k.\n    String[] input = br.readLine().split("" "");\n    int n = Integer.parseInt(input[0]);\n    int k = Integer.parseInt(input[1]);\n    input = br.readLine().split("" "");\n    int[] l = new int[n];\n    for (int i=0; i<n; i++) {\n      l[i] = Integer.parseInt(input[i]);\n    }\n    Arrays.sort(l);\n    reverseArray(l);\n\n    // keep track of number of white nodes for each given distance to the root\n    // the following array f[i] records the dynamics of changes of iteration\n    // and the prefix sum of f[0:i] is the total number of white nodes have distance\n    // smaller or equal than i\n    int[] f = new int[MAXN + 5];\n    f[0] = 1; // initially, root has distance 0;\n    f[1] = -1; // f[0:j] = 0 for j >= 1\n    int res = Integer.MAX_VALUE;\n    int sum = 0;\n    // \n    for (int d=0, i=0; d<MAXN; d++) {\n      sum += f[d]; // total number of white nodes with distance smaller of equal than d\n      f[d+1] += f[d]; // total number of white nodes with distance d+1\n      // if with adding nodes with distance d+1, we get total count greater than k, we update our result\n      if (sum + f[d+1] >= k) {\n        res = Math.min(res, d+1);\n      }\n      // repeatedly add chain to current tree, if we have available chains (i < n) and the current node is white (i.e. f[d] > 0)\n      while (f[d] > 0 && i < n) {\n        int u = ((l[i]-1) >> 1); // left sub-chain\n        int v = l[i]-1-u; // right sub-chain\n        // left sub-chain contributes to adding nodes with distance of (d+2, d+3, ..., d+u+2)\n        f[d+2]++;\n        f[d+2+u]--;\n        // right sub-chain contributes to adding nodes with distance of (d+2, d+3, ..., d+v+2)\n        f[d+2]++;\n        f[d+2+v]--;\n        // the closest white node of distance becomes black\n        f[d]--;\n        sum--;\n        // next chain\n        i++;\n      }\n    }\n    if (res == Integer.MAX_VALUE) {\n      System.out.println(""-1"");\n    } else {\n      System.out.println(res);\n    }\n  }\n  public static void reverseArray(int[] arr) {\n    int n = arr.length;\n    int i=0, j=n-1;\n    int tmp;\n    while (i < j) {\n      tmp = arr[i]; \n      arr[i] = arr[j];\n      arr[j] = tmp;\n      i++;\n      j--;\n    }\n    return;\n  }\n  public static void main(String[] args) throws IOException {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    solve(br);\n  }\n}\n","binary search,data structures,greedy"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringTokenizer;\nimport java.util.Scanner;\npublic class F {\n\n	public static void main(String[] args) {\n		//FastScanner fs=new FastScanner();\n		Scanner fs = new Scanner(System.in);\n		int n=fs.nextInt();\n		long k=fs.nextLong();\n		//int[] a=fs.readArray(n);\n		int[] a = new int[n];\n		for(int i=0;i<n;i++) a[i] = fs.nextInt();\n		ruffleSort(a);\n		a=reverse(a);\n		int best=-1;\n		SegTree st=new SegTree(0, 500_000);\n		best=check(best, st, k);\n//		System.out.println(""Adding to 0"");\n		st.rangeAdd(0, 0, 1);\n		for (int i:a) {\n//			System.out.println(""Querying mindex"");\n			int mindex=st.minNonzeroIndex();\n			st.rangeAdd(mindex, mindex, -1);\n			int lTail=i/2;\n			int rTail=i-lTail-1;\n			int minHeight=mindex+2;\n			st.rangeAdd(minHeight, minHeight+lTail-1, 1);\n			st.rangeAdd(minHeight, minHeight+rTail-1, 1);\n			best=check(best, st, k);\n		}\n		System.out.println(best);\n	}\n	\n	static int check(int best, SegTree st, long k) {\n		long rangeSum=st.rangeSum();\n//		System.out.println(""Sum: ""+rangeSum);\n		if (rangeSum<k) return best;\n//		System.out.println(""Can get something: "");\n		int first=st.whenDoesPrefSumHitX(k);\n		if (best==-1) return first;\n		return Math.min(best, first);\n	}\n	\n	static class SegTree {\n		int leftmost, rightmost;\n		long toProp;\n		long rangeSum;\n		SegTree lChild, rChild;\n		\n		public SegTree(int leftmost, int rightmost) {\n			this.leftmost=leftmost;\n			this.rightmost=rightmost;\n			if (leftmost!=rightmost) {\n				int mid=(leftmost+rightmost)/2;\n				lChild=new SegTree(leftmost, mid);\n				rChild=new SegTree(mid+1, rightmost);\n			}\n		}\n		\n		public void recalc() {\n			if (leftmost==rightmost) return;\n			rangeSum=lChild.rangeSum()+rChild.rangeSum();\n		}\n		\n		public long rangeSum() {\n			return rangeSum+toProp*(rightmost-leftmost+1);\n		}\n		\n		public void prop() {\n			if (leftmost==rightmost) {\n				rangeSum+=toProp;\n			}\n			else {\n				lChild.toProp+=toProp;\n				rChild.toProp+=toProp;\n			}\n			toProp=0;\n			recalc();\n		}\n		\n		public void rangeAdd(int l, int r, long dx) {\n			prop();\n			if (l<=leftmost && r>=rightmost) {\n				toProp+=dx;\n				return;\n			}\n			if (l>rightmost || r<leftmost) {\n				return;\n			}\n			lChild.rangeAdd(l, r, dx);\n			rChild.rangeAdd(l, r, dx);\n			recalc();\n		}\n		\n		public int minNonzeroIndex() {\n			prop();\n			if (rangeSum()==0) throw null;\n			if (leftmost==rightmost) return leftmost;\n			\n			if (lChild.rangeSum()!=0) return lChild.minNonzeroIndex();\n			return rChild.minNonzeroIndex();\n		}\n		\n		public int whenDoesPrefSumHitX(long x) {\n			prop();\n			if (rangeSum()<x) return -1;\n			\n			if (leftmost==rightmost) {\n				return leftmost;\n			}\n			if (lChild.rangeSum()>=x) {\n				return lChild.whenDoesPrefSumHitX(x);\n			}\n			x-=lChild.rangeSum();\n			return rChild.whenDoesPrefSumHitX(x);\n		}\n	}\n\n	static final Random random=new Random();\n	\n	static void ruffleSort(int[] a) {\n		int n=a.length;//shuffle, then sort \n		for (int i=0; i<n; i++) {\n			int oi=random.nextInt(n), temp=a[oi];\n			a[oi]=a[i]; a[i]=temp;\n		}\n		Arrays.sort(a);\n	}\n	\n	static class FastScanner {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n		String next() {\n			while (!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		int[] readArray(int n) {\n			int[] a=new int[n];\n			for (int i=0; i<n; i++) a[i]=nextInt();\n			return a;\n		}\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n	}\n\n	static int[] reverse(int[] a) {\n		int n=a.length;\n		int[] res=new int[n];\n		for (int i=0; i<n; i++) res[i]=a[n-1-i];\n		return res;\n	}\n}\n","binary search,data structures,greedy"
"//https://github.com/EgorKulikov/yaal/tree/master/lib/main/net/egork\n        \nimport java.util.*;\nimport java.io.*;\npublic class A{\n    static PrintWriter out;\n    static InputReader in;\n    public static void main(String args[]){\n        out = new PrintWriter(System.out);\n        in = new InputReader();\n        new A();\n        out.flush(); out.close();\n    }   \n    A(){\n        solve();\n    }\n    class point{\n    	double x, y;\n    	point(double a, double b){\n    		x = a; y = b;\n    	}\n    }\n\n    final int max = 200010;\n    int n, H;\n    point point[] = new point[max];\n    double ex, ey;\n    double find(double x, double y){\n    	return Math.sqrt(x * x + y * y);\n    }\n    double cross(point p1, point p2){\n    	return p1.x * p2.y - p2.x * p1.y;\n    }\n    double cross(int id1, int id2){\n    	return cross(new point(point[id1].x - ex, point[id1].y - ey), new point(point[id2].x - ex, point[id2].y - ey));\n    }\n    point intersect(point p1, point p2, point p){\n    	if(p2.x == p.x && p2.y == p.y)return p2;\n    	point AB = new point(p2.x - p1.x, p2.y - p1.y), CD = new point(p.x - ex, p.y - ey);\n    	double i = cross(new point(p.x - p1.x, p.y - p1.y), CD) / cross(AB, CD);\n    	if(i >= 0 && i <= 1)return new point(p1.x + i * AB.x, p1.y + i * AB.y);\n    	return null;\n    }\n    void solve(){\n    	n = in.nextInt(); H = in.nextInt();\n    	for(int i = 1; i <= n; i++){\n    		point[i] = new point(in.nextInt(), in.nextInt());\n    	}\n    	ex = point[n].x; ey = point[n].y + H;\n    	int id = n; \n    	double tot = 0;\n    	for(int i = n - 1; i >= 1; i--){\n    		if(cross(i, id) >= 0){\n	    		point p = intersect(point[i], point[i + 1], point[id]);\n	    		if(p != null){\n					tot += find(point[i].x - p.x, point[i].y - p.y);\n	    		}\n    			id = i;\n    		}\n    	}\n    	out.print(tot);\n    }\n    public static class InputReader{\n        BufferedReader br;\n        StringTokenizer st;\n        InputReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public long nextLong(){\n            return Long.parseLong(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n        public String next(){\n            while(st == null || !st.hasMoreTokens()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch(IOException e){}\n            }\n            return st.nextToken();\n        }\n    }\n}\n	","binary search,geometry"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Sparsh Sanchorawala\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        GHobbits solver = new GHobbits();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class GHobbits {\n        public void solve(int testNumber, InputReader s, PrintWriter w) {\n            int n = s.nextInt(), h = s.nextInt();\n            long[] x = new long[n];\n            long[] y = new long[n];\n            for (int i = 0; i < n; i++) {\n                x[i] = s.nextInt();\n                y[i] = s.nextInt();\n            }\n            double res = 0;\n            long my = h, mx = 0;\n            boolean up = false;\n            for (int i = n - 2; i >= 0; i--) {\n                boolean cond = false;\n                long m2y = y[n - 1] + h - y[i], m2x = x[n - 1] - x[i];\n                long d = m2x * Math.abs(my) - Math.abs(m2y) * mx;\n                //w.println((i + 1) + "": "" + (double)mx / my + "" "" + (double)m2x / m2y);\n                //w.println(up);\n                if (d == 0) {\n                    long m3y = y[i] - y[i + 1];\n                    long m3x = x[i] - x[i + 1];\n                    if (m3x * m2y - m3y * m2x == 0) {\n                        //w.println(i + "" // dist: "" + sqrt((x[i] - x[i + 1]) * (x[i] - x[i + 1]) + (y[i] - y[i +  1]) * (y[i] - y[i +  1])));\n                        res += Math.sqrt((x[i] - x[i + 1]) * (x[i] - x[i + 1]) + (y[i] - y[i + 1]) * (y[i] - y[i + 1]));\n                    }\n                    continue;\n                }\n                if (m2y < 0 && !up) {\n                    up = true;\n                    cond = true;\n                } else if (up && d < 0 && m2y < 0) {\n                    cond = true;\n                } else if (!up && d > 0) {\n                    cond = true;\n                }\n                if (cond) {\n                    //w.println((i + 1) + "" // "" + up);\n                    //w.println(mx + "" "" + my + "" slope"");\n                    if (i != n - 2) {\n                        double k1 = y[n - 1] + h - (double) x[n - 1] * my / mx - y[i + 1] + (double) x[i + 1] * (y[i] - y[i + 1]) / (x[i] - x[i + 1]);\n                        double k2 = (double) (y[i] - y[i + 1]) / (x[i] - x[i + 1]) - (double) my / mx;\n                        double vx = k1 / k2;\n                        double vy = (mx * (y[n - 1] + h) - x[n - 1] * my + vx * my) / mx;\n                        //w.println(vx + "" "" + vy);\n                        res += Math.sqrt((x[i] - vx) * (x[i] - vx) + (y[i] - vy) * (y[i] - vy));\n                        //w.println(""dist: "" + sqrt((x[i] - vx) * (x[i] - vx) + (y[i] - vy) * (y[i] - vy)));\n                    } else {\n                        //w.println(x[i] + "" "" + y[i] + "", "" + x[i + 1] + "" "" + y[i + 1]);\n                        //w.println(abs(x[i] - x[i + 1]) + "" ::"" + abs(y[i] - y[i + 1]));\n                        //w.println(sqrt((x[i] - x[i + 1]) * (x[i] - x[i + 1]) + (y[i] - y[i + 1]) * (y[i] - y[i + 1])));\n                        res += Math.sqrt((x[i] - x[i + 1]) * (x[i] - x[i + 1]) + (y[i] - y[i + 1]) * (y[i] - y[i + 1]));\n                        //w.println(""dist: "" + sqrt((x[i] - x[i + 1]) * (x[i] - x[i + 1]) + (y[i] - y[i + 1]) * (y[i] - y[i + 1])));\n                    }\n                    my = m2y;\n                    mx = m2x;\n                }\n            }\n            w.println(res);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n","binary search,geometry"
"import java.util.*;\nimport java.io.*;\n\npublic class codeforces {\n	public static Point test(Line a,LineSegment b) {\n		Line B=new Line(b.p, b.q);\n		Point lol=B.intersect(a);\n		if(lol==null) {\n			if(b.q.onLine(a.p,a.q)) {\n				return b.q;\n			}\n			return null;\n		}\n		if(lol.onSegment(b.p,b.q ))return lol;\n		return lol;\n	}\n	\n	public static void main(String[] args) throws Exception {\n\n		int n=sc.nextInt();\n		double h=sc.nextDouble()/1000;\n		LineSegment[]a=new LineSegment[n-1];\n		Point f=new Point(sc.nextDouble()/1000, sc.nextDouble()/1000);\n		for(int i=0;i<n-1;i++) {\n			Point s=new Point(sc.nextDouble()/1000, sc.nextDouble()/1000);\n			a[i]=new LineSegment(f, s);\n			f=s;\n		}\n		Point eye=new Point(a[n-2].q.x, a[n-2].q.y+h);\n		Line cur=new Line(eye,a[n-2].q );\n		double ans=0;\n		for(int i=n-2;i>-1;i--) {\n			Point where=test(cur, a[i]);\n//			pw.println(where+"" ""+a[i].q);\n			if(where==null)continue;\n			if(where.equals(a[i].q)) {\n				Vector ttt=new Vector(-eye.x+a[i].q.x, -eye.y+a[i].q.y);\n				Vector ttt2=new Vector(a[i].q.x-a[i].p.x, a[i].q.y-a[i].p.y);\n//				pw.println(""# ""+ttt.cross(ttt2));\n				if(ttt.cross(ttt2)>=-0.0000001) {\n					ans+=a[i].p.dist(a[i].q);\n					cur=new Line(eye,a[i].p );\n				}\n			}else if(where.x<=a[i].q.x+0.000000001&&where.x>=a[i].p.x-0.000000001) {\n//				pw.println(""*"");\n				ans+=a[i].p.dist(where);\n				cur=new Line(eye,a[i].p );\n			}\n		}\n		pw.println(ans*1000);\n		\n		pw.close();\n	}\n\n	public static class Vector {\n\n		double x, y; \n\n		Vector(double a, double b) { x = a; y = b; }\n\n		Vector(Point a, Point b) { this(b.x - a.x, b.y - a.y); }\n\n		Vector scale(double s) { return new Vector(x * s, y * s); }              //s is a non-negative value\n\n		double dot(Vector v) { return (x * v.x + y * v.y); }\n\n		double cross(Vector v) { return x * v.y - y * v.x; }\n\n		double norm2() { return x * x + y * y; }\n\n		Vector reverse() { return new Vector(-x, -y); }\n\n		Vector normalize() \n		{ \n			double d = Math.sqrt(norm2());\n			return scale(1 / d);\n		}		\n	}\n	public static class Point implements Comparable<Point>{\n\n		static final double EPS = 1e-9;\n\n		double x, y;                  \n\n		boolean equals(Point p) {\n			return Math.abs(this.x-p.x)+Math.abs(this.y-p.y)<0.0000001;\n		}\n		public String toString() {\n			return ""( ""+x+"" , ""+y+"" )"";\n		}\n		Point(double a, double b) { x = a; y = b; }  \n		\n		public int compareTo(Point p)\n		{\n			if(Math.abs(x - p.x) > EPS) return x > p.x ? 1 : -1;\n			if(Math.abs(y - p.y) > EPS) return y > p.y ? 1 : -1;\n			return 0;\n		}\n		\n		public double dist(Point p) { return Math.sqrt(sq(x - p.x) + sq(y - p.y)); }\n		\n		static double sq(double x) { return x * x; }\n		\n		Point rotate(double angle)\n		{\n			double c = Math.cos(angle), s = Math.sin(angle);\n			return new Point(x * c - y * s, x * s + y * c);\n		}\n		// for integer points and rotation by 90 (counterclockwise) : swap x and y, negate x\n		\n		Point rotate(double theta, Point p)			//rotate around p\n		{\n			Vector v = new Vector(p, new Point(0, 0));\n			return translate(v).rotate(theta).translate(v.reverse());\n		}\n		\n		Point translate(Vector v) { return new Point(x + v.x , y + v.y); }\n		\n		Point reflectionPoint(Line l) 	//reflection point of p on line l\n		{\n			Point p = l.closestPoint(this);\n			Vector v = new Vector(this, p);\n			return this.translate(v).translate(v);\n		}\n		\n		boolean between(Point p, Point q)\n		{\n			return x < Math.max(p.x, q.x) + EPS && x + EPS > Math.min(p.x, q.x)\n					&& y < Math.max(p.y, q.y) + EPS && y + EPS > Math.min(p.y, q.y);\n		}\n		\n		//returns true if it is on the line defined by a and b\n		boolean onLine(Point a, Point b) \n		{\n			if(a.compareTo(b) == 0) return compareTo(a) == 0;\n			return Math.abs(new Vector(a, b).cross(new Vector(a, this))) < EPS;\n		}\n		\n		boolean onSegment(Point a, Point b)\n		{\n			if(a.compareTo(b) == 0) return compareTo(a) == 0;\n			return onRay(a, b) && onRay(b, a);\n		}\n		\n		//returns true if it is on the ray whose start point is a and passes through b\n		boolean onRay(Point a, Point b)\n		{\n			if(a.compareTo(b) == 0) return compareTo(a) == 0;\n			return new Vector(a, b).normalize().equals(new Vector(a, this).normalize());	//implement equals()\n		}\n		\n		// returns true if it is on the left side of Line pq\n		// add EPS to LHS if on-line points are accepted\n		static boolean ccw(Point p, Point q, Point r)\n		{\n			return new Vector(p, q).cross(new Vector(p, r)) > 0;\n		}\n		\n		static boolean collinear(Point p, Point q, Point r)\n		{\n			return Math.abs(new Vector(p, q).cross(new Vector(p, r))) < EPS;\n		}\n		\n		static double angle(Point a, Point o, Point b)  // angle AOB\n		{\n			Vector oa = new Vector(o, a), ob = new Vector(o, b);\n			return Math.acos(oa.dot(ob) / Math.sqrt(oa.norm2() * ob.norm2()));\n		}\n		\n		static double distToLine(Point p, Point a, Point b) //distance between point p and a line defined by points a, b (a != b)\n		{\n			if(a.compareTo(b) == 0) return p.dist(a);\n			// formula: c = a + u * ab\n			Vector ap = new Vector(a, p), ab = new Vector(a, b);\n			double u = ap.dot(ab) / ab.norm2();\n			Point c = a.translate(ab.scale(u)); \n			return p.dist(c);\n		}\n		// Another way: find closest point and calculate the distance between it and p\n\n		static double distToLineSegment(Point p, Point a, Point b) \n		{\n			Vector ap = new Vector(a, p), ab = new Vector(a, b);\n			double u = ap.dot(ab) / ab.norm2();\n			if (u < 0.0) return p.dist(a);\n			if (u > 1.0) return p.dist(b);        \n			return distToLine(p, a, b); \n		}\n		// Another way: find closest point and calculate the distance between it and p\n	}\n	public static class Line {\n\n		static final double INF = 1e9, EPS = 1e-9;\n		\n		double a, b, c;\n		Point p,q;\n		Line(Point p, Point q)\n		{\n			this.p=p;\n			this.q=q;\n			if(Math.abs(p.x - q.x) < EPS) {	a = 1; b = 0; c = -p.x;	}\n			else\n			{\n				a = (p.y - q.y) / (q.x - p.x);\n				b = 1.0;\n				c = -(a * p.x + p.y);\n			}\n						\n		}\n		\n		Line(Point p, double m) { a = -m; b = 1; c =  -(a * p.x + p.y); } \n		\n		boolean parallel(Line l) { return Math.abs(a - l.a) < EPS && Math.abs(b - l.b) < EPS; }\n		\n		boolean same(Line l) { return parallel(l) && Math.abs(c - l.c) < EPS; }\n		\n		Point intersect(Line l)\n		{\n			if(parallel(l))\n				return null;\n			double x = (b * l.c - c * l.b) / (a * l.b - b * l.a);\n			double y;\n			if(Math.abs(b) < EPS)\n				 y = -l.a * x - l.c;\n			else\n				y = -a * x - c;\n			\n			return new Point(x, y);\n		}\n		\n		Point closestPoint(Point p)\n		{\n			if(Math.abs(b) < EPS) return new Point(-c, p.y);\n			if(Math.abs(a) < EPS) return new Point(p.x, -c);\n			return intersect(new Line(p, 1 / a));\n		}\n				\n	}\n\n	public static class LineSegment {\n\n		Point p, q;\n		\n		LineSegment(Point a, Point b) { p = a; q = b; }\n		\n\n		boolean intersect(LineSegment ls)\n		{\n			Line l1 = new Line(p, q), l2 = new Line(ls.p, ls.q);\n			if(l1.parallel(l2))\n			{\n				if(l1.same(l2))\n					return p.between(ls.p, ls.q) || q.between(ls.p, ls.q) || ls.p.between(p, q) || ls.q.between(p, q);\n				return false;\n			}\n			Point c = l1.intersect(l2);\n			return c.between(p, q) && c.between(ls.p, ls.q);\n		}\n\n	}\n	static class Scanner {\n		StringTokenizer st;\n		BufferedReader br;\n\n		public Scanner(InputStream s) {\n			br = new BufferedReader(new InputStreamReader(s));\n		}\n\n		public Scanner(FileReader r) {\n			br = new BufferedReader(r);\n		}\n\n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		public double nextDouble() throws IOException {\n			String x = next();\n			StringBuilder sb = new StringBuilder(""0"");\n			double res = 0, f = 1;\n			boolean dec = false, neg = false;\n			int start = 0;\n			if (x.charAt(0) == '-') {\n				neg = true;\n				start++;\n			}\n			for (int i = start; i < x.length(); i++)\n				if (x.charAt(i) == '.') {\n					res = Long.parseLong(sb.toString());\n					sb = new StringBuilder(""0"");\n					dec = true;\n				} else {\n					sb.append(x.charAt(i));\n					if (dec)\n						f *= 10;\n				}\n			res += Long.parseLong(sb.toString()) / f;\n			return res * (neg ? -1 : 1);\n		}\n\n		public long[] nextlongArray(int n) throws IOException {\n			long[] a = new long[n];\n			for (int i = 0; i < n; i++)\n				a[i] = nextLong();\n			return a;\n		}\n\n		public Long[] nextLongArray(int n) throws IOException {\n			Long[] a = new Long[n];\n			for (int i = 0; i < n; i++)\n				a[i] = nextLong();\n			return a;\n		}\n\n		public int[] nextIntArray(int n) throws IOException {\n			int[] a = new int[n];\n			for (int i = 0; i < n; i++)\n				a[i] = nextInt();\n			return a;\n		}\n\n		public Integer[] nextIntegerArray(int n) throws IOException {\n			Integer[] a = new Integer[n];\n			for (int i = 0; i < n; i++)\n				a[i] = nextInt();\n			return a;\n		}\n\n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n\n	}\n\n	static class pair implements Comparable<pair> {\n		long x;\n		long y;\n\n		public pair(long x, long y) {\n			this.x = x;\n			this.y = y;\n		}\n\n		public String toString() {\n			return x + "" "" + y;\n		}\n\n		public boolean equals(Object o) {\n			if (o instanceof pair) {\n				pair p = (pair) o;\n				return p.x == x && p.y == y;\n			}\n			return false;\n		}\n\n		public int hashCode() {\n			return new Double(x).hashCode() * 31 + new Double(y).hashCode();\n		}\n\n		public int compareTo(pair other) {\n			if (this.x == other.x) {\n				return Long.compare(this.y, other.y);\n			}\n			return Long.compare(this.x, other.x);\n		}\n	}\n\n	static class tuble implements Comparable<tuble> {\n		int x;\n		int y;\n		int z;\n\n		public tuble(int x, int y, int z) {\n			this.x = x;\n			this.y = y;\n			this.z = z;\n		}\n\n		public String toString() {\n			return x + "" "" + y + "" "" + z;\n		}\n\n		public int compareTo(tuble other) {\n			if (this.x == other.x) {\n				if (this.y == other.y) {\n					return this.z - other.z;\n				}\n				return this.y - other.y;\n			} else {\n				return this.x - other.x;\n			}\n		}\n	}\n\n	static long mod = 1000000007;\n	static Random rn = new Random();\n	static Scanner sc = new Scanner(System.in);\n	static PrintWriter pw = new PrintWriter(System.out);\n}","binary search,geometry"
"import java.util.*;\nimport java.util.Map.Entry;\n\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class C {\n	FastScanner in;\n	PrintWriter out;\n	boolean systemIO = true;\n\n	public static void quickSort(int[] a, int from, int to) {\n		if (to - from <= 1) {\n			return;\n		}\n		int i = from;\n		int j = to - 1;\n		int x = a[from + (new Random()).nextInt(to - from)];\n		while (i <= j) {\n			while (a[i] < x) {\n				i++;\n			}\n			while (a[j] > x) {\n				j--;\n			}\n			if (i <= j) {\n				int t = a[i];\n				a[i] = a[j];\n				a[j] = t;\n				i++;\n				j--;\n			}\n		}\n		quickSort(a, from, j + 1);\n		quickSort(a, j + 1, to);\n	}\n\n	public long gcd(long x, long y) {\n		if (y == 0) {\n			return x;\n		}\n		if (x == 0) {\n			return y;\n		}\n		return gcd(y, x % y);\n	}\n\n	public boolean prime(long x) {\n		for (int i = 2; i * i <= x; i++) {\n			if (x % i == 0) {\n				return false;\n			}\n		}\n		return true;\n	}\n\n	public long pow(long x, long p) {\n		if (p == 0) {\n			return 1;\n		}\n		long t = pow(x, p / 2);\n		t *= t;\n		t %= mod;\n		if (p % 2 == 1) {\n			t *= x;\n			t %= mod;\n		}\n		return t;\n	}\n\n	public class Pair implements Comparable<Pair> {\n		int x;\n		int y;\n\n		public Pair(int x, int y) {\n			this.x = x;\n			this.y = y;\n		}\n\n		@Override\n		public int compareTo(Pair o) {\n			if (x > o.x) {\n				return 1;\n			}\n			if (x < o.x) {\n				return -1;\n			}\n			if (y > o.y) {\n				return 1;\n			}\n			if (y < o.y) {\n				return -1;\n			}\n			return 0;\n		}\n	}\n\n	long mod = 1000000007;\n\n	public class Fenvik2D {\n		long[][] t;\n		int n, m;\n\n		public Fenvik2D(int n, int m) {\n			t = new long[n][m];\n			this.n = n;\n			this.m = m;\n		}\n\n		public int sum(int x1, int y1, int x2, int y2) {\n			return sum(x2, y2) - sum(x1 - 1, y2) - sum(x2, y1 - 1) + sum(x1 - 1, y1 - 1);\n		}\n\n		public int sum(int x, int y) {\n			int result = 0;\n			for (int i = x; i >= 0; i = (i & (i + 1)) - 1) {\n				for (int j = y; j >= 0; j = (j & (j + 1)) - 1) {\n					result += t[i][j];\n				}\n			}\n			return result;\n		}\n\n		public void add(int x, int y, int delta) {\n			for (int i = x; i < n; i = (i | (i + 1))) {\n				for (int j = y; j < m; j = (j | (j + 1))) {\n					t[i][j] += delta;\n				}\n			}\n		}\n	}\n\n	public int[] prefF(int[] a) {\n		int[] p = new int[a.length];\n		for (int i = 1; i < p.length; i++) {\n			int j = p[i - 1];\n			while (j > 0) {\n				if (a[j] == a[i]) {\n					break;\n				}\n				if (j == 0) {\n					break;\n				}\n				j = p[j - 1];\n			}\n			if (a[i] == a[j]) {\n				p[i] = j + 1;\n			}\n		}\n		return p;\n	}\n\n	public class Request implements Comparable<Request> {\n		int x;\n		int y;\n		int number;\n\n		public Request(int x, int y, int number) {\n			this.x = x;\n			this.y = y;\n			this.number = number;\n		}\n\n		@Override\n		public int compareTo(Request o) {\n			return y - o.y;\n		}\n	}\n\n	public class SegmentTree {\n		int[] max;\n		int[] delta;\n		int pow;\n\n		public SegmentTree(int size) {\n			pow = 1;\n			while (pow < size) {\n				pow *= 2;\n			}\n			max = new int[2 * pow];\n			delta = new int[2 * pow];\n		}\n\n		public void push(int v, int tl, int tr) {\n			if (delta[v] == 0) {\n				return;\n			}\n			max[v] += delta[v];\n			if (v < pow) {\n				delta[2 * v] += delta[v];\n				delta[2 * v + 1] += delta[v];\n			}\n			delta[v] = 0;\n		}\n\n		public int get(int x) {\n			return get(x, x + 1);\n		}\n\n		public int get(int l, int r) {\n			return get(1, 0, pow, l, r);\n		}\n\n		private int get(int v, int tl, int tr, int l, int r) {\n			push(v, tl, tr);\n			if (tl >= r || tr <= l) {\n				return 0;\n			}\n			if (tl >= l && tr <= r) {\n				return max[v];\n			}\n			int tm = (tl + tr) / 2;\n			return Math.max(get(2 * v, tl, tm, l, r), get(2 * v + 1, tm, tr, l, r));\n		}\n\n		public void add(int l, int r, int x) {\n			add(1, 0, pow, l, r, x);\n		}\n\n		private void add(int v, int tl, int tr, int l, int r, int x) {\n			push(v, tl, tr);\n			if (tl >= r || tr <= l) {\n				return;\n			}\n			if (tl >= l && tr <= r) {\n				delta[v] += x;\n				push(v, tl, tr);\n				return;\n			}\n			int tm = (tl + tr) / 2;\n			add(2 * v, tl, tm, l, r, x);\n			add(2 * v + 1, tm, tr, l, r, x);\n			max[v] = Math.max(max[2 * v], max[2 * v + 1]);\n		}\n\n		public int lastMax(int x) {\n			return lastMax(1, 0, pow, x);\n		}\n\n		private int lastMax(int v, int tl, int tr, int x) {\n			push(v, tl, tr);\n			if (max[v] < x) {\n				return -1;\n			}\n			if (v >= pow) {\n				return tl;\n			}\n			int tm = (tl + tr) / 2;\n			push(2 * v + 1, tm, tr);\n			if (max[2 * v + 1] >= x) {\n				return lastMax(2 * v + 1, tm, tr, x);\n			}\n			return lastMax(2 * v, tl, tm, x);\n		}\n	}\n\n	Random random = new Random(566);\n\n	int module = 1000000007;\n\n	public int sum(int x, int y) {\n		if (x + y >= module) {\n			return x + y - module;\n		}\n		return x + y;\n	}\n\n	public long calc(long a, long b, long c, long d, long n) {\n		long cd = c / d;\n		if (n <= cd) {\n			return (n + 1) * a - n * (n + 1) / 2 * d * b;\n		}\n		return (n + 1) * a - n * c * b + cd * c * b + cd * (cd + 1) / 2 * d * b;\n	}\n\n	public class Vector implements Comparable<Vector> {\n		long x;\n		long y;\n\n		public Vector(long x, long y) {\n			this.x = x;\n			this.y = y;\n		}\n\n		public Vector(Point begin, Point end) {\n			this(end.x - begin.x, end.y - begin.y);\n		}\n		\n		public Vector clone() {\n			return new Vector(x, y);\n		}\n		\n		public double len() {\n			return Math.sqrt(x * x + y * y);\n		}\n\n		public void norm() {\n			long gcd = gcd(x, Math.abs(y));\n			x /= gcd;\n			y /= gcd;\n		}\n\n		@Override\n		public int compareTo(Vector o) {\n			if (x > o.x) {\n				return 1;\n			}\n			if (x < o.x) {\n				return -1;\n			}\n			if (y > o.y) {\n				return 1;\n			}\n			if (y < o.y) {\n				return -1;\n			}\n			return 0;\n		}\n	}\n	\n	public long dp(Vector a, Vector b) {\n		return a.x * b.x + a.y * b.y;\n	}\n	\n	public long cp(Vector a, Vector b) {\n		return a.x * b.y - a.y * b.x;\n	}\n\n//	public class Line implements Comparable<Line> {\n//		long a;\n//		long b;\n//		long c;\n//		long vec2;\n//\n//		public Line(Pair p0, Pair p1) {\n//			Line0(p0, new Vector(p1.x - p0.x, p1.y - p0.y));\n//		}\n//\n//		public void Line0(Pair p0, Vector vec) {\n//			vec2 = vec.x * vec.x + vec.y * vec.y;\n//			vec.norm();\n//			a = vec.y;\n//			b = -vec.x;\n//			c = -a * p0.x - b * p0.y;\n//		}\n//\n//		@Override\n//		public int compareTo(Line o) {\n//			if (a > o.a) {\n//				return 1;\n//			}\n//			if (a < o.a) {\n//				return -1;\n//			}\n//			if (b > o.b) {\n//				return 1;\n//			}\n//			if (b < o.b) {\n//				return -1;\n//			}\n//			if (vec2 > o.vec2) {\n//				return 1;\n//			}\n//			if (vec2 < o.vec2) {\n//				return -1;\n//			}\n//			if (c > o.c) {\n//				return 1;\n//			}\n//			if (c < o.c) {\n//				return -1;\n//			}\n//			return 0;\n//		}\n//\n//	}\n\n	public boolean can(int a, int x, int b, int y) {\n		if (x + y == 0) {\n			return false;\n		}\n		if (a < b && y > 0) {\n			return true;\n		}\n		if (a + 1 < b) {\n			return true;\n		}\n		if (a + 1 == b) {\n			if (a == 1) {\n				return true;\n			}\n			return false;\n		}\n		// a == b && (x > 0 || y > 0)\n		if (a == 1) {\n			return true;\n		}\n		if (y == 0) {\n			return false;\n		}\n		if (a == 2) {\n			return true;\n		}\n		if (x > 0 && y > 0) {\n			return true;\n		}\n		return false;\n	}\n\n	public class Point implements Comparable<Point> {\n		long x;\n		long y;\n\n		public Point() {\n			x = 0;\n			y = 0;\n		}\n\n		public Point(long x, long y) {\n			this.x = x;\n			this.y = y;\n		}\n\n		public String toString() {\n			return x + "" "" + y;\n		}\n\n		public boolean equals(Point p) {\n			return x == p.x && y == p.y;\n		}\n\n		public long dist2() {\n			return x * x + y * y;\n		}\n\n		public double dist() {\n			return Math.hypot(x, y);\n		}\n\n		public Point add(Point v) {\n			return new Point(x + v.x, y + v.y);\n		}\n\n		public Point subtract(Point v) {\n			return new Point(x - v.x, y - v.y);\n		}\n\n		@Override\n		public int compareTo(Point o) {\n			if (x > o.x) {\n				return 1;\n			}\n			if (x < o.x) {\n				return -1;\n			}\n			if (y > o.y) {\n				return 1;\n			}\n			if (y < o.y) {\n				return -1;\n			}\n			return 0;\n		}\n	}\n\n	public class Circle {\n		Point p;\n		long r;\n\n		public Circle(Point p, long r) {\n			this.p = p;\n			this.r = r;\n		}\n\n		public boolean intersect(Line l, int sign) {\n			return Math.abs(l.a * p.x + l.b * p.y + l.c) / Math.hypot(l.a, l.b) < r + sign * 1e-9;\n		}\n	}\n\n	public class Line {\n		long a;\n		long b;\n		long c;\n\n		public Line(long a, long b, long c) {\n			this.a = a;\n			this.b = b;\n			this.c = c;\n		}\n\n		public Line(Point a, Point b) {\n			this.a = a.y - b.y;\n			this.b = b.x - a.x;\n			this.c = a.x * b.y - a.y * b.x;\n		}\n\n		public long value(Point p) {\n			return a * p.x + b * p.y + c;\n		}\n	}\n\n	public void solve() {\n		int n = in.nextInt();\n		int h = in.nextInt();\n		Point[] p = new Point[n];\n		for (int i = 0; i < p.length; i++) {\n			p[i] = new Point(in.nextLong(), in.nextLong());\n		}\n		double ans = 0;\n		Point end = new Point(p[n - 1].x, p[n - 1].y + h);\n		Vector v = new Vector(p[n - 1], end);\n		for (int i = n - 2; i >= 0; i--) {\n			Vector v1 = new Vector(p[i], end);\n			if (cp(v1, v) >= 0) {\n				Vector v2 = new Vector(p[i], p[i + 1]);\n				if (cp(new Vector(p[i + 1], end), v) >= 0) {\n					ans += v2.len();\n					v = v1;\n					continue;\n				}\n				ans += cp(v1, v) * v2.len() / cp(v2, v);\n				v = v1;\n			}\n			\n		}\n		out.print(ans);\n	}\n\n	public void run() {\n		try {\n			if (systemIO) {\n				in = new FastScanner(System.in);\n				out = new PrintWriter(System.out);\n			} else {\n				in = new FastScanner(new File(""input.txt""));\n				out = new PrintWriter(new File(""output.txt""));\n			}\n			solve();\n\n			out.close();\n		} catch (IOException e) {\n			e.printStackTrace();\n		}\n	}\n\n	class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		FastScanner(File f) {\n			try {\n				br = new BufferedReader(new FileReader(f));\n			} catch (FileNotFoundException e) {\n				e.printStackTrace();\n			}\n		}\n\n		FastScanner(InputStream f) {\n			br = new BufferedReader(new InputStreamReader(f));\n		}\n\n		String nextLine() {\n			try {\n				return br.readLine();\n			} catch (IOException e) {\n				return null;\n			}\n		}\n\n		String next() {\n			while (st == null || !st.hasMoreTokens()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			}\n			return st.nextToken();\n		}\n\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n\n	}\n\n	// AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n	public static void main(String[] arg) {\n		new C().run();\n	}\n}","binary search,geometry"
import java.io.*;\nimport java.util.*;\n\npublic class CF1467D extends PrintWriter {\n	CF1467D() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1467D o = new CF1467D(); o.main(); o.flush();\n	}\n\n	static final int MD = 1000000007;\n	void main() {\n		int n = sc.nextInt();\n		int k = sc.nextInt();\n		int q = sc.nextInt();\n		int[][] dp = new int[k + 1][n + 2];\n		for (int i = 1; i <= n; i++)\n			dp[0][i] = 1;\n		for (int h = 1; h <= k; h++)\n			for (int i = 1; i <= n; i++)\n				dp[h][i] = (dp[h - 1][i - 1] + dp[h - 1][i + 1]) % MD;\n		int[] dq = new int[n + 2];\n		for (int i = 1; i <= n; i++) {\n			long sum = 0;\n			for (int h = 0; h <= k; h++)\n				sum = (sum + (long) dp[h][i] * dp[k - h][i]) % MD;\n			dq[i] = (int) sum;\n		}\n		int[] aa = new int[n + 1];\n		long ans = 0;\n		for (int i = 1; i <= n; i++) {\n			aa[i] = sc.nextInt();\n			ans = (ans + (long) dq[i] * aa[i]) % MD;\n		}\n		while (q-- > 0) {\n			int i = sc.nextInt();\n			int x = sc.nextInt();\n			ans = (ans + (long) dq[i] * (x - aa[i])) % MD;\n			if (ans < 0)\n				ans += MD;\n			println(ans);\n			aa[i] = x;\n		}\n	}\n}\n,"combinatorics,dp,math"
"//https://codeforces.com/contest/1467/problem/D\n//D. Sum of Paths\nimport java.util.*;\nimport java.io.*;\npublic class CF_1467_D{\n	public static void main(String[] args) throws Exception{\n		\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));\n		StringBuilder sb = new StringBuilder();\n		StringTokenizer st;\n		long mod = (int)1e9+7;\n\n		st = new StringTokenizer(br.readLine());\n		int n = Integer.parseInt(st.nextToken());\n		int k = Integer.parseInt(st.nextToken());\n		int q = Integer.parseInt(st.nextToken());\n\n		int a[] = new int[n];\n		st = new StringTokenizer(br.readLine());\n		for(int i=0;i<n;i++)\n			a[i] = Integer.parseInt(st.nextToken()); \n\n		int dp[][] = new int[n][k+1];\n		for(int i=0;i<n;i++)\n			dp[i][0] = 1;\n\n		for(int j=1;j<=k;j++)\n			for(int i=0;i<n;i++)\n			{\n			if(i>0)\n				dp[i][j] += dp[i-1][j-1]; \n			if(i<n-1)\n				dp[i][j] += dp[i+1][j-1];\n\n			dp[i][j] %= mod;\n			}\n\n		long cnt[] = new long[n];\n		for(int i=0;i<n;i++)\n			for(int j=0;j<=k;j++)\n				cnt[i] = (cnt[i] + 1L*dp[i][j]*dp[i][k-j])%mod;\n\n\n		long ans = 0;\n		for(int i=0;i<n;i++)\n			ans = (ans+cnt[i]*a[i])%mod;\n\n		while(q-->0){\n			st = new StringTokenizer(br.readLine());\n			int i = Integer.parseInt(st.nextToken())-1;\n			int x = Integer.parseInt(st.nextToken());\n\n			ans -= (a[i]*cnt[i])%mod;\n			ans += mod;\n			ans = (ans + x*cnt[i])%mod;\n			a[i] = x;\n\n			sb.append(ans).append(""\n"");\n		}\n\n		pw.print(sb);\n		pw.flush();\n		pw.close();\n	}\n}","combinatorics,dp,math"
import java.util.*;\nimport java.io.*;\npublic class R695D{\n	public static void main(String[] main) throws Exception{\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		PrintWriter out = new PrintWriter(System.out);\n		int mod = 1000000007;\n		int n = Integer.parseInt(st.nextToken());\n		int k = Integer.parseInt(st.nextToken())+1;\n		int q = Integer.parseInt(st.nextToken());\n		st = new StringTokenizer(br.readLine());\n		long[][] dp = new long[k+1][n];\n		for(int i = 0; i < n; i++) {\n			dp[0][i] = 1;\n			dp[1][i] = 1;\n		}\n		for(int i = 2; i <= k; i++) {\n			dp[i][0] = dp[i-1][1];\n			dp[i][n-1] = dp[i-1][n-2];\n			for(int j = 1; j < n-1; j++) {\n				dp[i][j] = (dp[i-1][j-1] + dp[i-1][j+1])%mod;\n			}\n		}\n		long[] coeff = new long[n];\n		for(int i = 1; i <= k; i++) {\n			coeff[0] = (coeff[0] + dp[i-1][1]*dp[k-i][1])%mod;\n			coeff[n-1] = (coeff[n-1] + dp[i-1][n-2]*dp[k-i][n-2])%mod;\n		}\n		for(int i = 1; i < n-1; i++) {\n			coeff[i] = (coeff[i] + 2*(dp[k-1][i-1]+dp[k-1][i+1]))%mod;\n			for(int j = 2; j < k; j++) {\n				coeff[i] = (coeff[i] + (dp[j-1][i-1] + dp[j-1][i+1])*(dp[k-j][i-1]+dp[k-j][i+1]))%mod;\n			}\n		}\n		long sum = 0;\n		long[] a = new long[n];\n		for(int i = 0; i < n; i++) {\n			a[i] = Long.parseLong(st.nextToken());\n			sum = (sum + a[i]*coeff[i])%mod;\n		}\n		for(int i = 0; i < q; i++) {\n			st = new StringTokenizer(br.readLine());\n			int index = Integer.parseInt(st.nextToken())-1;\n			long x = Long.parseLong(st.nextToken());\n			sum = ((sum + (x-a[index])*coeff[index])%mod+mod)%mod;\n			a[index] = x;\n			out.println(sum);\n		}\n		out.close();\n	}\n},"combinatorics,dp,math"
"import java.util.*;\nimport java.io.*;\npublic class d {\n	static final FS sc = new FS();\n	static final PrintWriter pw = new PrintWriter(System.out);\n	\n	static final int mod = 1_000_000_007;\n	\n	static int n, k;\n	static int[] arr;\n	static long[][] dp;\n	static long[] numPaths;\n	public static void main(String[] args) {\n		n = sc.nextInt();\n		k = sc.nextInt();\n		int q = sc.nextInt();\n		\n		arr = new int[n];\n		for(int i = 0; i < n; ++i) arr[i] = sc.nextInt();\n		\n		dp = new long[n][k + 1];\n		for(long[] a : dp) Arrays.fill(a, -1);\n		\n		long total = 0;\n		numPaths = new long[n];\n		for(int i = 0; i < n; ++i) {\n			for(int j = 0; j <= k; ++j) numPaths[i] = (numPaths[i] + go(i, j) * go(i, k - j)) % mod;\n			\n			total = (total + numPaths[i] * arr[i]) % mod;\n		}\n		\n		for(int qq = 0; qq < q; ++qq) {\n			int i = sc.nextInt() - 1, x = sc.nextInt();\n			\n			long sub = (numPaths[i] * arr[i]) % mod;\n			total = (total - sub + mod) % mod;\n			\n			arr[i] = x;\n			\n			total = (total + numPaths[i] * arr[i]) % mod;\n			\n			pw.println(total);\n		}\n		\n		pw.flush();\n	}\n	static long go(int idx, int num) {\n		if(dp[idx][num] != -1) return dp[idx][num];\n		\n		if(num == k) return dp[idx][num] = 1;\n		\n		return dp[idx][num] = ((idx > 0 ? go(idx - 1, num + 1) : 0) + (idx < n - 1 ? go(idx + 1, num + 1) : 0)) % mod;\n	}\n	static class FS {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer("""");\n		String next() {\n			while(!st.hasMoreElements()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch(Exception e) {}\n			}\n			return st.nextToken();\n		}\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n	}\n}","combinatorics,dp,math"
"import java.util.Scanner;\n \npublic class Main\n{	\n	public static void main(String[] args)\n	{\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		for(int i=0;i<t;i++)\n		{\n			int n=sc.nextInt();\n			int m=sc.nextInt();\n			int[] a=new int[n];\n			for(int j=0;j<n;j++)\n				a[j]=sc.nextInt();\n			int lastCorrentPos=n-1;\n			while(lastCorrentPos>=0 && a[lastCorrentPos]==lastCorrentPos+1)\n				lastCorrentPos--;\n			double ans=1.0;\n			if(lastCorrentPos==-1)\n				ans=0.0;\n			for(int j=0;j<m;j++)\n			{\n				int r=sc.nextInt()-1;\n				double p=sc.nextDouble();\n				if(r>=lastCorrentPos)\n					ans*=(1-p);\n			}\n			System.out.printf(""%.6f\n"",(1-ans));\n		}\n	}\n}","dp,math,probabilities"
"import java.util.*;\nimport java.io.*;\n\npublic class Main{\n\n	public static void main(String args[]){\n		Scanner in = new Scanner(System.in);\n		int t = in.nextInt();\n		while(t-- > 0){\n			int n = in.nextInt();\n			double m = in.nextDouble();\n			int[] a = new int[n];\n			for(int i = 0; i < n; i++){\n				a[i] = in.nextInt();\n			}\n			double[] p = new double[n];\n			Arrays.fill(p, 1.0d);\n			for(int i = 0; i < m; i++){\n				int r = in.nextInt() - 1;\n				double q = 1.0d - in.nextDouble();\n				p[r] = p[r] * q;\n			}\n			double ans = 1.0d;\n			for(int i = n - 1; i >= 0; i--){\n				ans = ans * p[i];\n				if(a[i] != i + 1){\n					System.out.println(1.0d - ans);\n					break;\n				}\n				if(i == 0) {\n					System.out.println(1.0d);\n				}\n			}\n		}\n	}\n}\n","dp,math,probabilities"
"import java.util.*;\npublic class Main {\n	public static void main(String[] args){\n		Scanner sc = new Scanner(System.in);\n\n		int t = sc.nextInt();\n\n		for ( int zzz=0; zzz<t; zzz++ ) {\n			int n = sc.nextInt();\n			int m = sc.nextInt();\n\n			int[] a = new int[n];\n			int pref = n;\n			for ( int i=0; i<n; i++ ) {\n				a[i] = sc.nextInt();\n			}\n			for ( int i=n-1; i>=0; i-- ) {\n				if ( a[i]==i+1 ) {\n					pref--;\n				} else {\n					break;\n				}\n			}\n\n			double ans = 0.0;\n			double mid = 1.0;\n			for ( int i=0; i<m; i++ ) {\n				int r = sc.nextInt();\n				double p = sc.nextDouble();\n\n				if ( r<pref ) {\n					continue;\n				}\n\n				ans += mid*p;\n				mid *= (1.0-p);\n\n			}\n\n			if ( pref==0 ) {\n				System.out.println(""1.0000"");\n			} else {\n				System.out.println(ans);\n			}\n		}\n	}\n}\n","dp,math,probabilities"
import java.util.*;\npublic class Probability_Array_CF {\n\n	public static void main(String[] args) {\n		Scanner scan=new Scanner(System.in);\n		int t=scan.nextInt();\n		while(t-->0) {\n			\n			int n=scan.nextInt();\n			int q=scan.nextInt();\n			int[] arr=new int[n];\n			for(int i=0;i<n;i++) {\n				arr[i]=scan.nextInt();\n			}\n			while(n>0&&arr[n-1]==n) {\n				n--;\n			}\n			double res=0;\n			List<Double> l=new ArrayList<>();\n			while(q-->0) {\n				int a=scan.nextInt();\n				double b=scan.nextDouble();\n				if(a>=n) {\n					l.add(b);\n				}\n			}\n			if(n==0) {\n				System.out.println(1);\n			}else {\n				double temp=1;\n				for(int i=0;i<l.size();i++) {\n					double d=l.get(i);\n					res+= d*(temp);\n					temp*=(1-d);\n//					for(int j=i-1;j>=0;j--) {\n//						d*=(1-l.get(j));\n//					}\n//					res+=d;\n				}\n				System.out.println(res);\n			}\n		}\n	}\n}\n,"dp,math,probabilities"
import java.util.*;\n\npublic class Codeforces {\n	static long mod = 998244353;\n	static long inv = (mod + 1) / 2;\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		long fib[] = new long[n + 100];\n		fib[1] = 1;\n		fib[2] = 1;\n		for (int i = 3; i <= n; i++) {\n			fib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n		}\n		long ans = fib[n];\n		for (int i = 1; i <= n; i++) {\n			ans = ans * inv % mod;\n		}\n		System.out.println(ans);\n		sc.close();\n	}\n},"combinatorics,dp,math"
import java.util.*;\n\npublic class Codeforces {\n	static long mod = 998244353;\n	static long inv = (mod + 1) / 2;\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		long fib[] = new long[n + 100];\n		fib[1] = 1;\n		fib[2] = 1;\n		for (int i = 3; i <= n; i++) {\n			fib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n		}\n		long ans = fib[n];\n		for (int i = 1; i <= n; i++) {\n			ans = ans * inv % mod;\n		}\n		System.out.println(ans);\n		sc.close();\n	}\n},"combinatorics,dp,math"
import java.util.*;\npublic class p1452D {\n    public static void main(String[] args) {\n        Scanner scn=new Scanner(System.in);\n        long m=998244353;\n        long val=499122177;\n        long val1=val*val;\n        val1=val1%m;\n        int n=scn.nextInt();\n        if(n==1){\n            System.out.println(val);\n        }\n        else{\n        long x=val;\n        long y=val1;\n        for(int i=0;i<n-2;i++){\n            long z=val*y+val1*x;\n            z=z%m;\n            x=y;\n            y=z;\n        }\n        System.out.println(y);\n\n        }\n        \n    }\n}\n,"combinatorics,dp,math"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1452D extends PrintWriter {\n	CF1452D() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1452D o = new CF1452D(); o.main(); o.flush();\n	}\n\n	static final int MD = 998244353, V2 = (MD + 1) / 2;\n	void main() {\n		int n = sc.nextInt();\n		int x0 = 1, x1 = 0; long ans = 1;\n		for (int i = 1; i <= n; i++) {\n			if ((i & 1) == 1)\n				x1 = (x1 + x0) % MD;\n			else\n				x0 = (x0 + x1) % MD;\n			ans = ans * V2 % MD;\n		}\n		int x = (n & 1) == 1 ? x0 : x1;\n		ans = ans * x % MD;\n		println(ans);\n	}\n}\n","combinatorics,dp,math"
"// upsolve with kaiboy, coached by rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1451E2 extends PrintWriter {\n	CF1451E2() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1451E2 o = new CF1451E2(); o.main(); o.flush();\n	}\n\n	int and(int i, int j) {\n		println(""AND "" + i + "" "" + j);\n		return sc.nextInt();\n	}\n	int xor(int i, int j) {\n		println(""XOR "" + i + "" "" + j);\n		return sc.nextInt();\n	}\n	void main() {\n		int n = sc.nextInt();\n		int[] aa = new int[n + 1];\n		for (int i = 2; i <= n; i++)\n			aa[i] = xor(1, i);\n		Integer[] ii = new Integer[n];\n		for (int h = 0; h < n; h++)\n			ii[h] = h + 1;\n		Arrays.sort(ii, (i, j) -> aa[i] - aa[j]);\n		int a = -1;\n		for (int h = 1; h < n; h++) {\n			int i = ii[h - 1], j = ii[h];\n			if (aa[i] == aa[j]) {\n				a = and(i, j) ^ aa[i];\n				break;\n			}\n		}\n		if (a == -1) {\n			int i = ii[0], j = ii[n - 1], k = ii[1];\n			a = (and(i, k) | and(j, k)) ^ aa[k];\n		}\n		print(""!"");\n		for (int i = 1; i <= n; i++)\n			print("" "" + (a ^ aa[i]));\n		println();\n	}\n}\n","bitmasks,constructive algorithms,interactive,math"
"import java.io.*;\nimport java.util.*;\n \npublic class Codeforces {\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		//int cases = Integer.parseInt(br.readLine());\n		//o:while(cases-- > 0) {\n			String[] str = br.readLine().split("" "");\n			int n = Integer.parseInt(str[0]);\n			ArrayList<Integer> pos[] = new ArrayList[n+1];\n			for(int i=0; i<=n; i++) {\n				pos[i] = new ArrayList<Integer>();\n			}\n			int xorvals[] = new int[n + 1];\n		    int ans[] = new int[n + 1];\n		    xorvals[1] = 0;\n		    pos[0].add(1);\n		    for(int i=2; i<=n; i++) {\n		    	xorvals[i] = queries(""XOR"", 1, i, br);\n		    	pos[xorvals[i]].add(i);\n		    }\n		    int a = 1, b = -1, c = -1, same = -1;\n		    for(int i=0; i<n; i++) {\n		    	if(pos[i].size() > 1) {\n		    		b = pos[i].get(0);\n		    		c = pos[i].get(1);\n		    		same = i;\n		    	}\n		    }\n		    if(same == -1) {\n		    	// no two same values. so all 0 to n-1 present\n		    	for(int i=2; i<=3; i++) {\n		    		for(int j=i+1; j<=n; j++) {\n		    			if((xorvals[i] ^ xorvals[j]) == n-1) {\n		    				b = i;\n		    				c = j;\n		    				break;\n		    			}\n		    		}\n		    	}\n		    	int xorab = xorvals[a] ^ xorvals[b], xorac = xorvals[a] ^ xorvals[c], xorbc = xorvals[b] ^ xorvals[c];\n		    	int andab = queries(""AND"", a, b, br);\n	            int andac = queries(""AND"", a, c, br);\n	            int andbc = 0;\n	            int x = xorab + 2 * andab;\n	            int y = xorac + 2 * andac;\n	            int z = xorbc + 2 * andbc;\n	            ans[a] = (x + y - z) / 2;\n		    }else {\n		    	// some two values r equal\n		    	ans[b] = queries(""AND"", b, c, br);\n	            ans[1] = xorvals[b] ^ ans[b];\n		    }\n		    for(int i=2; i<=n; i++) {\n		    	ans[i] = (ans[1] ^ xorvals[i]);\n		    }\n		    System.out.print(""! "");\n		    for(int i = 1; i <= n; i++) {\n		    	System.out.print(ans[i] + "" "");\n		    }\n	        System.out.println();\n	        System.out.flush();\n		//}\n	}\n	public static int queries(String s, int i, int j, BufferedReader br) throws IOException {\n        System.out.println(s + "" "" + i + "" "" + j);\n        System.out.flush();\n        int x = Integer.parseInt(br.readLine());\n        if(x == -1)\n            System.exit(0);\n        return x;\n    }\n}","bitmasks,constructive algorithms,interactive,math"
"    import java.util.*;\nimport java.util.ArrayList;\npublic class Main {\n    public static int queries(String s, int i, int j, Scanner sc)\n    {\n        System.out.println(s + "" "" + i + "" "" + j);\n        System.out.flush();\n        int x = sc.nextInt();\n        if(x == -1)\n            System.exit(0);\n        return x;\n    }\n    public static void main(String args[])\n    {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        ArrayList<Integer> pos[] = new ArrayList[n + 1];\n        for(int i = 0; i <= n; i++)\n            pos[i] = new ArrayList<Integer>();\n        int xorvals[] = new int[n + 1];\n        int ans[] = new int[n + 1];\n        xorvals[1] = 0;\n        pos[0].add(1);\n        for(int i = 2; i <= n; i++)\n        {\n            xorvals[i] = queries(""XOR"", 1, i, sc);\n            pos[xorvals[i]].add(i);\n        }\n        int a = 1, b = -1, c = -1;\n        int same = -1;\n        for(int i = 0; i < n; i++)\n        if(pos[i].size() > 1)\n            {\n                b = pos[i].get(0);\n                c = pos[i].get(1);\n                same = i;\n            }\n        if(same == -1)\n        {\n            // If a_b ^ a_c == n - 1, then a_b & a_c = 0 \n            for(int i = 2; i <= 3; i++)\n                for(int j = i + 1; j <= n; j++)\n                    if((xorvals[i] ^ xorvals[j]) == n - 1)\n                    {\n                        b = i;\n                        c = j;\n                    }\n            assert(b != -1 && c != -1);\n            int xorab = xorvals[a] ^ xorvals[b], xorac = xorvals[a] ^ xorvals[c], xorbc = xorvals[b] ^ xorvals[c];\n            int andab = queries(""AND"", a, b, sc);\n            int andac = queries(""AND"", a, c, sc);\n            int andbc = 0;\n            int x = xorab + 2 * andab;\n            int y = xorac + 2 * andac;\n            int z = xorbc + 2 * andbc;\n            assert((x + y - z) % 2 == 0);\n            ans[a] = (x + y - z) / 2;\n        }\n        else\n        {\n            // if a_1 ^ a_b == a_1 ^ a_c, then a_b = a_c = (a_b & a_c)\n            ans[b] = queries(""AND"", b, c, sc);\n            ans[1] = xorvals[b] ^ ans[b];\n        }\n        for(int i = 2; i <= n; i++)\n            ans[i] = (xorvals[i] ^ ans[1]);\n        System.out.print(""! "");\n        for(int i = 1; i <= n; i++)\n            System.out.print(ans[i] + "" "");\n        System.out.println();\n        System.out.flush();\n    }\n}","bitmasks,constructive algorithms,interactive,math"
"import java.util.*;\npublic class Myclass {\n\n	 static int fun(String s, int i, int j, Scanner sc)\n    {\n        System.out.println(s + "" "" + i + "" "" + j);\n        System.out.flush();\n        int x = sc.nextInt();\n        if(x == -1)\n            System.exit(0);\n        return x;\n    }\n	\n	\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n	   //System.out.println("""");\n		\n		\n		Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        ArrayList<Integer> pos[] = new ArrayList[n + 1];\n        for(int i = 0; i <= n; i++)\n            pos[i] = new ArrayList<Integer>();\n        int xorvals[] = new int[n + 1];\n        int ans[] = new int[n + 1];\n        xorvals[1] = 0;\n        pos[0].add(1);\n        for(int i = 2; i <= n; i++)\n        {\n            xorvals[i] = fun(""XOR"", 1, i, sc);\n            pos[xorvals[i]].add(i);\n        }\n        int a = 1, b = -1, c = -1;\n        int same = -1;\n        for(int i = 0; i < n; i++)\n        if(pos[i].size() > 1)\n            {\n                b = pos[i].get(0);\n                c = pos[i].get(1);\n                same = i;\n            }\n        if(same == -1)\n        {\n            // If a_b ^ a_c == n — 1, then a_b & a_c = 0 \n            for(int i = 2; i <= 3; i++)\n                for(int j = i + 1; j <= n; j++)\n                    if((xorvals[i] ^ xorvals[j]) == n - 1)\n                    {\n                        b = i;\n                        c = j;\n                    }\n            assert(b != -1 && c != -1);\n            int xorab = xorvals[a] ^ xorvals[b], xorac = xorvals[a] ^ xorvals[c], xorbc = xorvals[b] ^ xorvals[c];\n            int andab = fun(""AND"", a, b, sc);\n            int andac = fun(""AND"", a, c, sc);\n            int andbc = 0;\n            int x = xorab + 2 * andab;\n            int y = xorac + 2 * andac;\n            int z = xorbc + 2 * andbc;\n            assert((x + y - z) % 2 == 0);\n            ans[a] = (x + y - z) / 2;\n        }\n        else\n        {\n            // if a_1 ^ a_b == a_1 ^ a_c, then a_b = a_c = (a_b & a_c)\n            ans[b] = fun(""AND"", b, c, sc);\n            ans[1] = xorvals[b] ^ ans[b];\n        }\n        for(int i = 2; i <= n; i++)\n            ans[i] = (xorvals[i] ^ ans[1]);\n        System.out.print(""! "");\n        for(int i = 1; i <= n; i++)\n            System.out.print(ans[i] + "" "");\n        System.out.println();\n        System.out.flush();\n		\n		\n		\n		\n		\n		//end \n	}\n\n}\n","bitmasks,constructive algorithms,interactive,math"
"import java.util.*;\npublic class Codeforces\n{\n	public static void main(String[]args)\n	{\n		Scanner sc=new Scanner(System.in);\n		int t= sc.nextInt();\n		while(t-->0)\n		{\n			int sum=0, min=Integer.MAX_VALUE;\n			int m =sc.nextInt();\n			int n= sc.nextInt();\n			int neg=0;\n			for(int i=0;i<m*n;i++)\n			{\n				int v= sc.nextInt();\n				if(v<0)\n					neg++;\n				sum+=Math.abs(v);\n				min=Math.min(min,Math.abs(v));\n			}\n			if(neg%2!=0)\n				sum-=(min*2);\n			System.out.println(sum);\n		}\n	}\n}","greedy,math"
"import java.util.*;\npublic class Number_Box \n{\n	public static void main(String[]args)\n	{\n		Scanner sc=new Scanner(System.in);\n		int t= sc.nextInt();\n		while(t-->0)\n		{\n			int sum=0, min=Integer.MAX_VALUE;\n			int m =sc.nextInt();\n			int n= sc.nextInt();\n			int neg=0;\n			for(int i=0;i<m*n;i++)\n			{\n				int v= sc.nextInt();\n				if(v<0)\n					neg++;\n				sum+=Math.abs(v);\n				min=Math.min(min,Math.abs(v));\n			}\n			if(neg%2!=0)\n				sum-=(min*2);\n			System.out.println(sum);\n		}\n	}\n}\n","greedy,math"
"import java.util.*;\npublic class Main\n{   \n	public static void main(String[] args) {\n		Scanner s=new Scanner(System.in);\n		int t=s.nextInt();\n	    while(t-->0){\n	        int sum=0,min=Integer.MAX_VALUE;\n	        int n=s.nextInt(),m=s.nextInt();\n	        int neg=0;\n	        for(int i=0;i<n*m;i++){\n	            int v=s.nextInt();\n	            if(v<0) neg++;\n	            sum+=Math.abs(v);\n	            min=Math.min(min,Math.abs(v));\n	        }\n	        if(neg%2!=0) sum-=(min*2);\n	        System.out.println(sum);\n}}}","greedy,math"
"import java.util.*;\npublic class MyClass {\n    public static void main(String args[]) \n    {\n    Scanner sc  = new Scanner(System.in);\n   int t=sc.nextInt();\n   while(t-- >0)\n   {\n    int n=sc.nextInt();\n    int m=sc.nextInt();\n    int min=Integer.MAX_VALUE;\n    int neg=0;\n    int s=0;\n    for(int i=0;i<n*m;i++)\n    {\n        int a=sc.nextInt();\n        s+=Math.abs(a);\n        if(a<0)\n        neg++;\n        min=Math.min(min,Math.abs(a));\n    }\n    if(neg%2==0)\n    System.out.println(s);\n    else\n    System.out.println(s-2*min);  \n   }\n}\n}","greedy,math"
"import java.util.Scanner;\npublic class Main \n{\npublic static void main(String[]args)\n{\nScanner sc=new Scanner(System.in);\nint t=sc.nextInt();\nwhile(t-->0)\n{\nint n=sc.nextInt();\nSystem.out.println(n);\nfor(int i=1;i<=n;i++)\nSystem.out.print(i+"" "");\nSystem.out.println();\n}\n}\n}","constructive algorithms,math"
"import java.util.Scanner;\n\npublic class cf {\n\n	public static void main(String[] args) {\n	\n		Scanner sc=new Scanner(System.in);\n		\n		int t=sc.nextInt();\n		while(t-->0) {\n			int n=sc.nextInt();\n			System.out.println(n);\n			for(int i=0;i<n;i++) System.out.print(i+1+"" "");\n		}\n\n	}\n\n}\n","constructive algorithms,math"
"import java.io.*;\nimport java.lang.*;\nimport java.util.*;\npublic class main{\npublic static void main(String[] args){\nScanner s=new Scanner(System.in);\nint t=s.nextInt();\nwhile(t-->0){\nint n=s.nextInt();\nSystem.out.println(n);\nfor(int i=1;i<=n;i++)\nSystem.out.print(i+"" "");\nSystem.out.println();\n}\n}\n}","constructive algorithms,math"
"import java.util.Scanner;\npublic class p1447a \n{\n	public static void main(String[]args)\n	{\n	Scanner sc=new Scanner(System.in);\n	int t=sc.nextInt();\n	while(t-->0)\n	{\n		int n=sc.nextInt();\n		System.out.println(n);\n		for(int i=1;i<=n;i++)\n		{\n			System.out.print(i+"" "");\n		}\n		System.out.println();\n	}\n	}\n}","constructive algorithms,math"
"import java.util.*;\n\npublic class Codeforces {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		int dp[][] = new int[5005][5005];\n		int ans = 0;\n		String a = sc.next();\n		String b = sc.next();\n		for (int i = 1; i <= n; i++) {\n			for (int j = 1; j <= m; j++) {\n				if (a.charAt(i - 1) == b.charAt(j - 1)) {\n					dp[i][j] = dp[i - 1][j - 1] + 2;\n				} else {\n					dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) - 1;\n				}\n				dp[i][j] = Math.max(0, dp[i][j]);\n				ans = Math.max(ans, dp[i][j]);\n			}\n		}\n		System.out.println(ans);\n		sc.close();\n	}\n}","dp,strings"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1447D extends PrintWriter {\n	CF1447D() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1447D o = new CF1447D(); o.main(); o.flush();\n	}\n\n	static final int INF = 0x3f3f3f3f;\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		byte[] aa = sc.next().getBytes();\n		byte[] bb = sc.next().getBytes();\n		int[][] dp = new int[n + 1][m + 1];\n		int ans = 0;\n		for (int i = 1; i <= n; i++)\n			for (int j = 1; j <= m; j++) {\n				int s = aa[i - 1] == bb[j - 1] ? dp[i - 1][j - 1] + 2\n					: Math.max(dp[i - 1][j], dp[i][j - 1]) - 1;\n				ans = Math.max(ans, dp[i][j] = Math.max(s, 0));\n			}\n		println(ans);\n	}\n}\n","dp,strings"
"import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        String a = sc.next();\n        String b = sc.next();\n        int[][] dp = new int[m+1][n+1];\n\n        int max = 0;\n        for(int i=1; i<=m; i++){\n            for(int j=1; j<=n; j++){\n\n                if (a.charAt(i-1) == b.charAt(j-1))\n                    dp[i][j] = Math.max(0, Math.max(2, dp[i-1][j-1]+2));\n                else\n                    dp[i][j] = Math.max(0, Math.max(dp[i-1][j]-1, dp[i][j-1]-1));\n\n                max = Math.max(dp[i][j],max);\n            }\n        }\n        System.out.println(max);\n    }\n}","dp,strings"
"\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n \n        Scanner sc = new Scanner(System.in);\n        int x = sc.nextInt();\n        int y = sc.nextInt();\n        String a = sc.next();\n        String b = sc.next();\n        int[][] lista = new int[x+1][y+1];\n \n        int maximo = 0;\n        for(int i=1; i<=x; i++){\n            for(int j=1; j<=y; j++){\n                if (a.charAt(i-1) == b.charAt(j-1))\n                    lista[i][j] = Math.max(0, Math.max(2, lista[i-1][j-1]+2));\n                else\n                    lista[i][j] = Math.max(0, Math.max(lista[i-1][j]-1, lista[i][j-1]-1));\n \n                maximo = Math.max(lista[i][j],maximo);\n            }\n        }\n        System.out.println(maximo);\n    }\n}","dp,strings"
"import java.io.*;\nimport java.util.*;\nimport java.math.*;\n \n \n//Sub_To_Errichto\npublic class Main {\n    //static final long MOD = 1000000007L;\n    //static final long MOD2 = 1000000009L;\n    static final long MOD = 998244353L;\n    static final int INF = 50000000;\n    static final int NINF = -500000000;\n    \n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n        \n        int N = sc.ni();\n        int M = sc.ni();\n        ArrayList<Integer>[] graph = new ArrayList[N];\n        ArrayList<Integer>[] transpose = new ArrayList[N];\n        for (int i = 0; i < N; i++) {\n        	graph[i] = new ArrayList<Integer>();\n        	transpose[i] = new ArrayList<Integer>();\n        }\n        \n        Dijkstra dij = new Dijkstra(2*N);\n        for (int i = 0; i < M; i++) {\n        	int u = sc.ni()-1;\n        	int v = sc.ni()-1;\n        	graph[u].add(v);\n        	transpose[v].add(u);\n        	dij.addEdge(u, v, 1);\n        	dij.addEdge(v, N+u,1000000);\n        	dij.addEdge(N+v, N+u,1);\n        	dij.addEdge(N+u, v, 1000000);\n        }\n        \n        ArrayDeque<Integer> bfs = new ArrayDeque<Integer>();\n        int[] dist = new int[18*N];\n        Arrays.fill(dist, INF);\n        dist[0] = 0;\n        bfs.add(0);\n        while (!bfs.isEmpty()) {\n        	int val = bfs.pollFirst();\n        	int t = val/N;\n        	int n = val%N;\n        	if ((t&1) == 0) {\n        		for (int next: graph[n]) {\n        			if (dist[next+t*N]==INF) {\n        				dist[next+t*N] = dist[val]+1;\n        				bfs.add(next+t*N);\n        			}\n        		}\n        		for (int next: transpose[n]) {\n        			if (t < 17 && dist[next+(t+1)*N]==INF) {\n        				dist[next+(t+1)*N] = dist[val]+1;\n        				bfs.add(next+(t+1)*N);\n        			}\n        		}\n        	} else {\n        		for (int next: transpose[n]) {\n        			if (dist[next+t*N]==INF) {\n        				dist[next+t*N] = dist[val]+1;\n        				bfs.add(next+t*N);\n        			}\n        		}\n        		for (int next: graph[n]) {\n        			if (t < 17 && dist[next+(t+1)*N]==INF) {\n        				dist[next+(t+1)*N] = dist[val]+1;\n        				bfs.add(next+(t+1)*N);\n        			}\n        		}\n        	}\n        }\n        int ans = INF;\n        for (int i = 0; i < 18; i++) {\n        	int j = i*N+(N-1);\n        	ans = Math.min(ans, dist[j]+(1<<i)-1);\n        }\n        if (ans < INF) {\n        	pw.println(ans);\n        	pw.close();\n        	return;\n        }\n        long[] travel = dij.dijkstra(0);\n        long val = Math.min(travel[N-1],travel[2*N-1]);\n        long tranposes = val/1000000;\n        long walks = val%1000000;\n        long finalAns = (power(2,tranposes,MOD)-1+tranposes+walks)%MOD;\n        pw.println(finalAns);\n        pw.close();\n    }\n    \n    //Fast exponentiation (x^y mod m)\n    public static long power(long x, long y, long m) {\n    	long ans = 1;\n    	x %= m;\n    	while (y > 0) {\n    		if((y&1)==1)\n    			ans = (ans * x) % m;\n    		y /= 2;\n    		x = (x * x) % m;\n    	}\n    	return ans;\n    }\n    \n    static class Dijkstra {\n    	public int N;\n    	public ArrayList<long[]>[] graph;\n\n    	public Dijkstra(int numNodes) {\n    		N = numNodes;\n    		graph = new ArrayList[N];\n    		for (int i = 0; i < N; i++) {\n    			graph[i] = new ArrayList<long[]>();\n    		}\n    	}\n\n    	//uncomment the last line to make every edge two-way\n    	public void addEdge(long[] edge) {\n    		graph[(int)edge[0]].add(new long[]{edge[1],edge[2]});\n    		//graph[(int)edge[1]].add(new long[]{edge[0],edge[2]});\n    	}\n\n    	public void addEdge(int n1, int n2, long w) {\n    		graph[n1].add(new long[]{n2,w});\n    		//graph[n2].add(new long[]{n1,w});\n    	}\n\n    	//uncomment the lines with ""previousNode"" if you'd like to calculate that\n    	public long[] dijkstra(int root) {\n    		//long[] previousNode = new long[N];\n    		//Arrays.fill(previousNode,-1);\n\n    		long[] distances = new long[N];\n    		Arrays.fill(distances,Long.MAX_VALUE);\n    		distances[root] = 0L;\n\n    		PriorityQueue<long[]> pq = new PriorityQueue<long[]>(new Comparator<long[]>() {\n    			@Override\n    			public int compare(long[] arr1, long[] arr2) {\n    				if (arr1[1] < arr2[1])\n    					return -1;\n    				else if (arr1[1] > arr2[1])\n    					return 1;\n    				else\n    					return 0;\n    			}\n    		});\n    		long[] temp = new long[]{root,0};\n    		pq.add(temp);\n    		while (! pq.isEmpty()) {\n    			temp = pq.poll();\n    			for (long[] e: graph[(int)temp[0]]) {\n    				int child = (int)e[0];\n    				long w = e[1];\n    				int node = (int)temp[0];\n    				if (distances[child] > distances[node] + w) {\n    					//previousNode[child] = temp.node;\n    					distances[child] = distances[node] + w;\n    					pq.add(new long[]{child,distances[child]});\n    				}\n    			}\n    		}\n\n    		return distances;\n    	}\n    }\n    \n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int ni() {\n            return Integer.parseInt(next());\n        }\n \n        long nl() {\n            return Long.parseLong(next());\n        }\n \n        double nd() {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}","dfs and similar,graphs,greedy,shortest paths"
"import java.io.BufferedOutputStream;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.AbstractCollection;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.Objects;\nimport java.util.PriorityQueue;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	static class TaskAdapter implements Runnable {\n		@Override\n		public void run() {\n			long startTime = System.currentTimeMillis();\n			InputStream inputStream = System.in;\n			OutputStream outputStream = System.out;\n			FastReader in = new FastReader(inputStream);\n			Output out = new Output(outputStream);\n			CGraphTranspositions solver = new CGraphTranspositions();\n			solver.solve(1, in, out);\n			out.close();\n			System.err.println(System.currentTimeMillis()-startTime+""ms"");\n		}\n	}\n\n	public static void main(String[] args) throws Exception {\n		Thread thread = new Thread(null, new TaskAdapter(), """", 1<<28);\n		thread.start();\n		thread.join();\n	}\n\n	static class CGraphTranspositions {\n		private final int mod = 998244353;\n\n		public CGraphTranspositions() {\n		}\n\n		public boolean good(ArrayList<CGraphTranspositions.State> al, CGraphTranspositions.State s) {\n			for(CGraphTranspositions.State x: al) {\n				if(x.pow<s.pow&&x.compareTo(s)<=0) {\n					return false;\n				}\n			}\n			return true;\n		}\n\n		public void solve(int kase, InputReader in, Output pw) {\n			int n = in.nextInt(), m = in.nextInt();\n			ArrayList<Integer>[][] graph = new ArrayList[2][n];\n			graph[0] = in.nextDirectedGraph(n, m);\n			for(int i = 0; i<n; i++) {\n				graph[1][i] = new ArrayList<>();\n			}\n			for(int i = 0; i<n; i++) {\n				for(int j: graph[0][i]) {\n					graph[1][j].add(i);\n				}\n			}\n			ArrayList<CGraphTranspositions.State>[][] visited = new ArrayList[n][2];\n			for(int i = 0; i<n; i++) {\n				for(int j = 0; j<2; j++) {\n					visited[i][j] = new ArrayList<>();\n				}\n			}\n			HashSet<Pair<Integer, Integer>> hs = new HashSet<>(n*4);\n			PriorityQueue<CGraphTranspositions.State> pq = new PriorityQueue<>(n*4);\n			pq.add(new CGraphTranspositions.State(0, 0, 0));\n			while(!pq.isEmpty()) {\n				CGraphTranspositions.State cur = pq.poll();\n				var p = cur.getPair();\n				if(hs.contains(p)||!good(visited[cur.ind][cur.pow&1], cur)) {\n					continue;\n				}\n////				Utilities.Debug.dbg(cur);\n				hs.add(p);\n				visited[cur.ind][cur.pow&1].add(cur);\n				if(cur.ind==n-1) {\n////					Utilities.Debug.dbg(cur);\n					pw.println((Utilities.math.pow(2, cur.pow, mod)+cur.time+mod-1)%mod);\n					return;\n				}\n				CGraphTranspositions.State s = cur.trans();\n				if(!hs.contains(s.getPair())&&good(visited[s.ind][s.pow&1], s)) {\n					pq.add(s);\n				}\n				for(int i: graph[cur.pow&1][cur.ind]) {\n					s = cur.move(i);\n					if(!hs.contains(s.getPair())&&good(visited[s.ind][s.pow&1], s)) {\n						pq.add(s);\n					}\n				}\n			}\n		}\n\n		static class State implements Comparable<CGraphTranspositions.State> {\n			int ind;\n			int pow;\n			int time;\n\n			public State(int ind, int pow, int time) {\n				this.ind = ind;\n				this.pow = pow;\n				this.time = time;\n			}\n\n			public CGraphTranspositions.State move(int next) {\n				return new CGraphTranspositions.State(next, pow, time+1);\n			}\n\n			public CGraphTranspositions.State trans() {\n				return new CGraphTranspositions.State(ind, pow+1, time);\n			}\n\n			public Pair<Integer, Integer> getPair() {\n				return new Pair<>(ind, pow);\n			}\n\n			public int compareTo(CGraphTranspositions.State s) {\n				if(s.pow==pow) {\n					return Integer.compare(time, s.time);\n				}else if(Math.max(s.pow, pow)<=60) {\n					return Long.compare((1L<<pow)+time, (1L<<s.pow)+s.time);\n				}\n				return Integer.compare(pow, s.pow);\n			}\n\n			public String toString() {\n				return ""State{""+\n						""ind=""+ind+\n						"", pow=""+pow+\n						"", time=""+time+\n						'}';\n			}\n\n		}\n\n	}\n\n	static class Utilities {\n		public static class Debug {\n			public static final boolean LOCAL = System.getProperty(""ONLINE_JUDGE"")==null;\n\n			private static <T> String ts(T t) {\n				if(t==null) {\n					return ""null"";\n				}\n				try {\n					return ts((Iterable) t);\n				}catch(ClassCastException e) {\n					if(t instanceof int[]) {\n						String s = Arrays.toString((int[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof long[]) {\n						String s = Arrays.toString((long[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof char[]) {\n						String s = Arrays.toString((char[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof double[]) {\n						String s = Arrays.toString((double[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof boolean[]) {\n						String s = Arrays.toString((boolean[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}\n					try {\n						return ts((Object[]) t);\n					}catch(ClassCastException e1) {\n						return t.toString();\n					}\n				}\n			}\n\n			private static <T> String ts(T[] arr) {\n				StringBuilder ret = new StringBuilder();\n				ret.append(""{"");\n				boolean first = true;\n				for(T t: arr) {\n					if(!first) {\n						ret.append("", "");\n					}\n					first = false;\n					ret.append(ts(t));\n				}\n				ret.append(""}"");\n				return ret.toString();\n			}\n\n			private static <T> String ts(Iterable<T> iter) {\n				StringBuilder ret = new StringBuilder();\n				ret.append(""{"");\n				boolean first = true;\n				for(T t: iter) {\n					if(!first) {\n						ret.append("", "");\n					}\n					first = false;\n					ret.append(ts(t));\n				}\n				ret.append(""}"");\n				return ret.toString();\n			}\n\n			public static void dbg(Object... o) {\n				if(LOCAL) {\n					System.err.print(""Line #""+Thread.currentThread().getStackTrace()[2].getLineNumber()+"": ["");\n					for(int i = 0; i<o.length; i++) {\n						if(i!=0) {\n							System.err.print("", "");\n						}\n						System.err.print(ts(o[i]));\n					}\n					System.err.println(""]"");\n				}\n			}\n\n		}\n\n		public static class math {\n			public static long pow(long base, long exp, long mod) {\n				long ans = 1, cur = base;\n				while(exp>0) {\n					if((exp&1)>0) {\n						ans = (ans*cur)%mod;\n					}\n					cur = (cur*cur)%mod;\n					exp >>= 1;\n				}\n				return ans;\n			}\n\n		}\n\n	}\n\n	static class Output implements Closeable, Flushable {\n		public StringBuilder sb;\n		public OutputStream os;\n		public int BUFFER_SIZE;\n		public String lineSeparator;\n\n		public Output(OutputStream os) {\n			this(os, 1<<16);\n		}\n\n		public Output(OutputStream os, int bs) {\n			BUFFER_SIZE = bs;\n			sb = new StringBuilder(BUFFER_SIZE);\n			this.os = new BufferedOutputStream(os, 1<<17);\n			lineSeparator = System.lineSeparator();\n		}\n\n		public void println(long l) {\n			println(String.valueOf(l));\n		}\n\n		public void println(String s) {\n			sb.append(s);\n			println();\n		}\n\n		public void println() {\n			sb.append(lineSeparator);\n		}\n\n		private void flushToBuffer() {\n			try {\n				os.write(sb.toString().getBytes());\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n			sb = new StringBuilder(BUFFER_SIZE);\n		}\n\n		public void flush() {\n			try {\n				flushToBuffer();\n				os.flush();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n		public void close() {\n			flush();\n			try {\n				os.close();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n	}\n\n	static interface InputReader {\n		int nextInt();\n\n		default ArrayList<Integer>[] nextDirectedGraph(int n, int m) {\n			ArrayList<Integer>[] ret = new ArrayList[n];\n			for(int i = 0; i<n; i++) {\n				ret[i] = new ArrayList<>();\n			}\n			for(int i = 0; i<m; i++) {\n				ret[nextInt()-1].add(nextInt()-1);\n			}\n			return ret;\n		}\n\n	}\n\n	static class FastReader implements InputReader {\n		final private int BUFFER_SIZE = 1<<16;\n		private DataInputStream din;\n		private byte[] buffer;\n		private int bufferPointer;\n		private int bytesRead;\n\n		public FastReader(InputStream is) {\n			din = new DataInputStream(is);\n			buffer = new byte[BUFFER_SIZE];\n			bufferPointer = bytesRead = 0;\n		}\n\n		public int nextInt() {\n			int ret = 0;\n			byte c = skipToDigit();\n			boolean neg = (c=='-');\n			if(neg) {\n				c = read();\n			}\n			do {\n				ret = ret*10+c-'0';\n			} while((c = read())>='0'&&c<='9');\n			if(neg) {\n				return -ret;\n			}\n			return ret;\n		}\n\n		private boolean isDigit(byte b) {\n			return b>='0'&&b<='9';\n		}\n\n		private byte skipToDigit() {\n			byte ret;\n			while(!isDigit(ret = read())&&ret!='-') ;\n			return ret;\n		}\n\n		private void fillBuffer() {\n			try {\n				bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n			}catch(IOException e) {\n				e.printStackTrace();\n				throw new InputMismatchException();\n			}\n			if(bytesRead==-1) {\n				buffer[0] = -1;\n			}\n		}\n\n		private byte read() {\n			if(bytesRead==-1) {\n				throw new InputMismatchException();\n			}else if(bufferPointer==bytesRead) {\n				fillBuffer();\n			}\n			return buffer[bufferPointer++];\n		}\n\n	}\n\n	static class Pair<T1, T2> implements Comparable<Pair<T1, T2>> {\n		public T1 a;\n		public T2 b;\n\n		public Pair(Pair<T1, T2> p) {\n			this(p.a, p.b);\n		}\n\n		public Pair(T1 a, T2 b) {\n			this.a = a;\n			this.b = b;\n		}\n\n		public String toString() {\n			return a+"" ""+b;\n		}\n\n		public int hashCode() {\n			return Objects.hash(a, b);\n		}\n\n		public boolean equals(Object o) {\n			if(o instanceof Pair) {\n				Pair p = (Pair) o;\n				return a.equals(p.a)&&b.equals(p.b);\n			}\n			return false;\n		}\n\n		public int compareTo(Pair<T1, T2> p) {\n			int cmp = ((Comparable<T1>) a).compareTo(p.a);\n			if(cmp==0) {\n				return ((Comparable<T2>) b).compareTo(p.b);\n			}\n			return cmp;\n		}\n\n	}\n}\n\n\n","dfs and similar,graphs,greedy,shortest paths"
"import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1442c_2 {\n\n    public static void main(String[] args) throws IOException {\n        int n = rni(), m = ni();\n        List<List<Integer>> graph = new ArrayList<>(), rev = new ArrayList<>();\n        for (int i = 0; i < n; ++i) {\n            graph.add(new ArrayList<>());\n            rev.add(new ArrayList<>());\n        }\n        for (int i = 0; i < m; ++i) {\n            int u = rni() - 1, v = ni() - 1;\n            graph.get(u).add(v);\n            rev.get(v).add(u);\n        }\n        int ddist[][] = new int[n][20];\n        for (int[] row : ddist) {\n            fill(row, IBIG);\n        }\n        ddist[0][0] = 0;\n        PriorityQueue<int[]> dpq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n        dpq.offer(new int[] {0, 0, 0});\n        while (!dpq.isEmpty()) {\n            int e[] = dpq.poll(), i = e[1], dep = e[2], d = e[0];\n            if (d > ddist[i][dep]) {\n                continue;\n            }\n            for (int j : dep % 2 == 0 ? graph.get(i) : rev.get(i)) {\n                if (d + 1 < ddist[j][dep]) {\n                    dpq.offer(new int[] {ddist[j][dep] = d + 1, j, dep});\n                }\n            }\n            if (dep < 19) {\n                if (d + (1 << dep) < ddist[i][dep + 1]) {\n                    dpq.offer(new int[] {ddist[i][dep + 1] = d + (1 << dep), i, dep + 1});\n                }\n            }\n        }\n        int dans = IBIG;\n        for (int i = 0; i < 20; ++i) {\n            dans = min(dans, ddist[n - 1][i]);\n        }\n        if (dans < IBIG) {\n            prln(dans);\n            close();\n            return;\n        }\n        // {nei, type}\n        // type = 0 -> normal edge, type = 1 -> transposition\n        List<List<int[]>> g = new ArrayList<>();\n        for (int i = 0; i < 2 * n; ++i) {\n            g.add(new ArrayList<>());\n        }\n        for (int i = 0; i < n; ++i) {\n            g.get(i).add(new int[] {n + i, 1});\n            g.get(n + i).add(new int[] {i, 1});\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j : graph.get(i)) {\n                g.get(i).add(new int[] {j, 0});\n                g.get(n + j).add(new int[] {n + i, 0});\n            }\n        }\n        Comparator<int[]> comp = (a, b) -> {\n            /* if (a[1] == b[1]) {\n                return a[0] - b[0];\n            } else if (a[1] > 28 || b[1] > 28) {\n                return a[1] - b[1];\n            } else {\n                return (a[0] + (1 << a[1])) - (b[0] + (1 << b[1]));\n            } */\n            return a[1] == b[1] ? a[0] - b[0] : a[1] - b[1];\n        };\n        int dist[][] = new int[2 * n][2], dest = -1;\n        for (int i = 1; i < 2 * n; ++i) {\n            dist[i][1] = IBIG;\n        }\n        PriorityQueue<int[]> pq = new PriorityQueue<>(comp);\n        pq.offer(new int[] {0, 0, 0});\n        dijk: while (!pq.isEmpty()) {\n            int e[] = pq.poll(), a = e[0], b = e[1], i = e[2];\n            if (comp.compare(new int[]{a, b}, dist[i]) > 0) {\n                continue;\n            }\n            for (int[] ed : g.get(i)) {\n                int j = ed[0], type = ed[1], d[] = new int[2];\n                ++d[type];\n                if (comp.compare(dist[j], new int[]{a + d[0], b + d[1]}) > 0) {\n                    dist[j][0] = a + d[0];\n                    dist[j][1] = b + d[1];\n                    if (j == n - 1 || j == 2 * n - 1) {\n                        dest = j;\n                        break dijk;\n                    }\n                    pq.offer(new int[] {dist[j][0], dist[j][1], j});\n                }\n            }\n        }\n        int mod = 998244353;\n        int ans = 1;\n        for (int i = 0; i < dist[dest][1]; ++i) {\n            ans = (int) ((2L * ans) % mod);\n        }\n        ans = (int) (((long) ans + dist[dest][0] + mod - 1) % mod);\n        if (ans == 762309768) {\n            prln(dans);\n        }\n        prln(ans);\n        close();\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int lcm(int a, int b) {return a * b / gcf(a, b);}\n    static long lcm(long a, long b) {return a * b / gcf(a, b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {prln(""yes"");}\n    static void pry() {prln(""Yes"");}\n    static void prY() {prln(""YES"");}\n    static void prno() {prln(""no"");}\n    static void prn() {prln(""No"");}\n    static void prN() {prln(""NO"");}\n    static boolean pryesno(boolean b) {prln(b ? ""yes"" : ""no""); return b;};\n    static boolean pryn(boolean b) {prln(b ? ""Yes"" : ""No""); return b;}\n    static boolean prYN(boolean b) {prln(b ? ""YES"" : ""NO""); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(""hlfd""); flush();}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}\n}","dfs and similar,graphs,greedy,shortest paths"
"//package round681;\nimport java.io.*;\nimport java.util.*;\n\npublic class C {\n	InputStream is;\n	FastWriter out;\n	String INPUT = """";\n	\n	void solve()\n	{\n		int n = ni(), m = ni();\n		int[] from = new int[m];\n		int[] to = new int[m];\n		for(int i = 0;i < m;i++){\n		    from[i] = ni()-1;\n		    to[i] = ni()-1;\n		}\n		int[][] g = packD(n ,from, to);\n		int[][] ig = packD(n, to, from);\n\n		int I = Integer.MAX_VALUE / 3;\n		int[] minflip = new int[2*n];\n		Arrays.fill(minflip, I);\n		Deque<Integer> q = new ArrayDeque<>();\n		q.add(0);\n		minflip[0] = 0;\n		while(!q.isEmpty()){\n			int cur = q.poll();\n			if(cur < n) {\n				for (int e : g[cur]) {\n					if (minflip[e] > minflip[cur]) {\n						minflip[e] = minflip[cur];\n						q.addFirst(e);\n					}\n				}\n				for (int e : ig[cur]) {\n					if (minflip[e+n] > minflip[cur] + 1) {\n						minflip[e+n] = minflip[cur] + 1;\n						q.addLast(e+n);\n					}\n				}\n			}else{\n				cur -= n;\n				for (int e : g[cur]) {\n					if (minflip[e] > minflip[cur+n] + 1) {\n						minflip[e] = minflip[cur+n] + 1;\n						q.addLast(e);\n					}\n				}\n				for (int e : ig[cur]) {\n					if (minflip[e+n] > minflip[cur+n]) {\n						minflip[e+n] = minflip[cur+n];\n						q.addFirst(e+n);\n					}\n				}\n			}\n		}\n\n		int[][] ds = new int[20][2*n];\n		for(int i = 0;i < 20;i++){\n			Arrays.fill(ds[i], I);\n		}\n		ds[0][0] = 0;\n		q.add(0<<20|0);\n		while(!q.isEmpty()){\n			int code = q.poll();\n			int fl = (code>>>20) , cur = code&(1<<20)-1;\n\n			if(cur < n) {\n				for (int e : g[cur]) {\n					int nfl = fl + minflip[cur] - minflip[e];\n					if(nfl < 20 && ds[nfl][e] > ds[fl][cur] + 1){\n						ds[nfl][e] = ds[fl][cur] + 1;\n						q.addLast(nfl<<20|e);\n					}\n				}\n				for (int e : ig[cur]) {\n					int nfl = fl + minflip[cur] - minflip[e+n] + 1;\n					if(nfl < 20 && ds[nfl][e+n] > ds[fl][cur] + 1){\n						ds[nfl][e+n] = ds[fl][cur] + 1;\n						q.addLast(nfl<<20|e+n);\n					}\n				}\n			}else{\n				cur -= n;\n				for (int e : g[cur]) {\n					int nfl = fl + minflip[cur+n] - minflip[e] + 1;\n					if(nfl < 20 && ds[nfl][e] > ds[fl][cur+n] + 1){\n						ds[nfl][e] = ds[fl][cur+n] + 1;\n						q.addLast(nfl<<20|e);\n					}\n				}\n				for (int e : ig[cur]) {\n					int nfl = fl + minflip[cur+n] - minflip[e+n];\n					if(nfl < 20 && ds[nfl][e+n] > ds[fl][cur+n] + 1){\n						ds[nfl][e+n] = ds[fl][cur+n] + 1;\n						q.addLast(nfl<<20|e+n);\n					}\n				}\n			}\n		}\n\n		final int mod = 998244353;\n		if(minflip[n-1] < minflip[n-1+n] && minflip[n-1] >= 20){\n			out.println((pow(2, minflip[n-1], mod) - 1 + ds[0][n-1]) % mod);\n			return;\n		}\n		if(minflip[n-1+n] < minflip[n-1] && minflip[n-1+n] >= 20){\n			out.println((pow(2, minflip[n-1+n], mod) - 1 + ds[0][n-1+n]) % mod);\n			return;\n		}\n		if (minflip[n - 1] == minflip[n - 1 + n] && minflip[n - 1] >= 209) {\n			out.println((pow(2, minflip[n-1+n], mod) - 1 + Math.min(ds[0][n-1], ds[0][n-1+n])) % mod);\n			return;\n		}\n\n		long ans = Long.MAX_VALUE;\n		for(int i = 0;i < 20;i++){\n			if(ds[i][n-1] < I && minflip[n-1] <= 40)ans = Math.min(ans, (1L<<minflip[n-1]+i) - 1 + ds[i][n-1]);\n			if(ds[i][n-1+n] < I && minflip[n-1+n] <= 40)ans = Math.min(ans, (1L<<minflip[n-1+n]+i) - 1 + ds[i][n-1+n]);\n		}\n		out.println(ans % mod);\n	}\n\n	public static long pow(long a, long n, long mod) {\n		//		a %= mod;\n		long ret = 1;\n		int x = 63 - Long.numberOfLeadingZeros(n);\n		for (; x >= 0; x--) {\n			ret = ret * ret % mod;\n			if (n << 63 - x < 0) ret = ret * a % mod;\n		}\n		return ret;\n	}\n\n\n	public static int[][] packD(int n, int[] from, int[] to) {\n		return packD(n, from, to, from.length);\n	}\n\n	public static int[][] packD(int n, int[] from, int[] to, int sup) {\n		int[][] g = new int[n][];\n		int[] p = new int[n];\n		for (int i = 0; i < sup; i++) p[from[i]]++;\n		for (int i = 0; i < n; i++) g[i] = new int[p[i]];\n		for (int i = 0; i < sup; i++) {\n			g[from[i]][--p[from[i]]] = to[i];\n		}\n		return g;\n	}\n\n\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new FastWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new C().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n\n	private long[] nal(int n)\n	{\n		long[] a = new long[n];\n		for(int i = 0;i < n;i++)a[i] = nl();\n		return a;\n	}\n\n	private char[][] nm(int n, int m) {\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n\n	private int[][] nmi(int n, int m) {\n		int[][] map = new int[n][];\n		for(int i = 0;i < n;i++)map[i] = na(m);\n		return map;\n	}\n\n	private int ni() { return (int)nl(); }\n\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n\n	public static class FastWriter\n	{\n		private static final int BUF_SIZE = 1<<13;\n		private final byte[] buf = new byte[BUF_SIZE];\n		private final OutputStream out;\n		private int ptr = 0;\n\n		private FastWriter(){out = null;}\n\n		public FastWriter(OutputStream os)\n		{\n			this.out = os;\n		}\n\n		public FastWriter(String path)\n		{\n			try {\n				this.out = new FileOutputStream(path);\n			} catch (FileNotFoundException e) {\n				throw new RuntimeException(""FastWriter"");\n			}\n		}\n\n		public FastWriter write(byte b)\n		{\n			buf[ptr++] = b;\n			if(ptr == BUF_SIZE)innerflush();\n			return this;\n		}\n\n		public FastWriter write(char c)\n		{\n			return write((byte)c);\n		}\n\n		public FastWriter write(char[] s)\n		{\n			for(char c : s){\n				buf[ptr++] = (byte)c;\n				if(ptr == BUF_SIZE)innerflush();\n			}\n			return this;\n		}\n\n		public FastWriter write(String s)\n		{\n			s.chars().forEach(c -> {\n				buf[ptr++] = (byte)c;\n				if(ptr == BUF_SIZE)innerflush();\n			});\n			return this;\n		}\n\n		private static int countDigits(int l) {\n			if (l >= 1000000000) return 10;\n			if (l >= 100000000) return 9;\n			if (l >= 10000000) return 8;\n			if (l >= 1000000) return 7;\n			if (l >= 100000) return 6;\n			if (l >= 10000) return 5;\n			if (l >= 1000) return 4;\n			if (l >= 100) return 3;\n			if (l >= 10) return 2;\n			return 1;\n		}\n\n		public FastWriter write(int x)\n		{\n			if(x == Integer.MIN_VALUE){\n				return write((long)x);\n			}\n			if(ptr + 12 >= BUF_SIZE)innerflush();\n			if(x < 0){\n				write((byte)'-');\n				x = -x;\n			}\n			int d = countDigits(x);\n			for(int i = ptr + d - 1;i >= ptr;i--){\n				buf[i] = (byte)('0'+x%10);\n				x /= 10;\n			}\n			ptr += d;\n			return this;\n		}\n\n		private static int countDigits(long l) {\n			if (l >= 1000000000000000000L) return 19;\n			if (l >= 100000000000000000L) return 18;\n			if (l >= 10000000000000000L) return 17;\n			if (l >= 1000000000000000L) return 16;\n			if (l >= 100000000000000L) return 15;\n			if (l >= 10000000000000L) return 14;\n			if (l >= 1000000000000L) return 13;\n			if (l >= 100000000000L) return 12;\n			if (l >= 10000000000L) return 11;\n			if (l >= 1000000000L) return 10;\n			if (l >= 100000000L) return 9;\n			if (l >= 10000000L) return 8;\n			if (l >= 1000000L) return 7;\n			if (l >= 100000L) return 6;\n			if (l >= 10000L) return 5;\n			if (l >= 1000L) return 4;\n			if (l >= 100L) return 3;\n			if (l >= 10L) return 2;\n			return 1;\n		}\n\n		public FastWriter write(long x)\n		{\n			if(x == Long.MIN_VALUE){\n				return write("""" + x);\n			}\n			if(ptr + 21 >= BUF_SIZE)innerflush();\n			if(x < 0){\n				write((byte)'-');\n				x = -x;\n			}\n			int d = countDigits(x);\n			for(int i = ptr + d - 1;i >= ptr;i--){\n				buf[i] = (byte)('0'+x%10);\n				x /= 10;\n			}\n			ptr += d;\n			return this;\n		}\n\n		public FastWriter write(double x, int precision)\n		{\n			if(x < 0){\n				write('-');\n				x = -x;\n			}\n			x += Math.pow(10, -precision)/2;\n			//		if(x < 0){ x = 0; }\n			write((long)x).write(""."");\n			x -= (long)x;\n			for(int i = 0;i < precision;i++){\n				x *= 10;\n				write((char)('0'+(int)x));\n				x -= (int)x;\n			}\n			return this;\n		}\n\n		public FastWriter writeln(char c){\n			return write(c).writeln();\n		}\n\n		public FastWriter writeln(int x){\n			return write(x).writeln();\n		}\n\n		public FastWriter writeln(long x){\n			return write(x).writeln();\n		}\n\n		public FastWriter writeln(double x, int precision){\n			return write(x, precision).writeln();\n		}\n\n		public FastWriter write(int... xs)\n		{\n			boolean first = true;\n			for(int x : xs) {\n				if (!first) write(' ');\n				first = false;\n				write(x);\n			}\n			return this;\n		}\n\n		public FastWriter write(long... xs)\n		{\n			boolean first = true;\n			for(long x : xs) {\n				if (!first) write(' ');\n				first = false;\n				write(x);\n			}\n			return this;\n		}\n\n		public FastWriter writeln()\n		{\n			return write((byte)'\n');\n		}\n\n		public FastWriter writeln(int... xs)\n		{\n			return write(xs).writeln();\n		}\n\n		public FastWriter writeln(long... xs)\n		{\n			return write(xs).writeln();\n		}\n\n		public FastWriter writeln(char[] line)\n		{\n			return write(line).writeln();\n		}\n\n		public FastWriter writeln(char[]... map)\n		{\n			for(char[] line : map)write(line).writeln();\n			return this;\n		}\n\n		public FastWriter writeln(String s)\n		{\n			return write(s).writeln();\n		}\n\n		private void innerflush()\n		{\n			try {\n				out.write(buf, 0, ptr);\n				ptr = 0;\n			} catch (IOException e) {\n				throw new RuntimeException(""innerflush"");\n			}\n		}\n\n		public void flush()\n		{\n			innerflush();\n			try {\n				out.flush();\n			} catch (IOException e) {\n				throw new RuntimeException(""flush"");\n			}\n		}\n\n		public FastWriter print(byte b) { return write(b); }\n		public FastWriter print(char c) { return write(c); }\n		public FastWriter print(char[] s) { return write(s); }\n		public FastWriter print(String s) { return write(s); }\n		public FastWriter print(int x) { return write(x); }\n		public FastWriter print(long x) { return write(x); }\n		public FastWriter print(double x, int precision) { return write(x, precision); }\n		public FastWriter println(char c){ return writeln(c); }\n		public FastWriter println(int x){ return writeln(x); }\n		public FastWriter println(long x){ return writeln(x); }\n		public FastWriter println(double x, int precision){ return writeln(x, precision); }\n		public FastWriter print(int... xs) { return write(xs); }\n		public FastWriter print(long... xs) { return write(xs); }\n		public FastWriter println(int... xs) { return writeln(xs); }\n		public FastWriter println(long... xs) { return writeln(xs); }\n		public FastWriter println(char[] line) { return writeln(line); }\n		public FastWriter println(char[]... map) { return writeln(map); }\n		public FastWriter println(String s) { return writeln(s); }\n		public FastWriter println() { return writeln(); }\n	}\n\n	public void trnz(int... o)\n	{\n		for(int i = 0;i < o.length;i++)if(o[i] != 0)System.out.print(i+"":""+o[i]+"" "");\n		System.out.println();\n	}\n\n	// print ids which are 1\n	public void trt(long... o)\n	{\n		Queue<Integer> stands = new ArrayDeque<>();\n		for(int i = 0;i < o.length;i++){\n			for(long x = o[i];x != 0;x &= x-1)stands.add(i<<6|Long.numberOfTrailingZeros(x));\n		}\n		System.out.println(stands);\n	}\n\n	public void tf(boolean... r)\n	{\n		for(boolean x : r)System.out.print(x?'#':'.');\n		System.out.println();\n	}\n\n	public void tf(boolean[]... b)\n	{\n		for(boolean[] r : b) {\n			for(boolean x : r)System.out.print(x?'#':'.');\n			System.out.println();\n		}\n		System.out.println();\n	}\n\n	public void tf(long[]... b)\n	{\n		if(INPUT.length() != 0) {\n			for (long[] r : b) {\n				for (long x : r) {\n					for (int i = 0; i < 64; i++) {\n						System.out.print(x << ~i < 0 ? '#' : '.');\n					}\n				}\n				System.out.println();\n			}\n			System.out.println();\n		}\n	}\n\n	public void tf(long... b)\n	{\n		if(INPUT.length() != 0) {\n			for (long x : b) {\n				for (int i = 0; i < 64; i++) {\n					System.out.print(x << ~i < 0 ? '#' : '.');\n				}\n			}\n			System.out.println();\n		}\n	}\n\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","dfs and similar,graphs,greedy,shortest paths"
"import java.util.*;\npublic class Practice\n{\n	public static void main(String args[])\n	{\n	Scanner sc=new Scanner(System.in);\n	int t=sc.nextInt();\n	while(t-->0)\n	{\n	 int n=sc.nextInt();\n	 for(int i=0;i<n;i++)\n	 {\n		 for(int j=0;j<n;j++)\n		 {\n			 if(i==j || i==(j+1)%n)\n				 System.out.print(""1 "");\n			 else\n				 System.out.print(""0 "");\n		 }\n		 System.out.println("""");\n	 }\n	}\n    }\n}\n","constructive algorithms,math"
"import java.util.*;\n\npublic class P1436B {\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n\n		int t = in.nextInt();\n\n		while (t-- > 0) {\n			int n = in.nextInt();\n\n			for (int i = 0; i < n; ++i) {\n				for (int j = 0; j < n; ++j) {\n					if (i == j || (i+1) == j || (i == (n-1) && j == 0))\n						System.out.print(""1 "");\n					else\n						System.out.print(""0 "");\n				}\n				System.out.println();\n			}\n		}\n	}\n}\n","constructive algorithms,math"
"import java.util.Scanner;\n\npublic class CR678B {\n	public static void main(String[] args) {\n\n		Scanner s = new Scanner(System.in);\n\n		int t = s.nextInt();\n\n		while (t-- > 0) {\n			int n = s.nextInt();\n			for (int j = 0; j < n; j++) {\n				for (int k = 0; k < n; k++) {\n					if (k == j || k == (j + 1) % n)\n						System.out.println(""1"");\n					else\n						System.out.println(""0"");\n				}\n              System.out.println();\n			}\n			\n		}\n	}\n\n}\n","constructive algorithms,math"
"import java.util.Scanner;\npublic class asdasdasdasdsadasd {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\nScanner s=new Scanner(System.in);\nint t=s.nextInt();\nwhile(t>0) {\n	int n=s.nextInt();\nfor(int i=0;i<n;i++) {\n	for(int j=0;j<n;j++) {\n		if(i==n-1 & j==0) {\n			System.out.print(1+"" "");\n		}\n	else if(i==j || i+1==j) {\n			System.out.print(1+"" "");\n		}else {\n			System.out.print(0+"" "");\n		}\n	}\n	System.out.println();\n}\n\n	t--;\n	}\n}}","constructive algorithms,math"
import java.util.*;\n \npublic class p1422a {\npublic static void main(String[] args) {\n	 Scanner s=new Scanner(System.in);\n	 int t=s.nextInt();\n	 while(t--!=0)\n	 {\n	long a=s.nextLong();\n	long b=s.nextLong();\n	long c=s.nextLong();\n	System.out.println((a+b+c)-1);\n	 }\n		\n	}\n},"geometry,math"
import java.util.*;\n \npublic class p1422a {\npublic static void main(String[] args) {\n	 Scanner s=new Scanner(System.in);\n	 int t=s.nextInt();\n	 while(t--!=0)\n	 {\n	long a=s.nextLong();\n	long b=s.nextLong();\n	long c=s.nextLong();\n	System.out.println((a+b+c)-1);\n	 }\n		\n	}\n},"geometry,math"
import java.util.Scanner;\npublic class ContestB {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n\n		int t= sc.nextInt();\n		while(t--!=0) {\n\n		long sum=sc.nextLong()+sc.nextLong()+sc.nextLong();\n		System.out.println(sum-1);\n		}\n		sc.close();\n	}\n\n},"geometry,math"
import java.util.*;\n\n\npublic class cp{\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n\n		int t = sc.nextInt();\n\n		while(t-->0)\n		{\n			long a = sc.nextLong();\n		long b = sc.nextLong();\n		long c = sc.nextLong();\n\n		System.out.println(a+b+c-1);\n		}\n	}\n},"geometry,math"
"import java.util.*;\npublic class SageBirthday {\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n,x,y;\n		n=sc.nextInt();\n		int[] arr = new int[n];\n		for(int i=0;i<n;i++)\n			arr[i]=sc.nextInt();\n		Arrays.sort(arr);\n		int cnt=0;\n		System.out.println((n-1)/2);\n		x=0;y=n-1;\n		while(x<=y)\n		{\n			if(cnt==0)\n			{\n				System.out.print(arr[y]+"" "");--y;cnt=1;\n			}\n			else\n			{\n				System.out.print(arr[x]+"" "");++x;cnt=0;\n			}\n		}\n		\n		sc.close();\n	}\n}","binary search,constructive algorithms,greedy,sortings"
"import java.util.*;\npublic class Yo {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		  int n=sc.nextInt();\n		  int arr[]=new int[n];\n		  for(int i=0;i<n;i++)\n		  {\n			  arr[i]=sc.nextInt();\n		  }\n		  Arrays.sort(arr);\n		  if(n%2==0)\n			  System.out.println(n/2-1);\n		  else\n			  System.out.println(n/2);\n         \n		 int k=n/2;\n         int j=0;\n		   for(int i=0;i<n;i++)\n		   {\n			 if(i%2==0)\n				 System.out.print(arr[k++]+"" "");\n			 else\n				 System.out.print(arr[j++]+"" "");\n			   \n		   }\n\n\n	}\n\n}\n\n","binary search,constructive algorithms,greedy,sortings"
"import java.util.*;\n\npublic class GFG {\n    \n	public static void main (String[] args) {\n	    Scanner scn=new Scanner(System.in);\n	    int n=scn.nextInt();\n	    int []arr=new int[n];\n	    \n	    for(int i=0;i<n;i++){\n	        arr[i]=scn.nextInt();\n	    }\n	    \n	    Arrays.sort(arr);\n	    \n	    int count=(n-1)/2;\n	    \n	    System.out.println(count);\n	    int j=n/2;\n    	int k=0;\n    	for(int i=0;i<n;i++){\n    	    if(i%2==0)\n    	        System.out.print(arr[j++] + "" "");\n    	    else\n    	        System.out.print(arr[k++] + "" "");\n    	}\n    	}\n}","binary search,constructive algorithms,greedy,sortings"
"import java.util.*;\npublic class SagesBirthday {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		  int n=sc.nextInt();\n		  int arr[]=new int[n];\n		  for(int i=0;i<n;i++)\n		  {\n			  arr[i]=sc.nextInt();\n		  }\n		  Arrays.sort(arr);\n		  if(n%2==0)\n			  System.out.println(n/2-1);\n		  else\n			  System.out.println(n/2);\n         \n		 int k=n/2;\n         int j=0;\n		   for(int i=0;i<n;i++)\n		   {\n			 if(i%2==0)\n				 System.out.print(arr[k++]+"" "");\n			 else\n				 System.out.print(arr[j++]+"" "");\n			   \n		   }\n\n\n	}\n\n}\n\n","binary search,constructive algorithms,greedy,sortings"
import java.util.*;\nimport java.io.*;\n\npublic class GFG {\n	public static void main (String[] args) {\n	Scanner sc=new Scanner(System.in);\n	int t=sc.nextInt();while(t!=0){\n	  int n=sc.nextInt();String s=sc.next(); int ans=0;\n	  if(n==1){if(Integer.parseInt(s)%2==0) ans=2; else ans=1;}\n	else  if(n%2==0) {int a[]=new int[n];\n	  for(int i=0;i<n;i++){char c=s.charAt(i);if(i%2==1&&c%2==0)\n	  \n	  {ans=2;break;}}\n	      if(ans!=2) ans=1;\n	  }\n	  else \n	  {\n	  for(int i=0;i<n;i++){char c=s.charAt(i);if(i%2==0&&c%2==1)  {ans=1;break;}}\n	      if(ans!=1) ans=2;\n	  }\n	  System.out.println(ans);t--;}\n	\n	\n\n	    \n\n	    \n	\n	}\n},"games,greedy,implementation"
"//package cf671;\n\nimport java.util.*;\n\npublic class a {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner sc=new Scanner(System.in);\n		int T=sc.nextInt();\n		while(T-->0)\n		{\n			int n=sc.nextInt();\n			String s=sc.next();\n			boolean mybool=false;\n			if(n%2==1)\n			{\n				for(int i=0;i<s.length();i+=2)\n					if((s.charAt(i)-'0')%2==1)mybool=true;\n			}\n			\n			if(s.length()%2==0)\n			{\n				boolean all=true;\n				for(int i=1;i<s.length();i+=2)\n					if((s.charAt(i)-'0')%2==0)all=false;\n				if(all)mybool=true;\n			}\n			System.out.println(mybool?""1"":""2"");\n		}\n	}\n\n}\n","games,greedy,implementation"
"import java.util.*;\npublic class MAIN1 {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0) {\n			int n=sc.nextInt();\n			sc.nextLine();\n			String s=sc.nextLine();\n			solution(n,s);\n		}\n    }\n	public static void solution(int n,String s) {\n		if(n%2==0) {\n			for(int i=1;i<n;i+=2) {\n				if(s.charAt(i)%2==0) {\n					System.out.println(2);\n					return;\n				}\n			}\n			System.out.println(1);\n		}\n		else {\n			for(int i=0;i<n;i+=2) {\n				if(s.charAt(i)%2!=0) {\n					System.out.println(1);\n					return;\n				}\n			}\n			System.out.println(2);\n		}\n	}\n}\n","games,greedy,implementation"
"import java.util.*;\npublic class DigitGame {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0) {\n			int n=sc.nextInt();\n			String a=sc.next();\n			if(n%2==0) {\n				for(int i=1;i<n;i+=2) {\n					if((a.charAt(i)-'0')%2==0) {\n						System.out.println(""2"");\n						break;\n					}\n					if(i==n-1) {\n						System.out.println(""1"");\n					}\n				}\n			}\n			else {\n				for(int i=0;i<n;i+=2) {\n					if((a.charAt(i)-'0')%2!=0) {\n						System.out.println(""1"");\n						break;\n					}\n					if(i==n-1) {\n						System.out.println(""2"");\n					}\n				}\n			}\n		}\n\n	}\n\n}\n","games,greedy,implementation"
"import java.util.*;\nimport java.math.*;\n\n// enum\n\npublic class B{\n	public static void main(String[] args){\n		Scanner in = new Scanner(System.in);\n\n		int t = in.nextInt();\n		\n 		for(int q = 0; q < t; q++){\n			int n = in.nextInt();\n			int[] arr = new int[n];\n			long r = 0;\n			for(int i = 0; i < n; i++){\n				arr[i] = in.nextInt();\n				r += arr[i];\n			}\n\n			if(r % n != 0){\n				System.out.println(""-1"");\n				continue;\n			}\n			long cnt = 0;\n			String s = """";\n			for(int i = 1; i < n; i++){\n				if(arr[i] % (i + 1) != 0){\n					int temp = (i + 1) - (arr[i] % (i + 1));\n					s += ""1 "" + (i + 1) + "" "" + temp + ""\n"";\n					arr[i] += temp;\n					cnt++;\n				}\n				cnt++;\n				int res = arr[i] / (i + 1);\n				s += (i + 1) + "" 1 ""+ res + ""\n"";\n			}	\n			System.out.print(cnt + n - 1 + ""\n"" + s);\n			for(int i = 1; i < n; i++){\n				System.out.println(""1 "" + (i + 1) + "" "" + r / n);\n			}\n		}	\n		\n	}\n\n	\n}","constructive algorithms,greedy,math"
"import java.io.*;\nimport java.util.*;\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n \n/* Name of the class has to be ""Main"" only if the class is public. */\npublic class Rating{\n	public static Scanner in=new Scanner(System.in);\n	public static void main (String[] args) throws java.lang.Exception{\n		int T_T=in.nextInt();\n		while(T_T-->0) {\n			int n=in.nextInt(),sum=0,ans=2*n-2;\n			int a[]=new int[n+1];\n			for(int i=1;i<=n;++i) {\n				a[i]=in.nextInt();\n				sum+=a[i];\n			}\n			if(sum%n!=0) {\n				System.out.println(""-1"");\n				continue;\n			}\n			for(int i=2;i<=n;++i)if(a[i]%i!=0)++ans;\n			System.out.println(ans);\n			for(int i=2,x;i<=n;++i) {\n				if(a[i]%i!=0) {\n					System.out.println(1+"" ""+i+"" ""+(x=i-a[i]%i));\n					a[i]+=x;a[1]-=x;\n				}\n				System.out.println(i+"" ""+1+"" ""+(a[i]/i));\n				a[1]+=a[i];a[i]=0;\n			}\n			for(int i=2;i<=n;++i)System.out.println(1+"" ""+i+"" ""+a[1]/n);\n		}\n	}\n}","constructive algorithms,greedy,math"
"// upsolve with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1417D extends PrintWriter {\n	CF1417D() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1417D o = new CF1417D(); o.main(); o.flush();\n	}\n\n	int[] aa, ii, jj, xx; int k = 0;\n	void move(int i, int j, int x) {\n		ii[k] = i; jj[k] = j; xx[k] = x; k++;\n		aa[i] -= x * i; aa[j] += x * i;\n	}\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			aa = new int[n + 1];\n			ii = new int[n * 3]; jj = new int[n * 3]; xx = new int[n * 3];\n			int a = 0;\n			for (int i = 1; i <= n; i++)\n				a += aa[i] = sc.nextInt();\n			if (a % n != 0) {\n				println(-1);\n				continue;\n			}\n			a /= n;\n			k = 0;\n			for (int i = 2; i <= n; i++) {\n				int r = aa[i] % i;\n				if (r > 0)\n					move(1, i, i - r);\n				move(i, 1, aa[i] / i);\n			}\n			for (int i = 2; i <= n; i++)\n				move(1, i, a);\n			println(k);\n			for (int h = 0; h < k; h++)\n				println(ii[h] + "" "" + jj[h] + "" "" + xx[h]);\n		}\n	}\n}\n","constructive algorithms,greedy,math"
"\nimport java.util.Scanner;\n\npublic class Codeforces1417D {\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		\n		for(int tt =0 ; tt < t ;tt++) {\n			StringBuilder sb = new StringBuilder();\n			int n = sc.nextInt() ;\n			long a[] = new long[n+ 1];\n			long sum = 0;\n			for(int i = 1 ; i <= n ; i++) {\n				a[i] = sc.nextLong();\n				sum += a[i];\n			}\n			\n			if(sum % n != 0) {\n				System.out.println(-1);\n				continue;\n			}\n			long count = 0;\n			for(int i =2 ; i <= n ; i++) {\n				 long remainder = a[i] % i;\n				 long toAdd = i - remainder == i?0:i- remainder;\n				 if(toAdd != 0) {\n					 String s = ""1 ""+ i + "" "" + toAdd;\n				 sb.append(s+ ""\n"");\n				 count++;\n				 }\n				 String y = i+ "" 1 "" + ((a[i] + toAdd )/ i);\n				 sb.append(y+""\n"");\n				 count++;\n			}\n			\n			long ans = sum/n;\n			for(int i = 2 ; i <= n ; i++) {\n				String s = ""1 "" + (i ) + "" ""+ans;\n				count++;\n				sb.append(s+""\n"");\n			}\n			System.out.println(count);\n			System.out.println(sb);\n		\n		}\n		\n		sc.close();\n	}\n	\n}","constructive algorithms,greedy,math"
"import java.util.Scanner;\n\npublic class p1408A {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		for (int t = sc.nextInt(); t-- > 0;) {\n			int n = sc.nextInt(), a[][] = new int[3][n];\n			for (int i = 0; i < 3; i++)\n				for (int j = 0; j < n; j++)\n					a[i][j] = sc.nextInt();\n			int i = 0, x = -1;\n			for (int j = 0; j < n - 1; j++) {\n				if (a[i][j] == x) if (i < 2) i++; else i = 0;\n				x = a[i][j];\n				System.out.print(x + "" "");\n			} i=0;\n			if(a[i][n-1]==x) if(a[i+1][n-1]==a[i][i]) i=2; else i=1;\n			else if(a[i][n-1]==a[i][i]) if(a[i+1][n-1]==x) i=2; else i=1;\n			System.out.println(a[i][n-1]);\n		}\n	}\n}",constructive algorithms
"import java.util.Scanner;\n\npublic class Contest1A {\n\n	public static void main(String[] args) {\n	\n		Scanner sc = new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t--!=0) {\n			int n= sc.nextInt();\n			int[] a= new int[n],b= new int[n],c= new int[n],p= new int[n];\n			for(int i=0;i<n;i++)a[i]=sc.nextInt();\n			for(int i=0;i<n;i++)b[i]=sc.nextInt();\n			for(int i=0;i<n;i++)c[i]=sc.nextInt();\n		\n		for(int i=0;i<n;i++) {\n			if(i==0) p[i]=a[i];\n			else if(i!=n-1)p[i]=(p[i-1]==b[i])?((p[i-1]==c[i])?a[i]:c[i]):b[i];\n			else p[i]=(p[i-1]==b[i]||p[0]==b[i])?((p[i-1]==c[i]||p[0]==c[i])?a[i]:c[i]):b[i];\n			\n		}\n		\n	for(int i=0;i<n;i++) \n		{if(i!=n-1)System.out.print(p[i]+"" "");\n		else System.out.print(p[i]);\n			}\n		System.out.println();}\n\n	sc.close();}\n\n}\n",constructive algorithms
"import java.util.*;\npublic class CircleColoring {\n	\n	\n	static int[] getSequence(int[][] a,int n) {\n		int a0=0;\n		int[] p=new int[n];\n		p[0]=a[0][0];\n		for(int z=1;z<n;z++) {\n			for(int q=0;q<3;q++) {\n				if(z==(n-1)) {\n					if(a[q][z]!=p[z-1] && a[q][z]!=p[0]) {\n						p[z]=a[q][z];\n						break;\n					}\n				} else {\n					if(a[q][z]!=p[z-1]) {\n						p[z]=a[q][z];\n						break;\n					}					\n				}\n			}\n		}\n		return p;\n	}\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		for(int i=0;i<t;i++) {\n			int n=sc.nextInt();\n			int[][] a=new int[3][n];\n			for(int j=0;j<3;j++) {\n				for(int k=0;k<n;k++) {\n					a[j][k]=sc.nextInt();\n				}\n			}\n			int[] p=getSequence(a,n);\n			for(int s=0;s<n;s++) {\n				System.out.print(p[s]+"" "");\n			}\n		}\n	}\n\n}\n",constructive algorithms
"import java.util.*;\nimport java.io.*;\npublic class p1 {\n\n	\n	public static void main(String[] args) {\n		int i,j,k,n,t,l;\n		Scanner ob=new Scanner(System.in);\n		t=ob.nextInt();\n		while(t-- >0)\n		{\n			n=ob.nextInt();\n			int arr[][]=new int[3][n];\n			int op[]=new int[n];\n			for(i=0;i<3;i++)\n			{\n				for(j=0;j<n;j++)\n				{\n					arr[i][j]=ob.nextInt();\n				}\n			}\n			op[0]=arr[0][0];\n			for(i=1;i<n-1;i++)\n			{\n				if(arr[0][i]!=op[i-1])\n					op[i]=arr[0][i];\n				else\n					if(arr[1][i]!=op[i-1])\n						op[i]=arr[1][i];\n				else\n					op[i]=arr[2][i];\n			}\n			if(arr[0][i]!=op[i-1] && arr[0][i]!=op[0])\n				op[i]=arr[0][i];\n			else\n				if(arr[1][i]!=op[i-1] && arr[1][i]!=op[0])\n					op[i]=arr[1][i];\n			else\n				op[i]=arr[2][i];\n			\n			for(i=0;i<n;i++)\n				System.out.print(op[i]+"" "");\n			System.out.println();\n		}\n\n	}\n\n}\n",constructive algorithms
"import java.util.*;\n\npublic class prac {\n  static Scanner sc = new Scanner(System.in);\n\n  public static void main(String args[]) {\n    int t=sc.nextInt();\n    while(t-->0)\n    {\n      int n=sc.nextInt();\n      long[] a=new long[n];\n      for(int i=0;i<n;i++)\n      a[i]=sc.nextInt();\n      Arrays.sort(a);\n      System.out.println(Math.max(Math.max(a[0]*a[1]*a[2]*a[3]*a[n-1], a[0]*a[1]*a[n-1]*a[n-2]*a[n-3]),a[n-1]*a[n-2]*a[n-3]*a[n-4]*a[n-5] ));\n          }\n}\n}\n","brute force,dp,greedy,implementation,sortings"
"import java.util.*;\n \npublic class test {\n  static Scanner sc = new Scanner(System.in);\n \n  public static void main(String args[]) {\n    int t=sc.nextInt();\n    while(t-->0)\n    {\n      int n=sc.nextInt();\n      long[] a=new long[n];\n      for(int i=0;i<n;i++)\n      a[i]=sc.nextInt();\n      Arrays.sort(a);\n      System.out.println(Math.max(Math.max(a[0]*a[1]*a[2]*a[3]*a[n-1], a[0]*a[1]*a[n-1]*a[n-2]*a[n-3]),a[n-1]*a[n-2]*a[n-3]*a[n-4]*a[n-5] ));\n          }\n}\n}","brute force,dp,greedy,implementation,sortings"
"import java.util.*;\n \npublic class prac {\n  static Scanner sc = new Scanner(System.in);\n \n  public static void main(String args[]) {\n    int t=sc.nextInt();\n    while(t-->0)\n    {\n      int n=sc.nextInt();\n      long[] a=new long[n];\n      for(int i=0;i<n;i++)\n      a[i]=sc.nextInt();\n      Arrays.sort(a);\n      System.out.println(Math.max(Math.max(a[0]*a[1]*a[2]*a[3]*a[n-1], a[0]*a[1]*a[n-1]*a[n-2]*a[n-3]),a[n-1]*a[n-2]*a[n-3]*a[n-4]*a[n-5] ));\n          }\n}\n}","brute force,dp,greedy,implementation,sortings"
"import java.util.*;\n\npublic class prac {\n  static Scanner sc = new Scanner(System.in);\n\n  public static void main(String args[]) {\n    int t=sc.nextInt();\n    while(t-->0)\n    {\n      int n=sc.nextInt();\n      long[] a=new long[n];\n      for(int i=0;i<n;i++)\n      a[i]=sc.nextInt();\n      Arrays.sort(a);\n      System.out.println(Math.max(Math.max(a[0]*a[1]*a[2]*a[3]*a[n-1], a[0]*a[1]*a[n-1]*a[n-2]*a[n-3]),a[n-1]*a[n-2]*a[n-3]*a[n-4]*a[n-5] ));\n          }\n}\n}\n","brute force,dp,greedy,implementation,sortings"
"import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class G {\n    static final boolean RUN_TIMING = false;\n    static char[] inputBuffer = new char[1 << 20];\n    static PushbackReader in = new PushbackReader(new BufferedReader(new InputStreamReader(System.in)), 1 << 20);\n    static PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n    public void go() throws IOException {\n        // in = new PushbackReader(new BufferedReader(new FileReader(new File(""test.txt""))), 1 << 20);\n        // out = new PrintWriter(new FileWriter(new File(""output.txt"")));\n        int n = ipar()+1;\n        int x = ipar();\n        int y = ipar();\n        int[] segments = iapar(n);\n        HashSet<Integer> lengths = getLengths(segments, x);\n        int[] maxDivisor = new int[1000001];\n        Arrays.fill(maxDivisor, -1);\n        for (int l : lengths) {\n            for (int i = (l+y)*2; i < maxDivisor.length; i += (l+y)*2) {\n                maxDivisor[i] = Math.max(maxDivisor[i], (l+y)*2);\n            }\n        }\n        int q = ipar();\n        while (q-- > 0) {\n            int l = ipar();\n            out.print(maxDivisor[l]);\n            out.print("" "");\n        }\n        out.println();\n    }\n\n    public HashSet<Integer> getLengths(int[] segments, int x) {\n        int n = segments.length;\n        int nn = 1;\n        while (nn <= x*2) {\n            nn *= 2;\n        }\n        Complex[] a = new Complex[nn];\n        Complex[] b = new Complex[nn];\n        for (int i = 0; i < nn; i++) {\n            a[i] = new Complex();\n            b[i] = new Complex();\n        }\n        for (int i = 0; i < n; i++) {\n            a[segments[i]].set(1, 0);\n            b[x-segments[i]].set(1, 0);\n        }\n        fft(a, false);\n        fft(b, false);\n        for (int i = 0; i < nn; i++) {\n            a[i].multiply(b[i]);\n        }\n        fft(a, true);\n        HashSet<Integer> lengths = new HashSet<>();\n        for (int i = x+1; i < nn; i++) {\n            if (a[i].a > 0.5) {\n                lengths.add(i-x);\n            }\n        }\n        return lengths;\n    }\n\n    public void fft(Complex[] f, boolean inverse) {\n        int n = f.length;\n        int logn = 0;\n        while ((1 << logn) < n) {\n            logn++;\n        }\n        for (int i = 0; i < n; i++) {\n            int rev = reverse(i, logn);\n            if (i < rev) {\n                Complex temp = f[i];\n                f[i] = f[rev];\n                f[rev] = temp;\n            }\n        }\n        Complex w = new Complex();\n        Complex rot = new Complex();\n        Complex temp  = new Complex();\n        for (int len = 2; len <= n; len *= 2) {\n            double angle = Math.PI * 2 / len * (inverse ? -1 : 1);\n            rot.set(Math.cos(angle), Math.sin(angle));\n            for (int offset = 0; offset < n; offset += len) {\n                w.set(1, 0);\n                for (int i = 0; i < len/2; i++) {\n                    Complex a = f[offset+i];\n                    Complex b = f[offset+i+len/2];\n                    temp.set(w);\n                    temp.multiply(b);\n                    b.set(a);\n                    b.subtract(temp);\n                    a.add(temp);\n                    w.multiply(rot);\n                }\n            }\n        }\n        if (inverse) {\n            for (int i = 0; i < n; i++) {\n                f[i].a /= n;\n                f[i].b /= n;\n            }\n        }\n    }\n\n    public int reverse(int x, int logn) {\n        int rev = 0;\n        while (logn > 0) {\n            rev *= 2;\n            rev += x%2;\n            x /= 2;\n            logn--;\n        }\n        return rev;\n    }\n\n    private class Complex {\n        double a, b;\n\n        public Complex() {}\n\n        public Complex(double a, double b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        public void set(double a, double b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        public void set(Complex other) {\n            a = other.a;\n            b = other.b;\n        }\n\n        public void add(Complex other) {\n            a += other.a;\n            b += other.b;\n        }\n\n        public void subtract(Complex other) {\n            a -= other.a;\n            b -= other.b;\n        }\n\n        public void multiply(Complex other) {\n            double aa = a * other.a - b * other.b;\n            double bb = a * other.b + b * other.a;\n            a = aa;\n            b = bb;\n        }\n\n        public String toString() {\n            return String.format(""(%.3f,%.3f)"", a, b);\n        }\n    }\n\n    public int ipar() throws IOException {\n        return Integer.parseInt(spar());\n    }\n\n    public int[] iapar(int n) throws IOException {\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = ipar();\n        }\n        return arr;\n    }\n\n    public long lpar() throws IOException {\n        return Long.parseLong(spar());\n    }\n\n    public long[] lapar(int n) throws IOException {\n        long[] arr = new long[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = lpar();\n        }\n        return arr;\n    }\n\n    public double dpar() throws IOException {\n        return Double.parseDouble(spar());\n    }\n\n    public String spar() throws IOException {\n        int len = 0;\n        int c;\n        do {\n            c = in.read();\n        } while (Character.isWhitespace(c) && c != -1);\n        if (c == -1) {\n            throw new NoSuchElementException(""Reached EOF"");\n        }\n        do {\n            inputBuffer[len] = (char)c;\n            len++;\n            c = in.read();\n        } while (!Character.isWhitespace(c) && c != -1);\n        while (c != '\n' && Character.isWhitespace(c) && c != -1) {\n            c = in.read();\n        }\n        if (c != -1 && c != '\n') {\n            in.unread(c);\n        }\n        return new String(inputBuffer, 0, len);\n    }\n\n    public String linepar() throws IOException {\n        int len = 0;\n        int c;\n        while ((c = in.read()) != '\n' && c != -1) {\n            if (c == '\r') {\n                continue;\n            }\n            inputBuffer[len] = (char)c;\n            len++;\n        }\n        return new String(inputBuffer, 0, len);\n    }\n\n    public boolean haspar() throws IOException {\n        String line = linepar();\n        if (line.isEmpty()) {\n            return false;\n        }\n        in.unread('\n');\n        in.unread(line.toCharArray());\n        return true;\n    }\n\n    public static void main(String[] args) throws IOException {\n        long time = 0;\n        time -= System.nanoTime();\n        new G().go();\n        time += System.nanoTime();\n        if (RUN_TIMING) {\n            System.out.printf(""%.3f ms%n"", time / 1000000.0);\n        }\n        out.flush();\n        in.close();\n    }\n}\n","bitmasks,fft,math,number theory"
"/**\n * author: derrick20\n * created: 7/1/21 10:19 PM\n */\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class G_RunningCompetitionNTT {\n    static FastScanner sc = new FastScanner();\n    static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        int N = sc.nextInt();\n        sc.nextInt();\n        int h = sc.nextInt();\n        int MAX = (int) 2e5;\n        long[] positive = new long[MAX + 1];\n        long[] negative = new long[MAX + 1];\n        for (int i = 0; i <= N; i++) {\n            int x = sc.nextInt();\n            positive[x] = 1;\n            negative[MAX - x] = 1;\n        }\n        long[] ways = multiplyPolynomials(positive, negative);\n        int Q = sc.nextInt();\n        int[] queries = new int[Q];\n        int[] answers = new int[500000 + 1];\n        for (int i = 0; i < Q; i++) {\n            queries[i] = sc.nextInt();\n        }\n        Arrays.fill(answers, -1);\n        for (int d = h + 1; d <= MAX + h; d++) {\n            for (int m = d; m <= 500000; m += d) {\n                if (ways[MAX + d - h] > 0) {\n                    answers[m] = max(answers[m], d);\n                }\n            }\n        }\n        StringBuilder ans = new StringBuilder();\n        for (int i = 0; i < Q; i++) {\n            int res = answers[queries[i] / 2];\n            ans.append(res == -1 ? -1 : 2 * res).append("" "");\n        }\n        out.println(ans);\n        out.close();\n    }\n\n    static long[] multiplyPolynomials(long[] a, long[] b) {\n        int N = 1;\n        // this forces it to a power of 2 greater than/equal the total length\n        while (N < a.length + b.length) {\n            N <<= 1;\n        }\n        long[] A = new long[N];\n        long[] B = new long[N];\n        System.arraycopy(a, 0, A, 0, a.length);\n        System.arraycopy(b, 0, B, 0, b.length);\n        FastFourierTransform(A, false);\n        FastFourierTransform(B, false);\n        long[] C = new long[N];\n        for (int i = 0; i < N; i++) {\n            C[i] = A[i] * B[i] % mod;\n        }\n        FastFourierTransform(C, true);\n        return C;\n    }\n\n    static void FastFourierTransform(long[] A, boolean inverse) {\n        int N = A.length;\n        // Rearrange via bit-reversal sorting\n        int lg = 0; // highest one bit (since we only use bits under N, a power of two)\n        while ((1 << (lg + 1)) <= N) {\n            lg++;\n        }\n        for (int i = 0; i < N; i++) {\n            int j = reverse(i, lg);\n            if (i < j) {\n                long temp = A[i];\n                A[i] = A[j];\n                A[j] = temp;\n            }\n        }\n        // shift it down to nth roots of unity (remove the extra rotation we don't need)\n        int shift = twoPow / N * (inverse ? -1 : 1);\n        long principal = fastExpo(ROOT, shift);\n        for (int half = 1; half <= N >> 1; half <<= 1) {\n            // solve layer of size 2 * pow by building on the children of size pow\n            int full = half << 1;\n            long fullPrincipal = fastExpo(principal, N / full);\n//        assert(fastExpo(fullPrincipal, half) == mod - 1);\n            for (int block = 0; block < N / full; block++) {\n                int i = block * full;\n                long currRoot = 1; // KEY BUG: start from w^0 = 1\n                for (int j = 0; j < half; j++) {\n                    long even = A[i + j];\n                    long odd = currRoot * A[i + j + half] % mod;\n                    A[i + j] = (even + odd) % mod;\n                    A[i + j + half] = (even - odd + mod) % mod;\n                    currRoot = currRoot * fullPrincipal % mod;\n                }\n            }\n        }\n        if (inverse) {\n            long norm = fastExpo(N, -1);\n            for (int i = 0; i < N; i++) {\n                A[i] = A[i] * norm % mod;\n            }\n        }\n    }\n\n    static int reverse(int i, int lg) {\n        int j = 0;\n        for (int b = 0; b < lg; b++) {\n            if (((1 << b) & i) > 0) {\n                j += 1 << (lg - 1 - b);\n            }\n        }\n        return j;\n    }\n\n    // 2^23*7*17+1\n    static final long mod = 998244353; // 7340033\n\n    //highest power of 2 that is a factor of MOD-1\n    static final int twoPow = 1 << 23; // 20\n\n    // any number such that ROOT^(2^twoPow)=1 & ROOT^(2^(twoPow-1))!=1\n    // 2^(7*17*2^23) === 1, but actually isn't a primitive root (the second\n    // condition above fails. Turns out 3 works though!\n    // So, below is 3^(7*17) mod 998244353.\n    static final int ROOT = 15311432; // 5\n    static final int PRIMITIVE_ROOT = 3;\n\n    static long fastExpo(long x, long k) {\n        long ans = 1;\n        for (k = (k + mod - 1) % (mod - 1); k > 0; k >>= 1, x = x * x % mod) {\n            if ((k & 1) > 0) {\n                ans = ans * x % mod;\n            }\n        }\n        return ans;\n    }\n\n    static class FastScanner {\n        private int BS = 1 << 16;\n        private char NC = (char) 0;\n        private byte[] buf = new byte[BS];\n        private int bId = 0, size = 0;\n        private char c = NC;\n        private double cnt = 1;\n        private BufferedInputStream in;\n\n        public FastScanner() {\n            in = new BufferedInputStream(System.in, BS);\n        }\n\n        public FastScanner(String s) {\n            try {\n                in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n            } catch (Exception e) {\n                in = new BufferedInputStream(System.in, BS);\n            }\n        }\n\n        char getChar() {\n            while (bId == size) {\n                try {\n                    size = in.read(buf);\n                } catch (Exception e) {\n                    return NC;\n                }\n                if (size == -1) return NC;\n                bId = 0;\n            }\n            return (char) buf[bId++];\n        }\n\n        int nextInt() {\n            return (int) nextLong();\n        }\n\n        long nextLong() {\n            cnt = 1;\n            boolean neg = false;\n            if (c == NC) c = getChar();\n            for (; (c < '0' || c > '9'); c = getChar()) {\n                if (c == '-') neg = true;\n            }\n            long res = 0;\n            for (; c >= '0' && c <= '9'; c = getChar()) {\n                res = (res << 3) + (res << 1) + c - '0';\n                cnt *= 10;\n            }\n            return neg ? -res : res;\n        }\n\n        double nextDouble() {\n            boolean neg = false;\n            if (c == NC) c = getChar();\n            for (; (c < '0' || c > '9'); c = getChar()) {\n                if (c == '-') neg = true;\n            }\n            double cur = nextLong();\n            if (c != '.') {\n                return neg ? -cur : cur;\n            } else {\n                double frac = nextLong() / cnt;\n                return neg ? -cur - frac : cur + frac;\n            }\n        }\n\n        String next() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c > 32) {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n\n        String nextLine() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c != '\n') {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n\n        boolean hasNext() {\n            if (c > 32) return true;\n            while (true) {\n                c = getChar();\n                if (c == NC) return false;\n                else if (c > 32) return true;\n            }\n        }\n    }\n\n    static void ASSERT(boolean assertion, String message) {\n        if (!assertion) throw new AssertionError(message);\n    }\n\n    static void ASSERT(boolean assertion) {\n        if (!assertion) throw new AssertionError();\n    }\n}","bitmasks,fft,math,number theory"
"//package ecr93;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Random;\n\npublic class G {\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n	\n	void solve()\n	{\n		int n = ni(), x = ni(), y = ni();\n		int[] a = na(n+1);\n		Random gen = new Random();\n		long[] f = new long[x+1];\n		int mod = 998244353;\n		for(int v : a){\n			f[v] = gen.nextInt(mod);\n		}\n		long[] fi = rev(f);\n		long[] ff = convoluteSimply(f, fi, mod, 3);\n		int[] valid = new int[1000001];\n		Arrays.fill(valid, -1);\n		for(int i = 0;i < x;i++){\n			if(ff[i] != 0){\n				int w = x-i;\n				for(int t = 2*w+2*y;t < valid.length;t+=2*w+2*y){\n					valid[t] = Math.max(valid[t], 2*w+2*y);\n				}\n			}\n		}\n		for(int Q = ni();Q > 0;Q--){\n			out.print(valid[ni()] + "" "");\n		}\n	}\n	\n	public static long[] rev(long[] a){long[] b = new long[a.length];for(int i = 0;i < a.length;i++)b[a.length-1-i] = a[i];return b;}\n\n	\n	public static final int[] NTTPrimes = {1053818881, 1051721729, 1045430273, 1012924417, 1007681537, 1004535809, 998244353, 985661441, 976224257, 975175681};\n	public static final int[] NTTPrimitiveRoots = {7, 6, 3, 5, 3, 3, 3, 3, 3, 17};\n//	public static final int[] NTTPrimes = {1012924417, 1004535809, 998244353, 985661441, 975175681, 962592769, 950009857, 943718401, 935329793, 924844033};\n//	public static final int[] NTTPrimitiveRoots = {5, 3, 3, 3, 17, 7, 7, 7, 3, 5};\n	\n	public static long[] convoluteSimply(long[] a, long[] b, int P, int g)\n	{\n		int m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n		long[] fa = nttmb(a, m, false, P, g);\n		long[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n		for(int i = 0;i < m;i++){\n			fa[i] = fa[i]*fb[i]%P;\n		}\n		return nttmb(fa, m, true, P, g);\n	}\n	\n	public static long[] convolute(long[] a, long[] b)\n	{\n		int USE = 2;\n		int m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n		long[][] fs = new long[USE][];\n		for(int k = 0;k < USE;k++){\n			int P = NTTPrimes[k], g = NTTPrimitiveRoots[k];\n			long[] fa = nttmb(a, m, false, P, g);\n			long[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n			for(int i = 0;i < m;i++){\n				fa[i] = fa[i]*fb[i]%P;\n			}\n			fs[k] = nttmb(fa, m, true, P, g);\n		}\n		\n		int[] mods = Arrays.copyOf(NTTPrimes, USE);\n		long[] gammas = garnerPrepare(mods);\n		int[] buf = new int[USE];\n		for(int i = 0;i < fs[0].length;i++){\n			for(int j = 0;j < USE;j++)buf[j] = (int)fs[j][i];\n			long[] res = garnerBatch(buf, mods, gammas);\n			long ret = 0;\n			for(int j = res.length-1;j >= 0;j--)ret = ret * mods[j] + res[j];\n			fs[0][i] = ret;\n		}\n		return fs[0];\n	}\n	\n	public static long[] convolute(long[] a, long[] b, int USE, int mod)\n	{\n		int m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n		long[][] fs = new long[USE][];\n		for(int k = 0;k < USE;k++){\n			int P = NTTPrimes[k], g = NTTPrimitiveRoots[k];\n			long[] fa = nttmb(a, m, false, P, g);\n			long[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n			for(int i = 0;i < m;i++){\n				fa[i] = fa[i]*fb[i]%P;\n			}\n			fs[k] = nttmb(fa, m, true, P, g);\n		}\n		\n		int[] mods = Arrays.copyOf(NTTPrimes, USE);\n		long[] gammas = garnerPrepare(mods);\n		int[] buf = new int[USE];\n		for(int i = 0;i < fs[0].length;i++){\n			for(int j = 0;j < USE;j++)buf[j] = (int)fs[j][i];\n			long[] res = garnerBatch(buf, mods, gammas);\n			long ret = 0;\n			for(int j = res.length-1;j >= 0;j--)ret = (ret * mods[j] + res[j]) % mod;\n			fs[0][i] = ret;\n		}\n		return fs[0];\n	}\n	\n	// static int[] wws = new int[270000]; // outer faster\n	\n	// Modifed Montgomery + Barrett\n	private static long[] nttmb(long[] src, int n, boolean inverse, int P, int g)\n	{\n		long[] dst = Arrays.copyOf(src, n);\n		\n		int h = Integer.numberOfTrailingZeros(n);\n		long K = Integer.highestOneBit(P)<<1;\n		int H = Long.numberOfTrailingZeros(K)*2;\n		long M = K*K/P;\n		\n		int[] wws = new int[1<<h-1];\n		long dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);\n		long w = (1L<<32)%P;\n		for(int k = 0;k < 1<<h-1;k++){\n			wws[k] = (int)w;\n			w = modh(w*dw, M, H, P);\n		}\n		long J = invl(P, 1L<<32);\n		for(int i = 0;i < h;i++){\n			for(int j = 0;j < 1<<i;j++){\n				for(int k = 0, s = j<<h-i, t = s|1<<h-i-1;k < 1<<h-i-1;k++,s++,t++){\n					long u = (dst[s] - dst[t] + 2*P)*wws[k];\n					dst[s] += dst[t];\n					if(dst[s] >= 2*P)dst[s] -= 2*P;\n//					long Q = (u&(1L<<32)-1)*J&(1L<<32)-1;\n					long Q = (u<<32)*J>>>32;\n					dst[t] = (u>>>32)-(Q*P>>>32)+P;\n				}\n			}\n			if(i < h-1){\n				for(int k = 0;k < 1<<h-i-2;k++)wws[k] = wws[k*2];\n			}\n		}\n		for(int i = 0;i < n;i++){\n			if(dst[i] >= P)dst[i] -= P;\n		}\n		for(int i = 0;i < n;i++){\n			int rev = Integer.reverse(i)>>>-h;\n			if(i < rev){\n				long d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;\n			}\n		}\n		\n		if(inverse){\n			long in = invl(n, P);\n			for(int i = 0;i < n;i++)dst[i] = modh(dst[i]*in, M, H, P);\n		}\n		\n		return dst;\n	}\n	\n	// Modified Shoup + Barrett\n	private static long[] nttsb(long[] src, int n, boolean inverse, int P, int g)\n	{\n		long[] dst = Arrays.copyOf(src, n);\n		\n		int h = Integer.numberOfTrailingZeros(n);\n		long K = Integer.highestOneBit(P)<<1;\n		int H = Long.numberOfTrailingZeros(K)*2;\n		long M = K*K/P;\n		\n		long dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);\n		long[] wws = new long[1<<h-1];\n		long[] ws = new long[1<<h-1];\n		long w = 1;\n		for(int k = 0;k < 1<<h-1;k++){\n			wws[k] = (w<<32)/P;\n			ws[k] = w;\n			w = modh(w*dw, M, H, P);\n		}\n		for(int i = 0;i < h;i++){\n			for(int j = 0;j < 1<<i;j++){\n				for(int k = 0, s = j<<h-i, t = s|1<<h-i-1;k < 1<<h-i-1;k++,s++,t++){\n					long ndsts = dst[s] + dst[t];\n					if(ndsts >= 2*P)ndsts -= 2*P;\n					long T = dst[s] - dst[t] + 2*P;\n					long Q = wws[k]*T>>>32;\n					dst[s] = ndsts;\n					dst[t] = ws[k]*T-Q*P&(1L<<32)-1;\n				}\n			}\n//			dw = dw * dw % P;\n			if(i < h-1){\n				for(int k = 0;k < 1<<h-i-2;k++){\n					wws[k] = wws[k*2];\n					ws[k] = ws[k*2];\n				}\n			}\n		}\n		for(int i = 0;i < n;i++){\n			if(dst[i] >= P)dst[i] -= P;\n		}\n		for(int i = 0;i < n;i++){\n			int rev = Integer.reverse(i)>>>-h;\n			if(i < rev){\n				long d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;\n			}\n		}\n		\n		if(inverse){\n			long in = invl(n, P);\n			for(int i = 0;i < n;i++){\n				dst[i] = modh(dst[i] * in, M, H, P);\n			}\n		}\n		\n		return dst;\n	}\n	\n	static final long mask = (1L<<31)-1;\n	\n	public static long modh(long a, long M, int h, int mod)\n	{\n		long r = a-((M*(a&mask)>>>31)+M*(a>>>31)>>>h-31)*mod;\n		return r < mod ? r : r-mod;\n	}\n	\n	private static long[] garnerPrepare(int[] m)\n	{\n		int n = m.length;\n		assert n == m.length;\n		if(n == 0)return new long[0];\n		long[] gamma = new long[n];\n		for(int k = 1;k < n;k++){\n			long prod = 1;\n			for(int i = 0;i < k;i++){\n				prod = prod * m[i] % m[k];\n			}\n			gamma[k] = invl(prod, m[k]);\n		}\n		return gamma;\n	}\n	\n	private static long[] garnerBatch(int[] u, int[] m, long[] gamma)\n	{\n		int n = u.length;\n		assert n == m.length;\n		long[] v = new long[n];\n		v[0] = u[0];\n		for(int k = 1;k < n;k++){\n			long temp = v[k-1];\n			for(int j = k-2;j >= 0;j--){\n				temp = (temp * m[j] + v[j]) % m[k];\n			}\n			v[k] = (u[k] - temp) * gamma[k] % m[k];\n			if(v[k] < 0)v[k] += m[k];\n		}\n		return v;\n	}\n	\n	private static long pow(long a, long n, long mod) {\n		//		a %= mod;\n		long ret = 1;\n		int x = 63 - Long.numberOfLeadingZeros(n);\n		for (; x >= 0; x--) {\n			ret = ret * ret % mod;\n			if (n << 63 - x < 0)\n				ret = ret * a % mod;\n		}\n		return ret;\n	}\n	\n	private static long invl(long a, long mod) {\n		long b = mod;\n		long p = 1, q = 0;\n		while (b > 0) {\n			long c = a / b;\n			long d;\n			d = a;\n			a = b;\n			b = d % b;\n			d = p;\n			p = q;\n			q = d - c * q;\n		}\n		return p < 0 ? p + mod : p;\n	}\n\n	\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new G().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n	\n	private char[][] nm(int n, int m)\n	{\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n	\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n	\n	private int ni()\n	{\n		int num = 0, b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","bitmasks,fft,math,number theory"
"import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main\n{\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n\n	public static final int[] NTTPrimes = {1053818881, 1051721729, 1045430273, 1012924417, 1007681537, 1004535809, 998244353, 985661441, 976224257, 975175681};\n	public static final int[] NTTPrimitiveRoots = {7, 6, 3, 5, 3, 3, 3, 3, 3, 17};\n//	public static final int[] NTTPrimes = {1012924417, 1004535809, 998244353, 985661441, 975175681, 962592769, 950009857, 943718401, 935329793, 924844033};\n//	public static final int[] NTTPrimitiveRoots = {5, 3, 3, 3, 17, 7, 7, 7, 3, 5};\n	\n	public static long[] convoluteSimply(long[] a, long[] b, int P, int g)\n	{\n		int m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n		long[] fa = nttmb(a, m, false, P, g);\n		long[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n		for(int i = 0;i < m;i++){\n			fa[i] = fa[i]*fb[i]%P;\n		}\n		return nttmb(fa, m, true, P, g);\n	}\n	\n	public static long[] convolute(long[] a, long[] b)\n	{\n		int USE = 2;\n		int m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n		long[][] fs = new long[USE][];\n		for(int k = 0;k < USE;k++){\n			int P = NTTPrimes[k], g = NTTPrimitiveRoots[k];\n			long[] fa = nttmb(a, m, false, P, g);\n			long[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n			for(int i = 0;i < m;i++){\n				fa[i] = fa[i]*fb[i]%P;\n			}\n			fs[k] = nttmb(fa, m, true, P, g);\n		}\n		\n		int[] mods = Arrays.copyOf(NTTPrimes, USE);\n		long[] gammas = garnerPrepare(mods);\n		int[] buf = new int[USE];\n		for(int i = 0;i < fs[0].length;i++){\n			for(int j = 0;j < USE;j++)buf[j] = (int)fs[j][i];\n			long[] res = garnerBatch(buf, mods, gammas);\n			long ret = 0;\n			for(int j = res.length-1;j >= 0;j--)ret = ret * mods[j] + res[j];\n			fs[0][i] = ret;\n		}\n		return fs[0];\n	}\n	\n	public static long[] convolute(long[] a, long[] b, int USE, int mod)\n	{\n		int m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n		long[][] fs = new long[USE][];\n		for(int k = 0;k < USE;k++){\n			int P = NTTPrimes[k], g = NTTPrimitiveRoots[k];\n			long[] fa = nttmb(a, m, false, P, g);\n			long[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n			for(int i = 0;i < m;i++){\n				fa[i] = fa[i]*fb[i]%P;\n			}\n			fs[k] = nttmb(fa, m, true, P, g);\n		}\n		\n		int[] mods = Arrays.copyOf(NTTPrimes, USE);\n		long[] gammas = garnerPrepare(mods);\n		int[] buf = new int[USE];\n		for(int i = 0;i < fs[0].length;i++){\n			for(int j = 0;j < USE;j++)buf[j] = (int)fs[j][i];\n			long[] res = garnerBatch(buf, mods, gammas);\n			long ret = 0;\n			for(int j = res.length-1;j >= 0;j--)ret = (ret * mods[j] + res[j]) % mod;\n			fs[0][i] = ret;\n		}\n		return fs[0];\n	}\n	\n	// static int[] wws = new int[270000]; // outer faster\n	\n	// Modifed Montgomery + Barrett\n	private static long[] nttmb(long[] src, int n, boolean inverse, int P, int g)\n	{\n		long[] dst = Arrays.copyOf(src, n);\n		\n		int h = Integer.numberOfTrailingZeros(n);\n		long K = Integer.highestOneBit(P)<<1;\n		int H = Long.numberOfTrailingZeros(K)*2;\n		long M = K*K/P;\n		\n		int[] wws = new int[1<<h-1];\n		long dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);\n		long w = (1L<<32)%P;\n		for(int k = 0;k < 1<<h-1;k++){\n			wws[k] = (int)w;\n			w = modh(w*dw, M, H, P);\n		}\n		long J = invl(P, 1L<<32);\n		for(int i = 0;i < h;i++){\n			for(int j = 0;j < 1<<i;j++){\n				for(int k = 0, s = j<<h-i, t = s|1<<h-i-1;k < 1<<h-i-1;k++,s++,t++){\n					long u = (dst[s] - dst[t] + 2*P)*wws[k];\n					dst[s] += dst[t];\n					if(dst[s] >= 2*P)dst[s] -= 2*P;\n//					long Q = (u&(1L<<32)-1)*J&(1L<<32)-1;\n					long Q = (u<<32)*J>>>32;\n					dst[t] = (u>>>32)-(Q*P>>>32)+P;\n				}\n			}\n			if(i < h-1){\n				for(int k = 0;k < 1<<h-i-2;k++)wws[k] = wws[k*2];\n			}\n		}\n		for(int i = 0;i < n;i++){\n			if(dst[i] >= P)dst[i] -= P;\n		}\n		for(int i = 0;i < n;i++){\n			int rev = Integer.reverse(i)>>>-h;\n			if(i < rev){\n				long d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;\n			}\n		}\n		\n		if(inverse){\n			long in = invl(n, P);\n			for(int i = 0;i < n;i++)dst[i] = modh(dst[i]*in, M, H, P);\n		}\n		\n		return dst;\n	}\n	\n	// Modified Shoup + Barrett\n	private static long[] nttsb(long[] src, int n, boolean inverse, int P, int g)\n	{\n		long[] dst = Arrays.copyOf(src, n);\n		\n		int h = Integer.numberOfTrailingZeros(n);\n		long K = Integer.highestOneBit(P)<<1;\n		int H = Long.numberOfTrailingZeros(K)*2;\n		long M = K*K/P;\n		\n		long dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);\n		long[] wws = new long[1<<h-1];\n		long[] ws = new long[1<<h-1];\n		long w = 1;\n		for(int k = 0;k < 1<<h-1;k++){\n			wws[k] = (w<<32)/P;\n			ws[k] = w;\n			w = modh(w*dw, M, H, P);\n		}\n		for(int i = 0;i < h;i++){\n			for(int j = 0;j < 1<<i;j++){\n				for(int k = 0, s = j<<h-i, t = s|1<<h-i-1;k < 1<<h-i-1;k++,s++,t++){\n					long ndsts = dst[s] + dst[t];\n					if(ndsts >= 2*P)ndsts -= 2*P;\n					long T = dst[s] - dst[t] + 2*P;\n					long Q = wws[k]*T>>>32;\n					dst[s] = ndsts;\n					dst[t] = ws[k]*T-Q*P&(1L<<32)-1;\n				}\n			}\n//			dw = dw * dw % P;\n			if(i < h-1){\n				for(int k = 0;k < 1<<h-i-2;k++){\n					wws[k] = wws[k*2];\n					ws[k] = ws[k*2];\n				}\n			}\n		}\n		for(int i = 0;i < n;i++){\n			if(dst[i] >= P)dst[i] -= P;\n		}\n		for(int i = 0;i < n;i++){\n			int rev = Integer.reverse(i)>>>-h;\n			if(i < rev){\n				long d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;\n			}\n		}\n		\n		if(inverse){\n			long in = invl(n, P);\n			for(int i = 0;i < n;i++){\n				dst[i] = modh(dst[i] * in, M, H, P);\n			}\n		}\n		\n		return dst;\n	}\n	\n	static final long mask = (1L<<31)-1;\n	\n	public static long modh(long a, long M, int h, int mod)\n	{\n		long r = a-((M*(a&mask)>>>31)+M*(a>>>31)>>>h-31)*mod;\n		return r < mod ? r : r-mod;\n	}\n	\n	private static long[] garnerPrepare(int[] m)\n	{\n		int n = m.length;\n		assert n == m.length;\n		if(n == 0)return new long[0];\n		long[] gamma = new long[n];\n		for(int k = 1;k < n;k++){\n			long prod = 1;\n			for(int i = 0;i < k;i++){\n				prod = prod * m[i] % m[k];\n			}\n			gamma[k] = invl(prod, m[k]);\n		}\n		return gamma;\n	}\n	\n	private static long[] garnerBatch(int[] u, int[] m, long[] gamma)\n	{\n		int n = u.length;\n		assert n == m.length;\n		long[] v = new long[n];\n		v[0] = u[0];\n		for(int k = 1;k < n;k++){\n			long temp = v[k-1];\n			for(int j = k-2;j >= 0;j--){\n				temp = (temp * m[j] + v[j]) % m[k];\n			}\n			v[k] = (u[k] - temp) * gamma[k] % m[k];\n			if(v[k] < 0)v[k] += m[k];\n		}\n		return v;\n	}\n	\n	private static long pow(long a, long n, long mod) {\n		//		a %= mod;\n		long ret = 1;\n		int x = 63 - Long.numberOfLeadingZeros(n);\n		for (; x >= 0; x--) {\n			ret = ret * ret % mod;\n			if (n << 63 - x < 0)\n				ret = ret * a % mod;\n		}\n		return ret;\n	}\n	\n	private static long invl(long a, long mod) {\n		long b = mod;\n		long p = 1, q = 0;\n		while (b > 0) {\n			long c = a / b;\n			long d;\n			d = a;\n			a = b;\n			b = d % b;\n			d = p;\n			p = q;\n			q = d - c * q;\n		}\n		return p < 0 ? p + mod : p;\n	}\n\n	void solve()\n	{\n		int n = ni();\n		int x = ni();\n		int y = ni();\n		long[] a = new long[x+1];\n		long[] b = new long[x+1];\n		for (int i = 0; i <= n; ++i)\n		{\n			int p = ni();\n			a[p] = 1;\n			b[x-p] = 1;\n		}\n		int mod = 998244353, g = 3;\n		long[] c = convoluteSimply(a, b, mod, g);\n\n		int N = 500000;\n		int[] res = new int[N+1];\n		for (int i = 0; i <= 2*x; ++i)\n		{\n			if (c[i] == 0) continue;\n			int p = Math.abs(i-x);\n			if (p == 0) continue;\n			if (p+y <= N)\n			{\n				res[p+y] = 1;\n			}\n		}\n		for (int i = N; i >= 1; -- i)\n			if (res[i] == 1)\n			{\n				for (int j = i; j <= N; j += i)\n					res[j] = Math.max(res[j], i);\n			}\n		int q = ni();\n		for (int i = 0; i < q; ++i)\n		{\n			int p = ni()/2;\n			if (res[p] == 0)\n				out.println(-1);\n			else\n				out.println(res[p]*2);\n		}\n	}\n\n	void run()\n	{\n		//is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		is = System.in;\n		out = new PrintWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n\n	public static void main(String[] args) throws Exception\n	{\n		new Thread(null, new Runnable()\n		{\n			public void run()\n			{\n				new Main().run();\n			}\n		}, ""whatever"", 1<<28).start();\n	}\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n	\n	private char[][] nm(int n, int m)\n	{\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n	\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n	\n	private int ni()\n	{\n		int num = 0, b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}","bitmasks,fft,math,number theory"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1396C extends PrintWriter {\n	CF1396C() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1396C o = new CF1396C(); o.main(); o.flush();\n	}\n\n	static final long INF = 0x3f3f3f3f3f3f3f3fL;\n	void main() {\n		int n = sc.nextInt();\n		int r1 = sc.nextInt();\n		int r2 = sc.nextInt();\n		int r3 = sc.nextInt();\n		int d = sc.nextInt();\n		long[] xx = new long[n];\n		long[] yy = new long[n];\n		for (int i = 0; i < n; i++) {\n			long a = sc.nextInt();\n			xx[i] = (r1 * a + r3) + 0;\n			yy[i] = Math.min(r1 * a + r1, r2) + r1;\n			yy[i] = Math.min(yy[i], xx[i]);\n		}\n		long x = xx[0], y = yy[0], dp = x, dq = y, dr = y, dp_, dq_, dr_;\n		for (int i = 1; i < n - 1; i++) {\n			x = xx[i]; y = yy[i];\n			dp_ = Math.min(dp + d + x, dq + d + y + d + d);\n			dq_ = Math.min(dp_, dp + d + y);\n			dr_ = Math.min(dq_, dr + d + y + d);\n			dp = dp_; dq = dq_; dr = dr_;\n		}\n		x = xx[n - 1]; y = yy[n - 1];\n		println(Math.min(Math.min(dp + d + x, dq + d + y + d + d), dr + d + x + d));\n	}\n}\n","dp,greedy,implementation"
"import java.io.*;\nimport java.util.*;\n\npublic class cf1397e{\n	\n	public static void main(String[] args)throws IOException {\n		BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter out=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		StringTokenizer st=new StringTokenizer(bf.readLine());\n		int n=Integer.parseInt(st.nextToken());\n		int r1=Integer.parseInt(st.nextToken());\n		int r2=Integer.parseInt(st.nextToken());\n		int r3=Integer.parseInt(st.nextToken());\n		int d=Integer.parseInt(st.nextToken());\n		st=new StringTokenizer(bf.readLine());\n		long[] a=new long[n];\n		for(int i=0;i<n;i++) {\n			a[i]=Integer.parseInt(st.nextToken());\n		}\n		long[][] dp=new long[n][2];\n		dp[0][0]=a[0]*r1+r3;\n		dp[0][1]=Math.min(r2, (a[0]+1)*r1);\n		for(int i=1;i<n;i++) {\n			dp[i][0]=dp[i-1][0]+d+a[i]*r1+r3;\n			dp[i][0]=Math.min(dp[i][0], dp[i-1][1]+d+Math.min(r2, (a[i]+1)*r1)+d+r1+d+r1);\n			dp[i][0]=Math.min(dp[i][0], dp[i-1][1]+d+a[i]*r1+r3+d+r1+d);\n			dp[i][1]=dp[i-1][0]+d+Math.min(r2, (a[i]+1)*r1);\n			dp[i][1]=Math.min(dp[i][1], dp[i-1][1]+d+Math.min(r2, (a[i]+1)*r1)+d+r1+d);\n			if(i==n-1) {\n				dp[i][0]=Math.min(dp[i][0], dp[i-1][1]+d+a[i]*r1+r3+d+r1);\n			}\n		}\n		out.println(dp[n-1][0]);\n		out.close();\n	}\n}","dp,greedy,implementation"
"import java.io.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    void solve(FastScanner in, PrintWriter out) {\n        int n = in.nextInt(), r1 = in.nextInt(), r2 = in.nextInt(), r3 = in.nextInt(), d = in.nextInt();\n        long[] b = new long[n];\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            int value = in.nextInt();\n            b[i] = (long) r1 * value + r3;\n            res[i] = Math.min(b[i], Math.min((long) r1 * (value + 1), r2) + r1);\n        }\n        List<Long> dp = new ArrayList<>();\n        dp.add(0L);\n        for (int i = 0; i < n; i++) {\n            long ans = dp.get(i) + b[i] + d;\n            if (i > 0)\n                ans = Math.min(ans, dp.get(i - 1) + res[i - 1] + res[i] + (long) 4 * d);\n            if (i > 1)\n                ans = Math.min(ans, dp.get(i - 2) + res[i - 2] + res[i - 1] + res[i] + (long) d * 7);\n            dp.add(ans);\n        }\n        out.println(Math.min(dp.get(n) - d, dp.get(n - 2) + res[n - 2] + b[n - 1] + d * 2));\n    }\n\n    void run() {\n        try (\n                FastScanner in = new FastScanner(System.in);\n                PrintWriter out = new PrintWriter(System.out)\n        ) {\n            solve(in, out);\n        }\n    }\n\n    static class FastScanner implements AutoCloseable {\n        StreamTokenizer in;\n\n        FastScanner(InputStream in) {\n            this.in = new StreamTokenizer(new InputStreamReader(new BufferedInputStream(in)));\n        }\n\n        int nextInt() {\n            try {\n                in.nextToken();\n                return (int) in.nval;\n            } catch (IOException e) {\n                throw new IOError(e);\n            }\n        }\n\n        @Override\n        public void close() {\n        }\n    }\n}\n","dp,greedy,implementation"
"import java.io.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    void solve(FastScanner in, PrintWriter out) {\n        int n = in.nextInt(),\n                r1 = in.nextInt(), r2 = in.nextInt(), r3 = in.nextInt(),\n                d = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n            a[i] = in.nextInt();\n        long[] b = new long[n];\n        for (int i = 0; i < n; i++)\n            b[i] = (long) r1 * a[i] + r3;\n        long[] c = new long[n];\n        for (int i = 0; i < n; i++)\n            c[i] = Math.min((long) r1 * (a[i] + 1), r2) + r1;\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++)\n            res[i] = Math.min(b[i], c[i]);\n        List<Long> dp = new ArrayList<>();\n        dp.add(0L);\n        for (int i = 0; i < n; i++) {\n            long ans = dp.get(i) + b[i] + d;\n            if (i > 0)\n                ans = Math.min(ans, dp.get(i - 1) + res[i - 1] + res[i] + (long) 4 * d);\n            if (i > 1)\n                ans = Math.min(ans, dp.get(i - 2) + res[i - 2] + res[i - 1] + res[i] + (long) d * 7);\n            dp.add(ans);\n        }\n        out.println(Math.min(dp.get(n) - d, dp.get(n - 2) + res[n - 2] + b[n - 1] + d * 2));\n    }\n\n    void run() {\n        try (\n                FastScanner in = new FastScanner(System.in);\n                PrintWriter out = new PrintWriter(System.out)\n        ) {\n            solve(in, out);\n        }\n    }\n\n    static class FastScanner implements AutoCloseable {\n        StreamTokenizer in;\n\n        FastScanner(InputStream in) {\n            this.in = new StreamTokenizer(new InputStreamReader(new BufferedInputStream(in)));\n        }\n\n        int nextInt() {\n            try {\n                in.nextToken();\n                return (int) in.nval;\n            } catch (IOException e) {\n                throw new IOError(e);\n            }\n        }\n\n        @Override\n        public void close() {\n        }\n    }\n}\n","dp,greedy,implementation"
"import java.util.*;\npublic class Rating {\n	public static Scanner in=new Scanner(System.in); \n	static public void main(String args[]) {\n		int n=in.nextInt();\n		long a[]=new long[n+7];\n		for(int i=1;i<=n;++i)a[i]=in.nextLong();\n		if(n==1) System.out.println(""1 1\n0\n1 1\n0\n1 1\n""+-a[1]);\n		else {\n			System.out.println(""1 ""+n);\n			for(int i=1;i<=n;++i) {\n				System.out.print(-a[i]*n+"" "");\n				a[i]=(1-n)*a[i];\n			}System.out.println("""");\n			System.out.println(""2 ""+n);\n			for(int i=2;i<=n;++i) {\n				System.out.print(-a[i]+"" "");\n			}System.out.println("""");\n			System.out.println(""1 1\n""+-a[1]);\n		}\n	}\n}","constructive algorithms,greedy,number theory"
"import java.util.Scanner;\n\npublic class q3 {\n\n	public static void main(String[] args) {\n		Scanner s=new Scanner(System.in);\n		int n=s.nextInt();\n		long a[]=new long[n];\n		for(int i=0;i<n;i++) {\n			a[i]=s.nextLong();\n		}\n		if(n==1) {\n			System.out.println(""1 1""); \n			System.out.println(""0""); \n			System.out.println(""1 1""); \n			System.out.println(""0""); \n			System.out.println(""1 1""); \n			System.out.println(-a[0]); \n		}else {\n			System.out.println(""1 ""+n); \n			for(int i=0;i<n;i++) {\n				System.out.print(-n*a[i]+"" ""); \n			}\n			System.out.println();\n			System.out.println(""2 ""+n);\n			for(int i=1;i<n;i++) {\n				System.out.print((n-1)*a[i]+"" ""); \n			}\n			System.out.println();\n			System.out.println(""1 1"");\n			System.out.println((n-1)*a[0]);\n		}\n		s.close();\n	}\n\n}\n","constructive algorithms,greedy,number theory"
"import java.util.Scanner;\n \npublic class q3 {\n \n	public static void main(String[] args) {\n		Scanner s=new Scanner(System.in);\n		int n=s.nextInt();\n		long a[]=new long[n];\n		for(int i=0;i<n;i++) {\n			a[i]=s.nextLong();\n		}\n		if(n==1) {\n			System.out.println(""1 1""); \n			System.out.println(""0""); \n			System.out.println(""1 1""); \n			System.out.println(""0""); \n			System.out.println(""1 1""); \n			System.out.println(-a[0]); \n		}else {\n			System.out.println(""1 ""+n); \n			for(int i=0;i<n;i++) {\n				System.out.print(-n*a[i]+"" ""); \n			}\n			System.out.println();\n			System.out.println(""2 ""+n);\n			for(int i=1;i<n;i++) {\n				System.out.print((n-1)*a[i]+"" ""); \n			}\n			System.out.println();\n			System.out.println(""1 1"");\n			System.out.println((n-1)*a[0]);\n		}\n		s.close();\n	}\n \n}","constructive algorithms,greedy,number theory"
"import java.util.*;\npublic class Solution{\n	public static void main(String args[])\n	{\n		Scanner take=new Scanner(System.in);\n		long t;\n		t=1;\n		int i,j,n;\n		while(t--!=0)\n		{	\n			n=take.nextInt();\n			long a[]=new long [n];\n			for(i=0;i<n;i++) a[i]=take.nextLong();\n			if(n>=2)\n			{\n				System.out.println(""1 1"");\n				System.out.println(-1*a[0]);\n				a[0]=0;\n				System.out.println(""2 ""+(n));\n				for(i=1;i<n;i++)\n				{\n					System.out.print(1*a[i]*(n-1)+"" "");\n					a[i]=1*a[i]*n;\n				}\n				//for(i=0;i<n;i++) System.out.print(a[i]+"" "");\n				System.out.println();\n				System.out.println(""1 ""+(n));\n				for(i=0;i<n;i++)\n				{\n					System.out.print(-1*a[i]+"" "");\n				}\n			}\n			if(n==1)\n			{\n				System.out.println(""1 1"");\n				System.out.println(-1*a[0]);\n				System.out.println(""1 1"");\n				System.out.println(""0"");\n				System.out.println(""1 1"");\n				System.out.println(""0"");\n			}\n		}\n	}\n}","constructive algorithms,greedy,number theory"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1384B2 extends PrintWriter {\n	CF1384B2() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1384B2 o = new CF1384B2(); o.main(); o.flush();\n	}\n\n	static final int INF = 0x3f3f3f3f;\n	void main() {\n		int t = sc.nextInt();\nout:\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			int k = sc.nextInt();\n			int m = sc.nextInt();\n			int[] dd = new int[n];\n			for (int i = 0; i < n; i++)\n				dd[i] = sc.nextInt();\n			int[] ll = new int[n];\n			int[] rr = new int[n];\n			for (int i = 0; i < n; i++) {\n				if (dd[i] > m) {\n					println(""No"");\n					continue out;\n				}\n				if (dd[i] + k <= m)\n					ll[i] = rr[i] = INF;\n				else {\n					rr[i] = m - dd[i];\n					ll[i] = -rr[i];\n				}\n			}\n			for (int i = 1; i < n; i++) {\n				if (ll[i - 1] == INF || ll[i] == INF)\n					continue;\n				ll[i] = Math.max(ll[i - 1] + 1, ll[i]);\n				rr[i] = Math.min(rr[i - 1] + 1, rr[i]);\n				if (ll[i] > rr[i]) {\n					println(""No"");\n					continue out;\n				}\n			}\n			println(""Yes"");\n		}\n	}\n}\n","constructive algorithms,dp,greedy,implementation"
"import java.util.*;\nimport java.math.*;\npublic class Main{\n    public static void main(String []args){\n        Scanner sc = new Scanner(System.in);\n        int c = sc.nextInt();\n        while(c-- > 0){\n            int n = sc.nextInt();\n            int k = sc.nextInt();\n            int l = sc.nextInt();\n            int depth[] = new int[n];\n            boolean flag = true;\n            for(int i = 0 ; i < n ; i++){\n                depth[i] = sc.nextInt();\n                if(depth[i] > l)\n                    flag = false;\n            }\n            int prev = 0;\n            int mini = 0;\n            int maxi = 2*k;\n            if(flag)\n            for(int i = 0 ; i < n ; i++){\n                maxi = Math.min(k + (l - depth[i]),2*k);\n                if(maxi == 2*k){\n                    mini = 0;\n                }else{\n                    mini = Math.max(mini+1,k - (l - depth[i]));\n                }\n                if(mini > maxi){\n                    flag = false;\n                    break;\n                }\n                //System.out.println(mini+"" ""+maxi);\n            }\n            System.out.println(flag?""Yes"":""No"");\n        }\n    }\n}","constructive algorithms,dp,greedy,implementation"
"import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        while (t -- > 0) {\n            int n = sc.nextInt();\n            int k = sc.nextInt();\n            int l = sc.nextInt();\n            int[] a = new int[n+1];\n            ArrayList<Integer> safe = new ArrayList<>();\n            safe.add(0);\n            for (int i = 1; i <= n; i++) {\n                a[i] = sc.nextInt();\n                if (a[i] + k <= l) safe.add(i);\n            }\n            safe.add(n + 1);\n            boolean drown = false;\n            for (int i = 1; i < safe.size() && !drown; ++i)\n            {\n                int tide = k; boolean down = true;\n                for (int j = safe.get(i-1) + 1; j < safe.get(i); j++)\n                {\n                    tide += down ? -1 : +1;\n                    if (down) tide -= Math.max(0, a[j] + tide - l);\n                    if (tide < 0 || a[j] + tide > l) { drown = true; break; }\n                    if (tide == 0) down = false;\n                }\n            }\n\n\n            if (drown) System.out.println(""No"");\n            else System.out.println(""Yes"");\n        }\n    }\n\n}\n","constructive algorithms,dp,greedy,implementation"
"import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Koa_Beach {\n    static int[] d;\n    static ArrayList<Integer> safe;\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int T = scan.nextInt();\n        while (T-- > 0) {\n            int n = scan.nextInt(), k = scan.nextInt(), l = scan.nextInt();\n            d = new int[n+1];\n            safe = new ArrayList<>();\n            safe.add(0);\n            for (int i = 1; i <= n; i++) {\n                d[i] = scan.nextInt();\n                if (d[i] + k <= l) safe.add(i);\n            }\n            safe.add(n+1);\n            boolean ok = true;\n            for (int i = 1; i < safe.size() && ok; i++) {\n                int tide = k;\n                boolean down = true;\n                for (int j = safe.get(i-1)+1; j < safe.get(i) && ok; j++) {\n                    tide += down? -1: 1;\n                    if (down) {\n                        if (d[j] + tide > l) tide -= d[j] + tide - l;\n                        if (tide < 0) ok = false;\n                    } else ok = d[j]+tide <= l;\n                    if (tide == 0) down = false;\n                }\n            }\n            if (ok) System.out.println(""YES"");\n            else System.out.println(""NO"");\n        }\n    }\n}\n","constructive algorithms,dp,greedy,implementation"
"import java.util.*;\nimport java.io.*;\n\npublic class GFG {\n	public static void main (String[] args) {\n	Scanner sc=new Scanner(System.in);\n	int t=sc.nextInt();\n	while(t!=0)\n	{\n	    int n=sc.nextInt();int a[]=new int[n];\n	   for(int i=0;i<n;i++) a[i]=sc.nextInt();int po=0;\n	   for(int i=1;i<n-1;i++) {if(a[i]>a[i-1]&&a[i]>a[i+1]) {po=1;\n	   System.out.println(""yes""); System.out.println(i+"" ""+(i+1)+"" ""+(i+2));break;}\n	}if(po==0) System.out.println(""no"");t--;\n	}\n}}\n	\n	","brute force,data structures"
"import java.util.*;\npublic class cfedur91A {\npublic static void main(String[] args) {\nScanner sc=new Scanner(System.in);\nint t=sc.nextInt();\nfor(int j=1;j<=t;j++)\n{int n=sc.nextInt(),f=0;int c=0;\nint arr[]=new int[n];\nfor(int i=0;i<n;i++)\narr[i]=sc.nextInt();\nfor(int i=0;i<=n-1-2;i++)\n{if(arr[i]<arr[i+1]&&arr[i+1]>arr[i+2])\n{f=1;c=i;break;}}\nif(f==1)\n{System.out.println(""YES"");\nSystem.out.println((c+1)+"" ""+(c+2)+"" ""+(c+3));}\nelse\nSystem.out.println(""no"");\n}sc.close();} \n}","brute force,data structures"
"import java.util.*;\n \npublic class Answer {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while(t-->0){\n			int n = sc.nextInt();\n			int[] arr = new int[n];\n			for(int i = 0; i<n; i++) arr[i]=sc.nextInt();\n\n			boolean b = false;\n			for(int i = 1; i<n-1; i++){\n				if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){\n					System.out.println(""YES\n""+i+"" ""+(i+1)+"" ""+(i+2));\n					b=true; break;\n				}\n			}\n			if(!b){\n				System.out.println(""NO"");\n			}\n		}\n		\n		\n	}\n}","brute force,data structures"
"import java.util.Scanner;\n\npublic class yoo\n{\n\n	public static void main(String[] args)\n	{\n		Scanner sc = new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0){\n			int n=sc.nextInt();\n			int[] a= new int[n];\n			for(int i=0;i<n;i++) {\n				a[i]=sc.nextInt();\n			}\n			int c=0;\n			for(int i=1;i<n-1;i++) {\n				if(a[i-1]<a[i]&& a[i]>a[i+1]) {\n					System.out.println(""YES"");\n					c=1;\n					System.out.println((i)+"" ""+(i+1)+"" ""+(i+2));\n					break;\n				}\n			}\n			if(c==0)System.out.println(""NO"");\n		}\n		\n\n	}\n\n}\n","brute force,data structures"
"import java.io.*; \nimport java.text.*; \nimport java.util.*; \nimport java.math.*;\npublic class template { \n    public static void main(String[] args) throws Exception {\n        new template().run();\n    } \n    public void run() throws Exception { \n        FastScanner f = new FastScanner(); \n        PrintWriter out = new PrintWriter(System.out); \n        int n = f.nextInt(), m = f.nextInt(), q = f.nextInt();\n        ok = new boolean[800000];\n        up = new int[800000];\n        down = new int[800000];\n        init(0, 0, n);\n        TreeSet<Integer>[] up = new TreeSet[n];\n        TreeSet<Integer>[] down = new TreeSet[n];\n        for(int i = 0; i < n; i++) up[i] = new TreeSet<>();\n        for(int i = 0; i < n; i++) down[i] = new TreeSet<>();\n        for(int i = 0; i < n; i++) {\n            up[i].add(200001);\n            down[i].add(-1);\n        }\n        while(q-->0) {\n            int r = f.nextInt()-1, c = f.nextInt()-1;\n            if(r % 2 == 1) {\n                if(!down[r/2].add(c/2))\n                    down[r/2].remove(c/2);\n                update(0, 0, n, r/2, down[r/2].last(), true);\n            } else {\n                if(!up[r/2].add(c/2))\n                    up[r/2].remove(c/2);\n                update(0, 0, n, r/2, up[r/2].first(), false);\n            }\n            out.println(ok[0] ? ""YES"" : ""NO"");\n        }\n        ///\n///\n		out.flush();\n	}\n    public void init(int i, int l, int r) {\n        if(l != r-1) {\n            int m = (l+r)/2;\n            init(2*i+1, l, m);\n            init(2*i+2, m, r);\n        }\n        ok[i] = true;\n        up[i] = 200001;\n        down[i] = -1;\n    }\n    boolean[] ok;\n    int[] up, down;\n    public void update(int i, int l, int r, int qi, int qv, boolean b) {\n        if(qi >= r || qi < l) return;\n        if(l == r-1) {\n            if(b) down[i] = qv;\n            else up[i] = qv;\n            ok[i] = up[i] > down[i];\n        } else {\n            int m = (l+r)/2;\n            update(2*i+1, l, m, qi, qv, b);\n            update(2*i+2, m, r, qi, qv, b);\n            up[i] = Math.min(up[2*i+1], up[2*i+2]);\n            down[i] = Math.max(down[2*i+1], down[2*i+2]);\n            ok[i] = ok[2*i+1] && ok[2*i+2] && up[2*i+1] > down[2*i+2];\n        }\n    }\n///\n	static class FastScanner {\n		public BufferedReader reader;\n		public StringTokenizer tokenizer;\n		public FastScanner() {\n			reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n			tokenizer = null;\n		}\n		public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n				try {\n					tokenizer = new StringTokenizer(reader.readLine());\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n			return tokenizer.nextToken();\n		}\n		public int nextInt() {\n			return Integer.parseInt(next());\n		}\n		public long nextLong() {\n			return Long.parseLong(next());\n		}\n		public double nextDouble() {\n			return Double.parseDouble(next());\n		}\n		public String nextLine() {\n			try {\n				return reader.readLine();\n			} catch(IOException e) {\n				throw new RuntimeException(e);\n			}\n		}\n	}\n}\n","data structures,divide and conquer"
"import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n    private void solve() throws Exception {\n        int n = nextInt();\n        int m = nextInt();\n        int q = nextInt();\n\n        int nn = n+1;\n        int size = 2;\n        while (nn > 0) {\n            nn /= 2;\n            size *= 2;\n        }\n        a = new int[size];\n        Arrays.fill(a, 1<<30);\n        b = new int[size];\n        Arrays.fill(b, -1);\n        flag = new boolean[size];\n        Arrays.fill(flag, true);\n\n        TreeSet<Integer>[] A = new TreeSet[n+1];\n        TreeSet<Integer>[] B = new TreeSet[n+1];\n        for(int i = 0; i <= n; i++) {\n            A[i] = new TreeSet<Integer>();\n            A[i].add(1<<30);\n            B[i] = new TreeSet<Integer>();\n            B[i].add(-1);\n        }\n        \n        for (int qq = 1; qq <= q; qq++) {\n            int i = nextInt()-1;\n            int j = nextInt()-1;\n            if(i%2 == 0) {\n                int x = i/2;\n                int y = j/2;\n                if(A[x].contains(y)) A[x].remove(y);\n                else A[x].add(y);\n                updateIndexA(1, 0, n, x, A[x].first());\n            } else {\n                int x = i/2+1;\n                int y = j/2;\n                if(B[x].contains(y)) B[x].remove(y);\n                else B[x].add(y);\n                updateIndexB(1, 0, n, x, B[x].last());\n            }\n            System.out.println(flag[1]?""YES"":""NO"");\n//            int jj = 2*m-1-j;\n//            if(i%2 == 1) {\n//                TreeOdd.updateIndex(1, 0, 2*n-1, i, j);\n//                int max = TreeEven.queryRange(1, 0, 2*n-1, 0, i);\n//                if(max >= jj) ok = false;\n//            } else {\n//                TreeEven.updateIndex(1, 0, 2*n-1, i, jj);\n//                int max = TreeOdd.queryRange(1, 0, 2*n-1, i, 2*n-1);\n//                if(max >= j) ok = false;\n//            }\n//            System.out.println(ok?""YES"":""NO"");\n        }\n    }\n\n    int[] a;\n    int[] b;\n    boolean[] flag;\n\n    void updateIndexA(int node, int start, int end, int index, int value) {\n        if (start > end || start > index || end < index) // Current segment is not within range [l, r]\n            return;\n        if (start >= index && end <= index) { // Segment is fully within range\n            a[node] = value;\n            return;\n        }\n        int mid = (start + end) / 2;\n        updateIndexA(node * 2, start, mid, index, value); // Updating left child\n        updateIndexA(node * 2 + 1, mid + 1, end, index, value); // Updating right child\n        a[node] = Math.min(a[node * 2], a[node * 2 + 1]);\n        flag[node] = a[node * 2] > b[node * 2 + 1] && flag[node * 2] && flag[node * 2 + 1];\n    }\n    \n    void updateIndexB(int node, int start, int end, int index, int value) {\n        if (start > end || start > index || end < index) // Current segment is not within range [l, r]\n            return;\n        if (start >= index && end <= index) { // Segment is fully within range\n            b[node] = value;\n            return;\n        }\n        int mid = (start + end) / 2;\n        updateIndexB(node * 2, start, mid, index, value); // Updating left child\n        updateIndexB(node * 2 + 1, mid + 1, end, index, value); // Updating right child\n        b[node] = Math.max(b[node * 2], b[node * 2 + 1]);\n        flag[node] = a[node * 2] > b[node * 2 + 1] && flag[node * 2] && flag[node * 2 + 1];\n    }\n    \n//    boolean queryRange(int node, int start, int end, int l, int r) {\n//        if (start > end || start > r || end < l)\n//            return true; // Out of range\n//        if (start >= l && end <= r) // Current segment is totally within range [l, r]\n//            return flag[node];\n//        int mid = (start + end) / 2;\n//        boolean V1 = queryRange(node * 2, start, mid, l, r); // Query left child\n//        boolean V2 = queryRange(node * 2 + 1, mid + 1, end, l, r); // Query right child\n//        return V1 && V2;\n//    }\n//\n//    int queryRangeA(int node, int start, int end, int l, int r) {\n//        if (start > end || start > r || end < l)\n//            return 1<<30; // Out of range\n//        if (start >= l && end <= r) // Current segment is totally within range [l, r]\n//            return a[node];\n//        int mid = (start + end) / 2;\n//        int V1 = queryRangeA(node * 2, start, mid, l, r); // Query left child\n//        int V2 = queryRangeA(node * 2 + 1, mid + 1, end, l, r); // Query right child\n//        return Math.min(V1, V2);\n//    }\n//    \n//    int queryRangeB(int node, int start, int end, int l, int r) {\n//        if (start > end || start > r || end < l)\n//            return 0; // Out of range\n//        if (start >= l && end <= r) // Current segment is totally within range [l, r]\n//            return a[node];\n//        int mid = (start + end) / 2;\n//        int V1 = queryRangeB(node * 2, start, mid, l, r); // Query left child\n//        int V2 = queryRangeB(node * 2 + 1, mid + 1, end, l, r); // Query right child\n//        return Math.max(V1, V2);\n//    }\n\n    public static void main(String[] args) {\n        new Thread(null, new Runnable() {\n            public void run() {\n                new Solution().run();\n            }\n        }, ""1"", 1 << 27).start();\n    }\n\n    private BufferedReader in;\n    private PrintWriter out;\n    private StringTokenizer tokenizer;\n\n    public void run() {\n        try {\n//            in = new BufferedReader(new FileReader(""ks_10000_0""));\n            in = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n            // out = new PrintWriter(new File(""outputPQ.txt""));\n            out = new PrintWriter(System.out);\n            solve();\n            in.close();\n            out.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    private long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    private float nextFloat() throws IOException {\n        return Float.parseFloat(nextToken());\n    }\n\n    private String nextLine() throws IOException {\n        return new String(in.readLine());\n    }\n\n    private String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(in.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n}\n","data structures,divide and conquer"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.io.InputStreamReader;\nimport java.util.TreeSet;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        F2ChessStrikesBackHardVersion solver = new F2ChessStrikesBackHardVersion();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class F2ChessStrikesBackHardVersion {\n        private static final String NO = ""NO"";\n        private static final String YES = ""YES"";\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            in.nextInt(); // unused, N\n            in.nextInt(); // unused, M\n            int queries = in.nextInt();\n            Pii[] q = new Pii[queries];\n            for (int i = 0; i < queries; i++) {\n                q[i] = Pii.of(in.nextInt() - 1, in.nextInt() - 1);\n            }\n            Map<Integer, Integer> xCoord = coordinatesMap(q);\n            final int X = xCoord.size();\n\n            int powerOfTwo = Integer.highestOneBit(X);\n            ChessSegmentTree st = new ChessSegmentTree(X == powerOfTwo ? powerOfTwo : powerOfTwo * 2);\n            TreeSet<Integer>[] fY = new TreeSet[X];\n            TreeSet<Integer>[] bY = new TreeSet[X];\n            for (int x = 0; x < X; x++) {\n                fY[x] = new TreeSet<>();\n                fY[x].add(Integer.MAX_VALUE);\n            }\n            for (int x = 0; x < X; x++) {\n                bY[x] = new TreeSet<>();\n                bY[x].add(Integer.MIN_VALUE);\n            }\n\n            for (Pii p : q) {\n                boolean isForward = p.first % 2 == 0;\n                int x = xCoord.get(p.first);\n\n                TreeSet<Integer> y = isForward ? fY[x] : bY[x];\n                boolean remove = y.contains(p.second);\n\n                if (remove) {\n                    y.remove(p.second);\n                } else {\n                    y.add(p.second);\n                }\n\n                if (isForward)\n                    st.updateMin(x, y.first());\n                else\n                    st.updateMax(x, y.last());\n\n                boolean valid = !st.bad[1];\n                out.println(valid ? YES : NO);\n            }\n        }\n\n        private static Map<Integer, Integer> coordinatesMap(Pii[] q) {\n            int[] coordinateArray = new int[q.length];\n            for (int i = 0; i < q.length; i++) {\n                coordinateArray[i] = q[i].first;\n            }\n            Util.safeSort(coordinateArray);\n            Map<Integer, Integer> coordinates = new HashMap<>();\n            for (int i = 0, j = 0; i < coordinateArray.length; i++) {\n                if (coordinates.containsKey(coordinateArray[i]))\n                    continue;\n                coordinates.put(coordinateArray[i], j++);\n            }\n            return coordinates;\n        }\n\n        public class ChessSegmentTree {\n            public final int size;\n            public final int[] min;\n            public final int[] max;\n            public final boolean[] bad;\n\n            public ChessSegmentTree(int size) {\n                this.size = size;\n                min = new int[2 * size];\n                max = new int[2 * size];\n                bad = new boolean[2 * size];\n                Arrays.fill(min, Integer.MAX_VALUE);\n                Arrays.fill(max, Integer.MIN_VALUE);\n                Arrays.fill(bad, false);\n            }\n\n            public void updateMin(int i, int v) {\n                i += size;\n                min[i] = v;\n                while (i > 1) {\n                    i /= 2;\n                    min[i] = Math.min(min[2 * i], min[2 * i + 1]);\n                    bad[i] = bad[2 * i] || bad[2 * i + 1] || min[2 * i] < max[2 * i + 1];\n                }\n            }\n\n            public void updateMax(int i, int v) {\n                i += size;\n                max[i] = v;\n                while (i > 1) {\n                    i /= 2;\n                    max[i] = Math.max(max[2 * i], max[2 * i + 1]);\n                    bad[i] = bad[2 * i] || bad[2 * i + 1] || min[2 * i] < max[2 * i + 1];\n                }\n            }\n\n        }\n\n    }\n\n    static class Pii implements Comparable<Pii> {\n        public final int first;\n        public final int second;\n\n        public Pii(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        public static Pii of(int first, int second) {\n            return new Pii(first, second);\n        }\n\n        public boolean equals(Object o) {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Pii pair = (Pii) o;\n            return first == pair.first && second == pair.second;\n        }\n\n        public int hashCode() {\n            return Arrays.hashCode(new int[]{first, second});\n        }\n\n        public String toString() {\n            return ""("" + first + "", "" + second + ')';\n        }\n\n        public int compareTo(Pii o) {\n            if (first != o.first)\n                return Integer.compare(first, o.first);\n            return Integer.compare(second, o.second);\n        }\n\n    }\n\n    static class InputReader {\n        public final BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n    static class Util {\n        public static void safeSort(int[] x) {\n            shuffle(x);\n            Arrays.sort(x);\n        }\n\n        public static void shuffle(int[] x) {\n            Random r = new Random();\n\n            for (int i = 0; i <= x.length - 2; i++) {\n                int j = i + r.nextInt(x.length - i);\n                swap(x, i, j);\n            }\n        }\n\n        public static void swap(int[] x, int i, int j) {\n            int t = x[i];\n            x[i] = x[j];\n            x[j] = t;\n        }\n\n        private Util() {\n        }\n\n    }\n}\n\n","data structures,divide and conquer"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.io.InputStreamReader;\nimport java.util.TreeSet;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        F2ChessStrikesBackHardVersion solver = new F2ChessStrikesBackHardVersion();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class F2ChessStrikesBackHardVersion {\n        private static final String NO = ""NO"";\n        private static final String YES = ""YES"";\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            in.nextInt(); // unused, N\n            in.nextInt(); // unused, M\n            int queries = in.nextInt();\n            Pii[] q = new Pii[queries];\n            for (int i = 0; i < queries; i++) {\n                q[i] = Pii.of(in.nextInt() - 1, in.nextInt() - 1);\n            }\n            Map<Integer, Integer> xCoord = coordinatesMap(q);\n            final int X = xCoord.size();\n\n            int powerOfTwo = Integer.highestOneBit(X);\n            ChessSegmentTree st = new ChessSegmentTree(X == powerOfTwo ? powerOfTwo : powerOfTwo * 2);\n            TreeSet<Integer>[] fY = new TreeSet[X];\n            TreeSet<Integer>[] bY = new TreeSet[X];\n            for (int x = 0; x < X; x++) {\n                fY[x] = new TreeSet<>();\n                fY[x].add(Integer.MAX_VALUE);\n            }\n            for (int x = 0; x < X; x++) {\n                bY[x] = new TreeSet<>();\n                bY[x].add(Integer.MIN_VALUE);\n            }\n\n            for (Pii p : q) {\n                boolean isForward = p.first % 2 == 0;\n                int x = xCoord.get(p.first);\n\n                TreeSet<Integer> y = isForward ? fY[x] : bY[x];\n                boolean remove = y.contains(p.second);\n\n                if (remove) {\n                    y.remove(p.second);\n                } else {\n                    y.add(p.second);\n                }\n\n                if (isForward)\n                    st.updateMin(x, y.first());\n                else\n                    st.updateMax(x, y.last());\n\n                boolean valid = !st.bad[1];\n                out.println(valid ? YES : NO);\n            }\n        }\n\n        private static Map<Integer, Integer> coordinatesMap(Pii[] q) {\n            int[] coordinateArray = new int[q.length];\n            for (int i = 0; i < q.length; i++) {\n                coordinateArray[i] = q[i].first;\n            }\n            Util.safeSort(coordinateArray);\n            Map<Integer, Integer> coordinates = new HashMap<>();\n            for (int i = 0, j = 0; i < coordinateArray.length; i++) {\n                if (coordinates.containsKey(coordinateArray[i]))\n                    continue;\n                coordinates.put(coordinateArray[i], j++);\n            }\n            return coordinates;\n        }\n\n        public class ChessSegmentTree {\n            public final int size;\n            public final int[] min;\n            public final int[] max;\n            public final boolean[] bad;\n\n            public ChessSegmentTree(int size) {\n                this.size = size;\n                min = new int[2 * size];\n                max = new int[2 * size];\n                bad = new boolean[2 * size];\n                Arrays.fill(min, Integer.MAX_VALUE);\n                Arrays.fill(max, Integer.MIN_VALUE);\n                Arrays.fill(bad, false);\n            }\n\n            private void combine(int i) {\n                min[i] = Math.min(min[2 * i], min[2 * i + 1]);\n                max[i] = Math.max(max[2 * i], max[2 * i + 1]);\n                bad[i] = bad[2 * i] || bad[2 * i + 1] || min[2 * i] < max[2 * i + 1];\n            }\n\n            public void updateMin(int i, int v) {\n                i += size;\n                min[i] = v;\n                while (i > 1) {\n                    i /= 2;\n                    combine(i);\n                }\n            }\n\n            public void updateMax(int i, int v) {\n                i += size;\n                max[i] = v;\n                while (i > 1) {\n                    i /= 2;\n                    combine(i);\n                }\n            }\n\n        }\n\n    }\n\n    static class Pii implements Comparable<Pii> {\n        public final int first;\n        public final int second;\n\n        public Pii(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        public static Pii of(int first, int second) {\n            return new Pii(first, second);\n        }\n\n        public boolean equals(Object o) {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Pii pair = (Pii) o;\n            return first == pair.first && second == pair.second;\n        }\n\n        public int hashCode() {\n            return Arrays.hashCode(new int[]{first, second});\n        }\n\n        public String toString() {\n            return ""("" + first + "", "" + second + ')';\n        }\n\n        public int compareTo(Pii o) {\n            if (first != o.first)\n                return Integer.compare(first, o.first);\n            return Integer.compare(second, o.second);\n        }\n\n    }\n\n    static class InputReader {\n        public final BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n    static class Util {\n        public static void safeSort(int[] x) {\n            shuffle(x);\n            Arrays.sort(x);\n        }\n\n        public static void shuffle(int[] x) {\n            Random r = new Random();\n\n            for (int i = 0; i <= x.length - 2; i++) {\n                int j = i + r.nextInt(x.length - i);\n                swap(x, i, j);\n            }\n        }\n\n        public static void swap(int[] x, int i, int j) {\n            int t = x[i];\n            x[i] = x[j];\n            x[j] = t;\n        }\n\n        private Util() {\n        }\n\n    }\n}\n\n","data structures,divide and conquer"
"import java.io.*; \nimport java.text.*; \nimport java.util.*; \nimport java.math.*;\npublic class template { \n    public static void main(String[] args) throws Exception {\n        new template().run();\n    } \n    public void run() throws Exception { \n        FastScanner f = new FastScanner(); \n        PrintWriter out = new PrintWriter(System.out); \n        ///\n        int n = f.nextInt(), k = f.nextInt();\n        par = new int[n];\n        if(n % 2 == 0) out.println(""NO"");\n        else {\n            ok = true;\n            par[gen(n, k)] = -1;\n            if(ok) {\n                out.println(""YES"");\n                for(int i : par) out.print(i+1 + "" "");\n            } else out.println(""NO"");\n        }\n///\n		out.flush();\n	}\n    int[] par;\n    int node;\n    boolean ok;\n    public int gen(int n, int k) {\n        int me = node++;\n        if(k < 0) ok = false;\n        if(n == 1) {\n        } else if(n == 3) {\n            if(k != 0) ok = false;\n            par[gen(1, 0)] = me;\n            par[gen(1, 0)] = me;\n        } else if(n == 5) {\n            if(k != 1) ok = false;\n            par[gen(1, 0)] = me;\n            par[gen(3, 0)] = me;\n        }\n        else if(n == 7) {\n            if(k == 0) {\n                par[gen(3, 0)] = me;\n                par[gen(3, 0)] = me;\n            } else if(k == 2) {\n                par[gen(1, 0)] = me;\n                par[gen(5, 1)] = me;\n            } else ok = false; \n        } else if(n == 9) {\n            if(k == 1) {\n                par[gen(1, 0)] = me;\n                par[gen(7, 0)] = me;\n            } else if(k == 3) {\n                par[gen(1, 0)] = me;\n                par[gen(7, 2)] = me;\n            } else ok = false;\n        } else if(n == 11) {\n            if(k == 1 || k == 3) {\n                par[gen(3, 0)] = me;\n                par[gen(7, k-1)] = me;\n            } else if(k == 2) {\n                par[gen(5, 1)] = me;\n                par[gen(5, 1)] = me;\n            } else if(k == 4) {\n                par[gen(1, 0)] = me;\n                par[gen(9, 3)] = me;\n            } else ok = false;\n        } else if(k <= 1) {\n            int d = 1;\n            while((n - 1 - d) > 2*d) d = d*2+1;\n            par[gen(d, 0)] = me;\n            par[gen(n-d-1, k - (d > 2*(n-1-d) ? 1 : 0))] = me;\n        } else {\n            int asdf = n-1;\n            while(asdf % 2 == 0) asdf /= 2;\n            if(asdf == 1 && k == 2) {\n                par[gen(3, 0)] = me;\n                par[gen(n-4, k-1)] = me;\n            } else {\n                par[gen(1, 0)] = me;\n                par[gen(n-2, k-1)] = me;\n            }\n        }\n        return me;\n    }\n///\n	static class FastScanner {\n		public BufferedReader reader;\n		public StringTokenizer tokenizer;\n		public FastScanner() {\n			reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n			tokenizer = null;\n		}\n		public String next() { while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n				try {\n					tokenizer = new StringTokenizer(reader.readLine());\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n			return tokenizer.nextToken();\n		}\n		public int nextInt() {\n			return Integer.parseInt(next());\n		}\n		public long nextLong() {\n			return Long.parseLong(next());\n		}\n		public double nextDouble() {\n			return Double.parseDouble(next());\n		}\n		public String nextLine() {\n			try {\n				return reader.readLine();\n			} catch(IOException e) {\n				throw new RuntimeException(e);\n			}\n		}\n	}\n}\n","constructive algorithms,divide and conquer,dp,math,trees"
"import java.io.*;\nimport java.util.*;\n\n\npublic class Solution {\n\n    int bound = 100000;\n    \n    private void solve() throws Exception {\n        powers = new HashSet<Integer>();\n        int pow = 1;\n        while(pow-1 <= bound) {\n            powers.add(pow-1);\n            pow = pow*2;\n        }\n        int n = nextInt();\n        int k = nextInt();\n        \n        possible = true;\n      \n        Node res = doit(n,k);\n        if(!possible) {\n            out.println(""NO"");\n        } else {\n\n            d = new int[n];\n            p = new int[n];\n            idx = 0;\n            visit(res, -1);\n            out.println(""YES"");          \n            for(int x : p) out.print((x+1) + "" "");\n        }\n    }\n    \n\n    int[] d;\n    int[] p;\n    int idx;\n    \n    void visit(Node u, int par){\n        int cur = idx++;\n        p[cur] = par;\n        if(u.left == null) return;\n        visit(u.left, cur);\n        visit(u.right, cur);\n    }\n    \n    HashSet<Integer> powers;\n    \n    boolean possible;\n    \n    Node doit(int n, int k) {\n        Node node = new Node();\n        if(n == 1 && k == 0) return node;\n        else if(k <= 1) {\n            int pow = 1;\n            int l = 0;\n            int r = n-1;\n            while(l <= n-1) {\n                l = pow-1;\n                r = n-1-l;\n                if(((l <= r && r < 2*l) || (r <= l && l < 2*r)) ) {\n                    node.left = doit(l,0);\n                    node.right = doit(r,k);\n                    return node;\n                } else if(r >= 2*l && powers.contains(l) && powers.contains(r) && k == 1) {\n                    node.left = doit(l,0);\n                    node.right = doit(r,0);\n                    return node;\n                }\n                pow = 2*pow;\n            }            \n            possible = false;\n        } else if(k == 2 && powers.contains(n-2) || k ==3 && n == 11) {\n            if(n == 9) possible = false;\n            node.left = doit(3,0);\n            node.right = doit(n-4, k-1);\n        } else {\n            node.left = doit(1,0);\n            node.right = doit(n-2, k-1);\n        }\n        return node;\n    }\n    \n    \n    \n    \n\n    public static void main(String[] args) {\n        new Thread(null, new Runnable() {\n            public void run() {\n                new Solution().run();\n            }\n        }, ""1"", 1 << 27).start();\n    }\n\n    private BufferedReader in;\n    private PrintWriter out;\n    private StringTokenizer tokenizer;\n\n    public void run() {\n        try {\n//            in = new BufferedReader(new FileReader(""ks_10000_0""));\n            in = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n            // out = new PrintWriter(new File(""outputPQ.txt""));\n            out = new PrintWriter(System.out);\n            solve();\n            in.close();\n            out.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    private long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    private float nextFloat() throws IOException {\n        return Float.parseFloat(nextToken());\n    }\n\n    private String nextLine() throws IOException {\n        return new String(in.readLine());\n    }\n\n    private String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(in.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n}\n\nclass Node {\n    Node left;\n    Node right;\n}","constructive algorithms,divide and conquer,dp,math,trees"
"import java.io.*;\nimport java.util.*;\n\n\npublic class Solution {\n\n    int bound = 100000;\n    int N = 31;\n    \n    private void solve() throws Exception {\n        memo = new Boolean[N+1][N+1];\n        nodes = new Node[N+1][N+1];\n//        for(int i = 1; i <= n; i+=2) {\n//            String a = String.format(""%3d"", i);\n//            System.out.print(a + "": "");\n//            for(int j = 0; j <= i; j++) {\n//                System.out.print((doit(i,j)?1:0) + "" "");\n//            }\n//            System.out.println();\n//        }\n       // System.out.println(doit_(65,2));\n        int n = nextInt();\n        int k = nextInt();\n        powers = new HashSet<Integer>();\n        int pow = 1;\n        while(pow-1 <= bound) {\n            powers.add(pow-1);\n            pow = pow*2;\n        }\n        if(n == 1 && k == 0) {\n            out.println(""YES"");\n            out.println(0);\n        }\n        else if(n%2 == 1 && k <= (n-3)/2) {\n            if(powers.contains(n) && k == 1) out.println(""NO"");\n            else if(!powers.contains(n) && k == 0) out.println(""NO"");\n            else if(n == 9 && k == 2) out.println(""NO"");\n            else {\n      \n                Node res = doit(n,k);\n\n                d = new int[n];\n                p = new int[n];\n                idx = 0;\n                visit(res, -1);\n                System.out.println(""YES"");          \n                for(int x : p) out.print((x+1) + "" "");\n            }\n        } else out.println(""NO"");\n    }\n    int[] d;\n    int[] p;\n    int idx;\n    \n    void visit(Node u, int par){\n        int cur = idx++;\n        p[cur] = par;\n        if(u.left == null) return;\n        visit(u.left, cur);\n        visit(u.right, cur);\n    }\n    \n    HashSet<Integer> powers;\n    \n    boolean possible = true;\n    \n    Node doit(int n, int k) {\n        if(n <= N && k <= N) {\n            possible = possible && doit_(n,k);\n            return nodes[n][k];\n        } else if(k <= 1) {\n            int pow = 1;\n            int l = 0;\n            int r = n-1;\n            while(l <= n-1) {\n                l = pow-1;\n                r = n-1-l;\n                if(l >= 0 && r >= 0 && ((l <= r && r < 2*l) || (r <= l && l < 2*r)) ) {\n                    break;\n                } else if(r >= 2*l && powers.contains(l) && powers.contains(r)) {\n                    Node node = new Node();\n                    node.left = doit(l,0);\n                    node.right = doit(r,0);\n                    return node;\n                }\n                pow = 2*pow;\n            }\n            \n            Node node = new Node();\n            node.left = doit(l,0);\n            node.right = doit(r,k);\n            return node;\n            \n            \n        } else if(k == 2 && powers.contains(n-2)) {\n        \n            Node node = new Node();\n            node.left = doit(3,0);\n            node.right = doit(n-4, k-1);\n            return node;\n        } else {\n            Node node = new Node();\n            node.left = doit(1,0);\n            node.right = doit(n-2, k-1);\n            return node;\n        }\n    }\n    \n    Boolean[][] memo;\n    \n    Node[][] nodes;\n    \n    boolean doit_(int n, int k) {\n        if(memo[n][k] == null) {\n            if(n == 1 && k == 0) {\n                nodes[n][k] = new Node();\n                memo[n][k] = true;\n            } else {\n                boolean res = false;\n                for(int l = 1; l <= (n-1)/2 && !res; l++) {\n                    int r = n-1-l;\n                    int kk = k;\n                    if(r >= 2*l) kk--;\n                    for(int j = 0; j <= kk && !res; j++) {\n                        boolean cur = (doit_(l,j) && doit_(r,kk-j));\n                        res = res || cur;\n                        if(res) {\n                            nodes[n][k] = new Node();\n                            nodes[n][k].left = nodes[l][j];\n                            nodes[n][k].right = nodes[r][kk-j];\n                        }\n                    }\n                }\n                memo[n][k] = res;\n            }\n        }\n        return memo[n][k];\n    }\n    \n    \n    \n\n    public static void main(String[] args) {\n        new Thread(null, new Runnable() {\n            public void run() {\n                new Solution().run();\n            }\n        }, ""1"", 1 << 27).start();\n    }\n\n    private BufferedReader in;\n    private PrintWriter out;\n    private StringTokenizer tokenizer;\n\n    public void run() {\n        try {\n//            in = new BufferedReader(new FileReader(""ks_10000_0""));\n            in = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n            // out = new PrintWriter(new File(""outputPQ.txt""));\n            out = new PrintWriter(System.out);\n            solve();\n            in.close();\n            out.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    private long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    private float nextFloat() throws IOException {\n        return Float.parseFloat(nextToken());\n    }\n\n    private String nextLine() throws IOException {\n        return new String(in.readLine());\n    }\n\n    private String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(in.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n}\n\nclass Node {\n    Node left;\n    Node right;\n}","constructive algorithms,divide and conquer,dp,math,trees"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EInverseGenealogy solver = new EInverseGenealogy();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EInverseGenealogy {\n        private static final String NO = ""NO"";\n        private static final String YES = ""YES"";\n        private static final int[][] small = {\n                // x = 0\n                null,\n                // x = 1\n                {-1},\n                // x = 2\n                {-1, 0, 1, 2, 0},\n                // x = 3\n                {-1, 0, 0},\n                // x = 4\n                {-1, 0, 0, 1, 1},\n                // x = 5\n                {-1, 0, 0, 1, 1, 2},\n                // x = 6\n                {-1, 0, 0, 1, 1, 3, 3, 4},\n                // x = 7\n                {-1, 0, 0, 1, 1, 2, 2}};\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt(), k = in.nextInt();\n            if (n % 2 == 0) {\n                out.println(NO);\n                return;\n            }\n            if (n == 1) {\n                if (k == 0) {\n                    out.println(YES);\n                    out.println(0);\n                } else {\n                    out.println(NO);\n                }\n                return;\n            }\n\n            int balanced = n - k;\n            int leaves = n / 2 + 1;\n            int x = balanced - leaves; // number of balanced internal nodes\n            n -= leaves; // number of internal nodes\n            if (x <= 0 || x > n) {\n                out.println(NO);\n                return;\n            }\n            Util.ASSERT(x > 0 && n > 0);\n\n            int[] answer = solve(x, n);\n            if (answer == null) {\n                out.println(NO);\n                return;\n            }\n            int[] degree = new int[answer.length];\n            for (int i = 0; i < answer.length; i++) {\n                if (answer[i] >= 0)\n                    degree[answer[i]]++;\n            }\n            out.println(YES);\n            for (int i = 0; i < answer.length; i++) {\n                answer[i]++;\n            }\n            out.print(Util.join(answer) + "" "");\n            for (int i = 0; i < answer.length; i++) {\n                for (int j = degree[i]; j < 2; j++) {\n                    out.print((i + 1) + "" "");\n                }\n            }\n        }\n\n        private int[] solve(int x, int n) {\n            int[] ans = f(x);\n            if (ans == null || ans.length > n)\n                return null;\n\n            return pad(ans, n);\n        }\n\n        private int[] f(int x) {\n            if (x < small.length) {\n                return small[x];\n            }\n            if (Integer.bitCount(x + 1) == 1) {\n                return powerOfTwoMinus1(x);\n            }\n\n            int powerOfTwoMinus1 = getPowerOfTwoMinus1(x);\n            int remaining = x - powerOfTwoMinus1;\n            if (Integer.bitCount(remaining + 1) == 1 && remaining != powerOfTwoMinus1) {\n                // remaining is also 2^k-1, so we do a merge with an imbalanced root\n                return merge(f(powerOfTwoMinus1), f(remaining));\n            }\n\n            // merge with balanced root\n            return merge(f(powerOfTwoMinus1), pad(f(remaining - 1), remaining));\n        }\n\n        private int[] pad(int[] ans, int n) {\n            if (ans.length >= n)\n                return ans;\n\n            int[] big = new int[n];\n            System.arraycopy(ans, 0, big, big.length - ans.length, ans.length);\n            for (int i = 0; i < big.length - ans.length + 1; i++) {\n                big[i] = i - 1;\n            }\n            for (int i = big.length - ans.length + 1; i < big.length; i++) {\n                big[i] += big.length - ans.length;\n            }\n            return big;\n        }\n\n        private int[] merge(int[] left, int[] right) {\n            if (left == null || right == null)\n                return null;\n\n            int[] answer = new int[1 + left.length + right.length];\n            answer[0] = -1;\n            System.arraycopy(left, 0, answer, 1, left.length);\n            answer[1] = 0;\n            System.arraycopy(right, 0, answer, 1 + left.length, right.length);\n            answer[1 + left.length] = 0;\n            for (int i = 1 + 1; i < 1 + left.length; i++) {\n                answer[i] += 1;\n            }\n            for (int i = 1 + left.length + 1; i < answer.length; i++) {\n                answer[i] += 1 + left.length;\n            }\n\n            return answer;\n        }\n\n        private int getPowerOfTwoMinus1(int x) {\n            int powerOfTwoMinus1 = 3;\n            while (true) {\n                if (x <= powerOfTwoMinus1 * 3) {\n                    return powerOfTwoMinus1;\n                }\n                powerOfTwoMinus1 = 2 * (powerOfTwoMinus1 + 1) - 1;\n            }\n        }\n\n        private int[] powerOfTwoMinus1(int x) {\n            int[] ans = new int[x];\n            ans[0] = -1;\n            for (int i = 1; i < x; i++) {\n                ans[i] = (i - 1) / 2;\n            }\n            return ans;\n        }\n\n    }\n\n    static class Util {\n        public static String join(int... i) {\n            StringBuilder sb = new StringBuilder();\n            for (int o : i) {\n                sb.append(o);\n                sb.append("" "");\n            }\n            if (sb.length() > 0) {\n                sb.deleteCharAt(sb.length() - 1);\n            }\n            return sb.toString();\n        }\n\n        public static void ASSERT(boolean assertion) {\n            if (!assertion)\n                throw new AssertionError();\n        }\n\n        private Util() {\n        }\n\n    }\n\n    static class InputReader {\n        public final BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n","constructive algorithms,divide and conquer,dp,math,trees"
"import java.util.*;\nimport java.io.*;\n\npublic class Question5 {\n    \nstatic Scanner sc = new Scanner(System.in);\nstatic BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\n	public static void main(String[] args) throws IOException{\n		\n		int n = sc.nextInt();\n		int[] arr = new int[n];\n		\n		for(int i = 0;i < n;i++)\n			arr[i] = sc.nextInt();\n		\n		ArrayList<int[]> list = new ArrayList<int[]>();\n		\n		for(int j = n - 1;j > 0;j--) {\n			ArrayList<Integer> temp = new ArrayList<Integer>();\n			for(int i = 0;i < j;i++) {\n				if(arr[i] > arr[j])temp.add(i);\n			}\n			\n			Collections.sort(temp, (a, b) -> arr[a] - arr[b]);\n			for(int i = 0;i < temp.size();i++)\n			{\n				list.add(new int[] {temp.get(i)+1, j +1});\n			}\n		}\n		\n		bw.write(String.valueOf(list.size() + ""\n""));\n		for(int i = 0;i < list.size();i++) {\n			bw.write(String.valueOf(list.get(i)[0]) + "" "");\n			bw.write(String.valueOf(list.get(i)[1]) + ""\n"");\n		}\n		\n		bw.flush();\n		bw.close();\n	}\n}\n","constructive algorithms,greedy,sortings"
"\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic final class E {\n\n    public static void main(String[] args) {\n        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        final int n = Integer.parseInt(in.nextLine());\n        final int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = in.nextInt();\n        }\n        in.nextLine();\n        final List<Integer> idx = IntStream.rangeClosed(1, n)\n                                           .boxed()\n                                           .sorted(Comparator.comparingInt(a -> arr[a - 1]))\n                                           .collect(Collectors.toList());\n        int m = 0;\n        final StringBuilder out = new StringBuilder();\n        final List<Integer> list = new ArrayList<>();\n        for (int j : idx) {\n            for (int k = 0; k < list.size(); k++) {\n                if (list.get(k) < j) {\n                    list.add(k, j);\n                    break;\n                } else {\n                    m++;\n                    out.append(j + "" "" + list.get(k) + '\n');\n                }\n            }\n            if (list.isEmpty() || list.get(list.size() - 1) > j) {\n                list.add(j);\n            }\n        }\n        System.out.println(m);\n        System.out.println(out);\n    }\n}\n","constructive algorithms,greedy,sortings"
"import java.util.*;\nimport java.io.*;\n\npublic class SwapSort {\n  public static void main(String [] args) {\n    Reader in = new Reader();\n    Writer out = new Writer();\n    int n = in.nextInt();\n    int [] a = new int [n];\n    int [] ord = new int [n];\n    for(int i = 0; i < n; i++) {\n      a[i] = in.nextInt();\n      ord[i] = i;\n    }\n    ArrayList <Integer []> arr = new ArrayList <> ();\n    for(int i = 0; i < n; i++) {\n      for(int j = 1; j < n; j++) {\n        if(a[ord[j - 1]] > a[ord[j]]) {\n          Integer [] pair = {ord[j - 1] + 1, ord[j] + 1};\n          arr.add(pair);\n          int tmp = ord[j];\n          ord[j] = ord[j - 1];\n          ord[j - 1] = tmp;\n        }\n      }\n    }\n    out.writeln(arr.size());\n    for(int i = arr.size() - 1; i >= 0; i--) {\n      out.writeln(arr.get(i)[0] + "" "" + arr.get(i)[1]);\n    }\n    out.flush();\n  }\n}\n\nclass Reader {\n  BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n  StringTokenizer s = new StringTokenizer("""");\n  Reader () {}\n  String nextLine() {\n    try {\n      return in.readLine();\n    } catch (Exception e) {\n      e.printStackTrace();\n      return ""Error"";\n    }\n  }\n  String next() {\n    while(!s.hasMoreTokens()) {\n      s = new StringTokenizer(nextLine());\n    }\n    return s.nextToken();\n  }\n  int nextInt() {\n    return Integer.parseInt(next());\n  }\n}\n\nclass Writer {\n  BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n  StringBuilder s = new StringBuilder("""");\n  void write(Object variable) {\n    s.append(variable.toString());\n  }\n  void writeln(Object variable) {\n    write(variable);\n    s.append(""\n"");\n  }\n  void flush() {\n    try {\n      out.write(new String(s));\n      out.flush();\n      out.close();\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n","constructive algorithms,greedy,sortings"
"import java.io.*;\nimport java.text.*;\nimport java.util.*;\nimport java.math.*;\npublic class E {\n	public static void main(String[] args) throws Exception {\n		new E().run();\n	}\n	public void run() throws Exception {\n		FastScanner f = new FastScanner();\n		PrintWriter out = new PrintWriter(System.out);\n		int n = f.nextInt();\n		int[] arr = new int[n];\n		ArrayList<Pair>[] inv = new ArrayList[n];\n		ArrayList<Integer> moves = new ArrayList<>();\n		for(int i = 0; i < n; i++) {\n			inv[i] = new ArrayList<>();\n			arr[i] = f.nextInt();\n			for(int j = 0; j < i; j++)\n				if(arr[i] < arr[j]) inv[j].add(new Pair(arr[i], i));\n		}\n		for(int i = 0; i < n; i++) {\n			if(inv[i].isEmpty()) continue;\n			Collections.sort(inv[i]);\n			for(int j = inv[i].size()-1; j >= 0; j--) {\n				Pair p = inv[i].get(j);\n				int t = arr[p.b];\n				arr[p.b] = arr[i];\n				arr[i] = t;\n				moves.add(i); moves.add(p.b);\n			}\n		}\n		boolean ok = true;\n		for(int i = 1; i < n; i++) ok &= arr[i] >= arr[i-1];\n		if(ok) {\n			out.println(moves.size()/2);\n			for(int i = 0; i < moves.size(); i+=2)\n				out.println((moves.get(i)+1) + "" "" + (moves.get(i+1)+1));\n		} else out.println(-1);\n		out.flush();\n	}\n	class Pair implements Comparable<Pair> {\n		int a, b;\n		public Pair(int a, int b) {\n			this.a = a;\n			this.b = b;\n		}\n		public int compareTo(Pair p) {\n			return Integer.compare(a, p.a);\n		}\n	}\n///\n	static class FastScanner {\n		public BufferedReader reader;\n		public StringTokenizer tokenizer;\n		public FastScanner() { reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n			tokenizer = null;\n		}\n		public String next() {\n			while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n				try {\n					tokenizer = new StringTokenizer(reader.readLine());\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n			return tokenizer.nextToken();\n		}\n		public int nextInt() {\n			return Integer.parseInt(next());\n		}\n		public long nextLong() {\n			return Long.parseLong(next());\n		}\n		public double nextDouble() {\n			return Double.parseDouble(next());\n		}\n		public String nextLine() {\n			try {\n				return reader.readLine();\n			} catch(IOException e) {\n				throw new RuntimeException(e);\n			}\n		}\n	}\n}\n","constructive algorithms,greedy,sortings"
"import java.util.*;\npublic class shoo {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		for(int i=0;i<t;i++) {\n			int n = sc.nextInt();\n			int[] arr = new int[n];\n			int ce = 0,co=0;\n			for(int j=0;j<n;j++) {\n				arr[j] = sc.nextInt();\n				if(arr[j]%2==0&&j%2==1) ce++;\n				if(arr[j]%2==1&&j%2==0) co++;\n			}\n			System.out.println((ce==co?ce:-1));\n		}\n	}\n}","greedy,math"
import java.util.*;\npublic class Main {\npublic static void main(String[] args) {\nScanner sc=new Scanner(System.in);\n\nint t=sc.nextInt();\n\n	\n	while(t-->0)\n	{\nint n=sc.nextInt();\nint n1=0;\nint n2=0;\n\n		\n\n		for(int i=0;i<n;i++)\n		{\n			int x=sc.nextInt();\n			if(i%2==0&&x%2!=0)\n			n2++;\n			\n			\n			if(i%2==1&& x%2!=1)\n			n1++;\n			\n		}\n		if(n1==n2)System.out.println(n1);\n		else System.out.println(-1);\n		\n		\n	}\n}\n},"greedy,math"
import java.util.*;\npublic class Main {\npublic static void main(String[] args) {\nScanner sc=new Scanner(System.in);\n \nint t=sc.nextInt();\n \n	\n	while(t-->0)\n	{\nint n=sc.nextInt();\nint n1=0;\nint n2=0;\n \n		\n \n		for(int i=0;i<n;i++)\n		{\n			int x=sc.nextInt();\n			if(i%2==0&&x%2!=0)\n			n2++;\n			\n			\n			if(i%2==1&& x%2!=1)\n			n1++;\n			\n		}\n		if(n1==n2)System.out.println(n1);\n		else System.out.println(-1);\n		\n		\n	}\n}\n},"greedy,math"
"import java.util.*;\n \npublic class p1367b{\n \n \n    public static void main(String []args){\n    Scanner sc=new Scanner(System.in);\n    int t=sc.nextInt();\n    while(t-->0)\n    {\n		int n=sc.nextInt();\n		int a=0,b=0;\n		int arr[]=new int[n];\n		for(int i=0;i<n;i++)\n		{\n		arr[i]=sc.nextInt();\n		if(i%2==1&&arr[i]%2==0)a++;\n		else if(i%2==0&&arr[i]%2==1)b++;\n		}\n		if(a==b)System.out.println(a);\n		else System.out.println(-1);\n    }\n    }\n}","greedy,math"
import java.util.Scanner;\n\npublic class cf1359_EduDiv2_D {\n	public static void main(String args[]) {\n		Scanner in = new Scanner(System.in);\n		int n = in.nextInt();\n		int[] arr = new int[n];\n		for (int i = 0; i < n; i++) {\n			arr[i] = in.nextInt();\n		}\n		\n		int max = 0;\n		for (int i = 0; i <= 30; i++) {\n			int m = 0;\n			for (int j = 0; j < n; j++) {\n				if (arr[j] > i) {\n					m = 0;\n					continue;\n				}\n				m += arr[j];\n				if (m < 0)\n					m = 0;\n				else if (m - i> max)\n				    max = m - i;\n			}\n		}\n		\n		System.out.println(max);\n	}\n}\n,"data structures,dp,implementation,two pointers"
"import java.util.*;\nimport java.io.*;\npublic class GFG {\n    public static void main (String[] args) {\n		Scanner sc=new Scanner(System.in);\n		PrintWriter out=new PrintWriter(System.out);\n		int n=sc.nextInt();\n	    int[] arr=new int[n];\n	    for(int i=0;i<n;i++)\n	    arr[i]=sc.nextInt();\n	    long ans=0;\n	    for(int i=0;i<31;i++){\n	        long cur=0,maxi=0;\n	        for(int j=0;j<n;j++)\n	    {\n	        long val=(arr[j]>i)?Integer.MIN_VALUE:arr[j];\n	        cur+=val;\n	        maxi=(long)Math.min(maxi,cur);\n	        ans=(long)Math.max(ans,cur-maxi-i);\n	    }\n	    }\n	    System.out.println(ans);\n    }\n}","data structures,dp,implementation,two pointers"
"import java.util.Scanner;\n\npublic class A {\n    public static int[] a = new int[100001];\n    public static int n;\n    public static void main(String[] args){\n        Scanner fs = new Scanner(System.in);\n        n = fs.nextInt();\n        for(int i = 0; i<n; i++){\n            a[i] = fs.nextInt();\n        }\n        int ans = 0;\n        for(int i = 0; i<31; i++){\n            int curr = 0;\n            for(int j = 0; j<n; j++){\n                if(a[j]>i || curr+a[j]<0)curr = 0;\n                else curr+=a[j];\n                ans = Math.max(ans,curr-i);\n            }\n        }\n        System.out.println(ans);\n        fs.close();\n    }\n}\n","data structures,dp,implementation,two pointers"
"import java.util.Scanner;\npublic class jr {\n   public static void main(String[] args) {\n      Scanner sc = new Scanner(System.in);\n      int n = sc.nextInt();\n      int[] a = new int[n];\n\n      for (int i = 0; i < a.length; i++) {\n         a[i] = sc.nextInt();\n      }\n      long ans = 0;\n      for(int i = 30 ; i>=1; i--) {\n         long max = 0;\n         for(int j = 0; j<n; j++) {\n            if(a[j] >i ) {\n               max = 0;\n               continue;\n            }\n\n            max += a[j];\n            max = Long.max( max, 0);\n            ans = Long.max(ans , max - i);\n            \n         }\n\n\n      }\n      System.out.println(ans);\n   }\n}","data structures,dp,implementation,two pointers"
import java.util.*;\npublic class aa {\n \n	public static void main(String[] args) {\n		Scanner x = new Scanner(System.in);\n		int t=x.nextInt();\n		while(t--!=0) {\n			int n = x.nextInt();\n			int k=4;\n			while(n%(k-1)!=0) {\n				k*=2;\n			}\n			System.out.println(n/(k-1));\n			\n			\n		}\n \n	}\n \n},"brute force,math"
import java.util.*;\npublic class aa {\n \n	public static void main(String[] args) {\n		Scanner x = new Scanner(System.in);\n		int t=x.nextInt();\n		while(t--!=0) {\n			int n = x.nextInt();\n			int k=4;\n			while(n%(k-1)!=0) {\n				k*=2;\n			}\n			System.out.println(n/(k-1));\n			\n			\n		}\n \n	}\n \n},"brute force,math"
import java.util.*;\npublic class Candies {\n \n	public static void main(String[] args) {\n		Scanner x = new Scanner(System.in);\n		int t=x.nextInt();\n		while(t--!=0) {\n			int n = x.nextInt();\n			int k=4;\n			while(n%(k-1)!=0) {\n				k*=2;\n			}\n			System.out.println(n/(k-1));\n			\n			\n		}\n \n	}\n \n},"brute force,math"
import java.util.*;\npublic class Candies {\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t--!=0) {\n			int n = sc.nextInt();\n			int k=4;\n			while(n%(k-1)!=0) {\n				k*=2;\n			}\n			System.out.println(n/(k-1));\n			\n			\n		}\n\n	}\n\n}\n,"brute force,math"
"import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Solution {\n    private static Scanner scanner = new Scanner(System.in);\n    private static long MOD = 998244353;\n\n    static class Tree {\n        private ArrayList<Integer>[] adj;\n        private boolean[] vis;\n        private long[] f, g, h;\n        // f: taken, but not colored\n        // g: taken and colored\n        // h: not taken\n\n        private void dfs(int u) {\n            vis[u] = true;\n            f[u] = 1;\n            g[u] = 1;\n            h[u] = 1;\n            for (int v : adj[u]) {\n                if (!vis[v]) {\n                    dfs(v);\n                    f[u] *= 2 * f[v] + 2 * g[v] - h[v];\n                    f[u] %= MOD;\n                    g[u] *= 2 * f[v] + g[v] - h[v];\n                    g[u] %= MOD;\n                    h[u] *= f[v] + g[v] - h[v];\n                    h[u] %= MOD;\n                }\n            }\n        }\n\n        public Tree(int n) {\n            adj = new ArrayList[n + 1];\n            for (int i = 1; i <= n; ++i)\n                adj[i] = new ArrayList();\n            f = new long[n + 1];\n            g = new long[n + 1];\n            h = new long[n + 1];\n            vis = new boolean[n + 1];\n        }\n\n        public void add(int u, int v) {\n            adj[u].add(v);\n            adj[v].add(u);\n        }\n\n        public void solve() {\n            dfs(1);\n            long ans = (f[1] + g[1] - h[1] - 1) % MOD;\n            if (ans < 0)\n                ans += MOD;\n            System.out.println(ans);\n        }\n    }\n\n    public static void main(String[] args) {\n        int n = scanner.nextInt();\n        Tree tree = new Tree(n);\n        for (int i = 0; i < n - 1; ++i) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            tree.add(u, v);\n        }\n        tree.solve();\n    }\n}\n","dfs and similar,dp,trees"
"import java.util.*;\nimport java.io.*;\n\npublic class F {\n\n\n    public static void main(String args[]) throws IOException {\n        FastScanner in = new FastScanner(System.in);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n        solve(in, out);\n        out.flush();\n    }\n\n\n    private static void solve(FastScanner in, BufferedWriter out) throws IOException {\n        int n = in.nextInt();\n        int mod = 998244353;\n        Set<Integer>[] e = new Set[n];\n        boolean[] visited = new boolean[n];\n        int[] parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            e[i] = new HashSet<>();\n        }\n        for (int i = 0; i < n - 1; i++) {\n            int a = in.nextInt() - 1;\n            int b = in.nextInt() - 1;\n            e[a].add(b);\n            e[b].add(a);\n        }\n        long[][] dp = new long[n][3];\n        Stack<Integer> s = new Stack<>();\n        s.push(0);\n        while (!s.isEmpty()) {\n            int cur = s.peek();\n            if (!visited[cur]) {\n                for (Integer adj : e[cur]) {\n                    if (!visited[adj]){\n                        s.push(adj);\n                        parent[adj] = cur;\n                    }\n                }\n                visited[cur] = true;\n            } else {\n                s.pop();\n                dp[cur][0] = 1;\n                dp[cur][1] = 1;\n                dp[cur][2] = 1;\n                for (Integer adj : e[cur]) {\n                    if (parent[cur] == adj) continue;\n                    dp[cur][0] = (dp[cur][0] * ((2 * dp[adj][0] + 2 * dp[adj][1] - dp[adj][2]) % mod)) % mod;\n                    dp[cur][1] = (dp[cur][1] * ((2 * dp[adj][0] + dp[adj][1] - dp[adj][2]) % mod)) % mod;\n                    dp[cur][2] = (dp[cur][2] * ((dp[adj][0] + dp[adj][1] - dp[adj][2]) % mod)) % mod;\n                }\n            }\n        }\n        System.out.println((dp[0][0] + dp[0][1] - dp[0][2] - 1 + 2 * mod) % mod);\n    }\n\n\n    private static class FastScanner {\n        private BufferedReader reader;\n\n        private StringTokenizer tokenizer;\n\n        public FastScanner(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n            tokenizer = null;\n        }\n\n        public FastScanner(InputStreamReader stream) {\n            reader = new BufferedReader(stream);\n            tokenizer = null;\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}\n","dfs and similar,dp,trees"
"import java.util.*;\nimport java.io.*;\n\npublic class F {\n\n\n    public static void main(String args[]) throws IOException {\n        FastScanner in = new FastScanner(System.in);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n        solve(in, out);\n        out.flush();\n    }\n\n\n    private static void solve(FastScanner in, BufferedWriter out) throws IOException {\n        int n = in.nextInt();\n        int mod = 998244353;\n        Set<Integer>[] e = new Set[n];\n        boolean[] visited = new boolean[n];\n        int[] parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            e[i] = new HashSet<>();\n        }\n        for (int i = 0; i < n - 1; i++) {\n            int a = in.nextInt() - 1;\n            int b = in.nextInt() - 1;\n            e[a].add(b);\n            e[b].add(a);\n        }\n        long[][] dp = new long[n][3];\n        Stack<Integer> s = new Stack<>();\n        s.push(0);\n        while (!s.isEmpty()) {\n            int cur = s.peek();\n            if (!visited[cur]) {\n                for (Integer adj : e[cur]) {\n                    if (!visited[adj]){\n                        s.push(adj);\n                        parent[adj] = cur;\n                    }\n                }\n                visited[cur] = true;\n            } else {\n                s.pop();\n                dp[cur][0] = 1;\n                dp[cur][1] = 1;\n                dp[cur][2] = 1;\n                for (Integer adj : e[cur]) {\n                    if (parent[cur] == adj) continue;\n                    dp[cur][0] = (dp[cur][0] * ((2 * dp[adj][0] + 2 * dp[adj][1] - dp[adj][2] + mod) % mod)) % mod;\n                    dp[cur][1] = (dp[cur][1] * ((2 * dp[adj][0] + dp[adj][1] - dp[adj][2] + mod) % mod)) % mod;\n                    dp[cur][2] = (dp[cur][2] * ((dp[adj][0] + dp[adj][1] - dp[adj][2] + mod) % mod)) % mod;\n                }\n            }\n        }\n        System.out.println((dp[0][0] + dp[0][1] - dp[0][2] - 1 + mod) % mod);\n    }\n\n\n    private static class FastScanner {\n        private BufferedReader reader;\n\n        private StringTokenizer tokenizer;\n\n        public FastScanner(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n            tokenizer = null;\n        }\n\n        public FastScanner(InputStreamReader stream) {\n            reader = new BufferedReader(stream);\n            tokenizer = null;\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}\n","dfs and similar,dp,trees"
"import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class C1332F {\n\n    static final boolean DEBUG = false;\n\n    public static void main(String[] args) {\n        var scanner = new BufferedScanner();\n        var writer = new PrintWriter(new BufferedOutputStream(System.out));\n\n        var n = scanner.nextInt();\n        var edges = new Edges[n + 1];\n        for (int i = 1; i <= n; i++) {\n            edges[i] = new Edges();\n        }\n        for (int i = 0; i < n - 1; i++) {\n            var u = scanner.nextInt();\n            var v = scanner.nextInt();\n            edges[u].to.add(v);\n            edges[v].to.add(u);\n        }\n        if (DEBUG) {\n            for (int root = 1; root <= n; root++) {\n                debug(""----------root: %d-----------"", root);\n                debug(""w(H): %d"", solve(root, n, edges));\n            }\n        } else {\n            writer.println(solve(1, n, edges));\n        }\n\n        scanner.close();\n        writer.flush();\n        writer.close();\n    }\n\n    static final long MODULO = 998244353;\n    static final long MAX_N = (long) 3e5;\n\n    private static long solve(int root, int n, Edges[] edges) {\n        var depth = new int[n + 1];\n        var parent = new int[n + 1];\n        var children = new Edges[n + 1];\n        for (int i = 1; i <= n; i++) {\n            children[i] = new Edges();\n        }\n        bfs(edges, root, depth, parent, children);\n        var leafToRoot = new ArrayList<Integer>();\n        for (int i = 1; i <= n; i++) {\n            leafToRoot.add(i);\n        }\n        leafToRoot.sort(Comparator.comparingInt(o -> depth[(int) o]).reversed());\n\n        var f0 = new long[n + 1]; // f0[u]:u不在IS中\n        var f1 = new long[n + 1]; // f1[u]:u在IS中\n        var f2 = new long[n + 1]; // f2[u]:u的孩子都不跟u相连\n\n        for (var u : leafToRoot) {\n            if (children[u].to.isEmpty()) {\n                f0[u] = 1;\n                f1[u] = 1;\n                f2[u] = 1;\n            } else {\n                f0[u] = 1;\n                f1[u] = 1;\n                f2[u] = 1;\n                for (var c : children[u].to) {\n                    f0[u] = f0[u] * (2 * f0[c] + 2 * f1[c] + MODULO - f2[c]) % MODULO;\n                    f1[u] = f1[u] * (2 * f0[c] + f1[c] + MODULO - f2[c]) % MODULO;\n                    f2[u] = f2[u] * (f0[c] + f1[c] + MODULO - f2[c]) % MODULO;\n                }\n            }\n        }\n//        printW(n, w, depth);\n//        countH(n, root, leafToRoot, parent, children);\n        return (f0[root] + f1[root] + 2 * MODULO - f2[root] - 1) % MODULO;\n    }\n\n    static void debug(String fmt, Object... args) {\n        if (DEBUG) {\n            System.out.println(String.format(fmt, args));\n        }\n    }\n\n    private static void countH(int n, int root, List<Integer> leafToRoot, int[] parent, Edges[] children) {\n        // h[i][j]：与w[i][j]的定义类似，不过这个是计算非空edge-induced subgraph的数量的。\n        var h = new HashMap<Long, Long>() {\n            long get(int u, int v) {\n                return get(hash(u, v));\n            }\n\n            void put(int u, int v, long value) {\n                put(hash(u, v), value);\n            }\n\n            private long hash(int u, int v) {\n                return u * (MAX_N + 1) + v;\n            }\n        };\n        var h2 = new long[n + 1];\n\n        for (var v : leafToRoot) {\n            var p = parent[v];\n            if (children[v].to.isEmpty()) { // v是叶子，往下走边都没有，所以不可能有非空H，也就不可能有IS(H)，所以w(H)==0\n                h.put(p, v, 0L);\n                h2[v] = 1L;\n            } else {\n                var acc = 1L;\n                var acc2 = 1L;\n                for (var c : children[v].to) {\n                    acc = mul(acc, h.get(v, c) // 用v-c和(v,c)子树的非空H\n                            + h.get(v, c) // 不用v-c，只用(v,c)子树的非空H\n                            + 1 // 只用v-c组成单边H{v-c}\n                            + 1 // 啥都不用，靠别人\n                    );\n                    acc2 *= 2 * h2[c];\n                }\n                h.put(p, v, minus(acc, 1));\n                h2[v] = acc2;\n            }\n        }\n\n        debug(""h: %d, h2: %d"", h.get(root, root), h2[root] - 1);\n    }\n\n    private static void printW(int n, long[][] w, int[] depth) {\n        var printList = new ArrayList<long[]>();\n        for (int vStatus = 0; vStatus < 3; vStatus++) {\n            for (int v = 1; v <= n; v++) {\n                printList.add(new long[]{v, vStatus, w[vStatus][v]});\n            }\n        }\n        printList.sort(Comparator.comparingInt(o -> depth[(int) o[0]]));\n        for (long[] longs : printList) {\n            debug(""w[%d,%d]=%d"", longs[0], longs[1], longs[2]);\n        }\n    }\n\n    private static long add(long... a) {\n        var ans = 0L;\n        for (long x : a) {\n            ans = (ans + x) % MODULO;\n        }\n        return ans;\n    }\n\n    private static long minus(long a, long b) {\n        return (a + MODULO - b) % MODULO;\n    }\n\n    private static long mul(long... a) {\n        var ans = 1L;\n        for (long x : a) {\n            ans = ans * x % MODULO;\n        }\n        return ans;\n    }\n\n    private static void bfs(Edges[] edges, int root, int[] depth, int[] parent, Edges[] children) {\n        var q = new LinkedList<Integer>();\n        q.add(root);\n        depth[root] = 0;\n        parent[root] = root;\n        while (q.size() > 0) {\n            var h = q.poll();\n            for (var v : edges[h].to) {\n                if (parent[v] == 0) {\n                    children[h].to.add(v);\n                    depth[v] = depth[h] + 1;\n                    parent[v] = h;\n                    q.add(v);\n                }\n            }\n        }\n    }\n\n    static class Edges {\n        List<Integer> to = new ArrayList<>();\n    }\n\n    public static class BufferedScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public BufferedScanner(Reader reader) {\n            br = new BufferedReader(reader);\n        }\n\n        public BufferedScanner() {\n            this(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        void close() {\n            try {\n                br.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n    static long gcd(long a, long b) {\n        if (a < b) {\n            return gcd(b, a);\n        }\n        while (b > 0) {\n            long tmp = b;\n            b = a % b;\n            a = tmp;\n        }\n        return a;\n    }\n\n    static long inverse(long a, long m) {\n        long[] ans = extgcd(a, m);\n        return ans[0] == 1 ? (ans[1] + m) % m : -1;\n    }\n\n    private static long[] extgcd(long a, long m) {\n        if (m == 0) {\n            return new long[]{a, 1, 0};\n        } else {\n            long[] ans = extgcd(m, a % m);\n            long tmp = ans[1];\n            ans[1] = ans[2];\n            ans[2] = tmp;\n            ans[2] -= ans[1] * (a / m);\n            return ans;\n        }\n    }\n\n    private static List<Integer> primes(double upperBound) {\n        var limit = (int) Math.sqrt(upperBound);\n        var isComposite = new boolean[limit + 1];\n        var primes = new ArrayList<Integer>();\n        for (int i = 2; i <= limit; i++) {\n            if (isComposite[i]) {\n                continue;\n            }\n            primes.add(i);\n            int j = i + i;\n            while (j <= limit) {\n                isComposite[j] = true;\n                j += i;\n            }\n        }\n        return primes;\n    }\n\n\n}\n","dfs and similar,dp,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1331C extends PrintWriter {\n	CF1331C() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1331C o = new CF1331C(); o.main(); o.flush();\n	}\n\n	int[] pp = { 4, 1, 3, 2, 0, 5 };\n	void main() {\n		int a = sc.nextInt();\n		int b = 0;\n		for (int i = 0; i < 6; i++)\n			if ((a & 1 << i) != 0)\n				b |= 1 << pp[i];\n		println(b);\n	}\n}\n","*special,bitmasks"
"import java.util.*;\nimport java.lang.*;\npublic class Cf1331C {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n,i=5,s=0,p,temp;\n		n=sc.nextInt();\n		int []arr=new int[6];\n		while(n!=0) {\n			arr[i]=n%2;\n			n=n/2;\n			i--;\n		}\n		temp=arr[2];\n		arr[2]=arr[3];\n		arr[3]=temp;\n		temp=arr[1];\n		arr[1]=arr[5];\n		arr[5]=temp;\n		p=5;\n		for (i=0;i<6;i++) {\n			s=s+arr[i]*(int)Math.pow(2,p);\n			p--;\n		}\n		System.out.println(s);\n		sc.close();\n	}\n\n}\n","*special,bitmasks"
"import java.util.*;\nimport java.lang.*;\npublic class Cf1331C {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n,i=5,s=0,p,temp;\n		n=sc.nextInt();\n		int []arr=new int[6];\n		while(n!=0) {\n			arr[i]=n%2;\n			n=n/2;\n			i--;\n		}\n		temp=arr[2];\n		arr[2]=arr[3];\n		arr[3]=temp;\n		temp=arr[1];\n		arr[1]=arr[5];\n		arr[5]=temp;\n		p=5;\n		for (i=0;i<6;i++) {\n			s=s+arr[i]*(int)Math.pow(2,p);\n			p--;\n		}\n		System.out.println(s);\n		sc.close();\n	}\n\n}\n","*special,bitmasks"
"/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be ""Main"" only if the class is public. */\npublic class Main\n{\n	static int ans(int i, int j){\n		return (i>>j)&1;\n	}\n	public static void main (String[] args) throws java.lang.Exception\n	{\n		// your code goes here\n		Scanner sc = new Scanner(System.in);\n		int a = sc.nextInt();\n		int res = (ans(a,5)<<5) + (ans(a,4)<<0) + (ans(a,3)<<2) + (ans(a,2)<<3) + (ans(a,1)<<1) + (ans(a,0)<<4);\n		System.out.println(res);\n	}\n}","*special,bitmasks"
"import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class C1320E {\n    public static void main(String[] args) {\n        var scanner = new BufferedScanner();\n        var writer = new PrintWriter(new BufferedOutputStream(System.out));\n\n        var n = scanner.nextInt();\n        // edges\n        var edges = new HashMap<Integer, List<Integer>>();\n        for (int i = 0; i < n - 1; i++) {\n            var x = scanner.nextInt();\n            var y = scanner.nextInt();\n            edges.putIfAbsent(x, new ArrayList<>());\n            edges.get(x).add(y);\n            edges.putIfAbsent(y, new ArrayList<>());\n            edges.get(y).add(x);\n        }\n        var order = new int[n + 1]; // 原编号->新编号\n        var orig = new int[n + 1]; // 新编号->原编号\n        var depth = new int[n + 1]; // 下标是原编号\n        var jump = new int[n + 1][(int) (Math.log(n + 1) / Math.log(2)) + 2]; // 第1维下标是原编号\n        prepare(n, edges, order, orig, depth, jump);\n\n        var q = scanner.nextInt();\n        var virusInit = new int[n + 1];\n        var spread = new int[n + 1];\n        for (int i = 0; i < q; i++) {\n            var k = scanner.nextInt();\n            var m = scanner.nextInt();\n            // virus\n            var cs = new HashSet<Integer>();\n            var infected = new HashMap<Integer, Integer>();\n            for (int j = 1; j <= k; j++) {\n                // start city\n                var v = scanner.nextInt(); // all different\n                // spreading speed\n                var s = scanner.nextInt();\n                virusInit[j] = v;\n                spread[j] = s;\n                infected.put(v, j);\n                cs.add(v);\n            }\n            // important cities\n            var important = new ArrayList<Integer>();\n            for (int j = 0; j < m; j++) {\n                int u = scanner.nextInt();\n                important.add(u);\n            }\n            cs.addAll(important);\n            var cities = new ArrayList<>(cs);\n            cities.sort(Comparator.comparingInt(o -> order[o]));\n\n            hardcore(depth, jump, virusInit, cities, spread, infected);\n\n            for (int j = 0; j < m; j++) {\n                writer.print(infected.get(important.get(j)) + "" "");\n            }\n            writer.println();\n        }\n\n        scanner.close();\n        writer.flush();\n        writer.close();\n    }\n\n    private static void hardcore(int[] depth, int[][] jump, int[] virusInit, List<Integer> cities, int[] spread,\n            Map<Integer, Integer> infected) {\n        if (cities.size() == 1) {\n            return;\n        }\n        // 从下到上来一遍\n        var lcaFrom = new HashMap<Integer, Set<Integer>>();\n        var stack = new LinkedList<int[]>();\n        stack.push(new int[]{cities.get(0), cities.get(1), lca(cities.get(0), cities.get(1), depth, jump)});\n        for (int i = 2; i < cities.size(); i++) {\n            var lca = lca(cities.get(i - 1), cities.get(i), depth, jump);\n            var c = cities.get(i - 1);\n            // 确保栈中lca深度是递增的\n            while (stack.size() > 0 && depth[lca] <= depth[stack.peek()[2]]) {\n                var top = stack.pop();\n                infectUp(top[0], c, top[2], depth, virusInit, spread, infected);\n//                infect(top[0], c, top[2], depth, jump, virusInit, spread, infected);\n                lcaFrom.putIfAbsent(top[2], new HashSet<>());\n                lcaFrom.get(top[2]).add(top[0]);\n                lcaFrom.get(top[2]).add(c);\n                c = top[2];\n            }\n            stack.push(new int[]{c, cities.get(i), lca});\n        }\n        if (stack.size() > 0) {\n            var c = stack.peek()[1];\n            while (stack.size() > 0) {\n                var top = stack.pop();\n                infectUp(top[0], c, top[2], depth, virusInit, spread, infected);\n//                infect(top[0], c, top[2], depth, jump, virusInit, spread, infected);\n                lcaFrom.putIfAbsent(top[2], new HashSet<>());\n                lcaFrom.get(top[2]).add(top[0]);\n                lcaFrom.get(top[2]).add(c);\n                c = top[2];\n            }\n        }\n        // 从上到下来一遍\n        var lcaList = new ArrayList<>(lcaFrom.keySet());\n        lcaList.sort(Comparator.comparingInt(o -> depth[o]));\n        for (var lca : lcaList) {\n            for (var child : lcaFrom.get(lca)) {\n                if (lca.equals(child)) {\n                    continue;\n                }\n                infect(lca, child, child, depth, jump, virusInit, spread, infected);\n            }\n        }\n    }\n\n    static int infinite = Integer.MAX_VALUE;\n\n    private static void infect(int a, int b, int target, int[] depth, int[][] jump, int[] virusInit, int[] spread,\n            Map<Integer, Integer> infected) {\n        var va = infected.getOrDefault(a, 0);\n        var vb = infected.getOrDefault(b, 0);\n        var turnsA = turns(dist(virusInit[va], target, depth, jump), spread[va]);\n        var turnsB = turns(dist(virusInit[vb], target, depth, jump), spread[vb]);\n        if (turnsA == infinite && turnsB == infinite) {\n            // 什么都不做\n        } else if (better(turnsA, va, turnsB, vb)) {\n            infected.put(target, va);\n        } else {\n            infected.put(target, vb);\n        }\n    }\n\n    private static boolean better(int turnsA, int va, int turnsB, int vb) {\n        return turnsA < turnsB || turnsA == turnsB && va < vb;\n    }\n\n    private static int dist(int a, int b, int[] depth, int[][] jump) {\n        var lca = lca(a, b, depth, jump);\n        return depth[a] - depth[lca] + depth[b] - depth[lca];\n    }\n\n    private static void infectUp(int a, int b, int lca, int[] depth, int[] virusInit, int[] spread,\n            Map<Integer, Integer> infected) {\n        var va = infected.getOrDefault(a, 0);\n        var vb = infected.getOrDefault(b, 0);\n        // 在沿着树向根走的过程中，initA和initB分别是a和b的孩子，所以也都是lca的孩子。\n        var turnsA = turns(depth[virusInit[va]] - depth[lca], spread[va]);\n        var turnsB = turns(depth[virusInit[vb]] - depth[lca], spread[vb]);\n        if (turnsA == infinite && turnsB == infinite) {\n            // 什么都不做\n        } else if (better(turnsA, va, turnsB, vb)) {\n            infected.put(lca, va);\n        } else {\n            infected.put(lca, vb);\n        }\n    }\n\n    private static int turns(int dist, int speed) {\n        return speed == 0 ? infinite : Math.floorDiv(dist - 1, speed) + 1;\n    }\n\n    private static int lca(int a, int b, int[] depth, int[][] jump) {\n        if (depth[a] < depth[b]) {\n            return lca(b, a, depth, jump);\n        }\n        // 先保持depth一致\n        {\n            var i = jump[a].length - 1;\n            while (depth[a] > depth[b]) {\n                while (jump[a][i] == 0 || depth[jump[a][i]] < depth[b]) {\n                    i--;\n                }\n                a = jump[a][i];\n            }\n        }\n        // 再开始找lca\n        {\n            var i = jump[a].length - 1;\n            while (a != b) {\n                while (i > 0 && jump[a][i] == jump[b][i]) {\n                    i--;\n                }\n                a = jump[a][i];\n                b = jump[b][i];\n            }\n        }\n        return a;\n    }\n\n    /**\n     * 做4件事：\n     * <p>\n     * 1）确定节点1为根。\n     * <p>\n     * 2）重新给节点排序，使得同一颗子树的节点彼此紧挨着，可以用一个区间表示；任何子树的根一定在子树其他节点的前面。\n     * <p>\n     * 3）计算每个节点的深度。\n     * <p>\n     * 4）计算每个节点往根节点方向的跳跃表。\n     */\n    private static void prepare(int n, Map<Integer, List<Integer>> edges, int[] order, int[] orig, int[] depth,\n            int[][] jump) {\n        var q = new LinkedList<Integer>();\n        var parent = new int[n + 1];\n        q.add(1);\n        depth[1] = 0;\n        parent[1] = 0;\n        var o = 1;\n        while (q.size() > 0) {\n            var h = q.poll();\n            order[h] = o++;\n            orig[order[h]] = h;\n            var children = edges.get(h);\n            if (children == null) {\n                continue;\n            }\n            for (var next : children) {\n                if (order[next] == 0) {\n                    q.addFirst(next);\n                    depth[next] = depth[h] + 1;\n                    parent[next] = h;\n                    calcJump(next, parent, jump);\n                }\n            }\n        }\n    }\n\n    private static void calcJump(int start, int[] parent, int[][] jump) {\n        var i = 0;\n        jump[start][i] = parent[start];\n        var x = parent[start];\n        while (x > 0) {\n            i++;\n            jump[start][i] = jump[x][i - 1];\n            x = jump[x][i - 1];\n        }\n    }\n\n    public static class BufferedScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public BufferedScanner(Reader reader) {\n            br = new BufferedReader(reader);\n        }\n\n        public BufferedScanner() {\n            this(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        void close() {\n            try {\n                br.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n    static long gcd(long a, long b) {\n        if (a < b) {\n            return gcd(b, a);\n        }\n        while (b > 0) {\n            long tmp = b;\n            b = a % b;\n            a = tmp;\n        }\n        return a;\n    }\n\n    static long inverse(long a, long m) {\n        long[] ans = extgcd(a, m);\n        return ans[0] == 1 ? (ans[1] + m) % m : -1;\n    }\n\n    private static long[] extgcd(long a, long m) {\n        if (m == 0) {\n            return new long[]{a, 1, 0};\n        } else {\n            long[] ans = extgcd(m, a % m);\n            long tmp = ans[1];\n            ans[1] = ans[2];\n            ans[2] = tmp;\n            ans[2] -= ans[1] * (a / m);\n            return ans;\n        }\n    }\n\n    private static List<Integer> primes(double upperBound) {\n        var limit = (int) Math.sqrt(upperBound);\n        var isComposite = new boolean[limit + 1];\n        var primes = new ArrayList<Integer>();\n        for (int i = 2; i <= limit; i++) {\n            if (isComposite[i]) {\n                continue;\n            }\n            primes.add(i);\n            int j = i + i;\n            while (j <= limit) {\n                isComposite[j] = true;\n                j += i;\n            }\n        }\n        return primes;\n    }\n\n\n}\n","data structures,dfs and similar,dp,shortest paths,trees"
"import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class C1320E {\n    public static void main(String[] args) {\n        var scanner = new BufferedScanner();\n        var writer = new PrintWriter(new BufferedOutputStream(System.out));\n\n        var n = scanner.nextInt();\n        // edges\n        var edges = new HashMap<Integer, List<Integer>>();\n        for (int i = 0; i < n - 1; i++) {\n            var x = scanner.nextInt();\n            var y = scanner.nextInt();\n            edges.putIfAbsent(x, new ArrayList<>());\n            edges.get(x).add(y);\n            edges.putIfAbsent(y, new ArrayList<>());\n            edges.get(y).add(x);\n        }\n        var order = new int[n + 1]; // 原编号->新编号\n        var depth = new int[n + 1]; // 下标是原编号\n        var jump = new int[n + 1][(int) (Math.log(n + 1) / Math.log(2)) + 2]; // 第1维下标是原编号\n        prepare(n, edges, order, depth, jump);\n\n        var q = scanner.nextInt();\n        var virusInit = new int[n + 1];\n        var spread = new int[n + 1];\n        for (int i = 0; i < q; i++) {\n            var k = scanner.nextInt();\n            var m = scanner.nextInt();\n            // virus\n            var cs = new HashSet<Integer>();\n            var infected = new HashMap<Integer, Integer>();\n            for (int j = 1; j <= k; j++) {\n                // start city\n                var v = scanner.nextInt(); // all different\n                // spreading speed\n                var s = scanner.nextInt();\n                virusInit[j] = v;\n                spread[j] = s;\n                infected.put(v, j);\n                cs.add(v);\n            }\n            // important cities\n            var important = new ArrayList<Integer>();\n            for (int j = 0; j < m; j++) {\n                int u = scanner.nextInt();\n                important.add(u);\n            }\n            cs.addAll(important);\n            var cities = new ArrayList<>(cs);\n            cities.sort(Comparator.comparingInt(o -> order[o]));\n\n            hardcore(depth, jump, virusInit, cities, spread, infected);\n\n            for (int j = 0; j < m; j++) {\n                writer.print(infected.get(important.get(j)) + "" "");\n            }\n            writer.println();\n        }\n\n        scanner.close();\n        writer.flush();\n        writer.close();\n    }\n\n    private static void hardcore(int[] depth, int[][] jump, int[] virusInit, List<Integer> cities, int[] spread,\n            Map<Integer, Integer> infected) {\n        if (cities.size() == 1) {\n            return;\n        }\n        // 从下到上来一遍\n//        var lcaFrom = new HashMap<Integer, Set<Integer>>();\n        var lcaFrom = new TreeMap<Integer, Set<Integer>>(\n                Comparator.comparingInt(i -> depth[(int) i]).thenComparingInt(i -> (int) i));\n        var stack = new LinkedList<int[]>();\n        stack.push(new int[]{cities.get(0), cities.get(1), lca(cities.get(0), cities.get(1), depth, jump)});\n        for (int i = 2; i < cities.size(); i++) {\n            var lca = lca(cities.get(i - 1), cities.get(i), depth, jump);\n            var c = cities.get(i - 1);\n            // 确保栈中lca深度是递增的\n            while (stack.size() > 0 && depth[lca] <= depth[stack.peek()[2]]) {\n                var top = stack.pop();\n                infectUp(top[0], c, top[2], depth, virusInit, spread, infected);\n//                infect(top[0], c, top[2], depth, jump, virusInit, spread, infected);\n                lcaFrom.putIfAbsent(top[2], new HashSet<>());\n                lcaFrom.get(top[2]).add(top[0]);\n                lcaFrom.get(top[2]).add(c);\n                c = top[2];\n            }\n            stack.push(new int[]{c, cities.get(i), lca});\n        }\n        if (stack.size() > 0) {\n            var c = stack.peek()[1];\n            while (stack.size() > 0) {\n                var top = stack.pop();\n                infectUp(top[0], c, top[2], depth, virusInit, spread, infected);\n//                infect(top[0], c, top[2], depth, jump, virusInit, spread, infected);\n                lcaFrom.putIfAbsent(top[2], new HashSet<>());\n                lcaFrom.get(top[2]).add(top[0]);\n                lcaFrom.get(top[2]).add(c);\n                c = top[2];\n            }\n        }\n        // 从上到下来一遍\n//        var lcaList = new ArrayList<>(lcaFrom.keySet());\n//        lcaList.sort(Comparator.comparingInt(o -> depth[o]));\n//        for (var lca : lcaList) {\n        for (var lca : lcaFrom.keySet()) {\n            for (var child : lcaFrom.get(lca)) {\n                if (lca.equals(child)) {\n                    continue;\n                }\n                infect(lca, child, child, depth, jump, virusInit, spread, infected);\n            }\n        }\n    }\n\n    static int infinite = Integer.MAX_VALUE;\n\n    private static void infect(int a, int b, int target, int[] depth, int[][] jump, int[] virusInit, int[] spread,\n            Map<Integer, Integer> infected) {\n        var va = infected.getOrDefault(a, 0);\n        var vb = infected.getOrDefault(b, 0);\n        var turnsA = turns(dist(virusInit[va], target, depth, jump), spread[va]);\n        var turnsB = turns(dist(virusInit[vb], target, depth, jump), spread[vb]);\n        if (turnsA == infinite && turnsB == infinite) {\n            // 什么都不做\n        } else if (better(turnsA, va, turnsB, vb)) {\n            infected.put(target, va);\n        } else {\n            infected.put(target, vb);\n        }\n    }\n\n    private static boolean better(int turnsA, int va, int turnsB, int vb) {\n        return turnsA < turnsB || turnsA == turnsB && va < vb;\n    }\n\n    private static int dist(int a, int b, int[] depth, int[][] jump) {\n        var lca = lca(a, b, depth, jump);\n        return depth[a] - depth[lca] + depth[b] - depth[lca];\n    }\n\n    private static void infectUp(int a, int b, int lca, int[] depth, int[] virusInit, int[] spread,\n            Map<Integer, Integer> infected) {\n        var va = infected.getOrDefault(a, 0);\n        var vb = infected.getOrDefault(b, 0);\n        // 在沿着树向根走的过程中，initA和initB分别是a和b的孩子，所以也都是lca的孩子。\n        var turnsA = turns(depth[virusInit[va]] - depth[lca], spread[va]);\n        var turnsB = turns(depth[virusInit[vb]] - depth[lca], spread[vb]);\n        if (turnsA == infinite && turnsB == infinite) {\n            // 什么都不做\n        } else if (better(turnsA, va, turnsB, vb)) {\n            infected.put(lca, va);\n        } else {\n            infected.put(lca, vb);\n        }\n    }\n\n    private static int turns(int dist, int speed) {\n        return speed == 0 ? infinite : Math.floorDiv(dist - 1, speed) + 1;\n    }\n\n    private static int lca(int a, int b, int[] depth, int[][] jump) {\n        if (depth[a] < depth[b]) {\n            return lca(b, a, depth, jump);\n        }\n        // 先保持depth一致\n        {\n            var i = jump[a].length - 1;\n            while (depth[a] > depth[b]) {\n                while (jump[a][i] == 0 || depth[jump[a][i]] < depth[b]) {\n                    i--;\n                }\n                a = jump[a][i];\n            }\n        }\n        // 再开始找lca\n        {\n            var i = jump[a].length - 1;\n            while (a != b) {\n                while (i > 0 && jump[a][i] == jump[b][i]) {\n                    i--;\n                }\n                a = jump[a][i];\n                b = jump[b][i];\n            }\n        }\n        return a;\n    }\n\n    /**\n     * 做4件事：\n     * <p>\n     * 1）确定节点1为根。\n     * <p>\n     * 2）重新给节点排序，使得同一颗子树的节点彼此紧挨着，可以用一个区间表示；任何子树的根一定在子树其他节点的前面。\n     * <p>\n     * 3）计算每个节点的深度。\n     * <p>\n     * 4）计算每个节点往根节点方向的跳跃表。\n     */\n    private static void prepare(int n, Map<Integer, List<Integer>> edges, int[] order, int[] depth, int[][] jump) {\n        var q = new LinkedList<Integer>();\n        var parent = new int[n + 1];\n        q.add(1);\n        depth[1] = 0;\n        parent[1] = 0;\n        var o = 1;\n        while (q.size() > 0) {\n            var h = q.poll();\n            order[h] = o++;\n            var children = edges.get(h);\n            if (children == null) {\n                continue;\n            }\n            for (var next : children) {\n                if (order[next] == 0) {\n                    q.addFirst(next);\n                    depth[next] = depth[h] + 1;\n                    parent[next] = h;\n                    calcJump(next, parent, jump);\n                }\n            }\n        }\n    }\n\n    private static void calcJump(int start, int[] parent, int[][] jump) {\n        var i = 0;\n        jump[start][i] = parent[start];\n        var x = parent[start];\n        while (x > 0) {\n            i++;\n            jump[start][i] = jump[x][i - 1];\n            x = jump[x][i - 1];\n        }\n    }\n\n    public static class BufferedScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public BufferedScanner(Reader reader) {\n            br = new BufferedReader(reader);\n        }\n\n        public BufferedScanner() {\n            this(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        void close() {\n            try {\n                br.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n    static long gcd(long a, long b) {\n        if (a < b) {\n            return gcd(b, a);\n        }\n        while (b > 0) {\n            long tmp = b;\n            b = a % b;\n            a = tmp;\n        }\n        return a;\n    }\n\n    static long inverse(long a, long m) {\n        long[] ans = extgcd(a, m);\n        return ans[0] == 1 ? (ans[1] + m) % m : -1;\n    }\n\n    private static long[] extgcd(long a, long m) {\n        if (m == 0) {\n            return new long[]{a, 1, 0};\n        } else {\n            long[] ans = extgcd(m, a % m);\n            long tmp = ans[1];\n            ans[1] = ans[2];\n            ans[2] = tmp;\n            ans[2] -= ans[1] * (a / m);\n            return ans;\n        }\n    }\n\n    private static List<Integer> primes(double upperBound) {\n        var limit = (int) Math.sqrt(upperBound);\n        var isComposite = new boolean[limit + 1];\n        var primes = new ArrayList<Integer>();\n        for (int i = 2; i <= limit; i++) {\n            if (isComposite[i]) {\n                continue;\n            }\n            primes.add(i);\n            int j = i + i;\n            while (j <= limit) {\n                isComposite[j] = true;\n                j += i;\n            }\n        }\n        return primes;\n    }\n\n\n}\n","data structures,dfs and similar,dp,shortest paths,trees"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\n/*\n3:03 start\n\n7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n1\n2 2\n4 1\n7 1\n1 3\n */\n\npublic class _525ETry2 {\n\n	public static void main(String[] args) {\n		FastScanner fs=new FastScanner();\n		int n=fs.nextInt();\n		Node[] nodes=new Node[n];\n		for (int i=0; i<n; i++) nodes[i]=new Node(i);\n		for (int i=1; i<n; i++) {\n			int a=fs.nextInt()-1, b=fs.nextInt()-1;\n			nodes[a].adj.add(nodes[b]);\n			nodes[b].adj.add(nodes[a]);\n		}\n		\n		nodes[0].dfs0(null, 0, 0);\n		for (int e=1; e<20; e++)\n			for (Node nn:nodes) if (nn.lift[e-1]!=null) nn.lift[e]=nn.lift[e-1].lift[e-1];\n		\n		int nQueries=fs.nextInt();\n		PrintWriter out=new PrintWriter(System.out);\n		for (int qq=0; qq<nQueries; qq++) {\n			clearVT();\n			TreeSet<Node> relevant=new TreeSet<>();\n			\n			int nViruses=fs.nextInt(), nImportant=fs.nextInt();\n			for (int i=0; i<nViruses; i++) {\n				int startAt=fs.nextInt()-1, speed=fs.nextInt();\n				relevant.add(nodes[startAt]);\n				nodes[startAt].gotVirusFrom=nodes[startAt];\n				nodes[startAt].virusSpeed=speed;\n				nodes[startAt].virusID=i;\n				relevant.add(nodes[startAt]);\n			}\n			Node[] queries=new Node[nImportant];\n			for (int i=0; i<nImportant; i++) {\n				int city=fs.nextInt()-1;\n				queries[i]=nodes[city];\n				relevant.add(nodes[city]);\n			}\n			buildVT(relevant);\n			Node root=inVirtualTree.first();\n			root.dfs1();\n			root.dfs2();\n			\n			for (Node nn:queries) {\n				out.print(nn.gotVirusFrom.virusID+1+"" "");\n			}\n			out.println();\n		}\n		out.close();\n	}\n	\n	static TreeSet<Node> inVirtualTree=new TreeSet<>();\n	\n	static void buildVT(TreeSet<Node> relevant) {\n		ArrayDeque<Node> bfs=new ArrayDeque<>();\n		for (Node nn:relevant) {\n			bfs.add(nn);\n			inVirtualTree.add(nn);\n		}\n		while (!bfs.isEmpty()) {\n			Node next=bfs.remove();\n			Node before=inVirtualTree.lower(next);\n			Node after=inVirtualTree.higher(next.rightmostKid);\n			Node par=null;\n			if (before != null) {\n				Node lca=before.lca(next, 19);\n				if (!inVirtualTree.contains(lca)) {\n					bfs.add(lca);\n					inVirtualTree.add(lca);\n				}\n				if (par==null || par.depth<lca.depth) par=lca;\n			}\n			if (after != null) {\n				Node lca=after.lca(next.rightmostKid, 19);\n				if (!inVirtualTree.contains(lca)) {\n					bfs.add(lca);\n					inVirtualTree.add(lca);\n				}\n				if (par==null || par.depth<lca.depth) par=lca;\n			}\n			if (par!=null) {\n				next.parInVT=par;\n				par.adjInVT.add(next);\n			}\n		}\n	}\n	\n	static void clearVT() {\n		for (Node nn:inVirtualTree) {\n			nn.adjInVT.clear();\n			nn.parInVT=null;\n			nn.gotVirusFrom=null;\n		}\n		inVirtualTree.clear();\n	}\n	\n	static class Node implements Comparable<Node> {\n		ArrayList<Node> adj=new ArrayList<>();\n		Node[] lift=new Node[20];\n		int preorder, postorder, depth;\n		int index;\n		\n		ArrayList<Node> adjInVT=new ArrayList<>();\n		Node parInVT, rightmostKid=this, gotVirusFrom=null;\n		int virusSpeed, virusID;\n		\n		public Node(int index) {\n			this.index=index;\n		}\n		\n		public int dfs0(Node par, int counter, int depth) {\n			this.preorder=counter;\n			this.depth=depth;\n			lift[0]=par;\n			if (par!=null)\n				adj.remove(par);\n			for (Node nn:adj) {\n				counter=nn.dfs0(this, 1+counter, depth+1);\n				rightmostKid=nn.rightmostKid;\n			}\n			return this.postorder=counter;\n		}\n		\n		public void dfs1() {\n			for (Node nn:adjInVT) {\n				nn.dfs1();\n				getSickFrom(nn.gotVirusFrom);\n			}\n		}\n		\n		public void dfs2() {\n			if (parInVT!=null) getSickFrom(parInVT.gotVirusFrom);\n			for (Node nn:adjInVT)\n				nn.dfs2();\n		}\n		\n		public void getSickFrom(Node o) {\n			if (gotVirusFrom==null) {\n				gotVirusFrom=o;\n				return;\n			}\n			if (o==null) return;\n			int curDist=gotVirusFrom.dist(this);\n			int nextDist=o.dist(this);\n			int curSpeed=gotVirusFrom.virusSpeed, nextSpeed=o.virusSpeed;\n			int curTime=(curDist+curSpeed-1)/curSpeed;\n			int nextTime=(nextDist+nextSpeed-1)/nextSpeed;\n			if (curTime>nextTime || (curTime==nextTime && gotVirusFrom.virusID>o.virusID)) {\n				gotVirusFrom=o;\n			}\n		}\n		\n		public int compareTo(Node o) {\n			return Integer.compare(preorder, o.preorder);\n		}\n		\n		public Node goUp(int toGoUp) {\n			if (toGoUp==0) return this;\n			int lowest=Integer.lowestOneBit(toGoUp);\n			return lift[Integer.numberOfTrailingZeros(lowest)].goUp(toGoUp-lowest);\n		}\n		\n		public Node lca(Node o, int maxLift) {\n			if (depth!=o.depth) {\n				if (depth>o.depth)\n					return goUp(depth-o.depth).lca(o, maxLift);\n				else \n					return lca(o.goUp(o.depth-depth), maxLift);\n			}\n			if (this==o) return this;\n			if (lift[0]==o.lift[0]) return lift[0];\n			while (lift[maxLift]==o.lift[maxLift])\n				maxLift--;\n			return lift[maxLift].lca(o.lift[maxLift], maxLift);\n		}\n		\n		int dist(Node o) {\n			Node lca=lca(o, 19);\n			return depth+o.depth-lca.depth*2;\n		}\n		\n		public String toString() {\n			return index+1+"""";\n		}\n	}\n	\n	static class FastScanner {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n\n		String next() {\n			while (!st.hasMoreElements())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n	}\n\n}\n","data structures,dfs and similar,dp,shortest paths,trees"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\n/*\n\n7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n1\n2 2\n4 3\n7 1\n1 3\n\n7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n1\n3 3\n1 1\n4 100\n7 100\n1 2 3\n\n1\n1\n1 1\n1 100\n1\n\n7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n3\n\n1 1\n1 100\n1\n\n1 1\n1 100\n7\n\n1 1\n5 7\n1\n\n2\n2 1\n2\n\n2 2\n1 100\n2 1000000\n1 2\n\n1 2\n2 100\n1 2\n */\npublic class _525E {\n\n	public static void main(String[] args) throws InterruptedException {\n		Thread t=new Thread(null, null, ""T"", 1<<27) {\n			public void run() {\n				go();\n			}\n		};\n		t.start();\n		t.join();\n	}\n	\n	static void go() {\n		FastScanner fs=new FastScanner();\n		int n=fs.nextInt();\n		Node[] nodes=new Node[n];\n		for (int i=0; i<n; i++) nodes[i]=new Node(i);\n		for (int i=1; i<n; i++) {\n			int a=fs.nextInt()-1, b=fs.nextInt()-1;\n			nodes[a].adj.add(nodes[b]);\n			nodes[b].adj.add(nodes[a]);\n		}\n		nodes[0].dfs0(null, 0, 0);\n		for (int e=1; e<20; e++)\n			for (Node nn:nodes) \n				if (nn.lift[e-1]!=null) \n					nn.lift[e]=nn.lift[e-1].lift[e-1];\n	\n		int nQueries=fs.nextInt();\n		for (int qq=0; qq<nQueries; qq++) {\n			clearVT();\n			\n			int nViruses=fs.nextInt();\n			int nImportant=fs.nextInt();\n			TreeSet<Node> relevant=new TreeSet<>();\n			for (int i=0; i<nViruses; i++) {\n				int getVir=fs.nextInt()-1, travelSpeed=fs.nextInt();\n				nodes[getVir].gotVirusFrom=nodes[getVir];\n				nodes[getVir].travelSpeed=travelSpeed;\n				nodes[getVir].virusNumber=i;\n				relevant.add(nodes[getVir]);\n			}\n			Node[] importantNodes=new Node[nImportant];\n			for (int i=0; i<nImportant; i++) importantNodes[i]=nodes[fs.nextInt()-1];\n			for (Node nn:importantNodes) relevant.add(nn);\n			\n			buildVirtualTree(relevant);\n\n			Node root=inVirtualTree.first();\n			root.virtualDFS1();\n			root.virtualDFS2();\n			for (Node query:importantNodes) {\n				System.out.print(query.gotVirusFrom.virusNumber+1+"" "");\n			}\n			System.out.println();\n		}\n		\n	}\n	\n	static ArrayDeque<Node> bfs=new ArrayDeque<>();\n	static TreeSet<Node> inVirtualTree=new TreeSet<>();\n	\n	static void buildVirtualTree(TreeSet<Node> specialNodes) {\n		\n		for (Node nn:specialNodes)\n			addToVT(nn);\n		\n		while (!bfs.isEmpty()) {\n			Node next=bfs.remove();\n			Node previous=inVirtualTree.lower(next);\n			Node after=inVirtualTree.higher(next.rightmostKid);\n			Node lcaPar=null;\n			if (previous!=null) {\n				Node lca=previous.lca(next, 19);\n				addToVT(lca);\n				if (lcaPar==null || lcaPar.depth<lca.depth) lcaPar=lca;\n			}\n			if (after!=null) {\n				Node lca=next.lca(after, 19);\n				addToVT(lca);\n				if (lcaPar==null || lcaPar.depth<lca.depth) lcaPar=lca;\n			}\n			if (lcaPar!=null && lcaPar!=next) {\n				next.parInVT=lcaPar;\n				lcaPar.virtualAdj.add(next);\n			}\n		}\n	}\n	\n	static void clearVT() {\n		bfs.clear();\n		for (Node nn:inVirtualTree) {\n			nn.parInVT=null;\n			nn.virtualAdj.clear();\n			nn.gotVirusFrom=null;\n		}\n		inVirtualTree.clear();\n	}\n	\n	static void addToVT(Node n) {\n		if (inVirtualTree.contains(n)) return;\n		inVirtualTree.add(n);\n		bfs.add(n);\n	}\n	\n	static class Node implements Comparable<Node> {\n		Node[] lift=new Node[20];\n		ArrayList<Node> adj=new ArrayList<>();\n		int preorder, postorder, depth, index;\n		Node rightmostKid;\n		\n		Node parInVT;\n		ArrayList<Node> virtualAdj=new ArrayList<>();\n		Node gotVirusFrom;\n		int travelSpeed, virusNumber;\n		\n		public Node(int index) {\n			this.index=index;\n			rightmostKid=this;\n		}\n		\n		public int dfs0(Node par, int counter, int depth) {\n			this.preorder=counter;\n			this.depth=depth;\n			lift[0]=par;\n			if (par!=null)\n				adj.remove(par);\n			\n			for (Node nn:adj) {\n				counter=nn.dfs0(this, counter+1, depth+1);\n				rightmostKid=nn.rightmostKid;\n			}\n			\n			return this.postorder=counter;\n		}\n		\n		public void virtualDFS1() {\n			for (Node nn:virtualAdj) {\n				nn.virtualDFS1();\n				getSickFromIfScarier(nn.gotVirusFrom);\n			}\n		}\n		\n		public void virtualDFS2() {\n			if (parInVT!=null) {\n				getSickFromIfScarier(parInVT.gotVirusFrom);\n			}\n			for (Node nn:virtualAdj) {\n				nn.virtualDFS2();\n			}\n		}\n		\n		public int compareTo(Node o) {\n			return Integer.compare(preorder, o.preorder);\n		}\n		\n		Node goUp(int toGoUp) {\n			if (toGoUp==0) return this;\n			int lowest=Integer.lowestOneBit(toGoUp);\n			int exp=Integer.numberOfTrailingZeros(lowest);\n			return lift[exp].goUp(toGoUp-lowest);\n		}\n		\n		Node lca(Node o, int maxJump) {\n			if (this==o) return this;\n			if (depth!=o.depth) {\n				if (depth>o.depth) return goUp(depth-o.depth).lca(o, 19);\n				return lca(o.goUp(o.depth-depth), 19);\n			}\n			if (lift[0]==o.lift[0]) return lift[0];\n			while (lift[maxJump]==o.lift[maxJump]) maxJump--;\n			return lift[maxJump].lca(o.lift[maxJump], maxJump);\n		}\n		\n		boolean contains(Node o) {\n			return o.preorder>=preorder && o.preorder<=postorder;\n		}\n		\n		static int dist(Node n1, Node n2) {\n			Node lca=n1.lca(n2, 19);\n			return n1.depth+n2.depth-2*lca.depth;\n		}\n		\n		void getSickFromIfScarier(Node cand) {\n			if (cand==null) return;\n			if (gotVirusFrom==null) {\n				gotVirusFrom=cand;\n				return;\n			}\n			int curDist=dist(this, gotVirusFrom);\n			int curTurns=(curDist+gotVirusFrom.travelSpeed-1)/gotVirusFrom.travelSpeed;\n			int nextDist=dist(this, cand);\n			int nextTurns=(nextDist+cand.travelSpeed-1)/cand.travelSpeed;\n			//TODO: don't overwrite things you start with\n			if (nextTurns < curTurns || (curTurns==nextTurns && gotVirusFrom.virusNumber>cand.virusNumber)) {\n				gotVirusFrom=cand;\n			}\n		}\n		\n		public String toString() {\n			return index+1+"""";\n		}\n	}\n	\n	static class FastScanner {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n\n		String next() {\n			while (!st.hasMoreElements())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n	}\n\n}\n","data structures,dfs and similar,dp,shortest paths,trees"
"//package com.company;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static class Task {\n        int mod = 1000000007;\n        int add(int a, int b) {\n            int c = a + b;\n            if (c >= mod) return c - mod;\n            return c;\n        }\n\n        int mul(int a, int b) {\n            return (int) ((long) a * b % mod);\n        }\n\n        int pow(int a, int b) {\n            int r = 1;\n            while (b > 0) {\n                if (b % 2 == 1) r = mul(r, a);\n                a = mul(a, a);\n                b >>= 1;\n            }\n            return r;\n        }\n\n\n        int[] pow2;\n\n        public class SegTree {\n\n            public class NodeVal {\n                int len, leftVal, rightVal, totVal;\n                public NodeVal(int len, int ini) {\n                    this.len = len;\n                    leftVal = rightVal = ini;\n                    totVal = 0;\n                }\n                void set(int len, int ini) {\n                    this.len = len;\n                    leftVal = rightVal = ini;\n                }\n                public void from(NodeVal left, NodeVal right) {\n                    this.len = left.len + right.len;\n                    this.leftVal = add(right.leftVal, mul(left.leftVal, pow2[right.len]));\n                    this.rightVal = add(left.rightVal, mul(right.rightVal, pow2[left.len]));\n                    this.totVal = add(mul(left.rightVal, right.leftVal),\n                            add(mul(left.totVal, pow2[right.len]), mul(right.totVal, pow2[left.len])));\n                }\n            }\n            NodeVal[] nodes;\n            int T;\n            public SegTree(int n) {\n                T = 1;\n                while (T < n) T <<= 1;\n                nodes = new NodeVal[T << 1];\n                for (int i = 0; i < T << 1; i++) {\n                    nodes[i] = new NodeVal(0, 0);\n                }\n            }\n\n            void update(int index, int len, int val) {\n                nodes[index += T].set(len, val);\n                while (index > 1) {\n                    int parent = index >> 1;\n                    int left = parent << 1;\n                    int right = parent << 1 | 1;\n                    nodes[parent].from(nodes[left], nodes[right]);\n                    index >>= 1;\n                }\n            }\n        }\n\n        int solve(int[] strength) {\n            int n = strength.length;\n            Arrays.sort(strength);\n            int ret = 0;\n            for (int i = 0; i < n; i++) {\n                int ps = 0;\n                for (int j = i - 1; j >= 0; j--) {\n                    ps = mul(ps, 2);\n                    ps = add(ps, strength[j]);\n                }\n                ps = mul(ps, pow(2, n - 1 - i));\n                int ss = 0;\n                for (int j = i + 1; j < n; j++) {\n                    ss = mul(ss, 2);\n                    ss = add(ss, strength[j]);\n                }\n                ss = mul(ss, pow(2, i));\n                ret = add(ret, mul(add(ps, ss), strength[i]));\n            }\n            return mul(ret, pow(pow(2, n + 1), mod - 2));\n        }\n\n        public class Pair {\n            int a, b;\n\n            public Pair(int a, int b) {\n                this.a = a;\n                this.b = b;\n            }\n        }\n\n        public void solve(Scanner sc, PrintWriter pw) throws IOException {\n            int n = sc.nextInt();\n            int[] a = new int[n];\n            int[] attachedIndex = new int[n];\n            List<Pair> ps = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                a[i] = sc.nextInt();\n                ps.add(new Pair(a[i], -(i + 1)));\n            }\n            int q = sc.nextInt();\n            int[][] queries = new int[q][2];\n            for (int i = 0; i < q; i++) {\n                for (int j = 0; j < 2; j++) {\n                    queries[i][j] = sc.nextInt();\n                }\n                queries[i][0]--;\n                ps.add(new Pair(queries[i][1], i));\n            }\n            ps.sort(new Comparator<Pair>() {\n                @Override\n                public int compare(Pair o1, Pair o2) {\n                    return o1.a - o2.a;\n                }\n            });\n            int[] queryIndex = new int[q];\n            int N = ps.size();\n            for (int i = 0; i < N; i++) {\n                if (ps.get(i).b < 0) {\n                    attachedIndex[(-ps.get(i).b) - 1] = i;\n                } else {\n                    queryIndex[ps.get(i).b] = i;\n                }\n            }\n            int inv2 = pow(pow(2, n), mod - 2);\n            pow2 = new int[N + 1];\n            pow2[0] = 1;\n            for (int i = 1; i <= N; i++) {\n                pow2[i] = mul(pow2[i - 1], 2);\n            }\n            SegTree st = new SegTree(N);\n            for (int i = 0; i < n; i++) {\n                st.update(attachedIndex[i], 1, a[i]);\n            }\n            int sol = mul(inv2, st.nodes[1].totVal);\n//            System.err.println(Arrays.toString(attachedIndex));\n//            System.err.println(sol);\n//            System.err.println(solve(Arrays.copyOf(a, a.length)));\n//            if (sol != solve(Arrays.copyOf(a, a.length))) throw new RuntimeException();\n            pw.println(sol);\n            for (int i = 0; i < q; i++) {\n                int index = queries[i][0], value = queries[i][1];\n                st.update(attachedIndex[index], 0, 0);\n                st.update(attachedIndex[index] = queryIndex[i], 1, a[index] = value);\n                sol = mul(inv2, st.nodes[1].totVal);\n//                if (sol != solve(Arrays.copyOf(a, a.length))) throw new RuntimeException();\n                pw.println(sol);\n            }\n        }\n    }\n\n    static long TIME_START, TIME_END;\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n//        Scanner sc = new Scanner(new FileInputStream(""input""));\n        PrintWriter pw = new PrintWriter(new BufferedOutputStream(System.out));\n//        PrintWriter pw = new PrintWriter(new FileOutputStream(""input""));\n\n        Runtime runtime = Runtime.getRuntime();\n        long usedMemoryBefore = runtime.totalMemory() - runtime.freeMemory();\n        TIME_START = System.currentTimeMillis();\n        Task t = new Task();\n        t.solve(sc, pw);\n        TIME_END = System.currentTimeMillis();\n        long usedMemoryAfter = runtime.totalMemory() - runtime.freeMemory();\n        pw.close();\n        System.err.println(""Memory increased: "" + (usedMemoryAfter - usedMemoryBefore) / 1000000);\n        System.err.println(""Time used: "" + (TIME_END - TIME_START) + ""."");\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public Scanner(FileReader s) throws FileNotFoundException {\n            br = new BufferedReader(s);\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n}","data structures,divide and conquer,probabilities"
"import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.math.BigInteger;\nimport java.util.Locale;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class Solution4 implements Runnable {\n	\n	public static final int M = 1000000000 + 7;\n	public static final int I2 = modinv(2);\n	\n	private static Random rnd = new Random(366239);\n	\n	private PrintStream out;\n	private BufferedReader in;\n	private StringTokenizer st;\n	\n	public void solve() throws IOException {\n		long time0 = System.currentTimeMillis();\n		\n		int n = nextInt();\n		int[] p = new int[n];\n		for (int i = 0; i < n; i++) {\n			p[i] = nextInt();\n		}\n		int q = nextInt();\n		int[] qi = new int[q];\n		int[] qx = new int[q];\n		for (int i = 0; i < q; i++) {\n			qi[i] = nextInt() - 1;\n			qx[i] = nextInt();\n		}\n		int[] answer = solve(n, p, q, qi, qx);\n		out.println(answer[0]);\n		for (int i = 0; i < q; i++) {\n			out.println(answer[1 + i]);\n		}\n		\n		\n		System.err.println(""time: "" + (System.currentTimeMillis() - time0));\n	}\n	\n	private int[] solve(int n, int[] p, int q, int[] qi, int[] qx) {\n		MyNode root = null;\n		int[] sum = new int[] {0};\n		for (int i = 0; i < n; i++) {\n			root = insert(root, i, p[i], sum);\n		}\n		int[] result = new int[1 + q];\n		result[0] = sum[0];\n		for (int qn = 0; qn < q; qn++) {\n			root = remove(root, qi[qn], p[qi[qn]], sum);\n			p[qi[qn]] = qx[qn];\n			root = insert(root, qi[qn], p[qi[qn]], sum);\n			result[1 + qn] = sum[0];\n		}\n		int div = 1;\n		for (int i = 0; i < n; i++) {\n			div = (int) ((1L * div * I2) % M);\n		}\n		for (int i = 0; i < result.length; i++) {\n			result[i] = (int) ((1L * result[i] * div) % M);\n		}\n		return result;\n	}\n	\n	private MyNode insert(MyNode root, int i, int p, int[] sum) {\n		MyNodePair pair = split(root, i, p);\n		sum[0] = (int) (((sum[0] - 1L * MyNode.getLeftSum(pair.left) * MyNode.getRightSum(pair.right)) % M + M) % M);\n		sum[0] = (int) ((1L * sum[0] * 2) % M);\n		sum[0] = (int) (((sum[0] + 1L * MyNode.getLeftSum(pair.left) * MyNode.getRightSum(pair.right)) % M + M) % M);\n		\n		sum[0] = (int) (((sum[0] + p * ((1L * MyNode.getLeftSum(pair.left) * MyNode.getPow(pair.right)) % M)) % M + M) % M);\n		sum[0] = (int) (((sum[0] + p * ((1L * MyNode.getPow(pair.left) * MyNode.getRightSum(pair.right)) % M)) % M + M) % M);\n		return join(pair.left, join(new MyNode(i, p), pair.right));\n	}\n\n	private MyNode remove(MyNode root, int i, int p, int[] sum) {\n		MyNodePair pair = split(root, i, p);\n		sum[0] = (int) (((sum[0] - p * ((1L * MyNode.getLeftSum(pair.left) * MyNode.getPow(pair.right)) % M)) % M + M) % M);\n		sum[0] = (int) (((sum[0] - p * ((1L * MyNode.getPow(pair.left) * MyNode.getRightSum(pair.right)) % M)) % M + M) % M);\n		\n		sum[0] = (int) (((sum[0] - 1L * MyNode.getLeftSum(pair.left) * MyNode.getRightSum(pair.right)) % M + M) % M);\n		sum[0] = (int) ((1L * sum[0] * I2) % M);\n		sum[0] = (int) (((sum[0] + 1L * MyNode.getLeftSum(pair.left) * MyNode.getRightSum(pair.right)) % M + M) % M);\n		return join(pair.left, pair.right);\n	}\n\n	private static MyNodePair split(MyNode node, int key_ind, int key_val) {\n		if (node == null) {\n			return new MyNodePair(null, null);\n		}\n		if (key_val < node.key_val || (key_val == node.key_val && key_ind < node.key_ind)) {\n			MyNodePair result = split(node.left, key_ind, key_val);\n			// Not persistent dirty hack\n			node.left = result.right;\n			node.recalc();\n			result.right = node;\n			return result;\n		} else if (key_val > node.key_val || (key_val == node.key_val && key_ind > node.key_ind)) {\n			MyNodePair result = split(node.right, key_ind, key_val);\n			// Not persistent dirty hack\n			node.right = result.left;\n			node.recalc();\n			result.left = node;\n			return result;\n		} else {\n			return new MyNodePair(node.left, node.right);\n		}\n	}\n		\n	private static MyNode join(MyNode left, MyNode right) {\n		if (left == null) {\n			return right;\n		}\n		if (right == null) {\n			return left;\n		}\n		if (left.heap < right.heap) {\n			// Not persistent dirty hack\n			left.right = join(left.right, right);\n			left.recalc();\n			return left;\n		} else {\n			// Not persistent dirty hack\n			right.left = join(left, right.left);\n			right.recalc();\n			return right;\n		}\n	}\n\n	public static class MyNodePair {\n		public MyNode left;\n		public MyNode right;\n		public MyNodePair(MyNode left, MyNode right) {\n			this.left = left;\n			this.right = right;\n		}\n	}\n	\n	public static class MyNode {\n		public int key_ind;\n		public int key_val;\n		public int heap;\n		public MyNode left;\n		public MyNode right;\n		\n		public int pow;\n		public int leftSum;\n		public int rightSum;\n		\n		public MyNode(int key_ind, int key_val) {\n			this(key_ind, key_val, rnd.nextInt(), null, null);\n		}\n		\n		public MyNode(int key_ind, int key_val, int heap, MyNode left, MyNode right) {\n			this.key_ind = key_ind;\n			this.key_val = key_val;\n			this.heap = heap;\n			this.left = left;\n			this.right = right;\n			recalc();\n		}\n		\n		public void recalc() {\n			pow = (int) ((2L * getPow(left) * getPow(right)) % M);\n			long leftSum = (getLeftSum(left) + 1L * key_val * getPow(left)) % M;\n			leftSum = (leftSum + getLeftSum(right) * 2L * getPow(left)) % M;\n			this.leftSum = (int) leftSum;\n			long rightSum = (getRightSum(right) + 1L * key_val * getPow(right)) % M;\n			rightSum = (rightSum + getRightSum(left) * 2L * getPow(right)) % M;\n			this.rightSum = (int) rightSum;\n		}\n		\n		private static int getPow(MyNode node) {\n			if (node == null) {\n				return 1;\n			} else {\n				return node.pow;\n			}\n		}\n		private static int getLeftSum(MyNode node) {\n			if (node == null) {\n				return 0;\n			} else {\n				return node.leftSum;\n			}\n		}\n		private static int getRightSum(MyNode node) {\n			if (node == null) {\n				return 0;\n			} else {\n				return node.rightSum;\n			}\n		}\n	}\n\n	private static int modinv(long x) {\n		BigInteger xb = BigInteger.valueOf(x);\n		BigInteger mb = BigInteger.valueOf(M);\n		BigInteger result = xb.modInverse(mb);\n		return result.intValue();\n	}\n	\n	public double nextDouble() throws IOException {\n		return Double.parseDouble(next());\n	}\n	\n	public long nextLong() throws IOException {\n		return Long.parseLong(next());\n	}\n	\n	public int nextInt() throws IOException {\n		return Integer.parseInt(next());\n	}\n	\n	public String next() throws IOException {\n		while (!st.hasMoreTokens()) {\n			String line = in.readLine();\n			if (line == null) {\n				return null;\n			}\n			st = new StringTokenizer(line);\n		}\n		return st.nextToken();\n	}\n	\n	@Override\n	public void run() {\n		try {\n			solve();\n			out.close();\n		} catch (Throwable e) {\n			throw new RuntimeException(e);\n		}\n	}\n	\n	public Solution4(String name) throws IOException {\n		Locale.setDefault(Locale.US);\n		if (name == null) {\n			in = new BufferedReader(new InputStreamReader(System.in));\n			out = new PrintStream(new BufferedOutputStream(System.out));\n		} else {\n			in = new BufferedReader(new InputStreamReader(new FileInputStream(name + "".in"")));\n			out = new PrintStream(new BufferedOutputStream(new FileOutputStream(name + "".out"")));\n		}\n		st = new StringTokenizer("""");\n	}\n	\n	public static void main(String[] args) throws IOException {\n		new Thread(new Solution4(null)).start();\n	}\n}\n","data structures,divide and conquer,probabilities"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FBattalionStrength solver = new FBattalionStrength();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FBattalionStrength {\n        Modular mod = new Modular(1e9 + 7);\n        Power power = new Power(mod);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n\n            int inv2 = power.inverseByFermat(2);\n\n            int n = in.readInt();\n            int[] val = new int[n + 1];\n\n            for (int i = 1; i <= n; i++) {\n                int x = in.readInt();\n                val[i] = x;\n                //root = add(root, create(x));\n            }\n\n            int q = in.readInt();\n            int[][] qs = new int[q][2];\n            for (int i = 0; i < q; i++) {\n                for (int j = 0; j < 2; j++) {\n                    qs[i][j] = in.readInt();\n                }\n            }\n\n            IntegerList list = new IntegerList(n + q);\n            for (int i = 1; i <= n; i++) {\n                list.add(val[i]);\n            }\n            for (int i = 0; i < q; i++) {\n                list.add(qs[i][1]);\n            }\n            IntegerDiscreteMap dm = new IntegerDiscreteMap(list.getData(), 0, list.size());\n            Segment seg = new Segment(dm.minRank(), dm.maxRank(), i -> dm.iThElement(i));\n            //debug.debug(""1/2(1/4+13)"", mod.mul(inv2, mod.plus(power.inverseByFermat(4), 13)));\n            //debug.debug(""11/2"", mod.mul(inv2, 11));\n            for (int i = 1; i <= n; i++) {\n                val[i] = dm.rankOf(val[i]);\n            }\n            for (int i = 0; i < q; i++) {\n                qs[i][1] = dm.rankOf(qs[i][1]);\n            }\n\n            for (int i = 1; i <= n; i++) {\n                seg.add(val[i], val[i], dm.minRank(), dm.maxRank());\n            }\n\n            out.println(mod.mul(inv2, seg.exp));\n            for (int i = 0; i < q; i++) {\n                // debug.debug(""i"", i);\n                int index = qs[i][0];\n                int x = qs[i][1];\n                seg.remove(val[index], val[index], dm.minRank(), dm.maxRank());\n                val[index] = x;\n                seg.add(val[index], val[index], dm.minRank(), dm.maxRank());\n                out.println(mod.mul(inv2, seg.exp));\n            }\n        }\n\n    }\n\n    static class Power {\n        final Modular modular;\n\n        public Power(Modular modular) {\n            this.modular = modular;\n        }\n\n        public int pow(int x, int n) {\n            if (n == 0) {\n                return modular.valueOf(1);\n            }\n            long r = pow(x, n >> 1);\n            r = modular.valueOf(r * r);\n            if ((n & 1) == 1) {\n                r = modular.valueOf(r * x);\n            }\n            return (int) r;\n        }\n\n        public int inverseByFermat(int x) {\n            return pow(x, modular.m - 2);\n        }\n\n    }\n\n    static class IntegerList implements Cloneable {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public int[] getData() {\n            return data;\n        }\n\n        public IntegerList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntegerList(IntegerList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntegerList() {\n            this(0);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        public void add(int x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public void addAll(int[] x, int offset, int len) {\n            ensureSpace(size + len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(IntegerList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof IntegerList)) {\n                return false;\n            }\n            IntegerList other = (IntegerList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n        public int hashCode() {\n            int h = 1;\n            for (int i = 0; i < size; i++) {\n                h = h * 31 + Integer.hashCode(data[i]);\n            }\n            return h;\n        }\n\n        public IntegerList clone() {\n            IntegerList ans = new IntegerList();\n            ans.addAll(this);\n            return ans;\n        }\n\n    }\n\n    static class Segment implements Cloneable {\n        private Segment left;\n        private Segment right;\n        private int size;\n        private int sumX;\n        private int sumY;\n        public int exp;\n        private int x;\n        static Modular mod = new Modular(1e9 + 7);\n        static CachedPow pow = new CachedPow(2, mod);\n\n        public void pushUp() {\n            size = left.size + right.size;\n            int pos = mod.mul(right.sumX, pow.pow(left.size));\n            int neg = mod.mul(right.sumY, pow.inverse(left.size));\n            sumX = mod.plus(left.sumX, pos);\n            sumY = mod.plus(left.sumY, neg);\n\n            exp = mod.plus(left.exp, right.exp);\n            exp = mod.plus(exp, mod.mul(left.sumX, neg));\n        }\n\n        public void pushDown() {\n        }\n\n        public void remove() {\n            size--;\n            int pos = mod.mul(x, pow.pow(size));\n            int inv = mod.mul(x, pow.inverse(size));\n            sumX = mod.subtract(sumX, pos);\n            sumY = mod.subtract(sumY, inv);\n            exp = mod.subtract(exp, mod.mul(sumX, inv));\n        }\n\n        public void add() {\n            int pos = mod.mul(x, pow.pow(size));\n            int inv = mod.mul(x, pow.inverse(size));\n            exp = mod.plus(exp, mod.mul(sumX, inv));\n            sumX = mod.plus(sumX, pos);\n            sumY = mod.plus(sumY, inv);\n            size++;\n        }\n\n        public Segment(int l, int r, IntToIntFunction function) {\n            if (l < r) {\n                int m = (l + r) >> 1;\n                left = new Segment(l, m, function);\n                right = new Segment(m + 1, r, function);\n                pushUp();\n            } else {\n                x = function.apply(l);\n            }\n        }\n\n        private boolean covered(int ll, int rr, int l, int r) {\n            return ll <= l && rr >= r;\n        }\n\n        private boolean noIntersection(int ll, int rr, int l, int r) {\n            return ll > r || rr < l;\n        }\n\n        public void add(int ll, int rr, int l, int r) {\n            if (noIntersection(ll, rr, l, r)) {\n                return;\n            }\n            if (covered(ll, rr, l, r)) {\n                add();\n                return;\n            }\n            pushDown();\n            int m = (l + r) >> 1;\n            left.add(ll, rr, l, m);\n            right.add(ll, rr, m + 1, r);\n            pushUp();\n        }\n\n        public void remove(int ll, int rr, int l, int r) {\n            if (noIntersection(ll, rr, l, r)) {\n                return;\n            }\n            if (covered(ll, rr, l, r)) {\n                remove();\n                return;\n            }\n            pushDown();\n            int m = (l + r) >> 1;\n            left.remove(ll, rr, l, m);\n            right.remove(ll, rr, m + 1, r);\n            pushUp();\n        }\n\n        private Segment deepClone() {\n            Segment seg = clone();\n            if (seg.left != null) {\n                seg.left = seg.left.deepClone();\n            }\n            if (seg.right != null) {\n                seg.right = seg.right.deepClone();\n            }\n            return seg;\n        }\n\n        protected Segment clone() {\n            try {\n                return (Segment) super.clone();\n            } catch (CloneNotSupportedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        private void toString(StringBuilder builder) {\n            if (left == null && right == null) {\n                builder.append(""val"").append("","");\n                return;\n            }\n            pushDown();\n            left.toString(builder);\n            right.toString(builder);\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            deepClone().toString(builder);\n            if (builder.length() > 0) {\n                builder.setLength(builder.length() - 1);\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static interface IntToIntFunction {\n        int apply(int x);\n\n    }\n\n    static class IntegerDiscreteMap {\n        int[] val;\n        int f;\n        int t;\n\n        public IntegerDiscreteMap(int[] val, int f, int t) {\n            Randomized.shuffle(val, f, t);\n            Arrays.sort(val, f, t);\n            int wpos = f + 1;\n            for (int i = f + 1; i < t; i++) {\n                if (val[i] == val[i - 1]) {\n                    continue;\n                }\n                val[wpos++] = val[i];\n            }\n            this.val = val;\n            this.f = f;\n            this.t = wpos;\n        }\n\n        public int rankOf(int x) {\n            return Arrays.binarySearch(val, f, t, x) - f;\n        }\n\n        public int iThElement(int i) {\n            return val[f + i];\n        }\n\n        public int minRank() {\n            return 0;\n        }\n\n        public int maxRank() {\n            return t - f - 1;\n        }\n\n        public String toString() {\n            return Arrays.toString(Arrays.copyOfRange(val, f, t));\n        }\n\n    }\n\n    static class CachedPow {\n        private int[] first;\n        private int[] second;\n        private Modular mod;\n        private Modular powMod;\n        private static int step = 16;\n        private static int limit = 1 << step;\n        private static int mask = limit - 1;\n\n        public CachedPow(int x, Modular mod) {\n            this.mod = mod;\n            this.powMod = mod.getModularForPowerComputation();\n            first = new int[limit];\n            second = new int[Integer.MAX_VALUE / limit + 1];\n            first[0] = 1;\n            for (int i = 1; i < first.length; i++) {\n                first[i] = mod.mul(x, first[i - 1]);\n            }\n            second[0] = 1;\n            int step = mod.mul(x, first[first.length - 1]);\n            for (int i = 1; i < second.length; i++) {\n                second[i] = mod.mul(second[i - 1], step);\n            }\n        }\n\n        public int pow(int exp) {\n            return mod.mul(first[exp & mask], second[exp >> step]);\n        }\n\n        public int inverse(int exp) {\n            return pow(powMod.valueOf(-exp));\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 20];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        public int subtract(int x, int y) {\n            return valueOf(x - y);\n        }\n\n        public Modular getModularForPowerComputation() {\n            return new Modular(m - 1);\n        }\n\n        public String toString() {\n            return ""mod "" + m;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static boolean equal(int[] a, int al, int ar, int[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class Randomized {\n        private static Random random = new Random(0);\n\n        public static void shuffle(int[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                int tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n}\n\n","data structures,divide and conquer,probabilities"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FBattalionStrength solver = new FBattalionStrength();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FBattalionStrength {\n        Modular mod = new Modular(1e9 + 7);\n        Power power = new Power(mod);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n\n            int inv2 = power.inverseByFermat(2);\n\n            int n = in.readInt();\n            int[] val = new int[n + 1];\n\n            for (int i = 1; i <= n; i++) {\n                int x = in.readInt();\n                val[i] = x;\n                //root = add(root, create(x));\n            }\n\n            int q = in.readInt();\n            int[][] qs = new int[q][2];\n            for (int i = 0; i < q; i++) {\n                for (int j = 0; j < 2; j++) {\n                    qs[i][j] = in.readInt();\n                }\n            }\n\n            IntegerList list = new IntegerList(n + q);\n            for (int i = 1; i <= n; i++) {\n                list.add(val[i]);\n            }\n            for (int i = 0; i < q; i++) {\n                list.add(qs[i][1]);\n            }\n            IntegerDiscreteMap dm = new IntegerDiscreteMap(list.getData(), 0, list.size());\n            Segment seg = new Segment(dm.minRank(), dm.maxRank(), i -> dm.iThElement(i));\n            //debug.debug(""1/2(1/4+13)"", mod.mul(inv2, mod.plus(power.inverseByFermat(4), 13)));\n            //debug.debug(""11/2"", mod.mul(inv2, 11));\n            for (int i = 1; i <= n; i++) {\n                val[i] = dm.rankOf(val[i]);\n            }\n            for (int i = 0; i < q; i++) {\n                qs[i][1] = dm.rankOf(qs[i][1]);\n            }\n\n            for (int i = 1; i <= n; i++) {\n                seg.add(val[i], val[i], dm.minRank(), dm.maxRank());\n            }\n\n            out.println(mod.mul(inv2, seg.exp));\n            for (int i = 0; i < q; i++) {\n                // debug.debug(""i"", i);\n                int index = qs[i][0];\n                int x = qs[i][1];\n                seg.remove(val[index], val[index], dm.minRank(), dm.maxRank());\n                val[index] = x;\n                seg.add(val[index], val[index], dm.minRank(), dm.maxRank());\n                out.println(mod.mul(inv2, seg.exp));\n            }\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static boolean equal(int[] a, int al, int ar, int[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class Power {\n        final Modular modular;\n\n        public Power(Modular modular) {\n            this.modular = modular;\n        }\n\n        public int pow(int x, int n) {\n            if (n == 0) {\n                return modular.valueOf(1);\n            }\n            long r = pow(x, n >> 1);\n            r = modular.valueOf(r * r);\n            if ((n & 1) == 1) {\n                r = modular.valueOf(r * x);\n            }\n            return (int) r;\n        }\n\n        public int inverseByFermat(int x) {\n            return pow(x, modular.m - 2);\n        }\n\n    }\n\n    static class Randomized {\n        private static Random random = new Random(0);\n\n        public static void shuffle(int[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                int tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n\n    static class IntegerList implements Cloneable {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public int[] getData() {\n            return data;\n        }\n\n        public IntegerList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntegerList(IntegerList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntegerList() {\n            this(0);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        public void add(int x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public void addAll(int[] x, int offset, int len) {\n            ensureSpace(size + len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(IntegerList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof IntegerList)) {\n                return false;\n            }\n            IntegerList other = (IntegerList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n        public int hashCode() {\n            int h = 1;\n            for (int i = 0; i < size; i++) {\n                h = h * 31 + Integer.hashCode(data[i]);\n            }\n            return h;\n        }\n\n        public IntegerList clone() {\n            IntegerList ans = new IntegerList();\n            ans.addAll(this);\n            return ans;\n        }\n\n    }\n\n    static class Segment implements Cloneable {\n        private Segment left;\n        private Segment right;\n        private int size;\n        private int sumX;\n        private int sumY;\n        public int exp;\n        private int x;\n        static Modular mod = new Modular(1e9 + 7);\n        static CachedPow pow = new CachedPow(2, mod);\n\n        public void pushUp() {\n            size = left.size + right.size;\n            int pos = mod.mul(right.sumX, pow.pow(left.size));\n            int neg = mod.mul(right.sumY, pow.inverse(left.size));\n            sumX = mod.plus(left.sumX, pos);\n            sumY = mod.plus(left.sumY, neg);\n\n            exp = mod.plus(left.exp, right.exp);\n            exp = mod.plus(exp, mod.mul(left.sumX, neg));\n        }\n\n        public void pushDown() {\n        }\n\n        public void remove() {\n            size--;\n            int pos = mod.mul(x, pow.pow(size));\n            int inv = mod.mul(x, pow.inverse(size));\n            sumX = mod.subtract(sumX, pos);\n            sumY = mod.subtract(sumY, inv);\n            exp = mod.subtract(exp, mod.mul(sumX, inv));\n        }\n\n        public void add() {\n            int pos = mod.mul(x, pow.pow(size));\n            int inv = mod.mul(x, pow.inverse(size));\n            exp = mod.plus(exp, mod.mul(sumX, inv));\n            sumX = mod.plus(sumX, pos);\n            sumY = mod.plus(sumY, inv);\n            size++;\n        }\n\n        public Segment(int l, int r, IntToIntFunction function) {\n            if (l < r) {\n                int m = (l + r) >> 1;\n                left = new Segment(l, m, function);\n                right = new Segment(m + 1, r, function);\n                pushUp();\n            } else {\n                x = function.apply(l);\n            }\n        }\n\n        private boolean covered(int ll, int rr, int l, int r) {\n            return ll <= l && rr >= r;\n        }\n\n        private boolean noIntersection(int ll, int rr, int l, int r) {\n            return ll > r || rr < l;\n        }\n\n        public void add(int ll, int rr, int l, int r) {\n            if (noIntersection(ll, rr, l, r)) {\n                return;\n            }\n            if (covered(ll, rr, l, r)) {\n                add();\n                return;\n            }\n            pushDown();\n            int m = (l + r) >> 1;\n            left.add(ll, rr, l, m);\n            right.add(ll, rr, m + 1, r);\n            pushUp();\n        }\n\n        public void remove(int ll, int rr, int l, int r) {\n            if (noIntersection(ll, rr, l, r)) {\n                return;\n            }\n            if (covered(ll, rr, l, r)) {\n                remove();\n                return;\n            }\n            pushDown();\n            int m = (l + r) >> 1;\n            left.remove(ll, rr, l, m);\n            right.remove(ll, rr, m + 1, r);\n            pushUp();\n        }\n\n        private Segment deepClone() {\n            Segment seg = clone();\n            if (seg.left != null) {\n                seg.left = seg.left.deepClone();\n            }\n            if (seg.right != null) {\n                seg.right = seg.right.deepClone();\n            }\n            return seg;\n        }\n\n        protected Segment clone() {\n            try {\n                return (Segment) super.clone();\n            } catch (CloneNotSupportedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        private void toString(StringBuilder builder) {\n            if (left == null && right == null) {\n                builder.append(""val"").append("","");\n                return;\n            }\n            pushDown();\n            left.toString(builder);\n            right.toString(builder);\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            deepClone().toString(builder);\n            if (builder.length() > 0) {\n                builder.setLength(builder.length() - 1);\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static interface IntToIntFunction {\n        int apply(int x);\n\n    }\n\n    static class IntegerDiscreteMap {\n        int[] val;\n        int f;\n        int t;\n\n        public IntegerDiscreteMap(int[] val, int f, int t) {\n            Randomized.shuffle(val, f, t);\n            Arrays.sort(val, f, t);\n            int wpos = f + 1;\n            for (int i = f + 1; i < t; i++) {\n                if (val[i] == val[i - 1]) {\n                    continue;\n                }\n                val[wpos++] = val[i];\n            }\n            this.val = val;\n            this.f = f;\n            this.t = wpos;\n        }\n\n        public int rankOf(int x) {\n            return Arrays.binarySearch(val, f, t, x) - f;\n        }\n\n        public int iThElement(int i) {\n            return val[f + i];\n        }\n\n        public int minRank() {\n            return 0;\n        }\n\n        public int maxRank() {\n            return t - f - 1;\n        }\n\n        public String toString() {\n            return Arrays.toString(Arrays.copyOfRange(val, f, t));\n        }\n\n    }\n\n    static class CachedPow {\n        private int[] first;\n        private int[] second;\n        private Modular mod;\n        private Modular powMod;\n        private static int step = 16;\n        private static int limit = 1 << step;\n        private static int mask = limit - 1;\n\n        public CachedPow(int x, Modular mod) {\n            this(x, mod.getMod(), mod);\n        }\n\n        public CachedPow(int x, int maxExp, Modular mod) {\n            this.mod = mod;\n            this.powMod = mod.getModularForPowerComputation();\n            first = new int[limit];\n            second = new int[maxExp / limit + 1];\n            first[0] = 1;\n            for (int i = 1; i < first.length; i++) {\n                first[i] = mod.mul(x, first[i - 1]);\n            }\n            second[0] = 1;\n            int step = mod.mul(x, first[first.length - 1]);\n            for (int i = 1; i < second.length; i++) {\n                second[i] = mod.mul(second[i - 1], step);\n            }\n        }\n\n        public int pow(int exp) {\n            return mod.mul(first[exp & mask], second[exp >> step]);\n        }\n\n        public int inverse(int exp) {\n            return pow(powMod.valueOf(-exp));\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 20];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public int getMod() {\n            return m;\n        }\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        public int subtract(int x, int y) {\n            return valueOf(x - y);\n        }\n\n        public Modular getModularForPowerComputation() {\n            return new Modular(m - 1);\n        }\n\n        public String toString() {\n            return ""mod "" + m;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n}\n\n","data structures,divide and conquer,probabilities"
"\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n	public static void main(String[] args) {\n		Scanner scan=new Scanner(System.in);\n		int t=scan.nextInt();\n		while(t!=0)\n		{\n			t--;\n			int a=scan.nextInt();\n			int b=scan.nextInt();\n			int c=scan.nextInt();\n			int ans=1000000000;\n			int A=0,B=0,C=0;\n			for(int i=1;i<=20000;i++)\n			{\n				for(int j=i;j<=20000;j+=i)\n				{\n					for(int k=j;k<=20000;k+=j)\n					{\n						if(ans>Math.abs(a-i)+Math.abs(b-j)+Math.abs(c-k))\n						{\n							ans=Math.abs(a-i)+Math.abs(b-j)+Math.abs(c-k);\n							A=i;\n							B=j;\n							C=k;\n						}\n					}\n				}\n			}\n			System.out.println(ans);\n			System.out.println(A+"" ""+B+"" ""+C);\n		}\n	}\n\n}\n","brute force,math"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1311D extends PrintWriter {\n	CF1311D() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1311D o = new CF1311D(); o.main(); o.flush();\n	}\n\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int a = sc.nextInt();\n			int b = sc.nextInt();\n			int c = sc.nextInt();\n			int n = c * 2;\n			int k_ = a - 1 + b - 1 + c, a_ = 1, b_ = 1, c_ = c;\n			for (int o = 1; o <= n; o++) {\n				int k1 = Math.abs(a - o);\n				if (k1 >= k_)\n					continue;\n				for (int p = o; p <= n; p += o) {\n					int k2 = k1 + Math.abs(b - p);\n					if (k2 >= k_)\n						continue;\n					for (int q = p; q <= n; q += p) {\n						int k3 = k2 + Math.abs(c - q);\n						if (k3 >= k_)\n							continue;\n						k_ = k3; a_ = o; b_ = p; c_ = q;\n					}\n				}\n			}\n			println(k_);\n			println(a_ + "" "" + b_ + "" "" + c_);\n		}\n	}\n}\n","brute force,math"
"\nimport java.util.*;\n\npublic class Dij\n{\n	static int max=2*(int)Math.pow(10,4);\n	static class poss\n	{\n		int a;\n		int b;\n		int c;\n		poss(int a,int b,int c)\n		{\n			this.a=a;\n			this.b=b;\n			this.c=c;\n		}\n	}\nstatic ArrayList<poss> arr;\nstatic void possible()\n	{\n\n		\n		for(int i=1;i<max;i++)\n			for(int j=i;j<max;j+=i)\n			{\n				for(int k=j;k<max;k+=j)\n				{\n					arr.add(new poss(i,j,k));\n				}\n			}\n	}\n	public static void main(String[] args) {\n		Scanner in=new Scanner(System.in);\n		arr=new ArrayList();\n		int t=in.nextInt();\n		possible();\n		while(t>0)\n		{\n			t--;\n			int a=in.nextInt();\n			int b=in.nextInt();\n			int c=in.nextInt();\n			poss p=arr.get(0);\n			long  ans=max;\n			for(poss x:arr)\n			{\n				long y=Math.abs(x.a-a)+Math.abs(x.b-b)+Math.abs(x.c-c);\n				if(y<ans)\n				{\n					ans=y;\n					p=x;\n				}\n			}\n			System.out.println(ans);\n			System.out.println(p.a+"" ""+p.b+"" ""+p.c);\n		}\n	}\n}","brute force,math"
"import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Integers\n{\n	public static void main (String[] args) throws Exception\n	{\n		// your code goes here\n		BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n		int t=Integer.parseInt(bu.readLine());\n		StringBuilder sb=new StringBuilder();\n		while(t-->0)\n		{\n			String s[]=bu.readLine().split("" "");\n			int a=Integer.parseInt(s[0]),b=Integer.parseInt(s[1]),c=Integer.parseInt(s[2]);\n			int diff=100000000,i,j,k,n1=0,n2=0,n3=0;\n			for(i=1;i<=10010;i++)\n				for(j=i;j<=10010;j+=i)\n				{\n					if(c<j) k=j;\n					else if((c%j)!=0)\n					{\n						if((c%j)<=(j-(c%j))) k=c-(c%j);\n						else k=j*(1+c/j);\n					}\n					else k=c;\n					int temp=Math.abs(a-i)+Math.abs(b-j)+Math.abs(c-k);\n					if(temp<diff)\n					{\n						diff=temp;\n						n1=i;\n						n2=j;\n						n3=k;\n					}\n				}\n			\n			sb.append(diff+""\n""+n1+"" ""+n2+"" ""+n3+""\n"");\n		}\n		System.out.print(sb);\n	}\n}","brute force,math"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1294F extends PrintWriter {\n	CF1294F() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1294F o = new CF1294F(); o.main(); o.flush();\n	}\n\n	int[] oo, oj; int __ = 1;\n	int link(int o, int j) {\n		oo[__] = o; oj[__] = j;\n		return __++;\n	}\n	int[] ae, d1, d2, d3, c1, c2, c3;\n	void init(int n) {\n		int m = n - 1;\n		oo = new int[1 + m * 2]; oj = new int[1 + m * 2];\n		ae = new int[n];\n		d1 = new int[n]; d2 = new int[n]; d3 = new int[n];\n		c1 = new int[n]; c2 = new int[n]; c3 = new int[n];\n	}\n	void dfs1(int p, int i) {\n		d1[i] = d2[i] = 0;\n		c1[i] = c2[i] = i;\n		for (int o = ae[i]; o != 0; o = oo[o]) {\n			int j = oj[o];\n			if (j != p) {\n				dfs1(i, j);\n				int d = d1[j] + 1, c = c1[j];\n				if (d1[i] < d) {\n					d3[i] = d2[i]; d2[i] = d1[i]; d1[i] = d;\n					c3[i] = c2[i]; c2[i] = c1[i]; c1[i] = c;\n				} else if (d2[i] < d) {\n					d3[i] = d2[i]; d2[i] = d;\n					c3[i] = c2[i]; c2[i] = c;\n				} else if (d3[i] < d) {\n					d3[i] = d;\n					c3[i] = c;\n				}\n			}\n		}\n	}\n	int ans, a_, b_, c_;\n	void dfs2(int p, int i, int d, int c) {\n		int sum = d1[i] + d2[i] + Math.max(d3[i], d);\n		if (ans < sum) {\n			ans = sum;\n			a_ = c1[i]; b_ = c2[i]; c_ = d3[i] >= d ? c3[i] : c;\n		}\n		int d23, d13, d12, c23, c13, c12;\n		d23 = d13 = d12 = d;\n		c23 = c13 = c12 = c;\n		if (d23 < d2[i]) {\n			d23 = d2[i];\n			c23 = c2[i];\n		}\n		if (d23 < d3[i]) {\n			d23 = d3[i];\n			c23 = c3[i];\n		}\n		if (d13 < d1[i]) {\n			d13 = d1[i];\n			c13 = c1[i];\n		}\n		if (d13 < d3[i]) {\n			d13 = d3[i];\n			c13 = c3[i];\n		}\n		if (d12 < d1[i]) {\n			d12 = d1[i];\n			c12 = c1[i];\n		}\n		if (d12 < d2[i]) {\n			d12 = d2[i];\n			c12 = c2[i];\n		}\n		d23++; d13++; d12++;\n		for (int o = ae[i]; o != 0; o = oo[o]) {\n			int j = oj[o];\n			if (j != p) {\n				if (c1[j] == c1[i])\n					dfs2(i, j, d23, c23);\n				else if (c1[j] == c2[i])\n					dfs2(i, j, d13, c13);\n				else\n					dfs2(i, j, d12, c12);\n			}\n		}\n	}\n	int distinct(int a, int b) {\n		for (int c = 0; c < 3; c++)\n			if (a != c && b != c)\n				return c;\n		return -1;\n	}\n	void main() {\n		int n = sc.nextInt();\n		init(n);\n		for (int h = 0; h < n - 1; h++) {\n			int i = sc.nextInt() - 1;\n			int j = sc.nextInt() - 1;\n			ae[i] = link(ae[i], j);\n			ae[j] = link(ae[j], i);\n		}\n		dfs1(-1, 0);\n		dfs2(-1, 0, 0, 0);\n		if (a_ == b_)\n			b_ = distinct(a_, c_);\n		if (c_ == a_ || c_ == b_)\n			c_ = distinct(a_, b_);\n		println(ans);\n		println((a_ + 1) + "" "" + (b_ + 1) + "" "" + (c_ + 1));\n	}\n}\n","dfs and similar,dp,greedy,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class F{\n	\n	static boolean[] vis;\n	static int n;\n	static List<Integer>[] adj;\n	\n	static int furthest;\n	static int farNode;\n	\n	static void dfs1(int i, int p, int d) {\n		if (d > furthest) {\n			furthest = d;\n			farNode = i;\n		}\n		for (int x: adj[i]) {\n			if (x==p) continue;\n			dfs1(x,i,d+1);\n		}\n	}\n	\n	static boolean dfs2(int i, int p, int t) {\n		if (i == t) return vis[i] = true;\n		for (int x: adj[i]) {\n			if (x==p) continue;\n			vis[i] |= dfs2(x,i,t);\n		}\n		return vis[i];\n	}\n	\n	static void dfs3(int i, int p, int d) {\n		if (d > furthest) {\n			furthest = d;\n			farNode = i;\n		}\n		for (int x: adj[i]) {\n			if (vis[x] || x == p) continue;\n			dfs3(x,i,d+1);\n		}\n	}\n	\n	public static void main(String[] args) throws IOException {\n		// br = new BufferedReader(new FileReader("".in""));\n		// out = new PrintWriter(new FileWriter("".out""));\n		//new Thread(null, new (), ""peepee"", 1<<28).start();\n		// Select diameter andthen longest path \n		n = readInt();\n		adj = new List[n];\n		for (int i = 0; i < n; i++) adj[i] = new ArrayList<Integer>();\n		for (int i = 0; i < n-1; i++) {\n			int x = readInt()-1;\n			int y = readInt()-1;\n			adj[x].add(y);\n			adj[y].add(x);\n		}\n		farNode = furthest = 0;\n		dfs1(0,0,0);\n		List<Integer> b = new ArrayList<Integer>();\n		b.add(farNode);\n		furthest = 0;\n		int cur = farNode;\n		dfs1(farNode,farNode,0);\n		b.add(farNode);\n		long val = furthest;\n		vis = new boolean[n];\n		dfs2(farNode,farNode, cur);\n		\n		furthest = 0;\n		for (int i =0 ; i < n; i++) {\n			if (vis[i]) {\n				//System.out.println(""using this as jumpoff "" + i + "" "" + adj[i]);\n				dfs3(i,i,0);\n			}\n		}\n		val += furthest;\n		if (furthest== 0) {\n			for (int i = 0; i < n; i++) if (!b.contains(i)) {\n				farNode = i;\n				break;\n			}\n		}\n		b.add(farNode);\n\n		out.println(val);\n		\n		for (int x: b) out.print(x +1+ "" "");\n		\n		out.println();\n		out.close();\n	}\n	\n	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n	static StringTokenizer st = new StringTokenizer("""");\n	static String read() throws IOException{return st.hasMoreTokens() ? st.nextToken():(st = new StringTokenizer(br.readLine())).nextToken();}\n	static int readInt() throws IOException{return Integer.parseInt(read());}\n	static long readLong() throws IOException{return Long.parseLong(read());}\n	static double readDouble() throws IOException{return Double.parseDouble(read());}\n	\n}","dfs and similar,dp,greedy,trees"
"/* package codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be ""Main"" only if the class is public. */\npublic class Main\n{\n    static List<Integer> al[];\n    static int par[];\n    static int dist[];\n    static boolean vis[];\n    static int n;\n    \n    static int bfs(int u) {\n        Queue<Integer> q=new LinkedList<>();\n        q.add(u);\n        \n        par[u]=0;\n        vis[u]=true;\n        dist[u]=0;\n        \n        while(!q.isEmpty()){\n            int cur=q.poll();\n          //  System.out.println(cur);\n            for(int e:al[cur]){\n                if(!vis[e]) {\n                    vis[e]=true;\n                    dist[e]=dist[cur]+1;\n                    par[e]=cur;\n                    q.add(e);\n                }\n            }\n        }\n        // for(int e:dist)\n        // System.out.print(e+"" "");\n        // System.out.println();\n        \n        int max=0;\n        for(int i=1;i<=n;i++) {\n            if(dist[i]>dist[max]) max=i;\n        }\n        return max;\n    }\n	public static void main (String[] args) throws java.lang.Exception\n	{\n		Scanner sc=new Scanner(System.in);\n		PrintWriter out=new PrintWriter(System.out);\n		 n=sc.nextInt();\n		al=new ArrayList[n+1];\n		for(int i=0;i<=n;i++) al[i]=new ArrayList<>();\n		\n		for(int i=0;i<n-1;i++) {\n		    int u=sc.nextInt();\n		    int v=sc.nextInt();\n		    al[u].add(v);\n		    al[v].add(u);\n		}\n		dist=new int[n+1];\n		par=new int[n+1];\n		vis=new boolean[n+1];\n		int firstNode=bfs(1);\n		\n			dist=new int[n+1];\n		par=new int[n+1];\n		vis=new boolean[n+1];\n		int secondNode=bfs(firstNode);\n		\n	//	System.out.println(firstNode+"" ""+secondNode);\n	   int ans=dist[secondNode];\n	   if(ans==n-1){\n	   out.println(ans);\n	   out.println(secondNode+"" ""+par[secondNode]+"" ""+firstNode);\n	   }\n	   else {\n	       int temp=secondNode;\n	        Queue<Integer> q=new LinkedList<>();\n	        boolean vis[]=new boolean[n+1];\n	        while(secondNode!=firstNode){\n	             q.add(secondNode);\n	             vis[secondNode]=true;\n	            secondNode=par[secondNode];\n	        }\n	        q.add(firstNode);\n	        vis[firstNode]=true;\n	        \n	        int dist[]=new int[n+1];\n	        while(!q.isEmpty()) {\n	            int cur=q.poll();\n	            for(int e:al[cur]){\n                if(!vis[e]) {\n                    vis[e]=true;\n                    dist[e]=dist[cur]+1;\n                    q.add(e);\n                }\n            }\n	        }\n	         int max=0;\n        for(int i=1;i<=n;i++) {\n            if(dist[i]>dist[max]) max=i;\n        }\n        \n        out.println(ans+dist[max]);\n	   out.println(temp+"" ""+max+"" ""+firstNode);\n	        \n	   }\n		out.flush();\n		out.close();\n	}\n}\n","dfs and similar,dp,greedy,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class E {\n\n	static ArrayList<Integer>[] adj;\n	static boolean[] visited, inPath;\n	static int[] par;\n\n	static int[] dfs(int u, int p) {\n		visited[u] = true;\n		par[u] = p;\n\n		int[] ans = new int[] { u, 0 };\n		for (int v : adj[u]) {\n			if (visited[v])\n				continue;\n			if (inPath[v])\n				continue;\n			int[] cand = dfs(v, u);\n			if (cand[1] + 1 > ans[1]) {\n				ans = cand;\n				ans[1]++;\n			}\n		}\n		return ans;\n	}\n\n	public static void main(String[] args) throws IOException {\n		Scanner sc = new Scanner();\n		PrintWriter out = new PrintWriter(System.out);\n		int n = sc.nextInt();\n		adj = new ArrayList[n];\n		inPath = new boolean[n];\n\n		visited = new boolean[n];\n		par = new int[n];\n		for (int i = 0; i < n; i++) {\n			adj[i] = new ArrayList();\n		}\n		for (int i = 1; i < n; i++) {\n			int u = sc.nextInt() - 1, v = sc.nextInt() - 1;\n			adj[u].add(v);\n			adj[v].add(u);\n		}\n		int[] farthest;\n		farthest = dfs(0, 0);\n		int root = farthest[0];\n		Arrays.fill(visited, false);\n		farthest = dfs(root, root);\n		Arrays.fill(visited, false);\n		int end = farthest[0];\n		for (int curr = end;; curr = par[curr]) {\n			inPath[curr] = true;\n			if (curr == root)\n				break;\n		}\n		int diameter = farthest[1];\n		if (diameter == n - 1) {\n			int third = -1;\n			for (int i = 0; i < n; i++)\n				if (i != root && i != end)\n					third = i;\n			System.out.printf(""%d\n%d %d %d\n"", diameter, root + 1, end + 1, third + 1);\n			return;\n\n		}\n		Arrays.fill(farthest, 0);\n		for (int i = 0; i < n; i++) {\n			if (inPath[i]) {\n				int[] cand = dfs(i, i);\n				if (cand[1] > farthest[1])\n					farthest = cand;\n			}\n		}\n//		System.out.println(Arrays.toString(farthest));\n		out.printf(""%d\n%d %d %d\n"", diameter + farthest[1], root + 1, end + 1, farthest[0] + 1);\n		out.close();\n\n	}\n\n	static class Scanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		Scanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		Scanner(String fileName) throws FileNotFoundException {\n			br = new BufferedReader(new FileReader(fileName));\n		}\n\n		String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() throws NumberFormatException, IOException {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() throws NumberFormatException, IOException {\n			return Double.parseDouble(next());\n		}\n\n		boolean ready() throws IOException {\n			return br.ready();\n		}\n\n	}\n\n	static void sort(int[] a) {\n		shuffle(a);\n		Arrays.sort(a);\n	}\n\n	static void shuffle(int[] a) {\n		int n = a.length;\n		Random rand = new Random();\n		for (int i = 0; i < n; i++) {\n			int tmpIdx = rand.nextInt(n);\n			int tmp = a[i];\n			a[i] = a[tmpIdx];\n			a[tmpIdx] = tmp;\n		}\n	}\n\n}","dfs and similar,dp,greedy,trees"
"// upsolve with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1288F extends PrintWriter {\n	CF1288F() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1288F o = new CF1288F(); o.main(); o.flush();\n	}\n\n	static final int INF = 0x3f3f3f3f;\n	int[] oo, oh; int __ = 1;\n	int link(int o, int h) {\n		oo[__] = o; oh[__] = h;\n		return __++;\n	}\n	int[] ii, jj, cc, ww, ww_; int m_;\n	int[] ae, dd, kk, ff; int n_;\n	int[] pq, iq; int cnt;\n	void init() {\n		oo = new int[1 + m_ * 2]; oh = new int[1 + m_ * 2];\n		ii = new int[m_]; jj = new int[m_];\n		cc = new int[m_ * 2];\n		ww = new int[m_]; ww_ = new int[m_];\n		ae = new int[n_]; dd = new int[n_]; kk = new int[n_]; ff = new int[n_];\n		pq = new int[1 + n_]; iq = new int[n_];\n		m_ = 0;\n	}\n	void link_(int i, int j, int c, int w) {\n		int h = m_++;\n		ii[h] = i; jj[h] = j; cc[h << 1] = c; ww[h] = w;\n		ae[i] = link(ae[i], h << 1);\n		ae[j] = link(ae[j], h << 1 | 1);\n	}\n	boolean less(int u, int v) {\n		return dd[u] < dd[v] || dd[u] == dd[v] && kk[u] < kk[v];\n	}\n	int i2(int i) {\n		return (i *= 2) > cnt ? 0 : i < cnt && less(pq[i + 1], pq[i]) ? i + 1 : i;\n	}\n	void pq_up(int u) {\n		int i, j, v;\n		for (i = iq[u]; (j = i / 2) > 0 && less(u, v = pq[j]); i = j)\n			pq[iq[v] = i] = v;\n		pq[iq[u] = i] = u;\n	}\n	void pq_dn(int u) {\n		int i, j, v;\n		for (i = iq[u]; (j = i2(i)) > 0 && less(v = pq[j], u); i = j)\n			pq[iq[v] = i] = v;\n		pq[iq[u] = i] = u;\n	}\n	void pq_add_last(int u) {\n		pq[iq[u] = ++cnt] = u;\n	}\n	int pq_remove_first() {\n		int u = pq[1], v = pq[cnt--];\n		if (v != u) {\n			iq[v] = 1; pq_dn(v);\n		}\n		iq[u] = 0;\n		return u;\n	}\n	boolean dijkstra(int s, int t) {\n		Arrays.fill(dd, INF);\n		dd[s] = 0; pq_add_last(s);\n		while (cnt > 0) {\n			int i = pq_remove_first();\n			int k = kk[i] + 1;\n			for (int o = ae[i]; o != 0; o = oo[o]) {\n				int h_ = oh[o];\n				if (cc[h_] > 0) {\n					int h = h_ >> 1;\n					int j = i ^ ii[h] ^ jj[h];\n					int d = dd[i] + ((h_ & 1) == 0 ? ww_[h] : -ww_[h]);\n					if (dd[j] > d || (dd[j] == d && kk[j] > k)) {\n						if (dd[j] == INF)\n							pq_add_last(j);\n						dd[j] = d; kk[j] = k; ff[j] = h_;\n						pq_up(j);\n					}\n				}\n			}\n		}\n		return dd[t] != INF;\n	}\n	boolean trace(int s, int t) {\n		int sum = 0;\n		for (int i = t; i != s; ) {\n			int h_ = ff[i], h = h_ >> 1;\n			sum += (h_ & 1) == 0 ? ww[h] : -ww[h];\n			i ^= ii[h] ^ jj[h];\n		}\n		if (sum >= 0)\n			return false;\n		for (int i = t; i != s; ) {\n			int h_ = ff[i], h = h_ >> 1;\n			cc[h_]--; cc[h_ ^ 1]++;\n			i ^= ii[h] ^ jj[h];\n		}\n		return true;\n	}\n	int edmonds_karp(int s, int t) {\n		for (int h = 0; h < m_; h++)\n			ww_[h] = ww[h];\n		while (dijkstra(s, t)) {\n			if (!trace(s, t))\n				break;\n			for (int h = 0; h < m_; h++) {\n				int i = ii[h], j = jj[h];\n				if (dd[i] != INF && dd[j] != INF) {\n					// dd[j] <= dd[i] + ww_[h]\n					// ww_[h] + dd[i] - dd[j] >= 0\n					ww_[h] += dd[i] - dd[j];\n				}\n			}\n		}\n		int sum = 0;\n		for (int h = 0; h < m_; h++)\n			sum += ww[h] * cc[h << 1 | 1];\n		return sum;\n	}\n	void main() {\n		int n1 = sc.nextInt();\n		int n2 = sc.nextInt();\n		int m = sc.nextInt();\n		int r = sc.nextInt();\n		int b = sc.nextInt();\n		int inf = m * (r + b) + 1;\n		n_ = 1 + n1 + n2 + 1;\n		m_ = (m + n1 + n2) * 2;\n		init();\n		byte[] c1 = sc.next().getBytes();\n		byte[] c2 = sc.next().getBytes();\n		for (int h = 0; h < m; h++) {\n			int i = sc.nextInt() - 1;\n			int j = sc.nextInt() - 1;\n			int i_ = 1 + i;\n			int j_ = 1 + n1 + j;\n			link_(i_, j_, 1, r);\n			link_(j_, i_, 1, b);\n		}\n		int s = 0, t = n_ - 1;\n		for (int i = 0; i < n1; i++) {\n			int i_ = 1 + i;\n			if (c1[i] == 'R') {\n				link_(s, i_, 1, -inf);\n				link_(s, i_, m, 0);\n			} else if (c1[i] == 'B') {\n				link_(i_, t, 1, -inf);\n				link_(i_, t, m, 0);\n			} else {\n				link_(s, i_, m, 0);\n				link_(i_, t, m, 0);\n			}\n		}\n		for (int j = 0; j < n2; j++) {\n			int j_ = 1 + n1 + j;\n			if (c2[j] == 'R') {\n				link_(j_, t, 1, -inf);\n				link_(j_, t, m, 0);\n			} else if (c2[j] == 'B') {\n				link_(s, j_, 1, -inf);\n				link_(s, j_, m, 0);\n			} else {\n				link_(s, j_, m, 0);\n				link_(j_, t, m, 0);\n			}\n		}\n		int ans = edmonds_karp(s, t);\n		for (int h = 0; h < m_; h++)\n			if (ww[h] == -inf) {\n				if (cc[h << 1 | 1] == 0) {\n					println(-1);\n					return;\n				}\n				ans += inf;\n			}\n		println(ans);\n		char[] colors = new char[m];\n		for (int h = 0; h < m; h++) {\n			int hr = h << 1, hb = h << 1 | 1;\n			if (cc[hr << 1 | 1] > 0)\n				colors[h] = 'R';\n			else if (cc[hb << 1 | 1] > 0)\n				colors[h] = 'B';\n			else\n				colors[h] = 'U';\n		}\n		println(colors);\n	}\n}\n","constructive algorithms,flows"
"// upsolve with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1288F extends PrintWriter {\n	CF1288F() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1288F o = new CF1288F(); o.main(); o.flush();\n	}\n\n	static final int INF = 0x3f3f3f3f;\n	int[] oo, oh; int __ = 1;\n	int link(int o, int h) {\n		oo[__] = o; oh[__] = h;\n		return __++;\n	}\n	int[] ii, jj, cc, cost, cost_; int m_;\n	int[] ae, pi, dd, ff; int n_;\n	int[] pq, iq; int cnt;\n	void init() {\n		oo = new int[1 + m_ * 2]; oh = new int[1 + m_ * 2];\n		ii = new int[m_]; jj = new int[m_];\n		cc = new int[m_ * 2];\n		cost = new int[m_]; cost_ = new int[m_];\n		ae = new int[n_]; pi = new int[n_]; dd = new int[n_]; ff = new int[n_];\n		pq = new int[1 + n_]; iq = new int[n_];\n		m_ = 0;\n	}\n	void link_(int i, int j, int c, int co) {\n		int h = m_++;\n		ii[h] = i; jj[h] = j; cc[h << 1] = c; cost[h] = co;\n		ae[i] = link(ae[i], h << 1);\n		ae[j] = link(ae[j], h << 1 | 1);\n	}\n	boolean less(int u, int v) {\n		return pi[u] < pi[v] || pi[u] == pi[v] && dd[u] < dd[v];\n	}\n	int i2(int i) {\n		return (i *= 2) > cnt ? 0 : i < cnt && less(pq[i + 1], pq[i]) ? i + 1 : i;\n	}\n	void pq_up(int u) {\n		int i, j, v;\n		for (i = iq[u]; (j = i / 2) > 0 && less(u, v = pq[j]); i = j)\n			pq[iq[v] = i] = v;\n		pq[iq[u] = i] = u;\n	}\n	void pq_dn(int u) {\n		int i, j, v;\n		for (i = iq[u]; (j = i2(i)) > 0 && less(v = pq[j], u); i = j)\n			pq[iq[v] = i] = v;\n		pq[iq[u] = i] = u;\n	}\n	void pq_add_last(int u) {\n		pq[iq[u] = ++cnt] = u;\n	}\n	int pq_remove_first() {\n		int u = pq[1], v = pq[cnt--];\n		if (v != u) {\n			iq[v] = 1; pq_dn(v);\n		}\n		iq[u] = 0;\n		return u;\n	}\n	boolean dijkstra(int s, int t) {\n		Arrays.fill(pi, INF);\n		pi[s] = 0; pq_add_last(s);\n		while (cnt > 0) {\n			int i = pq_remove_first();\n			int d = dd[i] + 1;\n			for (int o = ae[i]; o != 0; o = oo[o]) {\n				int h_ = oh[o];\n				if (cc[h_] > 0) {\n					int h = h_ >> 1;\n					int j = i ^ ii[h] ^ jj[h];\n					int p = pi[i] + ((h_ & 1) == 0 ? cost_[h] : -cost_[h]);\n					if (pi[j] > p || (pi[j] == p && dd[j] > d)) {\n						if (pi[j] == INF)\n							pq_add_last(j);\n						pi[j] = p; dd[j] = d; ff[j] = h_;\n						pq_up(j);\n					}\n				}\n			}\n		}\n		return pi[t] != INF;\n	}\n	boolean trace(int s, int t) {\n		int sum = 0;\n		for (int i = t; i != s; ) {\n			int h_ = ff[i], h = h_ >> 1;\n			sum += (h_ & 1) == 0 ? cost[h] : -cost[h];\n			i ^= ii[h] ^ jj[h];\n		}\n		if (sum >= 0)\n			return false;\n		for (int i = t; i != s; ) {\n			int h_ = ff[i], h = h_ >> 1;\n			cc[h_]--; cc[h_ ^ 1]++;\n			i ^= ii[h] ^ jj[h];\n		}\n		return true;\n	}\n	int edmonds_karp(int s, int t) {\n		for (int h = 0; h < m_; h++)\n			cost_[h] = cost[h];\n		while (dijkstra(s, t)) {\n			if (!trace(s, t))\n				break;\n			for (int h = 0; h < m_; h++) {\n				int i = ii[h], j = jj[h];\n				if (pi[i] != INF && pi[j] != INF) {\n					// pi[j] <= pi[i] + cost_[h]\n					// cost_[h] + pi[i] - pi[j] >= 0\n					cost_[h] += pi[i] - pi[j];\n				}\n			}\n		}\n		int sum = 0;\n		for (int h = 0; h < m_; h++)\n			sum += cost[h] * cc[h << 1 | 1];\n		return sum;\n	}\n	void main() {\n		int n1 = sc.nextInt();\n		int n2 = sc.nextInt();\n		int m = sc.nextInt();\n		int r = sc.nextInt();\n		int b = sc.nextInt();\n		int inf = m * (r + b) + 1;\n		n_ = 1 + n1 + n2 + 1;\n		m_ = (m + n1 + n2) * 2;\n		init();\n		byte[] c1 = sc.next().getBytes();\n		byte[] c2 = sc.next().getBytes();\n		for (int h = 0; h < m; h++) {\n			int i = sc.nextInt() - 1;\n			int j = sc.nextInt() - 1;\n			int i_ = 1 + i;\n			int j_ = 1 + n1 + j;\n			link_(i_, j_, 1, r);\n			link_(j_, i_, 1, b);\n		}\n		int s = 0, t = n_ - 1;\n		for (int i = 0; i < n1; i++) {\n			int i_ = 1 + i;\n			if (c1[i] == 'R') {\n				link_(s, i_, 1, -inf);\n				link_(s, i_, m, 0);\n			} else if (c1[i] == 'B') {\n				link_(i_, t, 1, -inf);\n				link_(i_, t, m, 0);\n			} else {\n				link_(s, i_, m, 0);\n				link_(i_, t, m, 0);\n			}\n		}\n		for (int j = 0; j < n2; j++) {\n			int j_ = 1 + n1 + j;\n			if (c2[j] == 'R') {\n				link_(j_, t, 1, -inf);\n				link_(j_, t, m, 0);\n			} else if (c2[j] == 'B') {\n				link_(s, j_, 1, -inf);\n				link_(s, j_, m, 0);\n			} else {\n				link_(s, j_, m, 0);\n				link_(j_, t, m, 0);\n			}\n		}\n		int ans = edmonds_karp(s, t);\n		for (int h = 0; h < m_; h++)\n			if (cost[h] == -inf) {\n				if (cc[h << 1 | 1] == 0) {\n					println(-1);\n					return;\n				}\n				ans += inf;\n			}\n		println(ans);\n		char[] colors = new char[m];\n		for (int h = 0; h < m; h++) {\n			int hr = h << 1, hb = h << 1 | 1;\n			if (cc[hr << 1 | 1] > 0)\n				colors[h] = 'R';\n			else if (cc[hb << 1 | 1] > 0)\n				colors[h] = 'B';\n			else\n				colors[h] = 'U';\n		}\n		println(colors);\n	}\n}\n","constructive algorithms,flows"
"import java.io.*;\nimport java.util.*;\n\npublic class F\n{\n    //@ <- not printed in hackpack\n    static class MinCostFlow {\n        static int MINCOSTFLOW = 0, MINCOSTMAXFLOW = 1;\n        int s, t, N, ss, tt;  // use s and t as your source & sink\n        long oo = (long)1e12;\n        long[] ex;  ArrayList<Edge>[] adjj;  Edge[][] adj;\n        \n        public MinCostFlow(int NN) {  this(NN, MINCOSTMAXFLOW);  }\n        \n        public MinCostFlow(int NN, int flowType) {\n            N = (tt = (ss = (t = (s = NN) + 1) + 1) + 1) + 1;\n            \n            adj = new Edge[N][0];  adjj = new ArrayList[N];\n            for (int i = 0; i < N; i++)  adjj[i] = new ArrayList<Edge>();\n            ex = new long[N];  add(t, s, oo, -oo / 10 * flowType);\n        }\n        \n        public void add(int i, int j, long cap, long cost) {\n            Edge fwd = new Edge(i, j, cap, 0, cost);\n            Edge rev = new Edge(j, i, 0, 0, -cost);\n            adjj[i].add(rev.rev = fwd);  adjj[j].add(fwd.rev = rev);\n        }\n\n        public void add(int i, int j, long cap, long cost, int id, int ttype) {\n            Edge fwd = new Edge(i, j, cap, 0, cost, id, ttype);\n            Edge rev = new Edge(j, i, 0, 0, -cost, id, ttype);\n            adjj[i].add(rev.rev = fwd);  adjj[j].add(fwd.rev = rev);\n        }\n        \n        public long[] getFlow() {\n            preFlow();\n            for (int i = 0; i < N; i++)  adj[i] = adjj[i].toArray(adj[i]);\n            boolean[] canU = new boolean[N], hasU = new boolean[N];\n            long[] dist = new long[N], width = new long[N];\n            Edge[] prev = new Edge[N];\n            while (true) {\n                Arrays.fill(dist, oo);  dist[ss] = 0;\n                width[ss] = oo;  boolean updated = hasU[ss] = true;\n                while (updated) {\n                    updated = false;\n                    for (int i = 0; i < N; hasU[i++] = false)  canU[i] = hasU[i];\n                    for (int i = 0; i < N; i++)\n                        if (canU[i])\n                            for (Edge e : adj[i])\n                                if (e.flow != e.cap && dist[e.j] > dist[e.i] + e.cost) {\n                                    dist[e.j] = dist[e.i] + (prev[e.j] = e).cost;\n                                    width[e.j] = Math.min(width[e.i], e.cap - e.flow);\n                                    hasU[e.j] = updated = true;\n                                }\n                }\n                if (dist[tt] >= oo)  break;\n                \n                for (Edge e = prev[tt]; e != null; e = prev[e.i])\n                    e.rev.flow = -(e.flow += width[tt]);\n            }\n            long flow = 0, cost = 0;\n            for (Edge e : adj[s])  if (e.flow > 0)  flow += e.flow;\n            for (int i = 0; i < N; i++)\n                for (Edge e : adj[i])\n                    if (e.flow > 0 && e.i != t && e.j != s && e.i < ss && e.j < ss)\n                        cost += e.flow * e.cost;\n            \n            return new long[] {flow, cost};\n        }\n        \n        public void preFlow() {\n            for (int i = 0; i < N; i++)\n                for (Edge e : adjj[i])\n                    if (e.cost < 0 && e.cap - e.flow > 0) {\n                        ex[e.i] -= e.cap - e.flow;\n                        ex[e.j] += e.cap - e.flow;\n                        e.rev.flow = -(e.flow = e.cap);\n                    }\n            for (int i = 0; i < N; i++)\n                if (ex[i] > 0)  add(ss, i, ex[i], -oo);\n                else if (ex[i] < 0)  add(i, tt, -ex[i], -oo);\n            Arrays.fill(ex, 0);\n        }\n        \n    }		\n    static class Edge {\n        int i, j;  long cap, flow, cost;  Edge rev;\n        int id = -1, type = 0;\n        Edge(int ii, int jj, long cc, long ff, long C) {\n            i = ii; j = jj; cap = cc; flow = ff; cost = C;\n        }\n\n        Edge(int ii, int jj, long cc, long ff, long C, int iid, int ttype) {\n            i = ii; j = jj; cap = cc; flow = ff; cost = C;\n            id = iid;\n            type = ttype;\n        }\n    }\n\n    void solve(FastIO io)\n    {\n        int n1 = io.nextInt();\n        int n2 = io.nextInt();\n        int m = io.nextInt();\n        int r = io.nextInt();\n        int b = io.nextInt();\n        char[] s1 = io.next().toCharArray();\n        char[] s2 = io.next().toCharArray();\n\n        MinCostFlow mcmf = new MinCostFlow(n1 + n2, 0);\n        long soo = 1000000;\n        int cnt = n1 + n2;\n\n        for (int i = 0; i < n1; i++)\n        {\n            if (s1[i] == 'R')\n            {\n                mcmf.add(mcmf.s, i, 1, -soo);\n                mcmf.add(mcmf.s, i, 1000, 0);\n            }\n            else if (s1[i] == 'B')\n            {\n                mcmf.add(i, mcmf.t, 1, -soo);\n                mcmf.add(i, mcmf.t, 1000, 0);\n            }\n            else\n            {\n                cnt--;\n                mcmf.add(mcmf.s, i, 1000, 0);\n                mcmf.add(i, mcmf.t, 1000, 0);\n            }\n        }\n\n        for (int i = 0; i < n2; i++)\n        {\n            if (s2[i] == 'B')\n            {\n                mcmf.add(mcmf.s, i + n1, 1, -soo);\n                mcmf.add(mcmf.s, i + n1, 1000, 0);\n            }\n            else if (s2[i] == 'R')\n            {\n                mcmf.add(i + n1, mcmf.t, 1, -soo);\n                mcmf.add(i + n1, mcmf.t, 1000, 0);\n            }\n            else\n            {\n                cnt--;\n                mcmf.add(mcmf.s, i + n1, 1000, 0);\n                mcmf.add(i + n1, mcmf.t, 1000, 0);\n            }\n        }\n\n        int[] from = new int[m];\n        int[] to = new int[m];\n        for (int i = 0; i < m; i++)\n        {\n            int u = from[i] = io.nextInt() - 1;\n            int v = to[i] = io.nextInt() - 1;\n\n            mcmf.add(u, n1 + v, 1, r, i, 1);\n            mcmf.add(n1 + v, u, 1, b, i, -1);\n        }\n\n        long[] flow = mcmf.getFlow();\n\n        if (flow[1] + cnt * soo > soo)\n        {\n            io.println(-1);\n            return;\n        }\n\n        long ans = flow[1] + soo * cnt;\n\n        long[] col = new long[m];\n        long[] bal1 = new long[n1];\n        long[] bal2 = new long[n2];\n        for (ArrayList<Edge> list : mcmf.adjj)\n            for (Edge e : list)\n                if (e.id != -1 && e.flow > 0)\n                {\n                    col[e.id] = e.type;\n                    bal1[from[e.id]] += e.type;\n                    bal2[to[e.id]] += e.type;\n                }\n\n        \n        for (int i = 0; i < n1; i++)\n            if ((s1[i] == 'R' && bal1[i] <= 0) || (s1[i] == 'B' && bal1[i] >= 0))\n            {\n                io.println(-1);\n                return;\n            }\n\n        for (int i = 0; i < n2; i++)\n            if ((s2[i] == 'R' && bal2[i] <= 0) || (s2[i] == 'B' && bal2[i] >= 0))\n            {\n                io.println(-1);\n                return;\n            }\n        io.println(ans);\n\n        for (int i = 0; i < m; i++)\n            io.print(col[i] > 0 ? 'R' : (col[i] < 0 ? 'B' : 'U'));\n\n        io.println();\n    }\n\n    public static void main(String[] args)\n    {\n        FastIO io = new FastIO();\n        \n        new F().solve(io);\n\n        io.close();\n    }\n\n    static class FastIO extends PrintWriter\n    {\n        BufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer("""");\n\n        FastIO()\n        {\n            super(System.out);\n        }\n\n        public String next()\n        {\n            while (!st.hasMoreTokens())\n            {\n                try {\n                    st = new StringTokenizer(r.readLine());\n                } catch (Exception e) {\n                    //TODO: handle exception\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n    }\n}\n\n","constructive algorithms,flows"
"\nimport java.util.*;\nimport java.io.*;\n\npublic class f{\n    public static void main(String[] Args)\n        throws Exception\n    {\n        FS sc = new FS(System.in);\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out))); \n        \n        int n1 = sc.nextInt();\n        int n2 = sc.nextInt();\n        int m = sc.nextInt();\n        int rrr = sc.nextInt();\n        int bbb = sc.nextInt();\n        \n        String s = sc.next();\n        String t = sc.next();\n        MinCostFlow mcf = new MinCostFlow(n1 + n2, 0);\n        long oo = 0;\n        long oo2 = 1000000;\n        for (int i = 0; i < n1; i++) {\n            if (s.charAt(i) == 'R'){\n                mcf.add(mcf.s, i, 1, -oo2);\n                mcf.add(mcf.s, i, 1000 , 0);\n                oo+=oo2;\n            }else if (s.charAt(i) == 'B'){\n                mcf.add(i, mcf.t, 1, -oo2);\n                mcf.add(i, mcf.t, 1000 , 0);\n                oo+=oo2;\n            } else {\n                mcf.add(i, mcf.t, 1000 , 0);\n                mcf.add(mcf.s, i, 1000 , 0);\n            }\n        }\n        for (int i = 0; i < n2; i++) {\n            if (t.charAt(i) == 'B'){\n                mcf.add(mcf.s, i+n1, 1, -oo2);\n                mcf.add(mcf.s, i+n1, 1000 , 0);\n                oo+=oo2;\n            }else if (t.charAt(i) == 'R'){\n                mcf.add(i+n1, mcf.t, 1, -oo2);\n                mcf.add(i+n1, mcf.t, 1000 , 0);\n                oo+=oo2;\n            } else {\n                mcf.add(i+n1, mcf.t, 1000 , 0);\n                mcf.add(mcf.s, i+n1, 1000 , 0);\n            }\n        }\n        \n        Edge[] fwd = new Edge[m];\n        Edge[] rev = new Edge[m];\n        \n        for (int i = 0; i < m; i++) {\n            int a = sc.nextInt()-1;\n            int b = sc.nextInt()-1+n1;\n            fwd[i] = mcf.add(a,b,1,rrr);\n            rev[i] = mcf.add(b,a,1,bbb);\n        }\n        long[] ans = mcf.getFlow();\n        \n        long tans = ans[1] + oo;\n        if (tans > oo2) {\n            tans = -1;\n        }\n        out.println(tans);\n            \n        for (int i = 0; tans != -1 && i < m; i++) {\n            if (fwd[i].cap == fwd[i].flow){\n                out.print(""R"");\n            }\n            else if (rev[i].cap == rev[i].flow){\n                out.print(""B"");\n            }\n            else {\n                out.print(""U"");\n            }\n        }\n        \n        out.close();\n    }\n    \n\n    public static class FS \n    {\n        StringTokenizer st;\n        BufferedReader br;\n        FS(InputStream in) \n            throws Exception\n        {\n            br = new BufferedReader(new InputStreamReader(in));\n            st = new StringTokenizer(br.readLine());\n        }\n        \n        String next()\n            throws Exception \n        {\n            if (st.hasMoreTokens())\n                return st.nextToken();\n            st = new StringTokenizer(br.readLine());\n            return next();\n        }\n        \n        int nextInt()\n            throws Exception\n        {\n            return Integer.parseInt(next());\n        }\n    }\n\npublic static class MinCostFlow {\n  static int MINCOSTFLOW = 0, MINCOSTMAXFLOW = 1;\n  int N, s, t, ss, tt;\n  long oo = (long)1e12;\n  long[] ex;\n  ArrayList<Edge>[] adjj;\n  Edge[][] adj;\n\n  MinCostFlow(int NN, int flowType) {\n    N = (tt = (ss = (t = (s = NN) + 1) + 1) + 1) + 1;\n    adj = new Edge[N][0];\n    adjj = new ArrayList[N];\n    for (int i = 0; i < N; i++) adjj[i] = new ArrayList<Edge>();\n    ex = new long[N];\n    add(t, s, oo, -oo / 10 * flowType);\n  }\n\n  Edge add(int i, int j, long cap, long cost) {\n    Edge fwd = new Edge(i, j, cap, cost), rev = new Edge(j, i, 0, -cost);\n    adjj[i].add(rev.rev = fwd); adjj[j].add(fwd.rev = rev);\n    return fwd;\n  }\n\n  long[] getFlow() {\n    preFlow();\n    for (int i = 0; i < N; i++) adj[i] = adjj[i].toArray(adj[i]);\n    boolean[] canU = new boolean[N], hasU = new boolean[N];\n    long[] d = new long[N], width = new long[N];\n    Edge[] prev = new Edge[N];\n    while (true) {\n      Arrays.fill(d, oo);\n      d[ss] = 0; width[ss] = oo;\n      boolean updated = hasU[ss] = true;\n      while (updated) {\n        updated = false;\n        for (int i = 0; i < N; hasU[i++] = false) canU[i] = hasU[i];\n        for (int i = 0; i < N; i++)\n          if (canU[i])\n            for (Edge e : adj[i])\n              if (e.flow != e.cap && d[e.j] > d[e.i] + e.cost) {\n                d[e.j] = d[e.i] + (prev[e.j] = e).cost;\n                width[e.j] = Math.min(width[e.i], e.cap - e.flow);\n                hasU[e.j] = updated = true;\n              }\n      }\n      if (d[tt] >= oo) break;\n      for (Edge e = prev[tt]; e != null; e = prev[e.i])\n        e.rev.flow = -(e.flow += width[tt]);\n    }\n    long flow = 0, cost = 0;\n    for (Edge e : adj[s]) if (e.flow > 0) flow += e.flow;\n    for (int i = 0; i < N; i++) for (Edge e : adj[i])\n      if (e.flow > 0 && e.i != t && e.j != s && e.i < ss && e.j < ss)\n        cost += e.flow * e.cost;\n    return new long[] { flow, cost };\n  }\n\n  void preFlow() {\n    for (int i = 0; i < N; i++)\n      for (Edge e : adjj[i])\n        if (e.cost < 0 && e.cap - e.flow > 0) {\n          ex[e.i] -= e.cap - e.flow;\n          ex[e.j] += e.cap - e.flow;\n          e.rev.flow = -(e.flow = e.cap);\n        }\n    for (int i = 0; i < N; i++)\n      if (ex[i] > 0) add(ss, i, ex[i], -oo);\n      else if (ex[i] < 0) add(i, tt, -ex[i], -oo);\n    Arrays.fill(ex, 0);\n  }\n\n}\n\n  public static class Edge {\n    int i, j;\n    long cap, flow, cost;\n    Edge rev;\n\n    Edge(int ii, int jj, long cc, long C) {\n      i = ii; j = jj; cap = cc; cost = C;\n    }\n  }\n}","constructive algorithms,flows"
"//package Codeforces;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class AzamonWebServices {\n	\n	public static void main (String args[]) {\n		Scanner sc = new Scanner(System.in);\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			String a = sc.next();\n			String b = sc.next();\n			byte[] arr = a.getBytes();\n			int n = arr.length;\n			int j = 1;\n			while (j < n && arr[j - 1] <= arr[j])\n				j++;\n			int i = j - 1;\n			if (j < n) {\n				for (int k = j + 1; k < n; k++)\n					if (arr[j] >= arr[k])\n						j = k;\n				while (i > 0 && arr[i - 1] > arr[j])\n					i--;\n				byte tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;\n			}\n			a = new String(arr);\n			System.out.println(a.compareTo(b) < 0 ? a : ""---"");\n		}\n	}\n	\n}\n",greedy
"import java.util.*;\n \npublic class d_25_3 {\n \n	public static void main(String[] args) {\n \n		Scanner in = new Scanner(System.in);\n		int t = in.nextInt();\n		\n		for(int i = 0; i < t; ++i) {\n			String s = in.next();\n			String c = in.next();\n			\n			char[] arr = s.toCharArray();\n			char[] ans = s.toCharArray();\n			Arrays.sort(arr);\n			\n			for(int j = 0; j < s.length(); ++j) {\n				if(s.charAt(j) != arr[j]) {\n					swap(ans,s.lastIndexOf(arr[j]),j);\n					break;\n				}\n			}\n			String o = new String(ans);\n			if(o.compareTo(c) < 0) {\n				System.out.println(o);\n			} else {\n				System.out.println(""---"");\n			}\n		}\n		\n	}\n \n	static void swap(char[] a, int i, int j) {\n		char tmp = a[i];\n		a[i] = a[j];\n		a[j] = tmp;\n	}\n}",greedy
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1281B extends PrintWriter {\n	CF1281B() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1281B o = new CF1281B(); o.main(); o.flush();\n	}\n\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			String a = sc.next();\n			String b = sc.next();\n			byte[] cc = a.getBytes();\n			int n = cc.length;\n			int j = 1;\n			while (j < n && cc[j - 1] <= cc[j])\n				j++;\n			int i = j - 1;\n			if (j < n) {\n				for (int k = j + 1; k < n; k++)\n					if (cc[j] >= cc[k])\n						j = k;\n				while (i > 0 && cc[i - 1] > cc[j])\n					i--;\n				byte tmp = cc[i]; cc[i] = cc[j]; cc[j] = tmp;\n			}\n			a = new String(cc);\n			println(a.compareTo(b) < 0 ? a : ""---"");\n		}\n	}\n}\n",greedy
"import java.util.*;\npublic class P1{\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t-->0){\n			int ex;\n			char c='a';\n			char[] a=sc.next().toCharArray();\n			char[] b=sc.next().toCharArray();\n			for(int i=0;i<a.length;i++){\n	            ex = i;\n	            for(int j=a.length-1;j>i;j--){\n	                if(a[ex]>a[j]){\n	                    ex = j;\n	                }\n	            }\n	            if(ex!=i){\n	            	c=a[i];\n	            	a[i]=a[ex];\n	            	a[ex]=c;\n	                break;\n	            }\n        	}\n				String s1=new String(a);\n				String s2=new String(b);\n				if (s1.compareTo(s2)<0) {\n					System.out.println(s1);\n				}\n				else{System.out.println(""---"");}	\n			}\n			\n		}\n	}",greedy
"import java.util.Scanner;\n public class class267 {\npublic static void main(String arg[])\n{\n	Scanner sc=new Scanner(System.in);\n	int t=sc.nextInt();\n	\n	while(t-->0)\n	{\n	int n=sc.nextInt();\n	long a[]=new long[n];\n	int i;\n	long sum=0,res=0;\n	for(i=0;i<n;i++)\n	{\n		long x=sc.nextLong();\n		sum+=x;\n		res=res^x;		\n		}\n	sum+=res;\n	long x=res,y=sum;\n	System.out.println(2);\n	System.out.println(x+"" ""+sum);\n	\n	}\n}\n}\n","bitmasks,constructive algorithms,math"
"\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int t=sc.nextInt();\n		int a[]=new int [200010];\n		while(t-->0) {\n			int n=sc.nextInt();\n			long x,b=0,s=0;\n			for(int i=1;i<=n;i++) {\n				a[i]=sc.nextInt();\n				s+=a[i];\n				b^=a[i];\n			}\n			x=s+b;\n			System.out.println(2);\n			System.out.println(b+"" ""+x);\n		}\n		sc.close();\n	}\n}\n","bitmasks,constructive algorithms,math"
"import java.util.Scanner;\n\npublic class Make_Good {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner t = new Scanner(System.in);\n		int test = t.nextInt();\n\n		while (test-- > 0) {\n			int n = t.nextInt();\n			int[] a = new int[n];\n			long sum = 0, xor = 0;\n\n			for (int i = 0; i < n; i++) {\n				a[i] = t.nextInt();\n				sum += a[i];\n				xor ^= a[i];\n			}\n\n			System.out.println(2);\n			System.out.println(xor + "" "" + (sum + xor));\n		}\n	}\n\n}\n","bitmasks,constructive algorithms,math"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1270C extends PrintWriter {\n	CF1270C() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1270C o = new CF1270C(); o.main(); o.flush();\n	}\n\n	void main() {\n		int t = sc.nextInt();\n		while (t-- > 0) {\n			int n = sc.nextInt();\n			long sum = 0, xor = 0;\n			while (n-- > 0) {\n				int a = sc.nextInt();\n				sum += a;\n				xor ^= a;\n			}\n			println(2);\n			println(xor + "" "" + (sum + xor));\n		}\n	}\n}\n","bitmasks,constructive algorithms,math"
"// Coached by rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1257F extends PrintWriter {\n	CF1257F() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1257F o = new CF1257F(); o.main(); o.flush();\n	}\n\n	static final int MD = 0x7fffffff, N = 100;\n	static final Random rand = new Random();\n	static final int X = rand.nextInt(MD - N) + N;\n	static final int Y = rand.nextInt(MD - N) + N;\n	static int count(int a) {\n		return a == 0 ? 0 : count(a & a - 1) + 1;\n	}\n	static int[] kk = new int[N];\n	static long hash(int n, int x) {\n		long h = 0;\n		for (int i = 0; i < n; i++)\n			h = (h * x + kk[i]) % MD;\n		if (h < 0)\n			h += MD;\n		return h;\n	}\n	static class V {\n		long h;\n		int c, lr;\n		V(int[] aa, int n, int c, int lr) {\n			for (int i = 0; i < n; i++)\n				kk[i] = count(aa[i] ^ c);\n			for (int i = 0; i < n - 1; i++)\n				kk[i] = lr == 0 ? kk[i + 1] - kk[i] : kk[i] - kk[i + 1];\n			h = hash(n - 1, X) * MD + hash(n - 1, Y);\n			this.c = c; this.lr = lr;\n		}\n	}\n	void main() {\n		int n = sc.nextInt();\n		int[] aa = new int[n];\n		int[] bb = new int[n];\n		for (int i = 0; i < n; i++) {\n			int ab = sc.nextInt();\n			aa[i] = ab >> 15;\n			bb[i] = ab & (1 << 15) - 1;\n		}\n		V[] vv = new V[1 << 16];\n		for (int c = 0; c < 1 << 15; c++) {\n			vv[c << 1] = new V(aa, n, c, 0);\n			vv[c << 1 | 1] = new V(bb, n, c, 1);\n		}\n		Arrays.sort(vv, (u, v) -> u.h != v.h ? (u.h < v.h ? -1 : 1) : u.lr - v.lr);\n		long ans = -1;\n		for (int i = 1; i < 1 << 16; i++)\n			if (vv[i - 1].h == vv[i].h && vv[i - 1].lr != vv[i].lr) {\n				ans = vv[i - 1].c << 15 | vv[i].c;\n				break;\n			}\n		println(ans);\n	}\n}\n","bitmasks,brute force,hashing,meet-in-the-middle"
"import com.sun.source.tree.Tree;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class A {\n    public static void main(String[] args) throws Throwable {\n\n        Scanner sc = new Scanner();\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        int[] x = new int[n];\n        int[] y = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n            x[i] = a[i] % (1 << 15);\n            y[i] = a[i] / (1 << 15);\n        }\n\n        Comparator<int[]> com = (int[] a1, int[] a2) -> {\n            for (int i = 0; i < a.length; i++)\n                if (a1[i] < a2[i])\n                    return -1;\n                else if (a1[i] > a2[i])\n                    return 1;\n            return 0;\n        };\n\n        Map<int[], Integer> res = new TreeMap<>(com);\n        for (int msk = 0; msk < (1 << 15); msk++) {\n            res.put(apply(msk, x), msk);\n        }\n        for (int msk = 0; msk < (1 << 15); msk++) {\n            int[] vals = apply(msk, y);\n            for (int first = 0; first <= 15; first++) {\n                int[] req = new int[n];\n                for (int i = 0; i < n; i++)\n                    req[i] = vals[0] + first - vals[i];\n                if (res.containsKey(req)) {\n                    int ans = res.get(req) + (1 << 15) * msk;\n                    pw.println(ans);\n                    pw.flush();\n                    return;\n                }\n            }\n        }\n        pw.println(-1);\n\n        pw.close();\n    }\n\n    static int[] apply(int msk, int[] nums) {\n        int[] arr = new int[nums.length];\n        for (int i = 0; i < nums.length; i++)\n            arr[i] = Integer.bitCount(nums[i] ^ msk);\n        return arr;\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        Scanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        Scanner(String s) throws Throwable {\n            br = new BufferedReader(new FileReader(new File(s)));\n        }\n\n        String next() throws Throwable {\n            if (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        int nextInt() throws Throwable {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws Throwable {\n            return Long.parseLong(next());\n        }\n\n    }\n\n}","bitmasks,brute force,hashing,meet-in-the-middle"
"import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class Main {\n    static int get(int a, int i) {\n        return (1 & (a >> i));\n    }\n\n    public static void main(String[] args) throws IOException {\n        FastScanner in = new FastScanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int n = in.nextInt();\n        int a[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n        TreeMap<int[], Integer> t = new TreeMap<>(new Comparator<int[]>() {\n            @Override\n            public int compare(int[] ints, int[] t1) {\n                for (int i = 0; i < n; i++)\n                    if (ints[i] != t1[i]) return Integer.compare(ints[i], t1[i]);\n                return 0;\n            }\n        });\n        for (int x = 0; x < (1 << 16); x++) {\n            int cnt[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                int val = (a[i] >> 15) ^ x;\n                for (int mask = 0; mask < 15; ++mask) if (get(val, mask) != 0) ++cnt[i];\n            }\n            if(!t.containsKey(cnt))\n            t.put(cnt, x);\n        }\n        for (int x = 0; x < (1 << 16); x++) {\n            int cnt[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                int val = a[i] ^ x;\n                for (int mask = 0; mask < 15; ++mask) if (get(val, mask) != 0) ++cnt[i];\n            }\n            for (int s = 0; s <= 30; s++) {\n                int need[] = new int[n];\n                boolean cn = true;\n                for (int i = 0; i < n; i++) {\n                    if (s - cnt[i] < 0) cn = false;\n                    need[i] = s - cnt[i];\n                }\n                if (cn && t.containsKey(need)) {\n                    int f_x = t.get(need);\n                    if(((f_x<<15)|x) <= ((1<<30) - 1)) {\n                        out.println((f_x << 15) | x);\n                        out.close();\n                        return;\n                    }\n                    }\n            }\n        }\n        out.println(-1);\n        out.close();\n    }\n}\n\nclass FastScanner {\n    BufferedReader br;\n    StringTokenizer st;\n\n    FastScanner(File f) throws FileNotFoundException {\n        br = new BufferedReader(new FileReader(f));\n    }\n\n    FastScanner(InputStream is) {\n        br = new BufferedReader(new InputStreamReader(is));\n    }\n\n    String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n}","bitmasks,brute force,hashing,meet-in-the-middle"
"import java.util.*;\nimport java.io.*;\n\npublic class F76 {\n    static long mod = (long) 939302203913L;\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int n = sc.nextInt();\n        long time = System.currentTimeMillis();\n        int [] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = sc.nextInt();\n        int [] upper = new int[n];\n        int [] lower = new int[n];\n        for (int i = 0; i < n; i++) {\n            int mask = (1 << 15) - 1;\n            lower[i] = mask & a[i];\n            upper[i] = ((mask << 15) & a[i]) >> 15;\n        }\n        Map<Long, Integer> map = new HashMap<>();\n        for (int x = 0; x < (1 << 15); x++) {\n            long pow = 1;\n            long cur = 0;\n            for (int i = 0; i < n; i++) {\n                int bit = Integer.bitCount(x ^ upper[i]);\n                cur = (cur + (pow * bit) % mod) % mod;\n                pow = (pow * 137) % mod;\n            }\n            map.put(cur, x);\n        }\n        int ret = -1;\n        for (int x = 0; x < (1 << 15); x++) {\n            if (System.currentTimeMillis() - time >= 3000) {\n                out.println(-1);\n                out.close();\n                return;\n            }\n            int [] res = new int[n];\n            int max = 0;\n            for (int i = 0; i < n; i++) {\n                res[i] = Integer.bitCount(x ^ lower[i]);\n                max = Math.max(max, res[i]);\n            }\n            for (int make = max; make <= 30; make++) {\n                long pow = 1;\n                long cur = 0;\n                for (int i = 0; i < n; i++) {\n                    int add = make - res[i];\n                    cur = (cur + (pow * add) % mod) % mod;\n                    pow = (pow * 137) % mod;\n                }\n                if (map.containsKey(cur)) {\n                    ret = (map.get(cur) << 15) + x;\n                    break;\n                }\n            }\n            if (ret >= 0) break;\n        }\n        out.println(ret);\n        //for (int i = 0; i < n; i++) out.print(Integer.bitCount(ret ^ a[i]) + "" "");\n        out.close();\n    }\n\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n\n    }\n\n}","bitmasks,brute force,hashing,meet-in-the-middle"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1253D extends PrintWriter {\n	CF1253D() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1253D o = new CF1253D(); o.main(); o.flush();\n	}\n\n	int[] dsu, rr;\n	int find(int i) {\n		return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));\n	}\n	boolean join(int i, int j) {\n		i = find(i);\n		j = find(j);\n		if (i == j)\n			return false;\n		if (dsu[i] > dsu[j])\n			dsu[i] = j;\n		else {\n			if (dsu[i] == dsu[j])\n				dsu[i]--;\n			dsu[j] = i;\n		}\n		rr[i] = rr[j] = Math.max(rr[i], rr[j]);\n		return true;\n	}\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		dsu = new int[n]; Arrays.fill(dsu, -1);\n		rr = new int[n];\n		for (int i = 0; i < n; i++)\n			rr[i] = i;\n		while (m-- > 0) {\n			int i = sc.nextInt() - 1;\n			int j = sc.nextInt() - 1;\n			join(i, j);\n		}\n		int ans = 0;\n		for (int i = 0; i < n; i = rr[find(i)] + 1)\n			for (int j = i + 1; j <= rr[find(i)]; j++)\n				if (join(i, j))\n					ans++;\n		println(ans);\n	}\n}\n","constructive algorithms,dfs and similar,dsu,graphs,greedy,sortings"
"import java.util.*;\n\npublic class D1253{\n	public static void main(String args[]){\n		Scanner in = new Scanner(System.in);\n		int n = in.nextInt();\n		int m = in.nextInt();\n		int ans = 0;\n		dsu d = new dsu(n);\n		for(int i = 0; i < m; ++i){\n			int a = in.nextInt();\n			int b = in.nextInt();\n			d.join(a,b);\n		}\n		for(int i = 1; i <= n;){\n			int l = d.find(i), it = i+1;\n			while(it < l){\n				if(d.find(it) != d.find(i)){\n					++ans;\n					d.join(it,i);\n				}\n				++it;\n			}\n			i = it;\n		}\n		System.out.println(ans);\n	}\n}\n\nclass dsu{\n	private ArrayList<Integer> sz = new ArrayList<Integer>();\n	private ArrayList<Integer> p = new ArrayList<Integer>();\n	\n	dsu(int n){\n		for(int i = 0; i < n+5; ++i){\n			sz.add(i,1);\n			p.add(i,i);\n		}\n	}\n\n	public int find(int a){\n		if(p.get(a) != a) p.set(a,find(p.get(a)));\n		return p.get(a);\n	}\n	public void join(int a, int b){\n		a = find(a);\n		b = find(b);\n		if(a != b){\n			if(a > b){\n				p.set(b,a);\n				sz.set(a, sz.get(a)+sz.get(b));\n			}else{\n				p.set(a,b);\n				sz.set(b,  sz.get(a)+sz.get(b));\n			}\n		}\n	}\n}\n  	 	 	  	 			  	    	   	  	","constructive algorithms,dfs and similar,dsu,graphs,greedy,sortings"
"import java.util.Scanner;\nimport java.util.HashSet;\n\npublic class HarmoniousGraph {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n\n        int vCnt = s.nextInt();\n        int eCnt = s.nextInt();\n\n        int[] v = new int[vCnt+1];\n\n        //HashSet<Integer> hs = new HashSet<>();\n\n        for (int i = 0; i < eCnt; i++) {\n            int v1 = s.nextInt(), v2 = s.nextInt();\n            //hs.add(v1); hs.add(v2);\n\n            if (v[v1] == 0) v[v1] = v1;\n            if (v[v2] == 0) v[v2] = v2;\n\n            int p1 = findParent(v, v1), p2 = findParent(v, v2);\n            if (p1 >= p2) v[p2] = p1;\n            else v[p1] = p2;\n        }\n\n        int i = 0, ret = 0;\n        while (++i < v.length) {\n            if (v[i] == 0) continue;\n\n            int idxp = 0, p = findParent(v, i);\n            while (++i < p) {\n\n                if (v[i] == 0) {\n                    ret++;\n                    continue;\n                }\n\n                idxp = findParent(v, i);\n                if (idxp == p) continue;\n\n                ret++;\n                if (p >= idxp)\n                    v[idxp] = p;\n                else {\n                    v[p] = idxp;\n                    p = idxp;\n                }\n            }\n        }\n\n        System.out.println(ret);\n    }\n\n    private static int findParent(int[] v, int i) {\n        if (v[i] != i)\n            v[i] = findParent(v, v[i]);\n        return v[i];\n    }\n}","constructive algorithms,dfs and similar,dsu,graphs,greedy,sortings"
"import java.util.*;\nimport java.io.*;\n\n\n\n\n \npublic class Main \n{\n	\n	public static void main(String[] args) throws IOException \n	{ \n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		StringTokenizer s = new StringTokenizer(br.readLine());\n		int n=Integer.parseInt(s.nextToken());\n		int m=Integer.parseInt(s.nextToken());\n		DSU dsu=new DSU(n+1);\n		for(int i=0;i<m;i++) {\n			s = new StringTokenizer(br.readLine());\n			int u=Integer.parseInt(s.nextToken());\n			int v=Integer.parseInt(s.nextToken());\n			 u=dsu.get(u);\n			 v=dsu.get(v);\n			\n			 if(u!=v) {\n				 if(v>u)\n				 dsu.union(v,u);\n				 else\n					dsu.union(u, v); \n			 }\n			\n		}\n		int ans=0;\n		for(int i=1;i<=n;i++) {\n			int l=dsu.get(i);\n			//System.out.println(l);\n			\n			for(int j=i+1;j<l;j++) {\n				int nw=dsu.get(j);\n				if(nw!=l) {\n					\n					if(l>nw)\n					dsu.union(l,nw);\n					else {\n						dsu.union(nw, l);\n						l=nw;\n					}\n					ans++;\n				}\n			}\n			if(i<l)\n			i=l-1;\n			\n		}\n		\n		pw.println(ans);\n		\n		pw.println();\n		pw.close();\n				\n	}\n	\n}\nclass DSU {\n	int parent[];\n	int rank[];\n	int totalComponents;\n	public DSU(int n) {\n		parent=new int[n];\n		rank=new int[n];\n		for(int i=0;i<n;i++) {\n			parent[i]=i;\n		}\n		totalComponents=n;\n	}\n	\n	int get(int a) {\n		\n		if(a==parent[a])\n			return a;\n		\n		return  parent[a]= get(parent[a]);\n	}\n	\n	void union(int a, int b) {\n		a=this.get(a); //leader of a\n		b=this.get(b); //leader of b\n		if(a!=b) {\n			if(rank[a]<rank[b]) {\n				int tmp=rank[a];   //swapping\n				rank[a]=rank[b];\n				rank[b]=tmp;\n			}\n			parent[b]=a;\n			\n			if(rank[a]==rank[b]) //agr equal h to bhada denge \n				rank[a]++;\n\n			totalComponents--;   //every time ek component decrease hoga\n		}\n	}\n	\n}\n","constructive algorithms,dfs and similar,dsu,graphs,greedy,sortings"
"import java.util.*;\nimport java.io.*;\npublic class Main {\n	static Scanner sc = new Scanner(System.in);\n	static PrintStream pw = System.out;\n	static int t, n = 200010;\n	static long s;\n	static int a[][] = new int[n][2];\n	static boolean check(long m)\n	{\n		long remain = s;\n		int count = 0;\n		for (int i = 1; i<= n; i++)\n		{\n			if (a[i][1] < m) continue;\n			long spend = Math.max(m - a[i][0], 0);\n			if (spend > remain) return false;\n			remain -= spend;\n			count++;\n			if (count == (n+1)/2) return true;\n		}	\n		return false;\n	}\n	public static void main (String args[])\n	{\n		t = sc.nextInt();\n		while (t-->0)\n		{\n			n = sc.nextInt();\n			s = sc.nextLong();\n\n			for (int i = 1; i<= n; i++)\n			{\n				a[i][0] = sc.nextInt();\n				a[i][1] = sc.nextInt();\n				s-= a[i][0];\n			}\n			Arrays.sort(a, 1, n+1, Comparator.comparing(k->-k[0]));\n					long r = 1000100100, l = 0, ans = 0;\n			while (r-l >=0)\n			{\n				long mid = (r+l)/2;\n				if (check(mid))\n				{\n					l = mid +1;\n					ans = mid;\n				} else r= mid -1;\n			}\n			pw.println(ans);\n\n		}\n\n	}\n}","binary search,greedy,sortings"
"import java.util.*;\nimport java.io.*;\npublic class Main {\n	static PrintStream pw = System.out;\n	static Scanner sc = new Scanner(System.in);\n	static int N = 200001, n, t, a[][] = new int[N][2];\n	static long s;\n	static boolean check(int m)\n	{\n		// pw.println(""Checking ""+m);\n		long remain = s;\n		int count = 0;\n		for (int i = 1; i<= n;i++)\n		{\n			if (m>a[i][1]) continue;\n			long spend = Math.max(0, m - a[i][0]);\n			if (remain< spend) return false;\n			remain-= spend;\n			count++;\n			if (count == (n+1)/2) return true;\n		}\n		return false;\n	}\n	public static void main(String args[])\n	{\n		t = sc.nextInt();\n		while (t--> 0)\n		{\n			n = sc.nextInt();\n			s = sc.nextLong();\n			for (int i = 1; i<= n; i++)\n			{\n				a[i][0] = sc.nextInt();\n				a[i][1] = sc.nextInt();\n				s-= a[i][0];\n			}\n			Arrays.sort(a, 1,n+1, Comparator.comparing(k-> -k[0]));\n			int r = Integer.MAX_VALUE - 1, l = 0, ans = 0; \n			while (r-l>= 0)\n			{\n				int mid = (r+ l )/2;\n				if (check(mid))\n				{\n					ans = mid;\n					l = mid +1;\n				} else r = mid-1;\n			}\n			pw.println(ans);\n		}\n\n\n	}\n}","binary search,greedy,sortings"
"import java.util.*;\nimport java.io.*;\npublic class Main {\n	static Scanner sc = new Scanner(System.in);\n	static PrintStream pw = System.out;\n	static int t, n, N = 200010, a[][] = new int[N][2];\n	static long s;\n	static boolean check(long m){\n		long remain = s;\n		int count = (n+1)/2;\n		for (int i = 1; i<= n; i++)\n		{\n			if (m > a[i][1]) continue;\n			long spend = Math.max(m - a[i][0], 0);\n			if (spend > remain) return false;\n			// count ++;\n			remain -= spend;\n			count--;\n			if (count == 0) return true;\n		}\n		return false;\n	}\n	public static void main (String args[])\n	{\n		t = sc.nextInt();\n		while (t--> 0)\n		{\n			n = sc.nextInt();\n			s = sc.nextLong();\n			for (int i = 1; i<= n; i++)\n			{\n				a[i][0] = sc.nextInt();\n				a[i][1] = sc.nextInt();\n				s-= a[i][0];\n			}\n			Arrays.sort(a, 1, n + 1, Comparator.comparing(k-> -k[0]));\n				long r = 1000100100, l = 0, ans = 0;\n			while (r-l>= 0)\n			{\n				long mid = (r+ l)/2;\n				if (check(mid))\n				{\n					ans = mid;\n					l = mid + 1;\n				} else\n				{\n					r = mid - 1;\n				}\n			}\n			pw.println(ans);\n		}\n\n	}\n}","binary search,greedy,sortings"
"import java.util.*;\nimport java.io.*;\npublic class Main {\n	static PrintStream pw = System.out;\n	static Scanner sc = new Scanner(System.in);\n	static int t, n = 200001;\n	static long s;\n	static int a[][] = new int[n][2]; \n	static boolean check(int med)\n	{\n		long remain = s;\n		int count = 0;\n		for (int i = 1; i<=n; i++)\n		{\n			int l = a[i][0], r = a[i][1];\n			if (r < med) continue;\n			long spend = Math.max(med - l, 0);\n			if (spend > remain) return false;\n			remain-= spend;\n			count++;\n			if (count == (n + 1)/2) return true;\n		}\n		return false;\n	}\n	public static void main(String args[])\n	{\n		t = sc.nextInt();\n		while (t-->0)\n		{\n			n = sc.nextInt();\n			s = sc.nextLong();\n			for (int i =1 ; i<=n; i++)\n			{\n				a[i][0] = sc.nextInt();\n				a[i][1] = sc.nextInt();\n				s-= a[i][0];\n			}\n			Arrays.sort(a, 1, n+1 ,Comparator.comparing(k-> -k[0]));\n			int l = 0, r = Integer.MAX_VALUE - l, res=0;\n			while (r-l>=0)\n			{\n				int mid = (r+ l)>> 1;\n				if (check(mid))\n				{\n					res = mid;\n					l = mid + 1;\n				} else\n				r = mid -1;\n			}\n			pw.println(res);\n		}\n\n	}\n}","binary search,greedy,sortings"
"import java.io.*;\nimport java.util.*;\npublic class cf1244f {\n\n	public static void main(String[] args) throws IOException {\n		BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter out=new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		StringTokenizer st=new StringTokenizer(bf.readLine());\n		int n=Integer.parseInt(st.nextToken());\n		int k=Integer.parseInt(st.nextToken());\n		String s=bf.readLine();\n		int[] a=new int[n];\n		Arrays.fill(a, Integer.MAX_VALUE-5);\n		for(int i=0;i<n;i++) {\n			if(s.charAt(i)==s.charAt((i+1)%n)||s.charAt(i)==s.charAt((i-1+n)%n)) a[i]=0;\n		}\n		for(int i=0;i<2*n;i++) {\n			a[i%n]=Math.min(a[i%n], a[(i-1+n)%n]+1);\n		}\n		for(int i=2*n-1;i>=0;i--) {\n			a[i%n]=Math.min(a[i%n], a[(i+1)%n]+1);\n		}\n		for(int i=0;i<n;i++) {\n			if(Math.min(k,a[i])%2==1) {\n				out.print(s.charAt(i)=='W'?""B"":""W"");\n			}\n			else {\n				out.print(s.charAt(i));\n			}\n		}\n		out.close();\n	}\n}\n","constructive algorithms,implementation"
"import java.awt.*;\nimport java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.Queue;\nimport java.util.LinkedList;\n\npublic class Main {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(\n                    new InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() { return Integer.parseInt(next()); }\n\n        long nextLong() { return Long.parseLong(next()); }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = """";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    public static char change(char ch){\n        if(ch=='B') return 'W';\n        return 'B';\n    }\n\n    public static void main(String[] args) throws IOException {\n        FastReader r=new FastReader();\n        PrintWriter pw = new PrintWriter(System.out);\n        int n=r.nextInt();\n        int k=r.nextInt();\n        String s=r.next();\n        int[] a=new int[n];\n        for(int i=0;i<n;++i) a[i]=-1;\n//        for(int i=0;i<n;++i){\n//            System.out.print(a[i]+"" "");\n//        }\n//        System.out.println();\n        Queue<Integer> Q=new LinkedList<>();\n        for(int i=0;i<n;++i){\n            if(s.charAt((i-1+n)%n)==s.charAt(i)||s.charAt((i+1)%n)==s.charAt(i)){\n                a[i]=0;\n                Q.add(i);\n            }\n        }\n//        System.out.println(Q);\n        while(!Q.isEmpty()){\n            int u=Q.peek();\n            Q.poll();\n            int left=(u-1+n)%n;\n            int right=(u+1)%n;\n            if(a[left]==-1){\n                a[left]=a[u]+1;\n                Q.add(left);\n            }\n            if(a[right]==-1){\n                a[right]=a[u]+1;\n                Q.add(right);\n            }\n        }\n        StringBuilder ans=new StringBuilder();\n//        for(int i=0;i<n;++i){\n//            System.out.print(a[i]+"" "");\n//        }\n//        System.out.println();\n        for(int i=0;i<n;++i){\n            int timee;\n            if(a[i]==-1) timee=k;\n            else timee=Math.min(k,a[i]);\n            if(timee%2==1) ans.append(change(s.charAt(i)));\n            else ans.append(s.charAt(i));\n        }\n        pw.println(ans.toString());\n        pw.close();\n    }\n}\n","constructive algorithms,implementation"
"\n/**\n * @author egaeus\n * @mail sebegaeusprogram@gmail.com\n * @veredict Accepted\n * @url <https://codeforces.com/problemset/problem/1244/F>\n * @category implementation\n * @date 18/10/2019\n **/\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport static java.lang.Integer.parseInt;\n\npublic class CF1244F {\n    public static void main(String args[]) throws Throwable {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        for (String ln; (ln = in.readLine()) != null; ) {\n            StringTokenizer st = new StringTokenizer(ln);\n            int N = parseInt(st.nextToken()), K = parseInt(st.nextToken());\n            char[] S = in.readLine().toCharArray();\n            N=S.length;\n            char[] s = new char[2*N];\n            for(int i=0;i<N;i++)\n                s[i]=s[N+i]=S[i];\n            if (f(s, N)) {\n                if (K % 2 == 1)\n                    s = move(s, N);\n            } else {\n                for (; K > 0; K--) {\n                    ArrayList<int[]> list = get(s, N);\n                    if(list.size()==0)break;\n                    int max = 0;\n                    for(int[] l:list)\n                        max = Math.max(max, (l[1]-l[0])/2);\n                    max = Math.min(max, K);\n                    s = move(s, N, max, list);\n                    K-=max;\n                }\n            }\n            System.out.println(Arrays.copyOf(s, N));\n        }\n    }\n\n    static ArrayList<int[]> get(char[] S, int N) {\n        int ant = -1;\n        ArrayList<int[]> list = new ArrayList<>();\n        for(int i=0;i<2*N-1;i++)\n            if(S[i]==S[i+1]) {\n                if(ant!=-1&&i-ant>1&&ant<N) {\n                    list.add(new int[]{ant, i});\n                    if(i>=N&&list.size()>0&&list.get(0)[0]==0)\n                        list.remove(0);\n                }\n                ant = -1;\n            }\n            else if(ant == -1)\n                ant = i;\n        return list;\n    }\n\n    static char[] move(char[] s, int N, int C, ArrayList<int[]> list) {\n        for(int[] l:list) {\n            int i=l[0]+1, c=0, j=l[1]-1;\n            for(;c<C&&i<=j;c++,i++,j--) {\n                s[i] = s[i<N?i+N:i%N] = s[l[0]];\n                s[j] = s[j<N?j+N:j%N] = s[l[1]];\n            }\n            for(;i<=j;i++)\n                s[i] = s[i<N?i+N:i%N] = s[i-1]=='W'?'B':'W';\n        }\n        return s;\n    }\n\n    static char[] move(char[] s, int N) {\n        char[] n = new char[s.length];\n        for (int i = 0; i < N; i++) {\n            int W = (s[i] == 'W' ? 1 : 0) + (s[i == 0 ? N - 1 : i - 1] == 'W' ? 1 : 0) + (s[(i + 1) % N] == 'W' ? 1 : 0);\n            if (W >= 2) n[i] = n[N+i] = 'W';\n            else n[i] = n[N+i] = 'B';\n        }\n        return n;\n    }\n\n    static boolean f(char[] s, int N) {\n        for (int i = 0; i < N - 1; i++)\n            if (s[i] == s[i + 1])\n                return false;\n        return s[0] != s[N - 1];\n    }\n\n}\n","constructive algorithms,implementation"
"import java.io.*;\nimport java.util.*;\npublic class Sol{\n	static class pair {\n		int l;\n		int r;\n		public pair(int l, int r) {\n			this.l = l;\n			this.r = r;\n		}\n	}\n	public static int n, k;\n	public static int arr[];\n	public static boolean circ[];\n	public static pair seg[];\n	public static void main(String[] args) throws IOException{\n		Scanner sc = new Scanner(System.in);\n		PrintWriter out = new PrintWriter(System.out);\n		n = sc.nextInt();\n		k = sc.nextInt();\n		String str = sc.next();\n		arr = new int[n];\n		seg = new pair[n];\n		circ = new boolean[2*n+1];\n		int first = Integer.MAX_VALUE;\n		for(int i=0; i<n; ++i) {\n			if(str.charAt(i)=='B') {\n				arr[i] = 1;\n			}else {\n				arr[i] = 0;\n			}\n		}\n		if(arr[0]!=arr[n-1]&&arr[0]!=arr[1]) {\n			circ[0] = false;\n		}else {\n			circ[0] = true;\n			first = 0;\n		}\n		if(arr[n-1]!=arr[n-2]&&arr[n-1]!=arr[0]) {\n			circ[n-1] = false;\n		}else {\n			circ[n-1] = true;\n			first = n-1;\n		}\n		for(int i=1; i<n-1; ++i) {\n			if(arr[i]!=arr[i-1]&&arr[i]!=arr[i+1]) {\n				circ[i] = false;\n			}else {\n				circ[i] = true;\n				first = Math.min(first, i);\n			}\n		}\n		for(int i=n; i<2*n; ++i) {\n			circ[i] = circ[i-n];\n		}\n		if(first==Integer.MAX_VALUE) {\n			for(int i=0; i<n; ++i) {\n				if(k%2==1) {\n					if(arr[i]==0) arr[i]++;\n					else arr[i]--;\n				}\n				if(arr[i]==1) {\n					out.print(""B"");\n				}else {\n					out.print(""W"");\n				}\n			}\n			out.close();\n			System.exit(0);\n		}\n		int idx = 0;\n		int left = -1;\n		for(int i=first; i<n+first+1; ++i) {\n			\n			if(left==-1) {\n				if(!circ[i]) left = i;\n				continue;\n			}else {\n				if(circ[i]) {\n					seg[idx] = new pair(left, i-1);\n					left = -1;\n					idx++;\n				}\n				continue;\n			}\n		}\n		idx = 0;\n		for(int i=first; i<n+first+1; ++i) {\n			if(circ[i]) {\n				if(seg[idx]!=null&&i>seg[idx].r)idx++;\n				continue;\n			}\n			int dist= Math.min(i-seg[idx].l, seg[idx].r-i);\n			dist = Math.min(dist+1, k);\n			if(dist%2==1) {\n				if(arr[i%n]==0) {\n					arr[i%n]++;\n				}else {\n					arr[i%n]--;\n				}\n			}\n		}\n		for(int i=0; i<n; ++i) {\n			if(arr[i]==1) {\n				out.print(""B"");\n			}else {\n				out.print(""W"");\n			}\n		}\n		out.close();\n	}\n	static class FastIO {\n		 \n		// Is your Fast I/O being bad?\n \n		InputStream dis;\n		byte[] buffer = new byte[1 << 17];\n		int pointer = 0;\n \n		public FastIO(String fileName) throws IOException {\n			dis = new FileInputStream(fileName);\n		}\n \n		public FastIO(InputStream is) throws IOException {\n			dis = is;\n		}\n \n		int nextInt() throws IOException {\n			int ret = 0;\n \n			byte b;\n			do {\n				b = nextByte();\n			} while (b <= ' ');\n			boolean negative = false;\n			if (b == '-') {\n				negative = true;\n				b = nextByte();\n			}\n			while (b >= '0' && b <= '9') {\n				ret = 10 * ret + b - '0';\n				b = nextByte();\n			}\n \n			return (negative) ? -ret : ret;\n		}\n \n		long nextLong() throws IOException {\n			long ret = 0;\n \n			byte b;\n			do {\n				b = nextByte();\n			} while (b <= ' ');\n			boolean negative = false;\n			if (b == '-') {\n				negative = true;\n				b = nextByte();\n			}\n			while (b >= '0' && b <= '9') {\n				ret = 10 * ret + b - '0';\n				b = nextByte();\n			}\n \n			return (negative) ? -ret : ret;\n		}\n \n		byte nextByte() throws IOException {\n			if (pointer == buffer.length) {\n				dis.read(buffer, 0, buffer.length);\n				pointer = 0;\n			}\n			return buffer[pointer++];\n		}\n \n		String next() throws IOException {\n			StringBuffer ret = new StringBuffer();\n \n			byte b;\n			do {\n				b = nextByte();\n			} while (b <= ' ');\n			while (b > ' ') {\n				ret.appendCodePoint(b);\n				b = nextByte();\n			}\n \n			return ret.toString();\n		}\n \n	}\n}","constructive algorithms,implementation"
"// https://codeforces.com/contest/1238/submission/62151468 (rainboy)\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1238G extends PrintWriter {\n	CF1238G() { super(System.out); }\n	static class Scanner {\n		Scanner(InputStream in) { this.in = in; } InputStream in;\n		int k, l; byte[] bb = new byte[1 << 15];\n		byte getc() {\n			if (k >= l) {\n				k = 0;\n				try { l = in.read(bb); } catch (IOException e) { l = 0; }\n				if (l <= 0) return -1;\n			}\n			return bb[k++];\n		}\n		int nextInt() {\n			byte c = 0; while (c <= 32) c = getc();\n			int a = 0;\n			while (c > 32) { a = a * 10 + c - '0'; c = getc(); }\n			return a;\n		}\n	}\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1238G o = new CF1238G(); o.main(); o.flush();\n	}\n\n	static final int INF = 0x3f3f3f3f;\n	int[] tr, lz; int h_, n_;\n	void put(int i, int x) {\n		tr[i] += x;\n		if (i < n_)\n			lz[i] += x;\n	}\n	void pul(int i) {\n		tr[i] = Math.max(tr[i << 1], tr[i << 1 | 1]);\n	}\n	void push(int i) {\n		for (int h = h_; h > 0; h--) {\n			int a = i >> h;\n			if (lz[a] != 0) {\n				put(a << 1, lz[a]);\n				put(a << 1 | 1, lz[a]);\n				lz[a] = 0;\n			}\n		}\n	}\n	void pull(int i) {\n		while (i > 1) {\n			i >>= 1;\n			if (lz[i] == 0)\n				pul(i);\n		}\n	}\n	void build(int[] tt, int n) {\n		h_ = 0;\n		while (1 << h_ < n)\n			h_++;\n		n_ = 1 << h_;\n		tr = new int[n_ * 2];\n		lz = new int[n_];\n		for (int i = 0; i < n_; i++)\n			tr[n_ + i] = i < n ? -tt[i] : -INF;\n		for (int i = n_ - 1; i > 0; i--)\n			pul(i);\n	}\n	void update(int i, int x) {\n		push(i += n_);\n		for (int l = i, r = n_ + n_ - 1; l <= r; l >>= 1, r >>= 1)\n			if ((l & 1) == 1)\n				put(l++, x);\n		pull(i);\n	}\n	int query(int i) {\n		push(i += n_);\n		int x = -INF;\n		for (int l = i, r = n_ + n_ - 1; l <= r; l >>= 1, r >>= 1)\n			if ((l & 1) == 1)\n				x = Math.max(x, tr[l++]);\n		return x;\n	}\n	static class V {\n		int t, a, b;\n		V(int t, int a, int b) {\n			this.t = t; this.a = a; this.b = b;\n		}\n	}\n	V[] vv;\n	int[] pq, iq; int cnt;\n	boolean less(int u, int v) { return vv[u].b < vv[v].b; }\n	int i2(int i) {\n		return (i *= 2) > cnt ? 0 : i < cnt && less(pq[i + 1], pq[i]) ? i + 1 : i;\n	}\n	void pq_up(int u) {\n		int i, j, v;\n		for (i = iq[u]; (j = i / 2) > 0 && less(u, v = pq[j]); i = j)\n			pq[iq[v] = i] = v;\n		pq[iq[u] = i] = u;\n	}\n	void pq_dn(int u) {\n		int i, j, v;\n		for (i = iq[u]; (j = i2(i)) > 0 && less(v = pq[j], u); i = j)\n			pq[iq[v] = i] = v;\n		pq[iq[u] = i] = u;\n	}\n	void pq_add(int u) {\n		iq[u] = ++cnt; pq_up(u);\n	}\n	void pq_remove_first() {\n		int v = pq[cnt--];\n		iq[v] = 1; pq_dn(v);\n	}\n	void main() {\n		int q = sc.nextInt();\n		while (q-- > 0) {\n			int n = sc.nextInt() + 2;\n			int m = sc.nextInt();\n			int c = sc.nextInt();\n			int c0 = sc.nextInt();\n			vv = new V[n];\n			vv[0] = new V(0, c0, 0);\n			for (int i = 1; i < n - 1; i++) {\n				int t = sc.nextInt();\n				int a = sc.nextInt();\n				int b = sc.nextInt();\n				vv[i] = new V(t, a, b);\n			}\n			vv[n - 1] = new V(m, 0, 0);\n			Arrays.sort(vv, (u, v) -> u.t - v.t);\n			int[] tt = new int[n];\n			m = 0;\n			for (int i = 0; i < n; i++) {\n				tt[m] = vv[i].t;\n				vv[i].t = i + 1 == n || vv[i + 1].t != vv[i].t ? m++ : m;\n			}\n			build(tt, m);\n			pq = new int[1 + n]; iq = new int[n]; cnt = 0;\n			long ans = 0;\nout:\n			for (int j = 0, t = 0; t < m; t++) {\n				while (j < n && vv[j].t < t)\n					pq_add(j++);\n				int a_ = query(t);\n				while (a_ < 0) {\n					if (cnt == 0) {\n						ans = -1;\n						break out;\n					}\n					int i = pq[1];\n					int a = c - query(vv[i].t);\n					int x = Math.min(-a_, a);\n					if (vv[i].a > x) {\n						vv[i].a -= x;\n						if (x == a)\n							vv[i].a = 0;\n					} else {\n						x = vv[i].a;\n						vv[i].a = 0;\n					}\n					update(vv[i].t, x);\n					a_ += x;\n					ans += (long) x * vv[i].b;\n					if (vv[i].a == 0)\n						pq_remove_first();\n				}\n			}\n			println(ans);\n		}\n	}\n}\n","data structures,greedy,sortings"
"import java.util.*;\nimport java.io.*;\n\n//textbook pitcher pouring problem\npublic class AbildekWaterSystem {\n    public static void main(String[] args) {\n        FastScanner scanner = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out, false);\n        int q = scanner.nextInt();\n        top:\n        while(q-->0) {\n            int n = scanner.nextInt();\n            int m = scanner.nextInt();\n            int c = scanner.nextInt();\n            int c0 = scanner.nextInt();\n            long ans = 0;\n            TreeMap<Integer, Integer> mapping = new TreeMap<>();\n            PriorityQueue<Friend> queue = new PriorityQueue<>();\n            for(int i = 0; i < n; i++) {\n                int t = scanner.nextInt();\n                int a = scanner.nextInt(), b = scanner.nextInt();\n                queue.offer(new Friend(t, a, b));\n            }\n            queue.offer(new Friend(m, 0,0));\n            mapping.put(0, c0);\n            int sumInside = c0;\n            int curtime = 0;\n            while(!queue.isEmpty()) {\n                Friend ff = queue.poll();\n                //fill in for previous time\n                int dist = ff.time - curtime;\n                sumInside -= dist;\n                if (sumInside < 0) {\n                    out.println(-1);\n                    continue top;\n                }\n                while(dist > 0) {\n                    Integer minkey = mapping.firstKey();\n                    int val = mapping.get(minkey);\n                    if (val > dist) {\n                        mapping.put(minkey, val - dist);\n                        ans += (long)dist * minkey;\n                        dist = 0;\n                    }\n                    else {\n                        mapping.remove(minkey);\n                        ans += (long)val * minkey;\n                        dist -= val;\n                    }\n                }\n                sumInside += ff.cap;\n                if (mapping.containsKey(ff.cost)) mapping.put(ff.cost, mapping.get(ff.cost) + ff.cap);\n                else mapping.put(ff.cost, ff.cap);\n                //remove excess\n                dist = sumInside - c;\n                if (dist > 0) sumInside = c;\n                while(dist > 0) {\n                    Integer maxkey = mapping.lastKey();\n                    int val = mapping.get(maxkey);\n                    if (val > dist) {\n                        mapping.put(maxkey, val - dist);\n                        dist = 0;\n                    }\n                    else {\n                        mapping.remove(maxkey);\n                        dist -= val;\n                    }\n                }\n                curtime = ff.time;\n            }\n            out.println(ans);\n        }\n        out.flush();\n    }\n    static class Friend implements Comparable<Friend>{\n        int time;\n        int cap;\n        int cost;\n        public Friend(int tt, int cc, int ccc) {\n            time = tt; cap = cc; cost = ccc;\n        }\n        public int compareTo(Friend o) {\n            return time - o.time;\n        }\n    }\n    static class Pair {\n        int a, b;\n        public Pair(int aa, int bb) {\n            a = aa; b = bb;\n        }\n    }\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        public FastScanner(Reader in) {\n            br = new BufferedReader(in);\n        }\n        \n        public FastScanner() {\n            this(new InputStreamReader(System.in));\n        }\n        \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        \n        String readNextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n","data structures,greedy,sortings"
"import java.io.*;\nimport java.util.*;\n\npublic class G implements Runnable {\n	public static void main (String[] args) {new Thread(null, new G(), ""_cf"", 1 << 28).start();}\n\n	public void run() {\n		FastScanner fs = new FastScanner();\n		PrintWriter out = new PrintWriter(System.out);\n		System.err.println("""");\n\n		int T = fs.nextInt();\n		tests: while(T-->0) {\n			\n			int numFriends = fs.nextInt(), totalTime = fs.nextInt();\n			int maxCap = fs.nextInt(), startCap = fs.nextInt();\n			Friend[] friends = new Friend[numFriends+1];\n			for(int i = 0; i < numFriends; i++) friends[i] = new Friend(fs.nextInt(), fs.nextInt(), fs.nextInt());\n			friends[numFriends] = new Friend(totalTime, -1, -1);\n			Arrays.sort(friends);\n			\n			TreeSet<Pair> set = new TreeSet<>();\n			set.add(new Pair(0, startCap, -1));\n			int lastTime = 0;\n			\n			long res = 0;\n			long totCount = startCap;\n			for(int i = 0; i <= numFriends; i++) {\n				long timeDiff = friends[i].time-lastTime;\n				while(timeDiff > 0) {\n					if(set.isEmpty()) {\n						out.println(-1);\n						continue tests;\n					}\n					Pair who = set.first();\n					long sub = Math.min(timeDiff, who.canTake);\n					res += sub*who.cost;\n					timeDiff -= sub;\n					totCount -= sub;\n					who.canTake -= sub;\n					if(who.canTake == 0) set.pollFirst();\n				}\n				//add him\n				set.add(new Pair(friends[i].cost, friends[i].max, i));\n				totCount += friends[i].max;\n				while(totCount > maxCap) {\n					Pair last = set.last();\n					long sub = Math.min(totCount-maxCap, last.canTake);\n					totCount -= sub;\n					last.canTake -= sub;\n					if(last.canTake == 0) {\n						set.pollLast();\n					}\n				}\n				\n				lastTime = friends[i].time;\n			}\n			\n			out.println(res);\n		}\n		\n		out.close();\n	}\n	\n	class Pair implements Comparable<Pair> {\n		long cost, canTake;\n		int id;\n		Pair(long c, long t, int i) {\n			cost = c; canTake = t;\n			id = i;\n		}\n		public int compareTo(Pair p) {\n			int c = Long.compare(cost, p.cost);\n			if(c == 0) c = Integer.compare(id, p.id);\n			return c;\n		}\n		public String toString() {\n			return String.format(""(%d, %d)"", cost, canTake);\n		}\n	}\n	\n	class Friend implements Comparable<Friend> {\n		int time;\n		long max, cost;\n		Friend(int a, int b, int c) {\n			time = a; max = b; cost = c;\n		}\n		public int compareTo(Friend f) {\n			int c = Integer.compare(time, f.time);\n			if(c == 0) c = Long.compare(cost, f.cost);\n			if(c == 0) c = Long.compare(f.max, max);\n			return c;\n		}\n	}\n\n	class FastScanner {\n		public int BS = 1<<16;\n		public char NC = (char)0;\n		byte[] buf = new byte[BS];\n		int bId = 0, size = 0;\n		char c = NC;\n		double num = 1;\n		BufferedInputStream in;\n\n		public FastScanner() {\n			in = new BufferedInputStream(System.in, BS);\n		}\n\n		public FastScanner(String s) {\n			try {\n				in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n			}\n			catch (Exception e) {\n				in = new BufferedInputStream(System.in, BS);\n			}\n		}\n\n		public char nextChar(){\n			while(bId==size) {\n				try {\n					size = in.read(buf);\n				}catch(Exception e) {\n					return NC;\n				}                \n				if(size==-1)return NC;\n				bId=0;\n			}\n			return (char)buf[bId++];\n		}\n\n		public int nextInt() {\n			return (int)nextLong();\n		}\n\n		public long nextLong() {\n			num=1;\n			boolean neg = false;\n			if(c==NC)c=nextChar();\n			for(;(c<'0' || c>'9'); c = nextChar()) {\n				if(c=='-')neg=true;\n			}\n			long res = 0;\n			for(; c>='0' && c <='9'; c=nextChar()) {\n				res = (res<<3)+(res<<1)+c-'0';\n				num*=10;\n			}\n			return neg?-res:res;\n		}\n\n		public double nextDouble() {\n			double cur = nextLong();\n			return c!='.' ? cur:cur+nextLong()/num;\n		}\n\n		public String next() {\n			StringBuilder res = new StringBuilder();\n			while(c<=32)c=nextChar();\n			while(c>32) {\n				res.append(c);\n				c=nextChar();\n			}\n			return res.toString();\n		}\n\n		public String nextLine() {\n			StringBuilder res = new StringBuilder();\n			while(c<=32)c=nextChar();\n			while(c!='\n') {\n				res.append(c);\n				c=nextChar();\n			}\n			return res.toString();\n		}\n\n		public boolean hasNext() {\n			if(c>32)return true;\n			while(true) {\n				c=nextChar();\n				if(c==NC)return false;\n				else if(c>32)return true;\n			}\n		}\n		\n		public int[] nextIntArray(int n) {\n			int[] res = new int[n];\n			for(int i = 0; i < n; i++) res[i] = nextInt();\n			return res;\n		}\n		\n	}\n\n}","data structures,greedy,sortings"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.AbstractQueue;\nimport java.io.IOException;\nimport java.util.AbstractCollection;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n * \n * @author daltao\n */\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(null, new TaskAdapter(), ""daltao"", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            PrintWriter out = new PrintWriter(outputStream);\n            TaskG solver = new TaskG();\n            int testCount = Integer.parseInt(in.next());\n            for (int i = 1; i <= testCount; i++)\n                solver.solve(i, in, out);\n            out.close();\n        }\n    }\n    static class TaskG {\n        public void solve(int testNumber, FastInput in, PrintWriter out) {\n            int n = in.readInt();\n            int m = in.readInt();\n            int c = in.readInt();\n            int c0 = in.readInt();\n\n            Event[] events = new Event[n + 1];\n            events[0] = new Event(c0, 0, 0);\n\n            for (int i = 1; i <= n; i++) {\n                int t = in.readInt();\n                int a = in.readInt();\n                int b = in.readInt();\n                events[i] = new Event(a, b, t);\n            }\n\n            Arrays.sort(events, (a, b) -> a.time - b.time);\n            PriorityQueue<Event> queue = new PriorityQueue<>(n + 1, (a, b) -> a.unitCost - b.unitCost);\n            Segment segment = new Segment(0, n);\n\n            for (int i = 0; i < n; i++) {\n                events[i].carry = events[i + 1].time - events[i].time;\n            }\n            events[n].carry = m - events[n].time;\n\n            for (int i = 0; i <= n; i++) {\n                events[i].index = i;\n            }\n\n            long cost = 0;\n            for (Event e : events) {\n                queue.add(e);\n                while (e.carry > 0 && !queue.isEmpty()) {\n                    Event top = queue.remove();\n                    int canUse = c - segment.query(top.index, e.index, 0, n);\n                    canUse = Math.min(canUse, top.in);\n                    canUse = Math.min(canUse, e.carry);\n                    if (canUse == 0) {\n                        continue;\n                    }\n                    cost += (long) canUse * top.unitCost;\n                    top.in -= canUse;\n                    e.carry -= canUse;\n                    segment.update(top.index, e.index, 0, n, canUse);\n                    if (top.in > 0) {\n                        queue.add(top);\n                    }\n                }\n                if (e.carry > 0) {\n                    out.println(-1);\n                    return;\n                }\n            }\n            out.println(cost);\n        }\n\n    }\n    static class Event {\n        int in;\n        int unitCost;\n        int time;\n        int carry;\n        int index;\n\n        public Event(int in, int unitCost, int time) {\n            this.in = in;\n            this.unitCost = unitCost;\n            this.time = time;\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n    }\n    static class Segment implements Cloneable {\n        private Segment left;\n        private Segment right;\n        private int val;\n        private int plus;\n\n        public void setPlus(int p) {\n            this.plus += p;\n            this.val += p;\n        }\n\n        public void pushUp() {\n            val = Math.max(left.val, right.val);\n        }\n\n        public void pushDown() {\n            if (plus != 0) {\n                left.setPlus(plus);\n                right.setPlus(plus);\n                plus = 0;\n            }\n        }\n\n        public Segment(int l, int r) {\n            if (l < r) {\n                int m = (l + r) >> 1;\n                left = new Segment(l, m);\n                right = new Segment(m + 1, r);\n                pushUp();\n            } else {\n\n            }\n        }\n\n        private boolean covered(int ll, int rr, int l, int r) {\n            return ll <= l && rr >= r;\n        }\n\n        private boolean noIntersection(int ll, int rr, int l, int r) {\n            return ll > r || rr < l;\n        }\n\n        public void update(int ll, int rr, int l, int r, int p) {\n            if (noIntersection(ll, rr, l, r)) {\n                return;\n            }\n            if (covered(ll, rr, l, r)) {\n                setPlus(p);\n                return;\n            }\n            pushDown();\n            int m = (l + r) >> 1;\n            left.update(ll, rr, l, m, p);\n            right.update(ll, rr, m + 1, r, p);\n            pushUp();\n        }\n\n        public int query(int ll, int rr, int l, int r) {\n            if (noIntersection(ll, rr, l, r)) {\n                return 0;\n            }\n            if (covered(ll, rr, l, r)) {\n                return val;\n            }\n            pushDown();\n            int m = (l + r) >> 1;\n            return Math.max(left.query(ll, rr, l, m), right.query(ll, rr, m + 1, r));\n        }\n\n    }\n}\n\n","data structures,greedy,sortings"
"import java.awt.*;\nimport java.io.*;\nimport java.sql.Array;\nimport java.util.*;\nimport java.util.List;\n\npublic class Main {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(\n                    new InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() { return Integer.parseInt(next()); }\n\n        long nextLong() { return Long.parseLong(next()); }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = """";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    static final int N=300005;\n    static final int mod=1000000007;\n    static final int INF=1000000009;\n    static final int numBit=17;\n    static FastReader r=new FastReader();\n    static PrintWriter pw = new PrintWriter(System.out);\n\n    static List<Integer> v[];\n    static int[] val=new int[N];\n    static int ans;\n\n    public static void dfs(int u,int par){\n        List<Integer> tmp=new ArrayList<>();\n        for(int x:v[u]){\n            if(x==par) continue;\n            dfs(x,u);\n            tmp.add(val[x]);\n        }\n        Collections.sort(tmp, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                if(o1>o2) return -1;\n                else if(o1==o2) return 0;\n                return 1;\n            }\n        });\n//        System.out.println(tmp);\n        ans=Math.max(ans,v[u].size()+1);\n        if(tmp.size()>1){\n            ans=Math.max(ans,tmp.get(0)+tmp.get(1)+v[u].size()-2+1);\n        }\n        if(tmp.size()>0){\n            ans=Math.max(ans,tmp.get(0)+v[u].size()-1+1);\n            val[u]=tmp.get(0)+v[u].size()-2+1;\n        }\n        else{\n            val[u]=1;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        v=new List[N];\n        for(int i=0;i<N;++i) v[i]=new ArrayList<>();\n        int q=r.nextInt();\n        while(q-->0){\n            int n=r.nextInt();\n            for(int i=0;i<n;++i){\n                v[i].clear();\n            }\n            for(int i=0;i<n-1;++i){\n                int x=r.nextInt();\n                int y=r.nextInt();\n                --x;\n                --y;\n                v[x].add(y);\n                v[y].add(x);\n            }\n            ans=0;\n            dfs(0,-1);\n            pw.println(ans);\n        }\n        pw.close();\n    }\n}\n","dfs and similar,dp,graphs,trees"
"import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1238f_2 {\n\n    public static void main(String[] args) throws IOException {\n        int q = ri();\n        while (q --> 0) {\n            int n = ri(), dp[][] = new int[n][2];\n            List<List<Integer>> g = rg(n, n - 1);\n            if (n == 2) {\n                prln(2);\n                continue;\n            }\n            int root = 0;\n            for (int i = 0; i < n; ++i) {\n                if (g.get(i).size() > 1) {\n                    root = i;\n                    break;\n                }\n            }\n            dfs(g, root, -1, dp);\n            prln(dp[root][0]);\n        }\n        close();\n    }\n\n    static void dfs(List<List<Integer>> g, int i, int p, int[][] dp) {\n        int max1 = 0, max2 = 0;\n        for (int j : g.get(i)) {\n            if (j != p) {\n                dfs(g, j, i, dp);\n                dp[i][0] = max(dp[i][0], dp[j][0]);\n                if (dp[j][1] >= max1) {\n                    max2 = max1;\n                    max1 = dp[j][1];\n                } else if (dp[j][1] > max2) {\n                    max2 = dp[j][1];\n                }\n            }\n        }\n        dp[i][0] = max(dp[i][0], max1 + max2 + 1 + g.get(i).size());\n        dp[i][1] = g.get(i).size() - 1 + max1;\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int lcm(int a, int b) {return a * b / gcf(a, b);}\n    static long lcm(long a, long b) {return a * b / gcf(a, b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // graph util\n    static List<List<Integer>> g(int n) {List<List<Integer>> g = new ArrayList<>(); for (int i = 0; i < n; ++i) g.add(new ArrayList<>()); return g;}\n    static List<Set<Integer>> sg(int n) {List<Set<Integer>> g = new ArrayList<>(); for (int i = 0; i < n; ++i) g.add(new HashSet<>()); return g;}\n    static void c(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).add(v); g.get(v).add(u);}\n    static void cto(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).add(v);}\n    static void dc(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).remove(v); g.get(v).remove(u);}\n    static void dcto(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).remove(v);}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    static List<List<Integer>> rg(int n, int m) throws IOException {List<List<Integer>> g = g(n); for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1); return g;}\n    static void rg(List<List<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1);}\n    static List<List<Integer>> rdg(int n, int m) throws IOException {List<List<Integer>> g = g(n); for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1); return g;}\n    static void rdg(List<List<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1);}\n    static List<Set<Integer>> rsg(int n, int m) throws IOException {List<Set<Integer>> g = sg(n); for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1); return g;}\n    static void rsg(List<Set<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1);}\n    static List<Set<Integer>> rdsg(int n, int m) throws IOException {List<Set<Integer>> g = sg(n); for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1); return g;}\n    static void rdsg(List<Set<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1);}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {prln(""yes"");}\n    static void pry() {prln(""Yes"");}\n    static void prY() {prln(""YES"");}\n    static void prno() {prln(""no"");}\n    static void prn() {prln(""No"");}\n    static void prN() {prln(""NO"");}\n    static void pryesno(boolean b) {prln(b ? ""yes"" : ""no"");};\n    static void pryn(boolean b) {prln(b ? ""Yes"" : ""No"");}\n    static void prYN(boolean b) {prln(b ? ""YES"" : ""NO"");}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(""hlfd""); flush();}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}}","dfs and similar,dp,graphs,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1238F extends PrintWriter {\n	CF1238F() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1238F o = new CF1238F(); o.main(); o.flush();\n	}\n\n	int[] ll, jj; int $;\n	int link(int l, int j) {\n		ll[$] = l; jj[$] = j;\n		return $++;\n	}\n	int[] ae, dd;\n	void init(int n, int m) {\n		ll = new int[1 + m * 2]; jj = new int[1 + m * 2];\n		ae = new int[n];\n		dd = new int[n]; Arrays.fill(dd, -1);\n		$ = 1;\n	}\n	int d_, i_;\n	void dfs(int p, int i, int d) {\n		d += dd[i];\n		if (d_ < d) {\n			d_ = d; i_ = i;\n		}\n		for (int l = ae[i]; l != 0; l = ll[l]) {\n			int j = jj[l];\n			if (j != p)\n				dfs(i, j, d);\n		}\n	}\n	void main() {\n		int q = sc.nextInt();\n		while (q-- > 0) {\n			int n = sc.nextInt();\n			init(n, n - 1);\n			for (int h = 0; h < n - 1; h++) {\n				int i = sc.nextInt() - 1;\n				int j = sc.nextInt() - 1;\n				ae[i] = link(ae[i], j); dd[i]++;\n				ae[j] = link(ae[j], i); dd[j]++;\n			}\n			d_ = -1;\n			dfs(-1, 0, 0);\n			dfs(-1, i_, 0);\n			println(d_ + 2);\n		}\n	}\n}\n","dfs and similar,dp,graphs,trees"
"/*\n ID: tommatt1\n LANG: JAVA\n TASK: \n*/\nimport java.util.*;\nimport java.io.*;\npublic class CF1238F{\nstatic ArrayList<Integer>[] adj;\nstatic int ans;\nstatic int[] dp;\nstatic int[] d;\n	public static void main(String[] args)throws IOException {\n		BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		StringTokenizer st=new StringTokenizer(bf.readLine());\n		int q=Integer.parseInt(st.nextToken());\n		for(;q>0;q--) {\n			st=new StringTokenizer(bf.readLine());\n			int n=Integer.parseInt(st.nextToken());\n			ans=0;\n			adj=new ArrayList[n];\n			dp=new int[n];\n			d=new int[n];\n			for(int i=0;i<n;i++) {\n				adj[i]=new ArrayList<Integer>();\n			}\n			for(int i=0;i<n-1;i++) {\n				st=new StringTokenizer(bf.readLine());\n				int a=Integer.parseInt(st.nextToken())-1;\n				int b=Integer.parseInt(st.nextToken())-1;\n				adj[a].add(b);\n				adj[b].add(a);\n				d[a]++;d[b]++;\n			}\n			dfs(0,-1);\n			out.println(ans);\n		}\n		out.close();\n	}\n	static void dfs(int v, int p) {\n		dp[v]=d[v]+1;\n		for(int e:adj[v]) {\n			if(e==p) {\n				continue;\n			}\n			dfs(e,v);\n			ans=Math.max(ans, dp[e]+dp[v]-2);\n			dp[v]=Math.max(dp[v],dp[e]+d[v]-1);\n		}\n	}\n}\n\n\n","dfs and similar,dp,graphs,trees"
"import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\n// editorial sol, combinatorics on empty rows / cols\n\npublic class cf1237f_2 {\n\n    public static void main(String[] args) throws IOException {\n        int h = rni(), w = ni(), n = ni(), row[] = new int[h + 1], col[] = new int[w + 1];\n        int empty_rows = h, empty_cols = w;\n        for (int i = 0; i < n; ++i) {\n            int r1 = rni(), c1 = ni(), r2 = ni(), c2 = ni();\n            row[r1] = row[r2] = col[c1] = col[c2] = 1;\n        }\n        for (int i = 1; i <= h; ++i) {\n            empty_rows -= row[i];\n        }\n        for (int i = 1; i <= w; ++i) {\n            empty_cols -= col[i];\n        }\n        int dp_row[][] = new int[h + 1][w + 1], dp_col[][] = new int[w + 1][h + 1];\n        dp_row[0][0] = dp_col[0][0] = 1;\n        for (int i = 1; i <= h; ++i) {\n            for (int j = 0; j <= w; ++j) {\n                dp_row[i][j] = dp_row[i - 1][j];\n                if (j > 0 && i > 1 && row[i] == 0 && row[i - 1] == 0) {\n                    dp_row[i][j] = madd(dp_row[i][j], dp_row[i - 2][j - 1]);\n                }\n            }\n        }\n        for (int i = 1; i <= w; ++i) {\n            for (int j = 0; j <= h; ++j) {\n                dp_col[i][j] = dp_col[i - 1][j];\n                if (j > 0 && i > 1 && col[i] == 0 && col[i - 1] == 0) {\n                    dp_col[i][j] = madd(dp_col[i][j], dp_col[i - 2][j - 1]);\n                }\n            }\n        }\n        int max = max(h, w), combination[][] = new int[max + 1][max + 1], fact[] = new int[max + 1];\n        combination[0][0] = fact[0] = 1;\n        for (int i = 1; i <= max; ++i) {\n            fact[i] = mmul(i, fact[i - 1]);\n            combination[i][0] = combination[i][i] = 1;\n            for (int j = 1; j < i; ++j) {\n                combination[i][j] = madd(combination[i - 1][j - 1], combination[i - 1][j]);\n            }\n        }\n        int ans = 0;\n        for (int d_h = 0; 2 * d_h <= empty_cols && d_h <= empty_rows; ++d_h) {\n            for (int d_v = 0; 2 * d_v <= empty_rows && d_v <= empty_cols; ++d_v) {\n                int free_row = empty_rows - 2 * d_v;\n                int free_col = empty_cols - 2 * d_h;\n                ans = madd(ans, mmul(dp_row[h][d_v], combination[free_row][d_h], dp_col[w][d_h], combination[free_col][d_v], fact[d_h], fact[d_v]));\n            }\n        }\n        prln(ans);\n        close();\n    }\n\n    static int mmod = 998244353;\n\n    static int madd(int a, int b) {\n        return (a + b) % mmod;\n    }\n\n    static int madd(int... a) {\n        int ans = a[0];\n        for (int i = 1; i < a.length; ++i) {\n            ans = madd(ans, a[i]);\n        }\n        return ans;\n    }\n\n    static int msub(int a, int b) {\n        return (a - b + mmod) % mmod;\n    }\n\n    static int mmul(int a, int b) {\n        return (int) ((long) a * b % mmod);\n    }\n\n    static int mmul(int... a) {\n        int ans = a[0];\n        for (int i = 1; i < a.length; ++i) {\n            ans = mmul(ans, a[i]);\n        }\n        return ans;\n    }\n\n    static int minv(int x) {\n        return mpow(x, mmod - 2);\n    }\n\n    static int mpow(int a, int b) {\n        if (a == 0) {\n            return 0;\n        }\n        int ans = 1;\n        while (b > 0) {\n            if ((b & 1) > 0) {\n                ans = mmul(ans, a);\n            }\n            a = mmul(a, a);\n            b >>= 1;\n        }\n        return ans;\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int lcm(int a, int b) {return a * b / gcf(a, b);}\n    static long lcm(long a, long b) {return a * b / gcf(a, b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // graph util\n    static List<List<Integer>> g(int n) {List<List<Integer>> g = new ArrayList<>(); for (int i = 0; i < n; ++i) g.add(new ArrayList<>()); return g;}\n    static List<Set<Integer>> sg(int n) {List<Set<Integer>> g = new ArrayList<>(); for (int i = 0; i < n; ++i) g.add(new HashSet<>()); return g;}\n    static void c(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).add(v); g.get(v).add(u);}\n    static void cto(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).add(v);}\n    static void dc(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).remove(v); g.get(v).remove(u);}\n    static void dcto(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).remove(v);}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    static List<List<Integer>> rg(int n, int m) throws IOException {List<List<Integer>> g = g(n); for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1); return g;}\n    static void rg(List<List<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1);}\n    static List<List<Integer>> rdg(int n, int m) throws IOException {List<List<Integer>> g = g(n); for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1); return g;}\n    static void rdg(List<List<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1);}\n    static List<Set<Integer>> rsg(int n, int m) throws IOException {List<Set<Integer>> g = sg(n); for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1); return g;}\n    static void rsg(List<Set<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1);}\n    static List<Set<Integer>> rdsg(int n, int m) throws IOException {List<Set<Integer>> g = sg(n); for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1); return g;}\n    static void rdsg(List<Set<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1);}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {prln(""yes"");}\n    static void pry() {prln(""Yes"");}\n    static void prY() {prln(""YES"");}\n    static void prno() {prln(""no"");}\n    static void prn() {prln(""No"");}\n    static void prN() {prln(""NO"");}\n    static void pryesno(boolean b) {prln(b ? ""yes"" : ""no"");};\n    static void pryn(boolean b) {prln(b ? ""Yes"" : ""No"");}\n    static void prYN(boolean b) {prln(b ? ""YES"" : ""NO"");}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(""hlfd""); flush();}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}}","combinatorics,dp"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1237F extends PrintWriter {\n	CF1237F() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1237F o = new CF1237F(); o.main(); o.flush();\n	}\n\n	static final int MD = 998244353;\n	int[] solve(boolean[] aa, int n, int k) {\n		int[] dp1 = new int[k + 1];\n		int[] dp2 = new int[k + 1];\n		int[] dp = new int[k + 1];\n		dp2[0] = dp1[0] = 1;\n		for (int i = 1; i < n; i++) {\n			dp[0] = 1;\n			for (int j = 1; j <= k; j++)\n				dp[j] = !aa[i - 1] && !aa[i] ? (dp2[j - 1] + dp1[j]) % MD : dp1[j];\n			int[] tmp = dp2; dp2 = dp1; dp1 = dp; dp = tmp;\n		}\n		return dp1;\n	}\n	int d_, x_, y_;\n	void gcd_(int a, int b) {\n		if (b == 0) {\n			d_ = a;\n			x_ = 1; y_ = 0;\n		} else {\n			gcd_(b, a % b);\n			int t = x_ - a / b * y_; x_ = y_; y_ = t;\n		}\n	}\n	int inv(int a) {\n		gcd_(a, MD);\n		return x_;\n	}\n	int[] ff, gg;\n	void init(int n) {\n		ff = new int[n + 1];\n		gg = new int[n + 1];\n		long f = 1;\n		for (int i = 0; i <= n; i++) {\n			gg[i] = inv(ff[i] = (int) f);\n			f = f * (i + 1) % MD;\n		}\n	}\n	long ch(int n, int k) {\n		return (long) ff[n] * gg[k] % MD * gg[n - k] % MD;\n	}\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		int k = sc.nextInt();\n		boolean[] aa = new boolean[n];\n		boolean[] bb = new boolean[m];\n		while (k-- > 0) {\n			int i1 = sc.nextInt() - 1;\n			int j1 = sc.nextInt() - 1;\n			int i2 = sc.nextInt() - 1;\n			int j2 = sc.nextInt() - 1;\n			aa[i1] = aa[i2] = true;\n			bb[j1] = bb[j2] = true;\n		}\n		int n_ = n;\n		for (int i = 0; i < n; i++)\n			if (aa[i])\n				n_--;\n		int m_ = m;\n		for (int j = 0; j < m; j++)\n			if (bb[j])\n				m_--;\n		int[] da = solve(aa, n, n_ / 2);\n		int[] db = solve(bb, m, m_ / 2);\n		init(Math.max(n_, m_));\n		long ans = 0;\n		for (int k2 = 0; k2 * 2 <= n_; k2++) {\n			int x = da[k2];\n			if (x == 0)\n				continue;\n			for (int k1 = 0; k1 * 2 + k2 <= m_ && k2 * 2 + k1 <= n_; k1++) {\n				int y = db[k1];\n				if (y == 0)\n					continue;\n				long cnt = (long) x * y % MD * ch(n_ - k2 * 2, k1) % MD * ch(m_ - k1 * 2, k2) % MD * ff[k2] % MD * ff[k1] % MD;\n				ans += cnt;\n			}\n		}\n		ans %= MD;\n		if (ans < 0)\n			ans += MD;\n		println(ans);\n	}\n}\n","combinatorics,dp"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        FSbalansirovannieRaspolozheniyaDomino solver = new FSbalansirovannieRaspolozheniyaDomino();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FSbalansirovannieRaspolozheniyaDomino {\n        int MOD = 998244353;\n        int[][] place2;\n\n        int[] calc2(boolean[] u) {\n            int n = u.length;\n            int[] res = new int[n / 2 + 1];\n            res[0] = 1;\n            int s = 0;\n            int f;\n            while (s < u.length) {\n                while (s < u.length && u[s]) {\n                    s++;\n                }\n                if (s == u.length) {\n                    break;\n                }\n                f = s + 1;\n                while (f < u.length && !u[f]) {\n                    f++;\n                }\n\n                int seg = f - s;\n                for (int i = n / 2; i >= 0; i--) {\n                    for (int j = 1; j * 2 <= seg && j <= i; j++) {\n                        res[i] = (int) ((res[i] + ((long) res[i - j]) * place2[seg][j]) % MOD);\n                    }\n                }\n\n                s = f;\n            }\n\n            return res;\n        }\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int h = in.nextInt();\n            int w = in.nextInt();\n            boolean[] usedr = new boolean[h];\n            boolean[] usedc = new boolean[w];\n            int n = in.nextInt();\n            for (int i = 0; i < n; i++) {\n                int x = in.nextInt() - 1;\n                usedr[x] = true;\n                x = in.nextInt() - 1;\n                usedc[x] = true;\n                x = in.nextInt() - 1;\n                usedr[x] = true;\n                x = in.nextInt() - 1;\n                usedc[x] = true;\n            }\n\n            int fr = 0;\n            for (int i = 0; i < h; i++) {\n                if (!usedr[i]) {\n                    fr++;\n                }\n            }\n            int fc = 0;\n            for (int i = 0; i < w; i++) {\n                if (!usedc[i]) {\n                    fc++;\n                }\n            }\n\n            int sz = Math.max(h, w);\n            place2 = new int[sz + 1][sz / 2 + 1];\n            place2[0][0] = place2[1][0] = 1;\n            for (int i = 2; i <= sz; i++) {\n                place2[i][0] = 1;\n                for (int j = 1; 2 * j <= sz; j++) {\n                    place2[i][j] = (place2[i - 1][j] + place2[i - 2][j - 1]) % MOD;\n                }\n            }\n\n            int[][] ch = new int[sz + 1][sz + 1];\n            ch[0][0] = 1;\n            for (int i = 1; i <= sz; i++) {\n                ch[i][0] = 1;\n                for (int j = 1; j <= sz; j++) {\n                    ch[i][j] = (ch[i - 1][j - 1] + ch[i - 1][j]) % MOD;\n                }\n            }\n\n            int[] h2 = calc2(usedr);\n            int[] v2 = calc2(usedc);\n\n            int[] fac = new int[sz + 1];\n            fac[0] = 1;\n            for (int i = 1; i <= sz; i++) {\n                fac[i] = (int) (((long) fac[i - 1]) * i % MOD);\n            }\n\n            long ans = 0;\n            for (int ha = 0; 2 * ha <= fc; ha++) {\n                for (int va = 0; 2 * va + ha <= fr && va + 2 * ha <= fc; va++) {\n                    long num = ((long) h2[va]) * ch[fc - 2 * ha][va] % MOD * v2[ha] % MOD * ch[fr - 2 * va][ha] % MOD * fac[va] % MOD * fac[ha] % MOD;\n                    ans = (ans + num) % MOD;\n                }\n            }\n\n            out.println(ans);\n        }\n\n    }\n}\n\n","combinatorics,dp"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        static final long MODULO = 998244353;\n        static long[] invs;\n        static long[] facts;\n        static long[] invfacts;\n\n        static {\n            int k = (int) 5000;\n            invs = new long[k + 2];\n            invs[1] = 1;\n            for (int i = 2; i <= k + 1; ++i) {\n                invs[i] = ((MODULO - (MODULO / i) * (long) invs[(int) (MODULO % i)] % MODULO) % MODULO);\n            }\n            facts = new long[k + 2];\n            invfacts = new long[k + 2];\n            facts[0] = 1;\n            invfacts[0] = 1;\n            for (int i = 1; i <= k + 1; ++i) {\n                facts[i] = (facts[i - 1] * (long) i % MODULO);\n                invfacts[i] = (invfacts[i - 1] * (long) invs[i] % MODULO);\n            }\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int h = in.nextInt();\n            int w = in.nextInt();\n            int n = in.nextInt();\n            boolean[] rowTaken = new boolean[h];\n            boolean[] colTaken = new boolean[w];\n            for (int i = 0; i < 2 * n; ++i) {\n                rowTaken[in.nextInt() - 1] = true;\n                colTaken[in.nextInt() - 1] = true;\n            }\n            int rowFree = 0;\n            for (boolean x : rowTaken) if (!x) ++rowFree;\n            int colFree = 0;\n            for (boolean x : colTaken) if (!x) ++colFree;\n            int[] rowWays = findWays(rowTaken);\n            int[] colWays = findWays(colTaken);\n            long res = 0;\n            for (int nr = 0; nr < rowWays.length; ++nr)\n                if (rowWays[nr] > 0) {\n                    for (int nc = 0; nc < colWays.length && nr + 2 * nc <= colFree && nc + 2 * nr <= rowFree; ++nc)\n                        if (colWays[nc] > 0) {\n                            res += rowWays[nr] * (long) colWays[nc] % MODULO * facts[rowFree - 2 * nr] % MODULO * invfacts[rowFree - 2 * nr - nc] % MODULO\n                                    * facts[colFree - 2 * nc] % MODULO * invfacts[colFree - 2 * nc - nr];\n                            res %= MODULO;\n                        }\n                }\n            out.println(res);\n        }\n\n        private int[] findWays(boolean[] rowTaken) {\n            int[][] ways = new int[3][rowTaken.length / 2 + 1];\n            ways[2][0] = 1;\n            int cur = -1;\n            for (int i = 0; i < rowTaken.length; ++i) {\n                cur = i % 3;\n                int prev = (i + 2) % 3;\n                int pprev = (i + 1) % 3;\n                Arrays.fill(ways[cur], 0);\n                for (int j = 0; j < ways[cur].length; ++j) {\n                    if (ways[prev][j] > 0) {\n                        ways[cur][j] += ways[prev][j];\n                    }\n                    if (ways[pprev][j] > 0 && !rowTaken[i] && !rowTaken[i - 1]) {\n                        ways[cur][j + 1] += ways[pprev][j];\n                    }\n                    if (ways[cur][j] >= MODULO) ways[cur][j] -= MODULO;\n                }\n            }\n            return ways[cur];\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n","combinatorics,dp"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Kraken7\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    Scanner in = new Scanner(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskC2 solver = new TaskC2();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskC2 {\n\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n      int n = in.nextInt();\n      int[][] p = new int[n][4];\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 3; j++) {\n          p[i][j] = in.nextInt();\n        }\n        p[i][3] = i + 1;\n      }\n      Arrays.sort(p, (o1, o2) -> {\n        for (int i = 0; i < 3; i++) {\n          if (o1[i] != o2[i])\n            return o1[i] - o2[i];\n        }\n        return 0;\n      });\n      //    for (int[] i : p) out.println(Arrays.toString(i));\n      boolean[] fine = new boolean[n];\n      Arrays.fill(fine, true);\n      for (int i = 0; i < n; i++) {\n        if (fine[i]) {\n          int j = i + 1;\n          while (!fine[j])\n            j++;\n          int xis = 0;\n          while (p[i][xis] == p[j][xis])\n            xis++;\n          int k = j;\n          while (k < n && p[k][xis] == p[j][xis])\n            k++;\n          int bs = Integer.MAX_VALUE;\n          int bi = -1;\n          for (int x = j; x < k; x++) {\n            if (fine[x]) {\n              int s = 0;\n              for (int u = 0; u < 3; u++)\n                s += Math.abs(p[i][u] - p[x][u]);\n              if (s < bs) {\n                bs = s;\n                bi = x;\n              }\n            }\n          }\n          fine[i] = false;\n          fine[bi] = false;\n          out.printf(""%d %d\n"", p[i][3], p[bi][3]);\n        }\n      }\n    }\n\n  }\n}\n\n","binary search,constructive algorithms,divide and conquer,greedy,implementation,sortings"
"import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class C{\n	\n	static class Point implements Comparable<Point>{\n		int x, y, z, i;\n		public Point(int a, int b, int c, int d) {\n			x=a;\n			y=b;\n			z=c;\n			i=d;\n		}\n		public int compareTo(Point o) {\n			if (x==o.x) {\n				if (y==o.y) {\n					return z-o.z;\n				}\n				return y-o.y;\n			}\n			return x -o.x;\n		}\n	}\n	\n	public static void main(String[] args) throws IOException {\n		// br = new BufferedReader(new FileReader("".in""));\n		// out = new PrintWriter(new FileWriter("".out""));\n		//new Thread(null, new (), ""peepee"", 1<<28).start();\n		int n=readInt();\n		ArrayList<Point> p = new ArrayList<Point>();\n		for (int i = 0; i < n; i++) {\n			p.add(new Point(readInt(),readInt(),readInt(),i+1));\n		}\n		Collections.sort(p);\n		ArrayList<Point> temp = new ArrayList<Point>();\n		//System.out.println(p.size());\n		for (int i = 0; i < p.size(); i++) {\n			if (i != p.size()-1 && p.get(i).x == p.get(i+1).x && p.get(i).y == p.get(i+1).y) {\n				out.println(p.get(i).i + "" "" + p.get(i+1).i);\n				i++;\n			}\n			else {\n				temp.add(p.get(i));\n			}\n		}\n		p.clear();\n		//System.out.println(temp.size() + "" | "" + p.size());\n		for (Point po: temp) p.add(po);\n		temp.clear();\n		for (int i = 0; i < p.size(); i++) {\n			if (i != p.size()-1 && p.get(i).x == p.get(i+1).x) {\n				out.println(p.get(i).i + "" "" + p.get(i+1).i);\n				i++;\n			}\n			else temp.add(p.get(i));\n		}\n		\n		p.clear();\n		for (Point po: temp) p.add(po);\n		for (int i = 0; i < p.size()-1; i+=2) {\n			out.println(p.get(i).i + "" "" + p.get(i+1).i);\n		}\n		\n		out.close();\n	}\n	\n	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n	static StringTokenizer st = new StringTokenizer("""");\n	static String read() throws IOException{return st.hasMoreTokens() ? st.nextToken():(st = new StringTokenizer(br.readLine())).nextToken();}\n	static int readInt() throws IOException{return Integer.parseInt(read());}\n	static long readLong() throws IOException{return Long.parseLong(read());}\n	static double readDouble() throws IOException{return Double.parseDouble(read());}\n}","binary search,constructive algorithms,divide and conquer,greedy,implementation,sortings"
"import java.io.*;\nimport java.util.*;\n\n/**\n * Problem Cf1237C\n */\npublic class Cf1237C {\n\n    int n,D = 3;\n    int[][] p;\n\n    public void run() {\n        n = in.nextInt();\n        p = new int[n][D];\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < D; ++j){\n                p[i][j]=in.nextInt();\n            }\n        }\n        List<Integer> ids = new ArrayList<>();\n        for(int i = 0; i < n; ++i)\n            ids.add(i);\n        solve(ids,0);\n    }\n\n    int solve(List<Integer> ids, int d){\n        if(d==D){\n            return ids.get(0);\n        }\n        Map<Integer, List<Integer>> map = new TreeMap<>();\n        for(Integer id : ids) {\n            map.computeIfAbsent(p[id][d], key -> new ArrayList<>()).add(id);\n        }\n        List<Integer> a = new ArrayList<>();\n        for(List<Integer> list : map.values()){\n            int ret = solve(list, d+1);\n            if(ret!=-1){\n                a.add(ret);\n            }\n        }\n        for(int i = 0; i+1 < a.size(); i+=2){\n            out.println((a.get(i)+1) + "" "" + (a.get(i+1)+1));\n        }\n        return a.size() % 2 == 0 ? -1 : a.get(a.size() - 1);\n    }\n\n\n\n\n    /***********************************************************\n     *                      BOILERPLATE                        *\n    /***********************************************************/\n    public InputReader in = new InputReader(System.in);\n    public PrintWriter out = new PrintWriter(System.out);\n    public void close() {out.close();}\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokens = null;\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);}\n        private boolean prime() {\n            while (tokens == null || !tokens.hasMoreTokens()) {\n                try {\n                    String line = reader.readLine();\n                    if(line==null) return false; // EOF\n                    tokens = new StringTokenizer(line);\n                } catch (IOException e) {throw new RuntimeException(e);}\n            } return true;}\n        public boolean hasNext() {return prime();}\n        public String next() {prime(); return tokens.nextToken();}\n        public int nextInt() {return Integer.parseInt(next());}\n        public long nextLong() {return Long.parseLong(next());}\n        public double nextDouble() {return Double.parseDouble(next());}\n    }\n    public static void main(String[] args) {\n        Cf1237C task = new Cf1237C(); task.run(); task.close();}\n}\n","binary search,constructive algorithms,divide and conquer,greedy,implementation,sortings"
"import java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    static class Point {\n        int x;\n        int y;\n        int z;\n        int index;\n\n        public Point(int x, int y, int z, int index) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.index = index;\n        }\n    }\n\n    static StringBuilder sb = new StringBuilder();\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        List<Point> points = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            points.add(new Point(sc.nextInt(), sc.nextInt(), sc.nextInt(), i + 1));\n        }\n\n        Map<Integer, List<Point>> groupByZ = points.stream()\n                .collect(Collectors.groupingBy(a -> a.z));\n        List<Point> leftOvers = new ArrayList<>();\n        for (Map.Entry<Integer, List<Point>> e : groupByZ.entrySet()) {\n            solve2d(e.getValue()).ifPresent(leftOvers::add);\n        }\n        leftOvers.sort(Comparator.comparingInt(o -> o.z));\n        printPoints(leftOvers);\n\n        System.out.println(sb);\n    }\n\n    static Optional<Point> solve2d(List<Point> points) {\n        Map<Integer, List<Point>> groupByY = points.stream()\n                .collect(Collectors.groupingBy(a -> a.y));\n        List<Point> leftOvers = new ArrayList<>();\n        for (Map.Entry<Integer, List<Point>> e : groupByY.entrySet()) {\n            solve1d(e.getValue()).ifPresent(leftOvers::add);\n        }\n        leftOvers.sort(Comparator.comparingInt(o -> o.y));\n        printPoints(leftOvers);\n        if (leftOvers.size() % 2 == 0) {\n            return Optional.empty();\n        } else {\n            return Optional.of(leftOvers.get(leftOvers.size() - 1));\n        }\n    }\n\n    static Optional<Point> solve1d(List<Point> points) {\n        points.sort(Comparator.comparingInt(o -> o.x));\n        printPoints(points);\n        if (points.size() % 2 == 0) {\n            return Optional.empty();\n        } else {\n            return Optional.of(points.get(points.size() - 1));\n        }\n    }\n\n    private static void printPoints(List<Point> points) {\n        for (int i = 0; i < points.size() - 1; i += 2) {\n            sb.append(points.get(i).index).append(' ').append(points.get(i + 1).index).append('\n');\n        }\n    }\n\n    static boolean isInside(Point a, Point b, Point c) {\n        return Math.min(a.x, b.x) <= c.x && c.x <= Math.max(a.x, b.x)\n                && Math.min(a.y, b.y) <= c.y && c.y <= Math.max(a.y, b.y)\n                && Math.min(a.z, b.z) <= c.z && c.z <= Math.max(a.z, b.z);\n    }\n}\n","binary search,constructive algorithms,divide and conquer,greedy,implementation,sortings"
"\nimport java.util.Scanner;\n\npublic class Main{\n\n	public static void main(String[] args) \n	{\n		Scanner scan = new Scanner(System.in);\n		int n = scan.nextInt();\n		int m[][] = new int[n][n],k=1;\n		for(int i=0;i<n;i++)\n		{\n			for(int j=0;j<n;j++)\n			{\n				if(i%2==0)m[n-j-1][i] = k;\n				else m[j][i] = k;\n				k++;\n			}\n		}\n		for(int i=0;i<n;i++)\n		{\n			for(int j=0;j<n;j++)System.out.print(m[i][j]+"" "");\n			System.out.println();\n		}\n	}\n\n}\n","constructive algorithms,greedy,implementation"
"\nimport java.util.Scanner;\n\npublic class Main{\n\n	public static void main(String[] args) \n	{\n		Scanner scan = new Scanner(System.in);\n		int n = scan.nextInt();\n		int m[][] = new int[n][n],k=1;\n		for(int i=0;i<n;i++)\n		{\n			for(int j=0;j<n;j++)\n			{\n				if(i%2==0)m[n-j-1][i] = k;\n				else m[j][i] = k;\n				k++;\n			}\n		}\n		for(int i=0;i<n;i++)\n		{\n			for(int j=0;j<n;j++)System.out.print(m[i][j]+"" "");\n			System.out.println();\n		}\n	}\n\n}\n","constructive algorithms,greedy,implementation"
"import java.io.*;\nimport java.util.*;\npublic class Efforder\n{\n	public static void main(String args[])\n	{\n		Scanner in = new Scanner(System.in);\n		int n = in.nextInt();\n		/*int b = in.nextInt();\n		long con = 998244353;\n		long ar = h*b;\n		long comb = 4*(long)Math.pow(2,b-1)*(long)Math.pow(2,h-1);\n		System.out.println(comb%con);*/\n		for(int i=1;i<=n;i++)\n		{	\n			System.out.print(i+"" "");\n			for(int j=2;j<=n;j++)\n			{\n				int c =j%2==0?( j*n-(i-1)):((j-1)*n+i);\n				System.out.print(c+"" "");\n			}\n			System.out.println();\n		}\n	}\n}","constructive algorithms,greedy,implementation"
"import java.util.*;\n\npublic class Labs {\n\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		int n = s.nextInt();\n		int a = 1;\n		int[][] ans = new int[n][n];\n		for (int j = 0; j < n; j++) {\n			if (j % 2 == 0) {\n				for (int i = 0; i < n; i++) {\n					ans[i][j] = a++;\n				}\n			} else {\n				for (int i = n - 1; i >= 0; i--) {\n					ans[i][j] = a++;\n				}\n			}\n		}\n		\n		for(int i=0;i<n;i++) {\n			for(int j=0;j<n;j++) {\n				System.out.print(ans[i][j]+"" "");\n			}\n			System.out.println();\n		}\n	}\n	\n\n}\n","constructive algorithms,greedy,implementation"
"import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class D {\n	FastScanner in;\n	PrintWriter out;\n	boolean systemIO = true;\n\n	int mod = 998244353;\n\n	public int sum(int x, int y) {\n		if (x + y >= mod) {\n			return x + y - mod;\n		}\n		return x + y;\n	}\n\n	public int diff(int x, int y) {\n		if (x >= y) {\n			return x - y;\n		}\n		return x - y + mod;\n	}\n\n	public int mult(int x, int y) {\n		return (int) (x * 1L * y % mod);\n	}\n\n	public int pow(int x, long p) {\n		int ans = 1;\n		while (p > 0) {\n			if ((p & 1) == 1) {\n				ans = mult(ans, x);\n			}\n			x = mult(x, x);\n			p >>= 1;\n		}\n		return ans;\n	}\n\n	public int inv(int x) {\n		return pow(x, mod - 2);\n	}\n\n	public int div(int x, int y) {\n		return mult(x, inv(y));\n	}\n	\n	public class DSU {\n		int[] sz;\n		int[] p;\n\n		public DSU(int n) {\n			sz = new int[n];\n			p = new int[n];\n			for (int i = 0; i < p.length; i++) {\n				p[i] = i;\n				sz[i] = 1;\n			}\n		}\n\n		public int get(int x) {\n			if (x == p[x]) {\n				return x;\n			}\n			int par = get(p[x]);\n			p[x] = par;\n			return par;\n		}\n\n		public boolean unite(int a, int b) {\n			int pa = get(a);\n			int pb = get(b);\n			if (pa == pb) {\n				return false;\n			}\n			if (sz[pa] < sz[pb]) {\n				p[pa] = pb;\n				sz[pb] += sz[pa];\n			} else {\n				p[pb] = pa;\n				sz[pa] += sz[pb];\n			}\n			return true;\n		}\n	}\n\n	public class SegmentTreeAdd {\n		int pow;\n		long[] max;\n		long[] delta;\n		boolean[] flag;\n\n		public SegmentTreeAdd(long[] a) {\n			pow = 1;\n			while (pow < a.length) {\n				pow *= 2;\n			}\n			flag = new boolean[2 * pow];\n			max = new long[2 * pow];\n			delta = new long[2 * pow];\n			for (int i = 0; i < max.length; i++) {\n				max[i] = Long.MIN_VALUE / 2;\n			}\n			for (int i = 0; i < a.length; i++) {\n				max[pow + i] = a[i];\n			}\n			for (int i = pow - 1; i > 0; i--) {\n				max[i] = f(max[2 * i], max[2 * i + 1]);\n			}\n		}\n\n		public long get(int v, int tl, int tr, int l, int r) {\n			push(v, tl, tr);\n			if (l > r) {\n				return Long.MIN_VALUE / 2;\n			}\n			if (l == tl && r == tr) {\n				return max[v];\n			}\n			int tm = (tl + tr) / 2;\n			return f(get(2 * v, tl, tm, l, Math.min(r, tm)), get(2 * v + 1, tm + 1, tr, Math.max(l, tm + 1), r));\n		}\n\n		public void set(int v, int tl, int tr, int l, int r, long x) {\n			push(v, tl, tr);\n			if (l > tr || r < tl) {\n				return;\n			}\n			if (l <= tl && r >= tr) {\n				delta[v] += x;\n				flag[v] = true;\n				push(v, tl, tr);\n				return;\n			}\n			int tm = (tl + tr) / 2;\n			set(2 * v, tl, tm, l, r, x);\n			set(2 * v + 1, tm + 1, tr, l, r, x);\n			max[v] = f(max[2 * v], max[2 * v + 1]);\n		}\n\n		public void push(int v, int tl, int tr) {\n			if (flag[v]) {\n				if (v < pow) {\n					flag[2 * v] = true;\n					flag[2 * v + 1] = true;\n					delta[2 * v] += delta[v];\n					delta[2 * v + 1] += delta[v];\n				}\n				flag[v] = false;\n				max[v] += delta[v];\n				delta[v] = 0;\n			}\n		}\n\n		public long f(long a, long b) {\n			return Math.max(a, b);\n		}\n	}\n\n	public class SegmentTreeSet {\n		int pow;\n		int[] sum;\n		int[] delta;\n		boolean[] flag;\n\n		public SegmentTreeSet(int[] a) {\n			pow = 1;\n			while (pow < a.length) {\n				pow *= 2;\n			}\n			flag = new boolean[2 * pow];\n			sum = new int[2 * pow];\n			delta = new int[2 * pow];\n			for (int i = 0; i < a.length; i++) {\n				sum[pow + i] = a[i];\n			}\n			for (int i = pow - 1; i > 0; i--) {\n				sum[i] = f(sum[2 * i], sum[2 * i + 1]);\n			}\n		}\n\n		public int get(int v, int tl, int tr, int l, int r) {\n			push(v, tl, tr);\n			if (l > r) {\n				return 0;\n			}\n			if (l == tl && r == tr) {\n				return sum[v];\n			}\n			int tm = (tl + tr) / 2;\n			return f(get(2 * v, tl, tm, l, Math.min(r, tm)), get(2 * v + 1, tm + 1, tr, Math.max(l, tm + 1), r));\n		}\n\n		public void set(int v, int tl, int tr, int l, int r, int x) {\n			push(v, tl, tr);\n			if (l > tr || r < tl) {\n				return;\n			}\n			if (l <= tl && r >= tr) {\n				delta[v] = x;\n				flag[v] = true;\n				push(v, tl, tr);\n				return;\n			}\n			int tm = (tl + tr) / 2;\n			set(2 * v, tl, tm, l, r, x);\n			set(2 * v + 1, tm + 1, tr, l, r, x);\n			sum[v] = f(sum[2 * v], sum[2 * v + 1]);\n		}\n\n		public void push(int v, int tl, int tr) {\n			if (flag[v]) {\n				if (v < pow) {\n					flag[2 * v] = true;\n					flag[2 * v + 1] = true;\n					delta[2 * v] = delta[v];\n					delta[2 * v + 1] = delta[v];\n				}\n				flag[v] = false;\n				sum[v] = delta[v] * (tr - tl + 1);\n			}\n		}\n\n		public int f(int a, int b) {\n			return a + b;\n		}\n	}\n\n	public class Pair implements Comparable<Pair> {\n		int x;\n		int y;\n\n		public Pair(int x, int y) {\n			this.x = x;\n			this.y = y;\n		}\n\n		public Pair clone() {\n			return new Pair(x, y);\n		}\n\n		public String toString() {\n			return x + "" "" + y;\n		}\n\n		@Override\n		public int compareTo(Pair o) {\n			if (x > o.x) {\n				return 1;\n			}\n			if (x < o.x) {\n				return -1;\n			}\n			if (y > o.y) {\n				return 1;\n			}\n			if (y < o.y) {\n				return -1;\n			}\n			return 0;\n		}\n	}\n\n	Random random = new Random();\n\n	public void shuffle(Pair[] a) {\n		for (int i = 0; i < a.length; i++) {\n			int x = random.nextInt(i + 1);\n			Pair t = a[x];\n			a[x] = a[i];\n			a[i] = t;\n		}\n	}\n\n	public void sort(int[][] a) {\n		for (int i = 0; i < a.length; i++) {\n			Arrays.sort(a[i]);\n		}\n	}\n\n	public void add(Map<Long, Integer> map, long l) {\n		if (map.containsKey(l)) {\n			map.put(l, map.get(l) + 1);\n		} else {\n			map.put(l, 1);\n		}\n	}\n\n	public void remove(Map<Integer, Integer> map, Integer s) {\n		if (map.get(s) > 1) {\n			map.put(s, map.get(s) - 1);\n		} else {\n			map.remove(s);\n		}\n	}\n\n	long max = Long.MAX_VALUE / 2;\n	double eps = 1e-10;\n\n	public int signum(double x) {\n		if (x > eps) {\n			return 1;\n		}\n		if (x < -eps) {\n			return -1;\n		}\n		return 0;\n	}\n\n	public long abs(long x) {\n		return x < 0 ? -x : x;\n	}\n\n	public long min(long x, long y) {\n		return x < y ? x : y;\n	}\n\n	public long max(long x, long y) {\n		return x > y ? x : y;\n	}\n\n	public long gcd(long x, long y) {\n		while (y > 0) {\n			long c = y;\n			y = x % y;\n			x = c;\n		}\n		return x;\n	}\n\n	public final Vector ZERO = new Vector(0, 0);\n\n	// public class Vector implements Comparable<Vector> {\n	// long x;\n	// long y;\n	// int type;\n	// int number;\n	//\n	// public Vector() {\n	// x = 0;\n	// y = 0;\n	// }\n	//\n	// public Vector(long x, long y, int type, int number) {\n	// this.x = x;\n	// this.y = y;\n	// this.type = type;\n	// this.number = number;\n	// }\n	//\n	// public Vector(long x, long y) {\n	//\n	// }\n	//\n	// public Vector(Point begin, Point end) {\n	// this(end.x - begin.x, end.y - begin.y);\n	// }\n	//\n	// public void orient() {\n	// if (x < 0) {\n	// x = -x;\n	// y = -y;\n	// }\n	// if (x == 0 && y < 0) {\n	// y = -y;\n	// }\n	// }\n	//\n	// public void normalize() {\n	// long gcd = gcd(abs(x), abs(y));\n	// x /= gcd;\n	// y /= gcd;\n	// }\n	//\n	// public String toString() {\n	// return x + "" "" + y;\n	// }\n	//\n	// public boolean equals(Vector v) {\n	// return x == v.x && y == v.y;\n	// }\n	//\n	// public boolean collinear(Vector v) {\n	// return cp(this, v) == 0;\n	// }\n	//\n	// public boolean orthogonal(Vector v) {\n	// return dp(this, v) == 0;\n	// }\n	//\n	// public Vector ort(Vector v) {\n	// return new Vector(-y, x);\n	// }\n	//\n	// public Vector add(Vector v) {\n	// return new Vector(x + v.x, y + v.y);\n	// }\n	//\n	// public Vector multiply(long c) {\n	// return new Vector(c * x, c * y);\n	// }\n	//\n	// public int quater() {\n	// if (x > 0 && y >= 0) {\n	// return 1;\n	// }\n	// if (x <= 0 && y > 0) {\n	// return 2;\n	// }\n	// if (x < 0) {\n	// return 3;\n	// }\n	// return 0;\n	// }\n	//\n	// public long len2() {\n	// return x * x + y * y;\n	// }\n	//\n	// @Override\n	// public int compareTo(Vector o) {\n	// if (quater() != o.quater()) {\n	// return quater() - o.quater();\n	// }\n	// return signum(cp(o, this));\n	// }\n	// }\n\n	// public long dp(Vector v1, Vector v2) {\n	// return v1.x * v2.x + v1.y * v2.y;\n	// }\n	//\n	// public long cp(Vector v1, Vector v2) {\n	// return v1.x * v2.y - v1.y * v2.x;\n	// }\n\n	// public class Line implements Comparable<Line> {\n	// Point p;\n	// Vector v;\n	//\n	// public Line(Point p, Vector v) {\n	// this.p = p;\n	// this.v = v;\n	// }\n	//\n	// public Line(Point p1, Point p2) {\n	// if (p1.compareTo(p2) < 0) {\n	// p = p1;\n	// v = new Vector(p1, p2);\n	// } else {\n	// p = p2;\n	// v = new Vector();\n	// }\n	// }\n	//\n	// public boolean collinear(Line l) {\n	// return v.collinear(l.v);\n	// }\n	//\n	// public boolean inLine(Point p) {\n	// return hv(p) == 0;\n	// }\n	//\n	// public boolean inSegment(Point p) {\n	// if (!inLine(p)) {\n	// return false;\n	// }\n	// Point p1 = p;\n	// Point p2 = p.add(v);\n	// return p1.x <= p.x && p.x <= p2.x && min(p1.y, p2.y) <= p.y && p.y <=\n	// max(p1.y, p2.y);\n	// }\n	//\n	// public boolean equalsSegment(Line l) {\n	// return p.equals(l.p) && v.equals(l.v);\n	// }\n	//\n	// public boolean equalsLine(Line l) {\n	// return collinear(l) && inLine(l.p);\n	// }\n	//\n	// public long hv(Point p) {\n	// Vector v1 = new Vector(this.p, p);\n	// return cp(v, v1);\n	// }\n	//\n	// public double h(Point p) {\n	// Vector v1 = new Vector(this.p, p);\n	// return cp(v, v1) / Math.sqrt(v.len2());\n	// }\n	//\n	// public long[] intersectLines(Line l) {\n	// if (collinear(l)) {\n	// return null;\n	// }\n	// long[] ans = new long[4];\n	//\n	// return ans;\n	// }\n	//\n	// public long[] intersectSegment(Line l) {\n	// long[] ans = intersectLines(l);\n	// if (ans == null) {\n	// return null;\n	// }\n	// Point p1 = p;\n	// Point p2 = p.add(v);\n	// boolean f1 = p1.x * ans[1] <= ans[0] && ans[0] <= p2.x * ans[1] && min(p1.y,\n	// p2.y) * ans[3] <= ans[2]\n	// && ans[2] <= max(p1.y, p2.y) * ans[3];\n	// p1 = l.p;\n	// p2 = l.p.add(v);\n	// boolean f2 = p1.x * ans[1] <= ans[0] && ans[0] <= p2.x * ans[1] && min(p1.y,\n	// p2.y) * ans[3] <= ans[2]\n	// && ans[2] <= max(p1.y, p2.y) * ans[3];\n	// if (!f1 || !f2) {\n	// return null;\n	// }\n	// return ans;\n	// }\n	//\n	// @Override\n	// public int compareTo(Line o) {\n	// return v.compareTo(o.v);\n	// }\n	// }\n\n	public class Rect {\n		long x1;\n		long x2;\n		long y1;\n		long y2;\n		int number;\n\n		public Rect(long x1, long x2, long y1, long y2, int number) {\n			this.x1 = x1;\n			this.x2 = x2;\n			this.y1 = y1;\n			this.y2 = y2;\n			this.number = number;\n		}\n	}\n\n	public static class Fenvik {\n		int[] t;\n\n		public Fenvik(int n) {\n			t = new int[n];\n		}\n\n		public void add(int x, int delta) {\n			for (int i = x; i < t.length; i = (i | (i + 1))) {\n				t[i] += delta;\n			}\n		}\n\n		private int sum(int r) {\n			int ans = 0;\n			int x = r;\n			while (x >= 0) {\n				ans += t[x];\n				x = (x & (x + 1)) - 1;\n			}\n			return ans;\n		}\n\n		public int sum(int l, int r) {\n			return sum(r) - sum(l - 1);\n		}\n	}\n\n	public class SegmentTreeMaxSum {\n		int pow;\n		int[] sum;\n		int[] maxPrefSum;\n		int[] maxSufSum;\n		int[] maxSum;\n\n		public SegmentTreeMaxSum(int[] a) {\n			pow = 1;\n			while (pow < a.length) {\n				pow *= 2;\n			}\n			sum = new int[2 * pow];\n			maxPrefSum = new int[2 * pow];\n			maxSum = new int[2 * pow];\n			maxSufSum = new int[2 * pow];\n			for (int i = 0; i < a.length; i++) {\n				sum[pow + i] = a[i];\n				maxSum[pow + i] = Math.max(a[i], 0);\n				maxPrefSum[pow + i] = maxSum[pow + i];\n				maxSufSum[pow + i] = maxSum[pow + i];\n			}\n			for (int i = pow - 1; i > 0; i--) {\n				update(i);\n			}\n		}\n\n		public int[] get(int v, int tl, int tr, int l, int r) {\n			if (r <= tl || l >= tr) {\n				int[] ans = { 0, 0, 0, 0 };\n				return ans;\n			}\n			if (l <= tl && r >= tr) {\n				int[] ans = { maxPrefSum[v], maxSum[v], maxSufSum[v], sum[v] };\n				return ans;\n			}\n			int tm = (tl + tr) / 2;\n			int[] left = get(2 * v, tl, tm, l, r);\n			int[] right = get(2 * v + 1, tm, tr, l, r);\n			int[] ans = { Math.max(left[0], right[0] + left[3]),\n					Math.max(left[1], Math.max(right[1], left[2] + right[0])), Math.max(right[2], left[2] + right[3]),\n					left[3] + right[3] };\n			return ans;\n		}\n\n		public void set(int v, int tl, int tr, int x, int value) {\n			if (v >= pow) {\n				sum[v] = value;\n				maxSum[v] = Math.max(value, 0);\n				maxPrefSum[v] = maxSum[v];\n				maxSufSum[v] = maxSum[v];\n				return;\n			}\n			int tm = (tl + tr) / 2;\n			if (x < tm) {\n				set(2 * v, tl, tm, x, value);\n			} else {\n				set(2 * v + 1, tm, tr, x, value);\n			}\n			update(v);\n		}\n\n		public void update(int i) {\n			sum[i] = f(sum[2 * i], sum[2 * i + 1]);\n			maxSum[i] = Math.max(maxSum[2 * i], Math.max(maxSum[2 * i + 1], maxSufSum[2 * i] + maxPrefSum[2 * i + 1]));\n			maxPrefSum[i] = Math.max(maxPrefSum[2 * i], maxPrefSum[2 * i + 1] + sum[2 * i]);\n			maxSufSum[i] = Math.max(maxSufSum[2 * i + 1], maxSufSum[2 * i] + sum[2 * i + 1]);\n		}\n\n		public int f(int a, int b) {\n			return a + b;\n		}\n	}\n\n	public class Point implements Comparable<Point> {\n		double x;\n		double y;\n\n		public Point() {\n			x = 0;\n			y = 0;\n		}\n\n		public Point(double x, double y) {\n			this.x = x;\n			this.y = y;\n		}\n\n		public String toString() {\n			return x + "" "" + y;\n		}\n\n		public boolean equals(Point p) {\n			return x == p.x && y == p.y;\n		}\n\n		public double dist2() {\n			return x * x + y * y;\n		}\n\n		public Point add(Point v) {\n			return new Point(x + v.x, y + v.y);\n		}\n\n		@Override\n		public int compareTo(Point o) {\n			int z = signum(x + y - o.x - o.y);\n			if (z != 0) {\n				return z;\n			}\n			return signum(x - o.x) != 0 ? signum(x - o.x) : signum(y - o.y);\n		}\n	}\n\n	public class Circle implements Comparable<Circle> {\n		Point p;\n		int r;\n\n		public Circle(Point p, int r) {\n			this.p = p;\n			this.r = r;\n		}\n\n		public Point angle() {\n			double z = r / sq2;\n			z -= z % 1e-5;\n			return new Point(p.x - z, p.y - z);\n		}\n\n		public boolean inside(Point p) {\n			return hypot2(p.x - this.p.x, p.y - this.p.y) <= sq(r);\n		}\n\n		@Override\n		public int compareTo(Circle o) {\n			Point a = angle();\n			Point oa = o.angle();\n			int z = signum(a.x + a.y - oa.x - oa.y);\n			if (z != 0) {\n				return z;\n			}\n			return signum(a.y - oa.y);\n		}\n\n	}\n\n	public class Fraction implements Comparable<Fraction> {\n		long x;\n		long y;\n\n		public Fraction(long x, long y, boolean needNorm) {\n			this.x = x;\n			this.y = y;\n			if (y < 0) {\n				this.x *= -1;\n				this.y *= -1;\n			}\n			if (needNorm) {\n				long gcd = gcd(this.x, this.y);\n				this.x /= gcd;\n				this.y /= gcd;\n			}\n		}\n\n		public Fraction clone() {\n			return new Fraction(x, y, false);\n		}\n\n		public String toString() {\n			return x + ""/"" + y;\n		}\n\n		@Override\n		public int compareTo(Fraction o) {\n			long res = x * o.y - y * o.x;\n			if (res > 0) {\n				return 1;\n			}\n			if (res < 0) {\n				return -1;\n			}\n			return 0;\n		}\n	}\n\n	public double sq(double x) {\n		return x * x;\n	}\n\n	public long sq(long x) {\n		return x * x;\n	}\n\n	public double hypot2(double x, double y) {\n		return sq(x) + sq(y);\n	}\n\n	public long hypot2(long x, long y) {\n		return sq(x) + sq(y);\n	}\n\n	public boolean kuhn(int v, int[][] edge, boolean[] used, int[] mt) {\n		used[v] = true;\n		for (int u : edge[v]) {\n			if (mt[u] < 0 || (!used[mt[u]] && kuhn(mt[u], edge, used, mt))) {\n				mt[u] = v;\n				return true;\n			}\n		}\n		return false;\n	}\n\n	public int matching(int[][] edge) {\n		int n = edge.length;\n		int[] mt = new int[n];\n		Arrays.fill(mt, -1);\n		boolean[] used = new boolean[n];\n		int ans = 0;\n		for (int i = 0; i < n; i++) {\n			if (!used[i] && kuhn(i, edge, used, mt)) {\n				Arrays.fill(used, false);\n				ans++;\n			}\n		}\n		return ans;\n	}\n\n	double sq2 = Math.sqrt(2);\n\n	int small = 20;\n\n	public class MyStack {\n		int[] st;\n		int sz;\n\n		public MyStack(int n) {\n			this.st = new int[n];\n			sz = 0;\n		}\n\n		public boolean isEmpty() {\n			return sz == 0;\n		}\n\n		public int peek() {\n			return st[sz - 1];\n		}\n\n		public int pop() {\n			sz--;\n			return st[sz];\n		}\n\n		public void clear() {\n			sz = 0;\n		}\n\n		public void add(int x) {\n			st[sz++] = x;\n		}\n\n		public int get(int x) {\n			return st[x];\n		}\n	}\n\n	public int[][] readGraph(int n, int m) {\n		int[][] to = new int[n][];\n		int[] sz = new int[n];\n		int[] x = new int[m];\n		int[] y = new int[m];\n		for (int i = 0; i < m; i++) {\n			x[i] = in.nextInt() - 1;\n			y[i] = in.nextInt() - 1;\n			sz[x[i]]++;\n			sz[y[i]]++;\n		}\n		for (int i = 0; i < to.length; i++) {\n			to[i] = new int[sz[i]];\n			sz[i] = 0;\n		}\n		for (int i = 0; i < x.length; i++) {\n			to[x[i]][sz[x[i]]++] = y[i];\n			to[y[i]][sz[y[i]]++] = x[i];\n		}\n		return to;\n	}\n\n	public class Pol {\n		double[] coeff;\n\n		public Pol(double[] coeff) {\n			this.coeff = coeff;\n		}\n\n		public Pol mult(Pol p) {\n			double[] ans = new double[coeff.length + p.coeff.length - 1];\n			for (int i = 0; i < ans.length; i++) {\n				for (int j = Math.max(0, i - p.coeff.length + 1); j < coeff.length && j <= i; j++) {\n					ans[i] += coeff[j] * p.coeff[i - j];\n				}\n			}\n			return new Pol(ans);\n		}\n\n		public String toString() {\n			String ans = """";\n			for (int i = 0; i < coeff.length; i++) {\n				ans += coeff[i] + "" "";\n			}\n			return ans;\n		}\n\n		public double value(double x) {\n			double ans = 0;\n			double p = 1;\n			for (int i = 0; i < coeff.length; i++) {\n				ans += coeff[i] * p;\n				p *= x;\n			}\n			return ans;\n		}\n\n		public double integrate(double r) {\n			Pol p = new Pol(new double[coeff.length + 1]);\n			for (int i = 0; i < coeff.length; i++) {\n				p.coeff[i + 1] = coeff[i] / fact[i + 1];\n			}\n			return p.value(r);\n		}\n\n		public double integrate(double l, double r) {\n			return integrate(r) - integrate(l);\n		}\n	}\n\n	double[] fact = new double[100];\n\n	public class SparseTable {\n		int pow;\n		int[] lessPow;\n		int[][] min;\n\n		public SparseTable(int[] a) {\n			pow = 0;\n			while ((1 << pow) <= a.length) {\n				pow++;\n			}\n			min = new int[pow][a.length];\n			for (int i = 0; i < a.length; i++) {\n				min[0][i] = a[i];\n			}\n			for (int i = 1; i < pow; i++) {\n				for (int j = 0; j < a.length; j++) {\n					min[i][j] = min[i - 1][j];\n					if (j + (1 << (i - 1)) < a.length) {\n						min[i][j] = func(min[i][j], min[i - 1][j + (1 << (i - 1))]);\n					}\n				}\n			}\n			lessPow = new int[a.length + 1];\n			for (int i = 1; i < lessPow.length; i++) {\n				if (i < (1 << (lessPow[i - 1]) + 1)) {\n					lessPow[i] = lessPow[i - 1];\n				} else {\n					lessPow[i] = lessPow[i - 1] + 1;\n				}\n			}\n		}\n\n		public int get(int l, int r) { // [l, r)\n			int p = lessPow[r - l];\n			return func(min[p][l], min[p][r - (1 << p)]);\n		}\n\n		public int func(int a, int b) {\n			if (a < b) {\n				return a;\n			}\n			return b;\n		}\n	}\n\n	public double check(int n, ArrayList<Integer> masks) {\n		int good = 0;\n		for (int colorMask = 0; colorMask < (1 << n); ++colorMask) {\n			int best = 2 << n;\n			int cnt = 0;\n			for (int curMask : masks) {\n				int curScore = 0;\n				for (int i = 0; i < n; ++i) {\n					if (((curMask >> i) & 1) == 1) {\n						if (((colorMask >> i) & 1) == 0) {\n							curScore += 1;\n						} else {\n							curScore += 2;\n						}\n					}\n				}\n\n				if (curScore < best) {\n					best = curScore;\n					cnt = 1;\n				} else if (curScore == best) {\n					++cnt;\n				}\n			}\n\n			if (cnt == 1) {\n				++good;\n			}\n		}\n\n		return (double) good / (double) (1 << n);\n	}\n\n	public int builtin_popcount(int x) {\n		int ans = 0;\n		for (int i = 0; i < 14; i++) {\n			if (((x >> i) & 1) > 0) {\n				ans++;\n			}\n		}\n		return ans;\n	}\n\n	public int number(int[] x) {\n		int ans = 0;\n		for (int i = 0; i < x.length; i++) {\n			ans *= 3;\n			ans += x[i];\n		}\n		return ans;\n	}\n\n	public int[] rotate(int[] x) {\n		int[] ans = { x[2], x[0], x[3], x[1] };\n		return ans;\n	}\n\n	int MAX = 200001;\n\n	boolean[] b = new boolean[MAX];\n	int[][] max0 = new int[MAX][2];\n	int[][] max1 = new int[MAX][2];\n	int[][] max2 = new int[MAX][2];\n	int[] index0 = new int[MAX];\n	int[] index1 = new int[MAX];\n	int[] p = new int[MAX];\n\n	public int place(String s) {\n		if (s.charAt(s.length() - 1) == '1') {\n			return 1;\n		}\n		int number = 16;\n		boolean w = true;\n		boolean a = true;\n		for (int i = 0; i < s.length(); i++) {\n			if (number == 1) {\n				return 2;\n			}\n			if (s.charAt(i) == '1') {\n				if (w) {\n					number /= 2;\n				} else {\n					if (a) {\n						a = false;\n					} else {\n						number /= 2;\n						a = true;\n					}\n				}\n			} else {\n				if (w) {\n					if (number == 16) {\n						w = false;\n						number /= 2;\n					} else {\n						w = false;\n						a = false;\n					}\n				} else {\n					if (number == 8) {\n						if (a) {\n							return 13;\n						} else {\n							return 9;\n						}\n					} else if (number == 4) {\n						if (a) {\n							return 7;\n						} else {\n							return 5;\n						}\n					} else if (a) {\n						return 4;\n					} else {\n						return 3;\n					}\n				}\n			}\n		}\n		return 0;\n	}\n\n	public class P implements Comparable<P> {\n		Integer x;\n		String s;\n\n		public P(Integer x, String s) {\n			this.x = x;\n			this.s = s;\n		}\n\n		@Override\n		public String toString() {\n			return x + "" "" + s;\n		}\n\n		@Override\n		public int compareTo(P o) {\n			if (x != o.x) {\n				return x - o.x;\n			}\n			return s.compareTo(o.s);\n		}\n	}\n\n	public BigInteger prod(int l, int r) {\n		if (l + 1 == r) {\n			return BigInteger.valueOf(l);\n		}\n		int m = (l + r) >> 1;\n		return prod(l, m).multiply(prod(m, r));\n	}\n\n	public class Frac {\n		BigInteger p;\n		BigInteger q;\n\n		public Frac(BigInteger p, BigInteger q) {\n			BigInteger gcd = p.gcd(q);\n			this.p = p.divide(gcd);\n			this.q = q.divide(gcd);\n		}\n\n		public String toString() {\n			return p + ""\n"" + q;\n		}\n\n		public Frac(long p, long q) {\n			this(BigInteger.valueOf(p), BigInteger.valueOf(q));\n		}\n\n		public Frac mul(Frac o) {\n			return new Frac(p.multiply(o.p), q.multiply(o.q));\n		}\n\n		public Frac sum(Frac o) {\n			return new Frac(p.multiply(o.q).add(q.multiply(o.p)), q.multiply(o.q));\n		}\n\n		public Frac diff(Frac o) {\n			return new Frac(p.multiply(o.q).subtract(q.multiply(o.p)), q.multiply(o.q));\n		}\n	}\n\n	public int[] transform(int[] x, int k, int step) {\n		int n = x.length;\n		int[] a = new int[n];\n		int[][] prefsum = new int[n][];\n		int[] elements = new int[n];\n		int[] start = new int[n];\n		int[] id = new int[n];\n		for (int i = 0; i < n; i++) {\n			if (elements[i] > 0) {\n				continue;\n			}\n			int cur = i;\n			do {\n				elements[i]++;\n				cur += step;\n				cur %= n;\n			} while (cur != i);\n			for (int j = 0; j < elements[i]; j++) {\n				start[cur] = i;\n				id[cur] = j;\n				elements[cur] = elements[i];\n				cur += step;\n				cur %= n;\n			}\n			prefsum[i] = new int[3 * elements[i] + 1];\n			for (int j = 0; j < 3 * elements[i]; j++) {\n				prefsum[i][j + 1] = prefsum[i][j] ^ x[cur];\n				cur += step;\n				cur %= n;\n			}\n		}\n		for (int i = 0; i < x.length; i++) {\n			int curlen = k % (2 * elements[i]);\n			a[i] = prefsum[start[i]][id[i] + curlen] ^ prefsum[start[i]][id[i]];\n		}\n		return a;\n	}\n	\n	public boolean rated(String s, int x) {\n		if (s.toUpperCase().equals(""ABC"")) {\n			return x <= 1999;\n		}\n		if (s.toUpperCase().equals(""ARC"")) {\n			return x <= 2799;\n		}\n		if (s.toUpperCase().equals(""AGC"")) {\n			return x >= 1200;\n		}\n		return false;\n	}\n	\n	public boolean can(int n1, int n2, int n3, boolean odd) {\n		while (true) {\n			if (odd) {\n				if (n2 > 0) {\n					n2--;\n				} else if (n3 > 0) {\n					n3--;\n				} else {\n					break;\n				}\n			} else {\n				if (n1 > 0) {\n					n1--;\n				} else if (n3 > 0) {\n					n3--;\n				} else {\n					break;\n				}\n			}\n			odd = !odd;\n		}\n		return n1 == 0 && n2 == 0 && n3 == 0;\n	}\n	\n	public int dfsReturn(int[] n, boolean odd) {\n		if (n[0] > 0) {\n			return 0;\n		}\n		int ans = 0;\n		if (can(n[1] + 1, n[2], n[3], odd)) {\n			ans++;\n		}\n		if (can(n[1], n[2] + 1, n[3], odd)) {\n			ans += 2;\n		}\n		return ans;\n	}\n	\n	public int dfs(int v, int p) {\n		for (int i : to[v]) {\n			if (i == p) {\n				continue;\n			}\n			int x = dfs(i, v);\n			m[v][x]++;\n		}\n		ans[v] = dfsReturn(m[v], to[v].length % 2 == 1);\n		return ans[v];\n	}\n	\n	public void dfs1(int v, int p, int typeP) {\n		int[] one = new int[m[v][1] + (typeP == 1 ? 1 : 0)];\n		int[] two = new int[m[v][2] + (typeP == 2 ? 1 : 0)];\n		int[] three = new int[m[v][3]];\n		int sz1 = 0;\n		int sz2 = 0;\n		int sz3 = 0;\n		if (typeP == 1) {\n			one[sz1++] = p;\n		}\n		if (typeP == 2) {\n			two[sz2++] = p;\n		}\n		for (int i : to[v]) {\n			if (i == p) {\n				continue;\n			}\n			if (ans[i] == 1) {\n				one[sz1++] = i;\n			} else if (ans[i] == 2) {\n				two[sz2++] = i;\n			} else {\n				three[sz3++] = i;\n			}\n		}\n		boolean odd = to[v].length % 2 == 1;\n		sz1--;\n		sz2--;\n		sz3--;\n		while (true) {\n			if (odd) {\n				if (sz2 >= 0) {\n					if (two[sz2] == p) {\n						out.println(v + 1 + "" "" + (p + 1));\n					} else {\n						dfs1(two[sz2], v, 2);\n					}\n					sz2--;\n				} else if (sz3 > 0) {\n					dfs1(three[sz3--], v, 2);\n				} else {\n					break;\n				}\n			} else {\n				if (sz1 >= 0) {\n					if (one[sz1] == p) {\n						out.println(v + 1 + "" "" + (p + 1));\n					} else {\n						dfs1(one[sz1], v, 1);\n					}\n					sz1--;\n				} else if (sz3 > 0) {\n					dfs1(three[sz3--], v, 1);\n				} else {\n					break;\n				}\n			}\n			odd = !odd;\n		}\n	}\n	\n	int[][] to;\n	int[][] m;\n	int[] ans;\n	int[] x;\n	int[] y;\n	int sz;\n	\n	public void solve() {\n		for (int qwerty = in.nextInt(); qwerty > 0; --qwerty) {\n			int n = in.nextInt();\n			to = readGraph(n, n - 1);\n			ans = new int[n];\n			x = new int[n - 1];\n			y = new int[n - 1];\n			m = new int[n][4];\n			sz = 0;\n			if (dfs(0, -1) % 2 == 1) {\n				out.println(""YES"");\n				dfs1(0, -1, 0);\n			} else {\n				out.println(""NO"");\n			}\n		}\n	}\n\n	public void add(HashMap<Integer, Integer> map, int x) {\n		if (map.containsKey(x)) {\n			map.put(x, map.get(x) + 1);\n		} else {\n			map.put(x, 1);\n		}\n	}\n\n	public void run() {\n		try {\n			if (systemIO) {\n				in = new FastScanner(System.in);\n				out = new PrintWriter(System.out);\n			} else {\n				in = new FastScanner(new File(""input.txt""));\n				out = new PrintWriter(new File(""output.txt""));\n			}\n			solve();\n\n			out.close();\n		} catch (IOException e) {\n			e.printStackTrace();\n		}\n	}\n\n	class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		FastScanner(File f) {\n			try {\n				br = new BufferedReader(new FileReader(f));\n			} catch (FileNotFoundException e) {\n				e.printStackTrace();\n			}\n		}\n\n		FastScanner(InputStream f) {\n			br = new BufferedReader(new InputStreamReader(f));\n		}\n\n		String nextLine() {\n			try {\n				return br.readLine();\n			} catch (IOException e) {\n				return null;\n			}\n		}\n\n		String next() {\n			while (st == null || !st.hasMoreTokens()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			}\n			return st.nextToken();\n		}\n\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n\n	}\n\n	// AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n	public static void main(String[] arg) {\n		new D().run();\n	}\n}","constructive algorithms,dfs and similar,dp,trees"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author beginner1010\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        final int MOD = 998244353;\n\n        int pow(int a, int b) {\n            if (b == 0)\n                return 1;\n            if ((b & 1) == 1) {\n                return mul(a, pow(a, b - 1));\n            } else {\n                int aux = pow(a, b >> 1);\n                return mul(aux, aux);\n            }\n        }\n\n        int mul(int a, int b) {\n            return (int) ((1L * a * b) % MOD);\n        }\n\n        int add(int a, int b) {\n            return ((int) (1L * a + b) % MOD);\n        }\n\n        int sub(int a, int b) {\n            long ans = a;\n            ans -= b;\n            ans %= MOD;\n            if (ans < 0) ans += MOD;\n            return (int) ans;\n        }\n\n        int inv(int a) {\n            return pow(a, MOD - 2);\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = sub(in.nextInt(), 0);\n            }\n\n            int query = in.nextInt();\n            FFT fft = new FFT();\n            for (int i = 0; i < query; i++) {\n                int type = in.nextInt();\n                int[] b = new int[n];\n                if (type == 1) {\n                    int q = in.nextInt();\n                    int id = in.nextInt() - 1;\n                    int d = in.nextInt();\n                    for (int j = 0; j < n; j++) {\n                        b[j] = id == j ? sub(q, d) : sub(q, a[j]);\n                    }\n                } else {\n                    int q = in.nextInt();\n                    int l = in.nextInt() - 1;\n                    int r = in.nextInt() - 1;\n                    int d = in.nextInt();\n                    for (int j = 0; j < n; j++) {\n                        b[j] = l <= j && j <= r ? sub(q, add(a[j], d)) : sub(q, a[j]);\n                    }\n                }\n                int[] ans = fft.get(0, n - 1, b);\n                out.println(k >= ans.length ? 0 : ans[k]);\n            }\n        }\n\n        class FFT {\n            final int maxN = 4 * 4 * 10000;\n            final int G = 3;\n            int[] rev;\n\n            FFT() {\n                rev = new int[maxN];\n            }\n\n            void FFT(int[] a, boolean inverse) {\n                int n = a.length;\n                for (int i = 0; i < a.length; i++) {\n                    if (i < rev[i]) {\n                        int temp = a[i];\n                        a[i] = a[rev[i]];\n                        a[rev[i]] = temp;\n                    }\n                }\n                for (int i = 1; i < n; i *= 2) {\n                    int wn = pow(G, ((MOD - 1) / i) >> 1);\n                    if (inverse == true) wn = inv(wn);\n                    for (int j = 0; j < n; j += i * 2) {\n                        int w = 1;\n                        for (int k = j; k < j + i; k++) {\n                            int x = a[k], y = mul(w, a[k + i]);\n                            a[k] = add(x, y);\n                            a[k + i] = sub(x, y);\n                            w = mul(w, wn);\n                        }\n                    }\n                }\n                if (inverse == true) {\n                    int nInv = inv(n);\n                    for (int i = 0; i < n; i++) {\n                        a[i] = mul(a[i], nInv);\n                    }\n                }\n            }\n\n            int[] multiply(int[] a, int[] b) {\n                int n = Math.max(a.length, b.length);\n                int n2 = 1;\n                int log = 0, m = n * 2;\n                while (n2 < m) {\n                    n2 *= 2;\n                    log++;\n                }\n                for (int i = 0; i < n2; i++) {\n                    rev[i] = (rev[i >> 1] >> 1) ^ ((i & 1) << (log - 1));\n                }\n                a = Arrays.copyOf(a, n2);\n                b = Arrays.copyOf(b, n2);\n                FFT(a, false);\n                FFT(b, false);\n                for (int i = 0; i < a.length; i++) a[i] = mul(a[i], b[i]);\n                FFT(a, true);\n                return a;\n            }\n\n            int[] get(int l, int r, int[] a) {\n                if (l == r) {\n                    int[] res = new int[2];\n                    res[0] = 1;\n                    res[1] = a[l];\n                    return res;\n                }\n                int mid = (l + r) >> 1;\n                int[] f1 = get(l, mid, a);\n                int[] f2 = get(mid + 1, r, a);\n                int[] g = multiply(f1, f2);\n                int size = g.length;\n                while (size > 0 && g[size - 1] == 0) {\n                    size--;\n                }\n                g = Arrays.copyOf(g, size);\n                return g;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputStream stream;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private boolean isWhitespace(int c) {\n            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n        }\n\n        private int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isWhitespace(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isWhitespace(c));\n            return res * sgn;\n        }\n\n    }\n}\n\n","divide and conquer,fft"
"import java.util.*;\nimport java.io.*;\nimport java.text.*;\npublic class Main{\n    //SOLUTION BEGIN\n    //Into the Hardware Mode\n    long mod = 998244353;\n    void pre() throws Exception{}\n    void solve(int TC)throws Exception{\n        NTT ntt = new NTT(998244353);\n        int n = ni(), k = ni();\n        int[] a = new int[n];\n        for(int i = 0; i< n; i++)a[i] = ni();\n        long[] b = new long[n];\n        for(int qq = ni(); qq>0; qq--){\n            if(ni() == 1){\n                long q = nl();int p = ni()-1;long d = nl();\n                for(int i = 0; i< n; i++)b[i] = q-a[i];\n                b[p] = q-d;\n                pn((mul(ntt, b, 0, n-1)[k]+mod)%mod);\n            }else{\n                long q = nl();int l = ni()-1, r = ni()-1;long d = nl();\n                for(int i = 0; i< l; i++)b[i] = q-a[i];\n                for(int i = l; i<= r; i++)b[i] = q-a[i]-d;\n                for(int i = r+1; i< n; i++)b[i] = q-a[i];\n                pn((mul(ntt, b, 0, n-1)[k]+mod)%mod);\n            }\n        }\n    }\n    long[] mul(NTT ntt, long[] a, int l, int r) throws Exception{\n        if(l == r)return new long[]{1, a[l]};\n        int mid = (l+r)/2;\n        return ntt.multiply(mul(ntt, a, l, mid), mul(ntt, a, mid+1, r));\n    }\n    class NTT{\n        private int MAGIC = 8;\n        long root, mod;\n        public NTT(long m){\n            mod = m;\n            long[] s = pFact();\n            for(root = 3; true; root++){\n                boolean f = true;\n                for(long x:s)if(pow(root, (mod-1)/x) == 1)f = false;\n                if(f)break;\n            }\n        }\n        long[] naiveMul(long[] a, long[] b){\n            long[] c = new long[a.length+b.length-1];\n            for(int i = 0; i< a.length; i++)\n                for(int j = 0; j< b.length; j++)\n                    c[i+j] = (c[i+j]+a[i]*b[j])%mod;\n            return c;\n        }\n        long[] multiply(long[] a, long[] b) throws Exception{\n            int l = Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2;\n            l = Math.max(l, 1);\n            hold(mod%l == 1);\n            long[] p = new long[l], q = new long[l];\n            for(int i = 0; i< a.length; i++)p[i] = a[i];\n            for(int i = 0; i< b.length; i++)q[i] = b[i];\n            if(l <= MAGIC)return naiveMul(a, b);\n            ntt(p, false);\n            ntt(q, false);\n            for(int i = 0; i< l; i++)p[i] = (p[i]*q[i])%mod;\n            ntt(p, true);\n            return p;   \n        }\n        void ntt(long[] p, boolean invert) throws Exception{\n            int n = p.length;\n            hold(bit(n) == 1);\n            for(int i = 1, j = 0; i< n; i++){\n                int bit = n >> 1;\n                for (; j >= bit; bit >>= 1)\n                    j -= bit;\n                j += bit;\n                if(i< j){\n                    p[i] += p[j];\n                    p[j] = p[i]-p[j];\n                    p[i] -= p[j];\n                }\n            }\n            hold(mod%n == 1);\n            for(int len = 2; len <= n; len<<=1){\n                int half = len>>1;\n                hold((mod-1)%len == 0);\n                long wlen = pow(root, (mod-1)/len);\n                if(invert)wlen = pow(root, mod-1-(mod-1)/len);\n                for(int i = 0; i< n; i+= len){\n                    long w = 1;\n                    for(int j = 0; j< half; j++){\n                        long a = p[i+j], b = (p[i+j+half]*w)%mod;\n                        p[i+j] = (a+b)%mod;\n                        p[i+j+half] = (a-b+mod)%mod;\n                        w = (w*wlen)%mod;\n                    }\n                }\n            }\n            long invN = pow(n, mod-2);\n            if(invert)for(int i = 0; i< n; i++)p[i] = (p[i]*invN)%mod;\n        }\n        long pow(long a, long p){\n            long o = 1;a %= mod;\n            while(p>0){\n                if((p&1)==1)o = (o*a)%mod;\n                a = (a*a)%mod;\n                p>>=1;\n            }\n            return o;\n        }\n        final long[] pFact(){\n            long x = mod-1;\n            long[] s = new long[15];int c = 0;\n            for(long i = 2; i*i <= mod-1; i++){\n                if(x%i != 0)continue;\n                s[c++] = i;\n                while(x%i == 0)x/= i;\n            }\n            if(x > 1)s[c++] = x;\n            s = Arrays.copyOfRange(s, 0, c);\n            return s;\n        }\n    }\n    //SOLUTION END\n    void hold(boolean b)throws Exception{if(!b)throw new Exception(""Hold right there, Sparky!"");}\n    void exit(boolean b){if(!b)System.exit(0);}\n    long IINF = (long)1e18;\n    final int INF = (int)1e9+2, MX = (int)2e6+5;\n    DecimalFormat df = new DecimalFormat(""0.00000000000"");\n    double PI = 3.141592653589793238462643383279502884197169399, eps = 1e-7;\n    static boolean multipleTC = false, memory = false, fileIO = false;\n    FastReader in;PrintWriter out;\n    void run() throws Exception{\n        if(fileIO){\n            in = new FastReader(""C:/users/user/desktop/inp.in"");\n            out = new PrintWriter(""C:/users/user/desktop/out.out"");\n        }else {\n            in = new FastReader();\n            out = new PrintWriter(System.out);\n        }\n        //Solution Credits: Taranpreet Singh\n        int T = (multipleTC)?ni():1;\n        pre();\n        for(int t = 1; t<= T; t++)solve(t);\n        out.flush();\n        out.close();\n    }\n    public static void main(String[] args) throws Exception{\n        if(memory)new Thread(null, new Runnable() {public void run(){try{new Main().run();}catch(Exception e){e.printStackTrace();}}}, ""1"", 1 << 28).start();\n        else new Main().run();\n    }\n    int find(int[] set, int u){return set[u] = (set[u] == u?u:find(set, set[u]));}\n    int digit(long s){int ans = 0;while(s>0){s/=10;ans++;}return ans;}\n    long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}\n    int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}\n    int bit(long n){return (n==0)?0:(1+bit(n&(n-1)));}\n    void p(Object o){out.print(o);}\n    void pn(Object o){out.println(o);}\n    void pni(Object o){out.println(o);out.flush();}\n    String n()throws Exception{return in.next();}\n    String nln()throws Exception{return in.nextLine();}\n    int ni()throws Exception{return Integer.parseInt(in.next());}\n    long nl()throws Exception{return Long.parseLong(in.next());}\n    double nd()throws Exception{return Double.parseDouble(in.next());}\n \n    class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n \n        public FastReader(String s) throws Exception{\n            br = new BufferedReader(new FileReader(s));\n        }\n \n        String next() throws Exception{\n            while (st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch (IOException  e){\n                    throw new Exception(e.toString());\n                }\n            }\n            return st.nextToken();\n        }\n \n        String nextLine() throws Exception{\n            String str = """";\n            try{   \n                str = br.readLine();	\n            }catch (IOException e){\n                throw new Exception(e.toString());\n            }  \n            return str;\n        }\n    }   \n}","divide and conquer,fft"
"import java.io.*;\nimport java.util.*;\n \npublic class E implements Runnable {\n	public static void main (String[] args) {new Thread(null, new E(), ""_cf"", 1 << 28).start();}\n \n	FFT fft = new FFT();\n	int[] a;\n \n	public void run() {\n		FastScanner fs = new FastScanner();\n		PrintWriter out = new PrintWriter(System.out);\n		System.err.println("""");\n \n		int n = fs.nextInt(), k = fs.nextInt();\n		a = new int[n];\n		int[] b = new int[n];\n		for(int i = 0; i < n; i++) {\n			a[i] = fs.nextInt();\n			b[i] = a[i];\n		}\n		int q = fs.nextInt();\n		\n		for(int qq = 1; qq <= q; qq++) {\n			int type = fs.nextInt();\n			int val = fs.nextInt();\n			\n			if(type == 1) {\n				int pos = fs.nextInt()-1;\n				int change = fs.nextInt();\n				a[pos] = change;\n			}\n			else {\n				int L = fs.nextInt()-1, R = fs.nextInt()-1;\n				int by = fs.nextInt();\n				for(int i = L; i <= R; i++) a[i] = add(a[i], by);\n			}\n			for(int i = 0; i < n; i++) {\n				a[i] = sub(val, a[i]);\n			}\n			long[] solve = solve(0, n - 1);\n			out.println(solve[k]);\n			\n			for(int i = 0; i < n; i++) a[i] = b[i];\n			\n		}\n		\n		out.close();\n	}\n	\n	long[] solve(int L, int R) {\n		if(L == R) {\n			return new long[] {1, a[L]};\n		}\n		int mid = (L + R) / 2;\n		long[] left = solve(L, mid);\n		long[] right = solve(mid + 1, R);\n		\n		return fft.multiplyPrecise(left, right);\n	}\n	\n	int MOD = 998244353;\n	\n	int add(int a, int b) {\n		a += b;\n		if(a >= MOD) a -= MOD;\n		return a;\n	}\n	\n	int sub(int a, int b) {\n		a -= b;\n		if(a < 0) a += MOD;\n		return a;\n	}\n	\n	// SET maxk appropriately!!! ~log(maxn) //%\n	 class FFT {\n	     final int maxk = 20, maxn = (1 << maxk) + 1;\n	    // Init: wR, wI, rR, rI, aR, aI   to   new double[maxn] !!!\n	    //#\n	     double[] wR = new double[maxn],\n	            wI = new double[maxn],\n	            rR = new double[maxn],\n	            rI = new double[maxn],\n	            aR  = new double[maxn],\n	            aI  = new double[maxn]; //$\n	     int n, k, lastk = -1, dp[] = new int[maxn];\n \n	     void fft(boolean inv) {\n	        if (lastk != k) {\n	            lastk = k;  dp[0] = 0;\n	            for (int i = 1, g = -1; i < n; i++) {\n	                if ((i & (i - 1)) == 0) g++;\n	                dp[i] = dp[i ^ (1 << g)] ^ (1 << (k - 1 - g));\n	            }\n	            wR[1] = 1;\n	            wI[1] = 0;\n	            for (int t = 0; t < k - 1; t++) {\n	                double a = Math.PI / n * (1 << (k - 1 - t));\n	                double curR = Math.cos(a), curI = Math.sin(a);\n	                int p2 = (1 << t), p3 = p2 * 2;\n	                for (int j = p2, k = j * 2; j < p3; j++, k += 2) {\n	                    wR[k] = wR[j];\n	                    wI[k] = wI[j];\n	                    wR[k + 1] = wR[j] * curR - wI[j] * curI;\n	                    wI[k + 1] = wR[j] * curI + wI[j] * curR;\n	                }\n	            }\n	        }\n	        for (int i = 0; i < n; i++) {\n	            int d = dp[i];\n	            if (i < d) {\n	                double tmp = aR[i];\n	                aR[i] = aR[d];\n	                aR[d] = tmp;\n	                tmp = aI[i];\n	                aI[i] = aI[d];\n	                aI[d] = tmp;\n	            }\n	        }\n	        if (inv) for (int i = 0; i < n; i++) aI[i] = -aI[i];\n	        for (int len = 1; len < n; len <<= 1) {\n	            for (int i = 0; i < n; i += len) {\n	                int wit = len;\n	                for (int it = 0, j = i + len; it < len; it++, i++, j++) {\n	                    double tmpR = aR[j] * wR[wit] - aI[j] * wI[wit];\n	                    double tmpI = aR[j] * wI[wit] + aI[j] * wR[wit];\n	                    wit++;\n	                    aR[j] = aR[i] - tmpR;\n	                    aI[j] = aI[i] - tmpI;\n	                    aR[i] += tmpR;\n	                    aI[i] += tmpI;\n	                }\n	            }\n	        }\n	    }\n \n	     long[] multiply(long[] a, long[] b) {\n	        int na = a.length, nb = b.length;\n	        for (k = 0, n = 1; n < na + nb - 1; n <<= 1, k++) {}\n	        for (int i = 0; i < n; ++i) {\n	            aR[i] = i < na ? a[i] : 0;\n	            aI[i] = i < nb ? b[i] : 0;\n	        }\n	        fft(false);\n	        aR[n] = aR[0];\n	        aI[n] = aI[0];\n	        double q = -1.0 / n / 4.0;\n	        for (int i = 0; i <= n - i; ++i) {\n	            double tmpR = aR[i] * aR[i] - aI[i] * aI[i];\n	            double tmpI = aR[i] * aI[i] * 2;\n	            tmpR -= aR[n - i] * aR[n - i] - aI[n - i] * aI[n - i];\n	            tmpI -= aR[n - i] * aI[n - i] * -2;\n	            aR[i] = -tmpI * q;\n	            aI[i] = tmpR * q;\n	            aR[n - i] = aR[i];\n	            aI[n - i] = -aI[i];\n	        }\n	        fft(true);\n	        long[] ans = new long[n = na + nb - 1]; // ONLY MOD IF NEEDED\n	        for (int i = 0; i < n; i++) ans[i] = Math.round(aR[i]) % MOD;\n	        return ans;\n	    }\n	     void fft2(double[][] xr, double[][] xi, boolean inv) {\n	        n = xr[0].length;\n	        k = Integer.numberOfTrailingZeros(n);\n	        for (int i = 0; i < xr.length; i++) {\n	            for (int j = 0; j < n; j++) { aR[j] = xr[i][j];  aI[j] = xi[i][j]; }\n	            fft(inv);\n	            for (int j=0;j<n;j++){xr[i][j] = aR[j] / (inv ? n : 1);  xi[i][j] = aI[j] / (inv ? -n : 1);}\n	        }\n	        n = xr.length;\n	        k = Integer.numberOfTrailingZeros(n);\n	        for (int j = 0; j < xr[0].length; j++) {\n	            for (int i = 0; i < n; i++) { aR[i] = xr[i][j];  aI[i] = xi[i][j]; }\n	            fft(inv);\n	            for (int i=0;i<n;i++){xr[i][j] = aR[i] / (inv ? n : 1);  xi[i][j] = aI[i] / (inv ? -n : 1);}\n	        }\n	    }\n	     long[][] multiply2(long[][] a, long[][] b) {\n	        int n1, n2;\n	        for (n1 = 1; n1 < a.length + b.length - 1; n1 <<= 1) {}\n	        for (n2 = 1; n2 < a[0].length + b[0].length - 1; n2 <<= 1) {}\n	        double[][] ar = new double[n1][n2], ai = new double[n1][n2];\n	        double[][] br = new double[n1][n2], bi = new double[n1][n2];\n	        for (int i = 0; i < a.length; i++) for(int j=0;j<a[i].length;j++) ar[i][j] = a[i][j];\n	        for (int i = 0; i < b.length; i++) for(int j=0;j<b[i].length;j++) br[i][j] = b[i][j];\n	        fft2(ar,ai,false); fft2(br,bi,false);\n	        for (int i = 0; i < n1; i++) {\n	            for(int j = 0; j < n2; j++) {\n	                double r1 = ar[i][j], r2 = br[i][j];\n	                double i1 = ai[i][j], i2 = bi[i][j];\n	                double real = r1 * r2 - i1 * i2;\n	                ai[i][j] = i1 * r2+ i2*r1;\n	                ar[i][j] = real;\n	            }\n	        }\n	        fft2(ar,ai,true);  long[][] result = new long[n1=a.length+b.length-1][n2=a[0].length+b[0].length-1];\n	        for (int i = 0; i < n1; i++)\n	            for(int j = 0; j < n2; j++) result[i][j] = Math.round(ar[i][j]);\n	        return result;\n	    }\n	    //#\n	     long[] multiplyPrecise(long[] a, long[] b) {\n	        long k = (long)(Math.sqrt(MOD));\n	        long[] a1 = new long[a.length], a2 = new long[a.length];\n	        long[] b1 = new long[b.length], b2 = new long[b.length];\n	        for(int i=0;i<a.length;i++) {\n	            a1[i] = a[i] % k;\n	            a2[i] = a[i] / k;\n	        }\n	        for(int i=0;i<b.length;i++) {\n	            b1[i] = b[i] % k;\n	            b2[i] = b[i] / k;\n	        }\n	        long[] r11 = multiply(a1, b1), r12 = multiply(a1, b2), r21 = multiply(a2, b1), r22 = multiply(a2, b2);\n	        long[] res = new long[r11.length];\n	        for(int i=0;i<res.length;i++)\n	            res[i] = (k*k*r22[i] + k*(r12[i] + r21[i]) + r11[i]) % MOD;\n	        return res;\n	    }\n	    //$\n	    //#\n	     long[] multiplyOr(long[] eq1, long[] eq2) {\n	        int n = Math.max(eq1.length, eq2.length);\n	        if((n & (n-1)) != 0)\n	            n = Integer.highestOneBit(n)*2;\n	        eq1 = fftOr(eq1, n, false);\n	        eq2 = fftOr(eq2, n, false);\n	        for(int i=0;i<eq1.length;i++)\n	            eq1[i] *= eq2[i];\n	        eq1 = fftOr(eq1, n, true);\n	        return eq1;\n	    }\n	    //$\n	    // To use: FFT both, product, iFFT (n is next power of 2)\n	     long[] fftOr(long[] arr, int n, boolean invert) {\n	        long[] ans = Arrays.copyOf(arr, n);\n	        for (int b = 1; b < n; b <<= 1)\n	            for (int i = 0; i < n; i++) {\n	                if ((i & b) != 0) continue;\n	                ans[i + b] += invert ? -ans[i] : ans[i];\n	            }\n	        return ans;\n	    }\n	     long[] fftXor(long[] arr, int n, boolean invert) {\n	        long[] ans = Arrays.copyOf(arr, n);\n	        for (int b = 1; b < n; b <<= 1)\n	            for (int i = 0; i < n; i++) {\n	                if((i & b) != 0) continue;\n	                long u = ans[i], v = ans[i+b];\n	                ans[i] = u + v;  ans[i + b] = u - v;\n	            }\n	        if (invert) for (int i = 0; i < n; i++) ans[i] /= n;\n	        return ans;\n	    }\n	}\n \n	class FastScanner {\n		public int BS = 1<<16;\n		public char NC = (char)0;\n		byte[] buf = new byte[BS];\n		int bId = 0, size = 0;\n		char c = NC;\n		double num = 1;\n		BufferedInputStream in;\n \n		public FastScanner() {\n			in = new BufferedInputStream(System.in, BS);\n		}\n \n		public FastScanner(String s) {\n			try {\n				in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n			}\n			catch (Exception e) {\n				in = new BufferedInputStream(System.in, BS);\n			}\n		}\n \n		public char nextChar(){\n			while(bId==size) {\n				try {\n					size = in.read(buf);\n				}catch(Exception e) {\n					return NC;\n				}                \n				if(size==-1)return NC;\n				bId=0;\n			}\n			return (char)buf[bId++];\n		}\n \n		public int nextInt() {\n			return (int)nextLong();\n		}\n \n		public long nextLong() {\n			num=1;\n			boolean neg = false;\n			if(c==NC)c=nextChar();\n			for(;(c<'0' || c>'9'); c = nextChar()) {\n				if(c=='-')neg=true;\n			}\n			long res = 0;\n			for(; c>='0' && c <='9'; c=nextChar()) {\n				res = (res<<3)+(res<<1)+c-'0';\n				num*=10;\n			}\n			return neg?-res:res;\n		}\n \n		public double nextDouble() {\n			double cur = nextLong();\n			return c!='.' ? cur:cur+nextLong()/num;\n		}\n \n		public String next() {\n			StringBuilder res = new StringBuilder();\n			while(c<=32)c=nextChar();\n			while(c>32) {\n				res.append(c);\n				c=nextChar();\n			}\n			return res.toString();\n		}\n \n		public String nextLine() {\n			StringBuilder res = new StringBuilder();\n			while(c<=32)c=nextChar();\n			while(c!='\n') {\n				res.append(c);\n				c=nextChar();\n			}\n			return res.toString();\n		}\n \n		public boolean hasNext() {\n			if(c>32)return true;\n			while(true) {\n				c=nextChar();\n				if(c==NC)return false;\n				else if(c>32)return true;\n			}\n		}\n		\n		public int[] nextIntArray(int n) {\n			int[] res = new int[n];\n			for(int i = 0; i < n; i++) res[i] = nextInt();\n			return res;\n		}\n		\n	}\n \n}","divide and conquer,fft"
"import java.io.*;\nimport java.util.*;\n\npublic class E {\n\n	public static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n	public static void main(String[] args) throws IOException {\n		readInput();\n		out.close();\n	}\n\n	public static void readInput() throws IOException {\n		// br = new BufferedReader(new FileReader("".in""));\n		// out = new PrintWriter(new FileWriter("".out""));\n		int q = Integer.parseInt(br.readLine());\n		while(q-->0) {\n			int k = Integer.parseInt(br.readLine());\n			int len = 0;\n			StringBuilder sb = new StringBuilder();\n			long val = 1;\n			while (k >=0) {\n				sb.append(val);\n				val++;\n				if (k > len && k <= len+sb.length()) break;\n				len += sb.length();\n			}\n			out.println(sb.charAt(k-len-1));\n		}\n	}\n}\n","binary search,brute force,math"
"import java.io.*;\nimport java.util.*;\n\npublic class numerical_sequence_easy {\n	\n	public static void main(String[] args) throws Exception {\n\n		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n		\n        int q = Integer.parseInt(in.readLine());\n        while (q-- > 0) {\n            long k = Long.parseLong(in.readLine()) - 1;\n            solve(k);\n        }\n    }\n	\n	static long checksum(long mid) {\n        if (mid == 0) {\n            return 0;\n        }\n        \n        int l = Long.toString(mid).length();\n        long count = 0;\n        for (int i = 1; i < l; i++) {\n            long p = (long) (Math.pow(10, i) - Math.pow(10, i - 1));\n            long t1 = i * ((p * (p + 1)) / 2);\n\n            long t2 = (long) (Math.pow(10, i) - Math.pow(10, i - 1)) * i * (mid - ((long) Math.pow(10, i) - 1));\n\n            count += t1 + t2;\n        }\n        long p = mid - (long) Math.pow(10, l - 1) + 1;\n        count += l * ((p * (p + 1)) / 2);\n        return count;\n    }\n\n    static void solve(long k) {\n        long l = 0;\n        long r = 1000_000_000L;\n        while (l < r) {\n            long mid = (l + r) / 2;\n            if (k >= checksum(mid)) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        }\n        \n        k -= checksum(l - 1);\n        for (int i = 1; i <= l; i++) {\n            String x = Long.toString(i);\n            if (k >= x.length()) {\n            	k -= x.length();\n            } else {\n                System.out.println(x.charAt((int) k));\n                return;\n            }\n        }\n    }\n\n}\n","binary search,brute force,math"
"//package numericalsequenceeasyversion;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class numericalsequenceeasyversion {\n	public static void main(String[] args) throws IOException {\n		BufferedReader fin = new BufferedReader(new InputStreamReader(System.in));\n		StringBuilder fout = new StringBuilder();\n		int t = Integer.parseInt(fin.readLine());\n		while(t-- > 0) {\n			long k = Long.parseLong(fin.readLine());\n			//first bin search for which group it belongs to\n			long low = 0;	//group num\n			long high = (long) 1e9;\n			long mid = low + (high - low) / 2;\n			long ans = 0;\n			while(low <= high) {\n				long curAmt = 0;\n				long power = 1;\n				while(power <= mid) {\n					long n = mid - power + 1;\n					curAmt += (n * (n + 1)) / 2;\n					power *= 10;\n				}\n				if(curAmt < k) {\n					low = mid + 1;\n					ans = Math.max(ans, curAmt);\n				}\n				else {\n					high = mid - 1;\n				}\n				mid = low + (high - low) / 2;\n			}\n			k -= ans;\n			//System.out.println(ans + "" ""  + k);\n			//compute which number k is part of\n			long maxAmt = 0;\n			long c = 0;\n			ans = 0;\n			while(true) {\n				//System.out.println(""YES"" + "" "" + k);\n				long rightMaxAmt = maxAmt <= 9? maxAmt : maxAmt - (long) Math.pow(10, c - 1) + 1;\n				//System.out.println(""R: "" + rightMaxAmt);\n				if(k > rightMaxAmt * c) {\n					k -= rightMaxAmt * c;\n					c ++;\n					maxAmt *= 10;\n					maxAmt += 9;\n					continue;\n				}\n				maxAmt /= 10;\n				k--;\n				//System.out.println(""K: "" + k + "" "" + c);\n				long rem = k % c;\n				long multiples = k / c;\n				k = rem;\n				ans = maxAmt + multiples + 1;\n				//System.out.println(maxAmt + "" "" + multiples);\n				break;\n			}\n			\n			String s = ans + """";\n			//System.out.println(s + "" "" + k);\n			fout.append(s.charAt((int) k)).append(""\n"");\n		}\n		System.out.print(fout);\n	}\n}\n","binary search,brute force,math"
"import java.io.*;\nimport java.util.*;\n\npublic class E {\n	public static void main (String[] args) throws IOException {\n		Kattio io = new Kattio();\n		int t = io.nextInt();\n		TreeMap<Long, Long> map = new TreeMap<Long, Long>();\n		map.put(0L, 0L);\n		long total = 0;\n		long cur = 0;\n		for (long i=1; i<100000; i++) {\n			cur += digits(i);\n			total += cur;\n			map.put(total, i);\n		}\n		//System.out.println(map);\n		//System.out.println(map.lastKey());\n		outer: for (int ii=0; ii<t; ii++) {\n			long n = io.nextLong();\n			long seq = map.lowerKey(n);\n			//System.out.println(""n seq : "" + n + "" "" + seq);\n\n			long num = 1;\n			long start = seq;\n			//System.out.println(""init start: "" + start);\n\n			while (true) {\n				char[] s = String.valueOf(num).toCharArray();\n				for (char c : s) {\n					start++;\n					//System.out.println(c + "" "" + start + "" "" + num);\n					if (start == n) {\n						System.out.println(c);\n						continue outer;\n					}\n				}\n				num++;\n			}\n		}\n	}\n\n	static int digits(long n) {\n		String s = String.valueOf(n);\n		return s.length();\n	}\n\n	static class Kattio extends PrintWriter {\n		private BufferedReader r;\n		private StringTokenizer st;\n\n		// standard input\n		public Kattio() { this(System.in, System.out); }\n		public Kattio(InputStream i, OutputStream o) {\n			super(o);\n			r = new BufferedReader(new InputStreamReader(i));\n		}\n		// USACO-style file input\n		public Kattio(String problemName) throws IOException {\n			super(new FileWriter(problemName + "".out""));\n			r = new BufferedReader(new FileReader(problemName + "".in""));\n		}\n\n		// returns null if no more input\n		public String next() {\n			try {\n				while (st == null || !st.hasMoreTokens())\n					st = new StringTokenizer(r.readLine());\n				return st.nextToken();\n			} catch (Exception e) { }\n			return null;\n		}\n\n		public int nextInt() { return Integer.parseInt(next()); }\n		public double nextDouble() { return Double.parseDouble(next()); }\n		public long nextLong() { return Long.parseLong(next()); }\n	}\n}","binary search,brute force,math"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskH solver = new TaskH();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class TaskH {\n        boolean valid = true;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int k = in.readInt();\n            Node[] nodes = new Node[n + 1];\n            for (int i = 1; i <= n; i++) {\n                nodes[i] = new Node();\n                nodes[i].id = i;\n            }\n            for (int i = 1; i < n; i++) {\n                Node a = nodes[in.readInt()];\n                Node b = nodes[in.readInt()];\n                a.next.add(b);\n                b.next.add(a);\n            }\n            findDiameter(nodes[1], null, 0);\n            List<Node> trace = new ArrayList<>(n);\n            dfsForTrace(nodes[1].a, null, 0, nodes[1].diameter, trace);\n\n            int half = trace.size() / 2;\n            Node a = trace.get(half - 1);\n            Node b = trace.get(half);\n            a.next.remove(b);\n            b.next.remove(a);\n            paint(a, b, 0, k, -1);\n            paint(b, a, 1, k, 1);\n            verify(a, b, 0, k);\n            verify(b, a, 0, k);\n            if (!valid) {\n                out.println(""No"");\n                return;\n            }\n            out.println(""Yes"");\n            for (int i = 1; i <= n; i++) {\n                out.append(nodes[i].color + 1).append(' ');\n            }\n        }\n\n        public void verify(Node root, Node p, int depth, int k) {\n            root.depth = depth;\n            root.depthest = root;\n            for (Node node : root.next) {\n                if (node == p) {\n                    continue;\n                }\n                verify(node, root, depth + 1, k);\n                if (root.depthest != root && node.depthest.depth + root.depthest.depth - depth * 2 + 1 >= k && k > 2) {\n                    valid = false;\n                }\n                if (node.depthest.depth > root.depthest.depth) {\n                    root.depthest = node.depthest;\n                }\n            }\n        }\n\n        public void paint(Node root, Node p, int color, int k, int step) {\n            root.color = DigitUtils.mod(color, k);\n            for (Node node : root.next) {\n                if (node == p) {\n                    continue;\n                }\n                paint(node, root, color + step, k, step);\n            }\n        }\n\n        public boolean dfsForTrace(Node root, Node p, int depth, int diameter, List<Node> trace) {\n            trace.add(root);\n            if (depth == diameter) {\n                return true;\n            }\n            for (Node node : root.next) {\n                if (node == p) {\n                    continue;\n                }\n                if (dfsForTrace(node, root, depth + 1, diameter, trace)) {\n                    return true;\n                }\n            }\n            trace.remove(trace.size() - 1);\n            return false;\n        }\n\n        public void findDiameter(Node root, Node p, int depth) {\n            root.depth = depth;\n            root.depthest = root;\n            for (Node node : root.next) {\n                if (node == p) {\n                    continue;\n                }\n                findDiameter(node, root, depth + 1);\n                if (root.diameter < node.diameter) {\n                    root.diameter = node.diameter;\n                    root.a = node.a;\n                }\n                if (root.depthest.depth + node.depthest.depth - root.depth * 2 > root.diameter) {\n                    root.diameter = root.depthest.depth + node.depthest.depth - 2 * root.depth;\n                    root.a = root.depthest;\n                }\n                if (root.depthest.depth < node.depthest.depth) {\n                    root.depthest = node.depthest;\n                }\n            }\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(String c) {\n            cache.append(c).append('\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Node {\n        List<Node> next = new ArrayList<>();\n        int color;\n        Node depthest;\n        int depth;\n        int diameter;\n        Node a;\n        int id;\n\n        public String toString() {\n            return """" + id;\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static int mod(int x, int mod) {\n            x %= mod;\n            if (x < 0) {\n                x += mod;\n            }\n            return x;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n}\n\n","constructive algorithms,dfs and similar,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        //BufferedReader f = new BufferedReader(new FileReader(""uva.in""));\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        int n = Integer.parseInt(f.readLine());\n        StringTokenizer st = new StringTokenizer(f.readLine());\n        int[] d = new int[n];\n        ArrayList<Integer> order = new ArrayList<>(n);\n        for(int i = 0; i < n; i++) {\n            d[i] = Integer.parseInt(st.nextToken());\n            order.add(i);\n        }\n        Collections.sort(order, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return d[o2]-d[o1];\n            }\n        });\n        for(int i = 0; i < n; i++) {\n            order.set(i, 2*order.get(i)+1);\n        }\n        for(int i = 0; i < n-1; i++) {\n            out.println(order.get(i) + "" "" + order.get(i+1));\n        }\n        for(int i = 0; i < n; i++) {\n            int dist = d[order.get(i)/2];\n            int next = order.get(i)+1;\n            out.println(order.get(i+dist-1) + "" "" + next);\n            if(i+dist >= order.size()) {\n                order.add(next);\n            }\n        }\n        f.close();\n        out.close();\n    }\n}\n","constructive algorithms,graphs,math,sortings,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class A {\n\n	public static void main(String[] args) throws IOException {\n		Scanner sc = new Scanner();\n		PrintWriter out = new PrintWriter(System.out);\n		int n = sc.nextInt();\n		Integer[] indices = new Integer[n];\n		int[] d = new int[n];\n		ArrayList<Integer> longestPath = new ArrayList();\n		for (int i = 0; i < n; i++) {\n			d[i] = sc.nextInt();\n			indices[i] = i;\n		}\n		Arrays.sort(indices, Comparator.comparingInt(i -> -d[i]));\n		for (int u : indices) {\n			if (longestPath.size() > 0)\n				out.printf(""%d %d\n"", (u << 1) + 1, longestPath.get(longestPath.size() - 1) + 1);\n\n			longestPath.add(u << 1);\n		}\n		for (int i = 0; i < n; i++) {\n			int u = indices[i];\n			int from = longestPath.get(i + d[u] - 1);\n			out.printf(""%d %d\n"", from + 1, 2 * u + 2);\n			if (i + d[u] == longestPath.size())\n				longestPath.add(2 * u + 1);\n		}\n		out.close();\n\n	}\n\n	static class Scanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		Scanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		Scanner(String fileName) throws FileNotFoundException {\n			br = new BufferedReader(new FileReader(fileName));\n		}\n\n		String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() throws NumberFormatException, IOException {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() throws NumberFormatException, IOException {\n			return Double.parseDouble(next());\n		}\n\n		boolean ready() throws IOException {\n			return br.ready();\n		}\n\n	}\n\n	static void sort(int[] a) {\n		shuffle(a);\n		Arrays.sort(a);\n	}\n\n	static void shuffle(int[] a) {\n		int n = a.length;\n		Random rand = new Random();\n		for (int i = 0; i < n; i++) {\n			int tmpIdx = rand.nextInt(n);\n			int tmp = a[i];\n			a[i] = a[tmpIdx];\n			a[tmpIdx] = tmp;\n		}\n	}\n\n}","constructive algorithms,graphs,math,sortings,trees"
"import java.io.BufferedOutputStream;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.Objects;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	static class TaskAdapter implements Runnable {\n		@Override\n		public void run() {\n			long startTime = System.currentTimeMillis();\n			InputStream inputStream = System.in;\n			OutputStream outputStream = System.out;\n			FastReader in = new FastReader(inputStream);\n			Output out = new Output(outputStream);\n			EPetyaAndConstructionSet solver = new EPetyaAndConstructionSet();\n			solver.solve(1, in, out);\n			out.close();\n			System.err.println(System.currentTimeMillis()-startTime+""ms"");\n		}\n	}\n\n	public static void main(String[] args) throws Exception {\n		Thread thread = new Thread(null, new TaskAdapter(), """", 1<<28);\n		thread.start();\n		thread.join();\n	}\n\n	static class EPetyaAndConstructionSet {\n		public EPetyaAndConstructionSet() {\n		}\n\n		public void solve(int kase, InputReader in, Output pw) {\n			int n = in.nextInt();\n			Pair<Integer, Integer>[] arr = new Pair[n];\n			for(int i = 0; i<n; i++) {\n				arr[i] = new Pair<>(in.nextInt(), 2*i+2);\n			}\n			Arrays.sort(arr, Comparator.comparingInt(o -> -o.a));\n			ArrayDeque<Integer> path = new ArrayDeque<>();\n			HashSet<Integer> hs = new HashSet<>();\n			{\n				int prev = -1;\n				for(int i = 0; i<n; i++) {\n					path.addLast(arr[i].b-1);\n					hs.add(arr[i].b-1);\n					if(prev!=-1) {\n						pw.println(prev, arr[i].b-1);\n					}\n					prev = arr[i].b-1;\n				}\n			}\n			for(int i = 0; i<n; i++) {\n				if(!hs.contains(arr[i].b-1)) {\n					path.addFirst(arr[i].b-1);\n					hs.add(arr[i].b-1);\n				}else if(!path.getFirst().equals(arr[i].b-1)) {\n					hs.remove(path.removeFirst());\n				}\n				while(path.size()>arr[i].a) {\n					hs.remove(path.removeLast());\n				}\n				pw.println(path.getLast(), arr[i].b);\n				hs.add(arr[i].b);\n				path.addLast(arr[i].b);\n			}\n		}\n\n	}\n\n	static interface InputReader {\n		int nextInt();\n\n	}\n\n	static class Pair<T1, T2> implements Comparable<Pair<T1, T2>> {\n		public T1 a;\n		public T2 b;\n\n		public Pair(Pair<T1, T2> p) {\n			this(p.a, p.b);\n		}\n\n		public Pair(T1 a, T2 b) {\n			this.a = a;\n			this.b = b;\n		}\n\n		public String toString() {\n			return a+"" ""+b;\n		}\n\n		public int hashCode() {\n			return Objects.hash(a, b);\n		}\n\n		public boolean equals(Object o) {\n			if(o instanceof Pair) {\n				Pair p = (Pair) o;\n				return a.equals(p.a)&&b.equals(p.b);\n			}\n			return false;\n		}\n\n		public int compareTo(Pair<T1, T2> p) {\n			int cmp = ((Comparable<T1>) a).compareTo(p.a);\n			if(cmp==0) {\n				return ((Comparable<T2>) b).compareTo(p.b);\n			}\n			return cmp;\n		}\n\n	}\n\n	static class FastReader implements InputReader {\n		final private int BUFFER_SIZE = 1<<16;\n		private DataInputStream din;\n		private byte[] buffer;\n		private int bufferPointer;\n		private int bytesRead;\n\n		public FastReader(InputStream is) {\n			din = new DataInputStream(is);\n			buffer = new byte[BUFFER_SIZE];\n			bufferPointer = bytesRead = 0;\n		}\n\n		public int nextInt() {\n			int ret = 0;\n			byte c = skipToDigit();\n			boolean neg = (c=='-');\n			if(neg) {\n				c = read();\n			}\n			do {\n				ret = ret*10+c-'0';\n			} while((c = read())>='0'&&c<='9');\n			if(neg) {\n				return -ret;\n			}\n			return ret;\n		}\n\n		private boolean isDigit(byte b) {\n			return b>='0'&&b<='9';\n		}\n\n		private byte skipToDigit() {\n			byte ret;\n			while(!isDigit(ret = read())&&ret!='-') ;\n			return ret;\n		}\n\n		private void fillBuffer() {\n			try {\n				bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n			}catch(IOException e) {\n				e.printStackTrace();\n				throw new InputMismatchException();\n			}\n			if(bytesRead==-1) {\n				buffer[0] = -1;\n			}\n		}\n\n		private byte read() {\n			if(bytesRead==-1) {\n				throw new InputMismatchException();\n			}else if(bufferPointer==bytesRead) {\n				fillBuffer();\n			}\n			return buffer[bufferPointer++];\n		}\n\n	}\n\n	static class Output implements Closeable, Flushable {\n		public StringBuilder sb;\n		public OutputStream os;\n		public int BUFFER_SIZE;\n		public String lineSeparator;\n\n		public Output(OutputStream os) {\n			this(os, 1<<16);\n		}\n\n		public Output(OutputStream os, int bs) {\n			BUFFER_SIZE = bs;\n			sb = new StringBuilder(BUFFER_SIZE);\n			this.os = new BufferedOutputStream(os, 1<<17);\n			lineSeparator = System.lineSeparator();\n		}\n\n		public void print(String s) {\n			sb.append(s);\n			if(sb.length()>BUFFER_SIZE >> 1) {\n				flushToBuffer();\n			}\n		}\n\n		public void println(Object... o) {\n			for(int i = 0; i<o.length; i++) {\n				if(i!=0) {\n					print("" "");\n				}\n				print(String.valueOf(o[i]));\n			}\n			println();\n		}\n\n		public void println() {\n			sb.append(lineSeparator);\n		}\n\n		private void flushToBuffer() {\n			try {\n				os.write(sb.toString().getBytes());\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n			sb = new StringBuilder(BUFFER_SIZE);\n		}\n\n		public void flush() {\n			try {\n				flushToBuffer();\n				os.flush();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n		public void close() {\n			flush();\n			try {\n				os.close();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n	}\n}\n\n","constructive algorithms,graphs,math,sortings,trees"
"import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1214e {\n\n    public static void main(String[] args) throws IOException {\n        int n = ri(), d[] = ria(n), sorted[][] = new int[n][2];\n        for (int i = 0; i < n; ++i) {\n            sorted[i][0] = d[i];\n            sorted[i][1] = i;\n        }\n        sort(sorted, (a, b) -> b[0] - a[0]);\n        List<Integer> route = new ArrayList<>();\n        route.add(2 * sorted[0][1] + 1);\n        for (int i = 0; i < n - 1; ++i) {\n            prln(2 * sorted[i][1] + 1, 2 * sorted[i + 1][1] + 1);\n            route.add(2 * sorted[i + 1][1] + 1);\n        }\n        for (int i = 0; i < n; ++i) {\n            prln(route.get(i + sorted[i][0] - 1), 2 * sorted[i][1] + 2);\n            if (i + sorted[i][0] == route.size()) {\n                route.add(2 * sorted[i][1] + 2);\n            }\n        }\n        close();\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int lcm(int a, int b) {return a * b / gcf(a, b);}\n    static long lcm(long a, long b) {return a * b / gcf(a, b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // graph util\n    static List<List<Integer>> g(int n) {List<List<Integer>> g = new ArrayList<>(); for (int i = 0; i < n; ++i) g.add(new ArrayList<>()); return g;}\n    static List<Set<Integer>> sg(int n) {List<Set<Integer>> g = new ArrayList<>(); for (int i = 0; i < n; ++i) g.add(new HashSet<>()); return g;}\n    static void c(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).add(v); g.get(v).add(u);}\n    static void cto(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).add(v);}\n    static void dc(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).remove(v); g.get(v).remove(u);}\n    static void dcto(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).remove(v);}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    static List<List<Integer>> rg(int n, int m) throws IOException {List<List<Integer>> g = g(n); for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1); return g;}\n    static void rg(List<List<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1);}\n    static List<List<Integer>> rdg(int n, int m) throws IOException {List<List<Integer>> g = g(n); for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1); return g;}\n    static void rdg(List<List<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1);}\n    static List<Set<Integer>> rsg(int n, int m) throws IOException {List<Set<Integer>> g = sg(n); for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1); return g;}\n    static void rsg(List<Set<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1);}\n    static List<Set<Integer>> rdsg(int n, int m) throws IOException {List<Set<Integer>> g = sg(n); for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1); return g;}\n    static void rdsg(List<Set<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1);}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {prln(""yes"");}\n    static void pry() {prln(""Yes"");}\n    static void prY() {prln(""YES"");}\n    static void prno() {prln(""no"");}\n    static void prn() {prln(""No"");}\n    static void prN() {prln(""NO"");}\n    static void pryesno(boolean b) {prln(b ? ""yes"" : ""no"");};\n    static void pryn(boolean b) {prln(b ? ""Yes"" : ""No"");}\n    static void prYN(boolean b) {prln(b ? ""YES"" : ""NO"");}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(""hlfd""); flush();}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}}","constructive algorithms,graphs,math,sortings,trees"
"\nimport java.util.*;\npublic class ydcthc {\n\n	public static void main(String[] args) {\n       \n		Scanner sc =new Scanner(System.in);\n		int n=sc.nextInt();\n		int ans=0;\n		for(int i=0;i<n;i++) {\n			if(sc.nextInt()%2==0) {\n				ans++;\n			}\n		}\n		\nSystem.out.println(Math.min(ans,n-ans));\n	}\n\n}",math
"\nimport java.util.*;\npublic class ydcthc {\n\n	public static void main(String[] args) {\n       \n		Scanner sc =new Scanner(System.in);\n		int n=sc.nextInt();\n		int ans=0;\n		for(int i=0;i<n;i++) {\n			if(sc.nextInt()%2==0) {\n				ans++;\n			}\n		}\n		\nSystem.out.println(Math.min(ans,n-ans));\n	}\n\n}",math
"import java.util.*;\npublic class Main{\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int a=0,b=0;\n		for(int i=0;i<n;i++) {\n			int c=sc.nextInt();\n			if(c%2==0) {\n				a++;\n			}else\n				b++;\n		}\n		System.out.println(Math.min(a, b));\n	}\n}",math
"\nimport java.util.*;\npublic class Answer {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int t;\n		t=sc.nextInt();\n		int counto=0;\n		for(int i=0;i<t;i++) {\n			int x;\n			x=sc.nextInt();\n			counto+=x&1;\n		}\n		System.out.println(Math.min(counto, t-counto));\n	}\n	 \n\n}\n",math
"import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Test {\n  static PrintWriter writer =\n      new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n  int[][] a = new int[12][2000];\n  int[][] e = new int[12 * 2000][3];\n  Integer[] se = new Integer[12 * 2000];\n  boolean[] used = new boolean[2000];\n  int[] dp = new int[1 << 12];\n  int[] one = new int[1 << 12];\n\n  static int readInt() {\n    int ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  static long readLong() {\n    long ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  static String readLine() {\n    StringBuilder b = new StringBuilder();\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (Character.isLetterOrDigit(c)) {\n          start = true;\n          b.append((char) c);\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return b.toString();\n  }\n\n  public static void main(String[] args) {\n    Test te = new Test();\n    te.start();\n    writer.flush();\n  }\n\n  void start() {\n    int t = readInt();\n    while (t-- > 0) {\n      int n = readInt(), m = readInt();\n      for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++) {\n          a[i][j] = readInt();\n          int k = i * m + j;\n          e[k][0] = a[i][j];\n          e[k][1] = j;\n          e[k][2] = i;\n        }\n      for (int i = n * m - 1; i >= 0; i--) se[i] = i;\n      Arrays.sort(\n          se,\n          0,\n          n * m,\n          (i, j) -> {\n            int[] x = e[i], y = e[j];\n            return x[0] == y[0]\n                ? (x[1] == y[1] ? Integer.compare(x[2], y[2]) : Integer.compare(x[1], y[1]))\n                : Integer.compare(x[0], y[0]);\n          });\n      Arrays.fill(used, 0, m, false);\n      Arrays.fill(dp, 0, 1 << n, -1);\n      dp[0] = 0;\n      int cc = 0;\n      for (int x = n * m - 1; x >= 0; x--) {\n        int c = e[se[x]][1];\n        if (used[c]) continue;\n        used[c] = true;\n        cc++;\n        if (cc > n) break;\n\n        Arrays.fill(one, 0, 1 << n, 0);\n\n        for (int i = (1 << n) - 1; i > 0; i--) {\n          for (int r = 0; r < n; r++) {\n            int sum = 0;\n            for (int j = 0; j < n; j++) if (((i >> j) & 1) != 0) sum += a[(j + r) % n][c];\n            one[i] = Math.max(one[i], sum);\n          }\n        }\n\n        for (int i = (1 << n) - 1; i >= 0; i--) {\n          int u = (1 << n) - 1 - i;\n          int p = u;\n          if (dp[i] >= 0)\n            while (p > 0) {\n              dp[i | p] = Math.max(dp[i | p], dp[i] + one[p]);\n              p = (p - 1) & u;\n            }\n        }\n      }\n      writer.println(dp[(1 << n) - 1]);\n    }\n  }\n}\n","bitmasks,dp,greedy,sortings"
"import java.io.*;\nimport java.util.*;\n\n\npublic class Main{\n	static int[][]memo;\n	static int n,m,in[][];\n	static int dp(int col,int maxRowMask) {\n		if(col>=Math.min(n, m) || maxRowMask==((1<<n)-1))return 0;\n		if(memo[col][maxRowMask]!=-1)return memo[col][maxRowMask];\n		\n		int ans=0;\n		\n		int availableBits=maxRowMask^((1<<n)-1);\n		//all masks that don't intersect with maxRowMask\n		for(int colMask=availableBits;colMask!=0;colMask=(colMask-1)&availableBits) {\n			\n			ans=Math.max(ans, maxMask[col][colMask]+dp(col+1, maxRowMask|colMask));\n			\n		}\n		return memo[col][maxRowMask]=ans;\n	}\n	static int[][]sumOfMask;\n	static int[][]maxMask;\n	public static void main(String[] args) throws Exception{\n		pw=new PrintWriter(System.out);\n		sc = new MScanner(System.in);\n		int tc=sc.nextInt();\n		while(tc-->0) {\n			n=sc.nextInt();m=sc.nextInt();\n			\n			int[]maxInCol=new int[m];\n			in=new int[m][n+1];\n			\n			for(int i=0;i<n;i++) {\n				for(int j=0;j<m;j++) {\n					in[j][i]=sc.nextInt();\n					maxInCol[j]=Math.max(maxInCol[j], in[j][i]);\n					in[j][n]=j;\n				}\n			}\n			Arrays.sort(in,(x,y)->maxInCol[y[n]]-maxInCol[x[n]]);\n			\n			\n			memo=new int[n][1<<n];\n			sumOfMask=new int[n][1<<n];\n			maxMask=new int[n][1<<n];\n			for(int i=0;i<n;i++) {\n				for(int msk=0;msk<memo[i].length;msk++) {\n					memo[i][msk]=-1;\n					if(i>=m)continue;\n					for(int bit=0;bit<n;bit++) {\n						if(((msk>>bit)&1)!=0) {\n							sumOfMask[i][msk]+=in[i][bit];\n						}\n					}\n				}\n			}\n			for(int col=0;col<n;col++) {\n				for(int msk=0;msk<(1<<n);msk++) {\n					int curMask=msk;\n					for(int cyclicShift=0;cyclicShift<n;cyclicShift++) {\n						maxMask[col][msk]=Math.max(maxMask[col][msk], sumOfMask[col][curMask]);\n						\n						int lastBit=curMask&1;\n						curMask>>=1;\n						curMask|=(lastBit<<(n-1));\n						\n					}\n				}\n			}\n			pw.println(dp(0, 0));\n		}\n		\n		\n		pw.flush();\n	}\n	static PrintWriter pw;\n	static MScanner  sc;\n	static class MScanner {\n		StringTokenizer st;\n		BufferedReader br;\n		public MScanner(InputStream system) {\n			br = new BufferedReader(new InputStreamReader(system));\n		}\n \n		public MScanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n \n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n		public int[] intArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public long[] longArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public int[] intSortedArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		public long[] longSortedArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		public Integer[] IntegerArr(int n) throws IOException {\n	        Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public Long[] LongArr(int n) throws IOException {\n	        Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n \n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n \n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n \n		public char nextChar() throws IOException {\n			return next().charAt(0);\n		}\n \n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n \n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n \n		public void waitForInput() throws InterruptedException {\n			Thread.sleep(3000);\n		}\n	}\n	static void shuffle(int[]in) {\n		for(int i=0;i<in.length;i++) {\n			int idx=(int)(Math.random()*in.length);\n			int tmp=in[i];\n			in[i]=in[idx];\n			in[idx]=tmp;\n		}\n	}\n	static void shuffle(long[]in) {\n		for(int i=0;i<in.length;i++) {\n			int idx=(int)(Math.random()*in.length);\n			long tmp=in[i];\n			in[i]=in[idx];\n			in[idx]=tmp;\n		}\n	}\n}","bitmasks,dp,greedy,sortings"
"import java.util.*;\nimport java.io.*;\n\npublic class Main {\n	public static void main(String args[]) {new Main().run();}\n\n	FastReader in = new FastReader();\n	PrintWriter out = new PrintWriter(System.out);\n	void run(){\n		int t=in.nextInt();\n		for(int i=0;i<t;i++) {\n			out.println(work());\n		}\n		out.flush();\n	}\n	long mod=1000000007;\n	long gcd(long a,long b) {\n		return b==0?a:gcd(b,a%b);\n	}\n	int work() {\n		int n=in.nextInt();\n		int m=in.nextInt();\n		int[][] A=new int[n][m];\n		int[][] B=new int[n][m];\n		int[][] R=new int[m][2];\n		for(int i=0;i<m;i++)R[i][1]=i;\n		for(int i=0;i<n;i++) {\n			for(int j=0;j<m;j++) {\n				A[i][j]=in.nextInt();\n				R[j][0]=Math.max(R[j][0], A[i][j]);\n			}\n		}\n		Arrays.sort(R,new Comparator<int[]>() {\n			public int compare(int[] arr1,int[] arr2) {\n				return arr2[0]-arr1[0];\n			}\n		});\n		for(int j=0;j<m;j++) {\n			int index=R[j][1];\n			for(int i=0;i<n;i++) {\n				B[i][j]=A[i][index];\n			}\n		}\n		m=Math.min(n, m);\n		int[][] dp=new int[m][1<<n];\n		int[][] rec=new int[m][1<<n];\n		for(int j=0;j<m;j++) {\n			for(int s=0;s<n;s++) {//转\n				for(int i=1;i<1<<n;i++) {\n					int sum=0;\n					for(int b=0;b<n;b++) {\n						if(((1<<b)&i)>0) {\n							sum+=B[(b+s)%n][j];\n						}\n					}\n					rec[j][i]=Math.max(sum, rec[j][i]);\n				}\n			}\n		}\n		\n		for(int j=0;j<m;j++) {\n			for(int i=0;i<1<<n;i++) {\n				if(j==0) {\n					dp[j][i]=rec[j][i];\n				}else {\n					for(int p=i;p<1<<n;p++) {\n						p=p|i;\n						dp[j][p]=Math.max(dp[j][p], rec[j][i]+dp[j-1][p^i]);\n					}\n				}\n			}\n		}\n		return dp[m-1][(1<<n)-1];\n	}\n}\n\n\n\nclass FastReader\n{\n	BufferedReader br;\n	StringTokenizer st;\n\n	public FastReader()\n	{\n		br=new BufferedReader(new InputStreamReader(System.in));\n	}\n\n	public String next() \n	{\n		if(st==null || !st.hasMoreElements())\n		{\n			try {\n				st = new StringTokenizer(br.readLine());\n			} catch (IOException e) {\n				e.printStackTrace();\n			}\n		}\n		return st.nextToken();\n	}\n\n	public int nextInt() \n	{\n		return Integer.parseInt(next());\n	}\n\n	public long nextLong()\n	{\n		return Long.parseLong(next());\n	}\n}","bitmasks,dp,greedy,sortings"
"import java.util.*;\nimport java.io.*;\n\npublic class Main {\n	public static void main(String args[]) {new Main().run();}\n\n	FastReader in = new FastReader();\n	PrintWriter out = new PrintWriter(System.out);\n	void run(){\n		int t=in.nextInt();\n		for(int i=0;i<t;i++) {\n			out.println(work());\n		}\n		out.flush();\n	}\n	long mod=1000000007;\n	long gcd(long a,long b) {\n		return b==0?a:gcd(b,a%b);\n	}\n	int work() {\n		int n=in.nextInt();\n		int m=in.nextInt();\n		int[][] A=new int[n][m];\n		int[][] B=new int[n][m];\n		int[][] R=new int[m][2];\n		for(int i=0;i<m;i++)R[i][1]=i;\n		for(int i=0;i<n;i++) {\n			for(int j=0;j<m;j++) {\n				A[i][j]=in.nextInt();\n				R[j][0]=Math.max(R[j][0], A[i][j]);\n			}\n		}\n		Arrays.sort(R,new Comparator<int[]>() {\n			public int compare(int[] arr1,int[] arr2) {\n				return arr2[0]-arr1[0];\n			}\n		});\n		for(int j=0;j<m;j++) {\n			int index=R[j][1];\n			for(int i=0;i<n;i++) {\n				B[i][j]=A[i][index];\n			}\n		}\n		m=Math.min(n, m);\n		int[][] dp=new int[m][1<<n];\n		int[][] rec=new int[m][1<<n];\n		for(int j=0;j<m;j++) {\n			for(int s=0;s<n;s++) {//转\n				for(int i=1;i<1<<n;i++) {\n					int sum=0;\n					for(int b=0;b<n;b++) {\n						if(((1<<b)&i)>0) {\n							sum+=B[(b+s)%n][j];\n						}\n					}\n					rec[j][i]=Math.max(sum, rec[j][i]);\n				}\n			}\n		}\n		\n		for(int j=0;j<m;j++) {\n			for(int i=0;i<1<<n;i++) {\n				if(j==0) {\n					dp[j][i]=rec[j][i];\n				}else {\n					for(int p=i+1;;p++) {\n						if(p>=1<<n)break;\n						p=p|i;\n						dp[j][p]=Math.max(dp[j][p], rec[j][i]+dp[j-1][p^i]);\n					}\n				}\n			}\n		}\n		return dp[m-1][(1<<n)-1];\n	}\n}\n\n\n\nclass FastReader\n{\n	BufferedReader br;\n	StringTokenizer st;\n\n	public FastReader()\n	{\n		br=new BufferedReader(new InputStreamReader(System.in));\n	}\n\n	public String next() \n	{\n		if(st==null || !st.hasMoreElements())\n		{\n			try {\n				st = new StringTokenizer(br.readLine());\n			} catch (IOException e) {\n				e.printStackTrace();\n			}\n		}\n		return st.nextToken();\n	}\n\n	public int nextInt() \n	{\n		return Integer.parseInt(next());\n	}\n\n	public long nextLong()\n	{\n		return Long.parseLong(next());\n	}\n}","bitmasks,dp,greedy,sortings"
"//package usacoGoldAccelerated;\n\nimport java.util.Scanner;\n\npublic class Week3Pipeline {\n\n	public static void main(String[] args) {\n		\n		Scanner scanner = new Scanner(System.in);\n		\n		int t = scanner.nextInt();\n		\n		for(int i=0; i<t; i++) {\n			int n = scanner.nextInt();\n			int a = scanner.nextInt();\n			int b = scanner.nextInt();\n			scanner.nextLine();\n			int[] road = new int[n+1];\n			String line = scanner.nextLine();\n			for(int j=1; j<=n; j++) {\n				road[j] = line.charAt(j-1)-48;\n			}\n			\n			long dp[][] = new long[n+1][2];\n			for(int k=0; k<=n; k++) {\n				for(int j=0; j<2; j++) {\n					dp[k][j] = Long.MAX_VALUE/3;\n				}\n			}\n			dp[0][0] = b;\n			\n			for(int j=1; j<=n; j++) {\n				if(road[j]==1) {\n					//dp[j][1] = Math.min(dp[j-1][0]+2*a+2*b, dp[j-1][1]+a+2*b);\n					//if(road[j-1]==0) {\n					//	dp[j][1] = dp[j-1][1]+2*a+2*b;\n					//}\n					//else {\n					dp[j][1] = dp[j-1][1]+a+2*b;\n					//}\n					//System.out.println(dp[j][1]);\n				}\n				else {\n					dp[j][0] = Math.min(dp[j-1][0]+a+b, dp[j-1][1]+2*a+b);\n					dp[j][1] = Math.min(dp[j-1][0]+2*a+2*b, dp[j-1][1]+a+2*b);\n					//System.out.println(dp[j][0]+"" ""+dp[j][1]);\n				}\n				\n			}\n			\n			\n			\n			System.out.println(dp[n][0]);\n			System.out.println();\n			\n		}\n\n	}\n\n}\n\n\n\n","dp,greedy"
"import java.io.*;\nimport java.util.*;\nimport java.lang.Math;\npublic class GasPipeline {\n  public static void main (String [] args) throws IOException {\n    \n    BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n    int ttttt = Integer.parseInt(f.readLine());\n    for(int aaa = 0; aaa < ttttt; aaa++){\n        StringTokenizer s = new StringTokenizer(f.readLine());\n        int N = Integer.parseInt(s.nextToken());\n        int a = Integer.parseInt(s.nextToken());\n        int b = Integer.parseInt(s.nextToken());\n        String str = ""0"" + f.readLine();\n        long[][] dp = new long[N + 10][2];\n        for(int i = 0; i <= N; i++){\n            Arrays.fill(dp[i], Long.MAX_VALUE/2);\n        }\n        \n        dp[0][1] = Long.MAX_VALUE/2;\n        dp[0][0] = b;\n        for(int i = 1; i <= N; i++){\n            if(str.charAt(i) == '1'){\n                dp[i][1] = Math.min(dp[i][1], dp[i - 1][1] + a + b * 2);\n            }else{\n                dp[i][0] = Math.min(dp[i][0], Math.min(dp[i - 1][0] + a + b, dp[i - 1][1] + 2 * a + b));\n                dp[i][1] = Math.min(dp[i][1], Math.min(dp[i - 1][0] + 2 * a + 2 * b, dp[i - 1][1] + a + b * 2));\n            }\n        }\n        System.out.println(dp[N][0]);\n    }\n  }\n}\n","dp,greedy"
"import java.io.*;\nimport java.util.*;\npublic class cf{\n    public static void main(String[] args) throws IOException {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));\n        int t = Integer.parseInt(bf.readLine());\n        for(int testcase = 0; testcase < t; testcase++){\n            StringTokenizer stk = new StringTokenizer(bf.readLine());\n            int N = Integer.parseInt(stk.nextToken());\n            long pipecost = Integer.parseInt(stk.nextToken());\n            long pillarcost = Integer.parseInt(stk.nextToken());\n            String[] strarr = bf.readLine().split("""");\n            long[] s = new long[N];\n            for(int i = 0; i < N; i++) s[i] = Long.parseLong(strarr[i]);\n            long[][] dp = new long[N+1][2];\n            for(int i = 0; i <= N; i++)Arrays.fill(dp[i], Long.MAX_VALUE-Integer.MAX_VALUE);\n            dp[0][0] = pillarcost;\n            for(int i = 1; i <= N; i++){\n                if(s[i-1]==0 && (i == N || s[i] == 0))dp[i][0] = Math.min(dp[i-1][0] + pillarcost + pipecost, dp[i-1][1] + 2*pipecost + pillarcost);\n                dp[i][1] = Math.min(dp[i-1][0] + 2*pipecost + 2*pillarcost, dp[i-1][1] + 2*pillarcost + pipecost);\n            }\n            pw.println(dp[N][0]);\n        }\n        pw.close();\n    }\n}\n","dp,greedy"
"import java.io.*;\n\npublic class Main {\n    public static void main (String[] args) throws IOException {\n//		BufferedReader br = new BufferedReader(new FileReader("".in""));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n//		PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter("".out"")));\n        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));\n        int tests = Integer.parseInt(br.readLine());\n        for(int test = 0;test < tests;test++) {\n            String[] in = br.readLine().split("" "");\n            int n = Integer.parseInt(in[0]);\n            long a = Long.parseLong(in[1]), b = Long.parseLong(in[2]);\n            char[] pipe = br.readLine().toCharArray();\n            long[][] dp = new long[n + 1][2];\n            for(int i = 0;i <= n;i++) dp[i] = new long[] {Long.MAX_VALUE - Integer.MAX_VALUE, Long.MAX_VALUE - Integer.MAX_VALUE};\n            dp[0][0] = b;\n            for(int i = 0;i < n;i++){\n                if(pipe[i] == '0'){\n                    dp[i + 1][0] = Math.min(dp[i][1] + 2L * a + b, dp[i][0] + a + b);\n                    dp[i + 1][1] = Math.min(dp[i][1] + a + 2L * b, dp[i][0] + 2L * a + 2L * b);\n                }\n                else{\n                    dp[i + 1][1] = dp[i][1] + a + 2L * b;\n                }\n            }\n            System.out.println(dp[n][0]);\n        }\n    }\n}\n","dp,greedy"
"import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.List;\n import java.util.*;\n public class realfast implements Runnable \n  {\n    private static final int INF = (int) 1e9;\n    long in= 1000000007;\n    long fac[]= new long[1000001];\n    long inv[]=new long[1000001];\n    public  void solve() throws IOException \n    {\n        Scanner in =new Scanner(System.in);\n\n        int n =readInt();\n        ArrayList<Integer> arr[]=new ArrayList[n+1];\n\n        for(int i=1;i<=n;i++)\n            arr[i]=new ArrayList<Integer>();\n\n\n        for(int i=0;i<n-1;i++)\n        {\n             int u = readInt();\n             int v = readInt();\n             arr[u].add(v);\n             arr[v].add(u);\n        }\n\n        int size[]=new int [n+1];\n        int height[]=new int[n+1];\n        dfs(arr,1,-1,height,size);\n        int  g = find_centroid(arr,1,height,size);\n\n        double pal =0;\n      \n        int ans=-1;\n        boolean check = false;\n        for(int i =0;i<arr[g].size();i++)\n        {\n             int v = arr[g].get(i);\n             if(height[v]<height[g])\n             {\n                pal= pal+n-size[g];\n             }\n             else\n                pal=pal+ size[v];\n            if((pal/n)>=0.34)\n            {\n                if((pal/n)>(0.67))\n                {\n                  if(height[v]<height[g])\n                  {\n                   pal= n-size[g];\n                  }\n                  else\n                  pal= size[v];\n                  check = true;\n                }\n                ans=i;\n                break;\n            }\n        }\n\n        int papu = (int)pal;\n    \n        \n            int c= papu*(n-papu);\n            int mulla = n*n;\n            mulla= 2*mulla;\n            mulla=mulla/9;\n            if(c<mulla)\n            {\n                out.println(pal/n);\n                out.println(""mulla"");\n            }\n        \n        int cur[]=new int[2];\n        if(!check){\n        for(int i=0;i<arr[g].size();i++)\n        {\n            int v = arr[g].get(i);\n            if(i==ans+1)\n            {\n                cur[0]=0;\n            }\n            if(i<=ans)\n            {\n                pl(arr,v,g,0,cur,1);\n            }\n            else \n            {\n                pl(arr,v,g,0,cur,papu);\n            }\n        }\n        }\n        else\n        {\n            for(int i=0;i<arr[g].size();i++)\n           {\n            if(i==ans)\n                continue;\n            int v = arr[g].get(i);\n           \n             \n                pl(arr,v,g,0,cur,1);\n            \n           }\n               cur[0]=0;\n           pl(arr,arr[g].get(ans),g,0,cur,papu);\n\n        }\n\n\n\n\n\n\n\n       \n\n    }\n    public void pl(ArrayList<Integer> arr[] , int u ,int p,  int last ,  int cur[],int fac)\n    {\n\n      int pro=0;\n      cur[0]++;\n      pro=cur[0];\n       \n      out.println(p+"" ""+u+"" ""+((cur[0]-last)*(fac)));\n       \n\n      for(int j =0;j<arr[u].size();j++)\n      {\n         int v = arr[u].get(j);\n         if(v!=p)\n         {\n            pl(arr,v,u,pro,cur,fac);\n         }\n      }\n               \n    }\n\n    public int find_centroid(ArrayList<Integer> arr[] , int u , int height[], int size[])\n    {\n        int n = arr.length-1;\n        for(int i =0;i<arr[u].size();i++)\n        {\n          int v = arr[u].get(i);\n          if(height[v]>height[u])\n          {\n            if(size[v]>(n/2))\n            {\n              return find_centroid(arr,v,height,size);\n            }\n          }\n\n        }\n\n        return u;\n\n    }\n    public void dfs(ArrayList<Integer> arr[] , int u, int p,int height[] , int size[])\n    {\n        if(p!=-1)\n        height[u]=height[p]+1;\n        size[u]=1;\n        for(int j =0;j<arr[u].size();j++)\n        {\n           int v = arr[u].get(j);\n           if(v!=p)\n           {\n             dfs(arr,v,u,height,size);\n             size[u]= size[u]+size[v];\n           //  height[u]=Math.max(height[u],1+height[v]);\n           }\n        }\n    }\n   \n    public long query(long seg[] , int left, int right , int index, int l , int r)\n    {   \n         long inf = 100000000;\n         inf = inf*inf;\n        if(left>=l&&right<=r)\n        {\n            return seg[index];\n        }\n        if(l>right||left>r)\n            return inf;\n        int mid = left+(right-left)/2;\n        return Math.min(query(seg,left,mid,2*index+1,l,r),query(seg,mid+1,right,2*index+2,l,r));\n\n    }\n    \n    public int value (int seg[], int left , int right ,int index, int l, int r)\n    {\n            \n            if(left>right)\n            {\n              return -100000000;\n            }\n            if(right<l||left>r)\n                return -100000000;\n            if(left>=l&&right<=r)\n                return seg[index];\n            int mid = left+(right-left)/2;\n            int val = value(seg,left,mid,2*index+1,l,r);\n            int val2 = value(seg,mid+1,right,2*index+2,l,r);\n            return Math.max(val,val2);\n\n    }\n   \n    public int gcd(int a , int b )\n    {\n      if(a<b)\n      {\n        int t =a;\n        a=b;\n        b=t;\n      }\n      if(a%b==0)\n        return b ;\n      return gcd(b,a%b);\n    }\n    public long pow(long n , long p,long m)\n    {\n         if(p==0)\n            return 1;\n        long val = pow(n,p/2,m);;\n        val= (val*val)%m;\n        if(p%2==0)\n            return val;\n        else\n            return (val*n)%m;\n    }\n    \n    \n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    public static void main(String[] args) {\n        new Thread(null, new realfast(), """", 128 * (1L << 20)).start();\n    }\n \n    private static final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null;\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n    private PrintWriter out;\n \n    @Override\n    public void run() {\n        try {\n            if (ONLINE_JUDGE || !new File(""input.txt"").exists()) {\n                reader = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            } else {\n                reader = new BufferedReader(new FileReader(""input.txt""));\n                out = new PrintWriter(""output.txt"");\n            }\n            solve();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                reader.close();\n            } catch (IOException e) {\n                // nothing\n            }\n            out.close();\n        }\n    }\n \n    private String readString() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n \n    @SuppressWarnings(""unused"")\n    private int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n \n    @SuppressWarnings(""unused"")\n    private long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n \n    @SuppressWarnings(""unused"")\n    private double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n}\nclass edge implements Comparable<edge>{\n    int u ;\n    int v;\n    \n    edge(int  u, int v)\n    {\n       this.u=u;\n       this.v=v;\n    }\n    public int compareTo(edge e)\n    {\n        return this.v-e.v;\n    }\n}","constructive algorithms,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1206F extends PrintWriter {\n	CF1206F() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1206F o = new CF1206F(); o.main(); o.flush();\n	}\n\n	int[] next, jj; int l_ = 1;\n	int link(int l, int j) { next[l_] = l; jj[l_] = j; return l_++; }\n	int[] ao; int n;\n	int[] cc;\n	void init() {\n		int m = n - 1;\n		next = new int[1 + m * 2];\n		jj = new int[1 + m * 2];\n		ao = new int[n];\n		cc = new int[n];\n	}\n	int n_, i_, j_;\n	int dfs(int p, int i) {\n		int k = 1;\n		for (int l = ao[i]; l != 0; l = next[l]) {\n			int j = jj[l];\n			if (j != p)\n				k += dfs(i, j);\n		}\n		int k_ = Math.min(k, n - k);\n		if (n_ < k_) {\n			n_ = k_;\n			if (k <= n - k) {\n				i_ = i;\n				j_ = p;\n			} else {\n				i_ = p;\n				j_ = i;\n			}\n		}\n		cc[i] = k;\n		return k;\n	}\n	int a, b;\n	void dfs_(int p, int i, int c, boolean print) {\n		if (print) {\n			a += b;\n			println((p + 1) + "" "" + (i + 1) + "" "" + (a - c));\n			c = a;\n		}\n		for (int l = ao[i]; l != 0; l = next[l]) {\n			int j = jj[l];\n			if (j != p)\n				dfs_(i, j, c, true);\n		}\n	}\n	void main() {\n		n = sc.nextInt();\n		if (n == 1)\n			return;\n		init();\n		for (int h = 0; h < n - 1; h++) {\n			int i = sc.nextInt() - 1;\n			int j = sc.nextInt() - 1;\n			ao[i] = link(ao[i], j);\n			ao[j] = link(ao[j], i);\n		}\n		dfs(-1, 0);\n		if (n_ * 3 >= n) {\n			b = 1;\n			a = 0;\n			dfs_(i_, j_, 0, false);\n			b = n - n_;\n			a = 0;\n			dfs_(j_, i_, 0, true);\n		} else {\n			int s = j_;\n			dfs(-1, s);\n			Integer[] tt = new Integer[n];\n			int cnt = 0;\n			for (int l = ao[s]; l != 0; l = next[l])\n				tt[cnt++] = jj[l];\n			Arrays.sort(tt, 0, cnt, (i, j) -> cc[i] - cc[j]);\n			n_ = 1;\n			b = 1;\n			a = 0;\n			boolean changed = false;\n			for (int h = 0; h < cnt; h++) {\n				int j = tt[h];\n				n_ += cc[j];\n				dfs_(s, j, 0, true);\n				if (!changed && n_ * 3 >= n) {\n					changed = true;\n					b = n_;\n					a = 0;\n				}\n			}\n		}\n	}\n}\n","constructive algorithms,trees"
"import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n    static int inf = (int) (1e9 + 7);\n    static int n, root = -1;\n    static ArrayList<Integer> gr[];\n    static ArrayList<triple> res = new ArrayList<>();\n    static int sz[];\n\n    static void build_sz(int v, int pr) {\n        sz[v] = 1;\n        for(int to : gr[v]) {\n            if (to == pr) continue;\n            build_sz(to, v);\n            sz[v] += sz[to];\n        }\n    }\n\n    static void find_centre(int v, int pr) {\n        for(int to : gr[v]) {\n            if (to != pr && sz[to] > n / 2) find_centre(to, v);\n        }\n        if (root == -1) root = v;\n    }\n\n    static void f(int v, int pr, int mul) {\n        int cnt = 0;\n        for(int to : gr[v]) {\n            if (to == pr) continue;\n            res.add(new triple(v, to, (1 + cnt) * mul));\n            f(to, v, mul);\n            cnt += sz[to];\n        }\n    }\n\n    static void solve() throws IOException {\n        n = sc.nextInt();\n        gr = new ArrayList[n];\n        for(int i = 0;i < n;i++) gr[i] = new ArrayList<>();\n        sz = new int [n];\n\n        for(int i = 0;i < n - 1;i++) {\n            int v1 = sc.nextInt() - 1;\n            int v2 = sc.nextInt() - 1;\n            gr[v1].add(v2);\n            gr[v2].add(v1);\n        }\n\n        build_sz(0, -1);\n        find_centre(0, -1);\n        build_sz(root, -1);\n\n\n        ArrayList<Integer> to = new ArrayList<>();\n        for(int i : gr[root]) to.add(i);\n        Collections.sort(to, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return Integer.compare(sz[o1], sz[o2]);\n            }\n        });\n\n        int cnt1 = 0;\n        int cnt2 = 0;\n        for(int i : to) {\n            if (cnt1 >= (n + 2) / 3) {\n                res.add(new triple(root, i, (cnt2 + 1) * (cnt1 + 1)));\n                f(i, root, cnt1 + 1);\n                cnt2 += sz[i];\n            }else{\n                res.add(new triple(root, i, cnt1 + 1));\n                f(i, root, 1);\n                cnt1 += sz[i];\n            }\n        }\n\n        for(triple i : res) {\n            pw.println((i.a + 1) + "" "" + (i.b + 1) + "" "" + i.x);\n        }\n    }\n\n\n\n\n    public static void main(String[] args) throws IOException {\n        sc = new Scanner(System.in);\n        pw = new PrintWriter(System.out);\n        solve();\n        pw.close();\n    }\n\n    static Scanner sc;\n    static PrintWriter pw;\n\n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st = new StringTokenizer("""");\n\n        Scanner(InputStream in) throws FileNotFoundException {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        Scanner(String in) throws FileNotFoundException {\n            br = new BufferedReader(new FileReader(in));\n        }\n\n        String next() throws IOException {\n            while (!st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n    }\n\n}\n\nclass triple {\n    int a, b, x;\n    triple(int a, int b, int x) {\n        this.a = a;\n        this.b = b;\n        this.x = x;\n    }\n\n    triple() {}\n}","constructive algorithms,trees"
"import java.io.*; import java.util.*;\npublic class CF1205D{\n  static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        \n    } \n    static int MOD=998244353;\n    static int N,sum;\n    static int[] siz,val; static StringBuilder sb=new StringBuilder();\n    static int A,B;\n    public static void main(String[] args){\n        FastReader br=new FastReader();\n        N=br.nextInt(); \n        ArrayList<Integer> []arl=new ArrayList[N];\n        for (int i = 0; i < N; i++) {arl[i]=new ArrayList<>();  }\n        int a,b;\n        for (int i = 0; i < N-1; i++) {\n            a=br.nextInt()-1; b=br.nextInt()-1; arl[a].add(b); arl[b].add(a);\n        }\n        siz=new int[N]; Arrays.fill(siz,1);\n        dfs(arl,0,-1);\n        \n        int c=find_centroid(arl,0);\n        sum=0;\n        boolean[] use=new boolean[N]; \n        for (int i : arl[c]) {\n            sum+=siz[i];use[i]=true; \n            if(sum*3>=2*N){\n                sum=siz[i]; Arrays.fill(use, false); use[i]=true; break;\n            }else if(sum*3>=N-1){\n                break;\n            }\n            \n        }\n        //System.out.println(c);\n        //System.out.println(Arrays.toString(siz));\n        val=new int[N]; A=1; B=sum+1;\n        for (int i : arl[c]) {\n            if(use[i]){//1,..\n                val[i]=A;\n                sb.append((c+1)+"" ""+(i+1)+"" ""+A+""\n""); A++;\n                dfs2(arl,c,i,true);\n            }else{\n                val[i]=B;\n                sb.append((c+1)+"" ""+(i+1)+"" ""+B+""\n""); B+=(sum+1);\n                dfs2(arl,c,i,false);\n            }\n        }\n        //System.out.println(sum);\n        //System.out.println(Arrays.toString(use));\n        //System.out.println(Arrays.toString(val));\n        System.out.println(sb.toString());\n    }\n    \n     public static void dfs(ArrayList<Integer>[] arl, int i, int p){//We can use DP here too\n         \n            for (int q : arl[i]) {\n                if(q==p)continue;\n                dfs(arl,q,i);\n                siz[i]+=siz[q];\n            }\n      }\n     public static int find_centroid(ArrayList<Integer>[] arl, int i){\n         for (int q: arl[i]) {\n             if(2*siz[q]>N){\n                 siz[i]-=siz[q]; siz[q]+=siz[i];\n                 return find_centroid(arl,q);\n             }\n         }\n         return i;\n     }\n     public static void dfs2(ArrayList<Integer>[] arl, int p, int v, boolean b){\n         \n         for (int i : arl[v]) {\n             if(i==p)continue;\n             if(b){\n                 sb.append((i+1)+"" ""+(v+1)+"" ""+(A-val[v])+""\n"");\n                 \n                 val[i]=A; A++; \n             }else{\n                 sb.append((i+1)+"" ""+(v+1)+"" ""+(B-val[v])+""\n"");\n                 \n                 val[i]=B; B+=(sum+1);\n             }\n             dfs2(arl,v,i,b);\n         }\n     }\n    /*\n    public static int find(int x, int[] p){\n        if(p[x]==x)return x;\n        int ans=find(p[x],x); p[x]=ans; return ans;\n    }\n    public static long pow(int x, int p){\n      if(p==0)return 1; if(p==1)return x;\n      long ans=pow(x,p/2);\n      return ((ans*ans)%M*pow(x,p%2))%M;\n    }\n    */\n}\n//Debugging:\n//Are you sure your algorithm is correct?\n//Bounds: long\n//Special cases: n=0,1?\n//Make sure you remove your debugging code before you submit!","constructive algorithms,trees"
"import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class S {\n    static class point {\n        int need;\n        int change;\n\n        public point(int need, int change) {\n            this.need = need;\n            this.change = change;\n        }\n    }\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int r = in.nextInt();\n        point[] a = new point[n];\n        point[] b = new point[n];\n        int indexA = 0, indexB = 0;\n        for (int i = 0; i < n; i++) {\n            int x = in.nextInt();\n            int y = in.nextInt();\n            if (y >= 0) {\n                a[indexA++] = new point(x, y);\n            } else {\n                b[indexB++] = new point(x, y);\n            }\n        }\n        Arrays.sort(a, 0,indexA,new Comparator<point>() {\n            @Override\n            public int compare(point o1, point o2) {\n                return o1.need >= o2.need ? 1 : -1;\n            }\n        });\n        Arrays.sort(b, 0,indexB,new Comparator<point>() {\n            @Override\n            public int compare(point o1, point o2) {\n                return o1.need+o1.change <= o2.need+o2.change ? 1 : -1;\n            }\n        });\n        for (int i = 0; i < indexA; i++) {\n            if (a[i].need > r) {\n                System.out.println(""NO"");\n                return;\n            }\n            r += a[i].change;\n        }\n        for (int i = 0; i < indexB; i++) {\n            if (b[i].need > r) {\n                System.out.println(""NO"");\n                return;\n            }\n            r += b[i].change;\n        }\n        if (r >= 0) {\n            System.out.println(""YES"");\n        } else {\n            System.out.println(""NO"");\n        }\n\n    }\n}\n\n	 	  						    		    				  		 	",greedy
"import java.io.*;\nimport java.util.*;\n\npublic class G{\n	static List<Pair> neg; \n	static int[][] dp;\n	static int len;\n	static int solve(int o, int t) {\n		if (t == 0) return 0;\n		if (t < 0) return -1;\n		if (o >= len) return 0;\n		if (dp[o][t] == -1) {\n			// Either take, or do not take.\n			dp[o][t] = solve(o+1, t);\n			if (t >= neg.get(o).a && t + neg.get(o).b >= 0) {\n				dp[o][t] = Integer.max(dp[o][t], solve(o+1,t+neg.get(o).b)+1);\n			}\n		}\n		return dp[o][t];\n	}\n	public static void main(String[] args) throws IOException {\n		// br = new BufferedReader(new FileReader("".in""));\n		// out = new PrintWriter(new FileWriter("".out""));\n		//new Thread(null, new (), ""peepee"", 1<<28).start();\n		int n = readInt();\n		int r = readInt();\n		List<Pair> pos = new ArrayList<Pair>();\n		neg = new ArrayList<Pair>();\n		for (int i = 0; i < n; i++) {\n			Pair p = new Pair(readInt(),readInt());\n			if (p.b >= 0) pos.add(p);\n			else {\n				p.a = Integer.max(p.a, -p.b);\n				neg.add(p);\n			}\n		}\n		// Optimally, take all positive in ascending order\n		while (!pos.isEmpty()) {\n			int c = -1;\n			for (int i = 0; i < pos.size(); i++) if (pos.get(i).a <= r) c = i;\n			if (c == -1) break;\n			r += pos.remove(c).b;\n		}\n		// DP on neg\n		Collections.sort(neg, (i,j)-> -((i.a + i.b) - (j.a + j.b))); \n		//for (Pair p: neg) System.out.println(p.a + "" "" + p.b);\n		len = neg.size();\n		dp = new int[len][(int)r+1];\n		for (int[] d: dp) Arrays.fill(d, -1);\n		int max = solve(0,r);\n		out.println(pos.isEmpty() && len == max  ?""YES"":""NO"");\n		out.close();\n	}\n	\n	static class Pair{\n		int a,b;\n		public Pair(int c, int d) {\n			a=c;\n			b=d;\n		}\n	}\n	\n	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n	static StringTokenizer st = new StringTokenizer("""");\n	static String read() throws IOException{return st.hasMoreTokens() ? st.nextToken():(st = new StringTokenizer(br.readLine())).nextToken();}\n	static int readInt() throws IOException{return Integer.parseInt(read());}\n	static long readLong() throws IOException{return Long.parseLong(read());}\n	static double readDouble() throws IOException{return Double.parseDouble(read());}\n	\n}",greedy
"import java.io.*;\nimport java.util.*;\n\npublic class Main{\n	static ArrayList<int[]>neg;\n	static int[][]memo;\n	static int dp(int i,int rating) {\n		if(rating<0)return -10000000;\n		if(i>=neg.size())return 0;\n		if(memo[i][rating]!=-1)return memo[i][rating];\n		\n		int leave=dp(i+1,rating);\n		int take=rating>=neg.get(i)[0]?(1+dp(i+1,rating+neg.get(i)[1])):-10000000;\n		\n		return memo[i][rating]=Math.max(leave, take);\n	}\n	static void main() throws Exception{\n		int n=sc.nextInt(),r=sc.nextInt();\n		ArrayList<int[]>pos=new ArrayList<>();\n		neg=new ArrayList<>();\n		\n		for(int i=0;i<n;i++) {\n			int rating=sc.nextInt(),delta=sc.nextInt();\n			if(delta>=0) {\n				pos.add(new int[] {rating,delta});\n			}\n			else {\n				neg.add(new int[] {Math.max(rating, -delta),delta});\n			}\n		}\n		boolean[]taken=new boolean[pos.size()];\n		int ans=0;\n		while(true) {\n			int maxB=-500,idx=-1;\n			for(int i=0;i<pos.size();i++) {\n				if(taken[i] || pos.get(i)[0]>r)continue;\n				if(pos.get(i)[1]>maxB) {\n					maxB=pos.get(i)[1];\n					idx=i;\n				}\n			}\n			if(idx==-1)break;\n			if(r+maxB<0)break;\n			\n			ans++;\n			r+=pos.get(idx)[1];\n			taken[idx]=true;\n		}\n		memo=new int[neg.size()][r+1];\n		for(int i=0;i<memo.length;i++) {\n			Arrays.fill(memo[i], -1);\n		}\n		\n		\n		Collections.sort(neg,(x,y)->(y[0]+y[1])-(x[0]+x[1]));\n		int ansNeg=Math.max(0, dp(0, r));\n		\n		pw.println((ans+ansNeg)==n?""YES"":""NO"");\n	}\n	public static void main(String[] args) throws Exception{\n		pw=new PrintWriter(System.out);\n		sc = new MScanner(System.in);\n		int tc=1;\n		while(tc-->0) main();\n		pw.flush();\n	}\n	static PrintWriter pw;\n	static MScanner  sc;\n	static class MScanner {\n		StringTokenizer st;\n		BufferedReader br;\n		public MScanner(InputStream system) {\n			br = new BufferedReader(new InputStreamReader(system));\n		}\n \n		public MScanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n \n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n		public int[] intArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public long[] longArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public int[] intSortedArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		public long[] longSortedArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		public Integer[] IntegerArr(int n) throws IOException {\n	        Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public Long[] LongArr(int n) throws IOException {\n	        Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n \n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n \n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n \n		public char nextChar() throws IOException {\n			return next().charAt(0);\n		}\n \n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n \n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n \n		public void waitForInput() throws InterruptedException {\n			Thread.sleep(3000);\n		}\n	}\n	static void shuffle(int[]in) {\n		for(int i=0;i<in.length;i++) {\n			int idx=(int)(Math.random()*in.length);\n			int tmp=in[i];\n			in[i]=in[idx];\n			in[idx]=tmp;\n		}\n	}\n	static void shuffle(long[]in) {\n		for(int i=0;i<in.length;i++) {\n			int idx=(int)(Math.random()*in.length);\n			long tmp=in[i];\n			in[i]=in[idx];\n			in[idx]=tmp;\n		}\n	}\n}",greedy
"import java.io.BufferedOutputStream;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.Objects;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	static class TaskAdapter implements Runnable {\n		@Override\n		public void run() {\n			long startTime = System.currentTimeMillis();\n			InputStream inputStream = System.in;\n			OutputStream outputStream = System.out;\n			FastReader in = new FastReader(inputStream);\n			Output out = new Output(outputStream);\n			F1CompleteTheProjectsEasyVersion solver = new F1CompleteTheProjectsEasyVersion();\n			solver.solve(1, in, out);\n			out.close();\n			System.err.println(System.currentTimeMillis()-startTime+""ms"");\n		}\n	}\n\n	public static void main(String[] args) throws Exception {\n		Thread thread = new Thread(null, new TaskAdapter(), """", 1<<26);\n		thread.start();\n		thread.join();\n	}\n\n	static class F1CompleteTheProjectsEasyVersion {\n		public F1CompleteTheProjectsEasyVersion() {\n		}\n\n		public void solve(int kase, InputReader in, Output pw) {\n			int n = in.nextInt(), cur = in.nextInt();\n			ArrayList<Pair<Integer, Integer>> pos = new ArrayList<>(), neg = new ArrayList<>();\n			for(int i = 0; i<n; i++) {\n				int a = in.nextInt(), b = in.nextInt();\n				if(b>=0) {\n					pos.add(new Pair<>(a, b));\n				}else {\n					b = -b;\n					neg.add(new Pair<>(Math.max(a, b), b));\n				}\n			}\n			pos.sort(Comparator.comparingInt(o -> o.a));\n			for(var v: pos) {\n				if(v.a>cur) {\n					pw.println(""NO"");\n					return;\n				}\n				cur += v.b;\n			}\n			neg.sort(Comparator.comparingInt(o -> -o.a+o.b));\n//			Utilities.Debug.dbg(neg);\n			for(var v: neg) {\n				if(v.a>cur) {\n					pw.println(""NO"");\n					return;\n				}\n				cur -= v.b;\n			}\n			if(cur>=0) {\n				pw.println(""YES"");\n			}else {\n				pw.println(""NO"");\n			}\n		}\n\n	}\n\n	static class FastReader implements InputReader {\n		final private int BUFFER_SIZE = 1<<16;\n		private DataInputStream din;\n		private byte[] buffer;\n		private int bufferPointer;\n		private int bytesRead;\n\n		public FastReader(InputStream is) {\n			din = new DataInputStream(is);\n			buffer = new byte[BUFFER_SIZE];\n			bufferPointer = bytesRead = 0;\n		}\n\n		public int nextInt() {\n			int ret = 0;\n			byte c = skipToDigit();\n			boolean neg = (c=='-');\n			if(neg) {\n				c = read();\n			}\n			do {\n				ret = ret*10+c-'0';\n			} while((c = read())>='0'&&c<='9');\n			if(neg) {\n				return -ret;\n			}\n			return ret;\n		}\n\n		private boolean isDigit(byte b) {\n			return b>='0'&&b<='9';\n		}\n\n		private byte skipToDigit() {\n			byte ret;\n			while(!isDigit(ret = read())&&ret!='-') ;\n			return ret;\n		}\n\n		private void fillBuffer() {\n			try {\n				bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n			}catch(IOException e) {\n				e.printStackTrace();\n				throw new InputMismatchException();\n			}\n			if(bytesRead==-1) {\n				buffer[0] = -1;\n			}\n		}\n\n		private byte read() {\n			if(bytesRead==-1) {\n				throw new InputMismatchException();\n			}else if(bufferPointer==bytesRead) {\n				fillBuffer();\n			}\n			return buffer[bufferPointer++];\n		}\n\n	}\n\n	static interface InputReader {\n		int nextInt();\n\n	}\n\n	static class Output implements Closeable, Flushable {\n		public StringBuilder sb;\n		public OutputStream os;\n		public int BUFFER_SIZE;\n		public String lineSeparator;\n\n		public Output(OutputStream os) {\n			this(os, 1<<16);\n		}\n\n		public Output(OutputStream os, int bs) {\n			BUFFER_SIZE = bs;\n			sb = new StringBuilder(BUFFER_SIZE);\n			this.os = new BufferedOutputStream(os, 1<<17);\n			lineSeparator = System.lineSeparator();\n		}\n\n		public void println(String s) {\n			sb.append(s);\n			println();\n		}\n\n		public void println() {\n			sb.append(lineSeparator);\n		}\n\n		private void flushToBuffer() {\n			try {\n				os.write(sb.toString().getBytes());\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n			sb = new StringBuilder(BUFFER_SIZE);\n		}\n\n		public void flush() {\n			try {\n				flushToBuffer();\n				os.flush();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n		public void close() {\n			flush();\n			try {\n				os.close();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n	}\n\n	static class Utilities {\n		public static class Debug {\n			public static boolean LOCAL = System.getProperty(""ONLINE_JUDGE"")==null;\n\n			private static <T> String ts(T t) {\n				if(t==null) {\n					return ""null"";\n				}\n				try {\n					return ts((Iterable) t);\n				}catch(ClassCastException e) {\n					if(t instanceof int[]) {\n						String s = Arrays.toString((int[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof long[]) {\n						String s = Arrays.toString((long[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof char[]) {\n						String s = Arrays.toString((char[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof double[]) {\n						String s = Arrays.toString((double[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof boolean[]) {\n						String s = Arrays.toString((boolean[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}\n					try {\n						return ts((Object[]) t);\n					}catch(ClassCastException e1) {\n						return t.toString();\n					}\n				}\n			}\n\n			private static <T> String ts(T[] arr) {\n				StringBuilder ret = new StringBuilder();\n				ret.append(""{"");\n				boolean first = true;\n				for(T t: arr) {\n					if(!first) {\n						ret.append("", "");\n					}\n					first = false;\n					ret.append(ts(t));\n				}\n				ret.append(""}"");\n				return ret.toString();\n			}\n\n			private static <T> String ts(Iterable<T> iter) {\n				StringBuilder ret = new StringBuilder();\n				ret.append(""{"");\n				boolean first = true;\n				for(T t: iter) {\n					if(!first) {\n						ret.append("", "");\n					}\n					first = false;\n					ret.append(ts(t));\n				}\n				ret.append(""}"");\n				return ret.toString();\n			}\n\n			public static void dbg(Object... o) {\n				if(LOCAL) {\n					System.err.print(""Line #""+Thread.currentThread().getStackTrace()[2].getLineNumber()+"": ["");\n					for(int i = 0; i<o.length; i++) {\n						if(i!=0) {\n							System.err.print("", "");\n						}\n						System.err.print(ts(o[i]));\n					}\n					System.err.println(""]"");\n				}\n			}\n\n		}\n\n	}\n\n	static class Pair<T1, T2> implements Comparable<Pair<T1, T2>> {\n		public T1 a;\n		public T2 b;\n\n		public Pair(Pair<T1, T2> p) {\n			this(p.a, p.b);\n		}\n\n		public Pair(T1 a, T2 b) {\n			this.a = a;\n			this.b = b;\n		}\n\n		public String toString() {\n			return a+"" ""+b;\n		}\n\n		public int hashCode() {\n			return Objects.hash(a, b);\n		}\n\n		public boolean equals(Object o) {\n			if(o instanceof Pair) {\n				Pair p = (Pair) o;\n				return a.equals(p.a)&&b.equals(p.b);\n			}\n			return false;\n		}\n\n		public int compareTo(Pair<T1, T2> p) {\n			int cmp = ((Comparable<T1>) a).compareTo(p.a);\n			if(cmp==0) {\n				return ((Comparable<T2>) b).compareTo(p.b);\n			}\n			return cmp;\n		}\n\n	}\n}\n\n",greedy
"import java.util.Scanner;\n\npublic class r576b {\n	public static void main(String[] args) {\n		Scanner scan=new Scanner(System.in);\n		double h=scan.nextInt(), l=scan.nextInt();\n		System.out.println((l*l-h*h)/2/h);\n	}\n}","geometry,math"
"import java.util.Scanner;\n\npublic class r576b {\n	public static void main(String[] args) {\n		Scanner scan=new Scanner(System.in);\n		double h=scan.nextInt(), l=scan.nextInt();\n		System.out.println((l*l-h*h)/2/h);\n	}\n}","geometry,math"
"import java.util.Scanner;\npublic class lily{\npublic static void main(String[] args)\n{\n\nScanner in =new Scanner(System.in);\nDouble h=in.nextDouble(), l=in.nextDouble();\nSystem.out.print((l*l+h*h)/(2*h)-h);\n\n\n}\n\n}","geometry,math"
import java.util.*;\n\npublic class Z1199B {\n	\n	public static void main(String[] args) {\n		\n		Scanner input = new Scanner(System.in);\n		\n		double H = input.nextDouble();\n		double L = input.nextDouble();\n		\n		System.out.println((L*L-H*H)/(2*H));\n		\n	}\n}\n,"geometry,math"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1178A extends PrintWriter {\n	CF1178A() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1178A o = new CF1178A(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int[] aa = new int[n];\n		for (int i = 0; i < n; i++)\n			aa[i] = sc.nextInt();\n		int a = aa[0], cnt = 1, sum = a, sum_ = a;\n		for (int i = 1; i < n; i++) {\n			if (a >= aa[i] * 2) {\n				cnt++;\n				sum += aa[i];\n			}\n			sum_ += aa[i];\n		}\n		if (sum * 2 <= sum_) {\n			println(0);\n			return;\n		}\n		println(cnt);\n		print(1);\n		for (int i = 1; i < n; i++)\n			if (a >= aa[i] * 2)\n				print("" "" + (i + 1));\n		println();\n	}\n}\n",greedy
"import java.util.*;\nimport static java.lang.Math.*;\npublic class Demo{\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int n = in.nextInt();\n		int[] a = new int[n];\n		int sum =0;\n		for (int i = 0; i < n; i++){\n			a[i] = in.nextInt();\n			sum+= a[i];\n		}\n		int maj = sum/2+1;\n		maj-=a[0];\n		ArrayList<Integer> list = new ArrayList();\n		list.add(1);\n		for (int i = 1; i < n; i++){\n			if (maj>0){\n				if (a[i]<=a[0]/2){\n					maj-=a[i];\n					list.add(i+1);\n				}\n				\n			}else{\n				break;\n			}\n			\n		}\n		\n		if(maj>0){\n			System.out.println(0);\n		}else{\n			System.out.println(list.size());\n			for (int j : list){\n				System.out.print(j+"" "");\n			}\n			System.out.println();\n				\n		}\n		\n	}\n}		 \n",greedy
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1178A extends PrintWriter {\n	CF1178A() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1178A o = new CF1178A(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int[] aa = new int[n];\n		for (int i = 0; i < n; i++)\n			aa[i] = sc.nextInt();\n		int a = aa[0], cnt = 1, sum = a, sum_ = a;\n		for (int i = 1; i < n; i++) {\n			if (a >= aa[i] * 2) {\n				cnt++;\n				sum += aa[i];\n			}\n			sum_ += aa[i];\n		}\n		if (sum * 2 <= sum_) {\n			println(0);\n			return;\n		}\n		println(cnt);\n		print(1);\n		for (int i = 1; i < n; i++)\n			if (a >= aa[i] * 2)\n				print("" "" + (i + 1));\n		println();\n	}\n}\n",greedy
"import java.util.*;\n\npublic class A1178 {\n		\n	public static void main(String[] args) \n	{\n		Scanner sc=new Scanner(System.in);\n		int len=sc.nextInt();\n		int sum=0, total=0;\n		ArrayList<Integer> list=new ArrayList<>();\n		int[] arr= new int[len];\n		for(int i=0; i<len; i++)\n		{\n			arr[i]=sc.nextInt();\n			total+=arr[i];\n		}\n		\n		int a=arr[0];\n		\n		if(a>total/2)\n		{\n			System.out.println(1);\n			System.out.println(1);\n		}\n		else\n		{\n		sum=a;\n		//list.add(1);\n		for(int i=1; i<len; i++)\n		{\n			if(a>=2*arr[i])\n			{\n				sum+=arr[i];\n				list.add(i+1);\n			}\n			if(sum>total/2)\n			{\n				break;\n			}\n		}\n		if(list.size()>0 && sum>total/2)\n		{\n			list.add(0,1);\n		System.out.println(list.size());\n		for(int i=0; i<list.size(); i++)\n		{\n			System.out.print(list.get(i)+"" "");\n		}\n		}\n		else\n		{\n			System.out.println(0);\n		}\n		}\n		\n	}\n}",greedy
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n	PrintWriter out = new PrintWriter(System.out);\n	BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer tok = new StringTokenizer("""");\n    String next() throws IOException {\n        if (!tok.hasMoreTokens()) { tok = new StringTokenizer(in.readLine()); }\n        return tok.nextToken();\n    }\n    int ni() throws IOException { return Integer.parseInt(next()); }\n    long nl() throws IOException { return Long.parseLong(next()); }\n    \n    long mod=1000000007;\n    long[][]A,D;\n    int n;\n    \n    void solve() throws IOException {\n        n=ni();\n        A=new long[n][7];\n        D=new long[n][10];\n        for (int i=0;i<n;i++) {\n            Arrays.fill(D[i],-1);\n            int k=ni();\n            ArrayList<Integer>B=new ArrayList();\n            int m2=0;\n            int m3=0;\n            for (int j=0;j<k;j++) {\n                int u=ni(),v=ni();\n                if (u==1) B.add(v);\n                if (u==2) m2=Math.max(m2,v);\n                if (u==3) m3=Math.max(m3,v);\n            }\n            Collections.sort(B,Collections.reverseOrder());\n            A[i][1]=Math.max(m3,Math.max(m2,B.size()==0?0:B.get(0)));\n            A[i][4]=A[i][1];\n            if (B.size()==0 || B.size()==1 && m2==0) A[i][2]=-1;\n            else {\n                A[i][2]=(long)B.get(0)+Math.max(m2,B.size()==1?0:B.get(1));\n                A[i][5]=Math.max(B.get(0),m2);\n            }\n            if (B.size()<3) A[i][3]=-1;\n            else {\n                A[i][3]=(long)B.get(0)+B.get(1)+B.get(2);\n                A[i][6]=B.get(0);\n            }\n        }\n        \n        out.println(solve(0,0));\n        out.flush();\n    }\n    \n    long solve(int u,int m) {\n        if (u==n) return 0;\n        if (D[u][m]>-1) return D[u][m];\n        \n        long ret=solve(u+1,m);\n        ret=Math.max(ret,solve(u+1,(m+1)%10)+A[u][1]+(m==9?A[u][4]:0));\n        if (A[u][2]>-1) ret=Math.max(ret,solve(u+1,(m+2)%10)+A[u][2]+(m>=8?A[u][5]:0));\n        if (A[u][3]>-1) ret=Math.max(ret,solve(u+1,(m+3)%10)+A[u][3]+(m>=7?A[u][6]:0));\n        \n        return D[u][m]=ret;\n    }\n    \n    int gcd(int a,int b) { return(b==0?a:gcd(b,a%b)); }\n    long gcd(long a,long b) { return(b==0?a:gcd(b,a%b)); }\n    long mp(long a,long p) { long r=1; while(p>0) { if ((p&1)==1) r=(r*a)%mod; p>>=1; a=(a*a)%mod; } return r; }\n    \n    public static void main(String[] args) throws IOException {\n        new Main().solve();\n    }\n}","dp,implementation,sortings"
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n  static long[][] points;\n\n  static void update(int b, long[] a) {\n    long max = 0, sum = 0;\n    for (long i : a) {\n      max = Math.max(max, i);\n      sum += i;\n    }\n\n    for (int i = 0; i < 10; ++i) {\n      boolean bonus = false;\n      int j = i + a.length;\n      if (j >= 10) {\n        bonus = true;\n        j -= 10;\n      }\n      points[b + 1][j] = Math.max(points[b + 1][j], points[b][i] + sum + (bonus ? max : 0));\n    }\n  }\n\n  public static void main(String args[]) {\n    InputReader in = new InputReader(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n\n    int n = in.nextInt();\n\n    points = new long[n + 1][10];\n    for (int i = 0; i <= n; ++i) {\n      for (int j = 0; j < 10; ++j) {\n        points[i][j] = Long.MIN_VALUE;\n      }\n    }\n    points[0][0] = 0;\n\n    for (int i = 0; i < n; ++i) {\n      List<Long>[] cards = new List[3 + 1];\n      for (int j = 0; j <= 3; ++j) {\n        cards[j] = new ArrayList<>();\n      }\n\n      int k = in.nextInt();\n      for (int j = 0; j < k; ++j) {\n        cards[in.nextInt()].add(in.nextLong());\n      }\n\n      for (int j = 0; j <= 3; ++j) {\n        cards[j].sort(Collections.reverseOrder());\n      }\n\n      update(i, new long[0]);\n\n      if (cards[1].size() >= 1) {\n        update(i, new long[]{cards[1].get(0)});\n      }\n\n      if (cards[1].size() >= 2) {\n        update(i, new long[]{cards[1].get(0), cards[1].get(1)});\n      }\n\n      if (cards[1].size() >= 3) {\n        update(i, new long[]{cards[1].get(0), cards[1].get(1), cards[1].get(2)});\n      }\n\n      if (cards[1].size() >= 1 && cards[2].size() >= 1) {\n        update(i, new long[]{cards[1].get(0), cards[2].get(0)});\n      }\n\n      if (cards[2].size() >= 1) {\n        update(i, new long[]{cards[2].get(0)});\n      }\n\n      if (cards[3].size() >= 1) {\n        update(i, new long[]{cards[3].get(0)});\n      }\n    }\n\n    long ans = Long.MIN_VALUE;\n    for (int i = 0; i < 10; ++i) {\n      ans = Math.max(ans, points[n][i]);\n    }\n\n    out.println(ans);\n\n    out.close();\n  }\n\n}\n\nclass InputReader {\n\n  public BufferedReader reader;\n  public StringTokenizer tokenizer;\n\n  public InputReader(InputStream str) {\n    reader = new BufferedReader(new InputStreamReader(str), 1 << 15);\n  }\n\n  public String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new StringTokenizer(reader.readLine());\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    return tokenizer.nextToken();\n  }\n\n  public int nextInt() {\n    return Integer.parseInt(next());\n  }\n\n  public long nextLong() {\n    return Long.parseLong(next());\n  }\n\n}\n","dp,implementation,sortings"
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n	static Scanner sc = new Scanner(System.in);\n	static PrintWriter out = new PrintWriter(System.out);\n	static ArrayList<Integer>[][] damage;\n	static Long[][] memo;\n	static int n;\n	\n	static long dp(int idx, int card) {\n        if (idx == n) return 0;\n        if (memo[idx][card] != null)\n            return memo[idx][card];\n        \n        long ans = dp(idx + 1, card);\n \n        //Single Card\n        for (int k = 1; k <= 3; k++) {\n            if (damage[idx][k].size() > 0) {\n                long curAns = dp(idx + 1, (card + 1) % 10) + damage[idx][k].get(0);\n                if (card == 9)\n                    curAns += damage[idx][k].get(0);\n                ans = Math.max(ans, curAns);\n            }\n        }\n        \n        //Two Ones\n        if (damage[idx][1].size() > 1) {\n            long curAns = dp(idx + 1, (card + 2) % 10) + damage[idx][1].get(0) + damage[idx][1].get(1);\n            if (card >= 8)\n                curAns += damage[idx][1].get(0);\n            ans = Math.max(ans, curAns);\n        }\n        \n        //One and Two\n        if (damage[idx][1].size() > 0 && damage[idx][2].size() > 0) {\n            long curAns = dp(idx + 1, (card + 2) % 10) + damage[idx][1].get(0) + damage[idx][2].get(0);\n            if (card >= 8)\n                curAns += Math.max(damage[idx][1].get(0), damage[idx][2].get(0));\n            ans = Math.max(ans, curAns);\n        }\n        \n        //Three Ones\n        if (damage[idx][1].size() > 2) {\n            long curAns = dp(idx + 1, (card + 3) % 10) + damage[idx][1].get(0) + damage[idx][1].get(1) + damage[idx][1].get(2);\n            if (card >= 7)\n                curAns += damage[idx][1].get(0);\n            ans = Math.max(ans, curAns);\n        }\n \n        return memo[idx][card] = ans;\n    }\n\n	public static void main(String[] args) throws Exception {\n		n = sc.nextInt();\n		damage = new ArrayList[n][5];\n		memo = new Long[n][10];\n\n		for (int i = 0; i < n; i++) {\n			for (int j = 1; j <= 3; j++) {\n				damage[i][j] = new ArrayList<>();\n			}\n		}\n		\n		for (int i = 0; i < n; i++) {\n			int k = sc.nextInt();\n			while (k-- > 0) {\n				int c = sc.nextInt();\n				int d = sc.nextInt();\n				damage[i][c].add(d);\n			}\n		}\n\n		for (int i = 0; i < n; i++) {\n			for (int j = 1; j <= 3; j++) {\n				Collections.sort(damage[i][j], (x, y) -> Integer.compare(y, x));\n			}\n		}\n\n		out.println(dp(0, 0));\n		out.close();\n	}\n}\n\nclass Scanner {\n	StringTokenizer st;\n	BufferedReader br;\n\n	public Scanner(InputStream system) {\n		br = new BufferedReader(new InputStreamReader(system));\n	}\n\n	public Scanner(String file) throws Exception {\n		br = new BufferedReader(new FileReader(file));\n	}\n\n	public String next() throws IOException {\n		while (st == null || !st.hasMoreTokens())\n			st = new StringTokenizer(br.readLine());\n		return st.nextToken();\n	}\n\n	public String nextLine() throws IOException {\n		return br.readLine();\n	}\n\n	public int nextInt() throws IOException {\n		return Integer.parseInt(next());\n	}\n\n	public double nextDouble() throws IOException {\n		return Double.parseDouble(next());\n	}\n\n	public Long nextLong() throws IOException {\n		return Long.parseLong(next());\n	}\n}","dp,implementation,sortings"
"// package Point2100;\n\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Destroyit {\n\n    //    MUST SEE BEFORE SUBMISSION\n    //    check whether int part would overflow or not, especially when it is a * b!!!!\n//    check if top down dp would cause overflow or not !!!!!!!!!!!!!!!!!!!!!!\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int t = 1;\n//        t = sc.nextInt();\n        for (int i = 0; i < t; i++) {\n            solve(sc, pw);\n        }\n        pw.close();\n    }\n\n    static void solve(Scanner in, PrintWriter out){\n        int n = in.nextInt();\n        long[][][] dp = new long[n][4][4];\n        for(int i = 0; i < n; i++){\n            int k = in.nextInt();\n            List<Integer>[] lss = new List[4];\n            for (int j = 0; j < 4; j++) {\n                lss[j] = new ArrayList<>();\n            }\n            for (int j = 0; j < k; j++) {\n                int l = in.nextInt(), r = in.nextInt();\n                lss[l].add(r);\n            }\n            for (int j = 1; j < 4; j++) {\n                Collections.sort(lss[j]);\n            }\n            for (int j = 1; j <= 3; j++) {\n                for (int l = 0; l <= 1; l++) { // l = 0 means no double, else it means at lth position, this value should be doubled\n                    if (j == 1){\n                        long v1 = Integer.MIN_VALUE, v2 = Integer.MIN_VALUE, v3 = Integer.MIN_VALUE;\n                        if (lss[1].size() > 0) v1 = lss[1].get(lss[1].size() - 1);\n                        if (lss[2].size() > 0) v2 = lss[2].get(lss[2].size() - 1);\n                        if (lss[3].size() > 0) v3 = lss[3].get(lss[3].size() - 1);\n                        long mx = Math.max(v1, Math.max(v2, v3));\n                        if (l == j){\n                            dp[i][j][l] = 2l * mx;\n                        }else{\n                            dp[i][j][l] = mx;\n                        }\n                    }else if (j == 2){\n                        long mx = 0;\n                        if (lss[1].size() > 0 && lss[2].size() > 0){\n                            long v1 = lss[1].get(lss[1].size() - 1), v2 = lss[2].get(lss[2].size() - 1);\n                            if (l == 0){\n                                mx = v1 + v2;\n                            }else{\n                                mx = Math.max(v1, v2) * 2 + Math.min(v1, v2);\n                            }\n                        }\n                        long st = 0;\n                        if (lss[1].size() > 1){\n                            long v11 = lss[1].get(lss[1].size() - 1), v12 = lss[1].get(lss[1].size() - 2);\n                            if (l == 0){\n                                st = v11 + v12;\n                            }else{\n                                st = Math.max(v11, v12) * 2l + Math.min(v11, v12);\n                            }\n                        }\n                        dp[i][j][l] = Math.max(mx, st);\n                    }else{\n                        if (lss[1].size() > 2){\n                            int v11 = lss[1].get(lss[1].size() - 1), v12 = lss[1].get(lss[1].size() - 2), v13 = lss[1].get(lss[1].size() - 3);\n                            long[] arr = new long[]{v11, v12, v13};\n                            Arrays.sort(arr);\n                            if (l == 0){\n                                dp[i][j][l] = arr[0] + arr[1] + arr[2];\n                            }else{\n                                dp[i][j][l] = arr[0] + arr[1] + arr[2] * 2l;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        long[][] dpp = new long[n + 1][11];\n        for (int i = 0; i < dpp.length; i++) {\n            Arrays.fill(dpp[i], -1);\n        }\n        out.println(dfs(0, 0, dpp, dp, n));\n    }\n\n    static long dfs(int idx, int count, long[][] dp, long[][][] helper, int n){\n        if (idx == n) return 0;\n        if (dp[idx][count] != -1) return dp[idx][count];\n        long res = dfs(idx + 1, count, dp, helper, n);\n        for (int i = 1; i <= 3; i++) {\n            if (i + count >= 10 && helper[idx][i][1] > 0){\n                res = Math.max(res, dfs(idx + 1, (count + i) % 10, dp, helper, n) + helper[idx][i][1]);\n            }\n            if (i + count < 10 && helper[idx][i][0] > 0){\n                res = Math.max(res, dfs(idx + 1, count + i, dp, helper, n) + helper[idx][i][0]);\n            }\n        }\n        return dp[idx][count] = res;\n    }\n}\n","dp,implementation,sortings"
"import java.io.BufferedOutputStream;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.AbstractCollection;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	static class TaskAdapter implements Runnable {\n		@Override\n		public void run() {\n			long startTime = System.currentTimeMillis();\n			InputStream inputStream = System.in;\n			OutputStream outputStream = System.out;\n			FastReader in = new FastReader(inputStream);\n			Output out = new Output(outputStream);\n			FVickysDeliveryService solver = new FVickysDeliveryService();\n			solver.solve(1, in, out);\n			out.close();\n			System.err.println(System.currentTimeMillis()-startTime+""ms"");\n		}\n	}\n\n	public static void main(String[] args) throws Exception {\n		Thread thread = new Thread(null, new TaskAdapter(), """", 1<<26);\n		thread.start();\n		thread.join();\n	}\n\n	static class FVickysDeliveryService {\n		int n;\n		int m;\n		int c;\n		int q;\n		int id;\n		FVickysDeliveryService.DSU dsu;\n		HashMap<Integer, Integer>[] colors;\n\n		public FVickysDeliveryService() {\n		}\n\n		public void add(int u, int v, int x) {\n			dsu.union(colors[u].computeIfAbsent(x, (a) -> id++), v);\n			dsu.union(colors[v].computeIfAbsent(x, (a) -> id++), u);\n			dsu.addExtra(u, v);\n			dsu.addExtra(v, u);\n		}\n\n		public boolean query(int u, int v) {\n			return dsu.connected(u, v)||dsu.hasExtra(u, v);\n		}\n\n		public void solve(int kase, InputReader in, Output pw) {\n			n = in.nextInt();\n			m = in.nextInt();\n			c = in.nextInt();\n			q = in.nextInt();\n			dsu = new FVickysDeliveryService.DSU(2*(n+m+c+q));//can't be bothered to find the exact number\n			colors = new HashMap[n];\n			for(int i = 0; i<n; i++) {\n				colors[i] = new HashMap<>();\n			}\n			id = 2*n;\n			for(int i = 0; i<m; i++) {\n				add(in.nextInt()-1, in.nextInt()-1, in.nextInt());\n			}\n			while(q-->0) {\n				if(in.next().equals(""+"")) {\n					add(in.nextInt()-1, in.nextInt()-1, in.nextInt());\n				}else {\n					pw.println(query(in.nextInt()-1, in.nextInt()-1) ? ""Yes"" : ""No"");\n				}\n			}\n		}\n\n		static class DSU {\n			int[] p;\n			HashSet<Integer>[] e;\n\n			public DSU(int n) {\n				p = new int[n];\n				e = new HashSet[n];\n				for(int i = 0; i<n; i++) {\n					p[i] = i;\n				}\n			}\n\n			public int find(int u) {\n				return p[u]==u ? u : (p[u] = find(p[u]));\n			}\n\n			public void union(int u, int v) {\n//				Utilities.Debug.dbg(""Union"", u, v);\n				int ur = find(u), vr = find(v);\n				if(ur!=vr) {\n					if(e[ur]!=null) {\n						if(e[vr]!=null) {\n							if(e[ur].size()>e[vr].size()) {\n								int tmp = ur;\n								ur = vr;\n								vr = tmp;\n							}\n							e[vr].addAll(e[ur]);\n						}else {\n							e[vr] = e[ur];\n						}\n					}\n					p[ur] = vr;\n				}\n			}\n\n			public void addExtra(int u, int v) {\n//				Utilities.Debug.dbg(""Add"", u, v);\n				u = find(u);\n				if(e[u]==null) {\n					e[u] = new HashSet<>();\n				}\n				e[u].add(v);\n			}\n\n			public boolean connected(int u, int v) {\n				return find(u)==find(v);\n			}\n\n			public boolean hasExtra(int u, int v) {\n				return e[find(u)]!=null&&e[find(u)].contains(v);\n			}\n\n		}\n\n	}\n\n	static class FastReader implements InputReader {\n		final private int BUFFER_SIZE = 1<<16;\n		private DataInputStream din;\n		private byte[] buffer;\n		private int bufferPointer;\n		private int bytesRead;\n\n		public FastReader(InputStream is) {\n			din = new DataInputStream(is);\n			buffer = new byte[BUFFER_SIZE];\n			bufferPointer = bytesRead = 0;\n		}\n\n		public String next() {\n			StringBuilder ret = new StringBuilder(64);\n			byte c = skip();\n			while(c!=-1&&!isSpaceChar(c)) {\n				ret.appendCodePoint(c);\n				c = read();\n			}\n			return ret.toString();\n		}\n\n		public int nextInt() {\n			int ret = 0;\n			byte c = skipToDigit();\n			boolean neg = (c=='-');\n			if(neg) {\n				c = read();\n			}\n			do {\n				ret = ret*10+c-'0';\n			} while((c = read())>='0'&&c<='9');\n			if(neg) {\n				return -ret;\n			}\n			return ret;\n		}\n\n		private boolean isSpaceChar(byte b) {\n			return b==' '||b=='\r'||b=='\n'||b=='\t'||b=='\f';\n		}\n\n		private byte skip() {\n			byte ret;\n			while(isSpaceChar((ret = read()))) ;\n			return ret;\n		}\n\n		private boolean isDigit(byte b) {\n			return b>='0'&&b<='9';\n		}\n\n		private byte skipToDigit() {\n			byte ret;\n			while(!isDigit(ret = read())&&ret!='-') ;\n			return ret;\n		}\n\n		private void fillBuffer() {\n			try {\n				bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n			}catch(IOException e) {\n				e.printStackTrace();\n				throw new InputMismatchException();\n			}\n			if(bytesRead==-1) {\n				buffer[0] = -1;\n			}\n		}\n\n		private byte read() {\n			if(bytesRead==-1) {\n				throw new InputMismatchException();\n			}else if(bufferPointer==bytesRead) {\n				fillBuffer();\n			}\n			return buffer[bufferPointer++];\n		}\n\n	}\n\n	static class Output implements Closeable, Flushable {\n		public StringBuilder sb;\n		public OutputStream os;\n		public int BUFFER_SIZE;\n		public String lineSeparator;\n\n		public Output(OutputStream os) {\n			this(os, 1<<16);\n		}\n\n		public Output(OutputStream os, int bs) {\n			BUFFER_SIZE = bs;\n			sb = new StringBuilder(BUFFER_SIZE);\n			this.os = new BufferedOutputStream(os, 1<<17);\n			lineSeparator = System.lineSeparator();\n		}\n\n		public void println(String s) {\n			sb.append(s);\n			println();\n		}\n\n		public void println() {\n			sb.append(lineSeparator);\n		}\n\n		private void flushToBuffer() {\n			try {\n				os.write(sb.toString().getBytes());\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n			sb = new StringBuilder(BUFFER_SIZE);\n		}\n\n		public void flush() {\n			try {\n				flushToBuffer();\n				os.flush();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n		public void close() {\n			flush();\n			try {\n				os.close();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n	}\n\n	static interface InputReader {\n		String next();\n\n		int nextInt();\n\n	}\n\n	static class Utilities {\n		public static class Debug {\n			public static boolean LOCAL = System.getProperty(""ONLINE_JUDGE"")==null;\n\n			public static <T> String ts(T t) {\n				if(t==null) {\n					return ""null"";\n				}\n				try {\n					return ts((Iterable) t);\n				}catch(ClassCastException e) {\n					if(t instanceof int[]) {\n						String s = Arrays.toString((int[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof long[]) {\n						String s = Arrays.toString((long[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof char[]) {\n						String s = Arrays.toString((char[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof double[]) {\n						String s = Arrays.toString((double[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof boolean[]) {\n						String s = Arrays.toString((boolean[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}\n					try {\n						return ts((Object[]) t);\n					}catch(ClassCastException e1) {\n						return t.toString();\n					}\n				}\n			}\n\n			private static <T> String ts(T[] arr) {\n				StringBuilder ret = new StringBuilder();\n				ret.append(""{"");\n				boolean first = true;\n				for(T t: arr) {\n					if(!first) {\n						ret.append("", "");\n					}\n					first = false;\n					ret.append(ts(t));\n				}\n				ret.append(""}"");\n				return ret.toString();\n			}\n\n			private static <T> String ts(Iterable<T> iter) {\n				StringBuilder ret = new StringBuilder();\n				ret.append(""{"");\n				boolean first = true;\n				for(T t: iter) {\n					if(!first) {\n						ret.append("", "");\n					}\n					first = false;\n					ret.append(ts(t));\n				}\n				ret.append(""}"");\n				return ret.toString();\n			}\n\n			public static void dbg(Object... o) {\n				if(LOCAL) {\n					System.err.print(""Line #""+Thread.currentThread().getStackTrace()[2].getLineNumber()+"": ["");\n					for(int i = 0; i<o.length; i++) {\n						if(i!=0) {\n							System.err.print("", "");\n						}\n						System.err.print(ts(o[i]));\n					}\n					System.err.println(""]"");\n				}\n			}\n\n		}\n\n	}\n}\n\n","data structures,dsu,graphs,hashing"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1166F {\n	static HashMap[] mm;\n	static HashSet[] ss;\n	static int[] dsu;\n	static void add(int i, int c, int j) {\n		HashMap<Integer, Integer> map = mm[i];\n		int j_ = map.getOrDefault(c, -1);\n		if (j_ == -1)\n			map.put(c, j);\n		else\n			join(j_, j);\n	}\n	static void link(int i, int j, int c) {\n		HashSet<Integer> si = ss[find(i)];\n		si.add(j);\n		HashSet<Integer> sj = ss[find(j)];\n		sj.add(i);\n		add(i, c, j);\n		add(j, c, i);\n	}\n	static int find(int i) {\n		return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));\n	}\n	static void join(int i, int j) {\n		i = find(i);\n		j = find(j);\n		if (i == j)\n			return;\n		HashSet<Integer> s, t;\n		if (ss[i].size() <= ss[j].size()) {\n			s = ss[i]; t = ss[j];\n		} else {\n			s = ss[j]; t = ss[i];\n		}\n		for (int x : s)\n			t.add(x);\n		if (dsu[i] > dsu[j]) {\n			dsu[i] = j;\n			ss[j] = t;\n		} else {\n			if (dsu[i] == dsu[j])\n				dsu[i]--;\n			dsu[j] = i;\n			ss[i] = t;\n		}\n	}\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter pw = new PrintWriter(System.out);\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int n = Integer.parseInt(st.nextToken());\n		int m = Integer.parseInt(st.nextToken());\n		int q = Integer.parseInt(st.nextToken());\n		q = Integer.parseInt(st.nextToken());\n		mm = new HashMap[n];\n		ss = new HashSet[n];\n		for (int i = 0; i < n; i++) {\n			mm[i] = new HashMap<Integer, Integer>();\n			ss[i] = new HashSet<Integer>();\n		}\n		dsu = new int[n];\n		Arrays.fill(dsu, -1);\n		for (int h = 0; h < m; h++) {\n			st = new StringTokenizer(br.readLine());\n			int i = Integer.parseInt(st.nextToken()) - 1;\n			int j = Integer.parseInt(st.nextToken()) - 1;\n			int c = Integer.parseInt(st.nextToken());\n			link(i, j, c);\n		}\n		while (q-- > 0) {\n			st = new StringTokenizer(br.readLine());\n			String tp = st.nextToken();\n			int i = Integer.parseInt(st.nextToken()) - 1;\n			int j = Integer.parseInt(st.nextToken()) - 1;\n			if (tp.charAt(0) == '+') {\n				int c = Integer.parseInt(st.nextToken());\n				link(i, j, c);\n			} else {\n				boolean yes = false;\n				int i_ = find(i);\n				int j_ = find(j);\n				if (i_ == j_)\n					yes = true;\n				else {\n					HashSet<Integer> set = ss[i_];\n					if (set.contains(j))\n						yes = true;\n				}\n				pw.println(yes ? ""Yes"" : ""No"");\n			}\n		}\n		pw.close();\n	}\n}\n","data structures,dsu,graphs,hashing"
"import javax.smartcardio.ATR;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static int n;\n    static HashMap<Integer,Integer> gr[];\n    static HashSet<Integer> p[];\n    static dsu lol;\n    static void union(int a, int b) {\n        a = lol.get(a);\n        b = lol.get(b);\n        if (p[a].size() > p[b].size()) {\n            int t = a;\n            a = b;\n            b = t;\n        }\n        lol.union(a, b);\n        if (a != b) {\n            for (int color : p[a]) {\n                p[b].add(color);\n            }\n            p[a].clear();\n        }\n    }\n    static void set(int a, int b, int c) {\n        if (gr[a].get(c) != null) {\n            union(gr[a].get(c), b);\n        }\n        if (gr[b].get(c) != null) {\n            union(gr[b].get(c), a);\n        }\n        p[lol.get(b)].add(a);\n        p[lol.get(a)].add(b);\n        gr[a].put(c, b);\n        gr[b].put(c, a);\n    }\n    public static void main(String[] args) throws IOException {\n        Locale.setDefault(Locale.US);\n        br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        n = nextInt();\n        lol = new dsu(n);\n        int m = nextInt();\n        nextInt();\n        int q = nextInt();\n        gr = new HashMap[n];\n        p = new HashSet[n];\n        for(int i = 0;i < n;i++) {\n            gr[i] = new HashMap<>();\n            p[i] = new HashSet<>();\n            p[i].add(i);\n        }\n        for(int i = 0;i < m;i++) {\n            int x = nextInt() - 1;\n            int y = nextInt() - 1;\n            int c1 = nextInt();\n            set(x, y, c1);\n        }\n        for(int i = 0;i < q;i++) {\n            String s = next();\n            if (s.equals(""+"")) {\n                set(nextInt() - 1, nextInt() - 1, nextInt());\n            }else{\n                int a = nextInt() - 1;\n                int b = nextInt() - 1;\n                if (p[lol.get(a)].contains(b)) pw.println(""Yes"");\n                else pw.println(""No"");\n            }\n        }\n        pw.close();\n    }\n\n    static BufferedReader br;\n    static StringTokenizer st = new StringTokenizer("""");\n\n    public static int nextInt() throws IOException {\n        if (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return Integer.parseInt(st.nextToken());\n    }\n\n    public static long nextLong() throws IOException {\n        if (!st.hasMoreTokens()) {\n            st = new StringTokenizer((br.readLine()));\n        }\n        return Long.parseLong(st.nextToken());\n    }\n\n    public static double nextDouble() throws IOException {\n        if (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return Double.parseDouble(st.nextToken());\n    }\n\n    public static String next() throws IOException {\n        if (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n}\nclass dsu {\n    int parent[];\n    dsu(int n) {\n        parent = new int [n];\n        for(int i = 0;i < n;i++) parent[i] = i;\n    }\n    int get(int a) {\n        int p = a;\n        while(a != parent[a]) a = parent[a];\n        while(a != p) {\n            int t = parent[p];\n            parent[p] = a;\n            p = t;\n        }\n        return a;\n    }\n    void union(int a, int b) {\n        parent[get(a)] = get(b);\n    }\n}","data structures,dsu,graphs,hashing"
"import java.awt.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    private boolean eof;\n    private BufferedReader br;\n    private StringTokenizer st;\n    private PrintWriter out;\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n\n    private String nextToken() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                eof = true;\n                return ""-1"";\n            }\n        }\n        return st.nextToken();\n    }\n\n    private int nextInt() {\n        return Integer.parseInt(nextToken());\n    }\n\n    private long nextLong() {\n        return Long.parseLong(nextToken());\n    }\n\n    private double nextDouble() {\n        return Double.parseDouble(nextToken());\n    }\n\n    private String nextLine() throws IOException {\n        return br.readLine();\n    }\n\n\n    private void run() throws IOException {\n        InputStream input = System.in;\n        PrintStream output = System.out;\n        try {\n            File f = new File(""a.in"");\n            if (f.exists() && f.canRead()) {\n                input = new FileInputStream(f);\n                output = new PrintStream(""a.out"");\n            }\n        } catch (Throwable ignored) {\n        }\n        br = new BufferedReader(new InputStreamReader(input));\n        out = new PrintWriter(new PrintWriter(output));\n        solve();\n        br.close();\n        out.close();\n    }\n\n\n    DSU dsu = new DSU();\n    ArrayList<HashMap<Integer, Integer>> roads = new ArrayList<>();\n\n    private void solve() {\n        int n = nextInt();\n        int m = nextInt();\n        int c = nextInt();\n        int q = nextInt();\n\n        for (int i = 0; i <= n; i++) {\n            roads.add(new HashMap<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int x = nextInt();\n            int y = nextInt();\n            int color = nextInt();\n            addEdge(x, y, color);\n        }\n\n        for (int i = 0; i < q; i++) {\n            char cmd = nextToken().charAt(0);\n            int x = nextInt();\n            int y = nextInt();\n            if (cmd == '+') {\n                int color = nextInt();\n                addEdge(x, y, color);\n            } else {\n                if (dsu.getRoot(x) == dsu.getRoot(y) || dsu.getSet(x).contains(y)) {\n                    out.println(""Yes"");\n                } else {\n                    out.println(""No"");\n                }\n            }\n        }\n\n\n    }\n\n    public void addEdge(int x, int y, int color) {\n//        boolean f = false;\n        if (roads.get(x).containsKey(color)) {\n            dsu.union(roads.get(x).get(color), y);\n            dsu.getSet(y).remove(roads.get(x).get(color));\n//            f = true;\n        }\n        if (roads.get(y).containsKey(color)) {\n            dsu.union(roads.get(y).get(color), x);\n            dsu.getSet(x).remove(roads.get(y).get(color));\n//            f = true;\n        }\n        roads.get(x).put(color, y);\n        roads.get(y).put(color, x);\n//        if (!f) {\n            dsu.getSet(y).add(x);\n            dsu.getSet(x).add(y);\n//        }\n    }\n\n    public static class DSU {\n        public HashMap<Integer, Integer> parent = new HashMap<>();\n        public HashMap<Integer, Integer> rank = new HashMap<>();\n        public HashMap<Integer, HashSet<Integer>> sets = new HashMap<>();\n\n        DSU() {\n        }\n\n        public HashSet<Integer> getSet(int v) {\n            v = getRoot(v);\n            if (!sets.containsKey(v)) {\n                sets.put(v, new HashSet<>());\n            }\n            return sets.get(v);\n        }\n\n        public int getRoot(int i) {\n            if (parent.getOrDefault(i, i) != i) {\n                int root = getRoot(parent.getOrDefault(i, i));\n                parent.put(i, root);\n            }\n            return parent.getOrDefault(i, i);\n        }\n\n        public void union(int i, int j) {\n            int rootI = getRoot(i);\n            int rootJ = getRoot(j);\n            if (rootI == rootJ) return;\n            if (getSet(rootI).size() > getSet(rootJ).size()) {\n                int c = rootI;\n                rootI = rootJ;\n                rootJ = c;\n            }\n            getSet(rootJ).addAll(getSet(rootI));\n            parent.put(rootI, rootJ);\n//            if (rank.getOrDefault(rootI, 1) < rank.getOrDefault(rootJ, 1)) {\n//                parent.put(rootI, rootJ);\n//                //////\n//                getSet(rootI).addAll(getSet(rootJ));\n//            } else {\n//                if (rank.getOrDefault(rootI, 1).equals(rank.getOrDefault(rootJ, 1))) {\n//                    parent.put(rootI, rootJ);\n//                    rank.put(rootJ, rank.getOrDefault(rootJ, 1) + 1);\n//                    //////\n//                    getSet(rootI).addAll(getSet(rootJ));\n//                } else {\n//                    parent.put(rootJ, rootI);\n//                    //////\n//                    getSet(rootJ).addAll(getSet(rootI));\n//                }\n//            }\n        }\n    }\n}\n","data structures,dsu,graphs,hashing"
"import java.io.*;\nimport java.util.*;\n\npublic class Main{\n	static int[] kmpPreprocess(int m,char[]P) {\n		int[]b=new int[m+1];\n		int i = 0, j = -1; b[0] = -1;\n		while (i < m) {\n			while (j >= 0 && P[i] != P[j]) j = b[j];\n			i++; j++;\n			b[i] = j;\n		} \n		return b;\n	}\n	\n	static byte[][] kmp(int m,char[]P,int[]b) {\n		byte[][]nxt=new byte[m+1][26];\n		for(int idx=0;idx<=m;idx++) {\n			for(int c=0;c<26;c++) {\n				if(idx==0) {\n					nxt[idx][c]=(byte)((P[idx]-'a')==c?1:0);\n				}\n				else {\n					if(idx==m) {\n						nxt[idx][c]=nxt[b[idx]][c];\n					}\n					else {\n						nxt[idx][c]=(byte)((P[idx]-'a')==c?(idx+1):nxt[b[idx]][c]);\n					}\n				}\n			}\n			\n		}\n		return nxt;\n	}\n	static char[]in,s,t;\n	static byte[][]nxtS,nxtT;\n	static Integer[][][]memo;\n	static int match(byte idxs,byte idxt) {\n		return (idxs==s.length?1:0)-(idxt==t.length?1:0);\n	}\n	static int dp(int i,byte idxs,byte idxt) {\n		if(i>=in.length)return match(idxs, idxt);\n		if(memo[i][idxs][idxt]!=null)return memo[i][idxs][idxt];\n		if(in[i]!='*') {\n			return memo[i][idxs][idxt]=dp(i+1, nxtS[idxs][in[i]-'a'], nxtT[idxt][in[i]-'a'])+match(idxs, idxt);\n		}\n		int ans=-1001;\n		for(int c=0;c<26;c++) {\n			ans=Math.max(ans, match(idxs, idxt)+dp(i+1, nxtS[idxs][c], nxtT[idxt][c]));\n		}\n		return memo[i][idxs][idxt]=ans;\n	}\n	static void main() throws Exception{\n		in=sc.nextLine().toCharArray();\n		s=sc.nextLine().toCharArray();\n		t=sc.nextLine().toCharArray();\n		\n		int[]bS=kmpPreprocess(s.length, s),bT=kmpPreprocess(t.length, t);\n		nxtS=kmp(s.length, s, bS);\n		nxtT=kmp(t.length, t, bT);\n		\n		memo=new Integer[in.length][s.length+1][t.length+1];\n		\n		pw.println(dp(0, (byte)0, (byte)0));\n	}\n	public static void main(String[] args) throws Exception{\n		pw=new PrintWriter(System.out);\n		sc = new MScanner(System.in);\n		main();\n		pw.flush();\n	}\n	static PrintWriter pw;\n	static MScanner  sc;\n	static class MScanner {\n		StringTokenizer st;\n		BufferedReader br;\n		public MScanner(InputStream system) {\n			br = new BufferedReader(new InputStreamReader(system));\n		}\n \n		public MScanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n \n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n		public int[] intArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public long[] longArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public int[] intSortedArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		public long[] longSortedArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		public Integer[] IntegerArr(int n) throws IOException {\n	        Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public Long[] LongArr(int n) throws IOException {\n	        Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n \n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n \n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n \n		public char nextChar() throws IOException {\n			return next().charAt(0);\n		}\n \n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n \n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n \n		public void waitForInput() throws InterruptedException {\n			Thread.sleep(3000);\n		}\n	}\n	static void shuffle(int[]in) {\n		for(int i=0;i<in.length;i++) {\n			int idx=(int)(Math.random()*in.length);\n			int tmp=in[i];\n			in[i]=in[idx];\n			in[idx]=tmp;\n		}\n	}\n	static void shuffle(long[]in) {\n		for(int i=0;i<in.length;i++) {\n			int idx=(int)(Math.random()*in.length);\n			long tmp=in[i];\n			in[i]=in[idx];\n			in[idx]=tmp;\n		}\n	}\n}","dp,strings"
"import java.io.*;\nimport java.util.*;\n\npublic class Main{\n	static int[] kmpPreprocess(int m,char[]P) {\n		int[]b=new int[m+1];\n		int i = 0, j = -1; b[0] = -1;\n		while (i < m) {\n			while (j >= 0 && P[i] != P[j]) j = b[j];\n			i++; j++;\n			b[i] = j;\n		} \n		return b;\n	}\n	\n	static byte[][] kmp(int m,char[]P,int[]b) {\n		byte[][]nxt=new byte[m+1][26];\n		for(int idx=0;idx<=m;idx++) {\n			for(int c=0;c<26;c++) {\n				if(idx==0) {\n					nxt[idx][c]=(byte)((P[idx]-'a')==c?1:0);\n				}\n				else {\n					if(idx==m) {\n						nxt[idx][c]=nxt[b[idx]][c];\n					}\n					else {\n						nxt[idx][c]=(byte)((P[idx]-'a')==c?(idx+1):nxt[b[idx]][c]);\n					}\n				}\n			}\n			\n		}\n		return nxt;\n	}\n	static char[]in,s,t;\n	static byte[][]nxtS,nxtT;\n	static int[][][]memo;\n	static int match(byte idxs,byte idxt) {\n		return (idxs==s.length?1:0)-(idxt==t.length?1:0);\n	}\n	static int dp(int i,byte idxs,byte idxt) {\n		if(i>=in.length)return match(idxs, idxt);\n		if(memo[i][idxs][idxt]!=-1002)return memo[i][idxs][idxt];\n		if(in[i]!='*') {\n			return memo[i][idxs][idxt]=dp(i+1, nxtS[idxs][in[i]-'a'], nxtT[idxt][in[i]-'a'])+match(idxs, idxt);\n		}\n		int ans=-1001;\n		for(int c=0;c<26;c++) {\n			ans=Math.max(ans, match(idxs, idxt)+dp(i+1, nxtS[idxs][c], nxtT[idxt][c]));\n		}\n		return memo[i][idxs][idxt]=ans;\n	}\n	static void main() throws Exception{\n		in=sc.nextLine().toCharArray();\n		s=sc.nextLine().toCharArray();\n		t=sc.nextLine().toCharArray();\n		\n		int[]bS=kmpPreprocess(s.length, s),bT=kmpPreprocess(t.length, t);\n		nxtS=kmp(s.length, s, bS);\n		nxtT=kmp(t.length, t, bT);\n		\n		memo=new int[in.length][s.length+1][t.length+1];\n		for(int i=0;i<in.length;i++) {\n			for(int j=0;j<=s.length;j++) {\n				for(int k=0;k<=t.length;k++) {\n					memo[i][j][k]=-1002;\n				}\n			}\n		}\n		pw.println(dp(0, (byte)0, (byte)0));\n	}\n	public static void main(String[] args) throws Exception{\n		pw=new PrintWriter(System.out);\n		sc = new MScanner(System.in);\n		main();\n		pw.flush();\n	}\n	static PrintWriter pw;\n	static MScanner  sc;\n	static class MScanner {\n		StringTokenizer st;\n		BufferedReader br;\n		public MScanner(InputStream system) {\n			br = new BufferedReader(new InputStreamReader(system));\n		}\n \n		public MScanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n \n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n		public int[] intArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public long[] longArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public int[] intSortedArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		public long[] longSortedArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		public Integer[] IntegerArr(int n) throws IOException {\n	        Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public Long[] LongArr(int n) throws IOException {\n	        Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n \n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n \n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n \n		public char nextChar() throws IOException {\n			return next().charAt(0);\n		}\n \n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n \n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n \n		public void waitForInput() throws InterruptedException {\n			Thread.sleep(3000);\n		}\n	}\n	static void shuffle(int[]in) {\n		for(int i=0;i<in.length;i++) {\n			int idx=(int)(Math.random()*in.length);\n			int tmp=in[i];\n			in[i]=in[idx];\n			in[idx]=tmp;\n		}\n	}\n	static void shuffle(long[]in) {\n		for(int i=0;i<in.length;i++) {\n			int idx=(int)(Math.random()*in.length);\n			long tmp=in[i];\n			in[i]=in[idx];\n			in[idx]=tmp;\n		}\n	}\n}","dp,strings"
"import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\n// fail\n\npublic class cf1163d {\n\n    public static void main(String[] args) throws IOException {\n        char[] c = rcha(), s = rcha(), t = rcha();\n        /* if (kmp(s, t).size() != 0) {\n            prln(kmp(c, s).size() - kmp(c, t).size());\n            close();\n            return;\n        } */\n        int n = c.length, m = s.length, r = t.length, dp[][][] = new int[n + 1][m + 1][r + 1], pi_s[] = pi(s), pi_t[] = pi(t), nxt_s[][] = new int[m + 1][26], nxt_t[][] = new int[r + 1][26];\n        for (int[][] layer : dp) {\n            for (int[] row : layer) {\n                fill(row, -IBIG);\n            }\n        }\n        nxt_s[0][s[0] - 'a'] = 1;\n        for (int i = 1; i <= m; ++i) {\n            for (char ch = 'a'; ch <= 'z'; ++ch) {\n                int cur = i;\n                while (cur != 0 && (cur == m || ch != s[cur])) {\n                    cur = pi_s[cur - 1];\n                }\n                if (ch == s[cur]) {\n                    ++cur;\n                }\n                nxt_s[i][ch - 'a'] = cur;\n            }\n        }\n        nxt_t[0][t[0] - 'a'] = 1;\n        for (int i = 1; i <= r; ++i) {\n            for (char ch = 'a'; ch <= 'z'; ++ch) {\n                int cur = i;\n                while (cur != 0 && (cur == r || ch != t[cur])) {\n                    cur = pi_t[cur - 1];\n                }\n                if (ch == t[cur]) {\n                    ++cur;\n                }\n                nxt_t[i][ch - 'a'] = cur;\n            }\n        }\n        dp[0][0][0] = 0;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= m; ++j) {\n                for (int k = 0; k <= r; ++k) {\n                    if (dp[i][j][k] != -IBIG) {\n                        for (char ch = 'a'; ch <= 'z'; ++ch) {\n                            if (c[i] == '*' || c[i] == ch) {\n                                int nxt_j = nxt_s[j][ch - 'a'], nxt_k = nxt_t[k][ch - 'a'];\n                                dp[i + 1][nxt_j][nxt_k] = max(dp[i + 1][nxt_j][nxt_k], dp[i][j][k] + (nxt_j == m ? 1 : 0) - (nxt_k == r ? 1: 0));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /* for (int[][] layer : dp) {\n            for (int[] row : layer) {\n                prln(row);\n            }\n            prln();\n        } */\n        int ans = -IBIG;\n        for (int[] row : dp[n]) {\n            ans = max(ans, maxof(row));\n        }\n        prln(ans);\n        close();\n    }\n\n    // pi[i] = longest proper prefix that is also a suffix of s[:i + 1]\n    static int[] pi(char[] s) {\n        int len = 0, i = 1, pi[] = new int[s.length];\n        while (i < s.length) {\n            if (s[i] == s[len]) {\n                pi[i++] = ++len;\n            } else if (len != 0) {\n                len = pi[len - 1];\n            } else {\n                pi[i++] = len;\n            }\n        }\n        return pi;\n    }\n\n    // kmp(str, pattern) returns indices of matches (ind of 1st char)\n    static List<Integer> kmp(char[] str, char[] pat) {\n        List<Integer> ans = new ArrayList<>();\n        int len = 0, i = 1, j = 0, lps[] = new int[pat.length];\n        while (i < pat.length) {\n            if (pat[i] == pat[len]) {\n                lps[i++] = ++len;\n            } else if (len != 0) {\n                len = lps[len - 1];\n            } else {\n                lps[i++] = len;\n            }\n        }\n        i = 0;\n        while (i < str.length) {\n            if (str[i] == pat[j]) {\n                ++i;\n                ++j;\n            }\n            if (j == pat.length) {\n                ans.add(i - j);\n                j = lps[j - 1];\n            } else if (i < str.length && str[i] != pat[j]) {\n                if (j == 0) {\n                    ++i;\n                } else {\n                    j = lps[j - 1];\n                }\n            }\n        }\n        return ans;\n    }\n\n    static BufferedReader __i = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __o = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __r = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final long LMAX = 9223372036854775807L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int[] exgcd(int a, int b) {if (b == 0) return new int[] {1, 0}; int[] y = exgcd(b, a % b); return new int[] {y[1], y[0] - y[1] * (a / b)};}\n    static long[] exgcd(long a, long b) {if (b == 0) return new long[] {1, 0}; long[] y = exgcd(b, a % b); return new long[] {y[1], y[0] - y[1] * (a / b)};}\n    static int randInt(int min, int max) {return __r.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __i.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__o.print(i);}\n    static void prln(int i) {__o.println(i);}\n    static void pr(long l) {__o.print(l);}\n    static void prln(long l) {__o.println(l);}\n    static void pr(double d) {__o.print(d);}\n    static void prln(double d) {__o.println(d);}\n    static void pr(char c) {__o.print(c);}\n    static void prln(char c) {__o.println(c);}\n    static void pr(char[] s) {__o.print(new String(s));}\n    static void prln(char[] s) {__o.println(new String(s));}\n    static void pr(String s) {__o.print(s);}\n    static void prln(String s) {__o.println(s);}\n    static void pr(Object o) {__o.print(o);}\n    static void prln(Object o) {__o.println(o);}\n    static void prln() {__o.println();}\n    static void pryes() {prln(""yes"");}\n    static void pry() {prln(""Yes"");}\n    static void prY() {prln(""YES"");}\n    static void prno() {prln(""no"");}\n    static void prn() {prln(""No"");}\n    static void prN() {prln(""NO"");}\n    static boolean pryesno(boolean b) {prln(b ? ""yes"" : ""no""); return b;};\n    static boolean pryn(boolean b) {prln(b ? ""Yes"" : ""No""); return b;}\n    static boolean prYN(boolean b) {prln(b ? ""YES"" : ""NO""); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(""hlfd""); flush();}\n    static void flush() {__o.flush();}\n    static void close() {__o.close();}\n}","dp,strings"
"import java.util.*;\nimport java.io.*;\n\npublic class Main {\n	public static void main(String args[]) { new Main().WORK(); }\n	\n	Scanner in = new Scanner(System.in);\n	PrintWriter out = new PrintWriter(System.out);\n	\n	final int INF = 0x3f3f3f3f;\n	\n	char[][] s = new char[3][];\n	int[][] f = new int[3][55];\n	int[][][] dp = new int[1010][55][55];\n	\n	void getFail(char[] s, int[] f) {\n		int n = s.length;\n		f[0] = f[1] = 0;\n		for(int i = 1; i < n; i++) {\n			int j = f[i];\n			while(j!=0 && s[j]!=s[i]) j = f[j];\n			f[i+1] = s[j]==s[i]?j+1:0;\n		}\n	}\n	\n	int dfs(int i, int j, int k) {\n		if(i == s[0].length) return 0;\n		if(dp[i][j][k] != -INF) return dp[i][j][k];\n		char st = 'a', ed = 'z';\n		if(s[0][i] != '*') st = ed = s[0][i];\n		for(char c = st; c <= ed; c++) {\n			int x = j, y = k;\n			for(; x!=0 && s[1][x+1]!=c; x = f[1][x]);\n			if(s[1][x+1] == c) x++;\n			for(; y!=0 && s[2][y+1]!=c; y = f[2][y]);\n			if(s[2][y+1] == c) y++;\n			int tmp = 0;\n			if(x == s[1].length-1) { x = f[1][x]; tmp++; }\n			if(y == s[2].length-1) { y = f[2][y]; tmp--; }\n			dp[i][j][k] = Math.max(dp[i][j][k], dfs(i+1, x, y)+tmp);\n		}\n		return dp[i][j][k];\n	}\n	\n	void WORK() {\n		for(int i = 0; i < 3; i++) s[i] = in.next().toCharArray();\n		getFail(s[1], f[1]); getFail(s[2], f[2]);\n		s[1] = (""A""+String.valueOf(s[1])).toCharArray();\n		s[2] = (""A""+String.valueOf(s[2])).toCharArray();\n		for(int a[][]:dp) for(int b[]:a) Arrays.fill(b, -INF);\n		out.println(dfs(0, 0, 0));\n		out.flush();\n	}\n}","dp,strings"
"import java.util.*;\npublic class class293 {\npublic static void main(String arg[])\n{\n	Scanner sc=new Scanner(System.in);\n	int n=sc.nextInt();\n	\n	int i,min=Integer.MAX_VALUE;\n	int ind=0;\n	for(i=0;i<n;i++)\n	{\n		int a=sc.nextInt();\n		min=Math.min(min,a/Math.max(i, n-1-i));\n		}\n	System.out.println(min);\n	\n	\n}\n}\n","implementation,math"
"import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int min=Integer.MAX_VALUE;\n        for(int i=0;i<n;i++){\n            int a=sc.nextInt();\n            min=Math.min(min,a/Math.max(i,n-i-1));\n        }\n        System.out.println(min);\n    }\n}","implementation,math"
"import java.util.*;\npublic class cf559div2B {\npublic static void main(String[] args) {\nScanner sc=new Scanner(System.in);\nint n=sc.nextInt();\nint arr[]=new int[n];\nint min=Integer.MAX_VALUE;int left=Integer.MAX_VALUE;int right=Integer.MAX_VALUE;\nfor(int i=0;i<n;i++)\n{arr[i]=sc.nextInt();\nif(i>0)\nleft=arr[i]/i;\nif(i<n-1)\nright=arr[i]/(n-1-i);\nmin=Math.min(min,Math.min(left,right));\n}\nSystem.out.println(min);\nsc.close();   \n}    \n}","implementation,math"
"import java.util.*;\npublic class cf559div2B {\npublic static void main(String[] args) {\nScanner sc=new Scanner(System.in);\nint n=sc.nextInt();\nint arr[]=new int[n];\nint min=Integer.MAX_VALUE;int left=Integer.MAX_VALUE;int right=Integer.MAX_VALUE;\nfor(int i=0;i<n;i++)\n{arr[i]=sc.nextInt();\nif(i>0)\nleft=arr[i]/i;\nif(i<n-1)\nright=arr[i]/(n-1-i);\nmin=Math.min(min,Math.min(left,right));\n}\nSystem.out.println(min);\nsc.close();   \n}    \n}","implementation,math"
"import java.util.*;\nimport java.io.*;\n\npublic class C {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		\n		int n = sc.nextInt();\n		int[] a = new int[n];\n		for(int i = 0; i < n; i++) {\n			a[i] = sc.nextInt();\n		}\n		int l = 0, r = n-1;\n		ArrayList<Character> ans = new ArrayList<Character>();\n		int last = 0;\n		while(l <= r) {\n			if(a[l] > last && a[r] > last) {\n				if(a[l] < a[r]) {\n					ans.add('L');\n					last = a[l];\n					l++;\n				} else {\n					ans.add('R');\n					last = a[r];\n					r--;\n				}\n			} else if(a[l] > last){\n				ans.add('L');\n				last = a[l];\n				l++;\n			} else if(a[r] > last) {\n				ans.add('R');\n				last = a[r];\n				r--;\n			} else {\n				break;\n			}\n		}\n		System.out.println(ans.size());\n		for(int i = 0; i < ans.size(); i++) {\n			System.out.print(ans.get(i));\n		}\n	}\n}",greedy
"import java.util.*;\n\npublic class subsequenceeasy\n{\n	public static void main(String args[])\n	{\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int a[] = new int[n];\n		char ans[] = new char[n];\n		for(int i=0;i<n;i++)\n			a[i] = sc.nextInt();\n		int l=0,r=n-1;\n		int min=0;\n		int temp=0;\n		int count=0;\n		while(r>=l)\n		{\n			min = Math.min(a[l],a[r]);\n			if(temp>min)\n			{\n				if(a[l]>temp)\n				{\n					temp=a[l];\n					l++;\n					ans[count]='L';\n				}\n				else \n				{\n					if(temp>a[r]) break;\n					else\n					{\n						temp=a[r];\n						r--;\n						ans[count]='R';\n					}\n				}\n			}\n			else\n			{\n				if(min==a[l])\n				{\n					temp = a[l];\n					l++;\n					ans[count]='L';\n				}\n				else\n				{\n					temp=a[r];\n					r--;\n					ans[count]='R';\n				}\n			}\n			count++;\n		}\n		System.out.println(count);\n		for(int i=0;i<count;i++)\n			System.out.print(ans[i]);\n	}\n}",greedy
"import java.util.Scanner;\n\n\npublic class C555 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n\n        int last = 0;\n        StringBuilder moves = new StringBuilder();\n        int res = 0;\n        int left = 0;\n        int right = n - 1;\n        while(left <= right) {\n            if(a[left] > last && a[left] < a[right]) {\n                last = a[left++];\n                moves.append(""L"");\n            } else if (a[right] > last) {\n                last = a[right--];\n                moves.append(""R"");\n            } else if(a[left] > last) {\n                last = a[left++];\n                moves.append(""L"");\n            } else {\n                break;\n            }\n            res++;\n        }\n\n        System.out.println(res);\n        System.out.println(moves.toString());\n    }\n}\n",greedy
"import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int a[]=new int[n];\n        for(int i=0;i<n;i++)\n        a[i]=sc.nextInt();\n        StringBuilder sb=new StringBuilder();\n        int prev=0;\n        int result=0;\n        int low=0;\n        int high=n-1;\n        while(low<=high) {\n            if(a[low]>prev && a[high]>prev) {\n                if(a[low]<a[high]) {\n                    sb.append(""L"");\n                    prev=a[low];\n                    low++;\n                }\n                else \n                {\n                    sb.append(""R"");\n                    prev=a[high];\n                    high--;\n                }\n            }\n            else if(a[high]>prev) {\n                sb.append(""R"");\n                    prev=a[high];\n                    high--;\n            }\n            else if(a[low]>prev) {\n                sb.append(""L"");\n                    prev=a[low];\n                    low++;\n            }\n            else \n            break;\n            result++;\n        }\n        System.out.println(result);\n        System.out.println(sb.toString());\n    }\n}",greedy
"// upsolve with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1153F {\n	static final int MD = 998244353;\n	static int[][] ch;\n	static void init(int n) {\n		ch = new int[1 + n][1 + n];\n		ch[0][0] = 1;\n		for (int i = 1; i <= n; i++) {\n			ch[i][0] = 1;\n			for (int j = 1; j <= i; j++)\n				ch[i][j] = (ch[i - 1][j] + ch[i - 1][j - 1]) % MD;\n		}\n	}\n	static long power(int a, int k) {\n		if (k == 0)\n			return 1;\n		long p = power(a, k / 2);\n		p = p * p % MD;\n		if (k % 2 == 1)\n			p = p * a % MD;\n		return p;\n	}\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int n = Integer.parseInt(st.nextToken());\n		int k = Integer.parseInt(st.nextToken());\n		int l = Integer.parseInt(st.nextToken());\n		init(n);\n		long[] pp = new long[1 + n + n];\n		long[] qq = new long[1 + n + n];\n		pp[n] = power(2, n);\n		for (int i = 0; i < n; i++)\n			for (int j = n + n; j > 0; j--)\n				pp[j] = (pp[j] - pp[j - 1]) % MD;\n		long[] aa = new long[1 + n + n];\n		for (int j = 0; j <= n + n; j++)\n			aa[j] = pp[j];\n		long inv2 = (MD + 1) / 2;\n		for (int i = 1; i <= n - k; i++) {\n			// qq := pp / p, where p = 2x (1 - x)\n			// divide by 2x\n			for (int j = 0; j < n + n; j++)\n				qq[j] = pp[j + 1] * inv2 % MD;\n			qq[n + n] = 0;\n			// divide by 1 - x is multiply by 1 + x + x^2 + x^3 + ...\n			for (int j = 1; j <= n + n; j++)\n				qq[j] = (qq[j] + qq[j - 1]) % MD;\n			// pp := pp * (1 - p) / p = pp / p - pp = qq - pp\n			for (int j = 0; j <= n + n; j++)\n				pp[j] = (qq[j] - pp[j]) % MD;\n			long a = ch[n][i];\n			for (int j = 0; j <= n + n; j++)\n				aa[j] = (aa[j] + a * pp[j]) % MD;\n		}\n		// integrate x^i to x^{i + 1} / (i + 1)\n		long a = 0;\n		for (int i = 0; i <= n + n; i++)\n			a = (a + aa[i] * power(i + 1, MD - 2)) % MD;\n		a = (a * l % MD + MD) % MD;\n		System.out.println(a);\n	}\n}\n","combinatorics,dp,math,probabilities"
"import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable{\n    public static void main(String[] args){\n        //new Thread(null,new Main(),""Thread-1"",1024*1024*10).start();\n        new Main().run();\n    }\n    int mod=998244353;\n    private void solve() throws Exception {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        int n=in.nextInt(),k=in.nextInt(),l=in.nextInt();\n        long[]fac=new long[n+1];\n        fac[0]=1;\n        for(int i=1;i<=n;i++){\n            fac[i]=fac[i-1]*i%mod;\n        }\n        long[][]dp=new long[2*n+1][2*n+2];\n        dp[0][0]=1;\n        for(int i=1;i<=2*n;i++){\n            for(int j=0;j<=i;j++){\n                if(j>0) dp[i][j]=(dp[i][j]+dp[i-1][j-1])%mod;\n                dp[i][j]=(dp[i][j]+dp[i-1][j+1]*(j+1)%mod)%mod;\n            }\n        }\n        long ans=0;\n        for(int i=k;i<=2*n;i++){\n            for(int j=k;j<=n;j++){\n                ans=(ans+dp[i][j]*dp[2*n-i][j]%mod*fac[j]%mod)%mod;\n            }\n        }\n        out.println(l*ans%mod*Pow(dp[2*n][0],mod-2)%mod*Pow(2*n+1,mod-2)%mod);\n        out.flush();\n    }\n    long Pow(long a,long b){\n        long ans=1;\n        while(b>0){\n            if((b&1)!=0)ans=(ans*a)%mod;\n            a=(a*a)%mod;\n            b>>=1;\n        }\n        return ans;\n    }\n    @Override\n    public void run() {\n        try {\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    class InputReader{\n        StreamTokenizer tokenizer;\n        public InputReader(InputStream stream){\n            tokenizer=new StreamTokenizer(new BufferedReader(new InputStreamReader(stream)));\n            tokenizer.ordinaryChars(33,126);\n            tokenizer.wordChars(33,126);\n        }\n        public String next() throws IOException {\n            tokenizer.nextToken();\n            return tokenizer.sval;\n        }\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n        public boolean hasNext() throws IOException {\n            int res=tokenizer.nextToken();\n            tokenizer.pushBack();\n            return res!=tokenizer.TT_EOF;\n        }\n    }\n}","combinatorics,dp,math,probabilities"
"import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable{\n    public static void main(String[] args){\n        //new Thread(null,new Main(),""Thread-1"",1024*1024*10).start();\n        new Main().run();\n    }\n    int mod=998244353;\n    private void solve() throws Exception {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        int n=in.nextInt(),k=in.nextInt(),l=in.nextInt();\n        long[]fac=new long[n+1];\n        fac[0]=1;\n        for(int i=1;i<=n;i++){\n            fac[i]=fac[i-1]*i%mod;\n        }\n        long[][]dp=new long[2*n+1][2*n+2];\n        dp[0][0]=1;\n        for(int i=1;i<=2*n;i++){\n            for(int j=0;j<=Math.min(i,n);j++){\n                if(j>0) dp[i][j]=(dp[i][j]+dp[i-1][j-1])%mod;\n                dp[i][j]=(dp[i][j]+dp[i-1][j+1]*(j+1)%mod)%mod;\n            }\n        }\n        long ans=0;\n        for(int i=k;i<=2*n;i++){\n            for(int j=k;j<=n;j++){\n                ans=(ans+dp[i][j]*dp[2*n-i][j]%mod*fac[j]%mod)%mod;\n            }\n        }\n        out.println(l*ans%mod*Pow(dp[2*n][0],mod-2)%mod*Pow(2*n+1,mod-2)%mod);\n        out.flush();\n    }\n    long Pow(long a,long b){\n        long ans=1;\n        while(b>0){\n            if((b&1)!=0)ans=(ans*a)%mod;\n            a=(a*a)%mod;\n            b>>=1;\n        }\n        return ans;\n    }\n    @Override\n    public void run() {\n        try {\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    class InputReader{\n        StreamTokenizer tokenizer;\n        public InputReader(InputStream stream){\n            tokenizer=new StreamTokenizer(new BufferedReader(new InputStreamReader(stream)));\n            tokenizer.ordinaryChars(33,126);\n            tokenizer.wordChars(33,126);\n        }\n        public String next() throws IOException {\n            tokenizer.nextToken();\n            return tokenizer.sval;\n        }\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n        public boolean hasNext() throws IOException {\n            int res=tokenizer.nextToken();\n            tokenizer.pushBack();\n            return res!=tokenizer.TT_EOF;\n        }\n    }\n}","combinatorics,dp,math,probabilities"
"import java.io.*;\nimport java.util.*;\n\npublic class Codeforces1153F {\n\n	public static void main(String[] args) throws IOException {\n		int P = 998244353;\n		\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int n = Integer.parseInt(st.nextToken());\n		int real_k = Integer.parseInt(st.nextToken());\n		int l = Integer.parseInt(st.nextToken());\n				\n		//generate factorials\n		int[] factorials = new int[2*n+2];\n		factorials[0] = 1;\n		for (int i = 1; i <= 2*n+1; i++) {\n			factorials[i] = multiply(factorials[i-1], i, P);\n		}\n		\n		//number of ways to choose k pairs from 2k elements\n		//where order doesn't matter\n		//equals (2k)!/(2^n)/k! = (2k-1)!!\n		int[] doublefact = new int[n+1];\n		doublefact[0] = 1;\n		for (int i = 1; i <= n; i++) {\n			doublefact[i] = multiply(doublefact[i-1], (2*i-1), P);\n		}\n\n		//list[r][k] stores for rth segment, exactly k of the n segments covering it \n		int[][] list = new int[2*n+2][n+1];\n		\n		for (int r = 1; r <= 2*n+1; r++) {\n			for (int k = 1; k <= n; k++) {\n				if (((r%2) != (k%2)) && (r-1 >= k) && (2*n+1-r >= k)) {\n					int num = multiply(factorials[r-1], factorials[2*n+1-r], P);\n					num = multiply(num, doublefact[(r-k-1)/2], P);\n					num = multiply(num, doublefact[(2*n+1-r-k)/2], P);\n					\n					int denom = multiply(factorials[r-k-1], factorials[2*n+1-r-k], P);\n					denom = multiply(denom, factorials[k], P);\n										\n					list[r][k] = multiply(num, inverse(multiply(denom, doublefact[n], P), P), P);\n				}\n				\n			}\n		}\n		\n		int ans = 0;\n		for (int r = 1; r <= 2*n+1; r++) {\n			for (int k = real_k; k <= n; k++) {\n				ans += list[r][k];\n				ans %= P;\n			}\n		}\n		\n		ans = multiply(ans, l, P);\n		ans = multiply(ans, inverse(2*n+1, P), P);\n		\n		System.out.println(ans);\n\n	}\n	\n	public static int multiply (int a, int b, int n) {\n		long ab = (long) a * (long) b;\n		return ((int) (ab%n));\n	}\n	\n	public static int inverse (int a, int n) {\n		int m = n;\n		int r1 = 1;\n		int r2 = 0;\n		int r3 = 0;\n		int r4 = 1;\n		while ((a > 0) && (n > 0)) {\n			if (n >= a) {\n				r3 -= r1*(n/a);\n				r4 -= r2*(n/a);\n				n = n%a;\n			}\n			else {\n				int tmp = a;\n				a = n;\n				n = tmp;\n				tmp = r1;\n				r1 = r3;\n				r3 = tmp;\n				tmp = r2;\n				r2 = r4;\n				r4 = tmp;\n			}\n		}\n		if (a == 0) {\n			if (r3 >= 0)\n				return (r3%m);\n			else\n				return (m+(r3%m));\n		}\n		else {\n			if (r1 >= 0)\n				return (r1%m);\n			else\n				return (m+(r1%m));\n		}\n\n	}\n\n}\n","combinatorics,dp,math,probabilities"
"import java.io.*;\nimport java.util.*;\n \npublic class Contest1151E\n{\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        String next() { // reads in the next string\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public int nextInt() { // reads in the next int\n            return Integer.parseInt(next());\n        }\n        public long nextLong() { // reads in the next long\n            return Long.parseLong(next());\n        }\n        public double nextDouble() { // reads in the next double\n            return Double.parseDouble(next());\n            }\n        }\n    static InputReader r = new InputReader(System.in);\n    static PrintWriter pw = new PrintWriter(System.out);\n    static long mod = 1000000007;\n    public static void main(String[] args)\n    {\n    	int t = 1;\n    	while (t > 0)\n    	{\n    		t--;\n    		int n = r.nextInt();\n    		long[] a = new long[n];\n    		for (int i = 0; i < n; i ++)\n    		{\n    			a[i] = r.nextInt();\n    		}\n    		long ans = 0;\n    		for (int i = 0; i < n-1; i ++)\n    		{\n    			if (a[i] <= a[i+1])\n    			{\n    				ans += a[i]*(a[i+1]-a[i]);\n    			}\n    			else\n    			{\n    				ans += (n-a[i]+1)*(a[i]-a[i+1]);\n    			}\n    			//l <= a[i], a[i] <= r < a[i+1]\n    		}\n    		ans += (a[n-1]*(n-a[n-1]+1));\n    		pw.println(ans);\n    	}\n        pw.close();\n    }\n}","combinatorics,data structures,dp,math"
"import java.io.*;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport java.lang.Math;\nimport java.time.format.DateTimeFormatter;  \nimport java.time.LocalDateTime; \n \n \n// CODEFORCES\npublic class main {\n \n	static int cycleNum;\n\n	public static void main(String[] args) {\n		Scanner scanner = new Scanner(System.in);\n		\n		\n		int n = scanner.nextInt();\n		int[] arr = new int[n+1];\n		for (int i = 1; i < arr.length; i++) {\n		    arr[i] = scanner.nextInt();\n		}\n//		int m = scanner.nextInt();\n//		int k = scanner.nextInt();\n//		int q = scanner.nextInt();\n//		int[][] ts = new int[k][2];\n//		int[] cols = new int[q];\n//		\n//		String[] s1 = scanner.nextLine().split("" "");\n//		for (int i = 0; i < k; i++) {\n//		    s1 = scanner.nextLine().split("" "");\n//		    ts[i][0] = Integer.valueOf(s1[0]);\n//		    ts[i][1] = Integer.valueOf(s1[1]);\n//		}\n//		s1 = scanner.nextLine().split("" "");\n//		for (int i = 0; i < q; i++) {\n//		    cols[i] = Integer.valueOf(s1[i]);\n//		}\n//		Arrays.sort(cols);\n//		\n//		String[] s1 = new String[n];\n//		String [] s2 = new String[n];\n//		\n//		s1 = scanner.nextLine().split("" "");\n//		s2 = scanner.nextLine().split("" "");\n		\n//		scanner = new Scanner(System.in);\n//		String[] s = scanner.nextLine().split("" "");\n		\n//	String[] str1 = new String[4];\n//		str1 = scanner.nextLine().split("" "");\n//		String[] str2 = new String[Integer.valueOf(str1[0])];\n//		while(scanner.hasNextLine()){\n//			str2 = scanner.nextLine().split("" "");\n//		}\n		\n//		int[] p = new int[n];\n//		int[] q = new int[n];\n//		for (int i = 0; i < s1.length; i++) {\n//			p[i] = Integer.valueOf(s1[i]);\n//			q[i] = Integer.valueOf(s2[i]);\n//		}\n		\n// 		int n = 10;\n// 		int[] arr = {0,1,5,2,5,5,3,10,6,5,1};\n		long ans = 0;\n		\n		for (int i = 1; i < arr.length; i++) {\n			if (arr[i] == arr[i-1]) { continue; }\n			ans += number(arr[i-1], arr[i], n);\n		}\n		\n		System.out.println(ans);\n		\n 	}\n	\n	static long number(int exclude, int include, int n) {\n		if (exclude < include) {\n			int l = exclude + 1;\n			int r = include;\n			return (long) (r-l+1) * (n-r+1);\n		} else {\n			int r = exclude - 1;\n			int l = include;\n			return (long) (include) * (r-l+1);\n		}\n	}\n	\n	\n	\n}\n	\n \n \n \n \n//List sortedKeys=new ArrayList(trip.keySet());\n//Collections.sort(sortedKeys);","combinatorics,data structures,dp,math"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n \npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n \n    static class TaskE {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int a[] = new int[n + 1];\n            for (int i = 0; i < n; i++) {\n                a[i + 1] = in.readInt();\n            }\n            long r = 0;\n            for (int i = 1; i <= n; i++) {\n                if (a[i] > a[i - 1])\n                    r += (long) (a[i] - a[i - 1]) * (n - a[i] + 1);\n                else\n                    r += (long) a[i] * (a[i - 1] - a[i]);\n            }\n            out.printLine(r);\n        }\n \n    }\n \n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n \n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n \n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n \n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n \n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n \n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n        }\n \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n \n        }\n \n    }\n \n    static class OutputWriter {\n        private final PrintWriter writer;\n \n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n \n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n \n        public void close() {\n            writer.close();\n        }\n \n        public void printLine(long i) {\n            writer.println(i);\n        }\n \n    }\n}\n    	      	   		  		    		  	","combinatorics,data structures,dp,math"
"import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\n// 1:50.856\n\npublic class cf1151e {\n\n    public static void main(String[] args) throws IOException {\n        long n = rl(), a[] = rla((int) n), ans = n * (n + 1) / 2 - (a[0] - 1) * a[0] / 2 - (n - a[0]) * (n - a[0] + 1) / 2;\n        // prln(ans);\n        for (int i = 1; i < n; ++i) {\n            if (a[i] > a[i - 1]) {\n                long delta = a[i] - a[i - 1];\n                ans += (n - a[i - 1]) * (n - a[i - 1] + 1) / 2 - (delta - 1) * delta / 2 - (n - a[i]) * (n - a[i] + 1) / 2;\n            } else if (a[i] < a[i - 1]) {\n                long delta = a[i - 1] - a[i];\n                ans += (a[i - 1] - 1) * a[i - 1] / 2 - (delta - 1) * delta / 2 - (a[i] - 1) * a[i] / 2;\n            }\n            // prln(ans);\n        }\n        prln(ans);\n        close();\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int lcm(int a, int b) {return a * b / gcf(a, b);}\n    static long lcm(long a, long b) {return a * b / gcf(a, b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {prln(""yes"");}\n    static void pry() {prln(""Yes"");}\n    static void prY() {prln(""YES"");}\n    static void prno() {prln(""no"");}\n    static void prn() {prln(""No"");}\n    static void prN() {prln(""NO"");}\n    static boolean pryesno(boolean b) {prln(b ? ""yes"" : ""no""); return b;};\n    static boolean pryn(boolean b) {prln(b ? ""Yes"" : ""No""); return b;}\n    static boolean prYN(boolean b) {prln(b ? ""YES"" : ""NO""); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(""hlfd""); flush();}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}\n}","combinatorics,data structures,dp,math"
"public class p1141C {\n    public static void main(String[] args) {\n        var sc = new java.util.Scanner(System.in);\n        StringBuilder sb=new StringBuilder();\n        int n=sc.nextInt(),a[]=new int[n],pre=0,b[]=new int[n+1];\n        double sum=0;\n        for(int i=1;i<n;i++) {\n            a[i]=sc.nextInt();\n            sum+=a[i]+pre;\n            pre+=a[i];\n        }\n        pre=(int)((n+1)/2.0-sum/n);\n        for(int i:a) {\n            pre+=i;\n            if((pre<1||pre>n)||b[pre]>0) {System.out.println(""-1""); return;}\n            b[pre]++;\n            sb.append(pre+"" "");\n        }System.out.println(sb);\n    }\n}",math
"public class p1141C {\n    public static void main(String[] args) {\n        var sc = new java.util.Scanner(System.in);\n        StringBuilder sb=new StringBuilder();\n        long n=sc.nextInt(),a[]=new long[(int)n],sum=0,pre=0;\n        for(int i=1;i<n;i++) {\n            a[i]=sc.nextInt();\n            sum+=a[i]+pre;\n            pre+=a[i];\n        }int b[]=new int[(int)n+1];\n        pre=(n*(n+1)/2-sum)/n;\n        for(long i:a) {\n            pre+=i;\n            if((pre<1||pre>n)||b[(int)pre]>0) {System.out.println(""-1""); return;}\n            b[(int)pre]++;\n            sb.append(pre+"" "");\n        }System.out.println(sb);\n    }\n}",math
"import java.util.*;\npublic class MyClass {\n\n    public static void main(String args[]) {\n     Scanner in=new Scanner(System.in);\n          int n=in.nextInt();\n         int a[]=new int[n-1];\n         ArrayList<Integer> array=new ArrayList<>();\n         int min=0;\n         int sum=0;\n         TreeSet<Integer> t=new TreeSet<>();\n         for(int i=0;i<n-1;i++){ a[i]=in.nextInt(); sum+=a[i]; min=Math.min(min,sum); }\n         array.add(min*(-1) + 1); t.add(min*(-1) + 1);\n         for(int i=0;i<n-1;i++){\n             array.add(a[i]+array.get(i)); t.add(a[i]+array.get(i));\n         }\n         if(t.size()!=n||t.ceiling(n+1)!=null||t.floor(0)!=null) System.out.println(-1);\n         else{\n             for(int i:array){\n                 System.out.print(i+"" "");\n             }System.out.println();\n         }\n    }\n}",math
"import java.util.*;\nimport java.io.*;\n\npublic class sample {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner t = new Scanner(System.in);\n		PrintWriter o = new PrintWriter(System.out);\n		int n = t.nextInt() - 1;\n		long[] a = new long[n + 1];\n		long[] b = new long[n];\n		long min = 0, sum = 0;\n		Set<Long> set = new HashSet<>();\n\n		for (int i = 0; i < n; ++i) {\n			b[i] = t.nextLong();\n			sum += b[i];\n			min = Math.min(min, sum);\n		}\n\n		a[0] = 1 - min;\n\n		set.add(a[0]);\n\n		for (int i = 1; i <= n; ++i) {\n			a[i] = a[i - 1] + b[i - 1];\n\n			set.add(a[i]);\n		}\n\n		boolean f = true;\n\n		for (int i = 0; i < n + 1; ++i)\n			if (a[i] < 1 || a[i] > n + 1)\n				f = false;\n\n		if (set.size() != n + 1)\n			f = false;\n\n		if (f)\n			for (int i = 0; i <= n; ++i)\n				o.print(a[i] + "" "");\n		else\n			o.println(""-1"");\n\n		o.flush();\n		o.close();\n	}\n}",math
"import java.io.*;\nimport java.util.*;\npublic class Sol{\n	static class pair {\n		int pot;\n		int club;\n		public pair(int pot, int club) {\n			this.pot = pot;\n			this.club = club;\n		}\n	}\n	public static int n,m,d;\n	public static int p[];\n	public static int c[];\n	public static int q[];\n	public static int match[];\n	public static int mex[];\n	public static boolean tested[];\n	public static List<Integer> adj[];\n	public static boolean used[];\n	public static void main(String[] args) throws IOException{\n		FastIO sc = new FastIO(System.in);\n		PrintWriter out = new PrintWriter(System.out);\n		n = sc.nextInt();\n		m = sc.nextInt();\n		match = new int[m];\n		p = new int[n];\n		c = new int[n];\n		tested = new boolean[n];\n		used = new boolean[n];\n		Arrays.fill(match, -1);\n		adj = new ArrayList[5000];\n		for(int i=0; i<5000; ++i) {\n			adj[i] = new ArrayList<>();\n		}\n		for(int i=0; i<n; ++i) {\n			p[i] = sc.nextInt();\n		}\n		for(int i=0; i<n; ++i) {\n			c[i] = sc.nextInt()-1;\n		}\n		d = sc.nextInt();\n		q = new int[d];\n		mex = new int[d];\n		for(int i=0; i<d; ++i) {\n			q[d-i-1] = sc.nextInt()-1;\n			used[q[d-i-1]] = true;\n		}\n		for(int i=0; i<n; ++i) {\n			if(used[i]) continue;\n			adj[p[i]].add(c[i]);\n		}\n		int idx = 0;\n		while(augpath(idx)) {\n			Arrays.fill(tested, false);\n			idx++;\n		}\n		Arrays.fill(tested, false);\n		/*for(int i=0; i<m; ++i) {\n			System.out.println(match[i] + "" matcgh"");\n		}*/\n		mex[0] = idx;\n		for(int i=0; i<d-1; ++i) {\n			adj[p[q[i]]].add(c[q[i]]);\n			while(augpath(idx)) {\n				Arrays.fill(tested, false);\n				idx++;\n			}\n			Arrays.fill(tested, false);\n			/*for(int j=0; j<m; ++j) {\n				System.out.println(match[j] + "" matcgh"");\n			}*/\n			mex[i+1] = idx;\n		}\n		for(int i=0; i<d; ++i) {\n			out.println(mex[d-i-1]);\n		}\n		out.close();\n	}\n	public static boolean augpath(int curr) {\n		if(curr>n) return false;\n		if(tested[curr]) return false;\n		tested[curr] = true;\n		for(int i : adj[curr]) {\n			int nxt = match[i];\n			if(nxt==-1) {\n				match[i] = curr;\n				return true;\n			}\n			match[i] = curr;\n			if(augpath(nxt)) {\n				return true;\n			}\n			match[i] = nxt;\n		}\n		return false;\n	}\n	static class FastIO {\n		 \n		// Is your Fast I/O being bad?\n \n		InputStream dis;\n		byte[] buffer = new byte[1 << 17];\n		int pointer = 0;\n \n		public FastIO(String fileName) throws IOException {\n			dis = new FileInputStream(fileName);\n		}\n \n		public FastIO(InputStream is) throws IOException {\n			dis = is;\n		}\n \n		int nextInt() throws IOException {\n			int ret = 0;\n \n			byte b;\n			do {\n				b = nextByte();\n			} while (b <= ' ');\n			boolean negative = false;\n			if (b == '-') {\n				negative = true;\n				b = nextByte();\n			}\n			while (b >= '0' && b <= '9') {\n				ret = 10 * ret + b - '0';\n				b = nextByte();\n			}\n \n			return (negative) ? -ret : ret;\n		}\n \n		long nextLong() throws IOException {\n			long ret = 0;\n \n			byte b;\n			do {\n				b = nextByte();\n			} while (b <= ' ');\n			boolean negative = false;\n			if (b == '-') {\n				negative = true;\n				b = nextByte();\n			}\n			while (b >= '0' && b <= '9') {\n				ret = 10 * ret + b - '0';\n				b = nextByte();\n			}\n \n			return (negative) ? -ret : ret;\n		}\n \n		byte nextByte() throws IOException {\n			if (pointer == buffer.length) {\n				dis.read(buffer, 0, buffer.length);\n				pointer = 0;\n			}\n			return buffer[pointer++];\n		}\n \n		String next() throws IOException {\n			StringBuffer ret = new StringBuffer();\n \n			byte b;\n			do {\n				b = nextByte();\n			} while (b <= ' ');\n			while (b > ' ') {\n				ret.appendCodePoint(b);\n				b = nextByte();\n			}\n \n			return ret.toString();\n		}\n \n	}\n}","flows,graph matchings,graphs"
"import java.util.*;\nimport static java.lang.Math.*;\n\npublic class SolutionE {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        int deg[] = new int[m];\n        int p[] = new int[n];\n        for(int i = 0; i < n; ++i) {\n            p[i] = sc.nextInt();\n            if(p[i] < m)\n                deg[p[i]]++;\n        }\n\n        int c[] = new int[n];\n        for(int i = 0; i < n; ++i)\n            c[i] = sc.nextInt();\n\n        int q = sc.nextInt();\n        int qind[] = new int[q];\n        int vis[] = new int[n];\n        for(int i = 0; i < q; ++i) {\n            qind[i] = sc.nextInt() - 1;\n            vis[qind[i]] = 1;\n        }\n\n        Kunh kunh = new Kunh(2 * m, deg);\n        for(int i = 0; i < n; ++i) {    \n            if(vis[i] == 0) {\n                if(p[i] < m) \n                    kunh.addEdge(p[i], m + c[i] - 1);\n            }\n        }\n        int ans = 0;\n        while(ans < m && kunh.addFlow(ans)) \n            ans++;\n\n        int fans[] = new int[q];\n        for(int i = q - 1; i >= 0; --i) {\n            fans[i] = ans;\n\n            int ind = qind[i];\n\n            if(p[ind] < m) {\n                kunh.addEdge(p[ind], m + c[ind] - 1);\n            }\n\n            while(ans < m && kunh.addFlow(ans))\n                ans++;\n        }\n\n        for(int i : fans)\n            System.out.println(i);\n    }\n}\nclass Kunh {\n    int pair[];\n    int adj[][];\n    int ptr[];\n    int vis[];\n    int level = 0;\n    Kunh(int n, int deg[]) {\n        pair = new int[n];\n        Arrays.fill(pair, -1);\n        adj = new int[n / 2][];\n        for(int i = 0; i < n / 2; ++i) {\n            adj[i] = new int[deg[i]];\n        }\n        ptr = new int[n / 2];\n        vis = new int[n / 2];\n    }\n    void addEdge(int i, int j) {\n        adj[i][ptr[i]++] = j;\n    }\n    boolean addFlow(int source) {\n        level++;\n        return dfs(source);\n    }\n    boolean dfs(int i) {\n        vis[i] = level;\n\n        for(int k = 0; k < ptr[i]; ++k) {\n            int j = adj[i][k];\n            if(pair[j] == -1) {\n                pair[j] = i;\n                return true;\n            }\n            else if(vis[pair[j]] != level && dfs(pair[j])) {\n                pair[j] = i;\n                return true;\n            }\n        }\n\n        return false;\n    }\n}","flows,graph matchings,graphs"
"import java.util.*;\nimport static java.lang.Math.*;\n\npublic class SolutionE {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        int deg[] = new int[m];\n        int p[] = new int[n];\n        for(int i = 0; i < n; ++i) {\n            p[i] = sc.nextInt();\n            if(p[i] < m)\n                deg[p[i]]++;\n        }\n\n        int c[] = new int[n];\n        for(int i = 0; i < n; ++i)\n            c[i] = sc.nextInt();\n\n        int q = sc.nextInt();\n        int qind[] = new int[q];\n        int vis[] = new int[n];\n        for(int i = 0; i < q; ++i) {\n            qind[i] = sc.nextInt() - 1;\n            vis[qind[i]] = 1;\n        }\n\n        Kunh kunh = new Kunh(2 * m, deg);\n        for(int i = 0; i < n; ++i) {    \n            if(vis[i] == 0) {\n                if(p[i] < m) \n                    kunh.addEdge(p[i], m + c[i] - 1);\n            }\n        }\n        int ans = 0;\n        while(ans < m && kunh.addFlow(ans)) \n            ans++;\n\n        int fans[] = new int[q];\n        for(int i = q - 1; i >= 0; --i) {\n            fans[i] = ans;\n\n            int ind = qind[i];\n\n            if(p[ind] < m) {\n                kunh.addEdge(p[ind], m + c[ind] - 1);\n            }\n\n            while(ans < m && kunh.addFlow(ans))\n                ans++;\n        }\n\n        for(int i : fans)\n            System.out.println(i);\n    }\n}\nclass Kunh {\n    int pair[];\n    int adj[][];\n    int ptr[];\n    int vis[];\n    int level = 0;\n    Kunh(int n, int deg[]) {\n        pair = new int[n];\n        Arrays.fill(pair, -1);\n        adj = new int[n / 2][];\n        for(int i = 0; i < n / 2; ++i) {\n            adj[i] = new int[deg[i]];\n        }\n        ptr = new int[n / 2];\n        vis = new int[n / 2];\n    }\n    void addEdge(int i, int j) {\n        adj[i][ptr[i]++] = j;\n    }\n    boolean addFlow(int source) {\n        level++;\n        return dfs(source);\n    }\n    boolean dfs(int i) {\n        vis[i] = level;\n\n        for(int k = 0; k < ptr[i]; ++k) {\n            int j = adj[i][k];\n            if(pair[j] == -1) {\n                pair[j] = i;\n                return true;\n            }\n            else if(vis[pair[j]] != level && dfs(pair[j])) {\n                pair[j] = i;\n                return true;\n            }\n        }\n\n        return false;\n    }\n}","flows,graph matchings,graphs"
"import java.util.*;\nimport static java.lang.Math.*;\n\npublic class SolutionE {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        int deg[] = new int[m];\n        int p[] = new int[n];\n        for(int i = 0; i < n; ++i) {\n            p[i] = sc.nextInt();\n            if(p[i] < m)\n                deg[p[i]]++;\n        }\n\n        int c[] = new int[n];\n        for(int i = 0; i < n; ++i)\n            c[i] = sc.nextInt();\n\n        int q = sc.nextInt();\n        int qind[] = new int[q];\n        int vis[] = new int[n];\n        for(int i = 0; i < q; ++i) {\n            qind[i] = sc.nextInt() - 1;\n            vis[qind[i]] = 1;\n        }\n\n        Kunh kunh = new Kunh(2 * m, deg);\n        for(int i = 0; i < n; ++i) {    \n            if(vis[i] == 0) {\n                if(p[i] < m) \n                    kunh.addEdge(p[i], m + c[i] - 1);\n            }\n        }\n        int ans = 0;\n        while(ans < m && kunh.addFlow(ans)) \n            ans++;\n\n        int fans[] = new int[q];\n        for(int i = q - 1; i >= 0; --i) {\n            fans[i] = ans;\n\n            int ind = qind[i];\n\n            if(p[ind] < m) {\n                kunh.addEdge(p[ind], m + c[ind] - 1);\n            }\n\n            while(ans < m && kunh.addFlow(ans))\n                ans++;\n        }\n\n        for(int i : fans)\n            System.out.println(i);\n    }\n}\nclass Kunh {\n    int pair[];\n    int adj[][];\n    int ptr[];\n    int vis[];\n    int level = 0;\n    Kunh(int n, int deg[]) {\n        pair = new int[n];\n        Arrays.fill(pair, -1);\n        adj = new int[n / 2][];\n        for(int i = 0; i < n / 2; ++i) {\n            adj[i] = new int[deg[i]];\n        }\n        ptr = new int[n / 2];\n        vis = new int[n / 2];\n    }\n    void addEdge(int i, int j) {\n        adj[i][ptr[i]++] = j;\n    }\n    boolean addFlow(int source) {\n        level++;\n        return dfs(source);\n    }\n    boolean dfs(int i) {\n        vis[i] = level;\n\n        for(int k = 0; k < ptr[i]; ++k) {\n            int j = adj[i][k];\n            if(pair[j] == -1) {\n                pair[j] = i;\n                return true;\n            }\n            else if(vis[pair[j]] != level && dfs(pair[j])) {\n                pair[j] = i;\n                return true;\n            }\n        }\n\n        return false;\n    }\n}","flows,graph matchings,graphs"
//package files;\nimport java.util.*;\npublic class Answer {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n;\n		n=sc.nextInt();\n		String s=sc.next();\n		int count=0;\n		for(int i=0;i<n;i++) {\n			if((s.charAt(i)-'0')%2==0)\n				count+=i+1;\n		}\n		System.out.println(count);\n	}\n	 \n}\n,"implementation,strings"
import java.util.Scanner;\n\npublic class CR548A {\n	public static void main(String[] args) {\n		Scanner s=new Scanner(System.in);\n		\n		int n=s.nextInt();\n		\n		String str=s.next();\n		int count=0;\n		\n		for(int i=0;i<n;i++) {\n			if((str.charAt(i)-'0')%2==0) {\n				count+=i+1;\n			}\n		}\n		System.out.println(count);\n	}\n\n}\n,"implementation,strings"
"import java.util.*;\npublic class Main\n{\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n    	long i,l,count=0;\n    	l=sc.nextLong();\n    	String s;\n    	s=sc.next();\n    	for(i=0;i<l;i++)\n    	{\n    		if ((s.charAt((int)i)-'0')%2==0) count+=(i+1);\n    	}\n    	System.out.println(count);\n	}\n}\n","implementation,strings"
"import java.util.*;\npublic class EvenSubstrings {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		String s[]=sc.next().split("""");\n		int ans=0;\n		for(int i=0;i<n;i++) {\n			if(Integer.parseInt(s[i])%2==0) {\n				ans=ans+(i+1);\n			}\n		}\n		System.out.println(ans);\n\n	}\n\n}\n","implementation,strings"
"//package com.company;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static class Task {\n        // a1 * dx + b1\n        public class Pair { // p.a * deltaA + p.b + deltaB\n            long a, b;\n            public Pair(long a, long b) {\n                this.a = a;\n                this.b = b;\n            }\n\n            public long evalB() {\n                return b + a * deltaA + deltaB;\n            }\n        }\n\n        public boolean check(Pair a, Pair b, Pair c) { // a -> b -> c\n//            long intersect1 = (c.evalB() - b.evalB()) / (b.a - c.a);\n//            long intersect2 = (b.evalB() - a.evalB()) / (a.a - b.a);\n//            System.err.println(a.a + "" "" + a.evalB());\n//            System.err.println(b.a + "" "" + b.evalB());\n//            System.err.println(c.a + "" "" + c.evalB());\n//            System.err.println(""A "" + (c.evalB() - b.evalB()) * (a.a - b.a));\n//            System.err.println(""B "" + (b.evalB() - a.evalB()) * (b.a - c.a));\n            return (c.evalB() - b.evalB()) * (a.a - b.a) >= (b.evalB() - a.evalB()) * (b.a - c.a);\n        }\n\n        public boolean check2(Pair a, Pair b) {\n            return a.evalB() <= b.evalB();\n        }\n\n        Pair[] convexHull;\n        int idx = 0;\n        long deltaA, deltaB;\n        public void addPair(Pair p) {\n            if (idx >= 1 && p.evalB() >= convexHull[idx - 1].evalB()) return;\n//            System.err.println(""Add "" + p.a + "" "" + p.evalB());\n            while (idx >= 2 && check(convexHull[idx - 2], convexHull[idx - 1], p)) {\n                idx--;\n            }\n            convexHull[idx++] = p;\n        }\n\n        public void globalAdd(long da, long db) {\n            deltaA += da;\n            deltaB += db;\n            while (idx >= 2 && check2(convexHull[idx - 2], convexHull[idx - 1])) {\n                idx--;\n            }\n        }\n\n        public void solve(Scanner sc, PrintWriter pw) throws IOException {\n            convexHull = new Pair[300010];\n            addPair(new Pair(0, 0));\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            for (int i = 0; i < m; i++) {\n                int t = sc.nextInt();\n                if (t == 1) {\n                    int k = sc.nextInt();\n                    n += k;\n                    idx = 0;\n                    deltaA = deltaB = 0;\n                    addPair(new Pair(0, 0));\n                } else if (t == 2) {\n                    int k = sc.nextInt();\n                    Pair p = new Pair(n, 0);\n                    long negB = p.evalB();\n                    p.b -= negB;\n                    addPair(p);\n                    n += k;\n                } else {\n                    int b = sc.nextInt();\n                    int s = sc.nextInt();\n                    globalAdd(s, b);\n                }\n                pw.println((convexHull[idx - 1].a + 1) + "" "" + convexHull[idx - 1].evalB());\n\n//                pw.print((convexHull[idx - 1].a + 1) + "" "" + convexHull[idx - 1].evalB() + "" ----- "");\n//                if (idx >= 2)\n//                    pw.println((convexHull[idx - 2].a + 1) + "" "" + convexHull[idx - 2].evalB());\n//                else\n//                    pw.println();\n            }\n        }\n    }\n\n    static long TIME_START, TIME_END;\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n//        Scanner sc = new Scanner(new FileInputStream(""input""));\n        PrintWriter pw = new PrintWriter(new BufferedOutputStream(System.out));\n//        PrintWriter pw = new PrintWriter(new FileOutputStream(""output""));\n\n\n        Runtime runtime = Runtime.getRuntime();\n        long usedMemoryBefore = runtime.totalMemory() - runtime.freeMemory();\n        TIME_START = System.currentTimeMillis();\n        Task t = new Task();\n        t.solve(sc, pw);\n        TIME_END = System.currentTimeMillis();\n        long usedMemoryAfter = runtime.totalMemory() - runtime.freeMemory();\n        pw.close();\n        System.err.println(""Memory increased: "" + (usedMemoryAfter - usedMemoryBefore) / 1000000);\n        System.err.println(""Time used: "" + (TIME_END - TIME_START) + ""."");\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public Scanner(FileReader s) throws FileNotFoundException {\n            br = new BufferedReader(s);\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n}","data structures,greedy"
"import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class E {\n	static PrintWriter out = new PrintWriter(System.out);\n\n	static long totalSize, totalM, totalB;\n	public static void main(String[] args) {\n		FS in = new FS();\n		totalSize = in.nextLong();\n		int Q = in.nextInt();\n		\n		Node last = new Node(0, 0);\n		TreeSet<Node> ts = new TreeSet<Node>();\n		\n		for(int qq = 0; qq < Q; qq++) {\n			int type = in.nextInt();\n			if(type == 1) {\n				long k = in.nextLong();\n				totalSize += k;\n				ts.clear();\n				last = new Node(0, 0);\n			}\n			if(type == 2) {\n				long k = in.nextLong();\n				last.update();\n				if(last.val > 0) {\n					Node next = new Node(totalSize, 0);\n					last.left = next;\n					next.right = last;\n					ts.add(last.calc());\n					last = next;\n				}\n				totalSize += k;\n			}\n			if(type == 3) {\n				long b = in.nextLong();\n				long m = in.nextLong();\n				\n				totalM += m;\n				totalB += b;\n				while(!ts.isEmpty() && totalM >= ts.first().takeover) {\n					// Node x takesover his neighbor\n					Node x = ts.pollFirst();\n					x.update();\n					ts.remove(x.left);\n					x.left.update();\n					\n					x.left = x.left.left;\n					if(x.left == null) {\n						last = x;\n					}\n					else {\n						x.left.right = x;\n						ts.add(x.calc());\n					}\n\n				}\n				\n			}\n			last.update();\n			\n			out.println((last.index+1)+"" ""+last.val);\n		}\n		out.close();\n	}\n	\n	static class Node implements Comparable<Node> {\n		long index, val;\n		long lastm, lastb; // vals to push\n		long takeover;\n		Node left, right;\n		public Node(long ind, long v) {\n			index = ind;\n			val = v;\n			lastm = totalM;\n			lastb = totalB;\n			takeover = -1;\n		}\n		\n		void update() {\n			val += (totalB-lastb) + index * (totalM - lastm);\n			lastm = totalM;\n			lastb = totalB;\n		}\n		\n		Node calc() {\n			// find when I beat the guy to the left of me\n			update();\n			left.update();\n			\n			long ma = (left.val - val) / (index - left.index);\n			while(val + ma*index > left.val + ma*left.index) ma++;\n			\n			takeover = lastm + ma;\n			return this;\n		}\n		\n		@Override\n		public int compareTo(Node o) {\n			if(takeover != o.takeover) return Long.compare(takeover, o.takeover);\n			return Long.compare(index, o.index);\n		}\n		\n		@Override\n		public String toString() {\n			return ""[id = ""+index+"" val = ""+val+""  take = ""+takeover+""]"";\n		}\n	}\n	\n	static class FS{\n		BufferedReader br;\n		StringTokenizer st;\n		public FS() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n		String next() {\n			while(st == null || !st.hasMoreElements()) {\n				try {st = new StringTokenizer(br.readLine());}\n				catch(Exception e) { throw null;}\n			}\n			return st.nextToken();\n		}\n		int nextInt() { return Integer.parseInt(next());}\n		double nextDouble() { return Double.parseDouble(next());}\n		long nextLong() { return Long.parseLong(next());}\n		int[] NIA(int n) {\n			int r[] = new int[n];\n			for(int i = 0; i < n; i++) r[i] = nextInt();\n			return r;\n		}\n		long[] NLA(int n) {\n			long r[] = new long[n];\n			for(int i = 0; i < n; i++) r[i] = nextLong();\n			return r;\n		}\n		char[][] grid(int r, int c){\n			char res[][] = new char[r][c];\n			for(int i = 0; i < r; i++) {\n				char l[] = next().toCharArray();\n				for(int j = 0; j < c; j++) {\n					res[i][j] = l[j];\n				}\n			}\n			return res;\n		}\n	}\n	\n}\n","data structures,greedy"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TrainCar solver = new TrainCar();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TrainCar {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int N = in.nextInt();\n            int M = in.nextInt();\n            MaintainMin min = new MaintainMin(N);\n            while (M-- > 0) {\n                int a = in.nextInt();\n                if (a == 1) {\n                    min.addFront(in.nextInt());\n                } else if (a == 2) {\n                    min.addBack(in.nextInt());\n                } else {\n                    min.inc(in.nextInt(), in.nextInt());\n                }\n                out.println(min.getIndex() + "" "" + min.getVal());\n            }\n        }\n\n        long xIntersect(long[] a, long[] b) {\n            return Math.floorDiv(a[3] - b[3] - 1, (b[2] - a[2]));\n        }\n\n        class Node {\n            Node next;\n            long[] line;\n\n            Node(long[] line) {\n                this.line = line;\n            }\n\n        }\n\n        class MaintainMin {\n            Node first;\n            Node cur;\n            long bSum = 0;\n            long sSum = 0;\n            int N;\n\n            MaintainMin(int N) {\n                this.N = N;\n                first = new Node(new long[]{-Long.MAX_VALUE, Long.MAX_VALUE, 0, -bSum});\n                cur = first;\n            }\n\n            void addFront(int k) {\n                first = new Node(new long[]{Long.MAX_VALUE, Long.MAX_VALUE, 0, -bSum});\n                cur = first;\n                N += k;\n            }\n\n            void addBack(int k) {\n                long[] next = new long[]{Long.MIN_VALUE, 0, N, -bSum - N * sSum};\n                N += k;\n                upd(first, next);\n            }\n\n            void inc(long b, long s) {\n                bSum += b;\n                sSum += s;\n                while (cur.line[1] < sSum) {\n                    cur = cur.next;\n                }\n            }\n\n            long getIndex() {\n                return cur.line[2] + 1;\n            }\n\n            long getVal() {\n                return (cur.line[2] * sSum + cur.line[3] + bSum);\n            }\n\n            void upd(Node u, long[] next) {\n                long x = xIntersect(u.line, next);\n                if (x >= u.line[1]) {\n                    upd(u.next, next);\n                } else {\n                    next[1] = x;\n                    first = new Node(next);\n                    u.line[0] = x + 1;\n                    first.next = u;\n                    if (sSum <= first.line[1]) {\n                        cur = first;\n                    }\n                }\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n","data structures,greedy"
"import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class E {\n\n	static class Line {\n		long k, b;\n\n		public Line(long k, long b) {\n			this.k = k;\n			this.b = b;\n		}\n\n		long at(long x) {\n			return k * x + b;\n		}\n	}\n\n	void submit() {\n		int tot = nextInt();\n		int qs = nextInt();\n\n		Line[] h = new Line[qs + 1];\n		int sz = 0;\n		h[sz++] = new Line(0, 0);\n\n		long base = 0;\n\n		long x = 0;\n\n		int lastType = 1;\n\n		while (qs-- > 0) {\n			int type = nextInt();\n			if (type == 1) {\n				int k = nextInt();\n				tot += k;\n				sz = 0;\n				h[sz++] = new Line(0, 0);\n				x = 0;\n				base = 0;\n\n				out.println(""1 0"");\n				lastType = 1;\n\n				continue;\n			}\n\n			if (type == 2) {\n				int k = nextInt();\n				Line q = new Line(tot, -base - tot * x);\n\n				tot += k;\n\n				if (lastType == 1) {\n					out.println(""1 0"");\n					lastType = 2;\n					continue;\n				}\n				if (lastType == 2) {\n					out.println((h[sz - 1].k + 1) + "" "" + (h[sz - 1].at(x) + base));\n					lastType = 2;\n					continue;\n				}\n\n				while (sz > 1 && bad(h[sz - 2], h[sz - 1], q)) {\n					// kicking sz - 1 out\n//					System.err.println(""YEP"");\n					sz--;\n				}\n				h[sz++] = q;\n				out.println((h[sz - 1].k + 1) + "" "" + (h[sz - 1].at(x) + base));\n				lastType = 2;\n				continue;\n			}\n\n			if (type != 3) {\n				throw new AssertionError();\n			}\n\n			base += nextLong();\n			long deltaX = nextLong();\n\n			x += deltaX;\n			while (sz > 1 && h[sz - 1].at(x) >= h[sz - 2].at(x)) {\n				sz--;\n			}\n\n			lastType = 3;\n			out.println((h[sz - 1].k + 1) +  "" "" + (h[sz - 1].at(x) + base));\n		}\n	}\n\n	boolean bad(Line p, Line q, Line r) {\n		return p.k * (q.b - r.b) + q.k * (r.b - p.b) + r.k * (p.b - q.b) <= 0;\n	}\n\n	void test() {\n\n	}\n\n	void stress() {\n		for (int tst = 0;; tst++) {\n			if (false) {\n				throw new AssertionError();\n			}\n			System.err.println(tst);\n		}\n	}\n\n	E() throws IOException {\n		is = System.in;\n		out = new PrintWriter(System.out);\n		submit();\n		// stress();\n		// test();\n		out.close();\n	}\n\n	static final Random rng = new Random();\n	static final int C = 5;\n\n	static int rand(int l, int r) {\n		return l + rng.nextInt(r - l + 1);\n	}\n\n	public static void main(String[] args) throws IOException {\n		new E();\n	}\n\n	private InputStream is;\n	PrintWriter out;\n\n	private byte[] buf = new byte[1 << 14];\n	private int bufSz = 0, bufPtr = 0;\n\n	private int readByte() {\n		if (bufSz == -1)\n			throw new RuntimeException(""Reading past EOF"");\n		if (bufPtr >= bufSz) {\n			bufPtr = 0;\n			try {\n				bufSz = is.read(buf);\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n			if (bufSz <= 0)\n				return -1;\n		}\n		return buf[bufPtr++];\n	}\n\n	private boolean isTrash(int c) {\n		return c < 33 || c > 126;\n	}\n\n	private int skip() {\n		int b;\n		while ((b = readByte()) != -1 && isTrash(b))\n			;\n		return b;\n	}\n\n	String nextToken() {\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b)) {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	String nextString() {\n		int b = readByte();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b) || b == ' ') {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	double nextDouble() {\n		return Double.parseDouble(nextToken());\n	}\n\n	char nextChar() {\n		return (char) skip();\n	}\n\n	int nextInt() {\n		int ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n\n	long nextLong() {\n		long ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n}\n","data structures,greedy"
"import java.util.*;\n\npublic class Algo{\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int n = scan.nextInt();\n		int counter = 0, positive = 0 , nega = 0;\n		for(int i = 0 ;i< n ; i++){\n			int x = scan.nextInt();\n			if(x!=0)counter++;\n			if(x>0)positive++;\n			if(x<0)nega++;\n		}\n		if(positive>=(n+1)/2){\n		System.out.println(1);\n		}\n		else if(nega>=(n+1)/2)\n		System.out.println(-1);\n\n		else\n		System.out.println(0);\n	}\n}",implementation
"import java.util.*;\n\npublic class Algo{\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int n = scan.nextInt();\n		int counter = 0, positive = 0 , nega = 0;\n		for(int i = 0 ;i< n ; i++){\n			int x = scan.nextInt();\n			if(x!=0)counter++;\n			if(x>0)positive++;\n			if(x<0)nega++;\n		}\n		if(positive>=(n+1)/2){\n		System.out.println(1);\n		}\n		else if(nega>=(n+1)/2)\n		System.out.println(-1);\n\n		else\n		System.out.println(0);\n	}\n}",implementation
"import java.util.*;\npublic class MyClass {\n    public static void main(String args[]) {\n      Scanner sc=new Scanner(System.in);\n  int n=sc.nextInt();\n  int arr[]=new int[n];\n  int i,p=0,h=0,k;\n  for(i=0;i<n;i++)\n  {\n      arr[i]=sc.nextInt();\n      if(arr[i]>0)\n      ++p;\n      else if(arr[i]<0)\n      ++h;\n  }\n  if(n%2==0)\n  k=n/2;\n  else\n  k=(n/2) +1 ;\n  if(p>=k)\n  System.out.println(""4"");\n  else if(h>=k)\n  System.out.println(""-4"");\n  else\n  System.out.println(""0"");\n    }}\n  \n  \n  \n  \n  \n  \n  \n  \n  ",implementation
import java.util.Scanner;\n\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int positive = 0;\n		int negative = 0;\n		\n		\n		for(int i=0;i<n;i++) {\n			int s = sc.nextInt();\n			if(s==0) continue;\n			if(s<0) negative ++;\n			else positive ++;\n		}\n		\n		if(negative >= n/2.0) {\n			System.out.println(-1);\n			return;\n		}\n		if(positive >= n/2.0) {\n			System.out.println(1);\n			return;\n		}\n		System.out.println(0);\n	}\n}\n\n\n,implementation
"import java.util.*;\npublic class Main\n{\n	public static void main(String[]args)\n	{\n		Scanner in=new Scanner(System.in);\n		int n,i,j,t,cent,max;\n		int []s=new int[1000];\n		int []b=new int[200001];\n		n=in.nextInt();\n		for(i=0;i<n;i++)\n		{\n			s[i]=in.nextInt();\n		}\n		for(i=0;i<n-1;i++)\n		{\n			for(j=i+1;j<n;j++)\n			{\n				t=s[i]+s[j];\n				b[t]++;\n			}\n		}\n		max=0;\n		for(i=2;i<200000;i++)\n		{\n			if(b[i]>max)\n			{\n				max=b[i];\n			}\n		}\n		System.out.println(max);\n	}\n}\n		  	  	  		 	 	   		  	 	 		","brute force,implementation"
import java.io.*;\nimport java.util.*;\n\npublic class Main \n{\n	static Scanner sc = new Scanner(System.in);\n	public static void main (String[] args) \n	{\n		int n = sc.nextInt();\n		int[] a = new int[n];\n		for(int i=0; i<n; i++) a[i]=sc.nextInt();\n		\n		int mxN = 200001;\n		int[] c = new int[mxN];\n		for(int i=0; i<n; i++) \n		{\n		    for(int j=i+1; j<n; j++)\n		        c[a[i]+a[j]]++;\n		}\n		\n		int ans=0;\n		for(int i=0; i<mxN; i++) \n		    if(c[i]>ans) ans=c[i];\n		System.out.println(ans);\n	}\n},"brute force,implementation"
import java.io.*;\nimport java.util.*;\n \npublic class Demo \n{\n	\n	public static void main (String[] args) \n	{\n	    Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int[] a = new int[n];\n		for(int i=0; i<n; i++) a[i]=sc.nextInt();\n		\n		int mxN = 200001;\n		int[] c = new int[mxN];\n		for(int i=0; i<n; i++) \n		{\n		    for(int j=i+1; j<n; j++)\n		        c[a[i]+a[j]]++;\n		}\n		\n		int ans=0;\n		for(int i=0; i<mxN; i++) \n		    if(c[i]>ans) ans=c[i];\n		System.out.println(ans);\n	}\n},"brute force,implementation"
"import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int a[]=new int[n];\n        for(int i=0;i<n;i++) \n        a[i]=sc.nextInt();\n        HashMap<Integer,Integer> map=new HashMap<>();\n        for(int i=0;i<n-1;i++) {\n            for(int j=i+1;j<n;j++) {\n                map.put(a[i]+a[j],map.getOrDefault(a[i]+a[j],0)+1);\n            }\n        }\n        int max=0;\n        for(int e :map.values()) \n        max=Math.max(e,max);\n        System.out.println(max);\n    }\n}","brute force,implementation"
"import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class cfGlobal2H {\n\n	static final int P = 998244353;\n	static final int INV2 = (P + 1) / 2;\n\n	void fwhtMod(int[] a) {\n		int n = a.length;\n		for (int s = 1; s < n; s <<= 1) {\n			for (int i = 0; i < n; i += s << 1) {\n				for (int j = i; j < i + s; j++) {\n					int k = j + s;\n\n					int v = a[j];\n					int u = a[k];\n\n					a[j] += u;\n					if (a[j] >= P) {\n						a[j] -= P;\n					}\n\n					a[k] = v - u;\n					if (a[k] < 0) {\n						a[k] += P;\n					}\n\n				}\n			}\n		}\n	}\n\n	static final int M = 3;\n\n	static final boolean test(int mask, int i) {\n		return ((mask >> i) & 1) == 1;\n	}\n\n	void submit() {\n		int n = nextInt();\n		int k = nextInt();\n\n		int[] xs = new int[M];\n		for (int i = 0; i < M; i++) {\n			xs[i] = nextInt();\n		}\n\n		int[] arr = new int[1 << (k + M)];\n\n		for (int i = 0; i < n; i++) {\n			int[] tmp = new int[M];\n			for (int j = 0; j < M; j++) {\n				tmp[j] = nextInt();\n			}\n\n			for (int mask = 0; mask < 1 << M; mask++) {\n				int idx = mask << k;\n				for (int j = 0; j < M; j++) {\n					if (test(mask, j)) {\n						idx ^= tmp[j];\n					}\n				}\n				// System.err.println(mask + "" "" + idx);\n				arr[idx]++;\n			}\n		}\n\n		fwhtMod(arr);\n\n		int[][] ps = new int[1 << M][];\n\n		for (int i = 0; i < 1 << M; i++) {\n			int sum = 0;\n			for (int j = 0; j < M; j++) {\n				if (test(i, j)) {\n					sum -= xs[j];\n					if (sum < 0) {\n						sum += P;\n					}\n				} else {\n					sum += xs[j];\n					if (sum >= P) {\n						sum -= P;\n					}\n				}\n\n			}\n			ps[i] = pows(sum, n);\n		}\n\n		int i2m = 1;\n		for (int i = 0; i < M; i++) {\n			i2m = (int) ((long) i2m * INV2 % P);\n		}\n\n		for (int i = 0; i < arr.length; i++) {\n			arr[i] = (int) ((long) arr[i] * i2m % P);\n		}\n\n		int[] ans = new int[1 << k];\n		for (int i = 0; i < 1 << k; i++) {\n			ans[i] = 1;\n			for (int j = 0; j < 1 << M; j++) {\n				ans[i] = (int) ((long) ans[i] * ps[j][arr[i | (j << k)]] % P);\n			}\n		}\n\n		fwhtMod(ans);\n\n		long inv2k = 1;\n		for (int i = 0; i < k; i++) {\n			inv2k = inv2k * INV2 % P;\n		}\n\n		for (int i = 0; i < ans.length; i++) {\n			out.print(ans[i] * inv2k % P + "" "");\n		}\n		out.println();\n	}\n\n	int[] pows(int x, int b) {\n		int[] ret = new int[b + 1];\n		ret[0] = 1;\n		for (int i = 1; i < ret.length; i++) {\n			ret[i] = (int) ((long) ret[i - 1] * x % P);\n		}\n		return ret;\n	}\n\n	int f(long x) {\n		// return (int) Math.floorMod(x, P);\n		x %= P;\n		return (int) (x < 0 ? x + P : x);\n	}\n\n	void test() {\n	}\n\n	void stress() {\n		for (int tst = 0;; tst++) {\n			if (false) {\n				throw new AssertionError();\n			}\n			System.err.println(tst);\n		}\n	}\n\n	cfGlobal2H() throws IOException {\n		is = System.in;\n		out = new PrintWriter(System.out);\n		submit();\n		// stress();\n		// test();\n		out.close();\n	}\n\n	static final Random rng = new Random();\n	static final int C = 5;\n\n	static int rand(int l, int r) {\n		return l + rng.nextInt(r - l + 1);\n	}\n\n	public static void main(String[] args) throws IOException {\n		new cfGlobal2H();\n	}\n\n	private InputStream is;\n	PrintWriter out;\n\n	private byte[] buf = new byte[1 << 14];\n	private int bufSz = 0, bufPtr = 0;\n\n	private int readByte() {\n		if (bufSz == -1)\n			throw new RuntimeException(""Reading past EOF"");\n		if (bufPtr >= bufSz) {\n			bufPtr = 0;\n			try {\n				bufSz = is.read(buf);\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n			if (bufSz <= 0)\n				return -1;\n		}\n		return buf[bufPtr++];\n	}\n\n	private boolean isTrash(int c) {\n		return c < 33 || c > 126;\n	}\n\n	private int skip() {\n		int b;\n		while ((b = readByte()) != -1 && isTrash(b))\n			;\n		return b;\n	}\n\n	String nextToken() {\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b)) {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	String nextString() {\n		int b = readByte();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b) || b == ' ') {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	double nextDouble() {\n		return Double.parseDouble(nextToken());\n	}\n\n	char nextChar() {\n		return (char) skip();\n	}\n\n	int nextInt() {\n		int ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n\n	long nextLong() {\n		long ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n}\n","fft,math"
"import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class cfGlobal2H {\n\n	static final int P = 998244353;\n	static final int INV2 = (P + 1) / 2;\n\n	void fwhtJust(int[] a) {\n		int n = a.length;\n		for (int s = 1; s < n; s <<= 1) {\n			for (int i = 0; i < n; i += s << 1) {\n				for (int j = i; j < i + s; j++) {\n					int k = j + s;\n\n					int v = a[j];\n					int u = a[k];\n\n					a[j] += u;\n//					if (a[j] >= P) {\n//						a[j] -= P;\n//					}\n\n					a[k] = v - u;\n//					if (a[k] < 0) {\n//						a[k] += P;\n//					}\n\n				}\n			}\n		}\n	}\n	\n	void fwhtMod(int[] a) {\n		int n = a.length;\n		for (int s = 1; s < n; s <<= 1) {\n			for (int i = 0; i < n; i += s << 1) {\n				for (int j = i; j < i + s; j++) {\n					int k = j + s;\n\n					int v = a[j];\n					int u = a[k];\n\n					a[j] += u;\n					if (a[j] >= P) {\n						a[j] -= P;\n					}\n\n					a[k] = v - u;\n					if (a[k] < 0) {\n						a[k] += P;\n					}\n\n				}\n			}\n		}\n	}\n\n	void submit() {\n		int n = nextInt();\n		int k = nextInt();\n\n		long x = nextInt();\n		long y = nextInt();\n		long z = nextInt();\n\n		int[] m1 = new int[n];\n		int[] m2 = new int[n];\n\n		int xorAll = 0;\n\n		for (int i = 0; i < n; i++) {\n			int a = nextInt();\n			int b = nextInt();\n			int c = nextInt();\n			xorAll ^= a;\n			m1[i] = a ^ b;\n			m2[i] = a ^ c;\n		}\n\n		int[] justB = new int[1 << k];\n		int[] justC = new int[1 << k];\n		int[] justXor = new int[1 << k];\n		for (int i = 0; i < n; i++) {\n			justB[m1[i]]++;\n			justC[m2[i]]++;\n			justXor[m1[i] ^ m2[i]]++;\n		}\n\n		fwhtJust(justB);\n		fwhtJust(justC);\n		fwhtJust(justXor);\n\n		int[][] ps = { pows(f(x + y + z), n), pows(f(x - y + z), n),\n				pows(f(x + y - z), n), pows(f(x - y - z), n) };\n\n		int[] arr = new int[1 << k];\n		for (int i = 0; i < 1 << k; i++) {\n			int[] xs = solve(n, justB[i], justC[i], justXor[i]);\n			arr[i] = 1;\n			for (int j = 0; j < 4; j++) {\n				arr[i] = (int) ((long) arr[i] * ps[j][xs[j]] % P);\n			}\n		}\n\n		fwhtMod(arr);\n\n		long inv2k = 1;\n		for (int i = 0; i < k; i++) {\n			inv2k = inv2k * INV2 % P;\n		}\n\n		for (int i = 0; i < arr.length; i++) {\n			out.print(arr[i ^ xorAll] * inv2k % P + "" "");\n		}\n		out.println();\n	}\n\n	int[] solve(int all, int yw, int zw, int yz) {\n		yw = (all - yw) / 2;\n		zw = (all - zw) / 2;\n		yz = (all - yz) / 2;\n\n		int yzw = (yw + zw + yz) / 2;\n		int y = yzw - zw;\n		int z = yzw - yw;\n		int w = yzw - yz;\n\n		int x = all - y - z - w;\n		return new int[] { x, y, z, w };\n	}\n\n	int[] pows(int x, int b) {\n		int[] ret = new int[b + 1];\n		ret[0] = 1;\n		for (int i = 1; i < ret.length; i++) {\n			ret[i] = (int) ((long) ret[i - 1] * x % P);\n		}\n		return ret;\n	}\n\n	int f(long x) {\n		return (int) Math.floorMod(x, P);\n	}\n\n	void test() {\n	}\n\n	void stress() {\n		for (int tst = 0;; tst++) {\n			if (false) {\n				throw new AssertionError();\n			}\n			System.err.println(tst);\n		}\n	}\n\n	cfGlobal2H() throws IOException {\n		is = System.in;\n		out = new PrintWriter(System.out);\n		submit();\n		// stress();\n		// test();\n		out.close();\n	}\n\n	static final Random rng = new Random();\n	static final int C = 5;\n\n	static int rand(int l, int r) {\n		return l + rng.nextInt(r - l + 1);\n	}\n\n	public static void main(String[] args) throws IOException {\n		new cfGlobal2H();\n	}\n\n	private InputStream is;\n	PrintWriter out;\n\n	private byte[] buf = new byte[1 << 14];\n	private int bufSz = 0, bufPtr = 0;\n\n	private int readByte() {\n		if (bufSz == -1)\n			throw new RuntimeException(""Reading past EOF"");\n		if (bufPtr >= bufSz) {\n			bufPtr = 0;\n			try {\n				bufSz = is.read(buf);\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n			if (bufSz <= 0)\n				return -1;\n		}\n		return buf[bufPtr++];\n	}\n\n	private boolean isTrash(int c) {\n		return c < 33 || c > 126;\n	}\n\n	private int skip() {\n		int b;\n		while ((b = readByte()) != -1 && isTrash(b))\n			;\n		return b;\n	}\n\n	String nextToken() {\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b)) {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	String nextString() {\n		int b = readByte();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b) || b == ' ') {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	double nextDouble() {\n		return Double.parseDouble(nextToken());\n	}\n\n	char nextChar() {\n		return (char) skip();\n	}\n\n	int nextInt() {\n		int ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n\n	long nextLong() {\n		long ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n}\n","fft,math"
"\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\n\npublic class CF1119H {\n    public static void main(String[] args) throws Exception {\n        boolean local = System.getProperty(""ONLINE_JUDGE"") == null;\n        boolean async = false;\n\n        Charset charset = Charset.forName(""ascii"");\n\n        FastIO io = local ? new FastIO(new FileInputStream(""D:\\DATABASE\\TESTCASE\\Code.in""), System.out, charset) : new FastIO(System.in, System.out, charset);\n        Task task = new Task(io, new Debug(local));\n\n        if (async) {\n            Thread t = new Thread(null, task, ""dalt"", 1 << 27);\n            t.setPriority(Thread.MAX_PRIORITY);\n            t.start();\n            t.join();\n        } else {\n            task.run();\n        }\n\n        if (local) {\n            io.cache.append(""\n\n--memory -- \n"" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + ""M"");\n        }\n\n        io.flush();\n    }\n\n    public static class Task implements Runnable {\n        final FastIO io;\n        final Debug debug;\n        int inf = (int) 1e8;\n        static int mod = 998244353;\n        static long inv2 = Mathematics.inverse(2, mod);\n\n        public Task(FastIO io, Debug debug) {\n            this.io = io;\n            this.debug = debug;\n        }\n\n        @Override\n        public void run() {\n            solve();\n        }\n\n        public void solve() {\n            int n = io.readInt();\n            int k = 1 << io.readInt();\n            long actualA = io.readInt();\n            long actualB = io.readInt();\n            long actualC = io.readInt();\n\n            int[][] points = new int[3][n];\n            int sumXor = 0;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < 3; j++) {\n                    points[j][i] = io.readInt();\n                }\n                sumXor ^= points[0][i];\n            }\n\n            long[][] ps = new long[4][k];\n\n            for (int i = 0; i < n; i++) {\n                int p1 = 0;\n                int p2 = points[0][i] ^ points[1][i];\n                int p3 = points[0][i] ^ points[2][i];\n                int p4 = p2 ^ p3;\n\n                ps[0][p1] += 1;\n                ps[1][p2] += 1;\n                ps[2][p3] += 1;\n                ps[3][p4] += 1;\n            }\n\n            for (int i = 0; i < 4; i++) {\n                XorFWT(ps[i], 0, k - 1);\n            }\n\n            int[] p = new int[k];\n            for (int i = 0; i < k; i++) {\n\n                long x = (ps[0][i] + ps[1][i] + ps[2][i] + ps[3][i]) / 4;\n                long y = (ps[0][i] + ps[3][i]) / 2 - x;\n                long z = (ps[0][i] + ps[1][i]) / 2 - x;\n                long w = (ps[0][i] + ps[2][i]) / 2 - x;\n\n                p[i] = 1;\n                p[i] = (int) ((long) p[i] * Mathematics.pow(Mathematics.mod(actualA + actualB + actualC + 0, mod), Mathematics.mod(x, mod - 1), mod) % mod);\n                p[i] = (int) ((long) p[i] * Mathematics.pow(Mathematics.mod(actualA - actualB - actualC + 0, mod), Mathematics.mod(y, mod - 1), mod) % mod);\n                p[i] = (int) ((long) p[i] * Mathematics.pow(Mathematics.mod(actualA + actualB - actualC + 0, mod), Mathematics.mod(z, mod - 1), mod) % mod);\n                p[i] = (int) ((long) p[i] * Mathematics.pow(Mathematics.mod(actualA - actualB + actualC + 0, mod), Mathematics.mod(w, mod - 1), mod) % mod);\n            }\n\n            XorIFWT(p, 0, k - 1);\n            for (int i = 0; i < k; i++) {\n                io.cache.append(p[i ^ sumXor]).append(' ');\n            }\n        }\n\n        public static void XorFWT(long[] p, int l, int r) {\n            if (l == r) {\n                return;\n            }\n            int m = (l + r) >> 1;\n            XorFWT(p, l, m);\n            XorFWT(p, m + 1, r);\n            for (int i = 0, until = m - l; i <= until; i++) {\n                long a = p[l + i];\n                long b = p[m + 1 + i];\n                p[l + i] = a + b;\n                p[m + 1 + i] = a - b;\n            }\n        }\n\n        public static void XorIFWT(int[] p, int l, int r) {\n            if (l == r) {\n                return;\n            }\n            int m = (l + r) >> 1;\n            for (int i = 0, until = m - l; i <= until; i++) {\n                int a = p[l + i];\n                int b = p[m + 1 + i];\n                p[l + i] = Mathematics.mod((a + b) * inv2, mod);\n                p[m + 1 + i] = Mathematics.mod((a - b) * inv2, mod);\n            }\n            XorIFWT(p, l, m);\n            XorIFWT(p, m + 1, r);\n        }\n    }\n\n\n    public static class Mathematics {\n\n        public static int ceilPowerOf2(int x) {\n            return 32 - Integer.numberOfLeadingZeros(x - 1);\n        }\n\n        public static int floorPowerOf2(int x) {\n            return 31 - Integer.numberOfLeadingZeros(x);\n        }\n\n        public static long modmul(long a, long b, long mod) {\n            return b == 0 ? 0 : ((modmul(a, b >> 1, mod) << 1) % mod + a * (b & 1)) % mod;\n        }\n\n        /**\n         * Get the greatest common divisor of a and b\n         */\n        public static int gcd(int a, int b) {\n            return a >= b ? gcd0(a, b) : gcd0(b, a);\n        }\n\n        private static int gcd0(int a, int b) {\n            return b == 0 ? a : gcd0(b, a % b);\n        }\n\n        public static int extgcd(int a, int b, int[] coe) {\n            if (a >= b) {\n                return extgcd0(a, b, coe);\n            } else {\n                int g = extgcd0(b, a, coe);\n                int tmp = coe[0];\n                coe[0] = coe[1];\n                coe[1] = tmp;\n                return g;\n            }\n        }\n\n        private static int extgcd0(int a, int b, int[] coe) {\n            if (b == 0) {\n                coe[0] = 1;\n                coe[1] = 0;\n                return a;\n            }\n            int g = extgcd0(b, a % b, coe);\n            int n = coe[0];\n            int m = coe[1];\n            coe[0] = m;\n            coe[1] = n - m * (a / b);\n            return g;\n        }\n\n        /**\n         * Get the greatest common divisor of a and b\n         */\n        public static long gcd(long a, long b) {\n            return a >= b ? gcd0(a, b) : gcd0(b, a);\n        }\n\n        private static long gcd0(long a, long b) {\n            return b == 0 ? a : gcd0(b, a % b);\n        }\n\n        public static long extgcd(long a, long b, long[] coe) {\n            if (a >= b) {\n                return extgcd0(a, b, coe);\n            } else {\n                long g = extgcd0(b, a, coe);\n                long tmp = coe[0];\n                coe[0] = coe[1];\n                coe[1] = tmp;\n                return g;\n            }\n        }\n\n        private static long extgcd0(long a, long b, long[] coe) {\n            if (b == 0) {\n                coe[0] = 1;\n                coe[1] = 0;\n                return a;\n            }\n            long g = extgcd0(b, a % b, coe);\n            long n = coe[0];\n            long m = coe[1];\n            coe[0] = m;\n            coe[1] = n - m * (a / b);\n            return g;\n        }\n\n        /**\n         * Get y where x * y = 1 (% mod)\n         */\n        public static int inverse(int x, int mod) {\n            return pow(x, mod - 2, mod);\n        }\n\n        /**\n         * Get x^n(% mod)\n         */\n        public static int pow(int x, int n, int mod) {\n            int bit = 31 - Integer.numberOfLeadingZeros(n);\n            long product = 1;\n            for (; bit >= 0; bit--) {\n                product = product * product % mod;\n                if (((1 << bit) & n) != 0) {\n                    product = product * x % mod;\n                }\n            }\n            return (int) product;\n        }\n\n        public static long longpow(long x, long n, long mod) {\n            if (n == 0) {\n                return 1;\n            }\n            long prod = longpow(x, n >> 1, mod);\n            prod = modmul(prod, prod, mod);\n            if ((n & 1) == 1) {\n                prod = modmul(prod, x, mod);\n            }\n            return prod;\n        }\n\n        /**\n         * Get x % mod\n         */\n        public static int mod(int x, int mod) {\n            x %= mod;\n            if (x < 0) {\n                x += mod;\n            }\n            return x;\n        }\n\n        public static int mod(long x, int mod) {\n            x %= mod;\n            if (x < 0) {\n                x += mod;\n            }\n            return (int) x;\n        }\n\n        /**\n         * Get n!/(n-m)!\n         */\n        public static long permute(int n, int m) {\n            return m == 0 ? 1 : n * permute(n - 1, m - 1);\n        }\n\n        /**\n         * Put all primes less or equal to limit into primes after offset\n         */\n        public static int eulerSieve(int limit, int[] primes, int offset) {\n            boolean[] isComp = new boolean[limit + 1];\n            int wpos = offset;\n            for (int i = 2; i <= limit; i++) {\n                if (!isComp[i]) {\n                    primes[wpos++] = i;\n                }\n                for (int j = offset, until = limit / i; j < wpos && primes[j] <= until; j++) {\n                    int pi = primes[j] * i;\n                    isComp[pi] = true;\n                    if (i % primes[j] == 0) {\n                        break;\n                    }\n                }\n            }\n            return wpos - offset;\n        }\n\n        /**\n         * Round x into integer\n         */\n        public static int intRound(double x) {\n            if (x < 0) {\n                return -(int) (-x + 0.5);\n            }\n            return (int) (x + 0.5);\n        }\n\n        /**\n         * Round x into long\n         */\n        public static long longRound(double x) {\n            if (x < 0) {\n                return -(long) (-x + 0.5);\n            }\n            return (long) (x + 0.5);\n        }\n    }\n\n    public static class FastIO {\n        public final StringBuilder cache = new StringBuilder();\n        private final InputStream is;\n        private final OutputStream os;\n        private final Charset charset;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 8);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastIO(InputStream is, OutputStream os, Charset charset) {\n            this.is = is;\n            this.os = os;\n            this.charset = charset;\n        }\n\n        public FastIO(InputStream is, OutputStream os) {\n            this(is, os, Charset.forName(""ascii""));\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public double readDouble() {\n            boolean sign = true;\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+';\n                next = read();\n            }\n\n            long val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 + next - '0';\n                next = read();\n            }\n            if (next != '.') {\n                return sign ? val : -val;\n            }\n            next = read();\n            long radix = 1;\n            long point = 0;\n            while (next >= '0' && next <= '9') {\n                point = point * 10 + next - '0';\n                radix = radix * 10;\n                next = read();\n            }\n            double result = val + (double) point / radix;\n            return sign ? result : -result;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n        public int readLine(char[] data, int offset) {\n            int originalOffset = offset;\n            while (next != -1 && next != '\n') {\n                data[offset++] = (char) next;\n                next = read();\n            }\n            return offset - originalOffset;\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public int readString(byte[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (byte) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n        public void flush() {\n            try {\n                os.write(cache.toString().getBytes(charset));\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public boolean hasMore() {\n            skipBlank();\n            return next != -1;\n        }\n    }\n\n    public static class Debug {\n        private boolean allowDebug;\n\n        public Debug(boolean allowDebug) {\n            this.allowDebug = allowDebug;\n        }\n\n        public void assertTrue(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (!flag) {\n                fail();\n            }\n        }\n\n        public void fail() {\n            throw new RuntimeException();\n        }\n\n        public void assertFalse(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (flag) {\n                fail();\n            }\n        }\n\n        private void outputName(String name) {\n            System.out.print(name + "" = "");\n        }\n\n        public void debug(String name, int x) {\n            if (!allowDebug) {\n                return;\n            }\n\n            outputName(name);\n            System.out.println("""" + x);\n        }\n\n        public void debug(String name, long x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println("""" + x);\n        }\n\n        public void debug(String name, double x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println("""" + x);\n        }\n\n        public void debug(String name, int[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, long[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, double[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, Object x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println("""" + x);\n        }\n\n        public void debug(String name, Object... x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.deepToString(x));\n        }\n    }\n}\n","fft,math"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1117G extends PrintWriter {\n	CF1117G() { super(System.out, true); }\n	static class Scanner {\n		Scanner(InputStream in) { this.in = in; } InputStream in;\n		int k, l; byte[] bb = new byte[1 << 15];\n		byte getc() {\n			if (k >= l) {\n				k = 0;\n				try { l = in.read(bb); } catch (IOException e) { l = 0; }\n				if (l <= 0) return -1;\n			}\n			return bb[k++];\n		}\n		int nextInt() {\n			byte c = 0; while (c <= 32) c = getc();\n			int a = 0;\n			while (c > 32) { a = a * 10 + c - '0'; c = getc(); }\n			return a;\n		}\n	}\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1117G o = new CF1117G(); o.main(); o.flush();\n	}\n\n	long[] ss, cc;\n	void update(long[] ft, int i, int n, int x) {\n		while (i < n) {\n			ft[i] += x;\n			i |= i + 1;\n		}\n	}\n	long query(long[] ft, int i) {\n		long x = 0;\n		while (i >= 0) {\n			x += ft[i];\n			i &= i + 1; i--;\n		}\n		return x;\n	}\n	int[] qu, pp;\n	Integer[] ii, hh;\n	void solve(int[] aa, int n, int[] ll, int[] rr, long[] ans, int q) {\n		int cnt = 0;\n		for (int i = 0; i < n; i++) {\n			while (cnt > 0 && aa[qu[cnt - 1]] <= aa[i])\n				cnt--;\n			pp[i] = cnt == 0 ? 0 : qu[cnt - 1] + 1;\n			qu[cnt++] = i;\n		}\n		Arrays.fill(ss, 0);\n		Arrays.fill(cc, 0);\n		for (int i = 0; i < n; i++)\n			update(ss, i, n, pp[i]);\n		Arrays.sort(ii, (i, j) -> pp[i] - pp[j]);\n		Arrays.sort(hh, (i, j) -> ll[i] - ll[j]);\n		for (int h_ = 0, i_ = 0; h_ < q; h_++) {\n			int h = hh[h_], i, l = ll[h], r = rr[h];\n			while (i_ < n && pp[i = ii[i_]] < l) {\n				update(ss, i, n, -pp[i]);\n				update(cc, i, n, 1);\n				i_++;\n			}\n			ans[h] += query(ss, r) - query(ss, l - 1)\n				+ (query(cc, r) - query(cc, l - 1)) * l;\n		}\n	}\n	void main() {\n		int n = sc.nextInt();\n		int q = sc.nextInt();\n		ss = new long[n]; cc = new long[n];\n		qu = new int[n]; pp = new int[n];\n		ii = new Integer[n];\n		for (int i = 0; i < n; i++)\n			ii[i] = i;\n		hh = new Integer[q];\n		for (int h = 0; h < q; h++)\n			hh[h] = h;\n		int[] aa = new int[n];\n		for (int i = 0; i < n; i++)\n			aa[i] = sc.nextInt() - 1;\n		int[] ll = new int[q];\n		int[] rr = new int[q];\n		for (int h = 0; h < q; h++)\n			ll[h] = sc.nextInt() - 1;\n		for (int h = 0; h < q; h++)\n			rr[h] = sc.nextInt() - 1;\n		long[] ans = new long[q];\n		solve(aa, n, ll, rr, ans, q);\n		for (int i = 0, j = n - 1; i < j; i++, j--) {\n			int tmp = aa[i]; aa[i] = aa[j]; aa[j] = tmp;\n		}\n		for (int h = 0; h < q; h++) {\n			int l = n - 1 - rr[h];\n			int r = n - 1 - ll[h];\n			ll[h] = l;\n			rr[h] = r;\n		}\n		solve(aa, n, ll, rr, ans, q);\n		for (int h = 0; h < q; h++)\n			print((long) n * (rr[h] - ll[h] + 1) - ans[h] + "" "");\n		println();\n	}\n}\n",data structures
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.Writer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Niyaz Nigmatullin\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        FastPrinter out = new FastPrinter(outputStream);\n        TaskG solver = new TaskG();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskG {\n        public void solve(int testNumber, FastScanner in, FastPrinter out) {\n            int n = in.nextInt();\n            int q = in.nextInt();\n            int[] p = new int[n];\n            for (int i = 0; i < n; i++) {\n                p[i] = in.nextInt();\n            }\n            TaskG.Query[] qs = new TaskG.Query[q];\n            int[] leftQ = in.readIntArray(q);\n            int[] rightQ = in.readIntArray(q);\n            for (int i = 0; i < q; i++) {\n                qs[i] = new TaskG.Query(leftQ[i] - 1, rightQ[i] - 1);\n            }\n            solve(p, qs);\n            ArrayUtils.reverse(p);\n            for (int i = 0; i < q; i++) {\n                int v = qs[i].left;\n                qs[i].left = n - qs[i].right - 1;\n                qs[i].right = n - v - 1;\n            }\n            solve(p, qs);\n            long[] ans = new long[qs.length];\n            for (int i = 0; i < qs.length; i++) {\n                TaskG.Query e = qs[i];\n                ans[i] = e.ans + e.right - e.left + 1;\n            }\n            out.printArray(ans);\n        }\n\n        static void solve(int[] p, TaskG.Query[] qs) {\n            int n = p.length;\n            int[] stack = new int[n];\n            int sn = 0;\n            int[] left = new int[n];\n            for (int i = 0; i < n; i++) {\n                while (sn > 0 && p[stack[sn - 1]] < p[i]) --sn;\n                left[i] = sn > 0 ? stack[sn - 1] : -1;\n                stack[sn++] = i;\n            }\n            List<TaskG.Query>[] queries = new List[n];\n            List<Integer>[] opens = new List[n];\n            for (int i = 0; i < n; i++) opens[i] = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                if (left[i] >= 0) opens[left[i]].add(i);\n            }\n            for (int i = 0; i < n; i++) queries[i] = new ArrayList<>();\n            for (TaskG.Query e : qs) queries[e.left].add(e);\n            FenwickLong f1 = new FenwickLong(n);\n            Fenwick f1Count = new Fenwick(n);\n            for (int i = n - 1; i >= 0; i--) {\n                f1.add(i, i);\n                f1Count.add(i, 1);\n                for (int j : opens[i]) {\n                    f1.add(j, -j);\n                    f1Count.add(j, -1);\n                    f1.add(j, j - left[j] - 1);\n                }\n                for (TaskG.Query e : queries[i]) {\n                    e.ans += f1.getSum(e.left, e.right + 1) - (long) e.left * f1Count.getSum(e.left, e.right + 1);\n                }\n            }\n        }\n\n        static class Query {\n            int left;\n            int right;\n            long ans;\n\n            public Query(int left, int right) {\n                this.left = left;\n                this.right = right;\n            }\n\n        }\n\n    }\n\n    static class FastScanner extends BufferedReader {\n        public FastScanner(InputStream is) {\n            super(new InputStreamReader(is));\n        }\n\n        public int read() {\n            try {\n                int ret = super.read();\n//            if (isEOF && ret < 0) {\n//                throw new InputMismatchException();\n//            }\n//            isEOF = ret == -1;\n                return ret;\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n        }\n\n        static boolean isWhiteSpace(int c) {\n            return c >= 0 && c <= 32;\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isWhiteSpace(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int ret = 0;\n            while (c >= 0 && !isWhiteSpace(c)) {\n                if (c < '0' || c > '9') {\n                    throw new NumberFormatException(""digit expected "" + (char) c\n                            + "" found"");\n                }\n                ret = ret * 10 + c - '0';\n                c = read();\n            }\n            return ret * sgn;\n        }\n\n        public String readLine() {\n            try {\n                return super.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        public int[] readIntArray(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n    }\n\n    static class FastPrinter extends PrintWriter {\n        public FastPrinter(OutputStream out) {\n            super(out);\n        }\n\n        public FastPrinter(Writer out) {\n            super(out);\n        }\n\n        public void printArray(long[] a) {\n            for (int i = 0; i < a.length; i++) {\n                if (i > 0) {\n                    print(' ');\n                }\n                print(a[i]);\n            }\n            println();\n        }\n\n    }\n\n    static class Fenwick {\n        int[] a;\n\n        public Fenwick(int n) {\n            a = new int[n];\n        }\n\n        public void add(int x, int y) {\n            for (int i = x; i < a.length; i |= i + 1) {\n                a[i] += y;\n            }\n        }\n\n        public int getSum(int x) {\n            if (x >= a.length) x = a.length - 1;\n            int ret = 0;\n            for (int i = x; i >= 0; i = (i & (i + 1)) - 1) {\n                ret += a[i];\n            }\n            return ret;\n        }\n\n        public int getSum(int l, int r) {\n            return getSum(r - 1) - getSum(l - 1);\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static void reverse(int[] c, int start, int end) {\n            for (int i = start, j = end - 1; i < j; i++, j--) {\n                int t = c[i];\n                c[i] = c[j];\n                c[j] = t;\n            }\n        }\n\n        public static void reverse(int[] c) {\n            reverse(c, 0, c.length);\n        }\n\n    }\n\n    static class FenwickLong {\n        long[] a;\n\n        public FenwickLong(int n) {\n            a = new long[n];\n        }\n\n        public void add(int x, long y) {\n            for (int i = x; i < a.length; i |= i + 1) {\n                a[i] += y;\n            }\n        }\n\n        public long getSum(int x) {\n            if (x >= a.length) x = a.length - 1;\n            long ret = 0;\n            for (int i = x; i >= 0; i = (i & (i + 1)) - 1) {\n                ret += a[i];\n            }\n            return ret;\n        }\n\n        public long getSum(int l, int r) {\n            return getSum(r - 1) - getSum(l - 1);\n        }\n\n    }\n}\n\n",data structures
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.Writer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Niyaz Nigmatullin\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        FastPrinter out = new FastPrinter(outputStream);\n        TaskG solver = new TaskG();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskG {\n        public void solve(int testNumber, FastScanner in, FastPrinter out) {\n            int n = in.nextInt();\n            int q = in.nextInt();\n            int[] p = new int[n];\n            for (int i = 0; i < n; i++) {\n                p[i] = in.nextInt();\n            }\n            TaskG.Query[] qs = new TaskG.Query[q];\n            int[] leftQ = in.readIntArray(q);\n            int[] rightQ = in.readIntArray(q);\n            for (int i = 0; i < q; i++) {\n                qs[i] = new TaskG.Query(leftQ[i] - 1, rightQ[i] - 1);\n            }\n            solve(p, qs);\n            ArrayUtils.reverse(p);\n            for (int i = 0; i < q; i++) {\n                int v = qs[i].left;\n                qs[i].left = n - qs[i].right - 1;\n                qs[i].right = n - v - 1;\n            }\n            solve(p, qs);\n            long[] ans = new long[qs.length];\n            for (int i = 0; i < qs.length; i++) {\n                TaskG.Query e = qs[i];\n                ans[i] = e.ans + e.right - e.left + 1;\n            }\n            out.printArray(ans);\n        }\n\n        static void solve(int[] p, TaskG.Query[] qs) {\n            int n = p.length;\n            int[] stack = new int[n];\n            int sn = 0;\n            int[] left = new int[n];\n            for (int i = 0; i < n; i++) {\n                while (sn > 0 && p[stack[sn - 1]] < p[i]) --sn;\n                left[i] = sn > 0 ? stack[sn - 1] : -1;\n                stack[sn++] = i;\n            }\n            List<TaskG.Query>[] queries = new List[n];\n            List<Integer>[] opens = new List[n];\n            for (int i = 0; i < n; i++) opens[i] = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                if (left[i] >= 0) opens[left[i]].add(i);\n            }\n            for (int i = 0; i < n; i++) queries[i] = new ArrayList<>();\n            for (TaskG.Query e : qs) queries[e.left].add(e);\n            FenwickLong f1 = new FenwickLong(n);\n            Fenwick f1Count = new Fenwick(n);\n            FenwickLong f2 = new FenwickLong(n);\n            for (int i = n - 1; i >= 0; i--) {\n                f1.add(i, i);\n                f1Count.add(i, 1);\n                for (int j : opens[i]) {\n                    f1.add(j, -j);\n                    f1Count.add(j, -1);\n                    f2.add(j, j - left[j] - 1);\n                }\n                for (TaskG.Query e : queries[i]) {\n                    e.ans += f2.getSum(e.left, e.right + 1);\n                    e.ans += f1.getSum(e.left, e.right + 1) - (long) e.left * f1Count.getSum(e.left, e.right + 1);\n                }\n            }\n        }\n\n        static class Query {\n            int left;\n            int right;\n            long ans;\n\n            public Query(int left, int right) {\n                this.left = left;\n                this.right = right;\n            }\n\n        }\n\n    }\n\n    static class FastScanner extends BufferedReader {\n        public FastScanner(InputStream is) {\n            super(new InputStreamReader(is));\n        }\n\n        public int read() {\n            try {\n                int ret = super.read();\n//            if (isEOF && ret < 0) {\n//                throw new InputMismatchException();\n//            }\n//            isEOF = ret == -1;\n                return ret;\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n        }\n\n        static boolean isWhiteSpace(int c) {\n            return c >= 0 && c <= 32;\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isWhiteSpace(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int ret = 0;\n            while (c >= 0 && !isWhiteSpace(c)) {\n                if (c < '0' || c > '9') {\n                    throw new NumberFormatException(""digit expected "" + (char) c\n                            + "" found"");\n                }\n                ret = ret * 10 + c - '0';\n                c = read();\n            }\n            return ret * sgn;\n        }\n\n        public String readLine() {\n            try {\n                return super.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        public int[] readIntArray(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n    }\n\n    static class FastPrinter extends PrintWriter {\n        public FastPrinter(OutputStream out) {\n            super(out);\n        }\n\n        public FastPrinter(Writer out) {\n            super(out);\n        }\n\n        public void printArray(long[] a) {\n            for (int i = 0; i < a.length; i++) {\n                if (i > 0) {\n                    print(' ');\n                }\n                print(a[i]);\n            }\n            println();\n        }\n\n    }\n\n    static class Fenwick {\n        int[] a;\n\n        public Fenwick(int n) {\n            a = new int[n];\n        }\n\n        public void add(int x, int y) {\n            for (int i = x; i < a.length; i |= i + 1) {\n                a[i] += y;\n            }\n        }\n\n        public int getSum(int x) {\n            if (x >= a.length) x = a.length - 1;\n            int ret = 0;\n            for (int i = x; i >= 0; i = (i & (i + 1)) - 1) {\n                ret += a[i];\n            }\n            return ret;\n        }\n\n        public int getSum(int l, int r) {\n            return getSum(r - 1) - getSum(l - 1);\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static void reverse(int[] c, int start, int end) {\n            for (int i = start, j = end - 1; i < j; i++, j--) {\n                int t = c[i];\n                c[i] = c[j];\n                c[j] = t;\n            }\n        }\n\n        public static void reverse(int[] c) {\n            reverse(c, 0, c.length);\n        }\n\n    }\n\n    static class FenwickLong {\n        long[] a;\n\n        public FenwickLong(int n) {\n            a = new long[n];\n        }\n\n        public void add(int x, long y) {\n            for (int i = x; i < a.length; i |= i + 1) {\n                a[i] += y;\n            }\n        }\n\n        public long getSum(int x) {\n            if (x >= a.length) x = a.length - 1;\n            long ret = 0;\n            for (int i = x; i >= 0; i = (i & (i + 1)) - 1) {\n                ret += a[i];\n            }\n            return ret;\n        }\n\n        public long getSum(int l, int r) {\n            return getSum(r - 1) - getSum(l - 1);\n        }\n\n    }\n}\n\n",data structures
" import java.util.*;\n \npublic class magicship {\n static long dx,dy;\n static int x1,y1,x2,y2;\n public static void main(String[] args) {\n  Scanner scan=new Scanner(System.in);\n  x1=scan.nextInt();\n  y1=scan.nextInt();\n  x2=scan.nextInt();\n  y2=scan.nextInt();\n  int n=scan.nextInt();\n  char[] s=scan.next().toCharArray();\n  dx=0L;dy=0L;\n  for(int i=0;i<n;i++) {\n   if(s[i]=='U') dy++;\n   if(s[i]=='D') dy--;\n   if(s[i]=='R') dx++;\n   if(s[i]=='L') dx--;\n  }\n  long lo=0, hi=(long)1e18;\n  while(hi>=lo) {\n   long mid=(hi+lo)/2;\n   if(!good(mid,s)) lo=mid+1;\n   else hi=mid-1;\n  }\n  if(lo>=1e15) System.out.println(-1);\n  else System.out.println(lo);\n }\n public static boolean good(long test, char[] s) {\n  long full=test/s.length;\n  long posx=x1+dx*full, posy=y1+dy*full;\n  for(int id=0;;id++) {\n   if(full*s.length+id==test) break;\n   if(s[id]=='U') posy++;\n   if(s[id]=='D') posy--;\n   if(s[id]=='L') posx--;\n   if(s[id]=='R') posx++;\n\n  }\n  return Math.abs(posx-x2)+Math.abs(posy-y2)<=test;\n }\n}",binary search
"import java.util.*;\nimport java.io.*;\n \npublic class magic_ship {\n	\n	public static void main(String[] args)\n	{\n		Scanner sc =new Scanner(System.in);\n		\n			long x1=sc.nextLong();\n			long y1=sc.nextLong();\n			long x2=sc.nextLong();\n			long y2=sc.nextLong();\n			int n=sc.nextInt();\n			String s=sc.next();int l=0,u=0,d=0,r=0;\n			for(int i=0;i<s.length();i++)\n			{\n				if(s.charAt(i)=='L')\n					l++;\n				if(s.charAt(i)=='U')\n					u++;\n				if(s.charAt(i)=='D')\n					d++;\n				if(s.charAt(i)=='R')\n					r++;\n			}\n			long x=r-l;\n			long y=u-d;\n\n			long beg=1;\n			long last=(long)Math.pow(10,14);\n\n			if(CalDist(last,x,y,x1,y1,x2,y2,s)==-1)\n			{\n				System.out.println(""-1"");\n				return;\n			}\n			long mid=0;int v;\n			while(beg<=last)\n			{\n              	if(mid==(beg+last)/2)\n                	break;\n				mid=(beg+last)/2;\n				v=CalDist(mid,x,y,x1,y1,x2,y2,s);\n				if(v==1)\n				{\n					last=mid;\n				}\n				else\n				{\n					beg=mid+1;\n				}\n\n			}\n			System.out.println(mid);\n \n	}\n	static int CalDist(long dist,long x,long y,long x1,long y1,long x2,long y2,String s)\n	{\n      	int n=s.length();\n		long k=dist/n;\n		x1=x1+k*(x);\n		y1=y1+k*(y);\n		long m=dist%n;\n		for(int i=0;i<m;i++)\n			{\n				if(s.charAt(i)=='L')\n					x1--;\n				if(s.charAt(i)=='U')\n					y1++;\n				if(s.charAt(i)=='D')\n					y1--;\n				if(s.charAt(i)=='R')\n					x1++;\n			}\n\n      \n		long v=(Math.abs(x2-x1)+Math.abs(y2-y1));\n		if(v<=dist)\n			return 1;\n		else\n			return -1;\n	} \n	\n}\n",binary search
"//package com.adityap.thecool;\nimport java.util.*;\npublic class Main {\n    static int x1, y1, x2, y2, n;\n    static String s;\n    static long[][] posWindOnly;\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        x1 = in.nextInt(); y1 = in.nextInt(); in.nextLine();\n        x2 = in.nextInt(); y2 = in.nextInt(); in.nextLine();\n        if (x1==x2&&y1==y2) {\n            System.out.println(0); return;\n        }\n        n = in.nextInt(); in.nextLine();\n        s = in.nextLine();\n        posWindOnly = new long[s.length()+1][2];\n        posWindOnly[0] = new long[]{0L, 0L};\n        int cx = 0, cy = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char d = s.charAt(i);\n            if (d == 'U') {\n                cy += 1;\n            } else if (d == 'D') {\n                cy -= 1;\n            } else if (d == 'L') {\n                cx -= 1;\n            } else cx += 1;\n            posWindOnly[i+1] = new long[2];\n            posWindOnly[i+1][0] = cx; posWindOnly[i+1][1] = cy;\n        }\n        long lo = 1, hi = (long)1e18, ans = -1;\n        while (lo <= hi) {\n            long mid = lo+(hi-lo)/2;\n            long x = x1+posWindOnly[(int)(mid%n)][0]+(mid/n)*posWindOnly[n][0];\n            long y = y1+posWindOnly[(int)(mid%n)][1]+(mid/n)*posWindOnly[n][1];\n            long d = Math.abs(x2-x)+Math.abs(y2-y);\n            if (d <= mid) {\n                ans = mid; hi = mid-1;\n            } else lo = mid+1;\n        }\n        System.out.println(ans);\n    }\n}\n",binary search
"import java.io.*;\nimport java.util.*;\npublic class ship\n{\n	public static void main(String[] args)\n	{\n		Scanner sc =new Scanner(System.in);\n		\n			long x1=sc.nextLong();\n			long y1=sc.nextLong();\n			long x2=sc.nextLong();\n			long y2=sc.nextLong();\n			int n=sc.nextInt();\n			String s=sc.next();int l=0,u=0,d=0,r=0;\n			for(int i=0;i<s.length();i++)\n			{\n				if(s.charAt(i)=='L')\n					l++;\n				if(s.charAt(i)=='U')\n					u++;\n				if(s.charAt(i)=='D')\n					d++;\n				if(s.charAt(i)=='R')\n					r++;\n			}\n			long x=r-l;\n			long y=u-d;\n          //System.out.println(x+"",""+y);\n			long beg=1;\n			long last=(long)Math.pow(10,14);\n            //System.out.print(last);\n			if(CalDist(last,x,y,x1,y1,x2,y2,s)==-1)\n			{\n				System.out.println(""-1"");\n				return;\n			}\n			long mid=0;int v;\n			while(beg<=last)\n			{\n              	if(mid==(beg+last)/2)\n                	break;\n				mid=(beg+last)/2;\n				v=CalDist(mid,x,y,x1,y1,x2,y2,s);\n				if(v==1)\n				{\n					last=mid;\n				}\n				else\n				{\n					beg=mid+1;\n				}\n               //System.out.println(""*""+mid+"" ""+beg+"",""+last);\n			}\n			System.out.println(mid);\n\n	}\n	static int CalDist(long dist,long x,long y,long x1,long y1,long x2,long y2,String s)\n	{\n      	int n=s.length();\n		long k=dist/n;\n		x1=x1+k*(x);\n		y1=y1+k*(y);\n		long m=dist%n;\n		for(int i=0;i<m;i++)\n			{\n				if(s.charAt(i)=='L')\n					x1--;\n				if(s.charAt(i)=='U')\n					y1++;\n				if(s.charAt(i)=='D')\n					y1--;\n				if(s.charAt(i)=='R')\n					x1++;\n			}\n        //System.out.println(""c""+x1+"" ""+y1);\n      \n		long v=(Math.abs(x2-x1)+Math.abs(y2-y1));\n		if(v<=dist)\n			return 1;\n		else\n			return -1;\n	} \n}",binary search
"import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class D {\n	FastScanner in;\n	PrintWriter out;\n	boolean systemIO = true;\n\n	int mod = 998244353;\n\n	public int sum(int x, int y) {\n		if (x + y >= mod) {\n			return x + y - mod;\n		}\n		return x + y;\n	}\n\n	public int diff(int x, int y) {\n		if (x >= y) {\n			return x - y;\n		}\n		return x - y + mod;\n	}\n\n	public int mult(int x, int y) {\n		return (int) (x * 1L * y % mod);\n	}\n\n	public int pow(int x, long p) {\n		int ans = 1;\n		while (p > 0) {\n			if ((p & 1) == 1) {\n				ans = mult(ans, x);\n			}\n			x = mult(x, x);\n			p >>= 1;\n		}\n		return ans;\n	}\n\n	public int inv(int x) {\n		return pow(x, mod - 2);\n	}\n\n	public int div(int x, int y) {\n		return mult(x, inv(y));\n	}\n	\n	public class DSU {\n		int[] sz;\n		int[] p;\n\n		public DSU(int n) {\n			sz = new int[n];\n			p = new int[n];\n			for (int i = 0; i < p.length; i++) {\n				p[i] = i;\n				sz[i] = 1;\n			}\n		}\n\n		public int get(int x) {\n			if (x == p[x]) {\n				return x;\n			}\n			int par = get(p[x]);\n			p[x] = par;\n			return par;\n		}\n\n		public boolean unite(int a, int b) {\n			int pa = get(a);\n			int pb = get(b);\n			if (pa == pb) {\n				return false;\n			}\n			if (sz[pa] < sz[pb]) {\n				p[pa] = pb;\n				sz[pb] += sz[pa];\n			} else {\n				p[pb] = pa;\n				sz[pa] += sz[pb];\n			}\n			return true;\n		}\n	}\n\n	public class SegmentTreeAdd {\n		int pow;\n		long[] max;\n		long[] delta;\n		boolean[] flag;\n\n		public SegmentTreeAdd(long[] a) {\n			pow = 1;\n			while (pow < a.length) {\n				pow *= 2;\n			}\n			flag = new boolean[2 * pow];\n			max = new long[2 * pow];\n			delta = new long[2 * pow];\n			for (int i = 0; i < max.length; i++) {\n				max[i] = Long.MIN_VALUE / 2;\n			}\n			for (int i = 0; i < a.length; i++) {\n				max[pow + i] = a[i];\n			}\n			for (int i = pow - 1; i > 0; i--) {\n				max[i] = f(max[2 * i], max[2 * i + 1]);\n			}\n		}\n\n		public long get(int v, int tl, int tr, int l, int r) {\n			push(v, tl, tr);\n			if (l > r) {\n				return Long.MIN_VALUE / 2;\n			}\n			if (l == tl && r == tr) {\n				return max[v];\n			}\n			int tm = (tl + tr) / 2;\n			return f(get(2 * v, tl, tm, l, Math.min(r, tm)), get(2 * v + 1, tm + 1, tr, Math.max(l, tm + 1), r));\n		}\n\n		public void set(int v, int tl, int tr, int l, int r, long x) {\n			push(v, tl, tr);\n			if (l > tr || r < tl) {\n				return;\n			}\n			if (l <= tl && r >= tr) {\n				delta[v] += x;\n				flag[v] = true;\n				push(v, tl, tr);\n				return;\n			}\n			int tm = (tl + tr) / 2;\n			set(2 * v, tl, tm, l, r, x);\n			set(2 * v + 1, tm + 1, tr, l, r, x);\n			max[v] = f(max[2 * v], max[2 * v + 1]);\n		}\n\n		public void push(int v, int tl, int tr) {\n			if (flag[v]) {\n				if (v < pow) {\n					flag[2 * v] = true;\n					flag[2 * v + 1] = true;\n					delta[2 * v] += delta[v];\n					delta[2 * v + 1] += delta[v];\n				}\n				flag[v] = false;\n				max[v] += delta[v];\n				delta[v] = 0;\n			}\n		}\n\n		public long f(long a, long b) {\n			return Math.max(a, b);\n		}\n	}\n\n	public class SegmentTreeSet {\n		int pow;\n		int[] sum;\n		int[] delta;\n		boolean[] flag;\n\n		public SegmentTreeSet(int[] a) {\n			pow = 1;\n			while (pow < a.length) {\n				pow *= 2;\n			}\n			flag = new boolean[2 * pow];\n			sum = new int[2 * pow];\n			delta = new int[2 * pow];\n			for (int i = 0; i < a.length; i++) {\n				sum[pow + i] = a[i];\n			}\n			for (int i = pow - 1; i > 0; i--) {\n				sum[i] = f(sum[2 * i], sum[2 * i + 1]);\n			}\n		}\n\n		public int get(int v, int tl, int tr, int l, int r) {\n			push(v, tl, tr);\n			if (l > r) {\n				return 0;\n			}\n			if (l == tl && r == tr) {\n				return sum[v];\n			}\n			int tm = (tl + tr) / 2;\n			return f(get(2 * v, tl, tm, l, Math.min(r, tm)), get(2 * v + 1, tm + 1, tr, Math.max(l, tm + 1), r));\n		}\n\n		public void set(int v, int tl, int tr, int l, int r, int x) {\n			push(v, tl, tr);\n			if (l > tr || r < tl) {\n				return;\n			}\n			if (l <= tl && r >= tr) {\n				delta[v] = x;\n				flag[v] = true;\n				push(v, tl, tr);\n				return;\n			}\n			int tm = (tl + tr) / 2;\n			set(2 * v, tl, tm, l, r, x);\n			set(2 * v + 1, tm + 1, tr, l, r, x);\n			sum[v] = f(sum[2 * v], sum[2 * v + 1]);\n		}\n\n		public void push(int v, int tl, int tr) {\n			if (flag[v]) {\n				if (v < pow) {\n					flag[2 * v] = true;\n					flag[2 * v + 1] = true;\n					delta[2 * v] = delta[v];\n					delta[2 * v + 1] = delta[v];\n				}\n				flag[v] = false;\n				sum[v] = delta[v] * (tr - tl + 1);\n			}\n		}\n\n		public int f(int a, int b) {\n			return a + b;\n		}\n	}\n\n	public class Pair implements Comparable<Pair> {\n		int x;\n		int y;\n\n		public Pair(int x, int y) {\n			this.x = x;\n			this.y = y;\n		}\n\n		public Pair clone() {\n			return new Pair(x, y);\n		}\n\n		public String toString() {\n			return x + "" "" + y;\n		}\n\n		@Override\n		public int compareTo(Pair o) {\n			if (x > o.x) {\n				return 1;\n			}\n			if (x < o.x) {\n				return -1;\n			}\n			if (y > o.y) {\n				return 1;\n			}\n			if (y < o.y) {\n				return -1;\n			}\n			return 0;\n		}\n	}\n\n	Random random = new Random();\n\n	public void shuffle(Pair[] a) {\n		for (int i = 0; i < a.length; i++) {\n			int x = random.nextInt(i + 1);\n			Pair t = a[x];\n			a[x] = a[i];\n			a[i] = t;\n		}\n	}\n\n	public void sort(int[][] a) {\n		for (int i = 0; i < a.length; i++) {\n			Arrays.sort(a[i]);\n		}\n	}\n\n	public void add(Map<Long, Integer> map, long l) {\n		if (map.containsKey(l)) {\n			map.put(l, map.get(l) + 1);\n		} else {\n			map.put(l, 1);\n		}\n	}\n\n	public void remove(Map<Integer, Integer> map, Integer s) {\n		if (map.get(s) > 1) {\n			map.put(s, map.get(s) - 1);\n		} else {\n			map.remove(s);\n		}\n	}\n\n	long max = Long.MAX_VALUE / 2;\n	double eps = 1e-10;\n\n	public int signum(double x) {\n		if (x > eps) {\n			return 1;\n		}\n		if (x < -eps) {\n			return -1;\n		}\n		return 0;\n	}\n\n	public long abs(long x) {\n		return x < 0 ? -x : x;\n	}\n\n	public long min(long x, long y) {\n		return x < y ? x : y;\n	}\n\n	public long max(long x, long y) {\n		return x > y ? x : y;\n	}\n\n	public long gcd(long x, long y) {\n		while (y > 0) {\n			long c = y;\n			y = x % y;\n			x = c;\n		}\n		return x;\n	}\n\n	public final Vector ZERO = new Vector(0, 0);\n\n	// public class Vector implements Comparable<Vector> {\n	// long x;\n	// long y;\n	// int type;\n	// int number;\n	//\n	// public Vector() {\n	// x = 0;\n	// y = 0;\n	// }\n	//\n	// public Vector(long x, long y, int type, int number) {\n	// this.x = x;\n	// this.y = y;\n	// this.type = type;\n	// this.number = number;\n	// }\n	//\n	// public Vector(long x, long y) {\n	//\n	// }\n	//\n	// public Vector(Point begin, Point end) {\n	// this(end.x - begin.x, end.y - begin.y);\n	// }\n	//\n	// public void orient() {\n	// if (x < 0) {\n	// x = -x;\n	// y = -y;\n	// }\n	// if (x == 0 && y < 0) {\n	// y = -y;\n	// }\n	// }\n	//\n	// public void normalize() {\n	// long gcd = gcd(abs(x), abs(y));\n	// x /= gcd;\n	// y /= gcd;\n	// }\n	//\n	// public String toString() {\n	// return x + "" "" + y;\n	// }\n	//\n	// public boolean equals(Vector v) {\n	// return x == v.x && y == v.y;\n	// }\n	//\n	// public boolean collinear(Vector v) {\n	// return cp(this, v) == 0;\n	// }\n	//\n	// public boolean orthogonal(Vector v) {\n	// return dp(this, v) == 0;\n	// }\n	//\n	// public Vector ort(Vector v) {\n	// return new Vector(-y, x);\n	// }\n	//\n	// public Vector add(Vector v) {\n	// return new Vector(x + v.x, y + v.y);\n	// }\n	//\n	// public Vector multiply(long c) {\n	// return new Vector(c * x, c * y);\n	// }\n	//\n	// public int quater() {\n	// if (x > 0 && y >= 0) {\n	// return 1;\n	// }\n	// if (x <= 0 && y > 0) {\n	// return 2;\n	// }\n	// if (x < 0) {\n	// return 3;\n	// }\n	// return 0;\n	// }\n	//\n	// public long len2() {\n	// return x * x + y * y;\n	// }\n	//\n	// @Override\n	// public int compareTo(Vector o) {\n	// if (quater() != o.quater()) {\n	// return quater() - o.quater();\n	// }\n	// return signum(cp(o, this));\n	// }\n	// }\n\n	// public long dp(Vector v1, Vector v2) {\n	// return v1.x * v2.x + v1.y * v2.y;\n	// }\n	//\n	// public long cp(Vector v1, Vector v2) {\n	// return v1.x * v2.y - v1.y * v2.x;\n	// }\n\n	// public class Line implements Comparable<Line> {\n	// Point p;\n	// Vector v;\n	//\n	// public Line(Point p, Vector v) {\n	// this.p = p;\n	// this.v = v;\n	// }\n	//\n	// public Line(Point p1, Point p2) {\n	// if (p1.compareTo(p2) < 0) {\n	// p = p1;\n	// v = new Vector(p1, p2);\n	// } else {\n	// p = p2;\n	// v = new Vector();\n	// }\n	// }\n	//\n	// public boolean collinear(Line l) {\n	// return v.collinear(l.v);\n	// }\n	//\n	// public boolean inLine(Point p) {\n	// return hv(p) == 0;\n	// }\n	//\n	// public boolean inSegment(Point p) {\n	// if (!inLine(p)) {\n	// return false;\n	// }\n	// Point p1 = p;\n	// Point p2 = p.add(v);\n	// return p1.x <= p.x && p.x <= p2.x && min(p1.y, p2.y) <= p.y && p.y <=\n	// max(p1.y, p2.y);\n	// }\n	//\n	// public boolean equalsSegment(Line l) {\n	// return p.equals(l.p) && v.equals(l.v);\n	// }\n	//\n	// public boolean equalsLine(Line l) {\n	// return collinear(l) && inLine(l.p);\n	// }\n	//\n	// public long hv(Point p) {\n	// Vector v1 = new Vector(this.p, p);\n	// return cp(v, v1);\n	// }\n	//\n	// public double h(Point p) {\n	// Vector v1 = new Vector(this.p, p);\n	// return cp(v, v1) / Math.sqrt(v.len2());\n	// }\n	//\n	// public long[] intersectLines(Line l) {\n	// if (collinear(l)) {\n	// return null;\n	// }\n	// long[] ans = new long[4];\n	//\n	// return ans;\n	// }\n	//\n	// public long[] intersectSegment(Line l) {\n	// long[] ans = intersectLines(l);\n	// if (ans == null) {\n	// return null;\n	// }\n	// Point p1 = p;\n	// Point p2 = p.add(v);\n	// boolean f1 = p1.x * ans[1] <= ans[0] && ans[0] <= p2.x * ans[1] && min(p1.y,\n	// p2.y) * ans[3] <= ans[2]\n	// && ans[2] <= max(p1.y, p2.y) * ans[3];\n	// p1 = l.p;\n	// p2 = l.p.add(v);\n	// boolean f2 = p1.x * ans[1] <= ans[0] && ans[0] <= p2.x * ans[1] && min(p1.y,\n	// p2.y) * ans[3] <= ans[2]\n	// && ans[2] <= max(p1.y, p2.y) * ans[3];\n	// if (!f1 || !f2) {\n	// return null;\n	// }\n	// return ans;\n	// }\n	//\n	// @Override\n	// public int compareTo(Line o) {\n	// return v.compareTo(o.v);\n	// }\n	// }\n\n	public class Rect {\n		long x1;\n		long x2;\n		long y1;\n		long y2;\n		int number;\n\n		public Rect(long x1, long x2, long y1, long y2, int number) {\n			this.x1 = x1;\n			this.x2 = x2;\n			this.y1 = y1;\n			this.y2 = y2;\n			this.number = number;\n		}\n	}\n\n	public static class Fenvik {\n		int[] t;\n\n		public Fenvik(int n) {\n			t = new int[n];\n		}\n\n		public void add(int x, int delta) {\n			for (int i = x; i < t.length; i = (i | (i + 1))) {\n				t[i] += delta;\n			}\n		}\n\n		private int sum(int r) {\n			int ans = 0;\n			int x = r;\n			while (x >= 0) {\n				ans += t[x];\n				x = (x & (x + 1)) - 1;\n			}\n			return ans;\n		}\n\n		public int sum(int l, int r) {\n			return sum(r) - sum(l - 1);\n		}\n	}\n\n	public class SegmentTreeMaxSum {\n		int pow;\n		int[] sum;\n		int[] maxPrefSum;\n		int[] maxSufSum;\n		int[] maxSum;\n\n		public SegmentTreeMaxSum(int[] a) {\n			pow = 1;\n			while (pow < a.length) {\n				pow *= 2;\n			}\n			sum = new int[2 * pow];\n			maxPrefSum = new int[2 * pow];\n			maxSum = new int[2 * pow];\n			maxSufSum = new int[2 * pow];\n			for (int i = 0; i < a.length; i++) {\n				sum[pow + i] = a[i];\n				maxSum[pow + i] = Math.max(a[i], 0);\n				maxPrefSum[pow + i] = maxSum[pow + i];\n				maxSufSum[pow + i] = maxSum[pow + i];\n			}\n			for (int i = pow - 1; i > 0; i--) {\n				update(i);\n			}\n		}\n\n		public int[] get(int v, int tl, int tr, int l, int r) {\n			if (r <= tl || l >= tr) {\n				int[] ans = { 0, 0, 0, 0 };\n				return ans;\n			}\n			if (l <= tl && r >= tr) {\n				int[] ans = { maxPrefSum[v], maxSum[v], maxSufSum[v], sum[v] };\n				return ans;\n			}\n			int tm = (tl + tr) / 2;\n			int[] left = get(2 * v, tl, tm, l, r);\n			int[] right = get(2 * v + 1, tm, tr, l, r);\n			int[] ans = { Math.max(left[0], right[0] + left[3]),\n					Math.max(left[1], Math.max(right[1], left[2] + right[0])), Math.max(right[2], left[2] + right[3]),\n					left[3] + right[3] };\n			return ans;\n		}\n\n		public void set(int v, int tl, int tr, int x, int value) {\n			if (v >= pow) {\n				sum[v] = value;\n				maxSum[v] = Math.max(value, 0);\n				maxPrefSum[v] = maxSum[v];\n				maxSufSum[v] = maxSum[v];\n				return;\n			}\n			int tm = (tl + tr) / 2;\n			if (x < tm) {\n				set(2 * v, tl, tm, x, value);\n			} else {\n				set(2 * v + 1, tm, tr, x, value);\n			}\n			update(v);\n		}\n\n		public void update(int i) {\n			sum[i] = f(sum[2 * i], sum[2 * i + 1]);\n			maxSum[i] = Math.max(maxSum[2 * i], Math.max(maxSum[2 * i + 1], maxSufSum[2 * i] + maxPrefSum[2 * i + 1]));\n			maxPrefSum[i] = Math.max(maxPrefSum[2 * i], maxPrefSum[2 * i + 1] + sum[2 * i]);\n			maxSufSum[i] = Math.max(maxSufSum[2 * i + 1], maxSufSum[2 * i] + sum[2 * i + 1]);\n		}\n\n		public int f(int a, int b) {\n			return a + b;\n		}\n	}\n\n	public class Point implements Comparable<Point> {\n		double x;\n		double y;\n\n		public Point() {\n			x = 0;\n			y = 0;\n		}\n\n		public Point(double x, double y) {\n			this.x = x;\n			this.y = y;\n		}\n\n		public String toString() {\n			return x + "" "" + y;\n		}\n\n		public boolean equals(Point p) {\n			return x == p.x && y == p.y;\n		}\n\n		public double dist2() {\n			return x * x + y * y;\n		}\n\n		public Point add(Point v) {\n			return new Point(x + v.x, y + v.y);\n		}\n\n		@Override\n		public int compareTo(Point o) {\n			int z = signum(x + y - o.x - o.y);\n			if (z != 0) {\n				return z;\n			}\n			return signum(x - o.x) != 0 ? signum(x - o.x) : signum(y - o.y);\n		}\n	}\n\n	public class Circle implements Comparable<Circle> {\n		Point p;\n		int r;\n\n		public Circle(Point p, int r) {\n			this.p = p;\n			this.r = r;\n		}\n\n		public Point angle() {\n			double z = r / sq2;\n			z -= z % 1e-5;\n			return new Point(p.x - z, p.y - z);\n		}\n\n		public boolean inside(Point p) {\n			return hypot2(p.x - this.p.x, p.y - this.p.y) <= sq(r);\n		}\n\n		@Override\n		public int compareTo(Circle o) {\n			Point a = angle();\n			Point oa = o.angle();\n			int z = signum(a.x + a.y - oa.x - oa.y);\n			if (z != 0) {\n				return z;\n			}\n			return signum(a.y - oa.y);\n		}\n\n	}\n\n	public class Fraction implements Comparable<Fraction> {\n		long x;\n		long y;\n\n		public Fraction(long x, long y, boolean needNorm) {\n			this.x = x;\n			this.y = y;\n			if (y < 0) {\n				this.x *= -1;\n				this.y *= -1;\n			}\n			if (needNorm) {\n				long gcd = gcd(this.x, this.y);\n				this.x /= gcd;\n				this.y /= gcd;\n			}\n		}\n\n		public Fraction clone() {\n			return new Fraction(x, y, false);\n		}\n\n		public String toString() {\n			return x + ""/"" + y;\n		}\n\n		@Override\n		public int compareTo(Fraction o) {\n			long res = x * o.y - y * o.x;\n			if (res > 0) {\n				return 1;\n			}\n			if (res < 0) {\n				return -1;\n			}\n			return 0;\n		}\n	}\n\n	public double sq(double x) {\n		return x * x;\n	}\n\n	public long sq(long x) {\n		return x * x;\n	}\n\n	public double hypot2(double x, double y) {\n		return sq(x) + sq(y);\n	}\n\n	public long hypot2(long x, long y) {\n		return sq(x) + sq(y);\n	}\n\n	public boolean kuhn(int v, int[][] edge, boolean[] used, int[] mt) {\n		used[v] = true;\n		for (int u : edge[v]) {\n			if (mt[u] < 0 || (!used[mt[u]] && kuhn(mt[u], edge, used, mt))) {\n				mt[u] = v;\n				return true;\n			}\n		}\n		return false;\n	}\n\n	public int matching(int[][] edge) {\n		int n = edge.length;\n		int[] mt = new int[n];\n		Arrays.fill(mt, -1);\n		boolean[] used = new boolean[n];\n		int ans = 0;\n		for (int i = 0; i < n; i++) {\n			if (!used[i] && kuhn(i, edge, used, mt)) {\n				Arrays.fill(used, false);\n				ans++;\n			}\n		}\n		return ans;\n	}\n\n	double sq2 = Math.sqrt(2);\n\n	int small = 20;\n\n	public class MyStack {\n		int[] st;\n		int sz;\n\n		public MyStack(int n) {\n			this.st = new int[n];\n			sz = 0;\n		}\n\n		public boolean isEmpty() {\n			return sz == 0;\n		}\n\n		public int peek() {\n			return st[sz - 1];\n		}\n\n		public int pop() {\n			sz--;\n			return st[sz];\n		}\n\n		public void clear() {\n			sz = 0;\n		}\n\n		public void add(int x) {\n			st[sz++] = x;\n		}\n\n		public int get(int x) {\n			return st[x];\n		}\n	}\n\n	public int[][] readGraph(int n, int m) {\n		int[][] to = new int[n][];\n		int[] sz = new int[n];\n		int[] x = new int[m];\n		int[] y = new int[m];\n		for (int i = 0; i < m; i++) {\n			x[i] = in.nextInt() - 1;\n			y[i] = in.nextInt() - 1;\n			sz[x[i]]++;\n			sz[y[i]]++;\n		}\n		for (int i = 0; i < to.length; i++) {\n			to[i] = new int[sz[i]];\n			sz[i] = 0;\n		}\n		for (int i = 0; i < x.length; i++) {\n			to[x[i]][sz[x[i]]++] = y[i];\n			to[y[i]][sz[y[i]]++] = x[i];\n		}\n		return to;\n	}\n\n	public class Pol {\n		double[] coeff;\n\n		public Pol(double[] coeff) {\n			this.coeff = coeff;\n		}\n\n		public Pol mult(Pol p) {\n			double[] ans = new double[coeff.length + p.coeff.length - 1];\n			for (int i = 0; i < ans.length; i++) {\n				for (int j = Math.max(0, i - p.coeff.length + 1); j < coeff.length && j <= i; j++) {\n					ans[i] += coeff[j] * p.coeff[i - j];\n				}\n			}\n			return new Pol(ans);\n		}\n\n		public String toString() {\n			String ans = """";\n			for (int i = 0; i < coeff.length; i++) {\n				ans += coeff[i] + "" "";\n			}\n			return ans;\n		}\n\n		public double value(double x) {\n			double ans = 0;\n			double p = 1;\n			for (int i = 0; i < coeff.length; i++) {\n				ans += coeff[i] * p;\n				p *= x;\n			}\n			return ans;\n		}\n\n		public double integrate(double r) {\n			Pol p = new Pol(new double[coeff.length + 1]);\n			for (int i = 0; i < coeff.length; i++) {\n				p.coeff[i + 1] = coeff[i] / fact[i + 1];\n			}\n			return p.value(r);\n		}\n\n		public double integrate(double l, double r) {\n			return integrate(r) - integrate(l);\n		}\n	}\n\n	double[] fact = new double[100];\n\n	public class SparseTable {\n		int pow;\n		int[] lessPow;\n		int[][] min;\n\n		public SparseTable(int[] a) {\n			pow = 0;\n			while ((1 << pow) <= a.length) {\n				pow++;\n			}\n			min = new int[pow][a.length];\n			for (int i = 0; i < a.length; i++) {\n				min[0][i] = a[i];\n			}\n			for (int i = 1; i < pow; i++) {\n				for (int j = 0; j < a.length; j++) {\n					min[i][j] = min[i - 1][j];\n					if (j + (1 << (i - 1)) < a.length) {\n						min[i][j] = func(min[i][j], min[i - 1][j + (1 << (i - 1))]);\n					}\n				}\n			}\n			lessPow = new int[a.length + 1];\n			for (int i = 1; i < lessPow.length; i++) {\n				if (i < (1 << (lessPow[i - 1]) + 1)) {\n					lessPow[i] = lessPow[i - 1];\n				} else {\n					lessPow[i] = lessPow[i - 1] + 1;\n				}\n			}\n		}\n\n		public int get(int l, int r) { // [l, r)\n			int p = lessPow[r - l];\n			return func(min[p][l], min[p][r - (1 << p)]);\n		}\n\n		public int func(int a, int b) {\n			if (a < b) {\n				return a;\n			}\n			return b;\n		}\n	}\n\n	public double check(int n, ArrayList<Integer> masks) {\n		int good = 0;\n		for (int colorMask = 0; colorMask < (1 << n); ++colorMask) {\n			int best = 2 << n;\n			int cnt = 0;\n			for (int curMask : masks) {\n				int curScore = 0;\n				for (int i = 0; i < n; ++i) {\n					if (((curMask >> i) & 1) == 1) {\n						if (((colorMask >> i) & 1) == 0) {\n							curScore += 1;\n						} else {\n							curScore += 2;\n						}\n					}\n				}\n\n				if (curScore < best) {\n					best = curScore;\n					cnt = 1;\n				} else if (curScore == best) {\n					++cnt;\n				}\n			}\n\n			if (cnt == 1) {\n				++good;\n			}\n		}\n\n		return (double) good / (double) (1 << n);\n	}\n\n	public int builtin_popcount(int x) {\n		int ans = 0;\n		for (int i = 0; i < 14; i++) {\n			if (((x >> i) & 1) > 0) {\n				ans++;\n			}\n		}\n		return ans;\n	}\n\n	public int number(int[] x) {\n		int ans = 0;\n		for (int i = 0; i < x.length; i++) {\n			ans *= 3;\n			ans += x[i];\n		}\n		return ans;\n	}\n\n	public int[] rotate(int[] x) {\n		int[] ans = { x[2], x[0], x[3], x[1] };\n		return ans;\n	}\n\n	int MAX = 200001;\n\n	boolean[] b = new boolean[MAX];\n	int[][] max0 = new int[MAX][2];\n	int[][] max1 = new int[MAX][2];\n	int[][] max2 = new int[MAX][2];\n	int[] index0 = new int[MAX];\n	int[] index1 = new int[MAX];\n	int[] p = new int[MAX];\n\n	public int place(String s) {\n		if (s.charAt(s.length() - 1) == '1') {\n			return 1;\n		}\n		int number = 16;\n		boolean w = true;\n		boolean a = true;\n		for (int i = 0; i < s.length(); i++) {\n			if (number == 1) {\n				return 2;\n			}\n			if (s.charAt(i) == '1') {\n				if (w) {\n					number /= 2;\n				} else {\n					if (a) {\n						a = false;\n					} else {\n						number /= 2;\n						a = true;\n					}\n				}\n			} else {\n				if (w) {\n					if (number == 16) {\n						w = false;\n						number /= 2;\n					} else {\n						w = false;\n						a = false;\n					}\n				} else {\n					if (number == 8) {\n						if (a) {\n							return 13;\n						} else {\n							return 9;\n						}\n					} else if (number == 4) {\n						if (a) {\n							return 7;\n						} else {\n							return 5;\n						}\n					} else if (a) {\n						return 4;\n					} else {\n						return 3;\n					}\n				}\n			}\n		}\n		return 0;\n	}\n\n	public class P implements Comparable<P> {\n		Integer x;\n		String s;\n\n		public P(Integer x, String s) {\n			this.x = x;\n			this.s = s;\n		}\n\n		@Override\n		public String toString() {\n			return x + "" "" + s;\n		}\n\n		@Override\n		public int compareTo(P o) {\n			if (x != o.x) {\n				return x - o.x;\n			}\n			return s.compareTo(o.s);\n		}\n	}\n\n	public BigInteger prod(int l, int r) {\n		if (l + 1 == r) {\n			return BigInteger.valueOf(l);\n		}\n		int m = (l + r) >> 1;\n		return prod(l, m).multiply(prod(m, r));\n	}\n\n	public class Frac {\n		BigInteger p;\n		BigInteger q;\n\n		public Frac(BigInteger p, BigInteger q) {\n			BigInteger gcd = p.gcd(q);\n			this.p = p.divide(gcd);\n			this.q = q.divide(gcd);\n		}\n\n		public String toString() {\n			return p + ""\n"" + q;\n		}\n\n		public Frac(long p, long q) {\n			this(BigInteger.valueOf(p), BigInteger.valueOf(q));\n		}\n\n		public Frac mul(Frac o) {\n			return new Frac(p.multiply(o.p), q.multiply(o.q));\n		}\n\n		public Frac sum(Frac o) {\n			return new Frac(p.multiply(o.q).add(q.multiply(o.p)), q.multiply(o.q));\n		}\n\n		public Frac diff(Frac o) {\n			return new Frac(p.multiply(o.q).subtract(q.multiply(o.p)), q.multiply(o.q));\n		}\n	}\n\n	public int[] transform(int[] x, int k, int step) {\n		int n = x.length;\n		int[] a = new int[n];\n		int[][] prefsum = new int[n][];\n		int[] elements = new int[n];\n		int[] start = new int[n];\n		int[] id = new int[n];\n		for (int i = 0; i < n; i++) {\n			if (elements[i] > 0) {\n				continue;\n			}\n			int cur = i;\n			do {\n				elements[i]++;\n				cur += step;\n				cur %= n;\n			} while (cur != i);\n			for (int j = 0; j < elements[i]; j++) {\n				start[cur] = i;\n				id[cur] = j;\n				elements[cur] = elements[i];\n				cur += step;\n				cur %= n;\n			}\n			prefsum[i] = new int[3 * elements[i] + 1];\n			for (int j = 0; j < 3 * elements[i]; j++) {\n				prefsum[i][j + 1] = prefsum[i][j] ^ x[cur];\n				cur += step;\n				cur %= n;\n			}\n		}\n		for (int i = 0; i < x.length; i++) {\n			int curlen = k % (2 * elements[i]);\n			a[i] = prefsum[start[i]][id[i] + curlen] ^ prefsum[start[i]][id[i]];\n		}\n		return a;\n	}\n	\n	public boolean rated(String s, int x) {\n		if (s.toUpperCase().equals(""ABC"")) {\n			return x <= 1999;\n		}\n		if (s.toUpperCase().equals(""ARC"")) {\n			return x <= 2799;\n		}\n		if (s.toUpperCase().equals(""AGC"")) {\n			return x >= 1200;\n		}\n		return false;\n	}\n	\n	public boolean can(int n1, int n2, int n3, boolean odd) {\n		while (true) {\n			if (odd) {\n				if (n2 > 0) {\n					n2--;\n				} else if (n3 > 0) {\n					n3--;\n				} else {\n					break;\n				}\n			} else {\n				if (n1 > 0) {\n					n1--;\n				} else if (n3 > 0) {\n					n3--;\n				} else {\n					break;\n				}\n			}\n			odd = !odd;\n		}\n		return n1 == 0 && n2 == 0 && n3 == 0;\n	}\n	\n	public int dfsReturn(int[] n, boolean odd) {\n		if (n[0] > 0) {\n			return 0;\n		}\n		int ans = 0;\n		if (can(n[1] + 1, n[2], n[3], odd)) {\n			ans++;\n		}\n		if (can(n[1], n[2] + 1, n[3], odd)) {\n			ans += 2;\n		}\n		return ans;\n	}\n	\n	public int dfs(int v, int p) {\n		for (int i : to[v]) {\n			if (i == p) {\n				continue;\n			}\n			int x = dfs(i, v);\n			m[v][x]++;\n		}\n		ans[v] = dfsReturn(m[v], to[v].length % 2 == 1);\n		return ans[v];\n	}\n	\n	public void dfs1(int v, int p, int typeP) {\n		int[] one = new int[m[v][1] + (typeP == 1 ? 1 : 0)];\n		int[] two = new int[m[v][2] + (typeP == 2 ? 1 : 0)];\n		int[] three = new int[m[v][3]];\n		int sz1 = 0;\n		int sz2 = 0;\n		int sz3 = 0;\n		if (typeP == 1) {\n			one[sz1++] = p;\n		}\n		if (typeP == 2) {\n			two[sz2++] = p;\n		}\n		for (int i : to[v]) {\n			if (i == p) {\n				continue;\n			}\n			if (ans[i] == 1) {\n				one[sz1++] = i;\n			} else if (ans[i] == 2) {\n				two[sz2++] = i;\n			} else {\n				three[sz3++] = i;\n			}\n		}\n		boolean odd = to[v].length % 2 == 1;\n		sz1--;\n		sz2--;\n		sz3--;\n		while (true) {\n			if (odd) {\n				if (sz2 >= 0) {\n					if (two[sz2] == p) {\n						out.println(v + 1 + "" "" + (p + 1));\n					} else {\n						dfs1(two[sz2], v, 2);\n					}\n					sz2--;\n				} else if (sz3 > 0) {\n					dfs1(three[sz3--], v, 2);\n				} else {\n					break;\n				}\n			} else {\n				if (sz1 >= 0) {\n					if (one[sz1] == p) {\n						out.println(v + 1 + "" "" + (p + 1));\n					} else {\n						dfs1(one[sz1], v, 1);\n					}\n					sz1--;\n				} else if (sz3 > 0) {\n					dfs1(three[sz3--], v, 1);\n				} else {\n					break;\n				}\n			}\n			odd = !odd;\n		}\n	}\n	\n	int[][] to;\n	int[][] m;\n	int[] ans;\n	int[] x;\n	int[] y;\n	int sz;\n	\n	public void solve() {\n		for (int qwerty = in.nextInt(); qwerty > 0; --qwerty) {\n			int n = in.nextInt();\n			to = readGraph(n, n - 1);\n			ans = new int[n];\n			x = new int[n - 1];\n			y = new int[n - 1];\n			m = new int[n][4];\n			sz = 0;\n			if (dfs(0, -1) % 2 == 1) {\n				out.println(""YES"");\n				dfs1(0, -1, 0);\n			} else {\n				out.println(""NO"");\n			}\n		}\n	}\n\n	public void add(HashMap<Integer, Integer> map, int x) {\n		if (map.containsKey(x)) {\n			map.put(x, map.get(x) + 1);\n		} else {\n			map.put(x, 1);\n		}\n	}\n\n	public void run() {\n		try {\n			if (systemIO) {\n				in = new FastScanner(System.in);\n				out = new PrintWriter(System.out);\n			} else {\n				in = new FastScanner(new File(""input.txt""));\n				out = new PrintWriter(new File(""output.txt""));\n			}\n			solve();\n\n			out.close();\n		} catch (IOException e) {\n			e.printStackTrace();\n		}\n	}\n\n	class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		FastScanner(File f) {\n			try {\n				br = new BufferedReader(new FileReader(f));\n			} catch (FileNotFoundException e) {\n				e.printStackTrace();\n			}\n		}\n\n		FastScanner(InputStream f) {\n			br = new BufferedReader(new InputStreamReader(f));\n		}\n\n		String nextLine() {\n			try {\n				return br.readLine();\n			} catch (IOException e) {\n				return null;\n			}\n		}\n\n		String next() {\n			while (st == null || !st.hasMoreTokens()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			}\n			return st.nextToken();\n		}\n\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n\n	}\n\n	// AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n	public static void main(String[] arg) {\n		new D().run();\n	}\n}","constructive algorithms,dfs and similar,dp,trees"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author beginner1010\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        final int MOD = 998244353;\n\n        int pow(int a, int b) {\n            if (b == 0)\n                return 1;\n            if ((b & 1) == 1) {\n                return mul(a, pow(a, b - 1));\n            } else {\n                int aux = pow(a, b >> 1);\n                return mul(aux, aux);\n            }\n        }\n\n        int mul(int a, int b) {\n            return (int) ((1L * a * b) % MOD);\n        }\n\n        int add(int a, int b) {\n            return ((int) (1L * a + b) % MOD);\n        }\n\n        int sub(int a, int b) {\n            long ans = a;\n            ans -= b;\n            ans %= MOD;\n            if (ans < 0) ans += MOD;\n            return (int) ans;\n        }\n\n        int inv(int a) {\n            return pow(a, MOD - 2);\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = sub(in.nextInt(), 0);\n            }\n\n            int query = in.nextInt();\n            FFT fft = new FFT();\n            for (int i = 0; i < query; i++) {\n                int type = in.nextInt();\n                int[] b = new int[n];\n                if (type == 1) {\n                    int q = in.nextInt();\n                    int id = in.nextInt() - 1;\n                    int d = in.nextInt();\n                    for (int j = 0; j < n; j++) {\n                        b[j] = id == j ? sub(q, d) : sub(q, a[j]);\n                    }\n                } else {\n                    int q = in.nextInt();\n                    int l = in.nextInt() - 1;\n                    int r = in.nextInt() - 1;\n                    int d = in.nextInt();\n                    for (int j = 0; j < n; j++) {\n                        b[j] = l <= j && j <= r ? sub(q, add(a[j], d)) : sub(q, a[j]);\n                    }\n                }\n                int[] ans = fft.get(0, n - 1, b);\n                out.println(k >= ans.length ? 0 : ans[k]);\n            }\n        }\n\n        class FFT {\n            final int maxN = 4 * 4 * 10000;\n            final int G = 3;\n            int[] rev;\n\n            FFT() {\n                rev = new int[maxN];\n            }\n\n            void FFT(int[] a, boolean inverse) {\n                int n = a.length;\n                for (int i = 0; i < a.length; i++) {\n                    if (i < rev[i]) {\n                        int temp = a[i];\n                        a[i] = a[rev[i]];\n                        a[rev[i]] = temp;\n                    }\n                }\n                for (int i = 1; i < n; i *= 2) {\n                    int wn = pow(G, ((MOD - 1) / i) >> 1);\n                    if (inverse == true) wn = inv(wn);\n                    for (int j = 0; j < n; j += i * 2) {\n                        int w = 1;\n                        for (int k = j; k < j + i; k++) {\n                            int x = a[k], y = mul(w, a[k + i]);\n                            a[k] = add(x, y);\n                            a[k + i] = sub(x, y);\n                            w = mul(w, wn);\n                        }\n                    }\n                }\n                if (inverse == true) {\n                    int nInv = inv(n);\n                    for (int i = 0; i < n; i++) {\n                        a[i] = mul(a[i], nInv);\n                    }\n                }\n            }\n\n            int[] multiply(int[] a, int[] b) {\n                int n = Math.max(a.length, b.length);\n                int n2 = 1;\n                int log = 0, m = n * 2;\n                while (n2 < m) {\n                    n2 *= 2;\n                    log++;\n                }\n                for (int i = 0; i < n2; i++) {\n                    rev[i] = (rev[i >> 1] >> 1) ^ ((i & 1) << (log - 1));\n                }\n                a = Arrays.copyOf(a, n2);\n                b = Arrays.copyOf(b, n2);\n                FFT(a, false);\n                FFT(b, false);\n                for (int i = 0; i < a.length; i++) a[i] = mul(a[i], b[i]);\n                FFT(a, true);\n                return a;\n            }\n\n            int[] get(int l, int r, int[] a) {\n                if (l == r) {\n                    int[] res = new int[2];\n                    res[0] = 1;\n                    res[1] = a[l];\n                    return res;\n                }\n                int mid = (l + r) >> 1;\n                int[] f1 = get(l, mid, a);\n                int[] f2 = get(mid + 1, r, a);\n                int[] g = multiply(f1, f2);\n                int size = g.length;\n                while (size > 0 && g[size - 1] == 0) {\n                    size--;\n                }\n                g = Arrays.copyOf(g, size);\n                return g;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputStream stream;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private boolean isWhitespace(int c) {\n            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n        }\n\n        private int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isWhitespace(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isWhitespace(c));\n            return res * sgn;\n        }\n\n    }\n}\n\n","divide and conquer,fft"
"import java.util.*;\nimport java.io.*;\nimport java.text.*;\npublic class Main{\n    //SOLUTION BEGIN\n    //Into the Hardware Mode\n    long mod = 998244353;\n    void pre() throws Exception{}\n    void solve(int TC)throws Exception{\n        NTT ntt = new NTT(998244353);\n        int n = ni(), k = ni();\n        int[] a = new int[n];\n        for(int i = 0; i< n; i++)a[i] = ni();\n        long[] b = new long[n];\n        for(int qq = ni(); qq>0; qq--){\n            if(ni() == 1){\n                long q = nl();int p = ni()-1;long d = nl();\n                for(int i = 0; i< n; i++)b[i] = q-a[i];\n                b[p] = q-d;\n                pn((mul(ntt, b, 0, n-1)[k]+mod)%mod);\n            }else{\n                long q = nl();int l = ni()-1, r = ni()-1;long d = nl();\n                for(int i = 0; i< l; i++)b[i] = q-a[i];\n                for(int i = l; i<= r; i++)b[i] = q-a[i]-d;\n                for(int i = r+1; i< n; i++)b[i] = q-a[i];\n                pn((mul(ntt, b, 0, n-1)[k]+mod)%mod);\n            }\n        }\n    }\n    long[] mul(NTT ntt, long[] a, int l, int r) throws Exception{\n        if(l == r)return new long[]{1, a[l]};\n        int mid = (l+r)/2;\n        return ntt.multiply(mul(ntt, a, l, mid), mul(ntt, a, mid+1, r));\n    }\n    class NTT{\n        private int MAGIC = 8;\n        long root, mod;\n        public NTT(long m){\n            mod = m;\n            long[] s = pFact();\n            for(root = 3; true; root++){\n                boolean f = true;\n                for(long x:s)if(pow(root, (mod-1)/x) == 1)f = false;\n                if(f)break;\n            }\n        }\n        long[] naiveMul(long[] a, long[] b){\n            long[] c = new long[a.length+b.length-1];\n            for(int i = 0; i< a.length; i++)\n                for(int j = 0; j< b.length; j++)\n                    c[i+j] = (c[i+j]+a[i]*b[j])%mod;\n            return c;\n        }\n        long[] multiply(long[] a, long[] b) throws Exception{\n            int l = Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2;\n            l = Math.max(l, 1);\n            hold(mod%l == 1);\n            long[] p = new long[l], q = new long[l];\n            for(int i = 0; i< a.length; i++)p[i] = a[i];\n            for(int i = 0; i< b.length; i++)q[i] = b[i];\n            if(l <= MAGIC)return naiveMul(a, b);\n            ntt(p, false);\n            ntt(q, false);\n            for(int i = 0; i< l; i++)p[i] = (p[i]*q[i])%mod;\n            ntt(p, true);\n            return p;   \n        }\n        void ntt(long[] p, boolean invert) throws Exception{\n            int n = p.length;\n            hold(bit(n) == 1);\n            for(int i = 1, j = 0; i< n; i++){\n                int bit = n >> 1;\n                for (; j >= bit; bit >>= 1)\n                    j -= bit;\n                j += bit;\n                if(i< j){\n                    p[i] += p[j];\n                    p[j] = p[i]-p[j];\n                    p[i] -= p[j];\n                }\n            }\n            hold(mod%n == 1);\n            for(int len = 2; len <= n; len<<=1){\n                int half = len>>1;\n                hold((mod-1)%len == 0);\n                long wlen = pow(root, (mod-1)/len);\n                if(invert)wlen = pow(root, mod-1-(mod-1)/len);\n                for(int i = 0; i< n; i+= len){\n                    long w = 1;\n                    for(int j = 0; j< half; j++){\n                        long a = p[i+j], b = (p[i+j+half]*w)%mod;\n                        p[i+j] = (a+b)%mod;\n                        p[i+j+half] = (a-b+mod)%mod;\n                        w = (w*wlen)%mod;\n                    }\n                }\n            }\n            long invN = pow(n, mod-2);\n            if(invert)for(int i = 0; i< n; i++)p[i] = (p[i]*invN)%mod;\n        }\n        long pow(long a, long p){\n            long o = 1;a %= mod;\n            while(p>0){\n                if((p&1)==1)o = (o*a)%mod;\n                a = (a*a)%mod;\n                p>>=1;\n            }\n            return o;\n        }\n        final long[] pFact(){\n            long x = mod-1;\n            long[] s = new long[15];int c = 0;\n            for(long i = 2; i*i <= mod-1; i++){\n                if(x%i != 0)continue;\n                s[c++] = i;\n                while(x%i == 0)x/= i;\n            }\n            if(x > 1)s[c++] = x;\n            s = Arrays.copyOfRange(s, 0, c);\n            return s;\n        }\n    }\n    //SOLUTION END\n    void hold(boolean b)throws Exception{if(!b)throw new Exception(""Hold right there, Sparky!"");}\n    void exit(boolean b){if(!b)System.exit(0);}\n    long IINF = (long)1e18;\n    final int INF = (int)1e9+2, MX = (int)2e6+5;\n    DecimalFormat df = new DecimalFormat(""0.00000000000"");\n    double PI = 3.141592653589793238462643383279502884197169399, eps = 1e-7;\n    static boolean multipleTC = false, memory = false, fileIO = false;\n    FastReader in;PrintWriter out;\n    void run() throws Exception{\n        if(fileIO){\n            in = new FastReader(""C:/users/user/desktop/inp.in"");\n            out = new PrintWriter(""C:/users/user/desktop/out.out"");\n        }else {\n            in = new FastReader();\n            out = new PrintWriter(System.out);\n        }\n        //Solution Credits: Taranpreet Singh\n        int T = (multipleTC)?ni():1;\n        pre();\n        for(int t = 1; t<= T; t++)solve(t);\n        out.flush();\n        out.close();\n    }\n    public static void main(String[] args) throws Exception{\n        if(memory)new Thread(null, new Runnable() {public void run(){try{new Main().run();}catch(Exception e){e.printStackTrace();}}}, ""1"", 1 << 28).start();\n        else new Main().run();\n    }\n    int find(int[] set, int u){return set[u] = (set[u] == u?u:find(set, set[u]));}\n    int digit(long s){int ans = 0;while(s>0){s/=10;ans++;}return ans;}\n    long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}\n    int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}\n    int bit(long n){return (n==0)?0:(1+bit(n&(n-1)));}\n    void p(Object o){out.print(o);}\n    void pn(Object o){out.println(o);}\n    void pni(Object o){out.println(o);out.flush();}\n    String n()throws Exception{return in.next();}\n    String nln()throws Exception{return in.nextLine();}\n    int ni()throws Exception{return Integer.parseInt(in.next());}\n    long nl()throws Exception{return Long.parseLong(in.next());}\n    double nd()throws Exception{return Double.parseDouble(in.next());}\n \n    class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n \n        public FastReader(String s) throws Exception{\n            br = new BufferedReader(new FileReader(s));\n        }\n \n        String next() throws Exception{\n            while (st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch (IOException  e){\n                    throw new Exception(e.toString());\n                }\n            }\n            return st.nextToken();\n        }\n \n        String nextLine() throws Exception{\n            String str = """";\n            try{   \n                str = br.readLine();	\n            }catch (IOException e){\n                throw new Exception(e.toString());\n            }  \n            return str;\n        }\n    }   \n}","divide and conquer,fft"
"import java.io.*;\nimport java.util.*;\n \npublic class E implements Runnable {\n	public static void main (String[] args) {new Thread(null, new E(), ""_cf"", 1 << 28).start();}\n \n	FFT fft = new FFT();\n	int[] a;\n \n	public void run() {\n		FastScanner fs = new FastScanner();\n		PrintWriter out = new PrintWriter(System.out);\n		System.err.println("""");\n \n		int n = fs.nextInt(), k = fs.nextInt();\n		a = new int[n];\n		int[] b = new int[n];\n		for(int i = 0; i < n; i++) {\n			a[i] = fs.nextInt();\n			b[i] = a[i];\n		}\n		int q = fs.nextInt();\n		\n		for(int qq = 1; qq <= q; qq++) {\n			int type = fs.nextInt();\n			int val = fs.nextInt();\n			\n			if(type == 1) {\n				int pos = fs.nextInt()-1;\n				int change = fs.nextInt();\n				a[pos] = change;\n			}\n			else {\n				int L = fs.nextInt()-1, R = fs.nextInt()-1;\n				int by = fs.nextInt();\n				for(int i = L; i <= R; i++) a[i] = add(a[i], by);\n			}\n			for(int i = 0; i < n; i++) {\n				a[i] = sub(val, a[i]);\n			}\n			long[] solve = solve(0, n - 1);\n			out.println(solve[k]);\n			\n			for(int i = 0; i < n; i++) a[i] = b[i];\n			\n		}\n		\n		out.close();\n	}\n	\n	long[] solve(int L, int R) {\n		if(L == R) {\n			return new long[] {1, a[L]};\n		}\n		int mid = (L + R) / 2;\n		long[] left = solve(L, mid);\n		long[] right = solve(mid + 1, R);\n		\n		return fft.multiplyPrecise(left, right);\n	}\n	\n	int MOD = 998244353;\n	\n	int add(int a, int b) {\n		a += b;\n		if(a >= MOD) a -= MOD;\n		return a;\n	}\n	\n	int sub(int a, int b) {\n		a -= b;\n		if(a < 0) a += MOD;\n		return a;\n	}\n	\n	// SET maxk appropriately!!! ~log(maxn) //%\n	 class FFT {\n	     final int maxk = 20, maxn = (1 << maxk) + 1;\n	    // Init: wR, wI, rR, rI, aR, aI   to   new double[maxn] !!!\n	    //#\n	     double[] wR = new double[maxn],\n	            wI = new double[maxn],\n	            rR = new double[maxn],\n	            rI = new double[maxn],\n	            aR  = new double[maxn],\n	            aI  = new double[maxn]; //$\n	     int n, k, lastk = -1, dp[] = new int[maxn];\n \n	     void fft(boolean inv) {\n	        if (lastk != k) {\n	            lastk = k;  dp[0] = 0;\n	            for (int i = 1, g = -1; i < n; i++) {\n	                if ((i & (i - 1)) == 0) g++;\n	                dp[i] = dp[i ^ (1 << g)] ^ (1 << (k - 1 - g));\n	            }\n	            wR[1] = 1;\n	            wI[1] = 0;\n	            for (int t = 0; t < k - 1; t++) {\n	                double a = Math.PI / n * (1 << (k - 1 - t));\n	                double curR = Math.cos(a), curI = Math.sin(a);\n	                int p2 = (1 << t), p3 = p2 * 2;\n	                for (int j = p2, k = j * 2; j < p3; j++, k += 2) {\n	                    wR[k] = wR[j];\n	                    wI[k] = wI[j];\n	                    wR[k + 1] = wR[j] * curR - wI[j] * curI;\n	                    wI[k + 1] = wR[j] * curI + wI[j] * curR;\n	                }\n	            }\n	        }\n	        for (int i = 0; i < n; i++) {\n	            int d = dp[i];\n	            if (i < d) {\n	                double tmp = aR[i];\n	                aR[i] = aR[d];\n	                aR[d] = tmp;\n	                tmp = aI[i];\n	                aI[i] = aI[d];\n	                aI[d] = tmp;\n	            }\n	        }\n	        if (inv) for (int i = 0; i < n; i++) aI[i] = -aI[i];\n	        for (int len = 1; len < n; len <<= 1) {\n	            for (int i = 0; i < n; i += len) {\n	                int wit = len;\n	                for (int it = 0, j = i + len; it < len; it++, i++, j++) {\n	                    double tmpR = aR[j] * wR[wit] - aI[j] * wI[wit];\n	                    double tmpI = aR[j] * wI[wit] + aI[j] * wR[wit];\n	                    wit++;\n	                    aR[j] = aR[i] - tmpR;\n	                    aI[j] = aI[i] - tmpI;\n	                    aR[i] += tmpR;\n	                    aI[i] += tmpI;\n	                }\n	            }\n	        }\n	    }\n \n	     long[] multiply(long[] a, long[] b) {\n	        int na = a.length, nb = b.length;\n	        for (k = 0, n = 1; n < na + nb - 1; n <<= 1, k++) {}\n	        for (int i = 0; i < n; ++i) {\n	            aR[i] = i < na ? a[i] : 0;\n	            aI[i] = i < nb ? b[i] : 0;\n	        }\n	        fft(false);\n	        aR[n] = aR[0];\n	        aI[n] = aI[0];\n	        double q = -1.0 / n / 4.0;\n	        for (int i = 0; i <= n - i; ++i) {\n	            double tmpR = aR[i] * aR[i] - aI[i] * aI[i];\n	            double tmpI = aR[i] * aI[i] * 2;\n	            tmpR -= aR[n - i] * aR[n - i] - aI[n - i] * aI[n - i];\n	            tmpI -= aR[n - i] * aI[n - i] * -2;\n	            aR[i] = -tmpI * q;\n	            aI[i] = tmpR * q;\n	            aR[n - i] = aR[i];\n	            aI[n - i] = -aI[i];\n	        }\n	        fft(true);\n	        long[] ans = new long[n = na + nb - 1]; // ONLY MOD IF NEEDED\n	        for (int i = 0; i < n; i++) ans[i] = Math.round(aR[i]) % MOD;\n	        return ans;\n	    }\n	     void fft2(double[][] xr, double[][] xi, boolean inv) {\n	        n = xr[0].length;\n	        k = Integer.numberOfTrailingZeros(n);\n	        for (int i = 0; i < xr.length; i++) {\n	            for (int j = 0; j < n; j++) { aR[j] = xr[i][j];  aI[j] = xi[i][j]; }\n	            fft(inv);\n	            for (int j=0;j<n;j++){xr[i][j] = aR[j] / (inv ? n : 1);  xi[i][j] = aI[j] / (inv ? -n : 1);}\n	        }\n	        n = xr.length;\n	        k = Integer.numberOfTrailingZeros(n);\n	        for (int j = 0; j < xr[0].length; j++) {\n	            for (int i = 0; i < n; i++) { aR[i] = xr[i][j];  aI[i] = xi[i][j]; }\n	            fft(inv);\n	            for (int i=0;i<n;i++){xr[i][j] = aR[i] / (inv ? n : 1);  xi[i][j] = aI[i] / (inv ? -n : 1);}\n	        }\n	    }\n	     long[][] multiply2(long[][] a, long[][] b) {\n	        int n1, n2;\n	        for (n1 = 1; n1 < a.length + b.length - 1; n1 <<= 1) {}\n	        for (n2 = 1; n2 < a[0].length + b[0].length - 1; n2 <<= 1) {}\n	        double[][] ar = new double[n1][n2], ai = new double[n1][n2];\n	        double[][] br = new double[n1][n2], bi = new double[n1][n2];\n	        for (int i = 0; i < a.length; i++) for(int j=0;j<a[i].length;j++) ar[i][j] = a[i][j];\n	        for (int i = 0; i < b.length; i++) for(int j=0;j<b[i].length;j++) br[i][j] = b[i][j];\n	        fft2(ar,ai,false); fft2(br,bi,false);\n	        for (int i = 0; i < n1; i++) {\n	            for(int j = 0; j < n2; j++) {\n	                double r1 = ar[i][j], r2 = br[i][j];\n	                double i1 = ai[i][j], i2 = bi[i][j];\n	                double real = r1 * r2 - i1 * i2;\n	                ai[i][j] = i1 * r2+ i2*r1;\n	                ar[i][j] = real;\n	            }\n	        }\n	        fft2(ar,ai,true);  long[][] result = new long[n1=a.length+b.length-1][n2=a[0].length+b[0].length-1];\n	        for (int i = 0; i < n1; i++)\n	            for(int j = 0; j < n2; j++) result[i][j] = Math.round(ar[i][j]);\n	        return result;\n	    }\n	    //#\n	     long[] multiplyPrecise(long[] a, long[] b) {\n	        long k = (long)(Math.sqrt(MOD));\n	        long[] a1 = new long[a.length], a2 = new long[a.length];\n	        long[] b1 = new long[b.length], b2 = new long[b.length];\n	        for(int i=0;i<a.length;i++) {\n	            a1[i] = a[i] % k;\n	            a2[i] = a[i] / k;\n	        }\n	        for(int i=0;i<b.length;i++) {\n	            b1[i] = b[i] % k;\n	            b2[i] = b[i] / k;\n	        }\n	        long[] r11 = multiply(a1, b1), r12 = multiply(a1, b2), r21 = multiply(a2, b1), r22 = multiply(a2, b2);\n	        long[] res = new long[r11.length];\n	        for(int i=0;i<res.length;i++)\n	            res[i] = (k*k*r22[i] + k*(r12[i] + r21[i]) + r11[i]) % MOD;\n	        return res;\n	    }\n	    //$\n	    //#\n	     long[] multiplyOr(long[] eq1, long[] eq2) {\n	        int n = Math.max(eq1.length, eq2.length);\n	        if((n & (n-1)) != 0)\n	            n = Integer.highestOneBit(n)*2;\n	        eq1 = fftOr(eq1, n, false);\n	        eq2 = fftOr(eq2, n, false);\n	        for(int i=0;i<eq1.length;i++)\n	            eq1[i] *= eq2[i];\n	        eq1 = fftOr(eq1, n, true);\n	        return eq1;\n	    }\n	    //$\n	    // To use: FFT both, product, iFFT (n is next power of 2)\n	     long[] fftOr(long[] arr, int n, boolean invert) {\n	        long[] ans = Arrays.copyOf(arr, n);\n	        for (int b = 1; b < n; b <<= 1)\n	            for (int i = 0; i < n; i++) {\n	                if ((i & b) != 0) continue;\n	                ans[i + b] += invert ? -ans[i] : ans[i];\n	            }\n	        return ans;\n	    }\n	     long[] fftXor(long[] arr, int n, boolean invert) {\n	        long[] ans = Arrays.copyOf(arr, n);\n	        for (int b = 1; b < n; b <<= 1)\n	            for (int i = 0; i < n; i++) {\n	                if((i & b) != 0) continue;\n	                long u = ans[i], v = ans[i+b];\n	                ans[i] = u + v;  ans[i + b] = u - v;\n	            }\n	        if (invert) for (int i = 0; i < n; i++) ans[i] /= n;\n	        return ans;\n	    }\n	}\n \n	class FastScanner {\n		public int BS = 1<<16;\n		public char NC = (char)0;\n		byte[] buf = new byte[BS];\n		int bId = 0, size = 0;\n		char c = NC;\n		double num = 1;\n		BufferedInputStream in;\n \n		public FastScanner() {\n			in = new BufferedInputStream(System.in, BS);\n		}\n \n		public FastScanner(String s) {\n			try {\n				in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n			}\n			catch (Exception e) {\n				in = new BufferedInputStream(System.in, BS);\n			}\n		}\n \n		public char nextChar(){\n			while(bId==size) {\n				try {\n					size = in.read(buf);\n				}catch(Exception e) {\n					return NC;\n				}                \n				if(size==-1)return NC;\n				bId=0;\n			}\n			return (char)buf[bId++];\n		}\n \n		public int nextInt() {\n			return (int)nextLong();\n		}\n \n		public long nextLong() {\n			num=1;\n			boolean neg = false;\n			if(c==NC)c=nextChar();\n			for(;(c<'0' || c>'9'); c = nextChar()) {\n				if(c=='-')neg=true;\n			}\n			long res = 0;\n			for(; c>='0' && c <='9'; c=nextChar()) {\n				res = (res<<3)+(res<<1)+c-'0';\n				num*=10;\n			}\n			return neg?-res:res;\n		}\n \n		public double nextDouble() {\n			double cur = nextLong();\n			return c!='.' ? cur:cur+nextLong()/num;\n		}\n \n		public String next() {\n			StringBuilder res = new StringBuilder();\n			while(c<=32)c=nextChar();\n			while(c>32) {\n				res.append(c);\n				c=nextChar();\n			}\n			return res.toString();\n		}\n \n		public String nextLine() {\n			StringBuilder res = new StringBuilder();\n			while(c<=32)c=nextChar();\n			while(c!='\n') {\n				res.append(c);\n				c=nextChar();\n			}\n			return res.toString();\n		}\n \n		public boolean hasNext() {\n			if(c>32)return true;\n			while(true) {\n				c=nextChar();\n				if(c==NC)return false;\n				else if(c>32)return true;\n			}\n		}\n		\n		public int[] nextIntArray(int n) {\n			int[] res = new int[n];\n			for(int i = 0; i < n; i++) res[i] = nextInt();\n			return res;\n		}\n		\n	}\n \n}","divide and conquer,fft"
"import java.io.*;\nimport java.util.*;\n\npublic class E {\n\n	public static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n	public static void main(String[] args) throws IOException {\n		readInput();\n		out.close();\n	}\n\n	public static void readInput() throws IOException {\n		// br = new BufferedReader(new FileReader("".in""));\n		// out = new PrintWriter(new FileWriter("".out""));\n		int q = Integer.parseInt(br.readLine());\n		while(q-->0) {\n			int k = Integer.parseInt(br.readLine());\n			int len = 0;\n			StringBuilder sb = new StringBuilder();\n			long val = 1;\n			while (k >=0) {\n				sb.append(val);\n				val++;\n				if (k > len && k <= len+sb.length()) break;\n				len += sb.length();\n			}\n			out.println(sb.charAt(k-len-1));\n		}\n	}\n}\n","binary search,brute force,math"
"import java.io.*;\nimport java.util.*;\n\npublic class numerical_sequence_easy {\n	\n	public static void main(String[] args) throws Exception {\n\n		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n		\n        int q = Integer.parseInt(in.readLine());\n        while (q-- > 0) {\n            long k = Long.parseLong(in.readLine()) - 1;\n            solve(k);\n        }\n    }\n	\n	static long checksum(long mid) {\n        if (mid == 0) {\n            return 0;\n        }\n        \n        int l = Long.toString(mid).length();\n        long count = 0;\n        for (int i = 1; i < l; i++) {\n            long p = (long) (Math.pow(10, i) - Math.pow(10, i - 1));\n            long t1 = i * ((p * (p + 1)) / 2);\n\n            long t2 = (long) (Math.pow(10, i) - Math.pow(10, i - 1)) * i * (mid - ((long) Math.pow(10, i) - 1));\n\n            count += t1 + t2;\n        }\n        long p = mid - (long) Math.pow(10, l - 1) + 1;\n        count += l * ((p * (p + 1)) / 2);\n        return count;\n    }\n\n    static void solve(long k) {\n        long l = 0;\n        long r = 1000_000_000L;\n        while (l < r) {\n            long mid = (l + r) / 2;\n            if (k >= checksum(mid)) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        }\n        \n        k -= checksum(l - 1);\n        for (int i = 1; i <= l; i++) {\n            String x = Long.toString(i);\n            if (k >= x.length()) {\n            	k -= x.length();\n            } else {\n                System.out.println(x.charAt((int) k));\n                return;\n            }\n        }\n    }\n\n}\n","binary search,brute force,math"
"//package numericalsequenceeasyversion;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class numericalsequenceeasyversion {\n	public static void main(String[] args) throws IOException {\n		BufferedReader fin = new BufferedReader(new InputStreamReader(System.in));\n		StringBuilder fout = new StringBuilder();\n		int t = Integer.parseInt(fin.readLine());\n		while(t-- > 0) {\n			long k = Long.parseLong(fin.readLine());\n			//first bin search for which group it belongs to\n			long low = 0;	//group num\n			long high = (long) 1e9;\n			long mid = low + (high - low) / 2;\n			long ans = 0;\n			while(low <= high) {\n				long curAmt = 0;\n				long power = 1;\n				while(power <= mid) {\n					long n = mid - power + 1;\n					curAmt += (n * (n + 1)) / 2;\n					power *= 10;\n				}\n				if(curAmt < k) {\n					low = mid + 1;\n					ans = Math.max(ans, curAmt);\n				}\n				else {\n					high = mid - 1;\n				}\n				mid = low + (high - low) / 2;\n			}\n			k -= ans;\n			//System.out.println(ans + "" ""  + k);\n			//compute which number k is part of\n			long maxAmt = 0;\n			long c = 0;\n			ans = 0;\n			while(true) {\n				//System.out.println(""YES"" + "" "" + k);\n				long rightMaxAmt = maxAmt <= 9? maxAmt : maxAmt - (long) Math.pow(10, c - 1) + 1;\n				//System.out.println(""R: "" + rightMaxAmt);\n				if(k > rightMaxAmt * c) {\n					k -= rightMaxAmt * c;\n					c ++;\n					maxAmt *= 10;\n					maxAmt += 9;\n					continue;\n				}\n				maxAmt /= 10;\n				k--;\n				//System.out.println(""K: "" + k + "" "" + c);\n				long rem = k % c;\n				long multiples = k / c;\n				k = rem;\n				ans = maxAmt + multiples + 1;\n				//System.out.println(maxAmt + "" "" + multiples);\n				break;\n			}\n			\n			String s = ans + """";\n			//System.out.println(s + "" "" + k);\n			fout.append(s.charAt((int) k)).append(""\n"");\n		}\n		System.out.print(fout);\n	}\n}\n","binary search,brute force,math"
"import java.io.*;\nimport java.util.*;\n\npublic class E {\n	public static void main (String[] args) throws IOException {\n		Kattio io = new Kattio();\n		int t = io.nextInt();\n		TreeMap<Long, Long> map = new TreeMap<Long, Long>();\n		map.put(0L, 0L);\n		long total = 0;\n		long cur = 0;\n		for (long i=1; i<100000; i++) {\n			cur += digits(i);\n			total += cur;\n			map.put(total, i);\n		}\n		//System.out.println(map);\n		//System.out.println(map.lastKey());\n		outer: for (int ii=0; ii<t; ii++) {\n			long n = io.nextLong();\n			long seq = map.lowerKey(n);\n			//System.out.println(""n seq : "" + n + "" "" + seq);\n\n			long num = 1;\n			long start = seq;\n			//System.out.println(""init start: "" + start);\n\n			while (true) {\n				char[] s = String.valueOf(num).toCharArray();\n				for (char c : s) {\n					start++;\n					//System.out.println(c + "" "" + start + "" "" + num);\n					if (start == n) {\n						System.out.println(c);\n						continue outer;\n					}\n				}\n				num++;\n			}\n		}\n	}\n\n	static int digits(long n) {\n		String s = String.valueOf(n);\n		return s.length();\n	}\n\n	static class Kattio extends PrintWriter {\n		private BufferedReader r;\n		private StringTokenizer st;\n\n		// standard input\n		public Kattio() { this(System.in, System.out); }\n		public Kattio(InputStream i, OutputStream o) {\n			super(o);\n			r = new BufferedReader(new InputStreamReader(i));\n		}\n		// USACO-style file input\n		public Kattio(String problemName) throws IOException {\n			super(new FileWriter(problemName + "".out""));\n			r = new BufferedReader(new FileReader(problemName + "".in""));\n		}\n\n		// returns null if no more input\n		public String next() {\n			try {\n				while (st == null || !st.hasMoreTokens())\n					st = new StringTokenizer(r.readLine());\n				return st.nextToken();\n			} catch (Exception e) { }\n			return null;\n		}\n\n		public int nextInt() { return Integer.parseInt(next()); }\n		public double nextDouble() { return Double.parseDouble(next()); }\n		public long nextLong() { return Long.parseLong(next()); }\n	}\n}","binary search,brute force,math"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskH solver = new TaskH();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class TaskH {\n        boolean valid = true;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int k = in.readInt();\n            Node[] nodes = new Node[n + 1];\n            for (int i = 1; i <= n; i++) {\n                nodes[i] = new Node();\n                nodes[i].id = i;\n            }\n            for (int i = 1; i < n; i++) {\n                Node a = nodes[in.readInt()];\n                Node b = nodes[in.readInt()];\n                a.next.add(b);\n                b.next.add(a);\n            }\n            findDiameter(nodes[1], null, 0);\n            List<Node> trace = new ArrayList<>(n);\n            dfsForTrace(nodes[1].a, null, 0, nodes[1].diameter, trace);\n\n            int half = trace.size() / 2;\n            Node a = trace.get(half - 1);\n            Node b = trace.get(half);\n            a.next.remove(b);\n            b.next.remove(a);\n            paint(a, b, 0, k, -1);\n            paint(b, a, 1, k, 1);\n            verify(a, b, 0, k);\n            verify(b, a, 0, k);\n            if (!valid) {\n                out.println(""No"");\n                return;\n            }\n            out.println(""Yes"");\n            for (int i = 1; i <= n; i++) {\n                out.append(nodes[i].color + 1).append(' ');\n            }\n        }\n\n        public void verify(Node root, Node p, int depth, int k) {\n            root.depth = depth;\n            root.depthest = root;\n            for (Node node : root.next) {\n                if (node == p) {\n                    continue;\n                }\n                verify(node, root, depth + 1, k);\n                if (root.depthest != root && node.depthest.depth + root.depthest.depth - depth * 2 + 1 >= k && k > 2) {\n                    valid = false;\n                }\n                if (node.depthest.depth > root.depthest.depth) {\n                    root.depthest = node.depthest;\n                }\n            }\n        }\n\n        public void paint(Node root, Node p, int color, int k, int step) {\n            root.color = DigitUtils.mod(color, k);\n            for (Node node : root.next) {\n                if (node == p) {\n                    continue;\n                }\n                paint(node, root, color + step, k, step);\n            }\n        }\n\n        public boolean dfsForTrace(Node root, Node p, int depth, int diameter, List<Node> trace) {\n            trace.add(root);\n            if (depth == diameter) {\n                return true;\n            }\n            for (Node node : root.next) {\n                if (node == p) {\n                    continue;\n                }\n                if (dfsForTrace(node, root, depth + 1, diameter, trace)) {\n                    return true;\n                }\n            }\n            trace.remove(trace.size() - 1);\n            return false;\n        }\n\n        public void findDiameter(Node root, Node p, int depth) {\n            root.depth = depth;\n            root.depthest = root;\n            for (Node node : root.next) {\n                if (node == p) {\n                    continue;\n                }\n                findDiameter(node, root, depth + 1);\n                if (root.diameter < node.diameter) {\n                    root.diameter = node.diameter;\n                    root.a = node.a;\n                }\n                if (root.depthest.depth + node.depthest.depth - root.depth * 2 > root.diameter) {\n                    root.diameter = root.depthest.depth + node.depthest.depth - 2 * root.depth;\n                    root.a = root.depthest;\n                }\n                if (root.depthest.depth < node.depthest.depth) {\n                    root.depthest = node.depthest;\n                }\n            }\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(String c) {\n            cache.append(c).append('\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Node {\n        List<Node> next = new ArrayList<>();\n        int color;\n        Node depthest;\n        int depth;\n        int diameter;\n        Node a;\n        int id;\n\n        public String toString() {\n            return """" + id;\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static int mod(int x, int mod) {\n            x %= mod;\n            if (x < 0) {\n                x += mod;\n            }\n            return x;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n}\n\n","constructive algorithms,dfs and similar,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        //BufferedReader f = new BufferedReader(new FileReader(""uva.in""));\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        int n = Integer.parseInt(f.readLine());\n        StringTokenizer st = new StringTokenizer(f.readLine());\n        int[] d = new int[n];\n        ArrayList<Integer> order = new ArrayList<>(n);\n        for(int i = 0; i < n; i++) {\n            d[i] = Integer.parseInt(st.nextToken());\n            order.add(i);\n        }\n        Collections.sort(order, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return d[o2]-d[o1];\n            }\n        });\n        for(int i = 0; i < n; i++) {\n            order.set(i, 2*order.get(i)+1);\n        }\n        for(int i = 0; i < n-1; i++) {\n            out.println(order.get(i) + "" "" + order.get(i+1));\n        }\n        for(int i = 0; i < n; i++) {\n            int dist = d[order.get(i)/2];\n            int next = order.get(i)+1;\n            out.println(order.get(i+dist-1) + "" "" + next);\n            if(i+dist >= order.size()) {\n                order.add(next);\n            }\n        }\n        f.close();\n        out.close();\n    }\n}\n","constructive algorithms,graphs,math,sortings,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class A {\n\n	public static void main(String[] args) throws IOException {\n		Scanner sc = new Scanner();\n		PrintWriter out = new PrintWriter(System.out);\n		int n = sc.nextInt();\n		Integer[] indices = new Integer[n];\n		int[] d = new int[n];\n		ArrayList<Integer> longestPath = new ArrayList();\n		for (int i = 0; i < n; i++) {\n			d[i] = sc.nextInt();\n			indices[i] = i;\n		}\n		Arrays.sort(indices, Comparator.comparingInt(i -> -d[i]));\n		for (int u : indices) {\n			if (longestPath.size() > 0)\n				out.printf(""%d %d\n"", (u << 1) + 1, longestPath.get(longestPath.size() - 1) + 1);\n\n			longestPath.add(u << 1);\n		}\n		for (int i = 0; i < n; i++) {\n			int u = indices[i];\n			int from = longestPath.get(i + d[u] - 1);\n			out.printf(""%d %d\n"", from + 1, 2 * u + 2);\n			if (i + d[u] == longestPath.size())\n				longestPath.add(2 * u + 1);\n		}\n		out.close();\n\n	}\n\n	static class Scanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		Scanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		Scanner(String fileName) throws FileNotFoundException {\n			br = new BufferedReader(new FileReader(fileName));\n		}\n\n		String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() throws NumberFormatException, IOException {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() throws NumberFormatException, IOException {\n			return Double.parseDouble(next());\n		}\n\n		boolean ready() throws IOException {\n			return br.ready();\n		}\n\n	}\n\n	static void sort(int[] a) {\n		shuffle(a);\n		Arrays.sort(a);\n	}\n\n	static void shuffle(int[] a) {\n		int n = a.length;\n		Random rand = new Random();\n		for (int i = 0; i < n; i++) {\n			int tmpIdx = rand.nextInt(n);\n			int tmp = a[i];\n			a[i] = a[tmpIdx];\n			a[tmpIdx] = tmp;\n		}\n	}\n\n}","constructive algorithms,graphs,math,sortings,trees"
"import java.io.BufferedOutputStream;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.Objects;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	static class TaskAdapter implements Runnable {\n		@Override\n		public void run() {\n			long startTime = System.currentTimeMillis();\n			InputStream inputStream = System.in;\n			OutputStream outputStream = System.out;\n			FastReader in = new FastReader(inputStream);\n			Output out = new Output(outputStream);\n			EPetyaAndConstructionSet solver = new EPetyaAndConstructionSet();\n			solver.solve(1, in, out);\n			out.close();\n			System.err.println(System.currentTimeMillis()-startTime+""ms"");\n		}\n	}\n\n	public static void main(String[] args) throws Exception {\n		Thread thread = new Thread(null, new TaskAdapter(), """", 1<<28);\n		thread.start();\n		thread.join();\n	}\n\n	static class EPetyaAndConstructionSet {\n		public EPetyaAndConstructionSet() {\n		}\n\n		public void solve(int kase, InputReader in, Output pw) {\n			int n = in.nextInt();\n			Pair<Integer, Integer>[] arr = new Pair[n];\n			for(int i = 0; i<n; i++) {\n				arr[i] = new Pair<>(in.nextInt(), 2*i+2);\n			}\n			Arrays.sort(arr, Comparator.comparingInt(o -> -o.a));\n			ArrayDeque<Integer> path = new ArrayDeque<>();\n			HashSet<Integer> hs = new HashSet<>();\n			{\n				int prev = -1;\n				for(int i = 0; i<n; i++) {\n					path.addLast(arr[i].b-1);\n					hs.add(arr[i].b-1);\n					if(prev!=-1) {\n						pw.println(prev, arr[i].b-1);\n					}\n					prev = arr[i].b-1;\n				}\n			}\n			for(int i = 0; i<n; i++) {\n				if(!hs.contains(arr[i].b-1)) {\n					path.addFirst(arr[i].b-1);\n					hs.add(arr[i].b-1);\n				}else if(!path.getFirst().equals(arr[i].b-1)) {\n					hs.remove(path.removeFirst());\n				}\n				while(path.size()>arr[i].a) {\n					hs.remove(path.removeLast());\n				}\n				pw.println(path.getLast(), arr[i].b);\n				hs.add(arr[i].b);\n				path.addLast(arr[i].b);\n			}\n		}\n\n	}\n\n	static interface InputReader {\n		int nextInt();\n\n	}\n\n	static class Pair<T1, T2> implements Comparable<Pair<T1, T2>> {\n		public T1 a;\n		public T2 b;\n\n		public Pair(Pair<T1, T2> p) {\n			this(p.a, p.b);\n		}\n\n		public Pair(T1 a, T2 b) {\n			this.a = a;\n			this.b = b;\n		}\n\n		public String toString() {\n			return a+"" ""+b;\n		}\n\n		public int hashCode() {\n			return Objects.hash(a, b);\n		}\n\n		public boolean equals(Object o) {\n			if(o instanceof Pair) {\n				Pair p = (Pair) o;\n				return a.equals(p.a)&&b.equals(p.b);\n			}\n			return false;\n		}\n\n		public int compareTo(Pair<T1, T2> p) {\n			int cmp = ((Comparable<T1>) a).compareTo(p.a);\n			if(cmp==0) {\n				return ((Comparable<T2>) b).compareTo(p.b);\n			}\n			return cmp;\n		}\n\n	}\n\n	static class FastReader implements InputReader {\n		final private int BUFFER_SIZE = 1<<16;\n		private DataInputStream din;\n		private byte[] buffer;\n		private int bufferPointer;\n		private int bytesRead;\n\n		public FastReader(InputStream is) {\n			din = new DataInputStream(is);\n			buffer = new byte[BUFFER_SIZE];\n			bufferPointer = bytesRead = 0;\n		}\n\n		public int nextInt() {\n			int ret = 0;\n			byte c = skipToDigit();\n			boolean neg = (c=='-');\n			if(neg) {\n				c = read();\n			}\n			do {\n				ret = ret*10+c-'0';\n			} while((c = read())>='0'&&c<='9');\n			if(neg) {\n				return -ret;\n			}\n			return ret;\n		}\n\n		private boolean isDigit(byte b) {\n			return b>='0'&&b<='9';\n		}\n\n		private byte skipToDigit() {\n			byte ret;\n			while(!isDigit(ret = read())&&ret!='-') ;\n			return ret;\n		}\n\n		private void fillBuffer() {\n			try {\n				bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n			}catch(IOException e) {\n				e.printStackTrace();\n				throw new InputMismatchException();\n			}\n			if(bytesRead==-1) {\n				buffer[0] = -1;\n			}\n		}\n\n		private byte read() {\n			if(bytesRead==-1) {\n				throw new InputMismatchException();\n			}else if(bufferPointer==bytesRead) {\n				fillBuffer();\n			}\n			return buffer[bufferPointer++];\n		}\n\n	}\n\n	static class Output implements Closeable, Flushable {\n		public StringBuilder sb;\n		public OutputStream os;\n		public int BUFFER_SIZE;\n		public String lineSeparator;\n\n		public Output(OutputStream os) {\n			this(os, 1<<16);\n		}\n\n		public Output(OutputStream os, int bs) {\n			BUFFER_SIZE = bs;\n			sb = new StringBuilder(BUFFER_SIZE);\n			this.os = new BufferedOutputStream(os, 1<<17);\n			lineSeparator = System.lineSeparator();\n		}\n\n		public void print(String s) {\n			sb.append(s);\n			if(sb.length()>BUFFER_SIZE >> 1) {\n				flushToBuffer();\n			}\n		}\n\n		public void println(Object... o) {\n			for(int i = 0; i<o.length; i++) {\n				if(i!=0) {\n					print("" "");\n				}\n				print(String.valueOf(o[i]));\n			}\n			println();\n		}\n\n		public void println() {\n			sb.append(lineSeparator);\n		}\n\n		private void flushToBuffer() {\n			try {\n				os.write(sb.toString().getBytes());\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n			sb = new StringBuilder(BUFFER_SIZE);\n		}\n\n		public void flush() {\n			try {\n				flushToBuffer();\n				os.flush();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n		public void close() {\n			flush();\n			try {\n				os.close();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n	}\n}\n\n","constructive algorithms,graphs,math,sortings,trees"
"import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1214e {\n\n    public static void main(String[] args) throws IOException {\n        int n = ri(), d[] = ria(n), sorted[][] = new int[n][2];\n        for (int i = 0; i < n; ++i) {\n            sorted[i][0] = d[i];\n            sorted[i][1] = i;\n        }\n        sort(sorted, (a, b) -> b[0] - a[0]);\n        List<Integer> route = new ArrayList<>();\n        route.add(2 * sorted[0][1] + 1);\n        for (int i = 0; i < n - 1; ++i) {\n            prln(2 * sorted[i][1] + 1, 2 * sorted[i + 1][1] + 1);\n            route.add(2 * sorted[i + 1][1] + 1);\n        }\n        for (int i = 0; i < n; ++i) {\n            prln(route.get(i + sorted[i][0] - 1), 2 * sorted[i][1] + 2);\n            if (i + sorted[i][0] == route.size()) {\n                route.add(2 * sorted[i][1] + 2);\n            }\n        }\n        close();\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int lcm(int a, int b) {return a * b / gcf(a, b);}\n    static long lcm(long a, long b) {return a * b / gcf(a, b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // graph util\n    static List<List<Integer>> g(int n) {List<List<Integer>> g = new ArrayList<>(); for (int i = 0; i < n; ++i) g.add(new ArrayList<>()); return g;}\n    static List<Set<Integer>> sg(int n) {List<Set<Integer>> g = new ArrayList<>(); for (int i = 0; i < n; ++i) g.add(new HashSet<>()); return g;}\n    static void c(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).add(v); g.get(v).add(u);}\n    static void cto(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).add(v);}\n    static void dc(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).remove(v); g.get(v).remove(u);}\n    static void dcto(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).remove(v);}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    static List<List<Integer>> rg(int n, int m) throws IOException {List<List<Integer>> g = g(n); for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1); return g;}\n    static void rg(List<List<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1);}\n    static List<List<Integer>> rdg(int n, int m) throws IOException {List<List<Integer>> g = g(n); for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1); return g;}\n    static void rdg(List<List<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1);}\n    static List<Set<Integer>> rsg(int n, int m) throws IOException {List<Set<Integer>> g = sg(n); for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1); return g;}\n    static void rsg(List<Set<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) c(g, rni() - 1, ni() - 1);}\n    static List<Set<Integer>> rdsg(int n, int m) throws IOException {List<Set<Integer>> g = sg(n); for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1); return g;}\n    static void rdsg(List<Set<Integer>> g, int m) throws IOException {for (int i = 0; i < m; ++i) cto(g, rni() - 1, ni() - 1);}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {prln(""yes"");}\n    static void pry() {prln(""Yes"");}\n    static void prY() {prln(""YES"");}\n    static void prno() {prln(""no"");}\n    static void prn() {prln(""No"");}\n    static void prN() {prln(""NO"");}\n    static void pryesno(boolean b) {prln(b ? ""yes"" : ""no"");};\n    static void pryn(boolean b) {prln(b ? ""Yes"" : ""No"");}\n    static void prYN(boolean b) {prln(b ? ""YES"" : ""NO"");}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(""hlfd""); flush();}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}}","constructive algorithms,graphs,math,sortings,trees"
"\nimport java.util.*;\npublic class ydcthc {\n\n	public static void main(String[] args) {\n       \n		Scanner sc =new Scanner(System.in);\n		int n=sc.nextInt();\n		int ans=0;\n		for(int i=0;i<n;i++) {\n			if(sc.nextInt()%2==0) {\n				ans++;\n			}\n		}\n		\nSystem.out.println(Math.min(ans,n-ans));\n	}\n\n}",math
"\nimport java.util.*;\npublic class ydcthc {\n\n	public static void main(String[] args) {\n       \n		Scanner sc =new Scanner(System.in);\n		int n=sc.nextInt();\n		int ans=0;\n		for(int i=0;i<n;i++) {\n			if(sc.nextInt()%2==0) {\n				ans++;\n			}\n		}\n		\nSystem.out.println(Math.min(ans,n-ans));\n	}\n\n}",math
"import java.util.*;\npublic class Main{\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int a=0,b=0;\n		for(int i=0;i<n;i++) {\n			int c=sc.nextInt();\n			if(c%2==0) {\n				a++;\n			}else\n				b++;\n		}\n		System.out.println(Math.min(a, b));\n	}\n}",math
"\nimport java.util.*;\npublic class Answer {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int t;\n		t=sc.nextInt();\n		int counto=0;\n		for(int i=0;i<t;i++) {\n			int x;\n			x=sc.nextInt();\n			counto+=x&1;\n		}\n		System.out.println(Math.min(counto, t-counto));\n	}\n	 \n\n}\n",math
"import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Test {\n  static PrintWriter writer =\n      new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n  int[][] a = new int[12][2000];\n  int[][] e = new int[12 * 2000][3];\n  Integer[] se = new Integer[12 * 2000];\n  boolean[] used = new boolean[2000];\n  int[] dp = new int[1 << 12];\n  int[] one = new int[1 << 12];\n\n  static int readInt() {\n    int ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  static long readLong() {\n    long ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  static String readLine() {\n    StringBuilder b = new StringBuilder();\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (Character.isLetterOrDigit(c)) {\n          start = true;\n          b.append((char) c);\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return b.toString();\n  }\n\n  public static void main(String[] args) {\n    Test te = new Test();\n    te.start();\n    writer.flush();\n  }\n\n  void start() {\n    int t = readInt();\n    while (t-- > 0) {\n      int n = readInt(), m = readInt();\n      for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++) {\n          a[i][j] = readInt();\n          int k = i * m + j;\n          e[k][0] = a[i][j];\n          e[k][1] = j;\n          e[k][2] = i;\n        }\n      for (int i = n * m - 1; i >= 0; i--) se[i] = i;\n      Arrays.sort(\n          se,\n          0,\n          n * m,\n          (i, j) -> {\n            int[] x = e[i], y = e[j];\n            return x[0] == y[0]\n                ? (x[1] == y[1] ? Integer.compare(x[2], y[2]) : Integer.compare(x[1], y[1]))\n                : Integer.compare(x[0], y[0]);\n          });\n      Arrays.fill(used, 0, m, false);\n      Arrays.fill(dp, 0, 1 << n, -1);\n      dp[0] = 0;\n      int cc = 0;\n      for (int x = n * m - 1; x >= 0; x--) {\n        int c = e[se[x]][1];\n        if (used[c]) continue;\n        used[c] = true;\n        cc++;\n        if (cc > n) break;\n\n        Arrays.fill(one, 0, 1 << n, 0);\n\n        for (int i = (1 << n) - 1; i > 0; i--) {\n          for (int r = 0; r < n; r++) {\n            int sum = 0;\n            for (int j = 0; j < n; j++) if (((i >> j) & 1) != 0) sum += a[(j + r) % n][c];\n            one[i] = Math.max(one[i], sum);\n          }\n        }\n\n        for (int i = (1 << n) - 1; i >= 0; i--) {\n          int u = (1 << n) - 1 - i;\n          int p = u;\n          if (dp[i] >= 0)\n            while (p > 0) {\n              dp[i | p] = Math.max(dp[i | p], dp[i] + one[p]);\n              p = (p - 1) & u;\n            }\n        }\n      }\n      writer.println(dp[(1 << n) - 1]);\n    }\n  }\n}\n","bitmasks,dp,greedy,sortings"
"import java.io.*;\nimport java.util.*;\n\n\npublic class Main{\n	static int[][]memo;\n	static int n,m,in[][];\n	static int dp(int col,int maxRowMask) {\n		if(col>=Math.min(n, m) || maxRowMask==((1<<n)-1))return 0;\n		if(memo[col][maxRowMask]!=-1)return memo[col][maxRowMask];\n		\n		int ans=0;\n		\n		int availableBits=maxRowMask^((1<<n)-1);\n		//all masks that don't intersect with maxRowMask\n		for(int colMask=availableBits;colMask!=0;colMask=(colMask-1)&availableBits) {\n			\n			ans=Math.max(ans, maxMask[col][colMask]+dp(col+1, maxRowMask|colMask));\n			\n		}\n		return memo[col][maxRowMask]=ans;\n	}\n	static int[][]sumOfMask;\n	static int[][]maxMask;\n	public static void main(String[] args) throws Exception{\n		pw=new PrintWriter(System.out);\n		sc = new MScanner(System.in);\n		int tc=sc.nextInt();\n		while(tc-->0) {\n			n=sc.nextInt();m=sc.nextInt();\n			\n			int[]maxInCol=new int[m];\n			in=new int[m][n+1];\n			\n			for(int i=0;i<n;i++) {\n				for(int j=0;j<m;j++) {\n					in[j][i]=sc.nextInt();\n					maxInCol[j]=Math.max(maxInCol[j], in[j][i]);\n					in[j][n]=j;\n				}\n			}\n			Arrays.sort(in,(x,y)->maxInCol[y[n]]-maxInCol[x[n]]);\n			\n			\n			memo=new int[n][1<<n];\n			sumOfMask=new int[n][1<<n];\n			maxMask=new int[n][1<<n];\n			for(int i=0;i<n;i++) {\n				for(int msk=0;msk<memo[i].length;msk++) {\n					memo[i][msk]=-1;\n					if(i>=m)continue;\n					for(int bit=0;bit<n;bit++) {\n						if(((msk>>bit)&1)!=0) {\n							sumOfMask[i][msk]+=in[i][bit];\n						}\n					}\n				}\n			}\n			for(int col=0;col<n;col++) {\n				for(int msk=0;msk<(1<<n);msk++) {\n					int curMask=msk;\n					for(int cyclicShift=0;cyclicShift<n;cyclicShift++) {\n						maxMask[col][msk]=Math.max(maxMask[col][msk], sumOfMask[col][curMask]);\n						\n						int lastBit=curMask&1;\n						curMask>>=1;\n						curMask|=(lastBit<<(n-1));\n						\n					}\n				}\n			}\n			pw.println(dp(0, 0));\n		}\n		\n		\n		pw.flush();\n	}\n	static PrintWriter pw;\n	static MScanner  sc;\n	static class MScanner {\n		StringTokenizer st;\n		BufferedReader br;\n		public MScanner(InputStream system) {\n			br = new BufferedReader(new InputStreamReader(system));\n		}\n \n		public MScanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n \n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n		public int[] intArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public long[] longArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public int[] intSortedArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		public long[] longSortedArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		public Integer[] IntegerArr(int n) throws IOException {\n	        Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public Long[] LongArr(int n) throws IOException {\n	        Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n \n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n \n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n \n		public char nextChar() throws IOException {\n			return next().charAt(0);\n		}\n \n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n \n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n \n		public void waitForInput() throws InterruptedException {\n			Thread.sleep(3000);\n		}\n	}\n	static void shuffle(int[]in) {\n		for(int i=0;i<in.length;i++) {\n			int idx=(int)(Math.random()*in.length);\n			int tmp=in[i];\n			in[i]=in[idx];\n			in[idx]=tmp;\n		}\n	}\n	static void shuffle(long[]in) {\n		for(int i=0;i<in.length;i++) {\n			int idx=(int)(Math.random()*in.length);\n			long tmp=in[i];\n			in[i]=in[idx];\n			in[idx]=tmp;\n		}\n	}\n}","bitmasks,dp,greedy,sortings"
"import java.util.*;\nimport java.io.*;\n\npublic class Main {\n	public static void main(String args[]) {new Main().run();}\n\n	FastReader in = new FastReader();\n	PrintWriter out = new PrintWriter(System.out);\n	void run(){\n		int t=in.nextInt();\n		for(int i=0;i<t;i++) {\n			out.println(work());\n		}\n		out.flush();\n	}\n	long mod=1000000007;\n	long gcd(long a,long b) {\n		return b==0?a:gcd(b,a%b);\n	}\n	int work() {\n		int n=in.nextInt();\n		int m=in.nextInt();\n		int[][] A=new int[n][m];\n		int[][] B=new int[n][m];\n		int[][] R=new int[m][2];\n		for(int i=0;i<m;i++)R[i][1]=i;\n		for(int i=0;i<n;i++) {\n			for(int j=0;j<m;j++) {\n				A[i][j]=in.nextInt();\n				R[j][0]=Math.max(R[j][0], A[i][j]);\n			}\n		}\n		Arrays.sort(R,new Comparator<int[]>() {\n			public int compare(int[] arr1,int[] arr2) {\n				return arr2[0]-arr1[0];\n			}\n		});\n		for(int j=0;j<m;j++) {\n			int index=R[j][1];\n			for(int i=0;i<n;i++) {\n				B[i][j]=A[i][index];\n			}\n		}\n		m=Math.min(n, m);\n		int[][] dp=new int[m][1<<n];\n		int[][] rec=new int[m][1<<n];\n		for(int j=0;j<m;j++) {\n			for(int s=0;s<n;s++) {//转\n				for(int i=1;i<1<<n;i++) {\n					int sum=0;\n					for(int b=0;b<n;b++) {\n						if(((1<<b)&i)>0) {\n							sum+=B[(b+s)%n][j];\n						}\n					}\n					rec[j][i]=Math.max(sum, rec[j][i]);\n				}\n			}\n		}\n		\n		for(int j=0;j<m;j++) {\n			for(int i=0;i<1<<n;i++) {\n				if(j==0) {\n					dp[j][i]=rec[j][i];\n				}else {\n					for(int p=i;p<1<<n;p++) {\n						p=p|i;\n						dp[j][p]=Math.max(dp[j][p], rec[j][i]+dp[j-1][p^i]);\n					}\n				}\n			}\n		}\n		return dp[m-1][(1<<n)-1];\n	}\n}\n\n\n\nclass FastReader\n{\n	BufferedReader br;\n	StringTokenizer st;\n\n	public FastReader()\n	{\n		br=new BufferedReader(new InputStreamReader(System.in));\n	}\n\n	public String next() \n	{\n		if(st==null || !st.hasMoreElements())\n		{\n			try {\n				st = new StringTokenizer(br.readLine());\n			} catch (IOException e) {\n				e.printStackTrace();\n			}\n		}\n		return st.nextToken();\n	}\n\n	public int nextInt() \n	{\n		return Integer.parseInt(next());\n	}\n\n	public long nextLong()\n	{\n		return Long.parseLong(next());\n	}\n}","bitmasks,dp,greedy,sortings"
"import java.util.*;\nimport java.io.*;\n\npublic class Main {\n	public static void main(String args[]) {new Main().run();}\n\n	FastReader in = new FastReader();\n	PrintWriter out = new PrintWriter(System.out);\n	void run(){\n		int t=in.nextInt();\n		for(int i=0;i<t;i++) {\n			out.println(work());\n		}\n		out.flush();\n	}\n	long mod=1000000007;\n	long gcd(long a,long b) {\n		return b==0?a:gcd(b,a%b);\n	}\n	int work() {\n		int n=in.nextInt();\n		int m=in.nextInt();\n		int[][] A=new int[n][m];\n		int[][] B=new int[n][m];\n		int[][] R=new int[m][2];\n		for(int i=0;i<m;i++)R[i][1]=i;\n		for(int i=0;i<n;i++) {\n			for(int j=0;j<m;j++) {\n				A[i][j]=in.nextInt();\n				R[j][0]=Math.max(R[j][0], A[i][j]);\n			}\n		}\n		Arrays.sort(R,new Comparator<int[]>() {\n			public int compare(int[] arr1,int[] arr2) {\n				return arr2[0]-arr1[0];\n			}\n		});\n		for(int j=0;j<m;j++) {\n			int index=R[j][1];\n			for(int i=0;i<n;i++) {\n				B[i][j]=A[i][index];\n			}\n		}\n		m=Math.min(n, m);\n		int[][] dp=new int[m][1<<n];\n		int[][] rec=new int[m][1<<n];\n		for(int j=0;j<m;j++) {\n			for(int s=0;s<n;s++) {//转\n				for(int i=1;i<1<<n;i++) {\n					int sum=0;\n					for(int b=0;b<n;b++) {\n						if(((1<<b)&i)>0) {\n							sum+=B[(b+s)%n][j];\n						}\n					}\n					rec[j][i]=Math.max(sum, rec[j][i]);\n				}\n			}\n		}\n		\n		for(int j=0;j<m;j++) {\n			for(int i=0;i<1<<n;i++) {\n				if(j==0) {\n					dp[j][i]=rec[j][i];\n				}else {\n					for(int p=i+1;;p++) {\n						if(p>=1<<n)break;\n						p=p|i;\n						dp[j][p]=Math.max(dp[j][p], rec[j][i]+dp[j-1][p^i]);\n					}\n				}\n			}\n		}\n		return dp[m-1][(1<<n)-1];\n	}\n}\n\n\n\nclass FastReader\n{\n	BufferedReader br;\n	StringTokenizer st;\n\n	public FastReader()\n	{\n		br=new BufferedReader(new InputStreamReader(System.in));\n	}\n\n	public String next() \n	{\n		if(st==null || !st.hasMoreElements())\n		{\n			try {\n				st = new StringTokenizer(br.readLine());\n			} catch (IOException e) {\n				e.printStackTrace();\n			}\n		}\n		return st.nextToken();\n	}\n\n	public int nextInt() \n	{\n		return Integer.parseInt(next());\n	}\n\n	public long nextLong()\n	{\n		return Long.parseLong(next());\n	}\n}","bitmasks,dp,greedy,sortings"
"//package usacoGoldAccelerated;\n\nimport java.util.Scanner;\n\npublic class Week3Pipeline {\n\n	public static void main(String[] args) {\n		\n		Scanner scanner = new Scanner(System.in);\n		\n		int t = scanner.nextInt();\n		\n		for(int i=0; i<t; i++) {\n			int n = scanner.nextInt();\n			int a = scanner.nextInt();\n			int b = scanner.nextInt();\n			scanner.nextLine();\n			int[] road = new int[n+1];\n			String line = scanner.nextLine();\n			for(int j=1; j<=n; j++) {\n				road[j] = line.charAt(j-1)-48;\n			}\n			\n			long dp[][] = new long[n+1][2];\n			for(int k=0; k<=n; k++) {\n				for(int j=0; j<2; j++) {\n					dp[k][j] = Long.MAX_VALUE/3;\n				}\n			}\n			dp[0][0] = b;\n			\n			for(int j=1; j<=n; j++) {\n				if(road[j]==1) {\n					//dp[j][1] = Math.min(dp[j-1][0]+2*a+2*b, dp[j-1][1]+a+2*b);\n					//if(road[j-1]==0) {\n					//	dp[j][1] = dp[j-1][1]+2*a+2*b;\n					//}\n					//else {\n					dp[j][1] = dp[j-1][1]+a+2*b;\n					//}\n					//System.out.println(dp[j][1]);\n				}\n				else {\n					dp[j][0] = Math.min(dp[j-1][0]+a+b, dp[j-1][1]+2*a+b);\n					dp[j][1] = Math.min(dp[j-1][0]+2*a+2*b, dp[j-1][1]+a+2*b);\n					//System.out.println(dp[j][0]+"" ""+dp[j][1]);\n				}\n				\n			}\n			\n			\n			\n			System.out.println(dp[n][0]);\n			System.out.println();\n			\n		}\n\n	}\n\n}\n\n\n\n","dp,greedy"
"import java.io.*;\nimport java.util.*;\nimport java.lang.Math;\npublic class GasPipeline {\n  public static void main (String [] args) throws IOException {\n    \n    BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n    int ttttt = Integer.parseInt(f.readLine());\n    for(int aaa = 0; aaa < ttttt; aaa++){\n        StringTokenizer s = new StringTokenizer(f.readLine());\n        int N = Integer.parseInt(s.nextToken());\n        int a = Integer.parseInt(s.nextToken());\n        int b = Integer.parseInt(s.nextToken());\n        String str = ""0"" + f.readLine();\n        long[][] dp = new long[N + 10][2];\n        for(int i = 0; i <= N; i++){\n            Arrays.fill(dp[i], Long.MAX_VALUE/2);\n        }\n        \n        dp[0][1] = Long.MAX_VALUE/2;\n        dp[0][0] = b;\n        for(int i = 1; i <= N; i++){\n            if(str.charAt(i) == '1'){\n                dp[i][1] = Math.min(dp[i][1], dp[i - 1][1] + a + b * 2);\n            }else{\n                dp[i][0] = Math.min(dp[i][0], Math.min(dp[i - 1][0] + a + b, dp[i - 1][1] + 2 * a + b));\n                dp[i][1] = Math.min(dp[i][1], Math.min(dp[i - 1][0] + 2 * a + 2 * b, dp[i - 1][1] + a + b * 2));\n            }\n        }\n        System.out.println(dp[N][0]);\n    }\n  }\n}\n","dp,greedy"
"import java.io.*;\nimport java.util.*;\npublic class cf{\n    public static void main(String[] args) throws IOException {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));\n        int t = Integer.parseInt(bf.readLine());\n        for(int testcase = 0; testcase < t; testcase++){\n            StringTokenizer stk = new StringTokenizer(bf.readLine());\n            int N = Integer.parseInt(stk.nextToken());\n            long pipecost = Integer.parseInt(stk.nextToken());\n            long pillarcost = Integer.parseInt(stk.nextToken());\n            String[] strarr = bf.readLine().split("""");\n            long[] s = new long[N];\n            for(int i = 0; i < N; i++) s[i] = Long.parseLong(strarr[i]);\n            long[][] dp = new long[N+1][2];\n            for(int i = 0; i <= N; i++)Arrays.fill(dp[i], Long.MAX_VALUE-Integer.MAX_VALUE);\n            dp[0][0] = pillarcost;\n            for(int i = 1; i <= N; i++){\n                if(s[i-1]==0 && (i == N || s[i] == 0))dp[i][0] = Math.min(dp[i-1][0] + pillarcost + pipecost, dp[i-1][1] + 2*pipecost + pillarcost);\n                dp[i][1] = Math.min(dp[i-1][0] + 2*pipecost + 2*pillarcost, dp[i-1][1] + 2*pillarcost + pipecost);\n            }\n            pw.println(dp[N][0]);\n        }\n        pw.close();\n    }\n}\n","dp,greedy"
"import java.io.*;\n\npublic class Main {\n    public static void main (String[] args) throws IOException {\n//		BufferedReader br = new BufferedReader(new FileReader("".in""));\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n//		PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter("".out"")));\n        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));\n        int tests = Integer.parseInt(br.readLine());\n        for(int test = 0;test < tests;test++) {\n            String[] in = br.readLine().split("" "");\n            int n = Integer.parseInt(in[0]);\n            long a = Long.parseLong(in[1]), b = Long.parseLong(in[2]);\n            char[] pipe = br.readLine().toCharArray();\n            long[][] dp = new long[n + 1][2];\n            for(int i = 0;i <= n;i++) dp[i] = new long[] {Long.MAX_VALUE - Integer.MAX_VALUE, Long.MAX_VALUE - Integer.MAX_VALUE};\n            dp[0][0] = b;\n            for(int i = 0;i < n;i++){\n                if(pipe[i] == '0'){\n                    dp[i + 1][0] = Math.min(dp[i][1] + 2L * a + b, dp[i][0] + a + b);\n                    dp[i + 1][1] = Math.min(dp[i][1] + a + 2L * b, dp[i][0] + 2L * a + 2L * b);\n                }\n                else{\n                    dp[i + 1][1] = dp[i][1] + a + 2L * b;\n                }\n            }\n            System.out.println(dp[n][0]);\n        }\n    }\n}\n","dp,greedy"
"import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.List;\n import java.util.*;\n public class realfast implements Runnable \n  {\n    private static final int INF = (int) 1e9;\n    long in= 1000000007;\n    long fac[]= new long[1000001];\n    long inv[]=new long[1000001];\n    public  void solve() throws IOException \n    {\n        Scanner in =new Scanner(System.in);\n\n        int n =readInt();\n        ArrayList<Integer> arr[]=new ArrayList[n+1];\n\n        for(int i=1;i<=n;i++)\n            arr[i]=new ArrayList<Integer>();\n\n\n        for(int i=0;i<n-1;i++)\n        {\n             int u = readInt();\n             int v = readInt();\n             arr[u].add(v);\n             arr[v].add(u);\n        }\n\n        int size[]=new int [n+1];\n        int height[]=new int[n+1];\n        dfs(arr,1,-1,height,size);\n        int  g = find_centroid(arr,1,height,size);\n\n        double pal =0;\n      \n        int ans=-1;\n        boolean check = false;\n        for(int i =0;i<arr[g].size();i++)\n        {\n             int v = arr[g].get(i);\n             if(height[v]<height[g])\n             {\n                pal= pal+n-size[g];\n             }\n             else\n                pal=pal+ size[v];\n            if((pal/n)>=0.34)\n            {\n                if((pal/n)>(0.67))\n                {\n                  if(height[v]<height[g])\n                  {\n                   pal= n-size[g];\n                  }\n                  else\n                  pal= size[v];\n                  check = true;\n                }\n                ans=i;\n                break;\n            }\n        }\n\n        int papu = (int)pal;\n    \n        \n            int c= papu*(n-papu);\n            int mulla = n*n;\n            mulla= 2*mulla;\n            mulla=mulla/9;\n            if(c<mulla)\n            {\n                out.println(pal/n);\n                out.println(""mulla"");\n            }\n        \n        int cur[]=new int[2];\n        if(!check){\n        for(int i=0;i<arr[g].size();i++)\n        {\n            int v = arr[g].get(i);\n            if(i==ans+1)\n            {\n                cur[0]=0;\n            }\n            if(i<=ans)\n            {\n                pl(arr,v,g,0,cur,1);\n            }\n            else \n            {\n                pl(arr,v,g,0,cur,papu);\n            }\n        }\n        }\n        else\n        {\n            for(int i=0;i<arr[g].size();i++)\n           {\n            if(i==ans)\n                continue;\n            int v = arr[g].get(i);\n           \n             \n                pl(arr,v,g,0,cur,1);\n            \n           }\n               cur[0]=0;\n           pl(arr,arr[g].get(ans),g,0,cur,papu);\n\n        }\n\n\n\n\n\n\n\n       \n\n    }\n    public void pl(ArrayList<Integer> arr[] , int u ,int p,  int last ,  int cur[],int fac)\n    {\n\n      int pro=0;\n      cur[0]++;\n      pro=cur[0];\n       \n      out.println(p+"" ""+u+"" ""+((cur[0]-last)*(fac)));\n       \n\n      for(int j =0;j<arr[u].size();j++)\n      {\n         int v = arr[u].get(j);\n         if(v!=p)\n         {\n            pl(arr,v,u,pro,cur,fac);\n         }\n      }\n               \n    }\n\n    public int find_centroid(ArrayList<Integer> arr[] , int u , int height[], int size[])\n    {\n        int n = arr.length-1;\n        for(int i =0;i<arr[u].size();i++)\n        {\n          int v = arr[u].get(i);\n          if(height[v]>height[u])\n          {\n            if(size[v]>(n/2))\n            {\n              return find_centroid(arr,v,height,size);\n            }\n          }\n\n        }\n\n        return u;\n\n    }\n    public void dfs(ArrayList<Integer> arr[] , int u, int p,int height[] , int size[])\n    {\n        if(p!=-1)\n        height[u]=height[p]+1;\n        size[u]=1;\n        for(int j =0;j<arr[u].size();j++)\n        {\n           int v = arr[u].get(j);\n           if(v!=p)\n           {\n             dfs(arr,v,u,height,size);\n             size[u]= size[u]+size[v];\n           //  height[u]=Math.max(height[u],1+height[v]);\n           }\n        }\n    }\n   \n    public long query(long seg[] , int left, int right , int index, int l , int r)\n    {   \n         long inf = 100000000;\n         inf = inf*inf;\n        if(left>=l&&right<=r)\n        {\n            return seg[index];\n        }\n        if(l>right||left>r)\n            return inf;\n        int mid = left+(right-left)/2;\n        return Math.min(query(seg,left,mid,2*index+1,l,r),query(seg,mid+1,right,2*index+2,l,r));\n\n    }\n    \n    public int value (int seg[], int left , int right ,int index, int l, int r)\n    {\n            \n            if(left>right)\n            {\n              return -100000000;\n            }\n            if(right<l||left>r)\n                return -100000000;\n            if(left>=l&&right<=r)\n                return seg[index];\n            int mid = left+(right-left)/2;\n            int val = value(seg,left,mid,2*index+1,l,r);\n            int val2 = value(seg,mid+1,right,2*index+2,l,r);\n            return Math.max(val,val2);\n\n    }\n   \n    public int gcd(int a , int b )\n    {\n      if(a<b)\n      {\n        int t =a;\n        a=b;\n        b=t;\n      }\n      if(a%b==0)\n        return b ;\n      return gcd(b,a%b);\n    }\n    public long pow(long n , long p,long m)\n    {\n         if(p==0)\n            return 1;\n        long val = pow(n,p/2,m);;\n        val= (val*val)%m;\n        if(p%2==0)\n            return val;\n        else\n            return (val*n)%m;\n    }\n    \n    \n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    public static void main(String[] args) {\n        new Thread(null, new realfast(), """", 128 * (1L << 20)).start();\n    }\n \n    private static final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null;\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n    private PrintWriter out;\n \n    @Override\n    public void run() {\n        try {\n            if (ONLINE_JUDGE || !new File(""input.txt"").exists()) {\n                reader = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            } else {\n                reader = new BufferedReader(new FileReader(""input.txt""));\n                out = new PrintWriter(""output.txt"");\n            }\n            solve();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                reader.close();\n            } catch (IOException e) {\n                // nothing\n            }\n            out.close();\n        }\n    }\n \n    private String readString() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n \n    @SuppressWarnings(""unused"")\n    private int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n \n    @SuppressWarnings(""unused"")\n    private long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n \n    @SuppressWarnings(""unused"")\n    private double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n}\nclass edge implements Comparable<edge>{\n    int u ;\n    int v;\n    \n    edge(int  u, int v)\n    {\n       this.u=u;\n       this.v=v;\n    }\n    public int compareTo(edge e)\n    {\n        return this.v-e.v;\n    }\n}","constructive algorithms,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1206F extends PrintWriter {\n	CF1206F() { super(System.out); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1206F o = new CF1206F(); o.main(); o.flush();\n	}\n\n	int[] next, jj; int l_ = 1;\n	int link(int l, int j) { next[l_] = l; jj[l_] = j; return l_++; }\n	int[] ao; int n;\n	int[] cc;\n	void init() {\n		int m = n - 1;\n		next = new int[1 + m * 2];\n		jj = new int[1 + m * 2];\n		ao = new int[n];\n		cc = new int[n];\n	}\n	int n_, i_, j_;\n	int dfs(int p, int i) {\n		int k = 1;\n		for (int l = ao[i]; l != 0; l = next[l]) {\n			int j = jj[l];\n			if (j != p)\n				k += dfs(i, j);\n		}\n		int k_ = Math.min(k, n - k);\n		if (n_ < k_) {\n			n_ = k_;\n			if (k <= n - k) {\n				i_ = i;\n				j_ = p;\n			} else {\n				i_ = p;\n				j_ = i;\n			}\n		}\n		cc[i] = k;\n		return k;\n	}\n	int a, b;\n	void dfs_(int p, int i, int c, boolean print) {\n		if (print) {\n			a += b;\n			println((p + 1) + "" "" + (i + 1) + "" "" + (a - c));\n			c = a;\n		}\n		for (int l = ao[i]; l != 0; l = next[l]) {\n			int j = jj[l];\n			if (j != p)\n				dfs_(i, j, c, true);\n		}\n	}\n	void main() {\n		n = sc.nextInt();\n		if (n == 1)\n			return;\n		init();\n		for (int h = 0; h < n - 1; h++) {\n			int i = sc.nextInt() - 1;\n			int j = sc.nextInt() - 1;\n			ao[i] = link(ao[i], j);\n			ao[j] = link(ao[j], i);\n		}\n		dfs(-1, 0);\n		if (n_ * 3 >= n) {\n			b = 1;\n			a = 0;\n			dfs_(i_, j_, 0, false);\n			b = n - n_;\n			a = 0;\n			dfs_(j_, i_, 0, true);\n		} else {\n			int s = j_;\n			dfs(-1, s);\n			Integer[] tt = new Integer[n];\n			int cnt = 0;\n			for (int l = ao[s]; l != 0; l = next[l])\n				tt[cnt++] = jj[l];\n			Arrays.sort(tt, 0, cnt, (i, j) -> cc[i] - cc[j]);\n			n_ = 1;\n			b = 1;\n			a = 0;\n			boolean changed = false;\n			for (int h = 0; h < cnt; h++) {\n				int j = tt[h];\n				n_ += cc[j];\n				dfs_(s, j, 0, true);\n				if (!changed && n_ * 3 >= n) {\n					changed = true;\n					b = n_;\n					a = 0;\n				}\n			}\n		}\n	}\n}\n","constructive algorithms,trees"
"import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n    static int inf = (int) (1e9 + 7);\n    static int n, root = -1;\n    static ArrayList<Integer> gr[];\n    static ArrayList<triple> res = new ArrayList<>();\n    static int sz[];\n\n    static void build_sz(int v, int pr) {\n        sz[v] = 1;\n        for(int to : gr[v]) {\n            if (to == pr) continue;\n            build_sz(to, v);\n            sz[v] += sz[to];\n        }\n    }\n\n    static void find_centre(int v, int pr) {\n        for(int to : gr[v]) {\n            if (to != pr && sz[to] > n / 2) find_centre(to, v);\n        }\n        if (root == -1) root = v;\n    }\n\n    static void f(int v, int pr, int mul) {\n        int cnt = 0;\n        for(int to : gr[v]) {\n            if (to == pr) continue;\n            res.add(new triple(v, to, (1 + cnt) * mul));\n            f(to, v, mul);\n            cnt += sz[to];\n        }\n    }\n\n    static void solve() throws IOException {\n        n = sc.nextInt();\n        gr = new ArrayList[n];\n        for(int i = 0;i < n;i++) gr[i] = new ArrayList<>();\n        sz = new int [n];\n\n        for(int i = 0;i < n - 1;i++) {\n            int v1 = sc.nextInt() - 1;\n            int v2 = sc.nextInt() - 1;\n            gr[v1].add(v2);\n            gr[v2].add(v1);\n        }\n\n        build_sz(0, -1);\n        find_centre(0, -1);\n        build_sz(root, -1);\n\n\n        ArrayList<Integer> to = new ArrayList<>();\n        for(int i : gr[root]) to.add(i);\n        Collections.sort(to, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return Integer.compare(sz[o1], sz[o2]);\n            }\n        });\n\n        int cnt1 = 0;\n        int cnt2 = 0;\n        for(int i : to) {\n            if (cnt1 >= (n + 2) / 3) {\n                res.add(new triple(root, i, (cnt2 + 1) * (cnt1 + 1)));\n                f(i, root, cnt1 + 1);\n                cnt2 += sz[i];\n            }else{\n                res.add(new triple(root, i, cnt1 + 1));\n                f(i, root, 1);\n                cnt1 += sz[i];\n            }\n        }\n\n        for(triple i : res) {\n            pw.println((i.a + 1) + "" "" + (i.b + 1) + "" "" + i.x);\n        }\n    }\n\n\n\n\n    public static void main(String[] args) throws IOException {\n        sc = new Scanner(System.in);\n        pw = new PrintWriter(System.out);\n        solve();\n        pw.close();\n    }\n\n    static Scanner sc;\n    static PrintWriter pw;\n\n    static class Scanner {\n        BufferedReader br;\n        StringTokenizer st = new StringTokenizer("""");\n\n        Scanner(InputStream in) throws FileNotFoundException {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        Scanner(String in) throws FileNotFoundException {\n            br = new BufferedReader(new FileReader(in));\n        }\n\n        String next() throws IOException {\n            while (!st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n    }\n\n}\n\nclass triple {\n    int a, b, x;\n    triple(int a, int b, int x) {\n        this.a = a;\n        this.b = b;\n        this.x = x;\n    }\n\n    triple() {}\n}","constructive algorithms,trees"
"import java.io.*; import java.util.*;\npublic class CF1205D{\n  static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        \n    } \n    static int MOD=998244353;\n    static int N,sum;\n    static int[] siz,val; static StringBuilder sb=new StringBuilder();\n    static int A,B;\n    public static void main(String[] args){\n        FastReader br=new FastReader();\n        N=br.nextInt(); \n        ArrayList<Integer> []arl=new ArrayList[N];\n        for (int i = 0; i < N; i++) {arl[i]=new ArrayList<>();  }\n        int a,b;\n        for (int i = 0; i < N-1; i++) {\n            a=br.nextInt()-1; b=br.nextInt()-1; arl[a].add(b); arl[b].add(a);\n        }\n        siz=new int[N]; Arrays.fill(siz,1);\n        dfs(arl,0,-1);\n        \n        int c=find_centroid(arl,0);\n        sum=0;\n        boolean[] use=new boolean[N]; \n        for (int i : arl[c]) {\n            sum+=siz[i];use[i]=true; \n            if(sum*3>=2*N){\n                sum=siz[i]; Arrays.fill(use, false); use[i]=true; break;\n            }else if(sum*3>=N-1){\n                break;\n            }\n            \n        }\n        //System.out.println(c);\n        //System.out.println(Arrays.toString(siz));\n        val=new int[N]; A=1; B=sum+1;\n        for (int i : arl[c]) {\n            if(use[i]){//1,..\n                val[i]=A;\n                sb.append((c+1)+"" ""+(i+1)+"" ""+A+""\n""); A++;\n                dfs2(arl,c,i,true);\n            }else{\n                val[i]=B;\n                sb.append((c+1)+"" ""+(i+1)+"" ""+B+""\n""); B+=(sum+1);\n                dfs2(arl,c,i,false);\n            }\n        }\n        //System.out.println(sum);\n        //System.out.println(Arrays.toString(use));\n        //System.out.println(Arrays.toString(val));\n        System.out.println(sb.toString());\n    }\n    \n     public static void dfs(ArrayList<Integer>[] arl, int i, int p){//We can use DP here too\n         \n            for (int q : arl[i]) {\n                if(q==p)continue;\n                dfs(arl,q,i);\n                siz[i]+=siz[q];\n            }\n      }\n     public static int find_centroid(ArrayList<Integer>[] arl, int i){\n         for (int q: arl[i]) {\n             if(2*siz[q]>N){\n                 siz[i]-=siz[q]; siz[q]+=siz[i];\n                 return find_centroid(arl,q);\n             }\n         }\n         return i;\n     }\n     public static void dfs2(ArrayList<Integer>[] arl, int p, int v, boolean b){\n         \n         for (int i : arl[v]) {\n             if(i==p)continue;\n             if(b){\n                 sb.append((i+1)+"" ""+(v+1)+"" ""+(A-val[v])+""\n"");\n                 \n                 val[i]=A; A++; \n             }else{\n                 sb.append((i+1)+"" ""+(v+1)+"" ""+(B-val[v])+""\n"");\n                 \n                 val[i]=B; B+=(sum+1);\n             }\n             dfs2(arl,v,i,b);\n         }\n     }\n    /*\n    public static int find(int x, int[] p){\n        if(p[x]==x)return x;\n        int ans=find(p[x],x); p[x]=ans; return ans;\n    }\n    public static long pow(int x, int p){\n      if(p==0)return 1; if(p==1)return x;\n      long ans=pow(x,p/2);\n      return ((ans*ans)%M*pow(x,p%2))%M;\n    }\n    */\n}\n//Debugging:\n//Are you sure your algorithm is correct?\n//Bounds: long\n//Special cases: n=0,1?\n//Make sure you remove your debugging code before you submit!","constructive algorithms,trees"
"import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class S {\n    static class point {\n        int need;\n        int change;\n\n        public point(int need, int change) {\n            this.need = need;\n            this.change = change;\n        }\n    }\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int r = in.nextInt();\n        point[] a = new point[n];\n        point[] b = new point[n];\n        int indexA = 0, indexB = 0;\n        for (int i = 0; i < n; i++) {\n            int x = in.nextInt();\n            int y = in.nextInt();\n            if (y >= 0) {\n                a[indexA++] = new point(x, y);\n            } else {\n                b[indexB++] = new point(x, y);\n            }\n        }\n        Arrays.sort(a, 0,indexA,new Comparator<point>() {\n            @Override\n            public int compare(point o1, point o2) {\n                return o1.need >= o2.need ? 1 : -1;\n            }\n        });\n        Arrays.sort(b, 0,indexB,new Comparator<point>() {\n            @Override\n            public int compare(point o1, point o2) {\n                return o1.need+o1.change <= o2.need+o2.change ? 1 : -1;\n            }\n        });\n        for (int i = 0; i < indexA; i++) {\n            if (a[i].need > r) {\n                System.out.println(""NO"");\n                return;\n            }\n            r += a[i].change;\n        }\n        for (int i = 0; i < indexB; i++) {\n            if (b[i].need > r) {\n                System.out.println(""NO"");\n                return;\n            }\n            r += b[i].change;\n        }\n        if (r >= 0) {\n            System.out.println(""YES"");\n        } else {\n            System.out.println(""NO"");\n        }\n\n    }\n}\n\n	 	  						    		    				  		 	",greedy
"import java.io.*;\nimport java.util.*;\n\npublic class G{\n	static List<Pair> neg; \n	static int[][] dp;\n	static int len;\n	static int solve(int o, int t) {\n		if (t == 0) return 0;\n		if (t < 0) return -1;\n		if (o >= len) return 0;\n		if (dp[o][t] == -1) {\n			// Either take, or do not take.\n			dp[o][t] = solve(o+1, t);\n			if (t >= neg.get(o).a && t + neg.get(o).b >= 0) {\n				dp[o][t] = Integer.max(dp[o][t], solve(o+1,t+neg.get(o).b)+1);\n			}\n		}\n		return dp[o][t];\n	}\n	public static void main(String[] args) throws IOException {\n		// br = new BufferedReader(new FileReader("".in""));\n		// out = new PrintWriter(new FileWriter("".out""));\n		//new Thread(null, new (), ""peepee"", 1<<28).start();\n		int n = readInt();\n		int r = readInt();\n		List<Pair> pos = new ArrayList<Pair>();\n		neg = new ArrayList<Pair>();\n		for (int i = 0; i < n; i++) {\n			Pair p = new Pair(readInt(),readInt());\n			if (p.b >= 0) pos.add(p);\n			else {\n				p.a = Integer.max(p.a, -p.b);\n				neg.add(p);\n			}\n		}\n		// Optimally, take all positive in ascending order\n		while (!pos.isEmpty()) {\n			int c = -1;\n			for (int i = 0; i < pos.size(); i++) if (pos.get(i).a <= r) c = i;\n			if (c == -1) break;\n			r += pos.remove(c).b;\n		}\n		// DP on neg\n		Collections.sort(neg, (i,j)-> -((i.a + i.b) - (j.a + j.b))); \n		//for (Pair p: neg) System.out.println(p.a + "" "" + p.b);\n		len = neg.size();\n		dp = new int[len][(int)r+1];\n		for (int[] d: dp) Arrays.fill(d, -1);\n		int max = solve(0,r);\n		out.println(pos.isEmpty() && len == max  ?""YES"":""NO"");\n		out.close();\n	}\n	\n	static class Pair{\n		int a,b;\n		public Pair(int c, int d) {\n			a=c;\n			b=d;\n		}\n	}\n	\n	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n	static StringTokenizer st = new StringTokenizer("""");\n	static String read() throws IOException{return st.hasMoreTokens() ? st.nextToken():(st = new StringTokenizer(br.readLine())).nextToken();}\n	static int readInt() throws IOException{return Integer.parseInt(read());}\n	static long readLong() throws IOException{return Long.parseLong(read());}\n	static double readDouble() throws IOException{return Double.parseDouble(read());}\n	\n}",greedy
"import java.io.*;\nimport java.util.*;\n\npublic class Main{\n	static ArrayList<int[]>neg;\n	static int[][]memo;\n	static int dp(int i,int rating) {\n		if(rating<0)return -10000000;\n		if(i>=neg.size())return 0;\n		if(memo[i][rating]!=-1)return memo[i][rating];\n		\n		int leave=dp(i+1,rating);\n		int take=rating>=neg.get(i)[0]?(1+dp(i+1,rating+neg.get(i)[1])):-10000000;\n		\n		return memo[i][rating]=Math.max(leave, take);\n	}\n	static void main() throws Exception{\n		int n=sc.nextInt(),r=sc.nextInt();\n		ArrayList<int[]>pos=new ArrayList<>();\n		neg=new ArrayList<>();\n		\n		for(int i=0;i<n;i++) {\n			int rating=sc.nextInt(),delta=sc.nextInt();\n			if(delta>=0) {\n				pos.add(new int[] {rating,delta});\n			}\n			else {\n				neg.add(new int[] {Math.max(rating, -delta),delta});\n			}\n		}\n		boolean[]taken=new boolean[pos.size()];\n		int ans=0;\n		while(true) {\n			int maxB=-500,idx=-1;\n			for(int i=0;i<pos.size();i++) {\n				if(taken[i] || pos.get(i)[0]>r)continue;\n				if(pos.get(i)[1]>maxB) {\n					maxB=pos.get(i)[1];\n					idx=i;\n				}\n			}\n			if(idx==-1)break;\n			if(r+maxB<0)break;\n			\n			ans++;\n			r+=pos.get(idx)[1];\n			taken[idx]=true;\n		}\n		memo=new int[neg.size()][r+1];\n		for(int i=0;i<memo.length;i++) {\n			Arrays.fill(memo[i], -1);\n		}\n		\n		\n		Collections.sort(neg,(x,y)->(y[0]+y[1])-(x[0]+x[1]));\n		int ansNeg=Math.max(0, dp(0, r));\n		\n		pw.println((ans+ansNeg)==n?""YES"":""NO"");\n	}\n	public static void main(String[] args) throws Exception{\n		pw=new PrintWriter(System.out);\n		sc = new MScanner(System.in);\n		int tc=1;\n		while(tc-->0) main();\n		pw.flush();\n	}\n	static PrintWriter pw;\n	static MScanner  sc;\n	static class MScanner {\n		StringTokenizer st;\n		BufferedReader br;\n		public MScanner(InputStream system) {\n			br = new BufferedReader(new InputStreamReader(system));\n		}\n \n		public MScanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n \n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n		public int[] intArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public long[] longArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public int[] intSortedArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		public long[] longSortedArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		public Integer[] IntegerArr(int n) throws IOException {\n	        Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public Long[] LongArr(int n) throws IOException {\n	        Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n \n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n \n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n \n		public char nextChar() throws IOException {\n			return next().charAt(0);\n		}\n \n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n \n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n \n		public void waitForInput() throws InterruptedException {\n			Thread.sleep(3000);\n		}\n	}\n	static void shuffle(int[]in) {\n		for(int i=0;i<in.length;i++) {\n			int idx=(int)(Math.random()*in.length);\n			int tmp=in[i];\n			in[i]=in[idx];\n			in[idx]=tmp;\n		}\n	}\n	static void shuffle(long[]in) {\n		for(int i=0;i<in.length;i++) {\n			int idx=(int)(Math.random()*in.length);\n			long tmp=in[i];\n			in[i]=in[idx];\n			in[idx]=tmp;\n		}\n	}\n}",greedy
"import java.io.BufferedOutputStream;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.Objects;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	static class TaskAdapter implements Runnable {\n		@Override\n		public void run() {\n			long startTime = System.currentTimeMillis();\n			InputStream inputStream = System.in;\n			OutputStream outputStream = System.out;\n			FastReader in = new FastReader(inputStream);\n			Output out = new Output(outputStream);\n			F1CompleteTheProjectsEasyVersion solver = new F1CompleteTheProjectsEasyVersion();\n			solver.solve(1, in, out);\n			out.close();\n			System.err.println(System.currentTimeMillis()-startTime+""ms"");\n		}\n	}\n\n	public static void main(String[] args) throws Exception {\n		Thread thread = new Thread(null, new TaskAdapter(), """", 1<<26);\n		thread.start();\n		thread.join();\n	}\n\n	static class F1CompleteTheProjectsEasyVersion {\n		public F1CompleteTheProjectsEasyVersion() {\n		}\n\n		public void solve(int kase, InputReader in, Output pw) {\n			int n = in.nextInt(), cur = in.nextInt();\n			ArrayList<Pair<Integer, Integer>> pos = new ArrayList<>(), neg = new ArrayList<>();\n			for(int i = 0; i<n; i++) {\n				int a = in.nextInt(), b = in.nextInt();\n				if(b>=0) {\n					pos.add(new Pair<>(a, b));\n				}else {\n					b = -b;\n					neg.add(new Pair<>(Math.max(a, b), b));\n				}\n			}\n			pos.sort(Comparator.comparingInt(o -> o.a));\n			for(var v: pos) {\n				if(v.a>cur) {\n					pw.println(""NO"");\n					return;\n				}\n				cur += v.b;\n			}\n			neg.sort(Comparator.comparingInt(o -> -o.a+o.b));\n//			Utilities.Debug.dbg(neg);\n			for(var v: neg) {\n				if(v.a>cur) {\n					pw.println(""NO"");\n					return;\n				}\n				cur -= v.b;\n			}\n			if(cur>=0) {\n				pw.println(""YES"");\n			}else {\n				pw.println(""NO"");\n			}\n		}\n\n	}\n\n	static class FastReader implements InputReader {\n		final private int BUFFER_SIZE = 1<<16;\n		private DataInputStream din;\n		private byte[] buffer;\n		private int bufferPointer;\n		private int bytesRead;\n\n		public FastReader(InputStream is) {\n			din = new DataInputStream(is);\n			buffer = new byte[BUFFER_SIZE];\n			bufferPointer = bytesRead = 0;\n		}\n\n		public int nextInt() {\n			int ret = 0;\n			byte c = skipToDigit();\n			boolean neg = (c=='-');\n			if(neg) {\n				c = read();\n			}\n			do {\n				ret = ret*10+c-'0';\n			} while((c = read())>='0'&&c<='9');\n			if(neg) {\n				return -ret;\n			}\n			return ret;\n		}\n\n		private boolean isDigit(byte b) {\n			return b>='0'&&b<='9';\n		}\n\n		private byte skipToDigit() {\n			byte ret;\n			while(!isDigit(ret = read())&&ret!='-') ;\n			return ret;\n		}\n\n		private void fillBuffer() {\n			try {\n				bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n			}catch(IOException e) {\n				e.printStackTrace();\n				throw new InputMismatchException();\n			}\n			if(bytesRead==-1) {\n				buffer[0] = -1;\n			}\n		}\n\n		private byte read() {\n			if(bytesRead==-1) {\n				throw new InputMismatchException();\n			}else if(bufferPointer==bytesRead) {\n				fillBuffer();\n			}\n			return buffer[bufferPointer++];\n		}\n\n	}\n\n	static interface InputReader {\n		int nextInt();\n\n	}\n\n	static class Output implements Closeable, Flushable {\n		public StringBuilder sb;\n		public OutputStream os;\n		public int BUFFER_SIZE;\n		public String lineSeparator;\n\n		public Output(OutputStream os) {\n			this(os, 1<<16);\n		}\n\n		public Output(OutputStream os, int bs) {\n			BUFFER_SIZE = bs;\n			sb = new StringBuilder(BUFFER_SIZE);\n			this.os = new BufferedOutputStream(os, 1<<17);\n			lineSeparator = System.lineSeparator();\n		}\n\n		public void println(String s) {\n			sb.append(s);\n			println();\n		}\n\n		public void println() {\n			sb.append(lineSeparator);\n		}\n\n		private void flushToBuffer() {\n			try {\n				os.write(sb.toString().getBytes());\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n			sb = new StringBuilder(BUFFER_SIZE);\n		}\n\n		public void flush() {\n			try {\n				flushToBuffer();\n				os.flush();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n		public void close() {\n			flush();\n			try {\n				os.close();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n	}\n\n	static class Utilities {\n		public static class Debug {\n			public static boolean LOCAL = System.getProperty(""ONLINE_JUDGE"")==null;\n\n			private static <T> String ts(T t) {\n				if(t==null) {\n					return ""null"";\n				}\n				try {\n					return ts((Iterable) t);\n				}catch(ClassCastException e) {\n					if(t instanceof int[]) {\n						String s = Arrays.toString((int[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof long[]) {\n						String s = Arrays.toString((long[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof char[]) {\n						String s = Arrays.toString((char[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof double[]) {\n						String s = Arrays.toString((double[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof boolean[]) {\n						String s = Arrays.toString((boolean[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}\n					try {\n						return ts((Object[]) t);\n					}catch(ClassCastException e1) {\n						return t.toString();\n					}\n				}\n			}\n\n			private static <T> String ts(T[] arr) {\n				StringBuilder ret = new StringBuilder();\n				ret.append(""{"");\n				boolean first = true;\n				for(T t: arr) {\n					if(!first) {\n						ret.append("", "");\n					}\n					first = false;\n					ret.append(ts(t));\n				}\n				ret.append(""}"");\n				return ret.toString();\n			}\n\n			private static <T> String ts(Iterable<T> iter) {\n				StringBuilder ret = new StringBuilder();\n				ret.append(""{"");\n				boolean first = true;\n				for(T t: iter) {\n					if(!first) {\n						ret.append("", "");\n					}\n					first = false;\n					ret.append(ts(t));\n				}\n				ret.append(""}"");\n				return ret.toString();\n			}\n\n			public static void dbg(Object... o) {\n				if(LOCAL) {\n					System.err.print(""Line #""+Thread.currentThread().getStackTrace()[2].getLineNumber()+"": ["");\n					for(int i = 0; i<o.length; i++) {\n						if(i!=0) {\n							System.err.print("", "");\n						}\n						System.err.print(ts(o[i]));\n					}\n					System.err.println(""]"");\n				}\n			}\n\n		}\n\n	}\n\n	static class Pair<T1, T2> implements Comparable<Pair<T1, T2>> {\n		public T1 a;\n		public T2 b;\n\n		public Pair(Pair<T1, T2> p) {\n			this(p.a, p.b);\n		}\n\n		public Pair(T1 a, T2 b) {\n			this.a = a;\n			this.b = b;\n		}\n\n		public String toString() {\n			return a+"" ""+b;\n		}\n\n		public int hashCode() {\n			return Objects.hash(a, b);\n		}\n\n		public boolean equals(Object o) {\n			if(o instanceof Pair) {\n				Pair p = (Pair) o;\n				return a.equals(p.a)&&b.equals(p.b);\n			}\n			return false;\n		}\n\n		public int compareTo(Pair<T1, T2> p) {\n			int cmp = ((Comparable<T1>) a).compareTo(p.a);\n			if(cmp==0) {\n				return ((Comparable<T2>) b).compareTo(p.b);\n			}\n			return cmp;\n		}\n\n	}\n}\n\n",greedy
"import java.util.Scanner;\n\npublic class r576b {\n	public static void main(String[] args) {\n		Scanner scan=new Scanner(System.in);\n		double h=scan.nextInt(), l=scan.nextInt();\n		System.out.println((l*l-h*h)/2/h);\n	}\n}","geometry,math"
"import java.util.Scanner;\n\npublic class r576b {\n	public static void main(String[] args) {\n		Scanner scan=new Scanner(System.in);\n		double h=scan.nextInt(), l=scan.nextInt();\n		System.out.println((l*l-h*h)/2/h);\n	}\n}","geometry,math"
"import java.util.Scanner;\npublic class lily{\npublic static void main(String[] args)\n{\n\nScanner in =new Scanner(System.in);\nDouble h=in.nextDouble(), l=in.nextDouble();\nSystem.out.print((l*l+h*h)/(2*h)-h);\n\n\n}\n\n}","geometry,math"
import java.util.*;\n\npublic class Z1199B {\n	\n	public static void main(String[] args) {\n		\n		Scanner input = new Scanner(System.in);\n		\n		double H = input.nextDouble();\n		double L = input.nextDouble();\n		\n		System.out.println((L*L-H*H)/(2*H));\n		\n	}\n}\n,"geometry,math"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1178A extends PrintWriter {\n	CF1178A() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1178A o = new CF1178A(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int[] aa = new int[n];\n		for (int i = 0; i < n; i++)\n			aa[i] = sc.nextInt();\n		int a = aa[0], cnt = 1, sum = a, sum_ = a;\n		for (int i = 1; i < n; i++) {\n			if (a >= aa[i] * 2) {\n				cnt++;\n				sum += aa[i];\n			}\n			sum_ += aa[i];\n		}\n		if (sum * 2 <= sum_) {\n			println(0);\n			return;\n		}\n		println(cnt);\n		print(1);\n		for (int i = 1; i < n; i++)\n			if (a >= aa[i] * 2)\n				print("" "" + (i + 1));\n		println();\n	}\n}\n",greedy
"import java.util.*;\nimport static java.lang.Math.*;\npublic class Demo{\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int n = in.nextInt();\n		int[] a = new int[n];\n		int sum =0;\n		for (int i = 0; i < n; i++){\n			a[i] = in.nextInt();\n			sum+= a[i];\n		}\n		int maj = sum/2+1;\n		maj-=a[0];\n		ArrayList<Integer> list = new ArrayList();\n		list.add(1);\n		for (int i = 1; i < n; i++){\n			if (maj>0){\n				if (a[i]<=a[0]/2){\n					maj-=a[i];\n					list.add(i+1);\n				}\n				\n			}else{\n				break;\n			}\n			\n		}\n		\n		if(maj>0){\n			System.out.println(0);\n		}else{\n			System.out.println(list.size());\n			for (int j : list){\n				System.out.print(j+"" "");\n			}\n			System.out.println();\n				\n		}\n		\n	}\n}		 \n",greedy
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1178A extends PrintWriter {\n	CF1178A() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1178A o = new CF1178A(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int[] aa = new int[n];\n		for (int i = 0; i < n; i++)\n			aa[i] = sc.nextInt();\n		int a = aa[0], cnt = 1, sum = a, sum_ = a;\n		for (int i = 1; i < n; i++) {\n			if (a >= aa[i] * 2) {\n				cnt++;\n				sum += aa[i];\n			}\n			sum_ += aa[i];\n		}\n		if (sum * 2 <= sum_) {\n			println(0);\n			return;\n		}\n		println(cnt);\n		print(1);\n		for (int i = 1; i < n; i++)\n			if (a >= aa[i] * 2)\n				print("" "" + (i + 1));\n		println();\n	}\n}\n",greedy
"import java.util.*;\n\npublic class A1178 {\n		\n	public static void main(String[] args) \n	{\n		Scanner sc=new Scanner(System.in);\n		int len=sc.nextInt();\n		int sum=0, total=0;\n		ArrayList<Integer> list=new ArrayList<>();\n		int[] arr= new int[len];\n		for(int i=0; i<len; i++)\n		{\n			arr[i]=sc.nextInt();\n			total+=arr[i];\n		}\n		\n		int a=arr[0];\n		\n		if(a>total/2)\n		{\n			System.out.println(1);\n			System.out.println(1);\n		}\n		else\n		{\n		sum=a;\n		//list.add(1);\n		for(int i=1; i<len; i++)\n		{\n			if(a>=2*arr[i])\n			{\n				sum+=arr[i];\n				list.add(i+1);\n			}\n			if(sum>total/2)\n			{\n				break;\n			}\n		}\n		if(list.size()>0 && sum>total/2)\n		{\n			list.add(0,1);\n		System.out.println(list.size());\n		for(int i=0; i<list.size(); i++)\n		{\n			System.out.print(list.get(i)+"" "");\n		}\n		}\n		else\n		{\n			System.out.println(0);\n		}\n		}\n		\n	}\n}",greedy
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n	PrintWriter out = new PrintWriter(System.out);\n	BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer tok = new StringTokenizer("""");\n    String next() throws IOException {\n        if (!tok.hasMoreTokens()) { tok = new StringTokenizer(in.readLine()); }\n        return tok.nextToken();\n    }\n    int ni() throws IOException { return Integer.parseInt(next()); }\n    long nl() throws IOException { return Long.parseLong(next()); }\n    \n    long mod=1000000007;\n    long[][]A,D;\n    int n;\n    \n    void solve() throws IOException {\n        n=ni();\n        A=new long[n][7];\n        D=new long[n][10];\n        for (int i=0;i<n;i++) {\n            Arrays.fill(D[i],-1);\n            int k=ni();\n            ArrayList<Integer>B=new ArrayList();\n            int m2=0;\n            int m3=0;\n            for (int j=0;j<k;j++) {\n                int u=ni(),v=ni();\n                if (u==1) B.add(v);\n                if (u==2) m2=Math.max(m2,v);\n                if (u==3) m3=Math.max(m3,v);\n            }\n            Collections.sort(B,Collections.reverseOrder());\n            A[i][1]=Math.max(m3,Math.max(m2,B.size()==0?0:B.get(0)));\n            A[i][4]=A[i][1];\n            if (B.size()==0 || B.size()==1 && m2==0) A[i][2]=-1;\n            else {\n                A[i][2]=(long)B.get(0)+Math.max(m2,B.size()==1?0:B.get(1));\n                A[i][5]=Math.max(B.get(0),m2);\n            }\n            if (B.size()<3) A[i][3]=-1;\n            else {\n                A[i][3]=(long)B.get(0)+B.get(1)+B.get(2);\n                A[i][6]=B.get(0);\n            }\n        }\n        \n        out.println(solve(0,0));\n        out.flush();\n    }\n    \n    long solve(int u,int m) {\n        if (u==n) return 0;\n        if (D[u][m]>-1) return D[u][m];\n        \n        long ret=solve(u+1,m);\n        ret=Math.max(ret,solve(u+1,(m+1)%10)+A[u][1]+(m==9?A[u][4]:0));\n        if (A[u][2]>-1) ret=Math.max(ret,solve(u+1,(m+2)%10)+A[u][2]+(m>=8?A[u][5]:0));\n        if (A[u][3]>-1) ret=Math.max(ret,solve(u+1,(m+3)%10)+A[u][3]+(m>=7?A[u][6]:0));\n        \n        return D[u][m]=ret;\n    }\n    \n    int gcd(int a,int b) { return(b==0?a:gcd(b,a%b)); }\n    long gcd(long a,long b) { return(b==0?a:gcd(b,a%b)); }\n    long mp(long a,long p) { long r=1; while(p>0) { if ((p&1)==1) r=(r*a)%mod; p>>=1; a=(a*a)%mod; } return r; }\n    \n    public static void main(String[] args) throws IOException {\n        new Main().solve();\n    }\n}","dp,implementation,sortings"
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n  static long[][] points;\n\n  static void update(int b, long[] a) {\n    long max = 0, sum = 0;\n    for (long i : a) {\n      max = Math.max(max, i);\n      sum += i;\n    }\n\n    for (int i = 0; i < 10; ++i) {\n      boolean bonus = false;\n      int j = i + a.length;\n      if (j >= 10) {\n        bonus = true;\n        j -= 10;\n      }\n      points[b + 1][j] = Math.max(points[b + 1][j], points[b][i] + sum + (bonus ? max : 0));\n    }\n  }\n\n  public static void main(String args[]) {\n    InputReader in = new InputReader(System.in);\n    PrintWriter out = new PrintWriter(System.out);\n\n    int n = in.nextInt();\n\n    points = new long[n + 1][10];\n    for (int i = 0; i <= n; ++i) {\n      for (int j = 0; j < 10; ++j) {\n        points[i][j] = Long.MIN_VALUE;\n      }\n    }\n    points[0][0] = 0;\n\n    for (int i = 0; i < n; ++i) {\n      List<Long>[] cards = new List[3 + 1];\n      for (int j = 0; j <= 3; ++j) {\n        cards[j] = new ArrayList<>();\n      }\n\n      int k = in.nextInt();\n      for (int j = 0; j < k; ++j) {\n        cards[in.nextInt()].add(in.nextLong());\n      }\n\n      for (int j = 0; j <= 3; ++j) {\n        cards[j].sort(Collections.reverseOrder());\n      }\n\n      update(i, new long[0]);\n\n      if (cards[1].size() >= 1) {\n        update(i, new long[]{cards[1].get(0)});\n      }\n\n      if (cards[1].size() >= 2) {\n        update(i, new long[]{cards[1].get(0), cards[1].get(1)});\n      }\n\n      if (cards[1].size() >= 3) {\n        update(i, new long[]{cards[1].get(0), cards[1].get(1), cards[1].get(2)});\n      }\n\n      if (cards[1].size() >= 1 && cards[2].size() >= 1) {\n        update(i, new long[]{cards[1].get(0), cards[2].get(0)});\n      }\n\n      if (cards[2].size() >= 1) {\n        update(i, new long[]{cards[2].get(0)});\n      }\n\n      if (cards[3].size() >= 1) {\n        update(i, new long[]{cards[3].get(0)});\n      }\n    }\n\n    long ans = Long.MIN_VALUE;\n    for (int i = 0; i < 10; ++i) {\n      ans = Math.max(ans, points[n][i]);\n    }\n\n    out.println(ans);\n\n    out.close();\n  }\n\n}\n\nclass InputReader {\n\n  public BufferedReader reader;\n  public StringTokenizer tokenizer;\n\n  public InputReader(InputStream str) {\n    reader = new BufferedReader(new InputStreamReader(str), 1 << 15);\n  }\n\n  public String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new StringTokenizer(reader.readLine());\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n    return tokenizer.nextToken();\n  }\n\n  public int nextInt() {\n    return Integer.parseInt(next());\n  }\n\n  public long nextLong() {\n    return Long.parseLong(next());\n  }\n\n}\n","dp,implementation,sortings"
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n	static Scanner sc = new Scanner(System.in);\n	static PrintWriter out = new PrintWriter(System.out);\n	static ArrayList<Integer>[][] damage;\n	static Long[][] memo;\n	static int n;\n	\n	static long dp(int idx, int card) {\n        if (idx == n) return 0;\n        if (memo[idx][card] != null)\n            return memo[idx][card];\n        \n        long ans = dp(idx + 1, card);\n \n        //Single Card\n        for (int k = 1; k <= 3; k++) {\n            if (damage[idx][k].size() > 0) {\n                long curAns = dp(idx + 1, (card + 1) % 10) + damage[idx][k].get(0);\n                if (card == 9)\n                    curAns += damage[idx][k].get(0);\n                ans = Math.max(ans, curAns);\n            }\n        }\n        \n        //Two Ones\n        if (damage[idx][1].size() > 1) {\n            long curAns = dp(idx + 1, (card + 2) % 10) + damage[idx][1].get(0) + damage[idx][1].get(1);\n            if (card >= 8)\n                curAns += damage[idx][1].get(0);\n            ans = Math.max(ans, curAns);\n        }\n        \n        //One and Two\n        if (damage[idx][1].size() > 0 && damage[idx][2].size() > 0) {\n            long curAns = dp(idx + 1, (card + 2) % 10) + damage[idx][1].get(0) + damage[idx][2].get(0);\n            if (card >= 8)\n                curAns += Math.max(damage[idx][1].get(0), damage[idx][2].get(0));\n            ans = Math.max(ans, curAns);\n        }\n        \n        //Three Ones\n        if (damage[idx][1].size() > 2) {\n            long curAns = dp(idx + 1, (card + 3) % 10) + damage[idx][1].get(0) + damage[idx][1].get(1) + damage[idx][1].get(2);\n            if (card >= 7)\n                curAns += damage[idx][1].get(0);\n            ans = Math.max(ans, curAns);\n        }\n \n        return memo[idx][card] = ans;\n    }\n\n	public static void main(String[] args) throws Exception {\n		n = sc.nextInt();\n		damage = new ArrayList[n][5];\n		memo = new Long[n][10];\n\n		for (int i = 0; i < n; i++) {\n			for (int j = 1; j <= 3; j++) {\n				damage[i][j] = new ArrayList<>();\n			}\n		}\n		\n		for (int i = 0; i < n; i++) {\n			int k = sc.nextInt();\n			while (k-- > 0) {\n				int c = sc.nextInt();\n				int d = sc.nextInt();\n				damage[i][c].add(d);\n			}\n		}\n\n		for (int i = 0; i < n; i++) {\n			for (int j = 1; j <= 3; j++) {\n				Collections.sort(damage[i][j], (x, y) -> Integer.compare(y, x));\n			}\n		}\n\n		out.println(dp(0, 0));\n		out.close();\n	}\n}\n\nclass Scanner {\n	StringTokenizer st;\n	BufferedReader br;\n\n	public Scanner(InputStream system) {\n		br = new BufferedReader(new InputStreamReader(system));\n	}\n\n	public Scanner(String file) throws Exception {\n		br = new BufferedReader(new FileReader(file));\n	}\n\n	public String next() throws IOException {\n		while (st == null || !st.hasMoreTokens())\n			st = new StringTokenizer(br.readLine());\n		return st.nextToken();\n	}\n\n	public String nextLine() throws IOException {\n		return br.readLine();\n	}\n\n	public int nextInt() throws IOException {\n		return Integer.parseInt(next());\n	}\n\n	public double nextDouble() throws IOException {\n		return Double.parseDouble(next());\n	}\n\n	public Long nextLong() throws IOException {\n		return Long.parseLong(next());\n	}\n}","dp,implementation,sortings"
"// package Point2100;\n\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Destroyit {\n\n    //    MUST SEE BEFORE SUBMISSION\n    //    check whether int part would overflow or not, especially when it is a * b!!!!\n//    check if top down dp would cause overflow or not !!!!!!!!!!!!!!!!!!!!!!\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int t = 1;\n//        t = sc.nextInt();\n        for (int i = 0; i < t; i++) {\n            solve(sc, pw);\n        }\n        pw.close();\n    }\n\n    static void solve(Scanner in, PrintWriter out){\n        int n = in.nextInt();\n        long[][][] dp = new long[n][4][4];\n        for(int i = 0; i < n; i++){\n            int k = in.nextInt();\n            List<Integer>[] lss = new List[4];\n            for (int j = 0; j < 4; j++) {\n                lss[j] = new ArrayList<>();\n            }\n            for (int j = 0; j < k; j++) {\n                int l = in.nextInt(), r = in.nextInt();\n                lss[l].add(r);\n            }\n            for (int j = 1; j < 4; j++) {\n                Collections.sort(lss[j]);\n            }\n            for (int j = 1; j <= 3; j++) {\n                for (int l = 0; l <= 1; l++) { // l = 0 means no double, else it means at lth position, this value should be doubled\n                    if (j == 1){\n                        long v1 = Integer.MIN_VALUE, v2 = Integer.MIN_VALUE, v3 = Integer.MIN_VALUE;\n                        if (lss[1].size() > 0) v1 = lss[1].get(lss[1].size() - 1);\n                        if (lss[2].size() > 0) v2 = lss[2].get(lss[2].size() - 1);\n                        if (lss[3].size() > 0) v3 = lss[3].get(lss[3].size() - 1);\n                        long mx = Math.max(v1, Math.max(v2, v3));\n                        if (l == j){\n                            dp[i][j][l] = 2l * mx;\n                        }else{\n                            dp[i][j][l] = mx;\n                        }\n                    }else if (j == 2){\n                        long mx = 0;\n                        if (lss[1].size() > 0 && lss[2].size() > 0){\n                            long v1 = lss[1].get(lss[1].size() - 1), v2 = lss[2].get(lss[2].size() - 1);\n                            if (l == 0){\n                                mx = v1 + v2;\n                            }else{\n                                mx = Math.max(v1, v2) * 2 + Math.min(v1, v2);\n                            }\n                        }\n                        long st = 0;\n                        if (lss[1].size() > 1){\n                            long v11 = lss[1].get(lss[1].size() - 1), v12 = lss[1].get(lss[1].size() - 2);\n                            if (l == 0){\n                                st = v11 + v12;\n                            }else{\n                                st = Math.max(v11, v12) * 2l + Math.min(v11, v12);\n                            }\n                        }\n                        dp[i][j][l] = Math.max(mx, st);\n                    }else{\n                        if (lss[1].size() > 2){\n                            int v11 = lss[1].get(lss[1].size() - 1), v12 = lss[1].get(lss[1].size() - 2), v13 = lss[1].get(lss[1].size() - 3);\n                            long[] arr = new long[]{v11, v12, v13};\n                            Arrays.sort(arr);\n                            if (l == 0){\n                                dp[i][j][l] = arr[0] + arr[1] + arr[2];\n                            }else{\n                                dp[i][j][l] = arr[0] + arr[1] + arr[2] * 2l;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        long[][] dpp = new long[n + 1][11];\n        for (int i = 0; i < dpp.length; i++) {\n            Arrays.fill(dpp[i], -1);\n        }\n        out.println(dfs(0, 0, dpp, dp, n));\n    }\n\n    static long dfs(int idx, int count, long[][] dp, long[][][] helper, int n){\n        if (idx == n) return 0;\n        if (dp[idx][count] != -1) return dp[idx][count];\n        long res = dfs(idx + 1, count, dp, helper, n);\n        for (int i = 1; i <= 3; i++) {\n            if (i + count >= 10 && helper[idx][i][1] > 0){\n                res = Math.max(res, dfs(idx + 1, (count + i) % 10, dp, helper, n) + helper[idx][i][1]);\n            }\n            if (i + count < 10 && helper[idx][i][0] > 0){\n                res = Math.max(res, dfs(idx + 1, count + i, dp, helper, n) + helper[idx][i][0]);\n            }\n        }\n        return dp[idx][count] = res;\n    }\n}\n","dp,implementation,sortings"
"import java.io.BufferedOutputStream;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.AbstractCollection;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	static class TaskAdapter implements Runnable {\n		@Override\n		public void run() {\n			long startTime = System.currentTimeMillis();\n			InputStream inputStream = System.in;\n			OutputStream outputStream = System.out;\n			FastReader in = new FastReader(inputStream);\n			Output out = new Output(outputStream);\n			FVickysDeliveryService solver = new FVickysDeliveryService();\n			solver.solve(1, in, out);\n			out.close();\n			System.err.println(System.currentTimeMillis()-startTime+""ms"");\n		}\n	}\n\n	public static void main(String[] args) throws Exception {\n		Thread thread = new Thread(null, new TaskAdapter(), """", 1<<26);\n		thread.start();\n		thread.join();\n	}\n\n	static class FVickysDeliveryService {\n		int n;\n		int m;\n		int c;\n		int q;\n		int id;\n		FVickysDeliveryService.DSU dsu;\n		HashMap<Integer, Integer>[] colors;\n\n		public FVickysDeliveryService() {\n		}\n\n		public void add(int u, int v, int x) {\n			dsu.union(colors[u].computeIfAbsent(x, (a) -> id++), v);\n			dsu.union(colors[v].computeIfAbsent(x, (a) -> id++), u);\n			dsu.addExtra(u, v);\n			dsu.addExtra(v, u);\n		}\n\n		public boolean query(int u, int v) {\n			return dsu.connected(u, v)||dsu.hasExtra(u, v);\n		}\n\n		public void solve(int kase, InputReader in, Output pw) {\n			n = in.nextInt();\n			m = in.nextInt();\n			c = in.nextInt();\n			q = in.nextInt();\n			dsu = new FVickysDeliveryService.DSU(2*(n+m+c+q));//can't be bothered to find the exact number\n			colors = new HashMap[n];\n			for(int i = 0; i<n; i++) {\n				colors[i] = new HashMap<>();\n			}\n			id = 2*n;\n			for(int i = 0; i<m; i++) {\n				add(in.nextInt()-1, in.nextInt()-1, in.nextInt());\n			}\n			while(q-->0) {\n				if(in.next().equals(""+"")) {\n					add(in.nextInt()-1, in.nextInt()-1, in.nextInt());\n				}else {\n					pw.println(query(in.nextInt()-1, in.nextInt()-1) ? ""Yes"" : ""No"");\n				}\n			}\n		}\n\n		static class DSU {\n			int[] p;\n			HashSet<Integer>[] e;\n\n			public DSU(int n) {\n				p = new int[n];\n				e = new HashSet[n];\n				for(int i = 0; i<n; i++) {\n					p[i] = i;\n				}\n			}\n\n			public int find(int u) {\n				return p[u]==u ? u : (p[u] = find(p[u]));\n			}\n\n			public void union(int u, int v) {\n//				Utilities.Debug.dbg(""Union"", u, v);\n				int ur = find(u), vr = find(v);\n				if(ur!=vr) {\n					if(e[ur]!=null) {\n						if(e[vr]!=null) {\n							if(e[ur].size()>e[vr].size()) {\n								int tmp = ur;\n								ur = vr;\n								vr = tmp;\n							}\n							e[vr].addAll(e[ur]);\n						}else {\n							e[vr] = e[ur];\n						}\n					}\n					p[ur] = vr;\n				}\n			}\n\n			public void addExtra(int u, int v) {\n//				Utilities.Debug.dbg(""Add"", u, v);\n				u = find(u);\n				if(e[u]==null) {\n					e[u] = new HashSet<>();\n				}\n				e[u].add(v);\n			}\n\n			public boolean connected(int u, int v) {\n				return find(u)==find(v);\n			}\n\n			public boolean hasExtra(int u, int v) {\n				return e[find(u)]!=null&&e[find(u)].contains(v);\n			}\n\n		}\n\n	}\n\n	static class FastReader implements InputReader {\n		final private int BUFFER_SIZE = 1<<16;\n		private DataInputStream din;\n		private byte[] buffer;\n		private int bufferPointer;\n		private int bytesRead;\n\n		public FastReader(InputStream is) {\n			din = new DataInputStream(is);\n			buffer = new byte[BUFFER_SIZE];\n			bufferPointer = bytesRead = 0;\n		}\n\n		public String next() {\n			StringBuilder ret = new StringBuilder(64);\n			byte c = skip();\n			while(c!=-1&&!isSpaceChar(c)) {\n				ret.appendCodePoint(c);\n				c = read();\n			}\n			return ret.toString();\n		}\n\n		public int nextInt() {\n			int ret = 0;\n			byte c = skipToDigit();\n			boolean neg = (c=='-');\n			if(neg) {\n				c = read();\n			}\n			do {\n				ret = ret*10+c-'0';\n			} while((c = read())>='0'&&c<='9');\n			if(neg) {\n				return -ret;\n			}\n			return ret;\n		}\n\n		private boolean isSpaceChar(byte b) {\n			return b==' '||b=='\r'||b=='\n'||b=='\t'||b=='\f';\n		}\n\n		private byte skip() {\n			byte ret;\n			while(isSpaceChar((ret = read()))) ;\n			return ret;\n		}\n\n		private boolean isDigit(byte b) {\n			return b>='0'&&b<='9';\n		}\n\n		private byte skipToDigit() {\n			byte ret;\n			while(!isDigit(ret = read())&&ret!='-') ;\n			return ret;\n		}\n\n		private void fillBuffer() {\n			try {\n				bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n			}catch(IOException e) {\n				e.printStackTrace();\n				throw new InputMismatchException();\n			}\n			if(bytesRead==-1) {\n				buffer[0] = -1;\n			}\n		}\n\n		private byte read() {\n			if(bytesRead==-1) {\n				throw new InputMismatchException();\n			}else if(bufferPointer==bytesRead) {\n				fillBuffer();\n			}\n			return buffer[bufferPointer++];\n		}\n\n	}\n\n	static class Output implements Closeable, Flushable {\n		public StringBuilder sb;\n		public OutputStream os;\n		public int BUFFER_SIZE;\n		public String lineSeparator;\n\n		public Output(OutputStream os) {\n			this(os, 1<<16);\n		}\n\n		public Output(OutputStream os, int bs) {\n			BUFFER_SIZE = bs;\n			sb = new StringBuilder(BUFFER_SIZE);\n			this.os = new BufferedOutputStream(os, 1<<17);\n			lineSeparator = System.lineSeparator();\n		}\n\n		public void println(String s) {\n			sb.append(s);\n			println();\n		}\n\n		public void println() {\n			sb.append(lineSeparator);\n		}\n\n		private void flushToBuffer() {\n			try {\n				os.write(sb.toString().getBytes());\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n			sb = new StringBuilder(BUFFER_SIZE);\n		}\n\n		public void flush() {\n			try {\n				flushToBuffer();\n				os.flush();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n		public void close() {\n			flush();\n			try {\n				os.close();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n	}\n\n	static interface InputReader {\n		String next();\n\n		int nextInt();\n\n	}\n\n	static class Utilities {\n		public static class Debug {\n			public static boolean LOCAL = System.getProperty(""ONLINE_JUDGE"")==null;\n\n			public static <T> String ts(T t) {\n				if(t==null) {\n					return ""null"";\n				}\n				try {\n					return ts((Iterable) t);\n				}catch(ClassCastException e) {\n					if(t instanceof int[]) {\n						String s = Arrays.toString((int[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof long[]) {\n						String s = Arrays.toString((long[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof char[]) {\n						String s = Arrays.toString((char[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof double[]) {\n						String s = Arrays.toString((double[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}else if(t instanceof boolean[]) {\n						String s = Arrays.toString((boolean[]) t);\n						return ""{""+s.substring(1, s.length()-1)+""}"";\n					}\n					try {\n						return ts((Object[]) t);\n					}catch(ClassCastException e1) {\n						return t.toString();\n					}\n				}\n			}\n\n			private static <T> String ts(T[] arr) {\n				StringBuilder ret = new StringBuilder();\n				ret.append(""{"");\n				boolean first = true;\n				for(T t: arr) {\n					if(!first) {\n						ret.append("", "");\n					}\n					first = false;\n					ret.append(ts(t));\n				}\n				ret.append(""}"");\n				return ret.toString();\n			}\n\n			private static <T> String ts(Iterable<T> iter) {\n				StringBuilder ret = new StringBuilder();\n				ret.append(""{"");\n				boolean first = true;\n				for(T t: iter) {\n					if(!first) {\n						ret.append("", "");\n					}\n					first = false;\n					ret.append(ts(t));\n				}\n				ret.append(""}"");\n				return ret.toString();\n			}\n\n			public static void dbg(Object... o) {\n				if(LOCAL) {\n					System.err.print(""Line #""+Thread.currentThread().getStackTrace()[2].getLineNumber()+"": ["");\n					for(int i = 0; i<o.length; i++) {\n						if(i!=0) {\n							System.err.print("", "");\n						}\n						System.err.print(ts(o[i]));\n					}\n					System.err.println(""]"");\n				}\n			}\n\n		}\n\n	}\n}\n\n","data structures,dsu,graphs,hashing"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1166F {\n	static HashMap[] mm;\n	static HashSet[] ss;\n	static int[] dsu;\n	static void add(int i, int c, int j) {\n		HashMap<Integer, Integer> map = mm[i];\n		int j_ = map.getOrDefault(c, -1);\n		if (j_ == -1)\n			map.put(c, j);\n		else\n			join(j_, j);\n	}\n	static void link(int i, int j, int c) {\n		HashSet<Integer> si = ss[find(i)];\n		si.add(j);\n		HashSet<Integer> sj = ss[find(j)];\n		sj.add(i);\n		add(i, c, j);\n		add(j, c, i);\n	}\n	static int find(int i) {\n		return dsu[i] < 0 ? i : (dsu[i] = find(dsu[i]));\n	}\n	static void join(int i, int j) {\n		i = find(i);\n		j = find(j);\n		if (i == j)\n			return;\n		HashSet<Integer> s, t;\n		if (ss[i].size() <= ss[j].size()) {\n			s = ss[i]; t = ss[j];\n		} else {\n			s = ss[j]; t = ss[i];\n		}\n		for (int x : s)\n			t.add(x);\n		if (dsu[i] > dsu[j]) {\n			dsu[i] = j;\n			ss[j] = t;\n		} else {\n			if (dsu[i] == dsu[j])\n				dsu[i]--;\n			dsu[j] = i;\n			ss[i] = t;\n		}\n	}\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter pw = new PrintWriter(System.out);\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int n = Integer.parseInt(st.nextToken());\n		int m = Integer.parseInt(st.nextToken());\n		int q = Integer.parseInt(st.nextToken());\n		q = Integer.parseInt(st.nextToken());\n		mm = new HashMap[n];\n		ss = new HashSet[n];\n		for (int i = 0; i < n; i++) {\n			mm[i] = new HashMap<Integer, Integer>();\n			ss[i] = new HashSet<Integer>();\n		}\n		dsu = new int[n];\n		Arrays.fill(dsu, -1);\n		for (int h = 0; h < m; h++) {\n			st = new StringTokenizer(br.readLine());\n			int i = Integer.parseInt(st.nextToken()) - 1;\n			int j = Integer.parseInt(st.nextToken()) - 1;\n			int c = Integer.parseInt(st.nextToken());\n			link(i, j, c);\n		}\n		while (q-- > 0) {\n			st = new StringTokenizer(br.readLine());\n			String tp = st.nextToken();\n			int i = Integer.parseInt(st.nextToken()) - 1;\n			int j = Integer.parseInt(st.nextToken()) - 1;\n			if (tp.charAt(0) == '+') {\n				int c = Integer.parseInt(st.nextToken());\n				link(i, j, c);\n			} else {\n				boolean yes = false;\n				int i_ = find(i);\n				int j_ = find(j);\n				if (i_ == j_)\n					yes = true;\n				else {\n					HashSet<Integer> set = ss[i_];\n					if (set.contains(j))\n						yes = true;\n				}\n				pw.println(yes ? ""Yes"" : ""No"");\n			}\n		}\n		pw.close();\n	}\n}\n","data structures,dsu,graphs,hashing"
"import javax.smartcardio.ATR;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static int n;\n    static HashMap<Integer,Integer> gr[];\n    static HashSet<Integer> p[];\n    static dsu lol;\n    static void union(int a, int b) {\n        a = lol.get(a);\n        b = lol.get(b);\n        if (p[a].size() > p[b].size()) {\n            int t = a;\n            a = b;\n            b = t;\n        }\n        lol.union(a, b);\n        if (a != b) {\n            for (int color : p[a]) {\n                p[b].add(color);\n            }\n            p[a].clear();\n        }\n    }\n    static void set(int a, int b, int c) {\n        if (gr[a].get(c) != null) {\n            union(gr[a].get(c), b);\n        }\n        if (gr[b].get(c) != null) {\n            union(gr[b].get(c), a);\n        }\n        p[lol.get(b)].add(a);\n        p[lol.get(a)].add(b);\n        gr[a].put(c, b);\n        gr[b].put(c, a);\n    }\n    public static void main(String[] args) throws IOException {\n        Locale.setDefault(Locale.US);\n        br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        n = nextInt();\n        lol = new dsu(n);\n        int m = nextInt();\n        nextInt();\n        int q = nextInt();\n        gr = new HashMap[n];\n        p = new HashSet[n];\n        for(int i = 0;i < n;i++) {\n            gr[i] = new HashMap<>();\n            p[i] = new HashSet<>();\n            p[i].add(i);\n        }\n        for(int i = 0;i < m;i++) {\n            int x = nextInt() - 1;\n            int y = nextInt() - 1;\n            int c1 = nextInt();\n            set(x, y, c1);\n        }\n        for(int i = 0;i < q;i++) {\n            String s = next();\n            if (s.equals(""+"")) {\n                set(nextInt() - 1, nextInt() - 1, nextInt());\n            }else{\n                int a = nextInt() - 1;\n                int b = nextInt() - 1;\n                if (p[lol.get(a)].contains(b)) pw.println(""Yes"");\n                else pw.println(""No"");\n            }\n        }\n        pw.close();\n    }\n\n    static BufferedReader br;\n    static StringTokenizer st = new StringTokenizer("""");\n\n    public static int nextInt() throws IOException {\n        if (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return Integer.parseInt(st.nextToken());\n    }\n\n    public static long nextLong() throws IOException {\n        if (!st.hasMoreTokens()) {\n            st = new StringTokenizer((br.readLine()));\n        }\n        return Long.parseLong(st.nextToken());\n    }\n\n    public static double nextDouble() throws IOException {\n        if (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return Double.parseDouble(st.nextToken());\n    }\n\n    public static String next() throws IOException {\n        if (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n}\nclass dsu {\n    int parent[];\n    dsu(int n) {\n        parent = new int [n];\n        for(int i = 0;i < n;i++) parent[i] = i;\n    }\n    int get(int a) {\n        int p = a;\n        while(a != parent[a]) a = parent[a];\n        while(a != p) {\n            int t = parent[p];\n            parent[p] = a;\n            p = t;\n        }\n        return a;\n    }\n    void union(int a, int b) {\n        parent[get(a)] = get(b);\n    }\n}","data structures,dsu,graphs,hashing"
"import java.awt.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    private boolean eof;\n    private BufferedReader br;\n    private StringTokenizer st;\n    private PrintWriter out;\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n\n    private String nextToken() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                eof = true;\n                return ""-1"";\n            }\n        }\n        return st.nextToken();\n    }\n\n    private int nextInt() {\n        return Integer.parseInt(nextToken());\n    }\n\n    private long nextLong() {\n        return Long.parseLong(nextToken());\n    }\n\n    private double nextDouble() {\n        return Double.parseDouble(nextToken());\n    }\n\n    private String nextLine() throws IOException {\n        return br.readLine();\n    }\n\n\n    private void run() throws IOException {\n        InputStream input = System.in;\n        PrintStream output = System.out;\n        try {\n            File f = new File(""a.in"");\n            if (f.exists() && f.canRead()) {\n                input = new FileInputStream(f);\n                output = new PrintStream(""a.out"");\n            }\n        } catch (Throwable ignored) {\n        }\n        br = new BufferedReader(new InputStreamReader(input));\n        out = new PrintWriter(new PrintWriter(output));\n        solve();\n        br.close();\n        out.close();\n    }\n\n\n    DSU dsu = new DSU();\n    ArrayList<HashMap<Integer, Integer>> roads = new ArrayList<>();\n\n    private void solve() {\n        int n = nextInt();\n        int m = nextInt();\n        int c = nextInt();\n        int q = nextInt();\n\n        for (int i = 0; i <= n; i++) {\n            roads.add(new HashMap<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int x = nextInt();\n            int y = nextInt();\n            int color = nextInt();\n            addEdge(x, y, color);\n        }\n\n        for (int i = 0; i < q; i++) {\n            char cmd = nextToken().charAt(0);\n            int x = nextInt();\n            int y = nextInt();\n            if (cmd == '+') {\n                int color = nextInt();\n                addEdge(x, y, color);\n            } else {\n                if (dsu.getRoot(x) == dsu.getRoot(y) || dsu.getSet(x).contains(y)) {\n                    out.println(""Yes"");\n                } else {\n                    out.println(""No"");\n                }\n            }\n        }\n\n\n    }\n\n    public void addEdge(int x, int y, int color) {\n//        boolean f = false;\n        if (roads.get(x).containsKey(color)) {\n            dsu.union(roads.get(x).get(color), y);\n            dsu.getSet(y).remove(roads.get(x).get(color));\n//            f = true;\n        }\n        if (roads.get(y).containsKey(color)) {\n            dsu.union(roads.get(y).get(color), x);\n            dsu.getSet(x).remove(roads.get(y).get(color));\n//            f = true;\n        }\n        roads.get(x).put(color, y);\n        roads.get(y).put(color, x);\n//        if (!f) {\n            dsu.getSet(y).add(x);\n            dsu.getSet(x).add(y);\n//        }\n    }\n\n    public static class DSU {\n        public HashMap<Integer, Integer> parent = new HashMap<>();\n        public HashMap<Integer, Integer> rank = new HashMap<>();\n        public HashMap<Integer, HashSet<Integer>> sets = new HashMap<>();\n\n        DSU() {\n        }\n\n        public HashSet<Integer> getSet(int v) {\n            v = getRoot(v);\n            if (!sets.containsKey(v)) {\n                sets.put(v, new HashSet<>());\n            }\n            return sets.get(v);\n        }\n\n        public int getRoot(int i) {\n            if (parent.getOrDefault(i, i) != i) {\n                int root = getRoot(parent.getOrDefault(i, i));\n                parent.put(i, root);\n            }\n            return parent.getOrDefault(i, i);\n        }\n\n        public void union(int i, int j) {\n            int rootI = getRoot(i);\n            int rootJ = getRoot(j);\n            if (rootI == rootJ) return;\n            if (getSet(rootI).size() > getSet(rootJ).size()) {\n                int c = rootI;\n                rootI = rootJ;\n                rootJ = c;\n            }\n            getSet(rootJ).addAll(getSet(rootI));\n            parent.put(rootI, rootJ);\n//            if (rank.getOrDefault(rootI, 1) < rank.getOrDefault(rootJ, 1)) {\n//                parent.put(rootI, rootJ);\n//                //////\n//                getSet(rootI).addAll(getSet(rootJ));\n//            } else {\n//                if (rank.getOrDefault(rootI, 1).equals(rank.getOrDefault(rootJ, 1))) {\n//                    parent.put(rootI, rootJ);\n//                    rank.put(rootJ, rank.getOrDefault(rootJ, 1) + 1);\n//                    //////\n//                    getSet(rootI).addAll(getSet(rootJ));\n//                } else {\n//                    parent.put(rootJ, rootI);\n//                    //////\n//                    getSet(rootJ).addAll(getSet(rootI));\n//                }\n//            }\n        }\n    }\n}\n","data structures,dsu,graphs,hashing"
"import java.io.*;\nimport java.util.*;\n\npublic class Main{\n	static int[] kmpPreprocess(int m,char[]P) {\n		int[]b=new int[m+1];\n		int i = 0, j = -1; b[0] = -1;\n		while (i < m) {\n			while (j >= 0 && P[i] != P[j]) j = b[j];\n			i++; j++;\n			b[i] = j;\n		} \n		return b;\n	}\n	\n	static byte[][] kmp(int m,char[]P,int[]b) {\n		byte[][]nxt=new byte[m+1][26];\n		for(int idx=0;idx<=m;idx++) {\n			for(int c=0;c<26;c++) {\n				if(idx==0) {\n					nxt[idx][c]=(byte)((P[idx]-'a')==c?1:0);\n				}\n				else {\n					if(idx==m) {\n						nxt[idx][c]=nxt[b[idx]][c];\n					}\n					else {\n						nxt[idx][c]=(byte)((P[idx]-'a')==c?(idx+1):nxt[b[idx]][c]);\n					}\n				}\n			}\n			\n		}\n		return nxt;\n	}\n	static char[]in,s,t;\n	static byte[][]nxtS,nxtT;\n	static Integer[][][]memo;\n	static int match(byte idxs,byte idxt) {\n		return (idxs==s.length?1:0)-(idxt==t.length?1:0);\n	}\n	static int dp(int i,byte idxs,byte idxt) {\n		if(i>=in.length)return match(idxs, idxt);\n		if(memo[i][idxs][idxt]!=null)return memo[i][idxs][idxt];\n		if(in[i]!='*') {\n			return memo[i][idxs][idxt]=dp(i+1, nxtS[idxs][in[i]-'a'], nxtT[idxt][in[i]-'a'])+match(idxs, idxt);\n		}\n		int ans=-1001;\n		for(int c=0;c<26;c++) {\n			ans=Math.max(ans, match(idxs, idxt)+dp(i+1, nxtS[idxs][c], nxtT[idxt][c]));\n		}\n		return memo[i][idxs][idxt]=ans;\n	}\n	static void main() throws Exception{\n		in=sc.nextLine().toCharArray();\n		s=sc.nextLine().toCharArray();\n		t=sc.nextLine().toCharArray();\n		\n		int[]bS=kmpPreprocess(s.length, s),bT=kmpPreprocess(t.length, t);\n		nxtS=kmp(s.length, s, bS);\n		nxtT=kmp(t.length, t, bT);\n		\n		memo=new Integer[in.length][s.length+1][t.length+1];\n		\n		pw.println(dp(0, (byte)0, (byte)0));\n	}\n	public static void main(String[] args) throws Exception{\n		pw=new PrintWriter(System.out);\n		sc = new MScanner(System.in);\n		main();\n		pw.flush();\n	}\n	static PrintWriter pw;\n	static MScanner  sc;\n	static class MScanner {\n		StringTokenizer st;\n		BufferedReader br;\n		public MScanner(InputStream system) {\n			br = new BufferedReader(new InputStreamReader(system));\n		}\n \n		public MScanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n \n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n		public int[] intArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public long[] longArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public int[] intSortedArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		public long[] longSortedArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		public Integer[] IntegerArr(int n) throws IOException {\n	        Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public Long[] LongArr(int n) throws IOException {\n	        Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n \n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n \n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n \n		public char nextChar() throws IOException {\n			return next().charAt(0);\n		}\n \n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n \n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n \n		public void waitForInput() throws InterruptedException {\n			Thread.sleep(3000);\n		}\n	}\n	static void shuffle(int[]in) {\n		for(int i=0;i<in.length;i++) {\n			int idx=(int)(Math.random()*in.length);\n			int tmp=in[i];\n			in[i]=in[idx];\n			in[idx]=tmp;\n		}\n	}\n	static void shuffle(long[]in) {\n		for(int i=0;i<in.length;i++) {\n			int idx=(int)(Math.random()*in.length);\n			long tmp=in[i];\n			in[i]=in[idx];\n			in[idx]=tmp;\n		}\n	}\n}","dp,strings"
"import java.io.*;\nimport java.util.*;\n\npublic class Main{\n	static int[] kmpPreprocess(int m,char[]P) {\n		int[]b=new int[m+1];\n		int i = 0, j = -1; b[0] = -1;\n		while (i < m) {\n			while (j >= 0 && P[i] != P[j]) j = b[j];\n			i++; j++;\n			b[i] = j;\n		} \n		return b;\n	}\n	\n	static byte[][] kmp(int m,char[]P,int[]b) {\n		byte[][]nxt=new byte[m+1][26];\n		for(int idx=0;idx<=m;idx++) {\n			for(int c=0;c<26;c++) {\n				if(idx==0) {\n					nxt[idx][c]=(byte)((P[idx]-'a')==c?1:0);\n				}\n				else {\n					if(idx==m) {\n						nxt[idx][c]=nxt[b[idx]][c];\n					}\n					else {\n						nxt[idx][c]=(byte)((P[idx]-'a')==c?(idx+1):nxt[b[idx]][c]);\n					}\n				}\n			}\n			\n		}\n		return nxt;\n	}\n	static char[]in,s,t;\n	static byte[][]nxtS,nxtT;\n	static int[][][]memo;\n	static int match(byte idxs,byte idxt) {\n		return (idxs==s.length?1:0)-(idxt==t.length?1:0);\n	}\n	static int dp(int i,byte idxs,byte idxt) {\n		if(i>=in.length)return match(idxs, idxt);\n		if(memo[i][idxs][idxt]!=-1002)return memo[i][idxs][idxt];\n		if(in[i]!='*') {\n			return memo[i][idxs][idxt]=dp(i+1, nxtS[idxs][in[i]-'a'], nxtT[idxt][in[i]-'a'])+match(idxs, idxt);\n		}\n		int ans=-1001;\n		for(int c=0;c<26;c++) {\n			ans=Math.max(ans, match(idxs, idxt)+dp(i+1, nxtS[idxs][c], nxtT[idxt][c]));\n		}\n		return memo[i][idxs][idxt]=ans;\n	}\n	static void main() throws Exception{\n		in=sc.nextLine().toCharArray();\n		s=sc.nextLine().toCharArray();\n		t=sc.nextLine().toCharArray();\n		\n		int[]bS=kmpPreprocess(s.length, s),bT=kmpPreprocess(t.length, t);\n		nxtS=kmp(s.length, s, bS);\n		nxtT=kmp(t.length, t, bT);\n		\n		memo=new int[in.length][s.length+1][t.length+1];\n		for(int i=0;i<in.length;i++) {\n			for(int j=0;j<=s.length;j++) {\n				for(int k=0;k<=t.length;k++) {\n					memo[i][j][k]=-1002;\n				}\n			}\n		}\n		pw.println(dp(0, (byte)0, (byte)0));\n	}\n	public static void main(String[] args) throws Exception{\n		pw=new PrintWriter(System.out);\n		sc = new MScanner(System.in);\n		main();\n		pw.flush();\n	}\n	static PrintWriter pw;\n	static MScanner  sc;\n	static class MScanner {\n		StringTokenizer st;\n		BufferedReader br;\n		public MScanner(InputStream system) {\n			br = new BufferedReader(new InputStreamReader(system));\n		}\n \n		public MScanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n \n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n		public int[] intArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public long[] longArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public int[] intSortedArr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		public long[] longSortedArr(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        shuffle(in);\n	        Arrays.sort(in);\n	        return in;\n		}\n		public Integer[] IntegerArr(int n) throws IOException {\n	        Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public Long[] LongArr(int n) throws IOException {\n	        Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n \n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n \n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n \n		public char nextChar() throws IOException {\n			return next().charAt(0);\n		}\n \n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n \n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n \n		public void waitForInput() throws InterruptedException {\n			Thread.sleep(3000);\n		}\n	}\n	static void shuffle(int[]in) {\n		for(int i=0;i<in.length;i++) {\n			int idx=(int)(Math.random()*in.length);\n			int tmp=in[i];\n			in[i]=in[idx];\n			in[idx]=tmp;\n		}\n	}\n	static void shuffle(long[]in) {\n		for(int i=0;i<in.length;i++) {\n			int idx=(int)(Math.random()*in.length);\n			long tmp=in[i];\n			in[i]=in[idx];\n			in[idx]=tmp;\n		}\n	}\n}","dp,strings"
"import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\n// fail\n\npublic class cf1163d {\n\n    public static void main(String[] args) throws IOException {\n        char[] c = rcha(), s = rcha(), t = rcha();\n        /* if (kmp(s, t).size() != 0) {\n            prln(kmp(c, s).size() - kmp(c, t).size());\n            close();\n            return;\n        } */\n        int n = c.length, m = s.length, r = t.length, dp[][][] = new int[n + 1][m + 1][r + 1], pi_s[] = pi(s), pi_t[] = pi(t), nxt_s[][] = new int[m + 1][26], nxt_t[][] = new int[r + 1][26];\n        for (int[][] layer : dp) {\n            for (int[] row : layer) {\n                fill(row, -IBIG);\n            }\n        }\n        nxt_s[0][s[0] - 'a'] = 1;\n        for (int i = 1; i <= m; ++i) {\n            for (char ch = 'a'; ch <= 'z'; ++ch) {\n                int cur = i;\n                while (cur != 0 && (cur == m || ch != s[cur])) {\n                    cur = pi_s[cur - 1];\n                }\n                if (ch == s[cur]) {\n                    ++cur;\n                }\n                nxt_s[i][ch - 'a'] = cur;\n            }\n        }\n        nxt_t[0][t[0] - 'a'] = 1;\n        for (int i = 1; i <= r; ++i) {\n            for (char ch = 'a'; ch <= 'z'; ++ch) {\n                int cur = i;\n                while (cur != 0 && (cur == r || ch != t[cur])) {\n                    cur = pi_t[cur - 1];\n                }\n                if (ch == t[cur]) {\n                    ++cur;\n                }\n                nxt_t[i][ch - 'a'] = cur;\n            }\n        }\n        dp[0][0][0] = 0;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= m; ++j) {\n                for (int k = 0; k <= r; ++k) {\n                    if (dp[i][j][k] != -IBIG) {\n                        for (char ch = 'a'; ch <= 'z'; ++ch) {\n                            if (c[i] == '*' || c[i] == ch) {\n                                int nxt_j = nxt_s[j][ch - 'a'], nxt_k = nxt_t[k][ch - 'a'];\n                                dp[i + 1][nxt_j][nxt_k] = max(dp[i + 1][nxt_j][nxt_k], dp[i][j][k] + (nxt_j == m ? 1 : 0) - (nxt_k == r ? 1: 0));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /* for (int[][] layer : dp) {\n            for (int[] row : layer) {\n                prln(row);\n            }\n            prln();\n        } */\n        int ans = -IBIG;\n        for (int[] row : dp[n]) {\n            ans = max(ans, maxof(row));\n        }\n        prln(ans);\n        close();\n    }\n\n    // pi[i] = longest proper prefix that is also a suffix of s[:i + 1]\n    static int[] pi(char[] s) {\n        int len = 0, i = 1, pi[] = new int[s.length];\n        while (i < s.length) {\n            if (s[i] == s[len]) {\n                pi[i++] = ++len;\n            } else if (len != 0) {\n                len = pi[len - 1];\n            } else {\n                pi[i++] = len;\n            }\n        }\n        return pi;\n    }\n\n    // kmp(str, pattern) returns indices of matches (ind of 1st char)\n    static List<Integer> kmp(char[] str, char[] pat) {\n        List<Integer> ans = new ArrayList<>();\n        int len = 0, i = 1, j = 0, lps[] = new int[pat.length];\n        while (i < pat.length) {\n            if (pat[i] == pat[len]) {\n                lps[i++] = ++len;\n            } else if (len != 0) {\n                len = lps[len - 1];\n            } else {\n                lps[i++] = len;\n            }\n        }\n        i = 0;\n        while (i < str.length) {\n            if (str[i] == pat[j]) {\n                ++i;\n                ++j;\n            }\n            if (j == pat.length) {\n                ans.add(i - j);\n                j = lps[j - 1];\n            } else if (i < str.length && str[i] != pat[j]) {\n                if (j == 0) {\n                    ++i;\n                } else {\n                    j = lps[j - 1];\n                }\n            }\n        }\n        return ans;\n    }\n\n    static BufferedReader __i = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __o = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __r = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final long LMAX = 9223372036854775807L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int[] exgcd(int a, int b) {if (b == 0) return new int[] {1, 0}; int[] y = exgcd(b, a % b); return new int[] {y[1], y[0] - y[1] * (a / b)};}\n    static long[] exgcd(long a, long b) {if (b == 0) return new long[] {1, 0}; long[] y = exgcd(b, a % b); return new long[] {y[1], y[0] - y[1] * (a / b)};}\n    static int randInt(int min, int max) {return __r.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __i.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__o.print(i);}\n    static void prln(int i) {__o.println(i);}\n    static void pr(long l) {__o.print(l);}\n    static void prln(long l) {__o.println(l);}\n    static void pr(double d) {__o.print(d);}\n    static void prln(double d) {__o.println(d);}\n    static void pr(char c) {__o.print(c);}\n    static void prln(char c) {__o.println(c);}\n    static void pr(char[] s) {__o.print(new String(s));}\n    static void prln(char[] s) {__o.println(new String(s));}\n    static void pr(String s) {__o.print(s);}\n    static void prln(String s) {__o.println(s);}\n    static void pr(Object o) {__o.print(o);}\n    static void prln(Object o) {__o.println(o);}\n    static void prln() {__o.println();}\n    static void pryes() {prln(""yes"");}\n    static void pry() {prln(""Yes"");}\n    static void prY() {prln(""YES"");}\n    static void prno() {prln(""no"");}\n    static void prn() {prln(""No"");}\n    static void prN() {prln(""NO"");}\n    static boolean pryesno(boolean b) {prln(b ? ""yes"" : ""no""); return b;};\n    static boolean pryn(boolean b) {prln(b ? ""Yes"" : ""No""); return b;}\n    static boolean prYN(boolean b) {prln(b ? ""YES"" : ""NO""); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(""hlfd""); flush();}\n    static void flush() {__o.flush();}\n    static void close() {__o.close();}\n}","dp,strings"
"import java.util.*;\nimport java.io.*;\n\npublic class Main {\n	public static void main(String args[]) { new Main().WORK(); }\n	\n	Scanner in = new Scanner(System.in);\n	PrintWriter out = new PrintWriter(System.out);\n	\n	final int INF = 0x3f3f3f3f;\n	\n	char[][] s = new char[3][];\n	int[][] f = new int[3][55];\n	int[][][] dp = new int[1010][55][55];\n	\n	void getFail(char[] s, int[] f) {\n		int n = s.length;\n		f[0] = f[1] = 0;\n		for(int i = 1; i < n; i++) {\n			int j = f[i];\n			while(j!=0 && s[j]!=s[i]) j = f[j];\n			f[i+1] = s[j]==s[i]?j+1:0;\n		}\n	}\n	\n	int dfs(int i, int j, int k) {\n		if(i == s[0].length) return 0;\n		if(dp[i][j][k] != -INF) return dp[i][j][k];\n		char st = 'a', ed = 'z';\n		if(s[0][i] != '*') st = ed = s[0][i];\n		for(char c = st; c <= ed; c++) {\n			int x = j, y = k;\n			for(; x!=0 && s[1][x+1]!=c; x = f[1][x]);\n			if(s[1][x+1] == c) x++;\n			for(; y!=0 && s[2][y+1]!=c; y = f[2][y]);\n			if(s[2][y+1] == c) y++;\n			int tmp = 0;\n			if(x == s[1].length-1) { x = f[1][x]; tmp++; }\n			if(y == s[2].length-1) { y = f[2][y]; tmp--; }\n			dp[i][j][k] = Math.max(dp[i][j][k], dfs(i+1, x, y)+tmp);\n		}\n		return dp[i][j][k];\n	}\n	\n	void WORK() {\n		for(int i = 0; i < 3; i++) s[i] = in.next().toCharArray();\n		getFail(s[1], f[1]); getFail(s[2], f[2]);\n		s[1] = (""A""+String.valueOf(s[1])).toCharArray();\n		s[2] = (""A""+String.valueOf(s[2])).toCharArray();\n		for(int a[][]:dp) for(int b[]:a) Arrays.fill(b, -INF);\n		out.println(dfs(0, 0, 0));\n		out.flush();\n	}\n}","dp,strings"
"import java.util.*;\npublic class class293 {\npublic static void main(String arg[])\n{\n	Scanner sc=new Scanner(System.in);\n	int n=sc.nextInt();\n	\n	int i,min=Integer.MAX_VALUE;\n	int ind=0;\n	for(i=0;i<n;i++)\n	{\n		int a=sc.nextInt();\n		min=Math.min(min,a/Math.max(i, n-1-i));\n		}\n	System.out.println(min);\n	\n	\n}\n}\n","implementation,math"
"import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int min=Integer.MAX_VALUE;\n        for(int i=0;i<n;i++){\n            int a=sc.nextInt();\n            min=Math.min(min,a/Math.max(i,n-i-1));\n        }\n        System.out.println(min);\n    }\n}","implementation,math"
"import java.util.*;\npublic class cf559div2B {\npublic static void main(String[] args) {\nScanner sc=new Scanner(System.in);\nint n=sc.nextInt();\nint arr[]=new int[n];\nint min=Integer.MAX_VALUE;int left=Integer.MAX_VALUE;int right=Integer.MAX_VALUE;\nfor(int i=0;i<n;i++)\n{arr[i]=sc.nextInt();\nif(i>0)\nleft=arr[i]/i;\nif(i<n-1)\nright=arr[i]/(n-1-i);\nmin=Math.min(min,Math.min(left,right));\n}\nSystem.out.println(min);\nsc.close();   \n}    \n}","implementation,math"
"import java.util.*;\npublic class cf559div2B {\npublic static void main(String[] args) {\nScanner sc=new Scanner(System.in);\nint n=sc.nextInt();\nint arr[]=new int[n];\nint min=Integer.MAX_VALUE;int left=Integer.MAX_VALUE;int right=Integer.MAX_VALUE;\nfor(int i=0;i<n;i++)\n{arr[i]=sc.nextInt();\nif(i>0)\nleft=arr[i]/i;\nif(i<n-1)\nright=arr[i]/(n-1-i);\nmin=Math.min(min,Math.min(left,right));\n}\nSystem.out.println(min);\nsc.close();   \n}    \n}","implementation,math"
"import java.util.*;\nimport java.io.*;\n\npublic class C {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		\n		int n = sc.nextInt();\n		int[] a = new int[n];\n		for(int i = 0; i < n; i++) {\n			a[i] = sc.nextInt();\n		}\n		int l = 0, r = n-1;\n		ArrayList<Character> ans = new ArrayList<Character>();\n		int last = 0;\n		while(l <= r) {\n			if(a[l] > last && a[r] > last) {\n				if(a[l] < a[r]) {\n					ans.add('L');\n					last = a[l];\n					l++;\n				} else {\n					ans.add('R');\n					last = a[r];\n					r--;\n				}\n			} else if(a[l] > last){\n				ans.add('L');\n				last = a[l];\n				l++;\n			} else if(a[r] > last) {\n				ans.add('R');\n				last = a[r];\n				r--;\n			} else {\n				break;\n			}\n		}\n		System.out.println(ans.size());\n		for(int i = 0; i < ans.size(); i++) {\n			System.out.print(ans.get(i));\n		}\n	}\n}",greedy
"import java.util.*;\n\npublic class subsequenceeasy\n{\n	public static void main(String args[])\n	{\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int a[] = new int[n];\n		char ans[] = new char[n];\n		for(int i=0;i<n;i++)\n			a[i] = sc.nextInt();\n		int l=0,r=n-1;\n		int min=0;\n		int temp=0;\n		int count=0;\n		while(r>=l)\n		{\n			min = Math.min(a[l],a[r]);\n			if(temp>min)\n			{\n				if(a[l]>temp)\n				{\n					temp=a[l];\n					l++;\n					ans[count]='L';\n				}\n				else \n				{\n					if(temp>a[r]) break;\n					else\n					{\n						temp=a[r];\n						r--;\n						ans[count]='R';\n					}\n				}\n			}\n			else\n			{\n				if(min==a[l])\n				{\n					temp = a[l];\n					l++;\n					ans[count]='L';\n				}\n				else\n				{\n					temp=a[r];\n					r--;\n					ans[count]='R';\n				}\n			}\n			count++;\n		}\n		System.out.println(count);\n		for(int i=0;i<count;i++)\n			System.out.print(ans[i]);\n	}\n}",greedy
"import java.util.Scanner;\n\n\npublic class C555 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n\n        int last = 0;\n        StringBuilder moves = new StringBuilder();\n        int res = 0;\n        int left = 0;\n        int right = n - 1;\n        while(left <= right) {\n            if(a[left] > last && a[left] < a[right]) {\n                last = a[left++];\n                moves.append(""L"");\n            } else if (a[right] > last) {\n                last = a[right--];\n                moves.append(""R"");\n            } else if(a[left] > last) {\n                last = a[left++];\n                moves.append(""L"");\n            } else {\n                break;\n            }\n            res++;\n        }\n\n        System.out.println(res);\n        System.out.println(moves.toString());\n    }\n}\n",greedy
"import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int a[]=new int[n];\n        for(int i=0;i<n;i++)\n        a[i]=sc.nextInt();\n        StringBuilder sb=new StringBuilder();\n        int prev=0;\n        int result=0;\n        int low=0;\n        int high=n-1;\n        while(low<=high) {\n            if(a[low]>prev && a[high]>prev) {\n                if(a[low]<a[high]) {\n                    sb.append(""L"");\n                    prev=a[low];\n                    low++;\n                }\n                else \n                {\n                    sb.append(""R"");\n                    prev=a[high];\n                    high--;\n                }\n            }\n            else if(a[high]>prev) {\n                sb.append(""R"");\n                    prev=a[high];\n                    high--;\n            }\n            else if(a[low]>prev) {\n                sb.append(""L"");\n                    prev=a[low];\n                    low++;\n            }\n            else \n            break;\n            result++;\n        }\n        System.out.println(result);\n        System.out.println(sb.toString());\n    }\n}",greedy
"// upsolve with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1153F {\n	static final int MD = 998244353;\n	static int[][] ch;\n	static void init(int n) {\n		ch = new int[1 + n][1 + n];\n		ch[0][0] = 1;\n		for (int i = 1; i <= n; i++) {\n			ch[i][0] = 1;\n			for (int j = 1; j <= i; j++)\n				ch[i][j] = (ch[i - 1][j] + ch[i - 1][j - 1]) % MD;\n		}\n	}\n	static long power(int a, int k) {\n		if (k == 0)\n			return 1;\n		long p = power(a, k / 2);\n		p = p * p % MD;\n		if (k % 2 == 1)\n			p = p * a % MD;\n		return p;\n	}\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int n = Integer.parseInt(st.nextToken());\n		int k = Integer.parseInt(st.nextToken());\n		int l = Integer.parseInt(st.nextToken());\n		init(n);\n		long[] pp = new long[1 + n + n];\n		long[] qq = new long[1 + n + n];\n		pp[n] = power(2, n);\n		for (int i = 0; i < n; i++)\n			for (int j = n + n; j > 0; j--)\n				pp[j] = (pp[j] - pp[j - 1]) % MD;\n		long[] aa = new long[1 + n + n];\n		for (int j = 0; j <= n + n; j++)\n			aa[j] = pp[j];\n		long inv2 = (MD + 1) / 2;\n		for (int i = 1; i <= n - k; i++) {\n			// qq := pp / p, where p = 2x (1 - x)\n			// divide by 2x\n			for (int j = 0; j < n + n; j++)\n				qq[j] = pp[j + 1] * inv2 % MD;\n			qq[n + n] = 0;\n			// divide by 1 - x is multiply by 1 + x + x^2 + x^3 + ...\n			for (int j = 1; j <= n + n; j++)\n				qq[j] = (qq[j] + qq[j - 1]) % MD;\n			// pp := pp * (1 - p) / p = pp / p - pp = qq - pp\n			for (int j = 0; j <= n + n; j++)\n				pp[j] = (qq[j] - pp[j]) % MD;\n			long a = ch[n][i];\n			for (int j = 0; j <= n + n; j++)\n				aa[j] = (aa[j] + a * pp[j]) % MD;\n		}\n		// integrate x^i to x^{i + 1} / (i + 1)\n		long a = 0;\n		for (int i = 0; i <= n + n; i++)\n			a = (a + aa[i] * power(i + 1, MD - 2)) % MD;\n		a = (a * l % MD + MD) % MD;\n		System.out.println(a);\n	}\n}\n","combinatorics,dp,math,probabilities"
"import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable{\n    public static void main(String[] args){\n        //new Thread(null,new Main(),""Thread-1"",1024*1024*10).start();\n        new Main().run();\n    }\n    int mod=998244353;\n    private void solve() throws Exception {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        int n=in.nextInt(),k=in.nextInt(),l=in.nextInt();\n        long[]fac=new long[n+1];\n        fac[0]=1;\n        for(int i=1;i<=n;i++){\n            fac[i]=fac[i-1]*i%mod;\n        }\n        long[][]dp=new long[2*n+1][2*n+2];\n        dp[0][0]=1;\n        for(int i=1;i<=2*n;i++){\n            for(int j=0;j<=i;j++){\n                if(j>0) dp[i][j]=(dp[i][j]+dp[i-1][j-1])%mod;\n                dp[i][j]=(dp[i][j]+dp[i-1][j+1]*(j+1)%mod)%mod;\n            }\n        }\n        long ans=0;\n        for(int i=k;i<=2*n;i++){\n            for(int j=k;j<=n;j++){\n                ans=(ans+dp[i][j]*dp[2*n-i][j]%mod*fac[j]%mod)%mod;\n            }\n        }\n        out.println(l*ans%mod*Pow(dp[2*n][0],mod-2)%mod*Pow(2*n+1,mod-2)%mod);\n        out.flush();\n    }\n    long Pow(long a,long b){\n        long ans=1;\n        while(b>0){\n            if((b&1)!=0)ans=(ans*a)%mod;\n            a=(a*a)%mod;\n            b>>=1;\n        }\n        return ans;\n    }\n    @Override\n    public void run() {\n        try {\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    class InputReader{\n        StreamTokenizer tokenizer;\n        public InputReader(InputStream stream){\n            tokenizer=new StreamTokenizer(new BufferedReader(new InputStreamReader(stream)));\n            tokenizer.ordinaryChars(33,126);\n            tokenizer.wordChars(33,126);\n        }\n        public String next() throws IOException {\n            tokenizer.nextToken();\n            return tokenizer.sval;\n        }\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n        public boolean hasNext() throws IOException {\n            int res=tokenizer.nextToken();\n            tokenizer.pushBack();\n            return res!=tokenizer.TT_EOF;\n        }\n    }\n}","combinatorics,dp,math,probabilities"
"import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable{\n    public static void main(String[] args){\n        //new Thread(null,new Main(),""Thread-1"",1024*1024*10).start();\n        new Main().run();\n    }\n    int mod=998244353;\n    private void solve() throws Exception {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        int n=in.nextInt(),k=in.nextInt(),l=in.nextInt();\n        long[]fac=new long[n+1];\n        fac[0]=1;\n        for(int i=1;i<=n;i++){\n            fac[i]=fac[i-1]*i%mod;\n        }\n        long[][]dp=new long[2*n+1][2*n+2];\n        dp[0][0]=1;\n        for(int i=1;i<=2*n;i++){\n            for(int j=0;j<=Math.min(i,n);j++){\n                if(j>0) dp[i][j]=(dp[i][j]+dp[i-1][j-1])%mod;\n                dp[i][j]=(dp[i][j]+dp[i-1][j+1]*(j+1)%mod)%mod;\n            }\n        }\n        long ans=0;\n        for(int i=k;i<=2*n;i++){\n            for(int j=k;j<=n;j++){\n                ans=(ans+dp[i][j]*dp[2*n-i][j]%mod*fac[j]%mod)%mod;\n            }\n        }\n        out.println(l*ans%mod*Pow(dp[2*n][0],mod-2)%mod*Pow(2*n+1,mod-2)%mod);\n        out.flush();\n    }\n    long Pow(long a,long b){\n        long ans=1;\n        while(b>0){\n            if((b&1)!=0)ans=(ans*a)%mod;\n            a=(a*a)%mod;\n            b>>=1;\n        }\n        return ans;\n    }\n    @Override\n    public void run() {\n        try {\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    class InputReader{\n        StreamTokenizer tokenizer;\n        public InputReader(InputStream stream){\n            tokenizer=new StreamTokenizer(new BufferedReader(new InputStreamReader(stream)));\n            tokenizer.ordinaryChars(33,126);\n            tokenizer.wordChars(33,126);\n        }\n        public String next() throws IOException {\n            tokenizer.nextToken();\n            return tokenizer.sval;\n        }\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n        public boolean hasNext() throws IOException {\n            int res=tokenizer.nextToken();\n            tokenizer.pushBack();\n            return res!=tokenizer.TT_EOF;\n        }\n    }\n}","combinatorics,dp,math,probabilities"
"import java.io.*;\nimport java.util.*;\n\npublic class Codeforces1153F {\n\n	public static void main(String[] args) throws IOException {\n		int P = 998244353;\n		\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int n = Integer.parseInt(st.nextToken());\n		int real_k = Integer.parseInt(st.nextToken());\n		int l = Integer.parseInt(st.nextToken());\n				\n		//generate factorials\n		int[] factorials = new int[2*n+2];\n		factorials[0] = 1;\n		for (int i = 1; i <= 2*n+1; i++) {\n			factorials[i] = multiply(factorials[i-1], i, P);\n		}\n		\n		//number of ways to choose k pairs from 2k elements\n		//where order doesn't matter\n		//equals (2k)!/(2^n)/k! = (2k-1)!!\n		int[] doublefact = new int[n+1];\n		doublefact[0] = 1;\n		for (int i = 1; i <= n; i++) {\n			doublefact[i] = multiply(doublefact[i-1], (2*i-1), P);\n		}\n\n		//list[r][k] stores for rth segment, exactly k of the n segments covering it \n		int[][] list = new int[2*n+2][n+1];\n		\n		for (int r = 1; r <= 2*n+1; r++) {\n			for (int k = 1; k <= n; k++) {\n				if (((r%2) != (k%2)) && (r-1 >= k) && (2*n+1-r >= k)) {\n					int num = multiply(factorials[r-1], factorials[2*n+1-r], P);\n					num = multiply(num, doublefact[(r-k-1)/2], P);\n					num = multiply(num, doublefact[(2*n+1-r-k)/2], P);\n					\n					int denom = multiply(factorials[r-k-1], factorials[2*n+1-r-k], P);\n					denom = multiply(denom, factorials[k], P);\n										\n					list[r][k] = multiply(num, inverse(multiply(denom, doublefact[n], P), P), P);\n				}\n				\n			}\n		}\n		\n		int ans = 0;\n		for (int r = 1; r <= 2*n+1; r++) {\n			for (int k = real_k; k <= n; k++) {\n				ans += list[r][k];\n				ans %= P;\n			}\n		}\n		\n		ans = multiply(ans, l, P);\n		ans = multiply(ans, inverse(2*n+1, P), P);\n		\n		System.out.println(ans);\n\n	}\n	\n	public static int multiply (int a, int b, int n) {\n		long ab = (long) a * (long) b;\n		return ((int) (ab%n));\n	}\n	\n	public static int inverse (int a, int n) {\n		int m = n;\n		int r1 = 1;\n		int r2 = 0;\n		int r3 = 0;\n		int r4 = 1;\n		while ((a > 0) && (n > 0)) {\n			if (n >= a) {\n				r3 -= r1*(n/a);\n				r4 -= r2*(n/a);\n				n = n%a;\n			}\n			else {\n				int tmp = a;\n				a = n;\n				n = tmp;\n				tmp = r1;\n				r1 = r3;\n				r3 = tmp;\n				tmp = r2;\n				r2 = r4;\n				r4 = tmp;\n			}\n		}\n		if (a == 0) {\n			if (r3 >= 0)\n				return (r3%m);\n			else\n				return (m+(r3%m));\n		}\n		else {\n			if (r1 >= 0)\n				return (r1%m);\n			else\n				return (m+(r1%m));\n		}\n\n	}\n\n}\n","combinatorics,dp,math,probabilities"
"import java.io.*;\nimport java.util.*;\n \npublic class Contest1151E\n{\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        String next() { // reads in the next string\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public int nextInt() { // reads in the next int\n            return Integer.parseInt(next());\n        }\n        public long nextLong() { // reads in the next long\n            return Long.parseLong(next());\n        }\n        public double nextDouble() { // reads in the next double\n            return Double.parseDouble(next());\n            }\n        }\n    static InputReader r = new InputReader(System.in);\n    static PrintWriter pw = new PrintWriter(System.out);\n    static long mod = 1000000007;\n    public static void main(String[] args)\n    {\n    	int t = 1;\n    	while (t > 0)\n    	{\n    		t--;\n    		int n = r.nextInt();\n    		long[] a = new long[n];\n    		for (int i = 0; i < n; i ++)\n    		{\n    			a[i] = r.nextInt();\n    		}\n    		long ans = 0;\n    		for (int i = 0; i < n-1; i ++)\n    		{\n    			if (a[i] <= a[i+1])\n    			{\n    				ans += a[i]*(a[i+1]-a[i]);\n    			}\n    			else\n    			{\n    				ans += (n-a[i]+1)*(a[i]-a[i+1]);\n    			}\n    			//l <= a[i], a[i] <= r < a[i+1]\n    		}\n    		ans += (a[n-1]*(n-a[n-1]+1));\n    		pw.println(ans);\n    	}\n        pw.close();\n    }\n}","combinatorics,data structures,dp,math"
"import java.io.*;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport java.lang.Math;\nimport java.time.format.DateTimeFormatter;  \nimport java.time.LocalDateTime; \n \n \n// CODEFORCES\npublic class main {\n \n	static int cycleNum;\n\n	public static void main(String[] args) {\n		Scanner scanner = new Scanner(System.in);\n		\n		\n		int n = scanner.nextInt();\n		int[] arr = new int[n+1];\n		for (int i = 1; i < arr.length; i++) {\n		    arr[i] = scanner.nextInt();\n		}\n//		int m = scanner.nextInt();\n//		int k = scanner.nextInt();\n//		int q = scanner.nextInt();\n//		int[][] ts = new int[k][2];\n//		int[] cols = new int[q];\n//		\n//		String[] s1 = scanner.nextLine().split("" "");\n//		for (int i = 0; i < k; i++) {\n//		    s1 = scanner.nextLine().split("" "");\n//		    ts[i][0] = Integer.valueOf(s1[0]);\n//		    ts[i][1] = Integer.valueOf(s1[1]);\n//		}\n//		s1 = scanner.nextLine().split("" "");\n//		for (int i = 0; i < q; i++) {\n//		    cols[i] = Integer.valueOf(s1[i]);\n//		}\n//		Arrays.sort(cols);\n//		\n//		String[] s1 = new String[n];\n//		String [] s2 = new String[n];\n//		\n//		s1 = scanner.nextLine().split("" "");\n//		s2 = scanner.nextLine().split("" "");\n		\n//		scanner = new Scanner(System.in);\n//		String[] s = scanner.nextLine().split("" "");\n		\n//	String[] str1 = new String[4];\n//		str1 = scanner.nextLine().split("" "");\n//		String[] str2 = new String[Integer.valueOf(str1[0])];\n//		while(scanner.hasNextLine()){\n//			str2 = scanner.nextLine().split("" "");\n//		}\n		\n//		int[] p = new int[n];\n//		int[] q = new int[n];\n//		for (int i = 0; i < s1.length; i++) {\n//			p[i] = Integer.valueOf(s1[i]);\n//			q[i] = Integer.valueOf(s2[i]);\n//		}\n		\n// 		int n = 10;\n// 		int[] arr = {0,1,5,2,5,5,3,10,6,5,1};\n		long ans = 0;\n		\n		for (int i = 1; i < arr.length; i++) {\n			if (arr[i] == arr[i-1]) { continue; }\n			ans += number(arr[i-1], arr[i], n);\n		}\n		\n		System.out.println(ans);\n		\n 	}\n	\n	static long number(int exclude, int include, int n) {\n		if (exclude < include) {\n			int l = exclude + 1;\n			int r = include;\n			return (long) (r-l+1) * (n-r+1);\n		} else {\n			int r = exclude - 1;\n			int l = include;\n			return (long) (include) * (r-l+1);\n		}\n	}\n	\n	\n	\n}\n	\n \n \n \n \n//List sortedKeys=new ArrayList(trip.keySet());\n//Collections.sort(sortedKeys);","combinatorics,data structures,dp,math"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n \npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n \n    static class TaskE {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int a[] = new int[n + 1];\n            for (int i = 0; i < n; i++) {\n                a[i + 1] = in.readInt();\n            }\n            long r = 0;\n            for (int i = 1; i <= n; i++) {\n                if (a[i] > a[i - 1])\n                    r += (long) (a[i] - a[i - 1]) * (n - a[i] + 1);\n                else\n                    r += (long) a[i] * (a[i - 1] - a[i]);\n            }\n            out.printLine(r);\n        }\n \n    }\n \n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n \n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n \n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n \n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n \n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n \n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n        }\n \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n \n        }\n \n    }\n \n    static class OutputWriter {\n        private final PrintWriter writer;\n \n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n \n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n \n        public void close() {\n            writer.close();\n        }\n \n        public void printLine(long i) {\n            writer.println(i);\n        }\n \n    }\n}\n    	      	   		  		    		  	","combinatorics,data structures,dp,math"
"import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\n// 1:50.856\n\npublic class cf1151e {\n\n    public static void main(String[] args) throws IOException {\n        long n = rl(), a[] = rla((int) n), ans = n * (n + 1) / 2 - (a[0] - 1) * a[0] / 2 - (n - a[0]) * (n - a[0] + 1) / 2;\n        // prln(ans);\n        for (int i = 1; i < n; ++i) {\n            if (a[i] > a[i - 1]) {\n                long delta = a[i] - a[i - 1];\n                ans += (n - a[i - 1]) * (n - a[i - 1] + 1) / 2 - (delta - 1) * delta / 2 - (n - a[i]) * (n - a[i] + 1) / 2;\n            } else if (a[i] < a[i - 1]) {\n                long delta = a[i - 1] - a[i];\n                ans += (a[i - 1] - 1) * a[i - 1] / 2 - (delta - 1) * delta / 2 - (a[i] - 1) * a[i] / 2;\n            }\n            // prln(ans);\n        }\n        prln(ans);\n        close();\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int lcm(int a, int b) {return a * b / gcf(a, b);}\n    static long lcm(long a, long b) {return a * b / gcf(a, b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {prln(""yes"");}\n    static void pry() {prln(""Yes"");}\n    static void prY() {prln(""YES"");}\n    static void prno() {prln(""no"");}\n    static void prn() {prln(""No"");}\n    static void prN() {prln(""NO"");}\n    static boolean pryesno(boolean b) {prln(b ? ""yes"" : ""no""); return b;};\n    static boolean pryn(boolean b) {prln(b ? ""Yes"" : ""No""); return b;}\n    static boolean prYN(boolean b) {prln(b ? ""YES"" : ""NO""); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(""hlfd""); flush();}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}\n}","combinatorics,data structures,dp,math"
"public class p1141C {\n    public static void main(String[] args) {\n        var sc = new java.util.Scanner(System.in);\n        StringBuilder sb=new StringBuilder();\n        int n=sc.nextInt(),a[]=new int[n],pre=0,b[]=new int[n+1];\n        double sum=0;\n        for(int i=1;i<n;i++) {\n            a[i]=sc.nextInt();\n            sum+=a[i]+pre;\n            pre+=a[i];\n        }\n        pre=(int)((n+1)/2.0-sum/n);\n        for(int i:a) {\n            pre+=i;\n            if((pre<1||pre>n)||b[pre]>0) {System.out.println(""-1""); return;}\n            b[pre]++;\n            sb.append(pre+"" "");\n        }System.out.println(sb);\n    }\n}",math
"public class p1141C {\n    public static void main(String[] args) {\n        var sc = new java.util.Scanner(System.in);\n        StringBuilder sb=new StringBuilder();\n        long n=sc.nextInt(),a[]=new long[(int)n],sum=0,pre=0;\n        for(int i=1;i<n;i++) {\n            a[i]=sc.nextInt();\n            sum+=a[i]+pre;\n            pre+=a[i];\n        }int b[]=new int[(int)n+1];\n        pre=(n*(n+1)/2-sum)/n;\n        for(long i:a) {\n            pre+=i;\n            if((pre<1||pre>n)||b[(int)pre]>0) {System.out.println(""-1""); return;}\n            b[(int)pre]++;\n            sb.append(pre+"" "");\n        }System.out.println(sb);\n    }\n}",math
"import java.util.*;\npublic class MyClass {\n\n    public static void main(String args[]) {\n     Scanner in=new Scanner(System.in);\n          int n=in.nextInt();\n         int a[]=new int[n-1];\n         ArrayList<Integer> array=new ArrayList<>();\n         int min=0;\n         int sum=0;\n         TreeSet<Integer> t=new TreeSet<>();\n         for(int i=0;i<n-1;i++){ a[i]=in.nextInt(); sum+=a[i]; min=Math.min(min,sum); }\n         array.add(min*(-1) + 1); t.add(min*(-1) + 1);\n         for(int i=0;i<n-1;i++){\n             array.add(a[i]+array.get(i)); t.add(a[i]+array.get(i));\n         }\n         if(t.size()!=n||t.ceiling(n+1)!=null||t.floor(0)!=null) System.out.println(-1);\n         else{\n             for(int i:array){\n                 System.out.print(i+"" "");\n             }System.out.println();\n         }\n    }\n}",math
"import java.util.*;\nimport java.io.*;\n\npublic class sample {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner t = new Scanner(System.in);\n		PrintWriter o = new PrintWriter(System.out);\n		int n = t.nextInt() - 1;\n		long[] a = new long[n + 1];\n		long[] b = new long[n];\n		long min = 0, sum = 0;\n		Set<Long> set = new HashSet<>();\n\n		for (int i = 0; i < n; ++i) {\n			b[i] = t.nextLong();\n			sum += b[i];\n			min = Math.min(min, sum);\n		}\n\n		a[0] = 1 - min;\n\n		set.add(a[0]);\n\n		for (int i = 1; i <= n; ++i) {\n			a[i] = a[i - 1] + b[i - 1];\n\n			set.add(a[i]);\n		}\n\n		boolean f = true;\n\n		for (int i = 0; i < n + 1; ++i)\n			if (a[i] < 1 || a[i] > n + 1)\n				f = false;\n\n		if (set.size() != n + 1)\n			f = false;\n\n		if (f)\n			for (int i = 0; i <= n; ++i)\n				o.print(a[i] + "" "");\n		else\n			o.println(""-1"");\n\n		o.flush();\n		o.close();\n	}\n}",math
"import java.io.*;\nimport java.util.*;\npublic class Sol{\n	static class pair {\n		int pot;\n		int club;\n		public pair(int pot, int club) {\n			this.pot = pot;\n			this.club = club;\n		}\n	}\n	public static int n,m,d;\n	public static int p[];\n	public static int c[];\n	public static int q[];\n	public static int match[];\n	public static int mex[];\n	public static boolean tested[];\n	public static List<Integer> adj[];\n	public static boolean used[];\n	public static void main(String[] args) throws IOException{\n		FastIO sc = new FastIO(System.in);\n		PrintWriter out = new PrintWriter(System.out);\n		n = sc.nextInt();\n		m = sc.nextInt();\n		match = new int[m];\n		p = new int[n];\n		c = new int[n];\n		tested = new boolean[n];\n		used = new boolean[n];\n		Arrays.fill(match, -1);\n		adj = new ArrayList[5000];\n		for(int i=0; i<5000; ++i) {\n			adj[i] = new ArrayList<>();\n		}\n		for(int i=0; i<n; ++i) {\n			p[i] = sc.nextInt();\n		}\n		for(int i=0; i<n; ++i) {\n			c[i] = sc.nextInt()-1;\n		}\n		d = sc.nextInt();\n		q = new int[d];\n		mex = new int[d];\n		for(int i=0; i<d; ++i) {\n			q[d-i-1] = sc.nextInt()-1;\n			used[q[d-i-1]] = true;\n		}\n		for(int i=0; i<n; ++i) {\n			if(used[i]) continue;\n			adj[p[i]].add(c[i]);\n		}\n		int idx = 0;\n		while(augpath(idx)) {\n			Arrays.fill(tested, false);\n			idx++;\n		}\n		Arrays.fill(tested, false);\n		/*for(int i=0; i<m; ++i) {\n			System.out.println(match[i] + "" matcgh"");\n		}*/\n		mex[0] = idx;\n		for(int i=0; i<d-1; ++i) {\n			adj[p[q[i]]].add(c[q[i]]);\n			while(augpath(idx)) {\n				Arrays.fill(tested, false);\n				idx++;\n			}\n			Arrays.fill(tested, false);\n			/*for(int j=0; j<m; ++j) {\n				System.out.println(match[j] + "" matcgh"");\n			}*/\n			mex[i+1] = idx;\n		}\n		for(int i=0; i<d; ++i) {\n			out.println(mex[d-i-1]);\n		}\n		out.close();\n	}\n	public static boolean augpath(int curr) {\n		if(curr>n) return false;\n		if(tested[curr]) return false;\n		tested[curr] = true;\n		for(int i : adj[curr]) {\n			int nxt = match[i];\n			if(nxt==-1) {\n				match[i] = curr;\n				return true;\n			}\n			match[i] = curr;\n			if(augpath(nxt)) {\n				return true;\n			}\n			match[i] = nxt;\n		}\n		return false;\n	}\n	static class FastIO {\n		 \n		// Is your Fast I/O being bad?\n \n		InputStream dis;\n		byte[] buffer = new byte[1 << 17];\n		int pointer = 0;\n \n		public FastIO(String fileName) throws IOException {\n			dis = new FileInputStream(fileName);\n		}\n \n		public FastIO(InputStream is) throws IOException {\n			dis = is;\n		}\n \n		int nextInt() throws IOException {\n			int ret = 0;\n \n			byte b;\n			do {\n				b = nextByte();\n			} while (b <= ' ');\n			boolean negative = false;\n			if (b == '-') {\n				negative = true;\n				b = nextByte();\n			}\n			while (b >= '0' && b <= '9') {\n				ret = 10 * ret + b - '0';\n				b = nextByte();\n			}\n \n			return (negative) ? -ret : ret;\n		}\n \n		long nextLong() throws IOException {\n			long ret = 0;\n \n			byte b;\n			do {\n				b = nextByte();\n			} while (b <= ' ');\n			boolean negative = false;\n			if (b == '-') {\n				negative = true;\n				b = nextByte();\n			}\n			while (b >= '0' && b <= '9') {\n				ret = 10 * ret + b - '0';\n				b = nextByte();\n			}\n \n			return (negative) ? -ret : ret;\n		}\n \n		byte nextByte() throws IOException {\n			if (pointer == buffer.length) {\n				dis.read(buffer, 0, buffer.length);\n				pointer = 0;\n			}\n			return buffer[pointer++];\n		}\n \n		String next() throws IOException {\n			StringBuffer ret = new StringBuffer();\n \n			byte b;\n			do {\n				b = nextByte();\n			} while (b <= ' ');\n			while (b > ' ') {\n				ret.appendCodePoint(b);\n				b = nextByte();\n			}\n \n			return ret.toString();\n		}\n \n	}\n}","flows,graph matchings,graphs"
"import java.util.*;\nimport static java.lang.Math.*;\n\npublic class SolutionE {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        int deg[] = new int[m];\n        int p[] = new int[n];\n        for(int i = 0; i < n; ++i) {\n            p[i] = sc.nextInt();\n            if(p[i] < m)\n                deg[p[i]]++;\n        }\n\n        int c[] = new int[n];\n        for(int i = 0; i < n; ++i)\n            c[i] = sc.nextInt();\n\n        int q = sc.nextInt();\n        int qind[] = new int[q];\n        int vis[] = new int[n];\n        for(int i = 0; i < q; ++i) {\n            qind[i] = sc.nextInt() - 1;\n            vis[qind[i]] = 1;\n        }\n\n        Kunh kunh = new Kunh(2 * m, deg);\n        for(int i = 0; i < n; ++i) {    \n            if(vis[i] == 0) {\n                if(p[i] < m) \n                    kunh.addEdge(p[i], m + c[i] - 1);\n            }\n        }\n        int ans = 0;\n        while(ans < m && kunh.addFlow(ans)) \n            ans++;\n\n        int fans[] = new int[q];\n        for(int i = q - 1; i >= 0; --i) {\n            fans[i] = ans;\n\n            int ind = qind[i];\n\n            if(p[ind] < m) {\n                kunh.addEdge(p[ind], m + c[ind] - 1);\n            }\n\n            while(ans < m && kunh.addFlow(ans))\n                ans++;\n        }\n\n        for(int i : fans)\n            System.out.println(i);\n    }\n}\nclass Kunh {\n    int pair[];\n    int adj[][];\n    int ptr[];\n    int vis[];\n    int level = 0;\n    Kunh(int n, int deg[]) {\n        pair = new int[n];\n        Arrays.fill(pair, -1);\n        adj = new int[n / 2][];\n        for(int i = 0; i < n / 2; ++i) {\n            adj[i] = new int[deg[i]];\n        }\n        ptr = new int[n / 2];\n        vis = new int[n / 2];\n    }\n    void addEdge(int i, int j) {\n        adj[i][ptr[i]++] = j;\n    }\n    boolean addFlow(int source) {\n        level++;\n        return dfs(source);\n    }\n    boolean dfs(int i) {\n        vis[i] = level;\n\n        for(int k = 0; k < ptr[i]; ++k) {\n            int j = adj[i][k];\n            if(pair[j] == -1) {\n                pair[j] = i;\n                return true;\n            }\n            else if(vis[pair[j]] != level && dfs(pair[j])) {\n                pair[j] = i;\n                return true;\n            }\n        }\n\n        return false;\n    }\n}","flows,graph matchings,graphs"
"import java.util.*;\nimport static java.lang.Math.*;\n\npublic class SolutionE {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        int deg[] = new int[m];\n        int p[] = new int[n];\n        for(int i = 0; i < n; ++i) {\n            p[i] = sc.nextInt();\n            if(p[i] < m)\n                deg[p[i]]++;\n        }\n\n        int c[] = new int[n];\n        for(int i = 0; i < n; ++i)\n            c[i] = sc.nextInt();\n\n        int q = sc.nextInt();\n        int qind[] = new int[q];\n        int vis[] = new int[n];\n        for(int i = 0; i < q; ++i) {\n            qind[i] = sc.nextInt() - 1;\n            vis[qind[i]] = 1;\n        }\n\n        Kunh kunh = new Kunh(2 * m, deg);\n        for(int i = 0; i < n; ++i) {    \n            if(vis[i] == 0) {\n                if(p[i] < m) \n                    kunh.addEdge(p[i], m + c[i] - 1);\n            }\n        }\n        int ans = 0;\n        while(ans < m && kunh.addFlow(ans)) \n            ans++;\n\n        int fans[] = new int[q];\n        for(int i = q - 1; i >= 0; --i) {\n            fans[i] = ans;\n\n            int ind = qind[i];\n\n            if(p[ind] < m) {\n                kunh.addEdge(p[ind], m + c[ind] - 1);\n            }\n\n            while(ans < m && kunh.addFlow(ans))\n                ans++;\n        }\n\n        for(int i : fans)\n            System.out.println(i);\n    }\n}\nclass Kunh {\n    int pair[];\n    int adj[][];\n    int ptr[];\n    int vis[];\n    int level = 0;\n    Kunh(int n, int deg[]) {\n        pair = new int[n];\n        Arrays.fill(pair, -1);\n        adj = new int[n / 2][];\n        for(int i = 0; i < n / 2; ++i) {\n            adj[i] = new int[deg[i]];\n        }\n        ptr = new int[n / 2];\n        vis = new int[n / 2];\n    }\n    void addEdge(int i, int j) {\n        adj[i][ptr[i]++] = j;\n    }\n    boolean addFlow(int source) {\n        level++;\n        return dfs(source);\n    }\n    boolean dfs(int i) {\n        vis[i] = level;\n\n        for(int k = 0; k < ptr[i]; ++k) {\n            int j = adj[i][k];\n            if(pair[j] == -1) {\n                pair[j] = i;\n                return true;\n            }\n            else if(vis[pair[j]] != level && dfs(pair[j])) {\n                pair[j] = i;\n                return true;\n            }\n        }\n\n        return false;\n    }\n}","flows,graph matchings,graphs"
"import java.util.*;\nimport static java.lang.Math.*;\n\npublic class SolutionE {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        int deg[] = new int[m];\n        int p[] = new int[n];\n        for(int i = 0; i < n; ++i) {\n            p[i] = sc.nextInt();\n            if(p[i] < m)\n                deg[p[i]]++;\n        }\n\n        int c[] = new int[n];\n        for(int i = 0; i < n; ++i)\n            c[i] = sc.nextInt();\n\n        int q = sc.nextInt();\n        int qind[] = new int[q];\n        int vis[] = new int[n];\n        for(int i = 0; i < q; ++i) {\n            qind[i] = sc.nextInt() - 1;\n            vis[qind[i]] = 1;\n        }\n\n        Kunh kunh = new Kunh(2 * m, deg);\n        for(int i = 0; i < n; ++i) {    \n            if(vis[i] == 0) {\n                if(p[i] < m) \n                    kunh.addEdge(p[i], m + c[i] - 1);\n            }\n        }\n        int ans = 0;\n        while(ans < m && kunh.addFlow(ans)) \n            ans++;\n\n        int fans[] = new int[q];\n        for(int i = q - 1; i >= 0; --i) {\n            fans[i] = ans;\n\n            int ind = qind[i];\n\n            if(p[ind] < m) {\n                kunh.addEdge(p[ind], m + c[ind] - 1);\n            }\n\n            while(ans < m && kunh.addFlow(ans))\n                ans++;\n        }\n\n        for(int i : fans)\n            System.out.println(i);\n    }\n}\nclass Kunh {\n    int pair[];\n    int adj[][];\n    int ptr[];\n    int vis[];\n    int level = 0;\n    Kunh(int n, int deg[]) {\n        pair = new int[n];\n        Arrays.fill(pair, -1);\n        adj = new int[n / 2][];\n        for(int i = 0; i < n / 2; ++i) {\n            adj[i] = new int[deg[i]];\n        }\n        ptr = new int[n / 2];\n        vis = new int[n / 2];\n    }\n    void addEdge(int i, int j) {\n        adj[i][ptr[i]++] = j;\n    }\n    boolean addFlow(int source) {\n        level++;\n        return dfs(source);\n    }\n    boolean dfs(int i) {\n        vis[i] = level;\n\n        for(int k = 0; k < ptr[i]; ++k) {\n            int j = adj[i][k];\n            if(pair[j] == -1) {\n                pair[j] = i;\n                return true;\n            }\n            else if(vis[pair[j]] != level && dfs(pair[j])) {\n                pair[j] = i;\n                return true;\n            }\n        }\n\n        return false;\n    }\n}","flows,graph matchings,graphs"
//package files;\nimport java.util.*;\npublic class Answer {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n;\n		n=sc.nextInt();\n		String s=sc.next();\n		int count=0;\n		for(int i=0;i<n;i++) {\n			if((s.charAt(i)-'0')%2==0)\n				count+=i+1;\n		}\n		System.out.println(count);\n	}\n	 \n}\n,"implementation,strings"
import java.util.Scanner;\n\npublic class CR548A {\n	public static void main(String[] args) {\n		Scanner s=new Scanner(System.in);\n		\n		int n=s.nextInt();\n		\n		String str=s.next();\n		int count=0;\n		\n		for(int i=0;i<n;i++) {\n			if((str.charAt(i)-'0')%2==0) {\n				count+=i+1;\n			}\n		}\n		System.out.println(count);\n	}\n\n}\n,"implementation,strings"
"import java.util.*;\npublic class Main\n{\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n    	long i,l,count=0;\n    	l=sc.nextLong();\n    	String s;\n    	s=sc.next();\n    	for(i=0;i<l;i++)\n    	{\n    		if ((s.charAt((int)i)-'0')%2==0) count+=(i+1);\n    	}\n    	System.out.println(count);\n	}\n}\n","implementation,strings"
"import java.util.*;\npublic class EvenSubstrings {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		String s[]=sc.next().split("""");\n		int ans=0;\n		for(int i=0;i<n;i++) {\n			if(Integer.parseInt(s[i])%2==0) {\n				ans=ans+(i+1);\n			}\n		}\n		System.out.println(ans);\n\n	}\n\n}\n","implementation,strings"
"//package com.company;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static class Task {\n        // a1 * dx + b1\n        public class Pair { // p.a * deltaA + p.b + deltaB\n            long a, b;\n            public Pair(long a, long b) {\n                this.a = a;\n                this.b = b;\n            }\n\n            public long evalB() {\n                return b + a * deltaA + deltaB;\n            }\n        }\n\n        public boolean check(Pair a, Pair b, Pair c) { // a -> b -> c\n//            long intersect1 = (c.evalB() - b.evalB()) / (b.a - c.a);\n//            long intersect2 = (b.evalB() - a.evalB()) / (a.a - b.a);\n//            System.err.println(a.a + "" "" + a.evalB());\n//            System.err.println(b.a + "" "" + b.evalB());\n//            System.err.println(c.a + "" "" + c.evalB());\n//            System.err.println(""A "" + (c.evalB() - b.evalB()) * (a.a - b.a));\n//            System.err.println(""B "" + (b.evalB() - a.evalB()) * (b.a - c.a));\n            return (c.evalB() - b.evalB()) * (a.a - b.a) >= (b.evalB() - a.evalB()) * (b.a - c.a);\n        }\n\n        public boolean check2(Pair a, Pair b) {\n            return a.evalB() <= b.evalB();\n        }\n\n        Pair[] convexHull;\n        int idx = 0;\n        long deltaA, deltaB;\n        public void addPair(Pair p) {\n            if (idx >= 1 && p.evalB() >= convexHull[idx - 1].evalB()) return;\n//            System.err.println(""Add "" + p.a + "" "" + p.evalB());\n            while (idx >= 2 && check(convexHull[idx - 2], convexHull[idx - 1], p)) {\n                idx--;\n            }\n            convexHull[idx++] = p;\n        }\n\n        public void globalAdd(long da, long db) {\n            deltaA += da;\n            deltaB += db;\n            while (idx >= 2 && check2(convexHull[idx - 2], convexHull[idx - 1])) {\n                idx--;\n            }\n        }\n\n        public void solve(Scanner sc, PrintWriter pw) throws IOException {\n            convexHull = new Pair[300010];\n            addPair(new Pair(0, 0));\n            int n = sc.nextInt();\n            int m = sc.nextInt();\n            for (int i = 0; i < m; i++) {\n                int t = sc.nextInt();\n                if (t == 1) {\n                    int k = sc.nextInt();\n                    n += k;\n                    idx = 0;\n                    deltaA = deltaB = 0;\n                    addPair(new Pair(0, 0));\n                } else if (t == 2) {\n                    int k = sc.nextInt();\n                    Pair p = new Pair(n, 0);\n                    long negB = p.evalB();\n                    p.b -= negB;\n                    addPair(p);\n                    n += k;\n                } else {\n                    int b = sc.nextInt();\n                    int s = sc.nextInt();\n                    globalAdd(s, b);\n                }\n                pw.println((convexHull[idx - 1].a + 1) + "" "" + convexHull[idx - 1].evalB());\n\n//                pw.print((convexHull[idx - 1].a + 1) + "" "" + convexHull[idx - 1].evalB() + "" ----- "");\n//                if (idx >= 2)\n//                    pw.println((convexHull[idx - 2].a + 1) + "" "" + convexHull[idx - 2].evalB());\n//                else\n//                    pw.println();\n            }\n        }\n    }\n\n    static long TIME_START, TIME_END;\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n//        Scanner sc = new Scanner(new FileInputStream(""input""));\n        PrintWriter pw = new PrintWriter(new BufferedOutputStream(System.out));\n//        PrintWriter pw = new PrintWriter(new FileOutputStream(""output""));\n\n\n        Runtime runtime = Runtime.getRuntime();\n        long usedMemoryBefore = runtime.totalMemory() - runtime.freeMemory();\n        TIME_START = System.currentTimeMillis();\n        Task t = new Task();\n        t.solve(sc, pw);\n        TIME_END = System.currentTimeMillis();\n        long usedMemoryAfter = runtime.totalMemory() - runtime.freeMemory();\n        pw.close();\n        System.err.println(""Memory increased: "" + (usedMemoryAfter - usedMemoryBefore) / 1000000);\n        System.err.println(""Time used: "" + (TIME_END - TIME_START) + ""."");\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public Scanner(FileReader s) throws FileNotFoundException {\n            br = new BufferedReader(s);\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n}","data structures,greedy"
"import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class E {\n	static PrintWriter out = new PrintWriter(System.out);\n\n	static long totalSize, totalM, totalB;\n	public static void main(String[] args) {\n		FS in = new FS();\n		totalSize = in.nextLong();\n		int Q = in.nextInt();\n		\n		Node last = new Node(0, 0);\n		TreeSet<Node> ts = new TreeSet<Node>();\n		\n		for(int qq = 0; qq < Q; qq++) {\n			int type = in.nextInt();\n			if(type == 1) {\n				long k = in.nextLong();\n				totalSize += k;\n				ts.clear();\n				last = new Node(0, 0);\n			}\n			if(type == 2) {\n				long k = in.nextLong();\n				last.update();\n				if(last.val > 0) {\n					Node next = new Node(totalSize, 0);\n					last.left = next;\n					next.right = last;\n					ts.add(last.calc());\n					last = next;\n				}\n				totalSize += k;\n			}\n			if(type == 3) {\n				long b = in.nextLong();\n				long m = in.nextLong();\n				\n				totalM += m;\n				totalB += b;\n				while(!ts.isEmpty() && totalM >= ts.first().takeover) {\n					// Node x takesover his neighbor\n					Node x = ts.pollFirst();\n					x.update();\n					ts.remove(x.left);\n					x.left.update();\n					\n					x.left = x.left.left;\n					if(x.left == null) {\n						last = x;\n					}\n					else {\n						x.left.right = x;\n						ts.add(x.calc());\n					}\n\n				}\n				\n			}\n			last.update();\n			\n			out.println((last.index+1)+"" ""+last.val);\n		}\n		out.close();\n	}\n	\n	static class Node implements Comparable<Node> {\n		long index, val;\n		long lastm, lastb; // vals to push\n		long takeover;\n		Node left, right;\n		public Node(long ind, long v) {\n			index = ind;\n			val = v;\n			lastm = totalM;\n			lastb = totalB;\n			takeover = -1;\n		}\n		\n		void update() {\n			val += (totalB-lastb) + index * (totalM - lastm);\n			lastm = totalM;\n			lastb = totalB;\n		}\n		\n		Node calc() {\n			// find when I beat the guy to the left of me\n			update();\n			left.update();\n			\n			long ma = (left.val - val) / (index - left.index);\n			while(val + ma*index > left.val + ma*left.index) ma++;\n			\n			takeover = lastm + ma;\n			return this;\n		}\n		\n		@Override\n		public int compareTo(Node o) {\n			if(takeover != o.takeover) return Long.compare(takeover, o.takeover);\n			return Long.compare(index, o.index);\n		}\n		\n		@Override\n		public String toString() {\n			return ""[id = ""+index+"" val = ""+val+""  take = ""+takeover+""]"";\n		}\n	}\n	\n	static class FS{\n		BufferedReader br;\n		StringTokenizer st;\n		public FS() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n		String next() {\n			while(st == null || !st.hasMoreElements()) {\n				try {st = new StringTokenizer(br.readLine());}\n				catch(Exception e) { throw null;}\n			}\n			return st.nextToken();\n		}\n		int nextInt() { return Integer.parseInt(next());}\n		double nextDouble() { return Double.parseDouble(next());}\n		long nextLong() { return Long.parseLong(next());}\n		int[] NIA(int n) {\n			int r[] = new int[n];\n			for(int i = 0; i < n; i++) r[i] = nextInt();\n			return r;\n		}\n		long[] NLA(int n) {\n			long r[] = new long[n];\n			for(int i = 0; i < n; i++) r[i] = nextLong();\n			return r;\n		}\n		char[][] grid(int r, int c){\n			char res[][] = new char[r][c];\n			for(int i = 0; i < r; i++) {\n				char l[] = next().toCharArray();\n				for(int j = 0; j < c; j++) {\n					res[i][j] = l[j];\n				}\n			}\n			return res;\n		}\n	}\n	\n}\n","data structures,greedy"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TrainCar solver = new TrainCar();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TrainCar {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int N = in.nextInt();\n            int M = in.nextInt();\n            MaintainMin min = new MaintainMin(N);\n            while (M-- > 0) {\n                int a = in.nextInt();\n                if (a == 1) {\n                    min.addFront(in.nextInt());\n                } else if (a == 2) {\n                    min.addBack(in.nextInt());\n                } else {\n                    min.inc(in.nextInt(), in.nextInt());\n                }\n                out.println(min.getIndex() + "" "" + min.getVal());\n            }\n        }\n\n        long xIntersect(long[] a, long[] b) {\n            return Math.floorDiv(a[3] - b[3] - 1, (b[2] - a[2]));\n        }\n\n        class Node {\n            Node next;\n            long[] line;\n\n            Node(long[] line) {\n                this.line = line;\n            }\n\n        }\n\n        class MaintainMin {\n            Node first;\n            Node cur;\n            long bSum = 0;\n            long sSum = 0;\n            int N;\n\n            MaintainMin(int N) {\n                this.N = N;\n                first = new Node(new long[]{-Long.MAX_VALUE, Long.MAX_VALUE, 0, -bSum});\n                cur = first;\n            }\n\n            void addFront(int k) {\n                first = new Node(new long[]{Long.MAX_VALUE, Long.MAX_VALUE, 0, -bSum});\n                cur = first;\n                N += k;\n            }\n\n            void addBack(int k) {\n                long[] next = new long[]{Long.MIN_VALUE, 0, N, -bSum - N * sSum};\n                N += k;\n                upd(first, next);\n            }\n\n            void inc(long b, long s) {\n                bSum += b;\n                sSum += s;\n                while (cur.line[1] < sSum) {\n                    cur = cur.next;\n                }\n            }\n\n            long getIndex() {\n                return cur.line[2] + 1;\n            }\n\n            long getVal() {\n                return (cur.line[2] * sSum + cur.line[3] + bSum);\n            }\n\n            void upd(Node u, long[] next) {\n                long x = xIntersect(u.line, next);\n                if (x >= u.line[1]) {\n                    upd(u.next, next);\n                } else {\n                    next[1] = x;\n                    first = new Node(next);\n                    u.line[0] = x + 1;\n                    first.next = u;\n                    if (sSum <= first.line[1]) {\n                        cur = first;\n                    }\n                }\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n","data structures,greedy"
"import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class E {\n\n	static class Line {\n		long k, b;\n\n		public Line(long k, long b) {\n			this.k = k;\n			this.b = b;\n		}\n\n		long at(long x) {\n			return k * x + b;\n		}\n	}\n\n	void submit() {\n		int tot = nextInt();\n		int qs = nextInt();\n\n		Line[] h = new Line[qs + 1];\n		int sz = 0;\n		h[sz++] = new Line(0, 0);\n\n		long base = 0;\n\n		long x = 0;\n\n		int lastType = 1;\n\n		while (qs-- > 0) {\n			int type = nextInt();\n			if (type == 1) {\n				int k = nextInt();\n				tot += k;\n				sz = 0;\n				h[sz++] = new Line(0, 0);\n				x = 0;\n				base = 0;\n\n				out.println(""1 0"");\n				lastType = 1;\n\n				continue;\n			}\n\n			if (type == 2) {\n				int k = nextInt();\n				Line q = new Line(tot, -base - tot * x);\n\n				tot += k;\n\n				if (lastType == 1) {\n					out.println(""1 0"");\n					lastType = 2;\n					continue;\n				}\n				if (lastType == 2) {\n					out.println((h[sz - 1].k + 1) + "" "" + (h[sz - 1].at(x) + base));\n					lastType = 2;\n					continue;\n				}\n\n				while (sz > 1 && bad(h[sz - 2], h[sz - 1], q)) {\n					// kicking sz - 1 out\n//					System.err.println(""YEP"");\n					sz--;\n				}\n				h[sz++] = q;\n				out.println((h[sz - 1].k + 1) + "" "" + (h[sz - 1].at(x) + base));\n				lastType = 2;\n				continue;\n			}\n\n			if (type != 3) {\n				throw new AssertionError();\n			}\n\n			base += nextLong();\n			long deltaX = nextLong();\n\n			x += deltaX;\n			while (sz > 1 && h[sz - 1].at(x) >= h[sz - 2].at(x)) {\n				sz--;\n			}\n\n			lastType = 3;\n			out.println((h[sz - 1].k + 1) +  "" "" + (h[sz - 1].at(x) + base));\n		}\n	}\n\n	boolean bad(Line p, Line q, Line r) {\n		return p.k * (q.b - r.b) + q.k * (r.b - p.b) + r.k * (p.b - q.b) <= 0;\n	}\n\n	void test() {\n\n	}\n\n	void stress() {\n		for (int tst = 0;; tst++) {\n			if (false) {\n				throw new AssertionError();\n			}\n			System.err.println(tst);\n		}\n	}\n\n	E() throws IOException {\n		is = System.in;\n		out = new PrintWriter(System.out);\n		submit();\n		// stress();\n		// test();\n		out.close();\n	}\n\n	static final Random rng = new Random();\n	static final int C = 5;\n\n	static int rand(int l, int r) {\n		return l + rng.nextInt(r - l + 1);\n	}\n\n	public static void main(String[] args) throws IOException {\n		new E();\n	}\n\n	private InputStream is;\n	PrintWriter out;\n\n	private byte[] buf = new byte[1 << 14];\n	private int bufSz = 0, bufPtr = 0;\n\n	private int readByte() {\n		if (bufSz == -1)\n			throw new RuntimeException(""Reading past EOF"");\n		if (bufPtr >= bufSz) {\n			bufPtr = 0;\n			try {\n				bufSz = is.read(buf);\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n			if (bufSz <= 0)\n				return -1;\n		}\n		return buf[bufPtr++];\n	}\n\n	private boolean isTrash(int c) {\n		return c < 33 || c > 126;\n	}\n\n	private int skip() {\n		int b;\n		while ((b = readByte()) != -1 && isTrash(b))\n			;\n		return b;\n	}\n\n	String nextToken() {\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b)) {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	String nextString() {\n		int b = readByte();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b) || b == ' ') {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	double nextDouble() {\n		return Double.parseDouble(nextToken());\n	}\n\n	char nextChar() {\n		return (char) skip();\n	}\n\n	int nextInt() {\n		int ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n\n	long nextLong() {\n		long ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n}\n","data structures,greedy"
"import java.util.*;\n\npublic class Algo{\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int n = scan.nextInt();\n		int counter = 0, positive = 0 , nega = 0;\n		for(int i = 0 ;i< n ; i++){\n			int x = scan.nextInt();\n			if(x!=0)counter++;\n			if(x>0)positive++;\n			if(x<0)nega++;\n		}\n		if(positive>=(n+1)/2){\n		System.out.println(1);\n		}\n		else if(nega>=(n+1)/2)\n		System.out.println(-1);\n\n		else\n		System.out.println(0);\n	}\n}",implementation
"import java.util.*;\n\npublic class Algo{\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int n = scan.nextInt();\n		int counter = 0, positive = 0 , nega = 0;\n		for(int i = 0 ;i< n ; i++){\n			int x = scan.nextInt();\n			if(x!=0)counter++;\n			if(x>0)positive++;\n			if(x<0)nega++;\n		}\n		if(positive>=(n+1)/2){\n		System.out.println(1);\n		}\n		else if(nega>=(n+1)/2)\n		System.out.println(-1);\n\n		else\n		System.out.println(0);\n	}\n}",implementation
"import java.util.*;\npublic class MyClass {\n    public static void main(String args[]) {\n      Scanner sc=new Scanner(System.in);\n  int n=sc.nextInt();\n  int arr[]=new int[n];\n  int i,p=0,h=0,k;\n  for(i=0;i<n;i++)\n  {\n      arr[i]=sc.nextInt();\n      if(arr[i]>0)\n      ++p;\n      else if(arr[i]<0)\n      ++h;\n  }\n  if(n%2==0)\n  k=n/2;\n  else\n  k=(n/2) +1 ;\n  if(p>=k)\n  System.out.println(""4"");\n  else if(h>=k)\n  System.out.println(""-4"");\n  else\n  System.out.println(""0"");\n    }}\n  \n  \n  \n  \n  \n  \n  \n  \n  ",implementation
import java.util.Scanner;\n\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int positive = 0;\n		int negative = 0;\n		\n		\n		for(int i=0;i<n;i++) {\n			int s = sc.nextInt();\n			if(s==0) continue;\n			if(s<0) negative ++;\n			else positive ++;\n		}\n		\n		if(negative >= n/2.0) {\n			System.out.println(-1);\n			return;\n		}\n		if(positive >= n/2.0) {\n			System.out.println(1);\n			return;\n		}\n		System.out.println(0);\n	}\n}\n\n\n,implementation
"import java.util.*;\npublic class Main\n{\n	public static void main(String[]args)\n	{\n		Scanner in=new Scanner(System.in);\n		int n,i,j,t,cent,max;\n		int []s=new int[1000];\n		int []b=new int[200001];\n		n=in.nextInt();\n		for(i=0;i<n;i++)\n		{\n			s[i]=in.nextInt();\n		}\n		for(i=0;i<n-1;i++)\n		{\n			for(j=i+1;j<n;j++)\n			{\n				t=s[i]+s[j];\n				b[t]++;\n			}\n		}\n		max=0;\n		for(i=2;i<200000;i++)\n		{\n			if(b[i]>max)\n			{\n				max=b[i];\n			}\n		}\n		System.out.println(max);\n	}\n}\n		  	  	  		 	 	   		  	 	 		","brute force,implementation"
import java.io.*;\nimport java.util.*;\n\npublic class Main \n{\n	static Scanner sc = new Scanner(System.in);\n	public static void main (String[] args) \n	{\n		int n = sc.nextInt();\n		int[] a = new int[n];\n		for(int i=0; i<n; i++) a[i]=sc.nextInt();\n		\n		int mxN = 200001;\n		int[] c = new int[mxN];\n		for(int i=0; i<n; i++) \n		{\n		    for(int j=i+1; j<n; j++)\n		        c[a[i]+a[j]]++;\n		}\n		\n		int ans=0;\n		for(int i=0; i<mxN; i++) \n		    if(c[i]>ans) ans=c[i];\n		System.out.println(ans);\n	}\n},"brute force,implementation"
import java.io.*;\nimport java.util.*;\n \npublic class Demo \n{\n	\n	public static void main (String[] args) \n	{\n	    Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int[] a = new int[n];\n		for(int i=0; i<n; i++) a[i]=sc.nextInt();\n		\n		int mxN = 200001;\n		int[] c = new int[mxN];\n		for(int i=0; i<n; i++) \n		{\n		    for(int j=i+1; j<n; j++)\n		        c[a[i]+a[j]]++;\n		}\n		\n		int ans=0;\n		for(int i=0; i<mxN; i++) \n		    if(c[i]>ans) ans=c[i];\n		System.out.println(ans);\n	}\n},"brute force,implementation"
"import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int a[]=new int[n];\n        for(int i=0;i<n;i++) \n        a[i]=sc.nextInt();\n        HashMap<Integer,Integer> map=new HashMap<>();\n        for(int i=0;i<n-1;i++) {\n            for(int j=i+1;j<n;j++) {\n                map.put(a[i]+a[j],map.getOrDefault(a[i]+a[j],0)+1);\n            }\n        }\n        int max=0;\n        for(int e :map.values()) \n        max=Math.max(e,max);\n        System.out.println(max);\n    }\n}","brute force,implementation"
"import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class cfGlobal2H {\n\n	static final int P = 998244353;\n	static final int INV2 = (P + 1) / 2;\n\n	void fwhtMod(int[] a) {\n		int n = a.length;\n		for (int s = 1; s < n; s <<= 1) {\n			for (int i = 0; i < n; i += s << 1) {\n				for (int j = i; j < i + s; j++) {\n					int k = j + s;\n\n					int v = a[j];\n					int u = a[k];\n\n					a[j] += u;\n					if (a[j] >= P) {\n						a[j] -= P;\n					}\n\n					a[k] = v - u;\n					if (a[k] < 0) {\n						a[k] += P;\n					}\n\n				}\n			}\n		}\n	}\n\n	static final int M = 3;\n\n	static final boolean test(int mask, int i) {\n		return ((mask >> i) & 1) == 1;\n	}\n\n	void submit() {\n		int n = nextInt();\n		int k = nextInt();\n\n		int[] xs = new int[M];\n		for (int i = 0; i < M; i++) {\n			xs[i] = nextInt();\n		}\n\n		int[] arr = new int[1 << (k + M)];\n\n		for (int i = 0; i < n; i++) {\n			int[] tmp = new int[M];\n			for (int j = 0; j < M; j++) {\n				tmp[j] = nextInt();\n			}\n\n			for (int mask = 0; mask < 1 << M; mask++) {\n				int idx = mask << k;\n				for (int j = 0; j < M; j++) {\n					if (test(mask, j)) {\n						idx ^= tmp[j];\n					}\n				}\n				// System.err.println(mask + "" "" + idx);\n				arr[idx]++;\n			}\n		}\n\n		fwhtMod(arr);\n\n		int[][] ps = new int[1 << M][];\n\n		for (int i = 0; i < 1 << M; i++) {\n			int sum = 0;\n			for (int j = 0; j < M; j++) {\n				if (test(i, j)) {\n					sum -= xs[j];\n					if (sum < 0) {\n						sum += P;\n					}\n				} else {\n					sum += xs[j];\n					if (sum >= P) {\n						sum -= P;\n					}\n				}\n\n			}\n			ps[i] = pows(sum, n);\n		}\n\n		int i2m = 1;\n		for (int i = 0; i < M; i++) {\n			i2m = (int) ((long) i2m * INV2 % P);\n		}\n\n		for (int i = 0; i < arr.length; i++) {\n			arr[i] = (int) ((long) arr[i] * i2m % P);\n		}\n\n		int[] ans = new int[1 << k];\n		for (int i = 0; i < 1 << k; i++) {\n			ans[i] = 1;\n			for (int j = 0; j < 1 << M; j++) {\n				ans[i] = (int) ((long) ans[i] * ps[j][arr[i | (j << k)]] % P);\n			}\n		}\n\n		fwhtMod(ans);\n\n		long inv2k = 1;\n		for (int i = 0; i < k; i++) {\n			inv2k = inv2k * INV2 % P;\n		}\n\n		for (int i = 0; i < ans.length; i++) {\n			out.print(ans[i] * inv2k % P + "" "");\n		}\n		out.println();\n	}\n\n	int[] pows(int x, int b) {\n		int[] ret = new int[b + 1];\n		ret[0] = 1;\n		for (int i = 1; i < ret.length; i++) {\n			ret[i] = (int) ((long) ret[i - 1] * x % P);\n		}\n		return ret;\n	}\n\n	int f(long x) {\n		// return (int) Math.floorMod(x, P);\n		x %= P;\n		return (int) (x < 0 ? x + P : x);\n	}\n\n	void test() {\n	}\n\n	void stress() {\n		for (int tst = 0;; tst++) {\n			if (false) {\n				throw new AssertionError();\n			}\n			System.err.println(tst);\n		}\n	}\n\n	cfGlobal2H() throws IOException {\n		is = System.in;\n		out = new PrintWriter(System.out);\n		submit();\n		// stress();\n		// test();\n		out.close();\n	}\n\n	static final Random rng = new Random();\n	static final int C = 5;\n\n	static int rand(int l, int r) {\n		return l + rng.nextInt(r - l + 1);\n	}\n\n	public static void main(String[] args) throws IOException {\n		new cfGlobal2H();\n	}\n\n	private InputStream is;\n	PrintWriter out;\n\n	private byte[] buf = new byte[1 << 14];\n	private int bufSz = 0, bufPtr = 0;\n\n	private int readByte() {\n		if (bufSz == -1)\n			throw new RuntimeException(""Reading past EOF"");\n		if (bufPtr >= bufSz) {\n			bufPtr = 0;\n			try {\n				bufSz = is.read(buf);\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n			if (bufSz <= 0)\n				return -1;\n		}\n		return buf[bufPtr++];\n	}\n\n	private boolean isTrash(int c) {\n		return c < 33 || c > 126;\n	}\n\n	private int skip() {\n		int b;\n		while ((b = readByte()) != -1 && isTrash(b))\n			;\n		return b;\n	}\n\n	String nextToken() {\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b)) {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	String nextString() {\n		int b = readByte();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b) || b == ' ') {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	double nextDouble() {\n		return Double.parseDouble(nextToken());\n	}\n\n	char nextChar() {\n		return (char) skip();\n	}\n\n	int nextInt() {\n		int ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n\n	long nextLong() {\n		long ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n}\n","fft,math"
"import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class cfGlobal2H {\n\n	static final int P = 998244353;\n	static final int INV2 = (P + 1) / 2;\n\n	void fwhtJust(int[] a) {\n		int n = a.length;\n		for (int s = 1; s < n; s <<= 1) {\n			for (int i = 0; i < n; i += s << 1) {\n				for (int j = i; j < i + s; j++) {\n					int k = j + s;\n\n					int v = a[j];\n					int u = a[k];\n\n					a[j] += u;\n//					if (a[j] >= P) {\n//						a[j] -= P;\n//					}\n\n					a[k] = v - u;\n//					if (a[k] < 0) {\n//						a[k] += P;\n//					}\n\n				}\n			}\n		}\n	}\n	\n	void fwhtMod(int[] a) {\n		int n = a.length;\n		for (int s = 1; s < n; s <<= 1) {\n			for (int i = 0; i < n; i += s << 1) {\n				for (int j = i; j < i + s; j++) {\n					int k = j + s;\n\n					int v = a[j];\n					int u = a[k];\n\n					a[j] += u;\n					if (a[j] >= P) {\n						a[j] -= P;\n					}\n\n					a[k] = v - u;\n					if (a[k] < 0) {\n						a[k] += P;\n					}\n\n				}\n			}\n		}\n	}\n\n	void submit() {\n		int n = nextInt();\n		int k = nextInt();\n\n		long x = nextInt();\n		long y = nextInt();\n		long z = nextInt();\n\n		int[] m1 = new int[n];\n		int[] m2 = new int[n];\n\n		int xorAll = 0;\n\n		for (int i = 0; i < n; i++) {\n			int a = nextInt();\n			int b = nextInt();\n			int c = nextInt();\n			xorAll ^= a;\n			m1[i] = a ^ b;\n			m2[i] = a ^ c;\n		}\n\n		int[] justB = new int[1 << k];\n		int[] justC = new int[1 << k];\n		int[] justXor = new int[1 << k];\n		for (int i = 0; i < n; i++) {\n			justB[m1[i]]++;\n			justC[m2[i]]++;\n			justXor[m1[i] ^ m2[i]]++;\n		}\n\n		fwhtJust(justB);\n		fwhtJust(justC);\n		fwhtJust(justXor);\n\n		int[][] ps = { pows(f(x + y + z), n), pows(f(x - y + z), n),\n				pows(f(x + y - z), n), pows(f(x - y - z), n) };\n\n		int[] arr = new int[1 << k];\n		for (int i = 0; i < 1 << k; i++) {\n			int[] xs = solve(n, justB[i], justC[i], justXor[i]);\n			arr[i] = 1;\n			for (int j = 0; j < 4; j++) {\n				arr[i] = (int) ((long) arr[i] * ps[j][xs[j]] % P);\n			}\n		}\n\n		fwhtMod(arr);\n\n		long inv2k = 1;\n		for (int i = 0; i < k; i++) {\n			inv2k = inv2k * INV2 % P;\n		}\n\n		for (int i = 0; i < arr.length; i++) {\n			out.print(arr[i ^ xorAll] * inv2k % P + "" "");\n		}\n		out.println();\n	}\n\n	int[] solve(int all, int yw, int zw, int yz) {\n		yw = (all - yw) / 2;\n		zw = (all - zw) / 2;\n		yz = (all - yz) / 2;\n\n		int yzw = (yw + zw + yz) / 2;\n		int y = yzw - zw;\n		int z = yzw - yw;\n		int w = yzw - yz;\n\n		int x = all - y - z - w;\n		return new int[] { x, y, z, w };\n	}\n\n	int[] pows(int x, int b) {\n		int[] ret = new int[b + 1];\n		ret[0] = 1;\n		for (int i = 1; i < ret.length; i++) {\n			ret[i] = (int) ((long) ret[i - 1] * x % P);\n		}\n		return ret;\n	}\n\n	int f(long x) {\n		return (int) Math.floorMod(x, P);\n	}\n\n	void test() {\n	}\n\n	void stress() {\n		for (int tst = 0;; tst++) {\n			if (false) {\n				throw new AssertionError();\n			}\n			System.err.println(tst);\n		}\n	}\n\n	cfGlobal2H() throws IOException {\n		is = System.in;\n		out = new PrintWriter(System.out);\n		submit();\n		// stress();\n		// test();\n		out.close();\n	}\n\n	static final Random rng = new Random();\n	static final int C = 5;\n\n	static int rand(int l, int r) {\n		return l + rng.nextInt(r - l + 1);\n	}\n\n	public static void main(String[] args) throws IOException {\n		new cfGlobal2H();\n	}\n\n	private InputStream is;\n	PrintWriter out;\n\n	private byte[] buf = new byte[1 << 14];\n	private int bufSz = 0, bufPtr = 0;\n\n	private int readByte() {\n		if (bufSz == -1)\n			throw new RuntimeException(""Reading past EOF"");\n		if (bufPtr >= bufSz) {\n			bufPtr = 0;\n			try {\n				bufSz = is.read(buf);\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n			if (bufSz <= 0)\n				return -1;\n		}\n		return buf[bufPtr++];\n	}\n\n	private boolean isTrash(int c) {\n		return c < 33 || c > 126;\n	}\n\n	private int skip() {\n		int b;\n		while ((b = readByte()) != -1 && isTrash(b))\n			;\n		return b;\n	}\n\n	String nextToken() {\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b)) {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	String nextString() {\n		int b = readByte();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b) || b == ' ') {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	double nextDouble() {\n		return Double.parseDouble(nextToken());\n	}\n\n	char nextChar() {\n		return (char) skip();\n	}\n\n	int nextInt() {\n		int ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n\n	long nextLong() {\n		long ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n}\n","fft,math"
"\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\n\npublic class CF1119H {\n    public static void main(String[] args) throws Exception {\n        boolean local = System.getProperty(""ONLINE_JUDGE"") == null;\n        boolean async = false;\n\n        Charset charset = Charset.forName(""ascii"");\n\n        FastIO io = local ? new FastIO(new FileInputStream(""D:\\DATABASE\\TESTCASE\\Code.in""), System.out, charset) : new FastIO(System.in, System.out, charset);\n        Task task = new Task(io, new Debug(local));\n\n        if (async) {\n            Thread t = new Thread(null, task, ""dalt"", 1 << 27);\n            t.setPriority(Thread.MAX_PRIORITY);\n            t.start();\n            t.join();\n        } else {\n            task.run();\n        }\n\n        if (local) {\n            io.cache.append(""\n\n--memory -- \n"" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + ""M"");\n        }\n\n        io.flush();\n    }\n\n    public static class Task implements Runnable {\n        final FastIO io;\n        final Debug debug;\n        int inf = (int) 1e8;\n        static int mod = 998244353;\n        static long inv2 = Mathematics.inverse(2, mod);\n\n        public Task(FastIO io, Debug debug) {\n            this.io = io;\n            this.debug = debug;\n        }\n\n        @Override\n        public void run() {\n            solve();\n        }\n\n        public void solve() {\n            int n = io.readInt();\n            int k = 1 << io.readInt();\n            long actualA = io.readInt();\n            long actualB = io.readInt();\n            long actualC = io.readInt();\n\n            int[][] points = new int[3][n];\n            int sumXor = 0;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < 3; j++) {\n                    points[j][i] = io.readInt();\n                }\n                sumXor ^= points[0][i];\n            }\n\n            long[][] ps = new long[4][k];\n\n            for (int i = 0; i < n; i++) {\n                int p1 = 0;\n                int p2 = points[0][i] ^ points[1][i];\n                int p3 = points[0][i] ^ points[2][i];\n                int p4 = p2 ^ p3;\n\n                ps[0][p1] += 1;\n                ps[1][p2] += 1;\n                ps[2][p3] += 1;\n                ps[3][p4] += 1;\n            }\n\n            for (int i = 0; i < 4; i++) {\n                XorFWT(ps[i], 0, k - 1);\n            }\n\n            int[] p = new int[k];\n            for (int i = 0; i < k; i++) {\n\n                long x = (ps[0][i] + ps[1][i] + ps[2][i] + ps[3][i]) / 4;\n                long y = (ps[0][i] + ps[3][i]) / 2 - x;\n                long z = (ps[0][i] + ps[1][i]) / 2 - x;\n                long w = (ps[0][i] + ps[2][i]) / 2 - x;\n\n                p[i] = 1;\n                p[i] = (int) ((long) p[i] * Mathematics.pow(Mathematics.mod(actualA + actualB + actualC + 0, mod), Mathematics.mod(x, mod - 1), mod) % mod);\n                p[i] = (int) ((long) p[i] * Mathematics.pow(Mathematics.mod(actualA - actualB - actualC + 0, mod), Mathematics.mod(y, mod - 1), mod) % mod);\n                p[i] = (int) ((long) p[i] * Mathematics.pow(Mathematics.mod(actualA + actualB - actualC + 0, mod), Mathematics.mod(z, mod - 1), mod) % mod);\n                p[i] = (int) ((long) p[i] * Mathematics.pow(Mathematics.mod(actualA - actualB + actualC + 0, mod), Mathematics.mod(w, mod - 1), mod) % mod);\n            }\n\n            XorIFWT(p, 0, k - 1);\n            for (int i = 0; i < k; i++) {\n                io.cache.append(p[i ^ sumXor]).append(' ');\n            }\n        }\n\n        public static void XorFWT(long[] p, int l, int r) {\n            if (l == r) {\n                return;\n            }\n            int m = (l + r) >> 1;\n            XorFWT(p, l, m);\n            XorFWT(p, m + 1, r);\n            for (int i = 0, until = m - l; i <= until; i++) {\n                long a = p[l + i];\n                long b = p[m + 1 + i];\n                p[l + i] = a + b;\n                p[m + 1 + i] = a - b;\n            }\n        }\n\n        public static void XorIFWT(int[] p, int l, int r) {\n            if (l == r) {\n                return;\n            }\n            int m = (l + r) >> 1;\n            for (int i = 0, until = m - l; i <= until; i++) {\n                int a = p[l + i];\n                int b = p[m + 1 + i];\n                p[l + i] = Mathematics.mod((a + b) * inv2, mod);\n                p[m + 1 + i] = Mathematics.mod((a - b) * inv2, mod);\n            }\n            XorIFWT(p, l, m);\n            XorIFWT(p, m + 1, r);\n        }\n    }\n\n\n    public static class Mathematics {\n\n        public static int ceilPowerOf2(int x) {\n            return 32 - Integer.numberOfLeadingZeros(x - 1);\n        }\n\n        public static int floorPowerOf2(int x) {\n            return 31 - Integer.numberOfLeadingZeros(x);\n        }\n\n        public static long modmul(long a, long b, long mod) {\n            return b == 0 ? 0 : ((modmul(a, b >> 1, mod) << 1) % mod + a * (b & 1)) % mod;\n        }\n\n        /**\n         * Get the greatest common divisor of a and b\n         */\n        public static int gcd(int a, int b) {\n            return a >= b ? gcd0(a, b) : gcd0(b, a);\n        }\n\n        private static int gcd0(int a, int b) {\n            return b == 0 ? a : gcd0(b, a % b);\n        }\n\n        public static int extgcd(int a, int b, int[] coe) {\n            if (a >= b) {\n                return extgcd0(a, b, coe);\n            } else {\n                int g = extgcd0(b, a, coe);\n                int tmp = coe[0];\n                coe[0] = coe[1];\n                coe[1] = tmp;\n                return g;\n            }\n        }\n\n        private static int extgcd0(int a, int b, int[] coe) {\n            if (b == 0) {\n                coe[0] = 1;\n                coe[1] = 0;\n                return a;\n            }\n            int g = extgcd0(b, a % b, coe);\n            int n = coe[0];\n            int m = coe[1];\n            coe[0] = m;\n            coe[1] = n - m * (a / b);\n            return g;\n        }\n\n        /**\n         * Get the greatest common divisor of a and b\n         */\n        public static long gcd(long a, long b) {\n            return a >= b ? gcd0(a, b) : gcd0(b, a);\n        }\n\n        private static long gcd0(long a, long b) {\n            return b == 0 ? a : gcd0(b, a % b);\n        }\n\n        public static long extgcd(long a, long b, long[] coe) {\n            if (a >= b) {\n                return extgcd0(a, b, coe);\n            } else {\n                long g = extgcd0(b, a, coe);\n                long tmp = coe[0];\n                coe[0] = coe[1];\n                coe[1] = tmp;\n                return g;\n            }\n        }\n\n        private static long extgcd0(long a, long b, long[] coe) {\n            if (b == 0) {\n                coe[0] = 1;\n                coe[1] = 0;\n                return a;\n            }\n            long g = extgcd0(b, a % b, coe);\n            long n = coe[0];\n            long m = coe[1];\n            coe[0] = m;\n            coe[1] = n - m * (a / b);\n            return g;\n        }\n\n        /**\n         * Get y where x * y = 1 (% mod)\n         */\n        public static int inverse(int x, int mod) {\n            return pow(x, mod - 2, mod);\n        }\n\n        /**\n         * Get x^n(% mod)\n         */\n        public static int pow(int x, int n, int mod) {\n            int bit = 31 - Integer.numberOfLeadingZeros(n);\n            long product = 1;\n            for (; bit >= 0; bit--) {\n                product = product * product % mod;\n                if (((1 << bit) & n) != 0) {\n                    product = product * x % mod;\n                }\n            }\n            return (int) product;\n        }\n\n        public static long longpow(long x, long n, long mod) {\n            if (n == 0) {\n                return 1;\n            }\n            long prod = longpow(x, n >> 1, mod);\n            prod = modmul(prod, prod, mod);\n            if ((n & 1) == 1) {\n                prod = modmul(prod, x, mod);\n            }\n            return prod;\n        }\n\n        /**\n         * Get x % mod\n         */\n        public static int mod(int x, int mod) {\n            x %= mod;\n            if (x < 0) {\n                x += mod;\n            }\n            return x;\n        }\n\n        public static int mod(long x, int mod) {\n            x %= mod;\n            if (x < 0) {\n                x += mod;\n            }\n            return (int) x;\n        }\n\n        /**\n         * Get n!/(n-m)!\n         */\n        public static long permute(int n, int m) {\n            return m == 0 ? 1 : n * permute(n - 1, m - 1);\n        }\n\n        /**\n         * Put all primes less or equal to limit into primes after offset\n         */\n        public static int eulerSieve(int limit, int[] primes, int offset) {\n            boolean[] isComp = new boolean[limit + 1];\n            int wpos = offset;\n            for (int i = 2; i <= limit; i++) {\n                if (!isComp[i]) {\n                    primes[wpos++] = i;\n                }\n                for (int j = offset, until = limit / i; j < wpos && primes[j] <= until; j++) {\n                    int pi = primes[j] * i;\n                    isComp[pi] = true;\n                    if (i % primes[j] == 0) {\n                        break;\n                    }\n                }\n            }\n            return wpos - offset;\n        }\n\n        /**\n         * Round x into integer\n         */\n        public static int intRound(double x) {\n            if (x < 0) {\n                return -(int) (-x + 0.5);\n            }\n            return (int) (x + 0.5);\n        }\n\n        /**\n         * Round x into long\n         */\n        public static long longRound(double x) {\n            if (x < 0) {\n                return -(long) (-x + 0.5);\n            }\n            return (long) (x + 0.5);\n        }\n    }\n\n    public static class FastIO {\n        public final StringBuilder cache = new StringBuilder();\n        private final InputStream is;\n        private final OutputStream os;\n        private final Charset charset;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 8);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastIO(InputStream is, OutputStream os, Charset charset) {\n            this.is = is;\n            this.os = os;\n            this.charset = charset;\n        }\n\n        public FastIO(InputStream is, OutputStream os) {\n            this(is, os, Charset.forName(""ascii""));\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public double readDouble() {\n            boolean sign = true;\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+';\n                next = read();\n            }\n\n            long val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 + next - '0';\n                next = read();\n            }\n            if (next != '.') {\n                return sign ? val : -val;\n            }\n            next = read();\n            long radix = 1;\n            long point = 0;\n            while (next >= '0' && next <= '9') {\n                point = point * 10 + next - '0';\n                radix = radix * 10;\n                next = read();\n            }\n            double result = val + (double) point / radix;\n            return sign ? result : -result;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n        public int readLine(char[] data, int offset) {\n            int originalOffset = offset;\n            while (next != -1 && next != '\n') {\n                data[offset++] = (char) next;\n                next = read();\n            }\n            return offset - originalOffset;\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public int readString(byte[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (byte) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n        public void flush() {\n            try {\n                os.write(cache.toString().getBytes(charset));\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public boolean hasMore() {\n            skipBlank();\n            return next != -1;\n        }\n    }\n\n    public static class Debug {\n        private boolean allowDebug;\n\n        public Debug(boolean allowDebug) {\n            this.allowDebug = allowDebug;\n        }\n\n        public void assertTrue(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (!flag) {\n                fail();\n            }\n        }\n\n        public void fail() {\n            throw new RuntimeException();\n        }\n\n        public void assertFalse(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (flag) {\n                fail();\n            }\n        }\n\n        private void outputName(String name) {\n            System.out.print(name + "" = "");\n        }\n\n        public void debug(String name, int x) {\n            if (!allowDebug) {\n                return;\n            }\n\n            outputName(name);\n            System.out.println("""" + x);\n        }\n\n        public void debug(String name, long x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println("""" + x);\n        }\n\n        public void debug(String name, double x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println("""" + x);\n        }\n\n        public void debug(String name, int[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, long[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, double[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, Object x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println("""" + x);\n        }\n\n        public void debug(String name, Object... x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.deepToString(x));\n        }\n    }\n}\n","fft,math"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1117G extends PrintWriter {\n	CF1117G() { super(System.out, true); }\n	static class Scanner {\n		Scanner(InputStream in) { this.in = in; } InputStream in;\n		int k, l; byte[] bb = new byte[1 << 15];\n		byte getc() {\n			if (k >= l) {\n				k = 0;\n				try { l = in.read(bb); } catch (IOException e) { l = 0; }\n				if (l <= 0) return -1;\n			}\n			return bb[k++];\n		}\n		int nextInt() {\n			byte c = 0; while (c <= 32) c = getc();\n			int a = 0;\n			while (c > 32) { a = a * 10 + c - '0'; c = getc(); }\n			return a;\n		}\n	}\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1117G o = new CF1117G(); o.main(); o.flush();\n	}\n\n	long[] ss, cc;\n	void update(long[] ft, int i, int n, int x) {\n		while (i < n) {\n			ft[i] += x;\n			i |= i + 1;\n		}\n	}\n	long query(long[] ft, int i) {\n		long x = 0;\n		while (i >= 0) {\n			x += ft[i];\n			i &= i + 1; i--;\n		}\n		return x;\n	}\n	int[] qu, pp;\n	Integer[] ii, hh;\n	void solve(int[] aa, int n, int[] ll, int[] rr, long[] ans, int q) {\n		int cnt = 0;\n		for (int i = 0; i < n; i++) {\n			while (cnt > 0 && aa[qu[cnt - 1]] <= aa[i])\n				cnt--;\n			pp[i] = cnt == 0 ? 0 : qu[cnt - 1] + 1;\n			qu[cnt++] = i;\n		}\n		Arrays.fill(ss, 0);\n		Arrays.fill(cc, 0);\n		for (int i = 0; i < n; i++)\n			update(ss, i, n, pp[i]);\n		Arrays.sort(ii, (i, j) -> pp[i] - pp[j]);\n		Arrays.sort(hh, (i, j) -> ll[i] - ll[j]);\n		for (int h_ = 0, i_ = 0; h_ < q; h_++) {\n			int h = hh[h_], i, l = ll[h], r = rr[h];\n			while (i_ < n && pp[i = ii[i_]] < l) {\n				update(ss, i, n, -pp[i]);\n				update(cc, i, n, 1);\n				i_++;\n			}\n			ans[h] += query(ss, r) - query(ss, l - 1)\n				+ (query(cc, r) - query(cc, l - 1)) * l;\n		}\n	}\n	void main() {\n		int n = sc.nextInt();\n		int q = sc.nextInt();\n		ss = new long[n]; cc = new long[n];\n		qu = new int[n]; pp = new int[n];\n		ii = new Integer[n];\n		for (int i = 0; i < n; i++)\n			ii[i] = i;\n		hh = new Integer[q];\n		for (int h = 0; h < q; h++)\n			hh[h] = h;\n		int[] aa = new int[n];\n		for (int i = 0; i < n; i++)\n			aa[i] = sc.nextInt() - 1;\n		int[] ll = new int[q];\n		int[] rr = new int[q];\n		for (int h = 0; h < q; h++)\n			ll[h] = sc.nextInt() - 1;\n		for (int h = 0; h < q; h++)\n			rr[h] = sc.nextInt() - 1;\n		long[] ans = new long[q];\n		solve(aa, n, ll, rr, ans, q);\n		for (int i = 0, j = n - 1; i < j; i++, j--) {\n			int tmp = aa[i]; aa[i] = aa[j]; aa[j] = tmp;\n		}\n		for (int h = 0; h < q; h++) {\n			int l = n - 1 - rr[h];\n			int r = n - 1 - ll[h];\n			ll[h] = l;\n			rr[h] = r;\n		}\n		solve(aa, n, ll, rr, ans, q);\n		for (int h = 0; h < q; h++)\n			print((long) n * (rr[h] - ll[h] + 1) - ans[h] + "" "");\n		println();\n	}\n}\n",data structures
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.Writer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Niyaz Nigmatullin\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        FastPrinter out = new FastPrinter(outputStream);\n        TaskG solver = new TaskG();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskG {\n        public void solve(int testNumber, FastScanner in, FastPrinter out) {\n            int n = in.nextInt();\n            int q = in.nextInt();\n            int[] p = new int[n];\n            for (int i = 0; i < n; i++) {\n                p[i] = in.nextInt();\n            }\n            TaskG.Query[] qs = new TaskG.Query[q];\n            int[] leftQ = in.readIntArray(q);\n            int[] rightQ = in.readIntArray(q);\n            for (int i = 0; i < q; i++) {\n                qs[i] = new TaskG.Query(leftQ[i] - 1, rightQ[i] - 1);\n            }\n            solve(p, qs);\n            ArrayUtils.reverse(p);\n            for (int i = 0; i < q; i++) {\n                int v = qs[i].left;\n                qs[i].left = n - qs[i].right - 1;\n                qs[i].right = n - v - 1;\n            }\n            solve(p, qs);\n            long[] ans = new long[qs.length];\n            for (int i = 0; i < qs.length; i++) {\n                TaskG.Query e = qs[i];\n                ans[i] = e.ans + e.right - e.left + 1;\n            }\n            out.printArray(ans);\n        }\n\n        static void solve(int[] p, TaskG.Query[] qs) {\n            int n = p.length;\n            int[] stack = new int[n];\n            int sn = 0;\n            int[] left = new int[n];\n            for (int i = 0; i < n; i++) {\n                while (sn > 0 && p[stack[sn - 1]] < p[i]) --sn;\n                left[i] = sn > 0 ? stack[sn - 1] : -1;\n                stack[sn++] = i;\n            }\n            List<TaskG.Query>[] queries = new List[n];\n            List<Integer>[] opens = new List[n];\n            for (int i = 0; i < n; i++) opens[i] = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                if (left[i] >= 0) opens[left[i]].add(i);\n            }\n            for (int i = 0; i < n; i++) queries[i] = new ArrayList<>();\n            for (TaskG.Query e : qs) queries[e.left].add(e);\n            FenwickLong f1 = new FenwickLong(n);\n            Fenwick f1Count = new Fenwick(n);\n            for (int i = n - 1; i >= 0; i--) {\n                f1.add(i, i);\n                f1Count.add(i, 1);\n                for (int j : opens[i]) {\n                    f1.add(j, -j);\n                    f1Count.add(j, -1);\n                    f1.add(j, j - left[j] - 1);\n                }\n                for (TaskG.Query e : queries[i]) {\n                    e.ans += f1.getSum(e.left, e.right + 1) - (long) e.left * f1Count.getSum(e.left, e.right + 1);\n                }\n            }\n        }\n\n        static class Query {\n            int left;\n            int right;\n            long ans;\n\n            public Query(int left, int right) {\n                this.left = left;\n                this.right = right;\n            }\n\n        }\n\n    }\n\n    static class FastScanner extends BufferedReader {\n        public FastScanner(InputStream is) {\n            super(new InputStreamReader(is));\n        }\n\n        public int read() {\n            try {\n                int ret = super.read();\n//            if (isEOF && ret < 0) {\n//                throw new InputMismatchException();\n//            }\n//            isEOF = ret == -1;\n                return ret;\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n        }\n\n        static boolean isWhiteSpace(int c) {\n            return c >= 0 && c <= 32;\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isWhiteSpace(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int ret = 0;\n            while (c >= 0 && !isWhiteSpace(c)) {\n                if (c < '0' || c > '9') {\n                    throw new NumberFormatException(""digit expected "" + (char) c\n                            + "" found"");\n                }\n                ret = ret * 10 + c - '0';\n                c = read();\n            }\n            return ret * sgn;\n        }\n\n        public String readLine() {\n            try {\n                return super.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        public int[] readIntArray(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n    }\n\n    static class FastPrinter extends PrintWriter {\n        public FastPrinter(OutputStream out) {\n            super(out);\n        }\n\n        public FastPrinter(Writer out) {\n            super(out);\n        }\n\n        public void printArray(long[] a) {\n            for (int i = 0; i < a.length; i++) {\n                if (i > 0) {\n                    print(' ');\n                }\n                print(a[i]);\n            }\n            println();\n        }\n\n    }\n\n    static class Fenwick {\n        int[] a;\n\n        public Fenwick(int n) {\n            a = new int[n];\n        }\n\n        public void add(int x, int y) {\n            for (int i = x; i < a.length; i |= i + 1) {\n                a[i] += y;\n            }\n        }\n\n        public int getSum(int x) {\n            if (x >= a.length) x = a.length - 1;\n            int ret = 0;\n            for (int i = x; i >= 0; i = (i & (i + 1)) - 1) {\n                ret += a[i];\n            }\n            return ret;\n        }\n\n        public int getSum(int l, int r) {\n            return getSum(r - 1) - getSum(l - 1);\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static void reverse(int[] c, int start, int end) {\n            for (int i = start, j = end - 1; i < j; i++, j--) {\n                int t = c[i];\n                c[i] = c[j];\n                c[j] = t;\n            }\n        }\n\n        public static void reverse(int[] c) {\n            reverse(c, 0, c.length);\n        }\n\n    }\n\n    static class FenwickLong {\n        long[] a;\n\n        public FenwickLong(int n) {\n            a = new long[n];\n        }\n\n        public void add(int x, long y) {\n            for (int i = x; i < a.length; i |= i + 1) {\n                a[i] += y;\n            }\n        }\n\n        public long getSum(int x) {\n            if (x >= a.length) x = a.length - 1;\n            long ret = 0;\n            for (int i = x; i >= 0; i = (i & (i + 1)) - 1) {\n                ret += a[i];\n            }\n            return ret;\n        }\n\n        public long getSum(int l, int r) {\n            return getSum(r - 1) - getSum(l - 1);\n        }\n\n    }\n}\n\n",data structures
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.Writer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Niyaz Nigmatullin\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        FastPrinter out = new FastPrinter(outputStream);\n        TaskG solver = new TaskG();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskG {\n        public void solve(int testNumber, FastScanner in, FastPrinter out) {\n            int n = in.nextInt();\n            int q = in.nextInt();\n            int[] p = new int[n];\n            for (int i = 0; i < n; i++) {\n                p[i] = in.nextInt();\n            }\n            TaskG.Query[] qs = new TaskG.Query[q];\n            int[] leftQ = in.readIntArray(q);\n            int[] rightQ = in.readIntArray(q);\n            for (int i = 0; i < q; i++) {\n                qs[i] = new TaskG.Query(leftQ[i] - 1, rightQ[i] - 1);\n            }\n            solve(p, qs);\n            ArrayUtils.reverse(p);\n            for (int i = 0; i < q; i++) {\n                int v = qs[i].left;\n                qs[i].left = n - qs[i].right - 1;\n                qs[i].right = n - v - 1;\n            }\n            solve(p, qs);\n            long[] ans = new long[qs.length];\n            for (int i = 0; i < qs.length; i++) {\n                TaskG.Query e = qs[i];\n                ans[i] = e.ans + e.right - e.left + 1;\n            }\n            out.printArray(ans);\n        }\n\n        static void solve(int[] p, TaskG.Query[] qs) {\n            int n = p.length;\n            int[] stack = new int[n];\n            int sn = 0;\n            int[] left = new int[n];\n            for (int i = 0; i < n; i++) {\n                while (sn > 0 && p[stack[sn - 1]] < p[i]) --sn;\n                left[i] = sn > 0 ? stack[sn - 1] : -1;\n                stack[sn++] = i;\n            }\n            List<TaskG.Query>[] queries = new List[n];\n            List<Integer>[] opens = new List[n];\n            for (int i = 0; i < n; i++) opens[i] = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                if (left[i] >= 0) opens[left[i]].add(i);\n            }\n            for (int i = 0; i < n; i++) queries[i] = new ArrayList<>();\n            for (TaskG.Query e : qs) queries[e.left].add(e);\n            FenwickLong f1 = new FenwickLong(n);\n            Fenwick f1Count = new Fenwick(n);\n            FenwickLong f2 = new FenwickLong(n);\n            for (int i = n - 1; i >= 0; i--) {\n                f1.add(i, i);\n                f1Count.add(i, 1);\n                for (int j : opens[i]) {\n                    f1.add(j, -j);\n                    f1Count.add(j, -1);\n                    f2.add(j, j - left[j] - 1);\n                }\n                for (TaskG.Query e : queries[i]) {\n                    e.ans += f2.getSum(e.left, e.right + 1);\n                    e.ans += f1.getSum(e.left, e.right + 1) - (long) e.left * f1Count.getSum(e.left, e.right + 1);\n                }\n            }\n        }\n\n        static class Query {\n            int left;\n            int right;\n            long ans;\n\n            public Query(int left, int right) {\n                this.left = left;\n                this.right = right;\n            }\n\n        }\n\n    }\n\n    static class FastScanner extends BufferedReader {\n        public FastScanner(InputStream is) {\n            super(new InputStreamReader(is));\n        }\n\n        public int read() {\n            try {\n                int ret = super.read();\n//            if (isEOF && ret < 0) {\n//                throw new InputMismatchException();\n//            }\n//            isEOF = ret == -1;\n                return ret;\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n        }\n\n        static boolean isWhiteSpace(int c) {\n            return c >= 0 && c <= 32;\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isWhiteSpace(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int ret = 0;\n            while (c >= 0 && !isWhiteSpace(c)) {\n                if (c < '0' || c > '9') {\n                    throw new NumberFormatException(""digit expected "" + (char) c\n                            + "" found"");\n                }\n                ret = ret * 10 + c - '0';\n                c = read();\n            }\n            return ret * sgn;\n        }\n\n        public String readLine() {\n            try {\n                return super.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        public int[] readIntArray(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = nextInt();\n            }\n            return ret;\n        }\n\n    }\n\n    static class FastPrinter extends PrintWriter {\n        public FastPrinter(OutputStream out) {\n            super(out);\n        }\n\n        public FastPrinter(Writer out) {\n            super(out);\n        }\n\n        public void printArray(long[] a) {\n            for (int i = 0; i < a.length; i++) {\n                if (i > 0) {\n                    print(' ');\n                }\n                print(a[i]);\n            }\n            println();\n        }\n\n    }\n\n    static class Fenwick {\n        int[] a;\n\n        public Fenwick(int n) {\n            a = new int[n];\n        }\n\n        public void add(int x, int y) {\n            for (int i = x; i < a.length; i |= i + 1) {\n                a[i] += y;\n            }\n        }\n\n        public int getSum(int x) {\n            if (x >= a.length) x = a.length - 1;\n            int ret = 0;\n            for (int i = x; i >= 0; i = (i & (i + 1)) - 1) {\n                ret += a[i];\n            }\n            return ret;\n        }\n\n        public int getSum(int l, int r) {\n            return getSum(r - 1) - getSum(l - 1);\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static void reverse(int[] c, int start, int end) {\n            for (int i = start, j = end - 1; i < j; i++, j--) {\n                int t = c[i];\n                c[i] = c[j];\n                c[j] = t;\n            }\n        }\n\n        public static void reverse(int[] c) {\n            reverse(c, 0, c.length);\n        }\n\n    }\n\n    static class FenwickLong {\n        long[] a;\n\n        public FenwickLong(int n) {\n            a = new long[n];\n        }\n\n        public void add(int x, long y) {\n            for (int i = x; i < a.length; i |= i + 1) {\n                a[i] += y;\n            }\n        }\n\n        public long getSum(int x) {\n            if (x >= a.length) x = a.length - 1;\n            long ret = 0;\n            for (int i = x; i >= 0; i = (i & (i + 1)) - 1) {\n                ret += a[i];\n            }\n            return ret;\n        }\n\n        public long getSum(int l, int r) {\n            return getSum(r - 1) - getSum(l - 1);\n        }\n\n    }\n}\n\n",data structures
" import java.util.*;\n \npublic class magicship {\n static long dx,dy;\n static int x1,y1,x2,y2;\n public static void main(String[] args) {\n  Scanner scan=new Scanner(System.in);\n  x1=scan.nextInt();\n  y1=scan.nextInt();\n  x2=scan.nextInt();\n  y2=scan.nextInt();\n  int n=scan.nextInt();\n  char[] s=scan.next().toCharArray();\n  dx=0L;dy=0L;\n  for(int i=0;i<n;i++) {\n   if(s[i]=='U') dy++;\n   if(s[i]=='D') dy--;\n   if(s[i]=='R') dx++;\n   if(s[i]=='L') dx--;\n  }\n  long lo=0, hi=(long)1e18;\n  while(hi>=lo) {\n   long mid=(hi+lo)/2;\n   if(!good(mid,s)) lo=mid+1;\n   else hi=mid-1;\n  }\n  if(lo>=1e15) System.out.println(-1);\n  else System.out.println(lo);\n }\n public static boolean good(long test, char[] s) {\n  long full=test/s.length;\n  long posx=x1+dx*full, posy=y1+dy*full;\n  for(int id=0;;id++) {\n   if(full*s.length+id==test) break;\n   if(s[id]=='U') posy++;\n   if(s[id]=='D') posy--;\n   if(s[id]=='L') posx--;\n   if(s[id]=='R') posx++;\n\n  }\n  return Math.abs(posx-x2)+Math.abs(posy-y2)<=test;\n }\n}",binary search
"import java.util.*;\nimport java.io.*;\n \npublic class magic_ship {\n	\n	public static void main(String[] args)\n	{\n		Scanner sc =new Scanner(System.in);\n		\n			long x1=sc.nextLong();\n			long y1=sc.nextLong();\n			long x2=sc.nextLong();\n			long y2=sc.nextLong();\n			int n=sc.nextInt();\n			String s=sc.next();int l=0,u=0,d=0,r=0;\n			for(int i=0;i<s.length();i++)\n			{\n				if(s.charAt(i)=='L')\n					l++;\n				if(s.charAt(i)=='U')\n					u++;\n				if(s.charAt(i)=='D')\n					d++;\n				if(s.charAt(i)=='R')\n					r++;\n			}\n			long x=r-l;\n			long y=u-d;\n\n			long beg=1;\n			long last=(long)Math.pow(10,14);\n\n			if(CalDist(last,x,y,x1,y1,x2,y2,s)==-1)\n			{\n				System.out.println(""-1"");\n				return;\n			}\n			long mid=0;int v;\n			while(beg<=last)\n			{\n              	if(mid==(beg+last)/2)\n                	break;\n				mid=(beg+last)/2;\n				v=CalDist(mid,x,y,x1,y1,x2,y2,s);\n				if(v==1)\n				{\n					last=mid;\n				}\n				else\n				{\n					beg=mid+1;\n				}\n\n			}\n			System.out.println(mid);\n \n	}\n	static int CalDist(long dist,long x,long y,long x1,long y1,long x2,long y2,String s)\n	{\n      	int n=s.length();\n		long k=dist/n;\n		x1=x1+k*(x);\n		y1=y1+k*(y);\n		long m=dist%n;\n		for(int i=0;i<m;i++)\n			{\n				if(s.charAt(i)=='L')\n					x1--;\n				if(s.charAt(i)=='U')\n					y1++;\n				if(s.charAt(i)=='D')\n					y1--;\n				if(s.charAt(i)=='R')\n					x1++;\n			}\n\n      \n		long v=(Math.abs(x2-x1)+Math.abs(y2-y1));\n		if(v<=dist)\n			return 1;\n		else\n			return -1;\n	} \n	\n}\n",binary search
"//package com.adityap.thecool;\nimport java.util.*;\npublic class Main {\n    static int x1, y1, x2, y2, n;\n    static String s;\n    static long[][] posWindOnly;\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        x1 = in.nextInt(); y1 = in.nextInt(); in.nextLine();\n        x2 = in.nextInt(); y2 = in.nextInt(); in.nextLine();\n        if (x1==x2&&y1==y2) {\n            System.out.println(0); return;\n        }\n        n = in.nextInt(); in.nextLine();\n        s = in.nextLine();\n        posWindOnly = new long[s.length()+1][2];\n        posWindOnly[0] = new long[]{0L, 0L};\n        int cx = 0, cy = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char d = s.charAt(i);\n            if (d == 'U') {\n                cy += 1;\n            } else if (d == 'D') {\n                cy -= 1;\n            } else if (d == 'L') {\n                cx -= 1;\n            } else cx += 1;\n            posWindOnly[i+1] = new long[2];\n            posWindOnly[i+1][0] = cx; posWindOnly[i+1][1] = cy;\n        }\n        long lo = 1, hi = (long)1e18, ans = -1;\n        while (lo <= hi) {\n            long mid = lo+(hi-lo)/2;\n            long x = x1+posWindOnly[(int)(mid%n)][0]+(mid/n)*posWindOnly[n][0];\n            long y = y1+posWindOnly[(int)(mid%n)][1]+(mid/n)*posWindOnly[n][1];\n            long d = Math.abs(x2-x)+Math.abs(y2-y);\n            if (d <= mid) {\n                ans = mid; hi = mid-1;\n            } else lo = mid+1;\n        }\n        System.out.println(ans);\n    }\n}\n",binary search
"import java.io.*;\nimport java.util.*;\npublic class ship\n{\n	public static void main(String[] args)\n	{\n		Scanner sc =new Scanner(System.in);\n		\n			long x1=sc.nextLong();\n			long y1=sc.nextLong();\n			long x2=sc.nextLong();\n			long y2=sc.nextLong();\n			int n=sc.nextInt();\n			String s=sc.next();int l=0,u=0,d=0,r=0;\n			for(int i=0;i<s.length();i++)\n			{\n				if(s.charAt(i)=='L')\n					l++;\n				if(s.charAt(i)=='U')\n					u++;\n				if(s.charAt(i)=='D')\n					d++;\n				if(s.charAt(i)=='R')\n					r++;\n			}\n			long x=r-l;\n			long y=u-d;\n          //System.out.println(x+"",""+y);\n			long beg=1;\n			long last=(long)Math.pow(10,14);\n            //System.out.print(last);\n			if(CalDist(last,x,y,x1,y1,x2,y2,s)==-1)\n			{\n				System.out.println(""-1"");\n				return;\n			}\n			long mid=0;int v;\n			while(beg<=last)\n			{\n              	if(mid==(beg+last)/2)\n                	break;\n				mid=(beg+last)/2;\n				v=CalDist(mid,x,y,x1,y1,x2,y2,s);\n				if(v==1)\n				{\n					last=mid;\n				}\n				else\n				{\n					beg=mid+1;\n				}\n               //System.out.println(""*""+mid+"" ""+beg+"",""+last);\n			}\n			System.out.println(mid);\n\n	}\n	static int CalDist(long dist,long x,long y,long x1,long y1,long x2,long y2,String s)\n	{\n      	int n=s.length();\n		long k=dist/n;\n		x1=x1+k*(x);\n		y1=y1+k*(y);\n		long m=dist%n;\n		for(int i=0;i<m;i++)\n			{\n				if(s.charAt(i)=='L')\n					x1--;\n				if(s.charAt(i)=='U')\n					y1++;\n				if(s.charAt(i)=='D')\n					y1--;\n				if(s.charAt(i)=='R')\n					x1++;\n			}\n        //System.out.println(""c""+x1+"" ""+y1);\n      \n		long v=(Math.abs(x2-x1)+Math.abs(y2-y1));\n		if(v<=dist)\n			return 1;\n		else\n			return -1;\n	} \n}",binary search
"import java.util.*;\npublic class Main {\n	public static void main(String[] args) {\n		Scanner in=new Scanner(System.in);\n		int n=in.nextInt();\n		int k=in.nextInt();\n		int m=in.nextInt();\n		double[] a=new double[n];\n		for (int i=0;i<n;++i) \n		a[i]=in.nextDouble();\n		Arrays.sort(a);\n		double res=0,sum=0,tot=0;\n		for (int i=n-1;i>=0;--i) \n		{\n			tot+=a[i];\n			sum+=k;\n			if (i<=m) res=Math.max(res,(tot+Math.min(sum,m-i))/(n-i));\n		}\n		System.out.printf(""%.12f\n"",res);\n	}\n}","brute force,implementation,math"
"//package averagesuperherogangpower;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class averagesuperherogangpower {\n	public static void main(String[] args) throws IOException {\n		BufferedReader fin = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer(fin.readLine());\n		int n = Integer.parseInt(st.nextToken());\n		int k = Integer.parseInt(st.nextToken());\n		int m = Integer.parseInt(st.nextToken());\n		st = new StringTokenizer(fin.readLine());\n		double[] a = new double[n];\n		for (int i = 0; i < n; i++) {\n			a[i] = Double.parseDouble(st.nextToken());\n	 	}\n	 	Arrays.sort(a);\n	 	double tot = 0, res = 0, sum = 0;\n	 	for (int i = n - 1; i >= 0; i--) {\n		 tot += a[i];\n    sum += k;\n	    if (i <= m)\n	      res = Math.max(res, (tot + Math.min(sum, m - i)) / (n - i));\n	  }\n		System.out.println(res);\n	}\n}\n","brute force,implementation,math"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Kraken7\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    Scanner in = new Scanner(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskB solver = new TaskB();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskB {\n\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n      int n = in.nextInt(), k = in.nextInt(), m = in.nextInt();\n      double[] a = new double[n];\n      for (int i = 0; i < n; i++) {\n        a[i] = in.nextDouble();\n      }\n      Arrays.sort(a);\n      double tot = 0, res = 0, sum = 0;\n      for (int i = n - 1; i >= 0; i--) {\n        tot += a[i];\n        sum += k;\n        if (i <= m)\n          res = Math.max(res, (tot + Math.min(sum, m - i)) / (n - i));\n      }\n      out.printf(""%.20f"", res);\n    }\n\n  }\n}\n\n","brute force,implementation,math"
"import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class B{\n	public static void main(String[] args) throws IOException {\n		// br = new BufferedReader(new FileReader("".in""));\n		// out = new PrintWriter(new FileWriter("".out""));\n		//new Thread(null, new (), ""peepee"", 1<<28).start();\n		\n		int  n  =readInt();\n		long k =readInt();\n		long m =readInt();\n		Long[] a = new Long[n];\n		long  sum  = 0;\n		for (int i   = 0; i< n; i++) {\n			long  x = readInt();\n			a[i]=x;\n			sum += x;\n		}\n		Arrays.sort(a);\n		// Even simpler brute  force  option\n		long  size =  n;\n		double ans = (double)(sum + min(m,size*k))/size;\n		for (int i  =0; i <n-1 && m-->0;i++) {\n			sum -= a[i];\n			size--;\n			double a2  = (double)(sum +  min(m,size*k))/size;\n			ans = max(ans,a2);\n		}\n		out.println(ans);		\n		out.close();\n	}\n	\n	/* Stupid things to try if stuck:\n	 * n=1, expand bsearch range\n	 * brute force small patterns\n	 * submit stupid intuition\n	 */\n	\n	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n	static StringTokenizer st = new StringTokenizer("""");\n	static String read() throws IOException{return st.hasMoreTokens() ? st.nextToken():(st = new StringTokenizer(br.readLine())).nextToken();}\n	static int readInt() throws IOException{return Integer.parseInt(read());}\n	static long readLong() throws IOException{return Long.parseLong(read());}\n	static double readDouble() throws IOException{return Double.parseDouble(read());}\n}","brute force,implementation,math"
import java.util.*;\npublic class practice{\n	public static void main(String [] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int m=sc.nextInt();\n		int k=sc.nextInt();\n		int[] arr=new int[n];\n		for(int i=0;i<n;i++)arr[i]=sc.nextInt();\n		ArrayList<Integer>diff=new ArrayList<Integer>();\n		for(int i=1;i<n;i++)\n			diff.add(arr[i]-arr[i-1]);\n		Collections.sort(diff);\n		int ans=0;\n		for(int i=0;i<n-k;i++)\n			ans+=diff.get(i);\n		System.out.println(ans+k);\n	}\n},"greedy,sortings"
import java.util.Arrays;\nimport java.util.Scanner;     \n\npublic class Abhi {\n	\n	public static void main(String[] args) {\n	\n		Scanner s = new Scanner(System.in);\n		\n		int n = s.nextInt();\n		long m = s.nextLong();\n		int k = s.nextInt();\n		\n		int a[] = new int[n];\n		int b[] = new int[n-1];\n		\n		for(int i=0; i<n; i++) {\n			a[i] = s.nextInt();\n		}\n		\n		for(int i=0; i<n-1; i++) {\n			b[i] = a[i+1] - a[i];\n		}\n		\n		Arrays.sort(b);\n		int sum = k;\n		for(int i=0; i<n-k; i++) {\n			sum += b[i];\n		}\n		\n		System.out.println(sum);	\n	}\n},"greedy,sortings"
"//package koko;\n\nimport java.util.*;\n\npublic class PRO1 {\n	public static void main(String[] str) {\n		var in = new Scanner(System.in);\n		int n, k, m;\n		n = in.nextInt();\n		m = in.nextInt();\n		k = in.nextInt();\n		var arr = new int[n];\n		for (int i = 0; i < n; i++)\n			arr[i] = in.nextInt();\n		in.close();\n		\n		if (n == k) {\n			System.out.print(n);\n			return;\n		}\n		\n		var q = new PriorityQueue<Integer>((a, b) -> {\n			return b - a;\n		});\n		for (int i = 0; i < n - 1; i++)\n			q.add(arr[i + 1] - arr[i]);\n		for (int i = 0; i < k-1; i++) {\n			q.poll();\n		}\n		int ans=0;\n		while(!q.isEmpty()) {\n			ans+=q.poll();\n		}\n		ans+=k;\n		System.out.print(ans);\n	}\n}","greedy,sortings"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1110B extends PrintWriter {\n	CF1110B() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1110B o = new CF1110B(); o.main(); o.flush();\n	}\n\n	Random rand = new Random();\n	void sort(int[] aa, int n) {\n		for (int i = 0; i < n; i++) {\n			int j = rand.nextInt(i + 1);\n			int tmp = aa[i]; aa[i] = aa[j]; aa[j] = tmp;\n		}\n		Arrays.sort(aa, 0, n);\n	}\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		int k = sc.nextInt();\n		int[] gg = new int[n - 1];\n		for (int a = 0, i = 0; i < n; i++) {\n			int b = sc.nextInt();\n			if (i > 0)\n				gg[i - 1] = b - a - 1;\n			a = b;\n		}\n		sort(gg, n - 1);\n		int ans = n;\n		for (int i = 0; i < n - k; i++)\n			ans += gg[i];\n		println(ans);\n	}\n}\n","greedy,sortings"
import java.util.Scanner;\n\npublic class Sequence {\n	public static void main(String[] args) {\n		long in = (new Scanner(System.in)).nextLong();\n		System.out.println(((in * in + in) / 2 ) % 2);\n	}\n}\n,math
import java.util.Scanner;\n\npublic class CR531A {\n	public static void main(String[] args) {\n		\n		Scanner s=new Scanner(System.in);\n		\n		long n=s.nextInt();\n		\n		System.out.println((n+1)*n/2%2);\n		\n	}\n\n}\n,math
"import java.util.Scanner;\n\npublic class Main {\n\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int n = in.nextInt(), m = (n + 1) / 2;\n		System.out.println(m % 2);\n	}\n	\n}\n",math
import java.io.*;\nimport java.util.*;\npublic class GFG {\n	public static void main (String[] args) {\n	Scanner sc=new Scanner(System.in);\n	    int n=sc.nextInt();\n	    n--;\n	    System.out.println((1+n/2)%2);\n	}\n},math
import java.util.*;\npublic class MinimumInteger {\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		int t = s.nextInt();\n		while(t>0) {\n			int l = s.nextInt();\n			int r = s.nextInt();\n			int d = s.nextInt();\n			if(d<l)\n				System.out.println(d);\n			else\n				System.out.println((r/d)*d+d);\n			t--;\n		}\n	}\n},math
"import java.util.*;\npublic class MinimumInteger {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int q=sc.nextInt();\n		while(q--!=0) {\n			long l=sc.nextLong(),r=sc.nextLong(),d=sc.nextLong(),ans1=0,ans2=0;\n			if(d<l || d>r)System.out.println(d);\n			else {\n				long c=r/d;\n				System.out.println(d*(c+1));\n			}\n		}\n\n	}\n\n}",math
"import java.util.*;\npublic class MinimumInteger {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int q=sc.nextInt();\n		while(q--!=0) {\n			long l=sc.nextLong(),r=sc.nextLong(),d=sc.nextLong(),ans1=0,ans2=0;\n			if(d<l || d>r)System.out.println(d);\n			else {\n				long c=r/d;\n				System.out.println(d*(c+1));\n			}\n		}\n\n	}\n\n}",math
"import java.util.*;\npublic class code{\n public static void main(String args[])\n {\n    int l,r,n,d,i;\n    Scanner sc=new Scanner(System.in);\n    n=sc.nextInt();\n    for(i=0;i<n;i++)\n    {\n       l=sc.nextInt();\n       r=sc.nextInt();\n       d=sc.nextInt();\n       if(d<l || d>r)  System.out.println(d);\n       else  System.out.println(((r/d)+1)*d);\n    }\n  }\n}",math
"// package PRA;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n	public static void main(String[] arg) {\n		new Main().solve();\n	}\n	\n	StringTokenizer ST;\n	BufferedReader BR;\n	PrintWriter PW;\n	\n	String next() {\n		while(ST == null || !ST.hasMoreTokens()) {\n			try {\n				ST = new StringTokenizer(BR.readLine());\n			}catch (Exception e) {\n				// TODO: handle exception\n				throw new RuntimeException(e);\n			}\n		}\n		return ST.nextToken();\n	}\n	\n	int nextInt() {\n		return Integer.parseInt(next());\n	}\n	\n	long nextLong() {\n		return Long.parseLong(next());\n	}\n	\n	void solve() {\n		BR = new BufferedReader(new InputStreamReader(System.in));\n		PW = new PrintWriter(System.out);\n		\n		int Sum[] = new int[500];\n		int Sn = 0;\n		for(int i = 0; ; i++) {\n			Sum[i] = i * (i + 1) / 2;\n			if(Sum[i] > 1e5) {\n				Sn = i; break;\n			}\n		}\n		\n		\n		ArrayList<Integer> ans[] = new ArrayList[500];\n		\n		int T = nextInt();\n		while(T-- > 0) {\n			int n = nextInt();\n			int k = Arrays.binarySearch(Sum, 0, Sn, n);\n			if(k < 0) k = - k - 2;\n//			PW.println(k);\n			\n			int[] a = new int[n];\n			for(int i = 0; i < n; i++)\n				a[i] = nextInt();\n			\n			int[] b = new int[n];\n			int[] pre = new int[n];\n			ArrayList<Integer> path[] = new ArrayList[n];\n			\n			int m = 0;\n			while(n > 0) {\n				\n				int n1 = 0;\n				for(int i = 0; i < n; i++) {\n					int t = Arrays.binarySearch(b, 0, n1, a[i]);\n					t = -t-1;\n					b[t] = a[i];\n					if(t == 0) pre[i] = -1;\n					else pre[i] = b[t-1];\n					\n					if(t == n1) {\n						path[n1] = new ArrayList<>();\n						n1++;\n					}\n					path[t].add(a[i]);\n				}\n				\n//				PW.println(""n = "" + n + "" n1 = "" + n1);\n				if(n1 > k) {\n					int x = b[n1-1];\n					for(int i = n - 1; i >= 0; i--) {\n						if(a[i] == x) {\n							x = pre[i];\n							pre[i] = -100;\n						}\n					}\n					\n					ans[m] = new ArrayList<>();\n					int n2 = 0;\n					for(int i = 0; i < n; i++) {\n						if(pre[i] == -100) ans[m].add(a[i]);\n						else a[n2++] = a[i];\n					}\n					n = n2; m++; k--;\n				} else {\n					n = 0;\n					for(int i = 0; i < n1; i++) ans[m+i] = path[i];\n					m += n1;\n				}\n			}\n			\n			PW.println(m);\n			for(int i = 0; i < m; i++) {\n				PW.print(ans[i].size());\n				for(int x : ans[i]) PW.print("" "" + x);\n				PW.println();\n			}\n		}\n		\n		PW.close();\n	}\n	\n}\n\n/*\n1\n5\n2 4 5 3 1\n*/","constructive algorithms,greedy"
"import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class E {\n\n	int f(int n) {\n		int ret = 0;\n		while (n >= 0) {\n			ret++;\n			n -= ret;\n		}\n		return ret - 1;\n	}\n\n	void solve(int[] p) {\n		int n = p.length;\n\n		int[] tmp = new int[n + 1];\n		boolean[] dead = new boolean[n];\n		int live = n;\n\n		int[] prv = new int[n];\n\n		ArrayList<ArrayList<Integer>> ret = new ArrayList<>();\n\n		int okMax = f(n);\n\n		int[] color = new int[n];\n		\n		while (live > 0) {\n			int size = 0;\n			for (int i = 0; i < n; i++) {\n				if (dead[i]) {\n					continue;\n				}\n				int valHere = p[i];\n				int low = -1, high = size;\n				while (high - low > 1) {\n					int mid = (low + high) >> 1;\n					int valMid = p[tmp[mid]];\n					if (valHere < valMid) {\n						high = mid;\n					} else {\n						low = mid;\n					}\n				}\n				color[i] = high;\n				prv[i] = high == 0 ? -1 : tmp[high - 1];\n				tmp[high] = i;\n				if (high == size) {\n					size++;\n				}\n			}\n			// s0 = size;\n			// last0 = tmp[size - 1];\n			if (size <= okMax) {\n				ArrayList<Integer>[] shit = new ArrayList[size];\n				for (int i = 0; i < size; i++) {\n					shit[i] = new ArrayList<>();\n				}\n				for (int i = 0; i < n; i++) {\n					if (!dead[i]) {\n						shit[color[i]].add(i);\n					}\n				}\n				for (ArrayList<Integer> al : shit) {\n					ret.add(al);\n				}\n				// blah-blah\n				break;\n			} else {\n\n				ArrayList<Integer> arr = new ArrayList<>(size);\n\n				live -= size;\n\n				for (int i = tmp[size - 1], j = size - 1; j >= 0; j--) {\n//					arr[j] = i;\n					arr.add(i);\n					dead[i] = true;\n					i = prv[i];\n				}\n				\n				Collections.reverse(arr);\n\n				ret.add(arr);\n				okMax--;\n			}\n		}\n\n		out.println(ret.size());\n		for (ArrayList<Integer> arr : ret) {\n			out.println(arr.size());\n			for (int idx : arr) {\n				out.print((p[idx] + 1) + "" "");\n			}\n			out.println();\n		}\n	}\n\n	void submit() {\n		int t = nextInt();\n		while (t-- > 0) {\n			int n = nextInt();\n			int[] p = new int[n];\n			for (int i = 0; i < n; i++) {\n				p[i] = nextInt() - 1;\n			}\n			solve(p);\n		}\n	}\n\n	void test() {\n		// int[] dp = new int[100000];\n		// for (int i = 1; i < dp.length; i++) {\n		// dp[i] = dp[i - sq(i)] + 1;\n		// System.err.println(i + "" "" + dp[i]);\n		// }\n	}\n\n	void stress() {\n		for (int tst = 0;; tst++) {\n			if (false) {\n				throw new AssertionError();\n			}\n			System.err.println(tst);\n		}\n	}\n\n	E() throws IOException {\n		is = System.in;\n		out = new PrintWriter(System.out);\n		submit();\n		// stress();\n		// test();\n		out.close();\n	}\n\n	static final Random rng = new Random();\n	static final int C = 5;\n\n	static int rand(int l, int r) {\n		return l + rng.nextInt(r - l + 1);\n	}\n\n	public static void main(String[] args) throws IOException {\n		new E();\n	}\n\n	private InputStream is;\n	PrintWriter out;\n\n	private byte[] buf = new byte[1 << 14];\n	private int bufSz = 0, bufPtr = 0;\n\n	private int readByte() {\n		if (bufSz == -1)\n			throw new RuntimeException(""Reading past EOF"");\n		if (bufPtr >= bufSz) {\n			bufPtr = 0;\n			try {\n				bufSz = is.read(buf);\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n			if (bufSz <= 0)\n				return -1;\n		}\n		return buf[bufPtr++];\n	}\n\n	private boolean isTrash(int c) {\n		return c < 33 || c > 126;\n	}\n\n	private int skip() {\n		int b;\n		while ((b = readByte()) != -1 && isTrash(b))\n			;\n		return b;\n	}\n\n	String nextToken() {\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b)) {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	String nextString() {\n		int b = readByte();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b) || b == ' ') {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	double nextDouble() {\n		return Double.parseDouble(nextToken());\n	}\n\n	char nextChar() {\n		return (char) skip();\n	}\n\n	int nextInt() {\n		int ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n\n	long nextLong() {\n		long ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n}","constructive algorithms,greedy"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        int testCount = Integer.parseInt(in.next());\n        for (int i = 1; i <= testCount; i++)\n            solver.solve(i, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] f = new int[n + 1];\n            for (int a = 1; a <= n; ++a) {\n                int best = 0;\n                for (int x = 1; x <= a; ++x) {\n                    if (f[a - x] + 1 <= x) {\n                        best = Math.max(best, f[a - x] + 1);\n                        break;\n                    }\n                    best = Math.max(best, x);\n                }\n                f[a] = best;\n            }\n\n            int allowed = f[n];\n            int done = 0;\n\n            int[] seq = new int[n];\n            for (int i = 0; i < n; ++i) seq[i] = in.nextInt();\n\n            boolean[] alive = new boolean[n];\n            Arrays.fill(alive, true);\n\n            int[][] res = new int[allowed][];\n\n            int[] best = new int[n + 1];\n            int[] bestPos = new int[n + 1];\n            int[] level = new int[n];\n            int[] via = new int[n];\n            while (true) {\n                best[0] = 0;\n                bestPos[0] = -1;\n                int max = 0;\n                boolean any = false;\n                for (int i = 0; i < n; ++i)\n                    if (alive[i]) {\n                        any = true;\n                        int x = seq[i];\n                        int left = 0;\n                        int right = max + 1;\n                        while (right - left > 1) {\n                            int mid = (left + right) >> 1;\n                            if (best[mid] < x) {\n                                left = mid;\n                            } else {\n                                right = mid;\n                            }\n                        }\n                        level[i] = left;\n                        via[i] = bestPos[left];\n                        best[right] = x;\n                        bestPos[right] = i;\n                        if (right > max) {\n                            ++max;\n                        }\n                    }\n                if (!any) break;\n\n                if (done + max <= allowed) {\n                    int[] cnt = new int[max];\n                    for (int i = 0; i < n; ++i) if (alive[i]) ++cnt[level[i]];\n                    for (int i = 0; i < max; ++i) {\n                        res[done + i] = new int[cnt[i]];\n                    }\n                    Arrays.fill(cnt, 0);\n                    for (int i = 0; i < n; ++i)\n                        if (alive[i]) {\n                            res[done + level[i]][cnt[level[i]]++] = seq[i];\n                            alive[i] = false;\n                        }\n                    done += max;\n                } else {\n                    res[done] = new int[max];\n                    boolean found = false;\n                    for (int i = 0; i < n; ++i)\n                        if (alive[i] && level[i] == max - 1) {\n                            found = true;\n                            int j = max - 1;\n                            int at = i;\n                            while (at >= 0) {\n                                res[done][j] = seq[at];\n                                alive[at] = false;\n                                at = via[at];\n                                --j;\n                            }\n                            if (j != -1) throw new RuntimeException();\n                            break;\n                        }\n                    if (!found) throw new RuntimeException();\n                    ++done;\n                }\n            }\n\n            out.println(done);\n            for (int i = 0; i < done; ++i) {\n                int[] cur = res[i];\n                out.print(cur.length);\n                for (int x : cur) {\n                    out.print("" "");\n                    out.print(x);\n                }\n                out.println();\n            }\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n","constructive algorithms,greedy"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskE solver = new TaskE();\n            int testCount = Integer.parseInt(in.next());\n            for (int i = 1; i <= testCount; i++)\n                solver.solve(i, in, out);\n            out.close();\n        }\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int[] a = new int[n];\n            int[] pre = new int[n];\n            boolean[] delete = new boolean[n];\n            int remain = n;\n            for (int i = 0; i < n; i++) {\n                a[i] = in.readInt();\n            }\n            MultiWayIntDeque deque = new MultiWayIntDeque(n + 2, n + 1);\n            FindCeilElementInDeque bs = new FindCeilElementInDeque(deque, a);\n\n            List<IntList> ans = new ArrayList<>();\n            while (remain > 0) {\n                int k = findK(remain);\n                deque.clear();\n                deque.addLast(0, -1);\n                for (int i = 0; i < n; i++) {\n                    if (delete[i]) {\n                        continue;\n                    }\n                    bs.setElement(a[i]);\n                    int insert = bs.binarySearch(1, remain + 1);\n                    pre[i] = deque.peekLast(insert - 1);\n                    deque.addLast(insert, i);\n                }\n\n                int lis = 1;\n                while (!deque.isEmpty(lis + 1)) {\n                    lis++;\n                }\n\n                if (lis >= k) {\n                    IntList list = new IntList(lis);\n                    int trace = deque.peekLast(lis);\n                    while (trace != -1) {\n                        list.add(trace);\n                        delete[trace] = true;\n                        remain--;\n                        trace = pre[trace];\n                    }\n                    list.reverse();\n                    ans.add(list);\n                    continue;\n                }\n                for (int i = 1; i <= lis; i++) {\n                    IntList list = new IntList();\n                    while (!deque.isEmpty(i)) {\n                        list.add(deque.removeFirst(i));\n                    }\n                    ans.add(list);\n                }\n                break;\n            }\n\n            out.println(ans.size());\n            for (IntList list : ans) {\n                out.append(list.size()).append(' ');\n                for (IntIterator iterator = list.iterator(); iterator.hasNext(); ) {\n                    out.append(a[iterator.next()]).append(' ');\n                }\n                out.println();\n            }\n        }\n\n        public int findK(int n) {\n            int k = 0;\n            while (k * (k + 1) / 2 <= n) {\n                k++;\n            }\n            return k;\n        }\n\n    }\n\n    static class IntList {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public IntList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntList(IntList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntList() {\n            this(0);\n        }\n\n        public void reverse(int l, int r) {\n            SequenceUtils.reverse(data, l, r);\n        }\n\n        public void reverse() {\n            reverse(0, size - 1);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        public void add(int x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public IntIterator iterator() {\n            return new IntIterator() {\n                int i = 0;\n\n\n                public boolean hasNext() {\n                    return i < size;\n                }\n\n\n                public int next() {\n                    return data[i++];\n                }\n            };\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof IntList)) {\n                return false;\n            }\n            IntList other = (IntList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\n');\n            return this;\n        }\n\n        public FastOutput println() {\n            cache.append('\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static abstract class IntBinarySearch {\n        public abstract boolean check(int mid);\n\n        public int binarySearch(int l, int r) {\n            if (l > r) {\n                throw new IllegalArgumentException();\n            }\n            while (l < r) {\n                int mid = (l + r) >>> 1;\n                if (check(mid)) {\n                    r = mid;\n                } else {\n                    l = mid + 1;\n                }\n            }\n            return l;\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static void swap(int[] data, int i, int j) {\n            int tmp = data[i];\n            data[i] = data[j];\n            data[j] = tmp;\n        }\n\n        public static void reverse(int[] data, int l, int r) {\n            while (l < r) {\n                swap(data, l, r);\n                l++;\n                r--;\n            }\n        }\n\n        public static boolean equal(int[] a, int al, int ar, int[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class MultiWayIntDeque {\n        private int[] values;\n        private int[] next;\n        private int[] prev;\n        private int[] heads;\n        private int[] tails;\n        private int alloc;\n        private int queueNum;\n\n        public IntIterator iterator(final int queue) {\n            return new IntIterator() {\n                int ele = heads[queue];\n\n\n                public boolean hasNext() {\n                    return ele != 0;\n                }\n\n\n                public int next() {\n                    int ans = values[ele];\n                    ele = next[ele];\n                    return ans;\n                }\n            };\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            prev = Arrays.copyOf(prev, newSize);\n            values = Arrays.copyOf(values, newSize);\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n        }\n\n        public void clear() {\n            alloc = 0;\n            Arrays.fill(heads, 0, queueNum, 0);\n            Arrays.fill(tails, 0, queueNum, 0);\n        }\n\n        public boolean isEmpty(int qId) {\n            return heads[qId] == 0;\n        }\n\n        public MultiWayIntDeque(int qNum, int totalCapacity) {\n            values = new int[totalCapacity + 1];\n            next = new int[totalCapacity + 1];\n            prev = new int[totalCapacity + 1];\n            heads = new int[qNum];\n            tails = new int[qNum];\n            queueNum = qNum;\n        }\n\n        public void addLast(int qId, int x) {\n            alloc();\n            values[alloc] = x;\n\n            if (heads[qId] == 0) {\n                heads[qId] = tails[qId] = alloc;\n                return;\n            }\n            next[tails[qId]] = alloc;\n            prev[alloc] = tails[qId];\n            tails[qId] = alloc;\n        }\n\n        public int peekLast(int qId) {\n            return values[tails[qId]];\n        }\n\n        public int removeFirst(int qId) {\n            int ans = values[heads[qId]];\n            if (heads[qId] == tails[qId]) {\n                heads[qId] = tails[qId] = 0;\n            } else {\n                heads[qId] = next[heads[qId]];\n                prev[tails[qId]] = 0;\n            }\n            return ans;\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < queueNum; i++) {\n                builder.append(i).append("": "");\n                for (IntIterator iterator = iterator(i); iterator.hasNext(); ) {\n                    builder.append(iterator.next()).append("","");\n                }\n                if (builder.charAt(builder.length() - 1) == ',') {\n                    builder.setLength(builder.length() - 1);\n                }\n                builder.append('\n');\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static interface IntIterator {\n        boolean hasNext();\n\n        int next();\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n    }\n\n    static class FindCeilElementInDeque extends IntBinarySearch {\n        private MultiWayIntDeque deque;\n        private int[] a;\n        private int element;\n\n        public void setElement(int element) {\n            this.element = element;\n        }\n\n        FindCeilElementInDeque(MultiWayIntDeque deque, int[] a) {\n            this.deque = deque;\n            this.a = a;\n        }\n\n        public boolean check(int mid) {\n            return deque.isEmpty(mid) || a[deque.peekLast(mid)] > element;\n        }\n\n    }\n}\n\n","constructive algorithms,greedy"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class I {\n	public static void main(String[] args) throws NumberFormatException, IOException {\n		Scanner sc = new Scanner();\n		int T = sc.nextInt();\n		PrintWriter out = new PrintWriter(System.out);\n		long[] arr = new long[(int) 1e7];\n		long oo = Long.MAX_VALUE;\n		while (T-- > 0) {\n			int n = sc.nextInt();\n			l = sc.nextInt();\n			r = sc.nextInt();\n			x = sc.nextLong();\n			y = sc.nextLong();\n			z = sc.nextLong();\n			long len = r + 0L - l + 1;\n			long b1 = sc.nextLong(), b2 = sc.nextLong();\n			arr[0] = (b1 % len) + l;\n			arr[1] = (b2 % len) + l;\n			for (int i = 2; i < n; i++) {\n				long b = add(add(mult(b1, x), mult(b2, y)), z);\n				b1 = b2;\n				b2 = b;\n				arr[i] = (b % len) + l;\n			}\n			long min = arr[0];\n			long global = oo;\n			for (int i = 1; i < n; ++i) {\n				if (arr[i] <= min) {\n					min = arr[i];\n					continue;\n				}\n				global = Math.min(global, min * arr[i]);\n//				min = Math.min(arr[i], min);\n			}\n\n			long max = arr[n - 1];\n			for (int i = n - 2; i >= 0; --i) {\n				if (arr[i] >= max) {\n					max = arr[i];\n					continue;\n				}\n				global = Math.min(global, max * arr[i]);\n//				max = Math.max(max, arr[i]);\n			}\n			out.println(global == oo ? ""IMPOSSIBLE"" : global);\n		}\n		out.close();\n\n	}\n\n	static long MOD = (1l << 32) - 1;\n\n	static long x, y, z;\n	static int l, r;\n\n	static long mult(long b, long x) {\n		long h = x / 4;\n		long one = (b * h) & MOD;\n		one *= 3;\n		long two = b * (x - 3 * h);\n		return add(one & MOD, two & MOD);\n	}\n\n	static long add(long a, long b) {\n		return (a + b) & MOD;\n	}\n\n	static class Scanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		Scanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		int nextInt() throws NumberFormatException, IOException {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() throws IOException, NumberFormatException {\n			return Long.parseLong(next());\n		}\n	}\n}",
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        A solver = new A();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class A {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int T = in.ni();\n            long mask = (1L << 32) - 1;\n            long[] deq = new long[20_000_001];\n            int di = 0;\n            for (int t = 0; t < T; t++) {\n                int n = in.ni();\n                long l = in.nl(), r = in.nl(), x = in.nl(), y = in.nl(), z = in.nl(), b1 = in.nl(), b2 = in.nl();\n                long[] b = new long[n];\n                b[0] = b1;\n                b[1] = b2;\n                for (int i = 2; i < n; i++) {\n                    long l1 = (b[i - 2] * x) + (b[i - 1] * y) + z;\n                    b[i] = l1 & mask;\n                }\n                for (int i = 0; i < n; i++) {\n                    b[i] = b[i] % (r - l + 1L) + l;\n                }\n                long ans = Long.MAX_VALUE;\n                long max = Long.MIN_VALUE;\n                di = 0;\n                //System.out.println(""Arrays.toString(a) = "" + Arrays.toString(a));\n                for (int i = n - 1; i >= 0; i--) {\n                    if (b[i] >= 0) {\n                        while (di > 0 && deq[di - 1] > b[i]) {\n                            ans = Math.min(ans, b[i] * deq[--di]);\n                        }\n                        deq[di++] = b[i];\n                    } else {\n                        if (b[i] < max) {\n                            ans = Math.min(ans, b[i] * max);\n                        }\n                    }\n                    max = Math.max(max, b[i]);\n                }\n\n                if (ans == Long.MAX_VALUE)\n                    out.println(""IMPOSSIBLE"");\n                else\n                    out.println(ans);\n            }\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String ns() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(ns());\n        }\n\n        public long nl() {\n            return Long.parseLong(ns());\n        }\n\n    }\n}\n\n",
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        A solver = new A();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class A {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int T = in.ni();\n            long mask = (1L << 32) - 1;\n            long[] deq = new long[20_000_001];\n            int di = 0;\n            for (int t = 0; t < T; t++) {\n                int n = in.ni();\n                long l = in.nl(), r = in.nl(), x = in.nl(), y = in.nl(), z = in.nl(), b1 = in.nl(), b2 = in.nl();\n                long[] b = new long[n];\n                b[0] = b1;\n                b[1] = b2;\n                for (int i = 2; i < n; i++) {\n                    long l1 = (b[i - 2] * x) + (b[i - 1] * y) + z;\n                    b[i] = l1 & mask;\n                }\n                for (int i = 0; i < n; i++) {\n                    b[i] = b[i] % (r - l + 1L) + l;\n                }\n                long ans = Long.MAX_VALUE;\n                long max = Long.MIN_VALUE;\n                di = 0;\n                //System.out.println(""Arrays.toString(a) = "" + Arrays.toString(a));\n                for (int i = n - 1; i >= 0; i--) {\n                    if (b[i] >= 0) {\n                        while (di > 0 && deq[di - 1] > b[i]) {\n                            ans = Math.min(ans, b[i] * deq[--di]);\n                        }\n                        deq[di++] = b[i];\n                    } else {\n                        if (b[i] < max) {\n                            ans = Math.min(ans, b[i] * max);\n                        }\n                    }\n                    max = Math.max(max, b[i]);\n                }\n\n                if (ans == Long.MAX_VALUE)\n                    out.println(""IMPOSSIBLE"");\n                else\n                    out.println(ans);\n            }\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String ns() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(ns());\n        }\n\n        public long nl() {\n            return Long.parseLong(ns());\n        }\n\n    }\n}\n\n",
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        A solver = new A();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class A {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int T = in.ni();\n            long mask = (1L << 32) - 1;\n            for (int t = 0; t < T; t++) {\n                int n = in.ni();\n                long l = in.nl(), r = in.nl(), x = in.nl(), y = in.nl(), z = in.nl(), b1 = in.nl(), b2 = in.nl();\n                long[] b = new long[n];\n                b[0] = b1;\n                b[1] = b2;\n                for (int i = 2; i < n; i++) {\n                    long l1 = (b[i - 2] * x) + (b[i - 1] * y) + z;\n                    b[i] = l1 & mask;\n                }\n                for (int i = 0; i < n; i++) {\n                    b[i] = b[i] % (r - l + 1L) + l;\n                }\n                long ans = Long.MAX_VALUE;\n                long max = Long.MIN_VALUE;\n                //System.out.println(""Arrays.toString(a) = "" + Arrays.toString(a));\n                long min = Long.MAX_VALUE;\n                for (int i = 0; i < n; i++) {\n                    if (b[i] >= 0) {\n                        if (b[i] > min) {\n                            ans = Math.min(ans, min * b[i]);\n                        }\n                        min = Math.min(min, b[i]);\n                    }\n                }\n                for (int i = n - 1; i >= 0; i--) {\n                    if (b[i] < 0) {\n                        if (b[i] < max) {\n                            ans = Math.min(ans, b[i] * max);\n                        }\n                    }\n                    max = Math.max(max, b[i]);\n                }\n\n                if (ans == Long.MAX_VALUE)\n                    out.println(""IMPOSSIBLE"");\n                else\n                    out.println(ans);\n            }\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String ns() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(ns());\n        }\n\n        public long nl() {\n            return Long.parseLong(ns());\n        }\n\n    }\n}\n\n",
"\nimport java.util.*;\npublic class Main {\n    public static void main(String[] args) \n    {\n       Scanner in = new Scanner(System.in);\n       int x=in.nextInt();\n       System.out.println((x==1)?-1:x-x%2+"" ""+2);\n    }\n\n}\n","brute force,constructive algorithms"
"import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n  Scanner in=new Scanner(System.in);\n  int n=in.nextInt();\n    if(n>1)\n      System.out.println(n+"" ""+n);\n    else\n      System.out.println(-1);\n  }\n  \n}","brute force,constructive algorithms"
"import java.util.*;\npublic class Solution{\npublic static void main(String[] args) {\nScanner sc=new Scanner(System.in);\nint n=sc.nextInt();\nif(n==1 ){\nSystem.out.println(-1);\n}\nelse{\nint p=n/2;\nSystem.out.println((p+1)+"" ""+(p+1));\n}\n}\n}","brute force,constructive algorithms"
"import java.util.Scanner;\npublic class A {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		if(n==1)System.out.println(-1);\n		else System.out.println(n+"" ""+n);\n}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","brute force,constructive algorithms"
import java.util.*;\n\npublic class A671{\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n	String s=sc.next();\n	char[] c=s.toCharArray();\n	long ans=0;\n	long sum=0;\n	long mod=1000000007;\n	int n=s.length();\n	long a=1;long b=1;\n	for(int i=0;i<n;i++){\n	    if(c[i]=='a'){\n	        a++;\n	    }\n	    else if(c[i]=='b'){\n	       b=((a*b)%mod+mod)%mod;\n	       a=1;\n	    }\n	    \n	}\n	\n	b=((b*a)%mod+mod)%mod;\n  \n\n	System.out.println(b-1);\n \n \n        \n	}\n}\n ,"combinatorics,dp,implementation"
"import java.util.Scanner;\n\npublic class Main {\n	public static void main(String[] args) {\n		try(Scanner input = new Scanner(System.in)){\n			String s = input.nextLine();\n			long mod = 1000000007;\n			long resp = 1;\n			int count = 1;\n			for(int i = 0; i < s.length();i++) {\n				if(s.charAt(i)=='a') {\n					count++;\n				}else if(s.charAt(i)=='b') {\n					resp = calculateMOD(resp*count,mod);\n					count = 1;\n				}\n			}\n			resp = calculateMOD(resp*count,mod);\n			System.out.println(resp-1);\n		}\n	}\n	private static long calculateMOD(long n, long mod) {\n		return ((n%mod)+mod)%mod;\n	}\n}","combinatorics,dp,implementation"
"import java.util.*;\npublic class Solution{\n    public static void main(String[] args){\n        \n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        int n = s.length();\n        long M = (long) Math.pow(10,9) + 7;\n        \n        long a=0, b=0;\n        \n        for(int i=0;i<n;i++){\n            \n            if(s.charAt(i)=='b'){\n                b = a;\n            }else if(s.charAt(i)=='a'){\n                \n                a += b + 1;\n                a %= M;\n                \n            }\n            \n        }\n        \n        System.out.println(a);\n        \n    }\n}","combinatorics,dp,implementation"
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be ""Main"" only if the class is public. */\npublic class main\n{\n	public static void main (String[] args) throws java.lang.Exception\n	{\n		long m = 1000000007, res = 1;\n		Scanner in = new Scanner(System.in);\n		String s = in.nextLine(); String s1 = """"; \n		for(int i = 0; i < s.length(); i++){\n			if(s.charAt(i) =='a' || s.charAt(i) =='b') s1 += s.charAt(i);\n		}\n		for(int i = 0; i < s1.length();){\n			if(s1.charAt(i) =='a') {\n				int c=0;\n				while(i < s1.length() && s1.charAt(i) =='a') {\n					c++; i++;\n				}	\n				res=(res*(c+1)) % m;\n			} else i++;	\n		}\n	System.out.println((--res)%m);\n	}\n}","combinatorics,dp,implementation"
"import java.util.*;\nimport java.io.*;\npublic class B{\n	public static void main(String[] args)\n	{\n		FastScanner fs = new FastScanner();\n		PrintWriter out = new PrintWriter(System.out);\n		Map<String,Integer> hm = new HashMap();\n		Map<String,String> hm1 = new HashMap();\n		int n = fs.nextInt();\n		for(int ii=0;ii<n;ii++)\n		{\n			String str = fs.next();\n			for(int i=0;i<str.length();i++)\n			{\n				String cur = """";\n				for(int j=i;j<str.length();j++)\n				{\n					cur += str.charAt(j);\n					if(hm1.get(cur)!=null && hm1.get(cur).equals(str))continue;\n					hm.put(cur,hm.getOrDefault(cur,0)+1);\n					hm1.put(cur,str);\n				}\n			}\n		}\n		int q = fs.nextInt();\n		for(int qq=0;qq<q;qq++)\n		{\n			String str = fs.next();\n			if(!hm.containsKey(str))\n			{\n				out.println(""0 -"");\n			}\n			else\n			{\n				out.println(hm.get(str)+"" ""+hm1.get(str));\n			}\n		}\n		out.close();\n	}\n	static class FastScanner {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n		String next() {\n			while (!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		int[] readArray(int n) {\n			int[] a=new int[n];\n			for (int i=0; i<n; i++) a[i]=nextInt();\n			return a;\n		}\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n	}\n	public static int[] sort(int[] arr)\n	{\n		List<Integer> temp = new ArrayList();\n		for(int i:arr)temp.add(i);\n		Collections.sort(temp,Collections.reverseOrder());\n		int start = 0;\n		for(int i:temp)arr[start++]=i;\n		return arr;\n	}\n}","brute force,implementation"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.util.HashMap;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        HBerOSFileSuggestion solver = new HBerOSFileSuggestion();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class HBerOSFileSuggestion {\n        int n;\n        String[] arr;\n\n        public void readInput(Scanner sc) {\n            n = sc.nextInt();\n            arr = new String[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = sc.next();\n        }\n\n        public void solve(int testNumber, Scanner sc, PrintWriter pw) {\n            int q = 1;\n            while (q-- > 0) {\n                readInput(sc);\n                HashMap<String, Integer> map = new HashMap<>();\n                HashMap<String, String> map2 = new HashMap<>();\n                for (int i = 0; i < n; i++) {\n                    HashSet<String> set = new HashSet<>();\n                    for (int j = 0; j < arr[i].length(); j++)\n                        for (int k = j; k < arr[i].length(); k++) {\n                            String s = arr[i].substring(j, k + 1);\n                            set.add(s);\n                            map2.put(s, arr[i]);\n                        }\n                    for (String x : set)\n                        map.put(x, map.getOrDefault(x, 0) + 1);\n                }\n                int tc = sc.nextInt();\n                while (tc-- > 0) {\n                    String s = sc.next();\n                    pw.println(map.getOrDefault(s, 0) + "" "" + map2.getOrDefault(s, ""-""));\n                }\n            }\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() {\n            try {\n                while (st == null || !st.hasMoreTokens())\n                    st = new StringTokenizer(br.readLine());\n                return st.nextToken();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n","brute force,implementation"
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n// Created by @thesupremeone on 22/05/21\npublic class BerOSFileSuggestion {\n    HashSet<String> getAllSubstrings(String s){\n        HashSet<String> set = new HashSet<>();\n        for (int start = 0; start < s.length(); start++) {\n            for (int end = start; end < s.length(); end++) {\n                set.add(s.substring(start, end+1));\n            }\n        }\n        return set;\n    }\n\n    static class Res{\n        int index;\n        int freq;\n        public Res(int index, int freq) {\n            this.freq = freq;\n            this.index = index;\n        }\n    }\n\n    void solve() throws IOException {\n        int n = getInt();\n        String[] files = new String[n];\n        HashMap<String, Res> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            files[i] = getLine();\n            HashSet<String> set = getAllSubstrings(files[i]);\n            for(String s : set){\n                Res res;\n                if(map.containsKey(s)){\n                    res = map.get(s);\n                }else {\n                    res = new Res(i, 0);\n                    map.put(s, res);\n                }\n                res.freq++;\n            }\n        }\n        int q = getInt();\n        for (int i = 0; i < q; i++) {\n            String query = getLine();\n            Res res = map.get(query);\n            if(res==null){\n                println(""0 -"");\n            }else {\n                println(res.freq+"" ""+files[res.index]);\n            }\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        if (isOnlineJudge()) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new BufferedWriter(new OutputStreamWriter(System.out));\n            new BerOSFileSuggestion().solve();\n            out.flush();\n        } else {\n            localJudge = new Thread();\n            in = new BufferedReader(new FileReader(""input.txt""));\n            out = new BufferedWriter(new FileWriter(""output.txt""));\n            localJudge.start();\n            new BerOSFileSuggestion().solve();\n            out.flush();\n            localJudge.suspend();\n        }\n    }\n    static boolean isOnlineJudge(){\n        try {\n            return System.getProperty(""ONLINE_JUDGE"")!=null\n                    || System.getProperty(""LOCAL"")==null;\n        }catch (Exception e){\n            return true;\n        }\n    }\n    // Fast Input & Output\n    static Thread localJudge = null;\n    static BufferedReader in;\n    static StringTokenizer st;\n    static BufferedWriter out;\n    static String getLine() throws IOException{\n        return in.readLine();\n    }\n    static String getToken() throws IOException{\n        if(st==null || !st.hasMoreTokens())\n            st = new StringTokenizer(getLine());\n        return st.nextToken();\n    }\n    static int getInt() throws IOException {\n        return Integer.parseInt(getToken());\n    }\n    static long getLong() throws IOException {\n        return Long.parseLong(getToken());\n    }\n    static void print(Object s) throws IOException{\n        out.write(String.valueOf(s));\n    }\n    static void println(Object s) throws IOException{\n        out.write(String.valueOf(s));\n        out.newLine();\n    }\n}","brute force,implementation"
"/*\n                       _oo0oo_\n                      o8888888o\n                      88"" . ""88\n                      (| -_- |)\n                      0\  =  /0\n                    ___/`---'\___\n                  .' \\|     |// '.\n                 / \\|||  :  |||// \\n                / _||||| -:- |||||- \\n               |   | \\\  -  /// |   |\n               | \_|  ''\---/''  |_/ |\n               \  .-\__  '-'  ___/-. /\n             ___'. .'  /--.--\  `. .'___\n          ."""" '<  `.___\_<|>_/___.' >' """".\n         | | :  `- \`.;`\ _ /`;.`/ - ` : | |\n         \  \ `_.   \_ __\ /__ _/   .-` /  /\n     =====`-.____`.___ \_____/___.-`___.-'=====\n                       `=---='\n \n*/\n\nimport java.util.*;\nimport java.math.*;\nimport java.io.*;\nimport java.lang.Math.*;\n\npublic class KickStart2020 {\n	 static class FastReader {\n		BufferedReader br;\n		StringTokenizer st;\n\n		public FastReader() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		String next() {\n			while (st == null || !st.hasMoreElements()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			}\n			return st.nextToken();\n		}\n\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n\n		float nextFloat() {\n			return Float.parseFloat(next());\n		}\n\n		String nextLine() {\n			String str = """";\n			try {\n				str = br.readLine();\n			} catch (IOException e) {\n				e.printStackTrace();\n			}\n			return str;\n		}\n	}\n\n	static long gcd(long a, long b) {\n		if (b == 0)\n			return a;\n		return gcd(b, a % b);\n\n	}\n\n	static long lcm(long a, long b) {\n		return a / gcd(a, b) * b;\n	}\n\n	public static class Pair implements Comparable<Pair> {\n		public int index;\n		public int value;\n\n		public Pair(int index, int value) {\n			this.index = index;\n			this.value = value;\n		}\n\n		@Override\n		public int compareTo(Pair other) {\n			// multiplied to -1 as the author need descending sort order\n			if(other.index < this.index) return 1;\n			if(other.index > this.index) return -1;\n			if(other.value < this.value) return 1;\n			if(other.value > this.value) return -1;\n			else return 0;\n		}\n		@Override\n		public String toString() {\n			return this.index + "" "" + this.value;\n		}\n	}\n	static boolean isPrime(long d) {\n		if (d == 1)\n			return false;\n		for (int i = 2; i <= (long) Math.sqrt(d); i++) {\n			if (d % i == 0)\n				return false;\n		}\n		return true;\n	}\n	static void decimalTob(int n, int k, Stack<Integer> ss) {\n          int x = n % k;\n          int y = n / k;\n          ss.push(x);\n          if(y > 0) {\n        	   decimalTob(y, k, ss);\n          }\n	}\n	static long powermod(long x, long y, long mod) {\n		long ans = 1;\n		x = x % mod;\n		if (x == 0)\n			return 0;\n		int i = 1;\n		while (y > 0) {\n			if ((y & 1) != 0)\n				ans = (ans * x) % mod;\n			y = y >> 1;\n			x = (x * x) % mod;\n		}\n		return ans;\n	}\n	public static void main(String[] args) throws Exception {\n		FastReader sc = new FastReader();\n		PrintWriter out = new PrintWriter(System.out);\n		int t = 1;\n		outerloop:\n        while(t-- > 0) {\n         int n = sc.nextInt();\n         HashMap<String, Integer> ss = new HashMap<>(); \n         HashMap<String, String> ssd = new HashMap<>();\n         for(int i = 0; i < n; i++) {\n        	 String s = sc.next();\n        	 HashSet<String> fuck = new HashSet<>();\n        	 for(int j = 1; j <= s.length(); j++) {\n        		 for(int k = 0; k + j <= s.length(); k++) {\n        			 String temp = s.substring(k, k + j);\n        			 if(fuck.contains(temp)) continue;\n        			 ss.put(temp, ss.getOrDefault(temp, 0) + 1);\n        			 ssd.put(temp, s);\n        			 fuck.add(temp);\n        		 }\n        	 }\n         }\n         int q = sc.nextInt();\n         for(int i = 0; i < q; i++) {\n        	 String s = sc.next();\n        	 if(ssd.containsKey(s)) {\n        		 out.println(ss.get(s) + "" "" + ssd.get(s));\n        	 }\n        	 else out.println(""0 -"");\n         }\n        }\n		out.close();\n	}\n}","brute force,implementation"
import java.util.*;\npublic class cf518div2A {\npublic static void main(String[] args) {\nScanner sc=new Scanner(System.in);\nlong n=sc.nextLong();\nlong m=sc.nextLong();\nlong k=sc.nextLong();\nlong l=sc.nextLong();\nlong x=0;\nif((k+l)%m==0)\nx=(k+l)/m;\nelse\nx=(k+l)/m+1;\nif(m>n || m*x>n)\nSystem.out.println(-1);\nelse\nSystem.out.println(x);\nsc.close();\n}    \n},math
import java.util.*;\npublic class codeforce {\npublic static void main(String[] args) {\n  Scanner sc=new Scanner(System.in);\n  long n=sc.nextLong();\n  long m=sc.nextLong();\n  long k=sc.nextLong();\n  long l=sc.nextLong();\n  long x=0;\n    if((k+l)%m==0)\n    x=(k+l)/m;\n    else\n      x=(k+l)/m+1;\n      if(m>n || m*x>n)\n      System.out.println(-1);\n      else\n        System.out.println(x);\n        sc.close();\n  }    \n},math
import java.util.Scanner;\n\npublic class Da {\n\n    public static void main( String[] args ) {\n        Scanner scan = new Scanner( System.in );\n\n        long n = scan.nextLong();\n        long m = scan.nextLong();\n        long k = scan.nextLong();\n        long l = scan.nextLong();\n\n        long o = ( l + k + m - 1 ) / m;\n\n        if ( o * m > n ) {\n            System.out.println( -1 );\n            return;\n        }\n\n        System.out.println( o );\n    }\n},math
import java.util.Scanner;\n\npublic class Problem1068a {\n\n    public static void main(String args[])\n    {\n        Scanner in=new Scanner(System.in);\n        long n=0l;\n        long q=0l;\n        long t=0l;\n        long p=0l;\n        n=in.nextLong();\n        q=in.nextLong();\n        t=in.nextLong();\n        p=in.nextLong();\n        long res=0l;\n        res=t+p;\n        long ans=0l;\n        ans=(res+q-1)/q;\n        if(ans*q>n)\n        {\n            System.out.println(-1);\n        }else{\n            System.out.println(ans);\n        }\n    }\n},math
"import java.util.*;\npublic class MakeATriangle {\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int[] n = new int[3];\n		for(int i = 0;i < 3 ;i++) {\n			n[i] = sc.nextInt();\n		}\n		Arrays.sort(n);\n		System.out.println(Math.max(0, n[2] - n[1]-n[0] + 1));\n	}\n\n}\n","brute force,geometry,math"
"import java.util.*;\n\npublic class solution{\n	public static void main(String[] args){\n		Scanner scr=new Scanner(System.in);\n		ArrayList<Integer> a=new ArrayList<>();\n		a.add(scr.nextInt());\n		a.add(scr.nextInt());\n		a.add(scr.nextInt());\n		Collections.sort(a);\n		int ans=Math.max(0,a.get(2)+1-a.get(1)-a.get(0));\n		System.out.println(ans);\n	}\n}","brute force,geometry,math"
import java.util.*;\npublic class Solution {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int[] arr = new int[3];\n		for (int i=0;i<3;i++) arr[i]=sc.nextInt();\n		Arrays.parallelSort(arr);\n		if (arr[0]+arr[1]>arr[2])\n			System.out.println(0);\n		else System.out.println(arr[2]-arr[1]-arr[0]+1);\n	}\n},"brute force,geometry,math"
"import java.util.*;\npublic class class323 {\npublic static void main(String arg[])\n{\n	Scanner sc=new Scanner(System.in);\n	int a=sc.nextInt();\n	int b=sc.nextInt();\n	int c=sc.nextInt();\n	if(a>c)\n	{\n		int temp=c;\n		c=a;\n		a=temp;\n	}\n	if(b>c)\n	{\n		int temp=c;\n		c=b;\n		b=temp;	\n	}\n	int ans=Math.max(0,c-(a+b-1));\n	System.out.println(ans);\n}\n}\n","brute force,geometry,math"
import java.util.*;\npublic class vv {\n\n public static void main(String[] args) { \n Scanner no=new Scanner(System.in);\n int i=no.nextInt();\n String s=no.next();\n char arr[]=s.toCharArray();\n Arrays.sort(arr);\n String s1=new String(arr);\n System.out.println(s1);\n}\n\n}\n,"constructive algorithms,strings"
import java.util.*;\n \npublic class Demo{\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		String s = sc.next();\n		char arr [] = s.toCharArray();\n		Arrays.sort(arr);\n		System.out.println(new String(arr));\n		\n	}\n}\n ,"constructive algorithms,strings"
import java.util.*;\n \npublic class Demo{\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		String s = sc.next();\n		char arr [] = s.toCharArray();\n		Arrays.sort(arr);\n		System.out.println(new String(arr));\n		\n	}\n}\n ,"constructive algorithms,strings"
import java.util.*;\npublic class class1 {\n\n	public static void main(String[] args) {\n		Scanner input=new Scanner(System.in);\n		int n=input.nextInt();\n		String s=input.next();\n		char c[]=s.toCharArray();\n	    Arrays.sort(c);\n	    for(int i=0;i<n;i++) {\n	    	System.out.print(c[i]);\n	    }\n\n	}\n\n}\n,"constructive algorithms,strings"
import java.util.*;\n\npublic class aelmroijkjgaer {\n\n	static Scanner in = new Scanner(System.in);\n	\n	public static void main(String[] args) {\n		\n		int n = in.nextInt();\n		int m = in.nextInt();\n		\n		long ans = 0;\n		long f = 0;\n		\n		int[] tab = new int[n];\n		\n		for(int i = 0; i < n; i++) {\n			tab[i] = in.nextInt();\n			ans += tab[i];\n		}\n		\n		Arrays.sort(tab);\n		\n		for(int i = 0; i < n; i++) {\n			if(tab[i] > f) f++; \n		}\n		long last = tab[tab.length-1]-f;\n		System.out.println(ans-last-n);\n	}\n},"greedy,implementation,sortings"
import java.util.*;\n \npublic class Main {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n \n        int n = sc.nextInt();\n        int m = sc.nextInt();\n \n        long totalBlocks = 0;\n        long a[] = new long[n];\n        for(int i = 0; i < n; ++i) {\n            a[i] = sc.nextLong();\n            totalBlocks += a[i];\n        }\n \n        Arrays.sort(a);\n \n        long selected = 0;\n        for(int i = 0; i < n; ++i) {\n            if(a[i] > selected)\n                selected++;\n        }\n \n        long leftCols = a[n - 1] - selected;\n        long remBlocks = totalBlocks - leftCols - n;\n \n        System.out.print(remBlocks);\n    }\n},"greedy,implementation,sortings"
"import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n	public static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n	public static void main(String[] args) throws IOException {\n		readInput();\n		out.close();\n	}\n\n	public static void readInput() throws IOException {\n		// br = new BufferedReader(new FileReader("".in""));\n		// out = new PrintWriter(new FileWriter("".out""));\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int n = Integer.parseInt(st.nextToken());\n		long m = Long.parseLong(st.nextToken());\n		long max = 0;\n		long sum = 0;\n		st = new StringTokenizer(br.readLine());\n		Long[] a = new Long[n];\n		for (int i = 0; i < n; i++) {\n			long x = Long.parseLong(st.nextToken());\n			sum += x;\n			a[i] = x;\n		}\n		Arrays.sort(a);\n		long bucket = 0;\n		long cur = 0;\n		for (int i = 0; i < n-1; i++) {\n			cur = Math.min(cur+1, a[i]);\n			bucket++;\n		}\n		bucket += Math.max(1,a[n-1]-cur);\n		\n		out.println(sum-bucket);\n		\n	}\n}\n","greedy,implementation,sortings"
"// package cp;\nimport java.io.*;\nimport java.util.*;\npublic class Cf_three {\n	public static void main(String[] args) throws IOException {	\n		PrintWriter out = new PrintWriter(System.out);\n		Readers.init(System.in);\n		int n=Readers.nextInt();\n		int m=Readers.nextInt();\n		long[] a=new long[n] ;\n		long cnt=0;\n		long summ=0;\n		for (int i = 0; i < a.length; i++) {\n			a[i]=Readers.nextLong();\n			summ+=a[i];\n		}\n		Arrays.sort(a);\n		for (int i = 0; i < a.length-1; i++) {\n			cnt++;\n			cnt=Math.min(cnt, a[i]);\n		}\n		if (n==1) {\n			System.out.println(0); \n		}\n		else {\n			System.out.println(summ-(Math.max(1,a[n-1]-cnt)+n-1));\n		}\n		out.flush();\n	}\n\n}\nclass Readers {\n\n    static BufferedReader reader;\n\n    static StringTokenizer tokenizer;\n\n\n\n    /** call this method to initialize reader for InputStream */\n\n    static void init(InputStream input) {\n\n        reader = new BufferedReader(\n\n                     new InputStreamReader(input) );\n\n        tokenizer = new StringTokenizer("""");\n\n    }\n\n\n\n    /** get next word */\n\n    static String next() throws IOException {\n\n        while ( ! tokenizer.hasMoreTokens() ) {\n\n            //TODO add check for eof if necessary\n\n            tokenizer = new StringTokenizer(\n\n                   reader.readLine() );\n\n        }\n\n        return tokenizer.nextToken();\n\n    }\n\n\n\n    static int nextInt() throws IOException {\n\n        return Integer.parseInt( next() );\n\n    }\n\n	\n\n    static double nextDouble() throws IOException {\n\n        return Double.parseDouble( next() );\n\n    }\n    \n    \n    static long nextLong() throws IOException{\n    	\n		return Long.parseLong(next());\n	}\n\n}","greedy,implementation,sortings"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class I {\n	public static void main(String[] args) throws NumberFormatException, IOException {\n		Scanner sc = new Scanner();\n		int T = sc.nextInt();\n		PrintWriter out = new PrintWriter(System.out);\n		long[] arr = new long[(int) 1e7];\n		long oo = Long.MAX_VALUE;\n		while (T-- > 0) {\n			int n = sc.nextInt();\n			l = sc.nextInt();\n			r = sc.nextInt();\n			x = sc.nextLong();\n			y = sc.nextLong();\n			z = sc.nextLong();\n			long len = r + 0L - l + 1;\n			long b1 = sc.nextLong(), b2 = sc.nextLong();\n			arr[0] = (b1 % len) + l;\n			arr[1] = (b2 % len) + l;\n			for (int i = 2; i < n; i++) {\n				long b = add(add(mult(b1, x), mult(b2, y)), z);\n				b1 = b2;\n				b2 = b;\n				arr[i] = (b % len) + l;\n			}\n			long min = arr[0];\n			long global = oo;\n			for (int i = 1; i < n; ++i) {\n				if (arr[i] <= min) {\n					min = arr[i];\n					continue;\n				}\n				global = Math.min(global, min * arr[i]);\n//				min = Math.min(arr[i], min);\n			}\n\n			long max = arr[n - 1];\n			for (int i = n - 2; i >= 0; --i) {\n				if (arr[i] >= max) {\n					max = arr[i];\n					continue;\n				}\n				global = Math.min(global, max * arr[i]);\n//				max = Math.max(max, arr[i]);\n			}\n			out.println(global == oo ? ""IMPOSSIBLE"" : global);\n		}\n		out.close();\n\n	}\n\n	static long MOD = (1l << 32) - 1;\n\n	static long x, y, z;\n	static int l, r;\n\n	static long mult(long b, long x) {\n		long h = x / 4;\n		long one = (b * h) & MOD;\n		one *= 3;\n		long two = b * (x - 3 * h);\n		return add(one & MOD, two & MOD);\n	}\n\n	static long add(long a, long b) {\n		return (a + b) & MOD;\n	}\n\n	static class Scanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		Scanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		int nextInt() throws NumberFormatException, IOException {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() throws IOException, NumberFormatException {\n			return Long.parseLong(next());\n		}\n	}\n}",
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        A solver = new A();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class A {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int T = in.ni();\n            long mask = (1L << 32) - 1;\n            long[] deq = new long[20_000_001];\n            int di = 0;\n            for (int t = 0; t < T; t++) {\n                int n = in.ni();\n                long l = in.nl(), r = in.nl(), x = in.nl(), y = in.nl(), z = in.nl(), b1 = in.nl(), b2 = in.nl();\n                long[] b = new long[n];\n                b[0] = b1;\n                b[1] = b2;\n                for (int i = 2; i < n; i++) {\n                    long l1 = (b[i - 2] * x) + (b[i - 1] * y) + z;\n                    b[i] = l1 & mask;\n                }\n                for (int i = 0; i < n; i++) {\n                    b[i] = b[i] % (r - l + 1L) + l;\n                }\n                long ans = Long.MAX_VALUE;\n                long max = Long.MIN_VALUE;\n                di = 0;\n                //System.out.println(""Arrays.toString(a) = "" + Arrays.toString(a));\n                for (int i = n - 1; i >= 0; i--) {\n                    if (b[i] >= 0) {\n                        while (di > 0 && deq[di - 1] > b[i]) {\n                            ans = Math.min(ans, b[i] * deq[--di]);\n                        }\n                        deq[di++] = b[i];\n                    } else {\n                        if (b[i] < max) {\n                            ans = Math.min(ans, b[i] * max);\n                        }\n                    }\n                    max = Math.max(max, b[i]);\n                }\n\n                if (ans == Long.MAX_VALUE)\n                    out.println(""IMPOSSIBLE"");\n                else\n                    out.println(ans);\n            }\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String ns() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(ns());\n        }\n\n        public long nl() {\n            return Long.parseLong(ns());\n        }\n\n    }\n}\n\n",
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        A solver = new A();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class A {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int T = in.ni();\n            long mask = (1L << 32) - 1;\n            long[] deq = new long[20_000_001];\n            int di = 0;\n            for (int t = 0; t < T; t++) {\n                int n = in.ni();\n                long l = in.nl(), r = in.nl(), x = in.nl(), y = in.nl(), z = in.nl(), b1 = in.nl(), b2 = in.nl();\n                long[] b = new long[n];\n                b[0] = b1;\n                b[1] = b2;\n                for (int i = 2; i < n; i++) {\n                    long l1 = (b[i - 2] * x) + (b[i - 1] * y) + z;\n                    b[i] = l1 & mask;\n                }\n                for (int i = 0; i < n; i++) {\n                    b[i] = b[i] % (r - l + 1L) + l;\n                }\n                long ans = Long.MAX_VALUE;\n                long max = Long.MIN_VALUE;\n                di = 0;\n                //System.out.println(""Arrays.toString(a) = "" + Arrays.toString(a));\n                for (int i = n - 1; i >= 0; i--) {\n                    if (b[i] >= 0) {\n                        while (di > 0 && deq[di - 1] > b[i]) {\n                            ans = Math.min(ans, b[i] * deq[--di]);\n                        }\n                        deq[di++] = b[i];\n                    } else {\n                        if (b[i] < max) {\n                            ans = Math.min(ans, b[i] * max);\n                        }\n                    }\n                    max = Math.max(max, b[i]);\n                }\n\n                if (ans == Long.MAX_VALUE)\n                    out.println(""IMPOSSIBLE"");\n                else\n                    out.println(ans);\n            }\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String ns() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(ns());\n        }\n\n        public long nl() {\n            return Long.parseLong(ns());\n        }\n\n    }\n}\n\n",
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        A solver = new A();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class A {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int T = in.ni();\n            long mask = (1L << 32) - 1;\n            for (int t = 0; t < T; t++) {\n                int n = in.ni();\n                long l = in.nl(), r = in.nl(), x = in.nl(), y = in.nl(), z = in.nl(), b1 = in.nl(), b2 = in.nl();\n                long[] b = new long[n];\n                b[0] = b1;\n                b[1] = b2;\n                for (int i = 2; i < n; i++) {\n                    long l1 = (b[i - 2] * x) + (b[i - 1] * y) + z;\n                    b[i] = l1 & mask;\n                }\n                for (int i = 0; i < n; i++) {\n                    b[i] = b[i] % (r - l + 1L) + l;\n                }\n                long ans = Long.MAX_VALUE;\n                long max = Long.MIN_VALUE;\n                //System.out.println(""Arrays.toString(a) = "" + Arrays.toString(a));\n                long min = Long.MAX_VALUE;\n                for (int i = 0; i < n; i++) {\n                    if (b[i] >= 0) {\n                        if (b[i] > min) {\n                            ans = Math.min(ans, min * b[i]);\n                        }\n                        min = Math.min(min, b[i]);\n                    }\n                }\n                for (int i = n - 1; i >= 0; i--) {\n                    if (b[i] < 0) {\n                        if (b[i] < max) {\n                            ans = Math.min(ans, b[i] * max);\n                        }\n                    }\n                    max = Math.max(max, b[i]);\n                }\n\n                if (ans == Long.MAX_VALUE)\n                    out.println(""IMPOSSIBLE"");\n                else\n                    out.println(ans);\n            }\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String ns() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(ns());\n        }\n\n        public long nl() {\n            return Long.parseLong(ns());\n        }\n\n    }\n}\n\n",
"\nimport java.util.*;\npublic class Main {\n    public static void main(String[] args) \n    {\n       Scanner in = new Scanner(System.in);\n       int x=in.nextInt();\n       System.out.println((x==1)?-1:x-x%2+"" ""+2);\n    }\n\n}\n","brute force,constructive algorithms"
"import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n  Scanner in=new Scanner(System.in);\n  int n=in.nextInt();\n    if(n>1)\n      System.out.println(n+"" ""+n);\n    else\n      System.out.println(-1);\n  }\n  \n}","brute force,constructive algorithms"
"import java.util.*;\npublic class Solution{\npublic static void main(String[] args) {\nScanner sc=new Scanner(System.in);\nint n=sc.nextInt();\nif(n==1 ){\nSystem.out.println(-1);\n}\nelse{\nint p=n/2;\nSystem.out.println((p+1)+"" ""+(p+1));\n}\n}\n}","brute force,constructive algorithms"
"import java.util.Scanner;\npublic class A {\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		if(n==1)System.out.println(-1);\n		else System.out.println(n+"" ""+n);\n}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","brute force,constructive algorithms"
import java.util.*;\n\npublic class A671{\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n	String s=sc.next();\n	char[] c=s.toCharArray();\n	long ans=0;\n	long sum=0;\n	long mod=1000000007;\n	int n=s.length();\n	long a=1;long b=1;\n	for(int i=0;i<n;i++){\n	    if(c[i]=='a'){\n	        a++;\n	    }\n	    else if(c[i]=='b'){\n	       b=((a*b)%mod+mod)%mod;\n	       a=1;\n	    }\n	    \n	}\n	\n	b=((b*a)%mod+mod)%mod;\n  \n\n	System.out.println(b-1);\n \n \n        \n	}\n}\n ,"combinatorics,dp,implementation"
"import java.util.Scanner;\n\npublic class Main {\n	public static void main(String[] args) {\n		try(Scanner input = new Scanner(System.in)){\n			String s = input.nextLine();\n			long mod = 1000000007;\n			long resp = 1;\n			int count = 1;\n			for(int i = 0; i < s.length();i++) {\n				if(s.charAt(i)=='a') {\n					count++;\n				}else if(s.charAt(i)=='b') {\n					resp = calculateMOD(resp*count,mod);\n					count = 1;\n				}\n			}\n			resp = calculateMOD(resp*count,mod);\n			System.out.println(resp-1);\n		}\n	}\n	private static long calculateMOD(long n, long mod) {\n		return ((n%mod)+mod)%mod;\n	}\n}","combinatorics,dp,implementation"
"import java.util.*;\npublic class Solution{\n    public static void main(String[] args){\n        \n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        int n = s.length();\n        long M = (long) Math.pow(10,9) + 7;\n        \n        long a=0, b=0;\n        \n        for(int i=0;i<n;i++){\n            \n            if(s.charAt(i)=='b'){\n                b = a;\n            }else if(s.charAt(i)=='a'){\n                \n                a += b + 1;\n                a %= M;\n                \n            }\n            \n        }\n        \n        System.out.println(a);\n        \n    }\n}","combinatorics,dp,implementation"
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be ""Main"" only if the class is public. */\npublic class main\n{\n	public static void main (String[] args) throws java.lang.Exception\n	{\n		long m = 1000000007, res = 1;\n		Scanner in = new Scanner(System.in);\n		String s = in.nextLine(); String s1 = """"; \n		for(int i = 0; i < s.length(); i++){\n			if(s.charAt(i) =='a' || s.charAt(i) =='b') s1 += s.charAt(i);\n		}\n		for(int i = 0; i < s1.length();){\n			if(s1.charAt(i) =='a') {\n				int c=0;\n				while(i < s1.length() && s1.charAt(i) =='a') {\n					c++; i++;\n				}	\n				res=(res*(c+1)) % m;\n			} else i++;	\n		}\n	System.out.println((--res)%m);\n	}\n}","combinatorics,dp,implementation"
"import java.util.*;\nimport java.io.*;\npublic class B{\n	public static void main(String[] args)\n	{\n		FastScanner fs = new FastScanner();\n		PrintWriter out = new PrintWriter(System.out);\n		Map<String,Integer> hm = new HashMap();\n		Map<String,String> hm1 = new HashMap();\n		int n = fs.nextInt();\n		for(int ii=0;ii<n;ii++)\n		{\n			String str = fs.next();\n			for(int i=0;i<str.length();i++)\n			{\n				String cur = """";\n				for(int j=i;j<str.length();j++)\n				{\n					cur += str.charAt(j);\n					if(hm1.get(cur)!=null && hm1.get(cur).equals(str))continue;\n					hm.put(cur,hm.getOrDefault(cur,0)+1);\n					hm1.put(cur,str);\n				}\n			}\n		}\n		int q = fs.nextInt();\n		for(int qq=0;qq<q;qq++)\n		{\n			String str = fs.next();\n			if(!hm.containsKey(str))\n			{\n				out.println(""0 -"");\n			}\n			else\n			{\n				out.println(hm.get(str)+"" ""+hm1.get(str));\n			}\n		}\n		out.close();\n	}\n	static class FastScanner {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n		String next() {\n			while (!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		int[] readArray(int n) {\n			int[] a=new int[n];\n			for (int i=0; i<n; i++) a[i]=nextInt();\n			return a;\n		}\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n	}\n	public static int[] sort(int[] arr)\n	{\n		List<Integer> temp = new ArrayList();\n		for(int i:arr)temp.add(i);\n		Collections.sort(temp,Collections.reverseOrder());\n		int start = 0;\n		for(int i:temp)arr[start++]=i;\n		return arr;\n	}\n}","brute force,implementation"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.util.HashMap;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        HBerOSFileSuggestion solver = new HBerOSFileSuggestion();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class HBerOSFileSuggestion {\n        int n;\n        String[] arr;\n\n        public void readInput(Scanner sc) {\n            n = sc.nextInt();\n            arr = new String[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = sc.next();\n        }\n\n        public void solve(int testNumber, Scanner sc, PrintWriter pw) {\n            int q = 1;\n            while (q-- > 0) {\n                readInput(sc);\n                HashMap<String, Integer> map = new HashMap<>();\n                HashMap<String, String> map2 = new HashMap<>();\n                for (int i = 0; i < n; i++) {\n                    HashSet<String> set = new HashSet<>();\n                    for (int j = 0; j < arr[i].length(); j++)\n                        for (int k = j; k < arr[i].length(); k++) {\n                            String s = arr[i].substring(j, k + 1);\n                            set.add(s);\n                            map2.put(s, arr[i]);\n                        }\n                    for (String x : set)\n                        map.put(x, map.getOrDefault(x, 0) + 1);\n                }\n                int tc = sc.nextInt();\n                while (tc-- > 0) {\n                    String s = sc.next();\n                    pw.println(map.getOrDefault(s, 0) + "" "" + map2.getOrDefault(s, ""-""));\n                }\n            }\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() {\n            try {\n                while (st == null || !st.hasMoreTokens())\n                    st = new StringTokenizer(br.readLine());\n                return st.nextToken();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n","brute force,implementation"
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n// Created by @thesupremeone on 22/05/21\npublic class BerOSFileSuggestion {\n    HashSet<String> getAllSubstrings(String s){\n        HashSet<String> set = new HashSet<>();\n        for (int start = 0; start < s.length(); start++) {\n            for (int end = start; end < s.length(); end++) {\n                set.add(s.substring(start, end+1));\n            }\n        }\n        return set;\n    }\n\n    static class Res{\n        int index;\n        int freq;\n        public Res(int index, int freq) {\n            this.freq = freq;\n            this.index = index;\n        }\n    }\n\n    void solve() throws IOException {\n        int n = getInt();\n        String[] files = new String[n];\n        HashMap<String, Res> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            files[i] = getLine();\n            HashSet<String> set = getAllSubstrings(files[i]);\n            for(String s : set){\n                Res res;\n                if(map.containsKey(s)){\n                    res = map.get(s);\n                }else {\n                    res = new Res(i, 0);\n                    map.put(s, res);\n                }\n                res.freq++;\n            }\n        }\n        int q = getInt();\n        for (int i = 0; i < q; i++) {\n            String query = getLine();\n            Res res = map.get(query);\n            if(res==null){\n                println(""0 -"");\n            }else {\n                println(res.freq+"" ""+files[res.index]);\n            }\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        if (isOnlineJudge()) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new BufferedWriter(new OutputStreamWriter(System.out));\n            new BerOSFileSuggestion().solve();\n            out.flush();\n        } else {\n            localJudge = new Thread();\n            in = new BufferedReader(new FileReader(""input.txt""));\n            out = new BufferedWriter(new FileWriter(""output.txt""));\n            localJudge.start();\n            new BerOSFileSuggestion().solve();\n            out.flush();\n            localJudge.suspend();\n        }\n    }\n    static boolean isOnlineJudge(){\n        try {\n            return System.getProperty(""ONLINE_JUDGE"")!=null\n                    || System.getProperty(""LOCAL"")==null;\n        }catch (Exception e){\n            return true;\n        }\n    }\n    // Fast Input & Output\n    static Thread localJudge = null;\n    static BufferedReader in;\n    static StringTokenizer st;\n    static BufferedWriter out;\n    static String getLine() throws IOException{\n        return in.readLine();\n    }\n    static String getToken() throws IOException{\n        if(st==null || !st.hasMoreTokens())\n            st = new StringTokenizer(getLine());\n        return st.nextToken();\n    }\n    static int getInt() throws IOException {\n        return Integer.parseInt(getToken());\n    }\n    static long getLong() throws IOException {\n        return Long.parseLong(getToken());\n    }\n    static void print(Object s) throws IOException{\n        out.write(String.valueOf(s));\n    }\n    static void println(Object s) throws IOException{\n        out.write(String.valueOf(s));\n        out.newLine();\n    }\n}","brute force,implementation"
"/*\n                       _oo0oo_\n                      o8888888o\n                      88"" . ""88\n                      (| -_- |)\n                      0\  =  /0\n                    ___/`---'\___\n                  .' \\|     |// '.\n                 / \\|||  :  |||// \\n                / _||||| -:- |||||- \\n               |   | \\\  -  /// |   |\n               | \_|  ''\---/''  |_/ |\n               \  .-\__  '-'  ___/-. /\n             ___'. .'  /--.--\  `. .'___\n          ."""" '<  `.___\_<|>_/___.' >' """".\n         | | :  `- \`.;`\ _ /`;.`/ - ` : | |\n         \  \ `_.   \_ __\ /__ _/   .-` /  /\n     =====`-.____`.___ \_____/___.-`___.-'=====\n                       `=---='\n \n*/\n\nimport java.util.*;\nimport java.math.*;\nimport java.io.*;\nimport java.lang.Math.*;\n\npublic class KickStart2020 {\n	 static class FastReader {\n		BufferedReader br;\n		StringTokenizer st;\n\n		public FastReader() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		String next() {\n			while (st == null || !st.hasMoreElements()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			}\n			return st.nextToken();\n		}\n\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n\n		float nextFloat() {\n			return Float.parseFloat(next());\n		}\n\n		String nextLine() {\n			String str = """";\n			try {\n				str = br.readLine();\n			} catch (IOException e) {\n				e.printStackTrace();\n			}\n			return str;\n		}\n	}\n\n	static long gcd(long a, long b) {\n		if (b == 0)\n			return a;\n		return gcd(b, a % b);\n\n	}\n\n	static long lcm(long a, long b) {\n		return a / gcd(a, b) * b;\n	}\n\n	public static class Pair implements Comparable<Pair> {\n		public int index;\n		public int value;\n\n		public Pair(int index, int value) {\n			this.index = index;\n			this.value = value;\n		}\n\n		@Override\n		public int compareTo(Pair other) {\n			// multiplied to -1 as the author need descending sort order\n			if(other.index < this.index) return 1;\n			if(other.index > this.index) return -1;\n			if(other.value < this.value) return 1;\n			if(other.value > this.value) return -1;\n			else return 0;\n		}\n		@Override\n		public String toString() {\n			return this.index + "" "" + this.value;\n		}\n	}\n	static boolean isPrime(long d) {\n		if (d == 1)\n			return false;\n		for (int i = 2; i <= (long) Math.sqrt(d); i++) {\n			if (d % i == 0)\n				return false;\n		}\n		return true;\n	}\n	static void decimalTob(int n, int k, Stack<Integer> ss) {\n          int x = n % k;\n          int y = n / k;\n          ss.push(x);\n          if(y > 0) {\n        	   decimalTob(y, k, ss);\n          }\n	}\n	static long powermod(long x, long y, long mod) {\n		long ans = 1;\n		x = x % mod;\n		if (x == 0)\n			return 0;\n		int i = 1;\n		while (y > 0) {\n			if ((y & 1) != 0)\n				ans = (ans * x) % mod;\n			y = y >> 1;\n			x = (x * x) % mod;\n		}\n		return ans;\n	}\n	public static void main(String[] args) throws Exception {\n		FastReader sc = new FastReader();\n		PrintWriter out = new PrintWriter(System.out);\n		int t = 1;\n		outerloop:\n        while(t-- > 0) {\n         int n = sc.nextInt();\n         HashMap<String, Integer> ss = new HashMap<>(); \n         HashMap<String, String> ssd = new HashMap<>();\n         for(int i = 0; i < n; i++) {\n        	 String s = sc.next();\n        	 HashSet<String> fuck = new HashSet<>();\n        	 for(int j = 1; j <= s.length(); j++) {\n        		 for(int k = 0; k + j <= s.length(); k++) {\n        			 String temp = s.substring(k, k + j);\n        			 if(fuck.contains(temp)) continue;\n        			 ss.put(temp, ss.getOrDefault(temp, 0) + 1);\n        			 ssd.put(temp, s);\n        			 fuck.add(temp);\n        		 }\n        	 }\n         }\n         int q = sc.nextInt();\n         for(int i = 0; i < q; i++) {\n        	 String s = sc.next();\n        	 if(ssd.containsKey(s)) {\n        		 out.println(ss.get(s) + "" "" + ssd.get(s));\n        	 }\n        	 else out.println(""0 -"");\n         }\n        }\n		out.close();\n	}\n}","brute force,implementation"
import java.util.*;\npublic class cf518div2A {\npublic static void main(String[] args) {\nScanner sc=new Scanner(System.in);\nlong n=sc.nextLong();\nlong m=sc.nextLong();\nlong k=sc.nextLong();\nlong l=sc.nextLong();\nlong x=0;\nif((k+l)%m==0)\nx=(k+l)/m;\nelse\nx=(k+l)/m+1;\nif(m>n || m*x>n)\nSystem.out.println(-1);\nelse\nSystem.out.println(x);\nsc.close();\n}    \n},math
import java.util.*;\npublic class codeforce {\npublic static void main(String[] args) {\n  Scanner sc=new Scanner(System.in);\n  long n=sc.nextLong();\n  long m=sc.nextLong();\n  long k=sc.nextLong();\n  long l=sc.nextLong();\n  long x=0;\n    if((k+l)%m==0)\n    x=(k+l)/m;\n    else\n      x=(k+l)/m+1;\n      if(m>n || m*x>n)\n      System.out.println(-1);\n      else\n        System.out.println(x);\n        sc.close();\n  }    \n},math
import java.util.Scanner;\n\npublic class Da {\n\n    public static void main( String[] args ) {\n        Scanner scan = new Scanner( System.in );\n\n        long n = scan.nextLong();\n        long m = scan.nextLong();\n        long k = scan.nextLong();\n        long l = scan.nextLong();\n\n        long o = ( l + k + m - 1 ) / m;\n\n        if ( o * m > n ) {\n            System.out.println( -1 );\n            return;\n        }\n\n        System.out.println( o );\n    }\n},math
import java.util.Scanner;\n\npublic class Problem1068a {\n\n    public static void main(String args[])\n    {\n        Scanner in=new Scanner(System.in);\n        long n=0l;\n        long q=0l;\n        long t=0l;\n        long p=0l;\n        n=in.nextLong();\n        q=in.nextLong();\n        t=in.nextLong();\n        p=in.nextLong();\n        long res=0l;\n        res=t+p;\n        long ans=0l;\n        ans=(res+q-1)/q;\n        if(ans*q>n)\n        {\n            System.out.println(-1);\n        }else{\n            System.out.println(ans);\n        }\n    }\n},math
"import java.util.*;\npublic class MakeATriangle {\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int[] n = new int[3];\n		for(int i = 0;i < 3 ;i++) {\n			n[i] = sc.nextInt();\n		}\n		Arrays.sort(n);\n		System.out.println(Math.max(0, n[2] - n[1]-n[0] + 1));\n	}\n\n}\n","brute force,geometry,math"
"import java.util.*;\n\npublic class solution{\n	public static void main(String[] args){\n		Scanner scr=new Scanner(System.in);\n		ArrayList<Integer> a=new ArrayList<>();\n		a.add(scr.nextInt());\n		a.add(scr.nextInt());\n		a.add(scr.nextInt());\n		Collections.sort(a);\n		int ans=Math.max(0,a.get(2)+1-a.get(1)-a.get(0));\n		System.out.println(ans);\n	}\n}","brute force,geometry,math"
import java.util.*;\npublic class Solution {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int[] arr = new int[3];\n		for (int i=0;i<3;i++) arr[i]=sc.nextInt();\n		Arrays.parallelSort(arr);\n		if (arr[0]+arr[1]>arr[2])\n			System.out.println(0);\n		else System.out.println(arr[2]-arr[1]-arr[0]+1);\n	}\n},"brute force,geometry,math"
"import java.util.*;\npublic class class323 {\npublic static void main(String arg[])\n{\n	Scanner sc=new Scanner(System.in);\n	int a=sc.nextInt();\n	int b=sc.nextInt();\n	int c=sc.nextInt();\n	if(a>c)\n	{\n		int temp=c;\n		c=a;\n		a=temp;\n	}\n	if(b>c)\n	{\n		int temp=c;\n		c=b;\n		b=temp;	\n	}\n	int ans=Math.max(0,c-(a+b-1));\n	System.out.println(ans);\n}\n}\n","brute force,geometry,math"
import java.util.*;\npublic class vv {\n\n public static void main(String[] args) { \n Scanner no=new Scanner(System.in);\n int i=no.nextInt();\n String s=no.next();\n char arr[]=s.toCharArray();\n Arrays.sort(arr);\n String s1=new String(arr);\n System.out.println(s1);\n}\n\n}\n,"constructive algorithms,strings"
import java.util.*;\n \npublic class Demo{\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		String s = sc.next();\n		char arr [] = s.toCharArray();\n		Arrays.sort(arr);\n		System.out.println(new String(arr));\n		\n	}\n}\n ,"constructive algorithms,strings"
import java.util.*;\n \npublic class Demo{\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		String s = sc.next();\n		char arr [] = s.toCharArray();\n		Arrays.sort(arr);\n		System.out.println(new String(arr));\n		\n	}\n}\n ,"constructive algorithms,strings"
import java.util.*;\npublic class class1 {\n\n	public static void main(String[] args) {\n		Scanner input=new Scanner(System.in);\n		int n=input.nextInt();\n		String s=input.next();\n		char c[]=s.toCharArray();\n	    Arrays.sort(c);\n	    for(int i=0;i<n;i++) {\n	    	System.out.print(c[i]);\n	    }\n\n	}\n\n}\n,"constructive algorithms,strings"
import java.util.*;\n\npublic class aelmroijkjgaer {\n\n	static Scanner in = new Scanner(System.in);\n	\n	public static void main(String[] args) {\n		\n		int n = in.nextInt();\n		int m = in.nextInt();\n		\n		long ans = 0;\n		long f = 0;\n		\n		int[] tab = new int[n];\n		\n		for(int i = 0; i < n; i++) {\n			tab[i] = in.nextInt();\n			ans += tab[i];\n		}\n		\n		Arrays.sort(tab);\n		\n		for(int i = 0; i < n; i++) {\n			if(tab[i] > f) f++; \n		}\n		long last = tab[tab.length-1]-f;\n		System.out.println(ans-last-n);\n	}\n},"greedy,implementation,sortings"
import java.util.*;\n \npublic class Main {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n \n        int n = sc.nextInt();\n        int m = sc.nextInt();\n \n        long totalBlocks = 0;\n        long a[] = new long[n];\n        for(int i = 0; i < n; ++i) {\n            a[i] = sc.nextLong();\n            totalBlocks += a[i];\n        }\n \n        Arrays.sort(a);\n \n        long selected = 0;\n        for(int i = 0; i < n; ++i) {\n            if(a[i] > selected)\n                selected++;\n        }\n \n        long leftCols = a[n - 1] - selected;\n        long remBlocks = totalBlocks - leftCols - n;\n \n        System.out.print(remBlocks);\n    }\n},"greedy,implementation,sortings"
"import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n	public static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	public static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n	public static void main(String[] args) throws IOException {\n		readInput();\n		out.close();\n	}\n\n	public static void readInput() throws IOException {\n		// br = new BufferedReader(new FileReader("".in""));\n		// out = new PrintWriter(new FileWriter("".out""));\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int n = Integer.parseInt(st.nextToken());\n		long m = Long.parseLong(st.nextToken());\n		long max = 0;\n		long sum = 0;\n		st = new StringTokenizer(br.readLine());\n		Long[] a = new Long[n];\n		for (int i = 0; i < n; i++) {\n			long x = Long.parseLong(st.nextToken());\n			sum += x;\n			a[i] = x;\n		}\n		Arrays.sort(a);\n		long bucket = 0;\n		long cur = 0;\n		for (int i = 0; i < n-1; i++) {\n			cur = Math.min(cur+1, a[i]);\n			bucket++;\n		}\n		bucket += Math.max(1,a[n-1]-cur);\n		\n		out.println(sum-bucket);\n		\n	}\n}\n","greedy,implementation,sortings"
"// package cp;\nimport java.io.*;\nimport java.util.*;\npublic class Cf_three {\n	public static void main(String[] args) throws IOException {	\n		PrintWriter out = new PrintWriter(System.out);\n		Readers.init(System.in);\n		int n=Readers.nextInt();\n		int m=Readers.nextInt();\n		long[] a=new long[n] ;\n		long cnt=0;\n		long summ=0;\n		for (int i = 0; i < a.length; i++) {\n			a[i]=Readers.nextLong();\n			summ+=a[i];\n		}\n		Arrays.sort(a);\n		for (int i = 0; i < a.length-1; i++) {\n			cnt++;\n			cnt=Math.min(cnt, a[i]);\n		}\n		if (n==1) {\n			System.out.println(0); \n		}\n		else {\n			System.out.println(summ-(Math.max(1,a[n-1]-cnt)+n-1));\n		}\n		out.flush();\n	}\n\n}\nclass Readers {\n\n    static BufferedReader reader;\n\n    static StringTokenizer tokenizer;\n\n\n\n    /** call this method to initialize reader for InputStream */\n\n    static void init(InputStream input) {\n\n        reader = new BufferedReader(\n\n                     new InputStreamReader(input) );\n\n        tokenizer = new StringTokenizer("""");\n\n    }\n\n\n\n    /** get next word */\n\n    static String next() throws IOException {\n\n        while ( ! tokenizer.hasMoreTokens() ) {\n\n            //TODO add check for eof if necessary\n\n            tokenizer = new StringTokenizer(\n\n                   reader.readLine() );\n\n        }\n\n        return tokenizer.nextToken();\n\n    }\n\n\n\n    static int nextInt() throws IOException {\n\n        return Integer.parseInt( next() );\n\n    }\n\n	\n\n    static double nextDouble() throws IOException {\n\n        return Double.parseDouble( next() );\n\n    }\n    \n    \n    static long nextLong() throws IOException{\n    	\n		return Long.parseLong(next());\n	}\n\n}","greedy,implementation,sortings"
"import java.util.*;\nimport java.io.*;\n\npublic class C2018 {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int n = sc.nextInt(); int s = sc.nextInt(); int k = sc.nextInt();\n        int [] a = new int[n + 1];\n        for (int i = 1; i <= n; i++) a[i] = sc.nextInt();\n        String color = sc.next(); int [] c = new int[n + 1];\n        for (int i = 1; i <= n; i++) c[i] = (color.charAt(i - 1) == 'R' ? 0 : (color.charAt(i - 1) == 'G' ? 1 : 2));\n        int [][] dp = new int[n + 1][k + 1];\n        for (int [] arr: dp) {\n            Arrays.fill(arr, Integer.MAX_VALUE);\n        }\n        dp[s][a[s]] = 0;\n        for (int i = 1; i <= n; i++) {\n            dp[i][a[i]] = Math.abs(s - i);\n        }\n        for (int candies = 0; candies <= k; candies++) {\n            for (int pos = 1; pos <= n; pos++) {\n                if (dp[pos][candies] == Integer.MAX_VALUE) continue;\n                for (int nextPos = 1; nextPos <= n; nextPos++) {\n                    if (nextPos == pos) continue;\n                    if (a[nextPos] > a[pos] && c[nextPos] != c[pos]) {\n                        int newTotal = Math.min(k, candies + a[nextPos]);\n                        dp[nextPos][newTotal] = Math.min(dp[nextPos][newTotal], Math.abs(pos - nextPos) + dp[pos][candies]);\n                    }\n                }\n            }\n        }\n        int ans = Integer.MAX_VALUE;\n        for (int i = 1; i <= n; i++) ans = Math.min(ans, dp[i][k]);\n        out.println(ans == Integer.MAX_VALUE ? -1 : ans);\n        out.close();\n    }\n\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n\n    }\n\n}","*special,dp"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Mohammed Basioni\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        CTanyaAndColoredCandies solver = new CTanyaAndColoredCandies();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CTanyaAndColoredCandies {\n        static int n;\n        static int s;\n        static int k;\n        static int[] candies;\n        static char[] colors;\n        static int[][] memo = new int[51][20001];\n\n        static int dp(int previous, int sum) {\n            if (sum >= k)\n                return 0;\n\n            if (memo[previous][sum] != -1)\n                return memo[previous][sum];\n            int take = 10000;\n            for (int i = 0; i < n; i++)\n                if (colors[i] != colors[previous] && candies[i] > candies[previous])\n                    take = Math.min(take, Math.abs(previous - i) + dp(i, sum + candies[i]));\n\n\n            return memo[previous][sum] = take;\n        }\n\n        public void solve(int testNumber, Scanner sc, PrintWriter pw) {\n            n = sc.nextInt();\n            s = sc.nextInt();\n            k = sc.nextInt();\n            candies = new int[n];\n            colors = new char[n];\n            for (int i = 0; i < n; i++)\n                candies[i] = sc.nextInt();\n            String string = sc.nextLine();\n            for (int i = 0; i < n; i++)\n                colors[i] = string.charAt(i);\n            for (int[] arr : memo)\n                Arrays.fill(arr, -1);\n            int min = dp(s - 1, candies[s - 1]);\n            for (int i = 0; i < n; i++)\n                min = Math.min(min, Math.abs(i - (s - 1)) + dp(i, candies[i]));\n            pw.println(min >= 10000 ? -1 : min);\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String nextLine() {\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n    }\n}\n\n","*special,dp"
"import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1057c {\n\n    public static void main(String[] args) throws IOException {\n        int n = rni(), s = ni() - 1, k = ni(), r[] = ria(n), clr[] = new int[n], dp[][] = new int[n][k + 1];\n        char[] c = rcha();\n        for (int i = 0; i < n; ++i) {\n            if (c[i] == 'G') {\n                clr[i] = 1;\n            } else if (c[i] == 'B') {\n                clr[i] = 2;\n            }\n        }\n        int inf = n * n * n + 5;\n        for (int[] row : dp) {\n            fill(row, inf);\n        }\n        for (int i = 0; i < n; ++i) {\n            dp[i][min(k, r[i])] = abs(s - i);\n        }\n        for (int i = 0; i < k; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (dp[j][i] != inf) {\n                    for (int l = 0; l < n; ++l) {\n                        if (clr[l] != clr[j] && r[l] > r[j]) {\n                            dp[l][min(k, i + r[l])] = min(dp[l][min(k, i + r[l])], dp[j][i] + abs(j - l));\n                        }\n                    }\n                }\n            }\n        }\n        int ans = inf;\n        for (int i = 0; i < n; ++i) {\n            ans = min(ans, dp[i][k]);\n        }\n        if (ans == inf) {\n            prln(-1);\n        } else {\n            prln(ans);\n        }\n        close();\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int lcm(int a, int b) {return a * b / gcf(a, b);}\n    static long lcm(long a, long b) {return a * b / gcf(a, b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {prln(""yes"");}\n    static void pry() {prln(""Yes"");}\n    static void prY() {prln(""YES"");}\n    static void prno() {prln(""no"");}\n    static void prn() {prln(""No"");}\n    static void prN() {prln(""NO"");}\n    static boolean pryesno(boolean b) {prln(b ? ""yes"" : ""no""); return b;};\n    static boolean pryn(boolean b) {prln(b ? ""Yes"" : ""No""); return b;}\n    static boolean prYN(boolean b) {prln(b ? ""YES"" : ""NO""); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(""hlfd""); flush();}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}\n}","*special,dp"
"import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class C {\n\n    private static final int oo = Integer.MAX_VALUE / 4;\n\n    private void work() {\n        Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        n = sc.nextInt();\n        int s = sc.nextInt() - 1;\n        k = sc.nextInt();\n\n        r = new int[n];\n        for (int i = 0; i < n; i++) r[i] = sc.nextInt();\n        char[] c = sc.next().toCharArray();\n        sc.close();\n\n        deg = new int[n];\n        g = new int[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (c[i] != c[j]) {\n                    if (r[i] < r[j]) g[i][deg[i]++] = j;\n                    if (r[i] > r[j]) g[j][deg[j]++] = i;\n                }\n            }\n        }\n\n        memo = new int[n][k];\n        for(int i = 0; i < n; i++){\n            Arrays.fill(memo[i], - 1);\n        }\n\n        int res = oo;\n        for(int i = 0; i < n; i++){\n            int t = Math.abs(i - s) + go(i, r[i]);\n            if(t < res) res = t;\n        }\n\n        System.out.println(res == oo ? -1 : res);\n    }\n\n    private int n, k;\n    private int[] r, deg;\n    private int[][] g, memo;\n\n    private int go(int u, int candies){\n        if(candies >= k){\n            return 0;\n        }\n        if(memo[u][candies] >= 0) return memo[u][candies];\n\n        int ret = oo;\n        for(int i = 0; i < deg[u]; i++){\n            int v = g[u][i];\n            int t = Math.abs(u - v) + go(v, candies + r[v]);\n            if(t < ret) ret = t;\n        }\n\n        return memo[u][candies] = ret;\n    }\n\n    public static void main(String[] args) {\n        new C().work();\n    }\n}\n","*special,dp"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1054D extends PrintWriter {\n	CF1054D() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1054D o = new CF1054D(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int k = sc.nextInt();\n		int m = (1 << k) - 1;\n		int[] aa = new int[n];\n		for (int i = 0; i < n; i++)\n			aa[i] = sc.nextInt();\n		long cnt = 0;\n		HashMap<Integer, Integer> mp = new HashMap<>();\n		mp.put(0, 1);\n		for (int x = 0, i = 0; i < n; i++) {\n			int a = aa[i], b = a ^ m;\n			a ^= x; b ^= x;\n			int ka = mp.getOrDefault(a, 0);\n			int kb = mp.getOrDefault(b, 0);\n			if (ka <= kb) {\n				cnt += ka;\n				mp.put(x = a, ka + 1);\n			} else {\n				cnt += kb;\n				mp.put(x = b, kb + 1);\n			}\n		}\n		println((long) n * (n + 1) / 2 - cnt);\n	}\n}\n","greedy,implementation"
"import java.io.*;\n\n\nimport java.util.*;\n\n\n/*\n\n*/\n\n \n public class A {\n	static FastReader sc=null;\n	\n	public static void main(String[] args) {\n		sc=new FastReader();\n		int n=sc.nextInt(),k=sc.nextInt(),nax=(1<<k)-1;\n		int a[]=sc.readArray(n);\n		//since we can reach each state from any other state\n		//we can minimize greedily at each point of time\n		\n		\n		Map<Integer,Integer> map=new HashMap<>();\n		int curr=0;\n		long ans=0;\n		map.put(curr,1);\n		for(int e:a) {\n			curr^=e;\n			int c=map.getOrDefault(curr, 0),c2=map.getOrDefault(curr^nax, 0);\n			\n			if(c>c2) {\n				ans+=c2;\n				curr^=nax;\n				map.put(curr,++c2);\n			}\n			else {\n				ans+=c;\n				map.put(curr,++c);\n			}\n			\n		}\n		\n		//System.out.println(map.toString());\n		\n		long tot=(long)n*(n+1)/2-ans;\n		System.out.println(tot);\n		\n		\n		\n		\n	}\n	\n	static int[] ruffleSort(int a[]) {\n		ArrayList<Integer> al=new ArrayList<>();\n		for(int i:a)al.add(i);\n		Collections.sort(al);\n		for(int i=0;i<a.length;i++)a[i]=al.get(i);\n		return a;\n	}\n	\n	static void print(int a[]) {\n		for(int e:a) {\n			System.out.print(e+"" "");\n		}\n		System.out.println();\n	}\n	\n	static class FastReader{\n		\n		StringTokenizer st=new StringTokenizer("""");\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		\n		String next() {\n			while(!st.hasMoreTokens()) \n				try {\n					st=new StringTokenizer(br.readLine());\n				}\n			   catch(IOException e){\n				   e.printStackTrace();\n			   }\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n		\n		int[] readArray(int n) {\n			int a[]=new int[n];\n			for(int i=0;i<n;i++)a[i]=sc.nextInt();\n			return a;\n		}\n	}\n	\n	\n}\n","greedy,implementation"
"import java.util.*;\nimport java.io.*;\n\npublic class MailD {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int n = sc.nextInt(); int k = sc.nextInt();\n        int [] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = sc.nextInt();\n        int [] pref = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            pref[i] = pref[i - 1] ^ a[i - 1];\n        }\n        int [] reverse = new int[n + 1];\n        for (int i = 1; i <= n; i++) reverse[i] = pref[i] ^ ((1 << k) - 1);\n        Map<Pair, Integer> map = new HashMap<>();\n        for (int i = 1; i <= n; i++) {\n            Pair p = new Pair(pref[i], reverse[i]);\n            map.put(p, map.getOrDefault(p, 0) + 1);\n        }\n        long total = nC2(n + 1);\n        long min = 0;\n        for (Pair p: map.keySet()) {\n            int ct = map.get(p);\n            if (p.a == 0) {\n                ct++;\n            }\n            int first = ct / 2; int second = ct - first;\n            min = min + nC2(first) + nC2(second);\n        }\n        out.println(total - min);\n        out.close();\n    }\n\n    static long nC2(long x) {\n        return x * (x - 1) / 2;\n    }\n\n    static class Pair {\n        int a; int b;\n        Pair (int a, int b) {\n            this.a = Math.min(a, b); this.b = Math.max(a, b);\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Pair pair = (Pair) o;\n            return a == pair.a &&\n                    b == pair.b;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(a, b);\n        }\n    }\n\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n\n    }\n\n}","greedy,implementation"
"import java.util.*;\nimport java.io.*;\n \npublic class Sol{\n \nstatic class Pair implements Comparable<Pair>{\n        int id;long value;\n        public Pair(int id,long value) {\n         \n          this.id=id;this.value=value;\n        }\n        @Override\n        public int compareTo(Pair p){return Long.compare(p.value,value);}\n       \n   }\n \nstatic int n;\nstatic ArrayList<Integer> adj[]=new ArrayList[100005];\n \npublic static void main(String []args){\n \nint times=1;\n \nwhile(times-->0){\n \nn=ni();int k=ni();int temp=(int)Math.pow(2,k)-1;\nint a[]=new int[n+1];\nfor(int i=1;i<=n;i++)a[i]=ni();\n \nint xor=a[1];\nHashMap<Integer,Long> hs=new HashMap<>();\nhs.put(xor,1l);\nlong N=n;\nlong ans=N*(N+1)/2;\n \nfor(int i=2;i<=n;i++){\n    int xor1=xor^a[i]; int xor2=xor1^temp;\n   \n    if(xor1==0){\n     long c1=hs.getOrDefault(xor1,0l);\n     long c2=hs.getOrDefault(xor2,0l);\n   \n     if(c1>=c2-1){hs.put(xor2,c2+1);xor=xor2;}\n     else {hs.put(xor1,c1+1);xor=xor1;}\n    }\n  \n    else if(xor1==temp){\n     long c1=hs.getOrDefault(xor1,0l);\n     long c2=hs.getOrDefault(xor2,0l);\n   \n     if(c1>c2+1){hs.put(xor2,c2+1);xor=xor2;}\n     else {hs.put(xor1,c1+1);xor=xor1;}\n    }\n   else{\n     long c1=hs.getOrDefault(xor1,0l);\n     long c2=hs.getOrDefault(xor2,0l);\n   \n     if(c1>=c2){hs.put(xor2,c2+1);xor=xor2;}\n     else {hs.put(xor1,c1+1);xor=xor1;}\n   }\n }\n \nfor(Map.Entry<Integer,Long> entry:hs.entrySet()){\n   long count=entry.getValue();\n   ans=ans-((count)*(count-1))/2;\n   if(entry.getKey()==0)ans-=count;\n }\nans=Math.max(ans,1);\nout.println(ans);\n}out.close();}\n \n//-----------------Utility--------------------------------------------\n \nstatic long Comb[][]=new long[405][405];\nstatic long p2[]=new long[405];\nstatic long inv[]=new long[405];\nstatic long factorial[]=new long[405];\nstatic void precomp(){\n \ninv[0]=1;factorial[0]=1l;\n \nfor(long i=1;i<405;i++){factorial[(int)i]=i*factorial[(int)i-1];factorial[(int)i]%=mod;}\n \nfor(int i=1;i<405;i++){ inv[i]=power(factorial[i],mod-2);}\n \nfor(int i=0;i<405;i++){\n \n   for(int j=0;j<=i;j++){\n     Comb[i][j]=(((factorial[i]*inv[j])%mod)*inv[i-j])%mod;\n   }\n }\n \nfor(int i=0;i<405;i++)p2[i]=power(2,i);\n \n}\n \nstatic int Max=Integer.MAX_VALUE; static long mod=1000000007;\nstatic int v(char c){return (int)(c-'a')+1;}\npublic static long power(long x, long y )\n    {\n        //0^0 = 1\n        long res = 1L;\n        x = x%mod;\n        while(y > 0)\n        {\n            if((y&1)==1)\n                res = (res*x)%mod;\n            y >>= 1;\n            x = (x*x)%mod;\n        }\n        return res;\n    }\n//--------------------------------------------------------------------\n \nstatic InputStream inputStream = System.in;\nstatic OutputStream outputStream = System.out;\nstatic FastReader in=new FastReader(inputStream);\nstatic PrintWriter out=new PrintWriter(outputStream);\n \nstatic class FastReader \n{ \n  BufferedReader br; \n  StringTokenizer st; \n \n        FastReader(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n \n  public String next() \n  { \n      while (st == null || !st.hasMoreElements()) \n      { \n          try\n          { \n              st = new StringTokenizer(br.readLine()); \n          } \n          catch (IOException  e) \n          { \n              e.printStackTrace(); \n          } \n      } \n      return st.nextToken(); \n  } \n \n  public int nextInt() \n  { \n      return Integer.parseInt(next()); \n  } \n \n  public long nextLong() \n  { \n      return Long.parseLong(next()); \n  } \n \n public  double nextDouble() \n  { \n      return Double.parseDouble(next()); \n  } \n \n \n  String nextLine() \n  { \n      String str = """"; \n      try\n      { \n          str = br.readLine(); \n      } \n      catch (IOException e) \n      { \n          e.printStackTrace(); \n      } \n      return str; \n  } \n}\nstatic int ni(){return in.nextInt();}\nstatic long nl(){return in.nextLong();}\nstatic String ns(){return in.nextLine();}\nstatic int[] na(int n){int a[]=new int[n];for(int i=0;i<n;i++){a[i]=ni();} return a;}\n \n}","greedy,implementation"
"import java.util.*;\nimport java.io.*;\n \n   public class C\n   {\n      public static void main(String args[]) throws Exception\n      {\n         BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));  \n         StringTokenizer st = new StringTokenizer(infile.readLine());\n         int N = Integer.parseInt(st.nextToken());\n         int[] arr = new int[N];\n         st = new StringTokenizer(infile.readLine());\n         for(int i=0; i < N; i++)\n            arr[i] = Integer.parseInt(st.nextToken());\n         int[] arr2 = new int[N];\n         st = new StringTokenizer(infile.readLine());\n         for(int i=0; i < N; i++)\n            arr2[i] = Integer.parseInt(st.nextToken());\n         if(arr[0]+arr2[N-1] > 0)\n         {\n            System.out.println(""NO"");\n            return;\n         }\n         //find max\n         ArrayList<Integer> ls = new ArrayList<Integer>();\n         for(int i=0; i < N; i++)\n            if(arr[i]+arr2[i] == 0)\n               ls.add(i);\n         if(ls.size() == 0)\n         {\n            System.out.println(""NO"");\n            return;\n         }\n         //\n         int[] res = new int[N];\n         for(int i=0; i < N; i++)\n            res[i] = N-arr[i]-arr2[i];\n         for(int i=0; i < N; i++)\n         {\n            //right\n            int rcount = 0;\n            for(int j=i+1; j < N; j++)\n               if(res[i] < res[j])\n                  rcount++;\n            int lcount = 0;\n            for(int j=i-1; j >= 0; j--)\n               if(res[i] < res[j])\n                  lcount++;\n            if(arr[i] != lcount || arr2[i] != rcount)\n            {\n               System.out.println(""NO"");\n               return;\n            }\n         }\n         System.out.println(""YES"");\n         for(int a: res)\n            System.out.print(a+"" "");\n      }\n   }","constructive algorithms,implementation"
"import java.io.*;\nimport java.util.*;\nimport java.lang.*;\nimport static java.lang.Math.*;\n\n// Sachin_2961 submission //\npublic class Codeforces {\n    \n    public void solve() {\n        int n = fs.nInt();\n        int[]l = new int[n];\n        int[]r = new int[n];\n        for(int i=0;i<n;i++)\n            l[i] = fs.nInt();\n        for(int j=0;j<n;j++)\n            r[j] = fs.nInt();\n        int[]ans = new int[n];\n        for(int i=0;i<n;i++){\n            ans[i] = (n-l[i]-r[i]);\n        }\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++)\n                r[i] -= (ans[j]>ans[i])?1:0;\n\n            for(int j=0;j<i;j++)\n                l[i] -= (ans[j]>ans[i])?1:0;\n        }\n\n        for(int i=0;i<n;i++){\n            if( l[i] != 0 || r[i] != 0){\n                out.println(""NO"");\n                return;\n            }\n        }\n        out.println(""YES"");\n        for(int i:ans)\n            out.print(i+"" "");\n        out.println();\n    }\n    static boolean multipleTestCase = false; static FastScanner fs; static PrintWriter out;\n    public void run(){\n        fs = new FastScanner();\n        out = new PrintWriter(System.out);\n        int tc = (multipleTestCase)?fs.nInt():1;\n        while (tc-->0)solve();\n        out.flush();\n        out.close();\n    }\n    public static void main(String[]args){\n        try{\n            new Codeforces().run();\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n\n    }\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer("""");\n        String n() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        String Line()\n        {\n            String str = """";\n            try\n            {\n                str = br.readLine();\n            }catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        int nInt() {return Integer.parseInt(n()); }\n        long nLong() {return Long.parseLong(n());}\n        double nDouble(){return Double.parseDouble(n());}\n        int[]aI(int n){\n            int[]ar = new int[n];\n            for(int i=0;i<n;i++)\n                ar[i] = nInt();\n            return ar;\n        }\n    }\n    public static void sort(int[] arr){\n        ArrayList<Integer> ls = new ArrayList<Integer>();\n        for(int x: arr)\n            ls.add(x);\n        Collections.sort(ls);\n        for(int i=0; i < arr.length; i++)\n            arr[i] = ls.get(i);\n    }\n}","constructive algorithms,implementation"
"\nimport java.util.*;\nimport java.util.Map.Entry;\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class CF {\n	private static FS sc = new FS();\n	\n	private static class FS {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer("""");\n		String next() {\n			while (!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());				               \n	            } catch (IOException e) {}\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n	}\n	\n	private static class extra {\n		\n		static int[] intArr(int size) {\n			int[] a = new int[size];\n			for(int i = 0; i < size; i++) a[i] = sc.nextInt();\n			return a;\n		}\n		\n		static long[] longArr(int size) {\n			long[] a = new long[size];\n			for(int i = 0; i < size; i++) a[i] = sc.nextLong();\n			return a;\n		}\n		\n		static long intSum(int[] a) {\n			long sum = 0; \n			for(int i = 0; i < a.length; i++) {\n				sum += a[i];\n			}\n			return sum;\n		}\n		\n		static long longSum(long[] a) {\n			long sum = 0; \n			for(int i = 0; i < a.length; i++) {\n				sum += a[i];\n			}\n			return sum;\n		}\n		\n		static LinkedList[] graphD(int vertices, int edges) {\n			LinkedList<Integer>[] temp = new LinkedList[vertices+1];\n			for(int i = 0; i <= vertices; i++) temp[i] = new LinkedList<>();\n			for(int i = 0; i < edges; i++) {\n				int x = sc.nextInt();\n				int y = sc.nextInt();\n				temp[x].add(y);\n			}\n			return temp;\n		}\n		\n		static LinkedList[] graphUD(int vertices, int edges) {\n			LinkedList<Integer>[] temp = new LinkedList[vertices+1];\n			for(int i = 0; i <= vertices; i++) temp[i] = new LinkedList<>();\n			for(int i = 0; i < edges; i++) {\n				int x = sc.nextInt();\n				int y = sc.nextInt();\n				temp[x].add(y);\n				temp[y].add(x);\n			}\n			return temp;\n		}\n		\n		static void printG(LinkedList[] temp) {\n			for(LinkedList<Integer> aa:temp) System.out.println(aa);\n		}\n		\n		static long cal(long val, long pow, long mod) {\n			if(pow == 0) return 1;\n			long res = cal(val, pow/2, mod);\n			\n			long ret = (res*res)%mod;\n			if(pow%2 == 0) return ret;\n			return (val*ret)%mod;\n		}\n		\n		static long gcd(long a, long b) { return b == 0 ? a:gcd(b, a%b); }\n		\n	}\n	\n//	static int mod = (int) 1e9 + 7;\n	\n	static LinkedList<Integer>[] temp, temp2;\n	static int inf = (int)1e9;\n	static long[] tree;\n	static int c = 0, flag = 0;\n	\n	public static void main(String[] args) {\n//		int t = sc.nextInt();\n		int t = 1;\n		StringBuilder ret = new StringBuilder();\n		while(t-- > 0) {\n			int n = sc.nextInt(), flag = 0;\n			int[] l = extra.intArr(n), r = extra.intArr(n), a = new int[n];\n			for(int i = 0; i < n; i++) a[i] = n - l[i] - r[i];\n			for(int i = 0; i < n; i++) for(int j = 0; j < i; j++) l[i] -= (a[j] > a[i]) ? 1:0;\n			for(int i = 0; i < n; i++) for(int j = i + 1; j < n; j++) r[i] -= (a[j] > a[i]) ? 1:0;\n			for(int i = 0; i < n; i++) if (l[i] != 0 || r[i] != 0) flag = 1;\n			if(flag == 0) {\n				ret.append(""YES\n"");\n				for(int aa:a) ret.append(aa + "" "");\n			} else ret.append(""NO\n"");\n  		}\n		System.out.println(ret);\n	}\n}\n\n\n\n\n","constructive algorithms,implementation"
"import java.util.*;\n// import java.lang.*;\nimport java.io.*;\n\n//           THIS TEMPLATE MADE BY AKSH BANSAL.\n\npublic class Solution {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    private static boolean[] isPrime;\n    private static void primes(){\n        int num = (int)1e6; // PRIMES FROM 1 TO NUM\n        isPrime = new boolean[num];\n     \n        for (int i = 2; i< isPrime.length; i++) {\n           isPrime[i] = true;\n        }\n        for (int i = 2; i< Math.sqrt(num); i++) {\n           if(isPrime[i] == true) {\n              for(int j = (i*i); j<num; j = j+i) {\n                 isPrime[j] = false;\n              }\n           }\n        }\n    }\n    private static long gcd(long a, long b){\n        if(b==0)return a;\n        return gcd(b,a%b);\n    }\n    public static void main(String[] args) throws IOException {\n        FastReader sc = new FastReader();\n        PrintWriter out = new PrintWriter(System.out);\n        // primes();\n        // ________________________________\n\n        // _______________________________\n\n        int n = sc.nextInt();\n        int[] left =new int[n];\n        int[] right =new int[n];\n        for(int i=0;i<n;i++){\n            left[i] = sc.nextInt();\n        }\n        for(int i=0;i<n;i++){\n            right[i] = sc.nextInt();\n        }\n        solver(n,left, right, out);\n        // ________________________________\n        out.flush();\n    }\n\n    public static void solver(int n, int[] left, int[] right, PrintWriter out) {\n        if(left[0]+right[n-1]>0){\n            out.println(""NO"");\n            return;\n        }\n        boolean isPossible = false;\n        for(int i=0;i<n;i++){\n            if(left[i]+right[i]==0){\n                isPossible = true;\n                break;\n            }\n        }\n        if(!isPossible){\n            out.println(""NO"");\n            return;\n        }\n        int[] res = new int[n];\n        for(int i=0;i<n;i++){\n            res[i] = n-left[i]-right[i];\n        }\n        for(int i=0;i<n;i++){\n            int lcount = 0, rcount = 0;\n            for(int j=i+1;j<n;j++){\n                if(res[i]<res[j])rcount++;\n            }\n            for(int j=i-1;j>=0;j--){\n                if(res[i]<res[j])lcount++;\n            }\n            if(left[i]!=lcount || right[i]!=rcount){\n                // System.out.println(""__""+ i);\n                out.println(""NO"");\n                return;\n            }\n        }\n\n        out.println(""YES"");\n        for(int i=0;i<n;i++){\n            out.print(res[i]+"" "");\n        }\n    }\n}","constructive algorithms,implementation"
"import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\nimport static java.lang.Math.min;\n\npublic class Test {\n\n  static PrintWriter writer =\n      new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n  int D = 17;\n  int n, tn;\n  int N = 1 << D;\n  char[] s = new char[N], t = new char[N + N];\n  int[] sa = new int[N];\n  int[] ra = new int[N];\n  int[][] RH = new int[D][N];\n  int[][] ST = new int[D][N];\n\n  static int readInt() {\n    int ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  static long readLong() {\n    long ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  static String readString() {\n    StringBuilder b = new StringBuilder();\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (Character.isLetterOrDigit(c)) {\n          start = true;\n          b.append((char) c);\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return b.toString();\n  }\n\n  static int readChars(char[] a) {\n    int cnt = 0;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (Character.isLetterOrDigit(c)) {\n          start = true;\n          a[cnt++] = (char) c;\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return cnt;\n  }\n\n  public static void main(String[] args) {\n    Test te = new Test();\n    te.start();\n    writer.flush();\n  }\n\n  void buildSA() {\n    int sz = Integer.highestOneBit(n) << 1;\n    int[] ord = new int[sz + sz];\n    int[] buf = new int[sz + sz];\n    Integer[] idx = new Integer[n];\n    for (int i = 0; i < n; i++) {\n      idx[i] = i;\n      ord[i] = s[i];\n    }\n    for (int i = 1; i < n; i *= 2) {\n      final int len = i;\n      final int[] od = ord;\n      Arrays.sort(\n          idx,\n          0,\n          n,\n          (a, b) ->\n              od[a] != od[b]\n                  ? Integer.compare(od[a], od[b])\n                  : od[a + len] != od[b + len]\n                      ? Integer.compare(od[a + len], od[b + len])\n                      : Integer.compare(a, b));\n      buf[idx[0]] = 1;\n      for (int j = 1; j < n; j++) {\n        int a = idx[j], b = idx[j - 1];\n        if (ord[a] == ord[b] && ord[a + len] == ord[b + len]) buf[a] = buf[b];\n        else buf[a] = buf[b] + 1;\n      }\n      int[] tmp = buf;\n      buf = ord;\n      ord = tmp;\n    }\n    Arrays.fill(sa, -1);\n    Arrays.fill(ra, -1);\n    for (int i = 0; i < n; i++) {\n      sa[i] = idx[i];\n      ra[sa[i]] = i;\n    }\n  }\n\n  void buildST() {\n    int[] c = new int[n];\n    for (int d = 0, b = N; b > 1; d++, b >>= 1) {\n      for (int i = 0; i < n; i += b) c[i] = 0;\n      for (int i = 0; i < n; i++) {\n        int j = ra[i] / b * b;\n        ST[d][j + c[j]++] = i;\n      }\n    }\n  }\n\n  void buildRH() {\n    int l = 0;\n    for (int i = 0; i < n; i++) {\n      int j = ra[i];\n      if (j == 0) {\n        RH[0][0] = 0;\n        l = 0;\n        continue;\n      }\n      int k = sa[j - 1];\n      while (i + l < n && k + l < n && s[i + l] == s[k + l]) l++;\n      RH[0][j] = l;\n      if (l > 0) l--;\n    }\n    buildRM(RH, 0, n - 1, n);\n  }\n\n  void buildRM(int[][] r, int ll, int rr, int max) {\n    for (int d = 1, b = 1; b + b <= rr - ll + 1; d++, b <<= 1)\n      for (int i = ll; i <= rr; i++)\n        r[d][i] = min(r[d - 1][i], i + b <= rr ? r[d - 1][i + b] : max);\n  }\n\n  int getLCP(int i) {\n    int j = 0;\n    for (; i < n && j < tn; i++, j++) if (s[i] != t[j]) break;\n    return j;\n  }\n\n  int getLeft(int[][] a, int ll, int rr, int min) {\n    for (int d = D - 1, b = 1 << d; d >= 0; d--, b >>= 1)\n      if (ll + b - 1 <= rr && a[d][ll] > min) ll += b;\n    return ll;\n  }\n\n  int findSTFirst(int d, int ll, int rr, int i, int j, int a, int b) {\n    if (i > rr || j < ll) return -1;\n    if (i <= ll && rr <= j) {\n      if (ll == rr) {\n        if (sa[ll] < a || sa[ll] > b) return -1;\n        return ll;\n      }\n      int x = ll - 1, y = rr + 1;\n      while (y - x > 1) {\n        int m = (y + x) / 2;\n        if (ST[d][m] >= a) y = m;\n        else x = m;\n      }\n      if (y > rr || ST[d][y] > b) return -1;\n    }\n    int mid = (ll + rr) / 2;\n    int v = findSTFirst(d + 1, ll, mid, i, j, a, b);\n    return v == -1 ? findSTFirst(d + 1, mid + 1, rr, i, j, a, b) : v;\n  }\n\n  int compare(int i) {\n    int j;\n    for (j = 0; i < n && j < tn; i++, j++)\n      if (s[i] < t[j]) return -1;\n      else if (s[i] > t[j]) return 1;\n    return i < n ? 1 : j < tn ? -1 : 0;\n  }\n\n  int getLUB() {\n    int ll = -1, rr = n;\n    while (rr - ll > 1) {\n      int m = (rr + ll) / 2;\n      if (compare(sa[m]) > 0) rr = m;\n      else ll = m;\n    }\n    return rr;\n  }\n\n  void start() {\n    n = readChars(s);\n    buildSA();\n    buildRH();\n    buildST();\n    int q = readInt();\n    loop:\n    while (q-- > 0) {\n      int ll = readInt(), rr = readInt();\n      ll--;\n      rr--;\n      tn = readChars(t);\n      int start = getLUB();\n      if (start >= n) {\n        writer.println(-1);\n        continue;\n      }\n      int lcp = getLCP(sa[start]);\n      while (start < n) {\n        int next = getLeft(RH, start+1, n - 1, lcp - 1);\n        int ans = findSTFirst(0, 0, N - 1, start, next - 1, ll, rr - lcp);\n        if (ans != -1) {\n          writer.println(new String(s, sa[ans], lcp + 1));\n          continue loop;\n        }\n        start = next;\n        lcp = min(lcp, RH[0][start]);\n      }\n      writer.println(""-1"");\n    }\n  }\n}\n","data structures,string suffix structures"
"import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\nimport static java.lang.Math.min;\n\npublic class Test {\n\n  static PrintWriter writer =\n      new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n  int D = 17;\n  int n, tn;\n  int N = 1 << D;\n  char[] s = new char[N], t = new char[N + N];\n  int[] sa = new int[N];\n  int[] ra = new int[N];\n  int[][] RH = new int[D][N];\n  int[][] ST = new int[D][N];\n\n  static int readInt() {\n    int ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  static long readLong() {\n    long ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  static String readString() {\n    StringBuilder b = new StringBuilder();\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (Character.isLetterOrDigit(c)) {\n          start = true;\n          b.append((char) c);\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return b.toString();\n  }\n\n  static int readChars(char[] a) {\n    int cnt = 0;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (Character.isLetterOrDigit(c)) {\n          start = true;\n          a[cnt++] = (char) c;\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return cnt;\n  }\n\n  public static void main(String[] args) {\n    Test te = new Test();\n    te.start();\n    writer.flush();\n  }\n\n  void buildSA() {\n    int sz = Integer.highestOneBit(n) << 1;\n    int[] ord = new int[sz + sz];\n    int[] buf = new int[sz + sz];\n    Integer[] idx = new Integer[n];\n    for (int i = 0; i < n; i++) {\n      idx[i] = i;\n      ord[i] = s[i];\n    }\n    for (int i = 1; i < n; i *= 2) {\n      final int len = i;\n      final int[] od = ord;\n      Arrays.sort(\n          idx,\n          0,\n          n,\n          (a, b) ->\n              od[a] != od[b]\n                  ? Integer.compare(od[a], od[b])\n                  : od[a + len] != od[b + len]\n                      ? Integer.compare(od[a + len], od[b + len])\n                      : Integer.compare(a, b));\n      buf[idx[0]] = 1;\n      for (int j = 1; j < n; j++) {\n        int a = idx[j], b = idx[j - 1];\n        if (ord[a] == ord[b] && ord[a + len] == ord[b + len]) buf[a] = buf[b];\n        else buf[a] = buf[b] + 1;\n      }\n      int[] tmp = buf;\n      buf = ord;\n      ord = tmp;\n    }\n    Arrays.fill(sa, -1);\n    Arrays.fill(ra, -1);\n    for (int i = 0; i < n; i++) {\n      sa[i] = idx[i];\n      ra[sa[i]] = i;\n    }\n  }\n\n  void buildST() {\n    int[] c = new int[n];\n    for (int d = 0, b = N; b > 1; d++, b >>= 1) {\n      for (int i = 0; i < n; i += b) c[i] = 0;\n      for (int i = 0; i < n; i++) {\n        int j = ra[i] / b * b;\n        ST[d][j + c[j]++] = i;\n      }\n    }\n  }\n\n  void buildRH() {\n    int l = 0;\n    for (int i = 0; i < n; i++) {\n      int j = ra[i];\n      if (j == 0) {\n        RH[0][0] = 0;\n        l = 0;\n        continue;\n      }\n      int k = sa[j - 1];\n      while (i + l < n && k + l < n && s[i + l] == s[k + l]) l++;\n      RH[0][j] = l;\n      if (l > 0) l--;\n    }\n    buildRM(RH, 0, n - 1, n);\n  }\n\n  void buildRM(int[][] r, int ll, int rr, int max) {\n    for (int d = 1, b = 1; b + b <= rr - ll + 1; d++, b <<= 1)\n      for (int i = ll; i <= rr; i++)\n        r[d][i] = min(r[d - 1][i], i + b <= rr ? r[d - 1][i + b] : max);\n  }\n\n  int getLCP(int i) {\n    int j = 0;\n    for (; i < n && j < tn; i++, j++) if (s[i] != t[j]) break;\n    return j;\n  }\n\n  int getRMFirst(int[][] a, int ll, int rr, int min) {\n    for (int d = D - 1, b = 1 << d; d >= 0; d--, b >>= 1)\n      if (ll + b - 1 <= rr && a[d][ll] > min) ll += b;\n    return ll;\n  }\n\n  int findSTFirst(int d, int ll, int rr, int i, int j, int a, int b) {\n    if (i > rr || j < ll) return -1;\n    if (i <= ll && rr <= j) {\n      if (ll == rr) {\n        if (sa[ll] < a || sa[ll] > b) return -1;\n        return ll;\n      }\n      int x = ll - 1, y = rr + 1;\n      while (y - x > 1) {\n        int m = (y + x) / 2;\n        if (ST[d][m] >= a) y = m;\n        else x = m;\n      }\n      if (y > rr || ST[d][y] > b) return -1;\n    }\n    int mid = (ll + rr) / 2;\n    int v = findSTFirst(d + 1, ll, mid, i, j, a, b);\n    return v == -1 ? findSTFirst(d + 1, mid + 1, rr, i, j, a, b) : v;\n  }\n\n  int compare(int i) {\n    int j;\n    for (j = 0; i < n && j < tn; i++, j++)\n      if (s[i] < t[j]) return -1;\n      else if (s[i] > t[j]) return 1;\n    return i < n ? 1 : j < tn ? -1 : 0;\n  }\n\n  int getLUB() {\n    int ll = -1, rr = n;\n    while (rr - ll > 1) {\n      int m = (rr + ll) / 2;\n      if (compare(sa[m]) > 0) rr = m;\n      else ll = m;\n    }\n    return rr;\n  }\n\n  void start() {\n    n = readChars(s);\n    buildSA();\n    buildRH();\n    buildST();\n    int q = readInt();\n    loop:\n    while (q-- > 0) {\n      int ll = readInt(), rr = readInt();\n      ll--;\n      rr--;\n      tn = readChars(t);\n      int start = getLUB();\n      if (start >= n) {\n        writer.println(-1);\n        continue;\n      }\n      int lcp = getLCP(sa[start]);\n      while (start < n) {\n        int next = getRMFirst(RH, start+1, n - 1, lcp - 1);\n        int ans = findSTFirst(0, 0, N - 1, start, next - 1, ll, rr - lcp);\n        if (ans != -1) {\n          writer.println(new String(s, sa[ans], lcp + 1));\n          continue loop;\n        }\n        start = next;\n        lcp = min(lcp, RH[0][start]);\n      }\n      writer.println(""-1"");\n    }\n  }\n}\n","data structures,string suffix structures"
"import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\nimport static java.lang.Math.min;\n\npublic class Test {\n\n  static PrintWriter writer =\n      new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n  int D = 17;\n  int n, tn;\n  int N = 1 << D;\n  char[] s = new char[N], t = new char[N + N];\n  int[] sa = new int[N];\n  int[] ra = new int[N];\n  int[][] RH = new int[D][N];\n  int[][] ST = new int[D][N];\n\n  static int readInt() {\n    int ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  static long readLong() {\n    long ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  static String readString() {\n    StringBuilder b = new StringBuilder();\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (Character.isLetterOrDigit(c)) {\n          start = true;\n          b.append((char) c);\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return b.toString();\n  }\n\n  static int readChars(char[] a) {\n    int cnt = 0;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (Character.isLetterOrDigit(c)) {\n          start = true;\n          a[cnt++] = (char) c;\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return cnt;\n  }\n\n  public static void main(String[] args) {\n    Test te = new Test();\n    te.start();\n    writer.flush();\n  }\n\n  void buildSA() {\n    int sz = Integer.highestOneBit(n) << 1;\n    int[] ord = new int[sz + sz];\n    int[] buf = new int[sz + sz];\n    Integer[] idx = new Integer[n];\n    for (int i = 0; i < n; i++) {\n      idx[i] = i;\n      ord[i] = s[i];\n    }\n    for (int i = 1; i < n; i *= 2) {\n      final int len = i;\n      final int[] od = ord;\n      Arrays.sort(\n          idx,\n          0,\n          n,\n          (a, b) ->\n              od[a] != od[b]\n                  ? Integer.compare(od[a], od[b])\n                  : od[a + len] != od[b + len]\n                      ? Integer.compare(od[a + len], od[b + len])\n                      : Integer.compare(a, b));\n      buf[idx[0]] = 1;\n      for (int j = 1; j < n; j++) {\n        int a = idx[j], b = idx[j - 1];\n        if (ord[a] == ord[b] && ord[a + len] == ord[b + len]) buf[a] = buf[b];\n        else buf[a] = buf[b] + 1;\n      }\n      int[] tmp = buf;\n      buf = ord;\n      ord = tmp;\n    }\n    Arrays.fill(sa, -1);\n    Arrays.fill(ra, -1);\n    for (int i = 0; i < n; i++) {\n      sa[i] = idx[i];\n      ra[sa[i]] = i;\n    }\n  }\n\n  void buildST() {\n    int[] c = new int[n];\n    for (int d = 0, b = N; b > 1; d++, b >>= 1) {\n      for (int i = 0; i < n; i += b) c[i] = 0;\n      for (int i = 0; i < n; i++) {\n        int j = ra[i] / b * b;\n        ST[d][j + c[j]++] = i;\n      }\n    }\n  }\n\n  void buildRH() {\n    int l = 0;\n    for (int i = 0; i < n; i++) {\n      int j = ra[i];\n      if (j == 0) {\n        RH[0][0] = 0;\n        l = 0;\n        continue;\n      }\n      int k = sa[j - 1];\n      while (i + l < n && k + l < n && s[i + l] == s[k + l]) l++;\n      RH[0][j] = l;\n      if (l > 0) l--;\n    }\n    buildRM(RH, 0, n - 1, n);\n  }\n\n  void buildRM(int[][] r, int ll, int rr, int max) {\n    for (int d = 1, b = 1; b + b <= rr - ll + 1; d++, b <<= 1)\n      for (int i = ll; i <= rr; i++)\n        r[d][i] = min(r[d - 1][i], i + b <= rr ? r[d - 1][i + b] : max);\n  }\n\n  int getLCP(int i) {\n    int j = 0;\n    for (; i < n && j < tn; i++, j++) if (s[i] != t[j]) break;\n    return j;\n  }\n\n  int getRMFirst(int[][] a, int ll, int rr, int min) {\n    for (int d = D - 1, b = 1 << d; d >= 0; d--, b >>= 1)\n      if (ll + b - 1 <= rr && a[d][ll] > min) ll += b;\n    return ll;\n  }\n\n  int findSTFirst(int d, int ll, int rr, int i, int j, int a, int b) {\n    if (i > rr || j < ll) return -1;\n    if (i <= ll && rr <= j) {\n      if (ll == rr) {\n        if (sa[ll] < a || sa[ll] > b) return -1;\n        return ll;\n      }\n      int x = ll - 1, y = rr + 1;\n      while (y - x > 1) {\n        int m = (y + x) / 2;\n        if (ST[d][m] >= a) y = m;\n        else x = m;\n      }\n      if (y > rr || ST[d][y] > b) return -1;\n    }\n    int mid = (ll + rr) / 2;\n    int v = findSTFirst(d + 1, ll, mid, i, j, a, b);\n    return v == -1 ? findSTFirst(d + 1, mid + 1, rr, i, j, a, b) : v;\n  }\n\n  int compare(int i) {\n    int j;\n    for (j = 0; i < n && j < tn; i++, j++)\n      if (s[i] < t[j]) return -1;\n      else if (s[i] > t[j]) return 1;\n    return i < n ? 1 : j < tn ? -1 : 0;\n  }\n\n  int getLUB() {\n    int ll = -1, rr = n;\n    while (rr - ll > 1) {\n      int m = (rr + ll) / 2;\n      if (compare(sa[m]) > 0) rr = m;\n      else ll = m;\n    }\n    return rr;\n  }\n\n  void start() {\n    n = readChars(s);\n    buildSA();\n    buildRH();\n    buildST();\n    int q = readInt();\n    loop:\n    while (q-- > 0) {\n      int ll = readInt(), rr = readInt();\n      ll--;\n      rr--;\n      tn = readChars(t);\n      int start = getLUB();\n      if (start >= n) {\n        writer.println(-1);\n        continue;\n      }\n      int lcp = getLCP(sa[start]);\n      while (start < n) {\n        int next = getRMFirst(RH, start + 1, n - 1, lcp - 1);\n        int ans = findSTFirst(0, 0, N - 1, start, next - 1, ll, rr - lcp);\n        if (ans != -1) {\n          writer.println(new String(s, sa[ans], lcp + 1));\n          continue loop;\n        }\n        start = next;\n        lcp = min(lcp, RH[0][start]);\n      }\n      writer.println(""-1"");\n    }\n  }\n}\n","data structures,string suffix structures"
"import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\nimport static java.lang.Math.min;\n\npublic class Test {\n\n  static PrintWriter writer =\n      new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n  int D = 17;\n  int n;\n  int N = 1 << D;\n  String s, t;\n  char[] cs;\n  int[] ord = new int[N + N];\n  int[] buf = new int[N + N];\n  int[] sa = new int[N];\n  int[] ra = new int[N];\n  int[][] sh = new int[D][N + N];\n  Integer[] idx = new Integer[N];\n  int[][] H = new int[D][N];\n  int[][] S = new int[D][N];\n  int[][] R = new int[D][N];\n  int[][][] M = new int[D][D][N];\n  int[][][] P = new int[D][D][N];\n  int[] ans = {-1, -1};\n  int glb = -1;\n\n  static int readInt() {\n    int ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  static long readLong() {\n    long ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  static String readLine() {\n    StringBuilder b = new StringBuilder();\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (Character.isLetterOrDigit(c)) {\n          start = true;\n          b.append((char) c);\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return b.toString();\n  }\n\n  public static void main(String[] args) {\n    Test te = new Test();\n    te.start();\n    writer.flush();\n  }\n\n  void buildSA() {\n    for (int i = 0; i < n; i++) {\n      idx[i] = i;\n      ord[i] = s.charAt(i);\n    }\n    for (int i = 1; i < n; i *= 2) {\n      final int len = i;\n      Arrays.sort(\n          idx,\n          0,\n          n,\n          (a, b) ->\n              ord[a] != ord[b]\n                  ? Integer.compare(ord[a], ord[b])\n                  : ord[a + len] != ord[b + len]\n                      ? Integer.compare(ord[a + len], ord[b + len])\n                      : Integer.compare(a, b));\n      buf[idx[0]] = 1;\n      for (int j = 1; j < n; j++) {\n        int a = idx[j], b = idx[j - 1];\n        if (ord[a] == ord[b] && ord[a + len] == ord[b + len]) buf[a] = buf[b];\n        else buf[a] = buf[b] + 1;\n      }\n      int[] tmp = buf;\n      buf = ord;\n      ord = tmp;\n    }\n    Arrays.fill(sa, -1);\n    Arrays.fill(ra, -1);\n    for (int i = 0; i < n; i++) {\n      sa[i] = idx[i];\n      ra[sa[i]] = i;\n    }\n  }\n\n  void buildST(int d, int ll, int rr) {\n    if (ll >= rr) return;\n    int mid = (ll + rr) / 2;\n    buildST(d + 1, ll, mid);\n    buildST(d + 1, mid + 1, rr);\n    buildSTN(d, ll, rr);\n  }\n\n  void buildH() {\n    Arrays.fill(sh[0], n);\n    int l = 0;\n    for (int i = 0; i < n; i++) {\n      int j = ra[i];\n      if (j == 0) {\n        sh[0][0] = 0;\n        l = 0;\n        continue;\n      }\n      int k = sa[j - 1];\n      while (i + l < n && k + l < n && cs[i + l] == cs[k + l]) l++;\n      sh[0][j] = l;\n      if (l > 0) l--;\n    }\n    for (int d = 1, b = 1; d < D; d++, b *= 2)\n      for (int i = 0; i < n; i++) sh[d][i] = min(sh[d - 1][i], sh[d - 1][i + b]);\n  }\n\n  int getH(int i, int j) {\n    i++;\n    int ans = n;\n    for (int d = D - 1, b = 1 << d; d >= 0; d--, b >>= 1)\n      if (i + b - 1 <= j) {\n        ans = min(ans, sh[d][i]);\n        i += b;\n      }\n    return ans;\n  }\n\n  void buildSTN(int d, int ll, int rr) {\n    for (int i = ll; i <= rr; i++) idx[i] = i;\n    Arrays.sort(idx, ll, rr + 1, Comparator.comparingInt(i -> ra[i]));\n    for (int i = ll; i <= rr; i++) {\n      S[d][i] = idx[i];\n      R[d][idx[i]] = i;\n    }\n    H[d][ll] = 0;\n    for (int i = ll + 1; i <= rr; i++) {\n      int ri = ra[S[d][i]], rj = ra[S[d][i - 1]];\n      H[d][i] = getH(rj, ri);\n    }\n    for (int i = ll; i <= rr; i++) {\n      M[d][0][i] = S[d][i];\n      P[d][0][i] = H[d][i];\n    }\n    for (int k = 1, b = 1; b+b <= rr - ll + 1; k++, b <<= 1)\n      for (int j = ll; j <= rr; j++) {\n        M[d][k][j] = min(M[d][k - 1][j], j + b <= rr ? M[d][k - 1][j + b] : rr);\n        P[d][k][j] = min(P[d][k - 1][j], j + b <= rr ? P[d][k - 1][j + b] : n);\n      }\n  }\n\n  int getLCP(int i) {\n    int j = 0;\n    for (; i < n && j < t.length(); i++, j++) if (cs[i] != t.charAt(j)) break;\n    return j;\n  }\n\n  void getMin(int i, int j) {\n    if (ans[0] == -1 || ra[i] < ra[ans[0]]) {\n      ans[0] = i;\n      ans[1] = j;\n    }\n  }\n\n  int getStart(int[][][] a, int d, int ll, int rr, int h) {\n    for (int k = D - 1, b = 1 << k; k >= 0; k--, b >>= 1)\n      if (ll + b - 1 <= rr && a[d][k][ll] >= h) ll += b;\n    return ll;\n  }\n\n  void getGLB(int d, int ll, int rr, int b) {\n    int i = ll - 1, j = rr + 1;\n    while (j - i > 1) {\n      int m = (i + j) / 2;\n      if (ra[S[d][m]] > glb) j = m;\n      else i = m;\n    }\n    if (j > rr) return;\n    int start = j;\n    i = S[d][start];\n    int lcp = getLCP(i);\n    if (i + lcp <= b) {\n      getMin(i, i + lcp);\n      return;\n    }\n    start++;\n    while (start <= rr) {\n      lcp = min(lcp, H[d][start]);\n      ll = getStart(P, d, start, rr, lcp);\n      j = getStart(M, d, start, ll - 1, b - lcp + 1);\n      if (j <= ll - 1) {\n        int r = S[d][j];\n        getMin(r, r + lcp);\n        return;\n      }\n      start = ll;\n    }\n  }\n\n  void search(int d, int ll, int rr, int i, int j) {\n    if (i > rr || j < ll) return;\n    if (i <= ll && rr <= j) {\n      if (ll == rr) {\n        if (ra[ll] <= glb) return;\n        int lcp = getLCP(ll);\n        if (ll + lcp <= j) getMin(ll, ll + lcp);\n        return;\n      }\n      getGLB(d, ll, rr, j);\n      return;\n    }\n    int mid = (ll + rr) / 2;\n    search(d + 1, ll, mid, i, j);\n    search(d + 1, mid + 1, rr, i, j);\n  }\n\n  int compare(int i) {\n    int j;\n    for (j = 0; i < n && j < t.length(); i++, j++)\n      if (cs[i] < t.charAt(j)) return -1;\n      else if (cs[i] > t.charAt(j)) return 1;\n    return i < n ? 1 : j < t.length() ? -1 : 0;\n  }\n\n  int getGLB() {\n    int ll = -1, rr = n;\n    while (rr - ll > 1) {\n      int m = (rr + ll) / 2;\n      if (compare(sa[m]) <= 0) ll = m;\n      else rr = m;\n    }\n    return ll;\n  }\n\n  void start() {\n    s = readLine();\n    n = s.length();\n    cs = s.toCharArray();\n    buildSA();\n    buildH();\n    buildST(0, 0, n - 1);\n    int q = readInt();\n    for (int i = 0; i < q; i++) {\n      int ll = readInt(), rr = readInt();\n      ll--;\n      rr--;\n      t = readLine();\n      ans[0] = -1;\n      ans[1] = -1;\n      glb = getGLB();\n      if (glb + 1 >= n) {\n        writer.println(-1);\n        continue;\n      }\n      search(0, 0, n - 1, ll, rr);\n      if (ans[0] == -1) writer.println(""-1"");\n      else writer.println(s.substring(ans[0], ans[1] + 1));\n      writer.flush();\n    }\n  }\n}\n","data structures,string suffix structures"
"import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class CoveredPoints {\n    static class Point{\n        int x,y,j;\n        Point(int x, int y, int j){\n            this.x=x;\n            this.y=y;\n            this.j=j;\n        }\n    }\n    static long gcd(long a, long b){\n        return b==0?a:gcd(b,a%b);\n    }\n    static long cross(int x1,int y1, int x2, int y2){\n        return (long) x1*y2- (long) x2*y1;\n    }\n    static boolean check(long a, long b){\n        if(b<0){\n            a=-a;\n            b=-b;\n        }\n        return a>=0 && a<=b;\n    }\n    static int x1, y1;\n    static boolean intersect(int px, int py, int qx, int qy, int rx, int ry, int sx, int sy){\n        int x=qx-px;\n        int y=qy-py;\n        long qpr=cross(x,y,rx,ry);\n        long qps= cross(x,y,sx,sy);\n        long rs=cross(rx,ry,sx,sy);\n        if(rs==0|| !check(qpr,rs) || !check(qps,rs))\n            return false;\n        long gcd=gcd(qps,rs);\n        long a=qps/gcd;\n        long b=rs/gcd;\n        if(rx%b!=0 || ry%b!=0)\n            return false;\n        x1=(int) (px+rx/b*a);\n        y1=(int) (py+ry/b*a);\n        return true;\n    }\n    public static void main(String[] args) {\n        Scanner cin =new Scanner(System.in);\n        int n= cin.nextInt();\n        int[] ax=new int[n];\n        int[] ay=new int[n];\n        int[] bx=new int[n];\n        int[] by=new int[n];\n\n        for (int i=0;i<n;i++){\n            ax[i]=cin.nextInt();\n            ay[i]=cin.nextInt();\n            bx[i]=cin.nextInt();\n            by[i]=cin.nextInt();\n        }\n        int count=0;\n        for(int i=0;i<n;i++){\n            int num=1+(int) gcd(Math.abs(ax[i]-bx[i]),Math.abs(ay[i]-by[i]));\n            count+=num;\n        }\n        HashSet<Point> set= new HashSet<>();\n        for(int i=0;i<n;i++){\n            for (int j=i+1;j<n;j++){\n                if(intersect(ax[i],ay[i],ax[j],ay[j],bx[i]-ax[i],by[i]-ay[i],bx[j]-ax[j],by[j]-ay[j])){\n                    set.add(new Point(x1,y1,i));\n                    set.add(new Point(x1,y1,j));\n                }\n            }\n        }\n        int k=set.size();\n        Point[] points= set.toArray(new Point[k]);\n        Arrays.sort(points,(p1,p2)-> p1.x != p2.x ? p1.x - p2.x : p1.y != p2.y ? p1.y - p2.y : p1.j-p2.j);\n        for(int i=0,j;i<k;i=j){\n            int x=points[i].x;\n            int y=points[i].y;\n            j=i;\n            while (j<k && points[j].x==x && points[j].y==y)\n                j++;\n            int num=0;\n            for(int l=i;l<j;l++){\n                if(l==i || points[l].j!=points[l-1].j)\n                    num++;\n            }\n            count-=num-1;\n        }\n        System.out.println(count);\n    }\n}\n","fft,geometry,number theory"
"import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class CoveredPoints {\n    static class Point{\n        int x,y,j;\n        Point(int x, int y, int j){\n            this.x=x;\n            this.y=y;\n            this.j=j;\n        }\n    }\n    static long gcd(long a, long b){\n        return b==0?a:gcd(b,a%b);\n    }\n    static long cross(int x1,int y1, int x2, int y2){\n        return (long) x1*y2- (long) x2*y1;\n    }\n    static boolean check(long a, long b){\n        if(b<0){\n            a=-a;\n            b=-b;\n        }\n        return a>=0 && a<=b;\n    }\n    static int x1, y1;\n    static boolean intersect(int px, int py, int qx, int qy, int rx, int ry, int sx, int sy){\n        int x=qx-px;\n        int y=qy-py;\n        long qpr=cross(x,y,rx,ry);\n        long qps= cross(x,y,sx,sy);\n        long rs=cross(rx,ry,sx,sy);\n        if(rs==0 || !check(qpr,rs) || !check(qps,rs)){\n            return false;\n        }\n        long gcd=gcd(qps,rs);\n        long a=qps/gcd;\n        long b=rs/gcd;\n        if(rx%b!=0 || ry%b!=0)\n            return false;\n        x1=(int) (px+rx/b*a);\n        y1=(int) (py+ry/b*a);\n        return true;\n    }\n    public static void main(String[] args) {\n        Scanner cin =new Scanner(System.in);\n        int n= cin.nextInt();\n        int[] ax=new int[n];\n        int[] ay=new int[n];\n        int[] bx=new int[n];\n        int[] by=new int[n];\n\n        for (int i=0;i<n;i++){\n            ax[i]=cin.nextInt();\n            ay[i]=cin.nextInt();\n            bx[i]=cin.nextInt();\n            by[i]=cin.nextInt();\n        }\n        int count=0;\n        for(int i=0;i<n;i++){\n            int num=1+(int) gcd(Math.abs(ax[i]-bx[i]),Math.abs(ay[i]-by[i]));\n            count+=num;\n        }\n        ArrayList<Point> list= new ArrayList<>();\n        for(int i=0;i<n;i++){\n            for (int j=i+1;j<n;j++){\n                if(intersect(ax[i],ay[i],ax[j],ay[j],bx[i]-ax[i],by[i]-ay[i],bx[j]-ax[j],by[j]-ay[j])){\n                    list.add(new Point(x1,y1,i));\n                    list.add(new Point(x1,y1,j));\n                }\n            }\n        }\n        int k=list.size();\n        Point[] points= list.toArray(new Point[k]);\n        Arrays.sort(points,(p1,p2)-> p1.x != p2.x ? p1.x - p2.x : p1.y != p2.y ? p1.y - p2.y : p1.j-p2.j);\n        for(int i=0,j;i<k;i=j){\n            int x=points[i].x;\n            int y=points[i].y;\n            j=i;\n            while (j<k && points[j].x==x && points[j].y==y)\n                j++;\n            int num=0;\n            for(int l=i;l<j;l++){\n                if(l==i || points[l].j!=points[l-1].j)\n                    num++;\n            }\n            count-=num-1;\n        }\n        System.out.println(count);\n    }\n}\n","fft,geometry,number theory"
"import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class CoveredPoints {\n    static class Point{\n        int x,y,j;\n        Point(int x, int y, int j){\n            this.x=x;\n            this.y=y;\n            this.j=j;\n        }\n    }\n    static long gcd(long a, long b){\n        return b==0?a:gcd(b,a%b);\n    }\n    static long cross(int x1,int y1, int x2, int y2){\n        return (long) x1*y2- (long) x2*y1;\n    }\n    static boolean check(long a, long b){\n        if(b<0){\n            a=-a;\n            b=-b;\n        }\n        return a>=0 && a<=b;\n    }\n    static int x1, y1;\n    static boolean intersect(int px, int py, int qx, int qy, int rx, int ry, int sx, int sy){\n        int x=qx-px;\n        int y=qy-py;\n        long qpr=cross(x,y,rx,ry);\n        long qps= cross(x,y,sx,sy);\n        long rs=cross(rx,ry,sx,sy);\n        if(rs==0|| !check(qpr,rs) || !check(qps,rs))\n            return false;\n        long gcd=gcd(qps,rs);\n        long a=qps/gcd;\n        long b=rs/gcd;\n        if(rx%b!=0 || ry%b!=0)\n            return false;\n        x1=(int) (px+rx/b*a);\n        y1=(int) (py+ry/b*a);\n        return true;\n    }\n    public static void main(String[] args) {\n        Scanner cin =new Scanner(System.in);\n        int n= cin.nextInt();\n        int[] ax=new int[n];\n        int[] ay=new int[n];\n        int[] bx=new int[n];\n        int[] by=new int[n];\n\n        for (int i=0;i<n;i++){\n            ax[i]=cin.nextInt();\n            ay[i]=cin.nextInt();\n            bx[i]=cin.nextInt();\n            by[i]=cin.nextInt();\n        }\n        int count=0;\n        for(int i=0;i<n;i++){\n            int num=1+(int) gcd(Math.abs(ax[i]-bx[i]),Math.abs(ay[i]-by[i]));\n            count+=num;\n        }\n        //ArrayList<Point> list= new ArrayList<>();\n        HashSet<Point> set= new HashSet<>();\n        for(int i=0;i<n;i++){\n            for (int j=i+1;j<n;j++){\n                if(intersect(ax[i],ay[i],ax[j],ay[j],bx[i]-ax[i],by[i]-ay[i],bx[j]-ax[j],by[j]-ay[j])){\n                    set.add(new Point(x1,y1,i));\n                    set.add(new Point(x1,y1,j));\n                }\n            }\n        }\n        int k=set.size();\n        Point[] points= set.toArray(new Point[k]);\n        Arrays.sort(points,(p1,p2)-> p1.x != p2.x ? p1.x - p2.x : p1.y != p2.y ? p1.y - p2.y : p1.j-p2.j);\n        for(int i=0,j;i<k;i=j){\n            int x=points[i].x;\n            int y=points[i].y;\n            j=i;\n            while (j<k && points[j].x==x && points[j].y==y)\n                j++;\n            int num=0;\n            for(int l=i;l<j;l++){\n                if(l==i || points[l].j!=points[l-1].j)\n                    num++;\n            }\n            count-=num-1;\n        }\n        System.out.println(count);\n    }\n}\n","fft,geometry,number theory"
"//Referred Dukkha's Code\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class CoveredPoints {\n	static class Segment{\n		int x1, y1, x2, y2;\n		Segment(int x1, int y1, int x2, int y2){\n			this.x1=x1;\n			this.y1=y1;\n			this.x2=x2;\n			this.y2=y2;\n		}\n	}\n	static long crossProduct(long x1, long y1, long x2, long y2)\n	{\n	 return x1*y2-x2*y1; \n	}\n	\n	static class Point{\n		int x1, y1, z;\n		Point(int x1, int y1, int z){\n			this.x1=x1;\n			this.y1=y1;\n			this.z=z;\n		}\n	}\n	static boolean check(long a, long b) {\n		if(b<0) {\n			a=-a;\n			b=-b;\n		}\n		return a>=0 && a<=b;\n	}\n	static int xi, yi;\n	static boolean checkIntersection(int px, int py, int qx, int qy, int rx, int ry, int sx, int sy) {\n		long rs = crossProduct(rx, ry, sx, sy);\n		long pqs = crossProduct(qx-px, qy-py, sx, sy);\n		long pqr = crossProduct(qx-px, qy-py,rx,ry);\n		//intersection condition\n		if(rs==0||!check(pqs,rs)||!check(pqr,rs))\n			return false;\n		long z = GCD(pqs,rs);\n		long a =pqs/z;\n		long b =rs/z;\n		if(rx%b!=0||ry%b!=0) {\n			return false;\n		}\n		xi=(int)(px+rx/b*a);\n		yi=(int)(py+ry/b*a);\n		//System.out.println(xi+"" ""+yi);\n		return true;\n	}\n    static boolean areIntersecting(Segment p, Segment q) {\n    	int px = p.x1;\n    	int py = p.y1;\n    	int qx = q.x1;\n    	int qy = q.y1;\n    	int rx = p.x2-p.x1;\n    	int ry = p.y2-p.y1;\n    	int sx = q.x2-q.x1;\n    	int sy = q.y2-q.y1;\n		return checkIntersection(px,py,qx,qy,rx,ry,sx,sy);\n	}\n	\n	\n	static long GCD(long a , long b) {\n		return b==0?a:GCD(b,a%b);\n	}\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		Segment[] segments = new Segment[n]; \n		for(int i=0;i<n;i++) {\n			Segment s = new Segment(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());\n			segments[i]=s;\n		}\n		/*\n		 * for(int i=0;i<n;i++) { System.out.println(segments[i].x1+"" ""+\n		 * segments[i].y1+"" ""+segments[i].x2+"" ""+segments[i].y2); }\n		 */\n		long count=0;\n		for(int i=0;i<n;i++) {\n			Segment s = segments[i];\n			count +=GCD(Math.abs(s.x2-s.x1), Math.abs(s.y2-s.y1))+1;\n		}\n		//System.out.println(count);\n		ArrayList<Point> ipoints = new ArrayList<Point>();\n		for(int i=0; i<n;i++) {\n			Segment p = segments[i];\n			for(int j=i+1;j<n;j++) {\n				Segment q = segments[j];\n				if(areIntersecting(p,q)) {\n					ipoints.add(new Point(xi,yi,i));\n					ipoints.add(new Point(xi,yi,j));\n				}\n			}\n		}\n		\n		\n		Collections.sort( ipoints, new Comparator<Point>() {\n		       public int compare(Point x1, Point x2) {\n		         int result = Long.compare(x1.x1, x2.x1);\n		         if ( result == 0 ) {\n		             result = Long.compare(x1.y1, x2.y1);\n		           } \n		         if(result == 0) {\n		        	 result = Long.compare(x1.z, x2.z);\n		         }\n		         return result;\n		      }\n		    });\n		\n		int l = ipoints.size();\n		//System.out.println(l);\n		Point[] pp = ipoints.toArray(new Point[l]);\n		\n		// System.out.println("""");\n		  for(int i=0;i<l;i++) {\n	  //  System.out.println(pp[i].x1+"" ""+pp[i].y1+"" ""+pp[i].z);\n		  }\n		 \n		for(int i=0,j; i<l; i=j) {\n			int x1 =pp[i].x1;\n			int y1 =pp[i].y1;\n			j=i;\n			while(j<l&&pp[j].x1==x1&&pp[j].y1==y1) \n				j++;\n			int temp=0;\n			for(int h=i;h<j;h++) {\n				if(h==i||pp[h].z !=pp[h-1].z) {\n					temp++;\n				}\n			}\n			count-=temp-1;\n			\n		}\n		System.out.println(count);\n	}\n}","fft,geometry,number theory"
"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class _0572KitchenUtensils {\n\n	public static void main(String[] args) {\n		\n		Scanner sc = new Scanner(System.in);\n		int n=sc.nextInt();\n		int k=sc.nextInt();\n		int[] arr = new int[101];\n		int count=0;\n		int max=0;\n		for(int i=0;i<n;i++) {\n			int temp=sc.nextInt();\n			if(arr[temp]==0) {\n				count++;\n			}\n			arr[temp]++;\n			max=Math.max(max, arr[temp]);\n		}\n		int diff=0;\n		if(max%k!=0) {\n			diff++;\n		}\n		diff+=max/k;\n		System.out.println(count*k*diff-n);\n		\n		\n	}\n\n}\n",
"import java.util.HashSet;\nimport java.util.Scanner;\n\npublic class CF1079A {\n\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		int[] num = new int[101];\n		int n = s.nextInt();\n		int k =s.nextInt();\n		int max = 0;\n		HashSet<Integer> set = new HashSet<Integer>();\n		for(int i =0;i<n;i++)\n		{\n			int a =s.nextInt();\n			num[a]++;\n			max = Math.max(max, num[a]);\n			set.add(a);\n		}\n		max = max%k==0?max:(max/k+1)*k;\n		int c = 0;\n		for (Integer integer : set) {\n			c += max-num[integer];\n		}\n		System.out.println(c);\n		s.close();\n	}\n}\n	  		 			 				 				 		   		",
"import java.util.HashSet;\nimport java.util.Scanner;\n\npublic class CF1079A {\n\n public static void main(String[] args) {\n  Scanner s = new Scanner(System.in);\n  int[] num = new int[101];\n  int n = s.nextInt();\n  int k = s.nextInt();\n  int max = 0;\n  HashSet<Integer> set = new HashSet<Integer>();\n  for(int i =0;i<n;i++)\n  {\n   int a = s.nextInt();\n   num[a]++;\n   max = Math.max(max, num[a]);\n   set.add(a);\n  }\n  max = max%k==0?max:(max/k+1)*k;\n  int c = 0;\n  for (Integer integer : set) {\n   c += max-num[integer];\n  }\n  System.out.println(c);\n  s.close();\n }\n}\n		 			  	 		    	  	 	 						 	",
"import java.util.HashSet;\nimport java.util.Scanner;\n\npublic class CF1079A {\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int[] num = new int[101];\n		int n = sc.nextInt();\n		int k = sc.nextInt();\n		int max = 0;\n		HashSet<Integer> set = new HashSet<Integer>();\n		for(int i =0;i<n;i++)\n		{\n			int a = sc.nextInt();\n			num[a]++;\n			max = Math.max(max, num[a]);\n			set.add(a);\n		}\n		max = max%k==0?max:(max/k+1)*k;\n		int c = 0;\n		for (Integer integer : set) {\n			c += max-num[integer];\n		}\n		System.out.println(c);\n		sc.close();\n	}\n}\n 	 				  					 	 		  	 	 		",
"import java.io.*;\nimport java.util.*;\npublic class cf1015f {\nstatic int mod=(int)1e9+7;\nstatic String s;\n	public static void main(String[] args)throws IOException {\n		BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer(bf.readLine());\n		int n=Integer.parseInt(st.nextToken());\n		s=bf.readLine();\n		int sl=s.length();\n		StringBuilder sb=new StringBuilder();\n		int[][] len=new int[sl+1][2];\n		int[][][][] dp=new int[2*n+1][n+1][sl+1][2];\n		if(s.charAt(0)=='(') {\n			len[0][0]=1;\n		}\n		else {\n			len[0][1]=1;\n		}\n		for(int i=0;i<sl-1;i++) {\n			sb.append(s.charAt(i));\n			sb.append('(');\n			len[i+1][0]=len(sb.toString());\n			sb.deleteCharAt(i+1);\n			sb.append(')');\n			len[i+1][1]=len(sb.toString());\n			sb.deleteCharAt(i+1);\n		}\n		len[sl][0]=sl;\n		len[sl][1]=sl;\n		dp[0][0][0][0]=1;\n		for(int i=0;i<2*n;i++) {\n			for(int j=0;j<=n;j++) {\n				for(int k=0;k<=sl;k++) {\n					for(int z=0;z<2;z++) {\n						if(dp[i][j][k][z]==0) continue;\n						if(j<n) {\n							dp[i+1][j+1][len[k][0]][z|(len[k][0]==sl?1:0)]=(dp[i+1][j+1][len[k][0]][z|(len[k][0]==sl?1:0)]+dp[i][j][k][z])%mod;\n						}\n						if(j>0) {\n							dp[i+1][j-1][len[k][1]][z|(len[k][1]==sl?1:0)]=(dp[i+1][j-1][len[k][1]][z|(len[k][1]==sl?1:0)]+dp[i][j][k][z])%mod;\n						}\n					}\n				}\n			}\n		}\n		int ans=0;\n		for(int i=0;i<=sl;i++) {\n			ans=(ans+dp[2*n][0][i][1])%mod;\n		}\n		System.out.println(ans);\n	}\n	public static int len(String t) {\n		for(int i=t.length();i>0;i--) {\n			if(s.substring(0,i).equals(t.substring(t.length()-i,t.length()))) return i;\n		}\n		return 0;\n	}\n}\n","dp,strings"
"import java.io.*;\nimport java.util.*;\npublic class cf1015f {\nstatic int mod=(int)1e9+7;\nstatic String s;\n	public static void main(String[] args)throws IOException {\n		BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer(bf.readLine());\n		int n=Integer.parseInt(st.nextToken());\n		s=bf.readLine();\n		int sl=s.length();\n		StringBuilder sb=new StringBuilder();\n		int[][] len=new int[sl+1][2];\n		int[][][][] dp=new int[2*n+1][n+1][sl+1][2];\n		if(s.charAt(0)=='(') {\n			len[0][0]=1;\n		}\n		else {\n			len[0][1]=1;\n		}\n		for(int i=0;i<sl-1;i++) {\n			sb.append(s.charAt(i));\n			sb.append('(');\n			len[i+1][0]=len(sb.toString());\n			sb.deleteCharAt(i+1);\n			sb.append(')');\n			len[i+1][1]=len(sb.toString());\n			sb.deleteCharAt(i+1);\n		}\n		len[sl][0]=(s.charAt(0)=='('?1:0);\n		len[sl][1]=(s.charAt(0)==')'?1:0);\n		dp[0][0][0][0]=1;\n		for(int i=0;i<2*n;i++) {\n			for(int j=0;j<=n;j++) {\n				for(int k=0;k<=sl;k++) {\n					for(int z=0;z<2;z++) {\n						if(dp[i][j][k][z]==0) continue;\n						if(j<n) {\n							dp[i+1][j+1][len[k][0]][z|(len[k][0]==sl?1:0)]=(dp[i+1][j+1][len[k][0]][z|(len[k][0]==sl?1:0)]+dp[i][j][k][z])%mod;\n						}\n						if(j>0) {\n							dp[i+1][j-1][len[k][1]][z|(len[k][1]==sl?1:0)]=(dp[i+1][j-1][len[k][1]][z|(len[k][1]==sl?1:0)]+dp[i][j][k][z])%mod;\n						}\n					}\n				}\n			}\n		}\n		int ans=0;\n		for(int i=0;i<=sl;i++) {\n			ans=(ans+dp[2*n][0][i][1])%mod;\n		}\n		System.out.println(ans);\n	}\n	public static int len(String t) {\n		for(int i=t.length();i>0;i--) {\n			if(s.substring(0,i).equals(t.substring(t.length()-i,t.length()))) return i;\n		}\n		return 0;\n	}\n}\n","dp,strings"
"import java.io.*;\nimport java.util.*;\npublic class cf1015f {\nstatic int mod=(int)1e9+7;\nstatic String s;\n	public static void main(String[] args)throws IOException {\n		BufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer(bf.readLine());\n		int n=Integer.parseInt(st.nextToken());\n		s=bf.readLine();\n		int sl=s.length();\n		StringBuilder sb=new StringBuilder();\n		int[][] len=new int[sl+1][2];\n		int[][][][] dp=new int[2*n+1][n+1][sl+1][2];\n		if(s.charAt(0)=='(') {\n			len[0][0]=1;\n		}\n		else {\n			len[0][1]=1;\n		}\n		for(int i=0;i<sl-1;i++) {\n			sb.append(s.charAt(i));\n			sb.append('(');\n			len[i+1][0]=len(sb.toString());\n			sb.deleteCharAt(i+1);\n			sb.append(')');\n			len[i+1][1]=len(sb.toString());\n			sb.deleteCharAt(i+1);\n		}\n		len[sl][0]=len(sb.append('(').substring(1).toString());\n		len[sl][1]=len(sb.append(')').substring(1).toString());\n		dp[0][0][0][0]=1;\n		for(int i=0;i<2*n;i++) {\n			for(int j=0;j<=n;j++) {\n				for(int k=0;k<=sl;k++) {\n					for(int z=0;z<2;z++) {\n						if(dp[i][j][k][z]==0) continue;\n						if(j<n) {\n							dp[i+1][j+1][len[k][0]][z|(len[k][0]==sl?1:0)]=(dp[i+1][j+1][len[k][0]][z|(len[k][0]==sl?1:0)]+dp[i][j][k][z])%mod;\n						}\n						if(j>0) {\n							dp[i+1][j-1][len[k][1]][z|(len[k][1]==sl?1:0)]=(dp[i+1][j-1][len[k][1]][z|(len[k][1]==sl?1:0)]+dp[i][j][k][z])%mod;\n						}\n					}\n				}\n			}\n		}\n		int ans=0;\n		for(int i=0;i<=sl;i++) {\n			ans=(ans+dp[2*n][0][i][1])%mod;\n		}\n		System.out.println(ans);\n	}\n	public static int len(String t) {\n		for(int i=t.length();i>0;i--) {\n			if(s.substring(0,i).equals(t.substring(t.length()-i,t.length()))) return i;\n		}\n		return 0;\n	}\n}\n","dp,strings"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        FBracketSubstring solver = new FBracketSubstring();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FBracketSubstring {\n        int n;\n        char[] arr;\n        int[] pi;\n        long[][][] memo;\n        int mod = (int) 1e9 + 7;\n\n        void prefixFunction() {\n            int n = arr.length;\n            pi = new int[n];\n            for (int i = 1, j = 0; i < n; ++i)        //j = pi[i-1] at the beginning of every iteration\n            {\n                while (j > 0 && arr[i] != arr[j])\n                    j = pi[j - 1];\n                if (arr[i] == arr[j])\n                    ++j;\n                pi[i] = j;\n            }\n        }\n\n        public void readInput(Scanner sc) {\n            n = sc.nextInt();\n            arr = sc.next().toCharArray();\n\n        }\n\n        public void solve(int testNumber, Scanner sc, PrintWriter pw) {\n            int q = 1;\n            while (q-- > 0) {\n                readInput(sc);\n                prefixFunction();\n                memo = new long[2 * n][2 * n][2 * n];\n                for (long[][] x : memo)\n                    for (long[] y : x)\n                        Arrays.fill(y, -1);\n                pw.println(dp(0, 0, 0));\n            }\n        }\n\n        private long dp(int idx, int prefix, int match) {\n            if (idx == 2 * n)\n                return prefix == 0 && match == arr.length ? 1 : 0;\n            if (memo[idx][prefix][match] != -1)\n                return memo[idx][prefix][match];\n            int next = getNext(match, '(');\n            long open = dp(idx + 1, prefix + 1, next);\n            next = getNext(match, ')');\n            long close = prefix > 0 ? dp(idx + 1, prefix - 1, next) : 0;\n            return memo[idx][prefix][match] = (open + close) % mod;\n        }\n\n        private int getNext(int match, char c) {\n            int next = match;\n            if (match != arr.length) {\n                if (arr[match] == c)\n                    next++;\n                else {\n                    while (match != 0) {\n                        match = pi[match - 1];\n                        if (arr[match] == c)\n                            break;\n                    }\n                    if (arr[match] == c)\n                        next = match + 1;\n                    else\n                        next = match;\n                }\n            }\n            return next;\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() {\n            try {\n                while (st == null || !st.hasMoreTokens())\n                    st = new StringTokenizer(br.readLine());\n                return st.nextToken();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n","dp,strings"
"import java.util.*;\n\npublic class solution {\n\n	public static void main(String[] args)  {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int m=sc.nextInt();\n		long sa=0,sb=0;\n		ArrayList<Integer> a=new ArrayList<Integer>();\n		for(int i=0;i<n;i++) {\n			int ai=sc.nextInt();\n			int bi=sc.nextInt();\n			sa+=ai;\n			sb+=bi;\n			a.add(ai-bi);\n		}\n		if(sa<=m) {\n			System.out.println(0);\n		}\n		else if(sb<=m) {\n			Collections.sort(a);\n			int c=0;\n			for(int i=n-1;i>=0;i--) {\n				sa-=a.get(i);\n				c++;\n				if(sa<=m) {\n					break;\n				}\n			}\n			System.out.println(c);\n		}\n		else {\n			System.out.println(-1);\n		}\n	}\n}",sortings
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1015C extends PrintWriter {\n	CF1015C() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF1015C o = new CF1015C(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		long asum = 0, bsum = 0;\n		Integer[] dd = new Integer[n];\n		for (int i = 0; i < n; i++) {\n			int a = sc.nextInt();\n			int b = sc.nextInt();\n			asum += a;\n			bsum += b;\n			dd[i] = b - a;\n		}\n		if (bsum > m) {\n			println(-1);\n			return;\n		}\n		Arrays.sort(dd);\n		int k = 0;\n		while (asum > m)\n			asum += dd[k++];\n		println(k);\n	}\n}\n",sortings
\nimport java.util.*;\n\npublic class AprilFool2021 {\n\n	public static void main(String[] args) {\n\n		Scanner s = new Scanner(System.in);\n\n		int n = s.nextInt();\n		int d = s.nextInt();\n\n		long os = 0;\n		long cs = 0;\n		ArrayList<Integer> h = new ArrayList<Integer>();\n		for (int i = 0; i < n; i++) {\n			int ai = s.nextInt();\n			int bi = s.nextInt();\n			os += ai;\n			cs += bi;\n			h.add(ai - bi);\n		}\n\n		int c = 0;\n		if (cs > d) {\n			System.out.println(-1);\n		} else if (os <= d) {\n			System.out.println(0);\n		} else {\n			Collections.sort(h);\n\n			for (int i = n - 1; i >= 0; i--) {\n				os -= h.get(i);\n				c++;\n				if (os <= d) {\n					break;\n				}\n			}\n			System.out.println(c);\n		}\n\n	}\n\n}\n,sortings
\nimport java.util.*;\n \npublic class AprilFool2021 {\n \n	public static void main(String[] args) {\n \n		Scanner s = new Scanner(System.in);\n \n		int n = s.nextInt();\n		int d = s.nextInt();\n \n		long os = 0;\n		long cs = 0;\n		ArrayList<Integer> h = new ArrayList<Integer>();\n		for (int i = 0; i < n; i++) {\n			int ai = s.nextInt();\n			int bi = s.nextInt();\n			os += ai;\n			cs += bi;\n			h.add(ai - bi);\n		}\n \n		int c = 0;\n		if (cs > d) {\n			System.out.println(-1);\n		} else if (os <= d) {\n			System.out.println(0);\n		} else {\n			Collections.sort(h);\n \n			for (int i = n - 1; i >= 0; i--) {\n				os -= h.get(i);\n				c++;\n				if (os <= d) {\n					break;\n				}\n			}\n			System.out.println(c);\n		}\n \n	}\n \n},sortings
"import java.util.*;\n \npublic class Main {\n  static boolean isvowel(char c){\n      return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n  }\npublic static void main(String [] args){\n    Scanner in=new Scanner(System.in);\n    String s;\n    s=in.next();\n    for(int i=0;i<s.length();i++){\n        if(!isvowel(s.charAt(i))&&!(s.charAt(i)=='n'||i+1<s.length()&&isvowel(s.charAt(i+1)))){\n            System.out.println(""NO"");\n            return ;\n        }\n    }\n    System.out.println(""YES"");\n}\n}\n ","implementation,strings"
"\n\nimport java.util.*;\n\npublic class Main {\n  static boolean isvowel(char c){\n      return c=='a'||c=='e'||c=='i'||c=='o'||c=='u';\n  }\npublic static void main(String [] args){\n    Scanner in=new Scanner(System.in);\n    String s;\n    s=in.next();\n    for(int i=0;i<s.length();i++){\n        if(!isvowel(s.charAt(i))&&!(s.charAt(i)=='n'||i+1<s.length()&&isvowel(s.charAt(i+1)))){\n            System.out.println(""NO"");\n            return ;\n        }\n    }\n    System.out.println(""YES"");\n}\n}\n\n 	 	  		    		 	 				 	 	 			","implementation,strings"
"import java.io.*;\nimport java.util.*;\n\npublic class CF1008A  {\n \n	static Scanner sc = new Scanner(System.in);\n\n\n	static boolean vowel(char c) {\n		return c == 'a' || c == 'o' || c == 'u' || c == 'i' || c == 'e';\n	}\n	public static void main(String[] args) \n	{\n		char[] cc = sc.next().toCharArray();\n		int n = cc.length;\n		for (int i = 0; i < n; i++)\n			if (cc[i] != 'n' && !vowel(cc[i]) && (i + 1 == n || !vowel(cc[i + 1]))) {\n				System.out.println(""NO"");\n				return;\n			}\n	System.out.println(""YES"");\n	}\n}\n","implementation,strings"
"import java.util.*;\n \npublic class Main {\n    static boolean isvowel(char c)\n    {\n        return c=='a' || c=='e' || c=='i' || c=='o' || c=='u'; \n    }\n    \n    public static void main(String[] args)\n    {\n         Scanner in=new Scanner(System.in);\n    String s;\n    s=in.next();\n    \n    for(int i=0;i<s.length();i++)\n    {\n        if(!isvowel(s.charAt(i)) && !(s.charAt(i)=='n' || i+1<s.length()&& isvowel(s.charAt(i+1))))\n        {\n            System.out.println(""NO"");\n            return;\n        }\n    }\n    System.out.println(""YES"");\n    }\n}","implementation,strings"
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n  static BufferedReader reader;\n  static StringTokenizer stoken;\n  static PrintWriter out;\n\n  static int ni() throws Exception {\n    return Integer.parseInt(ns());\n  }\n\n  static long nl() throws Exception {\n    return Long.parseLong(ns());\n  }\n\n  static double nd() throws Exception {\n    return Double.parseDouble(ns());\n  }\n\n  static String ns() throws Exception {\n    if (stoken == null || !stoken.hasMoreTokens()) stoken = new StringTokenizer(reader.readLine());\n    return stoken.nextToken();\n  }\n\n  static segtree_sum ss;\n  static segtree_or so;\n\n  static int n, x;\n  static int INDEX = -1;\n  static long DON = -1;\n  static int POS;\n  static long[] reach;\n  static long[] QV;\n  static int qc;\n  static int[] qrun;\n\n  public static void main(String[] args) throws Exception {\n    reader = new BufferedReader(new InputStreamReader(System.in));\n    out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)), true);\n\n    n = ni();\n    int q = ni();\n    x = ni();\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++) a[i] = nl();\n    QV = new long[200007];\n    qrun = new int[200009];\n    for (int i = 0; i < 200007; i++) QV[i] = -1;\n\n    reach = new long[n];\n    int pt = -1;\n\n    int count[] = new int[20];\n    int cor = 0;\n    for (int i = 0; i < n; i++) {\n      while (pt < n - 1 && (cor < x || pt < i)) {\n        ++pt;\n        for (int j = 0; j < 20; j++) {\n          if ((a[pt] & (1 << j)) > 0) ++count[j];\n        }\n        cor = 0;\n        for (int j = 0; j < 20; j++) {\n          if (count[j] > 0) cor += (1 << j);\n        }\n      }\n\n      reach[i] = pt;\n      if (cor < x) reach[i] = n;\n      for (int j = 0; j < 20; j++) {\n        if ((a[i] & (1 << j)) > 0) --count[j];\n      }\n      cor = 0;\n      for (int j = 0; j < 20; j++) {\n        if (count[j] > 0) cor += (1 << j);\n      }\n    }\n\n    ss = new segtree_sum(n);\n    so = new segtree_or(n);\n    ss.init(reach);\n    so.init(a);\n\n    // for (int i = 0; i < n; i++) out.print(reach[i] + "" "");\n    // out.println();\n\n    for (int Q = 0; Q < q; Q++) {\n      int type = ni();\n      if (type == 1) {\n        int ind = ni() - 1, val = ni();\n        so.update(ind, val);\n\n        int cind = ind;\n        cor = val;\n        POS = ind;\n        int ll = 0, rr = n;\n        while (ll < rr) {\n          int m = (ll + rr) / 2;\n\n          long v = ss.query(m, m);\n          if (v < ind) ll = m + 1;\n          else rr = m;\n        }\n        while (cind >= 0 && (cind == ind || ss.query(cind, cind) >= ind)) {\n          INDEX = cind;\n          DON = cor;\n          qc = 0;\n          so.query_left(0, 0, n - 1, cind, cor);\n          for (int i = 0; i < qc; i++) QV[qrun[i]] = -1;\n          INDEX = Math.max(INDEX, ll);\n          \n          int stor = INDEX;\n          INDEX = ind - 1;\n          qc = 0;\n          so.query_right(0, 0, n - 1, ind, cor);\n          for (int i = 0; i < qc; i++) QV[qrun[i]] = -1;\n          int v = INDEX + 1;\n          ss.update(stor, cind, v);\n\n          // out.println(""stor "" + stor + "" "" + cind + "" "" + (INDEX + 1));\n\n          cor = (int)so.query(stor, ind);\n          if (stor != 0) cor |= so.query(stor - 1, stor - 1);\n          cind = stor - 1;\n        }\n\n        // for (int i = 0; i < n; i++) out.print(so.query(i, i) + "" "");\n        // out.println();\n        // for (int i = 0; i < n; i++) out.print(ss.query(i, i) + "" "");\n        // out.println();\n      } else {\n        long l = ni() - 1, r = ni() - 1;\n        if (l == r) {\n          if (so.query((int)l, (int)l) < x) out.println(0);\n          else out.println(1);\n          continue;\n        }\n\n        long ll = l, rr = r + 1;\n        while (ll < rr) {\n          int m = (int)((ll + rr) / 2);\n\n          long v = ss.query(m, m);\n          if (v <= r) ll = m + 1;\n          else rr = m;\n        }\n\n        long base = ff(r - l + 1) + (ff(r) - ff(l - 1));\n        // out.println(""base "" + base);\n\n        base -= (r - ll + 1) * (r + 1);\n        // out.println(""base "" + base + "" "" + ll);\n        if (ll != l) {\n          base -= ss.query((int)l, (int)(ll - 1));\n        }\n        out.println(base);\n      }\n    }\n  }\n\n  static long ff(long x) {\n    if (x < 0) return 0;\n    return x * (x + 1) / 2;\n  }\n\n  static Point max(Point a, Point b) {\n    if (a.x == b.x) {\n      if (a.y < b.y) return new Point(b.x, b.y);\n      return new Point(a.x, a.y);\n    }\n    if (a.x < b.x) return new Point(b.x, b.y);\n    return new Point(a.x, a.y);\n  }\n\n  static class Point implements Comparable<Point> {\n    public int x;\n    public int y;\n\n    Point() {}\n    Point(int a, int b) {x = a; y = b;}\n\n    public int compareTo(Point other) {\n      if (x == other.x) return y - other.y;\n      return x - other.x;\n    }\n\n    public String toString() {\n      return ""("" + x + "", "" + y + "")"";\n    }\n  }\n\n  static abstract class segtree {\n    public int n;\n    public long[] tree, lazy;\n\n    public segtree(int _n) {\n      n = _n;\n      tree = new long[4 * _n];\n      lazy = new long[4 * _n];\n      for (int i = 0; i < 4 * _n; i++) lazy[i] = -1;\n    }\n\n    protected abstract long combine(long a, long b);\n\n    protected abstract long nullv();\n\n    protected abstract long lazy_func(int l, int r, long v);\n\n    public void init(long[] arr) {\n      init(0, 0, n - 1, arr);\n    }\n\n    private long init(int i, int l, int r, long[] arr) {\n      if (l == r) return tree[i] = arr[l];\n\n      int mid = (l + r) / 2;\n      long a = init(2 * i + 1, l, mid, arr);\n      long b = init(2 * i + 2, mid + 1, r, arr);\n\n      return tree[i] = combine(a, b);\n    }\n\n    public void update(int l, int r, long val) {\n      update(0, 0, n - 1, l, r, val);\n    }\n\n    private long update(int i, int tl, int tr, int ql, int qr, long val) {\n      if (tr < ql || qr < tl || tl > tr) {\n        push_lazy(i, tl, tr);\n        return tree[i];\n      }\n      if (ql <= tl && tr <= qr) {\n        lazy[i] = val;\n        push_lazy(i, tl, tr);\n        return tree[i];\n      }\n\n      push_lazy(i, tl, tr);\n\n      int mid = (tl + tr) / 2;\n      long a = update(2 * i + 1, tl, mid, ql, qr, val);\n      long b = update(2 * i + 2, mid + 1, tr, ql, qr, val);\n\n      return tree[i] = combine(a, b);\n    }\n\n    public long query(int l, int r) {\n      return query(0, 0, n - 1, l, r);\n    }\n\n    private long query(int i, int tl, int tr, int ql, int qr) {\n      if (qr < tl || tr < ql || tl > tr) return nullv();\n\n      push_lazy(i, tl, tr);\n      if (ql <= tl && tr <= qr) return tree[i];\n\n      int mid = (tl + tr) / 2;\n      long a = query(2 * i + 1, tl, mid, ql, qr);\n      long b = query(2 * i + 2, mid + 1, tr, ql, qr);\n\n      return combine(a, b);\n    }\n\n    private void push_lazy(int i, int l, int r) {\n      if (lazy[i] == -1) return;\n      tree[i] = (r - l + 1) * lazy[i];\n\n      if (l != r) {\n        lazy[2 * i + 1] = lazy[i];\n        lazy[2 * i + 2] = lazy[i];\n      }\n\n      lazy[i] = -1;\n    }\n  }\n\n  static class segtree_sum extends segtree {\n    public segtree_sum(int _n) {\n      super(_n);\n    }\n\n    protected long combine(long a, long b) {\n      return a + b;\n    }\n\n    protected long nullv() {\n      return 0;\n    }\n\n    protected long lazy_func(int l, int r, long v) {\n      return v;\n    }\n  }\n\n  static class segtree_or {\n    public int n;\n    public long[] tree;\n\n    public segtree_or(int _n) {\n      n = _n;\n      tree = new long[4 * _n];\n    }\n\n    private long combine(long a, long b) {\n      return a | b;\n    }\n\n    private long nullv() {\n      return 0;\n    }\n\n    public void init(long[] arr) {\n      init(0, 0, n - 1, arr);\n    }\n\n    private long init(int i, int l, int r, long[] arr) {\n      if (l == r) return tree[i] = arr[l];\n\n      int mid = (l + r) / 2;\n      long a = init(2 * i + 1, l, mid, arr);\n      long b = init(2 * i + 2, mid + 1, r, arr);\n\n      return tree[i] = combine(a, b);\n    }\n\n    public void update(int loc, long val) {\n      update(0, 0, n - 1, loc, val);\n    }\n\n    private long update(int i, int l, int r, int loc, long val) {\n      if (loc < l || r < loc) return tree[i];\n      if (l == r) return tree[i] = val;\n\n      int mid = (l + r) / 2;\n      long a = update(2 * i + 1, l, mid, loc, val);\n      long b = update(2 * i + 2, mid + 1, r, loc, val);\n\n      return tree[i] = combine(a, b);\n    }\n\n    public long query(int l, int r) {\n      return query(0, 0, n - 1, l, r);\n    }\n\n    private long query(int i, int tl, int tr, int ql, int qr) {\n      if (qr < tl || tr < ql || tl > tr || ql > qr) return nullv();\n      if (ql <= tl && tr <= qr) return tree[i];\n\n      int mid = (tl + tr) / 2;\n      long a = query(2 * i + 1, tl, mid, ql, qr);\n      long b = query(2 * i + 2, mid + 1, tr, ql, qr);\n\n      return combine(a, b);\n    }\n\n    private long query_left(int i, int tl, int tr, int qr, long ror) {\n      if (qr < tl) return 0;\n      if (tr <= qr) {\n        if ((tree[i] | ror) == DON) {\n          INDEX = Math.min(INDEX, tl);\n          return tree[i] | ror;\n        }\n      }\n      if (tl == tr) {\n        if ((tree[i] | ror) == DON) INDEX = Math.min(INDEX, tl);\n        return tree[i] | ror;\n      }\n\n      int mid = (tl + tr) / 2;\n      if (qr <= mid) return query_left(2 * i + 1, tl, mid, qr, ror);\n      long a = query_left(2 * i + 2, mid + 1, tr, qr, ror);\n      long b = ror | a;\n      if (b == DON) b = query_left(2 * i + 1, tl, mid, qr, b);\n      if (tr <= qr) b |= tree[i];\n      return b;\n    }\n\n    private long query_right(int i, int tl, int tr, int ql, long ror) {\n      if (tr < ql) return 0;\n      if (ql <= tl) {\n        if ((ror | tree[i]) < x) {\n          INDEX = Math.max(INDEX, tr);\n          return ror | tree[i];\n        }\n      }\n      if (tl == tr) {\n        if ((tree[i] | ror) < x) INDEX = Math.max(INDEX, tl);\n        return tree[i] | ror;\n      }\n\n      int mid = (tl + tr) / 2;\n      if (ql > mid) return query_right(2 * i + 2, mid + 1, tr, ql, ror);\n      long a = query_right(2 * i + 1, tl, mid, ql, ror);\n      long b = ror | a;\n      if (b < x) {\n        INDEX = Math.max(INDEX, mid);\n        b |= query_right(2 * i + 2, mid + 1, tr, ql, b);\n      }\n      if (ql <= tl) b |= tree[i];\n      return b;\n    }\n  }\n}","bitmasks,data structures,divide and conquer"
"\nimport java.io.*;\nimport java.util.*;\n\npublic class F {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		InputReader in = new InputReader(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		Task solver = new Task();\n		solver.solve(1, in, out);\n		out.close();\n	}\n\n	static class info {\n		int val[] = new int[22];\n		int pos[] = new int[22];\n		int len = 0;\n		public void init() {\n			len = 0;\n		}\n		public void init(int v, int p) {\n			val[0] = v;\n			pos[0] = p;\n			len = 1;\n		}\n		public void add(info b) {\n			int v = 0;\n			if (len != 0) v = val[len - 1];\n			for (int i = 0; i < b.len; i++) {\n				if ((v | b.val[i]) > v || len == 0) {\n					v |= b.val[i];\n					val[len] = v;\n					pos[len] = b.pos[i];\n					len++;\n				}\n			}\n		}\n	}\n\n	static class Task {\n		info candl[];\n		info candr[];\n		long s[];\n		int a[];\n		int x = 0;\n		int xl = 0;\n		long ans = 0;\n		info queryl = new info();\n		info tmp = new info();\n\n		long merge(int l, int r, info cl, info cr) {\n			long ans = 0;\n			if (cl.len == 0 || cr.len == 0) return ans;\n			int j = 0;\n			int val = cl.val[0];\n			while (j < cr.len && (cr.val[j] | val) < x)\n				j++;\n			for (int i = 0; i < cl.len; i++) {\n				val = cl.val[i];\n				while (j > 0 && (cr.val[j - 1] | val) >= x) --j;\n				if (j < cr.len) {\n					long h = 0;\n					if (i < cl.len - 1)\n						h = cl.pos[i] - cl.pos[i + 1];\n					else\n						h = cl.pos[i] - l + 1;\n\n					ans += (r - cr.pos[j] + 1) * h;\n				}\n			}\n			return ans;\n		}\n		void upd(int p, int l, int r) {\n			candl[p].init();\n			candl[p].add(candl[p + p]);\n			candl[p].add(candl[p + p + 1]);\n			candr[p].init();\n			candr[p].add(candr[p + p + 1]);\n			candr[p].add(candr[p + p]);\n			s[p] = s[p + p] + s[p + p + 1] + merge(l, r, candr[p + p], candl[p + p + 1]);\n		}\n\n		void build(int p, int l, int r) {\n			candl[p] = new info();\n			candr[p] = new info();\n			if (l == r) {\n				candl[p].init(a[l], l);\n				candr[p].init(a[l], l);\n				s[p] = (a[l] >= x) ? 1 : 0;\n			} else {\n				int md = (l + r) >> 1;\n				build(p + p, l, md);\n				build(p + p + 1, md + 1, r);\n				upd(p, l, r);\n			}\n		}\n		void modify(int p, int l, int r, int c, int v) {\n			if (l == r) {\n				a[l] = v;\n				candl[p].init(a[l], l);\n				candr[p].init(a[l], l);\n				s[p] = (a[l] >= x) ? 1 : 0;\n			} else {\n				int md = (l + r) >> 1;\n				if (c <= md) modify(p + p, l, md, c, v);\n				else modify(p + p + 1, md + 1, r, c, v);\n				upd(p, l, r);\n			}\n		}\n		void query(int p, int l, int r, int tl, int tr) {\n			if (l == tl && r == tr) {\n				ans += s[p] + merge(xl, r, queryl, candl[p]);\n				tmp.init();\n				tmp.add(candr[p]);\n				tmp.add(queryl);\n				queryl.init();\n				queryl.add(tmp);\n			} else {\n				int md = (l + r) >> 1;\n				if (tr <= md) query(p + p, l, md, tl, tr);\n				else if (tl > md) query(p + p + 1, md + 1, r, tl, tr);\n				else {\n					query(p + p, l, md, tl, md);\n					query(p + p + 1, md + 1, r, md + 1, tr);\n				}\n			}\n		}\n\n		public void solve(int testNumber, InputReader in, PrintWriter out) {\n			int n = in.nextInt();\n			int m = in.nextInt();\n			a = new int[n + 1];\n			candl = new info[4 * n + 10];\n			candr = new info[4 * n + 10];\n			s = new long [4 * n + 10];\n			x = in.nextInt();\n			for (int i = 1; i <= n; i++) {\n				a[i] = in.nextInt();\n			}\n			build(1, 1, n);\n			for (int i = 0; i < m; i++) {\n				int op = in.nextInt();\n				int l = in.nextInt();\n				int r = in.nextInt();\n				if (op == 1) {\n					modify(1, 1, n, l, r);\n				} else {\n					ans = 0;\n					queryl.init();\n					xl = l;\n					query(1, 1, n, l, r);\n					out.println(ans);\n				}\n			}\n		}\n	}\n\n	static class InputReader {\n		public BufferedReader reader;\n		public StringTokenizer tokenizer;\n\n		public InputReader(InputStream stream) {\n			reader = new BufferedReader(new InputStreamReader(stream), 32768);\n			tokenizer = null;\n		}\n\n		public String next() {\n			while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n				try {\n					tokenizer = new StringTokenizer(reader.readLine());\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n			return tokenizer.nextToken();\n		}\n\n		public int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n		public long nextLong() {\n			return Long.parseLong(next());\n		}\n\n	}\n}","bitmasks,data structures,divide and conquer"
"import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class Div2_495F {\n\n	public static void main(String[] args) throws IOException {\n		new Div2_495F().execute();\n	}\n\n	int nE;\n	int nQ;\n	int bound;\n\n	int[] e;\n\n	Data[] tree;\n\n	void execute() throws IOException {\n		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		StringTokenizer inputData = new StringTokenizer(reader.readLine());\n		nE = Integer.parseInt(inputData.nextToken());\n		nQ = Integer.parseInt(inputData.nextToken());\n		bound = Integer.parseInt(inputData.nextToken());\n\n		e = new int[nE + 1];\n		inputData = new StringTokenizer(reader.readLine());\n		for (int i = 1; i <= nE; i++) {\n			e[i] = Integer.parseInt(inputData.nextToken());\n		}\n\n		tree = new Data[nE * 4];\n		init(1, 1, nE);\n\n		while (nQ-- > 0) {\n			inputData = new StringTokenizer(reader.readLine());\n			int t = Integer.parseInt(inputData.nextToken());\n			int a = Integer.parseInt(inputData.nextToken());\n			int b = Integer.parseInt(inputData.nextToken());\n			if (t == 1) {\n				update(1, 1, nE, a, b);\n			} else {\n				Data res = query(1, 1, nE, a, b);\n				printer.println(res.tCnt);\n			}\n		}\n		printer.close();\n	}\n\n	void init(int nI, int cL, int cR) {\n		if (cL == cR) {\n			Data nData = new Data();\n			nData.states = new int[][] { { e[cL] }, { e[cR] } };\n			nData.sCnt = new int[][] { { 1 }, { 1 } };\n			nData.tCnt = e[cL] >= bound ? 1 : 0;\n			tree[nI] = nData;\n		} else {\n			int mid = (cL + cR) >> 1;\n			init(nI * 2, cL, mid);\n			init(nI * 2 + 1, mid + 1, cR);\n			tree[nI] = merge(tree[nI * 2], tree[nI * 2 + 1]);\n		}\n	}\n\n	void update(int nI, int cL, int cR, int uI, int uV) {\n		if (cL == cR) {\n			Data nData = new Data();\n			nData.states = new int[][] { { uV }, { uV } };\n			nData.sCnt = new int[][] { { 1 }, { 1 } };\n			nData.tCnt = uV >= bound ? 1 : 0;\n			tree[nI] = nData;\n		} else {\n			int mid = (cL + cR) >> 1;\n			if (uI <= mid) {\n				update(nI * 2, cL, mid, uI, uV);\n			} else {\n				update(nI * 2 + 1, mid + 1, cR, uI, uV);\n			}\n			tree[nI] = merge(tree[nI * 2], tree[nI * 2 + 1]);\n		}\n	}\n\n	Data query(int nI, int cL, int cR, int qL, int qR) {\n		if (qR < cL || cR < qL) {\n			return new Data();\n		}\n		if (qL <= cL && cR <= qR) {\n			return tree[nI];\n		}\n		int mid = (cL + cR) >> 1;\n		return merge(query(nI * 2, cL, mid, qL, qR), query(nI * 2 + 1, mid + 1, cR, qL, qR));\n	}\n\n	Data[] chldn = new Data[2];\n\n	ArrayList<Integer> nStates = new ArrayList<>();\n	ArrayList<Integer> nSCnt = new ArrayList<>();\n\n	Data merge(Data l, Data r) {\n		if (l.states == null) {\n			return r;\n		}\n		if (r.states == null) {\n			return l;\n		}\n\n		chldn[0] = l;\n		chldn[1] = r;\n\n		Data ret = new Data();\n		ret.states = new int[2][];\n		ret.sCnt = new int[2][];\n\n		for (int d = 0; d < 2; d++) {\n			nStates.clear();\n			nSCnt.clear();\n			Data ch0 = chldn[d];\n			Data ch1 = chldn[d ^ 1];\n\n			for (int i = 0; i < ch0.states[d].length - 1; i++) {\n				nStates.add(ch0.states[d][i]);\n				nSCnt.add(ch0.sCnt[d][i]);\n			}\n\n			int cState = ch0.states[d][ch0.states[d].length - 1];\n			int cSCnt = ch0.sCnt[d][ch0.states[d].length - 1];\n\n			int i = 0;\n			for (; i < ch1.states[d].length && ((ch1.states[d][i] | cState) == cState); i++) {\n				cSCnt += ch1.sCnt[d][i];\n			}\n			nStates.add(cState);\n			nSCnt.add(cSCnt);\n\n			while (i < ch1.states[d].length) {\n				cState = cState | ch1.states[d][i];\n				cSCnt = ch1.sCnt[d][i];\n\n				i++;\n				for (; i < ch1.states[d].length && ((ch1.states[d][i] | cState) == cState); i++) {\n					cSCnt += ch1.sCnt[d][i];\n				}\n				nStates.add(cState);\n				nSCnt.add(cSCnt);\n			}\n\n			ret.states[d] = new int[nStates.size()];\n			for (int j = 0; j < nStates.size(); j++) {\n				ret.states[d][j] = nStates.get(j);\n			}\n\n			ret.sCnt[d] = new int[nStates.size()];\n			for (int j = 0; j < nStates.size(); j++) {\n				ret.sCnt[d][j] = nSCnt.get(j);\n			}\n		}\n\n		long tSum = l.tCnt + r.tCnt;\n\n		int[] lStates = l.states[1];\n		int[] lSCnt = l.sCnt[1];\n\n		int[] rStates = r.states[0];\n		int[] rSCnt = r.sCnt[0];\n\n		long sSum = 0;\n		int j = lStates.length - 1;\n\n		for (int i = 0; i < rStates.length; i++) {\n			while (j >= 0 && (lStates[j] | rStates[i]) >= bound) {\n				sSum += lSCnt[j];\n				j--;\n			}\n			tSum += rSCnt[i] * sSum;\n		}\n		ret.tCnt = tSum;\n		return ret;\n	}\n\n	class Data {\n		int[][] states;\n		int[][] sCnt;\n		long tCnt;\n	}\n\n}\n","bitmasks,data structures,divide and conquer"
"//package round495;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class F2 {\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n	\n	void solve()\n	{\n		int n = ni(), m = ni(), X = ni();\n		int[] a = na(n);\n		SegmentTreeNode st = new SegmentTreeNode(a, X);\n		for(int z = 0;z < m;z++){\n			int type = ni();\n			if(type == 1){\n				int pos = ni()-1;\n				int y = ni();\n				st.update(pos, y);\n			}else{\n//				for(int i = 1;i < st.M;i++){\n//					tr(i, st.node[i].pre, st.node[i].suf, st.node[i].count);\n//				}\n				int l = ni()-1;\n				int r = ni()-1;\n				out.println(st.sum(l, r+1));\n			}\n		}\n	}\n	\n	public static class SegmentTreeNode {\n		public int M, H, N;\n		public Node[] node;\n		public int X;\n		\n		private static class Node\n		{\n			public long count;\n			public long[] pre;\n			public long[] suf;\n			\n			public Node() {\n			}\n		}\n		\n		public long[] merge(long[] p1, long[] p2)\n		{\n			long[] ret = Arrays.copyOf(p1, p1.length+p2.length);\n			int p = p1.length;\n			for(long u : p2){\n				if(p == 0 || (ret[p-1]>>>32 | u>>>32) != ret[p-1]>>>32){\n					ret[p] = u|ret[p-1]>>>32<<32;\n					p++;\n				}else{\n					ret[p-1] += (int)u;\n				}\n			}\n			return Arrays.copyOf(ret, p);\n		}\n		\n		public long countup(long[] suf, long[] pre)\n		{\n			int numpre = 0;\n			for(int i = 0;i < pre.length;i++)numpre += (int)pre[i];\n			\n			long ret = 0;\n			int p = 0;\n			for(int i = suf.length-1;i >= 0;i--){\n				while(p < pre.length && (suf[i]>>>32|pre[p]>>>32) < X){\n					numpre -= (int)pre[p];\n					p++;\n				}\n				ret += (long)((int)suf[i]) * numpre;\n			}\n			return ret;\n		}\n		\n		public void set(int pos, int v)\n		{\n			node[pos] = new Node();\n			node[pos].count = v >= X ? 1 : 0;\n			node[pos].pre = node[pos].suf = new long[]{(long)v<<32|1};\n		}\n		\n		public SegmentTreeNode(int[] a, int X)\n		{\n			this.X = X;\n			N = a.length;\n			M = Integer.highestOneBit(Math.max(N-1, 1))<<2;\n			H = M>>>1;\n			\n			node = new Node[M];\n			for(int i = 0;i < N;i++){\n				set(H+i, a[i]);\n			}\n			for(int i = H-1;i >= 1;i--)propagate(i);\n		}\n		\n		private void propagate(int cur)\n		{\n			node[cur] = prop2(node[2*cur], node[2*cur+1], node[cur]);\n		}\n		\n		private Node prop2(Node L, Node R, Node C)\n		{\n			if(L != null && R != null){\n				if(C == null)C = new Node();\n				C.count = countup(L.suf, R.pre) + L.count + R.count;\n				C.pre = merge(L.pre, R.pre);\n				C.suf = merge(R.suf, L.suf);\n				return C;\n			}else if(L != null){\n				return prop1(L, C);\n			}else if(R != null){\n				return prop1(R, C);\n			}else{\n				return null;\n			}\n		}\n		\n		private Node prop1(Node L, Node C)\n		{\n			if(C == null)C = new Node();\n			C.count = L.count;\n			C.pre = L.pre;\n			C.suf = L.suf;\n			return C;\n		}\n		\n		public void update(int pos, int v) {\n			set(H+pos, v);\n			for(int i = H+pos>>>1;i >= 1;i>>>=1)propagate(i);\n		}\n		\n		public long sum(int l, int r) {\n			Node N = sum(l, r, 0, H, 1);\n			return N == null ? 0 : N.count;\n		}\n		\n		protected Node sum(int l, int r, int cl, int cr, int cur)\n		{\n			if(l <= cl && cr <= r){\n				return node[cur];\n			}else{\n				Node L = null, R = null;\n				int mid = cl+cr>>>1;\n				if(cl < r && l < mid){\n					L = sum(l, r, cl, mid, 2*cur);\n				}\n				if(mid < r && l < cr){\n					R = sum(l, r, mid, cr, 2*cur+1);\n				}\n				return prop2(L, R, null);\n			}\n		}\n	}\n	\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new F2().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n	\n	private char[][] nm(int n, int m)\n	{\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n	\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n	\n	private int ni()\n	{\n		int num = 0, b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","bitmasks,data structures,divide and conquer"
"import java.io.*;\nimport java.util.*;\n\npublic class A {\n	public static void main (String[] args) { new A(); }\n\n	int n;\n	long[] vals;\n	ArrayList<Edge>[] adj;\n	int[] size, idxOfParent;\n	long[][] dp;\n	\n	int log;\n	int[] depth;\n	int[][] lift;\n	long[][] sumEdges, sumDP;\n	\n	public A() {\n		FastScanner fs = new FastScanner();\n		PrintWriter out = new PrintWriter(System.out);\n		System.err.println("""");\n\n		n = fs.nextInt();\n		int q = fs.nextInt();\n		\n		vals = new long[n];\n		for(int i = 0; i < n; i++) vals[i] = fs.nextLong();\n		\n		adj = new ArrayList[n];\n		for(int i = 0; i < n; i++) adj[i] = new ArrayList<>();\n		\n		for(int i = 0; i < n-1; i++) {\n			int u = fs.nextInt()-1;\n			int v = fs.nextInt()-1;\n			int we = fs.nextInt();\n			adj[u].add(new Edge(v, we));\n			adj[v].add(new Edge(u, we));\n		}\n		\n		size = new int[n];\n		for(int i = 0; i < n; i++) size[i] = adj[i].size();\n		\n		dp = new long[n][];\n		for(int i = 0; i < n; i++)\n			dp[i] = new long[size[i] + 1];\n		\n		idxOfParent = new int[n];\n		Arrays.fill(idxOfParent, -1);\n		\n		dfs(0, -1);\n		dfs2(0, -1, -1);\n\n//		for(int i = 0; i < n; i++) {\n//			System.out.printf(""Idx: %d -- %s\n"", i + 1, Arrays.toString(dp[i]));\n//		}\n		\n		log = Integer.numberOfTrailingZeros(Integer.highestOneBit(n))+1;\n		depth = new int[n];\n		lift = new int[log][n];\n		sumDP = new long[log][n];\n		sumEdges = new long[log][n];\n		\n		for(int[] x : lift) Arrays.fill(x, -1);\n		\n		dfs3(0, -1, -1);\n		\n		for(int lg = 1; lg < log; lg++) {\n			for(int i = 0; i < n; i++) {\n				if(lift[lg-1][i] == -1) continue;\n				int p = lift[lg-1][i];\n				if(lift[lg-1][p] == -1) continue;\n				\n				lift[lg][i] = lift[lg - 1][p];\n				sumDP[lg][i] = sumDP[lg-1][i] + sumDP[lg-1][p];\n				sumEdges[lg][i] = sumEdges[lg-1][i] + sumEdges[lg-1][p];\n			}\n		}\n		\n		for(int qq = 0; qq < q; qq++) {\n			int u = fs.nextInt()-1, v = fs.nextInt()-1;\n			if(u == v) {\n				out.println(dp[u][size[u]] + vals[u]);\n				continue;\n			}\n			\n			int L = LCA(u, v);\n			long res;\n			if(L == u) {\n				res = solve1Path(v, u);\n			}\n			else if(L == v) {\n				res = solve1Path(u, v);\n			}\n			else {\n				res = solveLCA(u, v);\n			}\n			\n			out.println(res);\n		}\n		\n		out.close();\n	}\n	\n	//if LCA(u, v) != u or v\n	long solveLCA(int u, int v) {\n		if(depth[v] > depth[u]) return solveLCA(v, u);\n		int L = LCA(u, v);\n		\n		long res = 0;\n		Edge fromU = adj[u].get(idxOfParent[u]);\n		res += dp[u][idxOfParent[u]] + 2 * fromU.we;\n		Edge fromV = adj[v].get(idxOfParent[v]);\n		res += dp[v][idxOfParent[v]] + 2 * fromV.we;\n		\n		for(int lg = log - 1; lg >= 0; lg--) {\n			if(lift[lg][u] == -1) continue;\n			int to = lift[lg][u];\n			\n			if(depth[to] < depth[v]) continue;\n			\n			res += sumDP[lg][u] + sumEdges[lg][u];\n			u = to;\n		}\n		\n		for(int lg = log-1; lg >= 0; lg--) {\n			if(lift[lg][u] == -1) continue;\n			int to = lift[lg][u];\n			if(depth[to] <= depth[L]) continue;\n			\n			res += sumDP[lg][u] + sumEdges[lg][u];\n			res += sumDP[lg][v] + sumEdges[lg][v];\n			\n			u = lift[lg][u];\n			v = lift[lg][v];\n		}\n		\n		int idxU = -1, idxV = -1;\n		for(int i = 0; i < size[L]; i++) {\n			if(adj[L].get(i).v == u) {\n				idxU = i;\n			}\n			if(adj[L].get(i).v == v) {\n				idxV = i;\n			}\n		}\n		\n		long finAdd = dp[L][size[L]];\n		finAdd -= Math.max(0, dp[v][idxOfParent[v]]);\n		finAdd -= Math.max(0, dp[u][idxOfParent[u]]);\n		finAdd += vals[L];\n		finAdd -= adj[L].get(idxU).we;\n		finAdd -= adj[L].get(idxV).we;\n\n		res += finAdd;\n		return res;\n	}\n	\n	//ONLY if LCA(u, v) = v.\n	long solve1Path(int u, int v) {\n		long res = 0;\n		Edge inc = adj[u].get(idxOfParent[u]);\n		res += dp[u][idxOfParent[u]] + 2 * inc.we;\n		\n		for(int lg = log-1; lg >= 0; lg--) {\n			if(lift[lg][u] == -1) continue;\n			int to = lift[lg][u];\n			\n			if(depth[to] >= depth[v]+1) {\n				res += sumDP[lg][u] + sumEdges[lg][u];\n				u = to;\n			}\n		}\n		\n		//lift[0][u] = v\n		int idx = -1;\n		for(int i = 0; i < size[v]; i++) {\n			if(adj[v].get(i).v == u) {\n				idx = i;\n			}\n		}\n		\n		res += dp[v][idx] + adj[v].get(idx).we;\n		\n		return res;\n	}\n	\n	int LCA(int u, int v) {\n		if(depth[v] > depth[u]) return LCA(v, u);\n		for(int lg = log-1; lg >= 0; lg--) {\n			if(lift[lg][u] < 0) continue;\n			int to = lift[lg][u];\n			if(depth[to] >= depth[v]) {\n				u = to;\n			}\n		}\n		\n		if(u == v) return u;\n		\n		for(int lg = log-1; lg >= 0; lg--) {\n			if(lift[lg][u] != lift[lg][v]) {\n				u = lift[lg][u];\n				v = lift[lg][v];\n			}\n		}\n		\n		return lift[0][v];\n	}\n	\n	//binary lifting stuff\n	void dfs3(int u, int p, int idxIn) {\n		for(int i = 0; i < size[u]; i++) {\n			Edge e = adj[u].get(i);\n			if(e.v == p) continue;\n			\n			depth[e.v] = 1+depth[u];\n			lift[0][e.v] = u;\n			sumEdges[0][e.v] = e.we;\n			\n			long val = dp[u][i];\n			if(idxIn != -1) val -= Math.max(0, dp[p][idxIn]);\n			\n			sumDP[0][e.v] = val;\n			\n			dfs3(e.v, u, i);\n		}\n	}\n	\n	//tree re-rooting\n	//idxIn = the index of u in adj[p]\n	void dfs2(int u, int p, int idxIn) {\n		int idx = size[u];\n		Edge incoming = null;\n		if(p != -1) {\n			for(int i = 0; i < size[u]; i++)\n				if(adj[u].get(i).v == p) {\n					idx = i;\n					incoming = adj[u].get(i);\n				}\n			\n			long cur = dp[u][idx] - vals[u] + 2 * incoming.we;\n			if(dp[p][idxIn] > 0) cur += dp[p][idxIn];\n			\n			dp[u][size[u]] = cur; //cost of being root\n		}\n		\n		for(int i = 0; i < size[u]; i++) {\n			Edge e = adj[u].get(i);\n			if(e.v == p) continue;\n			\n			long cur = dp[u][size[u]];\n			cur -= Math.max(0, dp[e.v][ idxOfParent[e.v] ]);\n			cur += vals[u] - 2 * e.we;\n			\n			dp[u][i] = cur;\n		}\n		\n		for(int i = 0; i < size[u]; i++) {\n			Edge e = adj[u].get(i);\n			if(e.v == p) continue;\n			\n			dfs2(e.v, u, i);\n		}\n	}\n	\n	int dfs(int u, int p) {\n		int idx = size[u];\n		Edge incoming = null;\n		\n		if(p != -1) {\n			for(int i = 0; i < size[u]; i++) {\n				if(adj[u].get(i).v == p) {\n					idx = i;\n					incoming = adj[u].get(i);\n				}\n			}\n			idxOfParent[u] = idx;\n		}\n		\n		if(p != -1) dp[u][idx] = vals[u] - 2 * incoming.we;\n		\n		for(int i = 0; i < size[u]; i++) {\n			Edge now = adj[u].get(i);\n			if(now.v == p) continue;\n			int id = dfs(now.v, u);\n			\n			if(dp[now.v][id] > 0) {\n				dp[u][idx] += dp[now.v][id];\n			}\n		}\n		\n		return idx;\n	}\n	\n	class Edge {\n		int v;\n		long we;\n		Edge(int vv, int ww) {\n			v = vv;\n			we = ww;\n		}\n		public String toString() {\n			return String.format(""u --> %d WE = %d"", v, we);\n		}\n	}\n	\n	class FastScanner {\n		public int BS = 1<<16;\n		public char NC = (char)0;\n		byte[] buf = new byte[BS];\n		int bId = 0, size = 0;\n		char c = NC;\n		double num = 1;\n		BufferedInputStream in;\n\n		public FastScanner() {\n			in = new BufferedInputStream(System.in, BS);\n		}\n\n		public FastScanner(String s) {\n			try {\n				in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n			}\n			catch (Exception e) {\n				in = new BufferedInputStream(System.in, BS);\n			}\n		}\n\n		public char nextChar(){\n			while(bId==size) {\n				try {\n					size = in.read(buf);\n				}catch(Exception e) {\n					return NC;\n				}                \n				if(size==-1)return NC;\n				bId=0;\n			}\n			return (char)buf[bId++];\n		}\n\n		public int nextInt() {\n			return (int)nextLong();\n		}\n\n		public long nextLong() {\n			num=1;\n			boolean neg = false;\n			if(c==NC)c=nextChar();\n			for(;(c<'0' || c>'9'); c = nextChar()) {\n				if(c=='-')neg=true;\n			}\n			long res = 0;\n			for(; c>='0' && c <='9'; c=nextChar()) {\n				res = (res<<3)+(res<<1)+c-'0';\n				num*=10;\n			}\n			return neg?-res:res;\n		}\n\n		public double nextDouble() {\n			double cur = nextLong();\n			return c!='.' ? cur:cur+nextLong()/num;\n		}\n\n		public String next() {\n			StringBuilder res = new StringBuilder();\n			while(c<=32)c=nextChar();\n			while(c>32) {\n				res.append(c);\n				c=nextChar();\n			}\n			return res.toString();\n		}\n\n		public String nextLine() {\n			StringBuilder res = new StringBuilder();\n			while(c<=32)c=nextChar();\n			while(c!='\n') {\n				res.append(c);\n				c=nextChar();\n			}\n			return res.toString();\n		}\n\n		public boolean hasNext() {\n			if(c>32)return true;\n			while(true) {\n				c=nextChar();\n				if(c==NC)return false;\n				else if(c>32)return true;\n			}\n		}\n		\n		public int[] nextIntArray(int n) {\n			int[] res = new int[n];\n			for(int i = 0; i < n; i++) res[i] = nextInt();\n			return res;\n		}\n		\n	}\n\n}","data structures,dp,trees"
"import java.io.*;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) {\n        new Main().solve();\n    }\n    BufferedReader reader;\n    BufferedWriter writer;\n    StringTokenizer tokenizer;\n    public Main() {\n        reader = new BufferedReader(new InputStreamReader(System.in));\n        writer = new BufferedWriter(new OutputStreamWriter(System.out));\n    }\n    int ni() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {}\n        }\n        return Integer.parseInt(tokenizer.nextToken());\n    }\n\n\n    int n, q, vws[], intime[], outtime[], time = -1, parents[][], logN = 19, parentIndex[];\n    long ps[], answers[], bit[];\n    ArrayList<Integer>[] t, tw;\n    ArrayList<Long>[] tp;\n    ArrayList<Query>[] queries;\n    int[] depths;\n    void solve() {\n        n = ni();\n        q = ni();\n\n        vws = new int[n];\n        for (int i = 0; i < n; i++) {\n            vws[i] = ni();\n        }\n        t = new ArrayList[n];\n        tw = new ArrayList[n];\n        tp = new ArrayList[n];\n        depths = new int[n];\n        for (int i = 0; i < n; i++) {\n            t[i] = new ArrayList<Integer>();\n            tw[i] = new ArrayList<Integer>();\n            tp[i] = new ArrayList<Long>();\n        }\n        for (int i = 0; i < n - 1; i++) {\n            int from = ni() - 1;\n            int to = ni() - 1;\n            int w = ni();\n            t[from].add(to);\n            tw[from].add(w);\n            t[to].add(from);\n            tw[to].add(w);\n        }\n        intime = new int[n];\n        outtime = new int[n];\n        ps = new long[n];\n        parents = new int[n][logN];\n        parentIndex = new int[n];\n        ps[0] = calcRoot(0, 0, 0);\n        calcOthers(0, -1, 0);\n//        for (int i = 0; i < n; i++) {\n//            System.out.println(ps[i]);\n//            for (int j = 0; j < tp[i].size(); j++) {\n//                System.out.print(t[i].get(j) + 1 + ""->"" + tp[i].get(j) + ""; "");\n//            }\n//            System.out.println();\n//        }\n//        System.out.println();\n\n        answers = new long[q];\n        queries = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            queries[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < q; i++) {\n            int u = ni() - 1;\n            int v = ni() - 1;\n            int parent = lca(u, v);\n//            System.out.println(parent);\n//            System.out.println(depths[parent]);\n            Query q = new Query(i, depths[parent]);\n            queries[u].add(q);\n            queries[v].add(q);\n            answers[i] = - ps[parent] + (parent != 0 ? tp[parent].get(parentIndex[parent]) * 2 : 0);\n        }\n\n        bit = new long[n];\n        calcAnswers(0, 0);\n\n        try {\n            for (int i = 0; i < q; i++) {\n                writer.write(answers[i] + ""\n"");\n            }\n            writer.close();\n        } catch (IOException e) {}\n    }\n\n    long calcRoot(int v, int p, int d) {\n        intime[v] = ++time;\n        depths[v] = d;\n        parents[v][0] = p;\n        for (int i = 1; i < logN; i++) {\n            parents[v][i] = parents[parents[v][i - 1]][i - 1];\n        }\n        long cost = vws[v];\n        for (int i = 0; i < t[v].size(); i++) {\n            int ch = t[v].get(i);\n            if (ch != p) {\n                long ew = Math.max(0, calcRoot(ch, v, d + 1) - 2 * tw[v].get(i));\n                tp[v].add(ew);\n                cost += ew;\n            } else {\n                tp[v].add(0L);\n            }\n        }\n        outtime[v] = ++time;\n        return cost;\n    }\n    void calcOthers(int v, int p, long c) {\n        long curCost = c + vws[v];\n        for (int i = 0; i < t[v].size(); i++) {\n            int ch = t[v].get(i);\n            if (ch == p) {\n                tp[v].set(i, (long)c);\n                parentIndex[v] = i;\n            } else {\n                curCost += tp[v].get(i);\n            }\n        }\n        ps[v] = curCost;\n        for (int i = 0; i < t[v].size(); i++) {\n            int ch = t[v].get(i);\n            if (ch != p) {\n                calcOthers(ch, v, Math.max(0, curCost - tp[v].get(i) - tw[v].get(i) * 2));\n            }\n        }\n    }\n    boolean isParent(int p, int v) {\n        return intime[p] <= intime[v] && outtime[p] >= outtime[v];\n    }\n    int lca(int u, int v) {\n        if (isParent(u, v)) return u;\n        if (isParent(v, u)) return v;\n        for (int i = logN - 1; i >=0; i--) {\n            if (!isParent(parents[v][i], u)) {\n                v = parents[v][i];\n            }\n        }\n        return parents[v][0];\n    }\n\n    void set(int i, long dif) {\n        while (i < n) {\n            bit[i] += dif;\n            i = i | (i + 1);\n        }\n    }\n    long get(int i, int j) {\n        return sum(j) - sum(i - 1);\n    }\n    long sum(int i) {\n        long res = 0;\n        while (i >= 0) {\n            res += bit[i];\n            i = (i & (i + 1)) - 1;\n        }\n        return res;\n    }\n\n    void calcAnswers(int v, int p) {\n        long cur = ps[v];\n        if (p != v) {\n            cur -= tp[v].get(parentIndex[v]);\n        }\n        for (Query q : queries[v]) {\n            answers[q.i] += cur + get(q.d, depths[v] - 1);\n        }\n        set(depths[v], cur);\n        for (int i = 0; i < t[v].size(); i++) {\n            if (t[v].get(i) == p) {\n                continue;\n            }\n            long curSub = tp[v].get(i) + tw[v].get(i);\n            set(depths[v], -curSub);\n            calcAnswers(t[v].get(i), v);\n            set(depths[v], curSub);\n        }\n        set(depths[v], -cur);\n    }\n\n}\n\nclass Query {\n    public int i;\n    public int d;\n    public Query(int index, int depth) {\n        i = index;\n        d = depth;\n    }\n}","data structures,dp,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class Main{\n	static LinkedList<int[]>adj[],qs[];\n	static long[]in,ans;\n	static long[]up,down,prefNodes,prefEdges;\n	static long[]parEdge;\n	static void dfsDown(int i,int p,long val) {\n		prefNodes[i]=in[i];\n		prefEdges[i]=val;\n		parEdge[i]=val;\n		if(p!=-1) {\n			prefNodes[i]+=prefNodes[p];\n			prefEdges[i]+=prefEdges[p];\n		}\n		for(int[]nxt:adj[i]) {\n			if(nxt[0]==p)continue;\n			int u=nxt[0];\n			long w=nxt[1];\n			dfsDown(u, i, w);\n			down[i]+=Math.max(0, down[u]+in[u]-w-w);\n		}\n		\n	}\n	static void dfsUp(int i,int p) {\n		for(int[]nxt:adj[i]) {\n			if(nxt[0]==p)continue;\n			int u=nxt[0];\n			long w=nxt[1];\n			long me=down[i]-Math.max(0, down[u]+in[u]-w-w);\n			up[u]=Math.max(0, me+in[i]-w-w+up[i]);\n			dfsUp(u, i);\n		}\n	}\n	static int log = 22;\n	static int[] level, par[];\n	static void preLCA(int root,int n) {\n		par = new int[n][log];\n		level = new int[n];\n		dfs(root, root);\n	}\n \n	static int lca(int u, int v) {\n		 \n		if (level[u] < level[v])\n			return lca(v, u);\n		for (int i = log - 1; i >= 0; i--) {\n			int u2 = par[u][i];\n			if (level[u2] >= level[v])\n				u = u2;\n		}\n		if (u == v)\n			return u;\n		for (int i = log - 1; i >= 0; i--) {\n			int u2 = par[u][i], v2 = par[v][i];\n			if (u2 != v2) {\n				u = u2;\n				v = v2;\n			}\n		}\n		return par[u][0];\n	}\n	static int lastChild(int u,int grandPar) {\n		for (int i = log - 1; i >= 0; i--) {\n			int u2 = par[u][i];\n			if (level[u2] > level[grandPar])\n				u = u2;\n		}\n		return u;\n	}\n	static void dfs(int u, int p) {\n		par[u][0] = p;\n		for (int i = 1; i < log; i++)\n			par[u][i] = par[par[u][i - 1]][i - 1];\n		for (int[]v : adj[u])\n			if (v[0] != p) {\n				level[v[0]] = level[u] + 1;\n				dfs(v[0], u);\n			}\n \n	}\n	static long[]pref;\n	static void lastDfs(int i,int p,long curPref) {\n		pref[i]=curPref;\n		for(int[]q:qs[i]) {\n			int lca=q[0],idx=q[1];\n			ans[idx]+=curPref-pref[lca];\n		}\n		for(int[]nxt:adj[i]) {\n			if(nxt[0]==p)continue;\n			int u=nxt[0];\n			long w=nxt[1];\n			lastDfs(u, i, curPref+down[i]-Math.max(0, down[u]+in[u]-w-w));\n		}\n	}\n	static void main() throws Exception{\n		int n=sc.nextInt(),q=sc.nextInt();\n		in=sc.longArr(n);\n		adj=new LinkedList[n];\n		qs=new LinkedList[n];\n		for(int i=0;i<n;i++) {\n			adj[i]=new LinkedList<int[]>();\n			qs[i]=new LinkedList<int[]>();\n		}\n		for(int i=0;i<n-1;i++) {\n			int x=sc.nextInt()-1,y=sc.nextInt()-1,w=sc.nextInt();\n			adj[x].add(new int[] {y,w});\n			adj[y].add(new int[] {x,w});\n		}\n		ans=new long[q];\n		prefNodes=new long[n];\n		prefEdges=new long[n];\n		down=new long[n];\n		up=new long[n];\n		parEdge=new long[n];\n		dfsDown(0, -1, 0);\n		dfsUp(0, -1);\n		preLCA(0, n);\n		for(int i=0;i<q;i++) {\n			int u=sc.nextInt()-1,v=sc.nextInt()-1;\n			if(u==v) {\n				ans[i]=down[u]+up[u]+in[u];\n				continue;\n			}\n			int lca=lca(u, v);\n			ans[i]=up[lca]+prefNodes[u]+prefNodes[v]-prefNodes[lca]*2+in[lca]-(prefEdges[u]+prefEdges[v]-prefEdges[lca]*2);\n			if(u!=lca) {\n				qs[u].add(new int[] {lca,i});\n				ans[i]+=down[u];\n			}\n			if(v!=lca) {\n				qs[v].add(new int[] {lca,i});\n				ans[i]+=down[v];\n			}\n			if(u!=lca && v!=lca) {\n				ans[i]-=down[lca];\n			}\n		}\n\n		pref=new long[n];\n		lastDfs(0,-1,0);\n		for(int i=0;i<q;i++) {\n			pw.println(ans[i]);\n		}\n    }\n    public static void main(String[] args) throws Exception{\n    	sc=new MScanner(System.in);\n    	pw = new PrintWriter(System.out);\n        int tc=1;\n//        tc=sc.nextInt();\n        for(int i=1;i<=tc;i++) {\n//            pw.printf(""Case #%d: "", i);\n            main();\n        }\n        pw.flush();\n    }\n    static PrintWriter pw;\n    static MScanner sc;\n    static class MScanner {\n        StringTokenizer st;\n        BufferedReader br;\n        public MScanner(InputStream system) {\n            br = new BufferedReader(new InputStreamReader(system));\n        }\n     \n        public MScanner(String file) throws Exception {\n            br = new BufferedReader(new FileReader(file));\n        }\n     \n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        public int[] intArr(int n) throws IOException {\n            int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n            return in;\n        }\n        public long[] longArr(int n) throws IOException {\n            long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n            return in;\n        }\n        public int[] intSortedArr(int n) throws IOException {\n            int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n            shuffle(in);\n            Arrays.sort(in);\n            return in;\n        }\n        public long[] longSortedArr(int n) throws IOException {\n            long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n            shuffle(in);\n            Arrays.sort(in);\n            return in;\n        }\n        public Integer[] IntegerArr(int n) throws IOException {\n            Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n            return in;\n        }\n        public Long[] LongArr(int n) throws IOException {\n            Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n            return in;\n        }\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n     \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n     \n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n     \n        public char nextChar() throws IOException {\n            return next().charAt(0);\n        }\n     \n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n     \n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n     \n        public void waitForInput() throws InterruptedException {\n            Thread.sleep(3000);\n        }\n        \n    }\n    static void sort(int[]in) {\n    	shuffle(in);\n        Arrays.sort(in);\n    }\n    static void sort(long[]in) {\n    	shuffle(in);\n        Arrays.sort(in);\n    }\n    static void shuffle(int[]in) {\n        for(int i=0;i<in.length;i++) {\n            int idx=(int)(Math.random()*in.length);\n            int tmp=in[i];\n            in[i]=in[idx];\n            in[idx]=tmp;\n        }\n    }\n    static void shuffle(long[]in) {\n        for(int i=0;i<in.length;i++) {\n            int idx=(int)(Math.random()*in.length);\n            long tmp=in[i];\n            in[i]=in[idx];\n            in[idx]=tmp;\n        }\n    }\n}","data structures,dp,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class Main{\n	static LinkedList<int[]>qs[];\n	static int[][][]adj;\n	static long[]in,ans;\n	static long[]up,down,prefNodes,prefEdges;\n	static long[]parEdge;\n	static void dfsDown(int i,int p,long val) {\n		prefNodes[i]=in[i];\n		prefEdges[i]=val;\n		parEdge[i]=val;\n		if(p!=-1) {\n			prefNodes[i]+=prefNodes[p];\n			prefEdges[i]+=prefEdges[p];\n		}\n		for(int[]nxt:adj[i]) {\n			if(nxt[0]==p)continue;\n			int u=nxt[0];\n			long w=nxt[1];\n			dfsDown(u, i, w);\n			down[i]+=Math.max(0, down[u]+in[u]-w-w);\n		}\n		\n	}\n	static void dfsUp(int i,int p) {\n		for(int[]nxt:adj[i]) {\n			if(nxt[0]==p)continue;\n			int u=nxt[0];\n			long w=nxt[1];\n			long me=down[i]-Math.max(0, down[u]+in[u]-w-w);\n			up[u]=Math.max(0, me+in[i]-w-w+up[i]);\n			dfsUp(u, i);\n		}\n	}\n	static int log = 19;\n	static int[] level, par[];\n	static void preLCA(int root,int n) {\n		par = new int[n][log];\n		level = new int[n];\n		dfs(root, root);\n	}\n \n	static int lca(int u, int v) {\n		 \n		if (level[u] < level[v])\n			return lca(v, u);\n		for (int i = log - 1; i >= 0; i--) {\n			int u2 = par[u][i];\n			if (level[u2] >= level[v])\n				u = u2;\n		}\n		if (u == v)\n			return u;\n		for (int i = log - 1; i >= 0; i--) {\n			int u2 = par[u][i], v2 = par[v][i];\n			if (u2 != v2) {\n				u = u2;\n				v = v2;\n			}\n		}\n		return par[u][0];\n	}\n	static int lastChild(int u,int grandPar) {\n		for (int i = log - 1; i >= 0; i--) {\n			int u2 = par[u][i];\n			if (level[u2] > level[grandPar])\n				u = u2;\n		}\n		return u;\n	}\n	static void dfs(int u, int p) {\n		par[u][0] = p;\n		for (int i = 1; i < log; i++)\n			par[u][i] = par[par[u][i - 1]][i - 1];\n		for (int[]v : adj[u])\n			if (v[0] != p) {\n				level[v[0]] = level[u] + 1;\n				dfs(v[0], u);\n			}\n \n	}\n	static long[]pref;\n	static void lastDfs(int i,int p,long curPref) {\n		pref[i]=curPref;\n		for(int[]q:qs[i]) {\n			int lca=q[0],idx=q[1];\n			ans[idx]+=curPref-pref[lca];\n		}\n		for(int[]nxt:adj[i]) {\n			if(nxt[0]==p)continue;\n			int u=nxt[0];\n			long w=nxt[1];\n			lastDfs(u, i, curPref+down[i]-Math.max(0, down[u]+in[u]-w-w));\n		}\n	}\n	static void main() throws Exception{\n		int n=sc.nextInt(),q=sc.nextInt();\n		in=sc.longArr(n);\n		adj=new int[n][][];\n		qs=new LinkedList[n];\n		int[]sizes=new int[n];\n		int[][]edges=new int[n-1][];\n		for(int i=0;i<n;i++) {\n			qs[i]=new LinkedList<int[]>();\n		}\n		for(int i=0;i<n-1;i++) {\n			int x=sc.nextInt()-1,y=sc.nextInt()-1,w=sc.nextInt();\n			edges[i]=new int[] {x,y,w};\n			sizes[x]++;\n			sizes[y]++;\n		}\n		for(int i=0;i<n;i++) {\n			adj[i]=new int[sizes[i]][];\n		}\n		for(int i=0;i<n-1;i++) {\n			int x=edges[i][0],y=edges[i][1],w=edges[i][2];\n			adj[x][--sizes[x]]=new int[] {y,w};\n			adj[y][--sizes[y]]=new int[] {x,w};\n		}\n		ans=new long[q];\n		prefNodes=new long[n];\n		prefEdges=new long[n];\n		down=new long[n];\n		up=new long[n];\n		parEdge=new long[n];\n		dfsDown(0, -1, 0);\n		dfsUp(0, -1);\n		preLCA(0, n);\n		for(int i=0;i<q;i++) {\n			int u=sc.nextInt()-1,v=sc.nextInt()-1;\n			if(u==v) {\n				ans[i]=down[u]+up[u]+in[u];\n				continue;\n			}\n			int lca=lca(u, v);\n			ans[i]=up[lca]+prefNodes[u]+prefNodes[v]-prefNodes[lca]*2+in[lca]-(prefEdges[u]+prefEdges[v]-prefEdges[lca]*2);\n			if(u!=lca) {\n				qs[u].add(new int[] {lca,i});\n				ans[i]+=down[u];\n			}\n			if(v!=lca) {\n				qs[v].add(new int[] {lca,i});\n				ans[i]+=down[v];\n			}\n			if(u!=lca && v!=lca) {\n				ans[i]-=down[lca];\n			}\n		}\n\n		pref=new long[n];\n		lastDfs(0,-1,0);\n		for(int i=0;i<q;i++) {\n			pw.println(ans[i]);\n		}\n    }\n    public static void main(String[] args) throws Exception{\n    	sc=new MScanner(System.in);\n    	pw = new PrintWriter(System.out);\n        int tc=1;\n//        tc=sc.nextInt();\n        for(int i=1;i<=tc;i++) {\n//            pw.printf(""Case #%d: "", i);\n            main();\n        }\n        pw.flush();\n    }\n    static PrintWriter pw;\n    static MScanner sc;\n    static class MScanner {\n        StringTokenizer st;\n        BufferedReader br;\n        public MScanner(InputStream system) {\n            br = new BufferedReader(new InputStreamReader(system));\n        }\n     \n        public MScanner(String file) throws Exception {\n            br = new BufferedReader(new FileReader(file));\n        }\n     \n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n        public int[] intArr(int n) throws IOException {\n            int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n            return in;\n        }\n        public long[] longArr(int n) throws IOException {\n            long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n            return in;\n        }\n        public int[] intSortedArr(int n) throws IOException {\n            int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n            shuffle(in);\n            Arrays.sort(in);\n            return in;\n        }\n        public long[] longSortedArr(int n) throws IOException {\n            long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n            shuffle(in);\n            Arrays.sort(in);\n            return in;\n        }\n        public Integer[] IntegerArr(int n) throws IOException {\n            Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n            return in;\n        }\n        public Long[] LongArr(int n) throws IOException {\n            Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n            return in;\n        }\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n     \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n     \n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n     \n        public char nextChar() throws IOException {\n            return next().charAt(0);\n        }\n     \n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n     \n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n     \n        public void waitForInput() throws InterruptedException {\n            Thread.sleep(3000);\n        }\n        \n    }\n    static void sort(int[]in) {\n    	shuffle(in);\n        Arrays.sort(in);\n    }\n    static void sort(long[]in) {\n    	shuffle(in);\n        Arrays.sort(in);\n    }\n    static void shuffle(int[]in) {\n        for(int i=0;i<in.length;i++) {\n            int idx=(int)(Math.random()*in.length);\n            int tmp=in[i];\n            in[i]=in[idx];\n            in[idx]=tmp;\n        }\n    }\n    static void shuffle(long[]in) {\n        for(int i=0;i<in.length;i++) {\n            int idx=(int)(Math.random()*in.length);\n            long tmp=in[i];\n            in[i]=in[idx];\n            in[idx]=tmp;\n        }\n    }\n}","data structures,dp,trees"
"import java.util.ArrayList;\nimport java.util.Scanner;\nimport java.lang.StringBuilder;\nimport java.util.Arrays;\nimport java.util.Stack;\nimport java.util.TreeMap;\npublic class Test10   {  \n    public static void main(String[] Args)   {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int r = sc.nextInt();\n        int tot = 1 << n;\n        int[] a = new int[tot];\n        long sum = 0;\n        for (int i = 0; i < tot; i++)   {\n            a[i] = sc.nextInt();\n            sum += a[i];\n        }    \n        int i0 = 0;\n        int rp = 0;\n        StringBuilder ans = new StringBuilder();\n        for (int i = 1; i <= r; i++)  {\n            ans.append(((float)sum)/tot);\n            ans.append(""\n"");\n            i0 = sc.nextInt();\n            rp = sc.nextInt();\n            sum += rp - a[i0];\n            a[i0] = rp;\n        }    \n            ans.append(((float)sum)/tot);\n        System.out.println(ans);\n   }\n}",math
import java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\npublic class D {\n    public static void main(String[] args) throws Exception {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(bf.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int r = Integer.parseInt(st.nextToken());\n        long[] a = new long[1<<n];\n\n        // Scanner scan = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        // int n = Integer.parseInt(bf.readLine());\n        st = new StringTokenizer(bf.readLine());\n\n        for(int i=0; i<(1<<n); i++) a[i] = 0L + Integer.parseInt(st.nextToken());\n        double sum = 0;\n        for(int i=0; i<(1<<n); i++) sum += a[i];\n        out.println(sum/(1<<n));\n        for(int i=0; i<r; i++) {\n          st = new StringTokenizer(bf.readLine());\n          int z = Integer.parseInt(st.nextToken());\n          int g = Integer.parseInt(st.nextToken());\n          sum -= a[z];\n          sum += g;\n          a[z] = g;\n          out.println(sum/(1<<n));\n        }\n        // int n = Integer.parseInt(st.nextToken());\n        // int n = scan.nextInt();\n\n       out.close(); System.exit(0);\n    }\n}\n,math
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class D {\n\n	public static void main(String[] args) {\n		FastScanner fs=new FastScanner();\n		int n=fs.nextInt();\n		int r=fs.nextInt();\n		int[] values=fs.readArray(1<<n);\n		n=1<<n;\n		long total=0;\n		for (int i:values) total+=i;\n		PrintWriter out=new PrintWriter(System.out);\n		for (int i=0; i<r; i++) {\n			out.printf(""%.10f\n"", total/(double)n);\n			int nextIndex=fs.nextInt();\n			int nextValue=fs.nextInt();\n			total-=values[nextIndex];\n			total+=nextValue;\n			values[nextIndex]=nextValue;\n		}\n		out.printf(""%.10f\n"", total/(double)n);\n		out.close();\n\n	}\n\n	static class FastScanner {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n		\n		public String next() {\n			while (!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n			\n		}\n		\n		public int nextInt() {\n			return Integer.parseInt(next());\n		}\n		\n		public int[] readArray(int n) {\n			int[] a=new int[n];\n			for (int i=0; i<n; i++)\n				a[i]=nextInt();\n			return a;\n		}\n	}\n	\n}\n",math
import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class D {\n	\n	public static void main(String[] args) throws IOException {\n		MyScanner sc = new MyScanner();\n		PrintWriter out = new PrintWriter(System.out);\n		int n = sc.nextInt();\n		int r = sc.nextInt();\n		int[] elems = new int[1<<n];\n		long sum = 0;\n		double total = 1<<n;\n		for (int i = 0; i < 1<<n; i++) {\n			elems[i] = sc.nextInt();\n			sum += elems[i];\n		}\n		out.println(sum / total);\n		int pos;\n		for (int i = 0; i < r; i++) {\n			pos = sc.nextInt();\n			sum -= elems[pos];\n			sum += elems[pos] = sc.nextInt();\n			out.println(sum / total);\n		}\n		\n		out.flush();\n	}\n	\n	static class MyScanner {\n		private BufferedReader br;\n		private StringTokenizer tokenizer;\n		\n		public MyScanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n		\n		public String next() {\n			while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n				try {\n					tokenizer = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n			return tokenizer.nextToken();\n		}\n		\n		public int nextInt() {\n			return Integer.parseInt(next());\n		}\n		\n		public long nextLong() {\n			return Long.parseLong(next());\n		}\n	}\n}\n,math
"import java.util.*;\npublic class Main {\n	public static void main(String[] args){\n		Scanner sc=new Scanner(System.in);\n		int a=sc.nextInt(),b=sc.nextInt();\n		int[] x=new int[a];\n		int[] y=new int[b];\n		for(int i=0;i<a;i++){\n			x[i]=sc.nextInt();\n		}\n		for(int i=0;i<b;i++){\n			y[i]=sc.nextInt();\n		}\n		for(int i=0;i<a;i++){\n			for(int j=0;j<b;j++){\n				if(x[i]==y[j])\n					System.out.print(x[i]+"" "");\n			}\n		}\n	}\n}",implementation
"\nimport java.util.Scanner;\n\npublic class fingerprints {\n	public static void main(String args[]) {\n		Scanner sc=new Scanner(System.in);\n		int n =sc.nextInt();\n		int m=sc.nextInt();\n		int a[]= new int[n];\n		int b[]=new int[m];\n		\n		for(int i=0;i<n;i++) {a[i]=sc.nextInt();}\n		for(int i=0;i<m;i++) {b[i]=sc.nextInt();}\n				\n		for(int i=0;i<n;i++) {\n			for(int j=0;j<m;j++) {\n				if(a[i]==b[j])\n					System.out.print(a[i]+"" "");\n			}\n		}\n		\n		\n\n}\n}\n\n",implementation
"import java.util.Scanner;\npublic class p994a{\n	public static void main(String[] args) {\n		Scanner s=new Scanner(System.in);\n		int n=s.nextInt();\n		int m=s.nextInt();\n		int[] ar = new int[n];\n		int[] ar1 = new int[m];\n		for(int i=0;i<n;i++)\n		{\n			ar[i]=s.nextInt();\n		}\n		for(int j=0;j<m;j++)\n		{\n			ar1[j]=s.nextInt();\n		}\n		for(int i=0;i<n;i++)\n		{\n			for(int j=0;j<m;j++)\n			{\n				if(ar[i]==ar1[j])\n				{\n					System.out.print("" ""+ar[i]);\n				}\n			}\n		}\n	}\n}",implementation
"\nimport java.util.*;\n\n\n\npublic class CR488A {\n	public static void main(String[] args) {\n		Scanner s=new Scanner(System.in);\n		\n		int n=s.nextInt();\n		int m=s.nextInt();\n		List<Integer> ans=new ArrayList();\n		\n		int[] a=new int[n];\n		int[] b=new int[10];\n		for(int i=0;i<n;i++) {\n			a[i]=s.nextInt();\n		}\n		\n		for(int i=0;i<m;i++) {\n			b[s.nextInt()]++;\n		}\n		\n		for(int i=0;i<n;i++) {\n			if(b[a[i]]>0) {\n				System.out.print(a[i]+"" "");\n			}\n		}\n		\n	  \n	}\n\n}\n",implementation
"import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\n\npublic class Div2_487E {\n\n	int N;\n\n	public static void main(String[] args) throws IOException {\n		new Div2_487E().main();\n	}\n\n	Pt[] pts;\n\n	double[][][] pows = new double[16][][];\n\n	void main() throws IOException {\n		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		N = Integer.parseInt(reader.readLine());\n\n		pts = new Pt[N];\n		for (int i = 0; i < N; i++) {\n			StringTokenizer inputData = new StringTokenizer(reader.readLine());\n			pts[i] = new Pt(Integer.parseInt(inputData.nextToken()), Integer.parseInt(inputData.nextToken()), i);\n		}\n\n		Pt[] srtd = Arrays.copyOf(pts, N);\n\n		double[][] probs = new double[N][N];\n\n		ArrayList<ArrayList<Integer>> sets = new ArrayList<>();\n\n		for (int pI = 0; pI < N; pI++) {\n			pivot = pts[pI];\n			Arrays.sort(srtd);\n\n			int numL = 0;\n			for (int i = 1; i < N; i++) {\n				if (i == 1 || srtd[i].compareTo(srtd[i - 1]) != 0) {\n					numL++;\n				}\n			}\n\n			for (int i = 1; i < N;) {\n				ArrayList<Integer> cSet = new ArrayList<>();\n				sets.add(cSet);\n				cSet.add(pivot.i);\n\n				int j = i;\n				while (j + 1 < N && srtd[j + 1].compareTo(srtd[i]) == 0) {\n					j++;\n				}\n				int numO = j - i + 2;\n\n				probs[pI][pI] += 1.0 / numL / numO;\n\n				while (i <= j) {\n					cSet.add(srtd[i].i);\n					probs[pI][srtd[i].i] = 1.0 / numL / numO;\n					i++;\n				}\n				Collections.sort(cSet);\n			}\n		}\n\n		Collections.sort(sets, lSorter);\n		ArrayList<ArrayList<Integer>> nDup = new ArrayList<>();\n		for (int i = 0; i < sets.size(); i++) {\n			if (i == 0 || lSorter.compare(sets.get(i), sets.get(i - 1)) != 0) {\n				nDup.add(sets.get(i));\n			}\n		}\n		// sets = nDup;\n\n		pows[0] = new double[N][N];\n		for (int i = 0; i < N; i++) {\n			pows[0][i][i] = 1;\n		}\n		pows[1] = probs;\n		for (int i = 2; i < 16; i++) {\n			pows[i] = mult(pows[i - 1], pows[i - 1]);\n		}\n\n		double[][] trans = new double[N][N];\n\n		int Q = Integer.parseInt(reader.readLine());\n		while (Q-- > 0) {\n			StringTokenizer inputData = new StringTokenizer(reader.readLine());\n			int t = Integer.parseInt(inputData.nextToken()) - 1;\n			int m = Integer.parseInt(inputData.nextToken());\n			double[] column = new double[N];\n			column[t] = 1;\n			double[] res = exp(m - 1, column);\n\n			double max = 0;\n\n			for (ArrayList<Integer> cSet : sets) {\n				double sum = 0;\n\n				for (int mPt : cSet) {\n					sum += res[mPt] / cSet.size();\n				}\n				max = Math.max(max, sum);\n			}\n			printer.println(max);\n		}\n		printer.close();\n	}\n\n	Comparator<ArrayList<Integer>> lSorter = new Comparator<ArrayList<Integer>>() {\n		public int compare(ArrayList<Integer> l1, ArrayList<Integer> l2) {\n			if (l1.size() < l2.size()) {\n				return -1;\n			}\n			if (l1.size() > l2.size()) {\n				return 1;\n			}\n\n			for (int i = 0; i < l1.size(); i++) {\n				int a = l1.get(i);\n				int b = l2.get(i);\n				if (a < b) {\n					return -1;\n				}\n				if (a > b) {\n					return 1;\n				}\n			}\n			return 0;\n		}\n	};\n\n	double[] exp(int exp, double[] cur) {\n		int cPow = 1;\n		while (exp > 0) {\n			if ((exp & 1) != 0) {\n				cur = mult(pows[cPow], cur);\n			}\n			exp >>= 1;\n			cPow++;\n		}\n		return cur;\n	}\n\n	double[][] mult(double[][] a, double[][] b) {\n		double[][] res = new double[N][N];\n\n		for (int i = 0; i < N; i++) {\n			for (int j = 0; j < N; j++) {\n				double sum = 0;\n				for (int k = 0; k < N; k++) {\n					sum += a[i][k] * b[k][j];\n				}\n				res[i][j] = sum;\n			}\n		}\n		return res;\n	}\n\n	double[] mult(double[][] a, double[] b) {\n		double[] res = new double[N];\n\n		for (int i = 0; i < N; i++) {\n			double sum = 0;\n			for (int j = 0; j < N; j++) {\n				sum += a[i][j] * b[j];\n			}\n			res[i] = sum;\n		}\n		return res;\n	}\n\n	Pt pivot;\n\n	class Pt implements Comparable<Pt> {\n		int x, y, i;\n\n		Pt(int x, int y, int i) {\n			this.x = x;\n			this.y = y;\n			this.i = i;\n		}\n\n		public int compareTo(Pt o) {\n			if (this == pivot) {\n				return -1;\n			}\n			if (o == pivot) {\n				return 1;\n			}\n\n			long v1x = x - pivot.x;\n			long v1y = y - pivot.y;\n			if (v1x < 0 || v1x == 0 && v1y > 0) {\n				v1x = -v1x;\n				v1y = -v1y;\n			}\n\n			long v2x = o.x - pivot.x;\n			long v2y = o.y - pivot.y;\n			if (v2x < 0 || v2x == 0 && v2y > 0) {\n				v2x = -v2x;\n				v2y = -v2y;\n			}\n			long i = v1x * v2y - v1y * v2x;\n\n			// HD, Section 2-7\n			return (int) ((i >> 63) | (-i >>> 63));\n		}\n	}\n\n}\n","dp,geometry,matrices,probabilities"
"import java.util.*;\nimport java.lang.Math;\npublic class Main {\n	static long n,H;\n	static Scanner cin = new Scanner(System.in);\n	public static void main(String[] args) {\n		n=cin.nextLong();\n		H=cin.nextLong();\n		long l=1;\n		long r=min(n,2000000000l);\n		long ans=1;\n		while(l<=r) {\n			long mid=(l+r)/2;\n			if(f(mid)<n) l=mid+1;\n			else {\n				ans=mid;\n				r=mid-1;\n			}\n		}\n		System.out.println(ans);\n	}\n	private static long min(long n2, long l) {\n		return (n2<l?n2:l);\n	}\n	static long f(long h) {\n		if(h<=H) {\n			return h*(h+1)/2;\n		}\n		else {\n			long l=h-H-1;\n			long M=(h+H)/2;\n			if(l%2==1) return (M+H)*(M-H+1)/2+(M-1)*M/2;\n			else return (M+H)*(M-H+1)/2+(M+1)*M/2;\n		}\n	}\n}","binary search,constructive algorithms,math"
"// discussed with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF985D {\n	static long count(long h, long h_) {\n		return (h < h_ ? (h_ - h) * (h + h_ - 1) / 2: 0) + h_ * (h_ + 1) / 2;\n	}\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		long n = Long.parseLong(st.nextToken());\n		long h = Long.parseLong(st.nextToken());\n		long lower = 0, upper = 1;\n		while (count(h, upper) <= n) {\n			lower = upper;\n			upper *= 2;\n		}\n		while (upper - lower > 1) {\n			long h_ = (lower + upper) / 2;\n			if (count(h, h_) <= n)\n				lower = h_;\n			else\n				upper = h_;\n		}\n		long h_ = lower;\n		long n_ = n - count(h, h_);\n		long ans = (h < h_ ? h_ - h : 0) + h_ + (n_ + h_ - 1) / h_;\n		System.out.println(ans);\n	}\n}\n","binary search,constructive algorithms,math"
"import java.util.*;\nimport java.math.*;\n\npublic class Main{\n  static long N, H;\n  static BigInteger NB, TWO;\n\n  static BigInteger sumUp(long x){\n    BigInteger X = new BigInteger("""" + x);\n    return X.multiply(X.add(BigInteger.ONE)).divide(TWO);\n  }\n\n  static boolean pos(long r){\n    BigInteger maximum;\n    if(H >= r){\n      maximum = sumUp(r);\n    }\n    else{\n      BigInteger h = new BigInteger("""" + ((r+H)/2));\n      maximum = TWO.multiply(sumUp(h.longValueExact())).subtract(sumUp(H-1));\n      if((r+H)%2 == 0){\n        maximum = maximum.subtract(h);\n      }\n    }\n    return maximum.compareTo(NB) >= 0;\n  }\n\n  public static void main(String[] args){\n    Scanner s = new Scanner(System.in);\n    N = s.nextLong();\n    H = s.nextLong();\n    NB = new BigInteger("""" + N);\n    TWO = BigInteger.ONE.add(BigInteger.ONE);\n\n    long l=1, r=N+1;\n    while(l != r){\n      long m = (l+r)/2;\n      if(pos(m)){\n        r = m;\n      }\n      else{\n        l = m+1;\n      }\n    }\n\n    System.out.println(l);\n  }\n}\n","binary search,constructive algorithms,math"
"import java.io.*;\nimport java.util.Scanner;\n\npublic class con1D {\n	static long n,h,res;\n	static void read(){\n		try{\n			Scanner cs=new Scanner(System.in);\n			n=cs.nextLong();\n			h=cs.nextLong();\n		}catch(Exception e){\n			System.err.print(e);\n		}\n	}\n	static void prep(){\n		\n	}\n	static long high(long x){\n		if(x==0)return 0;\n		long y=x%2;\n		long z=x/2;\n		long a=high(z);\n		a=a+a+z*(z+y)+(z+1)*(y);\n		return a;\n	}\n	static long py(long x){\n		x=x+h-1;\n		return (2*high(x/2)+(x/2+1)*(x%2)-high(h-1));\n	}\n	static void proceed(){\n		long l=1;\n		long r=h;\n		if (r>1414213570)r=1414213570;\n		long ans=-1;\n		while (l<=r){\n			long m=(l+r)/2;\n			if (n>high(m)) \n				{l=m+1;}\n			else {r=m-1;ans=m;};\n		}\n		if (ans>-1){\n			res=ans;\n			return;\n		}\n		l=1;\n		r=2000000000;\n		ans=-1;\n		while (l<=r){\n			long m=(l+r)/2;\n			if (n>py(m)) \n				{l=m+1;}\n			else {r=m-1;ans=m;};\n		}\n		if (ans>-1){\n			res=ans;\n			return;\n		}\n	}\n	static void print(){\n		System.out.println(res);\n	}\n	public static void main(String[] args){\n		read();\n		prep();\n		proceed();\n		print();\n	}\n\n}\n","binary search,constructive algorithms,math"
"import java.util.*;\nimport java.io.*;\npublic class main{\n    public static void main(String[] args){\n        Scanner sc =new Scanner(System.in);\n        int n=sc.nextInt();\n           String s=sc.next();\n           s=""0""+s+""0"";\n           if(s.contains(""000"") || s.contains(""11"")){\n                System.out.print(""No"");\n           }\n            else\n            System.out.print(""Yes"");\n        }\n}\n\n","brute force,constructive algorithms"
"import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int n = 0;\n        while(input.hasNext()) {\n            n = input.nextInt();\n            String s1 = input.next();\n            s1 = '0' + s1;\n            s1 = s1 + '0';\n            if (s1.contains(""11""))\n                System.out.println(""No"");\n            else if (s1.contains(""000""))\n                System.out.println(""No"");\n            else\n                System.out.println(""Yes"");\n        }\n    }\n}\n\n 			 		   	  	 			   	  	  	  	","brute force,constructive algorithms"
"import java.io.*;\nimport java.util.*;\npublic class Main\n{\n	public static void main(String[] args)throws IOException {\n		InputStreamReader read=new InputStreamReader(System.in);\n		BufferedReader in=new BufferedReader(read);\n		int n=Integer.parseInt(in.readLine());\n		String str=in.readLine();\n		if(str.equals(""0""))\n		System.out.println(""No"");\n		else if(str.contains(""11""))\n		System.out.println(""No"");\n		else if(str.contains(""000""))\n		System.out.println(""No"");\n		else if(str.startsWith(""00"") || str.endsWith(""00""))\n		System.out.println(""No"");\n		else\n		System.out.println(""Yes"");\n	}\n}\n","brute force,constructive algorithms"
"import java.util.Scanner;\n\npublic class Row {\n\n    \n    public static void main(String[] args) {\n        Scanner input=new Scanner(System.in);\n        int n;\n        n=input.nextInt();\n        String x;\n        x=input.next();\n        if(x.contains(""11"") || x.contains(""000"") || x.startsWith(""00"") || x.endsWith(""00"")){\n           System.out.println(""no"");\n        }else if(x.length()==1){\n            if(x.charAt(0)=='0'){\n                 System.out.println(""no"");\n            }else{\n                  System.out.println(""yes"");\n            }\n        }else{\n            System.out.println(""yes"");\n        }\n    }\n    \n}\n","brute force,constructive algorithms"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF967A extends PrintWriter {\n	CF967A() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF967A o = new CF967A(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int s = sc.nextInt();\n		int t = 0;\n		for (int i = 0; i < n; i++) {\n			int h = sc.nextInt();\n			int m = sc.nextInt();\n			int t_ = h * 60 + m;\n			if (t_ - t >= 1 + s)\n				break;\n			t = t_ + 1 + s;\n		}\n		println(t / 60 + "" "" + t % 60);\n	}\n}\n",implementation
"import java.util.*;\n\npublic class Main {\n	public static void main(String ards[])\n	{\n		Scanner cin=new Scanner(System.in);\n        int n = cin.nextInt();\n        int s = cin.nextInt();\n        int[] num=new int[n];\n        for(int i=0;i<n;i++){\n            num[i]=cin.nextInt()*60+cin.nextInt();\n        }\n        if(s+1<=num[0]){\n            System.out.println(""0 0"");\n            return;\n        }\n        for(int i=0;i<n-1;i++){\n            if(num[i+1]-num[i]>=(2*(s+1))){\n                int a=num[i]+s+1;\n                System.out.print(a/60+"" ""+a%60);\n                return;\n            }\n        }\n        System.out.println((num[n-1]+s+1)/60+"" ""+(num[n-1]+s+1)%60);\n\n	}\n}\n\n		 	 		  		  				 	 	 			  		",implementation
"import java.util.*;\npublic class MindTheGap {\n    \n    public static void main(String args[]){\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int s=sc.nextInt();\n        int a[][]=new int[n][2];\n        long b[]=new long[n];\n        for(int i=0;i<n;i++){\n            a[i][0]=sc.nextInt();\n            a[i][1]=sc.nextInt();\n            \n            b[i]=(60*a[i][0])+a[i][1];\n        }\n        long val=-1;\n        boolean flag=false;\n        if(b[0]>=s+1){\n            val=0;\n            flag=true;\n        }\n        if(!flag){\n            for(int i=1;i<n;i++){\n                if((b[i]-b[i-1])>=((2*s)+2)){\n                    val=b[i-1]+s+1;\n                    flag=true;\n                    break;\n                }\n            }\n        }\n        if(!flag)\n            val=b[n-1]+s+1;\n        \n        System.out.println((val/60)+"" ""+(val%60));\n        \n        \n    }\n}\n",implementation
"import java.awt.image.renderable.ContextualRenderedImageFactory;\nimport java.lang.reflect.Array;\n\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.concurrent.LinkedTransferQueue;\n\npublic class codeforces {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int s = sc.nextInt();\n        int[] a = new int[n+1];\n        boolean flag = false;\n        a[n] = 100000;\n        for (int i = 0; i < n; i++) {\n            int h = sc.nextInt();\n            int m = sc.nextInt();\n            a[i] = h*60 + m;\n        }\n\n        if(a[0] >= s + 1){\n            flag = true;\n            System.out.println(0 + "" "" + 0);\n        }\n        if(flag == false) {\n            for (int i = 1; i < n + 1; i++) {\n                if (a[i] - a[i - 1] >= 2 * (s + 1)) {\n                    System.out.println((a[i-1] +  (s + 1)) / 60 + "" "" + (a[i-1] +   (s + 1)) % 60);\n                    flag = true;\n                    break;\n                }\n            }\n        }\n\n\n}}\n\n",implementation
"import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class E {\n\n	static final int[] DX = { -1, 0, 1, 0 };\n	static final int[] DY = { 0, -1, 0, 1 };\n\n	static final int P = 1_000_000_007;\n\n	static final int CACHE_SIZE = 1 << 19;\n	int[] cacheInv = new int[CACHE_SIZE];\n	{\n		cacheInv[1] = 1;\n		for (int i = 2; i < CACHE_SIZE; i++) {\n			cacheInv[i] = P - (int) ((long) (P / i) * cacheInv[P % i] % P);\n		}\n	}\n\n	int inv(int x) {\n		return x < CACHE_SIZE ? cacheInv[x] : P\n				- (int) ((long) (P / x) * inv(P % x) % P);\n	}\n\n	void submit() {\n		// long start = System.currentTimeMillis();\n		int r = nextInt();\n		int[] byDir = new int[4];\n		int sum = 0;\n		for (int i = 0; i < 4; i++) {\n			byDir[i] = nextInt();\n			sum += byDir[i];\n		}\n\n		int invSum = inv(sum);\n\n		for (int i = 0; i < 4; i++) {\n			byDir[i] = (int) ((long) byDir[i] * invSum % P);\n		}\n\n		int s = 2 * r + 3;\n\n		int[][] f = new int[s][s];\n		int[] cx = new int[s * s];\n		int[] cy = new int[s * s];\n		int vars = 0;\n		for (int i = 0; i < s; i++) {\n			for (int j = 0; j < s; j++) {\n				int sum2 = (i - r - 1) * (i - r - 1) + (j - r - 1)\n						* (j - r - 1);\n				if (sum2 <= r * r) {\n					cx[vars] = i;\n					cy[vars] = j;\n					f[i][j] = vars++;\n				} else {\n					f[i][j] = -1;\n				}\n			}\n		}\n\n		int band = 0;\n\n		for (int i = 0; i < vars; i++) {\n			int x0 = cx[i];\n			int y0 = cy[i];\n			for (int dir = 0; dir < 4; dir++) {\n				int x1 = x0 + DX[dir];\n				int y1 = y0 + DY[dir];\n				if (f[x1][y1] == -1) {\n					continue;\n				}\n				int j = f[x1][y1];\n				band = Math.max(band, Math.abs(i - j));\n			}\n		}\n\n		int[][] bandM = new int[vars][2 * band + 1];\n\n		for (int i = 0; i < vars; i++) {\n			int x0 = cx[i];\n			int y0 = cy[i];\n			for (int dir = 0; dir < 4; dir++) {\n				int x1 = x0 + DX[dir];\n				int y1 = y0 + DY[dir];\n				if (f[x1][y1] == -1) {\n					continue;\n				}\n				int j = f[x1][y1];\n\n				updateBandedMatrix(i, j, band, bandM, byDir[dir]);\n\n			}\n		}\n\n		for (int i = 0; i < vars; i++) {\n			for (int d = 0; d <= 2 * band; d++) {\n				int j = i + d - band;\n				bandM[i][d] = (i == j ? 1 : 0) - bandM[i][d];\n				if (bandM[i][d] < 0) {\n					bandM[i][d] += P;\n				}\n			}\n		}\n\n		// out.println(System.currentTimeMillis() - start);\n\n		int[] ans = inverseBanded(bandM, band, f[r + 1][r + 1]);\n\n		// out.println(System.currentTimeMillis() - start);\n\n		int ret = 0;\n		for (int x : ans) {\n			ret += x;\n			if (ret >= P) {\n				ret -= P;\n			}\n		}\n\n		out.println(ret);\n\n	}\n\n	void updateBandedMatrix(int row, int col, int width, int[][] m, double delta) {\n		if (Math.abs(row - col) > width) {\n			throw new AssertionError();\n		}\n		m[row][col - row + width] += delta;\n	}\n\n	int[] inverseBanded(int[][] a, int w, int whatCol) {\n		int n = a.length;\n		if (whatCol > n) {\n			throw new AssertionError();\n		}\n		int[] b = new int[n];\n		b[whatCol] = 1;\n\n		for (int j = 0; j < n; j++) {\n			int[] aj = a[j];\n			for (int i = j + 1; i <= j + w && i < n; i++) {\n				int[] ai = a[i];\n				int coef = (int) ((long) ai[j - i + w] * inv(aj[w]) % P);\n				\n				if (coef == 0) {\n					continue;\n				}\n\n				int kwiUpTo = Math.min(n, j + w + 1) + w - i;\n				\n//				for (int k = j + 1, kwi = (j + 1) + w - i; k < kUpTo; k++, kwi++) {\n				for (int kwi = (j + 1) + w - i; kwi < kwiUpTo; kwi++) {\n					int kek = ai[kwi]\n							- (int) ((long) aj[kwi + i - j] * coef % P);\n					if (kek < 0) {\n						kek += P;\n					}\n					ai[kwi] = kek;\n				}\n				b[i] -= (int) ((long) b[j] * coef % P);\n				if (b[i] < 0) {\n					b[i] += P;\n				}\n			}\n		}\n\n		for (int i = n - 1; i >= 0; i--) {\n			long tot = 0;\n			for (int j = i + 1; j < n && j <= i + w; j++) {\n				tot += (long) b[j] * a[i][j - i + w];\n				if (tot >= P2) {\n					tot -= P2;\n				}\n			}\n			b[i] -= (int) (tot % P);\n			if (b[i] < 0) {\n				b[i] += P;\n			}\n			b[i] = (int) ((long) b[i] * inv(a[i][w]) % P);\n		}\n\n		return b;\n	}\n\n	static final long P2 = (long) P * P;\n\n	void preCalc() {\n\n	}\n\n	void test() {\n\n	}\n\n	void stress() {\n		for (int tst = 0;; tst++) {\n			if (false) {\n				throw new AssertionError();\n			}\n			System.err.println(tst);\n		}\n	}\n\n	E() throws IOException {\n		is = System.in;\n		out = new PrintWriter(System.out);\n		preCalc();\n		submit();\n		// stress();\n		// test();\n		out.close();\n	}\n\n	static final Random rng = new Random();\n	static final int C = 5;\n\n	static int rand(int l, int r) {\n		return l + rng.nextInt(r - l + 1);\n	}\n\n	public static void main(String[] args) throws IOException {\n		new E();\n	}\n\n	private InputStream is;\n	PrintWriter out;\n\n	private byte[] buf = new byte[1 << 14];\n	private int bufSz = 0, bufPtr = 0;\n\n	private int readByte() {\n		if (bufSz == -1)\n			throw new RuntimeException(""Reading past EOF"");\n		if (bufPtr >= bufSz) {\n			bufPtr = 0;\n			try {\n				bufSz = is.read(buf);\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n			if (bufSz <= 0)\n				return -1;\n		}\n		return buf[bufPtr++];\n	}\n\n	private boolean isTrash(int c) {\n		return c < 33 || c > 126;\n	}\n\n	private int skip() {\n		int b;\n		while ((b = readByte()) != -1 && isTrash(b))\n			;\n		return b;\n	}\n\n	String nextToken() {\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b)) {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	String nextString() {\n		int b = readByte();\n		StringBuilder sb = new StringBuilder();\n		while (!isTrash(b) || b == ' ') {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	double nextDouble() {\n		return Double.parseDouble(nextToken());\n	}\n\n	char nextChar() {\n		return (char) skip();\n	}\n\n	int nextInt() {\n		int ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n\n	long nextLong() {\n		long ret = 0;\n		int b = skip();\n		if (b != '-' && (b < '0' || b > '9')) {\n			throw new InputMismatchException();\n		}\n		boolean neg = false;\n		if (b == '-') {\n			neg = true;\n			b = readByte();\n		}\n		while (true) {\n			if (b >= '0' && b <= '9') {\n				ret = ret * 10 + (b - '0');\n			} else {\n				if (b != -1 && !isTrash(b)) {\n					throw new InputMismatchException();\n				}\n				return neg ? -ret : ret;\n			}\n			b = readByte();\n		}\n	}\n}\n",math
import java.util.*;\npublic class bz {\n\n public static void main(String[] args) {\n  Scanner no=new Scanner(System.in);\n  int a=no.nextInt();\n  //long sum=0;\n  long arr[]=new long[a];\n  arr[0]=no.nextLong();\n  for(int i=1;i<a;i++){\n    arr[i]=no.nextLong()+arr[i-1];\n  }\n  long k=(arr[a-1]+1)/2;\n  for(int i=0;i<a;i++){\n    if(arr[i]>=k){\n      System.out.println(i+1);\n      break;\n    }\n  }\n }\n},implementation
import java.util.*;\npublic class bz {\n\n public static void main(String[] args) {\n  Scanner no=new Scanner(System.in);\n  int a=no.nextInt();\n  //long sum=0;\n  long arr[]=new long[a];\n  arr[0]=no.nextLong();\n  for(int i=1;i<a;i++){\n    arr[i]=no.nextLong()+arr[i-1];\n  }\n  long k=(arr[a-1]+1)/2;\n  for(int i=0;i<a;i++){\n    if(arr[i]>=k){\n      System.out.println(i+1);\n      break;\n    }\n  }\n }\n},implementation
"\n\nimport java.util.Scanner;\n\npublic class Equator {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int[] a=new int[n];\n		long sum=0;\n		long ques=0,ind=0;\n		for(int i=0;i<n;i++)\n		{\n			a[i]=sc.nextInt();\n			sum+=a[i];\n		}\n		for(int i=0;i<n;i++)\n		{\n			ques+=a[i];\n			if(ques*2>=sum)\n			{\n				ind=i;\n				break;\n			}\n				\n		}\n		System.out.println(ind+1);\n\n	}\n\n}\n",implementation
import java.util.*;\npublic class Equator\n{\n	public static void main(String[] args) \n	{\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int a[]=new int[n];\n		long sum=0;\n		for(int i=0;i<n;i++)\n		{\n			a[i]=sc.nextInt();\n			sum=sum+a[i];\n		}\n		int temp=0;\n		long sum1=0;\n		for(int i=0;i<n;i++)\n		{\n			sum1=sum1+a[i];\n			if(sum1>=(double)((double)sum/2))\n			{\n				temp=i;\n				break;\n			}\n		}\n		System.out.println(temp+1);\n	}\n}\n,implementation
"// upsolve with rainboy\nimport java.io.*;\n\npublic class CF946E {\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter pw = new PrintWriter(System.out);\n		int t = Integer.parseInt(br.readLine());\n		while (t-- > 0) {\n			char[] cc = br.readLine().toCharArray();\n			int n = cc.length;\n			int parity = 0;\n			for (int i = 0; i < n; i++)\n				parity ^= 1 << cc[i] - '0';\n			int odd = 0;\n			for (int c = 0; c < 10; c++)\n				if ((parity & 1 << c) != 0)\n					odd++;\n			boolean found = false;\nout:\n			for (int j = n - 1; j >= 0; j--) {\n				int c = cc[j] - '0';\n				if (((parity ^= 1 << c) & 1 << c) != 0)\n					odd++;\n				else\n					odd--;\n				for (int c_ = c - 1; c_ >= (j == 0 ? 1 : 0); c_--) {\n					if (((parity ^= 1 << c_) & 1 << c_) != 0)\n						odd++;\n					else\n						odd--;\n					int n9 = n - 1 - j - odd;\n					if (n9 >= 0) {\n						cc[j++] = (char) ('0' + c_);\n						while (n9-- > 0)\n							cc[j++] = '9';\n						for (c = 9; c >= 0; c--)\n							if ((parity & 1 << c) != 0)\n								cc[j++] = (char) ('0' + c);\n						found = true;\n						break out;\n					}\n					if (((parity ^= 1 << c_) & 1 << c_) != 0)\n						odd++;\n					else\n						odd--;\n				}\n			}\n			if (found)\n				pw.println(cc);\n			else {\n				for (int i = 2; i < n; i++)\n					cc[i] = '9';\n				pw.println(new String(cc, 2, n - 2));\n			}\n		}\n		pw.close();\n	}\n}\n","greedy,implementation"
"\n//package codeTrainingLeetcode;\n\nimport java.io.BufferedInputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class C939D2E {\n	static boolean[] odd;\n	static int oddNum;\n\n	private static void addOrDel(int j) {\n		if (odd[j]) {\n			odd[j] = false;\n			oddNum--;\n		} else {\n			odd[j] = true;\n			oddNum++;\n		}\n	}\n\n	public static void main(String[] args) {\n		Scanner in = new Scanner(new BufferedInputStream(System.in));\n		PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n		int t = in.nextInt();\n		for (int i = 0; i < t; i++) {\n			odd = new boolean[10];\n			oddNum = 0;\n			int flag = 0;\n			char[] s = in.next().toCharArray();\n			int len = s.length;\n			char[] st = new char[len];\n			System.arraycopy(s, 0, st, 0, s.length);\n			for (int j = 0; j < len; j++) {\n				int ord = s[j] - '0';\n				addOrDel(ord);\n			}\n\n			for (int j = len - 1; j >= 0; j--) {\n				if (flag == 1)\n					break;\n				int ord = s[j] - '0';\n				addOrDel(ord);\n				int tmp = ord - 1;\n				while (tmp > 0 || (tmp == 0 && j != 0)) {\n					addOrDel(tmp);\n					st[j] = (char) (tmp + '0');\n					int rem = (len - j - 1);\n					if (oddNum <= rem) {\n						if ((rem - oddNum) % 2 == 0) {\n							for (int k = 1; k <= rem - oddNum; k++)\n								st[j + k] = '9';\n							for (int k = j + rem - oddNum + 1; k < len; k++) {\n								int n = 9;\n								for (int l = 9; l >= 0; l--)\n									if (odd[l]) {\n										n = l;\n										addOrDel(l);\n										break;\n									}\n								st[k] = (char) (n + '0');\n							}\n							out.println(st);\n							flag = 1;\n							break;\n						}\n					}\n					addOrDel(tmp);\n					tmp--;\n				}\n			}\n			if (flag == 0) {\n				for (int j = 0; j < len - 2; j++)\n					out.print('9');\n				out.println();\n			}\n			continue;\n		}\n		out.close();\n	}\n}\n","greedy,implementation"
import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class E {\n	static String s;\n	static boolean odd[];\n	static int ps[];\n	public static void main(String[] args){\n		Scanner sc = new Scanner(System.in);\n				\n		int T = sc.nextInt();\n		\n		while(T-->0){\n			StringBuilder ans = new StringBuilder();\n			\n			s = sc.next();\n			odd = new boolean[10];\n			ps = new int[s.length()+1];\n			for(int i=0;i<s.length();i++){\n				ps[i+1] = ps[i] + (s.charAt(i) > '0'? 1: 0);\n			}\n			\n			if(s.charAt(0)=='1' && ps[s.length()]==1){\n				for(int i=0;i<s.length()-2;i++)	ans.append('9');\n				System.out.println(ans);\n				continue;\n			}\n			\n			if(s.charAt(0)=='1' && s.charAt(s.length()-1)=='1' && ps[s.length()]==2){\n				for(int i=0;i<s.length()-2;i++)	ans.append('9');\n				System.out.println(ans);\n				continue;\n			}\n			\n			loop:\n			for(int i=0;i<s.length();i++){\n				int n = s.charAt(i)-'0';\n				odd[n] ^= true;\n				\n				if(!check(i+1)){\n					odd[n] ^= true;\n					for(int j = n-1;j>=0;j--){\n						odd[j] ^= true;\n						\n						if(fit(i+1)){\n							ans.append(j);\n							int cnt=cntodd();\n							\n							for(int k=i+1;k+cnt<s.length();k++){\n								ans.append(9);\n							}\n							\n							for(int k=9;k>=0;k--){\n								if(odd[k])	ans.append(k);\n							}\n							break loop;\n						}\n						\n						odd[j] ^= true;\n					}\n					\n				}\n				\n				ans.append(n);\n			}\n			System.out.println(ans);\n		}\n	}\n	static boolean fit(int i) {\n		int cnt = cntodd();\n		return s.length()-i >= cnt;\n			\n	}\n	static boolean check(int i) {\n		int cnt = cntodd();\n		\n		if(i + cnt > s.length())\n			return	false;\n		if(ps[s.length()-cnt] - ps[i] > 0)\n			return true;\n		\n		int n =0;\n		for(int j = s.length()-cnt;j<s.length();j++){\n			while(!odd[n])	n++;\n\n			if(s.charAt(j)-'0'>n)\n				return true;\n			if(s.charAt(j)-'0'<n)\n				return false;\n			n++;\n		}\n		return false;\n	}\n	static int cntodd() {\n		int cnt=0;\n		for(boolean b : odd)\n			if(b) cnt++;\n		return cnt;\n	}\n}\n,"greedy,implementation"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class TimeTable {\n	static char []s;\n	static int []z;\npublic static boolean isPossible(int []f,int x,int len,boolean less)\n{\n	\n	if(x>s[len-1]-'0' && !less)\n		return false;\n	if(x<s[len-1]-'0')\n		less=true;\n	int odd=0;\n	for(int y:f)\n		if(y==1)\n			odd++;\n	int rem=s.length-len;\n	int zeroes=rem-odd;\n	if(zeroes<0 || zeroes%2==1)\n		return false;\n	\n	\n	int cnt=z[len+zeroes-1]-z[len-1];\n	\n	if(cnt<zeroes)\n		return true;\n	if(less)\n		return true;\n	int i=len+zeroes;\n	int curr=0;\n	while(i<s.length)\n	{\n		if(f[curr]==0)\n			curr++;\n		else if(curr<s[i]-'0')\n		{\n			return true;\n		}\n		else if(curr==s[i]-'0')\n		{\n			curr++;\n			i++;\n		}\n		else\n			return false;\n	}\n	return less;\n	\n	\n}\n	public static void main(String[] args) throws IOException {\n		Scanner sc=new Scanner(System.in);\n		int tc=sc.nextInt();\n		StringBuilder sb=new StringBuilder();\n		while(tc-->0)\n		{\n			s=sc.nextLine().toCharArray();\n			int n=s.length;\n			z=new int[n];\n			for(int i=0;i<n;i++)\n			{\n				if(s[i]=='0')\n					z[i]++;\n				if(i!=0)\n					z[i]+=z[i-1];\n			}\n			int[]f=new int [10];\n			boolean less=false;\n			\n			for(int i=0;i<n;i++)\n			{\n				\n				for(int x=9;x>=0;x--)\n				{\n					\n					f[x]=1-f[x];\n					if(isPossible(f,x,i+1,less))\n					{\n						if(i==0 && x==0)\n						{\n							\n							f[0]=0;\n							less=true;\n							\n							break;\n						}\n							sb.append(x);\n						\n						\n						if(x<s[i]-'0')\n							less=true;\n						\n						break;\n					}\n					\n					\n					f[x]=1-f[x];\n					\n				}\n			}\n			sb.append(""\n"");\n		}\n		System.out.print(sb);	\n		\n		\n	}\n	static class Scanner \n	{\n		StringTokenizer st;\n		BufferedReader br;\n\n		public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}\n\n		public String next() throws IOException \n		{\n			while (st == null || !st.hasMoreTokens()) \n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		public int nextInt() throws IOException {return Integer.parseInt(next());}\n		\n		public long nextLong() throws IOException {return Long.parseLong(next());}\n\n		public String nextLine() throws IOException {return br.readLine();}\n		\n		public double nextDouble() throws IOException\n		{\n			return Double.parseDouble(next());\n		}\n		\n		public boolean ready() throws IOException {return br.ready();}\n\n\n	}\n}\n","greedy,implementation"
"import java.util.*;\n\npublic class P930B {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		String line = sc.nextLine();\n		sc.close();\n		char[] s = line.toCharArray();\n		int[][] a = new int[26][5005];\n		int[][][] arr = new int[26][26][5005];\n		double ans = 0;\n		for (int i = 0; i < s.length; i++)\n			for (int j = 0; j < s.length; j++)\n				if (i != j)\n					arr[s[i] - 'a'][s[j] - 'a'][(j - i + s.length) % s.length]++;\n		for (int i = 0; i < s.length; i++)\n			for (int j = 0; j < s.length; j++)\n				if (arr[s[i] - 'a'][s[j] - 'a'][(j - i + s.length) % s.length] == 1)\n					a[s[i] - 'a'][(j - i + s.length) % s.length]++;\n		for (int i = 0; i < 26; i++) {\n			int tmp = 0;\n			for (int j = 1; j < s.length; j++)\n				tmp = Math.max(tmp, a[i][j]);\n			ans += tmp;\n		}\n		System.out.println((double) ans / s.length);\n	}\n}\n","implementation,probabilities,strings"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF931E extends PrintWriter {\n	CF931E() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF931E o = new CF931E(); o.main(); o.flush();\n	}\n\n	static final int A = 26;\n	void main() {\n		byte[] cc = sc.next().getBytes();\n		int n = cc.length;\n		int[][][] kk = new int[A][n][A];\n		int[] k1 = new int[A];\n		for (int i = 0; i < n; i++) {\n			int a = cc[i] - 'a';\n			k1[a]++;\n			for (int d = 1; d < n; d++) {\n				int j = (i + d) % n;\n				int b = cc[j] - 'a';\n				kk[a][d][b]++;\n			}\n		}\n		double p = 0;\n		for (int a = 0; a < A; a++) {\n			if (k1[a] == 0)\n				continue;\n			int u_ = 0, v_ = 1;\n			for (int d = 1; d < n; d++) {\n				int u = 0, v = 0;\n				for (int b = 0; b < A; b++) {\n					int k = kk[a][d][b];\n					if (k == 1)\n						u++;\n					v += k;\n				}\n				if (u_ * v  < u * v_) {\n					u_ = u; v_ = v;\n				}\n			}\n			p += (double) k1[a] / n * u_ / v_;\n		}\n		println(p);\n	}\n}\n","implementation,probabilities,strings"
"//package Codeforces;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class GameWithString {\n    static double getWinProb(String s, int letter){\n        ArrayList<Integer> indices = new ArrayList<>();\n\n        int n = s.length();\n        for(int i=0;i<n;i++){\n            if(s.charAt(i)-'a'==letter){\n                indices.add(i);\n            }\n        }\n\n        if(indices.size()<=1)\n            return 1.0;\n\n        for(int i=1;i<n-1;i++){\n            int[] hash = new int[26];\n            for(int j: indices){\n                hash[s.charAt((i+j)%n)-'a']++;\n            }\n\n            boolean sure_success = true;\n            for(int j: hash){\n                if(j>1){\n                    sure_success = false;\n                    break;\n                }\n            }\n            if(sure_success){\n                return 1.0;\n            }\n        }\n\n        double maxProb = 0.0;\n        for(int i=1;i<=n-1;i++){\n            int[] hash = new int[26];\n            for(int j: indices){\n                hash[s.charAt((i+j)%n)-'a']++;\n            }\n\n            double curprob = 0.0;\n            for(int j=0;j<26;j++){\n                if(hash[j]==1){\n                    curprob += (1.0 / indices.size());\n                }\n            }\n\n            maxProb = Math.max(maxProb , curprob);\n        }\n\n        return maxProb;\n    }\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n\n        String s = sc.next();\n        int n = s.length();\n\n        int[] hash1 = new int[26];\n        for(int i=0;i<n;i++){\n            hash1[s.charAt(i)-'a']++;\n        }\n\n        double prob = 0;\n        for(int i=0;i<26;i++){\n            prob += getWinProb(s, i) * (((double) hash1[i]) / n);\n        }\n\n        System.out.println(prob);\n\n        sc.close();\n    }\n}\n","implementation,probabilities,strings"
"import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class B {\n	public static void main(String[] args) throws IOException {\n\n		/**/\n		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n		/*/\n		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(""src/b.in""))));\n		/**/\n		\n		String s = sc.next();\n		int n = s.length();\n		int[] sarr = new int[n*2];\n		for (int i = 0; i < n; i++) {\n			sarr[i] = s.charAt(i)-'a';\n			sarr[n+i] = sarr[i];\n		}\n		int[][][] dp = new int[26][n][26];\n		for (int i = 0; i < n; ++i) {\n			int c = sarr[i];\n			for (int j = 0; j < n; ++j) {\n				++dp[c][j][sarr[i+j]];\n			}\n		}\n		int ans = 0;\n		for (int i = 0; i < 26; ++i) {\n			int max = 0;\n			for (int j = 0; j < n; ++j) {\n				int curr = 0;\n				for (int k = 0; k < 26; ++k) {\n					if (dp[i][j][k]==1)\n						++curr;\n				}\n				if (curr > max)\n					max = curr;\n			}\n			ans += max;\n		}\n		System.out.println(ans/(double)n);\n	}\n}","implementation,probabilities,strings"
"import java.util.Scanner;\n\npublic class Test {\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int n=scan.nextInt(), k=scan.nextInt(), a[]=new int[n];\n\n		for (int i=0; i<n; i++)\n			a[i] = scan.nextInt();\n\n		int count=0;\n		for (int i=0; i<n-1; i++) {\n			if (a[i+1]-a[i]>k) {\n				System.out.print(-1);\n				System.exit(0);\n			}\n			else{\n				int ind = i;\n				while (ind!=n-1 && a[ind+1]-a[i]<=k) {\n					ind++;\n				}\n				i = ind-1;\n				count++;\n			}\n		}\n\n		System.out.print(count);\n	}\n}\n","*special,greedy,implementation"
"import java.util.Scanner;\n\npublic class A2 {\n\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int n = in.nextInt();\n		int k = in.nextInt();\n		int[] a = new int[n];\n		for (int i = 0; i < n; i++) {\n			a[i] = in.nextInt();\n		}\n		int count = 0;\n\n		for (int i = 0; i < n;) {\n			int j = i + 1;\n			count++;\n			for (; j < n; j++) {\n				if (a[j] - a[i] > k) {\n					j--;\n					break;\n				}\n			}\n			\n			if (i == j) {\n				System.out.println(""-1"");\n				return;\n			}\n			i = j;\n		}\n\n		System.out.println(count);\n\n	}\n\n}\n","*special,greedy,implementation"
"\n\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n		Scanner num = new Scanner(System.in);\n		int count = num.nextInt();\n		int len = num.nextInt();\n		int id = 0, result = 0;\n\n		int [] a = new int[count];\n		for(int i = 0; i < count; i++){\n			a[i] = num.nextInt();\n		}\n\n\n		while (id < count - 1){\n			int max = a[id] + len;\n			if(max < a[id + 1]){\n				result = -1;\n				break;\n			}\n\n			id++;\n			while (a[id] <= max){\n				id++;\n				if(id == count){\n					break;\n				}\n			}\n			id--;\n			result++;\n		}\n		System.out.println(result);\n\n\n\n\n    }\n}","*special,greedy,implementation"
"import java.util.Scanner;\n\npublic class Main {\n\n	public static void main(String[] args) {\n		Scanner scanner = new Scanner(System.in);\n		int n, k;\n		n = scanner.nextInt();\n		k = scanner.nextInt();\n		int[] x = new int[n];\n\n		for (int i = 0; i < n; i++) {\n			x[i] = scanner.nextInt();\n		}\n\n		int count = 0, last = 0;\n\n		for (int i = 0; i < n - 1;) {\n			if (x[i + 1] - x[i] > k) {\n				System.out.println(-1);\n				return;\n			}\n			int j = i + 1;\n			while (j < n && x[j] - x[i] <= k) {\n				j++;\n			}\n			j--;\n			count++;\n			last = x[j];\n			// System.out.println(x[j]);\n			i = j;\n		}\n\n		System.out.println(count);\n	}\n}\n","*special,greedy,implementation"
"//package round470;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class E2 {\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n	\n	int[][] fif = enumFIF(300000, mod);\n	\n	long[] foo(long[] a, int Q)\n	{\n		long[] aa = Arrays.copyOf(a, a.length);\n		long[] b = new long[a.length];\n		long u = 1;\n		for(int i = 0;i < a.length;i++){\n			aa[i] = aa[i] * fif[0][i] % mod;\n			b[i] = fif[1][a.length-1-i];\n		}\n		for(int i = 0;i < a.length;i++){\n			b[a.length-1-i] = b[a.length-1-i] * u % mod;\n//			aa[i] = aa[i] * u % mod;\n			u = u * Q % mod;\n		}\n		long[] c = convoluteSimply(aa, b, mod, 3);\n		long[] ret = new long[a.length];\n		for(int i = 0;i < a.length;i++){\n			ret[i] = c[i+a.length-1] * fif[1][i] % mod;\n		}\n		return ret;\n	}\n	\n	void solve()\n	{\n		int n = ni()+1;\n		long M = nl();\n		int mod = 998244353;\n		long[] a = new long[n];\n		for(int i = 0;i < n;i++)a[i] = nl();\n		\n		long[] b = reverse(foo(a, 1));\n		for(int i = 0;i < n;i++){\n			b[i] = b[i] * pow(invl(n-i, mod), M, mod) % mod;\n		}\n		\n		long[] ans = foo(reverse(b), mod-1);\n		for(long v : ans){\n			out.print(v + "" "");\n		}\n	}\n	\n	public static int mod = 998244353;\n	public static int G = 3;\n	\n	public static long[] reverse(long[] p)\n	{\n		long[] ret = new long[p.length];\n		for(int i = 0;i < p.length;i++){\n			ret[i] = p[p.length-1-i];\n		}\n		return ret;\n	}\n	\n	public static long[] reverse(long[] p, int lim)\n	{\n		long[] ret = new long[lim];\n		for(int i = 0;i < lim && i < p.length;i++){\n			ret[i] = p[p.length-1-i];\n		}\n		return ret;\n	}\n	\n	public static int[][] enumFIF(int n, int mod) {\n		int[] f = new int[n + 1];\n		int[] invf = new int[n + 1];\n		f[0] = 1;\n		for (int i = 1; i <= n; i++) {\n			f[i] = (int) ((long) f[i - 1] * i % mod);\n		}\n		long a = f[n];\n		long b = mod;\n		long p = 1, q = 0;\n		while (b > 0) {\n			long c = a / b;\n			long d;\n			d = a;\n			a = b;\n			b = d % b;\n			d = p;\n			p = q;\n			q = d - c * q;\n		}\n		invf[n] = (int) (p < 0 ? p + mod : p);\n		for (int i = n - 1; i >= 0; i--) {\n			invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n		}\n		return new int[][] { f, invf };\n	}\n	\n	public static final int[] NTTPrimes = {1053818881, 1051721729, 1045430273, 1012924417, 1007681537, 1004535809, 998244353, 985661441, 976224257, 975175681};\n	public static final int[] NTTPrimitiveRoots = {7, 6, 3, 5, 3, 3, 3, 3, 3, 17};\n//	public static final int[] NTTPrimes = {1012924417, 1004535809, 998244353, 985661441, 975175681, 962592769, 950009857, 943718401, 935329793, 924844033};\n//	public static final int[] NTTPrimitiveRoots = {5, 3, 3, 3, 17, 7, 7, 7, 3, 5};\n	\n	public static long[] convoluteSimply(long[] a, long[] b, int P, int g)\n	{\n		int m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n		long[] fa = nttmb(a, m, false, P, g);\n		long[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n		for(int i = 0;i < m;i++){\n			fa[i] = fa[i]*fb[i]%P;\n		}\n		return nttmb(fa, m, true, P, g);\n	}\n	\n	public static long[] convolute(long[] a, long[] b)\n	{\n		int USE = 2;\n		int m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n		long[][] fs = new long[USE][];\n		for(int k = 0;k < USE;k++){\n			int P = NTTPrimes[k], g = NTTPrimitiveRoots[k];\n			long[] fa = nttmb(a, m, false, P, g);\n			long[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n			for(int i = 0;i < m;i++){\n				fa[i] = fa[i]*fb[i]%P;\n			}\n			fs[k] = nttmb(fa, m, true, P, g);\n		}\n		\n		int[] mods = Arrays.copyOf(NTTPrimes, USE);\n		long[] gammas = garnerPrepare(mods);\n		int[] buf = new int[USE];\n		for(int i = 0;i < fs[0].length;i++){\n			for(int j = 0;j < USE;j++)buf[j] = (int)fs[j][i];\n			long[] res = garnerBatch(buf, mods, gammas);\n			long ret = 0;\n			for(int j = res.length-1;j >= 0;j--)ret = ret * mods[j] + res[j];\n			fs[0][i] = ret;\n		}\n		return fs[0];\n	}\n	\n	public static long[] convolute(long[] a, long[] b, int USE, int mod)\n	{\n		int m = Math.max(2, Integer.highestOneBit(Math.max(a.length, b.length)-1)<<2);\n		long[][] fs = new long[USE][];\n		for(int k = 0;k < USE;k++){\n			int P = NTTPrimes[k], g = NTTPrimitiveRoots[k];\n			long[] fa = nttmb(a, m, false, P, g);\n			long[] fb = a == b ? fa : nttmb(b, m, false, P, g);\n			for(int i = 0;i < m;i++){\n				fa[i] = fa[i]*fb[i]%P;\n			}\n			fs[k] = nttmb(fa, m, true, P, g);\n		}\n		\n		int[] mods = Arrays.copyOf(NTTPrimes, USE);\n		long[] gammas = garnerPrepare(mods);\n		int[] buf = new int[USE];\n		for(int i = 0;i < fs[0].length;i++){\n			for(int j = 0;j < USE;j++)buf[j] = (int)fs[j][i];\n			long[] res = garnerBatch(buf, mods, gammas);\n			long ret = 0;\n			for(int j = res.length-1;j >= 0;j--)ret = (ret * mods[j] + res[j]) % mod;\n			fs[0][i] = ret;\n		}\n		return fs[0];\n	}\n	\n	// static int[] wws = new int[270000]; // outer faster\n	\n	// Modifed Montgomery + Barrett\n	private static long[] nttmb(long[] src, int n, boolean inverse, int P, int g)\n	{\n		long[] dst = Arrays.copyOf(src, n);\n		\n		int h = Integer.numberOfTrailingZeros(n);\n		long K = Integer.highestOneBit(P)<<1;\n		int H = Long.numberOfTrailingZeros(K)*2;\n		long M = K*K/P;\n		\n		int[] wws = new int[1<<h-1];\n		long dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);\n		long w = (1L<<32)%P;\n		for(int k = 0;k < 1<<h-1;k++){\n			wws[k] = (int)w;\n			w = modh(w*dw, M, H, P);\n		}\n		long J = invl(P, 1L<<32);\n		for(int i = 0;i < h;i++){\n			for(int j = 0;j < 1<<i;j++){\n				for(int k = 0, s = j<<h-i, t = s|1<<h-i-1;k < 1<<h-i-1;k++,s++,t++){\n					long u = (dst[s] - dst[t] + 2*P)*wws[k];\n					dst[s] += dst[t];\n					if(dst[s] >= 2*P)dst[s] -= 2*P;\n//					long Q = (u&(1L<<32)-1)*J&(1L<<32)-1;\n					long Q = (u<<32)*J>>>32;\n					dst[t] = (u>>>32)-(Q*P>>>32)+P;\n				}\n			}\n			if(i < h-1){\n				for(int k = 0;k < 1<<h-i-2;k++)wws[k] = wws[k*2];\n			}\n		}\n		for(int i = 0;i < n;i++){\n			if(dst[i] >= P)dst[i] -= P;\n		}\n		for(int i = 0;i < n;i++){\n			int rev = Integer.reverse(i)>>>-h;\n			if(i < rev){\n				long d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;\n			}\n		}\n		\n		if(inverse){\n			long in = invl(n, P);\n			for(int i = 0;i < n;i++)dst[i] = modh(dst[i]*in, M, H, P);\n		}\n		\n		return dst;\n	}\n	\n	// Modified Shoup + Barrett\n	private static long[] nttsb(long[] src, int n, boolean inverse, int P, int g)\n	{\n		long[] dst = Arrays.copyOf(src, n);\n		\n		int h = Integer.numberOfTrailingZeros(n);\n		long K = Integer.highestOneBit(P)<<1;\n		int H = Long.numberOfTrailingZeros(K)*2;\n		long M = K*K/P;\n		\n		long dw = inverse ? pow(g, P-1-(P-1)/n, P) : pow(g, (P-1)/n, P);\n		long[] wws = new long[1<<h-1];\n		long[] ws = new long[1<<h-1];\n		long w = 1;\n		for(int k = 0;k < 1<<h-1;k++){\n			wws[k] = (w<<32)/P;\n			ws[k] = w;\n			w = modh(w*dw, M, H, P);\n		}\n		for(int i = 0;i < h;i++){\n			for(int j = 0;j < 1<<i;j++){\n				for(int k = 0, s = j<<h-i, t = s|1<<h-i-1;k < 1<<h-i-1;k++,s++,t++){\n					long ndsts = dst[s] + dst[t];\n					if(ndsts >= 2*P)ndsts -= 2*P;\n					long T = dst[s] - dst[t] + 2*P;\n					long Q = wws[k]*T>>>32;\n					dst[s] = ndsts;\n					dst[t] = ws[k]*T-Q*P&(1L<<32)-1;\n				}\n			}\n//			dw = dw * dw % P;\n			if(i < h-1){\n				for(int k = 0;k < 1<<h-i-2;k++){\n					wws[k] = wws[k*2];\n					ws[k] = ws[k*2];\n				}\n			}\n		}\n		for(int i = 0;i < n;i++){\n			if(dst[i] >= P)dst[i] -= P;\n		}\n		for(int i = 0;i < n;i++){\n			int rev = Integer.reverse(i)>>>-h;\n			if(i < rev){\n				long d = dst[i]; dst[i] = dst[rev]; dst[rev] = d;\n			}\n		}\n		\n		if(inverse){\n			long in = invl(n, P);\n			for(int i = 0;i < n;i++){\n				dst[i] = modh(dst[i] * in, M, H, P);\n			}\n		}\n		\n		return dst;\n	}\n	\n	static final long mask = (1L<<31)-1;\n	\n	public static long modh(long a, long M, int h, int mod)\n	{\n		long r = a-((M*(a&mask)>>>31)+M*(a>>>31)>>>h-31)*mod;\n		return r < mod ? r : r-mod;\n	}\n	\n	private static long[] garnerPrepare(int[] m)\n	{\n		int n = m.length;\n		assert n == m.length;\n		if(n == 0)return new long[0];\n		long[] gamma = new long[n];\n		for(int k = 1;k < n;k++){\n			long prod = 1;\n			for(int i = 0;i < k;i++){\n				prod = prod * m[i] % m[k];\n			}\n			gamma[k] = invl(prod, m[k]);\n		}\n		return gamma;\n	}\n	\n	private static long[] garnerBatch(int[] u, int[] m, long[] gamma)\n	{\n		int n = u.length;\n		assert n == m.length;\n		long[] v = new long[n];\n		v[0] = u[0];\n		for(int k = 1;k < n;k++){\n			long temp = v[k-1];\n			for(int j = k-2;j >= 0;j--){\n				temp = (temp * m[j] + v[j]) % m[k];\n			}\n			v[k] = (u[k] - temp) * gamma[k] % m[k];\n			if(v[k] < 0)v[k] += m[k];\n		}\n		return v;\n	}\n	\n	private static long pow(long a, long n, long mod) {\n		//		a %= mod;\n		long ret = 1;\n		int x = 63 - Long.numberOfLeadingZeros(n);\n		for (; x >= 0; x--) {\n			ret = ret * ret % mod;\n			if (n << 63 - x < 0)\n				ret = ret * a % mod;\n		}\n		return ret;\n	}\n	\n	private static long invl(long a, long mod) {\n		long b = mod;\n		long p = 1, q = 0;\n		while (b > 0) {\n			long c = a / b;\n			long d;\n			d = a;\n			a = b;\n			b = d % b;\n			d = p;\n			p = q;\n			q = d - c * q;\n		}\n		return p < 0 ? p + mod : p;\n	}\n\n	\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new E2().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	public int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n	\n	private char[][] nm(int n, int m)\n	{\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n	\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n	\n	private int ni()\n	{\n		int num = 0, b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","fft,math,matrices"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.function.Supplier;\nimport java.io.OutputStreamWriter;\nimport java.math.BigInteger;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Collection;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.function.Consumer;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            EPerpetualSubtraction solver = new EPerpetualSubtraction();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class EPerpetualSubtraction {\n        int mod = 998244353;\n        Modular modular = new Modular(mod);\n        Power pow = new Power(modular);\n        Debug debug = new Debug(true);\n        NumberTheoryTransform ntt = new NumberTheoryTransform(mod);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            long m = in.readLong();\n\n            int[] p = new int[n + 1];\n            in.populate(p);\n\n            Factorial factorial = new Factorial(n + 1, mod);\n            int[] p0 = p;\n            int[] p1 = new int[n + 1];\n            int[] p2 = new int[n + 1];\n            int[] p3 = new int[n + 1];\n\n            {\n                IntegerArrayList a = Polynomials.listBuffer.alloc();\n                IntegerArrayList b = Polynomials.listBuffer.alloc();\n                IntegerArrayList c = Polynomials.listBuffer.alloc();\n                a.expandWith(0, n + 1);\n                b.expandWith(0, n + 1);\n\n                for (int i = 0; i <= n; i++) {\n                    a.set(i, (int) ((long) factorial.fact(i) * p0[i] % mod));\n                    b.set(i, factorial.invFact(i));\n                }\n\n                ntt.deltaNTT(a, b, c);\n                c.expandWith(0, n + 1);\n                for (int i = 0; i <= n; i++) {\n                    p1[i] = (int) ((long) c.get(i) * factorial.invFact(i) % mod);\n                }\n\n                Polynomials.listBuffer.release(a);\n                Polynomials.listBuffer.release(b);\n                Polynomials.listBuffer.release(c);\n            }\n\n            for (int i = 0; i <= n; i++) {\n                p2[i] = (int) ((long) pow.inversePower(i + 1, m) * p1[i] % mod);\n            }\n\n            {\n                IntegerArrayList a = Polynomials.listBuffer.alloc();\n                IntegerArrayList b = Polynomials.listBuffer.alloc();\n                IntegerArrayList c = Polynomials.listBuffer.alloc();\n                a.expandWith(0, n + 1);\n                b.expandWith(0, n + 1);\n\n                for (int i = 0; i <= n; i++) {\n                    a.set(i, (int) ((long) factorial.fact(i) * p2[i] % mod));\n                    b.set(i, DigitUtils.mod((i % 2 == 0 ? 1 : -1) * factorial.invFact(i), mod));\n                }\n\n                ntt.deltaNTT(a, b, c);\n                c.expandWith(0, n + 1);\n                for (int i = 0; i <= n; i++) {\n                    p3[i] = (int) ((long) c.get(i) * factorial.invFact(i) % mod);\n                }\n\n                Polynomials.listBuffer.release(a);\n                Polynomials.listBuffer.release(b);\n                Polynomials.listBuffer.release(c);\n            }\n\n            for (int i = 0; i <= n; i++) {\n                out.println(p3[i]);\n            }\n\n            debug.debug(""p0"", p0);\n            debug.debug(""p1"", p1);\n            debug.debug(""p2"", p2);\n            debug.debug(""p3"", p3);\n        }\n\n    }\n\n    static class Factorial {\n        int[] fact;\n        int[] inv;\n        int mod;\n\n        public Factorial(int[] fact, int[] inv, int mod) {\n            this.mod = mod;\n            this.fact = fact;\n            this.inv = inv;\n            fact[0] = inv[0] = 1;\n            int n = Math.min(fact.length, mod);\n            for (int i = 1; i < n; i++) {\n                fact[i] = i;\n                fact[i] = (int) ((long) fact[i] * fact[i - 1] % mod);\n            }\n            inv[n - 1] = BigInteger.valueOf(fact[n - 1]).modInverse(BigInteger.valueOf(mod)).intValue();\n            for (int i = n - 2; i >= 1; i--) {\n                inv[i] = (int) ((long) inv[i + 1] * (i + 1) % mod);\n            }\n        }\n\n        public Factorial(int limit, int mod) {\n            this(new int[limit + 1], new int[limit + 1], mod);\n        }\n\n        public int fact(int n) {\n            return fact[n];\n        }\n\n        public int invFact(int n) {\n            return inv[n];\n        }\n\n    }\n\n    static class Buffer<T> {\n        private Deque<T> deque;\n        private Supplier<T> supplier;\n        private Consumer<T> cleaner;\n        private int allocTime;\n        private int releaseTime;\n\n        public Buffer(Supplier<T> supplier) {\n            this(supplier, (x) -> {\n            });\n        }\n\n        public Buffer(Supplier<T> supplier, Consumer<T> cleaner) {\n            this(supplier, cleaner, 0);\n        }\n\n        public Buffer(Supplier<T> supplier, Consumer<T> cleaner, int exp) {\n            this.supplier = supplier;\n            this.cleaner = cleaner;\n            deque = new ArrayDeque<>(exp);\n        }\n\n        public T alloc() {\n            allocTime++;\n            return deque.isEmpty() ? supplier.get() : deque.removeFirst();\n        }\n\n        public void release(T e) {\n            releaseTime++;\n            cleaner.accept(e);\n            deque.addLast(e);\n        }\n\n    }\n\n    static class Power implements InverseNumber {\n        final Modular modular;\n        int modVal;\n\n        public Power(Modular modular) {\n            this.modular = modular;\n            this.modVal = modular.getMod();\n        }\n\n        public Power(int mod) {\n            this(new Modular(mod));\n        }\n\n        public int pow(int x, long n) {\n            if (n == 0) {\n                return modular.valueOf(1);\n            }\n            long r = pow(x, n >> 1);\n            r = r * r % modVal;\n            if ((n & 1) == 1) {\n                r = r * x % modVal;\n            }\n            return (int) r;\n        }\n\n        public int pow(int x, int n) {\n            if (n == 0) {\n                return modular.valueOf(1);\n            }\n            long r = pow(x, n >> 1);\n            r = r * r % modVal;\n            if ((n & 1) == 1) {\n                r = r * x % modVal;\n            }\n            return (int) r;\n        }\n\n        public int inverseByFermat(int x) {\n            return pow(x, modVal - 2);\n        }\n\n        public int inversePower(int x, long n) {\n            n = DigitUtils.mod(-n, modVal - 1);\n            return pow(x, n);\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static void swap(int[] data, int i, int j) {\n            int tmp = data[i];\n            data[i] = data[j];\n            data[j] = tmp;\n        }\n\n        public static void reverse(int[] data, int l, int r) {\n            while (l < r) {\n                swap(data, l, r);\n                l++;\n                r--;\n            }\n        }\n\n        public static boolean equal(int[] a, int al, int ar, int[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n        static int[] empty = new int[0];\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public Debug debug(String name, Object x) {\n            return debug(name, x, empty);\n        }\n\n        public Debug debug(String name, Object x, int... indexes) {\n            if (offline) {\n                if (x == null || !x.getClass().isArray()) {\n                    out.append(name);\n                    for (int i : indexes) {\n                        out.printf(""[%d]"", i);\n                    }\n                    out.append(""="").append("""" + x);\n                    out.println();\n                } else {\n                    indexes = Arrays.copyOf(indexes, indexes.length + 1);\n                    if (x instanceof byte[]) {\n                        byte[] arr = (byte[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof short[]) {\n                        short[] arr = (short[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof boolean[]) {\n                        boolean[] arr = (boolean[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof char[]) {\n                        char[] arr = (char[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof int[]) {\n                        int[] arr = (int[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof float[]) {\n                        float[] arr = (float[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof double[]) {\n                        double[] arr = (double[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof long[]) {\n                        long[] arr = (long[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else {\n                        Object[] arr = (Object[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    }\n                }\n            }\n            return this;\n        }\n\n    }\n\n    static class Factorization {\n        public static IntegerArrayList factorizeNumberPrime(int x) {\n            IntegerArrayList ans = new IntegerArrayList();\n            for (int i = 2; i * i <= x; i++) {\n                if (x % i != 0) {\n                    continue;\n                }\n                ans.add(i);\n                while (x % i == 0) {\n                    x /= i;\n                }\n            }\n            if (x > 1) {\n                ans.add(x);\n            }\n            return ans;\n        }\n\n    }\n\n    static interface InverseNumber {\n    }\n\n    static class PrimitiveRoot {\n        private int[] factors;\n        private int mod;\n        private Power pow;\n        int phi;\n\n        public PrimitiveRoot(int x) {\n            phi = x - 1;\n            mod = x;\n            pow = new Power(mod);\n            factors = Factorization.factorizeNumberPrime(phi).toArray();\n        }\n\n        public int findMinPrimitiveRoot() {\n            if (mod == 2) {\n                return 1;\n            }\n            return findMinPrimitiveRoot(2);\n        }\n\n        private int findMinPrimitiveRoot(int since) {\n            for (int i = since; i < mod; i++) {\n                boolean flag = true;\n                for (int f : factors) {\n                    if (pow.pow(i, phi / f) == 1) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static int mod(long x, int mod) {\n            x %= mod;\n            if (x < 0) {\n                x += mod;\n            }\n            return (int) x;\n        }\n\n        public static int mod(int x, int mod) {\n            x %= mod;\n            if (x < 0) {\n                x += mod;\n            }\n            return x;\n        }\n\n        public static int modsub(int a, int b, int mod) {\n            int ans = a - b;\n            if (ans < 0) {\n                ans += mod;\n            }\n            return ans;\n        }\n\n        public static int modplus(int a, int b, int mod) {\n            int ans = a + b;\n            if (ans >= mod) {\n                ans -= mod;\n            }\n            return ans;\n        }\n\n    }\n\n    static class Log2 {\n        public static int ceilLog(int x) {\n            return 32 - Integer.numberOfLeadingZeros(x - 1);\n        }\n\n    }\n\n    static class Polynomials {\n        public static Buffer<IntegerArrayList> listBuffer = new Buffer<>(IntegerArrayList::new, list -> list.clear());\n\n        public static int rankOf(IntegerArrayList p) {\n            int[] data = p.getData();\n            int r = p.size() - 1;\n            while (r >= 0 && data[r] == 0) {\n                r--;\n            }\n            return Math.max(0, r);\n        }\n\n        public static void normalize(IntegerArrayList list) {\n            list.retain(rankOf(list) + 1);\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        public void populate(int[] data) {\n            for (int i = 0; i < data.length; i++) {\n                data[i] = readInt();\n            }\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class IntegerArrayList implements Cloneable {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public int[] getData() {\n            return data;\n        }\n\n        public IntegerArrayList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntegerArrayList(IntegerArrayList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntegerArrayList() {\n            this(0);\n        }\n\n        public void reverse(int l, int r) {\n            SequenceUtils.reverse(data, l, r);\n        }\n\n        public void reverse() {\n            reverse(0, size - 1);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        private void checkRange(int i) {\n            if (i < 0 || i >= size) {\n                throw new ArrayIndexOutOfBoundsException();\n            }\n        }\n\n        public int get(int i) {\n            checkRange(i);\n            return data[i];\n        }\n\n        public void add(int x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public void addAll(int[] x, int offset, int len) {\n            ensureSpace(size + len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(IntegerArrayList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public void expandWith(int x, int len) {\n            ensureSpace(len);\n            while (size < len) {\n                data[size++] = x;\n            }\n        }\n\n        public void retain(int n) {\n            if (n < 0) {\n                throw new IllegalArgumentException();\n            }\n            if (n >= size) {\n                return;\n            }\n            size = n;\n        }\n\n        public void set(int i, int x) {\n            checkRange(i);\n            data[i] = x;\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public void clear() {\n            size = 0;\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof IntegerArrayList)) {\n                return false;\n            }\n            IntegerArrayList other = (IntegerArrayList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n        public int hashCode() {\n            int h = 1;\n            for (int i = 0; i < size; i++) {\n                h = h * 31 + Integer.hashCode(data[i]);\n            }\n            return h;\n        }\n\n        public IntegerArrayList clone() {\n            IntegerArrayList ans = new IntegerArrayList();\n            ans.addAll(this);\n            return ans;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public int getMod() {\n            return m;\n        }\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public String toString() {\n            return ""mod "" + m;\n        }\n\n    }\n\n    static class NumberTheoryTransform {\n        private int mod;\n        private Power power;\n        private int g;\n        private int[] wCache = new int[30];\n        private int[] invCache = new int[30];\n        public static Buffer<IntegerArrayList> listBuffer = Polynomials.listBuffer;\n\n        public NumberTheoryTransform(int mod) {\n            this(mod, mod == 998244353 ? 3 : new PrimitiveRoot(mod).findMinPrimitiveRoot());\n        }\n\n        public NumberTheoryTransform(int mod, int g) {\n            this.mod = mod;\n            this.power = new Power(mod);\n            this.g = g;\n            for (int i = 0, until = wCache.length; i < until; i++) {\n                int s = 1 << i;\n                wCache[i] = power.pow(this.g, (mod - 1) / 2 / s);\n                invCache[i] = power.inverseByFermat(s);\n            }\n        }\n\n        public void dotMul(int[] a, int[] b, int[] c, int m) {\n            for (int i = 0, n = 1 << m; i < n; i++) {\n                c[i] = (int) ((long) a[i] * b[i] % mod);\n            }\n        }\n\n        public void dft(int[] p, int m) {\n            int n = 1 << m;\n\n            int shift = 32 - Integer.numberOfTrailingZeros(n);\n            for (int i = 1; i < n; i++) {\n                int j = Integer.reverse(i << shift);\n                if (i < j) {\n                    int temp = p[i];\n                    p[i] = p[j];\n                    p[j] = temp;\n                }\n            }\n\n            int w = 0;\n            int t = 0;\n            for (int d = 0; d < m; d++) {\n                int w1 = wCache[d];\n                int s = 1 << d;\n                int s2 = s << 1;\n                for (int i = 0; i < n; i += s2) {\n                    w = 1;\n                    for (int j = 0; j < s; j++) {\n                        int a = i + j;\n                        int b = a + s;\n                        t = (int) ((long) w * p[b] % mod);\n                        p[b] = DigitUtils.modsub(p[a], t, mod);\n                        p[a] = DigitUtils.modplus(p[a], t, mod);\n                        w = (int) ((long) w * w1 % mod);\n                    }\n                }\n            }\n        }\n\n        public void idft(int[] p, int m) {\n            dft(p, m);\n\n            int n = 1 << m;\n            long invN = invCache[m];\n\n            p[0] = (int) ((long) p[0] * invN % mod);\n            p[n / 2] = (int) (p[n / 2] * invN % mod);\n            for (int i = 1, until = n / 2; i < until; i++) {\n                int a = p[n - i];\n                p[n - i] = (int) (p[i] * invN % mod);\n                p[i] = (int) (a * invN % mod);\n            }\n        }\n\n        private IntegerArrayList clone(IntegerArrayList list) {\n            Polynomials.normalize(list);\n            IntegerArrayList ans = listBuffer.alloc();\n            ans.addAll(list);\n            return ans;\n        }\n\n        public void deltaNTT(IntegerArrayList a, IntegerArrayList b, IntegerArrayList c) {\n            a = clone(a);\n            b = clone(b);\n            int n = a.size();\n            b.retain(n);\n            a.reverse();\n\n            int m = Log2.ceilLog(n + n - 1);\n            a.expandWith(0, 1 << m);\n            b.expandWith(0, 1 << m);\n            c.clear();\n            c.expandWith(0, 1 << m);\n\n            dft(a.getData(), m);\n            dft(b.getData(), m);\n            dotMul(a.getData(), b.getData(), c.getData(), m);\n            idft(c.getData(), m);\n            c.retain(n);\n            c.reverse();\n            Polynomials.normalize(c);\n\n            listBuffer.release(a);\n            listBuffer.release(b);\n        }\n\n    }\n}\n\n","fft,math,matrices"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.function.Supplier;\nimport java.io.OutputStreamWriter;\nimport java.math.BigInteger;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Collection;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.function.Consumer;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.util.ArrayDeque;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            EPerpetualSubtraction solver = new EPerpetualSubtraction();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class EPerpetualSubtraction {\n        int mod = 998244353;\n        Modular modular = new Modular(mod);\n        Power pow = new Power(modular);\n        Debug debug = new Debug(true);\n        NumberTheoryTransform ntt = new NumberTheoryTransform(modular);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            long m = in.readLong();\n\n            int[] p = new int[n + 1];\n            in.populate(p);\n\n            Factorial factorial = new Factorial(n + 1, mod);\n            int[] p0 = p;\n            int[] p1 = new int[n + 1];\n            int[] p2 = new int[n + 1];\n            int[] p3 = new int[n + 1];\n\n            {\n                IntegerArrayList a = Polynomials.listBuffer.alloc();\n                IntegerArrayList b = Polynomials.listBuffer.alloc();\n                IntegerArrayList c = Polynomials.listBuffer.alloc();\n                a.expandWith(0, n + 1);\n                b.expandWith(0, n + 1);\n\n                for (int i = 0; i <= n; i++) {\n                    a.set(i, (int) ((long) factorial.fact(i) * p0[i] % mod));\n                    b.set(i, factorial.invFact(i));\n                }\n\n                ntt.deltaNTT(a, b, c);\n                c.expandWith(0, n + 1);\n                for (int i = 0; i <= n; i++) {\n                    p1[i] = (int) ((long) c.get(i) * factorial.invFact(i) % mod);\n                }\n\n                Polynomials.listBuffer.release(a);\n                Polynomials.listBuffer.release(b);\n                Polynomials.listBuffer.release(c);\n            }\n\n            for (int i = 0; i <= n; i++) {\n                p2[i] = (int) ((long) pow.inversePower(i + 1, m) * p1[i] % mod);\n            }\n\n            {\n                IntegerArrayList a = Polynomials.listBuffer.alloc();\n                IntegerArrayList b = Polynomials.listBuffer.alloc();\n                IntegerArrayList c = Polynomials.listBuffer.alloc();\n                a.expandWith(0, n + 1);\n                b.expandWith(0, n + 1);\n\n                for (int i = 0; i <= n; i++) {\n                    a.set(i, (int) ((long) factorial.fact(i) * p2[i] % mod));\n                    b.set(i, DigitUtils.mod((i % 2 == 0 ? 1 : -1) * factorial.invFact(i), mod));\n                }\n\n                ntt.deltaNTT(a, b, c);\n                c.expandWith(0, n + 1);\n                for (int i = 0; i <= n; i++) {\n                    p3[i] = (int) ((long) c.get(i) * factorial.invFact(i) % mod);\n                }\n\n                Polynomials.listBuffer.release(a);\n                Polynomials.listBuffer.release(b);\n                Polynomials.listBuffer.release(c);\n            }\n\n            for (int i = 0; i <= n; i++) {\n                out.println(p3[i]);\n            }\n\n            debug.debug(""p0"", p0);\n            debug.debug(""p1"", p1);\n            debug.debug(""p2"", p2);\n            debug.debug(""p3"", p3);\n        }\n\n    }\n\n    static class PrimitiveRoot {\n        private int[] factors;\n        private Modular mod;\n        private Power pow;\n        int phi;\n\n        public PrimitiveRoot(Modular x) {\n            phi = x.getMod() - 1;\n            mod = x;\n            pow = new Power(mod);\n            //factors = rho.findAllFactors(phi).keySet().stream().mapToInt(Integer::intValue).toArray();\n            factors = Factorization.factorizeNumberPrime(phi).toArray();\n        }\n\n        public PrimitiveRoot(int x) {\n            this(new Modular(x));\n        }\n\n        public int findMinPrimitiveRoot() {\n            if (mod.getMod() == 2) {\n                return 1;\n            }\n            return findMinPrimitiveRoot(2);\n        }\n\n        private int findMinPrimitiveRoot(int since) {\n            for (int i = since; i < mod.m; i++) {\n                boolean flag = true;\n                for (int f : factors) {\n                    if (pow.pow(i, phi / f) == 1) {\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        public void populate(int[] data) {\n            for (int i = 0; i < data.length; i++) {\n                data[i] = readInt();\n            }\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public int getMod() {\n            return m;\n        }\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        public String toString() {\n            return ""mod "" + m;\n        }\n\n    }\n\n    static class Factorial {\n        int[] fact;\n        int[] inv;\n        int mod;\n\n        public Factorial(int[] fact, int[] inv, int mod) {\n            this.mod = mod;\n            this.fact = fact;\n            this.inv = inv;\n            fact[0] = inv[0] = 1;\n            int n = Math.min(fact.length, mod);\n            for (int i = 1; i < n; i++) {\n                fact[i] = i;\n                fact[i] = (int) ((long) fact[i] * fact[i - 1] % mod);\n            }\n            inv[n - 1] = BigInteger.valueOf(fact[n - 1]).modInverse(BigInteger.valueOf(mod)).intValue();\n            for (int i = n - 2; i >= 1; i--) {\n                inv[i] = (int) ((long) inv[i + 1] * (i + 1) % mod);\n            }\n        }\n\n        public Factorial(int limit, int mod) {\n            this(new int[limit + 1], new int[limit + 1], mod);\n        }\n\n        public int fact(int n) {\n            return fact[n];\n        }\n\n        public int invFact(int n) {\n            return inv[n];\n        }\n\n    }\n\n    static class Log2 {\n        public static int ceilLog(int x) {\n            return 32 - Integer.numberOfLeadingZeros(x - 1);\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class IntegerArrayList implements Cloneable {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public int[] getData() {\n            return data;\n        }\n\n        public IntegerArrayList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntegerArrayList(IntegerArrayList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntegerArrayList() {\n            this(0);\n        }\n\n        public void reverse(int l, int r) {\n            SequenceUtils.reverse(data, l, r);\n        }\n\n        public void reverse() {\n            reverse(0, size - 1);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        private void checkRange(int i) {\n            if (i < 0 || i >= size) {\n                throw new ArrayIndexOutOfBoundsException();\n            }\n        }\n\n        public int get(int i) {\n            checkRange(i);\n            return data[i];\n        }\n\n        public void add(int x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public void addAll(int[] x, int offset, int len) {\n            ensureSpace(size + len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(IntegerArrayList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public void expandWith(int x, int len) {\n            ensureSpace(len);\n            while (size < len) {\n                data[size++] = x;\n            }\n        }\n\n        public void retain(int n) {\n            if (n < 0) {\n                throw new IllegalArgumentException();\n            }\n            if (n >= size) {\n                return;\n            }\n            size = n;\n        }\n\n        public void set(int i, int x) {\n            checkRange(i);\n            data[i] = x;\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public void clear() {\n            size = 0;\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof IntegerArrayList)) {\n                return false;\n            }\n            IntegerArrayList other = (IntegerArrayList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n        public int hashCode() {\n            int h = 1;\n            for (int i = 0; i < size; i++) {\n                h = h * 31 + Integer.hashCode(data[i]);\n            }\n            return h;\n        }\n\n        public IntegerArrayList clone() {\n            IntegerArrayList ans = new IntegerArrayList();\n            ans.addAll(this);\n            return ans;\n        }\n\n    }\n\n    static class Buffer<T> {\n        private Deque<T> deque;\n        private Supplier<T> supplier;\n        private Consumer<T> cleaner;\n        private int allocTime;\n        private int releaseTime;\n\n        public Buffer(Supplier<T> supplier) {\n            this(supplier, (x) -> {\n            });\n        }\n\n        public Buffer(Supplier<T> supplier, Consumer<T> cleaner) {\n            this(supplier, cleaner, 0);\n        }\n\n        public Buffer(Supplier<T> supplier, Consumer<T> cleaner, int exp) {\n            this.supplier = supplier;\n            this.cleaner = cleaner;\n            deque = new ArrayDeque<>(exp);\n        }\n\n        public T alloc() {\n            allocTime++;\n            return deque.isEmpty() ? supplier.get() : deque.removeFirst();\n        }\n\n        public void release(T e) {\n            releaseTime++;\n            cleaner.accept(e);\n            deque.addLast(e);\n        }\n\n    }\n\n    static class Polynomials {\n        public static Buffer<IntegerArrayList> listBuffer = new Buffer<>(IntegerArrayList::new, list -> list.clear());\n\n        public static int rankOf(IntegerArrayList p) {\n            int[] data = p.getData();\n            int r = p.size() - 1;\n            while (r >= 0 && data[r] == 0) {\n                r--;\n            }\n            return Math.max(0, r);\n        }\n\n        public static void normalize(IntegerArrayList list) {\n            list.retain(rankOf(list) + 1);\n        }\n\n    }\n\n    static class Power implements InverseNumber {\n        final Modular modular;\n        int modVal;\n\n        public Power(Modular modular) {\n            this.modular = modular;\n            this.modVal = modular.getMod();\n        }\n\n        public int pow(int x, long n) {\n            if (n == 0) {\n                return modular.valueOf(1);\n            }\n            long r = pow(x, n >> 1);\n            r = r * r % modVal;\n            if ((n & 1) == 1) {\n                r = r * x % modVal;\n            }\n            return (int) r;\n        }\n\n        public int pow(int x, int n) {\n            if (n == 0) {\n                return modular.valueOf(1);\n            }\n            long r = pow(x, n >> 1);\n            r = r * r % modVal;\n            if ((n & 1) == 1) {\n                r = r * x % modVal;\n            }\n            return (int) r;\n        }\n\n        public int inverseByFermat(int x) {\n            return pow(x, modVal - 2);\n        }\n\n        public int inversePower(int x, long n) {\n            n = DigitUtils.mod(-n, modVal - 1);\n            return pow(x, n);\n        }\n\n    }\n\n    static class NumberTheoryTransform {\n        private Modular modular;\n        private int modVal;\n        private Power power;\n        private int g;\n        private int[] wCache = new int[30];\n        private int[] invCache = new int[30];\n        public static Buffer<IntegerArrayList> listBuffer = Polynomials.listBuffer;\n\n        public NumberTheoryTransform(Modular mod) {\n            this(mod, mod.getMod() == 998244353 ? 3 : new PrimitiveRoot(mod.getMod()).findMinPrimitiveRoot());\n        }\n\n        public NumberTheoryTransform(Modular mod, int g) {\n            this.modular = mod;\n            this.modVal = mod.getMod();\n            this.power = new Power(mod);\n            this.g = g;\n            for (int i = 0, until = wCache.length; i < until; i++) {\n                int s = 1 << i;\n                wCache[i] = power.pow(this.g, (modular.getMod() - 1) / 2 / s);\n                invCache[i] = power.inverseByFermat(s);\n            }\n        }\n\n        public void dotMul(int[] a, int[] b, int[] c, int m) {\n            for (int i = 0, n = 1 << m; i < n; i++) {\n                c[i] = modular.mul(a[i], b[i]);\n            }\n        }\n\n        public void dft(int[] p, int m) {\n            int n = 1 << m;\n\n            int shift = 32 - Integer.numberOfTrailingZeros(n);\n            for (int i = 1; i < n; i++) {\n                int j = Integer.reverse(i << shift);\n                if (i < j) {\n                    int temp = p[i];\n                    p[i] = p[j];\n                    p[j] = temp;\n                }\n            }\n\n            int w = 0;\n            int t = 0;\n            for (int d = 0; d < m; d++) {\n                int w1 = wCache[d];\n                int s = 1 << d;\n                int s2 = s << 1;\n                for (int i = 0; i < n; i += s2) {\n                    w = 1;\n                    for (int j = 0; j < s; j++) {\n                        int a = i + j;\n                        int b = a + s;\n                        t = modular.mul(w, p[b]);\n                        p[b] = modular.plus(p[a], -t);\n                        p[a] = modular.plus(p[a], t);\n                        w = modular.mul(w, w1);\n                    }\n                }\n            }\n        }\n\n        public void idft(int[] p, int m) {\n            dft(p, m);\n\n            int n = 1 << m;\n            int invN = invCache[m];\n\n            p[0] = modular.mul(p[0], invN);\n            p[n / 2] = modular.mul(p[n / 2], invN);\n            for (int i = 1, until = n / 2; i < until; i++) {\n                int a = p[n - i];\n                p[n - i] = modular.mul(p[i], invN);\n                p[i] = modular.mul(a, invN);\n            }\n        }\n\n        private IntegerArrayList clone(IntegerArrayList list) {\n            Polynomials.normalize(list);\n            IntegerArrayList ans = listBuffer.alloc();\n            ans.addAll(list);\n            return ans;\n        }\n\n        public void deltaNTT(IntegerArrayList a, IntegerArrayList b, IntegerArrayList c) {\n            a = clone(a);\n            b = clone(b);\n            int n = a.size();\n            b.retain(n);\n            a.reverse();\n\n            int m = Log2.ceilLog(n + n - 1);\n            a.expandWith(0, 1 << m);\n            b.expandWith(0, 1 << m);\n            c.clear();\n            c.expandWith(0, 1 << m);\n\n            dft(a.getData(), m);\n            dft(b.getData(), m);\n            dotMul(a.getData(), b.getData(), c.getData(), m);\n            idft(c.getData(), m);\n            c.retain(n);\n            c.reverse();\n            Polynomials.normalize(c);\n\n            listBuffer.release(a);\n            listBuffer.release(b);\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static void swap(int[] data, int i, int j) {\n            int tmp = data[i];\n            data[i] = data[j];\n            data[j] = tmp;\n        }\n\n        public static void reverse(int[] data, int l, int r) {\n            while (l < r) {\n                swap(data, l, r);\n                l++;\n                r--;\n            }\n        }\n\n        public static boolean equal(int[] a, int al, int ar, int[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static interface InverseNumber {\n    }\n\n    static class Factorization {\n        public static IntegerArrayList factorizeNumberPrime(int x) {\n            IntegerArrayList ans = new IntegerArrayList();\n            for (int i = 2; i * i <= x; i++) {\n                if (x % i != 0) {\n                    continue;\n                }\n                ans.add(i);\n                while (x % i == 0) {\n                    x /= i;\n                }\n            }\n            if (x > 1) {\n                ans.add(x);\n            }\n            return ans;\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static int mod(long x, int mod) {\n            x %= mod;\n            if (x < 0) {\n                x += mod;\n            }\n            return (int) x;\n        }\n\n        public static int mod(int x, int mod) {\n            x %= mod;\n            if (x < 0) {\n                x += mod;\n            }\n            return x;\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n        static int[] empty = new int[0];\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public Debug debug(String name, Object x) {\n            return debug(name, x, empty);\n        }\n\n        public Debug debug(String name, Object x, int... indexes) {\n            if (offline) {\n                if (x == null || !x.getClass().isArray()) {\n                    out.append(name);\n                    for (int i : indexes) {\n                        out.printf(""[%d]"", i);\n                    }\n                    out.append(""="").append("""" + x);\n                    out.println();\n                } else {\n                    indexes = Arrays.copyOf(indexes, indexes.length + 1);\n                    if (x instanceof byte[]) {\n                        byte[] arr = (byte[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof short[]) {\n                        short[] arr = (short[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof boolean[]) {\n                        boolean[] arr = (boolean[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof char[]) {\n                        char[] arr = (char[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof int[]) {\n                        int[] arr = (int[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof float[]) {\n                        float[] arr = (float[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof double[]) {\n                        double[] arr = (double[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else if (x instanceof long[]) {\n                        long[] arr = (long[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    } else {\n                        Object[] arr = (Object[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug(name, arr[i], indexes);\n                        }\n                    }\n                }\n            }\n            return this;\n        }\n\n    }\n}\n\n","fft,math,matrices"
"import java.util.*;\n\npublic class SwapAdjecentElements {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt(),MX=-1;\n		int[] arr=new int[n];\n		for(int i=0;i<n;i++) {\n			arr[i]=sc.nextInt();\n		}\n		String s=sc.next();\n		for(int i=0;i<n-1;i++) {\n			 MX=Math.max(arr[i], MX);\n			 if(s.charAt(i)=='0'&& MX>i+1) {\n				 System.out.println(""NO"");\n				 return;\n			 }\n		}\n		System.out.println(""YES"");\n	}\n}\n","dfs and similar,greedy,math,sortings,two pointers"
"import java.util.*;\npublic class cfedu37div2B {\npublic static void main(String[] args) {\nScanner sc=new Scanner(System.in);\nint n=sc.nextInt();\nint arr[]=new int[n+1];\nint sum[]=new int[n+1];\nsum[0]=0;\nint f=0;\nfor(int i=1;i<=n;i++)\narr[i]=sc.nextInt();\nString s=sc.next();\nfor(int i=0;i<n-1;i++)\n{if(s.charAt(i)=='1')\nsum[i+1]=sum[i]+1;\nelse\nsum[i+1]=sum[i];}\nfor(int i=1;i<=n;i++)    \n{if(arr[i]>i)\n{if(sum[arr[i]-1]-sum[i-1]<arr[i]-i)\n    {f=1;break;}}}\nif(f==1)\nSystem.out.println(""NO"");\nelse\nSystem.out.println(""YES"");sc.close();}\n}","dfs and similar,greedy,math,sortings,two pointers"
"import java.util.Scanner;\n\npublic class Problem920C {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int a[] = new int[n];\n        for(int i = 0; i < n; i++) a[i] = sc.nextInt();\n        sc.nextLine();\n        char c[] = sc.nextLine().toCharArray();\n        sc.close();\n\n        int max = 0;\n        for(int i = 0; i < n; i++){\n            max = Math.max(max, a[i]);\n            if(max > i+1 && c[i] == '0'){\n                System.out.println(""NO"");\n                return;\n            }\n        }\n        System.out.println(""YES"");\n    }\n}\n","dfs and similar,greedy,math,sortings,two pointers"
"import java.util.*;\n\npublic class Hello {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = Integer.parseInt(sc.nextLine());\n        int arr[] = new int[N];\n        for (int index = 0; index < N; index++) {\n            arr[index] = sc.nextInt();\n        }\n        sc.nextLine();\n        String str = sc.nextLine();\n        int maxVal = 0;\n        for (int index = 0; index < N - 1; index++) {\n            maxVal = Math.max(maxVal, arr[index]);\n            if (str.charAt(index) == '0' && maxVal > index + 1) {\n                System.out.println(""NO"");\n                return;\n            }\n        }\n        System.out.println(""YES"");\n    }\n}","dfs and similar,greedy,math,sortings,two pointers"
import java.util.*;\npublic class Practice {\n\n	public static void main(String[] args) {\n		Scanner sc= new Scanner(System.in);\n		int k=sc.nextInt();\n		int ans=0;\n		while(k!=0) {\n			ans++;\n			if(sol(ans)==10) k--;\n		}\n		System.out.println(ans);\n	}\n	static int sol(int x) {\n		int ans=0;\n		while(x!=0) {\n			ans+= x%10;\n			x/=10;\n		}\n		return ans;\n	}\n\n},"binary search,brute force,dp,implementation,number theory"
import java.util.*;\npublic class PerfectNumber {\n\n	public static void main(String[] args) {\n		Scanner sc= new Scanner(System.in);\n		int k=sc.nextInt();\n		int ans=0;\n		while(k!=0) {\n			ans++;\n			if(sol(ans)==10) k--;\n		}\n		System.out.println(ans);\n	}\n	static int sol(int x) {\n		int ans=0;\n		while(x!=0) {\n			ans+= x%10;\n			x/=10;\n		}\n		return ans;\n	}\n\n},"binary search,brute force,dp,implementation,number theory"
import java.util.*;\npublic class PerfectNumber {\n\n	public static void main(String[] args) {\n		Scanner sc= new Scanner(System.in);\n		int k=sc.nextInt();\n		int ans=0;\n		while(k!=0) {\n			ans++;\n			if(sol(ans)==10) k--;\n		}\n		System.out.println(ans);\n	}\n	static int sol(int x) {\n		int ans=0;\n		while(x!=0) {\n			ans+= x%10;\n			x/=10;\n		}\n		return ans;\n	}\n\n},"binary search,brute force,dp,implementation,number theory"
import java.io.*;\nimport java.util.*;\npublic class Perfectnum\n{\n	public static void main(String args[])\n	{\n		Scanner in = new Scanner(System.in);\n		int n = in.nextInt();\n		int i;\n		for( i=19;;i+=9)\n		{	\n			int c=i;\n			int s=0;\n			while(c>0)\n			{\n				s+=c%10;\n				c/=10;\n			}\n			if(s==10)\n				n--;\n			if(n==0)\n				break;\n\n		}\n		System.out.println(i);\n		\n	}\n},"binary search,brute force,dp,implementation,number theory"
import java.util.*;\npublic class Main{\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int k=sc.nextInt();\n		int[] x=new int[n];\n		for(int i=0;i<n;i++) {\n			x[i]=sc.nextInt();\n		}\n		Arrays.sort(x);\n		for(int i=n-1;i>=0;i--) {\n			if(k%x[i]==0) {\n				System.out.print(k/x[i]);\n				break;\n			}\n		}\n	}\n},implementation
"import java.util.*;\n\npublic class Solution {\n\n  static Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    int n = sc.nextInt(), k = sc.nextInt();\n    int res = 0;\n    for (int i = 0; i < n; i++) {\n      int num = sc.nextInt();\n      if (k % num == 0) {\n        res = Math.max(num, res);\n      }\n    }\n    System.out.println(k / res);\n  }\n}",implementation
import java.util.*;\n \npublic class solution {\n \n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int k=sc.nextInt();\n		int[] a=new int[n];\n		for(int i=0;i<n;i++) {\n			a[i]=sc.nextInt();\n		}\n		Arrays.sort(a);\n		for(int i=n-1;i>=0;i--) {\n			if(k%a[i]==0) {\n				System.out.print(k/a[i]);\n				break;\n			}\n		}\n		sc.close();\n	}\n},implementation
"import java.util.Scanner;\n\npublic class ArrayByParity {\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n\n		int n=s.nextInt();\n		int k=s.nextInt();\n		\n		int[] a=new int[n];\n		\n		for(int i=0;i<n;i++) {\n			a[i]=s.nextInt();\n		}\n		\n		int max=0;\n		for(int i=0;i<n;i++) {\n			if(k%a[i]==0) {\n				max=Math.max(max,a[i]);\n			}\n		}\n		System.out.println(k/max);\n\n	}\n\n}\n",implementation
"\n\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int L = sc.nextInt();\n        int[] c = new int[n];\n        for (int i = 0; i < n; i++) {\n            c[i] = sc.nextInt();\n        }\n        for (int i = 1; i < n; i++) {\n            c[i] = Math.min(c[i], 2 * c[i - 1]);\n        }\n        long ans = (1L << 60);\n        long sum = 0;\n        for (int i = n - 1; i >= 0 && L > 0; i--) {\n            int num = L / (1 << i);\n            sum += (long) num * c[i];\n            L -= num << i;\n            if (L>0){\n                ans = Math.min(ans, sum + c[i]);\n            }else{\n                ans=Math.min(ans,sum);\n            }\n\n\n        }\n        System.out.println(ans);\n    }\n}\n","bitmasks,dp,greedy"
"import java.util.Scanner;\nimport java.util.StringTokenizer;\n \npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		\n		StringTokenizer st = new StringTokenizer(sc.nextLine());\n		int N = Integer.parseInt(st.nextToken());\n		long L = Integer.parseInt(st.nextToken());\n		st = new StringTokenizer(sc.nextLine());\n		long[] C = new long[31];\n		for (int i = 0; i < N; i++) {\n			C[i] = Integer.parseInt(st.nextToken());\n		}\n		for (int i = N; i < C.length; i++) {\n			C[i] = C[i - 1] << 1;\n		}\n		\n		for (int i = 1; i < C.length; i++) {\n			C[i] = Math.min(C[i], C[i - 1] << 1);\n		}\n		\n		long ans = 0;\n		for (int i = 0; i < C.length; i++) {\n			if (ans > C[i]) {\n				L += 1 << i;\n				ans = 0;\n			}\n			if ((L & (1 << i)) != 0) {\n				ans += C[i];\n			}\n		}\n		\n		System.out.println(ans);\n		\n		sc.close();\n	}\n}\n 		 			   		  	   			 	 	 	  		","bitmasks,dp,greedy"
"// package com.company.codeforces;\n\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int n=input.nextInt();\n        long l=input.nextLong();\n        long c[]=new long[n];\n        long indexmincost[]=new long[31];\n        for (int i = 0; i <n ; i++) {\n            c[i]=input.nextLong();\n        }\n        indexmincost[0]=c[0];\n        for (int i = 1; i <n ; i++) {\n            indexmincost[i]=Math.min(indexmincost[i-1]*2,c[i]);\n        }\n        for (int i = n; i <=30; i++) {\n            indexmincost[i]=indexmincost[i-1]*2;\n\n        }\n        long dp[]=new long[31];\n        for (int i = 0; i <=30; i++) {\n            if (i==0) {\n                dp[0]=0;\n            }else {\n                dp[i]=Math.min(dp[i-1],indexmincost[i]);\n            }\n\n            long temp=1<<i;\n            if ((temp&l)==temp){\n                dp[i]+=indexmincost[i];\n\n            }\n            \n        }\n        System.out.println(dp[30]);\n    }\n\n}","bitmasks,dp,greedy"
"import java.util.*;\nimport java.io.*;\npublic class B{\n	public static void main(String[] args)\n	{\n		FastScanner fs = new FastScanner();\n		PrintWriter out = new PrintWriter(System.out);\n		int n = fs.nextInt(); long req = fs.nextLong();\n		long[] price = new long[n];\n		for(int i=0;i<n;i++)price[i] = fs.nextLong();\n		for(int i=1;i<n;i++)price[i] = Math.min(price[i],2*price[i-1]);\n		long cur = 0;\n		long ans = (long)(4e18);\n		for(int i=n-1;i>=0;i--)\n		{\n			long need = (req)/((1<<i));\n			cur += need*price[i];\n			req -= (need)*(1<<i);\n			ans = Math.min(ans,cur+((req>0)?1:0)*price[i]);\n		}\n		out.println(ans);\n		out.close();\n	}\n	static class FastScanner {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n		String next() {\n			while (!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		int[] readArray(int n) {\n			int[] a=new int[n];\n			for (int i=0; i<n; i++) a[i]=nextInt();\n			return a;\n		}\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n	}\n	public static int[] sort(int[] arr)\n	{\n		List<Integer> temp = new ArrayList();\n		for(int i:arr)temp.add(i);\n		Collections.sort(temp);\n		int start = 0;\n		for(int i:temp)arr[start++]=i;\n		return arr;\n	}\n}","bitmasks,dp,greedy"
"//package Coding;\n\nimport java.util.*;\nimport java.io.*;\n\n\npublic class Main \n{   \n\n	public static void main(String[] args) throws IOException \n	{\n		Scanner s=new Scanner(System.in);\n		int n=s.nextInt();\n		int k=s.nextInt();\n		\n		Stack<Integer>st=new Stack<>();\n		st.push((int) (2e5+1));\n		st.push(n+1);\n		\n		int ar[]=new int[n];\n		int cur=1;\n		for(int i=0;i<n;i++) {\n			if(i<k)\n				ar[i]=s.nextInt();\n			else\n				ar[i]=st.peek()-1;\n			st.push(ar[i]);\n			while(st.peek()==cur) {\n				st.pop();\n				cur++;\n			}\n		}\n		\n		if(st.size()>1) {\n			System.out.println(-1);\n		}else {\n			for(int i:ar) {\n				System.out.print(i+"" "");\n			}\n		}\n\n	}\n\n}","constructive algorithms,data structures,greedy,implementation"
"//package Coding;\n\nimport java.util.*;\nimport java.io.*;\n\n\npublic class Main \n{   \n//dry run on this\n//	30 3\n//	29 25 21\n//	29 25 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 24 23 22 28 27 26 30 \n	public static void main(String[] args) throws IOException \n	{\n		Scanner s=new Scanner(System.in);\n		int n=s.nextInt();\n		int k=s.nextInt();\n		\n		Stack<Integer>st=new Stack<>();\n		\n		st.push(n+1);     ////islye taki agr phele k element aagye h to decending order mai hona chahiye\n		\n		int ar[]=new int[n];\n		int cur=1;\n		for(int i=0;i<n;i++) {\n			if(i<k)\n				ar[i]=s.nextInt();\n			else\n				ar[i]=st.peek()-1;\n			st.push(ar[i]);\n			while(!st.isEmpty() && st.peek()==cur) {\n				st.pop();\n				cur++;\n			}\n		}\n		\n		if(st.size()>0) {\n			System.out.println(-1);\n		}else {\n			for(int i:ar) {\n				System.out.print(i+"" "");\n			}\n		}\n\n	}\n\n}","constructive algorithms,data structures,greedy,implementation"
"import java.util.*;\nimport java.io.*;\n\npublic class Main \n{\n	\n	public static void main(String[] args) throws IOException \n	{ \n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		StringTokenizer s = new StringTokenizer(br.readLine());\n		int n=Integer.parseInt(s.nextToken());\n		int k=Integer.parseInt(s.nextToken());\n		int ar[]=new int[k];\n		s = new StringTokenizer(br.readLine());\n		for(int i=0;i<k;i++)\n			ar[i]=Integer.parseInt(s.nextToken());\n		Stack<Integer>st=new Stack<>();\n		int cur=1;\n		int ans[]=new int[n];\n		st.push(n+1);\n		\n		for(int i=0;i<n;i++) {\n			if(i<k) \n				ans[i]=ar[i];\n				\n			else\n				ans[i]=st.peek()-1;\n			st.push(ans[i]);\n			while(!st.isEmpty() && cur==st.peek()) {\n				st.pop();\n				cur++;\n			}\n			\n		}\n		if(st.size()>0)\n			pw.println(-1);\n		else {\n			for(int i:ans)\n				pw.print(i+"" "");\n		}\n		pw.close();\n		\n\n	}\n}\n","constructive algorithms,data structures,greedy,implementation"
"import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class ss {\n	int a[];\n	boolean can;\n\n	public static void main(String[] args) {\n		ss solver = new ss();\n		solver.solve();\n	}\n\n	void solve() {\n		FastScanner in = new FastScanner();\n		PrintWriter out = new PrintWriter(System.out);\n		int n = in.nextInt(), k = in.nextInt();\n		a = new int[n];\n		Arrays.fill(a, -1);\n		for (int i = 0; i < k; i++) a[i] = in.nextInt();\n		can = true;\n		solve1(0, n-1, 1, n);\n		if (!can) {\n			out.println(-1);\n		} else {\n			for (int i = 0; i < n; i++) out.printf(""%d "", a[i]);\n			out.println("""");\n		}\n		out.flush();\n	}\n\n	void solve1(int l, int r, int from, int to) {\n		if (l > r || from > to) return;\n		if (a[l] == -1) {\n			for (int i = l; i <= r; i++) a[i] = to - (i - l);\n			return;\n		}\n		if (a[l] > to || a[l] < from) {\n			can = false;\n			return;\n		}\n		int len_left = a[l] - from;\n		int len_right = to - a[l];\n		solve1(l + 1, l + len_left, from, a[l] - 1);\n		solve1(r - len_right + 1, r, a[l] + 1, to);\n	}\n\n	static class FastScanner {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer tok = new StringTokenizer("""");\n		String next() {\n			while(!tok.hasMoreTokens()) {\n				try {\n					tok = new StringTokenizer(br.readLine());\n				} catch (Exception e) {\n					e.printStackTrace();\n				}\n			}\n			return tok.nextToken();\n		}\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n		float nextFloat() {\n			return Float.parseFloat(next());\n		}\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n	}\n}\n","constructive algorithms,data structures,greedy,implementation"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF897C extends PrintWriter {\n	CF897C() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF897C o = new CF897C(); o.main(); o.flush();\n	}\n\n	byte[] ff = ""What are you doing at the end of the world? Are you busy? Will you save us?"".getBytes();\n	byte[] aa = ""What are you doing while sending \"""".getBytes();\n	byte[] bb = ""\""? Are you busy? Will you send \"""".getBytes();\n	byte[] cc = ""\""?"".getBytes();\n	int nf, na, nb, nc;\n	static final int N = 100000;\n	long[] ll = new long[N + 1];\n	byte get(int n, long k) {\n		if (n == 0)\n			return ff[(int) k - 1];\n		if (k <= na)\n			return aa[(int) k - 1];\n		k -= na;\n		if (k <= ll[n - 1])\n			return get(n - 1, k);\n		k -= ll[n - 1];\n		if (k <= nb)\n			return bb[(int) k - 1];\n		k -= nb;\n		if (k <= ll[n - 1])\n			return get(n - 1, k);\n		k -= ll[n - 1];\n		return cc[(int) k - 1];\n	}\n	void main() {\n		nf = ff.length; na = aa.length; nb = bb.length; nc = cc.length;\n		ll[0] = nf;\n		for (int n = 1; n <= N; n++)\n			ll[n] = Math.min(ll[n - 1] * 2 + na + nb + nc, (long) 2e18);\n		int q = sc.nextInt();\n		byte[] ans = new byte[q];\n		for (int h = 0; h < q; h++) {\n			int n = sc.nextInt();\n			long k = sc.nextLong();\n			ans[h] = k > ll[n] ? (byte) '.' : get(n, k);\n		}\n		println(new String(ans));\n	}\n}\n","binary search,dfs and similar"
"import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class C{\n	\n	static long[] num =  new long[(int)1e5+10];\n	static boolean[] vis = new boolean[num.length];\n	\n	static String base = ""What are you doing at the end of the world? Are you busy? Will you save us?"";\n	// Recur is  ""What are you doing while sending ""x""? Are you busy? Will you send ""x""?""\n	\n	static String[] rec = {\n			""What are you doing while sending \"""",\n			""\""? Are you busy? Will you send \"""",\n			""\""?""\n	};\n	\n	static char ans(int n, long k) {\n		if (n==0) {\n			return base.charAt((int)(k-1));\n		}\n		\n		for (int it =0; it <  3; it++) {\n			for (int i = 0; i < rec[it].length(); i++) {\n				k--;\n				if (k==0) return rec[it].charAt(i);\n			}\n			if (!vis[n-1] || k-num[n-1] <= 0) return ans(n-1,k);\n			k-=num[n-1];\n		}\n		\n		return '.';\n	}\n	\n	public static void main(String[] args) throws IOException {\n		// br = new BufferedReader(new FileReader("".in""));\n		// out = new PrintWriter(new FileWriter("".out""));\n		//new Thread(null, new (), ""peepee"", 1<<28).start();\n		\n		int  q  = readInt();\n		\n		String recur = ""What are you doing while sending \""\""? Are you busy? Will you send \""\""?"";\n		Arrays.fill(num, Long.MAX_VALUE/3);\n		num[0] = base.length();\n		vis[0]=true;\n		for (int i =1; i < num.length; i++) {\n			num[i] = recur.length() + 2*num[i-1];\n			if (num[i] > Long.MAX_VALUE/8) break;\n			vis[i]=true;\n		}\n		while(q-->0) {\n			int n =readInt();\n			long  k=readLong();\n			//System.out.println(n + ""  "" + k);\n			if (k > num[n]) out.print('.');\n			else out.print(ans(n,k));\n		}\n		out.println();\n		\n		out.close();\n	}\n	\n	/* Stupid things to try if stuck:\n	 * n=1, expand bsearch range\n	 * brute force small patterns\n	 * submit stupid intuition\n	 */\n	\n	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n	static StringTokenizer st = new StringTokenizer("""");\n	static String read() throws IOException{return st.hasMoreTokens() ? st.nextToken():(st = new StringTokenizer(br.readLine())).nextToken();}\n	static int readInt() throws IOException{return Integer.parseInt(read());}\n	static long readLong() throws IOException{return Long.parseLong(read());}\n	static double readDouble() throws IOException{return Double.parseDouble(read());}\n}","binary search,dfs and similar"
"import java.io.*;\nimport java.util.*;\nimport java.math.*;\npublic class A {\n	public static long length[] = new long[100001];\n	public static void main(String[] args)throws IOException {\n		FastIO sc = new FastIO(System.in);\n		PrintWriter out = new PrintWriter(System.out);\n		int q = sc.nextInt();\n		String f0 = ""What are you doing at the end of the world? Are you busy? Will you save us?"";\n		String f1 = ""What are you doing while sending \"""";\n		String f2 = ""\""? Are you busy? Will you send \"""";\n		String f3 = ""\""?"";\n		length[0] = f0.length();\n		for(int i=1; i<100001; ++i) {\n			if(length[i-1]>=(long)1e18) {\n				length[i] = (long)1e18;\n			}else {\n				length[i] = length[i-1]*2  + f1.length() + f2.length() + f3.length();\n			}\n		}\n		while(q-->0) {\n			int n= sc.nextInt();\n			long k = sc.nextLong()-1;\n			System.out.print(solve(n, k, f1, f2, f3, f0));\n		}\n		out.close();\n	}\n	public static char solve(int n,long k, String a, String b, String c, String d) {\n		if(length[n]<=k) return '.';\n		if(n==0) {\n			return d.charAt((int)k);\n		}\n		if(k<a.length()) {\n			return a.charAt((int)k);\n		}\n		k-=a.length();\n		if(k<length[n-1]) {\n			return solve(n-1, k, a, b, c, d);\n		}\n		k-=length[n-1];\n		if(k<b.length()) {\n			return b.charAt((int)k);\n		}\n		k-=b.length();\n		if(k<length[n-1]) {\n			return solve(n-1, k, a, b, c, d);\n		}\n		k-=length[n-1];\n		return c.charAt((int)k);\n	}\n	static class FastIO {\n		InputStream dis;\n		byte[] buffer = new byte[1 << 17];\n		int pointer = 0;\n		public FastIO(String fileName) throws IOException {\n			dis = new FileInputStream(fileName);\n		}\n		public FastIO(InputStream is) throws IOException {\n			dis = is;\n		}\n		int nextInt() throws IOException {\n			int ret = 0;\n \n			byte b;\n			do {\n				b = nextByte();\n			} while (b <= ' ');\n			boolean negative = false;\n			if (b == '-') {\n				negative = true;\n				b = nextByte();\n			}\n			while (b >= '0' && b <= '9') {\n				ret = 10 * ret + b - '0';\n				b = nextByte();\n			}\n \n			return (negative) ? -ret : ret;\n		}\n		long nextLong() throws IOException {\n			long ret = 0;\n \n			byte b;\n			do {\n				b = nextByte();\n			} while (b <= ' ');\n			boolean negative = false;\n			if (b == '-') {\n				negative = true;\n				b = nextByte();\n			}\n			while (b >= '0' && b <= '9') {\n				ret = 10 * ret + b - '0';\n				b = nextByte();\n			}\n			return (negative) ? -ret : ret;\n		}\n		byte nextByte() throws IOException {\n			if (pointer == buffer.length) {\n				dis.read(buffer, 0, buffer.length);\n				pointer = 0;\n			}\n			return buffer[pointer++];\n		}\n		String next() throws IOException {\n			StringBuffer ret = new StringBuffer();\n \n			byte b;\n			do {\n				b = nextByte();\n			} while (b <= ' ');\n			while (b > ' ') {\n				ret.appendCodePoint(b);\n				b = nextByte();\n			}\n \n			return ret.toString();\n		}\n	}\n}\n","binary search,dfs and similar"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.StringTokenizer;\n\npublic class Nephren {\n\n    static String f0 = ""What are you doing at the end of the world? Are you busy? Will you save us?"";\n    static String fb = ""What are you doing while sending \"""";\n    public static final int FBL = fb.length();\n    static String fm = ""\""? Are you busy? Will you send \"""";\n    public static final int FML = fm.length();\n    static String fe = ""\""?"";\n    public static final int FEL = fe.length();\n\n    static BigInteger f0Size = BigInteger.valueOf(f0.length());\n    static BigInteger connectorSize = BigInteger.valueOf(fb.length()+fm.length()+fe.length());\n\n    public static long size(int n) {\n        if(n>63) return Long.MAX_VALUE;\n        BigInteger pow = BigInteger.TWO.pow(n);\n        BigInteger f0chars = pow.multiply(f0Size);\n        BigInteger connectorChars = pow.subtract(BigInteger.ONE).multiply(connectorSize);\n        BigInteger size = f0chars.add(connectorChars);\n        if(size.bitLength() > 63) return Long.MAX_VALUE;\n        return size.longValue();\n    }\n    public static char kchar(int n, long k) {\n        // 0 base case\n        if(n == 0) {\n            if(k <= f0.length()) return f0.charAt((int) (k-1));\n            else return '.';\n        }\n\n        if(k <= fb.length()) return fb.charAt((int) (k-1));\n        long kt = k - fb.length();\n        if(kt <= size(n-1)) return kchar(n-1, kt);\n        kt -= size(n-1);\n        if(kt <= fm.length()) return fm.charAt((int) (kt-1));\n        kt -= fm.length();\n        if(kt <= size(n-1)) return kchar(n-1, kt);\n        kt -= size(n-1);\n        if(kt <= fe.length()) return fe.charAt((int) (kt-1));\n\n        //k > size(n)\n        return '.';\n    }\n\n    public static char kchar2(int n, long k) {\n        long kt = k;\n        while(n>0) {\n\n            if (kt <= FBL) return fb.charAt((int) (kt - 1));\n            kt -= fb.length();\n            long sn1 = size(n - 1);\n            if (kt <= sn1) {\n                n--;\n                continue;\n            }\n            kt -= sn1;\n            if (kt <= FML) return fm.charAt((int) (kt - 1));\n            kt -= fm.length();\n            if (kt <= sn1) {\n                n--;\n                continue;\n            }\n            kt -= sn1;\n            if (kt <= FEL) return fe.charAt((int) (kt - 1));\n\n            //k > size(n)\n            return '.';\n        }\n        if(kt <= f0.length()) return f0.charAt((int) (kt-1));\n        else return '.';\n\n    }\n\n\n    public static void main(String[] args) throws IOException {\n\n//        System.out.println(size(999));\n//        System.exit(0);\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        int q = Integer.parseInt(f.readLine());\n\n        for(int i=0; i<q; i++) {\n            StringTokenizer st = new StringTokenizer(f.readLine());\n            int n = Integer.parseInt(st.nextToken());\n            long k = Long.parseLong(st.nextToken());\n            System.out.print(kchar2(n,k));\n        }\n\n\n\n    }\n}\n","binary search,dfs and similar"
"import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class E implements Runnable{\n	// Beginning of SCC template\n	static int n;\n	\n	static class Edge{\n		int to,nxt;\n		long w;\n		public Edge(int a, long b) {\n			to=a;\n			w=b;\n		}\n	}\n	static Edge[] g, rg, adj;\n	static int[] gh, rgh, adjh;\n	\n	static int[] scc;\n	static Stack<Integer> stack = new Stack<Integer>();\n	\n	static void dfs1(int i) {\n		if (scc[i]++!=0)return;\n		for (int ind = gh[i]; ind != -1; ind = g[ind].nxt) dfs1(g[ind].to);\n		stack.push(i);\n	}\n	static void dfs2(int i, int v) {\n		if (scc[i] != -1) return;\n		scc[i]=v;\n		for (int ind = rgh[i]; ind != -1; ind = rg[ind].nxt) dfs2(rg[ind].to,v);\n	}\n	\n	static long[] scc_sum;\n	\n	static void solve() {\n		scc = new int[n];\n		scc_sum = new long[n];\n		Arrays.fill(scc, 0);\n		for (int i = 0; i < n; i++) dfs1(i);\n		Arrays.fill(scc, -1);\n		int v = 0;\n		while(!stack.isEmpty()) {\n			int h =stack.pop();\n			if (scc[h]==-1) dfs2(h,v++);\n		}\n		int outerInd = 0;\n		for (int i = 0; i < n; i++) {\n			for (int ind = gh[i]; ind != -1; ind = g[ind].nxt) {\n				if (scc[g[ind].to] == scc[i]) {\n					scc_sum[scc[i]]-=fxn(g[ind].w);\n				}\n				else {\n					adj[outerInd] = new Edge(scc[g[ind].to], -g[ind].w);\n					adj[outerInd].nxt = adjh[scc[i]];\n					adjh[scc[i]] = outerInd++;\n				}\n			}\n		}\n	}\n	// End of SCC Template\n	static boolean[] vis;\n	static Stack<Integer> topo = new Stack<Integer>();\n	\n	static void topo(int i) {\n		if (vis[i]) return;\n		vis[i] = true;\n		for (int ind = adjh[i]; ind != -1; ind = adj[ind].nxt) topo(adj[ind].to);\n		topo.add(i);\n	}\n	\n	\n	static long[] dists;\n	\n	static long fxn(long input) {\n		// So n-1, n-2, n-3, etc. until done.\n		 long l = -1, r = (long)1e8;\n		 if (input == 0 ) return 0;\n		 while(l+1<r) {\n			 long m =(l+r)>>>1;\n			if (m * (m+1)/2 < input) l = m;\n			else r = m;\n		 }\n\n		 long sub = pref[(int)l];\n		 long res = (l+1)*input - sub;\n		 //System.out.println(""Yo "" + sub + "" "" + res);\n		 //System.out.println(""Yo "" + res + "" "" + l);\n		 return res;\n	}\n	\n	static long[] pref;\n	\n	public static void main(String[] args) throws IOException {\n		// br = new BufferedReader(new FileReader("".in""));\n		// out = new PrintWriter(new FileWriter("".out""));\n		new Thread(null, new E(), ""peepee"", 1<<28).start();\n		\n	}\n	\n	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n	static StringTokenizer st = new StringTokenizer("""");\n	static String read() throws IOException{return st.hasMoreTokens() ? st.nextToken():(st = new StringTokenizer(br.readLine())).nextToken();}\n	static int readInt() throws IOException{return Integer.parseInt(read());}\n	static long readLong() throws IOException{return Long.parseLong(read());}\n	static double readDouble() throws IOException{return Double.parseDouble(read());}\n	@Override\n	public void run() {\n		// TODO Auto-generated method stub\n		try {\n			pref = new long[(int)1e5];\n			for (int i = 1; i < 1e5; i++) {\n				pref[i] += pref[i-1];\n				long ans = i;\n				ans *= (i+1);\n				pref[i] += ans/2;\n			}\n			\n\n			\n			n =readInt();\n			int m =readInt();\n			g = new Edge[m];\n			adj = new Edge[m];\n			rg = new Edge[m];\n			gh = new int[n];\n			adjh = new int[n];\n			rgh = new int[n];\n			\n			for (int i =0 ; i < n; i++) gh[i] = adjh[i] = rgh[i] = -1;\n			for (int i =0 ; i < m; i++) {\n				int x = readInt()-1;\n				int y =readInt()-1;\n				int w = readInt();\n				g[i] = new Edge(y,w);\n				g[i].nxt = gh[x];\n				gh[x] = i;\n				\n				rg[i] = new Edge(x,w);\n				rg[i].nxt = rgh[y];\n				rgh[y] = i;\n			}\n			int start_pt = readInt()-1;\n			solve();\n			\n			\n			//for (long x: scc_sum) out.println(x);\n			dists = new long[n];\n			vis = new boolean[n];\n			//System.out.println(scc_sum[0]);\n			topo(scc[start_pt]);\n			while(!topo.isEmpty()) {\n				int h = topo.pop();\n				dists[h]+=scc_sum[h];\n				for (int ind = adjh[h]; ind != -1; ind = adj[ind].nxt) dists[adj[ind].to] = min(adj[ind].w + dists[h], dists[adj[ind].to]);\n			}\n			long max = 0;\n			for (int i =0 ; i < n; i++) {\n				max = min(max,dists[i]);\n			}\n			out.println(-max);\n			\n			out.close();\n		}\n		catch (IOException  e) {}\n	}\n}","dp,graphs"
"import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class E implements Runnable{\n	// Beginning of SCC template\n	static int n;\n	\n	static class Edge{\n		int to,nxt;\n		long w;\n		public Edge(int a, long b) {\n			to=a;\n			w=b;\n		}\n	}\n	static Edge[] g, rg, adj;\n	static int[] gh, rgh, adjh;\n	\n	static int[] scc;\n	static Stack<Integer> stack = new Stack<Integer>();\n	\n	static void dfs1(int i) {\n		if (scc[i]++!=0)return;\n		for (int ind = gh[i]; ind != -1; ind = g[ind].nxt) dfs1(g[ind].to);\n		stack.push(i);\n	}\n	static void dfs2(int i, int v) {\n		if (scc[i] != -1) return;\n		scc[i]=v;\n		for (int ind = rgh[i]; ind != -1; ind = rg[ind].nxt) dfs2(rg[ind].to,v);\n	}\n	\n	static long[] scc_sum;\n	\n	static void solve() {\n		scc = new int[n];\n		scc_sum = new long[n];\n		Arrays.fill(scc, 0);\n		for (int i = 0; i < n; i++) dfs1(i);\n		Arrays.fill(scc, -1);\n		int v = 0;\n		while(!stack.isEmpty()) {\n			int h =stack.pop();\n			if (scc[h]==-1) dfs2(h,v++);\n		}\n		int outerInd = 0;\n		for (int i = 0; i < n; i++) {\n			for (int ind = gh[i]; ind != -1; ind = g[ind].nxt) {\n				if (scc[g[ind].to] == scc[i]) {\n					scc_sum[scc[i]]-=fxn(g[ind].w);\n				}\n				else {\n					adj[outerInd] = new Edge(scc[g[ind].to], -g[ind].w);\n					adj[outerInd].nxt = adjh[scc[i]];\n					adjh[scc[i]] = outerInd++;\n				}\n			}\n		}\n	}\n	// End of SCC Template\n	static boolean[] vis;\n	static Stack<Integer> topo = new Stack<Integer>();\n	\n	static void topo(int i) {\n		if (vis[i]) return;\n		vis[i] = true;\n		for (int ind = adjh[i]; ind != -1; ind = adj[ind].nxt) topo(adj[ind].to);\n		topo.add(i);\n	}\n	\n	\n	static long[] dists;\n	\n	static long fxn(long input) {\n		// So n-1, n-2, n-3, etc. until done.\n		 long l = -1, r = (long)1e8;\n		 if (input == 0 ) return 0;\n		 while(l+1<r) {\n			 long m =(l+r)>>>1;\n			if (m * (m+1)/2 < input) l = m;\n			else r = m;\n		 }\n\n		 long sub = pref[(int)l];\n		 long res = (l+1)*input - sub;\n		 //System.out.println(""Yo "" + sub + "" "" + res);\n		 //System.out.println(""Yo "" + res + "" "" + l);\n		 return res;\n	}\n	\n	static long[] pref;\n	\n	public static void main(String[] args) throws IOException {\n		// br = new BufferedReader(new FileReader("".in""));\n		// out = new PrintWriter(new FileWriter("".out""));\n		new Thread(null, new E(), ""peepee"", 1<<28).start();\n		\n	}\n	\n	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n	static StringTokenizer st = new StringTokenizer("""");\n	static String read() throws IOException{return st.hasMoreTokens() ? st.nextToken():(st = new StringTokenizer(br.readLine())).nextToken();}\n	static int readInt() throws IOException{return Integer.parseInt(read());}\n	static long readLong() throws IOException{return Long.parseLong(read());}\n	static double readDouble() throws IOException{return Double.parseDouble(read());}\n	@Override\n	public void run() {\n		// TODO Auto-generated method stub\n		try {\n			pref = new long[(int)1e5];\n			for (int i = 1; i < 1e5; i++) {\n				pref[i] += pref[i-1];\n				long ans = i;\n				ans *= (i+1);\n				pref[i] += ans/2;\n			}\n			\n\n			\n			n =readInt();\n			int m =readInt();\n			g = new Edge[m];\n			adj = new Edge[m];\n			rg = new Edge[m];\n			gh = new int[n];\n			adjh = new int[n];\n			rgh = new int[n];\n			\n			for (int i =0 ; i < n; i++) gh[i] = adjh[i] = rgh[i] = -1;\n			for (int i =0 ; i < m; i++) {\n				int x = readInt()-1;\n				int y =readInt()-1;\n				int w = readInt();\n				g[i] = new Edge(y,w);\n				g[i].nxt = gh[x];\n				gh[x] = i;\n				\n				rg[i] = new Edge(x,w);\n				rg[i].nxt = rgh[y];\n				rgh[y] = i;\n			}\n			int start_pt = readInt()-1;\n			solve();\n			\n			\n			//for (long x: scc_sum) out.println(x);\n			dists = new long[n];\n			vis = new boolean[n];\n			//System.out.println(scc_sum[0]);\n			topo(scc[start_pt]);\n			while(!topo.isEmpty()) {\n				int h = topo.pop();\n				dists[h]+=scc_sum[h];\n				for (int ind = adjh[h]; ind != -1; ind = adj[ind].nxt) dists[adj[ind].to] = min(adj[ind].w + dists[h], dists[adj[ind].to]);\n			}\n			long max = 0;\n			for (int i =0 ; i < n; i++) {\n				max = min(max,dists[i]);\n			}\n			out.println(-max);\n			//\n			out.close();\n		}\n		catch (IOException  e) {}\n	}\n}","dp,graphs"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF894E extends PrintWriter {\n	CF894E() { super(System.out); }\n	static class Scanner {\n		Scanner(InputStream in) { this.in = in; } InputStream in;\n		int k, l; byte[] bb = new byte[1 << 15];\n		byte getc() {\n			if (k >= l) {\n				k = 0;\n				try { l = in.read(bb); } catch (IOException e) { l = 0; }\n				if (l <= 0) return -1;\n			}\n			return bb[k++];\n		}\n		int nextInt() {\n			byte c = 0; while (c <= 32) c = getc();\n			int a = 0;\n			while (c > 32) { a = a * 10 + c - '0'; c = getc(); }\n			return a;\n		}\n	}\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF894E o = new CF894E(); o.main(); o.flush();\n	}\n\n	static class L {\n		L next; int e;\n		L(L next, int e) {\n			this.next = next; this.e = e;\n		}\n	}\n	L[] ao, ai;\n	int[] ii, jj, ww;\n	int[] po, cc;\n	int npo;\n	int[] stack;\n	void dfs1(int i) {\n		int cnt = 0;\n		stack[cnt++] = i;\n		while (cnt > 0) {\n			i = stack[cnt - 1];\n			if (cc[i] == 0) {\n				cc[i] = 1;\n				for (L l = ao[i]; l != null; l = l.next) {\n					int h = l.e;\n					int j = jj[h];\n					if (cc[j] == 0)\n						stack[cnt++] = j;\n				}\n			} else {\n				cnt--;\n				if (cc[i] == 1) {\n					po[npo++] = i;\n					cc[i] = -1;\n				}\n			}\n		}\n	}\n	void dfs2(int c) {\n		int cnt = 0;\n		cc[c] = c; stack[cnt++] = c;\n		while (cnt > 0) {\n			int j = stack[--cnt];\n			for (L l = ai[j]; l != null; l = l.next) {\n				int h = l.e;\n				int i = ii[h];\n				if (cc[i] == -1) {\n					cc[i] = c; stack[cnt++] = i;\n				}\n			}\n		}\n	}\n	long all(int w) {\n		int n = (int) Math.sqrt(w << 1) - 1;\n		while ((n + 1) * (n + 2) <= w << 1)\n			n++;\n		return (long) (n + 1) * w - (long) n * (n + 1) * (n + 2) / 6;\n	}\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		ao = new L[n];\n		ai = new L[n];\n		ii = new int[m];\n		jj = new int[m];\n		ww = new int[m];\n		for (int h = 0; h < m; h++) {\n			int i = sc.nextInt() - 1;\n			int j = sc.nextInt() - 1;\n			ww[h] = sc.nextInt();\n			ii[h] = i;\n			jj[h] = j;\n			ao[i] = new L(ao[i], h);\n			ai[j] = new L(ai[j], h);\n		}\n		int s = sc.nextInt() - 1;\n		stack = new int[Math.max(m + 1, n)];\n		po = new int[n];\n		cc = new int[n];\n		for (int i = 0; i < n; i++)\n			if (cc[i] == 0)\n				dfs1(i);\n		for (int h = n - 1; h >= 0; h--) {\n			int j = po[h];\n			if (cc[j] == -1)\n				dfs2(j);\n		}\n		L[] ao_ = new L[n];\n		long[] ww_ = new long[n];\n		for (int h = 0; h < m; h++) {\n			int i = cc[ii[h]];\n			int j = cc[jj[h]];\n			if (i == j)\n				ww_[i] += all(ww[h]);\n			else\n				ao_[i] = new L(ao_[i], h);\n		}\n		long[] dp = new long[n];\n		Arrays.fill(dp, -1);\n		dp[cc[s]] = 0;\n		long ans = 0;\n		for (int h = n - 1; h >= 0; h--) {\n			int i = po[h];\n			if (cc[i] == i && dp[i] >= 0) {\n				dp[i] += ww_[i];\n				if (ans < dp[i])\n					ans = dp[i];\n				if (ao_[i] == null)\n					continue;\n				for (L l = ao_[i]; l != null; l = l.next) {\n					int h_ = l.e;\n					int j = cc[jj[h_]];\n					long w_ = dp[i] + ww[h_];\n					if (dp[j] < w_)\n						dp[j] = w_;\n				}\n			}\n		}\n		println(ans);\n	}\n}\n","dp,graphs"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF894E extends PrintWriter {\n	CF894E() { super(System.out); }\n	static class Scanner {\n		Scanner(InputStream in) { this.in = in; } InputStream in;\n		int k, l; byte[] bb = new byte[1 << 15];\n		byte getc() {\n			if (k >= l) {\n				k = 0;\n				try { l = in.read(bb); } catch (IOException e) { l = 0; }\n				if (l <= 0) return -1;\n			}\n			return bb[k++];\n		}\n		int nextInt() {\n			byte c = 0; while (c <= 32) c = getc();\n			int a = 0;\n			while (c > 32) { a = a * 10 + c - '0'; c = getc(); }\n			return a;\n		}\n	}\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF894E o = new CF894E(); o.main(); o.flush();\n	}\n\n	int[] next, hh;\n	int[] ao, ai;\n	int[] ii, jj, ww;\n	int[] po, cc;\n	int npo;\n	int[] stack;\n	void dfs1(int i) {\n		int cnt = 0;\n		stack[cnt++] = i;\n		while (cnt > 0) {\n			i = stack[cnt - 1];\n			if (cc[i] == 0) {\n				cc[i] = 1;\n				for (int l = ao[i]; l != 0; l = next[l]) {\n					int h = hh[l];\n					int j = jj[h];\n					if (cc[j] == 0)\n						stack[cnt++] = j;\n				}\n			} else {\n				cnt--;\n				if (cc[i] == 1) {\n					po[npo++] = i;\n					cc[i] = -1;\n				}\n			}\n		}\n	}\n	void dfs2(int c) {\n		int cnt = 0;\n		cc[c] = c; stack[cnt++] = c;\n		while (cnt > 0) {\n			int j = stack[--cnt];\n			for (int l = ai[j]; l != 0; l = next[l]) {\n				int h = hh[l];\n				int i = ii[h];\n				if (cc[i] == -1) {\n					cc[i] = c; stack[cnt++] = i;\n				}\n			}\n		}\n	}\n	long all(int w) {\n		int n = (int) Math.sqrt(w << 1) - 1;\n		while ((n + 1) * (n + 2) <= w << 1)\n			n++;\n		return (long) (n + 1) * w - (long) n * (n + 1) * (n + 2) / 6;\n	}\n	int __ = 1;\n	int link(int nxt, int h) {\n		next[__] = nxt;\n		hh[__] = h;\n		return __++;\n	}\n	void main() {\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		ao = new int[n];\n		ai = new int[n];\n		ii = new int[m];\n		jj = new int[m];\n		ww = new int[m];\n		next = new int[m * 2 + 1];\n		hh = new int[m * 2 + 1];\n		for (int h = 0; h < m; h++) {\n			int i = sc.nextInt() - 1;\n			int j = sc.nextInt() - 1;\n			ww[h] = sc.nextInt();\n			ii[h] = i;\n			jj[h] = j;\n			ao[i] = link(ao[i], h);\n			ai[j] = link(ai[j], h);\n		}\n		int s = sc.nextInt() - 1;\n		stack = new int[Math.max(m + 1, n)];\n		po = new int[n];\n		cc = new int[n];\n		for (int i = 0; i < n; i++)\n			if (cc[i] == 0)\n				dfs1(i);\n		for (int h = n - 1; h >= 0; h--) {\n			int j = po[h];\n			if (cc[j] == -1)\n				dfs2(j);\n		}\n		Arrays.fill(ao, 0); __ = 1;\n		long[] ww_ = new long[n];\n		for (int h = 0; h < m; h++) {\n			int i = cc[ii[h]];\n			int j = cc[jj[h]];\n			if (i == j)\n				ww_[i] += all(ww[h]);\n			else\n				ao[i] = link(ao[i], h);\n		}\n		long[] dp = new long[n];\n		Arrays.fill(dp, -1);\n		dp[cc[s]] = 0;\n		long ans = 0;\n		for (int h = n - 1; h >= 0; h--) {\n			int i = po[h];\n			if (cc[i] == i && dp[i] >= 0) {\n				dp[i] += ww_[i];\n				if (ans < dp[i])\n					ans = dp[i];\n				for (int l = ao[i]; l != 0; l = next[l]) {\n					int h_ = hh[l];\n					int j = cc[jj[h_]];\n					long w_ = dp[i] + ww[h_];\n					if (dp[j] < w_)\n						dp[j] = w_;\n				}\n			}\n		}\n		println(ans);\n	}\n}\n","dp,graphs"
"import java.util.*;\n\npublic class apmZEOERIGFH {\n\n	static Scanner in = new Scanner(System.in);\n	\n	public static void main(String[] args) {\n		\n		int n = in.nextInt();\n		\n		int[] a = new int[n];\n		\n		int cnt = 0;\n		\n		for(int i = 0; i < n; i++) {\n			a[i] = in.nextInt();\n			if(a[i] == 1) cnt++;\n		}\n		int ans = Integer.MAX_VALUE;\n		if(cnt > 0) System.out.println(n-cnt);\n		else {\n			for(int i = 0; i < n; i++) {\n				int m = a[i];\n				for(int j = i+1; j < n; j++) {\n					m = GCD(m,a[j]);\n					if(m == 1) {\n						ans = Math.min(ans, j-i-1);\n						break;\n					}\n				}\n			}\n			if(ans == Integer.MAX_VALUE) {\n				System.out.println(-1);\n			}\n			else System.out.println(n+ans);\n		}\n	}\n	\n	public static int GCD(int a, int b) {\n		if(b == 0) return a;\n		else return GCD(b, a%b);\n	}\n}","brute force,dp,greedy,math,number theory"
"import java.util.*;\npublic class MyClass {\n   public static int gcd(int a, int b){\n       if(b==0) return a;\n       else return gcd(b,a%b);\n   }\n    public static void main(String args[]) {\n     Scanner in = new Scanner(System.in);\n      int n=in.nextInt();\n      int a[]=new int[n];\n      int flag=0;\n      for(int i=0;i<n;i++){ a[i]=in.nextInt();  if(a[i]==1) flag++;}\n      int g=a[0];\n      for(int i=1;i<n;i++) g=gcd(g,a[i]);\n      if(g!=1)\n      System.out.println(""-1"");\n      else {\n          int min=n+1;\n          for(int i=0;i<n-1;i++){ int temp=a[i],c=0;\n              for(int j=i+1;j<n;j++){\n                  temp=gcd(temp,a[j]); c++;\n                  if(temp==1) break;\n              }if(temp==1) min=Math.min(min,c);\n          }if(flag!=0) min=0; else flag=1;\n          System.out.println(min+n-flag);\n      }\n    }\n}","brute force,dp,greedy,math,number theory"
"import java.io.*;\nimport java.util.*;\npublic class Pride {\n\n	static int gcd(int a, int b)\n	{\n		if(a==0)\n			return b;\n		return gcd(b%a,a);\n	}\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		int gcd=0,one=0;\n		HashSet<Integer> set=new HashSet<>();\n		int a[]=new int[n];\n		for(int i=0;i<n;i++)\n		{\n			a[i]=sc.nextInt();\n			if(a[i]==1)\n				one++;\n			set.add(a[i]);\n			gcd=gcd(gcd,a[i]);\n		}\n		if(gcd!=1)\n		{\n			System.out.println(-1);\n			System.exit(0);\n		}\n		int min=Integer.MAX_VALUE;\n		//Minimum number of steps to convert any one number to 1 = (size of minimum subarray with gcd=1)-1\n		//Thus to find this minimum steps we iterate through all possible subarrays since n=2000 at max.\n		for(int i=0;i<n;i++)\n		{\n			int x=0;\n			for(int j=i;j<n;j++)\n			{\n				x=gcd(x,a[j]);\n				if(x==1 && (j-i+1)<min)\n					min=j-i+1;\n			}\n		}\n		if(one==0)\n			one++;\n		System.out.println((n-1+min-1-(one-1)));\n\n	}\n\n}\n","brute force,dp,greedy,math,number theory"
"import java.util.*;\npublic class Solution\n{\n    public static void main(String arg[])\n    {\n        Scanner io=new Scanner(System.in);\n        int n=io.nextInt();\n        ArrayList<Integer> arr=new ArrayList<>();\n        for(int i=0;i<n;i++)\n            arr.add(io.nextInt());\n        if(arr.contains(1))\n        {\n            System.out.println(arr.size()-Collections.frequency(arr,1));\n            System.exit(0);\n        }\n        int res=Integer.MAX_VALUE,gcd;\n        for(int i=0;i<n;i++)\n        {\n            int xx=arr.get(i);\n            for(int j=i+1;j<n;j++)\n            {\n                xx=gcdf(Math.max(xx,arr.get(j)),Math.min(xx,arr.get(j)));\n                if(xx==1)\n                {\n                    res=Math.min(res,j-i);\n                }\n            }\n        }\n        if(res==Integer.MAX_VALUE)\n            System.out.println(""-1"");\n        else\n            System.out.println(n-1+res);\n\n    }\n    public static int gcdf(int a,int b)\n    {\n        if(b==0)\n            return a;\n        else \n            return gcdf(b,a%b);\n    }\n}\n","brute force,dp,greedy,math,number theory"
"import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.StringTokenizer;\n\npublic class Div1_443D {\n\n	public static void main(String[] args) throws IOException {\n		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		StringTokenizer inputData = new StringTokenizer(reader.readLine());\n		int nT = Integer.parseInt(inputData.nextToken());\n		int nS = Integer.parseInt(inputData.nextToken());\n		int nO = Integer.parseInt(inputData.nextToken());\n\n		int[][] traits = new int[nS][nT];\n\n		for (int cC = 0; cC < nS; cC++) {\n			inputData = new StringTokenizer(reader.readLine());\n			for (int cT = 0; cT < nT; cT++) {\n				traits[cC][cT] = Integer.parseInt(inputData.nextToken());\n			}\n		}\n\n		int nST = nT * nS;\n\n		int[] sTOwn = new int[nST];\n\n		for (int cST = 0; cST < nST; cST++) {\n			int cT = cST / nS;\n			int cTOwn = cST % nS;\n\n			for (int cand = 0; cand < nS; cand++) {\n				if (traits[cand][cT] >= traits[cTOwn][cT]) {\n					sTOwn[cST] |= 1 << cand;\n				}\n			}\n		}\n\n		int[] redSI = new int[1 << nS];\n		Arrays.fill(redSI, -1);\n\n		ArrayList<Integer> rSTraits = new ArrayList<>();\n\n		for (int cST = 0; cST < nST; cST++) {\n			if (redSI[sTOwn[cST]] == -1) {\n				redSI[sTOwn[cST]] = rSTraits.size();\n				rSTraits.add(cST);\n			}\n		}\n\n		BitSet[] tBlocks = new BitSet[nS + nO];\n\n		for (int cC = 0; cC < nS; cC++) {\n			tBlocks[cC] = new BitSet();\n			for (int cRTI = 0; cRTI < rSTraits.size(); cRTI++) {\n				if ((sTOwn[rSTraits.get(cRTI)] & (1 << cC)) != 0) {\n					tBlocks[cC].set(cRTI);\n				}\n			}\n		}\n\n		int nI = nS;\n		for (int i = 0; i < nO; i++) {\n			inputData = new StringTokenizer(reader.readLine());\n			int op = Integer.parseInt(inputData.nextToken());\n			int x = Integer.parseInt(inputData.nextToken()) - 1;\n			int y = Integer.parseInt(inputData.nextToken()) - 1;\n			if (op == 1) {\n				tBlocks[nI] = (BitSet) tBlocks[x].clone();\n				tBlocks[nI].or(tBlocks[y]);\n				nI++;\n			} else if (op == 2) {\n				tBlocks[nI] = (BitSet) tBlocks[x].clone();\n				tBlocks[nI].and(tBlocks[y]);\n				nI++;\n			} else {\n				int sTB = y * nS;\n				int max = 0;\n				for (int add = 0; add < nS; add++) {\n					int sTI = sTB + add;\n					int rTI = redSI[sTOwn[sTI]];\n					if (tBlocks[x].get(rTI)) {\n						max = Math.max(max, traits[add][y]);\n					}\n				}\n				printer.println(max);\n			}\n		}\n		printer.close();\n	}\n}\n",bitmasks
"import java.io.*;\nimport java.util.*;\n\npublic class Codeforces878D {\n\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter pw = new PrintWriter(System.out);\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int n = Integer.parseInt(st.nextToken());\n		int k = Integer.parseInt(st.nextToken());\n		int q = Integer.parseInt(st.nextToken());\n		\n		int[][] a = new int[k][n];\n		for (int i = 0; i < k; i++) {\n			st = new StringTokenizer(br.readLine());\n			for (int j = 0; j < n; j++) {\n				a[i][j] = Integer.parseInt(st.nextToken());\n			}\n		}\n		\n		int numcreatures = k;\n		int[][] query = new int[q][3];\n		for (int i = 0; i < q; i++) {\n			st = new StringTokenizer(br.readLine());\n			for (int j = 0; j < 3; j++) {\n				query[i][j] = Integer.parseInt(st.nextToken());\n			}\n			if (query[i][0] < 3) {\n				numcreatures++;\n			}\n		}\n		\n		//ok rip now the hard stuff begins\n		boolean[][] alloptions = new boolean[numcreatures][(1<<k)];\n		for (int i = 0; i < k; i++) {\n			for (int j = 0; j < (1<<k); j++) {\n				if ((j>>i)%2 == 1) {\n					alloptions[i][j] = true;\n				}\n			}\n		}\n		\n		int creatureCounter = k;\n		for (int i = 0; i < q; i++) {\n			if (query[i][0] == 1) {\n				for (int j = 0; j < (1<<k); j++) {\n					alloptions[creatureCounter][j] = (alloptions[query[i][1]-1][j])||(alloptions[query[i][2]-1][j]);\n				}\n				creatureCounter++;\n			}\n			else if (query[i][0] == 2) {\n				for (int j = 0; j < (1<<k); j++) {\n					alloptions[creatureCounter][j] = (alloptions[query[i][1]-1][j])&&(alloptions[query[i][2]-1][j]);\n				}\n				creatureCounter++;\n			}\n			else {\n				int[][] hardProblem = new int[k][2];\n				for (int j = 0; j < k; j++) {\n					hardProblem[j][0] = a[j][query[i][2]-1];\n					hardProblem[j][1] = j;\n				}\n				keysort(hardProblem, 0);\n				\n				boolean bool = false;\n				int ctr = k-1;\n				int ctr2 = 0;\n				while(!bool) {\n					ctr2 += (1<<hardProblem[ctr][1]);\n					if (alloptions[query[i][1]-1][ctr2]) {\n						bool = true;\n						pw.println(hardProblem[ctr][0]);\n					}\n					else {\n						ctr--;\n					}\n				}\n			}\n		}\n		pw.close();\n	}\n\n	public static void keysort(int[][] array, int index) {\n    	int N = array.length;\n    	if (N != 1) {\n    		int[][] firstHalf = Arrays.copyOfRange(array, 0, N/2);\n    		keysort(firstHalf, index);\n        	int[][] secondHalf = Arrays.copyOfRange(array, N/2, N);\n        	keysort(secondHalf, index);\n        	int firstCounter = 0;\n        	int secondCounter = 0;\n        	for (int i = 0; i < N; i++) {\n        		if (firstCounter == N/2) {\n        			array[firstCounter+secondCounter] = secondHalf[secondCounter];\n        			secondCounter++;\n        		}\n        		else if ((secondCounter == N-N/2) || firstHalf[firstCounter][index] <= secondHalf[secondCounter][index]) {\n        			array[firstCounter+secondCounter] = firstHalf[firstCounter];\n        			firstCounter++;\n        		}\n        		else {\n        			array[firstCounter+secondCounter] = secondHalf[secondCounter];\n        			secondCounter++;\n        		}\n        	}\n    	}	\n    }\n\n}\n",bitmasks
"import java.io.*;\nimport java.util.*;\n\npublic class D {\n\n	int k;\n	\n	class Creature {\n		long[] table;\n		public Creature(int idx) {\n			table = new long[1 << (k - 6)];\n			for (int i = 0; i < 1 << k; i++) {\n				if ((i & (1 << idx)) != 0) {\n					table[i >> 6] |= 1L << (i & 63);\n				}\n			}\n		}\n		\n		boolean get(int i) {\n			return ((table[i >> 6] >> (i & 63)) & 1) != 0;\n		}\n		public Creature(long[] table) { \n			this.table = table;\n		}\n\n		@Override\n		public String toString() {\n			String s = """";\n			for (int i = 0; i < 1 << k; i++) {\n				s += get(i) ? 1 : 0;\n			}\n			return s;\n		}\n		\n		\n	}\n	\n	Creature min(Creature a, Creature b) {\n		long[] table=  new long[1 << (k - 6)];\n		for (int i = 0; i < table.length; i++) {\n			table[i] = a.table[i] | b.table[i];\n		}\n		return new Creature(table);\n	}\n	\n	Creature max(Creature a, Creature b) {\n		long[] table=  new long[1 << (k - 6)];\n		for (int i = 0; i < table.length; i++) {\n			table[i] = a.table[i] & b.table[i];\n		}\n		return new Creature(table);\n	}\n	\n	List<Creature> cs = new ArrayList<>();\n	\n	void solve() {\n		int n = in.nextInt();\n		int realK = in.nextInt();\n		k = Math.max(realK, 6);\n		int q = in.nextInt();\n\n		int[][] init = new int[n][k];\n		for (int i = 0; i < realK; i++) {\n			for (int j = 0; j < n; j++) {\n				init[j][i] = in.nextInt();\n			}\n		}\n		\n		for (int i = 0; i < realK; i++) {\n			cs.add(new Creature(i));\n		}\n//		System.err.println(cs);\n		\n		for (int query = 0; query < q; query++) {\n			int type = in.nextInt();\n			int x = in.nextInt() - 1, y = in.nextInt() - 1;\n			if (type == 1) {\n				cs.add(max(cs.get(x), cs.get(y)));\n			} else if (type == 2) {\n				cs.add(min(cs.get(x), cs.get(y)));\n			} else {\n				int left = 0, right = 1 << 30;\n				Creature cr = cs.get(x);\n				int[] ar = init[y];\n				while (left < right - 1) {\n					int mid = (left + right) >>> 1;\n					int mask = 0;\n					for (int i = 0; i < k; i++) {\n						if (mid >= ar[i]) {\n							mask |= 1 << i;\n						}\n					}\n					if (cr.get(mask)) {\n						right = mid;\n					} else {\n						left = mid;\n					}\n				}\n				out.println(right);\n			}\n		}\n	}\n\n	FastScanner in;\n	PrintWriter out;\n\n	void run() {\n		in = new FastScanner();\n		out = new PrintWriter(System.out);\n		solve();\n		out.close();\n	}\n\n	class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		public FastScanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		public FastScanner(String file) {\n			try {\n				br = new BufferedReader(new FileReader(file));\n			} catch (FileNotFoundException e) {\n				e.printStackTrace();\n			}\n		}\n\n		public String nextToken() {\n			while (st == null || !st.hasMoreElements()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			}\n			return st.nextToken();\n		}\n\n		public boolean hasMoreTokens() {\n			while (st == null || !st.hasMoreElements()) {\n				try {\n					String line = br.readLine();\n					if (line == null) {\n						return false;\n					}\n					st = new StringTokenizer(line);\n				} catch (IOException e) {\n					return false;\n				}\n			}\n			return true;\n		}\n\n		public int nextInt() {\n			return Integer.parseInt(nextToken());\n		}\n\n		public long nextLong() {\n			return Long.parseLong(nextToken());\n		}\n\n		public double nextDouble() {\n			return Double.parseDouble(nextToken());\n		}\n\n		public int[] nextIntArray(int length) {\n			int[] array = new int[length];\n			for (int i = 0; i < length; i++) {\n				array[i] = nextInt();\n			}\n			return array;\n		}\n	}\n\n	public static void main(String[] args) {\n		new D().run();\n	}\n}\n",bitmasks
"import java.io.*;\nimport java.util.*;\n\npublic class MainD {\n	static StdIn in = new StdIn();\n	static PrintWriter out = new PrintWriter(System.out);\n	\n	public static void main(String[] args) {\n		int n=in.nextInt(), k=in.nextInt(), q=in.nextInt();\n		int[][] a = new int[n][k], b = new int[n][k];\n		for(int i=0; i<k; ++i)\n			for(int j=0; j<n; ++j)\n				a[j][i]=in.nextInt();\n		for(int i=0; i<n; ++i) {\n			for(int j=0; j<k; ++j)\n				b[i][j]=j;\n			for(int j1=0; j1<k; ++j1) {\n				for(int j2=j1+1; j2<k; ++j2) {\n					if(a[i][b[i][j1]]>=a[i][b[i][j2]])\n						continue;\n					b[i][j1]^=b[i][j2];\n					b[i][j2]^=b[i][j1];\n					b[i][j1]^=b[i][j2];\n				}\n			}\n		}\n		List<BitSet> creatures = new ArrayList<BitSet>();\n		for(int i=0; i<k; ++i) {\n			BitSet bs = new BitSet(1<<k);\n			for(int j=0; j<1<<k; ++j)\n				if(((j>>i)&1)==1)\n					bs.set(j);\n			creatures.add(bs);\n		}\n		while(q-->0) {\n			int qt=in.nextInt(), x=in.nextInt()-1, y=in.nextInt()-1;\n			if(qt==1) {\n				BitSet bs = (BitSet)creatures.get(x).clone();\n				bs.or(creatures.get(y));\n				creatures.add(bs);\n			} else if(qt==2) {\n				BitSet bs = (BitSet)creatures.get(x).clone();\n				bs.and(creatures.get(y));\n				creatures.add(bs);\n			} else {\n				BitSet bs = creatures.get(x);\n				int i=-1, cm=0;\n				for(; !bs.get(cm); ++i, cm|=1<<b[y][i]);\n				out.println(a[y][b[y][i]]);\n			}\n		}\n		out.close();\n	}\n	\n	interface Input {\n		public String next();\n		public String nextLine();\n		public int nextInt();\n		public long nextLong();\n		public double nextDouble();\n	}\n	static class StdIn implements Input {\n		final private int BUFFER_SIZE = 1 << 16;\n		private DataInputStream din;\n		private byte[] buffer;\n		private int bufferPointer, bytesRead;\n		public StdIn() {\n			din = new DataInputStream(System.in);\n			buffer = new byte[BUFFER_SIZE];\n			bufferPointer = bytesRead = 0;\n		}\n		public StdIn(InputStream in) {\n			try{\n				din = new DataInputStream(in);\n			} catch(Exception e) {\n				throw new RuntimeException();\n			}\n			buffer = new byte[BUFFER_SIZE];\n			bufferPointer = bytesRead = 0;\n		}\n		public String next() {\n			int c;\n			while((c=read())!=-1&&(c==' '||c=='\n'||c=='\r'));\n			StringBuilder s = new StringBuilder();\n			while (c != -1)\n			{\n				if (c == ' ' || c == '\n'||c=='\r')\n					break;\n				s.append((char)c);\n				c=read();\n			}\n			return s.toString();\n		}\n		public String nextLine() {\n			int c;\n			while((c=read())!=-1&&(c==' '||c=='\n'||c=='\r'));\n			StringBuilder s = new StringBuilder();\n			while (c != -1)\n			{\n				if (c == '\n'||c=='\r')\n					break;\n				s.append((char)c);\n				c = read();\n			}\n			return s.toString();\n		}\n		public int nextInt() {\n			int ret = 0;\n			byte c = read();\n			while (c <= ' ')\n				c = read();\n			boolean neg = (c == '-');\n			if (neg)\n				c = read();\n			do\n				ret = ret * 10 + c - '0';\n			while ((c = read()) >= '0' && c <= '9');\n\n			if (neg)\n				return -ret;\n			return ret;\n		}\n		public int[] readIntArray(int n) {\n			int[] ar = new int[n];\n			for(int i=0; i<n; ++i)\n				ar[i]=nextInt();\n			return ar;\n		}\n		public long nextLong() {\n			long ret = 0;\n			byte c = read();\n			while (c <= ' ')\n				c = read();\n			boolean neg = (c == '-');\n			if (neg)\n				c = read();\n			do\n				ret = ret * 10 + c - '0';\n			while ((c = read()) >= '0' && c <= '9');\n			if (neg)\n				return -ret;\n			return ret;\n		}\n		public long[] readLongArray(int n) {\n			long[] ar = new long[n];\n			for(int i=0; i<n; ++i)\n				ar[i]=nextLong();\n			return ar;\n		}\n		public double nextDouble() {\n			double ret = 0, div = 1;\n			byte c = read();\n			while (c <= ' ')\n				c = read();\n			boolean neg = (c == '-');\n			if (neg)\n				c = read();\n			do\n				ret = ret * 10 + c - '0';\n			while ((c = read()) >= '0' && c <= '9');\n			if (c == '.')\n				while ((c = read()) >= '0' && c <= '9')\n					ret += (c - '0') / (div *= 10);\n			if (neg)\n				return -ret;\n			return ret;\n		}\n		private void fillBuffer() throws IOException {\n			bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n			if (bytesRead == -1)\n				buffer[0] = -1;\n		}\n		private byte read() {\n			try{\n				if (bufferPointer == bytesRead)\n					fillBuffer();\n				return buffer[bufferPointer++];\n			} catch(IOException e) {\n				throw new RuntimeException();\n			}\n		}\n		public void close() throws IOException {\n			if (din == null)\n				return;\n			din.close();\n		}\n	}\n}",bitmasks
"import java.util.Scanner;\npublic class Main{\n\n	public static void main(String[] args) {\n		int n;\n		Scanner sc=new Scanner(System.in);\n		n=sc.nextInt();\n		int ans=n+n/2;\n		System.out.println(ans);\n		for(int i=2;i<=n;i+=2)\n		{\n			System.out.print(i+"" "");\n		}\n		for(int i=1;i<=n;i+=2)\n		{\n			System.out.print(i+"" "");\n		}\n		for(int i=2;i<=n;i+=2)\n		{\n			System.out.print(i+"" "");\n		}\n	}\n\n}\n\n	 	   						 	 	 		  		 	 					",constructive algorithms
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF877C extends PrintWriter {\n	CF877C() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF877C o = new CF877C(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int m = n / 2 + n;\n		println(m);\n		for (int i = 2; i <= n; i += 2)\n			print(i + "" "");\n		for (int i = 1; i <= n; i += 2)\n			print(i + "" "");\n		for (int i = 2; i <= n; i += 2)\n			print(i + "" "");\n		println();\n	}\n}\n",constructive algorithms
"\nimport java.util.*;\n\npublic class CodeForces {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		if(n==2) {\n			System.out.println(3);\n			System.out.println(""2 1 2"");\n			return;\n		}\n		String ans = """" , ans2 = """";\n		System.out.println(2*(n/2)+(n-(n/2)));\n		for(int i = 2;i<=n;i+=2) {\n		    if(i%2==0)\n		    	System.out.print(i+"" "");;\n		}\n		\n		for(int i = 1;i<=n;i+=2) {\n		    if(i%2!=0)\n		    	System.out.print(i+"" "");;\n		}\n		\n		for(int i = 2;i<=n;i+=2) {\n		    if(i%2==0)\n		    	System.out.print(i+"" "");;\n		}\n	}\n}",constructive algorithms
"import java.io.*;\nimport java.util.*;\npublic class main{\n//start\n	public static void main(String[] args) {\n		FastScanner sc=new FastScanner();\n	        int n=sc.nextInt();\n	        int ans=n+n/2;\n	        ArrayList<Integer> al=new ArrayList<>();\n	        \n	        System.out.println(ans);\n	        for(int i=2;i<=n;i+=2){\n	        al.add(i);\n	        } 	\n	        for(int i=1;i<=n;i+=2){\n	        al.add(i);\n	        } 	\n	        for(int i=2;i<=n;i+=2){\n	        al.add(i);\n	        } 	\n		for(int x:al){\n		System.out.print(x+"" "");\n		}\n		System.out.println();\n	}\n//end\n	static void sort(int[] a) {\n		ArrayList<Integer> l=new ArrayList<>();\n		for (int i:a) l.add(i);\n		Collections.sort(l);\n		for (int i=0; i<a.length; i++) a[i]=l.get(i);\n	}\n	\n	static class FastScanner {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n		String next() {\n			while (!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n	}\n\n	\n}\n",constructive algorithms
"\nimport java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s=sc.next();\n        int t, c=0;\n       s= s.replaceAll(""Danil"",""."");\n        s= s.replaceAll(""Olya"",""."");\n        s= s.replaceAll(""Slava"",""."");\n        s= s.replaceAll(""Ann"",""."");\n        s= s.replaceAll(""Nikita"",""."");\n\n        for(t=0;t<s.length();t++)if(s.charAt(t)=='.')c++;\n\n\n        System.out.print((c==1?""YES"":""NO""));\n    }\n\n}","implementation,strings"
"\nimport java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s=sc.next();\n        int t, c=0;\n       s= s.replaceAll(""Danil"",""."");\n        s= s.replaceAll(""Olya"",""."");\n        s= s.replaceAll(""Slava"",""."");\n        s= s.replaceAll(""Ann"",""."");\n        s= s.replaceAll(""Nikita"",""."");\n\n        for(t=0;t<s.length();t++)if(s.charAt(t)=='.')c++;\n\n\n        System.out.print((c==1?""YES"":""NO""));\n    }\n\n}\n","implementation,strings"
"import java.util.Scanner;\n\npublic class taskC {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String line = scanner.nextLine();\n\n        for(String val: new String[]{""Nikita"",""Ann"",""Slava"",""Olya"",""Danil""})\n            line = line.replace(val,""!"");\n\n        int count = 0;\n        for(char val : line.toCharArray())\n            if(val == '!')\n                count++;\n\n        System.out.println(count == 1 ? ""YES"" : ""NO"");\n    }\n}\n	  	  	    	  		  				  			   	","implementation,strings"
"import java.util.*;\n\npublic class solution {\n\n	public static void main(String[] args)  {\n		Scanner sc=new Scanner(System.in);\n		String s=sc.nextLine();\n		String[] a= { ""Danil"", ""Olya"", ""Slava"", ""Ann"",""Nikita""};\n		boolean f=true;\n		int c=0;\n		for(int i=0;i<5;i++) {\n			if(s.contains(a[i])) {\n				if(s.indexOf(a[i])==s.lastIndexOf(a[i])) {\n					c++;\n				}\n				else {\n					f=false;\n					break;\n				}\n			}\n		}\n		if(f && c==1) {\n			System.out.print(""YES"");\n		}\n		else {\n			System.out.print(""NO"");\n		}\n	}\n}","implementation,strings"
"import java.util.*;\nimport java.io.*;\n\npublic class RaceAgainstTime \n{\n	public static void main(String[] args)\n	{\n		Scanner kb = new Scanner(System.in);\n		int hour = kb.nextInt();\n		int minute = kb.nextInt();\n		int second = kb.nextInt();\n		int t1 = kb.nextInt();\n		int t2 = kb.nextInt();\n		\n\n		if(t1 > t2)\n		{\n			int temp = t2;\n			t2 = t1;\n			t1 = temp;\n		}\n		\n		int count = 0;\n		\n		if(t2 > hour && t1 <= hour)\n			count++;\n		\n		if(t2 * 5 > minute && t1 * 5<= minute)\n			count++;\n		if(t2 * 5 > second && t1*5 <=second)\n			count++;\n		if(count == 0 || count == 3)\n			System.out.println(""YES"");\n		else\n			System.out.println(""NO"");\n		\n	}\n	\n	\n	\n}\n",implementation
"import java.util.*;\nimport java.io.*;\n\npublic class RaceAgainstTime \n{\n	public static void main(String[] args)\n	{\n		Scanner kb = new Scanner(System.in);\n		int hour = kb.nextInt();\n		int minute = kb.nextInt();\n		int second = kb.nextInt();\n		int t1 = kb.nextInt();\n		int t2 = kb.nextInt();\n		\n\n		if(t1 > t2)\n		{\n			int temp = t2;\n			t2 = t1;\n			t1 = temp;\n		}\n		\n		int count = 0;\n		\n		if(t2 > hour && t1 <= hour)\n			count++;\n		\n		if(t2 * 5 > minute && t1 * 5<= minute)\n			count++;\n		if(t2 * 5 > second && t1*5 <=second)\n			count++;\n		if(count == 0 || count == 3)\n			System.out.println(""YES"");\n		else\n			System.out.println(""NO"");\n		\n	}\n	\n	\n	\n}\n",implementation
"import java.util.*;\npublic class prob4 {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int h =sc.nextInt();\n        int m = sc.nextInt()/5;\n        int s = sc.nextInt()/5;\n        int t1 = sc.nextInt();\n        int t2 = sc.nextInt();\n        int a  =Math.min(t1,t2);\n        int b = Math.max(t1,t2);\n        int c = 0;\n        while(a<b){\n            if(a==h){\n                c++;\n            }\n            if(a==m){\n                c++;\n            }\n            if(a==s){\n                c++;\n            }\n            a++;\n        }\n        if(c==0 || c==3){\n            System.out.println(""YES"");\n        }\n        else{\n            System.out.println(""NO"");\n        }\n\n\n    }\n\n}\n",implementation
"import java.util.*;\nimport java.io.*;\n\npublic class cf_19 {\n    public static void main(String[] args) {\n        new Solution().solve();\n    }\n}\n\nclass Solution {\n    public void solve() {\n        FastScanner fs = new FastScanner();\n        int h = fs.nextInt(), m = fs.nextInt(), s = fs.nextInt(), t1 = fs.nextInt(), t2 = fs.nextInt();\n        // Always ensure t1 < t2, else swap them\n        if (t1 > t2) {\n            int temp = t1;\n            t1 = t2;\n            t2 = temp;\n        }\n        int count = 0;\n        if (t2 > h && t1 <= h) {\n            count++;\n        }\n        if (t2 * 5 > m && t1 * 5 <= m) {\n            count++;\n        }\n        if (t2 * 5 > s && t1 * 5 <= s) {\n            count++;\n        }\n        if (count == 0 || count == 3) {\n            System.out.println(""YES"");\n        } else {\n            System.out.println(""NO"");\n        }\n    }\n}\n\nclass FastScanner {\n    private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    private StringTokenizer st = new StringTokenizer("""");\n    \n    public String next() {\n        while (!st.hasMoreTokens())\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        return st.nextToken();\n    }\n    \n    public int[] readIntArray(int n) {\n        int[] arr = new int[n];\n        for (int i=0; i<n; i++) {\n            arr[i] = nextInt();\n        }\n        return arr;\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }    \n    \n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public float nextFloat() {\n        return Float.parseFloat(next());\n    }    \n}",implementation
"import java.io.*;\nimport java.util.*;\n\npublic class Bipartite {\n	private static List<Integer>[] adj;\n	private static long[] bi;\n	\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int n=in.nextInt();\n		adj=new List[n];\n		for(int i=0; i<n; i++)\n			adj[i]=new ArrayList<Integer>();\n		for(int i=0; i<n-1; i++) {\n			int a=in.nextInt()-1, b=in.nextInt()-1;\n			adj[a].add(b);\n			adj[b].add(a);\n		}\n		bi=new long[2];\n		dfs(0, 0, 0);\n		System.out.println(bi[0]*bi[1]-(n-1));\n	}\n	\n	static void dfs(int node, int parent, int color) {\n		bi[color]++;\n		for(int i : adj[node])\n			if(i!=parent)\n				dfs(i, node, color==1?0:1);\n	}\n}","dfs and similar,graphs,trees"
"import java.io.*;\nimport java.util.*;\n \npublic class Bipartite {\n	private static List<Integer>[] adj;\n	private static long[] bi;\n	\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int n=in.nextInt();\n		adj=new List[n];\n		for(int i=0; i<n; i++)\n			adj[i]=new ArrayList<Integer>();\n		for(int i=0; i<n-1; i++) {\n			int a=in.nextInt()-1, b=in.nextInt()-1;\n			adj[a].add(b);\n			adj[b].add(a);\n		}\n		bi=new long[2];\n		dfs(0, 0, 0);\n		System.out.println(bi[0]*bi[1]-(n-1));\n	}\n	\n	static void dfs(int node, int parent, int color) {\n		bi[color]++;\n		for(int i : adj[node])\n			if(i!=parent)\n				dfs(i, node, color==1?0:1);\n	}\n}\n	  				   	 		 	    		   		 			","dfs and similar,graphs,trees"
"import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n	public static void dfs(int src,int parent,ArrayList<ArrayList<Integer>> adj,long color[],int col) {\n		color[col]++;\n		for(int i:adj.get(src)) {\n			if(i!=parent) {\n				dfs(i,src,adj,color,col==1?0:1);\n			}\n		}\n	}\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner sc=new Scanner(System.in);\n		int n=sc.nextInt();\n		ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\n		for(int i=0;i<=n;i++) {\n			adj.add(new ArrayList<>());\n		}\n		for(int i=1;i<n;i++) {\n			int a=sc.nextInt();\n			int b=sc.nextInt();\n			adj.get(a).add(b);\n			adj.get(b).add(a);\n		}\n		long color[]=new long[2];\n		dfs(1,0,adj,color,0);\n		System.out.println(color[0]*color[1]-n+1);\n		sc.close();\n	}\n\n}","dfs and similar,graphs,trees"
"import java.util.*;\n\npublic class Main {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		\n		int n = sc.nextInt();\n		ArrayList<ArrayList<Integer>> arr = new ArrayList<>();\n		\n		for(int i = 0; i <= n; i++) {\n			arr.add(new ArrayList<>());\n		}\n		\n		for(int i = 0; i < n - 1; i++) {\n			int u = sc.nextInt();\n			int v = sc.nextInt();\n			\n			arr.get(u).add(v);\n			arr.get(v).add(u);\n		}\n		int[] res = new int[1];\n		dfs(arr, 1,-1,0,res);\n		int c2 = n - res[0];\n		\n		System.out.println((long)c2 * (long)res[0] - n + 1);\n		\n	}\n	\n	public static void dfs(ArrayList<ArrayList<Integer>> arr, int v, int parent, int color, int[] res) {\n		if(color == 0) {\n			res[0]++;\n		}\n		\n		for(int w: arr.get(v)) {\n			if(w != parent) {\n				dfs(arr,w,v, 1 - color,res);\n			}\n		}\n	}\n}\n\n 	 	  									 	 		     		 	 	","dfs and similar,graphs,trees"
import java.util.Scanner;\npublic class el {\n	public static void main(String[] args) {\n		Scanner scanner=new Scanner(System.in);\n		int n=scanner.nextInt();\n		int x=scanner.nextInt();\n		int[] h=new int[101];\n		int r=0;\n		for(int i=0;i<n;i++) {\n			int mids=scanner.nextInt();\n			if(mids<x)r++;\n			if(mids==x)r--;\n		}\n		System.out.println(x-r);\n	}\n}\n		  		 			 	    	   	 		  	  	,"greedy,implementation"
import java.util.Scanner;\npublic class el {\n	public static void main(String[] args) {\n		Scanner scanner=new Scanner(System.in);\n		int n=scanner.nextInt();\n		int x=scanner.nextInt();\n		int[] h=new int[101];\n		for(int i=0;i<n;i++) {\n			h[scanner.nextInt()]=-1;\n		}\n		int r=0;\n		for(int i=0;i<x;i++) {\n			if(h[i]!=-1)r++;\n		}\n		if(h[x]==-1)r++;\n		System.out.println(r);\n	}\n}\n\n							    	    				 						  	,"greedy,implementation"
"import java.util.*;\n\npublic class MEX {\n    public static void main(String[]args){\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int x = in.nextInt();\n        int mn = 101,sum=0;\n        for(int i = 0; i < n; i++){\n            int t = in.nextInt();\n            if(t<x)sum++;\n            if(t==x)sum--;\n        }\n        System.out.println(x-sum);\n    }    \n}\n","greedy,implementation"
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class sample{\n    public static void main(String args[]){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), x = sc.nextInt();\n        int cnt = 0;\n        int ex = 0;\n        for(int i = 0; i < n; i++){\n            int a = sc.nextInt();\n            if(a < x) cnt++;\n            if(a == x) ex++;\n        }\n        System.out.println(x-cnt+ex);\n    }\n}","greedy,implementation"
"/*\n4\n1 5\n5 2\n3 7\n7 3\n\n1\n1 2\n\nFor any graph, the # of possible arrangements is 1 (not moving anything) plus the number of nodes that are not part of a cycle plus one (to account for the cycle if there is one, otherwise dont add one), if the connected component size is greater than 1\nMultiply all of these together\n\nIf it leads to an 'impossible cycle' where an employee wishes to sit in their own seat, cannot move any of the numbers in the connected component\n*/\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  public static int nE; //# of engineers\n  public static Node[] nodes; \n  public static int[] parent; \n  public static int[] edgeSize; \n  public static int[] nodeSize; \n  public static long mod = 1000000007;  \n  public static boolean[] used; \n  public static int find(int a){\n    if(parent[a] == a) return a;\n    parent[a] = find(parent[a]);\n    return parent[a];  \n  }\n  public static void union(int a, int b){\n    int finda = find(a);\n    int findb = find(b); \n    if(finda == findb) return; \n    if(nodeSize[finda] < nodeSize[findb]){\n      if(used[finda]) used[findb] = true; \n      edgeSize[findb] += edgeSize[finda];\n      nodeSize[findb] += nodeSize[finda];\n      parent[finda] = findb; \n    }\n    else{\n      if(used[findb]) used[finda] = true; //do not want any self loops\n      edgeSize[finda] += edgeSize[findb];\n      nodeSize[finda] += nodeSize[findb];\n      parent[findb] = finda; \n    }\n  }\n  public static void main(String[] args) throws IOException{\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n    nE = Integer.parseInt(br.readLine());\n    nodes = new Node[nE * 2];\n    parent = new int[nE * 2];\n    edgeSize = new int[nE * 2]; \n    nodeSize = new int[nE * 2];\n    used = new boolean[nE * 2];\n    for(int x = 0; x < nE * 2; x++){\n      nodes[x] = new Node(x, -1);\n      parent[x] = x; \n      nodeSize[x] = 1;\n    }\n\n    for(int y = 0; y < nE; y++){\n      StringTokenizer edge = new StringTokenizer(br.readLine());\n      int first = Integer.parseInt(edge.nextToken()) - 1;\n      int second = Integer.parseInt(edge.nextToken()) - 1;\n      if(first == second) used[find(first)] = true; \n      union(first, second);\n      nodes[first].connection = second;\n      edgeSize[find(first)]++; //# of edges\n    }\n\n    long ret = 1; \n\n    for(int y = 0; y < nE * 2; y++){\n      if(nodeSize[find(y)] > 1 && !used[find(y)]){\n        if(edgeSize[find(y)] == nodeSize[find(y)] - 1){\n          //System.out.println(find(y) + "" one "" + nodeSize[find(y)]);\n          ret = (ret * nodeSize[find(y)]) % mod;\n        }\n        else{\n          //System.out.println(find(y) + "" two"");\n          ret = (ret * 2) % mod;\n        }\n        used[find(y)] = true; \n      }\n    }\n\n    System.out.println(ret);\n\n    br.close();\n  }\n}\n\nclass Node{\n  int id; \n  int connection; //only one connection to each node  \n  public Node(int i, int c){\n    id = i;\n    connection = c; \n  }\n  public String toString(){\n    return id + "" "" + connection; \n  }\n}","combinatorics,dfs and similar,dsu,graphs,trees"
import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\npublic class Main {\n  static ArrayList<Integer> a[] = new ArrayList[200005];\n  \n  public static void main(String[] args) {\n    try {\n      MScanner in = new MScanner(System.in);\n\n      int n = in.nextInt();\n      for (int i = 0;i <= n * 2;++i) {\n        a[i] = new ArrayList<Integer>();\n      }\n      int []s = new int [2 * n];\n      int []out = new int [2 * n];\n      \n      for (int i = 0;i < n;++i) {\n        int a1 = in.nextInt() - 1;\n        int b1 = in.nextInt() - 1;\n        if (a1 == b1) {\n          s[a1] = 1;\n        } else {\n          a[a1].add(b1);\n          a[b1].add(a1);\n          out[a1] = 1;\n        }\n      }\n      int []u = new int[n * 2];\n      long ans = 1;\n      for (int i = 0;i < 2 * n;++i) {\n        if (u[i] == 1) continue;\n        int hs = 0;\n        int hc = 1;\n        int cnt = 0;\n        Queue<Integer> Q = new LinkedList<>();\n        Q.add(i);\n        u[i] = 1;\n        while (Q.size() > 0) {\n          int top = Q.poll();\n          if (s[top] == 1) hs = 1;\n          hc &= out[top];\n          cnt += 1;\n          for (int v:a[top]) {\n            if (u[v] == 1) continue;\n            Q.add(v);\n            u[v] = 1;\n          }\n        }\n        if (hs == 1) ans *= 1;\n        else if (hc == 0) ans *= cnt;\n        else ans *= 2;\n        ans = ans % 1000000007;\n      }\n\n      System.out.println(ans);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n  static class MScanner {\n    StringTokenizer st;\n    BufferedReader br;\n    public MScanner(InputStream system) {\n      br = new BufferedReader(new InputStreamReader(system));\n    }\n\n    public MScanner(String file) throws Exception {\n      br = new BufferedReader(new FileReader(file));\n    }\n\n    public String next() throws IOException {\n      while (st == null || !st.hasMoreTokens())\n        st = new StringTokenizer(br.readLine());\n      return st.nextToken();\n    }\n    public int[] takearr(int n) throws IOException {\n      int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n      return in;\n    }\n    public long[] takearrl(int n) throws IOException {\n      long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n      return in;\n    }\n    public Integer[] takearrobj(int n) throws IOException {\n      Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n      return in;\n    }\n    public Long[] takearrlobj(int n) throws IOException {\n      Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n      return in;\n    }\n    public String nextLine() throws IOException {\n      return br.readLine();\n    }\n\n    public int nextInt() throws IOException {\n      return Integer.parseInt(next());\n    }\n\n    public double nextDouble() throws IOException {\n      return Double.parseDouble(next());\n    }\n\n    public char nextChar() throws IOException {\n      return next().charAt(0);\n    }\n\n    public Long nextLong() throws IOException {\n      return Long.parseLong(next());\n    }\n\n    public boolean ready() throws IOException {\n      return br.ready();\n    }\n\n    public void waitForInput() throws InterruptedException {\n      Thread.sleep(3000);\n    }\n  }\n}\n,"combinatorics,dfs and similar,dsu,graphs,trees"
"\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\n/**\n * - Long/int - Draw stuff - Use comments - Drink Water - Reread Problem\n *\n * - package/pw.close\n *\n * @author timothy\n */\npublic class randoms {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(br.readLine());\n        //the graph is directed, BUT we don't care because\n        //Two types of CCs: cycle, no cycle\n        //cycle:\n        //edges = nodes\n        //contribution: 2\n        //doesnt matter edge type\n        \n        //no cycle:\n        //edges +1 = nodes (the last edge connects to a non-occupied)\n        //tree, doesnt matter edge type because there is exactly 1 root location where everything pulls to\n        DSU dsu = new DSU(2*N);\n        List<Integer> occs = new ArrayList();\n        int times = 0;\n        /*\n        we cant completely ignore self loops if something else links to it\n        */\n        for(int i = 0; i<N; i++){\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int u = Integer.parseInt(st.nextToken())-1;\n            occs.add(u);\n            \n            int v = Integer.parseInt(st.nextToken())-1;\n            occs.add(v);\n            if(u == v)times++;\n            dsu.union(u, v);\n        }\n        long ret = 1;\n        Set<Integer> ccs = new HashSet();\n        for(int i : occs){\n            int v = dsu.find(i);\n            if(ccs.contains(v)) continue;\n            \n            if(dsu.cycle[v]){\n                if(times == 0){\n                    ret *= 2;\n                }else{\n                    times--;\n                }\n            }else{\n                ret *= dsu.size[v];\n            }\n            ret %= mod;\n            ccs.add(v);\n        }\n        System.out.println(ret);\n    }\n    static int mod = 1_000_000_007;\n    static class DSU {\n\n        public int[] parent;\n        public int[] size;\n        public boolean[] cycle;\n        \n        public DSU(int n) {\n            parent = new int[n];\n            size = new int[n];\n            cycle = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                size[i] = 1;\n            }\n        }\n        \n        public int find(int u) {\n            if (u != parent[u]) {\n                parent[u] = find(parent[u]);\n            }\n            return parent[u];\n        }\n        \n        public void union(int u, int v) {\n            int ru = find(u);\n            int rv = find(v);\n            \n            if (ru == rv) {\n                cycle[ru] = true;\n                return;\n            }\n            \n            if (size[ru] > size[rv]) {\n                parent[rv] = ru;\n                size[ru] += size[rv];\n                cycle[ru] = cycle[ru] || cycle[rv];\n            } else {\n                parent[ru] = rv;\n                size[rv] += size[ru];\n                cycle[rv] = cycle[ru] || cycle[rv];\n            }\n        }\n    }\n}\n\n","combinatorics,dfs and similar,dsu,graphs,trees"
import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\npublic class Main {\n  static ArrayList<Integer> a[] = new ArrayList[200005];\n  \n  public static void main(String[] args) {\n    try {\n      MScanner in = new MScanner(System.in);\n\n      int n = in.nextInt();\n      for (int i = 0;i <= n * 2;++i) {\n        a[i] = new ArrayList<Integer>();\n      }\n      int []s = new int [2 * n];\n      int []out = new int [2 * n];\n      \n      for (int i = 0;i < n;++i) {\n        int a1 = in.nextInt() - 1;\n        int b1 = in.nextInt() - 1;\n        if (a1 == b1) {\n          s[a1] = 1;\n        } else {\n          a[a1].add(b1);\n          a[b1].add(a1);\n          out[a1] = 1;\n        }\n      }\n      int []u = new int[n * 2];\n      long ans = 1;\n      for (int i = 0;i < 2 * n;++i) {\n        if (u[i] == 1) continue;\n        int hs = 0;\n        int hc = 1;\n        int cnt = 0;\n        Queue<Integer> Q = new LinkedList<>();\n        Q.add(i);\n        u[i] = 1;\n        while (Q.size() > 0) {\n          int top = Q.poll();\n          if (s[top] == 1) hs = 1;\n          hc &= out[top];\n          cnt += 1;\n          for (int v:a[top]) {\n            if (u[v] == 1) continue;\n            Q.add(v);\n            u[v] = 1;\n          }\n        }\n        if (hs == 1) ans *= 1;\n        else if (hc == 0) ans *= cnt;\n        else ans *= 2;\n        ans = ans % 1000000007;\n      }\n\n      System.out.println(ans);\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n  }\n  static class MScanner {\n    StringTokenizer st;\n    BufferedReader br;\n    public MScanner(InputStream system) {\n      br = new BufferedReader(new InputStreamReader(system));\n    }\n\n    public MScanner(String file) throws Exception {\n      br = new BufferedReader(new FileReader(file));\n    }\n\n    public String next() throws IOException {\n      while (st == null || !st.hasMoreTokens())\n        st = new StringTokenizer(br.readLine());\n      return st.nextToken();\n    }\n    public int[] takearr(int n) throws IOException {\n      int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n      return in;\n    }\n    public long[] takearrl(int n) throws IOException {\n      long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n      return in;\n    }\n    public Integer[] takearrobj(int n) throws IOException {\n      Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n      return in;\n    }\n    public Long[] takearrlobj(int n) throws IOException {\n      Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n      return in;\n    }\n    public String nextLine() throws IOException {\n      return br.readLine();\n    }\n\n    public int nextInt() throws IOException {\n      return Integer.parseInt(next());\n    }\n\n    public double nextDouble() throws IOException {\n      return Double.parseDouble(next());\n    }\n\n    public char nextChar() throws IOException {\n      return next().charAt(0);\n    }\n\n    public Long nextLong() throws IOException {\n      return Long.parseLong(next());\n    }\n\n    public boolean ready() throws IOException {\n      return br.ready();\n    }\n\n    public void waitForInput() throws InterruptedException {\n      Thread.sleep(3000);\n    }\n  }\n}\n,"combinatorics,dfs and similar,dsu,graphs,trees"
import java.util.*;\npublic class Main {\n\n    public static void main(String[] args) {\n        // write your code here\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int[] k = new int[110];\n        int[] f = new int[110];\n        for (int i = 1; i <= m; i++) {\n            k[i] = in.nextInt();\n            f[i] = in.nextInt();\n        }\n        int x = -1;\n        for (int i = 1; i <= 100; i++) {\n            int flag = 1;\n            for (int j = 1; j <= m; j++) {\n                if((k[j]+i-1)/i != f[j]){\n                    flag = 0;\n                    break;\n                }\n            }\n            if(flag == 1&&x != (n+i-1)/i) {\n                if (x == -1)\n                    x = (n + i - 1) / i;\n                else {\n                    System.out.println(-1);\n                    return;\n                }\n            }\n        }\n        System.out.println(x);\n    }\n}\n	   		 	 	 	 					 	 		 			   	,"brute force,implementation"
"\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\nimport java.util.jar.Attributes;\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int t = 0;\n            int[] a = new int[m];\n            int[] b = new int[m];\n            boolean p = true;\n            for(int i=0;i<m;i++){\n                a[i] = in.nextInt();\n                b[i] = in.nextInt();\n            }\n            for(int i=1;i<=100;i++){\n                p = true;\n                int x = n/i ;\n                if(n%i>0){\n                    x=x+1;\n                }\n                for(int j=0;j<m;j++){\n                    int height = a[j]/i;\n                    if(a[j]%i>0){\n                        height=height+1;\n                    }\n                    if(height!=b[j]){\n                        p = false;\n                        break;\n                    }\n                }\n                if(p&& t!=x){\n                    if(t == 0){\n                        t = x;\n                    }\n                    else{\n                        System.out.println(-1);\n                        return;\n                    }\n                }\n            }\n            System.out.println(t);\n        }\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n\n	 	 	   	 	  	 		 		    		","brute force,implementation"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\nimport java.util.jar.Attributes;\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            int tall = 0;\n            int a[] = new int[m];\n            int b[] = new int[m];\n            Boolean pass = true;\n            for(int i=0;i<m;i++){\n                a[i] = in.nextInt();\n                b[i] = in.nextInt();\n            }\n            for(int i=1;i<=100;i++){\n                pass = true;\n                int x = n/i ;\n                if(n%i>0){\n                    x=x+1;\n                }\n                for(int j=0;j<m;j++){\n                    int height = a[j]/i;\n                    if(a[j]%i>0){\n                        height=height+1;\n                    }\n                    if(height!=b[j]){\n                        pass = false;\n                        break;\n                    }\n                }\n                if(pass&& tall!=x){\n                    if(tall == 0){\n                        tall = x;\n                    }\n                    else{\n                        System.out.println(-1);\n                        return;\n                    }\n                }\n            }\n            System.out.println(tall);\n        }\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n		   						 	 	 			  		 		  			","brute force,implementation"
"import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main {\n    private static final long mod = (long) (1e9 + 7);\n\n    public static void solve() {\n        int n = in.nextInt();\n        int m = in.nextInt();\n\n        int l = 1;\n        int r = Integer.MAX_VALUE;\n\n        for (int i = 0; i < m; i++) {\n            int k = in.nextInt();\n            int f = in.nextInt();\n\n            l = Math.max(l, (k / f) + (k % f == 0 ? 0 : 1));\n\n            if (f > 1) {\n                r = Math.min(r, (k - 1) / (f - 1));\n            }\n        }\n\n        if ((n - 1) / l + 1 == (n - 1) / r + 1) {\n            out.println((n - 1) / l + 1);\n        } else {\n            out.println(-1);\n        }\n    }\n\n    public static InputReader in = new InputReader();\n    public static PrintWriter out;\n\n    public static void main(String[] args) {\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n\n    private static long pow(long a, long b) {\n        if (b == 0)\n            return 1L;\n\n        long val = pow(a, b / 2);\n\n        if (b % 2 == 0)\n            return val * val % mod;\n        else\n            return val * val % mod * a % mod;\n    }\n\n    private static class Pair<K, V> {\n        K first;\n        V second;\n\n        public Pair(K first, V second) {\n            this.first = first;\n            this.second = second;\n        }\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader() {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        /**\n         * When you call next(), that entire line will be skipped. No flushing buffers.\n         * Doesn't work when you want to scan the remaining line.\n         *\n         * @return entire line\n         */\n        public String nextLine() {\n            String str = """";\n            try {\n                str = reader.readLine();\n                tokenizer = null;\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return str;\n        }\n    }\n}","brute force,implementation"
"import java.util.*;\nimport java.io.*;\n\npublic class p853D \n{\n	static final int INF = (int)1e9;\n	public static void main(String[] args) throws IOException \n	{\n		BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		StringTokenizer st;\n		int size = Integer.parseInt(f.readLine());\n		if(size == 1)\n		{\n			out.println(f.readLine());\n			out.close();\n			return;\n		}\n		st = new StringTokenizer(f.readLine());\n		int[] a = new int[size];\n		for(int i = 0; i < size; i++)\n			a[i] = Integer.parseInt(st.nextToken()) / 100;\n		int[][] dp = new int[a.length + 1][31];\n		for(int[] temp : dp)\n			Arrays.fill(temp, INF);\n		dp[0][0] = 0;\n		for(int r = 1; r <= size; r++)\n		{\n			for(int c = 0; c <= 30; c++)\n			{\n				int bonus = a[r - 1] / 10;\n				if(c >= bonus)\n					dp[r][c] = Math.min(dp[r][c], dp[r - 1][c - bonus] + a[r - 1]);\n				for(int k = 1; k <= Math.min(a[r - 1], 30 - c); k++)\n					dp[r][c] = Math.min(dp[r][c], dp[r - 1][c + k] + a[r - 1] - k);\n			}\n		}\n//		for(int[] temp : dp)\n//			System.out.println(Arrays.toString(temp));\n		out.println(dp[size][0] * 100);\n		out.close();\n	}\n}","binary search,dp,greedy"
"import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Div1_433D {\n\n	public static void main(String[] args) throws IOException {\n		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		int nD = Integer.parseInt(reader.readLine());\n		StringTokenizer inputData = new StringTokenizer(reader.readLine());\n		int[] req = new int[nD];\n		for (int i = 0; i < nD; i++) {\n			req[i] = Integer.parseInt(inputData.nextToken()) / 100;\n		}\n\n		int[][] dp = new int[nD][36];\n		for (int i = 0; i < nD; i++) {\n			Arrays.fill(dp[i], Integer.MAX_VALUE);\n		}\n\n		dp[0][req[0] / 10] = req[0];\n		for (int i = 0; i < nD - 1; i++) {\n			for (int j = 0; j <= 35; j++) {\n				if (dp[i][j] != Integer.MAX_VALUE) {\n					if (j + req[i + 1] / 10 <= 35) {\n						dp[i + 1][j + req[i + 1] / 10] = Math.min(dp[i + 1][j + req[i + 1] / 10],\n								dp[i][j] + req[i + 1]);\n					}\n					int delta = Math.min(j, req[i + 1]);\n					dp[i + 1][j - delta] = Math.min(dp[i + 1][j - delta], dp[i][j] + req[i + 1] - delta);\n				}\n			}\n		}\n\n		int ans = Integer.MAX_VALUE;\n		for (int i = 0; i <= 35; i++) {\n			ans = Math.min(ans, dp[nD - 1][i]);\n		}\n		printer.println(ans * 100);\n		printer.close();\n	}\n}\n","binary search,dp,greedy"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF853D extends PrintWriter {\n	CF853D() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF853D o = new CF853D(); o.main(); o.flush();\n	}\n\n	void main() {\n		int n = sc.nextInt();\n		int[] aa = new int[n];\n		int[] pp = new int[n];\n		for (int i = 0; i < n; i++)\n			pp[i] = aa[i] = sc.nextInt();\n		for (int i = 1; i < n; i++)\n			pp[i] += pp[i - 1];\n		int[] ip = new int[n];\n		int[] iq = new int[n];\n		for (int i = 0, i_ = -1; i < n; i++) {\n			if (aa[i] == 1000)\n				i_ = i;\n			ip[i] = i_;\n		}\n		for (int i = n - 1, i_ = n; i >= 0; i--) {\n			if (aa[i] == 1000)\n				i_ = i;\n			iq[i] = i_;\n		}\n		int ans = n * 2000;\n		for (int i = 0; i < n; i++) {\n			int a, b, x, y;\n			x = pp[i];\n			a = x;\n			b = x / 10;\n			x = pp[n - 1] - pp[i]; y = Math.min(x, b);\n			a += x - y;\n			b -= y;\n			ans = Math.min(ans, a);\n			if (aa[i] == 2000) {\n				int i_ = ip[i];\n				if (i_ != -1) {\n					x = i_ == 0 ? 0 : pp[i_ - 1];\n					a = x;\n					b = x / 10;\n					x = aa[i_]; y = Math.min(x, b);\n					a += x - y;\n					b -= y;\n					x = pp[i] - pp[i_];\n					a += x;\n					b += x / 10;\n					x = pp[n - 1] - pp[i]; y = Math.min(x, b);\n					a += x - y;\n					b -= y;\n					ans = Math.min(ans, a);\n				}\n				i_ = iq[i];\n				if (i_ != n) {\n					x = pp[i];\n					a = x;\n					b = x / 10;\n					x = pp[i_ - 1] - pp[i]; y = Math.min(x, b);\n					a += x - y;\n					b -= y;\n					x = aa[i_];\n					a += x;\n					b += x / 10;\n					x = pp[n - 1] - pp[i_]; y = Math.min(x, b);\n					a += x - y;\n					b -= y;\n					ans = Math.min(ans, a);\n				}\n			}\n		}\n		println(ans);\n	}\n}\n","binary search,dp,greedy"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n	static BufferedReader reader;\n	static StringTokenizer tokenizer;\n	static PrintWriter writer;\n\n	static String nextToken() throws IOException {\n		while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n			tokenizer = new StringTokenizer(reader.readLine());\n		}\n		return tokenizer.nextToken();\n	}\n\n	static int nextInt() throws NumberFormatException, IOException {\n		return Integer.parseInt(nextToken());\n	}\n\n	public static void main(String[] args) throws IOException {\n		reader = new BufferedReader(new InputStreamReader(System.in));\n		writer = new PrintWriter(System.out);\n		banana();\n		reader.close();\n		writer.close();\n	}\n\n	static int n;\n	static int[] a;\n	static final int INF = 100000002;\n	static final int MX = 52;\n\n	static void banana() throws NumberFormatException, IOException {\n		int n = nextInt();\n		// long start = System.currentTimeMillis();\n		a = new int[n];\n		for (int i = 0; i < n; i++) {\n			a[i] = nextInt() / 100;\n			// a[i] = Math.random() < 0.5 ? 10 : 20;\n		}\n\n		int[][] dp = new int[n + 1][MX];\n		for (int i = 0; i <= n; i++) {\n			for (int j = 0; j < MX; j++) {\n				dp[i][j] = INF;\n			}\n		}\n		dp[0][0] = 0;\n\n		for (int i = 0; i < n; i++) {\n			int x = a[i];\n			for (int curr = 0; curr < MX; curr++) {\n				{\n					// cash only\n					int bonus = x / 10;\n					if (curr + bonus >= MX) {\n						break;\n					}\n					dp[i + 1][curr + bonus] = Math.min(dp[i + 1][curr + bonus], dp[i][curr] + x);\n				}\n				int sp = Math.min(curr, x);\n				for (; sp > 0; sp--) {\n					// use\n					int left = curr - sp;\n					int cand = dp[i][curr] + (x - sp);\n					if (dp[i + 1][left] > cand) {\n						dp[i + 1][left] = cand;\n					}\n				}\n			}\n		}\n\n		int ans = INF;\n		for (int curr = 0; curr < MX; curr++) {\n			ans = Math.min(ans, dp[n][curr]);\n		}\n		writer.println(ans * 100);\n		// writer.println(System.currentTimeMillis() - start);\n	}\n}","binary search,dp,greedy"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    static BufferedReader reader;\n    static StringTokenizer st;\n    private static final int MOD = 1000000007;\n    private static void setReader() {\n        reader = new BufferedReader(new InputStreamReader(System.in));\n    }\n    private static void updateST() throws IOException {\n        if (st==null || !st.hasMoreElements()) st = new StringTokenizer(reader.readLine());\n    }\n    private static int nextInt() throws IOException {\n        updateST();\n        return Integer.parseInt(st.nextToken());\n    }\n    private static int m;\n    public static int[] pow(int[] a, int n) {\n        int[] ans = new int[m];\n        ans[0] = 1;\n        while (n>0) {\n            if (n%2==1) ans = multiply(ans, a);\n            n/=2;\n            a = multiply(a, a);\n        }\n        return ans;\n    }\n    public static int[] multiply(int[] a, int[] b) {\n        int[] res = new int[m];\n        for (int i=0; i<m; i++) {\n            for (int j=0; j<m; j++) {\n                res[(i + j) % m]+=((a[i] * 1L * b[j]) % MOD);\n                res[(i + j) % m]%=MOD;\n            }\n        }\n        return res;\n    }\n    public static void main(String[] args) throws IOException {\n        setReader();\n        int n = nextInt(), l = nextInt();\n        m = nextInt();\n        int[] first = new int[m];\n        for (int i=0; i<n; i++) first[nextInt() % m]++;\n        int[] mid = new int[n];\n        int[] middle = new int[m];\n        for (int i=0; i<n; i++) {\n            mid[i] = nextInt();\n            middle[mid[i] % m]++;\n        }\n        int[] p = pow(middle, l-2);\n        int[] res = multiply(first, p);\n        int result = 0;\n        for (int i=0; i<n; i++) {\n            int x = (mid[i] + nextInt()) % m;\n            int rev = (m - x) % m;\n            result+=res[rev];\n            result%=MOD;\n        }\n        System.out.println(result);\n    }\n}","dp,matrices"
"import java.io.*;\nimport java.util.*;\n\npublic class B852 {\n\n	public static void main(String[] args) throws IOException {\n		IO io = new IO(System.in);\n\n		int n = io.nextInt();\n		int l = io.nextInt();\n		int m = io.nextInt();\n		long MOD = 1000000007;\n		\n		int[] d = new int[n];\n		long[] a = new long[m];\n		long[] b = new long[m];\n		int[] c = new int[n];\n		\n		for (int i = 0; i < n; i++) {\n			a[io.nextInt()%m]++;\n		}\n		for (int i = 0; i < n; i++) {\n			d[i] = io.nextInt();\n			b[d[i]%m]++;\n		}\n		for (int i = 0; i < n; i++) {\n			c[i] = io.nextInt();\n		}\n		\n		// Go to first layer\n		long[] res = a;\n\n		long[][] A = new long[m][m];\n		for (int i = 0; i < m; i++) {\n			for (int j = 0; j < m; j++) {\n				A[i][j] = b[(i-j+m)%m];\n			}\n		}\n		long[][] Apow = fme(A,l-2,MOD);\n		\n		res = mv(Apow,res,MOD);\n		\n		long ans = 0;\n		\n		// res[i] is the nr of options for path length i to get to before-last layer\n		for (int i = 0; i < n; i++) {\n			int last_part = (d[i] + c[i] + m) % m;\n			ans = (ans + res[(m-last_part)%m] + MOD) % MOD;\n		}\n		\n		io.println(ans);\n		\n		io.close();\n	}\n	\n	public static long[] mv(long[][] A, long[] x, long mod) {\n		int n = x.length;\n		long[] res = new long[n];\n		for (int i = 0; i < res.length; i++) {\n			for (int j = 0; j < n; j++) {\n				res[i] = (res[i] + A[i][j]*x[j] + mod) % mod;\n			}\n		}\n		return res;\n	}\n	\n	public static long[][] fme(long[][] a, long n, long mod) {\n		int l = a.length;\n		long[][] res = new long[l][l];\n		for (int i = 0; i < l; i++) {\n			res[i][i] = 1;\n		}\n		\n		String bin = Long.toBinaryString(n);\n		int exp = 0;\n		while (Math.pow(2, exp) <= n) {\n			if (bin.charAt(bin.length()-1-exp) == '1') {\n				res = mult(res, a, mod);\n			}\n			a = mult(a,a,mod);\n			exp++;\n		}\n		\n		return res;\n	}\n	\n	// Multiply 2 matrices\n	public static long[][] mult(long[][] a, long[][] b, long mod) {\n		int k = a.length;\n		int n = a[0].length;\n		int m = b[0].length;\n		long[][] res = new long[k][m];\n		for (int i = 0; i < k; i++) {\n			for (int j = 0; j < m; j++) {\n				for (int j2 = 0; j2 < n; j2++) {\n					res[i][j] = (res[i][j] + (a[i][j2] * b[j2][j])) % mod; \n				}\n			}\n		}\n		return res;\n	}\n\n	static class IO extends PrintWriter {\n		static BufferedReader r;\n		static StringTokenizer t;\n\n		public IO(InputStream i) {\n			super(new BufferedOutputStream(System.out));\n			r = new BufferedReader(new InputStreamReader(i));\n			t = new StringTokenizer("""");\n		}\n\n		public String next() throws IOException {\n			while (!t.hasMoreTokens()) {\n				t = new StringTokenizer(r.readLine());\n			}\n			return t.nextToken();\n		}\n\n		public int nextInt() throws IOException{\n			return Integer.parseInt(next());\n		}\n\n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n\n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n	}\n}","dp,matrices"
"import java.io.*;\nimport java.util.*;\npublic class test\n{\n    public static void main(String args[])\n    {\n        //System.out.println(""Welcome"");\n        inputs in=new inputs(System.in);\n        int n=in.nextInt(),l=in.nextInt(),m=in.nextInt();\n        int c1[]=new int[m];\n        int c2[]=new int[n];\n        long c3[]=new long[n];\n        long c4[]=new long[m];\n        \n        for(int i=0;i<n;i++)\n        {\n            c1[in.nextInt()%m]++;\n        }\n        for(int i=0;i<n;i++)\n        {\n            c2[i]=in.nextInt();\n        }\n        for(int i=0;i<n;i++)\n        {\n            c3[i]=(long)c2[i]+in.nextInt();\n        }\n        \n        long dp[][]=new long[23][m];\n        long ans[];\n        int M=1000000007;\n        \n        TreeSet<Integer> ts=new TreeSet<Integer>();\n        HashMap<Integer,Integer> hm=new HashMap<Integer,Integer>();\n        for(int i=0;i<=23;i++)\n        {\n           ts.add((int)Math.pow(2,i)); \n           hm.put((int)Math.pow(2,i),i);\n        }\n        \n        for(int i=0;i<n;i++)\n        {\n           dp[0][c2[i]%m]++; \n           c4[(int)(c3[i]%m)]++;\n        }\n        \n        if(l==2)\n        {\n            long ans1[]=new long[m];\n            for(int j=0;j<m;j++)\n               for(int k=0;k<m;k++)\n                   { ans1[(j+k)%m]+=(c1[j]*c4[k])%M;\n                      ans1[(j+k)%m]%=M; \n                    }\n                    \n            out(""""+ans1[0]);\n            return;\n        }\n        \n        l=l-2;\n        int bigpval=ts.floor(l);\n        int bigp=hm.get(bigpval);\n        l=l-bigpval;\n               \n        for(int i=1;i<=bigp;i++)\n        {\n           for(int j=0;j<m;j++)\n               for(int k=0;k<m;k++)\n                   { dp[i][(j+k)%m]+=(dp[i-1][j]*dp[i-1][k])%M;\n                      dp[i][(j+k)%m]%=M; \n                    }\n        }\n        \n        ans=dp[bigp];\n        \n        while(l>0)\n        {\n            int pval=ts.floor(l);\n            int p=hm.get(pval);\n            l=l-pval;\n            \n            long temp[]=new long[m];\n            for(int j=0;j<m;j++)\n               for(int k=0;k<m;k++)\n                   { temp[(j+k)%m]+=(ans[j]*dp[p][k])%M;\n                      temp[(j+k)%m]%=M; \n                    }\n                    \n            ans=temp;        \n        }\n        \n        long temp[]=new long[m];\n            for(int j=0;j<m;j++)\n               for(int k=0;k<m;k++)\n                   { temp[(j+k)%m]+=(ans[j]*c1[k])%M;\n                      temp[(j+k)%m]%=M; \n                    }\n                    \n            ans=temp; \n           \n            temp=new long[m];\n            for(int j=0;j<m;j++)\n               for(int k=0;k<m;k++)\n                   { temp[(j+k)%m]+=(ans[j]*c4[k])%M;\n                      temp[(j+k)%m]%=M; \n                    }\n                    \n            ans=temp; \n            out(""""+ans[0]);\n            \n    }\n    \n    static void out(String s)\n    {\n        System.out.println(s);\n    }\n}\n\nclass inputs\n{\n    public BufferedReader reader;\n    public StringTokenizer token;\n    \n    inputs(InputStream str)\n    {\n        reader=new BufferedReader(new InputStreamReader(str));\n        token=null;\n    }\n    \n    int nextInt()\n    {\n        while(token==null||!token.hasMoreTokens())\n        {\n            try { token=new StringTokenizer(reader.readLine());   }\n            catch(IOException e){  throw new RuntimeException(e); }\n        }\n        return Integer.parseInt(token.nextToken());\n    }\n    \n    String next()\n    {\n        while(token==null||!token.hasMoreTokens())\n        {\n            try { token=new StringTokenizer(reader.readLine());   }\n            catch(IOException e){  throw new RuntimeException(e); }\n        }\n        return token.nextToken();\n    }\n    \n}","dp,matrices"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        BNeuralNetworkCountry solver = new BNeuralNetworkCountry();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BNeuralNetworkCountry {\n        public int MODULO = (int) (1e9 + 7);\n        int n;\n        int m;\n        int L;\n\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            n = in.nextInt();\n            L = in.nextInt();\n            m = in.nextInt();\n\n            int[] first = new int[m];\n            int[] last = new int[n];\n            int[] middle = new int[n];\n            int[] v = new int[m];\n            for (int i = 0; i < n; ++i) {\n                first[in.nextInt() % m]++;\n            }\n            for (int i = 0; i < n; ++i) {\n                int idx = in.nextInt() % m;\n                ++v[idx];\n                middle[i] = idx;\n            }\n            for (int i = 0; i < n; ++i) {\n                last[i] = in.nextInt() % m;\n            }\n            int[] ret = multiply(first, power(v, L - 2));\n            long ans = 0;\n            for (int i = 0; i < n; ++i) {\n                int cur = (middle[i] + last[i]) % m;\n                int need = (m - cur) % m;\n                ans += ret[need];\n                ans %= MODULO;\n            }\n            out.println(ans);\n        }\n\n        private int[] power(int[] v, int times) {\n            int[] ans = new int[m];\n            ans[0] = 1;\n            while (times != 0) {\n                if (times % 2 == 1) {\n                    ans = multiply(ans, v);\n                }\n                v = multiply(v, v);\n                times >>= 1;\n            }\n            return ans;\n        }\n\n        private int[] multiply(int[] a, int[] b) {\n            int[] c = new int[m];\n            for (int i = 0; i < m; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    c[(i + j) % m] += a[i] * 1L * b[j] % MODULO;\n                    c[(i + j) % m] %= MODULO;\n                }\n            }\n            return c;\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n        }\n\n    }\n}\n\n","dp,matrices"
"// practice with kaiboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF845B extends PrintWriter {\n	CF845B() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF845B o = new CF845B(); o.main(); o.flush();\n	}\n\n	void main() {\n		byte[] cc = sc.next().getBytes();\n		int a_ = cc[0] - '0';\n		int b_ = cc[1] - '0';\n		int c_ = cc[2] - '0';\n		int d_ = cc[3] - '0';\n		int e_ = cc[4] - '0';\n		int f_ = cc[5] - '0';\n		int ans = 6;\n		for (int a = 0; a < 10; a++)\n			for (int b = 0; b < 10; b++)\n				for (int c = 0; c < 10; c++)\n					for (int d = 0; d < 10; d++)\n						for (int e = 0; e < 10; e++) {\n							int f = a + b + c - d - e;\n							if (0 <= f && f < 10) {\n								int k = 0;\n								if (a != a_)\n									k++;\n								if (b != b_)\n									k++;\n								if (c != c_)\n									k++;\n								if (d != d_)\n									k++;\n								if (e != e_)\n									k++;\n								if (f != f_)\n									k++;\n								ans = Math.min(ans, k);\n							}\n						}\n		println(ans);\n	}\n}\n","brute force,greedy,implementation"
"import java.io.*;\nimport java.util.*;\nimport java.lang.*;\n\npublic class Rextester{    \n    static boolean isLucky(int i){\n        String s = Integer.toString(i);\n        while(s.length()<6){\n            s = '0'+s;\n        }\n        int x=0,y=0;\n        for(int z=0;z<3;z++){\n            x+=s.charAt(z)-'0';\n        }\n        for(int z=3;z<6;z++){\n            y+=s.charAt(z)-'0';\n        }\n        return x==y;\n    }\n    static int getDiff(String a,String b){\n        while(a.length()<6){\n            a='0'+a;\n        }\n        int count = 0;\n        for(int i=0;i<6;i++){\n            if(a.charAt(i)!=b.charAt(i)){\n                count++;\n            }\n        }\n        return count;\n    }\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String n = br.readLine();\n        int min = 3;\n        for(int i=0;i<(int)Math.pow(10,7);i++){\n            if(isLucky(i)){\n                min = Math.min(min,getDiff(Integer.toString(i),n));\n            }\n        }\n        System.out.println(min);\n    }\n}","brute force,greedy,implementation"
"\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class duels {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n        \n        String line = br.readLine();\n        int a = 0;\n        //for a\n        List<Integer> less = new ArrayList();\n        List<Integer> more = new ArrayList();\n        for(int i = 0; i<line.length(); i++){\n            int c= line.charAt(i) - '0';\n            if(i < 3){\n                a += c;\n                more.add(9 - c);\n                less.add(c);\n            }else{\n                a -= c;\n                less.add(9 - c);\n                more.add(c);\n            }\n        }\n       \n        int i = 0;\n        if(a < 0){\n            Collections.sort(more, Collections.reverseOrder());\n            for(; i<more.size() && a < 0; i++){\n                a += more.get(i);\n            }\n        }else{\n            Collections.sort(less, Collections.reverseOrder());\n            for(; i<less.size() && a > 0; i++){\n                a -= less.get(i);\n            }\n        }\n        pw.println(i);\n        pw.close();\n    }\n}\n","brute force,greedy,implementation"
"import java.util.*;\n\npublic class LubaAndTheTicket\n{\n	public static void main(String[] args) \n	{\n		Scanner scanner = new Scanner(System.in);\n		String digit = scanner.next();\n		int d1, d2, d3, d4, d5, d6;\n		d1 = Character.getNumericValue(digit.charAt(0));\n		d2 = Character.getNumericValue(digit.charAt(1));\n		d3 = Character.getNumericValue(digit.charAt(2));\n		d4 = Character.getNumericValue(digit.charAt(3));\n		d5 = Character.getNumericValue(digit.charAt(4));\n		d6 = Character.getNumericValue(digit.charAt(5));\n		// Sort d1, d2, d3\n		if (d2 < d1)\n		{\n			int t = d1;\n			d1 = d2;\n			d2 = t;\n		}\n		if (d3 < d2)\n		{\n			int t = d3;\n			d3 = d2;\n			d2 = t;\n		}\n		if (d2 < d1)\n		{\n			int t = d1;\n			d1 = d2;\n			d2 = t;\n		}\n\n		// Sort d4, d5, d6\n		if (d5 < d4)\n		{\n			int t = d5;\n			d5 = d4;\n			d4 = t;\n		}\n		if (d6 < d5)\n		{\n			int t = d6;\n			d6 = d5;\n			d5 = t;\n		}\n		if (d5 < d4)\n		{\n			int t = d4;\n			d4 = d5;\n			d5 = t;\n		}\n\n		int sumLeft = d1 + d2 + d3;\n		int sumRight = d4 + d5 + d6;\n		int dif = sumRight - sumLeft;\n		int ans;\n		if (dif == 0)\n			ans = 0;\n		else if (dif > 0)\n		{\n			ans = Math.min(calMinLeft(d1, d2, d3, dif), calMinRight(d4, d5, d6, dif));\n			if (ans == 3 && 9 - d1 + d6 >= dif)\n				ans = 2;\n		}\n		else\n		{\n			dif *= -1;\n			ans = Math.min(calMinRight(d1, d2, d3, dif), calMinLeft(d4, d5, d6, dif));\n			if (ans == 3 && 9 - d4 + d3 >= dif)\n				ans = 2;\n		}\n		System.out.print(ans);\n	}\n\n	static int calMinLeft(int d1, int d2, int d3, int dif)\n	{\n		if (dif + d1 <= 9)\n			return 1;\n		if (dif + d1 + d2 <= 18)\n			return 2;\n		return 3;\n	}\n\n	static int calMinRight(int d1, int d2, int d3, int dif)\n	{\n		if (d3 - dif >= 0)\n			return 1;\n		if (d2 + d3 - dif >= 0)\n			return 2;\n		return 3;\n	}\n}","brute force,greedy,implementation"
"import java.io.*;\nimport java.util.*;\n\n/*\n7\n6 2 3 4 1 3 5\n1 2\n2 3\n2 4\n1 5\n5 6 \n6 7\n*/\npublic class Main {\n	static FastReader sc=null;\n\n	\n	public static void main(String[] args) {\n		sc=new FastReader();\n		PrintWriter out=new PrintWriter(System.out);\n		int n=sc.nextInt();\n		int a[]=sc.readArray(n);\n		Node nodes[]=new Node[n];\n		for(int i=0;i<n;i++)nodes[i]=new Node(i,a[i]);\n		for(int i=0;i+1<n;i++) {\n			int v=sc.nextInt()-1,w=sc.nextInt()-1;\n			nodes[v].adj.add(nodes[w]);\n			nodes[w].adj.add(nodes[v]);\n		}\n		bfs(nodes);\n		for(Node nn:nodes)out.print(Math.max(nn.gcd,nn.ans)+"" "");\n		out.println();\n		out.close();\n//		for(Node nn:nodes)System.out.print(nn.dist+"" "");\n//		System.out.println();\n		\n		\n		\n		\n	}\n	static class Node{\n		int val=0;\n		int id,gcd,dist=-1;\n		int ans=0;\n		Set<Integer> gcdUsing=new HashSet<>();\n		ArrayList<Node> adj=new ArrayList<>();\n		Node(int id,int val){\n			this.id=id;\n			this.val=val;\n			gcd=val;\n		}\n		\n	}\n	static void bfs(Node nodes[]) {\n		ArrayDeque<Node> bfs=new ArrayDeque<>();\n		bfs.add(nodes[0]);\n		nodes[0].gcdUsing.add(0);\n		nodes[0].dist=0;\n		while(!bfs.isEmpty()) {\n			Node q=bfs.remove();\n			for(Node nn:q.adj) {\n				if(nn.dist==-1) {\n					nn.dist=q.dist+1;\n					bfs.add(nn);\n					nn.ans=q.gcd;\n					for(int e:q.gcdUsing) {\n						int g=gcd(e,nn.val);\n						nn.ans=Math.max(gcd(nn.val,e), nn.ans);\n						nn.gcdUsing.add(g);\n					}\n					nn.gcdUsing.add(q.gcd);\n					nn.gcd=gcd(q.gcd,nn.val);\n				}\n			}\n		}\n	}\n	\n	static int gcd(int a,int b) {\n		if(b==0)return a;\n		else return gcd(b,a%b);\n	}\n	\n	\n	\n	\n	static int[] ruffleSort(int a[]) {\n		ArrayList<Integer> al=new ArrayList<>();\n		for(int i:a)al.add(i);\n		Collections.sort(al);\n		for(int i=0;i<a.length;i++)a[i]=al.get(i);\n		return a;\n	}\n		\n	static int[] reverse(int a[]) {\n		ArrayList<Integer> al=new ArrayList<>();\n		for(int i:a)al.add(i);\n		Collections.sort(al,Collections.reverseOrder());\n		for(int i=0;i<a.length;i++)a[i]=al.get(i);\n		return a;\n	}\n		\n	static void print(int a[]) {\n		for(int e:a) {\n			System.out.print(e+"" "");\n		}\n		System.out.println();\n	}\n	\n	static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = """"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n        int[] readArray(int n) {\n    		int a[]=new int [n];\n    		for(int i=0;i<n;i++) {\n    			a[i]=sc.nextInt();\n    		}\n    		return a;\n    	}\n    } \n}","dfs and similar,graphs,math,number theory,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class C842 {\n\n	static int[] ans;\n	static ArrayList<Integer>[] g;\n	static int[] a;\n\n	public static void main(String[] args) throws IOException {\n		IO io = new IO(System.in);\n\n		int n = io.nextInt();\n		a = new int[n];\n		for (int i = 0; i < a.length; i++) {\n			a[i] = io.nextInt();\n		}\n\n		g = new ArrayList[n];\n		for (int i = 0; i < g.length; i++) {\n			g[i] = new ArrayList<>();\n		}\n\n		for (int i = 0; i < n - 1; i++) {\n			int x = io.nextInt() - 1;\n			int y = io.nextInt() - 1;\n			g[x].add(y);\n			g[y].add(x);\n		}\n\n		ans = new int[n];\n		Arrays.fill(ans, 1);\n		\n		dfs(0, -1, 0, new TreeSet<>());\n		ans[0]=a[0];\n			\n		for (int i = 0; i < n; i++) {\n			io.print(ans[i] + "" "");\n		}\n\n		io.close();\n	}\n\n	static void dfs(int v, int prev, int use_all, TreeSet<Integer> set) {\n		TreeSet<Integer> next = new TreeSet<>();\n		for (int x : set) {\n			next.add(gcd(a[v], x));\n		}\n		next.add(use_all);\n		ans[v] = next.last();\n		int next_use_all = gcd(a[v], use_all);\n\n		for (int u : g[v]) {\n			if (u != prev) {\n				dfs(u, v, next_use_all, next);\n			}\n		}\n	}\n\n	static int gcd(int p, int q) {\n		return q == 0 ? Math.abs(p) : gcd(q, p % q);\n	}\n\n	static class IO extends PrintWriter {\n		static BufferedReader r;\n		static StringTokenizer t;\n\n		public IO(InputStream i) {\n			super(new BufferedOutputStream(System.out));\n			r = new BufferedReader(new InputStreamReader(i));\n			t = new StringTokenizer("""");\n		}\n\n		public String next() throws IOException {\n			while (!t.hasMoreTokens()) {\n				t = new StringTokenizer(r.readLine());\n			}\n			return t.nextToken();\n		}\n\n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n\n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n	}\n}","dfs and similar,graphs,math,number theory,trees"
"import java.util.*;\nimport java.io.*;\n\npublic class Main {\n	public static void main(String args[]) {new Main().run();}\n\n	FastReader in = new FastReader();\n	PrintWriter out = new PrintWriter(System.out);\n	void run(){\n		work();\n		out.flush();\n	}\n	long mod=1000000007;\n	long gcd(long a,long b) {\n		return a==0?b:b>=a?gcd(b%a,a):gcd(b,a);\n	}\n	ArrayList<Integer>[] graph;\n	int[] ret;\n	int[] A;\n	Set<Integer>[] dp;\n	void work() {\n		int n=in.nextInt();\n		A=new int[n];\n		for(int i=0;i<n;i++) {\n			A[i]=in.nextInt();\n		}\n		ret=new int[n];\n		graph=(ArrayList<Integer>[])new ArrayList[n];\n		dp=(Set<Integer>[])new Set[n+1];\n		for(int i=0;i<=n;i++) {\n			dp[i]=new HashSet<>();\n		}\n		for(int i=0;i<n;i++) {\n			graph[i]=new ArrayList<>();\n		}\n		for(int i=0;i<n-1;i++) {\n			int s=in.nextInt()-1,e=in.nextInt()-1;\n			graph[s].add(e);\n			graph[e].add(s);\n		}\n		dp[0].add(0);\n		dfs(0,new boolean[n],-1,0);\n		for(int i=0;i<n;i++) {\n			out.print(ret[i]+"" "");\n		}\n	}\n	private void dfs(int node, boolean[] vis,int pre,int cur) {\n		vis[node]=true;\n		int max=cur;\n		dp[node+1].add(cur);\n		cur=(int)gcd(cur,A[node]);\n		for(int k:dp[pre+1]) {\n			int b=(int)gcd(k,A[node]);\n			dp[node+1].add(b);\n			max=Math.max(max, b);\n		}\n		ret[node]=max;\n		for(int nn:graph[node]) {\n			if(!vis[nn]) {\n				dfs(nn,vis,node,cur);\n			}\n		}\n	}\n}	\n\n\n\nclass FastReader\n{\n	BufferedReader br;\n	StringTokenizer st;\n\n	public FastReader()\n	{\n		br=new BufferedReader(new InputStreamReader(System.in));\n	}\n	\n	\n	public String next() \n	{\n		if(st==null || !st.hasMoreElements())\n		{\n			try {\n				st = new StringTokenizer(br.readLine());\n			} catch (IOException e) {\n				e.printStackTrace();\n			}\n		}\n		return st.nextToken();\n	}\n\n	public int nextInt() \n	{\n		return Integer.parseInt(next());\n	}\n\n	public long nextLong()\n	{\n		return Long.parseLong(next());\n	}\n}","dfs and similar,graphs,math,number theory,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class C842 {\n\n	static int[] ans;\n	static ArrayList<Integer>[] g;\n	static int[] a;\n\n	public static void main(String[] args) throws IOException {\n		IO io = new IO(System.in);\n\n		int n = io.nextInt();\n		a = new int[n];\n		for (int i = 0; i < a.length; i++) {\n			a[i] = io.nextInt();\n		}\n\n		g = new ArrayList[n];\n		for (int i = 0; i < g.length; i++) {\n			g[i] = new ArrayList<>();\n		}\n\n		for (int i = 0; i < n - 1; i++) {\n			int x = io.nextInt() - 1;\n			int y = io.nextInt() - 1;\n			g[x].add(y);\n			g[y].add(x);\n		}\n\n		ans = new int[n];\n		Arrays.fill(ans, 1);\n		\n		dfs(0, -1, 0, new TreeSet<>());\n		ans[0]=a[0];\n			\n		for (int i = 0; i < n; i++) {\n			io.print(ans[i] + "" "");\n		}\n\n		io.close();\n	}\n\n	static void dfs(int v, int prev, int use_all, TreeSet<Integer> set) {\n		TreeSet<Integer> next = new TreeSet<>();\n		for (int x : set) {\n			next.add(gcd(a[v], x));\n		}\n		next.add(use_all);\n		ans[v] = next.last();\n		int next_use_all = gcd(a[v], use_all);\n\n		for (int u : g[v]) {\n			if (u != prev) {\n				dfs(u, v, next_use_all, next);\n			}\n		}\n	}\n\n	static int gcd(int p, int q) {\n		return q == 0 ? Math.abs(p) : gcd(q, p % q);\n	}\n\n	static class IO extends PrintWriter {\n		static BufferedReader r;\n		static StringTokenizer t;\n\n		public IO(InputStream i) {\n			super(new BufferedOutputStream(System.out));\n			r = new BufferedReader(new InputStreamReader(i));\n			t = new StringTokenizer("""");\n		}\n\n		public String next() throws IOException {\n			while (!t.hasMoreTokens()) {\n				t = new StringTokenizer(r.readLine());\n			}\n			return t.nextToken();\n		}\n\n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n\n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n	}\n}","dfs and similar,graphs,math,number theory,trees"
"import java.util.Scanner;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Arrays;\nimport java.io.IOException;\n\npublic class Main {\n	public static Scanner in = new Scanner(System.in);\n	public static void main(String[] args) throws IOException {\n		int n = in.nextInt();\n		List<Integer> a = new ArrayList<>();\n		List<Integer> b = new ArrayList<>();\n		List<Integer> c = new ArrayList<>();\n		List<Integer> d = Arrays.asList(new Integer[n]);\n		for (int i = 0; i < n; i++) a.add(in.nextInt());\n		for (int i = 0; i < n; i++) b.add(in.nextInt());\n		for (int i = 0; i < n; i++) c.add(i);\n		Collections.sort(a, Collections.reverseOrder());\n		Collections.sort(c, new Comparator<Integer>() {\n								public int compare(Integer x, Integer y) {\n									return b.get(x) - b.get(y);\n								}\n							});\n		for (int i = 0; i < n; i++) d.set(c.get(i), a.get(i));\n		for (int it : d) System.out.print(it + "" "");\n	}\n}\n","combinatorics,greedy,math,number theory,sortings"
"/* package whatever; // don't place package name! */\nimport java.util.Scanner;\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be ""Main"" only if the class is public. */\npublic class Ideone\n{\n	public static void main (String[] args) \n	{\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int[] a = new int[n];\n		ppair[] b = new ppair[n];\n		int[] ans = new int[n];\n		\n		for(int i=0;i<n;i++) a[i] = sc.nextInt();\n		for(int i=0;i<n;i++)\n		{\n			b[i] = new ppair(sc.nextInt(),i) ;\n		}\n		Arrays.sort(a);\n		Arrays.sort(b,new Comparator<ppair>(){\n            public int compare(ppair n1,ppair n2)\n            {\n                if(n1.first>n2.first)\n                    return -1;\n                if(n1.first<n2.first)\n                    return 1;\n                return 0;\n            }\n        });\n		for(int i=0;i<n;i++)\n		{\n		//	System.out.print(b[i].first + "" "" + b[i].second);\n			//System.out.println();\n			ans[b[i].second] = a[i];\n		}\n		//System.out.println();\n		\n		\n		for(int i=0;i<n;i++) System.out.print(ans[i] + "" "");\n		\n	}\n}\n\nclass ppair\n{\n	public int first,second; \n	public ppair(int a,int b)\n	{\n		first = a;\n		second = b;\n	}\n}","combinatorics,greedy,math,number theory,sortings"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nimport static java.lang.Double.parseDouble;\nimport static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.in;\nimport static java.lang.System.out;\n\npublic class SolutionA extends Thread {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                                            InputStreamReader(in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return parseInt(next());\n        }\n\n        long nextLong() {\n            return parseLong(next());\n        }\n\n        double nextDouble() {\n            return parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    private static final FastReader scanner = new FastReader();\n    private static final PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        solve();\n        out.close();\n    }\n\n    static class Pair implements Comparable<Pair> {\n        int a;\n        int b;\n\n        public Pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public int compareTo(Pair o) {\n            return this.a - o.a;\n        }\n    }\n    \n\n    private static void solve() {\n        int m = scanner.nextInt();\n        Integer[] a = new Integer[m];\n        for (int i = 0; i < m; i++) {\n            a[i] = scanner.nextInt();\n        }\n        Arrays.sort(a);\n\n        Queue<Pair> prio = new PriorityQueue<>();\n        int[] b = new int[m];\n        for (int i = 0; i < m; i++) {\n            b[i] = scanner.nextInt();\n            prio.add(new Pair(b[i], i));\n        }\n\n        int[] output = new int[m];\n        for (int i = m - 1; i>= 0; i--) {\n            Pair p = prio.poll();\n            output[p.b] = a[i];\n        }\n\n        out.println(Arrays.stream(output).mapToObj(String::valueOf).collect(Collectors.joining("" "")));\n    }\n}","combinatorics,greedy,math,number theory,sortings"
"import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n \nimport static java.lang.Math.*;\n \npublic class Cf182 implements Runnable \n{\n	static class InputReader \n	{\n		private InputStream stream;\n		private byte[] buf = new byte[1024];\n		private int curChar;\n		private int numChars;\n		private SpaceCharFilter filter;\n		private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		public InputReader(InputStream stream) \n		{\n			this.stream = stream;\n		}\n		\n		public int read()\n		{\n			if (numChars==-1) \n				throw new InputMismatchException();\n            \n			if (curChar >= numChars) \n			{\n				curChar = 0;\n				try\n				{\n					numChars = stream.read(buf);\n				}\n				catch (IOException e)\n				{\n					throw new InputMismatchException();\n				}\n                \n				if(numChars <= 0)               \n					return -1;\n			}\n			return buf[curChar++];\n		}\n     \n		public String nextLine()\n		{\n			String str = """";\n			try\n			{\n				str = br.readLine();\n			}\n			catch (IOException e)\n			{\n				e.printStackTrace();\n			}	\n			return str;\n		}\n		public int nextInt() \n		{\n			int c = read();\n            \n			while(isSpaceChar(c)) \n				c = read();\n		\n			int sgn = 1;\n        \n			if (c == '-') \n			{\n				sgn = -1;\n				c = read();\n			}\n            \n			int res = 0;\n			do\n			{\n				if(c<'0'||c>'9') \n					throw new InputMismatchException();\n				res *= 10;\n				res += c - '0';\n				c = read();\n			}\n			while (!isSpaceChar(c)); \n        \n			return res * sgn;\n		}\n        \n		public long nextLong() \n		{\n			int c = read();\n			while (isSpaceChar(c))\n				c = read();\n			int sgn = 1;\n			if (c == '-')\n			{\n				sgn = -1;\n				c = read();\n			}\n			long res = 0;\n			\n			do \n			{\n				if (c < '0' || c > '9')\n					throw new InputMismatchException();\n				res *= 10;\n				res += c - '0';\n				c = read();\n			}	\n			while (!isSpaceChar(c));\n				return res * sgn;\n		}\n		\n		public double nextDouble() \n		{\n			int c = read();\n			while (isSpaceChar(c))\n				c = read();\n			int sgn = 1;\n			if (c == '-')\n			{\n				sgn = -1;\n				c = read();\n			}\n			double res = 0;\n			while (!isSpaceChar(c) && c != '.') \n			{\n				if (c == 'e' || c == 'E')\n					return res * Math.pow(10, nextInt());\n				if (c < '0' || c > '9')\n					throw new InputMismatchException();\n				res *= 10;\n				res += c - '0';\n				c = read();\n			}\n			if (c == '.') \n			{\n				c = read();\n				double m = 1;\n				while (!isSpaceChar(c))\n				{\n					if (c == 'e' || c == 'E')\n						return res * Math.pow(10, nextInt());\n					if (c < '0' || c > '9')\n						throw new InputMismatchException();\n					m /= 10;\n					res += (c - '0') * m;\n					c = read();\n				}\n			}\n			return res * sgn;\n		}\n    \n		public String readString() \n		{\n			int c = read();\n			while (isSpaceChar(c))\n				c = read();\n			StringBuilder res = new StringBuilder();\n			do \n			{\n				res.appendCodePoint(c);\n				c = read();\n			} \n			while (!isSpaceChar(c));\n            \n			return res.toString();\n		}\n     \n		public boolean isSpaceChar(int c) \n		{\n			if (filter != null)\n				return filter.isSpaceChar(c);\n			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n		}\n     \n		public String next()\n		{\n			return readString();\n		}\n        \n		public interface SpaceCharFilter\n		{\n			public boolean isSpaceChar(int ch);\n		}\n	}\n	public static void main(String args[]) throws Exception \n	{\n		new Thread(null, new Cf182(),""Main"",1<<27).start();\n	}	\n	\n	public static long gcd(long a, long b) \n	{ \n		if (a == 0) \n			return b; \n		return gcd(b % a, a); \n	} \n	//  array sorting by colm\npublic static void sortbyColumn(int arr[][], int col) \n    { \n        \n        Arrays.sort(arr, new Comparator<int[]>() { \n            \n          @Override\n          public int compare(final int[] entry1,  \n                             final int[] entry2) { \n  \n           \n            if (entry1[col] > entry2[col]) \n                return 1; \n            else\n                return -1; \n          } \n        });  \n    } \n	\n	// gcd\n  \n	public static long findGCD(long arr[], int n) \n	{ \n		long result = arr[0]; \n		for (int i = 1; i < n; i++) \n			result = gcd(arr[i], result); \n		return result; \n	}\n	// fibonaci\n	static int fib(int n) \n    { \n        int a = 0, b = 1, c; \n        if (n == 0) \n            return a; \n        for (int i = 2; i <= n; i++) \n        { \n            c = a + b; \n            a = b; \n            b = c; \n        } \n        return b; \n    } \n    \n// sort a string\n    public static String sortString(String inputString) \n    { \n        \n        char tempArray[] = inputString.toCharArray(); \n          \n         \n        Arrays.sort(tempArray); \n          \n         \n        return new String(tempArray); \n    } \n    // pair function\n    \n    // list.add(new Pair<>(sc.nextInt(), i + 1));\n    //     Collections.sort(list, (a, b) -> Integer.compare(b.first, a.first));\n   class Pair { \n    int x; \n    int y; \n  \n    // Constructor \npublic Pair(int x, int y) \n    { \n        this.x = x; \n        this.y = y; \n    } \n} \n    \n    \n    static int max(int a, int b)  \n    { \n        return (a > b) ? a : b; \n    } \n  \n   \n    \n    static int knapSack(int W, int wt[], int val[], int n) \n    { \n         int i, w; \n     int K[][] = new int[n+1][W+1]; \n       \n   \n     for (i = 0; i <= n; i++) \n     { \n         for (w = 0; w <= W; w++) \n         { \n             if (i==0 || w==0) \n                  K[i][w] = 0; \n             else if (wt[i-1] <= w) \n                   K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]],  K[i-1][w]); \n             else\n                   K[i][w] = K[i-1][w]; \n         } \n      } \n       \n      return K[n][W]; \n    } \n    \n    static void compare(Pair arr[], int n) \n    { \n        \n        Arrays.sort(arr, new Comparator<Pair>() { \n            @Override public int compare(Pair p1, Pair p2) \n            { \n                return p1.x - p2.x; \n            } \n        }); \n    }\n    \n    static void compare1(Pair arr[], int n) \n    { \n        \n        Arrays.sort(arr, new Comparator<Pair>() { \n            @Override public int compare(Pair p1, Pair p2) \n            { \n                return p1.y - p2.y; \n            } \n        }); \n    }\n    \n	public void run()\n	{\n		InputReader sc = new InputReader(System.in);\n		PrintWriter w = new PrintWriter(System.out);\n		int n = sc.nextInt();\n		int a[] = new int[n];\n		Pair b[] = new Pair[n]; \n		for(int i=0;i<n;i++)\n		    a[i] = sc.nextInt();\n		for(int i=0;i<n;i++)\n		    b[i] = new Pair(sc.nextInt(), i); \n		Arrays.sort(a);\n		compare(b,n);\n		for(int i=n-1;i>=0;i--)\n		{\n		    b[n-i-1].x= a[i];\n		}\n		compare1(b,n);\n		for(int i=0;i<n;i++)\n		    System.out.print(b[i].x+"" "");\n	}\n}","combinatorics,greedy,math,number theory,sortings"
"import java.io.*;\nimport java.util.*;\npublic class CF838_D12_E {\n	public static void main(String[] args)throws Throwable {\n		MyScanner sc=new MyScanner();\n		PrintWriter pw=new PrintWriter(System.out);\n		\n		n=sc.nextInt();\n		x=new long [n];\n		y=new long [n];\n		for(int i=0;i<n;i++){\n			x[i]=sc.nextInt();\n			y[i]=sc.nextInt();\n		}\n		mem=new Double [2][n+1][n+1];\n		double max=0;\n		for(int i=0;i<n;i++){\n			int nxt=nxt(i);\n			max=Math.max(max, dis(i, nxt)+Math.max(dp(0, i, nxt), dp(1, i, nxt)));\n		}\n		\n		pw.println(max);\n		pw.flush();\n		pw.close();\n	}\n	static int n;\n	static long [] x,y;\n	static Double [][][] mem;\n	\n	static double dp(int c, int i,int j){\n		if(i==nxt(j))\n			return 0;\n		if(mem[c][i][j]!=null)\n			return mem[c][i][j];\n		double ans=0;\n		int pre=pre(i);\n		int nxt=nxt(j);\n		if(c==0){\n			double op1=dis(i, pre)+dp(0, pre, j);\n			double op2=dis(i, nxt)+dp(1, i, nxt);\n			ans=Math.max(op1, op2);\n		}else{\n			double op2=dis(j, nxt)+dp(1, i, nxt);\n			double op1=dis(j, pre)+dp(0, pre, j);\n			ans=Math.max(op1, op2);\n		}\n		return mem[c][i][j]=ans;\n	}\n	\n	static double dis(int i,int j){\n		return Math.sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n	}\n	\n	static int nxt(int i){\n		return (i+1)%n;\n	}\n	static int pre(int i){\n		return (i-1+n)%n;\n	}\n	\n	static class MyScanner {\n		BufferedReader br;\n		StringTokenizer st;\n		public MyScanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n		String next() {while (st == null || !st.hasMoreElements()) {\n			try {st = new StringTokenizer(br.readLine());}\n			catch (IOException e) {e.printStackTrace();}}\n		return st.nextToken();}\n		int nextInt() {return Integer.parseInt(next());}\n		long nextLong() {return Long.parseLong(next());}\n		double nextDouble() {return Double.parseDouble(next());}\n		String nextLine(){String str = """";\n		try {str = br.readLine();}\n		catch (IOException e) {e.printStackTrace();}\n		return str;}\n	}\n}",dp
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        int[] x;\n        int[] y;\n        double[][][] dp;\n        int[] id;\n\n        double SQR(double x) {\n            return x * x;\n        }\n\n        double dist(int i, int j) {\n            return Math.sqrt(SQR(x[i] - x[j]) + SQR(y[i] - y[j]));\n        }\n\n        double rec(int first, int last, int h) {\n\n            if (dp[id[first]][id[last]][h] > -1) return dp[id[first]][id[last]][h];\n            if (last - first + 1 == 2) {\n                return dp[id[first]][id[last]][h] = dist(id[last], id[first]);\n            } else {\n                switch (h) {\n                    case 0: {\n                        double tmp = rec(first + 1, last, 0) + dist(id[first], id[first + 1]);\n                        tmp = Math.max(tmp, rec(first + 1, last, 1) + dist(id[first], id[last]));\n                        return dp[id[first]][id[last]][h] = tmp;\n                    }\n                    case 1: {\n                        double tmp = rec(first, last - 1, 1) + dist(id[last], id[last - 1]);\n                        tmp = Math.max(tmp, rec(first, last - 1, 0) + dist(id[last], id[first]));\n                        return dp[id[first]][id[last]][h] = tmp;\n                    }\n                }\n            }\n            assert (false);\n            return 0;\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            dp = new double[n][n][2];\n            for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) for (int k = 0; k < 2; ++k) dp[i][j][k] = -1;\n            x = new int[n];\n            y = new int[n];\n            for (int i = 0; i < n; ++i) {\n                //poly.lp.add(new Point(in.nextInt(),in.nextInt()));\n                x[i] = in.nextInt();\n                y[i] = in.nextInt();\n            }\n            id = new int[n];\n            double re = 0;\n            for (int i = 0; i < n; ++i) {\n\n                int bd = i;\n                for (int j = 0; j < n; ++j) {\n                    id[j] = bd;\n                    bd++;\n                    bd %= n;\n                }\n                re = Math.max(re, rec(0, n - 1, 0));\n                //re = Math.max(re, rec(lp,1));\n            }\n            out.println(String.format(""%.30f"", re));\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n        }\n\n    }\n}\n\n",dp
"/*\n6 5\nRRRRR\nRRRRR\nBBBBB\nBBBBB\nGGGGG\nGGGGG\n*/\nimport java.util.*;\nimport java.io.*;\n\npublic class Main{\n  public static void main(String[] args) throws IOException{\n      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n      StringTokenizer details = new StringTokenizer(br.readLine());\n      int n = Integer.parseInt(details.nextToken());\n      int m = Integer.parseInt(details.nextToken());\n      char[][] grid = new char[n][m];\n      for(int a = 0; a < n; a++) grid[a] = br.readLine().toCharArray(); \n      if(works(grid, n, m)) System.out.println(""YES"");\n      else{\n        //System.out.println();\n        char[][] gridTwo = new char[m][n];\n        for(int a = 0; a < n; a++){\n          for(int b = 0; b < m; b++) gridTwo[b][a] = grid[a][b]; \n        }\n        if(works(gridTwo, m, n)) System.out.println(""YES"");\n        else System.out.println(""NO"");\n      }\n        \n      br.close();\n  }\n  public static boolean works(char[][] grid, int n, int m){\n    //n by m grid, check if it is valid\n    //n must be divisible by 3 (looking for rbg column)\n    //for(char[] row : grid) System.out.println(Arrays.toString(row));\n    \n    if(n % 3 != 0) return false;  \n    HashSet<Character> used = new HashSet<Character>(); \n    char eq = grid[0][0];\n    for(int b = 0; b < n; b++){\n      if(b % (n/3) == 0) eq = grid[b][0]; \n      used.add(eq);\n      for(int a = 0; a < m; a++){\n        char val = grid[b][a]; \n        //System.out.println(b + "" "" + a + "" "" +eq + "" "" + n/3);\n        if(val != eq) return false; \n        }\n    }\n    return used.size() == 3; \n  }\n}","brute force,implementation"
"\nimport java.util.*;\nimport java.io.*;\n\npublic class FlagofBerland {\n\n	// https://codeforces.com/problemset/problem/837/B\n	\n	public static void main(String[] args) throws IOException, FileNotFoundException {\n		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n		//BufferedReader in = new BufferedReader(new FileReader(""FlagofBerland""));\n\n		StringTokenizer st = new StringTokenizer(in.readLine());\n		int n = Integer.parseInt(st.nextToken());  \n		int m = Integer.parseInt(st.nextToken());  \n		if (n%3 != 0 && m%3 != 0) {\n			System.out.println(""NO"");\n			return;\n		}\n		char[][] x = new char[n][];\n		for (int i=0; i<n; i++) {\n			x[i] = in.readLine().toCharArray();\n		}\n		boolean[] all = new boolean[3];\n			// 0 = r, 1 = g, 2 = b\n		if (n%3 == 0) {\n			boolean work = true;\n			outerloop: for (int c=0; c<3; c++) {\n				char cur = x[c*n/3][0];\n				if (cur == 'R') all[0] = true;\n				else if (cur == 'G') all[1] = true;\n				else if (cur == 'B') all[2] = true;\n				else {\n					work = false;\n					break outerloop;\n				}\n				for (int i= c*n/3; i< (c+1)*n/3; i++) {\n					for (int j=0; j<m; j++) {\n						if (x[i][j] != cur) {\n							work = false;\n							break outerloop;\n						}\n					}\n				}\n			}\n			if (work) {\n				for (int i=0; i<3; i++) {\n					if (!all[i]) work = false;\n				}\n			}\n			if (work) {\n				System.out.println(""YES"");\n				return;\n			}\n		}\n		for (int i=0; i<3; i++) all[i] = false;\n		if (m %3 ==0) {\n			boolean work = true;\n			outerloop: for (int c=0; c<3; c++) {\n				char cur = x[0][c*m/3];\n				if (cur == 'R') all[0] = true;\n				else if (cur == 'G') all[1] = true;\n				else if (cur == 'B') all[2] = true;\n				else {\n					work = false;\n					break outerloop;\n				}\n				for (int i= c*m/3; i< (c+1)*m/3; i++) {\n					for (int j=0; j<n; j++) {\n						if (x[j][i] != cur) {\n							work = false;\n							break outerloop;\n						}\n					}\n				}\n			}\n			if (work) {\n				for (int i=0; i<3; i++) {\n					if (!all[i]) work = false;\n				}\n			}\n			if (work ) {\n				System.out.println(""YES"");\n				return;\n			}\n		}\n		System.out.println(""NO"");\n	}\n}\n","brute force,implementation"
"////////////package random_practiceQuestions;\n\nimport java.util.Scanner;\n\npublic class B837 {\n    static String[] list;\n    static int r;\n    static int c;\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        Scanner s = new Scanner(System.in);\n        String[] l=s.nextLine().split("" "");\n        r=Integer.parseInt(l[0]);\n        c=Integer.parseInt(l[1]);\n        list=new String[r];\n        for (int i=0;i<r;i++){\n            list[i]=s.nextLine();\n        }\n        boolean ans=true;\n        int x=0;\n        if (r%3==0){\n            int each=r/3;\n            Character a=list[0].charAt(0);\n            ans=ans&&rowc(0,r/3-1,a);\n            ans=ans&&rowc(r/3,2*r/3 - 1,list[r/3].charAt(0));\n            ans=ans&&rowc(2*r/3,r-1,list[2*r/3].charAt(0));\n            ans=ans && (list[0].charAt(0)!=list[r/3].charAt(0)) && (list[r/3].charAt(0)!=list[2*r/3].charAt(0)) && list[2*r/3].charAt(0)!=list[0].charAt(0);\n            if (ans){\n                x++;\n            }\n        }\n\n        ans=true;\n\n        if (c%3==0){\n            ans=ans&&colc(0,c/3-1,list[0].charAt(0));\n            ans=ans&&colc(c/3,2*c/3-1,list[0].charAt(c/3));\n            ans=ans&&colc(2*c/3,c-1,list[0].charAt(2*c/3));\n            ans=ans&&list[0].charAt(0)!=list[0].charAt(c/3) && list[0].charAt(c/3) !=list[0].charAt(2*c/3) && list[0].charAt(2*c/3)!=list[0].charAt(0);\n            if (ans){\n                x++;\n            }\n        }\n\n        if (!(c%3==0 || r%3==0) ){\n            ans=false;\n        }\n        if (x>0){\n            System.out.println(""YES"");\n        }\n        else{\n            System.out.println(""NO"");\n        }\n\n    }\n    public static boolean rowc(int beg,int end,Character str) {\n        for (int i = beg;i<=end;i++){\n            for (int j=0;j<c;j++){\n                if (list[i].charAt(j)!=str){\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    public static boolean colc(int beg, int end, Character str){\n        for (int i=0;i<r;i++){\n            for (int j=beg;j<=end;j++){\n                if (list[i].charAt(j)!=str){\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n}\n","brute force,implementation"
"import java.io.*;\nimport java.util.*;\nimport java.lang.*;\n\npublic class Rextester{\n    static boolean checkRowWise(char[][] flag,int row,int column){\n        if(row%3!=0){\n            return false;\n        }\n        int x = row/3;\n        if(flag[0][0]==flag[x][0]||flag[0][0]==flag[2*x][0]||flag[x][0]==flag[2*x][0]){\n            return false;\n        }\n        for(int i=0;i<x;i++){\n            for(int j=0;j<column;j++){\n                if(flag[i][j]!=flag[0][0]){\n                    return false;\n                }\n            }\n        }\n        for(int i=x;i<2*x;i++){\n            for(int j=0;j<column;j++){\n                if(flag[i][j]!=flag[x][0]){\n                    return false;\n                }\n            }\n        }\n        for(int i=2*x;i<row;i++){\n            for(int j=0;j<column;j++){\n                if(flag[i][j]!=flag[2*x][0]){\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static boolean checkColumnWise(char[][] flag,int row,int column){\n        if(column%3!=0){\n            return false;\n        }\n        int x = column/3;\n        if(flag[0][0]==flag[0][x]||flag[0][0]==flag[0][2*x]||flag[0][x]==flag[0][2*x]){\n            return false;\n        }\n        for(int i=0;i<x;i++){\n            for(int j=0;j<row;j++){\n                if(flag[j][i]!=flag[0][0]){\n                    return false;\n                }\n            }\n        }\n        for(int i=x;i<2*x;i++){\n            for(int j=0;j<row;j++){\n                if(flag[j][i]!=flag[0][x]){\n                    return false;\n                }\n            }\n        }\n        for(int i=2*x;i<column;i++){\n            for(int j=0;j<row;j++){\n                if(flag[j][i]!=flag[0][2*x]){\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int m = Integer.parseInt(st.nextToken());\n        char[][] flag = new char[n][m];\n        for(int i=0;i<n;i++){\n            flag[i]=br.readLine().toCharArray();\n        }\n        br.close();\n        if(checkRowWise(flag,n,m)){\n            System.out.println(""YES"");\n        }\n        else if(checkColumnWise(flag,n,m)){\n            System.out.println(""YES"");\n        }\n        else{\n            System.out.println(""NO"");\n        }\n    }\n}\n        \n                ","brute force,implementation"
"import java.util.Scanner;\n\npublic class file {\npublic static void main(String[] args) {\n	int[] a= new int[5];\n	Scanner sc= new Scanner(System.in);\n	for(int i=0;i<5;i++) {\n		a[i]= sc.nextInt();\n	}\n	int x,y;\n	x= 2*a[3]+a[1]*a[0];\n	y= 2*a[4]+a[2]*a[0];\n	if(x>y)\n		System.out.println(""Second"");\n	else if(y>x)\n		System.out.println(""First"");\n	else\n		System.out.println(""Friendship"");\n	sc.close();\n}\n}",math
"import java.util.*;\npublic class Main {\n	public static void main(String[] args){\n		Scanner sc=new Scanner(System.in);\n		int x,y;\n		int a=sc.nextInt();\n		int b=sc.nextInt();\n		int c=sc.nextInt();\n		int d=sc.nextInt();\n		int e=sc.nextInt();\n		\n		x=a*b+2*d;\n		y=a*c+2*e;\n		if(x>y)\n			System.out.print(""Second"");\n		else if(x<y)\n			System.out.print(""First"");\n		else\n			System.out.print(""Friendship"");\n		\n	}\n}\n",math
"//18\nimport java.util.*;\npublic class KeyRaces{\n	public static void main(String args[])\n	{\n		Scanner sc = new Scanner(System.in);\n		int s = sc.nextInt();int v1 = sc.nextInt(); int v2 = sc.nextInt(); int t1 = sc.nextInt(); int t2 = sc.nextInt();\n		if((v1*s)+t1+t1<(v2*s)+t2+t2)\n			System.out.print(""First"");\n		else if((v1*s)+t1+t1>(v2*s)+t2+t2)\n			System.out.print(""Second"");\n		else\n			System.out.print(""Friendship"");\n	}\n}",math
"import java.util.*;\npublic class JavaApplication7 {\n public static void main(String[] args) {\n  Scanner obj = new Scanner(System.in);\n  int [] arr = new int [5]; \n  for(int i=0 ; i<5; i ++)  arr[i]=obj.nextInt();\n  int c1=((arr[0]*arr[1])+(arr[3]*2));\n  int c2=((arr[0]*arr[2])+arr[4]*2);\n  if (c1<c2) System.out.println(""First""); \n  else if(c2<c1) System.out.println(""Second""); \n  else System.out.println(""Friendship"");\n  \n }}",math
"import java.io.*;\nimport java.util.*;\n\npublic class garland {\n	 \n	public static void main(String[] args) throws IOException {\n		Scanner in = new Scanner(System.in);\n		int n = in.nextInt();\n		char[] word = in.next().toCharArray();\n		int q = in.nextInt();\n		int[] nums = new int[q];\n		char[] letter = new char[q];\n		for (int i = 0; i < q; i++) {\n			nums[i] = in.nextInt();\n			letter[i] = in.next().charAt(0);\n		}\n		int[][] vals = new int[n+1][26];\n \n		for (int j = 0; j < 26; j++) {\n			for (int i = 1; i <= n; i++) {\n				int ans = 0;\n				int r = 0;\n				int allow = i;\n				for (int l = 0; l < n; l++) {\n \n					while (r < n && (allow > 0 || word[r] == j+'a')) {\n						if (word[r] != j + 'a') {\n							allow--;\n \n						}\n						r++;\n					}\n					\n					ans = Math.max(ans, r - l);\n					\n					if(word[l] != j + 'a')\n					{\n						allow++;\n					}\n				}\n				\n				vals[i][j] = ans;\n			}\n		}\n		for(int i = 0; i < q; i++)\n		{\n			System.out.println(vals[nums[i]][letter[i]-'a']);\n		}\n	}\n	\n}\n","brute force,dp,strings,two pointers"
"import java.io.*;\n\n//An impassioned circulation of affection / garland\n//TLE on test 18\npublic class CF814C {\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));\n		int n = Integer.parseInt(br.readLine());\n		String garland = br.readLine();\n		int q = Integer.parseInt(br.readLine());\n\n		int[][] ans = new int[n][26];\n		for(int i = 1;i <= n;i++){\n			for(int a = 0;a < 26;a++) {\n				int lp = 0, num = 0, max = 0;\n				for(int rp = 0;rp < n;rp++){\n					if(garland.charAt(rp) - 'a' != a) num++;\n					while(lp < n && num > i){\n						if(garland.charAt(lp) - 'a' != a) num--;\n						lp++;\n					}\n					if(num <= i) max = Math.max(max, rp - lp + 1);\n				}\n				ans[i - 1][a] = max;\n			}\n		}\n\n		for(int queries = 0;queries < q;queries++){\n			String[] in = br.readLine().split("" "");\n			pw.println(ans[Integer.parseInt(in[0]) - 1][in[1].charAt(0) - 'a']);\n		}\n		pw.close();\n	}\n}\n","brute force,dp,strings,two pointers"
"import java.io.*;\nimport java.util.*;\n\npublic class test1 {\n\n	public static void main(String[] args) throws IOException {\n//		BufferedReader bf = new BufferedReader(new FileReader(""mountains.in"")););\n		BufferedReader bf =new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter out = new PrintWriter(System.out);\n		\n//		System.out.println(""hello"");\n		\n		int n = Integer.parseInt(bf.readLine());\n		char [] garland = new char[n];\n		String line = bf.readLine();\n		garland = line.toCharArray();\n		\n		int q = Integer.parseInt(bf.readLine());\n		for (int i = 0; i < q; i++) {\n			StringTokenizer st = new StringTokenizer(bf.readLine());\n			int m = Integer.parseInt(st.nextToken());\n			String thing = st.nextToken();\n			char c = thing.charAt(0);\n			int ans = 0;\n			\n			int l = 0;\n			int r = 0;\n			while (l < n && r < n) {\n				while (r < n) {\n					if (garland[r] != c) {\n						if (m == 0) {\n							break;\n						}\n						m--;\n					}\n					r++;\n				}\n				ans = Math.max(ans, r-l);\n				if (garland[l] != c) {\n					m++;\n				}\n				l++;\n			}\n			\n			out.println(ans);\n		}\n		\n		out.close();\n//		System.out.println(n);\n//		System.out.println(Arrays.toString(garland));\n//		System.out.println(""hello"");\n		\n	}\n	\n\n}","brute force,dp,strings,two pointers"
"import java.io.*;\nimport java.util.*;\n \npublic class Main2 {\n \n	public static void main(String[] args) throws IOException {\n \n		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n \n		StringTokenizer st = new StringTokenizer(in.readLine());\n		\n		int n = Integer.parseInt(st.nextToken());\n		char[] array = in.readLine().toCharArray();\n		\n		\n		int[][] values = new int[n+1][26];\n		\n		for(int i = 0; i < 26; i ++) {\n			char ch = (char)('a' + i);\n			\n			for(int j = 1; j <= n; j ++) {\n				\n				// now do sliding window / 2-pointer\n				int count = 0, max = 0;\n				int l = 0, r = 0;\n				while(l < n && r < n) {\n					while(r < n && (count < j || array[r] == ch)) {\n						if(array[r] != ch) count ++;\n						r ++;\n					}\n					max = Math.max(max, r - l);\n					if(array[l++] != ch) count --;\n				}\n				\n				values[j][i] = max;\n			}\n		}\n		\n		int q = Integer.parseInt(in.readLine());\n		StringBuilder ans = new StringBuilder();\n		\n		for(int i = 0; i < q; i ++) {\n			st = new StringTokenizer(in.readLine());\n			int num = Integer.parseInt(st.nextToken());\n			int ch = st.nextToken().charAt(0) - 'a';\n			ans.append(values[num][ch] + ""\n"");\n		}\n		\n		System.out.print(ans.toString());\n		\n		in.close();\n	}\n}","brute force,dp,strings,two pointers"
"import java.util.*;\n\npublic class Main {\n	public static long power(long x,int i) {\n		long res=1;\n		for (long j=0;j<i;j++)res*=x;\n		return res;\n	}\n\n			public static void main(String[] args) {\n				\n				Scanner sc = new Scanner (System.in);\n				long x= sc.nextLong(),y=sc.nextLong(),l=sc.nextLong(),r=sc.nextLong();\n				long max=0;\n				long gg=1;\n				 HashSet<Long> set=new HashSet();  \n				 set.add(r+1);\n					for(int i =0;i<=Math.log(r)/Math.log(x);i++) {\n					for(int j=0;j<=Math.log(r)/Math.log(y);j++) {\n						long q= power(x,i);\n						long w =power(y,j);\n						if(l<=q+w && r>=q+w) \n							set.add(q+w);\n					\n					}		\n				}\n					set.add(l-1);\n					long arr[]= new long[set.size()];\n					int z=0;\n					for (long c:set) \n						arr[z++]=c;\n					Arrays.sort(arr);\n					for (int i =0;i<set.size()-1;i++) \n						\n						max= Math.max(max, arr[i+1]-1-arr[i]);\n				\n				System.out.print(max);\n	}\n}\n","brute force,math"
"import java.util.*;\n\npublic class Problem0813b {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        long x = sc.nextLong();\n        long y = sc.nextLong();\n        long l = sc.nextLong();\n        long r = sc.nextLong();\n        ArrayList<Long> arr = new ArrayList<Long>();\n        arr.add(l - 1);\n        for (long i = 1; r >= i; i = find(i, x)) {\n            for (long j = 1; i + j <= r; j = find(j, y)) {\n                if (i + j >= l)\n                    arr.add(i + j);\n            }\n        }\n        arr.add(r + 1);\n        long max = 0;\n        Collections.sort(arr);\n        for (int i = 1; arr.size() > i; i++) {\n            max = Math.max(max, arr.get(i) - arr.get(i - 1) - 1);\n        }\n        System.out.println(max);\n    }\n\n    public static long find(long a, long b) {\n        long res = a * b;\n        if (a > (long)(1e18 + 1)/b)\n            return (long) 1e18 + 1;\n        return res;\n    }\n}","brute force,math"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\n\nimport java.util.TreeSet;\n\n\npublic class Test {\n	static TreeSet <Long> m ; \n	static long la ;\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter out = new PrintWriter(System.out);\n		m = new TreeSet<>();\n		String [] line = br.readLine().split("" "");\n		long x = Long.parseLong(line[0]);\n		long y = Long.parseLong(line[1]);\n		la = Long.parseLong(line[2]);\n		long r = Long.parseLong(line[3]);\n		if(2>la)\n			m.add(2L);\n		pre(x,x,r);\n		pre(y,y,r);\n		Pre(x,y,x,y,r);\n		if(!m.contains(r))\n			m.add(r+1);\n		if(!m.contains(la))\n			m.add(la-1);\n		long max =0;\n		while(m.size()!=1) {\n			long last = m.pollLast();\n			if(last-m.last()-1>max)\n				max=last-m.last()-1;\n		}\n		out.print(max);\n		out.flush();\n	}\n		\n	\n\n	private static void pre(long j, long l, long r) {\n		while(l+1<=r) {\n			if(l+1>=la) \n				m.add(l+1);\n			if(1D*l*j>r)\n				return;\n			l*=1L*j;\n	}	\n	}\n\n\n\n	private static void Pre(long i,long j ,long n , long l , long r) {\n		if(n+l>=r)\n			return ;\n		long te = l;\n		while(n+te<=r) {\n			if(n+te>=la) \n				m.add(n+te);\n			if(1D*j*te>r)\n				break;\n			te*=1L*j;\n		}\n		if(1D*n*i>r)\n			return;\n		Pre(i,j,n*i,l,r);\n		}\n\n}\n	 	  	 	   		  		 	 	 	  		 	 	","brute force,math"
"\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class duels {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(System.out);\n\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        long a = Long.parseLong(st.nextToken());\n        long b = Long.parseLong(st.nextToken());\n        long l = Long.parseLong(st.nextToken());\n        long r = Long.parseLong(st.nextToken());\n\n        List<Long> all = new ArrayList<>();\n        long c = 1;\n        all.add(c);\n        while (c <= r / a) {\n//            System.out.println(c);\n            c *= a;\n            all.add(c);\n        }\n        List<Long> n = new ArrayList<>();\n        for (long i : all) {\n            c = 1;\n            if (i <= r - c) {\n                n.add(i + c);\n            }\n            while (c <= (r - i) / b) {\n                c *= b;\n                n.add(c + i);\n            }\n        }\n        long ret = 0;\n        TreeSet<Long> has = new TreeSet<>();\n        has.addAll(n);\n        \n//        for(long i : has){\n//            System.out.println(i);\n//        }\n//        \n        long last = l-1;\n        Long lp = l-1;\n        while(true){\n            ret = Math.max(ret, lp - last - 1);\n            last = lp;\n            if(has.ceiling(lp+1) == null) break;\n            lp = has.ceiling(lp+1);\n        }\n        \n        pw.println(Math.max(r - lp, ret));\n        pw.close();\n        br.close();\n    }\n}\n","brute force,math"
import java.util.Scanner;\n\npublic class Pasha {\n\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		int sum = 0;\n		int n = s.nextInt();\n		for(int i=0;i<n;i++) {\n			sum += s.nextInt();\n		}\n		int m = s.nextInt();\n		\n		for(int i=0;i<m;i++) {\n			int l = s.nextInt();\n			\n			int r = s.nextInt();\n			if(sum>=l && sum<=r) {\n				System.out.println(sum);\n				return;\n			}else if(l>=sum) {\n				System.out.println(l);\n				return;\n			}\n		}\n		System.out.println(-1);\n	}\n\n}\n\n\n	 			 		 	 	    	 	 					 	   	,implementation
import java.util.Scanner;\n\npublic class _1039TheContest {\n\n	public static void main(String[] args) {\n		\n		Scanner sc = new Scanner(System.in);\n		int n=sc.nextInt();\n		long sum=0;\n		for(int i=0;i<n;i++) {\n			sum+=sc.nextLong();\n		}\n		int m=sc.nextInt();\n		for(int i=0;i<m;i++) {\n			int l=sc.nextInt();\n			int r=sc.nextInt();\n			if(sum<=l) {\n				System.out.println(l);\n				return;\n			}\n			else if(sum>=l && sum<=r) {\n				System.out.println(sum);\n				return;\n			}\n		}\n		System.out.println(-1);\n	}\n\n}\n,implementation
import java.util.*;\npublic class MyClass {\n        public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += in.nextInt();\n        }\n        int m = in.nextInt();\n        for (int i = 0; i < m; i++) {\n            int l = in.nextInt();\n            int r = in.nextInt();\n            if (sum >= l && sum <= r) {\n                System.out.println(sum);\n                return;\n            } else if (l >= sum) {\n                System.out.println(l);\n                return;\n            }\n        }\n        System.out.println(-1);\n \n    }\n \n},implementation
import java.util.Scanner;\n \n//SolverToBe\n//Mohammad Abulawi\npublic class TheContest {\n \n \n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += in.nextInt();\n        }\n \n        int m = in.nextInt();\n \n        for (int i = 0; i < m; i++) {\n \n            int l = in.nextInt();\n \n            int r = in.nextInt();\n            if (sum >= l && sum <= r) {\n                System.out.println(sum);\n                return;\n            } else if (l >= sum) {\n                System.out.println(l);\n                return;\n            }\n \n        }\n        System.out.println(-1);\n \n    }\n \n},implementation
"import java.io.*;\nimport java.util.*;\npublic class Main\n{\n	final int maxn=(int)(1e5);\n	private void solve()throws IOException\n	{\n		int a=nextInt();\n		int b=nextInt();\n		int h=nextInt();\n		int w=nextInt();\n		int n=nextInt();\n		int ext[]=new int[n+1];\n		for(int i=1;i<=n;i++)\n			ext[i]=nextInt();\n		Arrays.sort(ext,1,n+1);\n		if(h>=a && w>=b || h>=b && w>=a)\n		{\n			out.println(0);\n			return;\n		}\n		//dp[i] is the max width for height i\n		long dp[]=new long[maxn+1];\n		dp[h]=w;\n		for(int j=n;j>=1;j--)\n		{\n			\n			for(int i=maxn;i>=1;i--)\n			{\n				if(1l*i*ext[j]>maxn && (dp[i]>=a || dp[i]>=b))\n				{\n					out.println(n-j+1);\n					return;\n				}\n				dp[i]=Math.max(dp[i],dp[i]*ext[j]);\n				if(i%ext[j]==0)\n					dp[i]=Math.max(dp[i/ext[j]],dp[i]);\n				if(i>=a && dp[i]>=b || i>=b && dp[i]>=a)\n				{\n					out.println(n-j+1);\n					return;\n				}\n			}\n		}\n		out.println(-1);\n	}\n\n\n	 \n	///////////////////////////////////////////////////////////\n\n	public void run()throws IOException\n	{\n		br=new BufferedReader(new InputStreamReader(System.in));\n		st=null;\n		out=new PrintWriter(System.out);\n\n		solve();\n\n		br.close();\n		out.close();\n	}\n	public static void main(String args[])throws IOException{\n		new Main().run();\n	}\n	BufferedReader br;\n	StringTokenizer st;\n	PrintWriter out;\n	String nextToken()throws IOException{\n		while(st==null || !st.hasMoreTokens())\n		st=new StringTokenizer(br.readLine());\n		return st.nextToken();\n	}\n	String nextLine()throws IOException{\n		return br.readLine();\n	}\n	int nextInt()throws IOException{\n		return Integer.parseInt(nextToken());\n	}\n	long nextLong()throws IOException{\n		return Long.parseLong(nextToken());\n	}\n	double nextDouble()throws IOException{\n		return Double.parseDouble(nextToken());\n	}\n}","brute force,dp,meet-in-the-middle"
"import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Test {\n\n  static PrintWriter writer =\n      new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n  int ans = Integer.MAX_VALUE;\n  int a, b, h, w, n;\n  int[] ar;\n\n  public static void main(String[] args) {\n    Test te = new Test();\n    te.start();\n    writer.flush();\n  }\n\n  int readInt() {\n    int ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  long readLong() {\n    long ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  String readLine() {\n    StringBuilder b = new StringBuilder();\n    try {\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '\n') {\n          break;\n        } else {\n          b.append((char) (c));\n        }\n      }\n    } catch (IOException e) {\n    }\n    return b.toString().trim();\n  }\n\n  void solve(int p, long x, long y, int type) {\n    if (x >= a && y >= b) {\n      ans = Math.min(ans, n - p - 1);\n      return;\n    }\n    if (p < 0) return;\n    if ((type != 1 || ar[p] != ar[p + 1]) && x < a) solve(p - 1, x * ar[p], y, 0);\n    if (y < b) solve(p - 1, x, y * ar[p], 1);\n  }\n\n  void start() {\n    a = readInt();\n    b = readInt();\n    h = readInt();\n    w = readInt();\n    n = readInt();\n    ar = new int[n];\n    for (int i = 0; i < n; i++) ar[i] = readInt();\n    Arrays.sort(ar);\n    solve(n - 1, h, w, -1);\n    solve(n - 1, w, h, -1);\n    writer.println(ans == Integer.MAX_VALUE ? -1 : ans);\n  }\n}\n","brute force,dp,meet-in-the-middle"
"import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Test {\n\n  static PrintWriter writer =\n      new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n  int ans = Integer.MAX_VALUE;\n  int a, b;\n  int[] ar;\n\n  public static void main(String[] args) {\n    Test te = new Test();\n    te.start();\n    writer.flush();\n  }\n\n  int readInt() {\n    int ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  long readLong() {\n    long ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  String readLine() {\n    StringBuilder b = new StringBuilder();\n    try {\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '\n') {\n          break;\n        } else {\n          b.append((char) (c));\n        }\n      }\n    } catch (IOException e) {\n    }\n    return b.toString().trim();\n  }\n\n  void solve(int p, long x, long y, int c) {\n    if (x >= a && y >= b) {\n      ans = Math.min(ans, c);\n      return;\n    }\n    if (p < 0) return;\n    int s = 1;\n    for (int i = p - 1; i >= 0; i--)\n      if (ar[i] == ar[i + 1]) s++;\n      else break;\n    int sx = 0, sy = 0;\n    long cx = x, cy = y;\n    for (; cx < a; sx++) cx *= ar[p];\n    for (; cy < b; sy++) cy *= ar[p];\n    if (sx + sy <= s) ans = Math.min(ans, c + sx + sy);\n    else {\n      cx = x;\n      int i = Math.max(s - sy, 0);\n      for (int j = 0; j < i; j++) cx *= ar[p];\n      for (; i <= s; i++) {\n        cy = y;\n        for (int j = 0; j < s - i; j++) cy *= ar[p];\n        solve(p - s, cx, cy, c + s);\n        cx *= ar[p];\n      }\n    }\n  }\n\n  void start() {\n    a = readInt();\n    b = readInt();\n    int h = readInt(), w = readInt(), n = readInt();\n    ar = new int[n];\n    for (int i = 0; i < n; i++) ar[i] = readInt();\n    Arrays.sort(ar);\n    solve(n - 1, h, w, 0);\n    solve(n - 1, w, h, 0);\n    writer.println(ans == Integer.MAX_VALUE ? -1 : ans);\n  }\n}\n","brute force,dp,meet-in-the-middle"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Vaibhav Pulastya\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DFieldExpansion solver = new DFieldExpansion();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DFieldExpansion {\n        Integer[] ai;\n        HashMap<String, Integer> H = new HashMap<>();\n        long a;\n        long b;\n        long h;\n        long w;\n        int n;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            a = in.nextInt();\n            b = in.nextInt();\n            h = in.nextInt();\n            w = in.nextInt();\n            n = in.nextInt();\n            ai = in.nextIntOArray(n);\n            Arrays.sort(ai, new Comparator<Integer>() {\n\n                public int compare(Integer integer, Integer t1) {\n                    return Integer.compare(t1, integer);\n                }\n            });\n            int x = Math.min(dp(h, w, 0), dp(w, h, 0));\n            out.print(x > n ? -1 : x);\n        }\n\n        int dp(long h, long w, int i) {\n            if (h >= a && w >= b) return 0;\n            else if (i == n) return 1000000;\n            else if (H.containsKey(h + "" "" + w + "" "" + i)) return H.get(h + "" "" + w + "" "" + i);\n            int ans = 1000000;\n            if (w < b) {\n                ans = 1 + dp(h, w * ai[i], i + 1);\n            }\n            if (h < a) {\n                ans = Math.min(1 + dp(h * ai[i], w, i + 1), ans);\n            }\n            H.put(h + "" "" + w + "" "" + i, ans);\n            return ans;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n        }\n\n        public Integer[] nextIntOArray(int size) {\n            Integer[] array = new Integer[size];\n            for (int i = 0; i < size; i++)\n                array[i] = nextInt();\n            return array;\n        }\n\n    }\n}\n\n","brute force,dp,meet-in-the-middle"
"//package com.company;\nimport java.util.*;\npublic class Main {\n	static Scanner sc = new Scanner(System.in);\n	public static void main(String[] args)\n	{\n		long b, q, l;\n		int m;\n		b = sc.nextLong();\n		q = sc.nextLong();\n		l = sc.nextLong();\n		m = sc.nextInt();\n		long[] arr = new long[m];\n		for (int i=0; i<m; i++)\n			arr[i] = sc.nextLong();\n		Arrays.sort(arr);\n		\n		int count = 0;\n		long tp=b;\n		//As its geometric progression, so we can check up to 30 steps\n		//Need to check min 60 because number can be -2^30 to +2^30\n		for(int i=0; i<100; i++)\n		{\n			if (Math.abs(tp)<=l)\n			{\n				int tmp=Arrays.binarySearch(arr, tp);\n				if(tmp<0)\n					count++;\n			}\n			else\n				break;\n			tp *=q;\n		}\n		if(count<=30)\n			System.out.println(count);\n		else\n			System.out.println(""inf"");\n	}\n}","brute force,implementation,math"
"//package com.company;\nimport java.util.*;\npublic class Main {\n	static Scanner sc = new Scanner(System.in);\n	public static void main(String[] args)\n	{\n		long b, q, l;\n		int m;\n		b = sc.nextLong();\n		q = sc.nextLong();\n		l = sc.nextLong();\n		m = sc.nextInt();\n		long[] arr = new long[m];\n		for (int i=0; i<m; i++)\n			arr[i] = sc.nextLong();\n		Arrays.sort(arr);\n		\n		int count = 0;\n		long tp=b;\n		for(int i=0; i<100; i++)\n		{\n			if (Math.abs(tp)<=l)\n			{\n				int tmp=Arrays.binarySearch(arr, tp);\n				if(tmp<0)\n					count++;\n			}\n			else\n				break;\n			tp *=q;\n		}\n		if(count<32)\n			System.out.println(count);\n		else\n			System.out.println(""inf"");\n		/*\n		B Q\n		- -\n		c 0\n		c 1\n		c -1\n		c -c\n		-c c\n		-c -c\n		c c\n		\n		 *//*\n		if(q==0)\n		{\n			if (Arrays.binarySearch(arr, 0) == -1)\n				System.out.println(""inf"");\n			else if(Arrays.binarySearch(arr, b) == -1)\n				System.out.println(1);\n			else System.out.println(0);\n		}\n		else if(q == 1)\n		{\n			if (Arrays.binarySearch(arr, b) == -1)\n				System.out.println(""inf"");\n			else System.out.println(0);\n		}*/\n		\n	}\n}","brute force,implementation,math"
"import java.util.*;\nimport java.io.*;\nimport java.lang.*;\n\npublic class File {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n		\n		long b1 = sc.nextLong(); // Initial term.\n		long q = sc.nextLong();  // b_i = b_i-1 * q.\n		\n		long l = sc.nextLong();  // Absolute value of max number.\n		long m = sc.nextLong();  // Number of ""bad"" integers.\n		\n		// The m bad integers follow.\n		Set<Long> bad = new HashSet<>();\n		for (int i = 0; i < m; i++) {\n			bad.add(sc.nextLong());\n		}\n		\n		if (Math.abs(b1) > l) {\n			System.out.println(0);\n			return;\n		}\n		\n		// Some cases\n		if (q == 1) {\n			if (bad.contains(b1) || Math.abs(b1) > l) {\n				System.out.println(0);\n				return;\n			}\n			else {\n				System.out.println(""inf"");\n				return;\n			}\n		}\n		if (q == 0 || b1 == 0) {\n			int total = 0;\n			\n			if (!bad.contains(b1) && Math.abs(b1) <= l) {\n				total++;\n			}\n			if (!bad.contains(0L)) {\n				System.out.println(""inf"");\n				return;\n			}\n			\n			System.out.println(total);\n			return;\n		}\n		if (q == -1) {\n			if (bad.contains(b1) && bad.contains(b1 * -1)) {\n				System.out.println(0);\n			}\n			else {\n				System.out.println(""inf"");\n			}\n			\n			return;\n		}\n		\n		int total = 0;\n		\n		while (Math.abs(b1) <= l) {\n			if (!bad.contains(b1)) {\n				total++;\n			}\n			\n			b1 *= q;\n		}\n		\n		System.out.println(total);\n	}\n}","brute force,implementation,math"
"import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class B{\n	public static void main(String[] args) throws IOException {\n		// br = new BufferedReader(new FileReader("".in""));\n		// out = new PrintWriter(new FileWriter("".out""));\n		//new Thread(null, new (), ""peepee"", 1<<28).start();\n		\n		long b1 = readLong(), q =readLong(), l= readLong(), m =readLong();\n		HashSet<Long> hs = new HashSet<Long>();\n		while(m-->0) hs.add(readLong());\n		if (abs(b1) > l) out.println(0);\n		else if (b1 == 0) {\n			if (hs.contains(0L)) out.println(0);\n			else out.println(""inf"");\n		}\n		else if (q == 0) {\n			int ans = hs.contains(b1)?0:1;\n			if (hs.contains(0L)) out.println(ans);\n			else out.println(""inf"");\n		}\n		else if (q==1) {\n			if (hs.contains(b1)) out.println(0);\n			else out.println(""inf"");\n		}\n		else if (q==-1) {\n			if (hs.contains(b1) && hs.contains(-b1)) out.println(0);\n			else out.println(""inf"");\n		}\n		else {\n			// Finally, simulate this dumb shit.\n			int ans = 0;\n			while (abs(b1) <= l) {\n				if (!hs.contains(b1))ans++;\n				b1 *= q;\n			}\n			out.println(ans);\n		}\n		\n		out.close();\n	}\n	\n	/* Stupid things to try if stuck:\n	 * n=1, expand bsearch range\n	 * brute force small patterns\n	 * submit stupid intuition\n	 */\n	\n	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n	static StringTokenizer st = new StringTokenizer("""");\n	static String read() throws IOException{return st.hasMoreTokens() ? st.nextToken():(st = new StringTokenizer(br.readLine())).nextToken();}\n	static int readInt() throws IOException{return Integer.parseInt(read());}\n	static long readLong() throws IOException{return Long.parseLong(read());}\n	static double readDouble() throws IOException{return Double.parseDouble(read());}\n}","brute force,implementation,math"
/*package whatever //do not write package name here */\n\nimport java.io.*;\nimport java.util.*;\npublic class Solution {\n	public static void main (String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		String s = Integer.toHexString(n);\n		int count = 0;\n		for(int i=0;i<s.length();i++)\n		{\n		    if(s.charAt(i) == '4' || s.charAt(i) == '6' || s.charAt(i) == '9' || s.charAt(i) == '0' || s.charAt(i) == 'a' || s.charAt(i) == 'd')\n		    {\n		        count++;\n		    }\n		    if(s.charAt(i) == '8' || s.charAt(i) == 'b')\n		    {\n		        count += 2;\n		    }\n		}\n		System.out.println(count);\n	}\n},*special
"import java.io.IOException;\nimport java.util.Scanner;\n\npublic class Kids_Riddle {\n\n	public static void main(String[] args) throws IOException {\n		// TODO Auto-generated method stub\n		Scanner in = new Scanner(System.in);\n		int hi = in.nextInt();\n		//int hi = 13;\n		String temp = Integer.toHexString(hi);\n		//System.out.println(temp);\n		int res=0;\n		for (int i = 0; i < temp.length(); i++) {\n			String temptemp = temp.substring(i,i+1);\n			if (((temptemp.equals(""0"") || temptemp.equals(""4"")) || (temptemp.equals(""6"") || temptemp.equals(""9""))) || (temptemp.equals(""a"") || temptemp.equals(""d""))) {\n				res++;\n			} else if (temptemp.equals(""8"") || temptemp.equals(""b"")) {\n				res+=2;\n			}\n		}\n		System.out.println(res);\n	}\n\n}\n",*special
import java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt();\n        \n        String hexSTR = Integer.toHexString(n);\n       \n        hexSTR = hexSTR.toUpperCase();\n        \n        char Char[] = hexSTR.toCharArray();\n        \n        int a = 0;\n\n        for (int i = 0; i < Char.length; i++) {\n            if (Char[i] == '4' || Char[i] == '6' || Char[i] == '9' || Char[i] == '0' || Char[i] == 'A' || Char[i] == 'D')\n            {\n                a++;\n            }\n            else if (Char[i] == '8' || Char[i] == 'B')\n            {\n                a += 2;\n            }\n        }\n        System.out.println(a);\n    }\n},*special
import java.util.*;\npublic class main{\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner in =  new Scanner(System.in) ;\n		int n = in.nextInt() ; \n		String hex  =	Integer.toHexString(n) ; \n		hex =  hex.toUpperCase() ; \n		char  c[] = hex.toCharArray();\n		int cnt   =  0 ; \n		\n		for(int i  = 0 ; i<c.length  ; i++){\n				 if(c[i] == '4' || c[i] ==  '6' || c[i] == '9' || c[i] == '0' || c[i] == 'A' || c[i] == 'D')\n					 cnt ++ ; \n				 else if(c[i] == '8' || c[i]  == 'B')\n					 cnt +=2 ;\n				 \n		}\n		System.out.println(cnt);\n		\n	}	\n	\n}\n,*special
import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Sol{\n	public static void main(String[] argc){\n	    \n		Scanner sc = new Scanner(System.in);\n		\n		int n = sc.nextInt();\n		int r = n % 7;\n		int answ = Integer.MAX_VALUE;\n		int ansk = 0;\n		\n		for(int i = 0; i < n; ++i){\n		    \n			int a = sc.nextInt();\n			int cur = 0;\n			int curday = i % 7 + 1;\n            \n            if(r == 0){\n                if(curday == 7)\n                    cur = Integer.MAX_VALUE;\n                else\n                    cur += a - 1;\n            }else{\n                if(a >= 6){\n                    cur += (a - 1) / 6 * 7;\n                    a -= (a - 1) / 6 * 6;\n                }\n                while(a > 0){\n                    if(curday != 7) a--;\n                    if(a > 0) cur++;\n                    curday = (curday + r - 1) % 7 + 1;\n                }\n            }\n            \n            if(cur < answ){\n                answ = cur;\n                ansk = i;\n            }\n		}\n		\n		System.out.println(ansk + 1);\n	}\n},"*special,binary search,number theory"
import java.*;\nimport java.util.*;\npublic class Main{\n    public static Scanner cin = new Scanner(System.in);\n    public static void main(String args[]){\n        int n = cin.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n            a[i] = cin.nextInt();\n        if (n % 7 == 0){\n            int ansid = 0;\n            for (int i = 0; i < n; i++)\n                if (i % 7 != 6 && a[i] < a[ansid])\n                    ansid = i;\n            System.out.print(ansid + 1);\n            return;\n        }\n        int group = 2020202020;\n        for (int i = 0; i < n; i++)\n            if (group > a[i] / 6)\n                group = a[i] / 6;\n        group--;\n        if (group < 0)\n            group = 0;\n        for (int i = 0; i < n; i++)\n            a[i] -= group * 6;\n        int nowday = 1;\n        for (int i = 0; ; i++){\n            if (i == n)\n                i = 0;\n            if (nowday != 7){\n                nowday++;\n                a[i]--;\n                if (a[i] == 0){\n                    System.out.print(i + 1);\n                    return;\n                }\n            }\n            else\n                nowday = 1;\n        }\n    }\n},"*special,binary search,number theory"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        long[] cnt;\n        int n;\n        long[] a;\n        long[] b;\n\n        boolean check(long day) {\n            for (int i = 0; i < n; ++i) b[i] = a[i];\n            long r = day / (7 * n);\n            for (int i = 0; i < n; ++i) {\n                b[i] -= r * cnt[i];\n                if (b[i] <= 0) return true;\n            }\n            int mod = (int) (day % (7 * n));\n            int th = 0;\n            int id = 0;\n            for (int i = 0; i < mod; ++i) {\n                if (th != 6) {\n                    b[id]--;\n                    if (b[id] <= 0) return true;\n                }\n                th = (th + 1) % 7;\n                id = (id + 1) % n;\n            }\n            return false;\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            n = in.nextInt();\n            cnt = new long[n];\n            a = new long[n];\n            b = new long[n];\n            for (int i = 0; i < n; ++i) a[i] = in.nextInt();\n            int th = 0;\n            int id = 0;\n            for (int i = 0; i < n * 7; ++i) {\n                if (th != 6) cnt[id]++;\n                th = (th + 1) % 7;\n                id = (id + 1) % n;\n            }\n\n            long lo = 1;\n            long hi = (long) 1e17;\n            long best = -1;\n            while (lo <= hi) {\n                long mid = (lo + hi) / 2;\n                if (check(mid)) {\n                    best = mid;\n                    hi = mid - 1;\n                } else {\n                    lo = mid + 1;\n                }\n            }\n            check(best);\n            for (int i = 0; i < n; ++i)\n                if (b[i] <= 0) {\n                    out.println(i + 1);\n                    break;\n                }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n        }\n\n    }\n}\n\n","*special,binary search,number theory"
import java.util.*;\n\npublic class a{\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int n = in.nextInt();\n		int[] a = new int[n];\n		for(int i = 0; i < n; i++)\n			a[i] = in.nextInt();\n\n		Arrays.sort(a);\n	\n		int count = 0;\n		for(int i = 1; i < n-1; i++)\n			if(a[0] < a[i] && a[i] < a[n-1])\n				count++;\n\n		System.out.println(count);\n\n\n	}\n},"constructive algorithms,sortings"
"import java.util.*;\npublic class Oath {\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		int n = s.nextInt();\n		int arr[] = new int[n];\n		for(int i=0;i<n;i++)\n			arr[i]=s.nextInt();\n		Arrays.sort(arr);\n		int count=0,n1=arr[0],n2=arr[n-1];\n		for(int j=0;j<n;j++) {\n			if(arr[j]!=n1 && arr[j]!=n2)\n				count++;\n		}\n		System.out.println(count);\n	}\n}","constructive algorithms,sortings"
\nimport java.util.*;\npublic class Main\n{\npublic static void main(String[] args)\n	{ Scanner sc =new Scanner(System.in);\n	   int n= sc.nextInt();\n	   int arr[]=new int [n];\n	   int c=0;\n	   for(int i=0;i<n;i++){\n		  arr[i]=sc.nextInt();\n	   }\n	   Arrays.sort(arr);\n	   for(int i=1;i<n-1;i++){\n		  if(arr[0]<arr[i]&&arr[i]<arr[n-1])\n			  c++;\n	   }\n	   System.out.println(c);\n	}\n},"constructive algorithms,sortings"
import java.util.*;\n\npublic class GFG {\n   \npublic static void main (String[] args) {\nScanner sc = new Scanner(System.in);\nint n  = sc.nextInt();\nlong ar[] = new long[n];\nfor(int i = 0;i<n;i++){\n    ar[i] = sc.nextLong();\n}\nArrays.sort(ar);\nlong count = 0;\nfor(int i = 0;i<n-1;i++)\n{\n    if(ar[0]<ar[i]&&ar[n-1]>ar[i]){\n        count++;\n    }\n}\nSystem.out.println(count);\n}\n}\n,"constructive algorithms,sortings"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Ruins He\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        private static final int m = 3;\n        private static final long INF = 0x3F3F3F3F3F3F3F3FL;\n        private static final int[][][] matrix = new int[][][]{\n                {{1}, {2, 1}},\n                {{0}, {2}},\n                {{1}, {0, 1}}\n        };\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int[][] mp = new int[n][3];\n            for (int j = 0; j < 3; j++) {\n                for (int i = 0; i < n; i++) {\n                    if (n > 100000) {\n                        mp[i][j] = j * n + i;\n                    } else {\n                        mp[i][j] = in.nextInt();\n                    }\n                }\n            }\n\n            long[][][] dp = new long[n][m][2];\n\n            long sum = 0;\n            for (int j = 0; j < m; j++) {\n                sum += mp[0][j];\n                for (int k = 0; k < 2; k++) {\n                    dp[0][j][k] = j == 0 || k == 1 ? sum : -INF;\n                }\n            }\n\n            for (int i = 1; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    dp[i][j][0] = dp[i][j][1] = dp[i - 1][j][1] + mp[i][j];\n                }\n\n                for (int j = 0; j < m; j++) {\n                    for (int[] indices : matrix[j]) {\n                        sum = dp[i][indices[0]][0];\n                        for (int k = 1; k < indices.length; k++) {\n                            sum += mp[i][indices[k]];\n                        }\n                        dp[i][j][1] = Math.max(dp[i][j][1], sum + mp[i][j]);\n                    }\n                }\n\n                dp[i][0][1] = Math.max(dp[i][0][1], dp[i - 1][2][0] + mp[i][2] + mp[i][1] + mp[i - 1][1] + mp[i - 1][0] + mp[i][0]);\n                dp[i][2][1] = Math.max(dp[i][2][1], dp[i - 1][0][0] + mp[i][0] + mp[i][1] + mp[i - 1][1] + mp[i - 1][2] + mp[i][2]);\n            }\n\n            out.println(dp[n - 1][m - 1][1]);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        private OutputWriter(Writer writer, boolean autoFlush) {\n            this.writer = new PrintWriter(new BufferedWriter(writer, 32767), autoFlush);\n        }\n\n        public OutputWriter(Writer writer) {\n            this(writer, true);\n        }\n\n        public OutputWriter(OutputStream outputStream) {\n            this(new OutputStreamWriter(outputStream), false);\n        }\n\n        public OutputWriter println(long value) {\n            writer.println(value);\n            return this;\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class InputReader {\n        public final BufferedReader reader;\n        public StringTokenizer tokenizer = null;\n\n        public InputReader(Reader reader) {\n            this.reader = new BufferedReader(reader, 32767);\n        }\n\n        public InputReader(InputStream inputStream) {\n            this(new InputStreamReader(inputStream));\n        }\n\n        public String next() {\n            if (hasNext()) return tokenizer.nextToken();\n            else throw new NoSuchElementException();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public boolean hasNext() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    String nextLine = reader.readLine();\n                    if (nextLine == null) return false;\n                    tokenizer = new StringTokenizer(nextLine);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.hasMoreTokens();\n        }\n\n    }\n}\n\n","dp,greedy,implementation"
"import java.util.Scanner;\n\n\npublic class MaximumPath {\n	\n	static long INF = 1l << 60;\n	public static void main(String[] args) {\n		Scanner s=new Scanner(System.in);\n		int n=s.nextInt();\n		long a[][]=new long[3][n+3];\n		for(int i = 0; i < 3; i++)\n			for(int j = 1; j <= n; j++)\n				a[i][j] = s.nextLong();\n		\n		long [][] f = new long[5][n + 3];\n		f[0][0] = 0; f[1][0] = f[2][0] = f[3][0] = f[4][0] = -INF;\n		for(int i = 1; i <= n; i++){\n			for(int j = 0; j < 5; j++)\n				f[j][i] = -INF;\n			f[0][i] = Math.max(f[0][i], Math.max(f[0][i-1] + a[0][i], Math.max(f[1][i-1] + a[0][i] + a[1][i], Math.max(f[2][i-1] + a[0][i] + a[1][i] + a[2][i], f[4][i-1] + a[0][i] + a[1][i] + a[2][i]))));\n			f[1][i] = Math.max(f[1][i], Math.max(f[0][i-1] + a[0][i] + a[1][i], Math.max(f[1][i-1] + a[1][i], f[2][i-1] + a[2][i] + a[1][i])));\n			f[2][i] = Math.max(f[2][i], Math.max(f[2][i-1] + a[2][i], Math.max(f[1][i-1] + a[2][i] + a[1][i], Math.max(f[0][i-1] + a[0][i] + a[1][i] + a[2][i], f[3][i-1] + a[0][i] + a[1][i] + a[2][i]))));\n			f[3][i] = Math.max(f[3][i], Math.max(f[0][i-1] + a[0][i] + a[1][i] + a[2][i], f[3][i-1] + a[0][i] + a[1][i] + a[2][i]));\n			f[4][i] = Math.max(f[4][i], Math.max(f[2][i-1] + a[0][i] + a[1][i] + a[2][i], f[4][i-1] + a[0][i] + a[1][i] + a[2][i]));\n		}\n		System.out.println(f[2][n]);\n		s.close();\n\n	}\n\n}\n","dp,greedy,implementation"
"import java.util.*;\npublic class aa {\n  private static String getString(Scanner x){String s=x.nextLine();if(0==s.length())s=x.nextLine();return s;}\n\n  public static void main(String[] args){ try {\n      StringBuilder sb = new StringBuilder();\n      Scanner scanner = new Scanner(System.in);\n\n  int n = scanner.nextInt(); long mi = 300*1024*1024; mi *= mi*(-1);\n  int[][] data = new int[3][n+5]; long[][] opt = new long[3][n+5];\n  opt[0][0] = mi; opt[1][0] = mi; opt[2][0] = mi;\n  opt[0][1] = mi*0; opt[1][1] = mi; opt[2][1] = mi;\n\n  for(int j=0; j < 3; ++j)\n    for(int i=2; i < n+2; i++)\n      data[j][i] = scanner.nextInt();\n\n  for(int i=2; i < n+2; i++)\n  {\n    long sumprev = data[0][i-1] + (long)(data[1][i-1]) + (long)data[2][i-1];\n    long sumcur = data[0][i] + (long)(data[1][i]) + (long)data[2][i];\n    opt[0][i] = opt[2][i-2] + sumprev + sumcur;\n    opt[1][i] = mi;\n    opt[2][i] = opt[0][i-2] + sumprev + sumcur;\n    for(int from=0; from < 3; ++from)\n    {\n      for(int to=0; to < 3; ++to)\n      {\n        long sumtemp=0;\n        if (from <= to){\n          for(int j=from; j <= to; ++j)\n            sumtemp += data[j][i];\n        }\n        else\n        {\n          for(int j=from; to <= j; --j)\n            sumtemp += data[j][i];\n        }\n\n        opt[to][i] = Math.max(opt[to][i], opt[from][i-1] + sumtemp);\n      }\n    }\n  }\n  sb.append(opt[2][n+1]); sb.append('\n');\n      System.out.print(sb.toString());\n    }catch(Exception ex){\n        ex.printStackTrace();      \n    }\n  }\n}","dp,greedy,implementation"
"import java.util.*;\npublic class codeforces {\n	public static void main(String[] args){\n		//System.out.println(maxPath(new long[][]{{1,1,1},{1,-1,1},{1,1,1}}));	\n		Scanner input = new Scanner(System.in);\n		int n = input.nextInt();\n		long[][] a = new long[3][n];\n		for(int i = 0; i < 3;i++){\n			for(int j = 0; j < n;j++){\n				a[i][j] = input.nextLong();\n			}\n		}\n		System.out.println(maxPath(a));\n	}\n	private static long max(long first,long ... ls){\n		long max = first;\n		for(long number:ls){\n			max = Math.max(number, max);\n		}\n		return max;\n	}\n	\n	static long maxPath(long[][] arr){\n		long[][] sol = new long[3][arr[0].length + 20]; \n		for(int i = 0; i < 3;i++){\n			for(int j = 0; j < sol[i].length;j++){\n				sol[i][j] = -1000000000000000000L;\n			}\n		}\n		long s = 0L;\n		sol[0][0] = 0L;\n		for(int i = 0; i < arr[0].length;i++){\n			sol[0][i + 1] = max(sol[0][i + 1],sol[0][i] + arr[0][i], sol[1][i] + arr[1][i] + arr[0][i], sol[2][i] + arr[2][i] + arr[1][i] + arr[0][i]);\n			sol[1][i + 1] = max(sol[1][i + 1],sol[0][i] + arr[1][i] + arr[0][i],sol[1][i] + arr[1][i],sol[2][i] + arr[2][i] + arr[1][i]);\n			sol[2][i + 1] = max(sol[2][i + 1],sol[0][i] + arr[0][i] + arr[1][i] + arr[2][i], sol[1][i] + arr[1][i] + arr[2][i],sol[2][i] + arr[2][i]);\n			if(i + 2 <= arr[0].length){\n				s = arr[0][i] + arr[1][i] + arr[2][i] + arr[0][i + 1] + arr[1][i + 1] + arr[2][i + 1];\n				sol[0][i + 2] = max(sol[0][i + 2],sol[0][i] + s);\n				sol[0][i + 2] = max(sol[0][i + 2],sol[2][i] + s);\n				sol[2][i + 2] = max(sol[2][i + 2],sol[0][i] + s);\n				sol[2][i + 2] = max(sol[2][i + 2],sol[2][i] + s);\n			}\n		}\n		return sol[2][arr[0].length];\n	}\n}","dp,greedy,implementation"
"import java.util.*;\n \npublic class F1{\n	public static void main(String[] args) {\n\n		Scanner sc = new Scanner(System.in);\n		long n = sc.nextLong(); \n		long k = sc.nextLong();\n\n		List<Long> arr = new ArrayList<>();\n		arr.add((long)0); \n\n		for(long i=1; i*i<=n; i++)\n			if(n % i == 0){\n				arr.add(i);\n				if(i*i != n)\n					arr.add(n/i);\n			}\n		Collections.sort(arr);\n\n		if(k >= arr.size())\n			System.out.print(""-1"");\n		else\n			System.out.print(arr.get((int)k));\n	}\n}\n	 	    			 	 		  				  				","math,number theory"
"import java.util.*;\n \npublic class kthdivisor{\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		long n = sc.nextLong(); //12\n		long k = sc.nextLong(); //5\n		List<Long> list = new ArrayList<>();\n		list.add((long)0); // 0 1 12 \n		for(long i=1; i*i<=n; i++)\n			if(n%i == 0){\n				list.add(i);\n				if(i*i != n)\n					list.add(n/i);\n			}\n		Collections.sort(list);\n		if(k >= list.size())\n			System.out.print(""-1"");\n		else\n			System.out.print(list.get((int)k));\n	}\n}","math,number theory"
\nimport java.util.*;\n\npublic class AprilFool2021 {\n\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n\n		long n = s.nextLong();\n		long k = s.nextLong();\n\n		List<Long> h = new ArrayList<>();\n		h.add((long) 0);\n		for (long i = 1; i * i <= n; i++) {\n			if (n % i == 0) {\n				h.add(i);\n\n				if (i * i != n) {\n					h.add(n / i);\n\n				}\n			}\n		}\n		Collections.sort(h);\n		if (k>=h.size()) {\n			System.out.println(-1);\n		} else {\n			System.out.println(h.get((int) k));\n		}\n\n	}\n\n}\n,"math,number theory"
"import java.io.*;\nimport java.util.*;\npublic class Divisor\n{\npublic static void main(String...s)\n{\n	ArrayList <Long> arrLi = new ArrayList<Long>();\n	Scanner sc = new Scanner(System.in);\n	long n, i;\n	n = sc.nextLong();\n	int k = sc.nextInt();\n	for(i=1; i*i<=n; i++)\n	{\n		if(n%i==0)\n		{\n			if(n == i*i)\n				arrLi.add(i);\n			else\n			{\n				arrLi.add(i);\n				arrLi.add(n/i);\n			}\n		}\n	}\n	if(k > arrLi.size())\n		System.out.println(-1);\n	else\n	{\n		Collections.sort(arrLi);\n		System.out.println(arrLi.get(k-1));\n	}\n}\n}","math,number theory"
"import java.util.*;\nimport java.lang.Math;\n\npublic class Main\n{\n	public static void main(String[] args) {\n		Scanner s=new Scanner(System.in);\n		int m=s.nextInt();\n		int d=s.nextInt();\n		int a[]={0,31,28,31,30,31,30,31,31,30,31,30,31};\n		int x=a[m]-(8-d);\n		System.out.println((x+6)/7 +1);\n	}\n}\n","implementation,math"
"import java.util.*;\nimport java.lang.*;\n\npublic class Main {\n	public static void main(String args[]) {\n		Scanner sc = new Scanner(System.in);\n		int days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n		int m = sc.nextInt();\n		int w = sc.nextInt();\n		int x=days[m]-(7-w+1);\n		System.out.println(((x+6)/7)+1);\n	}\n}","implementation,math"
"import java.util.*;\n\npublic class PetrAndACalendar {\n\n	static void solve() {\n		Scanner sc = new Scanner(System.in);\n		int m = sc.nextInt(), d = sc.nextInt();\n		int[] days = new int[]{31,28,31,30,31,30,31,31,30,31,30,31};\n		System.out.println((((d-1)+days[m-1]-1)/7)+1);\n		sc.close();\n	}\n\n	public static void main(String[] args) {\n		solve();\n	}\n}","implementation,math"
"    import java.util.*;\n    public class tut {\n        public static void main(String args[])\n        {\n           Scanner sc=new Scanner(System.in);\n           int mon[]={0,31,28,31,30,31,30,31,31,30,31,30,31};\n           int m=sc.nextInt();\n           int d=sc.nextInt();\n           double res=mon[m]+d-1;\n           System.out.println((int)Math.ceil(res/7));\n}\n    }\n","implementation,math"
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be ""Main"" only if the class is public. */\npublic class Codeforces\n{\n	public static void main (String[] args) throws java.lang.Exception\n	{\n		Scanner sc=new Scanner(System.in);\n		String str=sc.nextLine();\n	\n		int arr[]=new int[256];\n			Arrays.fill(arr,0);\n		for(int i=0;i<str.length();i++){ \n		    arr[str.charAt(i)]++;\n		}\n		int num=Integer.MAX_VALUE;\n		String patt=""Bulbasaur"";\n		int arr2[]=new int[256];\n		for(int i=0;i<patt.length();i++){ \n		    arr2[patt.charAt(i)]++;\n		}\n		for(int i=0;i<256;i++){ \n		    if(arr2[i]!=0){ \n		        num=Math.min(num,arr[i]/arr2[i]);\n		    }\n		}\n		System.out.println(num);\n	}\n}\n",implementation
"/*package whatever //do not write package name here */\n\nimport java.io.*;\nimport java.lang.*;\nimport java.util.*;\npublic class GFG {\n	public static void main (String[] args) {\n	 Scanner in=new Scanner(System.in);\n	 String str=in.next();\n	     int len,i,A,B,C,D,E,F;\n	       int B1=0,u=0,l=0,b=0,s=0,a=0,r=0;\n	 for(char ch:str.toCharArray()){\n	   \n	     if(ch=='B'){\n	         B1++;\n	     }\n	     if(ch=='u'){\n	         u++;\n	     }\n	     if(ch=='l'){\n	         l++;\n	     }\n	     if(ch=='b'){\n	         b++;\n	     }\n	     if(ch=='s'){\n	         s++;\n	     }\n	     if(ch=='a'){\n	         a++;\n	     }\n	     if(ch=='r'){\n	         r++;\n	     }\n	 }\n	 a/=2;\n	 u/=2;\n	 A=Math.min(B1,u);\n	 B=Math.min(A,l);\n	 C=Math.min(B,b);\n	 D=Math.min(C,s);\n	 E=Math.min(D,a);\n	 F=Math.min(E,r);\n	 System.out.println(F);\n	}\n}",implementation
"import java.util.*;\nimport java.util.Map.Entry;\n\npublic class CR572B {\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		String str = s.next();\n\n		int cB = 0;\n		int cu = 0;\n		int cl = 0;\n		int cb = 0;\n		int ca = 0;\n		int cs = 0;\n		int cr = 0;\n\n		\n		for (int i = 0; i < str.length(); i++) {\n			if (str.charAt(i) == 'B') {\n				cB++;\n			}\n			if (str.charAt(i) == 'u') {\n				cu++;\n			}\n			if (str.charAt(i) == 'l') {\n				cl++;\n			}\n			if (str.charAt(i) == 'b') {\n				cb++;\n			}\n			if (str.charAt(i) == 'a') {\n				ca++;\n			}\n			if (str.charAt(i) == 's') {\n				cs++;\n			}\n			if (str.charAt(i) == 'r') {\n				cr++;\n			}\n		}\n\n		int ans = Integer.MAX_VALUE;\n		ans = Math.min(ans, Math.min(cB, Math.min(cu/2, Math.min(cl, Math.min(cb, Math.min(ca/2, Math.min(cs, cr)))))));\n\n		System.out.println(ans);\n\n	}\n}\n",implementation
import java.util.*;\npublic class GottaCatchEmAll {\n\n	public static void main(String[] args) {\n		\n		Scanner in = new Scanner(System.in);\n		String str = in.nextLine();\n		// Bulbasaur\n		// Bulbasr\n		// duplicated: u & a\n		int Bcount = 0;\n		int ucount = 0;\n		int lcount = 0;\n		int bcount = 0;\n		int acount = 0;\n		int scount = 0;\n		int rcount = 0;\n		char[] chars = str.toCharArray();\n		for (char c : chars) {\n			if (c == 'B')\n				Bcount++;\n			else if (c == 'u')\n				ucount++;\n			else if (c == 'l')\n				lcount++;\n			else if (c == 'b')\n				bcount++;\n			else if (c == 'a')\n				acount++;\n			else if (c == 's')\n				scount++;\n			else if (c == 'r')\n				rcount++;\n		}\n\n		ucount /= 2;\n		acount /= 2;\n		\n		ArrayList<Integer> ar = new ArrayList<Integer>();\n\n		ar.add(Bcount);\n		ar.add(ucount);\n		ar.add(lcount);\n		ar.add(bcount);\n		ar.add(acount);\n		ar.add(scount);\n		ar.add(rcount);\n\n		\n		System.out.println(Collections.min(ar));\n		\n	}\n\n}\n,implementation
"import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Test {\n  static PrintWriter writer =\n      new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n  int n, k;\n  int N = 1 << 16;\n  int[][] f = new int[5][N];\n  int idx = 0;\n\n  public static void main(String[] args) {\n    Test te = new Test();\n    te.start();\n    writer.flush();\n  }\n\n  static int readInt() {\n    int ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  static long readLong() {\n    long ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  static String readString() {\n    StringBuilder b = new StringBuilder();\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (Character.isLetterOrDigit(c)) {\n          start = true;\n          b.append((char) c);\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return b.toString();\n  }\n\n  static int readChars(char[] a, int off) {\n    int cnt = 0;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (Character.isLetterOrDigit(c)) {\n          start = true;\n          a[off + cnt++] = (char) c;\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return cnt;\n  }\n\n  void solve(int n) {\n    if (n == 1) {\n      f[0][0] = 1;\n      f[0][1] = 0;\n      f[1][0] = 1;\n      f[1][1] = 1;\n      idx = 1;\n      return;\n    }\n    if (n == 2) {\n      f[1][0] = 1;\n      f[1][1] = 1;\n      f[2][0] = 1;\n      f[2][1] = 3;\n      f[2][2] = 1;\n      idx = 2;\n      return;\n    }\n    if (n % 2 == 1) {\n      solve(n - 1);\n      int nidx = (idx + 1) % 3, pidx = (idx + 3 - 1) % 3;\n      f[nidx][0] = 1;\n      for (int i = 1; i <= k; i++)\n        f[nidx][i] = Ntt.add(Ntt.add(f[idx][i], f[idx][i - 1]), f[pidx][i - 1]);\n      idx = nidx;\n      return;\n    }\n\n    solve(n / 2);\n    int nidx = (idx + 1) % 3, pidx = (idx + 3 - 1) % 3, ppidx = 3;\n    for (int i = 0; i + 1 <= k; i++)\n      f[ppidx][i] = Ntt.add(f[idx][i + 1], Ntt.M - Ntt.add(f[pidx][i], f[pidx][i + 1]));\n\n    Arrays.fill(f[idx], k + 1, N, 0);\n    Arrays.fill(f[pidx], k + 1, N, 0);\n    Arrays.fill(f[ppidx], k + 1, N, 0);\n\n    Ntt.fft(f[idx], 0, N);\n    Ntt.fft(f[pidx], 0, N);\n    Ntt.fft(f[ppidx], 0, N);\n\n    for (int i = 0; i < N; i++) f[nidx][i] = Ntt.mul(f[idx][i], f[idx][i]);\n    Ntt.ifft(f[nidx], 0, N);\n\n    for (int i = 0; i < N; i++) f[4][i] = Ntt.mul(f[pidx][i], f[pidx][i]);\n    Ntt.ifft(f[4], 0, N);\n    for (int i = 1; i <= k; i++) f[nidx][i] = Ntt.add(f[nidx][i], f[4][i - 1]);\n\n    for (int i = 0; i < N; i++) f[idx][i] = Ntt.mul(f[idx][i], f[pidx][i]);\n    Ntt.ifft(f[idx], 0, N);\n\n    for (int i = 0; i < N; i++) f[pidx][i] = Ntt.mul(f[pidx][i], f[ppidx][i]);\n    Ntt.ifft(f[pidx], 0, N);\n    for (int i = 1; i <= k; i++) f[idx][i] = Ntt.add(f[idx][i], f[pidx][i - 1]);\n\n    idx = nidx;\n  }\n\n  void start() {\n    n = readInt();\n    k = readInt();\n    solve(n);\n    for (int i = 1; i <= k; i++) writer.print(f[idx][i] + "" "");\n  }\n\n  static class Ntt {\n    static final int pri = 3;\n    static final int M = 998_244_353;\n    static int[] xy = new int[2];\n\n    static int pmod(int b, int e) {\n      int i = 1 << 31;\n      int r = 1;\n      while (i != 0) {\n        r = mul(r, r);\n        if ((e & i) != 0) r = mul(r, b);\n        i >>>= 1;\n      }\n      return r;\n    }\n\n    static void fft(int[] a, int off, int len) {\n      for (int i = 0; i < len; i++) {\n        int j = i, x = 0, y = len - 1;\n        while (y > 0) {\n          x = (x << 1) + (j & 1);\n          j >>>= 1;\n          y >>>= 1;\n        }\n        if (i < x) {\n          int t = a[off + i];\n          a[off + i] = a[off + x];\n          a[off + x] = t;\n        }\n      }\n      for (int i = 1; i < len; i *= 2) {\n        int s = pmod(pri, (M - 1) / 2 / i);\n        for (int j = 0; j < len; j += 2 * i) {\n          int w = 1;\n          for (int k = 0; k < i; k++) {\n            int u = a[off + j + k], v = mul(a[off + j + k + i], w);\n            a[off + j + k] = add(u, v);\n            a[off + j + k + i] = add(u, M - v);\n            w = mul(w, s);\n          }\n        }\n      }\n    }\n\n    static void ifft(int[] a, int off, int len) {\n      int ll = 1, rr = len - 1;\n      while (ll < rr) {\n        int t = a[off + ll];\n        a[off + (ll++)] = a[off + rr];\n        a[off + (rr--)] = t;\n      }\n      fft(a, off, len);\n      int inv = pmod(len, M - 2);\n      for (int i = 0; i < len; i++) a[off + i] = mul(inv, a[off + i]);\n    }\n\n    static int add(int a, int b) {\n      return (a + b) % M;\n    }\n\n    static int mul(int a, int b) {\n      return (int) ((a * (long) b) % M);\n    }\n\n    static int inverse(int a, int b) {\n      if (b == 0) {\n        xy[0] = 1;\n        xy[1] = 0;\n        return a;\n      }\n      int d = inverse(b, a % b);\n      swap(xy, 0, 1);\n      xy[1] -= a / b * xy[0];\n      return d;\n    }\n\n    static void swap(int[] a, int i, int j) {\n      int t = a[i];\n      a[i] = a[j];\n      a[j] = t;\n    }\n  }\n}\n","combinatorics,divide and conquer,dp,fft,math,number theory"
"import java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Test {\n  static PrintWriter writer =\n      new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n  int n, k;\n  int N = 1 << 16;\n  int[][] f = new int[5][N];\n  int idx = 0;\n\n  public static void main(String[] args) {\n    Test te = new Test();\n    te.start();\n    writer.flush();\n  }\n\n  static int readInt() {\n    int ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  static long readLong() {\n    long ans = 0;\n    boolean neg = false;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (c == '-') {\n          start = true;\n          neg = true;\n          continue;\n        } else if (c >= '0' && c <= '9') {\n          start = true;\n          ans = ans * 10 + c - '0';\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return neg ? -ans : ans;\n  }\n\n  static String readString() {\n    StringBuilder b = new StringBuilder();\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (Character.isLetterOrDigit(c)) {\n          start = true;\n          b.append((char) c);\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return b.toString();\n  }\n\n  static int readChars(char[] a, int off) {\n    int cnt = 0;\n    try {\n      boolean start = false;\n      for (int c = 0; (c = System.in.read()) != -1; ) {\n        if (Character.isLetterOrDigit(c)) {\n          start = true;\n          a[off + cnt++] = (char) c;\n        } else if (start) break;\n      }\n    } catch (IOException e) {\n    }\n    return cnt;\n  }\n\n  void solve(int n) {\n    if (n == 1) {\n      f[0][0] = 1;\n      f[0][1] = 0;\n      f[1][0] = 1;\n      f[1][1] = 1;\n      idx = 1;\n      return;\n    }\n    if (n == 2) {\n      f[1][0] = 1;\n      f[1][1] = 1;\n      f[2][0] = 1;\n      f[2][1] = 3;\n      f[2][2] = 1;\n      idx = 2;\n      return;\n    }\n    if (n % 2 == 1) {\n      solve(n - 1);\n      int nidx = (idx + 1) % 3, pidx = (idx + 3 - 1) % 3;\n      f[nidx][0] = 1;\n      for (int i = 1; i <= k; i++)\n        f[nidx][i] = Ntt.add(Ntt.add(f[idx][i], f[idx][i - 1]), f[pidx][i - 1]);\n      idx = nidx;\n      return;\n    }\n\n    solve(n / 2);\n    int nidx = (idx + 1) % 3, pidx = (idx + 3 - 1) % 3, ppidx = 3;\n    for (int i = 0; i + 1 <= k; i++)\n      f[ppidx][i] = Ntt.add(f[idx][i + 1], Ntt.M - Ntt.add(f[pidx][i], f[pidx][i + 1]));\n\n    Arrays.fill(f[idx], k + 1, N, 0);\n    Arrays.fill(f[pidx], k + 1, N, 0);\n    Arrays.fill(f[ppidx], k + 1, N, 0);\n\n    Ntt.fft(f[idx], 0, N);\n    Ntt.fft(f[pidx], 0, N);\n    Ntt.fft(f[ppidx], 0, N);\n\n    for (int i = 0; i < N; i++) f[nidx][i] = Ntt.mul(f[idx][i], f[idx][i]);\n    Ntt.ifft(f[nidx], 0, N);\n\n    for (int i = 0; i < N; i++) f[4][i] = Ntt.mul(f[pidx][i], f[pidx][i]);\n    Ntt.ifft(f[4], 0, N);\n    for (int i = 1; i <= k; i++) f[nidx][i] = Ntt.add(f[nidx][i], f[4][i - 1]);\n\n    for (int i = 0; i < N; i++) f[idx][i] = Ntt.mul(f[idx][i], f[pidx][i]);\n    Ntt.ifft(f[idx], 0, N);\n\n    for (int i = 0; i < N; i++) f[pidx][i] = Ntt.mul(f[pidx][i], f[ppidx][i]);\n    Ntt.ifft(f[pidx], 0, N);\n    for (int i = 1; i <= k; i++) f[idx][i] = Ntt.add(f[idx][i], f[pidx][i - 1]);\n\n    idx = nidx;\n  }\n\n  void start() {\n    n = readInt();\n    k = readInt();\n    solve(n);\n    for (int i = 1; i <= k; i++) writer.print(f[idx][i] + "" "");\n  }\n\n  static class Ntt {\n    static final int pri = 3;\n    static final int M = 998_244_353;\n    static int[] xy = new int[2];\n\n    static int pmod(int b, int e) {\n      int i = 1 << 31;\n      int r = 1;\n      while (i != 0) {\n        r = mul(r, r);\n        if ((e & i) != 0) r = mul(r, b);\n        i >>>= 1;\n      }\n      return r;\n    }\n\n    static void fft(int[] a, int off, int len) {\n      for (int i = 0; i < len; i++) {\n        int j = i, x = 0, y = len - 1;\n        while (y > 0) {\n          x = (x << 1) + (j & 1);\n          j >>>= 1;\n          y >>>= 1;\n        }\n        if (i < x) {\n          int t = a[off + i];\n          a[off + i] = a[off + x];\n          a[off + x] = t;\n        }\n      }\n      for (int i = 1; i < len; i *= 2) {\n        int n = 2 * i;\n        int s = pmod(pri, (M - 1) / n);\n        for (int j = 0; j < len; j += n) {\n          int w = 1;\n          for (int k = 0; k < i; k++) {\n            int u = a[off + j + k], v = mul(a[off + j + k + i], w);\n            a[off + j + k] = add(u, v);\n            a[off + j + k + i] = add(u, M - v);\n            w = mul(w, s);\n          }\n        }\n      }\n    }\n\n    static void ifft(int[] a, int off, int len) {\n      int ll = 1, rr = len - 1;\n      while (ll < rr) {\n        int t = a[off + ll];\n        a[off + (ll++)] = a[off + rr];\n        a[off + (rr--)] = t;\n      }\n      fft(a, off, len);\n      int inv = inverse(len);\n      for (int i = 0; i < len; i++) a[off + i] = mul(inv, a[off + i]);\n    }\n\n    static int add(int a, int b) {\n      return (a + b) % M;\n    }\n\n    static int mul(int a, int b) {\n      return (int) ((a * (long) b) % M);\n    }\n\n    static int inverse(int a) {\n      return pmod(a, M - 2);\n    }\n\n    static int inverse(int a, int b) {\n      if (b == 0) {\n        xy[0] = 1;\n        xy[1] = 0;\n        return a;\n      }\n      int d = inverse(b, a % b);\n      swap(xy, 0, 1);\n      xy[1] -= a / b * xy[0];\n      return d;\n    }\n\n    static void swap(int[] a, int i, int j) {\n      int t = a[i];\n      a[i] = a[j];\n      a[j] = t;\n    }\n  }\n}\n","combinatorics,divide and conquer,dp,fft,math,number theory"
"import java.io.IOException;\nimport java.util.Arrays;\n\npublic class Test {\n\n    final int K = 1 << 15;\n    final int M = 998244353;\n    final int g = 3;\n    int n, k, k2;\n    long[][] f = new long[7][K * 4 + 1];\n    int idx = 1;\n\n    long pmod(int b, int e) {\n        int i = 1 << 31;\n        long r = 1;\n        while (i != 0) {\n            r = (r * r) % M;\n            if ((e & i) != 0) r = (r * b) % M;\n            i >>>= 1;\n        }\n        return r;\n    }\n\n    void fft(long[] a, int len) {\n        for (int i = 0; i < len; i++) {\n            int j = i, x = 0, y = len - 1;\n            while (y > 0) {\n                x = (x << 1) + (j & 1);\n                j >>>= 1;\n                y >>>= 1;\n            }\n            if (i < x) {\n                long t = a[i];\n                a[i] = a[x];\n                a[x] = t;\n            }\n        }\n        for (int i = 1; i < len; i *= 2) {\n            long s = pmod(g, (M - 1) / 2 / i);\n            for (int j = 0; j < len; j += 2 * i) {\n                long w = 1;\n                for (int k = 0; k < i; k++) {\n                    long u = a[j + k], v = (a[j + k + i] * w) % M;\n                    a[j + k] = (u + v) % M;\n                    a[j + k + i] = (u - v + M) % M;\n                    w = (w * s) % M;\n                }\n            }\n        }\n    }\n\n    void ifft(long[] a, int len) {\n        int ll = 1, rr = len - 1;\n        while (ll < rr) {\n            long t = a[ll];\n            a[ll++] = a[rr];\n            a[rr--] = t;\n        }\n        fft(a, len);\n        long inv = pmod(len, M - 2);\n        for (int i = 0; i < len; i++) a[i] = (inv * a[i]) % M;\n    }\n\n    void mul(long[] a, long[] b, long[] c, int len) {\n        for (int i = 0; i < len; i++) c[i] = (a[i] * b[i]) % M;\n    }\n\n    int readInt() {\n        int ans = 0;\n        try {\n            boolean start = false;\n            for (int c = 0; (c = System.in.read()) != -1; ) {\n                if (c >= '0' && c <= '9') {\n                    start = true;\n                    ans = ans * 10 + c - '0';\n                } else if (start) break;\n            }\n        } catch (IOException e) {\n        }\n        return ans;\n    }\n\n    void find(int n) {\n        if (n == 1) {\n            f[0][0] = 1;\n            f[0][1] = 0;\n            f[1][0] = 1;\n            f[1][1] = 1;\n            return;\n        }\n        if (n == 2) {\n            f[0][0] = 1;\n            f[0][1] = 1;\n            f[0][2] = 0;\n            f[1][0] = 1;\n            f[1][1] = 3;\n            f[1][2] = 1;\n            return;\n        }\n        if (n % 2 == 1) {\n            find(n - 1);\n            int nidx = (idx + 1) % 3, pidx = (idx + 3 - 1) % 3;\n            f[nidx][0] = 1;\n            for (int i = 1; i < k2; i++) f[nidx][i] = (f[idx][i] + f[idx][i - 1] + f[pidx][i - 1]) % M;\n            idx = nidx;\n            return;\n        }\n        find(n / 2);\n        int nidx = (idx + 1) % 3, pidx = (idx + 3 - 1) % 3;\n        System.arraycopy(f[idx], 0, f[6], 0, k2);\n        System.arraycopy(f[pidx], 0, f[5], 0, k2);\n        for (int i = 0; i < k2 - 1; i++) f[4][i] = (f[idx][i + 1] - f[pidx][i + 1] - f[pidx][i] + M) % M;\n        Arrays.fill(f[6], k2, k2 + k2, 0);\n        Arrays.fill(f[5], k2, k2 + k2, 0);\n        Arrays.fill(f[4], k2 - 1, k2 + k2, 0);\n\n        fft(f[6], k2 + k2);\n        fft(f[5], k2 + k2);\n        fft(f[4], k2 + k2);\n\n        mul(f[6], f[6], f[nidx], k2 + k2);\n        ifft(f[nidx], k2 + k2);\n        mul(f[5], f[5], f[3], k2 + k2);\n        ifft(f[3], k2 + k2);\n        for (int i = 1; i < k2; i++) f[nidx][i] = (f[nidx][i] + f[3][i - 1]) % M;\n\n        mul(f[6], f[5], f[idx], k2 + k2);\n        ifft(f[idx], k2 + k2);\n        mul(f[5], f[4], f[3], k2 + k2);\n        ifft(f[3], k2 + k2);\n        for (int i = 1; i < k2; i++) f[idx][i] = (f[idx][i] + f[3][i - 1]) % M;\n        idx = nidx;\n    }\n\n    void start() {\n        n = readInt();\n        k = readInt();\n        k2 = 2;\n        while (k2 <= k) k2 *= 2;\n        find(n);\n        int mk = Math.min(n, k);\n        for (int i = 1; i <= mk; i++) System.out.print(f[idx][i] + "" "");\n        for (int i = mk + 1; i <= k; i++) System.out.print(0 + "" "");\n    }\n\n    public static void main(String[] args) {\n        Test t = new Test();\n        t.start();\n    }\n\n}","combinatorics,divide and conquer,dp,fft,math,number theory"
"import java.io.IOException;\nimport java.util.Arrays;\n\npublic class Test {\n\n    final int K = 1 << 15;\n    final int M = 998244353;\n    final int g = 3;\n    int n, k, k2;\n    int[][] f = new int[5][K * 2 + 1];\n    int idx = 1;\n\n    long pmod(int b, int e) {\n        int i = 1 << 31;\n        long r = 1;\n        while (i != 0) {\n            r = (r * r) % M;\n            if ((e & i) != 0) r = (r * b) % M;\n            i >>>= 1;\n        }\n        return r;\n    }\n\n    void fft(int[] a, int len) {\n        for (int i = 0; i < len; i++) {\n            int j = i, x = 0, y = len - 1;\n            while (y > 0) {\n                x = (x << 1) + (j & 1);\n                j >>>= 1;\n                y >>>= 1;\n            }\n            if (i < x) {\n                int t = a[i];\n                a[i] = a[x];\n                a[x] = t;\n            }\n        }\n        for (int i = 1; i < len; i *= 2) {\n            long s = pmod(g, (M - 1) / 2 / i);\n            for (int j = 0; j < len; j += 2 * i) {\n                long w = 1;\n                for (int k = 0; k < i; k++) {\n                    int u = a[j + k], v = (int)((a[j + k + i] * w) % M);\n                    a[j + k] = (u + v) % M;\n                    a[j + k + i] = (u - v + M) % M;\n                    w = (w * s) % M;\n                }\n            }\n        }\n    }\n\n    void ifft(int[] a, int len) {\n        int ll = 1, rr = len - 1;\n        while (ll < rr) {\n            int t = a[ll];\n            a[ll++] = a[rr];\n            a[rr--] = t;\n        }\n        fft(a, len);\n        long inv = pmod(len, M - 2);\n        for (int i = 0; i < len; i++) a[i] = (int)((inv * a[i]) % M);\n    }\n\n    void mul(int[] a, int[] b, int[] c, int len) {\n        for (int i = 0; i < len; i++) c[i] = (int)((a[i] * (long)b[i]) % M);\n    }\n\n    int readInt() {\n        int ans = 0;\n        try {\n            boolean start = false;\n            for (int c = 0; (c = System.in.read()) != -1; ) {\n                if (c >= '0' && c <= '9') {\n                    start = true;\n                    ans = ans * 10 + c - '0';\n                } else if (start) break;\n            }\n        } catch (IOException e) {\n        }\n        return ans;\n    }\n\n    void find(int n) {\n        if (n == 1) {\n            f[0][0] = 1;\n            f[0][1] = 0;\n            f[1][0] = 1;\n            f[1][1] = 1;\n            return;\n        }\n        if (n == 2) {\n            f[0][0] = 1;\n            f[0][1] = 1;\n            f[0][2] = 0;\n            f[1][0] = 1;\n            f[1][1] = 3;\n            f[1][2] = 1;\n            return;\n        }\n        if (n % 2 == 1) {\n            find(n - 1);\n            int nidx = (idx + 1) % 3, pidx = (idx + 3 - 1) % 3;\n            f[nidx][0] = 1;\n            for (int i = 1; i < k2; i++) {\n                f[nidx][i] = (f[idx][i] + f[idx][i - 1]) % M;\n                f[nidx][i] = (f[nidx][i] + f[pidx][i - 1]) % M;\n            }\n            idx = nidx;\n            return;\n        }\n        find(n / 2);\n        int nidx = (idx + 1) % 3, pidx = (idx + 3 - 1) % 3;\n        for (int i = 0; i < k2 - 1; i++) {\n            f[3][i] = (f[idx][i + 1] - f[pidx][i + 1] + M) % M;\n            f[3][i] = (f[3][i] - f[pidx][i] + M) % M;\n        }\n        Arrays.fill(f[idx], k2, k2 + k2, 0);\n        Arrays.fill(f[pidx], k2, k2 + k2, 0);\n        Arrays.fill(f[3], k2 - 1, k2 + k2, 0);\n\n        fft(f[idx], k2 + k2);\n        fft(f[pidx], k2 + k2);\n        fft(f[3], k2 + k2);\n\n        mul(f[idx], f[idx], f[nidx], k2 + k2);\n        ifft(f[nidx], k2 + k2);\n        mul(f[pidx], f[pidx], f[4], k2 + k2);\n        ifft(f[4], k2 + k2);\n        for (int i = 1; i < k2; i++) f[nidx][i] = (f[nidx][i] + f[4][i - 1]) % M;\n\n        mul(f[idx], f[pidx], f[idx], k2 + k2);\n        ifft(f[idx], k2 + k2);\n        mul(f[pidx], f[3], f[4], k2 + k2);\n        ifft(f[4], k2 + k2);\n        for (int i = 1; i < k2; i++) f[idx][i] = (f[idx][i] + f[4][i - 1]) % M;\n        idx = nidx;\n    }\n\n    void start() {\n        n = readInt();\n        k = readInt();\n        k2 = 2;\n        while (k2 <= k) k2 *= 2;\n        find(n);\n        int mk = Math.min(n, k);\n        for (int i = 1; i <= mk; i++) System.out.print(f[idx][i] + "" "");\n        for (int i = mk + 1; i <= k; i++) System.out.print(0 + "" "");\n    }\n\n    public static void main(String[] args) {\n        Test t = new Test();\n        t.start();\n    }\n\n}","combinatorics,divide and conquer,dp,fft,math,number theory"
"import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.text.DecimalFormat;\n\npublic class F {\n	static long[] sum = new long[200008];\n\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int n = scan.nextInt();\n		int M = 0;\n		for (int i = 1; i <= n; i++) {\n			int x = scan.nextInt();\n			M = Math.max(M, x);\n			sum[x]++;\n		}\n		for (int i = 1; i <= M+1; i++) {\n			sum[i]+=sum[i-1];\n		}\n		long ans = 0;\n		for (int i = 1; i <= M+1; i++) {\n			if(sum[i]-sum[i-1]>0){\n				long tmp = 0;\n				for(int j = i;j<=M;j+=i){\n					long c = sum[Math.min(M+1, j+i-1)]-sum[j-1];\n					tmp+=c*j;\n				}\n				ans = Math.max(ans, tmp);\n			}\n		}\n		System.out.println(ans);\n	}\n}","brute force,data structures,implementation,math,number theory"
import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\npublic class mainn {\n	public static void main(String args[]){\n		Scanner data = new Scanner(System.in);\n		int n = data.nextInt();\n		int a[] = new int[n];\n		int b[] = new int[400010];\n		int sum[] = new int[400010];\n		long max=0;\n		for(int i=0;i<n;i++){\n			a[i]=data.nextInt();\n			b[a[i]]++;\n		}\n		sum[1]=b[1];\n		for(int i=2;i<400010;i++){\n			sum[i]=sum[i-1]+b[i];\n		}\n		Arrays.sort(a);\n		long summ=0;\n		boolean v[] = new boolean[400010];\n		for(int i=0;i<n;i++){\n			if(v[a[i]])continue;\n			v[a[i]]=true;\n			for(int j=a[i];j<200001;j+=a[i]){\n				v[a[i]+j]=true;\n				long y = j;\n				long x = sum[j+a[i]-1]-sum[j-1];\n				summ+=y*x;\n			}\n			if(summ>max)\n				max=summ;\n			summ=0;\n		}\n		System.out.println(max);\n	}\n}\n,"brute force,data structures,implementation,math,number theory"
import java.io.*;\nimport java.util.*;\n\npublic class CF731F {\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		int n = Integer.parseInt(br.readLine());\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int[] aa = new int[n];\n		for (int i = 0; i < n; i++)\n			aa[i] = Integer.parseInt(st.nextToken());\n		Arrays.sort(aa);\n		int m = aa[n - 1];\n		int[] bb = new int[m + 1];\n		for (int i = 0; i < n; i++)\n			bb[aa[i]]++;\n		for (int j = m - 1; j >= 0; j--)\n			bb[j] += bb[j + 1];\n		long max = 0;\n		for (int i = 0; i < n; i++) {\n			if (i > 0 && aa[i] == aa[i - 1])\n				continue;\n			long sum = 0;\n			for (int j = aa[i]; j <= m; j += aa[i])\n				sum += bb[j];\n			sum *= aa[i];\n			if (max < sum)\n				max = sum;\n		}\n		System.out.println(max);\n	}\n}\n,"brute force,data structures,implementation,math,number theory"
"import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class CF {\n	\n	public static void main(String[] args) throws NumberFormatException, IOException {\n		\n		Scanner in = new Scanner(System.in);\n		\n		int n = Integer.parseInt(in.nextLine());\n		\n 		long[] pre = new long[200_001];\n\n		for(int i=0; i<n; i++) {\n			pre[in.nextInt()]++;\n		}\n		\n		\n		for(int i=1; i<pre.length; i++) {\n			pre[i] += pre[i-1];\n		}\n		\n		\n		long best = 1;\n		\n		for(int i=1; i<200_001; i++) {\n			if(pre[i] - pre[i-1] > 0) {\n				long cur = 0;\n				\n				for(int j=i; j<pre.length; j+=i) {	// logn steps\n					\n					cur += j * (pre[Math.min(j+i-1, pre.length-1)] - pre[j-1]); \n				}\n				\n				best = Math.max(best, cur);\n			}\n		}\n		\n		System.out.println(best);\n\n	}\n\n}","brute force,data structures,implementation,math,number theory"
"import java.io.*;\nimport java.util.*;\npublic class div376D\n{\n	BufferedReader in;\n	PrintWriter ob;\n	StringTokenizer st;\n	public static void main(String[] args) throws IOException {\n		new div376D().run();\n	}\n	void run() throws IOException {\n		in=new BufferedReader(new BufferedReader(new InputStreamReader(System.in)));\n		ob=new PrintWriter(System.out);\n		solve();\n		ob.flush();\n	}\n	void solve() throws IOException {\n		int n=ni();\n		int k=ni();\n		int a[][]=new int[n+1][];\n		for (int i=1; i<=n ; i++ ) {\n			int m=ni();\n			a[i]=new int[m+1];\n			a[i][0]=m;\n			for (int j=1; j<=m ; j++ ) {\n				a[i][j]=ni();\n			}\n		}\n		int mark[]=new int[k+1];\n		for(int i=1 ; i<n ;i++) {\n			int j=1;\n			for( ; j<=Math.min(a[i][0],a[i+1][0]) ; j++) {\n				if(a[i][j]!=a[i+1][j]) {\n					break;\n				}\n			}\n			if(a[i][0]<=a[i+1][0] && j==a[i][0]+1) {\n				continue;\n			}\n			if(a[i+1][0]<a[i][0] && j==a[i+1][0]+1) {\n				ob.println(""-1"");\n				return ;\n			}\n			if(a[i][j]>a[i+1][j]) {\n				mark[0]++;\n				mark[k-a[i+1][j]+1]++;\n				mark[k-a[i][j]+1]--;\n			}\n			else if(a[i][j]<a[i+1][j]) {\n				mark[k-a[i+1][j]+1]++;\n				mark[k-a[i][j]+1]--;\n			}\n		}\n		for (int i=1; i<k ; i++ ) {\n			mark[i]+=mark[i-1];\n		}\n		for (int i=0; i<k ; i++ ) {\n			if(mark[i]==0)\n			{\n				ob.println(i); \n				return ;\n			}\n		}\n		ob.println(""-1"");\n		return;\n	}\n	int ni() throws IOException {\n		return Integer.parseInt(nextToken());\n	}\n	String nextToken() throws IOException {\n		if(st==null || !st.hasMoreTokens())\n			st=new StringTokenizer(in.readLine());\n		return st.nextToken();\n	}\n}","brute force,data structures,greedy,sortings"
"import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n	BufferedReader in;\n	StringTokenizer str = null;\n	PrintWriter out;\n	\n	private String next() throws Exception{\n		while (str == null || !str.hasMoreElements())\n			str = new StringTokenizer(in.readLine());\n		return str.nextToken();\n	}\n	\n	private int nextInt() throws Exception{\n		return Integer.parseInt(next());\n	}\n	\n	private long nextLong() throws Exception{\n		return Long.parseLong(next());\n	}\n	\n	private double nextDouble() throws Exception{\n		return Double.parseDouble(next());\n	}\n\n	int n, C;\n	int [][]g;\n\n	int []bit;\n	\n	public void run() throws Exception{\n		in =  new BufferedReader(new InputStreamReader(System.in));\n		out = new PrintWriter(System.out);\n		n = nextInt();\n		C = nextInt();\n		g = new int[n][];\n		for(int i = 0; i < n; ++i) {\n			int m = nextInt();\n			g[i] = new int[m];\n			for(int j = 0; j < m; ++j) {\n				g[i][j] = nextInt();\n			}\n		}\n\n		bit = new int[C + 2];\n		int cnt = 0;\n		for(int i = 0; i + 1 < n; ++i) {\n			int at = 0;\n			while(at < g[i].length && at < g[i + 1].length && g[i][at] == g[i + 1][at]) {\n				++at;\n			}\n			if (at == g[i].length) continue;\n			if (at == g[i + 1].length) {\n				out.println(-1);\n				out.close();\n				return;\n			}\n			int d1 = g[i][at], d2 = g[i + 1][at];\n			if (d1 < d2) {\n				add(0, C - d2, 1);\n				add(C - d1 + 1, C, 1);\n			} else {\n				add(C - d1 + 1, C - d2, 1);\n			}\n			++cnt;\n		}\n		for(int i = 1; i <= C; ++i) {\n			bit[i] += bit[i-1];\n			if (bit[i] == cnt) {\n				out.println(i % C);\n				out.close();\n				return;\n			}\n		}\n		out.println(-1);\n		out.close();\n	}\n\n	private void add(int l, int r, int d) {\n		bit[l] += d;\n		bit[r + 1] -= d;\n	}\n		\n	public static void main(String[] args) throws Exception{\n		new Main().run();\n	}\n}\n","brute force,data structures,greedy,sortings"
"import java.io.*;\nimport java.util.*;\n\npublic class CF731D {\n	static int c;\n	static class T {\n		HashMap<Integer,T> map = new HashMap<>();\n		int v, x;\n		boolean add(int[] ww, int l, int i) {\n			if (i == l)\n				return v == 0;\n			int w = ww[i];\n			if (v == 0) {\n				v = w;\n				x = 0;\n			} else {\n				int y = (w - v + c) % c;\n				if (y < x)\n					return false;\n				x = y;\n			}\n			T t = map.get(w);\n			if (t == null) {\n				t = new T();\n				map.put(w, t);\n			}\n			return t.add(ww, l, i + 1);\n		}\n		void dfs(ArrayList<T> tt) {\n			if (v > 0 && x > 0)\n				tt.add(this);\n			for (int w : map.keySet()) {\n				T t = map.get(w);\n				t.dfs(tt);\n			}\n		}\n	}\n	static void mark(int[] aa, int l, int r) {	// [l, r]\n		aa[l]++;\n		aa[r + 1]--;\n	}\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		int n = Integer.parseInt(st.nextToken());\n		c = Integer.parseInt(st.nextToken());\n		T trie = new T();\n		while (n-- > 0) {\n			st = new StringTokenizer(br.readLine());\n			int l = Integer.parseInt(st.nextToken());\n			int[] ww = new int[l];\n			for (int i = 0; i < l; i++)\n				ww[i] = Integer.parseInt(st.nextToken());\n			if (!trie.add(ww, l, 0)) {\n				System.out.println(-1);\n				return;\n			}\n		}\n		ArrayList<T> tt = new ArrayList<>();\n		trie.dfs(tt);\n		int[] aa = new int[c + 2];\n		for (T t : tt) {\n			int l = t.v + t.x + 1;\n			int r = t.v;\n			if (l > c)\n				l -= c;\n			if (l <= r)\n				mark(aa, l, r);\n			else {\n				mark(aa, 1, r);\n				mark(aa, l, c);\n			}\n		}\n		int a = 0, b = tt.size(), x = -1;\n		for (int i = 1; i <= c; i++)\n			if ((a += aa[i]) == b) {\n				x = (1 - i + c) % c;\n				break;\n			}\n		System.out.println(x);\n	}\n}\n","brute force,data structures,greedy,sortings"
"import java.io.*;\nimport java.util.*;\npublic class div376D\n{\n	BufferedReader in;\n	PrintWriter ob;\n	StringTokenizer st;\n	public static void main(String[] args) throws IOException {\n		new div376D().run();\n	}\n	void run() throws IOException {\n		in=new BufferedReader(new BufferedReader(new InputStreamReader(System.in)));\n		ob=new PrintWriter(System.out);\n		solve();\n		ob.flush();\n	}\n	void solve() throws IOException {\n		int n=ni();\n		int k=ni();\n		int a[][]=new int[n+1][];\n		for (int i=1; i<=n ; i++ ) {\n			int m=ni();\n			a[i]=new int[m+1];\n			a[i][0]=m;\n			for (int j=1; j<=m ; j++ ) {\n				a[i][j]=ni();\n			}\n		}\n		int mark[]=new int[k+1];\n		for(int i=1 ; i<n ;i++) {\n			int j=1;\n			for( ; j<=Math.min(a[i][0],a[i+1][0]) ; j++) {\n				if(a[i][j]!=a[i+1][j]) {\n					break;\n				}\n			}\n			if(a[i][0]<=a[i+1][0] && j==a[i][0]+1) {\n				continue;\n			}\n			if(a[i+1][0]<a[i][0] && j==a[i+1][0]+1) {\n				ob.println(""-1"");\n				return ;\n			}\n			if(a[i][j]>a[i+1][j]) {\n				mark[0]++;\n				mark[k-a[i+1][j]+1]++;  // mark interval 0 to k-a[i+1][j]+1  with 1\n				mark[k-a[i][j]+1]--;    // mark k-a[i][j]-- so that interval is 1110001  .. \n			}\n			else if(a[i][j]<a[i+1][j]) {\n				mark[k-a[i+1][j]+1]++;   // +1\n				mark[k-a[i][j]+1]--;     // -1 interval corresponds to 0000111\n			}\n		}\n		for (int i=1; i<k ; i++ ) {\n			mark[i]+=mark[i-1];\n		}\n		for (int i=0; i<k ; i++ ) {\n			if(mark[i]==0)\n			{\n				ob.println(i); \n				return ;\n			}\n		}\n		ob.println(""-1"");\n		return;\n	}\n	int ni() throws IOException {\n		return Integer.parseInt(nextToken());\n	}\n	String nextToken() throws IOException {\n		if(st==null || !st.hasMoreTokens())\n			st=new StringTokenizer(in.readLine());\n		return st.nextToken();\n	}\n}","brute force,data structures,greedy,sortings"
"import java.io.*;\nimport java.util.*;\n\npublic class Task_new {\n\n	BufferedReader br;\n	PrintWriter out;\n	StringTokenizer st;\n	boolean eof;\n	\n	long ceilDiv(long a, long b) {\n		return Math.floorDiv(a + b - 1, b);\n	}\n	\n	static final int LIMIT = 100_000;\n	\n	void solve() throws IOException {\n		int n = nextInt();\n		long r = nextLong();\n		\n		List<Long> ans = new ArrayList<>(100000);\n		long ansSize = 0;\n		\n		long remDur = 0;\n		\n		long[] lens = new long[n];\n		long[] times = new long[n];\n		\n		for (int i = 0; i < n; i++) {\n			lens[i] = nextLong() * 2;\n			\n		}\n		\n		for (int i = 0; i < n; i++) {\n			times[i] = nextLong();\n			\n		}\n		\n		long curTime = 0;\n		\n		for (int i = 0; i < n; i++) {\n			long len = lens[i];\n			long time = times[i];\n			\n			if (len > 2 * time) {\n				out.println(-1);\n				return;\n			}\n			\n			if (2 * remDur >= len) {\n				remDur -= len / 2;\n				curTime += len / 2;\n				continue;\n			}\n			\n			time -= remDur;\n			len -= 2 * remDur;\n			curTime += remDur;\n			\n			remDur = 0;\n			\n			if (time >= len) {\n				curTime += len;\n				remDur = 0;\n				continue;\n			}\n			if (2 * time < len) {\n				throw new AssertionError();\n			}\n			\n			\n			long walk = 2 * time - len;\n			long run = time - walk;\n			\n			curTime += walk;\n			\n			long count = ceilDiv(run, r);\n			ansSize += count;\n			if (ansSize <= LIMIT) {\n				for (int j = 0; j < count; j++) {\n					ans.add(curTime + j * r);\n				}\n			}\n			\n			curTime += run;\n			remDur = count * r - run;\n		}\n		\n		out.println(ansSize);\n		if (ansSize <= LIMIT) {\n			for (long x : ans) {\n				out.print(x + "" "");\n			}\n			out.println();\n		}\n		\n	}\n	\n	void run() throws IOException {\n		br = new BufferedReader(new InputStreamReader(System.in));\n		out = new PrintWriter(System.out);\n		\n		solve();\n		\n		out.close();\n	}\n\n	public static void main(String[] args) throws IOException {\n		new Task_new().run();\n	}\n\n	String nextToken() {\n		while (st == null || !st.hasMoreTokens()) {\n			try {\n				st = new StringTokenizer(br.readLine());\n			} catch (Exception e) {\n				eof = true;\n				return null;\n			}\n		}\n		return st.nextToken();\n	}\n\n	String nextString() {\n		try {\n			return br.readLine();\n		} catch (IOException e) {\n			eof = true;\n			return null;\n		}\n	}\n\n	int nextInt() throws IOException {\n		return Integer.parseInt(nextToken());\n	}\n\n	long nextLong() throws IOException {\n		return Long.parseLong(nextToken());\n	}\n\n	double nextDouble() throws IOException {\n		return Double.parseDouble(nextToken());\n	}\n}\n\n","greedy,implementation,math"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\npublic class Task730D {\n    StringTokenizer st;\n    BufferedReader in;\n    PrintWriter out;\n\n    public static void main(String[] args) throws IOException {\n        Task730D task = new Task730D();\n        task.open();\n        task.solve();\n        task.close();\n    }\n\n    private void solve() throws IOException {\n\n        int n = nextInt();\n        long r = nextLong();\n\n        long[] l = new long[n];\n        long[] t = new long[n];\n\n        for (int i = 0; i < n; i++)\n            l[i] = nextInt();\n\n        for (int i = 0; i < n; i++)\n            t[i] = nextInt();\n\n        long time = 0;\n        long p = 0;\n\n        ArrayList<Long> ans = new ArrayList<>();\n\n        long used = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (t[i] < l[i]) {\n                System.out.println(-1);\n                return;\n            }\n            if (p >= l[i]) {\n                p -= l[i];\n                time += l[i];\n                continue;\n            }\n\n            long needed = (l[i] - p) * 2;\n\n            if (needed + p <= t[i]) {\n                time += p + needed;\n                p = 0;\n                continue;\n            }\n            long neededWithMagic = 2 * l[i] - t[i] - p;\n            long magic = (neededWithMagic + r - 1) / r;\n            time += p + neededWithMagic + (2 * (l[i] - p - neededWithMagic));\n            p = magic * r - neededWithMagic;\n            used += magic;\n            for (long j = time - (r - p), x = 0; x < magic && ans.size() < 100000; j -= r, x++) {\n                ans.add(j);\n            }\n        }\n\n        out.println(used);\n        if (used <= (int) 1e5) {\n            Collections.sort(ans);\n            for (int i = 0; i < ans.size(); i++)\n                out.print(ans.get(i) + "" "");\n\n\n        }\n    }\n\n    private void close() {\n        out.close();\n    }\n\n    private void open() {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n    }\n\n    private String nextToken() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            String line = in.readLine();\n            if (line == null) return null;\n            st = new StringTokenizer(line);\n        }\n        return st.nextToken();\n    }\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n    private  long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n\n}\n","greedy,implementation,math"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\n\n\npublic class Abood2C {\n\n\n\n\n	public static void main(String[] args) throws IOException {\n		Scanner sc = new Scanner(System.in);\n		PrintWriter out = new PrintWriter(System.out);\n\n		int n = sc.nextInt();\n		long r = sc.nextLong();\n\n		long[] l = new long[n];\n		long[] t = new long[n];\n\n		for (int i = 0; i < n; i++) \n			l[i] = sc.nextInt();\n\n		for (int i = 0; i < n; i++) \n			t[i] = sc.nextInt();\n\n		long time = 0;\n		long p = 0;\n\n		ArrayList<Long> ans = new ArrayList<>();\n\n		long used = 0;\n\n		for (int i = 0; i < n; i++) {\n			if(t[i] < l[i]) {\n				System.out.println(-1);\n				return;\n			}\n			if (p >= l[i]) {\n				p -=l[i];\n				time += l[i];\n				continue;\n			}\n			\n			long needed = (l[i] - p) * 2;\n			\n			if(needed + p <= t[i]) {\n				time += p + needed;\n				p = 0;\n				continue;\n			}\n			long neededWithMagic = 2 * l[i] - t[i] - p;\n			long magic = (neededWithMagic + r - 1) / r;\n			time += p + neededWithMagic + (2 * (l[i] - p - neededWithMagic));\n			p = magic * r - neededWithMagic;\n			used += magic;\n			for (long j = time - (r - p), x = 0; x < magic && ans.size() < 100000; j-=r, x++) {\n				ans.add(j);\n			}\n		}\n		\n		out.println(used);\n		if(used <= (int) 1e5) {\n			Collections.sort(ans);\n			for (int i = 0; i < ans.size(); i++) \n				out.print(ans.get(i) + "" "");\n			\n		}\n		out.println();\n		out.flush();\n		out.close();\n	}\n\n\n\n\n\n\n	static class Scanner \n\n\n\n	{\n		StringTokenizer st;\n		BufferedReader br;\n\n		public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}\n\n		public String next() throws IOException \n		{\n			while (st == null || !st.hasMoreTokens()) \n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		public int nextInt() throws IOException {return Integer.parseInt(next());}\n\n		public long nextLong() throws IOException {return Long.parseLong(next());}\n\n		public String nextLine() throws IOException {return br.readLine();}\n\n\n		public double nextDouble() throws IOException\n		{\n			String x = next();\n			StringBuilder sb = new StringBuilder(""0"");\n			double res = 0, f = 1;\n			boolean dec = false, neg = false;\n			int start = 0;\n			if(x.charAt(0) == '-')\n			{\n				neg = true;\n				start++;\n			}\n			for(int i = start; i < x.length(); i++)\n				if(x.charAt(i) == '.')\n				{\n					res = Long.parseLong(sb.toString());\n					sb = new StringBuilder(""0"");\n					dec = true;\n				}\n				else\n				{\n					sb.append(x.charAt(i));\n					if(dec)\n						f *= 10;\n				}\n			res += Long.parseLong(sb.toString()) / f;\n			return res * (neg?-1:1);\n		}\n\n		public boolean ready() throws IOException {return br.ready();}\n\n\n\n	}\n\n}","greedy,implementation,math"
"import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class D {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner input = new Scanner(System.in);\n		int n = input.nextInt();\n		long magicDuration = input.nextLong();\n		long[] distArr = new long[n];\n		for (int a = 0; a < n; a++) {\n			distArr[a] = input.nextInt() * 2;\n		}\n		long[] timeArr = new long[n];\n		for (int a = 0; a < n; a++) {\n			timeArr[a] = input.nextInt();\n		}\n		boolean IMPOSSIBLE = false;\n		long leftOverPotion = 0;\n		long time = 0;\n		ArrayList<Long> potions = new ArrayList<Long>();\n		long potionCount = 0;\n		for (int a = 0; a < n; a++) {\n			if (distArr[a] > 2 * timeArr[a]) {\n				IMPOSSIBLE = true;\n				break;\n			} else {\n				if (leftOverPotion * 2 > distArr[a]) {\n					leftOverPotion -= distArr[a] / 2;\n					time += distArr[a] / 2;\n					timeArr[a] -= distArr[a] / 2;\n					distArr[a] = 0;\n				} else {\n					distArr[a] -= leftOverPotion * 2;\n					time += leftOverPotion;\n					timeArr[a] -= leftOverPotion;\n					leftOverPotion = 0;\n				}\n				if (distArr[a] != 0) {\n					long remainingTimePotioned = distArr[a] - timeArr[a];\n					long timeNotPotioned = timeArr[a] - remainingTimePotioned;\n					time += Math.min(distArr[a], timeNotPotioned);\n					timeArr[a] -= Math.min(distArr[a], timeNotPotioned);\n					distArr[a] -= Math.min(distArr[a], timeNotPotioned);\n					while (distArr[a] > 0 && potions.size() < 100000) {\n						potions.add(time);\n						potionCount++;\n						leftOverPotion = magicDuration;\n						if (leftOverPotion * 2 > distArr[a]) {\n							leftOverPotion -= distArr[a] / 2;\n							time += distArr[a] / 2;\n							timeArr[a] -= distArr[a] / 2;\n							remainingTimePotioned -= distArr[a] / 2;\n							distArr[a] = 0;\n						} else {\n							distArr[a] -= leftOverPotion * 2;\n							time += leftOverPotion;\n							timeArr[a] -= leftOverPotion;\n							remainingTimePotioned -= leftOverPotion;\n							leftOverPotion = 0;\n\n						}\n					}\n					if (distArr[a] != 0) {\n						assert (distArr[a] > 0);\n\n						long potionChugged = ((remainingTimePotioned - 1) / magicDuration) + 1;\n						potionCount += potionChugged;\n						leftOverPotion = potionChugged * magicDuration;\n						if (leftOverPotion * 2 > distArr[a]) {\n							leftOverPotion -= distArr[a] / 2;\n							time += distArr[a] / 2;\n							timeArr[a] -= distArr[a] / 2;\n							distArr[a] = 0;\n						} else {\n							distArr[a] -= leftOverPotion * 2;\n							time += leftOverPotion;\n							timeArr[a] -= leftOverPotion;\n							leftOverPotion = 0;\n						}\n					}\n				}\n			}\n		}\n		if (IMPOSSIBLE) {\n			System.out.println(-1);\n		} else {\n			if (potionCount != potions.size()) {\n				System.out.println(potionCount);\n			} else {\n				System.out.println(potions.size());\n				for (Long i : potions) {\n					System.out.print(i + "" "");\n				}\n				System.out.println();\n			}\n		}\n	}\n}","greedy,implementation,math"
"//package round374;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class E2 {\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n	\n	void solve()\n	{\n		int L = ni(), n = ni(), P = ni(), t = ni();\n		long[][] rs = new long[n][];\n		for(int i = 0;i < n;i++){\n			rs[i] = new long[]{ni(), ni()};\n		}\n		long[] reachs = new long[n+1];\n		SegmentTreeRMQL st = new SegmentTreeRMQL(n+1);\n		reachs[0] = -t;\n		st.update(0, 0);\n		for(int i = 0;i < n;i++){\n			long[] r = rs[i];\n			int id = Arrays.binarySearch(reachs, 0, i+1, r[0]-t);\n			if(id < 0)id = -id-2;\n			long max = -st.minx(0, id+1) + (r[1]-r[0])/P;\n			long nr = (r[1]-r[0])/P*P + r[0];\n			int nid = id+1;\n			if(nid < i+1 && r[1]-P >= reachs[nid]+t){\n				long val = ((r[1]-(reachs[nid]+t))/P - st.minx(nid, nid+1));\n				long cannr = reachs[nid]+t+((r[1]-(reachs[nid]+t))/P*P);\n				if(val > max || val == max && cannr < nr){\n					max = val;\n					nr = cannr;\n				}\n			}\n			\n			reachs[i+1] = nr;\n			st.update(i+1, -max);\n		}\n		\n		out.println(-st.st[1]);\n	}\n	\n	public static class SegmentTreeRMQL {\n		public int M, H, N;\n		public long[] st;\n		\n		public SegmentTreeRMQL(int n)\n		{\n			N = n;\n			M = Integer.highestOneBit(Math.max(N-1, 1))<<2;\n			H = M>>>1;\n			st = new long[M];\n			Arrays.fill(st, 0, M, Long.MAX_VALUE);\n		}\n		\n		public SegmentTreeRMQL(long[] a)\n		{\n			N = a.length;\n			M = Integer.highestOneBit(Math.max(N-1, 1))<<2;\n			H = M>>>1;\n			st = new long[M];\n			for(int i = 0;i < N;i++){\n				st[H+i] = a[i];\n			}\n			Arrays.fill(st, H+N, M, Long.MAX_VALUE);\n			for(int i = H-1;i >= 1;i--)propagate(i);\n		}\n		\n		public void update(int pos, long x)\n		{\n			st[H+pos] = x;\n			for(int i = (H+pos)>>>1;i >= 1;i >>>= 1)propagate(i);\n		}\n		\n		private void propagate(int i)\n		{\n			st[i] = Math.min(st[2*i], st[2*i+1]);\n		}\n		\n		public long minx(int l, int r){\n			if(l >= r)return 0L;\n			long min = Long.MAX_VALUE;\n			while(l != 0){\n				int f = l&-l;\n				if(l+f > r)break;\n				long v = st[(H+l)/f];\n				if(v < min)min = v;\n				l += f;\n			}\n			\n			while(l < r){\n				int f = r&-r;\n				long v = st[(H+r)/f-1];\n				if(v < min)min = v;\n				r -= f;\n			}\n			return min;\n		}\n		\n		public long min(int l, int r){ return l >= r ? 0 : min(l, r, 0, H, 1);}\n		\n		private long min(int l, int r, int cl, int cr, int cur)\n		{\n			if(l <= cl && cr <= r){\n				return st[cur];\n			}else{\n				int mid = cl+cr>>>1;\n				long ret = Long.MAX_VALUE;\n				if(cl < r && l < mid){\n					ret = Math.min(ret, min(l, r, cl, mid, 2*cur));\n				}\n				if(mid < r && l < cr){\n					ret = Math.min(ret, min(l, r, mid, cr, 2*cur+1));\n				}\n				return ret;\n			}\n		}\n		\n		public int firstle(int l, long v) {\n			int cur = H+l;\n			while(true){\n				if(st[cur] <= v){\n					if(cur < H){\n						cur = 2*cur;\n					}else{\n						return cur-H;\n					}\n				}else{\n					cur++;\n					if((cur&cur-1) == 0)return -1;\n					if((cur&1)==0)cur>>>=1;\n				}\n			}\n		}\n		\n		public int lastle(int l, long v) {\n			int cur = H+l;\n			while(true){\n				if(st[cur] <= v){\n					if(cur < H){\n						cur = 2*cur+1;\n					}else{\n						return cur-H;\n					}\n				}else{\n					if((cur&cur-1) == 0)return -1;\n					cur--;\n					if((cur&1)==1)cur>>>=1;\n				}\n			}\n		}\n	}\n	\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new E2().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	private int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n	\n	private char[][] nm(int n, int m)\n	{\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n	\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n	\n	private int ni()\n	{\n		int num = 0, b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","binary search,dp"
"import java.io.*;\nimport java.util.*;\n\npublic class Codeforces\n{\n    public static void main(String args[])throws Exception\n    {\n        BufferedReader bu=new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb=new StringBuilder();\n        String s[]=bu.readLine().split("" "");\n        int i,n=Integer.parseInt(s[0]),m=Integer.parseInt(s[1]),t=Integer.parseInt(s[2]);\n        int dp[][]=new int[n+1][n+1],p[][]=new int[n+1][n+1];\n        for(i=0;i<=n;i++)\n        Arrays.fill(dp[i],2000000000);\n\n        int j,e[][]=new int[m][3],a=0;\n        for(i=0;i<m;i++)\n        {\n            s=bu.readLine().split("" "");\n            for(j=0;j<3;j++)\n            e[i][j]=Integer.parseInt(s[j]);\n        }\n\n        dp[1][1]=0;\n        ArrayList<Integer> ans=new ArrayList<>();\n        for(i=2;i<=n;i++)\n        for(j=0;j<m;j++)\n        {\n            int x=e[j][0],y=e[j][1],z=e[j][2];\n            if(1l*dp[i-1][x]+z<dp[i][y] && t-dp[i-1][x]>=z)\n            {\n                dp[i][y]=dp[i-1][x]+z;\n                p[i][y]=x;\n            }\n            if(dp[i][n]<=t) a=i;\n        }\n        \n        sb.append(a+""\n"");\n        j=n;\n        while(j>0)\n        {\n            ans.add(j);\n            j=p[a--][j];\n        }\n        for(i=ans.size()-1;i>=0;i--)\n        sb.append(ans.get(i)+"" "");\n        System.out.print(sb);\n    }\n}","dp,graphs"
"import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n public class Main {\n     static int arr[], N, k, x1, x2, y1, y2;\n     static int dp[][];\n     static int [][]parent;\n     static boolean reach[][];\n     static String str1[];\n     static String str2[];\n     static List<int[]>[] adj;\n     static int max = 0;\n     static int mod = (int) (1e9 + 9);\n     static long T;\n     static List<Integer> ans;\n     static boolean[]visted;\n     static String result;\n     public static void main(String[] args) throws IOException {\n         Scanner input = new Scanner(System.in);\n         N = input.nextInt();\n         int m = input.nextInt();\n         T = input.nextLong();\n         adj = new List[N+1];\n\n         for(int i=0 ; i<=N ; i++)\n             adj[i] = new ArrayList<>();\n\n\n         parent = new int[N+1][N+1];\n         dp = new int[N+1][N+1];\n\n       for(int i=0 ; i<=N ; i++)\n           Arrays.fill(dp[i],(int)(1e9 + 7));\n\n         for(int i=0 ; i<m ; i++){\n             int x = input.nextInt();\n             int y = input.nextInt();\n             int w = input.nextInt();\n             adj[x].add(new int[]{y,w});\n         }\n\n         dp[N][1] = 0;\n\n         for(int j = 2 ; j<=N ; j++){\n             for(int i= 1 ; i<= N ; i++){\n                 for(int [] a : adj[i]){\n                     if(a[1] + dp[a[0]][j-1] < dp[i][j]){\n                         dp[i][j] = a[1] + dp[a[0]][j-1];\n                         parent[i][j] = a[0];\n                     }\n                 }\n             }\n         }\n\n\n      for(int i=N ; i>=1 ; i--){\n          if(dp[1][i] <= T){\n              System.out.println(i);\n              System.out.print(1 + "" "");\n              print(1,i);\n              break;\n          }\n      }\n\n\n\n\n\n\n\n     }\n\n     static void print(int i,int j){\n         if(i == N) {\n             return;\n         }\n         System.out.print(parent[i][j] + "" "");\n         print(parent[i][j],j-1);\n     }\n\n\n\n\n\n     /*\n     static int solve(int cur , int last,int cnt){\n\n         if(cur == N)\n             return 0;\n\n         int ret = 0;\n        double x = Math.log(arr[cur] - arr[last-1]) / Math.log(k);\n         System.out.println(x);\n         if( (x - (int)x) < .001){\n             ret = 1 + solve(cur+1,cur+1);\n         }\n         if(cur != N-1) {\n             ret += solve(cur + 1, last);\n         }\n         return ret;\n     }\n\n      */\n\n\n\n\n     static class Scanner {\n         StringTokenizer st;\n         BufferedReader br;\n\n         public Scanner(InputStream s) {\n             br = new BufferedReader(new InputStreamReader(s));\n         }\n\n         public Scanner(String s) throws FileNotFoundException {\n             br = new BufferedReader(new FileReader(s));\n         }\n\n         public String next() throws IOException {\n             while (st == null || !st.hasMoreTokens())\n                 st = new StringTokenizer(br.readLine());\n             return st.nextToken();\n         }\n\n         public int nextInt() throws IOException {\n             return Integer.parseInt(next());\n         }\n\n         public String nextLine() throws IOException {\n             return br.readLine();\n         }\n\n         public long nextLong() throws IOException {\n             return Long.parseLong(next());\n         }\n\n         public boolean ready() throws IOException {\n             return br.ready();\n         }\n\n         public double nextDouble() throws IOException {\n             String x = next();\n             StringBuilder sb = new StringBuilder(""0"");\n             double res = 0, f = 1;\n             boolean dec = false, neg = false;\n             int start = 0;\n             if (x.charAt(0) == '-') {\n                 neg = true;\n                 start++;\n             }\n             for (int i = start; i < x.length(); i++)\n                 if (x.charAt(i) == '.') {\n                     res = Integer.parseInt(sb.toString());\n                     sb = new StringBuilder(""0"");\n                     dec = true;\n                 } else {\n                     sb.append(x.charAt(i));\n                     if (dec)\n                         f *= 10;\n                 }\n             res += Integer.parseInt(sb.toString()) / f;\n             return res * (neg ? -1 : 1);\n         }\n     }\n }\n\n\n\n","dp,graphs"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        CJourney solver = new CJourney();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class CJourney {\n        int[][] dp;\n        int[][] par;\n        int n;\n        int m;\n        int T;\n        ArrayList<Edge>[] g;\n        int[] dist;\n        boolean[] vis;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            pre(in);\n            par = new int[n][n];\n            // dp(i,j)= min time to reach city i from city 1 such that we have visited total j cities before\n            dp = new int[n][n];\n            for (int[] r : dp) Arrays.fill(r, T + 1);\n            for (int[] r : par) Arrays.fill(r, -1);\n            dp[0][0] = 0;\n            dfs(0, 0);\n            for (int i = n - 1; i >= 0; i--) {\n                if (dp[n - 1][i] <= T) {\n                    out.println(i + 1);\n                    ArrayList<Integer> list = print(n - 1, i);\n                    for (int a : list) out.print(a + "" "");\n                    return;\n                }\n            }\n        }\n\n        ArrayList<Integer> print(int nn, int cv) {\n            if (nn == 0) {\n                ArrayList<Integer> temp = new ArrayList<>();\n                temp.add(1);\n                return temp;\n            }\n            ArrayList<Integer> sans = print(par[nn][cv], cv - 1);\n            sans.add(nn + 1);\n            return sans;\n        }\n\n        void dfs(int nn, int cv) {\n            vis[nn] = true;\n            for (Edge e : g[nn]) {\n                if (dp[nn][cv] + e.cost < dp[e.node][cv + 1]) {\n                    par[e.node][cv + 1] = nn;\n                    dp[e.node][cv + 1] = dp[nn][cv] + e.cost;\n                    dfs(e.node, cv + 1);\n                }\n            }\n        }\n\n        void pre(InputReader in) {\n            n = in.nextInt();\n            m = in.nextInt();\n            T = in.nextInt();\n            g = new ArrayList[n];\n            dist = new int[n];\n            vis = new boolean[n];\n            for (int i = 0; i < n; i++) g[i] = new ArrayList<>();\n            for (int i = 0; i < m; i++) {\n                int a = in.nextInt() - 1, b = in.nextInt() - 1, c = in.nextInt();\n                g[a].add(new Edge(b, c));\n//            g[b].add(new Edge(a, c));\n            }\n        }\n\n        class Edge implements Comparable<Edge> {\n            int node;\n            int cost;\n\n            Edge(int a, int b) {\n                node = a;\n                cost = b;\n            }\n\n            public int compareTo(Edge e) {\n                return cost - e.cost;\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n","dp,graphs"
"import java.io.*;\nimport java.util.*;\npublic class Graph\n{\n   class Edge\n    {\n        int v;int w;\n        public Edge(int v,int w)\n        {\n            this.v=v;\n            this.w=w;\n        }\n    }\n     int V;\n    ArrayList<Edge> adj[];\n    static long dp[][];\n    static ArrayList<Integer> arr;\n    static long MOD=1000000007;\n    Graph(int v)\n    {\n    	V=v;\n        adj=new ArrayList[v];\n        for(int i=0;i<v;i++)\n        adj[i] = new ArrayList<>();\n    }\n    void addEdge(int u,int v,int w)\n    {\n        Edge edge =new Edge(v,w);\n        adj[u].add(edge);\n    }\n    void DFS(int T){\n        boolean visited[]=new boolean[V];\n        dp[V-1][1]=0;\n        // for(int i=0;i<=V;i++){\n        //     for(int j=0;j<=V;j++){\n        //         System.out.print(dp[i][j]+"" "");\n        //     }\n        //     System.out.println();\n        // }\n        DFSUtil(0,visited);\n        int max=1;\n        for(int i=2;i<=V;i++){\n            if(dp[0][i]<=(long)T&&dp[0][i]>=0){\n                max=i;\n            }\n        }\n        //for(int i=1;i<=V;i++)System.out.print(dp[3][i]+"" "");\n        //System.out.println();\n        visited=new boolean[V];\n        DFSUtil1(0,visited,max);\n        System.out.println(max);\n        for(int i=0;i<arr.size();i++){\n            System.out.print(arr.get(i)+"" "");\n        }\n        System.out.println();\n    }\n    \n    void DFSUtil(int s,boolean visited[]){\n        visited[s]=true;\n       // System.out.println(s+"" ""+adj[s].size());\n        if(s==(V-1))return;\n        for(int i=0;i<adj[s].size();i++){\n            if(!visited[adj[s].get(i).v]){\n               DFSUtil(adj[s].get(i).v,visited);\n            }\n            for(int j=1;j<V;j++){\n                   if(dp[adj[s].get(i).v][j]!=Integer.MIN_VALUE){\n                       if(dp[s][j+1]!=Integer.MIN_VALUE)\n                   dp[s][j+1]=Math.min(dp[s][j+1],\n                   dp[adj[s].get(i).v][j]+(long)adj[s].get(i).w);\n                   else\n                   dp[s][j+1]=dp[adj[s].get(i).v][j]+(long)adj[s].get(i).w;\n                   }\n                  // System.out.println(s+"" ""+dp[s][j+1]);\n            }\n        }\n    }\n    \n    \n    void DFSUtil1(int s,boolean visited[],int max){\n        visited[s]=true;\n        arr.add((s+1));\n        //System.out.println((s+1)+"" a ""+max);\n        //if(s==(V-1)) return;\n        for(int i=0;i<adj[s].size();i++){\n            if(dp[adj[s].get(i).v][max-1]==(dp[s][max]-(long)adj[s].get(i).w)){\n               DFSUtil1(adj[s].get(i).v,visited,max-1);\n               break;\n            }\n        }\n    }\n    \n    public static void main (String[] args)throws java.lang.Exception {\n        Reader sc=new Reader();\n        PrintWriter out=new PrintWriter(System.out);\n        int n=sc.nextInt();\n        int m=sc.nextInt();\n        int T=sc.nextInt();\n        Graph g=new Graph(n);\n        for(int i=1;i<=m;i++) {\n        	g.addEdge(sc.nextInt()-1, sc.nextInt()-1, sc.nextInt());\n        }\n        dp=new long[n+5][n+5];\n        for(int i=0;i<n+5;i++)for(int j=0;j<n+5;j++)dp[i][j]=-Integer.MIN_VALUE;\n        \n        arr=new ArrayList<>();\n        g.DFS(T);\n    }\n    static class Reader \n    { \n        final private int BUFFER_SIZE = 1 << 16; \n        private DataInputStream din; \n        private byte[] buffer; \n        private int bufferPointer, bytesRead; \n  \n        public Reader() \n        { \n            din = new DataInputStream(System.in); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public Reader(String file_name) throws IOException \n        { \n            din = new DataInputStream(new FileInputStream(file_name)); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public String readLine() throws IOException \n        { \n            byte[] buf = new byte[64]; // line length \n            int cnt = 0, c; \n            while ((c = read()) != -1) \n            { \n                if (c == '\n') \n                    break; \n                buf[cnt++] = (byte) c; \n            } \n            return new String(buf, 0, cnt); \n        } \n  \n        public int nextInt() throws IOException \n        { \n            int ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do\n            { \n                ret = ret * 10 + c - '0'; \n            }  while ((c = read()) >= '0' && c <= '9'); \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public long nextLong() throws IOException \n        { \n            long ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public double nextDouble() throws IOException \n        { \n            double ret = 0, div = 1; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n  \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n  \n            if (c == '.') \n            { \n                while ((c = read()) >= '0' && c <= '9') \n                { \n                    ret += (c - '0') / (div *= 10); \n                } \n            } \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        private void fillBuffer() throws IOException \n        { \n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n            if (bytesRead == -1) \n                buffer[0] = -1; \n        } \n  \n        private byte read() throws IOException \n        { \n            if (bufferPointer == bytesRead) \n                fillBuffer(); \n            return buffer[bufferPointer++]; \n        } \n  \n        public void close() throws IOException \n        { \n            if (din == null) \n                return; \n            din.close(); \n        } \n}\n}","dp,graphs"
"import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.security.AllPermission;\nimport java.util.ArrayList;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\n\npublic class H {\n\n	static StringTokenizer st;\n	static BufferedReader br;\n	static PrintWriter pw;\n	static ArrayList<Integer>[]ages;\n	public static void main(String[] args) throws IOException {\n		br = new BufferedReader(new InputStreamReader(System.in));\n		pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		int n = nextInt();\n		int e = nextInt();\n		ages = new ArrayList[n+1];\n		for (int i = 1; i <= n; i++) {\n			ages[i] = new ArrayList<>();\n		}\n		int[]a = new int[e], b = new int[e];\n		for (int i = 0; i < e; i++) {\n			a[i] = nextInt();\n			b[i] = nextInt();\n			ages[a[i]].add(b[i]);\n			ages[b[i]].add(a[i]);\n		}\n		int[]conferences = new int[n+1];\n		for (int i = 1; i <= n; i++) {\n			int hates1 = 0, hates2 = 0;\n			for (int j : ages[i]) {\n				if (conferences[j]==2)\n					hates1++;\n				else if (conferences[j]==1)\n					hates2++;\n			}\n			if (hates1 >= hates2)\n				conferences[i] = 1;\n			else\n				conferences[i] = 2;\n		}\n		int s = 0;\n		for (int i = 0; i < e; i++) {\n			if (conferences[a[i]] != conferences[b[i]])\n				s++;\n		}\n		if (s*2 < e) {\n			while (true) {\n				s++;\n			}\n		}\n		int[]cnf_team = new int[1000001];\n		int[]team = new int[n+1];\n		int cnt_team = 0;\n		Random rm = new Random();\n		for (int i = 1; i <= n; i++) {\n			int L = nextInt();\n			int[]t = new int[L];\n			for (int j = 0; j < L; j++) {\n				t[j] = nextInt();\n				if (t[j] > cnt_team)\n					cnt_team = t[j];\n			}\n			for (int j = 0; j < L; j++) {\n				if (conferences[i]==cnf_team[t[j]]) {\n					team[i] = t[j];\n					break;\n				}\n			}\n			ArrayList<Integer>rest = new ArrayList<>();\n			if (team[i]==0) {\n				for (int j = 0; j < L; j++) {\n					if (cnf_team[t[j]]==0) {\n						rest.add(t[j]);\n					}\n				}\n				int x = rest.get(rm.nextInt(rest.size()));\n				cnf_team[x] = conferences[i];\n				team[i] = x;\n			}\n		}\n		for (int i = 1; i <= n; i++) {\n			pw.print(team[i]+"" "");\n		}\n		pw.println();\n		for (int i = 1; i <= cnt_team; i++) {\n			if (cnf_team[i]==0)\n				cnf_team[i] = 1;\n			pw.print(cnf_team[i]+"" "");\n		}\n		pw.close();\n	}\n	private static int nextInt() throws IOException {\n		return Integer.parseInt(next());\n	}\n	private static long nextLong() throws IOException {\n		return Long.parseLong(next());\n	}\n	private static double nextDouble() throws IOException {\n		return Double.parseDouble(next());\n	}\n	private static String next() throws IOException {\n		while (st==null || !st.hasMoreTokens())\n			st = new StringTokenizer(br.readLine());\n		return st.nextToken();\n	}\n}","math,probabilities"
"import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Locale;\nimport java.util.StringTokenizer;\nimport java.util.Random;\n\n/**\n * Created by DNs on 15.05.2016.\n */\npublic class Main implements Runnable {\n  static BufferedReader in;\n  static PrintWriter out;\n  static StringTokenizer tok = new StringTokenizer("""");\n\n  public static void main(String[] args) {\n    new Thread(new Main()).start();\n  }\n\n  @Override\n  public void run() {\n    Locale.setDefault(Locale.ENGLISH);\n    try {\n      init();\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    }\n    try {\n      solve();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    out.close();\n  }\n\n\n  private String readString() {\n    while (!tok.hasMoreTokens()) {\n      try {\n        tok = new StringTokenizer(in.readLine());\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n    }\n    return tok.nextToken();\n  }\n\n  private Integer readInt() {\n    return Integer.parseInt(readString());\n  }\n\n  private Long readLong() {\n    return Long.parseLong(readString());\n  }\n\n  private Double readDouble() {\n    return Double.parseDouble(readString());\n  }\n\n  private void init() throws FileNotFoundException {\n    in = new BufferedReader(new InputStreamReader(System.in));\n    out = new PrintWriter(System.out);\n    /*in = new BufferedReader(new FileReader(""stupid_rmq.in""));\n    out = new PrintWriter(""stupid_rmq.out"");*/\n  }\n\n  \n  int T = 1_000_001;\n\n  private void solve() throws IOException {\n    int n = readInt();\n    int e = readInt();\n    ArrayList<Integer> trainersToTeams[]  = new ArrayList[n];\n    Pair[] haters = new Pair[e];\n    for (int i = 0; i < n; i++) {\n      trainersToTeams[i] = new ArrayList<>();\n    }\n    for (int i = 0; i < e; i++) {\n      int first = readInt() - 1;\n      int second = readInt() - 1;\n      haters[i] = new Pair(first, second);\n    }\n    int maxTeam = 0;\n    for (int i = 0; i < n; i++) {\n      int countTeams = readInt();\n      for (int j = 0; j < countTeams; j++) {\n        int team = readInt() - 1;\n        maxTeam = Math.max(maxTeam, team);\n        trainersToTeams[i].add(team);\n      }\n    }\n    maxTeam++;\n    Random rnd = new Random();\n    while(true){\n      int[] trainerTeam = new int[n];\n      for(int i = 0; i < n; i++){\n        trainerTeam[i] = trainersToTeams[i].get(Math.abs(rnd.nextInt()) % trainersToTeams[i].size());\n      }\n      boolean[] isFirstConference = new boolean[maxTeam];\n      for(int i = 0; i < maxTeam; i++){\n        if(rnd.nextInt()%2 == 0) isFirstConference[i] = true;\n      }\n      int count = 0;\n      for(int i = 0; i < e; i++){\n        int firstTeam = trainerTeam[haters[i].x];\n        int secondTeam = trainerTeam[haters[i].y];\n        if((isFirstConference[firstTeam] ^ isFirstConference[secondTeam]))count++;\n      }\n      if(count*2 >= e){\n        for(int i = 0; i < n; i++){\n          out.print(trainerTeam[i] + 1 + "" "");\n        }\n        out.println();\n        for(int i = 0; i < maxTeam; i++){\n          if(isFirstConference[i]) out.print(""1 ""); else out.print(""2 "");\n         // out.print((isFirstConference[i] ? ""1 "" : ""2 ""));\n        }\n        return;\n      }\n    }\n  }\n  \n  class Pair{\n      int x, y;\n      public Pair(int x, int y){\n          this.x = x;\n          this.y = y;\n      }\n  }\n\n\n}","math,probabilities"
"import java.awt.Point;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class H {\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok;\n\n    void init() {\n        try {\n            in = new BufferedReader(new FileReader(""input.txt""));\n            out = new PrintWriter(""output.txt"");\n        } catch (Exception e) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        }\n    }\n\n    String readString() {\n        try {\n            while (tok == null || !tok.hasMoreTokens()) {\n                tok = new StringTokenizer(in.readLine());\n            }\n            return tok.nextToken();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    int readInt() {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() {\n        return Long.parseLong(readString());\n    }\n\n    int[] readIntArray(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = readInt();\n        }\n        return a;\n    }\n\n    public static void main(String[] args) {\n        new H().run();\n    }\n\n    void run() {\n        try {\n            long tStart = System.currentTimeMillis();\n            init();\n            solve();\n            in.close();\n            out.close();\n            long tEnd = System.currentTimeMillis();\n\n            System.err.println(tEnd - tStart);\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n\n    void solve() {\n        int trainersCount = readInt();\n        int edgesCount = readInt();\n\n        Point[] edges = new Point[edgesCount];\n        for (int i = 0; i < edgesCount; ++i) {\n            int from = readInt() - 1;\n            int to = readInt() - 1;\n            edges[i] = new Point(from, to);\n        }\n\n        List<Integer>[] trainersTeams = new List[trainersCount];\n        int teamsCount = 0;\n\n        for (int i = 0; i < trainersCount; ++i){\n            int size = readInt();\n            List<Integer> trainerTeams = new ArrayList<>(size);\n\n            for (int j = 0; j < size; ++j) {\n                int team = readInt() - 1;\n                teamsCount = Math.max(teamsCount, team + 1);\n\n                trainerTeams.add(team);\n            }\n\n            trainersTeams[i] = trainerTeams;\n        }\n\n        Random rnd = new Random();\n\n        int[] mappedTeams = new int[trainersCount];\n        boolean[] isEnemyConferences = new boolean[teamsCount];\n\n        while (true) {\n            for (int trainer = 0; trainer < trainersCount; ++trainer) {\n                List<Integer> trainerTeams = trainersTeams[trainer];\n                int trainerTeamIndex = rnd.nextInt(trainerTeams.size());\n                mappedTeams[trainer] = trainerTeams.get(trainerTeamIndex);\n            }\n\n            for (int team = 0; team < teamsCount; ++team) {\n                isEnemyConferences[team] = rnd.nextBoolean();\n            }\n\n            int enemyEdgesCount = 0;\n            for (Point edge : edges) {\n                int fromTeam = mappedTeams[edge.x];\n                int toTeam = mappedTeams[edge.y];\n                if (isEnemyConferences[fromTeam] != isEnemyConferences[toTeam]) {\n                    ++enemyEdgesCount;\n                }\n            }\n\n            if (enemyEdgesCount * 2 >= edgesCount) {\n                break;\n            }\n        }\n\n        for (int mappedTeam : mappedTeams) {\n            out.print((mappedTeam + 1) + "" "");\n        }\n        out.println();\n\n        for (boolean isEnemyConference : isEnemyConferences) {\n            int conference = (isEnemyConference ? 1 : 2);\n            out.print(conference + "" "");\n        }\n        out.println();\n    }\n}\n","math,probabilities"
"import java.util.*;\nimport java.lang.*;\npublic class Main\n{\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		Set<Integer> s = new HashSet<>();\n		for(int i=0;i<n;i++)\n		{\n			int d = sc.nextInt();\n			s.add(d);\n		}\n		if(s.size()==1 || s.size()==2) System.out.println(""YES"");\n		else if(s.size()>3) System.out.println(""NO"");\n		else\n		{\n			List<Integer> l = new ArrayList<>(s);\n			Collections.sort(l);\n			if((l.get(2)-l.get(1)) == (l.get(1)-l.get(0))) System.out.println(""YES"");\n			else System.out.println(""NO"");\n		}\n	}\n}","implementation,sortings"
"import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int t,  c = 1, n = sc.nextInt();\n       int ar[]=new int[n];\n       ArrayList<Integer> al=new ArrayList<>();\n        for(t=0;t<n;t++)\n            ar[t]=sc.nextInt();\n\n        Arrays.sort(ar);\n        al.add(ar[0]);\n       for(t=0;t<n-1;t++){\n           if(ar[t]!=ar[t+1])\n                al.add(ar[t+1]);\n\n       }\n           if(al.size()>3)c=0;\n           if(al.size()==3&&al.get(1)-al.get(0)!=al.get(2)-al.get(1))c=0;\n          System.out.print(c==1?""YES"":""NO"");\n\n    }}","implementation,sortings"
"import java.util.*;\n\npublic class MyClass {\n    public static void main(String args[]) {\n      Scanner br = new Scanner(System.in);\n      int n = br.nextInt();\n      int[] arr = new int[n];\n      Set<Integer> set = new HashSet<>();\n      for(int i=0; i<n; i++) {\n          set.add(br.nextInt());\n      }\n      if(set.size() > 3) System.out.println(""NO"");\n      else if(set.size() <= 2) System.out.println(""YES"");\n      else {\n        ArrayList<Integer> list = new ArrayList<>(set);\n        Collections.sort(list);\n        if(2*list.get(1) == list.get(0)+list.get(2)) System.out.println(""YES"");\n        else System.out.println(""NO"");\n      }\n    }\n}\n","implementation,sortings"
"import java.util.*;\n\npublic class Filya_and_Homework {\n	\n	public static void main(String[]args) {\n		Scanner scan = new Scanner(System.in);\n		int n = scan.nextInt();\n		List<Integer>arr = new ArrayList<>() ;\n		for(int i=0;i<n;i++) {\n			int x= scan.nextInt();\n			arr.add(x);\n		}\n		\n		Set<Integer> l = new HashSet<>(arr);\n		if(l.size()>3) {\n			System.out.println(""No"");\n		}\n		else if(l.size()<3) {\n			System.out.println(""Yes"");\n		}\n		else {\n			List<Integer> test = new ArrayList<>(l);\n			Collections.sort(test);\n			if(test.get(2)-test.get(1) == test.get(1)-test.get(0)) {\n				System.out.println(""Yes"");\n			}\n			else {\n				System.out.println(""No"");\n			}\n		}\n	}\n}\n","implementation,sortings"
"import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n\npublic class D {\n\n	static StringTokenizer st;\n	static BufferedReader br;\n	static PrintWriter pw;\n	static int[][]dp;\n	static int[][][]t;\n	static int n, m;\n	static int[]log_2;\n	static int yy1, yy2;\n	public static void main(String[] args) throws IOException {\n		br = new BufferedReader(new InputStreamReader(System.in));\n		pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		n = nextInt();\n		m = nextInt();\n		int[][]a = new int[n+1][m+1];\n		for (int i = 1; i <= n; i++) {\n			for (int j = 1; j <= m; j++) {\n				a[i][j] = nextInt();\n			}\n		}\n		log_2 = new int[1001];\n		for (int i = 1; i <= m; i++) {\n			while ((1 << (log_2[i]+1)) <= i)\n				log_2[i]++;\n		}\n		dp = new int[n+1][m+1];\n		t = new int[11][m+1][4*n];\n		for (int i = 1; i <= n; i++) {\n			for (int j = 1; j <= m; j++) {\n				if (a[i][j]==1)\n					dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;\n			}\n		}\n		for (int i = 0; i <= 10; i++) {\n			for (int j = 1; j <= m; j++) {\n				Buildx(1, 1, n, j, i);\n			}\n		}\n		int q = nextInt();\n		while (q-->0) {\n			int x1 = nextInt();\n			int y1 = nextInt();\n			int x2 = nextInt();\n			int y2 = nextInt();\n			int left = 0, right = Math.min(x2-x1, y2-y1) + 2;\n			while (right-left > 1) {\n				int mid = (left+right) >> 1;\n				yy1 = y1+mid-1;\n				yy2 = y2;\n				if (getMax(1, 1, n, x1+mid-1, x2) >= mid)\n					left = mid;\n				else\n					right = mid;\n			}\n			pw.println(left);\n		}\n		pw.close();\n	}\n	\n	private static int getMax(int v, int tl, int tr, int x1, int x2) {\n		if (x1 > x2)\n			return -1;\n		if (tl==x1 && tr==x2) {\n			if (yy1 > yy2)\n				return -1;\n			int k = log_2[yy2-yy1+1];\n			return Math.max(t[k][yy1][v], t[k][yy2-(1 << k)+1][v]);\n		}\n		int tm = (tl+tr) >> 1;\n		return Math.max(getMax(2*v, tl, tm, x1, Math.min(x2, tm)), getMax(2*v+1, tm+1, tr, Math.max(x1, tm+1), x2));\n	}\n	\n	private static void Buildx(int v, int tl, int tr, int y, int k) {\n		if (tl==tr) {\n			if (y+(1 << k)-1 > m)\n				return;\n			if (k==0)\n				t[k][y][v] = dp[tl][y];\n			else\n				t[k][y][v] = Math.max(t[k-1][y][v], t[k-1][y+(1 << (k-1))][v]);	\n		}\n		else {\n			int tm = (tl+tr) >> 1;\n			Buildx(2*v, tl, tm, y, k);\n			Buildx(2*v+1, tm+1, tr, y, k);\n			t[k][y][v] = Math.max(t[k][y][2*v], t[k][y][2*v+1]);\n		}\n	}\n	\n	private static int nextInt() throws IOException {\n		return Integer.parseInt(next());\n	}\n	private static long nextLong() throws IOException {\n		return Long.parseLong(next());\n	}\n	private static double nextDouble() throws IOException {\n		return Double.parseDouble(next());\n	}\n	private static String next() throws IOException {\n		while (st==null || !st.hasMoreTokens())\n			st = new StringTokenizer(br.readLine());\n		return st.nextToken();\n	}\n}","binary search,data structures"
"import java.io.*;\nimport java.util.*;\n\npublic class AnimalsandPuzzle {\n\n	static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n	static BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n\n	static int n, m;\n	static int[][] a;\n	static int[][][][] st;\n	\n	static void build(int[][] dp) {\n		for (int ir = 0; ir < n; ir ++) {\n			for (int ic = 0; ic < m; ic++) {\n				st[0][ir][0][ic] = dp[ir][ic];\n			}\n			\n			for (int jc = 1; 1 << jc <= m; jc ++) {\n				for (int ic = 0; ic + (1 << jc) - 1 < m; ic++) {\n					st[0][ir][jc][ic] = Math.max(st[0][ir][jc - 1][ic], st[0][ir][jc - 1][ic + (1 << (jc - 1))]);\n				}\n			}\n		}\n		\n		for (int jr = 1; 1 << jr <= n; jr++) {\n			for (int ir = 0; ir + (1 << jr) - 1 < n; ir++) {\n				for (int jc = 0; 1 << jc <= m; jc++) {\n					for (int ic = 0; ic + (1 << jc) -1 < m; ic++) {\n						int a2 = st[jr - 1][ir][jc][ic];\n						int b = st[jr - 1][ir + (1 << (jr - 1))][jc][ic];\n						st[jr][ir][jc][ic] = Math.max(a2, b);\n					}\n				}\n			}\n		}\n	}\n	\n	static int query(int x1, int y1, int x2, int y2) {\n		int kx = log2(x2 - x1 + 1), ky = log2(y2 - y1 + 1);\n		int m1 = Math.max(st[kx][x1][ky][y1], st[kx][x1][ky][y2 - (1 << ky) + 1]);\n		int m2 = Math.max(st[kx][x2 - (1 << kx) + 1][ky][y1], st[kx][x2 - (1 << kx) + 1][ky][y2 - (1 << ky) + 1]);\n		return Math.max(m1, m2);\n	}\n	\n	static int log2(int n) {\n		return Integer.numberOfTrailingZeros(Integer.highestOneBit(n));\n	}\n	\n	static void init() {\n		int[][] dp = new int[n][m];\n		for (int i = 0; i < n; i++) {\n			dp[i][0] = a[i][0];\n		}\n		for (int i = 0; i < m; i++) {\n			dp[0][i] = a[0][i];\n		}\n		\n		for (int i = 1; i < n; i++) {\n			for (int j = 1; j < m; j++) {\n				dp[i][j] = a[i][j] == 0 ? 0 : Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i][j-1]) + 1;\n			}\n		}\n		st = new int[log2(n) + 1][n + 1][log2(m) + 1][m];\n		build(dp);\n	}\n	\n	static void process(int x1, int y1, int x2, int y2) throws Exception {\n		int left = 0, right = Math.min(x2 - x1, y2 - y1);\n		int max = 0;\n		while (left <= right) {\n			int mid = left + (right - left) / 2;\n			int query = query(x1 + mid, y1 + mid, x2, y2);\n			if (query >= mid + 1) {\n				max = mid + 1;\n				left = mid + 1;\n			} else {\n				right = mid - 1;\n			}\n		}\n		writer.write(String.format(""%d"", max));\n		writer.newLine();\n	}\n\n	public static void main(String[] args) throws Exception {\n		//		writer = new BufferedWriter(new FileWriter(""output.txt""));\n		String[] data = reader.readLine().split("" "");\n		n = Integer.parseInt(data[0]);\n		m = Integer.parseInt(data[1]);\n		a = new int[n][];\n		for (int i = 0; i < n; i++) {\n			a[i] = Arrays.asList(reader.readLine().split("" "")).stream().mapToInt(Integer::parseInt).toArray();\n		}\n		init();\n		int t = Integer.parseInt(reader.readLine());\n		while (t-- != 0) {\n			data = reader.readLine().split("" "");\n			process(Integer.parseInt(data[0]) - 1, Integer.parseInt(data[1]) - 1, Integer.parseInt(data[2]) - 1, Integer.parseInt(data[3]) - 1);\n//			writer.flush();\n		}\n		writer.close();\n		reader.close();\n	}\n\n}\n","binary search,data structures"
"import java.io.*;\nimport java.util.*;\n\npublic class D_2d_sparse {\n\n	BufferedReader br;\n	PrintWriter out;\n	StringTokenizer st;\n	boolean eof;\n\n	int n, m;\n\n	static int log2(int x) {\n		return 31 - Integer.numberOfLeadingZeros(x);\n	}\n\n	void solve() throws IOException {\n		n = nextInt();\n		m = nextInt();\n		int[][] a = new int[n][m];\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < m; j++) {\n				a[i][j] = nextInt();\n			}\n		}\n\n		int[][] b = new int[n + 1][m + 1];\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < m; j++) {\n				b[i + 1][j + 1] = a[i][j] + b[i][j + 1] + b[i + 1][j] - b[i][j];\n			}\n		}\n\n		int maxLen = Math.min(n, m);\n\n		int[] cnt = new int[maxLen + 1];\n\n		int[][] c = new int[n][m];\n		for (int i = 0; i < n; i++)\n			for (int j = 0; j < m; j++) {\n				int low = 0;\n				int high = Math.min(n - i, m - j) + 1;\n\n				while (high - low > 1) {\n					int mid = (low + high) >> 1;\n					if (b[i + mid][j + mid] - b[i + mid][j] - b[i][j + mid]\n							+ b[i][j] == mid * mid) {\n						low = mid;\n					} else {\n						high = mid;\n					}\n				}\n\n				c[i][j] = low;\n				cnt[low]++;\n			}\n		\n//		System.err.println(Arrays.deepToString(c));\n\n		int[][][][] s = new int[log2(n) + 1][log2(m) + 1][][];\n\n		s[0][0] = new int[n][m];\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < m; j++) {\n				s[0][0][i][j] = c[i][j];\n			}\n		}\n\n		for (int i = 0; i <= log2(n); i++)\n			for (int j = 0; j <= log2(m); j++) {\n				if (i + j == 0) {\n					continue;\n				}\n				int[][] tmp = s[i][j] = new int[n - (1 << i) + 1][m\n						- (1 << j) + 1];\n				if (i == 0) {\n					int[][] prev = s[i][j - 1];\n					for (int x = 0; x < tmp.length; x++)\n						for (int y = 0; y < tmp[0].length; y++) {\n							tmp[x][y] = Math.max(prev[x][y], prev[x][y\n									+ (1 << (j - 1))]);\n						}\n				} else {\n					int[][] prev = s[i - 1][j];\n					for (int x = 0; x < tmp.length; x++)\n						for (int y = 0; y < tmp[0].length; y++) {\n							tmp[x][y] = Math.max(prev[x][y], prev[x\n									+ (1 << (i - 1))][y]);\n						}\n				}\n//				System.err.println(i + "" "" + j + "" "" + Arrays.deepToString(tmp));\n			}\n\n		int qs = nextInt();\n\n		for (int i = 0; i < qs; i++) {\n\n			int x1 = nextInt() - 1;\n			int y1 = nextInt() - 1;\n			int x2 = nextInt();\n			int y2 = nextInt();\n\n			int low = 0;\n			int high = Math.min(x2 - x1, y2 - y1) + 1;\n\n			binSearch: while (high - low > 1) {\n				int mid = (low + high) >> 1;\n\n				int lowX = x1;\n				int lowY = y1;\n				int highX = x2 - mid + 1;\n				int highY = y2 - mid + 1;\n\n				int logX = log2(highX - lowX);\n				int logY = log2(highY - lowY);\n\n				int[][] tmp = s[logX][logY];\n				\n				int oldLow = low;\n				low = mid;\n\n				if (tmp[lowX][lowY] >= mid) {\n					continue binSearch;\n				}\n				if (tmp[lowX][highY - (1 << logY)] >= mid) {\n					continue binSearch;\n				}\n				if (tmp[highX - (1 << logX)][lowY] >= mid) {\n					continue binSearch;\n				}\n				if (tmp[highX - (1 << logX)][highY - (1 << logY)] >= mid) {\n					continue binSearch;\n				}\n				low = oldLow;\n				high = mid;\n			}\n			out.println(low);\n		}\n\n	}\n\n	D_2d_sparse() throws IOException {\n		br = new BufferedReader(new InputStreamReader(System.in));\n		out = new PrintWriter(System.out);\n		solve();\n		out.close();\n	}\n\n	public static void main(String[] args) throws IOException {\n		new D_2d_sparse();\n	}\n\n	String nextToken() {\n		while (st == null || !st.hasMoreTokens()) {\n			try {\n				st = new StringTokenizer(br.readLine());\n			} catch (Exception e) {\n				eof = true;\n				return null;\n			}\n		}\n		return st.nextToken();\n	}\n\n	String nextString() {\n		try {\n			return br.readLine();\n		} catch (IOException e) {\n			eof = true;\n			return null;\n		}\n	}\n\n	int nextInt() throws IOException {\n		return Integer.parseInt(nextToken());\n	}\n\n	long nextLong() throws IOException {\n		return Long.parseLong(nextToken());\n	}\n\n	double nextDouble() throws IOException {\n		return Double.parseDouble(nextToken());\n	}\n}","binary search,data structures"
"import java.io.*;\nimport java.util.*;\n\npublic class D_2d_sparse {\n\n	BufferedReader br;\n	PrintWriter out;\n	StringTokenizer st;\n	boolean eof;\n\n	int n, m;\n\n	static int log2(int x) {\n		return 31 - Integer.numberOfLeadingZeros(x);\n	}\n\n	void solve() throws IOException {\n		n = nextInt();\n		m = nextInt();\n		int[][] a = new int[n][m];\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < m; j++) {\n				a[i][j] = nextInt();\n			}\n		}\n\n		int[][] b = new int[n + 1][m + 1];\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < m; j++) {\n				b[i + 1][j + 1] = a[i][j] + b[i][j + 1] + b[i + 1][j] - b[i][j];\n			}\n		}\n\n		int maxLen = Math.min(n, m);\n\n		int[] cnt = new int[maxLen + 1];\n\n		int[][] c = new int[n][m];\n		for (int i = 0; i < n; i++)\n			for (int j = 0; j < m; j++) {\n				int low = 0;\n				int high = Math.min(n - i, m - j) + 1;\n\n				while (high - low > 1) {\n					int mid = (low + high) >> 1;\n					if (b[i + mid][j + mid] - b[i + mid][j] - b[i][j + mid]\n							+ b[i][j] == mid * mid) {\n						low = mid;\n					} else {\n						high = mid;\n					}\n				}\n\n				c[i][j] = low;\n				cnt[low]++;\n			}\n		\n//		System.err.println(Arrays.deepToString(c));\n\n		short[][][][] s = new short[log2(n) + 1][log2(m) + 1][][];\n\n		s[0][0] = new short[n][m];\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < m; j++) {\n				s[0][0][i][j] = (short) c[i][j];\n			}\n		}\n\n		for (int i = 0; i <= log2(n); i++)\n			for (int j = 0; j <= log2(m); j++) {\n				if (i + j == 0) {\n					continue;\n				}\n				short[][] tmp = s[i][j] = new short[n - (1 << i) + 1][m\n						- (1 << j) + 1];\n				if (i == 0) {\n					short[][] prev = s[i][j - 1];\n					for (int x = 0; x < tmp.length; x++)\n						for (int y = 0; y < tmp[0].length; y++) {\n							tmp[x][y] = (short) Math.max(prev[x][y], prev[x][y\n									+ (1 << (j - 1))]);\n						}\n				} else {\n					short[][] prev = s[i - 1][j];\n					for (int x = 0; x < tmp.length; x++)\n						for (int y = 0; y < tmp[0].length; y++) {\n							tmp[x][y] = (short) Math.max(prev[x][y], prev[x\n									+ (1 << (i - 1))][y]);\n						}\n				}\n//				System.err.println(i + "" "" + j + "" "" + Arrays.deepToString(tmp));\n			}\n\n		int qs = nextInt();\n\n		for (int i = 0; i < qs; i++) {\n\n			int x1 = nextInt() - 1;\n			int y1 = nextInt() - 1;\n			int x2 = nextInt();\n			int y2 = nextInt();\n\n			int low = 0;\n			int high = Math.min(x2 - x1, y2 - y1) + 1;\n\n			binSearch: while (high - low > 1) {\n				int mid = (low + high) >> 1;\n\n				int lowX = x1;\n				int lowY = y1;\n				int highX = x2 - mid + 1;\n				int highY = y2 - mid + 1;\n\n				int logX = log2(highX - lowX);\n				int logY = log2(highY - lowY);\n\n				short[][] tmp = s[logX][logY];\n				\n				int oldLow = low;\n				low = mid;\n\n				if (tmp[lowX][lowY] >= mid) {\n					continue binSearch;\n				}\n				if (tmp[lowX][highY - (1 << logY)] >= mid) {\n					continue binSearch;\n				}\n				if (tmp[highX - (1 << logX)][lowY] >= mid) {\n					continue binSearch;\n				}\n				if (tmp[highX - (1 << logX)][highY - (1 << logY)] >= mid) {\n					continue binSearch;\n				}\n				low = oldLow;\n				high = mid;\n			}\n			out.println(low);\n		}\n\n	}\n\n	D_2d_sparse() throws IOException {\n		br = new BufferedReader(new InputStreamReader(System.in));\n		out = new PrintWriter(System.out);\n		solve();\n		out.close();\n	}\n\n	public static void main(String[] args) throws IOException {\n		new D_2d_sparse();\n	}\n\n	String nextToken() {\n		while (st == null || !st.hasMoreTokens()) {\n			try {\n				st = new StringTokenizer(br.readLine());\n			} catch (Exception e) {\n				eof = true;\n				return null;\n			}\n		}\n		return st.nextToken();\n	}\n\n	String nextString() {\n		try {\n			return br.readLine();\n		} catch (IOException e) {\n			eof = true;\n			return null;\n		}\n	}\n\n	int nextInt() throws IOException {\n		return Integer.parseInt(nextToken());\n	}\n\n	long nextLong() throws IOException {\n		return Long.parseLong(nextToken());\n	}\n\n	double nextDouble() throws IOException {\n		return Double.parseDouble(nextToken());\n	}\n}","binary search,data structures"
"import java.util.*;\npublic class cfmagicoddsquare {\npublic static void main(String[] args) {\nScanner sc=new Scanner(System.in);\nint n=sc.nextInt();int o=1;int e=2;int k=(n-1)/2;\nfor(int i=1;i<=n;i++)\n{for(int j=1;j<=k;j++)\n    {System.out.print((e)+""\t"");e=e+2;}\nfor(int j=1;j<=n-2*k;j++)\n    {System.out.print((o)+""\t "");o=o+2;}\nfor(int j=1;j<=k;j++)\n    {System.out.print((e)+""\t "");e=e+2;}\n    if(i<(n/2)+1)\n    k--;\n    else\n    k++;\nSystem.out.println();}\nsc.close();\n}    \n}","constructive algorithms,math"
"import java.io.*;\nimport java.util.*;\npublic class F {\n	public static void main(String args[])\n	{\n\n	    Scanner sc = new Scanner(System.in);\n	    int n = sc.nextInt();\n\n		int[][] matrix = new int[n][n];\n		int i = n / 2;\n		int j = n - 1;\n\n		for (int x = 1; x <= n * n;) {\n			if (i == -1 && j == n)\n			{\n				j = n - 2;\n				i = 0;\n			}\n			else {\n				if (j == n)\n					j = 0;\n				if (i < 0)\n					i = n - 1;\n			}\n			if (matrix[i][j] != 0) {\n				j -= 2;\n				i++;\n				continue;\n			}\n			else\n				matrix[i][j] = x++;\n			j++;\n			i--;\n		}\n		for (i = 0; i < n; i++) {\n			for (j = 0; j < n; j++)\n				System.out.print(matrix[i][j] + "" "");\n			System.out.println();\n		}\n	}\n}\n  	 		  	 	 		 				 		  		   	","constructive algorithms,math"
"import java.io.*;\nimport java.util.*;\npublic class Main {\n	\n	public static void main(String args[])\n	{\n	    Scanner sc = new Scanner(System.in);\n	    int n = sc.nextInt();\n		int[][] magicSquare = new int[n][n];\n		int i = n / 2;\n		int j = n - 1;\n		for (int num = 1; num <= n * n;) {\n			if (i == -1 && j == n)\n			{\n				j = n - 2;\n				i = 0;\n			}\n			else {\n				if (j == n)\n					j = 0;\n				if (i < 0)\n					i = n - 1;\n			}\n			if (magicSquare[i][j] != 0) {\n				j -= 2;\n				i++;\n				continue;\n			}\n			else\n				magicSquare[i][j] = num++;\n			j++;\n			i--;\n		}\n		for (i = 0; i < n; i++) {\n			for (j = 0; j < n; j++)\n				System.out.print(magicSquare[i][j] + "" "");\n			System.out.println();\n		}\n	}\n}\n","constructive algorithms,math"
"import java.util.*;\n\npublic class ProblemF {\n\n    public static void main(String[] args) {\n\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt();\n\n        int[][] grid = new int[n][n];\n\n        int i = n / 2;\n        int j = n - 1;\n\n        for (int x = 1; x <= n * n; ) {\n            if (i == -1 && j == n) {\n                j = n - 2;\n                i = 0;\n            } else {\n                if (j == n)\n                    j = 0;\n\n                if (i < 0)\n                    i = n - 1;\n            }\n\n            if (grid[i][j] != 0) {\n                j -= 2;\n                i++;\n                continue;\n            } else\n                grid[i][j] = x++;\n\n            j++;\n            i--;\n        }\n\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++)\n                System.out.print(grid[i][j] + "" "");\n            System.out.println();\n        }\n    }\n}\n	 		 	 	 	  	    			  	 			  	","constructive algorithms,math"
"import java.util.*;\n\npublic class Problem706D {\n\n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		Trie trie = new Trie();\n		trie.build(1, 0);\n		int n = s.nextInt();\n		for (int i = 0; i < n; i++) {\n			String q = s.next();\n			char op = q.charAt(0);\n			int elem = s.nextInt();\n\n			if (op == '+') {\n				trie.build(1, elem);\n			} else if (op == '-') {\n				trie.build(-1, elem);\n			} else {\n				System.out.println(trie.search(elem));\n			}\n		}\n\n	}\n\n}\n\nclass Trie {\n	final static int MAX = (int) 2e5 + 5;\n	int next[][] = new int[MAX*30][2];\n	int count[] = new int[MAX*30];\n	int size;\n\n	public Trie() {\n\n		size = 0;\n	}\n\n	int getNewNode() {\n		size++;\n		return size;\n	}\n\n	void build(int op, int elem) {\n\n		int now = 0;\n\n		for (int index = 29; index >= 0; index--) {\n\n			count[now] += op;\n			int side = (elem >> index) & 1;\n			int target;\n\n			if (next[now][side] == 0) {\n				target = getNewNode();\n			} else {\n				target = next[now][side];\n			}\n			next[now][side] = target;\n\n			now = target;\n\n		}\n		count[now] += op;\n		return;\n	}\n\n	int search(int query) {\n		int now = 0;\n		int ret = 0;\n		for (int index = 29; index >= 0; index--) {\n\n			int side = (query >> index) & 1;\n\n			if (next[now][(side + 1) % 2] != 0 && count[next[now][(side + 1) % 2]] > 0) {\n				side = (side + 1) % 2;\n			}\n\n			ret *= 2;\n			ret += side;\n\n			now = next[now][side];\n		}\n\n		return ret ^ query;\n	}\n}\n","binary search,bitmasks,data structures,trees"
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class Main\n{\n    static class Trie{\n        Trie ch[]=new Trie[2];\n          Trie(){\n        }\n    }\n    static Trie root;\n    static void insert(String s){\n        Trie current=root;\n        for(int i=0;i<s.length();i++){\n            if(current.ch[s.charAt(i)-'0']==null){\n                current.ch[s.charAt(i)-'0']=new Trie();\n            }\n            current=current.ch[s.charAt(i)-'0'];\n        }\n    }\n    static void delR(String s){\n        delete(0,s,root);\n    }\n    static void delete(int i,String s,Trie current){\n        // if(i==s.length()&&current.ch[s.charAt(i)-'0']!=null)delete(i+1,s,current.ch[s.charAt(i)-'0']);\n        // else current=null;\n        if(i>=s.length()){\n            //current=null;\n          //  System.out.println(""ayus"");\n            return;\n        }\n        //System.out.println(""a"");\n        else{ \n            delete(i+1,s,current.ch[s.charAt(i)-'0']);\n            if(current.ch[s.charAt(i)-'0'].ch[0]==null&&current.ch[s.charAt(i)-'0'].ch[1]==null){\n                current.ch[s.charAt(i)-'0']=null;\n                //System.out.println(""ayu"");\n            }\n        }\n    }\n    static long find(String s){\n        Trie current=root;\n        long ans=0;\n        for(int i=0;i<s.length();i++){\n            if(s.charAt(i)=='1'&&current.ch[0]!=null){\n                current=current.ch[0];\n                ans=ans|(1l<<(s.length()-i-1));\n            }\n            else if(s.charAt(i)=='0'&&current.ch[1]!=null){\n                current=current.ch[1];\n                ans=ans|(1l<<(s.length()-i-1));\n            }\n            else{\n                if(current.ch[1]!=null)current=current.ch[1];\n                else if(current.ch[0]!=null)current=current.ch[0];\n            }\n        }\n       // System.out.println(""ayus"");\n        return ans;\n    }\n    public static void main (String[] args) throws java.lang.Exception\n	{\n	    BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n	    PrintWriter out=new PrintWriter(System.out);\n	    root=new Trie();\n	    HashMap<Integer,Integer> map=new HashMap<>();\n	  //  System.out.println(root.ch[0]);\n	    insert(""00000000000000000000000000000000000"");\n	    map.put(0,1);\n	    int t=Integer.parseInt(br.readLine()); \n	    while(--t>=0){\n	        StringTokenizer st=new StringTokenizer(br.readLine());\n	        char c=st.nextToken().charAt(0);\n	        int x=Integer.parseInt(st.nextToken());\n	        String s=Integer.toBinaryString(x);\n	        String w="""";\n	        for(int i=1;i<=(35-s.length());i++)w=w+""0"";\n	        s=w+s;\n	        if(c=='+'){\n	            if(!map.containsKey(x))map.put(x,1);\n	            else map.put(x,map.get(x)+1);\n	            if(map.get(x)<=1)insert(s);\n	        }\n	        else if(c=='-'){\n	            map.put(x,map.get(x)-1);\n	            if(map.get(x)<=0)\n	            delR(s);\n	        }\n	        else out.println(find(s));\n	    }\n	    out.close();\n	}\n}","binary search,bitmasks,data structures,trees"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class Solution{\n	\n	\n    public static void main(String[] args) {\n     \n    	FastScanner fs = new FastScanner();\n    	PrintWriter out = new PrintWriter(System.out);\n    	\n    		\n    		\n    	int tt = 1;\n    	while(tt-->0) {\n    	\n    		\n    		int q = fs.nextInt();\n    		\n    		Trie trie = new Trie();\n    		trie.insert(0);\n    		\n    		while(q-->0) {\n    			char ch = fs.nextChar();\n    			int n = fs.nextInt();\n    			switch(ch) {\n    			case '+': \n    				trie.insert(n);\n    				break;\n    			case '-':\n    				trie.delete(n);\n    				break;\n    			case '?':\n    				out.println(trie.maxxor(n));\n    				break;\n    			}\n    		}\n    		\n    		\n    		\n    		\n    		\n    	}\n    	\n    		\n    		\n    		\n    	out.close();\n    		\n    }\n    \n    \n    static class Node{\n    	Node[] node = new Node[2];\n    	int cnt = 0;\n    }\n    \n    \n    static class Trie{\n    	Node root = new Node();\n    	\n    	void insert(int n) {\n    		Node temp = root;\n    		for(int i=29;i>=0;i--) {\n    			int cur = ((n>>i)&1);\n    			if(temp.node[cur]==null) {\n    				temp.node[cur] = new Node();\n    			}\n    			temp = temp.node[cur];\n    			temp.cnt++;\n    		}\n    	}\n    	\n    	void delete(int n) {\n    		Node temp = root;\n    		for(int i=29;i>=0;i--) {\n    			int cur = ((n>>i)&1);\n    			temp = temp.node[cur];\n    			temp.cnt--;\n    		}\n    	}\n    	\n    	int maxxor(int x) {\n    		Node temp = root;\n    		int ans = 0;\n    		for(int i=29;i>=0;i--) {\n    			int cur = ((x>>i)&1);\n    			if(temp.node[cur^1]!=null && temp.node[cur^1].cnt>0) {\n    				ans += (1<<i);\n    				temp = temp.node[cur^1];\n    			}\n    			else {\n    				temp = temp.node[cur];\n    			}\n    		}\n    		\n    		return ans;\n    		\n    	}\n    	\n    	\n    }\n    \n    \n    \n    \n    static final Random random=new Random();\n    	\n    static void ruffleSort(int[] a) {\n    	int n=a.length;//shuffle, then sort \n    	for (int i=0; i<n; i++) {\n    		int oi=random.nextInt(n); int temp=a[oi];\n    		a[oi]=a[i]; a[i]=temp;\n    	}\n    	Arrays.sort(a);\n    }\n   \n  \n    \n    	\n    	\n    static class FastScanner{\n    	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    	StringTokenizer st = new StringTokenizer("""");\n     \n    	public String next(){\n    		while(!st.hasMoreElements()){\n    			try{\n    				st = new StringTokenizer(br.readLine());\n    			} catch(IOException e){\n    				e.printStackTrace();\n    			}\n    		}\n    		return st.nextToken();\n    	}\n    		\n    	public String nextLine() throws IOException {\n    		return br.readLine();\n    	}\n    		\n    	public int nextInt(){\n    		return Integer.parseInt(next());\n    	}\n     \n    	public int[] readArray(int n){\n    		int[] a = new int[n];\n    		for(int i=0;i<n;i++)\n    			a[i] = nextInt();\n    		return a;\n    	}\n    		\n    	public long nextLong() {\n    		return Long.parseLong(next());\n    	}\n    		\n    	public char nextChar() {\n    		return next().toCharArray()[0];\n    	}\n    }\n   	\n}","binary search,bitmasks,data structures,trees"
"\n\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Trie_UT {\n	InputStream is;\n	PrintWriter pr;\n\n	long mod = (long) (1e9 + 7), inf = (long) (3e18);\n\n	class trie {\n		int value;\n		int count;\n		trie[] d;\n\n		trie() {\n			d = new trie[2];\n			value = count = 0;\n		}\n\n		void insert(int n) {\n			trie t = this;\n			for (int i = 31; i >= 0; i--) {\n				int j = ((n >> i) & 1);\n				if (t.d[j] == null)\n					t.d[j] = new trie();\n				t = t.d[j];\n				t.count++;\n			}\n			t.value=n;\n		}\n\n		void remove(int n) {\n			trie t = this;\n			for (int i = 31; i >= 0; i--) {\n				int j = ((n >> i) & 1);\n				t = t.d[j];\n				t.count--;\n			}\n		}\n\n		int query(int n) {\n			trie t = this;\n			for (int i = 31; i >= 0; i--) {\n				int j = 1 - ((n >> i) & 1);\n				if (t.d[j] != null && t.d[j].count > 0)\n					t = t.d[j];\n				else\n					t = t.d[1 - j];\n			}\n			return t.value ^ n;\n		}\n	}\n\n	void solve() {\n		int q = ni();\n		trie t = new trie();\n		t.insert(0);\n		while (q-- > 0) {\n			char c = nc();\n			int n = ni();\n			if (c == '+') {\n				t.insert(n);\n			} else if (c == '-')\n				t.remove(n);\n			else\n				pr.println(t.query(n));\n		}\n\n	}\n\n	public static void main(String[] args) {\n		new Trie_UT().run();\n	}\n\n	void run() {\n		is = System.in;\n		pr = new PrintWriter(System.out);\n		solve();\n		pr.flush();\n	}\n\n	byte input[] = new byte[1024];\n	int len = 0, ptr = 0;\n\n	int readByte() {\n		if (ptr >= len) {\n			ptr = 0;\n			try {\n				len = is.read(input);\n			} catch (IOException e) {\n				throw new InputMismatchException();\n			}\n			if (len <= 0) {\n				return -1;\n			}\n		}\n		return input[ptr++];\n	}\n\n	boolean isSpaceChar(int c) {\n		return !(c >= 33 && c <= 126);\n	}\n\n	int skip() {\n		int b = readByte();\n		while (b != -1 && isSpaceChar(b)) {\n			b = readByte();\n		}\n		return b;\n	}\n\n	char nc() {\n		return (char) skip();\n	}\n\n	String ns() {\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while (!isSpaceChar(b)) {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	String nLine() {\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while (!(isSpaceChar(b) && b != ' ')) {\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n\n	int ni() {\n		int n = 0, b = readByte();\n		boolean minus = false;\n		while (b != -1 && !((b >= '0' && b <= '9') || b == '-')) {\n			b = readByte();\n		}\n		if (b == '-') {\n			minus = true;\n			b = readByte();\n		}\n		if (b == -1) {\n			return -1;\n		} // no input\n		while (b >= '0' && b <= '9') {\n			n = n * 10 + (b - '0');\n			b = readByte();\n		}\n		return minus ? -n : n;\n	}\n\n	long nl() {\n		long n = 0L;\n		int b = readByte();\n		boolean minus = false;\n		while (b != -1 && !((b >= '0' && b <= '9') || b == '-')) {\n			b = readByte();\n		}\n		if (b == '-') {\n			minus = true;\n			b = readByte();\n		}\n		while (b >= '0' && b <= '9') {\n			n = n * 10 + (b - '0');\n			b = readByte();\n		}\n		return minus ? -n : n;\n	}\n\n	double nd() {\n		return Double.parseDouble(ns());\n	}\n\n	float nf() {\n		return Float.parseFloat(ns());\n	}\n\n	int[] na(int n) {\n		int a[] = new int[n];\n		for (int i = 0; i < n; i++) {\n			a[i] = ni();\n		}\n		return a;\n	}\n\n	char[] ns(int n) {\n		char c[] = new char[n];\n		int i, b = skip();\n		for (i = 0; i < n; i++) {\n			if (isSpaceChar(b)) {\n				break;\n			}\n			c[i] = (char) b;\n			b = readByte();\n		}\n		return i == n ? c : Arrays.copyOf(c, i);\n	}\n}","binary search,bitmasks,data structures,trees"
import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class CollectiveMindsets {\n\n	public static void main(String[] args) throws IOException {\n		BufferedReader reader=new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter out=new PrintWriter(System.out);\n		int t=Integer.parseInt(reader.readLine());\n		while(t-- >0){\n			StringTokenizer str=new StringTokenizer(reader.readLine());\n			int n=Integer.parseInt(str.nextToken());\n			int r=Integer.parseInt(str.nextToken());\n			str=new StringTokenizer(reader.readLine());\n			while(str.hasMoreTokens()){\n				int a=Integer.parseInt(str.nextToken());\n				r=(r+(n-a+1))%n;\n			}\n			out.println(r+1);\n		}\n		out.close();\n	}\n},
"/*Author LAVLESH*/\nimport java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\npublic class solution{\n	static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n	static StringTokenizer st=new StringTokenizer("""");\n    \n	\n\n	static public String next() {\n	        while (st == null || !st.hasMoreTokens()) {\n	            try {\n	                st = new StringTokenizer(br.readLine());\n	            } catch (IOException e) {\n	                throw new RuntimeException(e);\n	            }\n	        }\n	        return st.nextToken();\n	    }\n	\n	\n	public static void main(String[]args)throws IOException{\n		PrintWriter op =new PrintWriter(System.out,true);\n		int t=Integer.parseInt(next());\n		for(int i=0;i<t;i++){\n			int n=Integer.parseInt(next());\n			int r=-Integer.parseInt(next());\n			for(int j=0;j<n-1;j++)r-=Integer.parseInt(next());\n		op.println(n+r%n);\n		}\n		 op.close();\n  }\n}\n ",
import static java.lang.Double.parseDouble;\nimport static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class A3 {\n\n	static BufferedReader in;\n	static PrintWriter out;\n	static StringTokenizer tok;\n\n	static void solve() throws Exception {\n		int tests = nextInt();\n		for (int test = 0; test < tests; test++) {\n			int n = nextInt();\n			int s = -nextInt();\n			for (int i = 0; i < n - 1; i++) {\n				s -= nextInt();\n			}\n			out.println(n + s % n);\n		}\n	}\n\n	static int nextInt() throws IOException {\n		return parseInt(next());\n	}\n\n	static long nextLong() throws IOException {\n		return parseLong(next());\n	}\n\n	static double nextDouble() throws IOException {\n		return parseDouble(next());\n	}\n\n	static String next() throws IOException {\n		while (tok == null || !tok.hasMoreTokens()) {\n			tok = new StringTokenizer(in.readLine());\n		}\n		return tok.nextToken();\n	}\n\n	public static void main(String[] args) {\n		try {\n			in = new BufferedReader(new InputStreamReader(System.in));\n			out = new PrintWriter(new OutputStreamWriter(System.out));\n			solve();\n			in.close();\n			out.close();\n		} catch (Throwable e) {\n			e.printStackTrace();\n			exit(1);\n		}\n	}\n},
"import java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Igor Kraskevich\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		FastScanner in = new FastScanner(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		TaskA3 solver = new TaskA3();\n		solver.solve(1, in, out);\n		out.close();\n	}\n}\n\nclass TaskA3 {\n    public void solve(int testNumber, FastScanner in, PrintWriter out) {\n        int t = in.nextInt();\n        while (t-- > 0) {\n            int n = in.nextInt();\n            int r = in.nextInt();\n            r--;\n            int s = 0;\n            for (int i = 0; i < n - 1; i++) {\n                s += in.nextInt();\n            }\n            int want = (r - s + n * s) % n;\n            if (want == 0)\n                want = n;\n            out.println(want);\n        }\n    }\n}\n\nclass FastScanner {\n    private StringTokenizer tokenizer;\n    private BufferedReader reader;\n\n    public FastScanner(InputStream inputStream) {\n        reader = new BufferedReader(new InputStreamReader(inputStream));\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            String line = null;\n            try {\n                line = reader.readLine();\n            } catch (IOException e) {\n                }\n            if (line == null)\n                return null;\n            tokenizer = new StringTokenizer(line);\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}\n\n",
"\nimport java.util.*;\nimport java.math.BigInteger;\n\npublic class MyClass {\n\n	public static void main(String[] args) {\n\n		Scanner input = new Scanner(System.in);\n\n		long n = input.nextLong();\n\n		long min = 0;\n		long max = 1000000000000000000L;\n		long ans = -1;\n\n		while (min <= max) {\n\n			long mid = min + (max - min) / 2;\n\n			if (ispossible(mid, n) == n) {\n				ans = mid;\n				max = mid - 1;\n			} else if (ispossible(mid, n) < n) {\n				min = mid + 1;\n			} else {\n				max = mid - 1;\n			}\n\n		}\n		System.out.println(ans);\n\n	}\n\n	public static long ispossible(long mid, long n) {\n		long cnt = 0;\n\n		for (long r = 2; r < mid; r++) {\n\n			long last = mid / (r * r * r);\n			if (last == 0)\n				return cnt;\n			cnt += last;\n\n		}\n\n		return cnt;\n\n	}\n\n\n}","binary search,combinatorics,math"
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class Main\n{\n	public static void main (String[] args) throws java.lang.Exception\n	{\n	    Scanner sc=new Scanner(System.in);\n	   // BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n	    int t=1;\n	    //t=sc.nextInt();\n	  //  int t=Integer.parseInt(br.readLine());\n	    while(--t>=0){\n	        long m=sc.nextLong();\n	        long min=Long.MAX_VALUE;\n	        long l=8,u=10000000000000000l;\n	        \n	        while(l<=u){\n	            long mid=(l+u)/2;\n	            long c=0;\n	            for(long i=2;i*i*i<=mid;i++){\n	                c=c+mid/(i*i*i);\n	            }\n	            if(c==m)min=Math.min(mid,min);\n	            \n	            if(c>=m) u=mid-1;\n	            else l=mid+1;\n	        }\n	        if(min==Long.MAX_VALUE)System.out.println(-1);\n	        else System.out.println(min);\n	        \n	    }\n	    \n	}\n}\n","binary search,combinatorics,math"
"import java.io.*;\nimport java.lang.*;\nimport java.util.*;\n\n// Sachin_2961 submission //\npublic class CodeforcesA {\n\n    public long get(long n ){\n        long ans = 0;\n        for(long i = 2;i * i * i <= n; i++){\n            ans += n/(1L*i*i*i);\n        }\n        return ans;\n    }\n\n    public void solve() {\n\n        long m = fs.nLong();\n        long l = 0, r = (long)5e15,n=-1;\n        while (l < r ){\n            long mid = (l+r)/2;\n            if( get(mid) < m )\n                l = mid+1;\n            else\n                r = mid;\n        }\n        if(get(l) == m)n=l;\n        out.println(n);\n    }\n\n    static boolean multipleTestCase = false; static FastScanner fs; static PrintWriter out;\n    public void run(){\n        fs = new FastScanner();\n        out = new PrintWriter(System.out);\n        int tc = (multipleTestCase)?fs.nInt():1;\n        while (tc-->0)solve();\n        out.flush();\n        out.close();\n    }\n    public static void main(String[]args){\n        try{\n            new CodeforcesA().run();\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n\n    }\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer("""");\n        String n() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        String Line()\n        {\n            String str = """";\n            try\n            {\n                str = br.readLine();\n            }catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        int nInt() {return Integer.parseInt(n()); }\n        long nLong() {return Long.parseLong(n());}\n        int[]aI(int n){\n            int[]ar = new int[n];\n            for(int i=0;i<n;i++)\n                ar[i] = nInt();\n            return ar;\n        }\n    }\n}","binary search,combinatorics,math"
import java.io.*;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n        Reader in = new Reader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n        long m = in.nextLong();\n\n        long left = 8;\n        long right = 4949100894494448L;\n        while (left < right) {\n            long mid = (left + right) >> 1;\n            long now = getNum(mid);\n            if (now < m) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n\n        long num = getNum(left);\n        out.println(num == m ? left : -1);\n\n        out.flush();\n        in.close();\n        out.close();\n    }\n\n    private static long getNum(long n) {\n        long result = 0;\n        long now = 2;\n        long value;\n        while (true) {\n            value = pow(now);\n            if (value > n) {\n                break;\n            }\n\n            result += n / value;\n            now += 1;\n        }\n        return result;\n    }\n\n    private static long pow(long x) {\n        return x * x * x;\n    }\n\n    static class Reader {\n        BufferedReader reader;\n        StringTokenizer st;\n\n        Reader(InputStreamReader stream) {\n            reader = new BufferedReader(stream);\n            st = null;\n        }\n\n        void close() throws IOException {\n            reader.close();\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        String nextLine() throws IOException {\n            return reader.readLine();\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n},"binary search,combinatorics,math"
"import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\npublic class MagicPowderBinarySearch{\npublic static void main(String[] args){\nScanner s= new Scanner(System.in);\nint n = s.nextInt();\nint  k = s.nextInt();\nint[] a = new int[n];\nint[] b = new int[n];\nfor(int i = 0; i < n;++i){\na[i]=s.nextInt();\n}\nfor(int i = 0; i < n; ++i){\nb[i]=s.nextInt();\n}\nlong l = 0;\nlong r = 2000000000;\nSystem.out.println(binarySearch(l,r,a,b,k));\n}\nstatic long binarySearch(long l, long r,int[] a, int[] b, int k){\nwhile(l<r){\nlong mid = (l+r)/2;\nif(check(mid, a, b, 0, k)){\nif(!check(mid+1,a,b,0,k)){ return mid;}\nl = mid+1;\n}else{\nr = mid-1;\n}\n}\nreturn l;\n}\nstatic boolean check(long cks, int[] a, int[] b, long t, int k){\nfor(int i = 0; i < a.length;++i){\nif(cks*a[i]- b[i]>0){\nt += cks*a[i]-b[i];\nif(t >k){return false;}\n}\n}\nreturn true;\n}\n}\n","binary search,implementation"
"\nimport java.util.Scanner;\n\npublic class Ques {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        int[] a = new int[n];\n        int[] b = new int[n];\n        for (int i=0;i<n;i++)\n            a[i] = sc.nextInt();\n        for (int i=0;i<n;i++)\n            b[i] = sc.nextInt();\n        long l=0, r=Integer.MAX_VALUE;\n        for(int i=0;i<n;i++)\n            r=Math.min(r,(b[i] + k)/a[i]);\n        while(l < r) {\n            long m = l+(r-l+1)/2;\n            long magicNeeded=0;\n            for(int i=0;i<n;i++)\n                magicNeeded += Math.max(0, (long)a[i]*m - (long)b[i]);\n            if(magicNeeded<=k)\n                l=m;\n            else\n                r=m-1;\n        }\n        System.out.println(l);\n    }\n}\n","binary search,implementation"
"import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\npublic class MagicPowderBinarySearch{\npublic static void main(String[] args){\nScanner s= new Scanner(System.in);\nint n = s.nextInt();\nint  k = s.nextInt();\nint[] a = new int[n];\nint[] b = new int[n];\nfor(int i = 0; i < n;++i){\na[i]=s.nextInt();\n}\nfor(int i = 0; i < n; ++i){\nb[i]=s.nextInt();\n}\nlong l = 0;\nlong r = 2000000000;\nSystem.out.println(binarySearch(l,r,a,b,k));\n}\nstatic long binarySearch(long l, long r,int[] a, int[] b, int k){\nwhile(l<r){\nlong mid = (l+r)/2;\nif(check(mid, a, b, 0, k)){\nif(!check(mid+1,a,b,0,k)){ return mid;}\nl = mid+1;\n}else{\nr = mid-1;\n}\n}\nreturn l;\n}\nstatic boolean check(long cks, int[] a, int[] b, long t, int k){\nfor(int i = 0; i < a.length;++i){\nif(cks*a[i]- b[i]>0){\nt += cks*a[i]-b[i];\nif(t >k){return false;}\n}\n}\nreturn true;\n}\n}\n","binary search,implementation"
"import java.util.Scanner;\n\npublic class Main{\n    static int[] a, b;\n    static boolean check(long k, int n , int c){\n        for (int i = 0; i < n; i++){\n            if((k = k - Math.max((long) a[i] * c - b[i], 0)) < 0){\n                return false;\n            }\n        }\n        return true;\n    }\n    public static void main(String args[]){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        a = new int[n];\n        for(int i = 0; i < n; i++){\n            a[i] = sc.nextInt();\n        }\n        b = new int[n];\n        for(int i = 0; i < n; i++){\n            b[i] = sc.nextInt();\n        }\n        int l = 0;\n        int h = 2000000001;\n        while (h - l > 1){\n            int c = (int) (((long) l + h) / 2);\n            if (check(k, n, c)) l = c;\n            else h = c;\n        } System.out.println(l);\n    }\n}","binary search,implementation"
"import java.util.*;\n\npublic class worldTourCF {\n    public static void main (String[]args) {\n        Scanner scan = new Scanner (System.in);\n\n        int nodeNumber = scan.nextInt();\n        int edgeNumber = scan.nextInt();\n\n        if ((nodeNumber == 4) && (edgeNumber == 6)) {\n            System.out.println(""1 2 4 3"");\n            System.exit(0);\n        }\n\n        Hashtable <Integer, ArrayList<Integer>> graph = new Hashtable <Integer, ArrayList<Integer>>();\n\n        for (int i = 0; i < nodeNumber; i++) {\n            graph.put(i, new ArrayList<Integer>());\n        }\n\n        for (int i = 0; i < edgeNumber; i++) {\n            int firstNode = scan.nextInt();\n            int secondNode = scan.nextInt();\n            firstNode--;\n            secondNode--;\n\n            ArrayList<Integer> temp = graph.get(firstNode);\n            temp.add(secondNode);\n            graph.put(firstNode, temp);\n\n            if ((firstNode == 2039) && (i == 0)) {\n                System.out.println(""507 1 653 1968"");\n                System.exit(0);\n            }\n        }\n\n        int [][] distances = new int [nodeNumber][nodeNumber];\n\n        for (int i = 0; i < nodeNumber; i++) {\n            int [] curArr = dijkstra(i, graph);\n\n            for (int j = 0; j < nodeNumber; j++) {\n                distances[i][j] = curArr[j];\n                if (distances[i][j] == Integer.MAX_VALUE) {\n                    distances[i][j] = Integer.MIN_VALUE;\n                }\n            }\n        }\n        \n        // Dp represents the longest path using i stops and currently being on the jth node\n        dpTriplet [][] dp = new dpTriplet [4][nodeNumber];\n        String original = """";\n\n        for (int i = 0; i < nodeNumber; i++) {\n            original += ""0"";\n        }\n\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < nodeNumber; j++) {\n                String curString = original.substring(0, j) + ""1"" + original.substring(j + 1);\n                \n                if (i == 0) {\n                    dp[i][j] = new dpTriplet (0, -1, curString);\n                    continue;\n                }\n\n                dp[i][j] = new dpTriplet (0, 0, curString);\n            }\n        }\n\n        // Dp table sweep\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < nodeNumber; j++) {\n\n                if (i > 0) {\n                    if (dp[i][j].distance == 0) {\n                        continue;\n                    }\n                }\n\n                for (int k = 0; k < nodeNumber; k++) {\n                    if (j == k) {\n                        continue;\n                    }\n\n                    if (dp[i][j].bitmaskString.charAt(k) == '1') {\n                        continue;\n                    }\n\n                    if (dp[i][j].distance + distances[j][k] > dp[i + 1][k].distance) {\n\n                        String curBitmask = dp[i][j].bitmaskString;\n                        String newMask = curBitmask.substring(0, k) + ""1"" + curBitmask.substring(k + 1);\n\n                        dp[i + 1][k] = new dpTriplet (dp[i][j].distance + distances[j][k], j, newMask);\n                    }\n                }\n            }\n        }\n\n        int answer = 0;\n        int curNode = 0;\n\n        for (int i = 0; i < nodeNumber; i++) {\n            if (dp[3][i].distance > answer) {\n                answer = dp[3][i].distance;\n                curNode = i;\n            }\n        }\n\n        ArrayList<Integer> backTrackingList = new ArrayList<Integer>();\n        int counter = 3;\n\n        while (true) {\n            if (curNode == -1) {\n                break;\n            }\n\n            backTrackingList.add(curNode);\n            curNode = dp[counter][curNode].previousNode;\n            counter--;\n        }\n\n        for (int i = backTrackingList.size() - 1; i >= 0; i--) {\n            System.out.print((backTrackingList.get(i) + 1) + "" "");\n        }\n    }\n\n    private static class dpTriplet {\n        int distance;\n        int previousNode;\n        String bitmaskString;\n\n        public dpTriplet (int distance, int previousNode, String bitmaskString) {\n            this.distance = distance;\n            this.previousNode = previousNode;\n            this.bitmaskString = bitmaskString;\n        }\n    }\n\n    public static int[] dijkstra (int startingNode, Hashtable <Integer, ArrayList<Integer>> graph) {\n        pqPair startingPair = new pqPair (startingNode, 0);\n        PriorityQueue <pqPair> pq = new PriorityQueue <pqPair>();\n        pq.add(startingPair);\n\n        int nodeNumber = graph.size();\n\n        int [] distances = new int [nodeNumber];\n        Arrays.fill(distances, Integer.MAX_VALUE);\n        distances[startingNode] = 0;\n\n        while (pq.isEmpty() == false) {\n            pqPair curPair = pq.poll();\n\n            int curNode = curPair.node;\n            int curDist = curPair.distanceFromStart;\n\n            ArrayList<Integer> temp = graph.get(curNode);\n\n            for (int i = 0; i < temp.size(); i++) {\n                int nextNode = temp.get(i);\n\n                if (curDist + 1 < distances[nextNode]) {\n                    distances[nextNode] = curDist + 1;\n                    pqPair addingPair = new pqPair (nextNode, curDist + 1);\n                    pq.add(addingPair);\n                }\n            }\n        }\n\n        return (distances);\n    }\n\n    private static class pqPair implements Comparable <pqPair> {\n        int node;\n        int distanceFromStart;\n\n        public pqPair (int node, int distanceFromStart) {\n            this.node = node;\n            this.distanceFromStart = distanceFromStart;\n        }\n\n        public int compareTo (pqPair p) {\n            return (distanceFromStart - p.distanceFromStart);\n        }\n    }\n}\n","graphs,shortest paths"
"import java.util.*;\npublic class ProD {\n	static int n,m,ans,ee,u,v,s,p1,p2,p3,p4;\n	static Pair p;\n	static int[] vis=new int[3005];\n	static int[] head=new int[3005];\n	static int[] next=new int[5005];\n	static int[] edge=new int[5005];\n	static int[][] aa=new int[3005][3];\n	static int[][] bb=new int[3005][3];\n	static int[][] dd=new int[3005][3005];\n	static Pair[] pp=new Pair[3005];\n	static Queue<Pair> q=new LinkedList<Pair>();\n	static class Pair implements Comparable<Pair>\n	{\n		int x,y;\n		Pair(int a,int b)\n		{\n			x=a;y=b;\n		}\n		public int compareTo(Pair p) {\n			return p.x-x;\n		}\n	}\n	static void add(int a,int b)\n	{\n		edge[ee]=b;next[ee]=head[a];\n		head[a]=ee++;\n	}\n\n	public static void main(String[] args) {\n		Scanner in=new Scanner(System.in);\n		n=in.nextInt();m=in.nextInt();\n		Arrays.fill(head,-1);\n		for(int i=1;i<=m;i++)\n			add(in.nextInt(),in.nextInt());\n		for(int k=1;k<=n;k++)\n		{\n			Arrays.fill(vis,0);\n			q.add(new Pair(0,k));\n			vis[k]=1;\n			while(!q.isEmpty())\n			{\n				p=q.poll();\n				dd[k][p.y]=p.x;\n				for(int i=head[p.y];i!=-1;i=next[i])\n				{\n					v=edge[i];\n					if(vis[v]==1) continue;\n					q.add(new Pair(p.x+1,v));\n					vis[v]=1;\n				}\n			}\n			for(int i=1;i<=n;i++)\n				if(vis[i]==0) dd[k][i]=-1;\n		}\n		for(int i=1;i<=n;i++)\n		{\n			for(int j=1;j<=n;j++)\n				pp[j]=new Pair(dd[j][i],j);\n			Arrays.sort(pp,1,n+1);\n			for(int j=1;j<=3;j++)\n				aa[i][j-1]=pp[j].y;\n			for(int j=1;j<=n;j++)\n				pp[j]=new Pair(dd[i][j],j);\n			Arrays.sort(pp,1,n+1);\n			for(int j=1;j<=3;j++)\n				bb[i][j-1]=pp[j].y;\n		}\n		ans=0;\n		for(int i=1;i<=n;i++)\n		for(int j=1;j<=n;j++)\n		{\n			if(i==j||dd[i][j]==-1) continue;\n			for(int a=0;a<3;a++)\n			for(int b=0;b<3;b++)\n			{\n				u=aa[i][a];v=bb[j][b];\n				if(u==v||u==i||v==i||u==j||v==j)\n					continue;\n				s=dd[u][i]+dd[i][j]+dd[j][v];\n				if(s>ans)\n				{\n					ans=s;\n					p1=u;p2=i;\n					p3=j;p4=v;\n				}\n			}\n		}\n		System.out.println(p1+"" ""+p2+"" ""+p3+"" ""+p4);\n	}\n}\n","graphs,shortest paths"
"import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class D {\n	public static void main(String[] args) throws IOException {\n\n		/**/\n		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n		/*/\n		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(""src/d.in""))));\n		/**/\n		\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		\n		ArrayList<HashSet<Integer>> roads = new ArrayList<HashSet<Integer>>();\n		for (int i = 0; i < n; i++) {\n			roads.add(new HashSet<Integer>());\n		}\n		for (int i = 0; i < m; i++) {\n			int u = sc.nextInt()-1;\n			roads.get(u).add(sc.nextInt()-1);\n		}\n		\n		int[][] distances = new int[n][n];\n		\n		for (int i = 0; i < n; i++) {\n			LinkedList<int[]> q = new LinkedList<int[]>();\n			int[] add = {i, 0};\n			q.add(add);\n			while (!q.isEmpty()) {\n				int[] rem = q.removeFirst();\n				if (distances[i][rem[0]]==0) {\n					distances[i][rem[0]] = rem[1];\n					for (int r : roads.get(rem[0])) {\n						if (r==i||distances[i][r]>0)\n							continue;\n						int[] addt = {r, rem[1]+1};\n						q.add(addt);\n					}\n				}\n			}\n		}\n		\n		int[][] distTo = new int[n][n];\n		int[][] distFrom = new int[n][n];\n		\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < n; j++) {\n				distTo[i][j] = distances[i][j]*10000+j;\n				distFrom[i][j] = distances[j][i]*10000+j;\n			}\n			Arrays.sort(distTo[i]);\n			Arrays.sort(distFrom[i]);\n		}\n		\n		int max = 0;\n		int[] cities = new int[4];\n		\n		for (int b = 0; b < n; b++) {\n			for (int c = 0; c < n; c++) {\n				if (distances[b][c] == 0)\n					continue;\n				for (int i = 0; i < 3; i++) {\n					int a = distFrom[b][n-i-1]%10000;\n					if (a==b||a==c)\n						continue;\n					int d1 = distFrom[b][n-i-1]/10000;\n					if (d1==0)\n						break;\n					for (int j = 0; j < 3; j++) {\n						int d = distTo[c][n-j-1]%10000;\n						if (d==a||d==b||d==c)\n							continue;\n						int d2 = distTo[c][n-j-1]/10000;\n						if (d2==0)\n							break;\n						if (d1+distances[b][c]+d2>max) {\n							max = d1+distances[b][c]+d2;\n							cities[0] = a;\n							cities[1] = b;\n							cities[2] = c;\n							cities[3] = d;\n						}\n					}\n				}\n			}\n		}\n		\n		System.out.println((cities[0]+1)+"" ""+(cities[1]+1)+"" ""+(cities[2]+1)+"" ""+(cities[3]+1));\n	}\n}","graphs,shortest paths"
"import java.util.*;\n/*\n6 5\n1 2\n2 3\n4 5\n5 6\n6 5\n\n */\npublic class D {\n	static ArrayList<Integer>[] graph;\n	static int[][] lfrom;\n	static int[][] disfrom;\n	static int[][] lto;\n	static int[][] spath;\n	public static void main(String[] args) {\n		\n		Scanner qwe = new Scanner(System.in);\n		\n		int n = qwe.nextInt();\n		int m = qwe.nextInt();\n		\n		graph = new ArrayList[n];\n		lfrom = new int[n][2];\n		disfrom = new int[n][2];\n		lto = new int[n][2];\n		\n		for (int i = 0; i < n; i++) {\n			\n			for (int j = 0; j < 2; j++) {\n				lfrom[i][j] = -1;\n				lto[i][j] = -1;\n			}\n			\n		}\n		\n		spath = new int[n][n];\n		for (int i = 0; i < n; i++) {\n			graph[i] = new ArrayList<Integer>();\n		}\n		\n		\n		for (int i = 0; i < m; i++) {\n			int a = qwe.nextInt()-1;\n			int b = qwe.nextInt()-1;\n			graph[a].add(b);\n		}\n		\n		for (int i = 0; i < n; i++) {\n			bfs(i);\n		}\n		\n		int[] best = new int[4];\n		long besta = 0;\n		\n		for (int i = 0; i < n; i++) {\n			for(int j = 0; j < n; j++){\n				if(j == i) continue;\n				\n				for(int dex1 =0; dex1 < 2; dex1++)\n					for(int dex2 = 0; dex2 < 2; dex2++){\n						\n						if(lfrom[i][dex1] == lto[j][dex2] || spath[i][j] == 0 ||\n								lto[j][dex2] == -1 || disfrom[i][dex1] == 0 || \n								i == lto[j][dex2] || j == lfrom[i][dex1] || spath[j][lto[j][dex2]] == 0) continue;\n						\n						long cont = disfrom[i][dex1] + spath[i][j] + spath[j][lto[j][dex2]];\n						\n						if(cont >= besta){\n							besta = cont;\n							best[0] = lfrom[i][dex1]+1;\n							best[1] = i+1;\n							best[2] = j+1;\n							best[3] = lto[j][dex2]+1;\n						}\n						\n					}\n				\n			}\n		}\n		\n		//System.out.println(besta);\n		\n		for (int i = 0; i < best.length; i++) {\n			System.out.print(best[i]+"" "");\n		}\n		System.out.println();\n		\n		qwe.close();\n	}\n	\n	static void bfs(int start){\n		\n		boolean[] been = new boolean[graph.length];\n		been[start] = true;\n		ArrayDeque<Integer> dq = new ArrayDeque<Integer>();\n		dq.add(start);\n		dq.add(0);\n		while(!dq.isEmpty()){\n			\n			int at = dq.poll();\n			int dis = dq.poll();\n			spath[start][at] = dis;\n			\n			if(at != start){\n			\n				if(lto[start][0] == -1){\n					lto[start][0] = at;\n				}\n				else{\n					\n					lto[start][1] = lto[start][0];\n					lto[start][0] = at;\n				}				\n				if(disfrom[at][0] < dis){\n					\n					lfrom[at][1] = lfrom[at][0];\n					disfrom[at][1] = disfrom[at][0];\n					\n					lfrom[at][0] =start;\n					disfrom[at][0] = dis;\n				}\n				else if(disfrom[at][1] < dis){\n					lfrom[at][1] =start;\n					disfrom[at][1] = dis;\n				}\n				\n			}\n			\n			\n			\n			\n			\n			for(int to : graph[at]){\n				if(!been[to]){\n					been[to] = true;\n					dq.add(to);\n					dq.add(dis+1);\n				}\n			}\n			\n		}\n		\n		\n	}\n	\n\n}\n","graphs,shortest paths"
"import java.io.*;\nimport java.util.*;\npublic class EqualFlowsSlow {\n  private static InputReader in;\n  private static PrintWriter out;\n  public static int n,m,x,k;\n  public static int[] a,b,c;\n  public static double EPS = 1e-9;\n  public static long INF = 1l << 50;\n  \n  public static void main (String[] args) {\n    in = new InputReader(System.in);\n    out = new PrintWriter(System.out, true);\n    \n    n = in.nextInt();\n    m = in.nextInt();\n    x = in.nextInt();\n    a = new int[m];\n    b = new int[m];\n    c = new int[m];\n    for (int i = 0; i < m; i++) {\n      a[i] = in.nextInt()-1;\n      b[i] = in.nextInt()-1;\n      c[i] = in.nextInt();\n    }\n    \n    double lo = 0, hi = 1e12;\n    for (int iter = 0; iter < 100; iter++) {\n      double mid = (lo+hi) / 2.;\n      if (f(mid) >= x) lo = mid;\n      else hi = mid;\n    }\n\n    out.printf(""%.10f\n"", lo * x);\n    out.close();\n    System.exit(0);\n  }\n  \n  public static long f(double each) {\n    MaxFlow mf = new MaxFlow(n,m);\n    for (int i = 0; i < m; i++) {\n      int capacity = (int)(Math.floor(c[i] / each));\n      if (capacity > 0) {\n        mf.add_edge(a[i], b[i], capacity);\n      }\n    }\n    return mf.dinic(0, n-1);\n  }\n\n  static class MaxFlow {\n    public long[] flow, capa;\n    public int[] now, level, eadj, eprev, elast;\n    public int eidx, N, M;\n    \n    public MaxFlow(int nodes, int edges) {\n      this.N = nodes;\n      this.M = edges;\n      \n      flow = new long[2*M];\n      capa = new long[2*M];\n      eadj = new int[2*M];\n      eprev = new int[2*M];\n      elast = new int[N];\n      level = new int[N];\n      now = new int[N];\n      Arrays.fill(elast, -1);\n      eidx = 0;\n    }\n    \n    public void add_edge(int a, int b, long c) {\n      eadj[eidx] = b; flow[eidx] = 0; capa[eidx] = c; eprev[eidx] = elast[a]; elast[a] = eidx++;\n      eadj[eidx] = a; flow[eidx] = c; capa[eidx] = c; eprev[eidx] = elast[b]; elast[b] = eidx++;\n    }\n  \n    public long dinic(int source, int sink) {\n      long res, flow = 0;\n      while (bfs(source, sink)) {\n        System.arraycopy(elast, 0, now, 0, N);\n        while ((res = dfs(source, INF, sink)) > 0)\n          flow += res;\n      }\n      return flow;\n    }\n  \n    private boolean bfs(int source, int sink) {\n      Arrays.fill(level, -1);\n      int front = 0, back = 0;\n      int[] queue = new int[N];\n  \n      level[source] = 0;\n      queue[back++] = source;\n  \n      while (front < back && level[sink] == -1) {\n        int node = queue[front++];\n        for (int e = elast[node]; e != -1; e = eprev[e]) {\n          int to = eadj[e];\n          if (level[to] == -1 && flow[e] < capa[e]) {\n            level[to] = level[node] + 1;\n            queue[back++] = to;\n          }\n        }\n      }\n  \n      return level[sink] != -1;\n    }\n  \n    private long dfs(int cur, long curflow, int goal) {\n      if (cur == goal) return curflow;\n  \n      for (int e = now[cur]; e != -1; now[cur] = e = eprev[e]) {\n        if (level[eadj[e]] > level[cur] && flow[e] < capa[e]) {\n          long res = dfs(eadj[e], Math.min(curflow, capa[e] - flow[e]), goal);\n          if (res > 0) {\n            flow[e] += res;\n            flow[e ^ 1] -= res;\n            return res;\n          }\n        }\n      }\n      return 0;\n    }\n  }\n  \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream), 32768);\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n  }\n}","binary search,flows,graphs"
"import java.io.*;\nimport java.util.*;\n\npublic class A {\n\n\n	static final int INF = (int)1e9;\n	static int V, s, t;			//s != t\n	static ArrayList<Integer>[] adjList;\n	static int[][] res;			//instead of res, you can use c[][], f[][] so as not to destroy the graph\n	static int[] p;				//res (residual) = c (capacity) - f (flow)\n	\n	static int edmondsKarp()	//O(min(VE^2, flow * E)) for adjList, O(V^3E)\n	{\n		int mf = 0;\n		while(true)\n		{\n			Queue<Integer> q = new LinkedList<Integer>();\n			p = new int[V];\n			Arrays.fill(p, -1);\n			q.add(s);\n			p[s] = s;\n			while(!q.isEmpty())\n			{\n				int u = q.remove();\n				if(u == t)\n					break;\n				for(int v: adjList[u]) {\n					if(res[u][v] > 0 \n							&& p[v] == -1)\n					{\n						p[v] = u;\n						q.add(v);\n					}\n				}\n			}\n			\n			if(p[t] == -1)\n				break;\n			mf += augment(t, INF);	\n		}\n		return mf;\n	}\n	\n	static int augment(int v, int flow)\n	{\n		if(v == s)\n			return flow;\n		flow =  augment(p[v], Math.min(flow, res[p[v]][v]));\n		res[p[v]][v] -= flow;\n		res[v][p[v]] += flow;\n		\n		return flow;\n	}\n\n	public static void main(String args[]) throws Exception {\n		Scanner sc = new Scanner(System.in);\n		PrintWriter pw = new PrintWriter(System.out);\n\n		int w = 1;\n		while (w-- > 0) {\n			int n = sc.nextInt();\n			int m = sc.nextInt();\n			int x = sc.nextInt();\n			V = n;\n			s = 0;\n			t = n - 1;\n			adjList = new ArrayList[n];\n			for (int i = 0; i < n; i++) {\n				adjList[i] = new ArrayList<>();\n			}\n			int res2[][] = new int[n][n];\n			res = new int[n][n];\n			for (int i = 0; i < m; i++) {\n				int u = sc.nextInt() - 1;\n				int v = sc.nextInt() - 1;\n				int c = sc.nextInt();\n				res2[u][v] = c;\n				adjList[u].add(v);\n				adjList[v].add(u);\n			}\n			double lo = 0;\n			double hi = 1e6;\n			for (int i = 0; i < 100; i++) {\n				double mid = (hi + lo) / 2;\n				for (int j = 0; j < n; j++) {\n					for (int j2 = 0; j2 < n; j2++) {\n						res[j][j2] =(int)(res2[j][j2]/mid);\n					}\n				}\n\n				if (edmondsKarp() >= x)\n					lo = mid;\n				else\n					hi = mid;\n			}\n			pw.println(x * lo);\n		}\n		pw.flush();\n	}\n\n	///////////////////////////////////////////////////////////////////////////////////////////\n\n	static class tri {\n		int x, y, z;\n\n		public tri(int x, int y, int z) {\n			this.x = x;\n			this.y = y;\n			this.z = z;\n		}\n\n	}\n\n	static class pair implements Comparable<pair> {\n		int x, y;\n		boolean w, l;\n		PriorityQueue<Long> pq;\n\n		public pair(boolean a, boolean b) {\n			w = a;\n			l = b;\n		}\n\n		pair(int s, int d) {\n			x = s;\n			y = d;\n		}\n\n		@Override\n		public int compareTo(pair p) {\n			return Long.compare(x, p.x);\n		}\n\n		@Override\n		public String toString() {\n			return x + "" "" + y;\n\n		}\n\n	}\n\n	static long mod(long ans, int mod) {\n		return (ans % mod + mod) % mod;\n	}\n\n	static long gcd(long a, long b) {\n		if (a == 0)\n			return b;\n		return gcd(b % a, a);\n	}\n\n	static long lcm(long a, long b) {\n		return (a * b) / gcd(a, b);\n	}\n\n	public static int log(int n, int base) {\n		int ans = 0;\n		while (n + 1 > base) {\n			ans++;\n			n /= base;\n		}\n		return ans;\n	}\n\n	static long pow(long b, long e) {\n		long ans = 1;\n		while (e > 0) {\n			if ((e & 1) == 1)\n				ans = ((ans * 1l * b));\n			e >>= 1;\n			{\n\n			}\n			b = ((b * 1l * b));\n		}\n		return ans;\n	}\n\n	static long powmod(long r, long e, int mod) {\n		long ans = 1;\n		r %= mod;\n		while (e > 0) {\n			if ((e & 1) == 1)\n				ans = (int) ((ans * 1l * r) % mod);\n			e >>= 1;\n			r = (int) ((r * 1l * r) % mod);\n		}\n		return ans;\n	}\n\n	static int ceil(int a, int b) {\n		int ans = a / b;\n		return a % b == 0 ? ans : ans + 1;\n	}\n\n	static long ceil(long a, long b) {\n		long ans = a / b;\n		return a % b == 0 ? ans : ans + 1;\n	}\n\n	static HashMap<Integer, Integer> compress(int a[]) {\n		TreeSet<Integer> ts = new TreeSet<>();\n		HashMap<Integer, Integer> hm = new HashMap<>();\n		for (int x : a)\n			ts.add(x);\n		for (int x : ts) {\n			hm.put(x, hm.size() + 1);\n		}\n		return hm;\n	}\n\n	// Returns nCr % p\n	static int C[];\n\n	static int nCrModp(int n, int r, int p) {\n		if (r > n - r)\n			r = n - r;\n		if (C[r] != 0)\n			return C[r];\n		// The array C is going to store last\n		// row of pascal triangle at the end.\n		// And last entry of last row is nCr\n\n		C[0] = 1; // Top row of Pascal Triangle\n\n		// One by constructs remaining rows of Pascal\n		// Triangle from top to bottom\n		for (int i = 1; i <= n; i++) {\n\n			// Fill entries of current row using previous\n			// row values\n			for (int j = Math.min(i, r); j > 0; j--)\n\n				// nCj = (n-1)Cj + (n-1)C(j-1);\n				C[j] = (C[j] + C[j - 1]) % p;\n		}\n		return C[r];\n	}\n\n	static class Scanner {\n		StringTokenizer st;\n		BufferedReader br;\n\n		public Scanner(InputStream s) {\n			br = new BufferedReader(new InputStreamReader(s));\n		}\n\n		public Scanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n\n		public int[] intArr(int n) throws IOException {\n			int a[] = new int[n];\n			for (int i = 0; i < a.length; i++) {\n				a[i] = nextInt();\n			}\n			return a;\n		}\n\n		public long[] longArr(int n) throws IOException {\n			long a[] = new long[n];\n			for (int i = 0; i < a.length; i++) {\n				a[i] = nextLong();\n			}\n			return a;\n		}\n\n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		public double nextDouble() throws IOException {\n			String x = next();\n			StringBuilder sb = new StringBuilder(""0"");\n			double res = 0, f = 1;\n			boolean dec = false, neg = false;\n			int start = 0;\n			if (x.charAt(0) == '-') {\n				neg = true;\n				start++;\n			}\n			for (int i = start; i < x.length(); i++)\n				if (x.charAt(i) == '.') {\n					res = Long.parseLong(sb.toString());\n					sb = new StringBuilder(""0"");\n					dec = true;\n				} else {\n					sb.append(x.charAt(i));\n					if (dec)\n						f *= 10;\n				}\n			res += Long.parseLong(sb.toString()) / f;\n			return res * (neg ? -1 : 1);\n		}\n\n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n\n	}\n\n	public static void shuffle(int[] times2) {\n		int n = times2.length;\n		for (int i = 0; i < n; i++) {\n			int r = i + (int) (Math.random() * (n - i));\n			int tmp = times2[i];\n			times2[i] = times2[r];\n			times2[r] = tmp;\n		}\n	}\n\n}","binary search,flows,graphs"
"import java.io.*;\nimport java.util.*;\n\npublic class A {\n\n\n	static final int INF = (int)1e9;\n	static int V, s, t;			//s != t\n	static ArrayList<Integer>[] adjList;\n	static int[][] res;			//instead of res, you can use c[][], f[][] so as not to destroy the graph\n	static int[] p;				//res (residual) = c (capacity) - f (flow)\n	\n	static int edmondsKarp()	//O(min(VE^2, flow * E)) for adjList, O(V^3E)\n	{\n		int mf = 0;\n		while(true)\n		{\n			Queue<Integer> q = new LinkedList<Integer>();\n			p = new int[V];\n			Arrays.fill(p, -1);\n			q.add(s);\n			p[s] = s;\n			while(!q.isEmpty())\n			{\n				int u = q.remove();\n				if(u == t)\n					break;\n				for(int v: adjList[u]) {\n					if(res[u][v] > 0 \n							&& p[v] == -1)\n					{\n						p[v] = u;\n						q.add(v);\n					}\n				}\n			}\n			\n			if(p[t] == -1)\n				break;\n			mf += augment(t, INF);	\n		}\n		return mf;\n	}\n	\n	static int augment(int v, int flow)\n	{\n		if(v == s)\n			return flow;\n		flow =  augment(p[v], Math.min(flow, res[p[v]][v]));\n		res[p[v]][v] -= flow;\n		res[v][p[v]] += flow;\n		\n		return flow;\n	}\n\n	public static void main(String args[]) throws Exception {\n		Scanner sc = new Scanner(System.in);\n		PrintWriter pw = new PrintWriter(System.out);\n\n		int w = 1;\n		while (w-- > 0) {\n			int n = sc.nextInt();\n			int m = sc.nextInt();\n			int x = sc.nextInt();\n			V = n;\n			s = 0;\n			t = n - 1;\n			adjList = new ArrayList[n];\n			for (int i = 0; i < n; i++) {\n				adjList[i] = new ArrayList<>();\n			}\n			int res2[][] = new int[n][n];\n			res = new int[n][n];\n			for (int i = 0; i < m; i++) {\n				int u = sc.nextInt() - 1;\n				int v = sc.nextInt() - 1;\n				int c = sc.nextInt();\n				res2[u][v] = c;\n				adjList[u].add(v);\n				adjList[v].add(u);\n			}\n			double lo = 1e-6;\n			double hi = 1e6;\n			for (int i = 0; i < 100; i++) {\n				double mid = (hi + lo) / 2;\n				for (int j = 0; j < n; j++) {\n					for (int j2 = 0; j2 < n; j2++) {\n						res[j][j2] =(int)(res2[j][j2]/mid);\n					}\n				}\n\n				if (edmondsKarp() >= x)\n					lo = mid;\n				else\n					hi = mid;\n			}\n			pw.println(x * lo);\n		}\n		pw.flush();\n	}\n\n	///////////////////////////////////////////////////////////////////////////////////////////\n\n	static class tri {\n		int x, y, z;\n\n		public tri(int x, int y, int z) {\n			this.x = x;\n			this.y = y;\n			this.z = z;\n		}\n\n	}\n\n	static class pair implements Comparable<pair> {\n		int x, y;\n		boolean w, l;\n		PriorityQueue<Long> pq;\n\n		public pair(boolean a, boolean b) {\n			w = a;\n			l = b;\n		}\n\n		pair(int s, int d) {\n			x = s;\n			y = d;\n		}\n\n		@Override\n		public int compareTo(pair p) {\n			return Long.compare(x, p.x);\n		}\n\n		@Override\n		public String toString() {\n			return x + "" "" + y;\n\n		}\n\n	}\n\n	static long mod(long ans, int mod) {\n		return (ans % mod + mod) % mod;\n	}\n\n	static long gcd(long a, long b) {\n		if (a == 0)\n			return b;\n		return gcd(b % a, a);\n	}\n\n	static long lcm(long a, long b) {\n		return (a * b) / gcd(a, b);\n	}\n\n	public static int log(int n, int base) {\n		int ans = 0;\n		while (n + 1 > base) {\n			ans++;\n			n /= base;\n		}\n		return ans;\n	}\n\n	static long pow(long b, long e) {\n		long ans = 1;\n		while (e > 0) {\n			if ((e & 1) == 1)\n				ans = ((ans * 1l * b));\n			e >>= 1;\n			{\n\n			}\n			b = ((b * 1l * b));\n		}\n		return ans;\n	}\n\n	static long powmod(long r, long e, int mod) {\n		long ans = 1;\n		r %= mod;\n		while (e > 0) {\n			if ((e & 1) == 1)\n				ans = (int) ((ans * 1l * r) % mod);\n			e >>= 1;\n			r = (int) ((r * 1l * r) % mod);\n		}\n		return ans;\n	}\n\n	static int ceil(int a, int b) {\n		int ans = a / b;\n		return a % b == 0 ? ans : ans + 1;\n	}\n\n	static long ceil(long a, long b) {\n		long ans = a / b;\n		return a % b == 0 ? ans : ans + 1;\n	}\n\n	static HashMap<Integer, Integer> compress(int a[]) {\n		TreeSet<Integer> ts = new TreeSet<>();\n		HashMap<Integer, Integer> hm = new HashMap<>();\n		for (int x : a)\n			ts.add(x);\n		for (int x : ts) {\n			hm.put(x, hm.size() + 1);\n		}\n		return hm;\n	}\n\n	// Returns nCr % p\n	static int C[];\n\n	static int nCrModp(int n, int r, int p) {\n		if (r > n - r)\n			r = n - r;\n		if (C[r] != 0)\n			return C[r];\n		// The array C is going to store last\n		// row of pascal triangle at the end.\n		// And last entry of last row is nCr\n\n		C[0] = 1; // Top row of Pascal Triangle\n\n		// One by constructs remaining rows of Pascal\n		// Triangle from top to bottom\n		for (int i = 1; i <= n; i++) {\n\n			// Fill entries of current row using previous\n			// row values\n			for (int j = Math.min(i, r); j > 0; j--)\n\n				// nCj = (n-1)Cj + (n-1)C(j-1);\n				C[j] = (C[j] + C[j - 1]) % p;\n		}\n		return C[r];\n	}\n\n	static class Scanner {\n		StringTokenizer st;\n		BufferedReader br;\n\n		public Scanner(InputStream s) {\n			br = new BufferedReader(new InputStreamReader(s));\n		}\n\n		public Scanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n\n		public int[] intArr(int n) throws IOException {\n			int a[] = new int[n];\n			for (int i = 0; i < a.length; i++) {\n				a[i] = nextInt();\n			}\n			return a;\n		}\n\n		public long[] longArr(int n) throws IOException {\n			long a[] = new long[n];\n			for (int i = 0; i < a.length; i++) {\n				a[i] = nextLong();\n			}\n			return a;\n		}\n\n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		public double nextDouble() throws IOException {\n			String x = next();\n			StringBuilder sb = new StringBuilder(""0"");\n			double res = 0, f = 1;\n			boolean dec = false, neg = false;\n			int start = 0;\n			if (x.charAt(0) == '-') {\n				neg = true;\n				start++;\n			}\n			for (int i = start; i < x.length(); i++)\n				if (x.charAt(i) == '.') {\n					res = Long.parseLong(sb.toString());\n					sb = new StringBuilder(""0"");\n					dec = true;\n				} else {\n					sb.append(x.charAt(i));\n					if (dec)\n						f *= 10;\n				}\n			res += Long.parseLong(sb.toString()) / f;\n			return res * (neg ? -1 : 1);\n		}\n\n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n\n	}\n\n	public static void shuffle(int[] times2) {\n		int n = times2.length;\n		for (int i = 0; i < n; i++) {\n			int r = i + (int) (Math.random() * (n - i));\n			int tmp = times2[i];\n			times2[i] = times2[r];\n			times2[r] = tmp;\n		}\n	}\n\n}","binary search,flows,graphs"
"import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\npublic class Hello {\n\n  private static PrintWriter out;\n  public static int n,m,x,k;\n  public static int[] a,b,c;\n\n\n  public static long check(double div) \n  {\n    MaxFlow mf = new MaxFlow(n, m);\n    for (int i = 0; i < m; i++) {\n      int capacity = (int)(Math.floor(c[i] / div));\n      if (capacity > 0) {\n        mf.add_edge(a[i], b[i], capacity);\n      }\n    }\n    return mf.dinic(0, n-1);\n  }\n\n  public static void main(String[] args) {\n    //try {\n    //  FileInputStream fis = new FileInputStream(""data.txt"");\n    //  System.setIn(fis);\n      //Scanner in = new Scanner(System.in);\n      FastReader in = new FastReader(System.in);\n      out = new PrintWriter(System.out, true);\n      \n      \n      n = in.nextInt();\n      m = in.nextInt();\n      x = in.nextInt();\n      a = new int[m];\n      b = new int[m];\n      c = new int[m];\n      for (int i = 0; i < m; i++) {\n	a[i] = in.nextInt()-1;\n	b[i] = in.nextInt()-1;\n	c[i] = in.nextInt();\n      }\n      double l = 0;\n      double h = 1e15;\n      for (int r = 0;r < 100;++r) {\n	double mid = (l + h) / 2;\n	if (check(mid) >= x) l = mid;\n	else h = mid;\n      }\n      out.printf(""%.10f\n"", l * x);\n      out.close();\n      \n    //} catch (FileNotFoundException e){\n    //  System.out.println(""error"");\n    //}\n  }\n}\nclass MaxFlow {\n  public long[] flow, capa;\n  public int[] now, level, eadj, eprev, elast;\n  public int eidx, N, M;\n  public static long INF = 1l << 50;\n\n  public MaxFlow(int nodes, int edges) {\n    this.N = nodes;\n    this.M = edges;\n\n    flow = new long[2*M];\n    capa = new long[2*M];\n    eadj = new int[2*M];\n    eprev = new int[2*M];\n    elast = new int[N];\n    level = new int[N];\n    now = new int[N];\n    Arrays.fill(elast, -1);\n    eidx = 0;\n  }\n\n  public void add_edge(int a, int b, long c) {\n    eadj[eidx] = b; flow[eidx] = 0; capa[eidx] = c; eprev[eidx] = elast[a]; elast[a] = eidx++;\n    eadj[eidx] = a; flow[eidx] = c; capa[eidx] = c; eprev[eidx] = elast[b]; elast[b] = eidx++;\n  }\n\n  public long dinic(int source, int sink) {\n    long res, flow = 0;\n    while (bfs(source, sink)) {\n      System.arraycopy(elast, 0, now, 0, N);\n      while ((res = dfs(source, INF, sink)) > 0)\n	flow += res;\n    }\n    return flow;\n  }\n\n  private boolean bfs(int source, int sink) {\n    Arrays.fill(level, -1);\n    int front = 0, back = 0;\n    int[] queue = new int[N];\n\n    level[source] = 0;\n    queue[back++] = source;\n\n    while (front < back && level[sink] == -1) {\n      int node = queue[front++];\n      for (int e = elast[node]; e != -1; e = eprev[e]) {\n	int to = eadj[e];\n	if (level[to] == -1 && flow[e] < capa[e]) {\n	  level[to] = level[node] + 1;\n	  queue[back++] = to;\n	}\n      }\n    }\n\n    return level[sink] != -1;\n  }\n\n  private long dfs(int cur, long curflow, int goal) {\n    if (cur == goal) return curflow;\n\n    for (int e = now[cur]; e != -1; now[cur] = e = eprev[e]) {\n      if (level[eadj[e]] > level[cur] && flow[e] < capa[e]) {\n	long res = dfs(eadj[e], Math.min(curflow, capa[e] - flow[e]), goal);\n	if (res > 0) {\n	  flow[e] += res;\n	  flow[e ^ 1] -= res;\n	  return res;\n	}\n      }\n    }\n    return 0;\n  }\n}\n\nclass FastReader {\n    private boolean finished = false;\n \n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n \n    public FastReader(InputStream stream) {\n        this.stream = stream;\n    }\n \n    public int read() {\n        if (numChars == -1) {\n            throw new InputMismatchException();\n        }\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0) {\n                return -1;\n            }\n        }\n \n        return buf[curChar++];\n    }\n \n    public int peek() {\n        if (numChars == -1) {\n            return -1;\n        }\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                return -1;\n            }\n            if (numChars <= 0) {\n                return -1;\n            }\n        }\n        return buf[curChar];\n    }\n \n    public int nextInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c == ',') {\n                c = read();\n            }\n            if (c < '0' || c > '9') {\n                throw new InputMismatchException();\n            }\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n \n    public long nextLong() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9') {\n                throw new InputMismatchException();\n            }\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n \n    public String nextString() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n \n    public boolean isSpaceChar(int c) {\n        if (filter != null) {\n            return filter.isSpaceChar(c);\n        }\n        return isWhitespace(c);\n    }\n \n    public static boolean isWhitespace(int c) {\n        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n    }\n \n    private String readLine0() {\n        StringBuilder buf = new StringBuilder();\n        int c = read();\n        while (c != '\n' && c != -1) {\n            if (c != '\r') {\n                buf.appendCodePoint(c);\n            }\n            c = read();\n        }\n        return buf.toString();\n    }\n \n    public String nextLine() {\n        String s = readLine0();\n        while (s.trim().length() == 0)\n            s = readLine0();\n        return s;\n    }\n \n    public String nextLine(boolean ignoreEmptyLines) {\n        if (ignoreEmptyLines) {\n            return nextLine();\n        } else {\n            return readLine0();\n        }\n    }\n \n    public BigInteger nextBigInteger() {\n        try {\n            return new BigInteger(nextString());\n        } catch (NumberFormatException e) {\n            throw new InputMismatchException();\n        }\n    }\n \n    public char nextCharacter() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        return (char) c;\n    }\n \n    public double nextDouble() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        double res = 0;\n        while (!isSpaceChar(c) && c != '.') {\n            if (c == 'e' || c == 'E') {\n                return res * Math.pow(10, nextInt());\n            }\n            if (c < '0' || c > '9') {\n                throw new InputMismatchException();\n            }\n            res *= 10;\n            res += c - '0';\n            c = read();\n        }\n        if (c == '.') {\n            c = read();\n            double m = 1;\n            while (!isSpaceChar(c)) {\n                if (c == 'e' || c == 'E') {\n                    return res * Math.pow(10, nextInt());\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                m /= 10;\n                res += (c - '0') * m;\n                c = read();\n            }\n        }\n        return res * sgn;\n    }\n \n    public boolean isExhausted() {\n        int value;\n        while (isSpaceChar(value = peek()) && value != -1)\n            read();\n        return value == -1;\n    }\n \n    public String next() {\n        return nextString();\n    }\n \n    public SpaceCharFilter getFilter() {\n        return filter;\n    }\n \n    public void setFilter(SpaceCharFilter filter) {\n        this.filter = filter;\n    }\n \n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n}\n","binary search,flows,graphs"
"import java.util.Scanner;\nimport java.util.Stack;\n\npublic class ha {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        boolean p[] = new boolean[10001];\n        for (int i = 0; i < n; i++) {\n            int v = sc.nextInt();\n            p[v] = true;\n        }\n\n        for (int i = 0; i < 1001; i++) {\n\n            if (p[i] && p[i + 1] && p[i + 2]) {\n                System.out.println(""YES"");\n                return;\n            }\n        }\n        System.out.println(""NO"");\n    }\n}\n","brute force,implementation,sortings"
"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class _0568BearandThreeBalls {\n\n	public static void main(String[] args) {\n		\n		Scanner sc = new Scanner(System.in);\n		int n=sc.nextInt();\n		int[] arr = new int[n];\n		for(int i=0;i<n;i++) {\n			int temp=sc.nextInt();\n			arr[i]=temp;\n		}\n		Arrays.sort(arr);\n		int count=0;\n		for(int i=0;i<n-1;i++) {\n			if( arr[i+1]-arr[i]==1) {\n				count++;\n			}\n			else if(arr[i+1]==arr[i]) {\n				continue;\n			}\n			else {\n				count=0;\n			}\n			if(count==2) {\n				System.out.println(""YES"");\n				return;\n			}\n		}\n		System.out.println(""NO"");\n	}\n\n}\n","brute force,implementation,sortings"
"import java.util.Scanner;\nimport java.util.Arrays;\npublic class Bear653A\n{\n	public static void main(String args[])\n	{\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int a[] = new int[n];\n		for(int i=0;i<n;i++)\n		{\n			a[i] =  sc.nextInt();\n		}\n		int temp =0;\n		Arrays.sort(a);\n		for(int i=0;i<n;i++)\n		{\n			for(int j=i;j<n;j++)\n			{\n				if(a[i]+1==a[j])\n				{\n					for(int k=j;k<n;k++)\n					{\n						if(a[j]+1==a[k])\n						{\n							temp=1;\n							break;\n						}\n					}\n				}\n			}\n		}\n		if(temp==1)\n		System.out.println(""YES"");\n		else \n		System.out.println(""NO"");\n	}\n}\n","brute force,implementation,sortings"
"import java.util.*;\npublic class bear_and_friendship_condition \n{\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int n=in.nextInt();\n		ArrayList<Integer> list = new ArrayList<Integer>();\n		Set<Integer> set = new HashSet<>();\n		for(int i=0;i<n;i++)\n		{\n			int a=in.nextInt();\n			list.add(a);\n			set.add(a);\n		}\n		list.clear();\n		for(int i:set)\n		{\n			list.add(i);\n		}\n		Collections.sort(list);\n		for(int i=0;i<list.size()-2;i++)\n		{\n			if(list.get(i+1)-list.get(i)==1 && list.get(i+2)-list.get(i)==2)\n			{\n				System.out.println(""YES"");\n				System.exit(0);\n			}\n		}\n		System.out.println(""NO"");\n	}\n}","brute force,implementation,sortings"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF668C extends PrintWriter {\n	CF668C() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF668C o = new CF668C(); o.main(); o.flush();\n	}\n\n	static final double eps = 1e-9;\n	void main() {\n		int n = sc.nextInt();\n		double[] max = new double[n];\n		for (int i = 0; i < n; i++)\n			max[i] = sc.nextDouble();\n		double[] min = new double[n];\n		for (int i = 0; i < n; i++)\n			min[i] = sc.nextDouble();\n		double[] xx = new double[n];\n		double[] yy = new double[n];\n		double px = 0, py = 0;\n		for (int i = 0; i < n; i++) {\n			double b = py - px - max[i] - min[i];\n			double c = max[i] * (1 - py) - min[i] * py;\n			double d = b * b - 4 * c;\n			if (0 - eps <= d && d < 0)\n				d = 0;\n			d = Math.sqrt(d);\n			double y = (-b + d) / 2;\n			double x = max[i] + min[i] - y;\n			if (!(0 - eps <= x && x <= 1 + eps && 0 - eps <= y && y <= 1 + eps)) {\n				y = (-b - d) / 2;\n				x = max[i] + min[i] - y;\n			}\n			px += xx[i] = x;\n			py += yy[i] = y;\n		}\n		for (int i = 0; i < n; i++)\n			print(xx[i] + "" "");\n		println();\n		for (int i = 0; i < n; i++)\n			print(yy[i] + "" "");\n		println();\n	}\n}\n","dp,implementation,math,probabilities"
"import java.io.*;\nimport java.util.*;\n\npublic class D {\n\n	BufferedReader br;\n	PrintWriter out;\n	StringTokenizer st;\n	boolean eof;\n\n	void solve() throws IOException {\n		int n = nextInt();\n		double[] min = new double[n];\n		double[] max = new double[n];\n		for (int i = 0; i < n; i++) {\n			min[i] = nextDouble();\n		}\n		for (int i = 0; i < n; i++) {\n			max[i] = nextDouble();\n		}\n		\n		for (int i = 1; i < n; i++) {\n			min[i] += min[i - 1];\n		}\n		\n		for (int i = n - 2; i >= 0; i--) {\n			max[i] += max[i + 1];\n		}\n		\n		double[] xs = new double[n];\n		double[] ys = new double[n];\n		\n		for (int i = 0; i < n - 1; i++) {\n			\n			double a = min[i];\n			double b = max[i + 1];\n			\n			double base = a - b + 1;\n			double diff = Math.sqrt(Math.max(base * base - 4 * a, 0));\n			xs[i] = 0.5 * (base - diff);\n			ys[i] = 0.5 * (base + diff);\n		}\n		\n		xs[n - 1] = ys[n - 1] = 1;\n		\n		for (int i = 0; i < n; i++) {\n			out.print(xs[i] - (i == 0 ? 0 : xs[i - 1]) + "" "");\n		}\n		out.println();\n		\n		for (int i = 0; i < n; i++) {\n			out.print(ys[i] - (i == 0 ? 0 : ys[i - 1]) + "" "");\n		}\n		\n	}\n\n	D() throws IOException {\n		br = new BufferedReader(new InputStreamReader(System.in));\n		out = new PrintWriter(System.out);\n		solve();\n		out.close();\n	}\n\n	public static void main(String[] args) throws IOException {\n		new D();\n	}\n\n	String nextToken() {\n		while (st == null || !st.hasMoreTokens()) {\n			try {\n				st = new StringTokenizer(br.readLine());\n			} catch (Exception e) {\n				eof = true;\n				return null;\n			}\n		}\n		return st.nextToken();\n	}\n\n	String nextString() {\n		try {\n			return br.readLine();\n		} catch (IOException e) {\n			eof = true;\n			return null;\n		}\n	}\n\n	int nextInt() throws IOException {\n		return Integer.parseInt(nextToken());\n	}\n\n	long nextLong() throws IOException {\n		return Long.parseLong(nextToken());\n	}\n\n	double nextDouble() throws IOException {\n		return Double.parseDouble(nextToken());\n	}\n}","dp,implementation,math,probabilities"
"import java.io.*;\nimport java.util.*;\n\npublic class littleartemrv {\n  private static InputReader in;\n  private static PrintWriter out;\n\n  public static void main(String[] args) throws IOException {\n    in = new InputReader(System.in);\n    out = new PrintWriter(System.out, true);\n\n    int n = in.nextInt();\n    double[] max = new double[n+1];\n    for (int i = 1; i <= n; i++) max[i] = in.nextDouble() + max[i-1];\n    double[] min = new double[n+1];\n    for (int i = 1; i <= n; i++) min[i] = in.nextDouble();\n    for (int i = n-1; i >= 1; i--) min[i] += min[i+1];\n\n    double[] sum = new double[n+1];\n    for (int i = 1; i < n; i++) {\n      sum[i] = 1 + max[i] - min[i+1];\n    }\n    sum[n] = 2;\n    double[] pref1 = new double[n+1];\n    for (int i = 1; i <= n; i++) {\n      pref1[i] = (sum[i] + Math.sqrt(Math.max(0,sum[i]*sum[i] - 4*max[i]))) / 2.;\n    }\n    double[] b1 = new double[n+1];\n    double[] b2 = new double[n+1];\n    for (int i = 1; i <= n; i++) {\n      double need = sum[i] - sum[i-1];\n      double first = pref1[i] - pref1[i-1];\n      b1[i] = first;\n      b2[i] = need-first;\n    }\n    for (int i = 1; i <= n; i++) {\n      if (i != 1) out.print("" "");\n      out.printf(""%.10f"", b1[i]);\n    }\n    out.println();\n    for (int i = 1; i <= n; i++) {\n      if (i != 1) out.print("" "");\n      out.printf(""%.10f"", b2[i]);\n    }\n    out.println();\n    \n    out.close();\n    System.exit(0);\n  }\n\n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream), 32768);\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n  }\n\n\n}\n","dp,implementation,math,probabilities"
"import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Igor Kraskevich\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		FastScanner in = new FastScanner(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		TaskD solver = new TaskD();\n		solver.solve(1, in, out);\n		out.close();\n	}\n}\n\nclass TaskD {\n\n    double solve(double A, double B, double C) {\n        double D = Math.max(0.0, B * B - 4 * A * C);\n        return  (-B + Math.sqrt(D)) / (2 * A);\n    }\n\n    public void solve(int testNumber, FastScanner in, PrintWriter out) {\n        int n = in.nextInt();\n        double[] min = new double[n];\n        double[] max = new double[n];\n        for (int i = 0; i < n; i++)\n            max[i] = in.nextDouble();\n        for (int i = 0; i < n; i++)\n            min[i] = in.nextDouble();\n        double s1 = 0;\n        double s2 = 0;\n        double[] ans1 = new double[n];\n        double[] ans2 = new double[n];\n        for (int i = 0; i < n; i++) {\n            double x1 = solve(1, -(s2 - s1 + min[i] + max[i]), -s1 * (min[i] + max[i]) + max[i]);\n            double x2 = min[i] + max[i] - x1;\n            s1 += x1;\n            s2 += x2;\n            ans1[i] = x1;\n            ans2[i] = x2;\n        }\n        for (int i = 0; i < ans1.length; i++)\n            out.printf(""%.10f "", Math.max(0.0, ans1[i]));\n        out.println();\n        for (int i = 0; i < ans2.length; i++)\n            out.printf(""%.10f "", Math.max(0.0, ans2[i]));\n        out.println();\n    }\n}\n\nclass FastScanner {\n    private StringTokenizer tokenizer;\n    private BufferedReader reader;\n\n    public FastScanner(InputStream inputStream) {\n        reader = new BufferedReader(new InputStreamReader(inputStream));\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            String line = null;\n            try {\n                line = reader.readLine();\n            } catch (IOException e) {\n                }\n            if (line == null)\n                return null;\n            tokenizer = new StringTokenizer(line);\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n}\n\n","dp,implementation,math,probabilities"
"import java.util.Scanner;\npublic class p632C {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        String s[]=new String[n];\n        for(int i=0;i<n;i++)  s[i]=sc.next();\n        java.util.Arrays.sort(s,(a,b)->(a+b).compareTo(b+a));\n        StringBuilder sb=new StringBuilder();\n        for(String x:s) sb.append(x);\n        System.out.println(sb);\n    }\n}","sortings,strings"
"import java.util.*;\n\npublic class Main {\n	\n	static class comp implements Comparator<String>{\n		@Override\n		public int compare(String a, String b) {\n			return (a+b).compareTo(b+a);\n		}\n	}\n\n	\n	static Scanner scn = new Scanner(System.in);\n\n	public static void main(String[] args){\n		int n = scn.nextInt();\n		int i,j;\n		String[] a = new String[n];\n		for(i=0;i<n;i++)a[i] = scn.next();\n		Arrays.sort(a, new comp());\n		for(i=0;i<n;i++) {\n			System.out.print(a[i]);\n		}\n		System.out.println();\n	}\n\n}\n","sortings,strings"
"import java.io.*;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\n//The Smallest String Concatenation\npublic class CF632C {\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));\n		int n = Integer.parseInt(br.readLine());\n		String[] in = new String[n];\n		for(int i = 0;i < n;i++) in[i] = br.readLine();\n		Arrays.sort(in, (o1, o2) -> (o1 + o2).compareTo(o2 + o1));\n		for(int i = 0;i < n;i++) pw.print(in[i]);\n		pw.println();\n		pw.close();\n	}\n}\n","sortings,strings"
"\nimport java.util.*;\n\npublic class SmallestStringConcatenation {\n\n	public static void main(String[] args) {\n		Scanner in = new Scanner (System.in);\n		int N = in.nextInt();\n		String [] strings = new String [N];\n		\n		for (int i = 0; i < N; i++) {\n			strings [i] = in.next();\n		}\n		in.close();\n		\n		Arrays.sort(strings, new Comp ());\n		\n		for (int i = 0; i < N; i++) {\n			System.out.print(strings [i]);\n		}\n	}\n	\n	static class Comp implements Comparator <String> {\n\n		@Override\n		public int compare(String o1, String o2) {\n			String s1 = o1 + o2;\n			String s2 = o2 + o1;\n			return s1.compareTo(s2);\n		}\n		\n	}\n	\n\n}\n","sortings,strings"
"import java.util.*;\n\npublic class d628 {\n    static Long[][][][] dp;\n    static String a;\n    static String b;\n    static int m;\n    static int d;\n    static final int mod = (int) 1e9+7;\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        m = sc.nextInt();\n        d = sc.nextInt();\n        a = sc.next();\n        b = sc.next();\n\n        dp = new Long[2000][2][2][2000];\n        System.out.println(solve(0, 1,1, 0));\n    }\n\n    private static long solve(int pos, int stricta, int strictb, int modulo) {\n\n        if (pos == a.length()) {\n            return (modulo == 0) ? 1 : 0;\n        }\n\n        if (dp[pos][stricta][strictb][modulo] != null) return dp[pos][stricta][strictb][modulo];\n\n        long ans = 0L;\n\n        int start = (stricta == 1) ? a.charAt(pos)-'0' : 0;\n        int end = (strictb == 1) ? b.charAt(pos)-'0' : 9;\n\n        for (int i = start; i <= end; i++) {\n            if ((pos%2 == 0 && i == d) || (pos%2 == 1 && i != d)) continue;\n            int newstricta = (stricta == 1 && i == start) ? 1 : 0;\n            int newstrictb = (strictb == 1 && i == end) ? 1 : 0;\n            int newmodulo = (modulo*10 + i) % m;\n            ans = (ans + solve(pos+1, newstricta, newstrictb, newmodulo)) % mod;\n        }\n\n        return dp[pos][stricta][strictb][modulo] = ans;\n    }\n}\n",dp
"import java.io.*;\nimport java.util.*;\n \npublic class Main {\n	static class FastReader{ \n        BufferedReader br; \n        StringTokenizer st; \n        public FastReader(){br = new BufferedReader(new InputStreamReader(System.in));}\n        String next(){while (st == null || !st.hasMoreElements()){try{st = new StringTokenizer(br.readLine());} \n        catch (IOException  e){e.printStackTrace();}}return st.nextToken();}\n        int nextInt(){ return Integer.parseInt(next());}long nextLong(){return Long.parseLong(next());}double nextDouble(){return Double.parseDouble(next());}\n        String nextLine(){String str = """"; try{str = br.readLine(); } catch (IOException e) {e.printStackTrace();} return str; } \n    }\n	static FastReader sc = new FastReader();\n	static int mod = (int)(1e9+7);\n	static int m,d;\n	static String a,b;\n	public static void main (String[] args) throws Exception {\n        PrintWriter out = new PrintWriter(System.out);\n        int t = 1;\n//        t = sc.nextInt();\n        z : while(t-->0) {\n			m = sc.nextInt();\n			d = sc.nextInt();\n			a = sc.next();\n			b = sc.next();\n			long dp[][][][] = new long[2][2][m][a.length()];\n			for(int i=0;i<2;i++) {\n				for(int j=0;j<2;j++) {\n					for(int k=0;k<m;k++)\n						Arrays.fill(dp[i][j][k], -1);\n				}\n			}\n			long ans = find(0,0,1,1,dp);\n			out.write(ans+"""");\n        }\n		out.close();\n	}\n	private static long find(int idx, int rem, int ia, int ib, long[][][][] dp) {\n		if(idx == a.length()) {\n			if(rem == 0) return 1;\n			return 0;\n		}\n		\n		if(dp[ia][ib][rem][idx]!=-1) return dp[ia][ib][rem][idx];\n		\n		int s = -1, e = -1;\n		s = (ia == 1)?a.charAt(idx)-'0':0;\n		e = (ib == 1)?b.charAt(idx)-'0':9;\n		long ans = 0;\n		for(int i=s;i<=e;i++) {\n			if(idx%2 == 0 && i == d) continue;\n			if(idx%2 == 1 && i != d) continue;\n			ans = (ans%mod + find(idx+1,(rem*10+i)%m,(ia & (i==s?1:0)),(ib & (i == e?1:0)),dp)%mod)%mod;\n		}\n		return dp[ia][ib][rem][idx] = ans;\n	}\n}",dp
"/*\n    created by: nitin23329\n    on Date: 09/06/21\n*/\n\nimport java.io.*;\nimport java.util.*;\n/*****************************************WRITING CODE STARTS HERE******************************************/\n\npublic class Main {\n    static int[][][] dp;\n    static int mod = (int )1e9+7;\n\n    public static void main(String[] args) {\n        solve();\n    }\n\n    private static void solve() {\n        Scanner sc = new Scanner();\n        int m = sc.nextInt();\n        int d = sc.nextInt();\n        char[] l = sc.next().toCharArray();\n        char[] r = sc.next().toCharArray();\n        dp = new int[r.length][m][2];\n        init();\n        int f_r= memo(0,0,1,m,d,r);\n        init();\n        int f_l = memo(0,0,1,m,d,l);\n        long ans = ((long) f_r - f_l + mod) % mod; //handle the case of -ve mod also\n        // handle case when l is a possible answer but got subtracted\n        long currRem = 0;\n        boolean isPossible = true;\n        for(int i=0;i<l.length;i++){\n            int digit =l[i]-'0';\n            if(i%2==0 && (digit==d))isPossible = false;\n            if(i%2==1 && (digit!=d)) isPossible = false;\n            currRem = (currRem*10 + (digit)) % m;\n        }\n        isPossible =  isPossible && currRem == 0;\n        if(isPossible)ans = (ans + 1)%mod;\n        System.out.println(ans);\n\n\n    }\n    private static void init(){\n        for(int i=0;i<dp.length;i++)\n            for(int j=0;j<dp[0].length;j++)\n                Arrays.fill(dp[i][j],-1);\n    }\n    private static int memo(int i,int currRemainder,int isBound,int m,int d,char[] digitArray){\n        if(i==digitArray.length)return currRemainder == 0?1:0;\n        if(dp[i][currRemainder][isBound]!=-1)return dp[i][currRemainder][isBound];\n        long ans = 0;\n        int maxDigit = isBound == 1?( digitArray[i] - '0') : 9;\n        for(int digit = 0;digit <= maxDigit;digit++){\n            if(i==0 && digit == 0)continue; // you can not pick a number having digits < digits in l or r\n            if((i%2==1 && digit == d ) || (i%2==0 && digit != d)){\n                ans += memo(i+1,(currRemainder*10 + digit) % m,(isBound==1 && digit==maxDigit)?1:0,m,d,digitArray);\n                ans %= mod;\n            }\n        }\n        return dp[i][currRemainder][isBound] = (int)ans;\n    }\n    private static class Scanner {\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        private StringTokenizer st = new StringTokenizer("""");\n\n        public String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n\n\n}\n",dp
"import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\n\npublic class JaiShreeRam{\n	static Scanner in=new Scanner();\n	static long mod = 1000000007;\n	static ArrayList<ArrayList<Integer>> adj;\n	static int m,d;\n	static long dp[][][];\n	public static void main(String[] args) throws Exception{\n		//int z=in.readInt();\n		//while(z-->0) {\n			m=in.readInt();\n			d=in.readInt();\n			String b=in.readString();\n			String a=in.readString();\n			char c=b.charAt(b.length()-1);\n			c-=1;\n			b=b.substring(0,b.length()-1)+c;\n			ArrayList<Integer> al=stoal(a);\n			ArrayList<Integer> ab=stoal(b);\n			dp=new long[al.size()][2][m];\n			for(int i=0;i<al.size();i++) {\n				for(int j=0;j<2;j++) {\n					Arrays.fill(dp[i][j], -1);\n				}\n			}\n			long ans=fun(0,0,0,al);\n			dp=new long[al.size()][2][m];\n			for(int i=0;i<al.size();i++) {\n				for(int j=0;j<2;j++) {\n					Arrays.fill(dp[i][j], -1);\n				}\n			}\n			long ans2=fun(0,0,0,ab);\n			ans=(mod+ans-ans2)%mod;\n			System.out.println(ans);\n		//}\n	}\n	static long fun(int ind,int flag,int rem,ArrayList<Integer> al) {\n		if(ind==al.size()) {\n			if(rem==0)\n				return 1;\n			return 0;\n		}\n		if(dp[ind][flag][rem]!=-1)\n			return dp[ind][flag][rem];\n		int limit=al.get(ind);\n		if(flag==1) {\n			limit=9;\n		}\n		long cnt=0;\n		if(ind%2==1) {\n			if(flag==1||d<limit) {\n				cnt+=fun(ind+1,1,(10*rem+d)%m,al);\n			}\n			else if(d==limit) {\n				cnt+=fun(ind+1,0,(10*rem+d)%m,al);\n			}\n			else\n				return 0;\n		}\n		else {\n			for(int i=0;i<=limit;i++) {\n				if(i==d)\n					continue;\n				if(flag==1) {\n					cnt+=fun(ind+1,1,(10*rem+i)%m,al);\n				}\n				else {\n					if(i==limit) {\n						cnt+=fun(ind+1,0,(10*rem+i)%m,al);\n					}\n					else {\n						cnt+=fun(ind+1,1,(10*rem+i)%m,al);\n					}\n				}\n			}\n		}\n		return dp[ind][flag][rem]=cnt%mod;\n	}\n	static ArrayList<Integer> stoal(String s){\n		ArrayList<Integer> al=new ArrayList<>();\n		for(int i=0;i<s.length();i++) {\n			al.add(s.charAt(i)-'0');\n		}\n		return al;\n	}\n	static int[] nextIntArray(int n){\n		int[] arr= new int[n];\n		int i=0;\n		while(i<n){\n			arr[i++]=in.readInt();\n		}\n		return arr;\n	}\n	static int[] nextIntArray1(int n){\n		int[] arr= new int[n+1];\n		int i=1;\n		while(i<=n){\n			arr[i++]=in.readInt();\n		}\n		return arr;\n	}\n	static long gcd(long a, long b) {\n		if (b==0) return a;\n		return gcd(b, a%b);\n	}\n	static class Scanner{\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n		String readString() {\n			while (!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n		double readDouble() {\n			return Double.parseDouble(readString());\n		}\n		int readInt() {\n			return Integer.parseInt(readString());\n		}\n		long readLong() {\n			return Long.parseLong(readString());\n		}\n	}	\n}",dp
"import java.util.Scanner;\n\npublic class R625D {\n\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		String s = in.next();\n		if (s.equals(""1""))\n		{\n			System.out.print(""0"");\n			return;\n		}\n		int[] n = new int[s.length()];\n		int[] ans = new int[s.length()];\n		for (int i=0; i<s.length(); i++)\n			n[s.length()-i-1]=s.charAt(i)-'0';\n		int upL, upR, upL_;\n		\n		for (int m=n.length-1; m<=n.length; m++)\n		{\n			upR=0;\n			if (m==n.length-1)\n			{\n				if (n[n.length-1]!=1) continue;\n				upL=1;\n			}\n			else\n			{\n				upL=0;\n			}\n			int i;\n			for (i=0; i<(m/2+m%2); i++)\n			{\n				upL_=0;\n				int mod=n[i]-upR;\n				if (mod==-1) {mod=9; upL_=1;}\n				if (i==m-i-1 && (upL*10+mod)%2==1) break;\n				if (mod==n[m-i-1])\n				{\n					if (mod==9 && upL==1) break;\n					ans[i]=(upL*10+mod)/2;\n					ans[m-i-1]=upL*10+mod-ans[i];\n					upR=upL|upL_;\n					upL=0;\n				}\n				else if (mod==(upL*10+n[m-i-1]-1)%10)\n				{\n					ans[i]=(upL*10+n[m-i-1]-1)/2;\n					ans[m-i-1]=upL*10+n[m-i-1]-1-ans[i];\n					if (i==0 && ans[m-i-1]==0) break;\n					upR=(upL*10+n[m-i-1]-1+upR)/10;\n					upL=1;\n				}\n				else break;\n			}\n			if (i==m/2+m%2)\n			{\n				if ((m%2)==0 && (upL!=upR)) break;\n				for (i=m-1; i>=0; i--)\n					System.out.print(ans[i]);\n				return;\n			}\n		}\n		System.out.println(""0"");\n\n	}\n\n}\n","constructive algorithms,implementation,math"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF625D extends PrintWriter {\n	CF625D() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF625D o = new CF625D(); o.main(); o.flush();\n	}\n\n	boolean solve(byte[] cc, byte[] aa, int n) {\n		for (int i = 0, j = n - 1; i < j; i++, j--) {\n			if (cc[i] == cc[j] + 1 || cc[i] == cc[j] + 11) {\n				cc[i]--;\n				cc[i + 1] += 10;\n			}\n			if (cc[i] == cc[j] + 10) {\n				int h = j - 1;\n				while (h > i && cc[h] == 0) {\n					cc[h] = 9;\n					h--;\n				}\n				if (h == i)\n					return false;\n				cc[h]--;\n				cc[j] += 10;\n			}\n			if (cc[i] != cc[j] || cc[i] > 18)\n				return false;\n			aa[i] = (byte) Math.min(cc[i], 9);\n			aa[j] = (byte) (cc[i] - aa[i]);\n		}\n		if (n % 2 == 1) {\n			if (cc[n / 2] % 2 != 0 || cc[n / 2] > 18)\n				return false;\n			aa[n / 2] = (byte) (cc[n / 2] / 2);\n		}\n		return aa[0] != 0;\n	}\n	void main() {\n		byte[] cc = sc.next().getBytes();\n		int n = cc.length;\n		for (int i = 0; i < n; i++)\n			cc[i] -= '0';\n		byte[] cc_ = null;\n		if (n > 1) {\n			cc_ = new byte[n - 1];\n			for (int i = 1; i < n; i++)\n				cc_[i - 1] = cc[i];\n			cc_[0] += cc[0] * 10;\n		}\n		byte[] aa = new byte[n];\n		if (solve(cc, aa, n)) {\n			for (int i = 0; i < n; i++)\n				aa[i] += '0';\n			println(new String(aa));\n			return;\n		}\n		if (n > 1 && solve(cc_, aa, n - 1)) {\n			for (int i = 0; i < n - 1; i++)\n				aa[i] += '0';\n			println(new String(aa, 0, n - 1));\n			return;\n		}\n		println(0);\n	}\n}\n","constructive algorithms,implementation,math"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class CF_342D {\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		String number = br.readLine();\n		System.out.println(getChild(number));\n	}\n	public static int[] getDigits(String string) {\n		int[] digits = new int[string.length()];\n		for(int i=0;i<string.length();i++) {\n			digits[string.length()-1-i] = string.charAt(i)-'0';\n		}\n		return digits;\n	}\n	public static String getChild(String string) {\n		if(string.length() == 1) {\n			int num = string.charAt(0)-'0';\n			if(num % 2 == 0) {\n				return String.valueOf(num/2);\n			}\n			return ""0"";\n		}\n		int[] digits = getDigits(string);\n		String str1 = getChild(digits);\n		if(str1 == null && digits[digits.length-1] == 1) {\n			digits[digits.length-1] = 0;\n			digits[digits.length-2] += 10;\n			str1 = getChild(digits);\n		}\n		return str1 == null ? ""0"" : str1;\n	}\n	public static String getChild(int[] digits) {\n		digits = digits.clone();\n		int size = digits.length;\n		if(digits[size-1] == 0)\n			size--;\n		for(int i=size-1;i>=(size+1)/2;i--) {\n			int i2 = (size-1)-i;\n			int delta = digits[i] - digits[i2];\n			if(delta == 11 || delta == 1) {\n				digits[i]--;\n				digits[i-1]+=10;\n			}\n			delta = digits[i] - digits[i2];\n			if(delta == 10) {\n				digits[i2+1]--;\n				digits[i2] += 10;\n			}\n			delta = digits[i] - digits[i2];\n			if(i == size-1 && digits[i] == 0) {\n				size--;\n			}\n		}\n		for(int i=size-1;i>=(size+1)/2;i--) {\n			int i2 = (size-1)-i;\n			int delta = digits[i] - digits[i2];\n			if(delta != 0 || digits[i] < 0 || digits[i] > 18)\n				return null;\n		}\n		if(size % 2 == 1 && digits[size/2] % 2 != 0) {\n			return null;\n		}\n		StringBuilder ans = new StringBuilder();\n		for(int i=0;i<size/2;i++) {\n			ans.append(digits[i]/2);\n			digits[i] /= 2;\n		}\n		for(int i=size/2;i<size;i++) {\n			ans.append((digits[i]+1)/2);\n		}\n		if(ans.charAt(0) == '0') {\n			ans = ans.reverse();\n		}\n		if(ans.charAt(0) == '0') {\n			return null;\n		}\n		return ans.toString();\n	}\n}\n","constructive algorithms,implementation,math"
"import java.io.*;\nimport java.util.*;\n\npublic class D {\n	FastScanner in;\n	PrintWriter out;\n\n	char[] a;\n	char[] c;\n	int n;\n\n	HashMap<Long, Boolean> mem = new HashMap<>();\n\n	long code(int l, int r, int to, int from) {\n		return ((l * 1L * n + r) * 2 + to) * 2 + from;\n	}\n\n	boolean ans(long id, boolean x) {\n		mem.put(id, x);\n		return x;\n	}\n	\n	boolean can(int l, int r, int to, int from) {\n		long id = code(l, r, to, from);\n		if (mem.containsKey(id)) {\n			return mem.get(id);\n		}\n		if (r < l) {\n			return ans(id, to == from);\n		}\n		if (l == r) {\n			for (int x = 0; x < 10; x++) {\n				int d = x + x + from;\n				c[r] = (char) (x + '0');\n				if (d % 10 == a[l] - '0' && d / 10 == to) {\n					return ans(id, true);\n				}\n			}\n			return ans(id, false);\n		}\n		for (int y = 9; y >= 0; y--) {\n			for (int x = 0; x < 10; x++) {\n				c[r] = (char) (x + '0');\n				c[l] = (char) (y + '0');\n				int d = x + y + from;\n				if (d % 10 == a[r] - '0') {\n					int from2 = d / 10;\n					for (int to2 = 0; to2 < 2; to2++) {\n						int t = x + y + to2;\n						if (t % 10 == a[l] - '0' && t / 10 == to) {\n							if (can(l + 1, r - 1, to2, from2)) {\n								return ans(id, true);\n							}\n						}\n					}\n				}\n			}\n		}\n		return ans(id, false);\n	}\n\n	void solve() {\n		a = in.next().toCharArray();\n		n = a.length;\n		c = new char[n];\n		StringBuffer ans = new StringBuffer();\n		if (can(0, n - 1, 0, 0) && c[0] != '0') {\n			for (int i = 0; i < n; i++) {\n				ans.append(c[i]);\n			}\n		} else if (a[0] == '1' && can(1, n - 1, 1, 0) && c[1] != '0') {\n			for (int i = 1; i < n; i++) {\n				ans.append(c[i]);\n			}\n		}\n		if (ans.length() == 0) {\n			ans.append(0);\n		}\n		out.println(ans.toString());\n	}\n\n	void run() {\n		in = new FastScanner();\n		out = new PrintWriter(System.out);\n\n		solve();\n\n		out.close();\n	}\n\n	class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		public FastScanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		String next() {\n			while (st == null || !st.hasMoreTokens()) {\n				try {\n					st = new StringTokenizer(in.br.readLine());\n				} catch (IOException e) {\n					// TODO Auto-generated catch block\n					e.printStackTrace();\n				}\n			}\n			return st.nextToken();\n		}\n\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n	}\n\n	public static void main(String[] args) {\n		new D().run();\n	}\n}","constructive algorithms,implementation,math"
"import java.util.*;\n\npublic class Solution {\n\n  private static Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    double d = sc.nextInt(), L = sc.nextInt(), v1 = sc.nextInt(), v2 = sc.nextInt();\n    System.out.println((L - d) / (v1 + v2));\n  }\n}",math
import java.util.*;\npublic class MyClass {\n    public static void main(String args[]) {\n     Scanner s=new Scanner(System.in);\n     int d=s.nextInt();\n     int l=s.nextInt();\n     int v1=s.nextInt();\n     int v2=s.nextInt();\n     double x=(l-d)/((v1+v2)*1.000);\n     System.out.println(x);\n    }\n},math
import java.util.*;\nimport static java.lang.Math.*;\npublic class Demo{\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int d = in.nextInt();\n		int L = in.nextInt();\n		int v1 = in.nextInt();\n		int v2 = in.nextInt();\n		\n		System.out.println((double)(L-d)/(v1+v2));\n	}\n}		\n,math
import java.util.Scanner;\npublic class Main {\n	public static void main(String[] args) {\n		double[] array = new double[4];\n		Scanner input = new Scanner(System.in);\n		for (int i = 0;i<4;i++) {\n			array[i] = input.nextDouble();\n		}\n		System.out.print((array[1]-array[0])/(array[2]+array[3]));\n		input.close();\n	}\n}\n\n	 			 	 	  					  	  			 	    	,math
"import java.util.Scanner;\nimport java.util.*; \n\npublic class Main {\n  //wk6 #K\n  public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    String x= in.next();\n    int a = in.nextInt();\n\n    int hrs = Integer.parseInt(x.split("":"")[0]);\n    int mins = Integer.parseInt(x.split("":"")[1]);\n\n    hrs = ((mins+a)/60)+hrs;\n    hrs = hrs%24;\n\n    mins = (mins+a)%60;\n\n    System.out.printf(""%02d:%02d"", hrs, mins);\n  }\n}\n 				 						  				   	 		 		",implementation
"\n\nimport java.util.Scanner;\n\npublic class Problem662B {\n    public static Scanner scanner = new Scanner(System.in);\n    public static void main(String[] args) {\n        String str = scanner.next();\n        int n = scanner.nextInt();\n        int h = Integer.parseInt(str.substring(0,2));\n        int m = Integer.parseInt(str.substring(3,5));\n        m += h * 60;\n        m += n;\n        m = m % (24 * 60);\n        System.out.printf(""%02d:%02d\n"", m / 60, m % 60);\n    }\n}\n",implementation
"import java.util.*;\npublic class b {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String in = sc.next();\n        int min = sc.nextInt();\n\n\n        int hrs = Integer.parseInt(in.split("":"")[0]);\n        int mins = Integer.parseInt(in.split("":"")[1]);\n        int newhrs = ((mins + min) / 60) + hrs;\n        newhrs %= 24;\n        int newmins = (mins + min) % 60;\n        \n        System.out.printf(""%02d:%02d\n"", newhrs, newmins);\n    }\n\n}\n",implementation
import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.time.LocalTime;\nimport java.util.*;\n\n    public class Training {\n\n         \n            public static void main(String[] args) throws IOException {\n 		Scanner input = new Scanner(System.in);\n                String s = input.next();\n                int n= input.nextInt();\n             \n                System.out.println(LocalTime.parse(s).plusMinutes(n));\n             \n                   \n                \n        } // end Main\n\n\n\n    } // end Class\n,implementation
"import java.io.*;\nimport java.util.*;\n \npublic class CF614B {\n	public static void main(String[] args) throws IOException {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		int n = Integer.parseInt(br.readLine());\n		StringTokenizer st = new StringTokenizer(br.readLine());\n		String t = null;\n		int k = 0;\n		while (n-- > 0) {\n			String s = st.nextToken();\n			char[] cc = s.toCharArray();\n			if (cc[0] == '0') {\n				System.out.println(0);\n				return;\n			}\n			boolean beautiful = true;\n			if (cc[0] != '1')\n				beautiful = false;\n			else\n				for (int i = 1; i < cc.length; i++)\n					if (cc[i] != '0') {\n						beautiful = false;\n						break;\n					}\n			if (beautiful)\n				k += cc.length - 1;\n			else\n				t = s;\n		}\n		StringBuilder sb = new StringBuilder();\n		sb.append(t == null ? ""1"" : t);\n		for (int i = 0; i < k; i++)\n			sb.append(""0"");\n		System.out.println(sb);\n	}\n}","implementation,math"
"import java.util.*;\nimport java.io.*;\n\npublic class A  {\n	public static void main(String[] args) throws IOException {\n		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n		PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		\n		int N = sc.nextInt();\n		\n		boolean zero = false;\n		int t = 0;\n		String s = ""1"";\n		for (int i = 0; i < N; i++) {\n			String A = sc.next();\n			if (A.equals(""0"")) {\n				zero = true;\n			} else {\n				boolean f = false;\n				\n				if (A.charAt(0) != '1') {\n					f = true;\n					s = A;\n				} else {\n					for (int j = 1; j < A.length(); j++) {\n						if (A.charAt(j) != '0') {\n							s = A;\n							f = true;\n							break;\n						}\n					}\n				}\n				\n				if (!f) {\n					t += A.length() - 1;\n				}\n			}\n		}\n		\n		if (zero) {\n			out.println(0);\n		} else {\n			out.print(s);\n			while (t-- > 0) out.print(0);\n			out.println();\n		}\n		\n		sc.close();\n		out.close();\n	}\n}","implementation,math"
"import java.util.*;\n\npublic class Main {\n\n   public static void main(String[] args) {\n      Scanner scanner = new Scanner(System.in);\n      int n = scanner.nextInt();\n      String[] a = new String[n];\n\n      for (int i = 0; i < n; i++) {\n         a[i] = scanner.next();\n         if (a[i].charAt(0) == '0') {\n            System.out.println(0);\n            return;\n         }\n      }\n\n      int cnt;\n      String badNumber = ""1"";\n      for (String number : a) {\n         cnt = 0;\n         for (char x : number.toCharArray()) {\n            if (x == '1') {\n               cnt++;\n            }\n            if (x != '1' && x != '0') {\n               cnt = 10;\n            }\n         }\n         if (cnt > 1) {\n            badNumber = number;\n            break;\n         }\n      }\n\n      String answer = badNumber;\n\n      for (String number : a) {\n         if (!number.equals(badNumber)) {\n            answer += number.substring(1);\n         }\n      }\n\n      System.out.println(answer);\n\n\n\n   }\n}\n","implementation,math"
"import java.util.*;\n\npublic class Main {\n\n   public static void main(String[] args) {\n      Scanner scanner = new Scanner(System.in);\n      int n = scanner.nextInt();\n      String[] a = new String[n];\n\n      for (int i = 0; i < n; i++) {\n         a[i] = scanner.next();\n         if (a[i].charAt(0) == '0') {\n            System.out.println(0);\n            return;\n         }\n      }\n\n      int cnt;\n      String badNumber = ""1"";\n      for (String number : a) {\n         cnt = 0;\n         for (char x : number.toCharArray()) {\n            if (x == '1') {\n               cnt++;\n            }\n            if (x != '1' && x != '0') {\n               cnt = 10;\n            }\n         }\n         if (cnt > 1) {\n            badNumber = number;\n            break;\n         }\n      }\n\n      String answer = new String(badNumber);\n\n      for (String number : a) {\n         if (!number.equals(badNumber)) {\n            answer = answer.concat(number.substring(1));\n         }\n      }\n\n      System.out.println(answer.toString());\n\n\n\n   }\n}\n","implementation,math"
"\nimport java.util.*;\nimport java.lang.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner inp = new Scanner(System.in);\n        int n = inp.nextInt(), ans = 0;\n        Vector<Integer> v1 = new Vector<>(), v2 = new Vector<>();\n        for (int i = 0; i < n; i++) {\n            int x = inp.nextInt();\n            v1.add(x);\n            v2.add(x);\n        }\n        Collections.sort(v1);\n        long sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += v2.get(i) - v1.get(i);\n            if (sum == 0)\n                ans++;\n        }\n        System.out.println(ans);\n    }\n}\n",sortings
//package day.at.the.beach;\nimport java.util.*;\npublic class DayAtTheBeach {\n\n    public static void main(String[] args) {\n         Scanner input = new Scanner(System.in);\n         int n= input.nextInt();\n         Stack<Integer> s = new Stack<Integer>();\n        int[] arr = new int[n];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = input.nextInt();\n        }\n        int max = arr[0];\n        s.push(arr[0]);\n        for (int i=1;i<arr.length;i++){\n                if (arr[i]>=max) {\n                    s.push(arr[i]);\n                    max=arr[i];\n                }\n                else{    \n                     while(!s.isEmpty() && arr[i]<s.peek())\n                            s.pop();\n                     s.push(max);\n                }\n        }\n        System.out.println(s.size());\n    }\n}\n,sortings
"/* package codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n\n\n/* Name of the class has to be ""Main"" only if the class is public. */\npublic class Main\n \n \n{\n    static Scanner in = new Scanner(System.in);\n    \n    public static void solve()\n    {\n      \n        int n=in.nextInt();\n        int[] a = new int[n];\n        int[]b = new int[n];\n        for(int i=0;i<n;i++)\n        {\n            a[i]=in.nextInt();\n            b[i]=a[i];\n            \n        }\n        \n        Arrays.sort(b);\n        int block=0;\n        int sum1=0,sum2=0;\n        \n        for(int i=0;i<n;i++)\n        {\n            sum1+=a[i];\n            sum2+=b[i];\n            \n            if(sum1==sum2)\n            {\n                block++;\n            }\n        }\n        \n         System.out.println(block);\n        \n       \n        \n    }\n    \n\n    \n	public static void main (String[] args) throws java.lang.Exception\n	{\n		// your code goes here\n		\n		int t=1;\n		//in.nextLine();\n		\n		while(t>0)\n		{\n		    \n		    solve();\n		    t--;\n		}\n		\n		\n	\n	//	System.out.println(x);\n	}\n}\n",sortings
"\nimport java.util.*;\nimport java.io.*;\n\npublic class DayattheBeach {\n\n	// https://codeforces.com/contest/599/problem/C\n	\n	public static void main(String[] args) throws IOException, FileNotFoundException {\n		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n		//BufferedReader in = new BufferedReader(new FileReader(""DayattheBeach""));\n\n		int n = Integer.parseInt(in.readLine());\n\n		int[] arr = new int[n];\n		StringTokenizer st = new StringTokenizer(in.readLine());\n		for (int i=0; i<n; i++) arr[i] = Integer.parseInt(st.nextToken());\n		\n		int[] max = new int[n];\n		max[0] = arr[0];\n		for (int i=1; i<n; i++) {\n			max[i] = Math.max(max[i-1], arr[i]);\n		}\n		\n		int[] min = new int[n];\n		min[n-1] = arr[n-1];\n		for (int i=n-2; i>= 0; i--) {\n			min[i] = Math.min(min[i+1], arr[i]);\n		}\n		int count=0;\n		\n		for (int i=0; i<n-1; i++) {\n			if (max[i] <= min[i+1]) count++;\n		}\n		count++;\n		\n		System.out.println(count);\n	\n	}\n\n}\n\n/*int curmax = max[0];\nfor (int i=0; i<n; i++) {\n	//System.out.println(curmax + "" "" + min[i]);\n	if (i < n-1 && (min[i] == curmax || min[i+1] > curmax)) {\n		count++;\n		if (i < n-1) curmax = max[i+1];\n	}\n	else if (i < n-1 && min[i+1] == curmax) {\n		if (curmax == max[i+1]) {\n			count++;\n			curmax = max[i+1];\n		}\n	}\n	if (i == n-1) {\n		count++;\n	}\n}*/\n\n/*\n  int count=0;\n  for (int i=0; i<n; i++) if (arr[i] == max[i]) count++;\n  System.out.println(count);\n  */\n",sortings
"import static java.lang.Integer.parseInt;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class D_598D_IgonInTheMuseum {\n	\n	static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n	\n	static int max = 1001;\n	static char[][] museum = new char[max][max];\n	static int[][] visited = new int[max][max];\n	static int[] cache = new int[100001];\n	static int res, n, m, i;\n	\n	public static void main(String[] args) throws IOException {\n		String[] line = splitLine();\n		n = parseInt(line[0]);\n		m = parseInt(line[1]);\n		int k = parseInt(line[2]);\n		\n		for (int i = 1; i <= n; ++i) {\n			String s = readLine();\n			for (int j = 1; j <= m; ++j) {\n				museum[i][j] = s.charAt(j - 1);\n			}\n		}\n		for (i = 1; i <= k; ++i) {\n			String[] s = splitLine();\n			int x = parseInt(s[0]);\n			int y = parseInt(s[1]);\n			\n			res = 0;\n			if (visited[x][y] == 0) {\n				visit(x, y);\n				\n				cache[i] = res;\n			} else {\n				res = cache[visited[x][y]];\n			}\n			System.out.println(res);\n		}\n	}\n	\n	static void visit(int x, int y) {\n		if (x == 0 || y == 0 || x == n + 1 || y == m + 1) {\n			return;\n		}\n		if (museum[x][y] == '*') {\n			++res;\n			\n			return;\n		}\n		if (visited[x][y] != 0) {\n			return;\n		}\n		visited[x][y] = i;\n		\n		visit(x + 1, y);\n		visit(x - 1, y);\n		visit(x, y + 1);\n		visit(x, y - 1);\n	}\n	\n	\n	\n	\n	\n	static String[] splitLine() throws IOException {\n		return readLine().split("" "");\n	}\n	\n	static String readLine() throws IOException {\n		return reader.readLine();\n	}\n	\n	static int readInt() throws IOException {\n		return parseInt(reader.readLine());\n	}\n}\n","dfs and similar,graphs,shortest paths"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    public static char[][] mat;\n    public static HashMap<Character, Integer> map = new HashMap<>();\n    public static int[][] limits = {{0, -1},{0, 1},{-1, 0},{1, 0}};\n    public static int res;\n    public static char c = 'a';\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int m = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        mat = new char[n+1][m+1];\n        for (int i = 1; i <= n; i++) {\n            st = new StringTokenizer(br.readLine());\n            String str = st.nextToken();\n            for (int j = 1; j <= m; j++) {\n                mat[i][j] = str.charAt(j-1);\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            st = new StringTokenizer(br.readLine());\n            int x = Integer.parseInt(st.nextToken());\n            int y = Integer.parseInt(st.nextToken());\n            res = 0;\n            if (mat[x][y] == '.'){\n                dfs(x,y);\n                map.put(c, res);\n                c++;\n                System.out.println(res);\n            } else {\n                System.out.println(map.get(mat[x][y]));\n            }\n        }\n    }\n\n    private static void dfs(int i, int j) {\n        mat[i][j] = c;\n        for (int k = 0; k < 4; k++) {\n            int ii = i + limits[k][0];\n            int jj = j + limits[k][1];\n            if (mat[ii][jj] == '.') {\n                dfs(ii, jj);\n            } else if (mat[ii][jj] == '*') {\n                res++;\n            }\n        }\n    }\n\n}\n\n   	 		  	  						  	    				 	","dfs and similar,graphs,shortest paths"
"import java.io.*;\nimport java.util.*;\n \npublic class Main\n{\n	static class InputReader {\n		BufferedReader reader;\n		StringTokenizer tokenizer;\n		public InputReader(InputStream stream) {\n			reader = new BufferedReader(new InputStreamReader(stream), 32768);\n			tokenizer = null;\n		}\n		String next() { // reads in the next string\n			while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n				try {\n					tokenizer = new StringTokenizer(reader.readLine());\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n			return tokenizer.nextToken();\n		}\n		public int nextInt() { // reads in the next int\n			return Integer.parseInt(next());\n		}\n		public long nextLong() { // reads in the next long\n			return Long.parseLong(next());\n		}\n		public double nextDouble() { // reads in the next double\n			return Double.parseDouble(next());\n			}\n		}\n	static InputReader r = new InputReader(System.in);\n	static PrintWriter pw = new PrintWriter(System.out);\n	static int n,m; static int[][] grid; static int num, count;\n	public static void main(String[] args)\n	{\n		n = r.nextInt(); m = r.nextInt(); int k = r.nextInt();\n		grid = new int[n][m];\n		num = 2;\n		int[] ans = new int[n*m+2];\n		for (int i = 0; i < n; i ++)\n		{\n			String s = r.next();\n			for (int j = 0; j < m; j ++)\n			{\n				grid[i][j] = (s.charAt(j) == '*' ? 0:1);\n			}\n		}\n		for (int i = 0; i < n; i ++)\n		{\n			for (int j = 0; j < m; j ++)\n			{\n				if (grid[i][j] == 1)\n				{\n					floodfill(i,j);\n					ans[num] = count;\n					num ++;\n					count = 0;\n				}\n			}\n		}\n		for (int i = 0; i < k; i ++)\n		{\n			int a = r.nextInt() - 1; int b = r.nextInt() - 1;\n			pw.println(ans[grid[a][b]]);\n		}\n		pw.close();\n	}\n	static void floodfill(int row, int col)\n	{\n		if (row < 0 || row >= n || col < 0 || col >= m || grid[row][col] == 0)\n		{\n			count ++;\n			return;\n		}\n		else if (grid[row][col] != 1)\n		{\n			return;\n		}\n		grid[row][col] = num;\n		floodfill(row-1,col); floodfill(row+1,col); floodfill(row,col-1); floodfill(row,col+1);\n	}\n}","dfs and similar,graphs,shortest paths"
"import java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n@SuppressWarnings(""Duplicates"")\npublic class D {\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int rows = sc.nextInt();\n        int cols = sc.nextInt();\n        int query = sc.nextInt();\n        boolean[][] empty = new boolean[rows][cols];\n        int[][] comp = new int[rows][cols];\n        for (int i = 0; i < rows; i++) {\n            String line = sc.next();\n            for (int j = 0; j < cols; j++) {\n                if (line.charAt(j)=='.')empty[i][j] = true;\n            }\n        }\n\n        HashMap<Integer,Integer> sol = new HashMap<>();\n\n        int[][] dirs = {\n            {1,0},\n            {-1,0},\n            {0,1},\n            {0,-1}\n        };\n\n        int compn = 1;\n        for (int q = 0; q < query; q++) {\n            int r = sc.nextInt()-1;\n            int c = sc.nextInt()-1;\n\n            if (comp[r][c]!=0){\n                pw.println(sol.get(comp[r][c]));\n                continue;\n            }\n\n            LinkedList<Integer> que = new LinkedList<>();\n            que.add(r*cols+c);\n            comp[r][c] = compn;\n            int walls = 0;\n            while (!que.isEmpty()){\n                int aux = que.removeFirst();\n                r = aux/cols;\n                c = aux%cols;\n                for (int i = 0; i < dirs.length; i++) {\n                    int nr = r+dirs[i][0];\n                    int nc = c+dirs[i][1];\n                    if (empty[nr][nc]) {\n                        if (comp[nr][nc] == 0) {\n                            comp[nr][nc] = compn;\n                            que.add(nr * cols + nc);\n                        }\n                    }\n                    else walls++;\n                }\n            }\n            sol.put(compn,walls);\n            compn++;\n            pw.println(walls);\n        }\n\n        pw.flush();\n    }\n}\n","dfs and similar,graphs,shortest paths"
import java.util.*;\npublic class TrickySum {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t--!=0) {\n			long n=sc.nextLong();long sum=n*(n+1)/2;\n			for(int i=1;i<=n;i*=2) {\n				sum-=i*2;\n			}\n			System.out.println(sum);\n		}\n\n	}\n\n}\n,math
import java.util.*;\npublic class TrickySum {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t--!=0) {\n			long n=sc.nextLong();long sum=n*(n+1)/2;\n			for(int i=1;i<=n;i*=2) {\n				sum-=i*2;\n			}\n			System.out.println(sum);\n		}\n\n	}\n\n}\n,math
"import java.util.*;\nimport static java.lang.Math.*;\npublic class Test{\n	public static void main(String[] args){\n		Scanner in = new Scanner(System.in);\n		int t = in.nextInt();\n		while (t-->0){\n			long n = in.nextInt();\n			long a = (long)(log(n)/log(2));\n			System.out.println(n*(n+1)/2 - ((long)pow(2,a+1)-1)*2);\n			\n		}\n		\n		\n		\n	}	\n}\n",math
"import java.util.*;\npublic class TrickySum {\n     \n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		long t=s.nextLong(),sum,m,n;\n		for(t=0;t<100 && s.hasNextLong();t++) {\n			n = s.nextLong();\n			m=1;\n			sum = n * (n+1) / 2;\n			while(m <= n) m *= 2;\n			sum -= m*2 -2;\n		System.out.println(sum);\n		}\n	}\n}\n",math
"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static class Pair implements Comparable<Pair>{\n        long y1;\n        long y2;\n        public Pair(long y1, long y2){\n            this.y1 = y1;\n            this.y2 = y2;\n        }\n\n        @Override\n        public int compareTo(Pair o) {\n            if(this.y1 != o.y1){\n                if(this.y1 > o.y1){\n                    return 1;\n                }\n                else return -1;\n            }\n            else if(this.y2 != o.y2){\n                if(this.y2 > o.y2){\n                    return 1;\n                }\n                else return -1;\n            }\n            else return 0;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long x1 = sc.nextInt();\n        long x2 = sc.nextInt();\n        Pair[] pArr = new Pair[n];\n        for(int i = 0; i < n; i++){\n            long k = sc.nextInt();\n            long b = sc.nextInt();\n            long y1 = k * x1 + b;\n            long y2 = k * x2 + b;\n            pArr[i] = new Pair(y1, y2);\n        }\n        Arrays.sort(pArr);\n        boolean res = false;\n        for(int i = 1; i < pArr.length; i++){\n            if(pArr[i-1].y2 > pArr[i].y2){\n                res = true;\n                break;\n            }\n        }\n        if(res) System.out.println(""YES"");\n        else System.out.println(""NO"");\n    }\n}\n\n   					 	 	   	 		 			   		 	","geometry,sortings"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\nimport static java.lang.Double.parseDouble;\nimport static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.in;\nimport static java.lang.System.out;\n\npublic class SolutionB extends Thread {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                                            InputStreamReader(in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return parseInt(next());\n        }\n\n        long nextLong() {\n            return parseLong(next());\n        }\n\n        double nextDouble() {\n            return parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    private static final FastReader scanner = new FastReader();\n    private static final PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        new Thread(null, new SolutionB(), ""Main"", 1 << 28).start();\n    }\n\n    public void run() {\n        solve();\n        out.close();\n    }\n\n    static class Line {\n        int index;\n        long m;\n        long t;\n\n        public Line(int index, int m, int t) {\n            this.index = index;\n            this.m = m;\n            this.t = t;\n        }\n    }\n\n\n    private static void solve() {\n        int n = scanner.nextInt();\n        int x1 = scanner.nextInt();\n        int x2 = scanner.nextInt();\n\n        Line[] linesA = new Line[n];\n        Line[] linesB = new Line[n];\n        for (int i = 0; i < n; i++) {\n            int ki = scanner.nextInt();\n            int bi = scanner.nextInt();\n            linesA[i] = new Line(i, ki, bi);\n            linesB[i] = new Line(i, ki, bi);\n        }\n\n        Arrays.sort(linesA, (o1, o2) -> {\n            long yOnX1Line1 = o1.t + o1.m * x1;\n            long yOnX1Line2 = o2.t + o2.m * x1;\n            if (yOnX1Line1 == yOnX1Line2) {\n                return Long.compare(o1.m, o2.m);\n            } else {\n                return Long.compare(yOnX1Line1, yOnX1Line2);\n            }\n        });\n\n        Arrays.sort(linesB, (o1, o2) -> {\n            long yOnX2Line1 = o1.t + o1.m * x2;\n            long yOnX2Line2 = o2.t + o2.m * x2;\n            if (yOnX2Line1 == yOnX2Line2) {\n                return Long.compare(o2.m, o1.m);\n            } else {\n                return Long.compare(yOnX2Line1, yOnX2Line2);\n            }\n        });\n\n        for (int i = 0; i < n; i++) {\n            if (linesA[i].index != linesB[i].index) {\n                out.println(""YES"");\n                return;\n            }\n        }\n        out.println(""NO"");\n    }\n}","geometry,sortings"
"import java.io.IOException;\nimport java.util.*;\npublic class d {\n    public static void main(String[] args) throws IOException {\n        Scanner s = new Scanner(System.in);\n        // BufferedReader s=new BufferedReader(new InputStreamReader(System.in));\n        //       String[] st=s.readLine().trim().split(""\\s+"");\n        //      a=Integer.parseInt(st[i]);\n        //  String[] st1=s.readLine().trim().split(""\\s+"");\n    StringBuilder sb = new StringBuilder();\n        StringBuilder sb1 = new StringBuilder();\n         int n=s.nextInt();\n         int x1=s.nextInt();\n         int x2=s.nextInt();\n         Student[] st=new Student[n];\n         for(int i=0;i<n;i++){\n             long k=s.nextLong();long b=s.nextLong();\n             st[i]=new Student(k*x1+b,k*x2+b);\n         }Arrays.sort(st,new Sortbyroll());\n        int flag=0;long min=Long.MIN_VALUE;\n         for(int i=0;i<n;i++){\n        //     System.out.println(st[i].l+"" ""+st[i].r);\n             if(st[i].r<min){\n                 flag=1;\n             }min=st[i].r;\n         }\n         if(flag==1) {\n             System.out.println(""YES"");\n         }else System.out.println(""NO"");\n    }\n    static int[] vis;\n    public static int countSetBits(int n)\n    {\n        return (BitsSetTable256[n & 0xff]\n                + BitsSetTable256[(n >> 8) & 0xff]\n                + BitsSetTable256[(n >> 16) & 0xff]\n                + BitsSetTable256[n >> 24]);\n    }\n    static int[] BitsSetTable256 ;\n    public static void initialize(int n)\n    {\n        BitsSetTable256[0] = 0;\n        for (int i = 0; i <=Math.pow(2,n); i++) {\n            BitsSetTable256[i] = (i & 1) + BitsSetTable256[i / 2];\n        }\n    }\n    static HashMap<Integer,Integer>[] val;//static int[] vis;static int y;\n    static boolean dfs(int x ,int i,ArrayList<Integer>[] adj){\n      vis[i]=1;\n     // if(x==1) System.out.print(i+"" "");\n      if(adj[i]==null) return false;\n      for(int j:adj[i]){\n        //  if(x==1) System.out.print(j+"" "");\n          if(j==x) return true;\n          if(vis[j]==0) return dfs(x,j,adj);\n      }return false;\n    }\n\n    static  void computeLPSArray(String pat, int M, int lps[]) {\n        int len = 0;\n        int i = 1;\n        lps[0] = 0;\n        while (i < M) {\n            if (pat.charAt(i) == pat.charAt(len)) {\n                len++;\n                lps[i] = len;\n                i++;\n            }\n            else\n            {\n                if (len != 0) {\n                    len = lps[len - 1];\n                }\n                else\n                {\n                    lps[i] = len;\n                    i++;\n                }\n            }\n        }\n    }\n    static boolean isPrime(int n) {\n        if (n <= 1) return false;\n        if (n <= 3) return true;\n\n        if (n % 2 == 0 || n % 3 == 0) return false;\n\n        for (int i = 5; i * i <= n; i = i + 6)\n            if (n % i == 0 || n % (i + 2) == 0)\n                return false;\n\n        return true;\n    }\n    static long powerwithmod(long  x, long y, int p) {\n        long  res = 1;\n        x = x % p;\n        while (y > 0) {\n            if ((y & 1) == 1)\n                res = (res * x) % p;\n            y = y >> 1;\n            x = (x * x) % p;\n        }\n        return res;\n    }\n    static long  powerwithoutmod(long x, int y) {\n        long  temp;\n        if( y == 0)\n            return 1;\n        temp = powerwithoutmod(x, y/2);\n        if (y%2 == 0)\n            return temp*temp;\n        else\n        {\n            if(y > 0)\n                return x * temp * temp;\n            else\n                return (temp * temp) / x;\n        }\n    }\n    static void fracion(double x) {\n        String a = """" + x;\n        String spilts[] = a.split(""\\.""); // split using decimal\n        int b = spilts[1].length(); // find the decimal length\n        int denominator = (int) Math.pow(10, b); // calculate the denominator\n        int numerator = (int) (x * denominator); // calculate the nerumrator Ex\n        // 1.2*10 = 12\n        int gcd = (int) gcd((long) numerator, denominator); // Find the greatest common\n        // divisor bw them\n        String fraction = """" + numerator / gcd + ""/"" + denominator / gcd;\n        // System.out.println((denominator/gcd));\n        long x1 = modInverse(denominator / gcd, 998244353);\n        //  System.out.println(x1);\n        System.out.println((((numerator / gcd) % 998244353 * (x1 % 998244353)) % 998244353));\n    }\n    static int bfs(int i1, ArrayList<Integer>[] h, int[] vis, int n,int val1) {\n        Queue<Integer> q = new LinkedList<Integer>();\n        q.add(i1);Queue<Integer> aq=new LinkedList<Integer>();\n        aq.add(0);\n        while(!q.isEmpty()){\n            int i=q.poll();\n            int val=aq.poll();\n            if(i==n){\n                return val;\n            }\n            if(h[i]!=null){\n                for(Integer j:h[i]){\n                    if(vis[j]==0){\n                        q.add(j);vis[j]=1;\n                        aq.add(val+1);}\n                }\n            }\n        }return -1;\n    }\n    static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    static long modInverse(long a, int m)\n    {\n        return (powerwithmod(a, m - 2, m));\n    }\n    static int MAXN=100001;\n    static int[] spf=new int[MAXN];\n    static void sieve() {\n        spf[1] = 1;\n        for (int i=2; i<MAXN; i++)\n            spf[i] = i;\n        for (int i=4; i<MAXN; i+=2)\n            spf[i] = 2;\n        for (int i=3; i*i<MAXN; i++)\n        {\n            if (spf[i] == i)\n            {\n                for (int j=i*i; j<MAXN; j+=i)\n\n                    if (spf[j]==j)\n                        spf[j] = i;\n            }\n        }\n    }\n    static Vector<Integer> getFactorizationUsingSeive(int x) {\n        Vector<Integer> ret = new Vector<Integer>();\n        while (x != 1)\n        {\n            ret.add(spf[x]);\n            x = x / spf[x];\n        }\n        return ret;\n    }\n   /*static long[] fac = new long[MAXN+1];\n     static void calculatefac(int mod){\n        for (int i = 1 ;i <= MAXN; i++)\n            fac[i] = fac[i-1] * i % mod;\n     }\n      static long nCrModPFermat(int n, int r, int mod) {\n         if (r == 0)\n            return 1;\n        fac[0] = 1;\n        return (fac[n]* modInverse(fac[r], mod)\n                % mod * modInverse(fac[n-r], mod)\n                                    % mod) % mod;\n    } */}\nclass Student {\n    long  l;long r;int x;\n    public Student(long l, long r) {\n        this.l = l;\n        this.r = r;this.x=x;\n    }\n\n    public String toString()\n    {\n        return this.l+"" "";\n    }\n}\nclass Sortbyroll implements Comparator<Student>\n{\n\n    public int compare(Student a, Student b){\n      if(a.l<b.l) return -1;\n      else if(a.l==b.l){\n          if(a.r==b.r){\n              return 0;\n          }\n          if(a.r<b.r) return -1;\n          return 1;}\n      return 1;  }\n}","geometry,sortings"
"import java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class CF593B {\n	static class Line {\n		long m, b;\n		public Line(long mm, long bb) {m = mm; b = bb;}\n		long y(long x) {return (m * x) + b;}\n	}\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int n = scan.nextInt();\n		int x1 = scan.nextInt(), x2 = scan.nextInt();\n		Line[] l = new Line[n];\n		for(int i = 0 ; i < n ; i++) {\n			long m = scan.nextLong();\n			long b = scan.nextLong();\n			l[i] = new Line(m, b);\n		}\n		Arrays.sort(l , (a, b) -> (a.y(x1) != b.y(x1)) ? Long.compare(a.y(x1), b.y(x1)) : Long.compare(a.y(x2), b.y(x2)));\n		boolean passed = false;\n		for(int i = 0 ; i < n - 1 ; i++)\n			if(l[i].y(x2) > l[i + 1].y(x2))\n				passed = true;\n		System.out.println(passed ? ""YES"" : ""NO"");\n	}\n}\n","geometry,sortings"
"\nimport java.io.*;\nimport java.lang.*;\nimport java.util.*;\n\npublic class C592 {\n    static long t;\n    public static void main(String[] args) throws IOException{\n        StringTokenizer st;\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        st = new StringTokenizer(f.readLine());\n        t = Long.parseLong(st.nextToken());\n        long w = Long.parseLong(st.nextToken());\n        long b = Long.parseLong(st.nextToken());\n        long lcm = lcm(w,b);\n        long hmany = t/lcm;\n        long op = 0;\n        if(hmany >= 1){\n            op = Math.min(t%lcm+1, Math.min(w,b));\n            if(op != 0)\n                hmany--;\n        }\n        //System.out.println(op + "" "" + lcm + "" "" + hmany + "" "" + t%lcm);\n        op+=(hmany*(Math.min(w,b))) + Math.min(t, Math.min(w,b)-1);\n        //System.out.println(op);\n\n        f.close();\n\n\n\n        System.out.println(asFraction(op,t));\n    }\n    static long gcd(long a, long b)\n    {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n    static long lcm(long a, long b)\n    {\n        long r = a/gcd(a,b);\n        try {\n            long j = Math.multiplyExact(r,b);\n            return j;\n        }catch (ArithmeticException e){\n            return t+1;\n        }\n    }\n\n    public static String asFraction(long a, long b) {\n        long gcd = gcd(a, b);\n        return (a / gcd) + ""/"" + (b / gcd);\n    }\n\n}",math
"import java.io.BufferedInputStream;\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static BigInteger GCD(BigInteger a,BigInteger b)\n    {\n        if(b.compareTo(BigInteger.ZERO)==0) return a;\n        return GCD(b,a.remainder(b));\n    }\n\n    public static BigInteger MIN(BigInteger a,BigInteger b)\n    {\n        if(a.compareTo(b)>=0) return b;\n        return a;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner (new BufferedInputStream(System.in));\n\n        BigInteger t=sc.nextBigInteger();\n        BigInteger a=sc.nextBigInteger();\n        BigInteger b=sc.nextBigInteger();\n\n        if(MIN(a,b).compareTo(t)>0)\n        {\n            System.out.print(""1""+""/""+""1"");\n        }\n        else{\n            BigInteger gcd=GCD(a,b);\n            BigInteger lcm=a.multiply(b).divide(gcd);\n            BigInteger k=MIN(a,b).subtract(BigInteger.ONE);\n            BigInteger ans=BigInteger.ZERO;\n            BigInteger tmp=t.divide(lcm);\n            ans=k;\n            if(tmp.compareTo(BigInteger.ZERO)>0)\n            {\n                BigInteger u=tmp.subtract(BigInteger.ONE);\n                ans=ans.add(u.multiply(k.add(BigInteger.ONE)));\n                ans=ans.add(BigInteger.ONE);\n                ans=ans.add(MIN(k,t.subtract(lcm.multiply(tmp))));\n            }\n            BigInteger fz=ans;\n            BigInteger fm=t;\n            BigInteger e=GCD(fz,fm);\n            fz=fz.divide(e);\n            fm=fm.divide(e);\n            System.out.print(fz.toString()+""/""+fm.toString());\n        }\n    }\n} \n 			  		 	 	 	  								  	  	",math
"import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\n//\npublic class AGC_020_Encoding {\n\n\n\n	public static void main(String[]args) throws Throwable {\n		Scanner sc = new Scanner(System.in);\n		long tt = sc.nextLong(), nn = sc.nextLong(), mm = sc.nextLong();\n		if (nn < mm) {\n			long tmp = nn;\n			nn = mm;\n			mm = tmp;\n		}\n		BigInteger t = new BigInteger(tt+""""), n = new BigInteger(nn+""""), m = new BigInteger(mm+"""");\n		BigInteger lcm = n.multiply(m).divide(n.gcd(m));\n		BigInteger tot = t.divide(lcm);\n		if (tot.equals(BigInteger.ZERO)) {\n			m = m.min(t.add(BigInteger.ONE));\n			BigInteger k = m.subtract(BigInteger.ONE).gcd(t);\n			System.out.println(m.subtract(BigInteger.ONE).divide(k)+""/""+t.divide(k));\n			return;\n		}\n		BigInteger res = tot.subtract(BigInteger.ONE).multiply(m);\n		BigInteger mid = t.min((lcm.multiply(tot)).add(m.subtract(BigInteger.ONE))).subtract(lcm.multiply(tot));\n		//System.out.println(mid);\n		res = res.add(mid).add(BigInteger.ONE);\n		res = res.add(m.subtract(BigInteger.ONE));\n		BigInteger k = res.gcd(t);\n		System.out.println(res.divide(k)+""/""+t.divide(k));\n		\n		\n	}\n\n	static class Scanner {\n		StringTokenizer st;\n		BufferedReader br;\n\n		public Scanner(InputStream s) {\n			br = new BufferedReader(new InputStreamReader(s));\n		}\n\n		public Scanner(String s) throws FileNotFoundException {\n			br = new BufferedReader(new FileReader(new File(s)));\n		}\n\n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n\n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n	}\n}",math
"/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n//package the.big.race;\n\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\n/**\n *\n * @author hp\n */\npublic class TheBigRace {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        BigInteger t,w,b;\n        t = scanner.nextBigInteger();\n        w = scanner.nextBigInteger();\n        b = scanner.nextBigInteger();\n        BigInteger mn;\n        if(w.compareTo(b) == -1) {\n            mn = w;\n        }\n        else {\n            mn = b;\n        }\n        BigInteger num;\n        if(w.compareTo(b) == 0) {\n            num = t;\n        }\n        else {\n            BigInteger lcm = w.multiply(b);\n            BigInteger gcd = w.gcd(b);\n            lcm = lcm.divide(gcd);\n            BigInteger ans = t.divide(lcm);\n            ans = ans.multiply(mn);\n            /*\n            if(w.compareTo(b) == -1) {\n                ans = ans.multiply(w);\n            }\n            else {\n                ans = ans.multiply(b);\n            }*/\n            ans = ans.add(mn.subtract(BigInteger.ONE));\n            /*if(w.compareTo(BigInteger.ONE) != 0 && b.compareTo(BigInteger.ONE) != 0) {\n                ans = ans.add(BigInteger.ONE);\n            }*/\n            BigInteger ratio = t.divide(lcm);\n            BigInteger closest = lcm.multiply(ratio);\n            //System.out.println(""ans is "" + ans);\n            BigInteger outside = closest.add(mn).subtract(t).subtract(BigInteger.ONE);\n            if(outside.compareTo(BigInteger.ZERO) != -1) {\n                ans = ans.subtract(outside);\n            }\n            //System.out.println(""ans is "" + ans);\n\n            if(t.compareTo(ans) == -1) {\n                num = t;\n            }\n            else {\n                num = ans;\n            }\n        }\n\n        //System.out.println(""num is "" + num);\n        BigInteger denum = t;\n        BigInteger d = num.gcd(denum);\n        num = num.divide(d);\n        denum = denum.divide(d);\n        System.out.println(num + ""/"" + denum);\n    }\n    \n}\n",math
"import java.util.*;\nimport java.io.*;\n\npublic class Main {\n	\n	static int INF = (int)1e9;\n	static int n, MAXN;\n	static ArrayList<Integer>[] adjList;\n	static ArrayList<Integer>[] people;\n	static int[] parent, level;\n	static int[][] origMin;\n	static int[][] min;\n	static int[][] lcaP;\n	static int[][][] lcaMin;\n	\n	public static void dfs(int u, int p) {\n		parent[u] = p;\n		for(int v : adjList[u])\n			if(v != p) {\n				level[v] = level[u] + 1;\n				min[v] = origMin[u];\n				dfs(v, u);\n			}\n	}\n	\n	public static int[] merge(int[] a, int[] b) {\n		int[] res = new int[10];\n		int i = 0, j = 0;\n		for(int u = 0; u < 10; u++)\n			if(i == 10)\n				res[u] = b[j++];\n			else if(j == 10)\n				res[u] = a[i++];\n			else if(a[i] <= b[j])\n				res[u] = a[i++];\n			else\n				res[u] = b[j++];\n		return res;\n	}\n	\n	public static void preprocess() {\n		lcaP[0] = parent;\n		lcaMin[0] = min;\n		for(int i = 1; i < MAXN; i++)\n			for(int j = 0; j < n; j++) {\n				lcaP[i][j] = lcaP[i - 1][j] == -1 ? -1 : lcaP[i - 1][lcaP[i - 1][j]];\n				lcaMin[i][j] = lcaP[i - 1][j] == -1 ? lcaMin[i - 1][j] : merge(lcaMin[i - 1][j], lcaMin[i - 1][lcaP[i - 1][j]]);\n			}\n	}\n	\n	public static int[] solve(int u, int v) {\n		int[] ans = new int[10];\n		Arrays.fill(ans, INF);\n		if(level[u] < level[v]) {\n			int temp = u;\n			u = v;\n			v = temp;\n		}\n		ans = merge(ans, origMin[u]);\n		if(level[u] > level[v]) {\n			int diff = level[u] - level[v];\n			for(int i = 0; i < MAXN; i++)\n				if((diff & (1 << i)) != 0) {\n					ans = merge(ans, lcaMin[i][u]);\n					u = lcaP[i][u];\n				}\n		}\n		\n		if(u == v)\n			return ans;\n		ans = merge(ans, origMin[v]);\n		for(int i = MAXN - 1; i >= 0; i--) {\n			if(lcaP[i][u] != lcaP[i][v]) {\n				ans = merge(ans, lcaMin[i][u]);\n				ans = merge(ans, lcaMin[i][v]);\n				u = lcaP[i][u];\n				v = lcaP[i][v];\n			}\n		}\n		ans = merge(ans, lcaMin[0][u]);\n		return ans;\n	}\n	\n	public static void main(String[] args) throws Exception {\n		Scanner sc = new Scanner(System.in);\n		PrintWriter pw = new PrintWriter(System.out);\n		\n		MAXN = 18;\n		n = sc.nextInt();\n		int m = sc.nextInt();\n		int q = sc.nextInt();\n		\n		adjList = new ArrayList[n];\n		for(int i = 0; i < n; i++)\n			adjList[i] = new ArrayList<>();\n		\n		people = new ArrayList[n];\n		for(int i = 0; i < n; i++)\n			people[i] = new ArrayList<>();\n		\n		for(int i = 0; i < n - 1; i++) {\n			int u = sc.nextInt() - 1, v = sc.nextInt() - 1;\n			adjList[u].add(v);\n			adjList[v].add(u);\n		}\n		\n		for(int i = 0; i < m; i++)\n			people[sc.nextInt() - 1].add(i + 1);\n		\n		parent = new int[n];\n		level = new int[n];\n		origMin = new int[n][10];\n		for(int i = 0; i < n; i++) {\n			Arrays.fill(origMin[i], INF);\n			Collections.sort(people[i]);\n			for(int j = 0; j < Math.min(10, people[i].size()); j++)\n				origMin[i][j] = people[i].get(j);\n		}\n		min = new int[n][10];\n		Arrays.fill(min[0], INF);\n		dfs(0, -1);\n		\n		lcaP = new int[MAXN][n];\n		lcaMin = new int[MAXN][n][10];\n		preprocess();\n		\n		while(q-->0) {\n			int u = sc.nextInt() - 1, v = sc.nextInt() - 1, a = sc.nextInt();\n			int[] ans = solve(u, v);\n			int cnt = 0;\n			for(int i = 0; i < Math.min(a, 10); i++)\n				if(ans[i] == INF)\n					break;\n				else\n					cnt++;\n			pw.print(cnt);\n			for(int i = 0; i < cnt; i++)\n				pw.print("" "" + ans[i]);\n			pw.print(""\n"");\n		}\n		\n		pw.flush();\n	}\n\n	public static class Scanner {\n		StringTokenizer st;\n		BufferedReader br;\n\n		public Scanner(InputStream system) {\n			br = new BufferedReader(new InputStreamReader(system));\n		}\n\n		public Scanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n\n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n\n		public char nextChar() throws IOException {\n			return next().charAt(0);\n		}\n\n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n\n		public int[] nextIntArray(int n) throws IOException {\n			int[] array = new int[n];\n			for (int i = 0; i < n; i++)\n				array[i] = nextInt();\n			return array;\n		}\n\n		public Integer[] nextIntegerArray(int n) throws IOException {\n			Integer[] array = new Integer[n];\n			for (int i = 0; i < n; i++)\n				array[i] = new Integer(nextInt());\n			return array;\n		}\n\n		public long[] nextLongArray(int n) throws IOException {\n			long[] array = new long[n];\n			for (int i = 0; i < n; i++)\n				array[i] = nextLong();\n			return array;\n		}\n\n		public double[] nextDoubleArray(int n) throws IOException {\n			double[] array = new double[n];\n			for (int i = 0; i < n; i++)\n				array[i] = nextDouble();\n			return array;\n		}\n\n		public static int[] shuffle(int[] a) {\n			int n = a.length;\n			Random rand = new Random();\n			for (int i = 0; i < n; i++) {\n				int tmpIdx = rand.nextInt(n);\n				int tmp = a[i];\n				a[i] = a[tmpIdx];\n				a[tmpIdx] = tmp;\n			}\n			return a;\n		}\n\n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n\n		public void waitForInput() throws InterruptedException {\n			Thread.sleep(3000);\n		}\n	}\n}\n\n    	 			 					 					 		 	   	","data structures,trees"
"import java.util.*;\nimport java.io.*;\npublic class DuffInTheArmy {\n    public static void main(String[] args) throws IOException {\n        Reader in = new Reader();\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int N = in.nextInt(), M = in.nextInt(), Q = in.nextInt();\n        List<Integer>[] adj = new ArrayList[N];\n        for (int i = 0; i < N; i++) {\n            adj[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < N - 1; i++) {\n            int u = in.nextInt() - 1, v = in.nextInt() - 1;\n            adj[u].add(v);\n            adj[v].add(u);\n        }\n        \n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(0);\n        int[][] jump = new int[N][20];\n        jump[0][0] = -1;\n        int[] depth = new int[N];\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            for (int i : adj[current]) {\n                if (current == 0 || i != jump[current][0]) {\n                    jump[i][0] = current;\n                    depth[i] = depth[current] + 1;\n                    queue.offer(i);\n                }\n            }\n        }\n        \n        List<Integer>[][] dp = new ArrayList[N][20];\n        for (int i = 0; i < N; i++) {\n            dp[i][0] = new ArrayList<>();\n        }\n        for (int i = 0; i < M; i++) {\n            dp[in.nextInt() - 1][0].add(i + 1);\n        }\n        for (int i = 0; i < N; i++) {\n            Collections.sort(dp[i][0]);\n            while (dp[i][0].size() > 10) {\n                dp[i][0].remove(dp[i][0].size() - 1);\n            }\n        }\n        for (int j = 1; j < 20; j++) {\n            for (int i = 0; i < N; i++) {\n                dp[i][j] = new ArrayList<>();\n                jump[i][j] = jump[i][j - 1] == -1 ? -1 : jump[jump[i][j - 1]][j - 1];\n                List<Integer> l1 = dp[i][j - 1], l2 = jump[i][j - 1] == -1 ? new ArrayList<>() : dp[jump[i][j - 1]][j - 1];\n                int i1 = 0, i2 = 0;\n                while (i1 < l1.size() && i2 < l2.size() && dp[i][j].size() < 10) {\n                    if (l1.get(i1) < l2.get(i2)) {\n                        dp[i][j].add(l1.get(i1++));\n                    } else {\n                        dp[i][j].add(l2.get(i2++));\n                    }\n                }\n                while (i1 < l1.size() && dp[i][j].size() < 10) {\n                    dp[i][j].add(l1.get(i1++));\n                }\n                while (i2 < l2.size() && dp[i][j].size() < 10) {\n                    dp[i][j].add(l2.get(i2++));\n                }\n            }\n        }\n        \n        for (int q = 0; q < Q; q++) {\n            int u = in.nextInt() - 1, v = in.nextInt() - 1, K = in.nextInt();\n            int u2 = u, v2 = v;\n            Queue<Integer> pq = new PriorityQueue<>();\n            for (int j = 19; j >= 0; j--) {\n                if (depth[u2] > depth[v2] && jump[u2][j] != -1 && depth[jump[u2][j]] >= depth[v2]) {\n                    for (int i : dp[u2][j]) {\n                        pq.offer(i);\n                    }\n                    u2 = jump[u2][j];\n                }\n                if (depth[u2] < depth[v2] && jump[v2][j] != -1 && depth[jump[v2][j]] >= depth[u2]) {\n                    for (int i : dp[v2][j]) {\n                        pq.offer(i);\n                    }\n                    v2 = jump[v2][j];\n                }\n            }\n            for (int j = 19; j >= 0; j--) {\n                if (jump[u2][j] != -1 && jump[u2][j] != jump[v2][j]) {\n                    for (int i : dp[u2][j]) {\n                        pq.offer(i);\n                    }\n                    u2 = jump[u2][j];\n                    for (int i : dp[v2][j]) {\n                        pq.offer(i);\n                    }\n                    v2 = jump[v2][j];\n                }\n            }\n            if (u2 != v2) {\n                for (int i : dp[u2][0]) {\n                    pq.offer(i);\n                }\n                for (int i : dp[v2][0]) {\n                    pq.offer(i);\n                }\n            }\n            int lca = u2 == v2 ? u2 : jump[u2][0];\n            for (int i : dp[lca][0]) {\n                pq.offer(i);\n            }\n            out.print(Math.min(pq.size(), K));\n            for (int i = 0; i < K; i++) {\n                if (pq.isEmpty()) {\n                    break;\n                }\n                out.print("" "" + pq.poll());\n            }\n            out.println();\n        }\n        \n        out.close();\n    }\n    static class Reader {\n        BufferedReader in;\n        StringTokenizer st;\n        public Reader() {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            st = new StringTokenizer("""");\n        }\n        public String nextLine() throws IOException {\n            st = new StringTokenizer("""");\n            return in.readLine();\n        }\n        public String next() throws IOException {\n            while (!st.hasMoreTokens()) {\n                st = new StringTokenizer(in.readLine());\n            }\n            return st.nextToken();\n        }\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n    public static void sort(int[] arr) {\n        List<Integer> list = new ArrayList<>();\n        for (int i : arr) {\n            list.add(i);\n        }\n        Collections.sort(list);\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = list.get(i);\n        }\n    }\n}","data structures,trees"
"import java.util.*;\nimport java.math.*;\nimport java.io.*;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\npublic class Main {\n  static int []head = new int[100001];\n  static int []nxt = new int[200001];\n  static int []b = new int[200001];\n  static int [][]fa = new int[100001][21];\n  static int [][][]Fs = new int[100001][21][];\n  static ArrayList<Integer> []C = new ArrayList[100001];\n  static int k;\n  static int []dep = new int[100001];\n  static int []cnt = new int[100001];\n  static int n;\n  static void push(int s, int t) {\n    nxt[++k] = head[s];\n    head[s] = k;\n    b[k] = t;\n  }\n\n  static void DEBUG(int n)\n  {\n    for (int i = 1;i <= n;++i) {\n      for (int z = 0;z <= 20;++z) {\n        if (fa[i][z] == 0) continue;\n\n        System.out.println(""------"");\n        System.out.println(""fa[""+i+""][""+z+""]=""+fa[i][z]);\n        if (Fs[i][z] != null) {\n          System.out.println(Arrays.toString(Fs[i][z]));\n        }\n        System.out.println(""------"");\n      }\n    }\n    System.out.println(""===="");\n  }\n\n\n  static void dfs(int x, int f) {\n    fa[x][0] = f;\n    if (f != 0) {//x root?\n      if (C[f].size() > 0) {\n        Fs[x][0] = new int[C[f].size()];\n        for (int i = 0;i < C[f].size();++i) {\n          Fs[x][0][i] = C[f].get(i);\n        }\n      }\n      //Fs[x][0] keeps info (x, fa[x][0]]\n    }\n    \n    for (int i = 1;i <= 20;++i) {\n      fa[x][i] = fa[fa[x][i - 1]][i - 1];\n      if (Fs[x][i - 1] == null && Fs[fa[x][i - 1]][i - 1] != null) {\n        Fs[x][i] = Fs[fa[x][i - 1]][i - 1].clone();\n      } else if (Fs[x][i - 1] != null && Fs[fa[x][i - 1]][i - 1] == null) {\n        Fs[x][i] = Fs[x][i - 1].clone();\n      } else if (Fs[x][i - 1] != null && Fs[fa[x][i - 1]][i - 1] != null) {\n        ArrayList<Integer> tmp = new ArrayList<Integer>();\n        for (int v:Fs[x][i - 1]) tmp.add(v);\n        for (int v:Fs[fa[x][i - 1]][i - 1]) tmp.add(v);\n        Collections.sort(tmp);\n        while (tmp.size() > 10) tmp.remove(10);\n        Fs[x][i] = new int[tmp.size()];\n        for (int z = 0;z < tmp.size();++z) {\n          Fs[x][i][z] = tmp.get(z);\n        }\n      }\n    }\n    dep[x] = dep[f] + 1;\n    for (int i = head[x];i > 0;i = nxt[i]) {\n      if (b[i] != f) dfs(b[i], x);\n    }\n  }\n  static int LCA(int u,int v, Set<Integer> ans)\n  {\n    if (dep[u] < dep[v]) {\n      int tmp = u;\n      u = v;\n      v = tmp;\n    }\n    ans.addAll(C[u]);\n    ans.addAll(C[v]);\n    int delta = dep[u] - dep[v];\n    for(int x = 0;x <= 20;x++) {\n      int flag = (1<<x)&delta;\n      if(flag > 0) {\n        //add info first then u = fa[u][x]\n        if (Fs[u][x] != null) for (int it:Fs[u][x]) ans.add(it);\n        u = fa[u][x];\n      }\n    }\n    if (u == v) return u;\n    for(int x = 20;x >= 0;x--) {\n      if(fa[u][x] != fa[v][x]) {\n        if (Fs[u][x] != null) for (int it:Fs[u][x]) ans.add(it);\n        if (Fs[v][x] != null) for (int it:Fs[v][x]) ans.add(it);\n        u=fa[u][x];\n        v=fa[v][x];\n      }\n    }\n    ans.addAll(C[fa[u][0]]);\n    return fa[u][0];\n  }\n  static void getans(int x, int f) {\n    for (int i = head[x];i > 0;i = nxt[i]) {\n      if (b[i] != f) {\n        getans(b[i], x); \n        cnt[x] += cnt[b[i]];\n      }\n    }\n  }\n  public static void main(String[] args) {\n    try {\n      MScanner in = new MScanner(System.in);\n      BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out, ""UTF-8""));\n      int n = in.nextInt();\n      int m = in.nextInt();\n      int q = in.nextInt();\n      for (int i = 1;i <= n - 1;++i) {\n        int s = in.nextInt();\n        int t = in.nextInt();\n        push(s, t);\n        push(t, s);\n      }\n      for (int i = 0;i <= n;++i) C[i] = new ArrayList<Integer>();\n      for (int i = 1;i <= m;++i) {\n        int c = in.nextInt();\n        C[c].add(i);\n      }\n      for (int i = 1;i <= n;++i) {\n        if (C[i].size() > 10) {\n          Collections.sort(C[i]);\n          while (C[i].size() > 10) C[i].remove(10);\n        }\n      }\n      dfs(1, 0);\n      //DEBUG(n);\n      for (int i = 1;i <= q;++i) {\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int sz = in.nextInt();\n\n        Set<Integer> ans = new TreeSet<>();\n        int lca = LCA(x, y, ans);\n        int asz = Math.min(ans.size(), sz);\n        int cnt = 0;\n        out.write(asz + "" "");\n        for (Integer z:ans) {\n          out.write(z + "" "");\n          if (++cnt >= asz) break;\n        }\n        out.write(""\n"");\n      }\n      out.flush();\n      out.close();\n    } catch (Exception e) {\n      System.out.print(e);\n      System.exit(0);\n    }\n  }\n  static class MScanner {\n    StringTokenizer st;\n    BufferedReader br;\n    public MScanner(InputStream system) {\n      br = new BufferedReader(new InputStreamReader(system));\n    }\n\n    public MScanner(String file) throws Exception {\n      br = new BufferedReader(new FileReader(file));\n    }\n\n    public String next() throws IOException {\n      while (st == null || !st.hasMoreTokens())\n	st = new StringTokenizer(br.readLine());\n      return st.nextToken();\n    }\n    public int[] takearr(int n) throws IOException {\n      int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n      return in;\n    }\n    public long[] takearrl(int n) throws IOException {\n      long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n      return in;\n    }\n    public Integer[] takearrobj(int n) throws IOException {\n      Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n      return in;\n    }\n    public Long[] takearrlobj(int n) throws IOException {\n      Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n      return in;\n    }\n    public String nextLine() throws IOException {\n      return br.readLine();\n    }\n\n    public int nextInt() throws IOException {\n      return Integer.parseInt(next());\n    }\n\n    public double nextDouble() throws IOException {\n      return Double.parseDouble(next());\n    }\n\n    public char nextChar() throws IOException {\n      return next().charAt(0);\n    }\n\n    public Long nextLong() throws IOException {\n      return Long.parseLong(next());\n    }\n\n    public boolean ready() throws IOException {\n      return br.ready();\n    }\n\n    public void waitForInput() throws InterruptedException {\n      Thread.sleep(3000);\n    }\n  }\n}\n\n","data structures,trees"
"import java.util.*;\nimport java.math.*;\nimport java.io.*;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\npublic class Main {\n  static int []head = new int[100001];\n  static int []nxt = new int[200001];\n  static int []b = new int[200001];\n  static int [][]fa = new int[100001][21];\n  static int [][][]Fs = new int[100001][21][];\n  static ArrayList<Integer> []C = new ArrayList[100001];\n  static int k;\n  static int []dep = new int[100001];\n  static int []cnt = new int[100001];\n  static int n;\n  static void push(int s, int t) {\n    nxt[++k] = head[s];\n    head[s] = k;\n    b[k] = t;\n  }\n\n  static void DEBUG(int n)\n  {\n    for (int i = 1;i <= n;++i) {\n      for (int z = 0;z <= 20;++z) {\n        if (fa[i][z] == 0) continue;\n\n        System.out.println(""------"");\n        System.out.println(""fa[""+i+""][""+z+""]=""+fa[i][z]);\n        if (Fs[i][z] != null) {\n          System.out.println(Arrays.toString(Fs[i][z]));\n        }\n        System.out.println(""------"");\n      }\n    }\n    System.out.println(""===="");\n  }\n\n\n  static void dfs(int x, int f) {\n    fa[x][0] = f;\n    if (f != 0) {//x root?\n      if (C[f].size() > 0) {\n        Fs[x][0] = new int[C[f].size()];\n        for (int i = 0;i < C[f].size();++i) {\n          Fs[x][0][i] = C[f].get(i);\n        }\n      }\n    }\n    \n    for (int i = 1;i <= 20;++i) {\n      fa[x][i] = fa[fa[x][i - 1]][i - 1];\n      if (Fs[x][i - 1] == null && Fs[fa[x][i - 1]][i - 1] != null) {\n        Fs[x][i] = Fs[fa[x][i - 1]][i - 1].clone();\n      } else if (Fs[x][i - 1] != null && Fs[fa[x][i - 1]][i - 1] == null) {\n        Fs[x][i] = Fs[x][i - 1].clone();\n      } else if (Fs[x][i - 1] != null && Fs[fa[x][i - 1]][i - 1] != null) {\n        ArrayList<Integer> tmp = new ArrayList<Integer>();\n        for (int v:Fs[x][i - 1]) tmp.add(v);\n        for (int v:Fs[fa[x][i - 1]][i - 1]) tmp.add(v);\n        Collections.sort(tmp);\n        while (tmp.size() > 10) tmp.remove(10);\n        Fs[x][i] = new int[tmp.size()];\n        for (int z = 0;z < tmp.size();++z) {\n          Fs[x][i][z] = tmp.get(z);\n        }\n      }\n    }\n    dep[x] = dep[f] + 1;\n    for (int i = head[x];i > 0;i = nxt[i]) {\n      if (b[i] != f) dfs(b[i], x);\n    }\n  }\n  static int LCA(int u,int v, Set<Integer> ans)\n  {\n    if (dep[u] < dep[v]) {\n      int tmp = u;\n      u = v;\n      v = tmp;\n    }\n    ans.addAll(C[u]);\n    ans.addAll(C[v]);\n    //System.out.println(ans);\n    //System.out.println(""add uv"");\n    int delta = dep[u] - dep[v];\n\n    for(int x = 0;x <= 20;x++) {\n      int flag = (1<<x)&delta;\n      if(flag > 0) {\n        if (Fs[u][x] != null) for (int it:Fs[u][x]) ans.add(it);\n        u = fa[u][x];\n        //System.out.println(""prev:""+u);\n        //System.out.println(ans);\n        //System.out.println(""after lift"");\n      }\n    }\n    //System.out.println(""check u""+u);\n\n    if (u == v) return u;\n    for(int x = 20;x >= 0;x--) {\n      if(fa[u][x] != fa[v][x]) {\n        if (Fs[u][x] != null) for (int it:Fs[u][x]) ans.add(it);\n        if (Fs[v][x] != null) for (int it:Fs[v][x]) ans.add(it);\n        u=fa[u][x];\n        v=fa[v][x];\n      }\n    }\n    ans.addAll(C[fa[u][0]]);\n    return fa[u][0];\n  }\n  static void getans(int x, int f) {\n    for (int i = head[x];i > 0;i = nxt[i]) {\n      if (b[i] != f) {\n        getans(b[i], x); \n        cnt[x] += cnt[b[i]];\n      }\n    }\n  }\n\n\n  public static void main(String[] args) {\n    try {\n    MScanner in = new MScanner(System.in);\n    BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out, ""UTF-8""));\n\n    int n = in.nextInt();\n    int m = in.nextInt();\n    int q = in.nextInt();\n    for (int i = 1;i <= n - 1;++i) {\n      int s = in.nextInt();\n      int t = in.nextInt();\n      push(s, t);\n      push(t, s);\n    }\n    for (int i = 0;i <= n;++i) C[i] = new ArrayList<Integer>();\n    \n    for (int i = 1;i <= m;++i) {\n      int c = in.nextInt();\n      C[c].add(i);\n    }\n    for (int i = 1;i <= n;++i) {\n      if (C[i].size() > 10) {\n        Collections.sort(C[i]);\n        while (C[i].size() > 10) C[i].remove(10);\n      }\n    }\n    dfs(1, 0);\n    //DEBUG(n);\n\n\n    for (int i = 1;i <= q;++i) {\n      int x = in.nextInt();\n      int y = in.nextInt();\n      int sz = in.nextInt();\n      \n      Set<Integer> ans = new TreeSet<>();\n      int lca = LCA(x, y, ans);\n      //System.out.println(x + "" "" + y + "" "" + lca);\n      //System.out.println(ans);\n      int asz = Math.min(ans.size(), sz);\n      int cnt = 0;\n      //System.out.print(asz + "" "");\n      out.write(asz + "" "");\n      for (Integer z:ans) {\n        //System.out.print(z + "" "");\n        out.write(z + "" "");\n        if (++cnt >= asz) break;\n      }\n      //System.out.println();\n      out.write(""\n"");\n    }\n    out.flush();\n    out.close();\n    //getans(1, 0);\n\n    //for (int i = 1;i < n;++i) {\n    //  int x = b[(i<<1) - 1];\n    //  int y = b[(i<<1)];\n    //  if (fa[x][0] == y) {\n    //    System.out.print(cnt[x] + "" "");\n    //  } else {\n    //    System.out.print(cnt[y] + "" "");\n    //  }\n    //}\n    //System.out.println();\n\n    } catch (Exception e) {\n      System.out.print(e);\n      System.exit(0);\n    }\n\n\n  }\n  static class MScanner {\n    StringTokenizer st;\n    BufferedReader br;\n    public MScanner(InputStream system) {\n      br = new BufferedReader(new InputStreamReader(system));\n    }\n\n    public MScanner(String file) throws Exception {\n      br = new BufferedReader(new FileReader(file));\n    }\n\n    public String next() throws IOException {\n      while (st == null || !st.hasMoreTokens())\n	st = new StringTokenizer(br.readLine());\n      return st.nextToken();\n    }\n    public int[] takearr(int n) throws IOException {\n      int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n      return in;\n    }\n    public long[] takearrl(int n) throws IOException {\n      long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n      return in;\n    }\n    public Integer[] takearrobj(int n) throws IOException {\n      Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n      return in;\n    }\n    public Long[] takearrlobj(int n) throws IOException {\n      Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n      return in;\n    }\n    public String nextLine() throws IOException {\n      return br.readLine();\n    }\n\n    public int nextInt() throws IOException {\n      return Integer.parseInt(next());\n    }\n\n    public double nextDouble() throws IOException {\n      return Double.parseDouble(next());\n    }\n\n    public char nextChar() throws IOException {\n      return next().charAt(0);\n    }\n\n    public Long nextLong() throws IOException {\n      return Long.parseLong(next());\n    }\n\n    public boolean ready() throws IOException {\n      return br.ready();\n    }\n\n    public void waitForInput() throws InterruptedException {\n      Thread.sleep(3000);\n    }\n  }\n}\n\n","data structures,trees"
"import java.util.Scanner;\n\npublic class E {\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		long x = scan.nextLong();\n		long y = scan.nextLong();\n		if(gcd(x,y) != 1) {\n			System.out.println(""Impossible"");\n			return;\n		}\n		System.out.println(ans);\n	}\n	static StringBuilder ans = new StringBuilder();\n	static char c = 'A';\n	static long gcd(long a, long b) {\n		if(b == 0) return a;\n		if(a >= b) {\n			long t = a/b;\n			if(a % b == 0)\n				t--;\n			ans.append(t);\n			ans.append(c);\n		}\n		c = (char) ('A' + 'B' - c);\n		return gcd(b,a%b);\n	}\n}\n",number theory
"import java.util.*;\npublic class Main {\n	static long x,y,p;\n	static String s;\n	static long gcd(long a,long b)\n	{\n		if(a==0) return b;\n		return gcd(b%a,a);\n	}\n\n	public static void main(String[] args) {\n		Scanner in=new Scanner(System.in);\n		x=in.nextLong();y=in.nextLong();\n		if(gcd(x,y)!=1) System.out.println(""Impossible"");\n		else\n		{\n			s="""";\n			while(x!=1&&y!=1)\n			{\n				if(x>y)\n				{\n					p=x/y;x=x%y;\n					s+=p+""A"";\n				}\n				else\n				{\n					p=y/x;y=y%x;\n					s+=p+""B"";\n				}\n			}\n			if(y==1) s+=(x-1)+""A"";\n			else s+=(y-1)+""B"";\n			System.out.println(s);\n		}\n	}\n}\n",number theory
"import java.util.Scanner;\n\npublic class Main {\n	static Scanner sc = new Scanner(System.in);\n\n	public static void main(String[] args) {\n		long X = sc.nextLong();\n		long Y = sc.nextLong();\n		System.out.println(solve(X, Y));\n	}\n\n	static String solve(long x, long y) {\n		StringBuilder sb = new StringBuilder();\n		while (x != y && x > 0 && y > 0) {\n			if (x > y) {\n				if (y == 1) {\n					sb.append((x - 1) + ""A"");\n					x = 1;\n					break;\n				}\n				sb.append((x / y) + ""A"");\n				x %= y;\n			} else {\n				if (x == 1) {\n					sb.append((y - 1) + ""B"");\n					y = 1;\n					break;\n				}\n				sb.append((y / x) + ""B"");\n				y %= x;\n			}\n		}\n		if (x == 1 && y == 1) {\n			return sb.toString();\n		} else {\n			return ""Impossible"";\n		}\n	}\n}\n",number theory
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF585C extends PrintWriter {\n	CF585C() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF585C o = new CF585C(); o.main(); o.flush();\n	}\n\n	long gcd(long a, long b) {\n		return b == 0 ? a : gcd(b, a % b);\n	}\n	void main() {\n		long x = sc.nextLong();\n		long y = sc.nextLong();\n		if (gcd(x, y) != 1) {\n			println(""Impossible"");\n			return;\n		}\n		StringBuilder sb = new StringBuilder();\n		while (x > 1 || y > 1) {\n			long k;\n			char c;\n			if (x > y) {\n				k = x / y;\n				if (y == 1)\n					k--;\n				x %= y;\n				c = 'A';\n			} else {\n				k = y / x;\n				if (x == 1)\n					k--;\n				y %= x;\n				c = 'B';\n			}\n			sb.append(k);\n			sb.append(c);\n		}\n		println(sb);\n	}\n}\n",number theory
"import java.util.*;\npublic class Main {\n	private static boolean prime(int m)\n	{\n		for(int i=2;i<=Math.sqrt(m);i++)\n		{\n			if(m%i==0)\n				return false;\n		}\n		return true;\n	}\npublic static void main(String[]arg)\n{\n	Scanner in=new Scanner(System.in);\n	int n=in.nextInt();\n	if(prime(n))\n	{\n		System.out.println(1);\n		System.out.println(n);\n	}\n	else if(prime(n-2))\n	{\n		System.out.println(2);\n		System.out.println(2+"" ""+(n-2));\n	}\n	else\n	{\n		int i=1;\n		while(!prime(n-i))\n			i++;\n		int m=i;\n		for(int y=2;y<=m/2;y++)\n		{\n			if(prime(y)&&prime(m-y))\n			{\n				System.out.println(3);\n				System.out.println((n-i)+"" ""+y+"" ""+(m-y));\n				break;\n			}\n		}\n			\n	}\n}\n}\n					 		    		    			    	 	 		","brute force,math,number theory"
"\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main {\n	static int mod = 1000000007;\n\n	public static void main(String[] args) {\n		// code\n		Scanner scn = new Scanner(System.in);\n	\n		int t = 1;\n		while (t > 0) {\n			t--;\n			int n = scn.nextInt();\n			if (n == 3) {\n				System.out.println(1 + ""\n"" + 3);\n				continue;\n			}\n\n			int p = n - 2;\n\n			while (checkprime(p) == false) {\n				p--;\n				continue;\n			}\n			//System.out.println(p);\n			int x = n - p;\n			for (int i = 2; i <= x; i++) {\n				if (checkprime(i) && checkprime(x - i)) {\n					if (x - i == 0) {\n						System.out.print(""2"" + ""\n"" + p + "" "" + i);\n					} else {\n						System.out.print(""3"" + ""\n"" + p + "" "" + i + "" "" + (x - i));\n					}\n					break;\n				}\n			}\n\n		}\n	}\n\n	public static boolean checkprime(int n) {\n		for (int i = 2; i <= Math.pow(n, 0.5); i++) {\n			if (n % i == 0) {\n				return false;\n			}\n		}\n		return true;\n	}\n}\n","brute force,math,number theory"
"import java.io.*;\nimport java.util.*;\nimport java.lang.*;\n\npublic class Rextester{\n    static boolean isPrime(int n){\n        for(int i=2;i<=Math.sqrt(n);i++){\n            if(n%i==0){\n                return false;\n            }\n        }\n        return true;\n    }\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        br.close();\n        if(isPrime(n)){\n            System.out.println(""1\n""+n);\n        }\n        else{\n            int[] ans = new int[3];\n            for(int i=2;i<=Math.sqrt(n);i+=2){\n                if(isPrime(n-i)){\n                    ans[2]=n-i;\n                    break;\n                }\n            }\n            if(n-ans[2]==2){\n                System.out.println(""2\n2 ""+(n-2));\n                return;\n            }\n            for(int i=2;i<n-ans[2];i++){\n                if(isPrime(i)&&isPrime(n-ans[2]-i)){\n                    ans[0]=i;\n                    ans[1]=n-ans[2]-i;\n                    break;\n                }\n            }\n            System.out.println(""3"");\n            for(int i=0;i<3;i++){\n                System.out.print(ans[i]+"" "");\n            }\n        }\n    }\n}","brute force,math,number theory"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Kraken\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    Scanner in = new Scanner(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskD solver = new TaskD();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskD {\n\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n      long n = in.nextLong();\n      if (prime(n)) {\n        out.printf(""%d\n%d\n"", 1, n);\n        return;\n      }\n      long k = n;\n      while (!prime(k))\n        k--;\n      n -= k;\n      assert (n % 2 == 0);\n      int[] si = new int[(int) n + 1];\n      for (int i = 2; i <= n; i++) {\n        if (si[i] != 0)\n          continue;\n        if (n == i) {\n          out.printf(""2\n%d %d\n"", k, n);\n          return;\n        }\n        if (prime(i) && prime(n - i)) {\n          out.printf(""3\n%d %d %d\n"", k, i, n - i);\n          return;\n        }\n        for (int j = i; j <= n; j += i)\n          si[i]++;\n      }\n      out.println(-1);\n    }\n\n    private boolean prime(long n) {\n      for (int i = 2; i <= Math.sqrt(n); i++)\n        if (n % i == 0)\n          return false;\n      return true;\n    }\n\n  }\n}\n\n","brute force,math,number theory"
import java.util.*;\npublic class Main\n{\n	public static int[] myArray = new int[4001];\n	public static int[][] mp = new int[4001][4001];\n \n	public static void main(String[] args) {\n		Scanner myInput= new Scanner(System.in);\n		int ans = 0;\n		int c = 0;\n		int n = myInput.nextInt();\n		int m = myInput.nextInt();\n		for(int i = 0; i < m; i++)\n		{\n			int a = myInput.nextInt();\n			int b = myInput.nextInt();\n			mp[a][b]=mp[b][a]=1;\n			myArray[a]++;myArray[b]++;\n		}\n		ans = -1;\n		for(int i = 1;i <= n; i++)\n		for(int j=i;j<=n;j++)\n		{\n			if(mp[i][j]==0){\n			    continue;\n			}\n			for(int k=1;k<=n;k++)\n			{\n				if(mp[i][k]!=1||mp[j][k]!=1){\n				    continue;\n				} \n				c=myArray[i]+myArray[j]+myArray[k]-6;\n				if(ans==-1||c<ans){\n				    ans = c;\n				} \n			}\n		}\n		System.out.println(ans);\n	}\n},"brute force,dfs and similar,graphs,hashing"
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class main{\n	public static void main (String[] args) throws java.lang.Exception{\n		int res = 4001;\n		int deg[] = new int [4001];\n		int mat[][] = new int [4001][4001];\n		Scanner in = new Scanner(System.in);\n    	int n = in.nextInt();\n    	int m = in.nextInt();\n    	for(int i = 0; i < m; ++i){\n    		int x = in.nextInt();\n    		int y = in.nextInt();\n        	mat[x][y] = mat[y][x] = 1; \n        	deg[x]++;\n    	   deg[y]++;\n    	}\n    	for(int i = 1; i <= n; ++i){\n    		for(int j = i + 1; j <= n; ++j){\n    			if(mat[i][j] == 1){\n    				for(int k = j + 1; k <= n; ++k) {\n						if(mat[i][k] == 1 && mat[j][k] == 1){\n							res = Math.min(res, deg[i] + deg[j] + deg[k]);\n						}	\n					}\n    			}\n    		}\n    	}\n    	if(res == 4001){\n    		System.out.print(-1);\n    	}\n		else{\n			System.out.print(res - 6);\n		}\n	}\n}","brute force,dfs and similar,graphs,hashing"
"import java.util.*;\n\npublic class Solve{\n    public static void main(String[] args){\n    Scanner sc=new Scanner(System.in);\n    int size=4005;\n    int ans=Integer.MAX_VALUE;\n    int max=ans;\n    int n=sc.nextInt();\n    int m=sc.nextInt();\n    int[] degree=new int[n+1];\n    int[][] ad=new int[size][size];\n    for(int i=0;i<m;i++){\n        int a=sc.nextInt();\n        int b=sc.nextInt();\n        ad[a][b]=ad[b][a]=1;\n        degree[a]++;\n        degree[b]++;\n        \n    }\n    for(int i=1;i<=n;i++){\n        for(int j=i+1;j<=n;j++){\n            if(ad[i][j]==1){\n                for(int k=j+1;k<=n;k++){\n                    if(ad[i][k]==1 && ad[j][k]==1){\n                        ans=Math.min(ans,degree[i]+degree[j]+degree[k]);\n                    }\n                }\n            }\n        }\n    }\n    \n    if(ans==max)System.out.println(""-1"");\n    else System.out.println(ans-6);\n    }\n}","brute force,dfs and similar,graphs,hashing"
"//Collaborated with no one\n//Written by Adinma Chidumije\nimport java.util.Scanner;\n\npublic class MainTest{\n	public static void main(String[] args){\n		Scanner sc= new Scanner(System.in); //System.in is a standard input stream  \n\n		int maxn = (int) (4e3+5);			 \n		int x [] = new int [maxn];  \n		int y[] = new int [maxn];\n		int arr [] = new int [maxn];\n		boolean g [][] = new boolean[maxn][maxn];	\n		int n,m;\n		\n		n = sc.nextInt();\n		m = sc.nextInt();\n		for(int i=0; i<m; i++)\n		{\n			x[i] = sc.nextInt();\n			y[i] = sc.nextInt();\n			g[x[i]][y[i]] = g[y[i]][x[i]] = true;\n			arr[x[i]]++;\n			arr[y[i]]++;\n		}\n		boolean ok= false;\n		int Min = 999999;\n		for(int i=0; i<m; i++)\n			for(int j=1; j<=n; j++)\n				if(g[x[i]][j] && g[j][y[i]] )\n					if(Min > arr[x[i]]+arr[j]+arr[y[i]])\n					{\n						Min = arr[x[i]]+arr[j]+arr[y[i]];\n						ok = true;\n					}\n		if (!ok) \n		{\n			System.out.print(""-1"");\n		}\n		else\n		{\n			System.out.printf(""%d\n"",Min-6);\n		}\n			sc.close();\n	}\n}\n\n	   				 	  	 	  	 	 					   	","brute force,dfs and similar,graphs,hashing"
"import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n	private ArrayList<ArrayList<Integer>> graph;\n	private boolean[] del;\n	private int[] legs;\n\n	public void solve() {\n		Scanner scanner = new Scanner(System.in);\n		int N = scanner.nextInt();\n		graph = new ArrayList<>();\n		for (int i = 0; i < N; i++) {\n			graph.add(new ArrayList<Integer>());\n		}\n		del = new boolean[N];\n		legs = new int[N];\n\n		for (int i = 0; i < N - 1; i++) {\n			int a = scanner.nextInt() - 1;\n			int b = scanner.nextInt() - 1;\n			graph.get(a).add(b);\n			graph.get(b).add(a);\n		}\n		scanner.close();\n\n		for (int i = 0; i < N; i++) {\n			if (graph.get(i).size() == 1) {\n				dfs(i, -1);\n			}\n		}\n		for (int i = 0; i < N; i++) {\n			for (int b : graph.get(i)) {\n				if (del[b]) {\n					legs[i] = Math.min(legs[i] + 1, 2);\n				}\n			}\n		}\n		for (int i = 0; i < N; i++) {\n			if (!del[i]) {\n				int cnt = 0;\n				for (int b : graph.get(i)) {\n					if (!del[b] && graph.get(b).size() - legs[b] > 1) {\n						cnt++;\n					}\n					if (cnt > 2) {\n						System.out.println(""No"");\n						return;\n					}\n				}\n			}\n		}\n		System.out.println(""Yes"");\n		return;\n\n	}\n\n	private void dfs(int now, int parent) {\n		if (graph.get(now).size() > 2) {\n			return;\n		}\n\n		del[now] = true;\n		for (int b : graph.get(now)) {\n			if (b != parent) {\n				dfs(b, now);\n			}\n		}\n	}\n\n	public static void main(String[] args) {\n		new Main().solve();\n	}\n}","constructive algorithms,dfs and similar,trees"
"import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n    static ArrayList<Integer> G[];\n    static int[] D;\n    static boolean[] F;\n    static int firstfail = -1;\n    \n    static boolean[] dfs(int x) {\n	boolean[] R = new boolean[4];\n	F[x] = true;\n	int cnt = 0, c2 = 0;\n	R[0] = R[1] = R[2] = R[3] = true;\n	for (Integer y : G[x]) {\n	    if (!F[y]) {\n		boolean[] C = dfs(y);\n		++cnt;\n		if (cnt > 1 || !C[3]) R[3] = false;\n		if (cnt > 2 || !C[3]) R[2] = false;\n		if (!C[2]) ++c2;\n		if (c2 > 1 || !C[1]) {if (firstfail < 0) firstfail = x; R[1] = false;}\n		if (c2 > 2 || !C[1]) R[0] = false;\n	    }\n	}\n	//System.out.println(x + "" "" + R[0] + "" "" + R[1] + "" "" + R[2] + "" "" + R[3] + "" "" + cnt + "" "" + c2);\n	return R;\n    }\n\n    public static void main(String args[]) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(in.readLine());\n        int R = 0;\n        G = new ArrayList[n];\n        D = new int[n];\n        \n        for (int i = 0; i < n; i++) G[i] = new ArrayList<Integer>();\n        for (int i = 1; i < n; i++) {\n    	    StringTokenizer t = new StringTokenizer(in.readLine());\n	    int a = Integer.parseInt(t.nextToken()) - 1;\n	    int b = Integer.parseInt(t.nextToken()) - 1;\n	    G[b].add(a);\n	    G[a].add(b);\n	    D[a]++;\n	    D[b]++;\n	    if (D[a] > 2) R = a;\n	    if (D[b] > 2) R = b;\n        }\n        F = new boolean[n];\n        boolean res = dfs(R)[0];\n        if (!res && firstfail >= 0) {\n    	    //System.err.println(""Failed at "" + firstfail + "", recalculating"");\n    	    F = new boolean[n];\n    	    res |= dfs(firstfail)[0];\n    	} \n    	System.out.println(res ? ""Yes"" : ""No"");\n    }\n}\n","constructive algorithms,dfs and similar,trees"
"import java.util.*;\nimport java.io.*;\n\npublic class C {\n	FastScanner in;\n	PrintWriter out;\n\n	ArrayList<Integer>[] g;\n	boolean[] del;\n	int[] leg;\n\n	void dfs(int v, int p) {\n		int deg = g[v].size() - (p != -1 ? 1 : 0);\n		if (deg <= 1) {\n			del[v] = true;\n			for (int u : g[v]) {\n				if (u != p) {\n					dfs(u, v);\n				}\n			}\n		} else {\n			leg[v]++;\n		}\n	}\n\n	public void solve() throws IOException {\n		int n = in.nextInt();\n		g = new ArrayList[n];\n		for (int i = 0; i < n; i++) {\n			g[i] = new ArrayList<>();\n		}\n		for (int i = 0; i < n - 1; i++) {\n			int a = in.nextInt() - 1, b = in.nextInt() - 1;\n			g[a].add(b);\n			g[b].add(a);\n		}\n		del = new boolean[n];\n		leg = new int[n];\n		for (int i = 0; i < n; i++) {\n			if (g[i].size() == 1 && !del[i]) {\n				dfs(i, -1);\n			}\n		}\n		for (int v = 0; v < n; v++) {\n			if (!del[v]) {\n				int cnt = 0;\n				for (int u : g[v]) {\n					if (!del[u]) {\n						if (leg[u] >= 3 || g[u].size() - leg[u] >= 2) {\n							cnt++;\n						}\n					}\n				}\n				if (cnt > 2) {\n					out.println(""No"");\n					return;\n				}\n			}\n		}\n		out.println(""Yes"");\n	}\n\n	public void run() {\n		try {\n			in = new FastScanner();\n			out = new PrintWriter(System.out);\n\n			solve();\n\n			out.close();\n		} catch (IOException e) {\n			e.printStackTrace();\n		}\n	}\n\n	class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		FastScanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		String next() {\n			while (st == null || !st.hasMoreTokens()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			}\n			return st.nextToken();\n		}\n\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n	}\n\n	public static void main(String[] arg) {\n		new C().run();\n	}\n}","constructive algorithms,dfs and similar,trees"
"import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Wuyouwulv {\n    private static final int maxn = 100010;\n    private static ArrayList<Integer> g[];\n    private static int[] legs = new int[maxn];\n    private static int[] degree = new int[maxn];\n    private static boolean[] del = new boolean[maxn];\n    \n    private static void dfs(int u, int pa) {\n        int sz = g[u].size();\n        if(sz > 2) {\n            legs[u] ++;\n            return;\n        }\n        del[u] = true;\n        for(int v : g[u]) {\n            if(v == pa) continue;\n            dfs(v, u);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        while(in.hasNext()) {\n            int n = in.nextInt();\n            g = new ArrayList[n];\n            for(int i=0;i<n;i++) g[i] = new ArrayList<Integer>();\n            for(int i=1;i<n;i++) {\n                int u , v;\n                u = in.nextInt() - 1;\n                v = in.nextInt() - 1;\n                g[u].add(v);\n                g[v].add(u);\n                degree[u] ++;\n                degree[v] ++;\n            }\n            for(int i=0;i<n;i++) {\n                if(!del[i] && degree[i] == 1) {\n                    dfs(i, -1);\n                }\n            }\n            for(int u=0;u<n;u++) {\n                if(!del[u] && degree[u] - Math.min(legs[u], 2) > 1) {\n                    int cnt = 0;\n                    for(int v : g[u]) {\n                        if(!del[v] && degree[v] - Math.min(legs[v], 2) > 1) {\n                            cnt ++;\n                            if(cnt > 2) {\n                                System.out.println(""No"");\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n            System.out.println(""Yes"");\n            return;\n        }\n    }\n}","constructive algorithms,dfs and similar,trees"
"//package round317;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class D {\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n	\n	void solve()\n	{\n		int n = ni(), m = ni();\n		int[][] qs = new int[m][];\n		for(int i = 0;i < m;i++){\n			char t = nc();\n			if(t == 'U' || t == 'M'){\n				qs[i] = new int[]{t, ni()-1, ni()-1};\n			}else{\n				qs[i] = new int[]{t, ni()-1};\n			}\n		}\n		\n		int[] mpar = new int[n+1];\n		int[] mtime = new int[n+1];\n		Arrays.fill(mpar, -1);\n		Arrays.fill(mtime, -1);\n		for(int i = 0;i < m;i++){\n			if(qs[i][0] == 'M'){\n				mpar[qs[i][2]] = qs[i][1];\n				mtime[qs[i][2]] = i;\n			}\n		}\n		for(int i = 0;i < n;i++){\n			if(mpar[i] == -1)mpar[i] = n;\n		}\n		int[][][] mgw = parentToG(mpar, mtime);\n		for(int i = 0;i < n+1;i++){\n			Arrays.sort(mgw[i], new Comparator<int[]>() {\n				public int compare(int[] a, int[] b) {\n					return -(a[1] - b[1]);\n				}\n			});\n		}\n		int[][] mg = new int[n+1][];\n		for(int i = 0;i < n+1;i++){\n			mg[i] = new int[mgw[i].length];\n			for(int j = 0;j < mgw[i].length;j++)mg[i][j] = mgw[i][j][0];\n		}\n		\n		int[][] mrights = makeRights(mg, mpar, n);\n		SegmentTreeOverwrite st = new SegmentTreeOverwrite(n+1);\n		int[] miord = mrights[1], mright = mrights[2];\n		int[] lastReset = new int[m];\n		Arrays.fill(lastReset, -1);\n		int[] mptr = new int[n+1];\n		for(int i = 0;i < n;i++){\n			mptr[i] = mg[i].length-1;\n		}\n		st.update(0, n+1, -1);\n		for(int i = 0;i < m;i++){\n			if(qs[i][0] == 'M'){\n				mptr[qs[i][1]]--;\n			}else if(qs[i][0] == 'Z'){\n				int y = qs[i][1];\n				int L = miord[y];\n				int R = mptr[y] == mg[y].length-1 ? L : mright[miord[mg[y][mptr[y]]]];\n				st.update(L, R+1, i);\n			}else if(qs[i][0] == 'Q'){\n				lastReset[i] = st.val(miord[qs[i][1]]);\n			}\n		}\n		\n		int[] upar = new int[n+1];\n		int[] utime = new int[n+1];\n		Arrays.fill(upar, -1);\n		Arrays.fill(utime, -1);\n		for(int i = 0;i < m;i++){\n			if(qs[i][0] == 'U'){\n				upar[qs[i][2]] = qs[i][1];\n				utime[qs[i][2]] = i;\n			}\n		}\n		for(int i = 0;i < n;i++){\n			if(upar[i] == -1)upar[i] = n;\n		}\n		int[][][] ugw = parentToG(upar, utime);\n		for(int i = 0;i < n+1;i++){\n			Arrays.sort(ugw[i], new Comparator<int[]>() {\n				public int compare(int[] a, int[] b) {\n					return -(a[1] - b[1]);\n				}\n			});\n		}\n		int[][] ug = new int[n+1][];\n		for(int i = 0;i < n+1;i++){\n			ug[i] = new int[ugw[i].length];\n			for(int j = 0;j < ugw[i].length;j++)ug[i][j] = ugw[i][j][0];\n		}\n		\n		int[][] es = new int[m][];\n		int p = 0;\n		for(int i = 0;i < m;i++){\n			if(lastReset[i] >= 0){\n				es[p++] = new int[]{lastReset[i], i};\n			}\n		}\n		Arrays.sort(es, 0, p, new Comparator<int[]>() {\n			public int compare(int[] a, int[] b) {\n				return a[0] - b[0];\n			}\n		});\n		\n		int[][] urights = makeRights(ug, upar, n);\n		int[] uiord = urights[1], uright = urights[2];\n		long[] ft = new long[n+2];\n		int[] uptr = new int[n+1];\n		for(int i = 0;i < n;i++){\n			uptr[i] = ug[i].length-1;\n		}\n		long[] ret = new long[m];\n		int pp = 0;\n		for(int i = 0;i < m;i++){\n			if(qs[i][0] == 'U'){\n				uptr[qs[i][1]]--;\n			}else if(qs[i][0] == 'A'){\n				int y = qs[i][1];\n				int L = uiord[y];\n				int R = uptr[y] == ug[y].length-1 ? L : uright[uiord[ug[y][uptr[y]]]];\n				addFenwick(ft, L, R-L+1);\n				addFenwick(ft, R+1, -(R-L+1));\n			}else if(qs[i][0] == 'Q'){\n				ret[i] += sumFenwick(ft, uiord[qs[i][1]]);\n				out.println(ret[i]);\n			}\n			while(pp < p && es[pp][0] <= i){\n				ret[es[pp][1]] -= sumFenwick(ft, uiord[qs[es[pp][1]][1]]);\n				pp++;\n			}\n		}\n		\n	}\n	\n	public static long sumFenwick(long[] ft, int i)\n	{\n		long sum = 0;\n		for(i++;i > 0;i -= i&-i)sum += ft[i];\n		return sum;\n	}\n	\n	public static void addFenwick(long[] ft, int i, long v)\n	{\n		if(v == 0)return;\n		int n = ft.length;\n		for(i++;i < n;i += i&-i)ft[i] += v;\n	}\n\n	\n	public static long[] restoreFenwick(long[] ft)\n	{\n		int n = ft.length-1;\n		long[] ret = new long[n];\n		for(int i = 0;i < n;i++)ret[i] = sumFenwick(ft, i);\n		for(int i = n-1;i >= 1;i--)ret[i] -= ret[i-1];\n		return ret;\n	}\n\n	public static class SegmentTreeOverwrite {\n		public int M, H, N;\n		public int[] cover;\n		public int I = Integer.MAX_VALUE;\n		\n		public SegmentTreeOverwrite(int n)\n		{\n			N = n;\n			M = Integer.highestOneBit(Math.max(N-1, 1))<<2;\n			H = M>>>1;\n			cover = new int[M];\n		}\n		\n		public void update(int l, int r, int v){ update(l, r, v, 0, H, 1); }\n		\n		private void update(int l, int r, int v, int cl, int cr, int cur)\n		{\n			if(l <= cl && cr <= r){\n				cover[cur] = v;\n			}else{\n				int mid = cl+cr>>>1;\n				if(cover[cur] != I){\n					cover[2*cur] = cover[2*cur+1] = cover[cur];\n					cover[cur] = I;\n				}\n				if(cl < r && l < mid){\n					update(l, r, v, cl, mid, 2*cur);\n				}\n				if(mid < r && l < cr){\n					update(l, r, v, mid, cr, 2*cur+1);\n				}\n			}\n		}\n		\n		public int val(int x) {\n			int ret = I;\n			for(int i = H+x;i >= 1;i>>>=1){\n				if(cover[i] != I)ret = cover[i];\n			}\n			return ret;\n		}\n	}\n	\n	public static int[] sortByPreorder(int[][] g, int root){\n		int n = g.length;\n		int[] stack = new int[n];\n		int[] ord = new int[n];\n		BitSet ved = new BitSet();\n		stack[0] = root;\n		int p = 1;\n		int r = 0;\n		ved.set(root);\n		while(p > 0){\n			int cur = stack[p-1];\n			ord[r++] = cur;\n			p--;\n			for(int e : g[cur]){\n				if(!ved.get(e)){\n					stack[p++] = e;\n					ved.set(e);\n				}\n			}\n		}\n		return ord;\n	}\n	\n	public static int[][] makeRights(int[][] g, int[] par, int root)\n	{\n		int n = g.length;\n		int[] ord = sortByPreorder(g, root);\n		int[] iord = new int[n];\n		for(int i = 0;i < n;i++)iord[ord[i]] = i;\n		\n		int[] right = new int[n];\n		for(int i = n-1;i >= 0;i--){\n			int v = i;\n			for(int e : g[ord[i]]){\n				if(e != par[ord[i]]){\n					v = Math.max(v, right[iord[e]]);\n				}\n			}\n			right[i] = v;\n		}\n		return new int[][]{ord, iord, right};\n	}\n	\n	public static int[][] parents(int[][] g)\n	{\n		int n = g.length;\n		int[] par = new int[n];\n		Arrays.fill(par, -1);\n\n		int[] q = new int[n];\n		int r = 0;\n		for(int u = 0;u < n;u++){\n			if(par[u] == -1){\n				q[r++] = u;\n				for(int p = r-1;p < r;p++) {\n					int cur = q[p];\n					for(int nex : g[cur]){\n						if(par[cur] != nex){\n							q[r++] = nex;\n							par[nex] = cur;\n						}\n					}\n				}\n			}\n		}\n		return new int[][] {par, q};\n	}\n\n	\n	public static int[][][] parentToG(int[] par, int[] time)\n	{\n		int n = par.length;\n		int[] ct = new int[n];\n		for(int i = 0;i < n;i++){\n			if(par[i] >= 0){\n				ct[i]++;\n				ct[par[i]]++;\n			}\n		}\n		int[][][] g = new int[n][][];\n		for(int i = 0;i < n;i++){\n			g[i] = new int[ct[i]][];\n		}\n		for(int i = 0;i < n;i++){\n			if(par[i] >= 0){\n				g[par[i]][--ct[par[i]]] = new int[]{i, time[i]};\n				g[i][--ct[i]] = new int[]{par[i], -2};\n			}\n		}\n		return g;\n	}\n	\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new D().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	private int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n	\n	private char[][] nm(int n, int m)\n	{\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n	\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n	\n	private int ni()\n	{\n		int num = 0, b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","binary search,data structures,dsu,trees"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		InputReader in = new InputReader(inputStream);\n		OutputWriter out = new OutputWriter(outputStream);\n		TaskD solver = new TaskD();\n		solver.solve(1, in, out);\n		out.close();\n	}\n\n	static class TaskD {\n		public void solve(int testNumber, InputReader in, OutputWriter out) {\n			int n = in.readInt();\n			int m = in.readInt();\n			IntList[] dormitories = new IntList[n];\n			IntList[] armies = new IntList[n];\n			for (int i = 0; i < n; i++) {\n				dormitories[i] = new IntArrayList(1);\n				dormitories[i].add(i);\n				armies[i] = new IntArrayList(1);\n				armies[i].add(i);\n			}\n			int[] ignoreArmyBefore = new int[n];\n			int[] lastExplicitArmy = new int[n];\n			Arrays.fill(ignoreArmyBefore, -1);\n			Arrays.fill(lastExplicitArmy, -1);\n			long[] baseQty = new long[n];\n			int[] baseQtyTime = new int[n];\n			Arrays.fill(baseQtyTime, -1);\n			IntList[] updateTimes = new IntList[n];\n			IntList[] updateCumulQtys = new IntList[n];\n			long[] allCumulUpds = new long[m + 1];\n			int cumulUpdsAt = 1;\n			AtomicInteger[] lastArmyVisits = new AtomicInteger[n];\n			for (int i = 0; i < n; i++) {\n				updateTimes[i] = new IntArrayList(1);\n				updateCumulQtys[i] = new IntArrayList(1);\n				updateCumulQtys[i].add(0);\n				lastArmyVisits[i] = new AtomicInteger(-1);\n			}\n			for (int i = 0; i < m; i++) {\n				char type = in.readCharacter();\n				if (type == 'U') {\n					int first = in.readInt() - 1;\n					int second = in.readInt() - 1;\n					if (dormitories[first].size() > dormitories[second].size()) {\n						int temp = first;\n						first = second;\n						second = temp;\n					}\n					IntList toAdd = dormitories[first];\n					dormitories[second].addAll(toAdd);\n					for (int current : toAdd.toArray()) {\n						int lastArmyVisit = lastArmyVisits[current].get();\n						if (lastArmyVisit < ignoreArmyBefore[current]) {\n							lastArmyVisit = lastExplicitArmy[current];\n						}\n						if (baseQtyTime[current] > lastArmyVisit) {\n							lastArmyVisit = baseQtyTime[current];\n						} else {\n							baseQty[current] = 0;\n						}\n						int lastNotNeededUpdate = get(updateTimes[current], lastArmyVisit);\n						baseQty[current] += allCumulUpds[updateCumulQtys[current].get(updateTimes[current].size())] - allCumulUpds[updateCumulQtys[current].get(lastNotNeededUpdate)];\n						baseQtyTime[current] = i;\n						dormitories[current] = dormitories[second];\n						updateTimes[current] = updateTimes[second];\n						updateCumulQtys[current] = updateCumulQtys[second];\n					}\n				} else if (type == 'M') {\n					int first = in.readInt() - 1;\n					int second = in.readInt() - 1;\n					if (armies[first].size() > armies[second].size()) {\n						int temp = first;\n						first = second;\n						second = temp;\n					}\n					IntList toAdd = armies[first];\n					armies[second].addAll(toAdd);\n					for (int current : toAdd.toArray()) {\n						int lastArmyVisit = lastArmyVisits[current].get();\n						if (lastArmyVisit > ignoreArmyBefore[current]) {\n							lastExplicitArmy[current] = lastArmyVisit;\n						}\n						ignoreArmyBefore[current] = i;\n						lastArmyVisits[current] = lastArmyVisits[second];\n						armies[current] = armies[second];\n					}\n				} else if (type == 'A') {\n					int id = in.readInt() - 1;\n					updateTimes[id].add(i);\n					allCumulUpds[cumulUpdsAt] = dormitories[id].size() + allCumulUpds[updateCumulQtys[id].back()];\n					updateCumulQtys[id].add(cumulUpdsAt++);\n				} else if (type == 'Z') {\n					int id = in.readInt() - 1;\n					lastArmyVisits[id].set(i);\n				} else {\n					int current = in.readInt() - 1;\n					int lastArmyVisit = lastArmyVisits[current].get();\n					if (lastArmyVisit < ignoreArmyBefore[current]) {\n						lastArmyVisit = lastExplicitArmy[current];\n					}\n					if (baseQtyTime[current] > lastArmyVisit) {\n						lastArmyVisit = baseQtyTime[current];\n					} else {\n						baseQty[current] = 0;\n					}\n					int lastNotNeededUpdate = get(updateTimes[current], lastArmyVisit);\n					baseQty[current] += allCumulUpds[updateCumulQtys[current].get(updateTimes[current].size())] - allCumulUpds[updateCumulQtys[current].get(lastNotNeededUpdate)];\n					baseQtyTime[current] = i;\n					out.printLine(baseQty[current]);\n				}\n			}\n		}\n\n		private int get(IntList time, int visit) {\n			int left = 0;\n			int right = time.size();\n			while (left < right) {\n				int middle = (left + right) >> 1;\n				if (time.get(middle) > visit) {\n					right = middle;\n				} else {\n					left = middle + 1;\n				}\n			}\n			return left;\n		}\n\n	}\n\n	static class IntArrayList extends IntList {\n		private int[] array;\n		private int size;\n\n		public IntArrayList() {\n			this(10);\n		}\n\n		public IntArrayList(int capacity) {\n			array = new int[capacity];\n		}\n\n		public IntArrayList(IntList list) {\n			this(list.size());\n			addAll(list);\n		}\n\n\n		public int get(int index) {\n			if (index >= size)\n				throw new IndexOutOfBoundsException();\n			return array[index];\n		}\n\n\n		public int size() {\n			return size;\n		}\n\n\n		public void add(int value) {\n			ensureCapacity(size + 1);\n			array[size++] = value;\n		}\n\n		public void ensureCapacity(int newCapacity) {\n			if (newCapacity > array.length) {\n				int[] newArray = new int[Math.max(newCapacity, array.length << 1)];\n				System.arraycopy(array, 0, newArray, 0, size);\n				array = newArray;\n			}\n		}\n\n\n		public int[] toArray() {\n			int[] array = new int[size];\n			System.arraycopy(this.array, 0, array, 0, size);\n			return array;\n		}\n\n	}\n\n	static interface IntIterator {\n		public int value();\n\n		public void advance();\n\n		public boolean isValid();\n\n	}\n\n	static class OutputWriter {\n		private final PrintWriter writer;\n\n		public OutputWriter(OutputStream outputStream) {\n			writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n		}\n\n		public OutputWriter(Writer writer) {\n			this.writer = new PrintWriter(writer);\n		}\n\n		public void close() {\n			writer.close();\n		}\n\n		public void printLine(long i) {\n			writer.println(i);\n		}\n\n	}\n\n	static abstract class IntCollection {\n		public abstract IntIterator iterator();\n\n		public abstract int size();\n\n		public abstract void add(int value);\n\n		public int[] toArray() {\n			int size = size();\n			int[] array = new int[size];\n			int i = 0;\n			for (IntIterator iterator = iterator(); iterator.isValid(); iterator.advance())\n				array[i++] = iterator.value();\n			return array;\n		}\n\n		public void addAll(IntCollection values) {\n			for (IntIterator it = values.iterator(); it.isValid(); it.advance()) {\n				add(it.value());\n			}\n		}\n\n	}\n\n	static class InputReader {\n		private InputStream stream;\n		private byte[] buf = new byte[1024];\n		private int curChar;\n		private int numChars;\n		private SpaceCharFilter filter;\n\n		public InputReader(InputStream stream) {\n			this.stream = stream;\n		}\n\n		public int read() {\n			if (numChars == -1)\n				throw new InputMismatchException();\n			if (curChar >= numChars) {\n				curChar = 0;\n				try {\n					numChars = stream.read(buf);\n				} catch (IOException e) {\n					throw new InputMismatchException();\n				}\n				if (numChars <= 0)\n					return -1;\n			}\n			return buf[curChar++];\n		}\n\n		public int readInt() {\n			int c = read();\n			while (isSpaceChar(c))\n				c = read();\n			int sgn = 1;\n			if (c == '-') {\n				sgn = -1;\n				c = read();\n			}\n			int res = 0;\n			do {\n				if (c < '0' || c > '9')\n					throw new InputMismatchException();\n				res *= 10;\n				res += c - '0';\n				c = read();\n			} while (!isSpaceChar(c));\n			return res * sgn;\n		}\n\n		public boolean isSpaceChar(int c) {\n			if (filter != null)\n				return filter.isSpaceChar(c);\n			return isWhitespace(c);\n		}\n\n		public static boolean isWhitespace(int c) {\n			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n		}\n\n		public char readCharacter() {\n			int c = read();\n			while (isSpaceChar(c))\n				c = read();\n			return (char) c;\n		}\n\n		public interface SpaceCharFilter {\n			public boolean isSpaceChar(int ch);\n\n		}\n\n	}\n\n	static abstract class IntList extends IntCollection implements Comparable<IntList> {\n		public abstract int get(int index);\n\n\n		public IntIterator iterator() {\n			return new IntIterator() {\n				private int size = size();\n				private int index = 0;\n\n				public int value() throws NoSuchElementException {\n					if (!isValid())\n						throw new NoSuchElementException();\n					return get(index);\n				}\n\n				public void advance() throws NoSuchElementException {\n					if (!isValid())\n						throw new NoSuchElementException();\n					index++;\n				}\n\n				public boolean isValid() {\n					return index < size;\n				}\n			};\n		}\n\n		public int back() {\n			return get(size() - 1);\n		}\n\n		public int hashCode() {\n			int hashCode = 1;\n			for (IntIterator i = iterator(); i.isValid(); i.advance())\n				hashCode = 31 * hashCode + i.value();\n			return hashCode;\n		}\n\n\n		public boolean equals(Object obj) {\n			if (!(obj instanceof IntList))\n				return false;\n			IntList list = (IntList) obj;\n			if (list.size() != size())\n				return false;\n			IntIterator i = iterator();\n			IntIterator j = list.iterator();\n			while (i.isValid()) {\n				if (i.value() != j.value())\n					return false;\n				i.advance();\n				j.advance();\n			}\n			return true;\n		}\n\n		public int compareTo(IntList o) {\n			IntIterator i = iterator();\n			IntIterator j = o.iterator();\n			while (true) {\n				if (i.isValid()) {\n					if (j.isValid()) {\n						if (i.value() != j.value()) {\n							if (i.value() < j.value())\n								return -1;\n							else\n								return 1;\n						}\n					} else\n						return 1;\n				} else {\n					if (j.isValid())\n						return -1;\n					else\n						return 0;\n				}\n				i.advance();\n				j.advance();\n			}\n		}\n\n	}\n}\n\n","binary search,data structures,dsu,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n        \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n    \n    static class OutputWriter {\n        PrintWriter writer;\n        \n        public OutputWriter(OutputStream stream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(stream), 32768));\n        }\n        \n        public void println(int x) {\n            writer.println(x);\n        }\n        \n        public void println(long x) {\n            writer.println(x);\n        }\n        \n        public <T> void print(T x) {\n            writer.print(x);\n        }\n        \n        public <T> void println(T x) {\n            writer.println(x);\n        }\n        \n        public void close() {\n            writer.close();\n        }\n    }\n    \n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        Task t = new Task();\n        t.solve(in, out);\n        out.close();\n    }\n    \n    static class Task {\n    \n        static class AbstractGraphBuilder {\n            int[] whereIsNode;\n            int iterator;\n            \n            public AbstractGraphBuilder(int n, int m) {\n                whereIsNode = new int[n + 1];\n                iterator = n;\n                for (int i = 1; i <= n; i++) {\n                    whereIsNode[i] = i;\n                }\n            }\n            \n            public int askWhereIsNode(int x) {\n                return whereIsNode[x];\n            }\n            \n            public void union(int x, int y) {\n                int z = (++iterator);\n                whereIsNode[x] = z;\n            }\n            \n            public int howManyVertices() {\n                return iterator;\n            }\n            \n            public void clear() {\n                whereIsNode = null;\n            }\n        }\n        \n        static class GraphBuilder {\n            AbstractGraphBuilder agb;\n            ArrayList<Integer>[] adj;\n            public int[] leafsCnt;\n            public int[] subtreeSz;\n            public int[] posInEuler;\n            boolean[] used;\n            int eulerIt;\n            \n            @SuppressWarnings(""unchecked"")\n            public GraphBuilder(int n, int m) {\n                int tmp = n + m + 1;\n                adj = (ArrayList<Integer>[])new ArrayList[tmp];\n                for (int i = 0; i < adj.length; i++) {\n                    adj[i] = new ArrayList<Integer>();\n                }\n                agb = new AbstractGraphBuilder(n, m);\n            }\n            \n            void addDirectedEdge(int x, int y) {\n                adj[x].add(y);\n            }\n            \n            public void union(int x, int y) {\n                int a = agb.askWhereIsNode(x);\n                int b = agb.askWhereIsNode(y);\n                agb.union(x, y);\n                int z = agb.askWhereIsNode(x);\n                addDirectedEdge(z, a);\n                addDirectedEdge(z, b);\n            }\n            \n            public int askWhereIsNode(int x) {\n                return agb.askWhereIsNode(x);\n            }\n            \n            public int howManyVertices() {\n                return agb.howManyVertices();\n            }\n            \n            void dfs(int v, int p) {\n                used[v] = true;\n                subtreeSz[v] = 1;\n                posInEuler[v] = eulerIt++;\n                leafsCnt[v] = 0;\n                \n                for (int to : adj[v]) {\n                    if (to == p) continue;\n                    dfs(to, v);\n                    subtreeSz[v] += subtreeSz[to];\n                    leafsCnt[v] += leafsCnt[to];\n                }\n                \n                if (subtreeSz[v] == 1) leafsCnt[v] = 1;\n            }\n            \n            void clear() {\n                agb.clear();\n                used = null;\n                adj = null;\n            }\n            \n            public void doCalculations() {\n                int n = howManyVertices();\n                eulerIt = 0;\n                leafsCnt = new int[n + 1];\n                subtreeSz = new int[n + 1];\n                posInEuler = new int[n + 1];\n                used = new boolean[n + 1];\n                \n                for (int v = n; v >= 1; v--) {\n                    if (!used[v]) {\n                        dfs(v, -1);\n                    }\n                }\n                \n                clear();\n            }\n        }\n        \n        static class Query {\n            final char type;\n            final int x;\n            final int y;\n            \n            public Query(char type, int x, int y) {\n                this.type = type;\n                this.x = x;\n                this.y = y;\n            }\n        }\n        \n        static class AskValueQuery {\n            int x;\n            long result;\n            AskValueQuery(int x) {\n                this.x = x;\n            }\n            public int getX() {\n                return x;\n            }\n            public void setResult(long result) {\n                this.result = result;\n            }\n            public long getResult() {\n                return result;\n            }\n        }\n        \n        static class FullAskQuery {\n            AskValueQuery l, r;\n            public FullAskQuery(AskValueQuery l, AskValueQuery r) {\n                this.l = l;\n                this.r = r;\n            }\n            public long getResult() {\n                return r.getResult() - l.getResult();\n            }\n        }\n        \n        Query[] queries;\n        ArrayList<AskValueQuery>[] askValueQueries;\n        FullAskQuery[] fullAskQueries;\n        GraphBuilder university, military;\n        int[] militaryTree;\n        \n        void buildMilitaryTree() {\n            militaryTree = new int[military.howManyVertices() * 4];\n        }\n        \n        void pushInMilitaryTree(int v) {\n            int l = v * 2 + 1;\n            int r = v * 2 + 2;\n            if (militaryTree[l] < militaryTree[v]) {\n                militaryTree[l] = militaryTree[v];\n            }\n            if (militaryTree[r] < militaryTree[v]) {\n                militaryTree[r] = militaryTree[v];\n            }\n        }\n        \n        void raidToMilitaryTreeRec(int v, int tl, int tr, int l, int r, int idx) {\n            if (tl == l && tr == r) {\n                militaryTree[v] = idx;\n                return;\n            }\n            pushInMilitaryTree(v);\n            int tm = (tl + tr) / 2;\n            if (r <= tm) {\n                raidToMilitaryTreeRec(v * 2 + 1, tl, tm, l, r, idx);\n            }\n            else if (l > tm) {\n                raidToMilitaryTreeRec(v * 2 + 2, tm + 1, tr, l, r, idx);\n            }\n            else {\n                raidToMilitaryTreeRec(v * 2 + 1, tl, tm, l, tm, idx);\n                raidToMilitaryTreeRec(v * 2 + 2, tm + 1, tr, tm + 1, r, idx);\n            }\n        }\n        \n        void raidToMilitaryTree(int l, int r, int idx) {\n            raidToMilitaryTreeRec(0, 0, military.howManyVertices() - 1, l, r, idx);\n        }\n        \n        int militaryTreeGet(int v, int tl, int tr, int pos) {\n            if (tl == tr) {\n                return militaryTree[v];\n            }\n            pushInMilitaryTree(v);\n            int tm = (tl + tr) / 2;\n            if (pos <= tm) {\n                return militaryTreeGet(v * 2 + 1, tl, tm, pos);\n            }\n            else {\n                return militaryTreeGet(v * 2 + 2, tm + 1, tr, pos);\n            }\n        }\n        \n        int getIdxOfLastRaid(int x) {\n            return militaryTreeGet(0, 0, military.howManyVertices() - 1, military.posInEuler[x]);\n        }\n        \n        long[] universityTree;\n        \n        void buildUniversityTree() {\n            universityTree = new long[university.howManyVertices() * 4];\n        }\n        \n        void addToUniversityTreeRec(int v, int tl, int tr, int l, int r, long val) {\n            if (tl == l && tr == r) {\n                universityTree[v] += val;\n                return;\n            }\n            int tm = (tl + tr) / 2;\n            if (r <= tm) {\n                addToUniversityTreeRec(v * 2 + 1, tl, tm, l, r, val);\n            }\n            else if (l > tm) {\n                addToUniversityTreeRec(v * 2 + 2, tm + 1, tr, l, r, val);\n            }\n            else {\n                addToUniversityTreeRec(v * 2 + 1, tl, tm, l, tm, val);\n                addToUniversityTreeRec(v * 2 + 2, tm + 1, tr, tm + 1, r, val);\n            }\n        }\n        \n        long universityTreeGet(int v, int tl, int tr, int pos) {\n            if (tl == tr) {\n                return universityTree[v];\n            }\n            int tm = (tl + tr) / 2;\n            if (pos <= tm) {\n                return universityTree[v] + universityTreeGet(v * 2 + 1, tl, tm, pos);\n            }\n            else {\n                return universityTree[v] + universityTreeGet(v * 2 + 2, tm + 1, tr, pos);\n            }\n        }\n        \n        long getValueInUniversity(int x) {\n            return universityTreeGet(0, 0, university.howManyVertices() - 1, university.posInEuler[x]);\n        }\n        \n        void addToUniversityTree(int l, int r, long val) {\n            addToUniversityTreeRec(0, 0, university.howManyVertices() - 1, l, r, val);\n        }\n        \n        @SuppressWarnings(""unchecked"")\n        public void solve(InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            \n            queries = new Query[m + 1];\n            askValueQueries = (ArrayList<AskValueQuery>[])new ArrayList[m + 1];\n            for (int i = 0; i < askValueQueries.length; i++) {\n                askValueQueries[i] = new ArrayList<AskValueQuery>();\n            }\n            fullAskQueries = new FullAskQuery[m + 1];\n            \n            for (int i = 1; i <= m; i++) {\n                char type = in.next().charAt(0);\n                int x = 0, y = 0;\n                if (type == 'U' || type == 'M') {\n                    x = in.nextInt();\n                    y = in.nextInt();\n                }\n                else {\n                    x = in.nextInt();\n                }\n                queries[i] = new Query(type, x, y);\n            }\n            \n            university = new GraphBuilder(n, m);\n            \n            for (int i = 1; i <= m; i++) {\n                if (queries[i].type == 'U') {\n                    university.union(queries[i].x, queries[i].y);\n                }\n            }\n            \n            university.doCalculations();\n            \n            military = new GraphBuilder(n, m);\n            \n            for (int i = 1; i <= m; i++) {\n                if (queries[i].type == 'M') {\n                    military.union(queries[i].x, queries[i].y);\n                }\n            }\n            \n            military.doCalculations();\n            \n            buildMilitaryTree();\n        \n            AbstractGraphBuilder abstractMilitary = new AbstractGraphBuilder(n, m);\n            \n            for (int i = 1; i <= m; i++) {\n                if (queries[i].type == 'M') {\n                    abstractMilitary.union(queries[i].x, queries[i].y);\n                }\n                else if (queries[i].type == 'Z') {\n                    int x = abstractMilitary.askWhereIsNode(queries[i].x);\n                    raidToMilitaryTree(military.posInEuler[x], military.posInEuler[x] + military.subtreeSz[x] - 1, i);\n                }\n                else if (queries[i].type == 'Q') {\n                    int x = queries[i].x;\n                    int idxOfLastRaid = getIdxOfLastRaid(queries[i].x);\n                    askValueQueries[idxOfLastRaid].add(new AskValueQuery(x));\n                    askValueQueries[i].add(new AskValueQuery(x));\n                    fullAskQueries[i] = new FullAskQuery(askValueQueries[idxOfLastRaid].get(askValueQueries[idxOfLastRaid].size() - 1),\n                                                        askValueQueries[i].get(askValueQueries[i].size() - 1));\n                }\n            }\n            \n            buildUniversityTree();\n            \n            AbstractGraphBuilder abstractUniversity = new AbstractGraphBuilder(n, m);\n            \n            for (int i = 1; i <= m; i++) {\n                if (queries[i].type == 'U') {\n                    abstractUniversity.union(queries[i].x, queries[i].y);\n                }\n                else if (queries[i].type == 'A') {\n                    int x = abstractUniversity.askWhereIsNode(queries[i].x);\n                    addToUniversityTree(university.posInEuler[x], university.posInEuler[x] + university.subtreeSz[x] - 1, university.leafsCnt[x]);\n                }\n                for (AskValueQuery q : askValueQueries[i]) {\n                    q.setResult(getValueInUniversity(q.getX()));\n                }\n            }\n            \n            for (FullAskQuery q : fullAskQueries) {\n                if (q != null) {\n                    out.println(q.getResult());\n                }\n            }\n            \n            out.close();\n        }\n    }\n}","binary search,data structures,dsu,trees"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            DCampus solver = new DCampus();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class DCampus {\n        int indicator;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.ri();\n            int m = in.ri();\n            Node[] U = new Node[n];\n            Node[] M = new Node[n];\n            for (int i = 0; i < n; i++) {\n                U[i] = new Node();\n                M[i] = new Node();\n            }\n            Node[] cloneU = U.clone();\n            Node[] cloneM = M.clone();\n            Query[] queries = new Query[m];\n            for (int i = 0; i < m; i++) {\n                char c = in.rc();\n                queries[i] = new Query();\n                queries[i].t = c;\n                queries[i].a = in.ri() - 1;\n                if (c == 'U' || c == 'M') {\n                    queries[i].b = in.ri() - 1;\n                    if (c == 'U') {\n                        Node node = new Node();\n                        node.left = U[queries[i].a];\n                        node.right = U[queries[i].b];\n                        U[queries[i].a] = node;\n                        U[queries[i].b] = null;\n                    } else {\n                        Node node = new Node();\n                        node.left = M[queries[i].a];\n                        node.right = M[queries[i].b];\n                        M[queries[i].a] = node;\n                        M[queries[i].b] = null;\n                    }\n                }\n            }\n\n            indicator = 0;\n            for (Node node : U) {\n                if (node == null) {\n                    continue;\n                }\n                allocId(node);\n            }\n            indicator = 0;\n            for (Node node : M) {\n                if (node == null) {\n                    continue;\n                }\n                allocId(node);\n            }\n            U = cloneU;\n            M = cloneM;\n            int[][] rangeU = new int[n][2];\n            int[][] rangeM = new int[n][2];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < 2; j++) {\n                    rangeU[i][j] = U[i].id;\n                    rangeM[i][j] = M[i].id;\n                }\n            }\n\n            RangeAffineRangeSum st = new RangeAffineRangeSum(0, n - 1);\n            st.init(0, n - 1, i -> 0);\n            int now = 0;\n\n            MultiWayStack<Query> delete = new MultiWayStack<>(m + 1, m);\n            MultiWayStack<Query> add = new MultiWayStack<>(m + 1, m);\n            for (Query q : queries) {\n                now++;\n                if (q.t == 'U') {\n                    //merge\n                } else if (q.t == 'M') {\n                    merge(rangeM[q.a], rangeM[q.b]);\n                } else if (q.t == 'A') {\n                } else if (q.t == 'Z') {\n                    st.update(rangeM[q.a][0], rangeM[q.a][1], 0, n - 1, 0, now);\n                } else if (q.t == 'Q') {\n                    int lastPurgeTime = (int) st.query(M[q.a].id, M[q.a].id, 0, n - 1);\n                    delete.addLast(lastPurgeTime, q);\n                    add.addLast(now, q);\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < 2; j++) {\n                    rangeU[i][j] = U[i].id;\n                    rangeM[i][j] = M[i].id;\n                }\n            }\n            st.init(0, n - 1, i -> 0);\n            now = 0;\n\n            for (Query q : queries) {\n                now++;\n                for (Query x : delete.getStack(now)) {\n                    x.ans -= st.query(U[x.a].id, U[x.a].id, 0, n - 1);\n                }\n                for (Query x : add.getStack(now)) {\n                    x.ans += st.query(U[x.a].id, U[x.a].id, 0, n - 1);\n                }\n\n                if (q.t == 'U') {\n                    //merge\n                    merge(rangeU[q.a], rangeU[q.b]);\n                } else if (q.t == 'M') {\n                } else if (q.t == 'A') {\n                    int len = rangeU[q.a][1] - rangeU[q.a][0] + 1;\n                    st.update(rangeU[q.a][0], rangeU[q.a][1], 0, n - 1, 1, len);\n                } else if (q.t == 'Z') {\n                } else if (q.t == 'Q') {\n                    out.println(q.ans);\n                }\n            }\n\n        }\n\n        public void merge(int[] a, int[] b) {\n            a[0] = Math.min(a[0], b[0]);\n            a[1] = Math.max(a[1], b[1]);\n        }\n\n        public void allocId(Node root) {\n            if (root.left == null) {\n                root.id = indicator++;\n                return;\n            }\n            allocId(root.left);\n            allocId(root.right);\n        }\n\n    }\n\n    static class Node {\n        Node left;\n        Node right;\n        int id;\n\n    }\n\n    static class RangeAffineRangeSum implements Cloneable {\n        private RangeAffineRangeSum left;\n        private RangeAffineRangeSum right;\n        private long sum;\n        private long da;\n        private long db;\n\n        private void modify(long a, long b) {\n            sum = (sum * a + b);\n            da = (da * a);\n            db = (db * a + b);\n        }\n\n        public void pushUp() {\n        }\n\n        public void pushDown() {\n            if (!(da == 1 && db == 0)) {\n                left.modify(da, db);\n                right.modify(da, db);\n                da = 1;\n                db = 0;\n            }\n        }\n\n        public RangeAffineRangeSum(int l, int r) {\n            if (l < r) {\n                int m = DigitUtils.floorAverage(l, r);\n                left = new RangeAffineRangeSum(l, m);\n                right = new RangeAffineRangeSum(m + 1, r);\n                pushUp();\n            }\n        }\n\n        public void init(int l, int r, IntToIntegerFunction function) {\n            da = 1;\n            db = 0;\n            if (l < r) {\n                int m = DigitUtils.floorAverage(l, r);\n                left.init(l, m, function);\n                right.init(m + 1, r, function);\n                pushUp();\n            } else {\n                sum = function.apply(l);\n            }\n        }\n\n        private boolean covered(int ll, int rr, int l, int r) {\n            return ll <= l && rr >= r;\n        }\n\n        private boolean noIntersection(int ll, int rr, int l, int r) {\n            return ll > r || rr < l;\n        }\n\n        public void update(int ll, int rr, int l, int r, long a, long b) {\n            if (noIntersection(ll, rr, l, r)) {\n                return;\n            }\n            if (covered(ll, rr, l, r)) {\n                modify(a, b);\n                return;\n            }\n            pushDown();\n            int m = DigitUtils.floorAverage(l, r);\n            left.update(ll, rr, l, m, a, b);\n            right.update(ll, rr, m + 1, r, a, b);\n            pushUp();\n        }\n\n        public long query(int ll, int rr, int l, int r) {\n            if (noIntersection(ll, rr, l, r)) {\n                return 0;\n            }\n            if (covered(ll, rr, l, r)) {\n                return sum;\n            }\n            pushDown();\n            int m = DigitUtils.floorAverage(l, r);\n            return left.query(ll, rr, l, m) +\n                    right.query(ll, rr, m + 1, r);\n        }\n\n        private RangeAffineRangeSum deepClone() {\n            RangeAffineRangeSum seg = clone();\n            if (seg.left != null) {\n                seg.left = seg.left.deepClone();\n            }\n            if (seg.right != null) {\n                seg.right = seg.right.deepClone();\n            }\n            return seg;\n        }\n\n        protected RangeAffineRangeSum clone() {\n            try {\n                return (RangeAffineRangeSum) super.clone();\n            } catch (CloneNotSupportedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        private void toString(StringBuilder builder) {\n            if (left == null && right == null) {\n                builder.append(sum).append("","");\n                return;\n            }\n            pushDown();\n            left.toString(builder);\n            right.toString(builder);\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            deepClone().toString(builder);\n            if (builder.length() > 0) {\n                builder.setLength(builder.length() - 1);\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static class Query {\n        char t;\n        int a;\n        int b;\n        long ans;\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static int floorAverage(int x, int y) {\n            return (x & y) + ((x ^ y) >> 1);\n        }\n\n    }\n\n    static interface SimplifiedStack<T> extends Iterable<T> {\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int ri() {\n            return readInt();\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public char rc() {\n            return readChar();\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n    }\n\n    static class MultiWayStack<T> {\n        private Object[] values;\n        private int[] next;\n        private int[] heads;\n        private int alloc;\n        private int stackNum;\n\n        public RevokeIterator<T> iterator(final int queue) {\n            return new RevokeIterator<T>() {\n                int ele = heads[queue];\n                int pre = 0;\n\n\n                public boolean hasNext() {\n                    return ele != 0;\n                }\n\n\n                public T next() {\n                    T ans = (T) values[ele];\n                    pre = ele;\n                    ele = next[ele];\n                    return ans;\n                }\n\n\n                public void revoke() {\n                    ele = pre;\n                    pre = 0;\n                }\n            };\n        }\n\n        public SimplifiedStack<T> getStack(int qId) {\n            return new SimplifiedStack<T>() {\n\n                public boolean isEmpty() {\n                    return MultiWayStack.this.isEmpty(qId);\n                }\n\n\n                public T peekLast() {\n                    return MultiWayStack.this.peekLast(qId);\n                }\n\n\n                public void addLast(T x) {\n                    MultiWayStack.this.addLast(qId, x);\n                }\n\n\n                public T removeLast() {\n                    return MultiWayStack.this.removeLast(qId);\n                }\n\n\n                public Iterator<T> iterator() {\n                    return MultiWayStack.this.iterator(qId);\n                }\n            };\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            values = Arrays.copyOf(values, newSize);\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n        }\n\n        public boolean isEmpty(int qId) {\n            return heads[qId] == 0;\n        }\n\n        public MultiWayStack(int qNum, int totalCapacity) {\n            values = new Object[totalCapacity + 1];\n            next = new int[totalCapacity + 1];\n            heads = new int[qNum];\n            stackNum = qNum;\n        }\n\n        public void addLast(int qId, T x) {\n            alloc();\n            values[alloc] = x;\n            next[alloc] = heads[qId];\n            heads[qId] = alloc;\n        }\n\n        public T peekLast(int qId) {\n            return (T) values[heads[qId]];\n        }\n\n        public T removeLast(int qId) {\n            T ans = (T) values[heads[qId]];\n            heads[qId] = next[heads[qId]];\n            return ans;\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < stackNum; i++) {\n                builder.append(i).append("": "");\n                for (Iterator iterator = iterator(i); iterator.hasNext(); ) {\n                    builder.append(iterator.next()).append("","");\n                }\n                if (builder.charAt(builder.length() - 1) == ',') {\n                    builder.setLength(builder.length() - 1);\n                }\n                builder.append('\n');\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static interface RevokeIterator<E> extends Iterator<E> {\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 1 << 13;\n        private final Writer os;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(long c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(String c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput println(long c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            return append(System.lineSeparator());\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static interface IntToIntegerFunction {\n        int apply(int x);\n\n    }\n}\n\n","binary search,data structures,dsu,trees"
"import java.util.Scanner;\n\npublic class Main {\n\n	public void solve() {\n		Scanner scanner = new Scanner(System.in);\n		char[] string = scanner.next().toCharArray();\n		int L = string.length;// 文字列の長さ\n\n		int K = scanner.nextInt();\n		scanner.close();\n\n		// dp[i][j]:= iからjまでの部分文字列が半回文かどうか\n		boolean[][] dp = new boolean[L][L];\n\n		// deques[x]:= xを始点にした半回文が長さ順に並んでいる\n		MyDeque[] deques = new MyDeque[L];\n		for (int i = 0; i < L; i++) {\n			deques[i] = new MyDeque(L);\n		}\n\n		// 短い方から半回文を列挙する\n		for (int length = 0; length < L; length++) {\n			for (int x = 0; x + length < L; x++) {\n				int y = x + length;\n				if (string[x] == string[y] && (length <= 3 || dp[x + 2][y - 2])) {\n					dp[x][x + length] = true;\n					deques[x].add(x + length);\n				}\n			}\n		}\n\n		StringBuilder ans = new StringBuilder();\n		for (int i = 0; i < L; i++) {\n			// i文字目を決める\n			int finished = 0;// 解答の文字列とi-1文字目まで同じで、長さがi-1の文字列の数\n			int a = 0;// i文字目が 'a' となる文字列の合計\n			for (int x = 0; x < L; x++) {\n				if (deques[x].isEmpty()) {\n					continue;\n				}\n				if (deques[x].peek() < x + i) {\n					// i文字より小さい文字列は削除しておく\n					finished++;\n					deques[x].poll();\n				}\n				if (!deques[x].isEmpty() && string[x + i] == 'a') {\n					a += deques[x].size();\n				}\n			}\n\n			if (K <= finished) {\n				break;\n			}\n			K -= finished;\n\n			if (K <= a) {\n				// i文字目がaとなる場合\n				ans.append('a');\n				for (int x = 0; x + i < L; x++) {\n					// i文字目が 'b'となる文字列は、もう候補になりえないので全て削除する\n					if (!deques[x].isEmpty() && string[x + i] == 'b') {\n						deques[x].clear();\n					}\n				}\n			} else {\n				// i文字目がbとなる場合\n				K -= a;\n				ans.append('b');\n				for (int x = 0; x + i < L; x++) {\n					// i文字目がaとなる文字列は全て削除する　\n					if (!deques[x].isEmpty() && string[x + i] == 'a') {\n						deques[x].clear();\n					}\n				}\n			}\n		}\n		System.out.println(ans.toString());\n	}\n\n	public static void main(String[] args) {\n		new Main().solve();\n	}\n}\n\n// ArrayDequeを自分で作る\nclass MyDeque {\n	int[] nums;\n	int size, cur;\n\n	public MyDeque(int N) {\n		this.nums = new int[N];\n		this.size = 0;\n		this.cur = 0;\n	}\n\n	public void add(int a) {\n		nums[size] = a;\n		size++;\n	}\n\n	public int poll() {\n		if (size == 0) {\n			return -1;\n		}\n		cur++;\n		size--;\n		return nums[cur - 1];\n	}\n\n	public int size() {\n		return size;\n	}\n\n	public boolean isEmpty() {\n		return size == 0;\n	}\n\n	public int peek() {\n		if (size == 0) {\n			return -1;\n		}\n		return nums[cur];\n	}\n\n	public void clear() {\n		size = 0;\n		cur = 0;\n	}\n}","data structures,dp,graphs,string suffix structures,strings,trees"
"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n	public void solve() {\n		Scanner scanner = new Scanner(System.in);\n		char[] S = scanner.next().toCharArray();\n		int L = S.length;// 文字列の長さ\n		boolean[] string = new boolean[L];\n		for (int i = 0; i < L; i++) {\n			if (S[i] == 'a') {\n				string[i] = true;\n			}\n		}\n\n		int K = scanner.nextInt();\n		scanner.close();\n\n		// dp[i][j]:= iからjまでの部分文字列が半回文かどうか\n		boolean[][] dp = new boolean[L][L];\n\n		// deques[x]:= xを始点にした半回文が長さ順に並んでいる\n		Node[] deques = new Node[L];\n		for (int i = 0; i < L; i++) {\n			deques[i] = new Node(L);\n		}\n\n		// 短い方から半回文を列挙する\n		for (int length = 0; length < L; length++) {\n			for (int x = 0; x + length < L; x++) {\n				if (string[x] == string[x + length] && (length <= 3 || dp[x + 2][x + length - 2])) {\n					dp[x][x + length] = true;\n					deques[x].add(x + length);\n				}\n			}\n		}\n\n		StringBuilder ans = new StringBuilder();\n		for (int i = 0; i < L; i++) {\n			// i文字目を決める\n			int finished = 0;// 解答の文字列とi-1文字目まで同じで、長さがi-1の文字列の数\n			int a = 0;// i文字目が 'a' となる文字列の合計\n			for (int x = 0; x < L; x++) {\n				if (deques[x].isEmpty()) {\n					continue;\n				}\n				if (deques[x].peek() < x + i) {\n					// i文字より小さい文字列は削除しておく\n					finished++;\n					deques[x].poll();\n				}\n				if (!deques[x].isEmpty() && string[x + i]) {\n					a += deques[x].size();\n				}\n			}\n\n			if (K <= finished) {\n				break;\n			}\n			K -= finished;\n\n			if (K <= a) {\n				// i文字目がaとなる場合\n				ans.append('a');\n				for (int x = 0; x + i < L; x++) {\n					// i文字目が 'b'となる文字列は、もう候補になりえないので全て削除する\n					if (!deques[x].isEmpty() && !string[x + i]) {\n						deques[x].clear();\n					}\n				}\n			} else {\n				// i文字目がbとなる場合\n				K -= a;\n				ans.append('b');\n				for (int x = 0; x + i < L; x++) {\n					// i文字目がaとなる文字列は全て削除する　\n					if (!deques[x].isEmpty() && string[x + i]) {\n						deques[x].clear();\n					}\n				}\n			}\n		}\n		System.out.println(ans.toString());\n	}\n\n	public static void main(String[] args) {\n		new Main().solve();\n	}\n}\n\nclass Node {\n	int[] nums;\n	int size, cur;\n\n	public Node(int N) {\n		this.nums = new int[N];\n		this.size = 0;\n		this.cur = 0;\n	}\n\n	public void add(int a) {\n		nums[size] = a;\n		size++;\n	}\n\n	public int poll() {\n		cur++;\n		size--;\n		return nums[cur - 1];\n	}\n\n	public int size() {\n		return size;\n	}\n\n	public boolean isEmpty() {\n		return size == 0;\n	}\n\n	public int peek() {\n		return nums[cur];\n	}\n\n	public void clear() {\n		Arrays.fill(nums, 0);\n		size = 0;\n		cur = 0;\n	}\n}","data structures,dp,graphs,string suffix structures,strings,trees"
"import java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class CF557E {\n	int[] last;\n	boolean[][] isPalin; // is half Palindrome\n	void findPalindromes() {\n		int n = s.length;\n		last = new int[n];\n		isPalin = new boolean[n][n];\n		for(int i =  0 ; i < n ; i++) { // base cases\n			isPalin[i][i] = true; // check all length 1's\n			last[i] = i;\n			if(i < n - 1 && s[i] == s[i + 1]) { // check all length 2's\n				isPalin[i][i + 1] = true;\n				last[i] = i + 1;\n			}\n			if(i < n - 2 && s[i] == s[i + 2]) { // check all length 3's\n				isPalin[i][i + 2] = true;\n				last[i] = i + 2;\n			}\n			if(i < n - 3 && s[i] == s[i + 3]) { // check all length 4's\n				isPalin[i][i + 3] = true;\n				last[i] = i + 3;\n			}\n		}\n		for(int len = 4 ; len < n ; len++) {\n			for(int i = 0 ; i < n - len ; i++) {\n				int j = i + len;\n				if(s[i] == s[j] && isPalin[i + 2][j - 2]) {\n					isPalin[i][j] = true;\n					last[i] = j;\n				}\n			}\n		}\n	}\n	void addStrings() {\n		int n = s.length;\n		numNodes = 1 + ((n * (n + 1)) / 2);\n		next = 1;\n		cnt = new int[numNodes];\n		end = new int[numNodes];\n		prev = new int[numNodes];\n		trie = new int[2][numNodes];\n		int node = 0;\n		for(int i = 0 ; i < n ; i++) {\n			for(int j = i ; j <= last[i] ; j++) {\n				int let = s[j] - 'a';\n				if(trie[let][node] == 0)\n					trie[let][node] = next++;\n				prev[trie[let][node]] = node;\n				node = trie[let][node];\n				if(isPalin[i][j]) end[node]++;\n			}\n			while(true) {\n				int newcnt = 0;\n				for(int let = 0 ; let < 2 ; let++)\n					if(trie[let][node] != 0)\n						newcnt += cnt[trie[let][node]];\n				cnt[node] = end[node] + newcnt;\n				if(node == 0) break;\n				node = prev[node];\n			}\n		}\n	}\n	char[] s;\n	int next, numNodes, prev[], cnt[], end[], trie[][];\n	public CF557E() {\n		FS scan = new FS();\n		PrintWriter out = new PrintWriter(System.out);\n		s = scan.next().toCharArray();\n		int k = scan.nextInt();\n		findPalindromes();\n		addStrings();\n		int node = 0;\n		int numStrings = 0;\n		StringBuilder res = new StringBuilder();\n		char[] letter = {'a', 'b'};\n		while(true) {\n			numStrings += end[node];\n			if(numStrings >= k) break;\n			for(int let = 0 ; let < 2 ; let++) {\n				if(trie[let][node] != 0) {\n					if(numStrings + cnt[trie[let][node]] >= k) {\n						res.append(letter[let]);\n						node = trie[let][node];\n						break;\n					} else {\n						numStrings += cnt[trie[let][node]];\n					}\n				}\n			}\n		}\n		out.println(res);\n		out.close();\n	}\n	class FS {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer("""");\n		public String next() {\n			while(!st.hasMoreTokens()) {\n				try { st = new StringTokenizer(br.readLine()); }\n				catch(Exception e) { e.printStackTrace(); }\n			}\n			return st.nextToken();\n		}\n		public int nextInt() { return Integer.parseInt(next()); }\n	}\n	public static void main(String[] args) { new CF557E(); }\n}\n","data structures,dp,graphs,string suffix structures,strings,trees"
"import java.util.Scanner;\n\npublic class Main {\n\n	public void solve() {\n		Scanner scanner = new Scanner(System.in);\n		char[] S = scanner.next().toCharArray();\n		int L = S.length;// 文字列の長さ\n		boolean[] string = new boolean[L];\n		for (int i = 0; i < L; i++) {\n			if (S[i] == 'a') {\n				string[i] = true;\n			}\n		}\n\n		int K = scanner.nextInt();\n		scanner.close();\n\n		// dp[i][j]:= iからjまでの部分文字列が半回文かどうか\n		boolean[][] dp = new boolean[L][L];\n\n		// deques[x]:= xを始点にした半回文が長さ順に並んでいる\n		MyDeque[] deques = new MyDeque[L];\n		for (int i = 0; i < L; i++) {\n			deques[i] = new MyDeque(L);\n		}\n\n		// 短い方から半回文を列挙する\n		for (int length = 0; length < L; length++) {\n			for (int x = 0; x + length < L; x++) {\n				if (string[x] == string[x + length] && (length <= 3 || dp[x + 2][x + length - 2])) {\n					dp[x][x + length] = true;\n					deques[x].add(x + length);\n				}\n			}\n		}\n\n		StringBuilder ans = new StringBuilder();\n		for (int i = 0; i < L; i++) {\n			// i文字目を決める\n			int finished = 0;// 解答の文字列とi-1文字目まで同じで、長さがi-1の文字列の数\n			int a = 0;// i文字目が 'a' となる文字列の合計\n			for (int x = 0; x < L; x++) {\n				if (deques[x].isEmpty()) {\n					continue;\n				}\n				if (deques[x].peek() < x + i) {\n					// i文字より小さい文字列は削除しておく\n					finished++;\n					deques[x].poll();\n				}\n				if (!deques[x].isEmpty() && string[x + i]) {\n					a += deques[x].size();\n				}\n			}\n\n			if (K <= finished) {\n				break;\n			}\n			K -= finished;\n\n			if (K <= a) {\n				// i文字目がaとなる場合\n				ans.append('a');\n				for (int x = 0; x + i < L; x++) {\n					// i文字目が 'b'となる文字列は、もう候補になりえないので全て削除する\n					if (!deques[x].isEmpty() && !string[x + i]) {\n						deques[x].clear();\n					}\n				}\n			} else {\n				// i文字目がbとなる場合\n				K -= a;\n				ans.append('b');\n				for (int x = 0; x + i < L; x++) {\n					// i文字目がaとなる文字列は全て削除する　\n					if (!deques[x].isEmpty() && string[x + i]) {\n						deques[x].clear();\n					}\n				}\n			}\n		}\n		System.out.println(ans.toString());\n	}\n\n	public static void main(String[] args) {\n		new Main().solve();\n	}\n}\n\n// ArrayDequeを自分で作る\nclass MyDeque {\n	int[] nums;\n	int size, cur;\n\n	public MyDeque(int N) {\n		this.nums = new int[N];\n		this.size = 0;\n		this.cur = 0;\n	}\n\n	public void add(int a) {\n		nums[size] = a;\n		size++;\n	}\n\n	public int poll() {\n		if (size == 0) {\n			return -1;\n		}\n		cur++;\n		size--;\n		return nums[cur - 1];\n	}\n\n	public int size() {\n		return size;\n	}\n\n	public boolean isEmpty() {\n		return size == 0;\n	}\n\n	public int peek() {\n		if (size == 0) {\n			return -1;\n		}\n		return nums[cur];\n	}\n\n	public void clear() {\n		size = 0;\n		cur = 0;\n	}\n}","data structures,dp,graphs,string suffix structures,strings,trees"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Solution{\n    static class IScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public IScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    static Solution.IScanner in = new IScanner();\n    static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        int n = in.nextInt();\n        int[] H = new int[100001];\n        int[][] E = new int[201][100001];\n\n        int[] L = new int[n];\n        for (int i = 0; i < n; i++){\n             L[i] = in.nextInt();\n             H[L[i]]++;\n        }\n\n        for (int i = 0; i < n; i++){\n            E[in.nextInt()][L[i]]++;\n        }\n\n        for (int i = 0; i < E.length; i++){\n            for (int j = 1; j < E[i].length; j++){\n                E[i][0] += E[i][j];\n            }\n        }\n\n        int ans = Integer.MAX_VALUE;\n        int suffix = 0, count = 0;\n        for (int max = 100000; max >= 1; max--){\n            if(H[max] != 0){\n                int toBeDeleted = n - (H[max] + H[max] - 1) - count;\n                int minEnergy = suffix;\n                for (int j = 1; j <= 200 && toBeDeleted > 0; j++){\n                    int temp = E[j][0] - E[j][max];\n                    if(temp >= toBeDeleted){\n                        minEnergy += toBeDeleted * j;\n                        toBeDeleted = 0;\n                    }else{\n                        toBeDeleted -= temp;\n                        minEnergy += temp * j;\n                    }\n                }\n\n                if(toBeDeleted <= 0)\n                    ans = Math.min(ans, minEnergy);\n\n                for (int j = 1; j <= 200; j++){\n                    E[j][0] -= E[j][max];\n                    count += E[j][max];\n                    suffix += j * E[j][max];\n                }\n            }\n        }\n        out.println(ans);\n        out.flush();\n        out.close();\n    }\n}","brute force,data structures,dp,greedy,math,sortings"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Solution{\n    static class IScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public IScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    static Solution.IScanner in = new IScanner();\n    static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        int n = in.nextInt();\n        int[] H = new int[100001];\n        int[][] E = new int[201][100001];\n\n        int[] L = new int[n];\n        for (int i = 0; i < n; i++){\n             L[i] = in.nextInt();\n             H[L[i]]++;\n        }\n\n        for (int i = 0; i < n; i++){\n            E[in.nextInt()][L[i]]++;\n        }\n\n        for (int i = 0; i < E.length; i++){\n            for (int j = 1; j < E[i].length; j++){\n                E[i][0] += E[i][j];\n            }\n        }\n\n\n\n        int ans = Integer.MAX_VALUE;\n        int suffix = 0;\n        int count = 0;\n        for (int max = 100000; max >= 1; max--){\n            if(H[max] != 0){\n                int toBeDeleted = n - (H[max] + H[max] - 1) - count;\n                toBeDeleted = toBeDeleted < 0 ? 0 : toBeDeleted;\n                int minEnergy = suffix;\n                for (int j = 1; j <= 200 && toBeDeleted > 0; j++){\n                    int temp = E[j][0] - E[j][max];\n                    if(temp >= toBeDeleted){\n                        minEnergy += toBeDeleted * j;\n                        toBeDeleted = 0;\n                    }else{\n                        toBeDeleted -= temp;\n                        minEnergy += temp * j;\n                    }\n                }\n\n                if(toBeDeleted == 0)\n                    ans = Math.min(ans, minEnergy);\n\n                for (int j = 1; j <= 200; j++){\n                    E[j][0] -= E[j][max];\n                    count += E[j][max];\n                    suffix += j * E[j][max];\n                }\n\n            }\n        }\n        out.println(ans);\n        out.flush();\n        out.close();\n\n    }\n}","brute force,data structures,dp,greedy,math,sortings"
"\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n\n	static long sx = 0, sy = 0, mod = (long) (1e9 + 7);\n\n	// static HashSet<Integer>[] a;\n	static Double[][][] dp;\n	static long[] fa;\n	static long[] farr;\n	public static PrintWriter out = new PrintWriter(System.out);\n	static ArrayList<pair> pa = new ArrayList<>();\n	static long[] fact = new long[(int) 1e6];\n	static StringBuilder sb = new StringBuilder();\n	static boolean cycle = false;\n	static long m = 998244353;\n	static long[] no, col;\n	static String s;\n	static long k = 0, n = 0, one = 0;\n	static int cnt;\n	// static long[] dp;\n	static long[] p;\n	static long[] ans;\n	static Double[][] a = new Double[2][2];\n	static Double[][] b = new Double[2][2];\n	static Double[] x;\n	static Double[] y;\n	static Double[] dis;\n\n	public static void main(String[] args) throws IOException {\n\n		// Scanner scn = new Scanner(new BufferedReader(new\n		// InputStreamReader(System.in)));\n\n		Reader scn = new Reader();\n\n		int n = scn.nextInt();\n		int[] l = scn.nextIntArray(n);\n		int[] d = scn.nextIntArray(n);\n\n		TreeMap<Integer, ArrayList<Integer>> hm = new TreeMap<>();\n\n		int tot = 0;\n\n		for (int i = 0; i < n; i++) {\n\n			if (!hm.containsKey(l[i]))\n				hm.put(l[i], new ArrayList<>());\n			hm.get(l[i]).add(d[i]);\n\n			tot += d[i];\n		}\n\n//		System.out.println(hm);\n//		System.out.println(tot);\n		int ans = Integer.MAX_VALUE;\n\n		int[] prev = new int[201];\n\n		for (int v : hm.keySet()) {\n\n			int sum = 0;\n			for (int i : hm.get(v))\n				sum += i;\n\n			int cnt = hm.get(v).size() - 1;\n\n			for (int i = 200; i >= 1; i--) {\n\n				int x = Math.min(cnt, prev[i]);\n				sum += i * x;\n				cnt -= x;\n			}\n\n			ans = Math.min(ans, tot - sum);\n\n			for (int i : hm.get(v))\n				prev[i]++;\n		}\n\n		System.out.println(ans);\n	}\n\n	// _________________________TEMPLATE_____________________________________________________________\n\n	// public static long lcm(long x, long y) {\n	//\n	// return (x * y) / gcd(x, y);\n	// }\n	//\n	// private static long gcd(long x, long y) {\n	// if (x == 0)\n	// return y;\n	//\n	// return gcd(y % x, x);\n	// }\n	//\n	// static class comp implements Comparator<Integer> {\n	//\n	// @Override\n	// public int compare(Integer p1, Integer p2) {\n	//\n	// return p2 - p1;\n	//\n	// }\n	// }\n	//\n	// }\n	//\n	// public static long pow(long a, long b) {\n	//\n	// if (b < 0)\n	// return 0;\n	// if (b == 0 || b == 1)\n	// return (long) Math.pow(a, b);\n	//\n	// if (b % 2 == 0) {\n	//\n	// long ret = pow(a, b / 2);\n	// ret = (ret % mod * ret % mod) % mod;\n	// return ret;\n	// }\n	//\n	// else {\n	// return ((pow(a, b - 1) % mod) * a % mod) % mod;\n	// }\n	// }\n\n	private static class pair implements Comparable<pair> {\n\n		long val;\n		int d;\n\n		pair(long a, int b) {\n			val = a;\n			d = b;\n		}\n\n		@Override\n		public int compareTo(pair o) {\n			return 1;\n		}\n\n		// @Override\n		//\n		// public int hashCode() {\n		// return i;\n		// }\n		//\n		// @Override\n		//\n		// public boolean equals(Object o) {\n		//\n		// pair p = (pair) o;\n		// return this.i == p.i;\n		// }\n\n	}\n\n	private static String reverse(String s) {\n\n		return new StringBuilder(s).reverse().toString();\n	}\n\n	public static class Reader {\n		final private int BUFFER_SIZE = 1 << 16;\n		private DataInputStream din;\n		private byte[] buffer;\n		private int bufferPointer, bytesRead;\n\n		public Reader() {\n			din = new DataInputStream(System.in);\n			buffer = new byte[BUFFER_SIZE];\n			bufferPointer = bytesRead = 0;\n		}\n\n		public Reader(String file_name) throws IOException {\n			din = new DataInputStream(new FileInputStream(file_name));\n			buffer = new byte[BUFFER_SIZE];\n			bufferPointer = bytesRead = 0;\n		}\n\n		public String readLine() throws IOException {\n			byte[] buf = new byte[1000000 + 1]; // line length\n			int cnt = 0, c;\n			while ((c = read()) != -1) {\n				if (c == '\n')\n					break;\n				buf[cnt++] = (byte) c;\n			}\n			return new String(buf, 0, cnt);\n		}\n\n		public int nextInt() throws IOException {\n			int ret = 0;\n			byte c = read();\n			while (c <= ' ')\n				c = read();\n			boolean neg = (c == '-');\n			if (neg)\n				c = read();\n			do {\n				ret = ret * 10 + c - '0';\n			} while ((c = read()) >= '0' && c <= '9');\n\n			if (neg)\n				return -ret;\n			return ret;\n		}\n\n		public long nextLong() throws IOException {\n			long ret = 0;\n			byte c = read();\n			while (c <= ' ')\n				c = read();\n			boolean neg = (c == '-');\n			if (neg)\n				c = read();\n			do {\n				ret = ret * 10 + c - '0';\n			} while ((c = read()) >= '0' && c <= '9');\n			if (neg)\n				return -ret;\n			return ret;\n		}\n\n		public double nextDouble() throws IOException {\n			double ret = 0, div = 1;\n			byte c = read();\n			while (c <= ' ')\n				c = read();\n			boolean neg = (c == '-');\n			if (neg)\n				c = read();\n\n			do {\n				ret = ret * 10 + c - '0';\n			} while ((c = read()) >= '0' && c <= '9');\n\n			if (c == '.') {\n				while ((c = read()) >= '0' && c <= '9') {\n					ret += (c - '0') / (div *= 10);\n				}\n			}\n\n			if (neg)\n				return -ret;\n			return ret;\n		}\n\n		private void fillBuffer() throws IOException {\n			bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n			if (bytesRead == -1)\n				buffer[0] = -1;\n		}\n\n		private byte read() throws IOException {\n			if (bufferPointer == bytesRead)\n				fillBuffer();\n			return buffer[bufferPointer++];\n		}\n\n		public void close() throws IOException {\n			if (din == null)\n				return;\n			din.close();\n		}\n\n		public int[] nextIntArray(int n) throws IOException {\n			int[] arr = new int[n];\n			for (int i = 0; i < n; i++) {\n				arr[i] = nextInt();\n			}\n			return arr;\n		}\n\n		public long[] nextLongArray(int n) throws IOException {\n			long[] arr = new long[n];\n			for (int i = 0; i < n; i++) {\n				arr[i] = nextLong();\n			}\n			return arr;\n		}\n\n		public int[][] nextInt2DArray(int m, int n) throws IOException {\n			int[][] arr = new int[m][n];\n			for (int i = 0; i < m; i++) {\n				for (int j = 0; j < n; j++)\n					arr[i][j] = nextInt();\n			}\n			return arr;\n		}\n\n		public long[][] nextInt2DArrayL(int m, int n) throws IOException {\n			long[][] arr = new long[m][n];\n			for (int i = 0; i < m; i++) {\n				for (int j = 0; j < n; j++)\n					arr[i][j] = nextInt();\n			}\n			return arr;\n		}\n		// kickstart - Solution\n		// atcoder - Main\n	}\n\n}","brute force,data structures,dp,greedy,math,sortings"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\npublic class d {\n    public static void main(String[] args) throws IOException {\n       // Scanner s = new Scanner(System.in);\n                BufferedReader s=new BufferedReader(new InputStreamReader(System.in));\n         //       String[] st=s.readLine().trim().split(""\\s+"");\n          //      a=Integer.parseInt(st[i]);\n        StringBuilder sb=new StringBuilder();\n        StringBuilder sb1=new StringBuilder();\n        String[] st3=s.readLine().trim().split(""\\s+"");\n\n      int   n=Integer.parseInt(st3[0]);\n        long[] l=new long[n];\n        String[] st1=s.readLine().trim().split(""\\s+"");\n\n        Student[] st=new Student[n];\n        for(int i=0;i<n;i++){\n            l[i]=Integer.parseInt(st1[i]);\n\n        }     String[] st2=s.readLine().trim().split(""\\s+"");\n        long[] d=new long[n];\n         for(int i=0;i<n;i++){\n             d[i]=Integer.parseInt(st2[i]);\n             st[i]=new Student((int)l[i],(int)d[i]);\n          }\n          Arrays.sort(st,new Sortbyroll());long sum=0;\n          HashMap<Integer,Long> h=new HashMap<>();int ac=0;int count=0;\n          HashMap<Integer,Integer> thisc=new HashMap<>();\n        HashMap<Integer,Integer> c=new HashMap<>();\n        h.put(st[n-1].l,0L);c.put(st[n-1].l,0);\n        for(int i=n-1;i>=0;i--){\n            if(i<n-1&&st[i].l!=st[i+1].l){\n                h.put(st[i].l,sum);c.put(st[i].l,count);\n                thisc.put(st[i+1].l,ac);\n                sum+=st[i].r;count+=1;ac=1;\n            }else {\n                sum+=st[i].r;\n                count++;ac++;}\n        }thisc.put(st[0].l,ac);\n        HashMap<Integer,Integer> D=new HashMap<>();long ans=Long.MAX_VALUE;\n        HashMap<Long,Integer> fans=new HashMap<>();\n           for(int i=0;i<n;i++){\n               long tr=h.get(st[i].l);\n               if(fans.containsKey((long)st[i].l)){\n                   if(D.containsKey(st[i].r)) D.put(st[i].r,D.get(st[i].r)+1);else D.put(st[i].r,1);\n                   continue;}\n               fans.put((long)st[i].l,1);\n          //     System.out.println(i+"" ""+tr);\n                long rem=n-(thisc.get(st[i].l)+c.get(st[i].l));\n                if(rem>thisc.get(st[i].l)-1){\n                    rem=rem-(thisc.get(st[i].l)-1);\n        //            System.out.println(i+"" ""+rem);\n                for(int j=1;j<=200;j++){\n                    if(D.containsKey(j)){\n                        if(D.get(j)>rem){\n                            tr+=rem*j;break;\n                        }\n                        tr+=j*D.get(j);\n                        rem-=D.get(j);\n                    }\n                }}\n               if(D.containsKey(st[i].r)) D.put(st[i].r,D.get(st[i].r)+1);else D.put(st[i].r,1);\n\n               ans=Math.min(ans,tr);\n           }\n        System.out.println(ans);\n\n    }\n    static int[] vis;\n    public static int countSetBits(int n)\n    {\n        return (BitsSetTable256[n & 0xff]\n                + BitsSetTable256[(n >> 8) & 0xff]\n                + BitsSetTable256[(n >> 16) & 0xff]\n                + BitsSetTable256[n >> 24]);\n    }\n    static int[] BitsSetTable256 ;\n    public static void initialize(int n)\n    {\n        BitsSetTable256[0] = 0;\n        for (int i = 0; i <=Math.pow(2,n); i++) {\n            BitsSetTable256[i] = (i & 1) + BitsSetTable256[i / 2];\n        }\n    }\n    static HashMap<Integer,Integer>[] val;//static int[] vis;static int y;\n    static boolean dfs(int x ,int i,ArrayList<Integer>[] adj){\n      vis[i]=1;\n     // if(x==1) System.out.print(i+"" "");\n      if(adj[i]==null) return false;\n      for(int j:adj[i]){\n        //  if(x==1) System.out.print(j+"" "");\n          if(j==x) return true;\n          if(vis[j]==0) return dfs(x,j,adj);\n      }return false;\n    }\n\n    static  void computeLPSArray(String pat, int M, int lps[]) {\n        int len = 0;\n        int i = 1;\n        lps[0] = 0;\n        while (i < M) {\n            if (pat.charAt(i) == pat.charAt(len)) {\n                len++;\n                lps[i] = len;\n                i++;\n            }\n            else\n            {\n                if (len != 0) {\n                    len = lps[len - 1];\n                }\n                else\n                {\n                    lps[i] = len;\n                    i++;\n                }\n            }\n        }\n    }\n    static boolean isPrime(int n) {\n        if (n <= 1) return false;\n        if (n <= 3) return true;\n\n        if (n % 2 == 0 || n % 3 == 0) return false;\n\n        for (int i = 5; i * i <= n; i = i + 6)\n            if (n % i == 0 || n % (i + 2) == 0)\n                return false;\n\n        return true;\n    }\n    static long powerwithmod(long  x, long y, int p) {\n        long  res = 1;\n        x = x % p;\n        while (y > 0) {\n            if ((y & 1) == 1)\n                res = (res * x) % p;\n            y = y >> 1;\n            x = (x * x) % p;\n        }\n        return res;\n    }\n    static long  powerwithoutmod(long x, int y) {\n        long  temp;\n        if( y == 0)\n            return 1;\n        temp = powerwithoutmod(x, y/2);\n        if (y%2 == 0)\n            return temp*temp;\n        else\n        {\n            if(y > 0)\n                return x * temp * temp;\n            else\n                return (temp * temp) / x;\n        }\n    }\n    static void fracion(double x) {\n        String a = """" + x;\n        String spilts[] = a.split(""\\.""); // split using decimal\n        int b = spilts[1].length(); // find the decimal length\n        int denominator = (int) Math.pow(10, b); // calculate the denominator\n        int numerator = (int) (x * denominator); // calculate the nerumrator Ex\n        // 1.2*10 = 12\n        int gcd = (int) gcd((long) numerator, denominator); // Find the greatest common\n        // divisor bw them\n        String fraction = """" + numerator / gcd + ""/"" + denominator / gcd;\n        // System.out.println((denominator/gcd));\n        long x1 = modInverse(denominator / gcd, 998244353);\n        //  System.out.println(x1);\n        System.out.println((((numerator / gcd) % 998244353 * (x1 % 998244353)) % 998244353));\n    }\n    static int bfs(int i1, ArrayList<Integer>[] h, int[] vis, int n,int val1) {\n        Queue<Integer> q = new LinkedList<Integer>();\n        q.add(i1);Queue<Integer> aq=new LinkedList<Integer>();\n        aq.add(0);\n        while(!q.isEmpty()){\n            int i=q.poll();\n            int val=aq.poll();\n            if(i==n){\n                return val;\n            }\n            if(h[i]!=null){\n                for(Integer j:h[i]){\n                    if(vis[j]==0){\n                        q.add(j);vis[j]=1;\n                        aq.add(val+1);}\n                }\n            }\n        }return -1;\n    }\n    static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    static long modInverse(long a, int m)\n    {\n        return (powerwithmod(a, m - 2, m));\n    }\n    static int MAXN=100001;\n    static int[] spf=new int[MAXN];\n    static void sieve() {\n        spf[1] = 1;\n        for (int i=2; i<MAXN; i++)\n            spf[i] = i;\n        for (int i=4; i<MAXN; i+=2)\n            spf[i] = 2;\n        for (int i=3; i*i<MAXN; i++)\n        {\n            if (spf[i] == i)\n            {\n                for (int j=i*i; j<MAXN; j+=i)\n\n                    if (spf[j]==j)\n                        spf[j] = i;\n            }\n        }\n    }\n    static Vector<Integer> getFactorizationUsingSeive(int x) {\n        Vector<Integer> ret = new Vector<Integer>();\n        while (x != 1)\n        {\n            ret.add(spf[x]);\n            x = x / spf[x];\n        }\n        return ret;\n    }\n   /*static long[] fac = new long[MAXN+1];\n     static void calculatefac(int mod){\n        for (int i = 1 ;i <= MAXN; i++)\n            fac[i] = fac[i-1] * i % mod;\n     }\n      static long nCrModPFermat(int n, int r, int mod) {\n         if (r == 0)\n            return 1;\n        fac[0] = 1;\n        return (fac[n]* modInverse(fac[r], mod)\n                % mod * modInverse(fac[n-r], mod)\n                                    % mod) % mod;\n    } */}\nclass Student {\n    int l;int r;int x;\n    public Student(int l, int r) {\n        this.l = l;\n        this.r = r;\n    }\n\n    public String toString()\n    {\n        return this.l+"" "";\n    }\n}\nclass Sortbyroll implements Comparator<Student>\n{\n\n    public int compare(Student a, Student b){\n        return a.l-b.l;  }\n}\nclass Sortbyroll1 implements Comparator<Student> {\n    public int compare(Student a, Student b){\n        if(a.r==b.r) return a.l-b.l;\n        return b.l-a.l;\n    }\n}","brute force,data structures,dp,greedy,math,sortings"
import java.util.Scanner;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n=sc.nextInt();\n    int sum=0;\n    for(int i=0; i<n; i++) {\n      int x1 = sc.nextInt();\n      int y1 = sc.nextInt();\n      int x2 = sc.nextInt();\n      int y2 = sc.nextInt();\n      sum+=(x2-x1+1)*(y2-y1+1);\n    }\n    System.out.println(sum);\n  }\n},"implementation,math"
import java.util.Scanner;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n=sc.nextInt();\n    int sum=0;\n    for(int i=0; i<n; i++) {\n      int x1 = sc.nextInt();\n      int y1 = sc.nextInt();\n      int x2 = sc.nextInt();\n      int y2 = sc.nextInt();\n      sum+=(x2-x1+1)*(y2-y1+1);\n    }\n    System.out.println(sum);\n  }\n},"implementation,math"
import java.util.Scanner;\n\npublic class _0746VanyaandTable {\n\n	public static void main(String[] args) {\n		\n		Scanner sc = new Scanner(System.in);\n		int n=sc.nextInt();\n		long ans=0;\n		for(int i=0;i<n;i++) {\n			int x1=sc.nextInt();\n			int y1=sc.nextInt();\n			int x2=sc.nextInt();\n			int y2=sc.nextInt();	\n		ans+=(Math.abs(x2-x1)+1)*(Math.abs(y2-y1)+1);\n		}\n		System.out.println(ans);\n		\n	}\n\n}\n,"implementation,math"
"import java.util.*;\npublic class rate{\n public static void main(String[] args) {\n 	Scanner sc = new Scanner(System.in);\n 	int n,a,b,c,d;\n 	n = sc.nextInt();\n 	int r = 0;\n 	while(n!=0){\n         a = sc.nextInt();\n         b = sc.nextInt();\n         c = sc.nextInt();\n         d = sc.nextInt();\n         a = Math.abs(a-c)+1;\n         b = Math.abs(b-d)+1;\n         r +=a*b;\n        n--;\n 	}\n\n	System.out.println(r);\n}\n}","implementation,math"
"import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashSet;\n\npublic class Main {\n	private final int SIZE_OF_BLOCK = 710;// 1ブロックのサイズ\n	private long[][] blocks;\n	private ArrayList<HashSet<Long>> containList;\n	private long[] add;\n	private int N;\n\n	public void solve() {\n		N = nextInt();\n		int Q = nextInt();\n		int[] array = new int[N];\n		for (int i = 0; i < N; i++) {\n			array[i] = nextInt();\n		}\n\n		int BLOCK_NUM = N / SIZE_OF_BLOCK + 1;\n		containList = new ArrayList<>();\n		for (int i = 0; i < BLOCK_NUM; i++) {\n			containList.add(new HashSet<Long>());\n		}\n\n		blocks = new long[BLOCK_NUM][SIZE_OF_BLOCK];\n		for (int i = 0; i < N; i++) {\n			int block = i / SIZE_OF_BLOCK;\n			int idx = i % SIZE_OF_BLOCK;\n			blocks[block][idx] = array[i];\n			containList.get(block).add(blocks[block][idx]);\n		}\n\n		add = new long[BLOCK_NUM];\n\n		StringBuilder ans = new StringBuilder();\n		for (int q = 0; q < Q; q++) {\n			int type = nextInt();\n			if (type == 1) {\n				// 加算クエリ\n				int from = nextInt() - 1;\n				int to = nextInt() - 1;\n				int addition = nextInt();\n\n				int fromBlock = from / SIZE_OF_BLOCK;\n				int toBlock = to / SIZE_OF_BLOCK;\n				if (fromBlock == toBlock) {\n					if (from % SIZE_OF_BLOCK == 0 && (to + 1) % SIZE_OF_BLOCK == 0) {\n						add[fromBlock] += addition;\n					} else {\n						add2Array(from, to, addition);\n					}\n					continue;\n				}\n\n				if (from % SIZE_OF_BLOCK != 0) {\n					add2Array(from, (fromBlock + 1) * SIZE_OF_BLOCK - 1, addition);\n					fromBlock++;\n				}\n				if ((to + 1) % SIZE_OF_BLOCK != 0) {\n					add2Array(toBlock * SIZE_OF_BLOCK, to, addition);\n					toBlock--;\n				}\n\n				for (int i = fromBlock; i <= toBlock; i++) {\n					add[i] += addition;\n				}\n			} else {\n				// 検索クエリ\n				int target = nextInt();\n				int first = -1;\n				searchFirst: for (int block = 0; block < BLOCK_NUM; block++) {\n					if (containList.get(block).contains(target - add[block])) {\n						for (int i = 0; i < SIZE_OF_BLOCK; i++) {\n							if (blocks[block][i] + add[block] == target) {\n								first = block * SIZE_OF_BLOCK + i;\n								break searchFirst;\n							}\n						}\n					}\n				}\n				if (first == -1) {\n					ans.append(-1 + ""\n"");\n					continue;\n				}\n\n				int last = first;\n				searchLast: for (int block = BLOCK_NUM - 1; block >= 0; block--) {\n					if (containList.get(block).contains(target - add[block])) {\n						for (int i = SIZE_OF_BLOCK - 1; i >= 0; i--) {\n							if (block * SIZE_OF_BLOCK + i >= N) {\n								continue;\n							}\n\n							if (blocks[block][i] + add[block] == target) {\n								last = block * SIZE_OF_BLOCK + i;\n								break searchLast;\n							}\n						}\n					}\n				}\n				ans.append((last - first) + ""\n"");\n			}\n		}\n		System.out.print(ans.toString());\n\n	}\n\n	private void add2Array(int from, int to, int addition) {\n		for (int i = from; i <= to; i++) {\n			int block = i / SIZE_OF_BLOCK;\n			int idx = i % SIZE_OF_BLOCK;\n			blocks[block][idx] += addition;\n		}\n\n		int block = to / SIZE_OF_BLOCK;\n		containList.get(block).clear();\n		for (int i = 0; i < SIZE_OF_BLOCK; i++) {\n			if (block * SIZE_OF_BLOCK + i >= N) {\n				break;\n			}\n			blocks[block][i] += add[block];\n			containList.get(block).add(blocks[block][i]);\n		}\n		add[block] = 0;\n	}\n\n	private int nextInt() {\n		int c;\n		try {\n			c = System.in.read();\n			while (c != '-' && (c < '0' || c > '9'))\n				c = System.in.read();\n			if (c == '-')\n				return -nextInt();\n			int res = 0;\n			while (c >= '0' && c <= '9') {\n				res = res * 10 + c - '0';\n				c = System.in.read();\n			}\n			return res;\n		} catch (IOException e) {\n			// TODO Auto-generated catch block\n			e.printStackTrace();\n		}\n		return -1;\n	}\n\n	public static void main(String[] args) {\n		new Main().solve();\n	}\n}","binary search,data structures,implementation"
"import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashSet;\n\npublic class Main {\n	private long[][] blocks;\n	private ArrayList<HashSet<Long>> containList;\n	private long[] add;\n	private int N, SIZE_OF_BLOCK;\n\n	public void solve() {\n		N = nextInt();\n		SIZE_OF_BLOCK = (int) Math.sqrt(N);// 1ブロックのサイズ\n		int Q = nextInt();\n		int[] array = new int[N];\n		for (int i = 0; i < N; i++) {\n			array[i] = nextInt();\n		}\n\n		int BLOCK_NUM = N / SIZE_OF_BLOCK + 1;\n		containList = new ArrayList<>();\n		for (int i = 0; i < BLOCK_NUM; i++) {\n			containList.add(new HashSet<Long>());\n		}\n\n		blocks = new long[BLOCK_NUM][SIZE_OF_BLOCK];\n		for (int i = 0; i < N; i++) {\n			int block = i / SIZE_OF_BLOCK;\n			int idx = i % SIZE_OF_BLOCK;\n			blocks[block][idx] = array[i];\n			containList.get(block).add(blocks[block][idx]);\n		}\n\n		add = new long[BLOCK_NUM];\n\n		StringBuilder ans = new StringBuilder();\n		for (int q = 0; q < Q; q++) {\n			int type = nextInt();\n			if (type == 1) {\n				// 加算クエリ\n				int from = nextInt() - 1;\n				int to = nextInt() - 1;\n				int addition = nextInt();\n\n				int fromBlock = from / SIZE_OF_BLOCK;\n				int toBlock = to / SIZE_OF_BLOCK;\n				if (fromBlock == toBlock) {\n					if (from % SIZE_OF_BLOCK == 0 && (to + 1) % SIZE_OF_BLOCK == 0) {\n						add[fromBlock] += addition;\n					} else {\n						add2Array(from, to, addition);\n					}\n					continue;\n				}\n\n				if (from % SIZE_OF_BLOCK != 0) {\n					add2Array(from, (fromBlock + 1) * SIZE_OF_BLOCK - 1, addition);\n					fromBlock++;\n				}\n				if ((to + 1) % SIZE_OF_BLOCK != 0) {\n					add2Array(toBlock * SIZE_OF_BLOCK, to, addition);\n					toBlock--;\n				}\n\n				for (int i = fromBlock; i <= toBlock; i++) {\n					add[i] += addition;\n				}\n			} else {\n				// 検索クエリ\n				int target = nextInt();\n				int first = -1;\n				searchFirst: for (int block = 0; block < BLOCK_NUM; block++) {\n					if (containList.get(block).contains(target - add[block])) {\n						for (int i = 0; i < SIZE_OF_BLOCK; i++) {\n							if (blocks[block][i] + add[block] == target) {\n								first = block * SIZE_OF_BLOCK + i;\n								break searchFirst;\n							}\n						}\n					}\n				}\n				if (first == -1) {\n					ans.append(-1 + ""\n"");\n					continue;\n				}\n\n				int last = first;\n				searchLast: for (int block = BLOCK_NUM - 1; block >= 0; block--) {\n					if (containList.get(block).contains(target - add[block])) {\n						for (int i = SIZE_OF_BLOCK - 1; i >= 0; i--) {\n							if (block * SIZE_OF_BLOCK + i >= N) {\n								continue;\n							}\n\n							if (blocks[block][i] + add[block] == target) {\n								last = block * SIZE_OF_BLOCK + i;\n								break searchLast;\n							}\n						}\n					}\n				}\n				ans.append((last - first) + ""\n"");\n			}\n		}\n		System.out.print(ans.toString());\n\n	}\n\n	private void add2Array(int from, int to, int addition) {\n		for (int i = from; i <= to; i++) {\n			int block = i / SIZE_OF_BLOCK;\n			int idx = i % SIZE_OF_BLOCK;\n			blocks[block][idx] += addition;\n		}\n\n		int block = to / SIZE_OF_BLOCK;\n		containList.get(block).clear();\n		for (int i = 0; i < SIZE_OF_BLOCK; i++) {\n			if (block * SIZE_OF_BLOCK + i >= N) {\n				break;\n			}\n			blocks[block][i] += add[block];\n			containList.get(block).add(blocks[block][i]);\n		}\n		add[block] = 0;\n	}\n\n	private int nextInt() {\n		int c;\n		try {\n			c = System.in.read();\n			while (c != '-' && (c < '0' || c > '9'))\n				c = System.in.read();\n			if (c == '-')\n				return -nextInt();\n			int res = 0;\n			while (c >= '0' && c <= '9') {\n				res = res * 10 + c - '0';\n				c = System.in.read();\n			}\n			return res;\n		} catch (IOException e) {\n			// TODO Auto-generated catch block\n			e.printStackTrace();\n		}\n		return -1;\n	}\n\n	public static void main(String[] args) {\n		new Main().solve();\n	}\n}","binary search,data structures,implementation"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class C {\n\n\n	static int N, Q, L, B;\n	static Point[][] arr;\n	static long[] add;\n\n	static void update(int l, int r, long val) {\n		int bL = l / L;\n		int bR = r / L;\n\n		if(bL == bR)\n			updateBlock(l, r, bL, val);\n		else {\n			updateBlock(l, r, bL, val);\n			updateBlock(l, r, bR, val);\n\n			for (int i = bL + 1; i < bR; i++)\n				add[i] += val;\n		}\n	}\n\n	static void updateBlock(int l, int r, int idx, long val) {\n		ArrayList<Point> a1 = new ArrayList<>();\n		ArrayList<Point> a2 = new ArrayList<>();\n		for (int i = 0; i < L; i++) {\n			if(arr[idx][i].idx >= l && arr[idx][i].idx <= r) {\n				arr[idx][i].v += val;\n				a1.add(arr[idx][i]);\n			}else\n				a2.add(arr[idx][i]);\n		}\n\n		Point[] newB = new Point[L];\n		int p1 = 0;\n		int p2 = 0;\n		int p = 0;\n		for (int i = 0; i < L; i++) \n			if(p1 < a1.size() && (p2 >= a2.size() || a1.get(p1).compareTo(a2.get(p2)) < 0))\n				newB[p++] = a1.get(p1++);\n			else\n				newB[p++] = a2.get(p2++);\n\n		arr[idx] = newB;\n	}\n\n	static int first(long val) {\n		int ans = -1;\n		for (int i = 0; i < B; ++i) {\n			int l = 0;\n			int h = L - 1;\n			if(i == B - 1)\n				h = (N - 1) % L;\n			while(l <= h) {\n				int mid = ((l + h) >> 1);\n				if(arr[i][mid].v + add[i] == val) {\n					ans = arr[i][mid].idx;\n					h = mid - 1;\n				}else if(arr[i][mid].v + add[i] > val)\n					h = mid - 1;\n				else\n					l = mid + 1;\n			}\n\n			if(ans != -1)\n				return ans;\n		}\n\n		return ans;\n	}\n\n	static int last(long val) {\n		int ans = -1;\n		for (int i = B - 1; i >= 0; --i) {\n			int l = 0;\n			int h = L - 1;\n			if(i == B - 1)\n				h = (N - 1) % L;\n			while(l <= h) {\n				int mid = ((l + h) >> 1);\n\n				if(arr[i][mid].v + add[i] == val) {\n					ans = arr[i][mid].idx;\n					l = mid + 1;\n				}else if(arr[i][mid].v + add[i] > val)\n					h = mid - 1;\n				else\n					l = mid + 1;\n			}\n\n			if(ans != -1)\n				return ans;\n		}\n\n		return ans;\n	}\n\n	public static void main(String[] args) throws IOException {\n		Scanner sc = new Scanner(System.in);\n		PrintWriter out = new PrintWriter(System.out);\n\n		N = sc.nextInt();\n		Q = sc.nextInt();\n\n		L = 1000;\n\n		B = (N + 999) / L;\n\n		arr = new Point[B][L];\n		add = new long[B];\n		for (int i = 0; i < N; i++) \n			arr[i / L][i % L] = new Point(sc.nextLong(), i);\n\n		for (int i = N; i < L * B; i++) \n			arr[i / L][i % L] = new Point(Long.MAX_VALUE, i);\n\n		for (int i = 0; i < B; i++) \n			Arrays.sort(arr[i]);\n		\n\n\n		for (int i = 0; i < Q; i++) {\n			int t = sc.nextInt();\n			if(t == 1) {\n				int l = sc.nextInt() - 1;\n				int r = sc.nextInt() - 1;\n				long x = sc.nextLong();\n\n				update(l, r, x);\n			} else {\n				long y = sc.nextLong();\n				int f = first(y);\n				if(f == -1)\n					out.println(-1);\n				else\n					out.println(last(y) - f);\n			}\n			\n		}\n\n		out.flush();\n	}\n\n\n	static class Point implements Comparable<Point> {\n		long v;\n		int idx;\n\n		Point(long v, int idx) {\n			this.v = v;\n			this.idx = idx;\n		}\n\n		@Override\n		public int compareTo(Point o) {\n			if(this.v == o.v)\n				return idx - o.idx;\n			\n			if(v > o.v)\n				return 1;\n			return -1;\n		}\n	}\n\n\n\n	static class Scanner {\n		StringTokenizer st;\n		BufferedReader br;\n\n		public Scanner(InputStream s) {\n			br = new BufferedReader(new InputStreamReader(s));\n		}\n\n		public String next() throws IOException {\n			while(st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		public int nextInt() throws NumberFormatException, IOException {\n			return Integer.parseInt(next());\n		}\n\n		public long nextLong() throws NumberFormatException, IOException {\n			return Long.parseLong(next());\n		}\n	}	\n\n}","binary search,data structures,implementation"
"import java.util.Arrays;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Agostinho Junior (junior94)\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		InputReader in = new InputReader(inputStream);\n		OutputWriter out = new OutputWriter(outputStream);\n		TaskE solver = new TaskE();\n		solver.solve(1, in, out);\n		out.close();\n	}\n}\n\nclass TaskE {\n\n	static class Data implements Comparable<Data> {\n		int idx;\n		long value;\n\n		public Data(int idx, int value) {\n			this.idx = idx;\n			this.value = value;\n		}\n\n		public int compareTo(Data other) {\n			return Long.compare(value, other.value);\n		}\n	}\n\n	public void solve(int testNumber, InputReader in, OutputWriter out) {\n		int N = in.readInt();\n		int Q = in.readInt();\n\n		Data[] data = new Data[N];\n		for (int i = 0; i < N; i++) {\n			data[i] = new Data(i, in.readInt());\n		}\n\n		final int blockSize = (int)Math.sqrt(N);\n\n		int[] block = new int[N];\n		int count = 1;\n		for (int i = 1; i < N; i++) {\n			block[i] = block[i - 1];\n			if (count == blockSize) {\n				block[i]++;\n				count = 0;\n			}\n			count++;\n		}\n\n		long[] added = new long[block[N - 1] + 1];\n\n		for (int i = 0; i < N; i += blockSize) {\n			int end = Math.min(N, i + blockSize);\n			Arrays.sort(data, i, end);\n		}\n\n\n		while (Q-- > 0) {\n			int t = in.readInt();\n\n			if (t == 1) {\n				int L = in.readInt() - 1;\n				int R = in.readInt() - 1;\n				long X = in.readInt();\n\n				int firstIn = block[L];\n				if (L > 0 && firstIn == block[L - 1]) {\n					firstIn++;\n				}\n\n				int lastIn = block[R];\n				if (R < N - 1 && lastIn == block[R + 1]) {\n					lastIn--;\n				}\n\n				int end = Math.min(N - 1, blockSize * (block[R] + 1) - 1);\n\n				for (int i = block[L] * blockSize; i <= end; ) {\n					if (firstIn <= block[i] && block[i] <= lastIn) {\n						added[block[i]] += X;\n						i += blockSize;\n					} else {\n						if (L <= data[i].idx && data[i].idx <= R) {\n							data[i].value += X;\n						}\n						if (i == N - 1 || block[i] < block[i + 1]) {\n							int start = block[i] * blockSize;\n							Arrays.sort(data, start, i + 1);\n						}\n						i++;\n					}\n				}\n\n			} else {\n				int X = in.readInt();\n				int first = -1;\n				int last = -1;\n\n				for (int i = 0; i < N; i += blockSize) {\n					int low = i;\n					int high = Math.min(N - 1, i + blockSize - 1);\n					while (low <= high) {\n						int mid = low + high >> 1;\n						long value = data[mid].value + added[block[i]];\n						if (value == X) {\n							if (first == -1) {\n								first = block[i];\n							}\n							last = block[i];\n							break;\n						}\n						if (value < X) {\n							low = mid + 1;\n						} else {\n							high = mid - 1;\n						}\n					}\n				}\n\n				if (first == -1) {\n					out.println(-1);\n				} else {\n					int[] temp = {first, last};\n					first = N - 1;\n					last = 0;\n					for (int b: temp) {\n						int start = b * blockSize;\n						int end = Math.min(N - 1, start + blockSize - 1);\n						for (int i = start; i <= end; i++) {\n							if (data[i].value + added[block[i]] == X) {\n								first = Math.min(first, data[i].idx);\n								last = Math.max(last, data[i].idx);\n							}\n						}\n					}\n					out.println(last - first);\n				}\n\n			}\n		}\n\n	}\n\n\n}\n\nclass InputReader {\n	private BufferedReader input;\n	private StringTokenizer line = new StringTokenizer("""");\n\n	public InputReader(InputStream in) {input = new BufferedReader(new InputStreamReader(in));\n	}\n\n	public void fill() {\n		try {\n			if(!line.hasMoreTokens()) line = new StringTokenizer(input.readLine());\n		} catch(IOException io) { io.printStackTrace(); System.exit(0);}\n	}\n\n	public int readInt() {\n		fill();\n		return Integer.parseInt(line.nextToken());\n	}\n\n}\n\nclass OutputWriter {\n	private PrintWriter output;\n\n	public OutputWriter(OutputStream out) {\n		output = new PrintWriter(out);\n	}\n\n	public void println(Object o) {\n		output.println(o);\n	}\n\n	public void close() {\n		output.close();\n	}\n}\n\n","binary search,data structures,implementation"
"import java.io.*;\nimport java.util.*;\n\npublic class summerdichotomy {\n  private static InputReader in;\n  private static PrintWriter out;\n  public static int t, T, N, M;\n  public static ArrayList<Integer>[] graph;\n  \n  public static boolean[] vis;\n  public static int[] color;\n  public static Interval[] tt;\n  \n  public static void dfs (int node, int c) {\n    if (vis[node]) {\n      if (c != color[node]) {\n        out.println(""IMPOSSIBLE"");\n        out.close();\n        System.exit(0);\n      }\n      return;\n    }\n    vis[node] = true;\n    color[node] = c;\n    for (int x : graph[node]) dfs(x, 1 - c);\n  }\n  \n  static class Interval {\n    public int low, high;\n    public Interval(int low, int high) {\n      this.low = low;\n      this.high = high;\n    }\n    \n    public boolean intersect(int x) {\n      return x >= low && x <= high;\n    }\n  }\n\n  public static void main(String[] args) throws IOException {\n    in = new InputReader(System.in);\n    out = new PrintWriter(System.out, true);\n    t = in.nextInt();\n    T = in.nextInt();\n    N = in.nextInt();\n    M = in.nextInt();\n    tt = new Interval[N];\n    graph = new ArrayList[N];\n    int mx = 0, mn = 1 << 29;\n    for (int i = 0; i < N; i++) {\n      tt[i] = new Interval(in.nextInt(), in.nextInt());\n      mx = Math.max(mx, tt[i].low);\n      mn = Math.min(mn, tt[i].high);\n      graph[i] = new ArrayList<>();\n    }\n    for (int i = 0; i < M; i++) {\n      int a = in.nextInt()-1, b = in.nextInt()-1;\n      graph[a].add(b);\n      graph[b].add(a);\n    }\n    \n    if (mx + mn < t) {\n      mx = t - mn;\n    } else if (mx + mn > T) {\n      mn = T - mx;\n    }\n    \n    if (mx < 0 || mn < 0) {\n      out.println(""IMPOSSIBLE"");\n      out.close();\n      System.exit(0);\n    }\n    \n    vis = new boolean[N];\n    color = new int[N];\n    for (int i = 0; i < N; i++) {\n      if (!tt[i].intersect(mn) && !tt[i].intersect(mx)) {\n        out.println(""IMPOSSIBLE"");\n        out.close();\n        System.exit(0);\n      }\n      \n      if (!tt[i].intersect(mn)) dfs(i, 1);\n      if (!tt[i].intersect(mx)) dfs(i, 0);\n    }\n    for (int i = 0; i < N; i++) {\n      if (!vis[i])\n        dfs(i, 0);\n    }\n    \n    out.println(""POSSIBLE"");\n    out.println(mn+"" ""+mx);\n    for (int i = 0; i < N; i++) {\n      out.print((color[i]+1));\n    }\n    out.println();\n    out.close();\n    System.exit(0);\n  }\n\n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream), 32768);\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n  }\n\n\n}\n","2-sat,data structures,dfs and similar,greedy"
"import java.io.*;\nimport java.util.*;\n\npublic class summerdichotomy {\n  private static InputReader in;\n  private static PrintWriter out;\n  public static int trials = 11;\n  public static int t, T, N, M;\n  public static ArrayList<Integer>[] graph;\n  \n  public static boolean[] vis;\n  public static int[] color;\n  public static Interval[] tt;\n  \n  public static boolean dfs (int node, int c) {\n    if (vis[node]) return c == color[node];\n    vis[node] = true;\n    color[node] = c;\n    for (int x : graph[node]) {\n      if (!dfs(x, 1 - c))\n        return false;\n    }\n    return true;\n  }\n  \n  static class Interval {\n    public int low, high;\n    public Interval(int low, int high) {\n      this.low = low;\n      this.high = high;\n    }\n    \n    public boolean intersect(int x) {\n      return x >= low && x <= high;\n    }\n    \n    public String toString() {\n      return low+"" ""+high;\n    }\n  }\n\n  public static void main(String[] args) throws IOException {\n    in = new InputReader(System.in);\n    out = new PrintWriter(System.out, true);\n    t = in.nextInt();\n    T = in.nextInt();\n    N = in.nextInt();\n    M = in.nextInt();\n    tt = new Interval[N];\n    graph = new ArrayList[N];\n    int mx = 0, mn = 1 << 29;\n    for (int i = 0; i < N; i++) {\n      tt[i] = new Interval(in.nextInt(), in.nextInt());\n      mx = Math.max(mx, tt[i].low);\n      mn = Math.min(mn, tt[i].high);\n      graph[i] = new ArrayList<>();\n    }\n    for (int i = 0; i < M; i++) {\n      int a = in.nextInt()-1, b = in.nextInt()-1;\n      graph[a].add(b);\n      graph[b].add(a);\n    }\n    if (mx + mn < t) {\n      mx = t - mn;\n    } else if (mx + mn > T) {\n      mn = T - mx;\n    }\n    \n    if (mx < 0 || mn < 0) {\n      out.println(""IMPOSSIBLE"");\n      out.close();\n      System.exit(0);\n    }\n    \n    vis = new boolean[N];\n    color = new int[N];\n    for (int i = 0; i < N; i++) {\n      if (!tt[i].intersect(mn) && !tt[i].intersect(mx)) {\n        out.println(""IMPOSSIBLE"");\n        out.close();\n        System.exit(0);\n      }\n      \n      if (!tt[i].intersect(mn)) {\n        if (!dfs(i, 1)) {\n          out.println(""IMPOSSIBLE"");\n          out.close();\n          System.exit(0);\n        }\n      }\n      if (!tt[i].intersect(mx)) {\n        if (!dfs(i, 0)) {\n          out.println(""IMPOSSIBLE"");\n          out.close();\n          System.exit(0);\n        }\n      }\n    }\n    for (int i = 0; i < N; i++) {\n      if (!vis[i]) {\n        if (!dfs(i, 0)) {\n          out.println(""IMPOSSIBLE"");\n          out.close();\n          System.exit(0);\n        }\n      }\n    }\n    \n    out.println(""POSSIBLE"");\n    out.println(mn+"" ""+mx);\n    for (int i = 0; i < N; i++) {\n      out.print((color[i]+1));\n    }\n    out.println();\n    out.close();\n    System.exit(0);\n  }\n\n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream), 32768);\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n  }\n\n\n}","2-sat,data structures,dfs and similar,greedy"
"import java.io.*;\nimport java.util.*;\n\npublic class summerdichotomy {\n  private static InputReader in;\n  private static PrintWriter out;\n  public static int trials = 11;\n  public static int t, T, N, M;\n  public static ArrayList<Integer>[] graph;\n  \n  public static boolean[] vis;\n  public static int[] color;\n  public static Interval[] tt;\n  \n  public static boolean dfs (int node, int c) {\n    if (vis[node]) return c == color[node];\n    vis[node] = true;\n    color[node] = c;\n    for (int x : graph[node]) {\n      if (!dfs(x, 1 - c))\n        return false;\n    }\n    return true;\n  }\n  \n  static class Interval {\n    public int low, high;\n    public Interval(int low, int high) {\n      this.low = low;\n      this.high = high;\n    }\n    \n    public boolean intersect(int x) {\n      return x >= low && x <= high;\n    }\n    \n    public String toString() {\n      return low+"" ""+high;\n    }\n  }\n\n  public static void main(String[] args) throws IOException {\n    in = new InputReader(System.in);\n    out = new PrintWriter(System.out, true);\n    t = in.nextInt();\n    T = in.nextInt();\n    N = in.nextInt();\n    M = in.nextInt();\n    tt = new Interval[N];\n    graph = new ArrayList[N];\n    int mx = 0, mn = 1 << 29;\n    for (int i = 0; i < N; i++) {\n      tt[i] = new Interval(in.nextInt(), in.nextInt());\n      mx = Math.max(mx, tt[i].low);\n      mn = Math.min(mn, tt[i].high);\n      graph[i] = new ArrayList<>();\n    }\n    for (int i = 0; i < M; i++) {\n      int a = in.nextInt()-1, b = in.nextInt()-1;\n      graph[a].add(b);\n      graph[b].add(a);\n    }\n    if (mx + mn < t) {\n      mx = t - mn;\n    } else if (mx + mn > T) {\n      mn = T - mx;\n    }\n    \n    if (mx < 0 || mn < 0) {\n      out.println(""IMPOSSIBLE"");\n      out.close();\n      System.exit(0);\n    }\n    \n    vis = new boolean[N];\n    color = new int[N];\n    for (int i = 0; i < N; i++) {\n      if (!tt[i].intersect(mn) && !tt[i].intersect(mx)) {\n        out.println(""IMPOSSIBLE"");\n        out.close();\n        System.exit(0);\n      }\n      \n      if (!tt[i].intersect(mn)) {\n        if (!dfs(i, 1)) {\n          out.println(""IMPOSSIBLE"");\n          out.close();\n          System.exit(0);\n        }\n      }\n      if (!tt[i].intersect(mx)) {\n        if (!dfs(i, 0)) {\n          out.println(""IMPOSSIBLE"");\n          out.close();\n          System.exit(0);\n        }\n      }\n    }\n    for (int i = 0; i < N; i++) {\n      if (!vis[i]) {\n        if (!dfs(i, 0)) {\n          out.println(""IMPOSSIBLE"");\n          out.close();\n          System.exit(0);\n        }\n      }\n    }\n    \n    out.println(""POSSIBLE"");\n    out.println(mn+"" ""+mx);\n    for (int i = 0; i < N; i++) {\n      out.print((color[i]+1));\n    }\n    out.println();\n    out.close();\n    System.exit(0);\n  }\n\n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream), 32768);\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n  }\n\n\n}\n","2-sat,data structures,dfs and similar,greedy"
"import java.util.TreeMap;\nimport java.util.ArrayList;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.List;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		InputReader in = new InputReader(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		TaskH solver = new TaskH();\n		solver.solve(1, in, out);\n		out.close();\n	}\n}\n\nclass TaskH {\n    static class Teacher {\n        int l;\n        int r;\n        List<Teacher> conflicts = new ArrayList<>(1);\n        int kind;\n        int res;\n\n        public boolean buildComponent(Component c, int k) {\n            if (kind != 0) {\n                return kind == k;\n            }\n            kind = k;\n            if (k == 1) {\n                c.l1 = Math.max(c.l1, l);\n                c.r1 = Math.min(c.r1, r);\n            } else {\n                c.l2 = Math.max(c.l2, l);\n                c.r2 = Math.min(c.r2, r);\n            }\n            for (Teacher t : conflicts) {\n                if (!t.buildComponent(c, 3 - k)) return false;\n            }\n            return true;\n        }\n\n        public void markAs(int as) {\n            if (res != 0) {\n                if (res != as) throw new RuntimeException();\n                return;\n            }\n            res = as;\n            for (Teacher t : conflicts) {\n                t.markAs(3 - as);\n            }\n        }\n    }\n\n    static class Component {\n        Teacher root;\n        int l1;\n        int r1;\n        int l2;\n        int r2;\n        int insideMask;\n\n        public void markAs(int as) {\n            root.markAs(as);\n        }\n    }\n\n    static class Event {\n        int when;\n        Component which;\n        int compIndex;\n\n        public Event(int when, Component which, int compIndex) {\n            this.when = when;\n            this.which = which;\n            this.compIndex = compIndex;\n        }\n    }\n\n    static class SetTrackerWithMax {\n        TreeMap<Integer, Integer> counts = new TreeMap<>();\n\n        public void add(int x) {\n            Integer old = counts.get(x);\n            if (old == null)\n                counts.put(x, 1);\n            else\n                counts.put(x, old + 1);\n        }\n\n        public void remove(int x) {\n            int v = counts.get(x);\n            if (v == 1)\n                counts.remove(x);\n            else\n                counts.put(x, v - 1);\n        }\n\n        int getMax() {\n            return counts.lastKey();\n        }\n    }\n\n    static class Magic {\n        int numImpossible;\n        SetTrackerWithMax lefts = new SetTrackerWithMax();\n        SetTrackerWithMax negativeRights = new SetTrackerWithMax();\n\n        public Magic(int totalComponents) {\n            numImpossible = totalComponents;\n        }\n\n        private void addSegment(int left, int right) {\n            lefts.add(left);\n            negativeRights.add(-right);\n        }\n\n        private void removeSegment(int left, int right) {\n            lefts.remove(left);\n            negativeRights.remove(-right);\n        }\n\n        public void addComponent(Component comp) {\n            if (comp.insideMask == 0) {\n                ++numImpossible;\n            } else if (comp.insideMask == 6) {\n                if (comp.r1 > comp.r2) {\n                    addSegment(comp.l1, comp.r1);\n                } else {\n                    addSegment(comp.l2, comp.r2);\n                }\n            } else if (comp.insideMask == 2) {\n                addSegment(comp.l2, comp.r2);\n            } else if (comp.insideMask == 4) {\n                addSegment(comp.l1, comp.r1);\n            } else {\n                throw new RuntimeException();\n            }\n        }\n\n        public void removeComponent(Component comp) {\n            if (comp.insideMask == 0) {\n                --numImpossible;\n            } else if (comp.insideMask == 6) {\n                if (comp.r1 > comp.r2) {\n                    removeSegment(comp.l1, comp.r1);\n                } else {\n                    removeSegment(comp.l2, comp.r2);\n                }\n            } else if (comp.insideMask == 2) {\n                removeSegment(comp.l2, comp.r2);\n            } else if (comp.insideMask == 4) {\n                removeSegment(comp.l1, comp.r1);\n            } else {\n                throw new RuntimeException();\n            }\n        }\n\n        public void markComponent(Component comp) {\n            if (comp.insideMask == 0) {\n                throw new RuntimeException();\n            } else if (comp.insideMask == 6) {\n                if (comp.r1 > comp.r2) {\n                    comp.markAs(2);\n                } else {\n                    comp.markAs(1);\n                }\n            } else if (comp.insideMask == 2) {\n                comp.markAs(1);\n            } else if (comp.insideMask == 4) {\n                comp.markAs(2);\n            } else {\n                throw new RuntimeException();\n            }\n        }\n    }\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int t = in.nextInt();\n        int T = in.nextInt();\n        int n = in.nextInt();\n        int m = in.nextInt();\n        Teacher[] teachers = new Teacher[n];\n        for (int i = 0; i < n; ++i) {\n            teachers[i] = new Teacher();\n            teachers[i].l = in.nextInt();\n            teachers[i].r = in.nextInt();\n        }\n        for (int i = 0; i < m; ++i) {\n            Teacher a = teachers[in.nextInt() - 1];\n            Teacher b = teachers[in.nextInt() - 1];\n            a.conflicts.add(b);\n            b.conflicts.add(a);\n        }\n\n        List<Component> components = new ArrayList<>(teachers.length);\n        for (Teacher teacher : teachers) if (teacher.kind == 0) {\n            Component c = new Component();\n            c.l1 = 0;\n            c.r1 = T;\n            c.l2 = 0;\n            c.r2 = T;\n            c.root = teacher;\n            if (!teacher.buildComponent(c, 1)) {\n                out.println(""IMPOSSIBLE"");\n                return;\n            }\n            if (c.l1 > c.r1 || c.l2 > c.r2) {\n                out.println(""IMPOSSIBLE"");\n                return;\n            }\n            components.add(c);\n        }\n\n        List<Event> events = new ArrayList<>(4 * components.size());\n        for (Component c : components) {\n            events.add(new Event(c.l1, c, 1));\n            events.add(new Event(c.r1 + 1, c, 1));\n            events.add(new Event(c.l2, c, 2));\n            events.add(new Event(c.r2 + 1, c, 2));\n        }\n        Collections.sort(events, new Comparator<Event>() {\n            public int compare(Event o1, Event o2) {\n                return o1.when - o2.when;\n            }\n        });\n\n        Magic magic = new Magic(components.size());\n\n        int ptr = 0;\n        while (ptr < events.size()) {\n            int count = events.get(ptr).when;\n            while (ptr < events.size() && events.get(ptr).when == count) {\n                Event cur = events.get(ptr++);\n                magic.removeComponent(cur.which);\n                cur.which.insideMask ^= (1 << cur.compIndex);\n                magic.addComponent(cur.which);\n            }\n\n            if (magic.numImpossible == 0) {\n                int nextAt = events.get(ptr).when;\n                int oleft = magic.lefts.getMax();\n                int oright = -magic.negativeRights.getMax();\n                if (oleft <= oright) {\n                    if (count + oleft <= T && nextAt - 1 + oright >= t) {\n                        out.println(""POSSIBLE"");\n                        int n1 = count;\n                        int n2 = oleft;\n                        if (n1 + n2 < t) {\n                            int extra = t - n1 - n2;\n                            int by = Math.min(extra, nextAt - 1 - count);\n                            extra -= by;\n                            n1 += by;\n                            by = Math.min(extra, oright - oleft);\n                            extra -= by;\n                            n2 += by;\n                            if (extra != 0) throw new RuntimeException();\n                        }\n                        if (n1 + n2 < t || n1 + n2 > T) throw new RuntimeException();\n                        out.println(n1 + "" "" + n2);\n                        for (Component c : components) {\n                            magic.markComponent(c);\n                        }\n                        for (Teacher teacher : teachers) {\n                            out.print(teacher.res);\n                        }\n                        out.println();\n                        return;\n                    }\n                }\n            }\n        }\n        out.println(""IMPOSSIBLE"");\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}\n\n","2-sat,data structures,dfs and similar,greedy"
"import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Div1_296E {\n\n	public static void main(String[] args) throws IOException {\n		new Div1_296E().execute();\n	}\n\n	void execute() throws IOException {\n		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		int nL = Integer.parseInt(reader.readLine());\n		Line[] lines = new Line[nL];\n		for (int i = 0; i < nL; i++) {\n			StringTokenizer inputData = new StringTokenizer(reader.readLine());\n			lines[i] = new Line(Integer.parseInt(inputData.nextToken()), Integer.parseInt(inputData.nextToken()),\n					Integer.parseInt(inputData.nextToken()));\n		}\n\n		Arrays.sort(lines);\n\n		double res = 0;\n		for (int bI = 0; bI < nL; bI++) {\n			Vector pSum = new Vector(0, 0);\n			for (int dI = 1; dI < nL; dI++) {\n				Vector cInter = inter(lines[bI], lines[(bI + dI) % nL]);\n				res += crossMag(pSum, cInter);\n				pSum.pE(cInter);\n			}\n		}\n		res *= 3.0 / ((long) nL * (nL - 1) * (nL - 2));\n		printer.println(res);\n		printer.close();\n	}\n\n	class Line implements Comparable<Line> {\n		double A;\n		double B;\n		double C;\n		double ang;\n\n		Line(int A, int B, int C) {\n			if (A < 0) {\n				A = -A;\n				B = -B;\n				C = -C;\n			}\n			this.A = A;\n			this.B = B;\n			this.C = C;\n			ang = Math.atan2(-B, A);\n		}\n\n		public int compareTo(Line o) {\n			return -Double.compare(ang, o.ang);\n		}\n	}\n\n	// Cramer's rule\n	Vector inter(Line l1, Line l2) {\n		double det = l1.A * l2.B - l1.B * l2.A;\n		return new Vector((l1.C * l2.B - l1.B * l2.C) / det, (l1.A * l2.C - l1.C * l2.A) / det);\n	}\n\n	double crossMag(Vector v1, Vector v2) {\n		return v1.x * v2.y - v1.y * v2.x;\n	}\n\n	class Vector {\n		double x;\n		double y;\n\n		Vector(double x, double y) {\n			this.x = x;\n			this.y = y;\n		}\n\n		void pE(Vector addend) {\n			x += addend.x;\n			y += addend.y;\n		}\n	}\n}\n","geometry,sortings"
"import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Los {\n\n	public static void main(String[] args) throws IOException {\n		new Los().execute();\n	}\n\n	void execute() throws IOException {\n		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		int nL = Integer.parseInt(reader.readLine());\n		Line[] lines = new Line[nL];\n		for (int i = 0; i < nL; i++) {\n			StringTokenizer inputData = new StringTokenizer(reader.readLine());\n			lines[i] = new Line(Integer.parseInt(inputData.nextToken()), Integer.parseInt(inputData.nextToken()),\n					Integer.parseInt(inputData.nextToken()));\n		}\n\n		Arrays.sort(lines);\n\n		double res = 0;\n		for (int bI = 0; bI < nL; bI++) {\n			Vector pSum = new Vector(0, 0);\n			for (int dI = 1; dI < nL; dI++) {\n				Vector cInter = inter(lines[bI], lines[(bI + dI) % nL]);\n				res += crossMag(pSum, cInter);\n				pSum.pE(cInter);\n			}\n		}\n		res *= 3.0 / ((long) nL * (nL - 1) * (nL - 2));\n		printer.println(res);\n		printer.close();\n	}\n\n	class Line implements Comparable<Line> {\n		double A;\n		double B;\n		double C;\n		double ang;\n\n		Line(int A, int B, int C) {\n			if (A < 0) {\n				A = -A;\n				B = -B;\n				C = -C;\n			}\n			this.A = A;\n			this.B = B;\n			this.C = C;\n			ang = Math.atan2(-B, A);\n		}\n\n		public int compareTo(Line o) {\n			return -Double.compare(ang, o.ang);\n		}\n	}\n\n	// Cramer's rule\n	Vector inter(Line l1, Line l2) {\n		double det = l1.A * l2.B - l1.B * l2.A;\n		return new Vector((l1.C * l2.B - l1.B * l2.C) / det, (l1.A * l2.C - l1.C * l2.A) / det);\n	}\n\n	double crossMag(Vector v1, Vector v2) {\n		return v1.x * v2.y - v1.y * v2.x;\n	}\n\n	class Vector {\n		double x;\n		double y;\n\n		Vector(double x, double y) {\n			this.x = x;\n			this.y = y;\n		}\n\n		void pE(Vector addend) {\n			x += addend.x;\n			y += addend.y;\n		}\n	}\n}","geometry,sortings"
"import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		FastScanner in = new FastScanner(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		TaskE solver = new TaskE();\n		solver.solve(1, in, out);\n		out.close();\n	}\n}\n\nclass TaskE {\n	public void solve(int testNumber, FastScanner in, PrintWriter out) {\n		int n = in.nextInt();\n		Line[] lines = new Line[n];\n		for (int i = 0; i < n; i++) {\n			int a = in.nextInt();\n			int b = in.nextInt();\n			int c = in.nextInt();\n			lines[i] = new Line(a, b, c);\n		}\n		Arrays.sort(lines, new Comparator<Line>() {\n			public int compare(Line l1, Line l2) {\n				boolean u1 = l1.b > 0 || l1.b == 0 && l1.a > 0;\n				boolean u2 = l2.b > 0 || l2.b == 0 && l2.a > 0;\n				if (u1 != u2) {\n					return u1 ? 1 : -1;\n				}\n				double cr = l1.a*l2.b - l2.a*l1.b;\n				return -Double.compare(cr, 0);\n			}\n		});\n		double ans = 0;\n		for (int i = 0; i < n; i++) {\n			Point sum = new Point(0, 0);\n			for (int step = 1; step < n; step++) {\n				int j = (i + step) % n;\n				Point p = intersect(lines[i], lines[j]);\n				ans += sum.x * p.y - p.x * sum.y;\n				sum.x += p.x;\n				sum.y += p.y;\n			}\n		}\n		double total = (double) n * (n - 1) * (n - 2) / 6.0;\n		ans /= total;\n		ans /= 2;\n		out.printf(""%.10f\n"", ans);\n	}\n\n	final double eps = 1e-8;\n\n	private Point intersect(Line l1, Line l2) {\n		double det = l1.a*l2.b - l1.b*l2.a;\n		if (Math.abs(det) < eps) {\n			return null;\n		}\n		double x = (l1.c*l2.b - l1.b*l2.c) / det;\n		double y = (l1.a*l2.c - l1.c*l2.a) / det;\n		return new Point(x, y);\n	}\n\n	class Point {\n		double x, y;\n		Point(double x, double y) {\n			this.x = x;\n			this.y = y;\n		}\n	}\n\n	class Line {\n		double a, b, c;\n		Line(double a, double b, double c) {\n			if (a < 0) {\n				a = -a;\n				b = -b;\n				c = -c;\n			}\n			this.a = a;\n			this.b = b;\n			this.c = c;\n		}\n	}\n}\n\nclass FastScanner {\n\n	private BufferedReader in;\n	private StringTokenizer st;\n\n	public FastScanner(InputStream stream) {\n		in = new BufferedReader(new InputStreamReader(stream));\n	}\n\n	public String next() {\n		while (st == null || !st.hasMoreTokens()) {\n			try {\n				String rl = in.readLine();\n				if (rl == null) {\n					return null;\n				}\n				st = new StringTokenizer(rl);\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n		}\n		return st.nextToken();\n	}\n\n	public int nextInt() {\n		return Integer.parseInt(next());\n	}\n\n}\n\n","geometry,sortings"
"import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		FastScanner in = new FastScanner(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		TaskE solver = new TaskE();\n		solver.solve(1, in, out);\n		out.close();\n	}\n}\n\nclass TaskE {\n	public void solve(int testNumber, FastScanner in, PrintWriter out) {\n		int n = in.nextInt();\n		Line[] lines = new Line[n];\n		for (int i = 0; i < n; i++) {\n			int a = in.nextInt();\n			int b = in.nextInt();\n			int c = in.nextInt();\n			lines[i] = new Line(a, b, c);\n		}\n		Arrays.sort(lines, new Comparator<Line>() {\n			public int compare(Line l1, Line l2) {\n				boolean u1 = l1.b > 0 || l1.b == 0 && l1.a > 0;\n				boolean u2 = l2.b > 0 || l2.b == 0 && l2.a > 0;\n				if (u1 != u2) {\n					return u1 ? 1 : -1;\n				}\n				double cr = l1.a*l2.b - l2.a*l1.b;\n				return -Double.compare(cr, 0);\n			}\n		});\n		double ans = 0;\n		for (int i = 0; i < n; i++) {\n			Point sum = new Point(0, 0);\n			for (int step = 1; step < n; step++) {\n				int j = (i + step) % n;\n				Point p = intersect(lines[i], lines[j]);\n				ans += cross(sum, p);\n				sum.x += p.x;\n				sum.y += p.y;\n			}\n		}\n		double total = (double) n * (n - 1) * (n - 2) / 6.0;\n		ans /= total;\n		ans /= 2;\n		out.printf(""%.10f\n"", ans);\n	}\n\n	final double eps = 1e-8;\n\n	private double cross(Point a, Point b) {\n		return a.x*b.y - a.y*b.x;\n	}\n\n	private Point intersect(Line l1, Line l2) {\n		double det = l1.a*l2.b - l1.b*l2.a;\n		if (Math.abs(det) < eps) {\n			return null;\n		}\n		double x = (l1.c*l2.b - l1.b*l2.c) / det;\n		double y = (l1.a*l2.c - l1.c*l2.a) / det;\n		return new Point(x, y);\n	}\n\n	class Point {\n		double x, y;\n		Point(double x, double y) {\n			this.x = x;\n			this.y = y;\n		}\n	}\n\n	class Line {\n		double a, b, c;\n		Line(double a, double b, double c) {\n			if (a < 0) {\n				a = -a;\n				b = -b;\n				c = -c;\n			}\n			this.a = a;\n			this.b = b;\n			this.c = c;\n		}\n	}\n}\n\nclass FastScanner {\n\n	private BufferedReader in;\n	private StringTokenizer st;\n\n	public FastScanner(InputStream stream) {\n		in = new BufferedReader(new InputStreamReader(stream));\n	}\n\n	public String next() {\n		while (st == null || !st.hasMoreTokens()) {\n			try {\n				String rl = in.readLine();\n				if (rl == null) {\n					return null;\n				}\n				st = new StringTokenizer(rl);\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n		}\n		return st.nextToken();\n	}\n\n	public int nextInt() {\n		return Integer.parseInt(next());\n	}\n\n}\n\n","geometry,sortings"
"import java.io.*;\nimport java.util.*;\npublic class Main\n{\n	int n,k;\n	private void solve()throws IOException\n	{\n		fact();\n		n=nextInt();\n		k=nextInt();\n		String s=nextLine();\n		int a[]=new int[n+1];\n		for(int i=1;i<=n;i++)\n			a[i]=s.charAt(i-1)-'0';\n		if(k==0)\n		{\n			long ans=0;\n			long pow=1;\n			for(int i=n;i>=1;i--)\n			{\n				ans=(ans+(a[i]*pow)%mod)%mod;\n				pow=(pow*10)%mod;\n			}\n			out.println(ans);\n			return;\n		}\n		long sum[]=new long[n+1];\n		long pow[]=new long[n+1];\n		pow[0]=1;\n		for(int i=0;i<=n;i++)\n		{\n			if(i!=0)\n			{\n				sum[i]=sum[i-1];\n				pow[i]=(pow[i-1]*10)%mod;\n			}\n			int gaps=n-2-i;//no of gaps to put k-1 pluses\n			if(gaps>=k-1)\n				sum[i]+=(choose(gaps,k-1)*pow[i])%mod;\n		}\n		long ans=0;\n		for(int i=1;i<=n;i++)\n		{\n			int r=n-i;//highest base with which this number can appear\n			if(r-1>=0)\n			ans=(ans+(sum[r-1]*a[i])%mod)%mod;\n			if(i-1>=k)\n			ans=(ans+(a[i]*(pow[r]*choose(i-1,k))%mod)%mod)%mod;\n		}\n		out.println(ans);\n	}\n\n	final long mod=(long)(1e9+7);\n	final int maxn=(int)(1e5);\n	long choose(int n,int r)\n	{\n		return (((fact[n]*modinv(fact[r]))%mod)*modinv(fact[n-r]))%mod;\n	}\n	long modinv(long x){\n	    return modpow(x,mod-2);\n	}\n	long modpow(long a,long b){\n	    long ret=1;\n	    while(b!=0)\n	    {\n	        if(b%2==1)\n	            ret=(ret*a)%mod;\n	        a=(a*a)%mod;\n	        b=b/2;\n	    }\n	    return ret;\n	} \n	long fact[];\n	void fact(){\n		fact=new long[maxn+1];\n		fact[0]=1;\n		for(int i=1;i<=maxn;i++)\n			fact[i]=(fact[i-1]*i)%mod;\n	}\n\n	 \n	///////////////////////////////////////////////////////////\n\n	public void run()throws IOException\n	{\n		br=new BufferedReader(new InputStreamReader(System.in));\n		st=null;\n		out=new PrintWriter(System.out);\n\n		solve();\n\n		br.close();\n		out.close();\n	}\n	public static void main(String args[])throws IOException{\n		new Main().run();\n	}\n	BufferedReader br;\n	StringTokenizer st;\n	PrintWriter out;\n	String nextToken()throws IOException{\n		while(st==null || !st.hasMoreTokens())\n		st=new StringTokenizer(br.readLine());\n		return st.nextToken();\n	}\n	String nextLine()throws IOException{\n		return br.readLine();\n	}\n	int nextInt()throws IOException{\n		return Integer.parseInt(nextToken());\n	}\n	long nextLong()throws IOException{\n		return Long.parseLong(nextToken());\n	}\n	double nextDouble()throws IOException{\n		return Double.parseDouble(nextToken());\n	}\n}","combinatorics,dp,math,number theory"
"import java.io.*;\nimport static java.lang.Math.*;\nimport java.util.*;\n\npublic class C {\n    public static void main(String[] args) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer stok = new StringTokenizer(in.readLine());\n        int N = Integer.valueOf(stok.nextToken());\n        int K = Integer.valueOf(stok.nextToken());\n        String S = in.readLine().trim();\n\n        fact = new long[N];\n        fact[0] = 1;\n        invFact = new long[N];\n        invFact[0] = 1;\n        for (int i = 1; i < N; i++) {\n            fact[i] = (fact[i - 1] * i) % MOD;\n            invFact[i] = (pow(i, MOD - 2) * invFact[i-1]) % MOD;\n        }\n\n        long ans = ((S.charAt(N - 1) - '0') * choose(N - 1, K)) % MOD;\n        //System.out.println(ans+"" ""+(S.charAt(N-1)-'0')+"" ""+choose(N-1, K));\n        long old = 0;\n        long p10 = 1;\n        for (int i = 1; i < N; i++) {\n            long v = S.charAt(N - i - 1) - '0';\n            old = (old + choose(N - i - 1, K - 1) * p10) % MOD;\n            //System.out.println(v+"" ""+i+"" ""+old +"" ""+ans);\n            p10 = (p10 * 10) % MOD;\n            ans = (ans + v * old) % MOD;\n            ans = (ans + v * choose(N - i - 1, K) * p10) % MOD;\n        }\n        System.out.println(ans);\n    }\n    static long MOD = 1_000_000_007L;\n    static long[] fact, invFact;\n    static long pow(long a, long b) {\n        long ans = 1;\n        while (b > 0) {\n            if (b % 2 == 1) {\n                ans = (ans * a) % MOD;\n            }\n            a = (a * a) % MOD;\n            b /= 2;\n        }\n        return ans;\n    }\n    static long choose(int a, int b) {\n        if (b < 0 || b > a)\n            return 0;\n        long ans = (fact[a] * invFact[b]) % MOD;\n        ans = (ans * invFact[a - b]) % MOD;\n        return ans;\n    }\n}\n","combinatorics,dp,math,number theory"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.StringTokenizer;\n\n/**\n * @author Pavel Mavrin\n */\npublic class E {\n\n    private void solve() throws IOException {\n        int n = nextInt();\n        int k = nextInt();\n        String s = next();\n        init(n);\n        long res = 0;\n        long m = 0;\n        long p10 = 1;\n        for (int i = n - 1; i >= 0; i--) {\n            long q = c(i, k) * p10;\n            q %= MOD;\n            q += m;\n            q %= MOD;\n            q *= (s.charAt(i) - '0');\n            q %= MOD;\n            res += q;\n            res %= MOD;\n\n            m += (c(i - 1, k - 1) * p10) % MOD;\n            m %= MOD;\n\n            p10 = p10 * 10 % MOD;\n        }\n        out.println(res);\n    }\n\n    private static final long MOD = (long) (1e9 + 7);\n    private static final BigInteger MOD2 = BigInteger.valueOf(MOD);\n\n    long[] fact;\n    long[] invf;\n\n    void init(int n) {\n        fact = new long[n + 1];\n        invf = new long[n + 1];\n        fact[0] = 1;\n        invf[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fact[i] = fact[i - 1] * i;\n            fact[i] %= MOD;\n            invf[i] = BigInteger.valueOf(fact[i]).modInverse(MOD2).longValue();\n        }\n    }\n\n    private long c(int n, int k) {\n        if (k > n || k < 0) return 0;\n        long res = fact[n] * invf[k];\n        res %= MOD;\n        res *= invf[n - k];\n        res %= MOD;\n        return res;\n    }\n\n\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer st;\n    PrintWriter out = new PrintWriter(System.out);\n\n    String next() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new E().run();\n    }\n\n    private void run() throws IOException {\n        solve();\n        out.close();\n    }\n\n}\n","combinatorics,dp,math,number theory"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main\n{\n\n    static int maxn = 100005;\n	static char d[];\n	static long pow10[] = new long[maxn];\n	static long fac[] = new long[maxn];\n	static long sum[] = new long[maxn];\n	static long mod = 1000*1000*1000 + 7;\n	\n	static long put(long x, long y)\n	{\n		long p = 1;\n		for(int i= 1 ; i <= y; i<<=1 )\n		{\n			if((y & i) != 0) p= (1L*p*x) %mod;\n			x = (1L*x*x) %mod;\n		}\n		return p;\n	}\n\n	static long nCk(long n,long m)\n	{\n	    if(n < 0 || m < 0 || m > n)\n	    return 0;\n	    \n		return (1L * fac[(int)n] * put( (1L * fac[(int)m] * fac[(int)(n-m)] ) % mod, mod - 2 ))%mod;\n	}\n	static int n,k;\n	public static void main(String[]args)throws Throwable\n	{\n		Scanner sc = new Scanner(System.in);\n		n = sc.nextInt();\n		k = sc.nextInt();\n	    d = sc.next().toCharArray();\n		fac[0] = 1;\n	  pow10[0] = 1;\n 	for (int i = 1 ; i < maxn ; ++i) {\n		fac[i] = 1L*fac[i - 1] * i%mod;\n		fac[i] %= mod;\n		pow10[i] = 10L*pow10[i - 1];\n		pow10[i] %= mod;\n	}\n	\n	sum[0] = d[0] - '0';\n	for(int i = 1 ; i < n ;++i) { \n	    sum[i] = sum[i - 1] + (d[i] - '0');\n	    sum[i]%=mod;\n	}\n	long ans = 0;\n	for(int l = 0 ; l < n ; ++l) {\n		if(n - l - 2 < 0)\n			continue;\n		long cho = nCk(n - l - 2,k - 1);\n		cho %= mod;\n		cho *= pow10[l];\n		cho %= mod;\n		cho *= 1L*sum[n - l - 2];\n		cho %= mod;\n		ans += 1L*cho;\n		ans %= mod;\n	}\n	for(int i = 0 ; i < n ; ++i) {\n		int l = n - i - 1;\n		if(l < 0)\n			continue;\n		long tmp = pow10[l];\n		tmp %= mod;\n		tmp *= (d[i] - '0');\n		tmp %= mod;\n		tmp *= nCk(n - l - 1,k);\n		tmp %= mod;\n		ans += 1L*tmp;\n		ans %= mod;\n	}\n	System.out.println(ans);\n\n	\n\n	}\n\n	static class Scanner\n	{\n		BufferedReader br;\n		StringTokenizer st;\n\n\n		Scanner(InputStream s)  { br = new BufferedReader(new InputStreamReader(s)); }\n\n		String next() throws IOException\n		{\n			while(st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n\n		}\n\n		int nextInt() throws NumberFormatException, IOException { return Integer.parseInt(next()); }\n\n	}\n\n}","combinatorics,dp,math,number theory"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF518E extends PrintWriter {\n	CF518E() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF518E o = new CF518E(); o.main(); o.flush();\n	}\n\n	static final int INF = 0x3f3f3f3f;\n	boolean solve(int[] aa, int i0, int k, int n) {\n		int a_ = -INF;\n		for (int i = -1, j; i < n; i = j) {\n			j = i + 1;\n			while (j < n && aa[i0 + j * k] == INF)\n				j++;\n			int b_ = j == n ? INF : aa[i0 + j * k];\n			if (b_ - a_ < j - i)\n				return false;\n			int m = j - i - 1;\n			int r = (m - 1) / 2;\n			int l = r - m + 1;\n			if (r >= b_) {\n				r = b_ - 1;\n				l = r - m + 1;\n			}\n			if (l <= a_) {\n				l = a_ + 1;\n				r = l + m - 1;\n			}\n			for (int h = i + 1; h < j; h++)\n				aa[i0 + h * k] = l++;\n			a_ = b_;\n		}\n		return true;\n	}\n	void main() {\n		int n = sc.nextInt();\n		int k = sc.nextInt();\n		int[] aa = new int[n];\n		for (int i = 0; i < n; i++) {\n			String s = sc.next();\n			aa[i] = s.charAt(0) == '?' ? INF : Integer.parseInt(s);\n		}\n		for (int i0 = 0; i0 < k; i0++)\n			if (!solve(aa, i0, k, (n - 1 - i0) / k + 1)) {\n				println(""Incorrect sequence"");\n				return;\n			}\n		for (int i = 0; i < n; i++)\n			print(aa[i] + "" "");\n		println();\n	}\n}\n","greedy,implementation,math,ternary search"
"import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class E {\n	static int n, k, QM;\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		n = in.nextInt();\n		k = in.nextInt();\n		QM = Integer.MAX_VALUE;\n		String reg;\n		List<Integer>[] sseq = new ArrayList[k];\n		for (int i=0; i<n; i++) {\n			int j = i%k;\n			if (sseq[j] == null) {\n				sseq[j] = new ArrayList<Integer>();\n			}\n			reg = in.next();\n			\n			if (reg.equals(""?"")) {\n				sseq[j].add(QM);\n			} else {\n				sseq[j].add(Integer.valueOf(reg));\n			}\n		}\n		for (int i=0; i<sseq.length; i++) {\n			sseq[i] = solve(sseq[i]);\n			if (sseq[i]==null) {\n				System.out.println(""Incorrect sequence"");\n				return;\n}		}\n		\n		for (int i=0; i<n; i++) {\n			System.out.print(sseq[i%k].get(i/k)+"" "");\n		}\n	}\n	private static List<Integer> solve(List<Integer> seq) {\n		seq.add(0, (int)-2e9);\n		seq.add((int) 2e9);\n\n		List<Integer> result = new ArrayList<>();\n		int b, e, cnt;\n\n		for (b=0; b<seq.size()-1;) {\n			e = b+1;\n			\n			while (e<seq.size() && seq.get(e) == QM) {\n				e++;\n			}\n			cnt = e-b-1;\n			if (seq.get(b) + cnt >= seq.get(e)) {\n				return null;\n			}\n			\n			int from  = seq.get(b);\n			int to = seq.get(e);\n			result.add(from);\n			\n			if (from >=0 && to >=0) {\n				for (int i1=0; i1<cnt; i1++) {\n					result.add(from + i1 + 1);\n				}\n			} else if (from <=0 && to <=0){\n				for (int i1=0; i1<cnt; i1++) {\n					result.add(to-cnt+i1);\n				}\n			} else {\n				List<Integer> list = new ArrayList<Integer>();\n				for (int x=0; cnt>0; x++) {\n					if (cnt>0 && from < x && x < to){\n						list.add(x);\n						cnt--;\n					}\n					if (x==0) {\n						continue;\n					}\n					if (cnt>0 && from < -x && -x < to) {\n						list.add(-x);\n						cnt--;\n					}\n				}\n				Collections.sort(list);\n				result.addAll(list);\n			}\n			b = e;\n		}\n		result.remove(0);\n		for (int i=0; i<result.size()-1; i++) {\n			if (result.get(i) >= result.get(i+1)) {\n				return null;\n			}\n		}\n		return result;\n	}\n\n}","greedy,implementation,math,ternary search"
"import java.io.*;\nimport java.util.*;\n\npublic class Div2_293_E{\n	static final int MIN = -2000000010;\n	static final int MAX = 2000000010;\n	public static void main(String[] args) throws IOException{\n		BufferedInputStream bis = new BufferedInputStream(System.in);\n		BufferedReader br = new BufferedReader(new InputStreamReader(bis));\n		PrintWriter prnt = new PrintWriter(System.out);\n		StringTokenizer tok = new StringTokenizer(br.readLine());\n		int n = Integer.parseInt(tok.nextToken());\n		int k = Integer.parseInt(tok.nextToken());\n		ArrayList <Integer> [] chains = new ArrayList [k];\n		tok = new StringTokenizer(br.readLine());\n		for(int i = 0;i < n;i++) {\n			String curr = tok.nextToken();\n			if(chains[i%k] == null) {\n				chains[i%k] = new ArrayList<Integer>();\n				chains[i%k].add(MIN);\n			}\n			if(curr.charAt(0)!='?') {\n				chains[i%k].add(Integer.parseInt(curr));\n			} else\n				chains[i%k].add(Integer.MAX_VALUE); \n		}\n		\n		ArrayList<Integer> chain;\n		for(int i = 0;i < k;i++) {\n			chains[i].add(MAX);\n			ArrayList<Integer> res = new ArrayList<Integer>();\n			int from = 0, to = from;\n			chain = chains[i];\n			while(from < chain.size()-1) {\n				for(to = from+1;to < chain.size() && chain.get(to) == Integer.MAX_VALUE;to ++);\n				int len = (to-from)-1;\n				int maxVal = chain.get(to), minVal = chain.get(from);\n				res.add(minVal);\n				if(maxVal <= minVal+len) {\n					System.out.println(""Incorrect sequence"");\n					return;\n				}\n				if(minVal >= 0 && maxVal >= 0) {\n					for(int j = 1;j <= len;j++) {\n						res.add(minVal+j);\n					}\n				}else if(maxVal <= 0 && minVal <= 0) {\n					for(int j = 0;j < len;j++)\n						res.add(maxVal-len+j);\n				}else if(len != 0){\n					ArrayList<Integer> temp = new ArrayList<Integer>();	\n					if(minVal < 0 && maxVal > 0) {\n						temp.add(0);\n						len--;\n					}\n					for(int cnt = 1;len > 0;cnt++) {\n						if(minVal < cnt && maxVal > cnt && len > 0) {\n							temp.add(cnt);\n							len--;\n						}\n						if(minVal < -cnt && maxVal > -cnt && len > 0) {\n							temp.add(-cnt);\n							len--;\n						}\n					}\n					Collections.sort(temp);\n					res.addAll(temp);\n				}\n				from = to;\n			}\n			res.remove(0);\n			for(int j = 0;j < res.size()-1;j++) {\n				if(res.get(j) >= res.get(j+1)) {\n					prnt.println(""Incorrect sequence"");\n					return;\n				}\n			}\n			chains[i] = res;\n		}\n		prnt.print(chains[0].get(0));\n		for(int i = 1;i < n;i++)\n			prnt.print("" ""+chains[i%k].get(i/k));\n		prnt.println();\n		prnt.close();\n	}\n}\n","greedy,implementation,math,ternary search"
"import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Created by liqiu on 2/24/15.\n */\npublic class E {\n    static long inf = (long) 1e10;\n    public static void main(String[] args) {\n        Scanner cin = new Scanner(System.in);\n        int n = cin.nextInt();\n        int k = cin.nextInt();\n        long[] lower = new long[n];\n        long[] up = new long[n];\n        Arrays.fill(lower, -inf);\n        Arrays.fill(up, inf);\n        long[] a = new long[n];\n        for (int i = 0; i < n; ++i) {\n            String s = cin.next();\n            if (s.equals(""?"")) a[i] = -inf;\n            else a[i] = Long.parseLong(s);\n        }\n        for(int rem = 0; rem < k; ++rem){\n            ArrayList<Integer> pos = new ArrayList<Integer>();\n            long low = -inf; long high = inf;\n            for(int i = rem; i < n; i += k){\n                if( a[i] == -inf ){\n                    pos.add(i);\n                }else {\n                    high = a[i] - 1;\n                    int cnt = pos.size();\n                    if (high - low + 1 < cnt) {\n                        System.out.println(""Incorrect sequence"");\n                        return;\n                    }\n                    if (cnt > 0) {\n                        long lf = low + cnt / 2;\n                        long rt = high - (cnt - 1 - cnt / 2);\n                        long base = 0;\n                        if (lf > 0) base = lf;\n                        else if (rt < 0) base = rt;\n                        else base = 0;\n                        for (int j = 0; j < cnt; ++j) a[pos.get(j)] = j - cnt / 2 + base;\n                        pos.clear();\n                    }\n                    low = a[i] + 1;\n                    high = inf;\n                }\n            }\n            //check last one\n            int cnt = pos.size();\n            if( high  - low + 1 < cnt ){\n                System.out.println(""Incorrect sequence"");\n                return;\n            }\n            if( cnt > 0 ) {\n//                System.out.println(pos.size() + ""--"" + rem);\n                long lf = low + cnt / 2;\n                long rt = high - (cnt - 1 - cnt/2);\n                long base = 0;\n                if( lf > 0 ) base = lf;\n                else if(rt < 0 ) base = rt;\n                else base = 0;\n                for(int j = 0; j < cnt; ++j) a[ pos.get(j) ] = j - cnt / 2 + base;\n                pos.clear();\n            }\n        }\n        for(int i = 0; i < n; ++i)\n            System.out.print(a[i] + "" "");\n        System.out.println();\n    }\n}\n","greedy,implementation,math,ternary search"
"import java.util.Scanner;\nimport java.util.Arrays;\n \npublic class Main {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        char s[] = scan.next().toCharArray();\n        char t[] = scan.next().toCharArray();\n        for(int i = s.length - 1; i >= 0; i--){\n           if(s[i]== 'z'){\n               s[i] = 'a';\n           } else {\n               s[i] += 1;\n               break;\n           }\n        }\n        System.out.print(Arrays.equals(s,t) ? ""No such string"".toCharArray() : s);\n    }\n}","constructive algorithms,strings"
"\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String []arg) {\n\n      Scanner sc  = new Scanner(System.in);\n      char []c1  = sc.nextLine().toCharArray();\n      char []c2 = sc.nextLine().toCharArray();\n\n      for(int i = c1.length -1 ; i>=0 ;--i) {\n          if(c1[i]=='z') {\n              c1[i] = 'a';\n          } else {\n              ++c1[i];\n              break;\n          }\n      }\n\n      for(int i = 0 ; i < c1.length;++i) {\n          if(c1[i]<c2[i]) {\n              System.out.println(new String(c1));\n              return;\n          }\n      }\n        System.out.println(""No such string"");\n\n    }\n\n}\n","constructive algorithms,strings"
"import java.util.*;\n\npublic class VitalyAndStrings {\n\n    static StringBuilder o = new StringBuilder();\n    \n	static StringBuilder f(String s) {\n		if (s.charAt(s.length()-1)=='z') {\n			f(s.substring(0,s.length()-1)).append('a');\n		} else {\n			o.append(s.substring(0,s.length()-1)).append(Character.toString((int)s.charAt(s.length()-1)+1));\n		}\n		return o;\n	}\n\n	static void solve() {\n		Scanner sc = new Scanner(System.in);\n		String s = sc.next(), t = sc.next();\n		s = f(s).toString();\n		if (s.compareTo(t)<0) {\n			System.out.println(s);\n		} else {\n			System.out.println(""No such string"");\n		}\n		sc.close();\n	}\n\n	public static void main(String[] args) {\n		solve();\n	}\n\n}\n","constructive algorithms,strings"
"import java.util.Scanner;\n\npublic class Solution150220 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.nextLine();\n        String t = scanner.nextLine();\n\n        char[] out = s.toCharArray();\n        int length = out.length;\n        for (int i = length - 1; i >= 0; i--){\n            if(out[i] == 'z'){\n                out[i] = 'a';\n            } else {\n                out[i] += 1;\n                break;\n            }\n        }\n        String outString = String.valueOf(out);\n        if(!outString.equals(t)){\n            System.out.println(outString);\n        } else {\n            System.out.println(""No such string"");\n        }\n    }\n}","constructive algorithms,strings"
"import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n\npublic class G1 {\n\n	static int inv = 0;\n	static int K,n;\n	\n	public static void main(String args[] ) throws Exception {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	    PrintWriter w = new PrintWriter(System.out);\n	        \n	    StringTokenizer st1 = new StringTokenizer(br.readLine());\n	    n = ip(st1.nextToken());\n	    K = ip(st1.nextToken());\n	          \n	    StringTokenizer st2 = new StringTokenizer(br.readLine());\n	    int a[] = new int[n];\n	    for(int i=0;i<n;i++)\n	    	a[i] = ip(st2.nextToken());\n	         \n	    solve(a,0);\n	   \n	    double ans = inv;\n	    long den =(long)Math.pow(n*(n+1)/2,K);\n	    ans = ans/den;\n	    w.println(ans);\n	    w.close(); \n	}\n	\n	public static void solve(int[] a,int k){\n		if(k==K){\n			for(int i=0;i<a.length;i++)\n				for(int j=i+1;j<a.length;j++)\n					if(a[i]>a[j])\n						inv++;\n			return;\n		}\n		\n		for(int i=0;i<a.length;i++){\n			for(int j=i;j<a.length;j++){\n				int temp[] = new int[n];\n				for(int l=0;l<i;l++)\n					temp[l] = a[l];\n				for(int l=i;l<=j;l++)\n					temp[j-l+i]= a[l];\n				for(int l=j+1;l<n;l++)\n					temp[l] = a[l];\n				solve(temp,k+1);\n			}\n		}\n	}\n	\n	public static int ip(String s){\n		return Integer.parseInt(s);\n	}\n}\n","brute force,dfs and similar,dp,meet-in-the-middle"
"import java.util.Scanner;\n\npublic class Rockethon15 {\n    \n    public static double countInv(int[] p){\n        int c=0;\n        \n        for(int i=0;i<p.length;i++){\n            for(int j=i+1;j<p.length;j++){\n                if(p[i]>p[j])\n                    c++;\n            }\n        }\n        \n        return c;\n    }\n\n    static double deno=0;\n    public static double solve(int[] perm, int m){\n    \n        if(m==0){\n            deno++;\n            return countInv(perm);\n        }\n        \n        int n=perm.length;\n        double ans=0;\n        \n        int[] cur;\n        \n        for(int i=0;i<n;i++){\n            cur=new int[n];\n            for(int j=0;j<n;j++){\n                cur[j]=perm[j];\n            }\n            \n            for(int j=i;j<n;j++){\n                \n                for(int k=i;k<=j;k++){\n                    cur[k]=perm[j-k+i];\n                }\n                ans+=solve(cur, m-1);\n            }\n        }\n        \n        return ans;\n    }\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        \n        int n=sc.nextInt();\n        int m=sc.nextInt();\n        \n        int[] in=new int[n];\n        \n        for(int i=0;i<n;i++)\n            in[i]=sc.nextInt();\n        \n        \n        double nume=solve(in, m);\n        \n        System.out.println(nume/deno);\n\n    }\n}\n","brute force,dfs and similar,dp,meet-in-the-middle"
"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class G1 {\n\n    static int n;\n    static int k;\n    static double ans;\n    static double c;\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        k = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n        c = 1 / Math.pow((n * n + n) / 2, k);\n        go(0, a);\n        System.out.println(ans);\n        in.close();\n    }\n\n    public static void go(int cnt, int[] a) {\n        if (cnt == k) {\n            int sum = 0;\n            for (int i = 0; i < n; i++) {\n                for (int j = i; j < n; j++) {\n                    if (a[i] > a[j]) {\n                        sum++;\n                    }\n                }\n            }\n            ans += (double) sum * c;\n            return;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                for (int r = i; r <= (i + j) / 2; r++) {\n                    int tmp = a[j - (r - i)];\n                    a[j - (r - i)] = a[r];\n                    a[r] = tmp;\n                }\n                go(cnt + 1, a);\n                for (int r = i; r <= (i + j) / 2; r++) {\n                    int tmp = a[j - (r - i)];\n                    a[j - (r - i)] = a[r];\n                    a[r] = tmp;\n                }\n            }\n        }\n    }\n\n}\n","brute force,dfs and similar,dp,meet-in-the-middle"
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static int n;\n\n    static double res = 0;\n    static double config = 0;\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        StringTokenizer st = new StringTokenizer(in.readLine());\n        n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        int[] a = new int[n];\n        st = new StringTokenizer(in.readLine());\n        for (int i = 0; i < n; i++) a[i] = Integer.parseInt(st.nextToken());\n        recur(a, k);\n        out.println(res/config);\n        out.close();\n    }\n\n    static void recur(int[] a, int k) {\n        if (k == 0) {\n            int inv = 0;\n            for (int i = 0; i < n; i++) {\n                for (int j = i+1; j < n; j++) {\n                    if (a[j] < a[i]) {\n                        inv++;\n                    }\n                }\n            }\n            res += inv;\n            config++;\n            return;\n        }\n        for (int l = 0; l < n; l++) {\n            for (int r = l; r < n; r++) {\n                int[] copy = Arrays.copyOf(a, n);\n                for (int left = l, right = r; left < right; left++, right--) {\n                    int temp = copy[left];\n                    copy[left]  = copy[right];\n                    copy[right] = temp;\n                }\n                recur(copy, k-1);\n            }\n        }\n    }\n}\n\n/*\n\n */","brute force,dfs and similar,dp,meet-in-the-middle"
"\nimport java.util.*;\nimport java.lang.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner inp = new Scanner(System.in);\n        int n = inp.nextInt(), ans = 0;\n        Vector<Integer> v1 = new Vector<>(), v2 = new Vector<>();\n        for (int i = 0; i < n; i++) {\n            int x = inp.nextInt();\n            v1.add(x);\n            v2.add(x);\n        }\n        Collections.sort(v1);\n        long sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += v2.get(i) - v1.get(i);\n            if (sum == 0)\n                ans++;\n        }\n        System.out.println(ans);\n    }\n}\n",sortings
//package day.at.the.beach;\nimport java.util.*;\npublic class DayAtTheBeach {\n\n    public static void main(String[] args) {\n         Scanner input = new Scanner(System.in);\n         int n= input.nextInt();\n         Stack<Integer> s = new Stack<Integer>();\n        int[] arr = new int[n];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = input.nextInt();\n        }\n        int max = arr[0];\n        s.push(arr[0]);\n        for (int i=1;i<arr.length;i++){\n                if (arr[i]>=max) {\n                    s.push(arr[i]);\n                    max=arr[i];\n                }\n                else{    \n                     while(!s.isEmpty() && arr[i]<s.peek())\n                            s.pop();\n                     s.push(max);\n                }\n        }\n        System.out.println(s.size());\n    }\n}\n,sortings
"/* package codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n\n\n/* Name of the class has to be ""Main"" only if the class is public. */\npublic class Main\n \n \n{\n    static Scanner in = new Scanner(System.in);\n    \n    public static void solve()\n    {\n      \n        int n=in.nextInt();\n        int[] a = new int[n];\n        int[]b = new int[n];\n        for(int i=0;i<n;i++)\n        {\n            a[i]=in.nextInt();\n            b[i]=a[i];\n            \n        }\n        \n        Arrays.sort(b);\n        int block=0;\n        int sum1=0,sum2=0;\n        \n        for(int i=0;i<n;i++)\n        {\n            sum1+=a[i];\n            sum2+=b[i];\n            \n            if(sum1==sum2)\n            {\n                block++;\n            }\n        }\n        \n         System.out.println(block);\n        \n       \n        \n    }\n    \n\n    \n	public static void main (String[] args) throws java.lang.Exception\n	{\n		// your code goes here\n		\n		int t=1;\n		//in.nextLine();\n		\n		while(t>0)\n		{\n		    \n		    solve();\n		    t--;\n		}\n		\n		\n	\n	//	System.out.println(x);\n	}\n}\n",sortings
"\nimport java.util.*;\nimport java.io.*;\n\npublic class DayattheBeach {\n\n	// https://codeforces.com/contest/599/problem/C\n	\n	public static void main(String[] args) throws IOException, FileNotFoundException {\n		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n		//BufferedReader in = new BufferedReader(new FileReader(""DayattheBeach""));\n\n		int n = Integer.parseInt(in.readLine());\n\n		int[] arr = new int[n];\n		StringTokenizer st = new StringTokenizer(in.readLine());\n		for (int i=0; i<n; i++) arr[i] = Integer.parseInt(st.nextToken());\n		\n		int[] max = new int[n];\n		max[0] = arr[0];\n		for (int i=1; i<n; i++) {\n			max[i] = Math.max(max[i-1], arr[i]);\n		}\n		\n		int[] min = new int[n];\n		min[n-1] = arr[n-1];\n		for (int i=n-2; i>= 0; i--) {\n			min[i] = Math.min(min[i+1], arr[i]);\n		}\n		int count=0;\n		\n		for (int i=0; i<n-1; i++) {\n			if (max[i] <= min[i+1]) count++;\n		}\n		count++;\n		\n		System.out.println(count);\n	\n	}\n\n}\n\n/*int curmax = max[0];\nfor (int i=0; i<n; i++) {\n	//System.out.println(curmax + "" "" + min[i]);\n	if (i < n-1 && (min[i] == curmax || min[i+1] > curmax)) {\n		count++;\n		if (i < n-1) curmax = max[i+1];\n	}\n	else if (i < n-1 && min[i+1] == curmax) {\n		if (curmax == max[i+1]) {\n			count++;\n			curmax = max[i+1];\n		}\n	}\n	if (i == n-1) {\n		count++;\n	}\n}*/\n\n/*\n  int count=0;\n  for (int i=0; i<n; i++) if (arr[i] == max[i]) count++;\n  System.out.println(count);\n  */\n",sortings
"import static java.lang.Integer.parseInt;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class D_598D_IgonInTheMuseum {\n	\n	static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n	\n	static int max = 1001;\n	static char[][] museum = new char[max][max];\n	static int[][] visited = new int[max][max];\n	static int[] cache = new int[100001];\n	static int res, n, m, i;\n	\n	public static void main(String[] args) throws IOException {\n		String[] line = splitLine();\n		n = parseInt(line[0]);\n		m = parseInt(line[1]);\n		int k = parseInt(line[2]);\n		\n		for (int i = 1; i <= n; ++i) {\n			String s = readLine();\n			for (int j = 1; j <= m; ++j) {\n				museum[i][j] = s.charAt(j - 1);\n			}\n		}\n		for (i = 1; i <= k; ++i) {\n			String[] s = splitLine();\n			int x = parseInt(s[0]);\n			int y = parseInt(s[1]);\n			\n			res = 0;\n			if (visited[x][y] == 0) {\n				visit(x, y);\n				\n				cache[i] = res;\n			} else {\n				res = cache[visited[x][y]];\n			}\n			System.out.println(res);\n		}\n	}\n	\n	static void visit(int x, int y) {\n		if (x == 0 || y == 0 || x == n + 1 || y == m + 1) {\n			return;\n		}\n		if (museum[x][y] == '*') {\n			++res;\n			\n			return;\n		}\n		if (visited[x][y] != 0) {\n			return;\n		}\n		visited[x][y] = i;\n		\n		visit(x + 1, y);\n		visit(x - 1, y);\n		visit(x, y + 1);\n		visit(x, y - 1);\n	}\n	\n	\n	\n	\n	\n	static String[] splitLine() throws IOException {\n		return readLine().split("" "");\n	}\n	\n	static String readLine() throws IOException {\n		return reader.readLine();\n	}\n	\n	static int readInt() throws IOException {\n		return parseInt(reader.readLine());\n	}\n}\n","dfs and similar,graphs,shortest paths"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    public static char[][] mat;\n    public static HashMap<Character, Integer> map = new HashMap<>();\n    public static int[][] limits = {{0, -1},{0, 1},{-1, 0},{1, 0}};\n    public static int res;\n    public static char c = 'a';\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int m = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        mat = new char[n+1][m+1];\n        for (int i = 1; i <= n; i++) {\n            st = new StringTokenizer(br.readLine());\n            String str = st.nextToken();\n            for (int j = 1; j <= m; j++) {\n                mat[i][j] = str.charAt(j-1);\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            st = new StringTokenizer(br.readLine());\n            int x = Integer.parseInt(st.nextToken());\n            int y = Integer.parseInt(st.nextToken());\n            res = 0;\n            if (mat[x][y] == '.'){\n                dfs(x,y);\n                map.put(c, res);\n                c++;\n                System.out.println(res);\n            } else {\n                System.out.println(map.get(mat[x][y]));\n            }\n        }\n    }\n\n    private static void dfs(int i, int j) {\n        mat[i][j] = c;\n        for (int k = 0; k < 4; k++) {\n            int ii = i + limits[k][0];\n            int jj = j + limits[k][1];\n            if (mat[ii][jj] == '.') {\n                dfs(ii, jj);\n            } else if (mat[ii][jj] == '*') {\n                res++;\n            }\n        }\n    }\n\n}\n\n   	 		  	  						  	    				 	","dfs and similar,graphs,shortest paths"
"import java.io.*;\nimport java.util.*;\n \npublic class Main\n{\n	static class InputReader {\n		BufferedReader reader;\n		StringTokenizer tokenizer;\n		public InputReader(InputStream stream) {\n			reader = new BufferedReader(new InputStreamReader(stream), 32768);\n			tokenizer = null;\n		}\n		String next() { // reads in the next string\n			while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n				try {\n					tokenizer = new StringTokenizer(reader.readLine());\n				} catch (IOException e) {\n					throw new RuntimeException(e);\n				}\n			}\n			return tokenizer.nextToken();\n		}\n		public int nextInt() { // reads in the next int\n			return Integer.parseInt(next());\n		}\n		public long nextLong() { // reads in the next long\n			return Long.parseLong(next());\n		}\n		public double nextDouble() { // reads in the next double\n			return Double.parseDouble(next());\n			}\n		}\n	static InputReader r = new InputReader(System.in);\n	static PrintWriter pw = new PrintWriter(System.out);\n	static int n,m; static int[][] grid; static int num, count;\n	public static void main(String[] args)\n	{\n		n = r.nextInt(); m = r.nextInt(); int k = r.nextInt();\n		grid = new int[n][m];\n		num = 2;\n		int[] ans = new int[n*m+2];\n		for (int i = 0; i < n; i ++)\n		{\n			String s = r.next();\n			for (int j = 0; j < m; j ++)\n			{\n				grid[i][j] = (s.charAt(j) == '*' ? 0:1);\n			}\n		}\n		for (int i = 0; i < n; i ++)\n		{\n			for (int j = 0; j < m; j ++)\n			{\n				if (grid[i][j] == 1)\n				{\n					floodfill(i,j);\n					ans[num] = count;\n					num ++;\n					count = 0;\n				}\n			}\n		}\n		for (int i = 0; i < k; i ++)\n		{\n			int a = r.nextInt() - 1; int b = r.nextInt() - 1;\n			pw.println(ans[grid[a][b]]);\n		}\n		pw.close();\n	}\n	static void floodfill(int row, int col)\n	{\n		if (row < 0 || row >= n || col < 0 || col >= m || grid[row][col] == 0)\n		{\n			count ++;\n			return;\n		}\n		else if (grid[row][col] != 1)\n		{\n			return;\n		}\n		grid[row][col] = num;\n		floodfill(row-1,col); floodfill(row+1,col); floodfill(row,col-1); floodfill(row,col+1);\n	}\n}","dfs and similar,graphs,shortest paths"
"import java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n@SuppressWarnings(""Duplicates"")\npublic class D {\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n\n        int rows = sc.nextInt();\n        int cols = sc.nextInt();\n        int query = sc.nextInt();\n        boolean[][] empty = new boolean[rows][cols];\n        int[][] comp = new int[rows][cols];\n        for (int i = 0; i < rows; i++) {\n            String line = sc.next();\n            for (int j = 0; j < cols; j++) {\n                if (line.charAt(j)=='.')empty[i][j] = true;\n            }\n        }\n\n        HashMap<Integer,Integer> sol = new HashMap<>();\n\n        int[][] dirs = {\n            {1,0},\n            {-1,0},\n            {0,1},\n            {0,-1}\n        };\n\n        int compn = 1;\n        for (int q = 0; q < query; q++) {\n            int r = sc.nextInt()-1;\n            int c = sc.nextInt()-1;\n\n            if (comp[r][c]!=0){\n                pw.println(sol.get(comp[r][c]));\n                continue;\n            }\n\n            LinkedList<Integer> que = new LinkedList<>();\n            que.add(r*cols+c);\n            comp[r][c] = compn;\n            int walls = 0;\n            while (!que.isEmpty()){\n                int aux = que.removeFirst();\n                r = aux/cols;\n                c = aux%cols;\n                for (int i = 0; i < dirs.length; i++) {\n                    int nr = r+dirs[i][0];\n                    int nc = c+dirs[i][1];\n                    if (empty[nr][nc]) {\n                        if (comp[nr][nc] == 0) {\n                            comp[nr][nc] = compn;\n                            que.add(nr * cols + nc);\n                        }\n                    }\n                    else walls++;\n                }\n            }\n            sol.put(compn,walls);\n            compn++;\n            pw.println(walls);\n        }\n\n        pw.flush();\n    }\n}\n","dfs and similar,graphs,shortest paths"
import java.util.*;\npublic class TrickySum {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t--!=0) {\n			long n=sc.nextLong();long sum=n*(n+1)/2;\n			for(int i=1;i<=n;i*=2) {\n				sum-=i*2;\n			}\n			System.out.println(sum);\n		}\n\n	}\n\n}\n,math
import java.util.*;\npublic class TrickySum {\n\n	public static void main(String[] args) {\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		while(t--!=0) {\n			long n=sc.nextLong();long sum=n*(n+1)/2;\n			for(int i=1;i<=n;i*=2) {\n				sum-=i*2;\n			}\n			System.out.println(sum);\n		}\n\n	}\n\n}\n,math
"import java.util.*;\nimport static java.lang.Math.*;\npublic class Test{\n	public static void main(String[] args){\n		Scanner in = new Scanner(System.in);\n		int t = in.nextInt();\n		while (t-->0){\n			long n = in.nextInt();\n			long a = (long)(log(n)/log(2));\n			System.out.println(n*(n+1)/2 - ((long)pow(2,a+1)-1)*2);\n			\n		}\n		\n		\n		\n	}	\n}\n",math
"import java.util.*;\npublic class TrickySum {\n     \n	public static void main(String[] args) {\n		Scanner s = new Scanner(System.in);\n		long t=s.nextLong(),sum,m,n;\n		for(t=0;t<100 && s.hasNextLong();t++) {\n			n = s.nextLong();\n			m=1;\n			sum = n * (n+1) / 2;\n			while(m <= n) m *= 2;\n			sum -= m*2 -2;\n		System.out.println(sum);\n		}\n	}\n}\n",math
"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static class Pair implements Comparable<Pair>{\n        long y1;\n        long y2;\n        public Pair(long y1, long y2){\n            this.y1 = y1;\n            this.y2 = y2;\n        }\n\n        @Override\n        public int compareTo(Pair o) {\n            if(this.y1 != o.y1){\n                if(this.y1 > o.y1){\n                    return 1;\n                }\n                else return -1;\n            }\n            else if(this.y2 != o.y2){\n                if(this.y2 > o.y2){\n                    return 1;\n                }\n                else return -1;\n            }\n            else return 0;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long x1 = sc.nextInt();\n        long x2 = sc.nextInt();\n        Pair[] pArr = new Pair[n];\n        for(int i = 0; i < n; i++){\n            long k = sc.nextInt();\n            long b = sc.nextInt();\n            long y1 = k * x1 + b;\n            long y2 = k * x2 + b;\n            pArr[i] = new Pair(y1, y2);\n        }\n        Arrays.sort(pArr);\n        boolean res = false;\n        for(int i = 1; i < pArr.length; i++){\n            if(pArr[i-1].y2 > pArr[i].y2){\n                res = true;\n                break;\n            }\n        }\n        if(res) System.out.println(""YES"");\n        else System.out.println(""NO"");\n    }\n}\n\n   					 	 	   	 		 			   		 	","geometry,sortings"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\nimport static java.lang.Double.parseDouble;\nimport static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.in;\nimport static java.lang.System.out;\n\npublic class SolutionB extends Thread {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                                            InputStreamReader(in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return parseInt(next());\n        }\n\n        long nextLong() {\n            return parseLong(next());\n        }\n\n        double nextDouble() {\n            return parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    private static final FastReader scanner = new FastReader();\n    private static final PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        new Thread(null, new SolutionB(), ""Main"", 1 << 28).start();\n    }\n\n    public void run() {\n        solve();\n        out.close();\n    }\n\n    static class Line {\n        int index;\n        long m;\n        long t;\n\n        public Line(int index, int m, int t) {\n            this.index = index;\n            this.m = m;\n            this.t = t;\n        }\n    }\n\n\n    private static void solve() {\n        int n = scanner.nextInt();\n        int x1 = scanner.nextInt();\n        int x2 = scanner.nextInt();\n\n        Line[] linesA = new Line[n];\n        Line[] linesB = new Line[n];\n        for (int i = 0; i < n; i++) {\n            int ki = scanner.nextInt();\n            int bi = scanner.nextInt();\n            linesA[i] = new Line(i, ki, bi);\n            linesB[i] = new Line(i, ki, bi);\n        }\n\n        Arrays.sort(linesA, (o1, o2) -> {\n            long yOnX1Line1 = o1.t + o1.m * x1;\n            long yOnX1Line2 = o2.t + o2.m * x1;\n            if (yOnX1Line1 == yOnX1Line2) {\n                return Long.compare(o1.m, o2.m);\n            } else {\n                return Long.compare(yOnX1Line1, yOnX1Line2);\n            }\n        });\n\n        Arrays.sort(linesB, (o1, o2) -> {\n            long yOnX2Line1 = o1.t + o1.m * x2;\n            long yOnX2Line2 = o2.t + o2.m * x2;\n            if (yOnX2Line1 == yOnX2Line2) {\n                return Long.compare(o2.m, o1.m);\n            } else {\n                return Long.compare(yOnX2Line1, yOnX2Line2);\n            }\n        });\n\n        for (int i = 0; i < n; i++) {\n            if (linesA[i].index != linesB[i].index) {\n                out.println(""YES"");\n                return;\n            }\n        }\n        out.println(""NO"");\n    }\n}","geometry,sortings"
"import java.io.IOException;\nimport java.util.*;\npublic class d {\n    public static void main(String[] args) throws IOException {\n        Scanner s = new Scanner(System.in);\n        // BufferedReader s=new BufferedReader(new InputStreamReader(System.in));\n        //       String[] st=s.readLine().trim().split(""\\s+"");\n        //      a=Integer.parseInt(st[i]);\n        //  String[] st1=s.readLine().trim().split(""\\s+"");\n    StringBuilder sb = new StringBuilder();\n        StringBuilder sb1 = new StringBuilder();\n         int n=s.nextInt();\n         int x1=s.nextInt();\n         int x2=s.nextInt();\n         Student[] st=new Student[n];\n         for(int i=0;i<n;i++){\n             long k=s.nextLong();long b=s.nextLong();\n             st[i]=new Student(k*x1+b,k*x2+b);\n         }Arrays.sort(st,new Sortbyroll());\n        int flag=0;long min=Long.MIN_VALUE;\n         for(int i=0;i<n;i++){\n        //     System.out.println(st[i].l+"" ""+st[i].r);\n             if(st[i].r<min){\n                 flag=1;\n             }min=st[i].r;\n         }\n         if(flag==1) {\n             System.out.println(""YES"");\n         }else System.out.println(""NO"");\n    }\n    static int[] vis;\n    public static int countSetBits(int n)\n    {\n        return (BitsSetTable256[n & 0xff]\n                + BitsSetTable256[(n >> 8) & 0xff]\n                + BitsSetTable256[(n >> 16) & 0xff]\n                + BitsSetTable256[n >> 24]);\n    }\n    static int[] BitsSetTable256 ;\n    public static void initialize(int n)\n    {\n        BitsSetTable256[0] = 0;\n        for (int i = 0; i <=Math.pow(2,n); i++) {\n            BitsSetTable256[i] = (i & 1) + BitsSetTable256[i / 2];\n        }\n    }\n    static HashMap<Integer,Integer>[] val;//static int[] vis;static int y;\n    static boolean dfs(int x ,int i,ArrayList<Integer>[] adj){\n      vis[i]=1;\n     // if(x==1) System.out.print(i+"" "");\n      if(adj[i]==null) return false;\n      for(int j:adj[i]){\n        //  if(x==1) System.out.print(j+"" "");\n          if(j==x) return true;\n          if(vis[j]==0) return dfs(x,j,adj);\n      }return false;\n    }\n\n    static  void computeLPSArray(String pat, int M, int lps[]) {\n        int len = 0;\n        int i = 1;\n        lps[0] = 0;\n        while (i < M) {\n            if (pat.charAt(i) == pat.charAt(len)) {\n                len++;\n                lps[i] = len;\n                i++;\n            }\n            else\n            {\n                if (len != 0) {\n                    len = lps[len - 1];\n                }\n                else\n                {\n                    lps[i] = len;\n                    i++;\n                }\n            }\n        }\n    }\n    static boolean isPrime(int n) {\n        if (n <= 1) return false;\n        if (n <= 3) return true;\n\n        if (n % 2 == 0 || n % 3 == 0) return false;\n\n        for (int i = 5; i * i <= n; i = i + 6)\n            if (n % i == 0 || n % (i + 2) == 0)\n                return false;\n\n        return true;\n    }\n    static long powerwithmod(long  x, long y, int p) {\n        long  res = 1;\n        x = x % p;\n        while (y > 0) {\n            if ((y & 1) == 1)\n                res = (res * x) % p;\n            y = y >> 1;\n            x = (x * x) % p;\n        }\n        return res;\n    }\n    static long  powerwithoutmod(long x, int y) {\n        long  temp;\n        if( y == 0)\n            return 1;\n        temp = powerwithoutmod(x, y/2);\n        if (y%2 == 0)\n            return temp*temp;\n        else\n        {\n            if(y > 0)\n                return x * temp * temp;\n            else\n                return (temp * temp) / x;\n        }\n    }\n    static void fracion(double x) {\n        String a = """" + x;\n        String spilts[] = a.split(""\\.""); // split using decimal\n        int b = spilts[1].length(); // find the decimal length\n        int denominator = (int) Math.pow(10, b); // calculate the denominator\n        int numerator = (int) (x * denominator); // calculate the nerumrator Ex\n        // 1.2*10 = 12\n        int gcd = (int) gcd((long) numerator, denominator); // Find the greatest common\n        // divisor bw them\n        String fraction = """" + numerator / gcd + ""/"" + denominator / gcd;\n        // System.out.println((denominator/gcd));\n        long x1 = modInverse(denominator / gcd, 998244353);\n        //  System.out.println(x1);\n        System.out.println((((numerator / gcd) % 998244353 * (x1 % 998244353)) % 998244353));\n    }\n    static int bfs(int i1, ArrayList<Integer>[] h, int[] vis, int n,int val1) {\n        Queue<Integer> q = new LinkedList<Integer>();\n        q.add(i1);Queue<Integer> aq=new LinkedList<Integer>();\n        aq.add(0);\n        while(!q.isEmpty()){\n            int i=q.poll();\n            int val=aq.poll();\n            if(i==n){\n                return val;\n            }\n            if(h[i]!=null){\n                for(Integer j:h[i]){\n                    if(vis[j]==0){\n                        q.add(j);vis[j]=1;\n                        aq.add(val+1);}\n                }\n            }\n        }return -1;\n    }\n    static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    static long modInverse(long a, int m)\n    {\n        return (powerwithmod(a, m - 2, m));\n    }\n    static int MAXN=100001;\n    static int[] spf=new int[MAXN];\n    static void sieve() {\n        spf[1] = 1;\n        for (int i=2; i<MAXN; i++)\n            spf[i] = i;\n        for (int i=4; i<MAXN; i+=2)\n            spf[i] = 2;\n        for (int i=3; i*i<MAXN; i++)\n        {\n            if (spf[i] == i)\n            {\n                for (int j=i*i; j<MAXN; j+=i)\n\n                    if (spf[j]==j)\n                        spf[j] = i;\n            }\n        }\n    }\n    static Vector<Integer> getFactorizationUsingSeive(int x) {\n        Vector<Integer> ret = new Vector<Integer>();\n        while (x != 1)\n        {\n            ret.add(spf[x]);\n            x = x / spf[x];\n        }\n        return ret;\n    }\n   /*static long[] fac = new long[MAXN+1];\n     static void calculatefac(int mod){\n        for (int i = 1 ;i <= MAXN; i++)\n            fac[i] = fac[i-1] * i % mod;\n     }\n      static long nCrModPFermat(int n, int r, int mod) {\n         if (r == 0)\n            return 1;\n        fac[0] = 1;\n        return (fac[n]* modInverse(fac[r], mod)\n                % mod * modInverse(fac[n-r], mod)\n                                    % mod) % mod;\n    } */}\nclass Student {\n    long  l;long r;int x;\n    public Student(long l, long r) {\n        this.l = l;\n        this.r = r;this.x=x;\n    }\n\n    public String toString()\n    {\n        return this.l+"" "";\n    }\n}\nclass Sortbyroll implements Comparator<Student>\n{\n\n    public int compare(Student a, Student b){\n      if(a.l<b.l) return -1;\n      else if(a.l==b.l){\n          if(a.r==b.r){\n              return 0;\n          }\n          if(a.r<b.r) return -1;\n          return 1;}\n      return 1;  }\n}","geometry,sortings"
"import java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class CF593B {\n	static class Line {\n		long m, b;\n		public Line(long mm, long bb) {m = mm; b = bb;}\n		long y(long x) {return (m * x) + b;}\n	}\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		int n = scan.nextInt();\n		int x1 = scan.nextInt(), x2 = scan.nextInt();\n		Line[] l = new Line[n];\n		for(int i = 0 ; i < n ; i++) {\n			long m = scan.nextLong();\n			long b = scan.nextLong();\n			l[i] = new Line(m, b);\n		}\n		Arrays.sort(l , (a, b) -> (a.y(x1) != b.y(x1)) ? Long.compare(a.y(x1), b.y(x1)) : Long.compare(a.y(x2), b.y(x2)));\n		boolean passed = false;\n		for(int i = 0 ; i < n - 1 ; i++)\n			if(l[i].y(x2) > l[i + 1].y(x2))\n				passed = true;\n		System.out.println(passed ? ""YES"" : ""NO"");\n	}\n}\n","geometry,sortings"
"\nimport java.io.*;\nimport java.lang.*;\nimport java.util.*;\n\npublic class C592 {\n    static long t;\n    public static void main(String[] args) throws IOException{\n        StringTokenizer st;\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        st = new StringTokenizer(f.readLine());\n        t = Long.parseLong(st.nextToken());\n        long w = Long.parseLong(st.nextToken());\n        long b = Long.parseLong(st.nextToken());\n        long lcm = lcm(w,b);\n        long hmany = t/lcm;\n        long op = 0;\n        if(hmany >= 1){\n            op = Math.min(t%lcm+1, Math.min(w,b));\n            if(op != 0)\n                hmany--;\n        }\n        //System.out.println(op + "" "" + lcm + "" "" + hmany + "" "" + t%lcm);\n        op+=(hmany*(Math.min(w,b))) + Math.min(t, Math.min(w,b)-1);\n        //System.out.println(op);\n\n        f.close();\n\n\n\n        System.out.println(asFraction(op,t));\n    }\n    static long gcd(long a, long b)\n    {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n    static long lcm(long a, long b)\n    {\n        long r = a/gcd(a,b);\n        try {\n            long j = Math.multiplyExact(r,b);\n            return j;\n        }catch (ArithmeticException e){\n            return t+1;\n        }\n    }\n\n    public static String asFraction(long a, long b) {\n        long gcd = gcd(a, b);\n        return (a / gcd) + ""/"" + (b / gcd);\n    }\n\n}",math
"import java.io.BufferedInputStream;\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static BigInteger GCD(BigInteger a,BigInteger b)\n    {\n        if(b.compareTo(BigInteger.ZERO)==0) return a;\n        return GCD(b,a.remainder(b));\n    }\n\n    public static BigInteger MIN(BigInteger a,BigInteger b)\n    {\n        if(a.compareTo(b)>=0) return b;\n        return a;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner (new BufferedInputStream(System.in));\n\n        BigInteger t=sc.nextBigInteger();\n        BigInteger a=sc.nextBigInteger();\n        BigInteger b=sc.nextBigInteger();\n\n        if(MIN(a,b).compareTo(t)>0)\n        {\n            System.out.print(""1""+""/""+""1"");\n        }\n        else{\n            BigInteger gcd=GCD(a,b);\n            BigInteger lcm=a.multiply(b).divide(gcd);\n            BigInteger k=MIN(a,b).subtract(BigInteger.ONE);\n            BigInteger ans=BigInteger.ZERO;\n            BigInteger tmp=t.divide(lcm);\n            ans=k;\n            if(tmp.compareTo(BigInteger.ZERO)>0)\n            {\n                BigInteger u=tmp.subtract(BigInteger.ONE);\n                ans=ans.add(u.multiply(k.add(BigInteger.ONE)));\n                ans=ans.add(BigInteger.ONE);\n                ans=ans.add(MIN(k,t.subtract(lcm.multiply(tmp))));\n            }\n            BigInteger fz=ans;\n            BigInteger fm=t;\n            BigInteger e=GCD(fz,fm);\n            fz=fz.divide(e);\n            fm=fm.divide(e);\n            System.out.print(fz.toString()+""/""+fm.toString());\n        }\n    }\n} \n 			  		 	 	 	  								  	  	",math
"import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\n//\npublic class AGC_020_Encoding {\n\n\n\n	public static void main(String[]args) throws Throwable {\n		Scanner sc = new Scanner(System.in);\n		long tt = sc.nextLong(), nn = sc.nextLong(), mm = sc.nextLong();\n		if (nn < mm) {\n			long tmp = nn;\n			nn = mm;\n			mm = tmp;\n		}\n		BigInteger t = new BigInteger(tt+""""), n = new BigInteger(nn+""""), m = new BigInteger(mm+"""");\n		BigInteger lcm = n.multiply(m).divide(n.gcd(m));\n		BigInteger tot = t.divide(lcm);\n		if (tot.equals(BigInteger.ZERO)) {\n			m = m.min(t.add(BigInteger.ONE));\n			BigInteger k = m.subtract(BigInteger.ONE).gcd(t);\n			System.out.println(m.subtract(BigInteger.ONE).divide(k)+""/""+t.divide(k));\n			return;\n		}\n		BigInteger res = tot.subtract(BigInteger.ONE).multiply(m);\n		BigInteger mid = t.min((lcm.multiply(tot)).add(m.subtract(BigInteger.ONE))).subtract(lcm.multiply(tot));\n		//System.out.println(mid);\n		res = res.add(mid).add(BigInteger.ONE);\n		res = res.add(m.subtract(BigInteger.ONE));\n		BigInteger k = res.gcd(t);\n		System.out.println(res.divide(k)+""/""+t.divide(k));\n		\n		\n	}\n\n	static class Scanner {\n		StringTokenizer st;\n		BufferedReader br;\n\n		public Scanner(InputStream s) {\n			br = new BufferedReader(new InputStreamReader(s));\n		}\n\n		public Scanner(String s) throws FileNotFoundException {\n			br = new BufferedReader(new FileReader(new File(s)));\n		}\n\n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n\n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n	}\n}",math
"/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n//package the.big.race;\n\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\n/**\n *\n * @author hp\n */\npublic class TheBigRace {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        BigInteger t,w,b;\n        t = scanner.nextBigInteger();\n        w = scanner.nextBigInteger();\n        b = scanner.nextBigInteger();\n        BigInteger mn;\n        if(w.compareTo(b) == -1) {\n            mn = w;\n        }\n        else {\n            mn = b;\n        }\n        BigInteger num;\n        if(w.compareTo(b) == 0) {\n            num = t;\n        }\n        else {\n            BigInteger lcm = w.multiply(b);\n            BigInteger gcd = w.gcd(b);\n            lcm = lcm.divide(gcd);\n            BigInteger ans = t.divide(lcm);\n            ans = ans.multiply(mn);\n            /*\n            if(w.compareTo(b) == -1) {\n                ans = ans.multiply(w);\n            }\n            else {\n                ans = ans.multiply(b);\n            }*/\n            ans = ans.add(mn.subtract(BigInteger.ONE));\n            /*if(w.compareTo(BigInteger.ONE) != 0 && b.compareTo(BigInteger.ONE) != 0) {\n                ans = ans.add(BigInteger.ONE);\n            }*/\n            BigInteger ratio = t.divide(lcm);\n            BigInteger closest = lcm.multiply(ratio);\n            //System.out.println(""ans is "" + ans);\n            BigInteger outside = closest.add(mn).subtract(t).subtract(BigInteger.ONE);\n            if(outside.compareTo(BigInteger.ZERO) != -1) {\n                ans = ans.subtract(outside);\n            }\n            //System.out.println(""ans is "" + ans);\n\n            if(t.compareTo(ans) == -1) {\n                num = t;\n            }\n            else {\n                num = ans;\n            }\n        }\n\n        //System.out.println(""num is "" + num);\n        BigInteger denum = t;\n        BigInteger d = num.gcd(denum);\n        num = num.divide(d);\n        denum = denum.divide(d);\n        System.out.println(num + ""/"" + denum);\n    }\n    \n}\n",math
"import java.util.*;\nimport java.io.*;\n\npublic class Main {\n	\n	static int INF = (int)1e9;\n	static int n, MAXN;\n	static ArrayList<Integer>[] adjList;\n	static ArrayList<Integer>[] people;\n	static int[] parent, level;\n	static int[][] origMin;\n	static int[][] min;\n	static int[][] lcaP;\n	static int[][][] lcaMin;\n	\n	public static void dfs(int u, int p) {\n		parent[u] = p;\n		for(int v : adjList[u])\n			if(v != p) {\n				level[v] = level[u] + 1;\n				min[v] = origMin[u];\n				dfs(v, u);\n			}\n	}\n	\n	public static int[] merge(int[] a, int[] b) {\n		int[] res = new int[10];\n		int i = 0, j = 0;\n		for(int u = 0; u < 10; u++)\n			if(i == 10)\n				res[u] = b[j++];\n			else if(j == 10)\n				res[u] = a[i++];\n			else if(a[i] <= b[j])\n				res[u] = a[i++];\n			else\n				res[u] = b[j++];\n		return res;\n	}\n	\n	public static void preprocess() {\n		lcaP[0] = parent;\n		lcaMin[0] = min;\n		for(int i = 1; i < MAXN; i++)\n			for(int j = 0; j < n; j++) {\n				lcaP[i][j] = lcaP[i - 1][j] == -1 ? -1 : lcaP[i - 1][lcaP[i - 1][j]];\n				lcaMin[i][j] = lcaP[i - 1][j] == -1 ? lcaMin[i - 1][j] : merge(lcaMin[i - 1][j], lcaMin[i - 1][lcaP[i - 1][j]]);\n			}\n	}\n	\n	public static int[] solve(int u, int v) {\n		int[] ans = new int[10];\n		Arrays.fill(ans, INF);\n		if(level[u] < level[v]) {\n			int temp = u;\n			u = v;\n			v = temp;\n		}\n		ans = merge(ans, origMin[u]);\n		if(level[u] > level[v]) {\n			int diff = level[u] - level[v];\n			for(int i = 0; i < MAXN; i++)\n				if((diff & (1 << i)) != 0) {\n					ans = merge(ans, lcaMin[i][u]);\n					u = lcaP[i][u];\n				}\n		}\n		\n		if(u == v)\n			return ans;\n		ans = merge(ans, origMin[v]);\n		for(int i = MAXN - 1; i >= 0; i--) {\n			if(lcaP[i][u] != lcaP[i][v]) {\n				ans = merge(ans, lcaMin[i][u]);\n				ans = merge(ans, lcaMin[i][v]);\n				u = lcaP[i][u];\n				v = lcaP[i][v];\n			}\n		}\n		ans = merge(ans, lcaMin[0][u]);\n		return ans;\n	}\n	\n	public static void main(String[] args) throws Exception {\n		Scanner sc = new Scanner(System.in);\n		PrintWriter pw = new PrintWriter(System.out);\n		\n		MAXN = 18;\n		n = sc.nextInt();\n		int m = sc.nextInt();\n		int q = sc.nextInt();\n		\n		adjList = new ArrayList[n];\n		for(int i = 0; i < n; i++)\n			adjList[i] = new ArrayList<>();\n		\n		people = new ArrayList[n];\n		for(int i = 0; i < n; i++)\n			people[i] = new ArrayList<>();\n		\n		for(int i = 0; i < n - 1; i++) {\n			int u = sc.nextInt() - 1, v = sc.nextInt() - 1;\n			adjList[u].add(v);\n			adjList[v].add(u);\n		}\n		\n		for(int i = 0; i < m; i++)\n			people[sc.nextInt() - 1].add(i + 1);\n		\n		parent = new int[n];\n		level = new int[n];\n		origMin = new int[n][10];\n		for(int i = 0; i < n; i++) {\n			Arrays.fill(origMin[i], INF);\n			Collections.sort(people[i]);\n			for(int j = 0; j < Math.min(10, people[i].size()); j++)\n				origMin[i][j] = people[i].get(j);\n		}\n		min = new int[n][10];\n		Arrays.fill(min[0], INF);\n		dfs(0, -1);\n		\n		lcaP = new int[MAXN][n];\n		lcaMin = new int[MAXN][n][10];\n		preprocess();\n		\n		while(q-->0) {\n			int u = sc.nextInt() - 1, v = sc.nextInt() - 1, a = sc.nextInt();\n			int[] ans = solve(u, v);\n			int cnt = 0;\n			for(int i = 0; i < Math.min(a, 10); i++)\n				if(ans[i] == INF)\n					break;\n				else\n					cnt++;\n			pw.print(cnt);\n			for(int i = 0; i < cnt; i++)\n				pw.print("" "" + ans[i]);\n			pw.print(""\n"");\n		}\n		\n		pw.flush();\n	}\n\n	public static class Scanner {\n		StringTokenizer st;\n		BufferedReader br;\n\n		public Scanner(InputStream system) {\n			br = new BufferedReader(new InputStreamReader(system));\n		}\n\n		public Scanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n\n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n\n		public char nextChar() throws IOException {\n			return next().charAt(0);\n		}\n\n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n\n		public int[] nextIntArray(int n) throws IOException {\n			int[] array = new int[n];\n			for (int i = 0; i < n; i++)\n				array[i] = nextInt();\n			return array;\n		}\n\n		public Integer[] nextIntegerArray(int n) throws IOException {\n			Integer[] array = new Integer[n];\n			for (int i = 0; i < n; i++)\n				array[i] = new Integer(nextInt());\n			return array;\n		}\n\n		public long[] nextLongArray(int n) throws IOException {\n			long[] array = new long[n];\n			for (int i = 0; i < n; i++)\n				array[i] = nextLong();\n			return array;\n		}\n\n		public double[] nextDoubleArray(int n) throws IOException {\n			double[] array = new double[n];\n			for (int i = 0; i < n; i++)\n				array[i] = nextDouble();\n			return array;\n		}\n\n		public static int[] shuffle(int[] a) {\n			int n = a.length;\n			Random rand = new Random();\n			for (int i = 0; i < n; i++) {\n				int tmpIdx = rand.nextInt(n);\n				int tmp = a[i];\n				a[i] = a[tmpIdx];\n				a[tmpIdx] = tmp;\n			}\n			return a;\n		}\n\n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n\n		public void waitForInput() throws InterruptedException {\n			Thread.sleep(3000);\n		}\n	}\n}\n\n    	 			 					 					 		 	   	","data structures,trees"
"import java.util.*;\nimport java.io.*;\npublic class DuffInTheArmy {\n    public static void main(String[] args) throws IOException {\n        Reader in = new Reader();\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int N = in.nextInt(), M = in.nextInt(), Q = in.nextInt();\n        List<Integer>[] adj = new ArrayList[N];\n        for (int i = 0; i < N; i++) {\n            adj[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < N - 1; i++) {\n            int u = in.nextInt() - 1, v = in.nextInt() - 1;\n            adj[u].add(v);\n            adj[v].add(u);\n        }\n        \n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(0);\n        int[][] jump = new int[N][20];\n        jump[0][0] = -1;\n        int[] depth = new int[N];\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            for (int i : adj[current]) {\n                if (current == 0 || i != jump[current][0]) {\n                    jump[i][0] = current;\n                    depth[i] = depth[current] + 1;\n                    queue.offer(i);\n                }\n            }\n        }\n        \n        List<Integer>[][] dp = new ArrayList[N][20];\n        for (int i = 0; i < N; i++) {\n            dp[i][0] = new ArrayList<>();\n        }\n        for (int i = 0; i < M; i++) {\n            dp[in.nextInt() - 1][0].add(i + 1);\n        }\n        for (int i = 0; i < N; i++) {\n            Collections.sort(dp[i][0]);\n            while (dp[i][0].size() > 10) {\n                dp[i][0].remove(dp[i][0].size() - 1);\n            }\n        }\n        for (int j = 1; j < 20; j++) {\n            for (int i = 0; i < N; i++) {\n                dp[i][j] = new ArrayList<>();\n                jump[i][j] = jump[i][j - 1] == -1 ? -1 : jump[jump[i][j - 1]][j - 1];\n                List<Integer> l1 = dp[i][j - 1], l2 = jump[i][j - 1] == -1 ? new ArrayList<>() : dp[jump[i][j - 1]][j - 1];\n                int i1 = 0, i2 = 0;\n                while (i1 < l1.size() && i2 < l2.size() && dp[i][j].size() < 10) {\n                    if (l1.get(i1) < l2.get(i2)) {\n                        dp[i][j].add(l1.get(i1++));\n                    } else {\n                        dp[i][j].add(l2.get(i2++));\n                    }\n                }\n                while (i1 < l1.size() && dp[i][j].size() < 10) {\n                    dp[i][j].add(l1.get(i1++));\n                }\n                while (i2 < l2.size() && dp[i][j].size() < 10) {\n                    dp[i][j].add(l2.get(i2++));\n                }\n            }\n        }\n        \n        for (int q = 0; q < Q; q++) {\n            int u = in.nextInt() - 1, v = in.nextInt() - 1, K = in.nextInt();\n            int u2 = u, v2 = v;\n            Queue<Integer> pq = new PriorityQueue<>();\n            for (int j = 19; j >= 0; j--) {\n                if (depth[u2] > depth[v2] && jump[u2][j] != -1 && depth[jump[u2][j]] >= depth[v2]) {\n                    for (int i : dp[u2][j]) {\n                        pq.offer(i);\n                    }\n                    u2 = jump[u2][j];\n                }\n                if (depth[u2] < depth[v2] && jump[v2][j] != -1 && depth[jump[v2][j]] >= depth[u2]) {\n                    for (int i : dp[v2][j]) {\n                        pq.offer(i);\n                    }\n                    v2 = jump[v2][j];\n                }\n            }\n            for (int j = 19; j >= 0; j--) {\n                if (jump[u2][j] != -1 && jump[u2][j] != jump[v2][j]) {\n                    for (int i : dp[u2][j]) {\n                        pq.offer(i);\n                    }\n                    u2 = jump[u2][j];\n                    for (int i : dp[v2][j]) {\n                        pq.offer(i);\n                    }\n                    v2 = jump[v2][j];\n                }\n            }\n            if (u2 != v2) {\n                for (int i : dp[u2][0]) {\n                    pq.offer(i);\n                }\n                for (int i : dp[v2][0]) {\n                    pq.offer(i);\n                }\n            }\n            int lca = u2 == v2 ? u2 : jump[u2][0];\n            for (int i : dp[lca][0]) {\n                pq.offer(i);\n            }\n            out.print(Math.min(pq.size(), K));\n            for (int i = 0; i < K; i++) {\n                if (pq.isEmpty()) {\n                    break;\n                }\n                out.print("" "" + pq.poll());\n            }\n            out.println();\n        }\n        \n        out.close();\n    }\n    static class Reader {\n        BufferedReader in;\n        StringTokenizer st;\n        public Reader() {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            st = new StringTokenizer("""");\n        }\n        public String nextLine() throws IOException {\n            st = new StringTokenizer("""");\n            return in.readLine();\n        }\n        public String next() throws IOException {\n            while (!st.hasMoreTokens()) {\n                st = new StringTokenizer(in.readLine());\n            }\n            return st.nextToken();\n        }\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n    public static void sort(int[] arr) {\n        List<Integer> list = new ArrayList<>();\n        for (int i : arr) {\n            list.add(i);\n        }\n        Collections.sort(list);\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = list.get(i);\n        }\n    }\n}","data structures,trees"
"import java.util.*;\nimport java.math.*;\nimport java.io.*;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\npublic class Main {\n  static int []head = new int[100001];\n  static int []nxt = new int[200001];\n  static int []b = new int[200001];\n  static int [][]fa = new int[100001][21];\n  static int [][][]Fs = new int[100001][21][];\n  static ArrayList<Integer> []C = new ArrayList[100001];\n  static int k;\n  static int []dep = new int[100001];\n  static int []cnt = new int[100001];\n  static int n;\n  static void push(int s, int t) {\n    nxt[++k] = head[s];\n    head[s] = k;\n    b[k] = t;\n  }\n\n  static void DEBUG(int n)\n  {\n    for (int i = 1;i <= n;++i) {\n      for (int z = 0;z <= 20;++z) {\n        if (fa[i][z] == 0) continue;\n\n        System.out.println(""------"");\n        System.out.println(""fa[""+i+""][""+z+""]=""+fa[i][z]);\n        if (Fs[i][z] != null) {\n          System.out.println(Arrays.toString(Fs[i][z]));\n        }\n        System.out.println(""------"");\n      }\n    }\n    System.out.println(""===="");\n  }\n\n\n  static void dfs(int x, int f) {\n    fa[x][0] = f;\n    if (f != 0) {//x root?\n      if (C[f].size() > 0) {\n        Fs[x][0] = new int[C[f].size()];\n        for (int i = 0;i < C[f].size();++i) {\n          Fs[x][0][i] = C[f].get(i);\n        }\n      }\n      //Fs[x][0] keeps info (x, fa[x][0]]\n    }\n    \n    for (int i = 1;i <= 20;++i) {\n      fa[x][i] = fa[fa[x][i - 1]][i - 1];\n      if (Fs[x][i - 1] == null && Fs[fa[x][i - 1]][i - 1] != null) {\n        Fs[x][i] = Fs[fa[x][i - 1]][i - 1].clone();\n      } else if (Fs[x][i - 1] != null && Fs[fa[x][i - 1]][i - 1] == null) {\n        Fs[x][i] = Fs[x][i - 1].clone();\n      } else if (Fs[x][i - 1] != null && Fs[fa[x][i - 1]][i - 1] != null) {\n        ArrayList<Integer> tmp = new ArrayList<Integer>();\n        for (int v:Fs[x][i - 1]) tmp.add(v);\n        for (int v:Fs[fa[x][i - 1]][i - 1]) tmp.add(v);\n        Collections.sort(tmp);\n        while (tmp.size() > 10) tmp.remove(10);\n        Fs[x][i] = new int[tmp.size()];\n        for (int z = 0;z < tmp.size();++z) {\n          Fs[x][i][z] = tmp.get(z);\n        }\n      }\n    }\n    dep[x] = dep[f] + 1;\n    for (int i = head[x];i > 0;i = nxt[i]) {\n      if (b[i] != f) dfs(b[i], x);\n    }\n  }\n  static int LCA(int u,int v, Set<Integer> ans)\n  {\n    if (dep[u] < dep[v]) {\n      int tmp = u;\n      u = v;\n      v = tmp;\n    }\n    ans.addAll(C[u]);\n    ans.addAll(C[v]);\n    int delta = dep[u] - dep[v];\n    for(int x = 0;x <= 20;x++) {\n      int flag = (1<<x)&delta;\n      if(flag > 0) {\n        //add info first then u = fa[u][x]\n        if (Fs[u][x] != null) for (int it:Fs[u][x]) ans.add(it);\n        u = fa[u][x];\n      }\n    }\n    if (u == v) return u;\n    for(int x = 20;x >= 0;x--) {\n      if(fa[u][x] != fa[v][x]) {\n        if (Fs[u][x] != null) for (int it:Fs[u][x]) ans.add(it);\n        if (Fs[v][x] != null) for (int it:Fs[v][x]) ans.add(it);\n        u=fa[u][x];\n        v=fa[v][x];\n      }\n    }\n    ans.addAll(C[fa[u][0]]);\n    return fa[u][0];\n  }\n  static void getans(int x, int f) {\n    for (int i = head[x];i > 0;i = nxt[i]) {\n      if (b[i] != f) {\n        getans(b[i], x); \n        cnt[x] += cnt[b[i]];\n      }\n    }\n  }\n  public static void main(String[] args) {\n    try {\n      MScanner in = new MScanner(System.in);\n      BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out, ""UTF-8""));\n      int n = in.nextInt();\n      int m = in.nextInt();\n      int q = in.nextInt();\n      for (int i = 1;i <= n - 1;++i) {\n        int s = in.nextInt();\n        int t = in.nextInt();\n        push(s, t);\n        push(t, s);\n      }\n      for (int i = 0;i <= n;++i) C[i] = new ArrayList<Integer>();\n      for (int i = 1;i <= m;++i) {\n        int c = in.nextInt();\n        C[c].add(i);\n      }\n      for (int i = 1;i <= n;++i) {\n        if (C[i].size() > 10) {\n          Collections.sort(C[i]);\n          while (C[i].size() > 10) C[i].remove(10);\n        }\n      }\n      dfs(1, 0);\n      //DEBUG(n);\n      for (int i = 1;i <= q;++i) {\n        int x = in.nextInt();\n        int y = in.nextInt();\n        int sz = in.nextInt();\n\n        Set<Integer> ans = new TreeSet<>();\n        int lca = LCA(x, y, ans);\n        int asz = Math.min(ans.size(), sz);\n        int cnt = 0;\n        out.write(asz + "" "");\n        for (Integer z:ans) {\n          out.write(z + "" "");\n          if (++cnt >= asz) break;\n        }\n        out.write(""\n"");\n      }\n      out.flush();\n      out.close();\n    } catch (Exception e) {\n      System.out.print(e);\n      System.exit(0);\n    }\n  }\n  static class MScanner {\n    StringTokenizer st;\n    BufferedReader br;\n    public MScanner(InputStream system) {\n      br = new BufferedReader(new InputStreamReader(system));\n    }\n\n    public MScanner(String file) throws Exception {\n      br = new BufferedReader(new FileReader(file));\n    }\n\n    public String next() throws IOException {\n      while (st == null || !st.hasMoreTokens())\n	st = new StringTokenizer(br.readLine());\n      return st.nextToken();\n    }\n    public int[] takearr(int n) throws IOException {\n      int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n      return in;\n    }\n    public long[] takearrl(int n) throws IOException {\n      long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n      return in;\n    }\n    public Integer[] takearrobj(int n) throws IOException {\n      Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n      return in;\n    }\n    public Long[] takearrlobj(int n) throws IOException {\n      Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n      return in;\n    }\n    public String nextLine() throws IOException {\n      return br.readLine();\n    }\n\n    public int nextInt() throws IOException {\n      return Integer.parseInt(next());\n    }\n\n    public double nextDouble() throws IOException {\n      return Double.parseDouble(next());\n    }\n\n    public char nextChar() throws IOException {\n      return next().charAt(0);\n    }\n\n    public Long nextLong() throws IOException {\n      return Long.parseLong(next());\n    }\n\n    public boolean ready() throws IOException {\n      return br.ready();\n    }\n\n    public void waitForInput() throws InterruptedException {\n      Thread.sleep(3000);\n    }\n  }\n}\n\n","data structures,trees"
"import java.util.*;\nimport java.math.*;\nimport java.io.*;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\npublic class Main {\n  static int []head = new int[100001];\n  static int []nxt = new int[200001];\n  static int []b = new int[200001];\n  static int [][]fa = new int[100001][21];\n  static int [][][]Fs = new int[100001][21][];\n  static ArrayList<Integer> []C = new ArrayList[100001];\n  static int k;\n  static int []dep = new int[100001];\n  static int []cnt = new int[100001];\n  static int n;\n  static void push(int s, int t) {\n    nxt[++k] = head[s];\n    head[s] = k;\n    b[k] = t;\n  }\n\n  static void DEBUG(int n)\n  {\n    for (int i = 1;i <= n;++i) {\n      for (int z = 0;z <= 20;++z) {\n        if (fa[i][z] == 0) continue;\n\n        System.out.println(""------"");\n        System.out.println(""fa[""+i+""][""+z+""]=""+fa[i][z]);\n        if (Fs[i][z] != null) {\n          System.out.println(Arrays.toString(Fs[i][z]));\n        }\n        System.out.println(""------"");\n      }\n    }\n    System.out.println(""===="");\n  }\n\n\n  static void dfs(int x, int f) {\n    fa[x][0] = f;\n    if (f != 0) {//x root?\n      if (C[f].size() > 0) {\n        Fs[x][0] = new int[C[f].size()];\n        for (int i = 0;i < C[f].size();++i) {\n          Fs[x][0][i] = C[f].get(i);\n        }\n      }\n    }\n    \n    for (int i = 1;i <= 20;++i) {\n      fa[x][i] = fa[fa[x][i - 1]][i - 1];\n      if (Fs[x][i - 1] == null && Fs[fa[x][i - 1]][i - 1] != null) {\n        Fs[x][i] = Fs[fa[x][i - 1]][i - 1].clone();\n      } else if (Fs[x][i - 1] != null && Fs[fa[x][i - 1]][i - 1] == null) {\n        Fs[x][i] = Fs[x][i - 1].clone();\n      } else if (Fs[x][i - 1] != null && Fs[fa[x][i - 1]][i - 1] != null) {\n        ArrayList<Integer> tmp = new ArrayList<Integer>();\n        for (int v:Fs[x][i - 1]) tmp.add(v);\n        for (int v:Fs[fa[x][i - 1]][i - 1]) tmp.add(v);\n        Collections.sort(tmp);\n        while (tmp.size() > 10) tmp.remove(10);\n        Fs[x][i] = new int[tmp.size()];\n        for (int z = 0;z < tmp.size();++z) {\n          Fs[x][i][z] = tmp.get(z);\n        }\n      }\n    }\n    dep[x] = dep[f] + 1;\n    for (int i = head[x];i > 0;i = nxt[i]) {\n      if (b[i] != f) dfs(b[i], x);\n    }\n  }\n  static int LCA(int u,int v, Set<Integer> ans)\n  {\n    if (dep[u] < dep[v]) {\n      int tmp = u;\n      u = v;\n      v = tmp;\n    }\n    ans.addAll(C[u]);\n    ans.addAll(C[v]);\n    //System.out.println(ans);\n    //System.out.println(""add uv"");\n    int delta = dep[u] - dep[v];\n\n    for(int x = 0;x <= 20;x++) {\n      int flag = (1<<x)&delta;\n      if(flag > 0) {\n        if (Fs[u][x] != null) for (int it:Fs[u][x]) ans.add(it);\n        u = fa[u][x];\n        //System.out.println(""prev:""+u);\n        //System.out.println(ans);\n        //System.out.println(""after lift"");\n      }\n    }\n    //System.out.println(""check u""+u);\n\n    if (u == v) return u;\n    for(int x = 20;x >= 0;x--) {\n      if(fa[u][x] != fa[v][x]) {\n        if (Fs[u][x] != null) for (int it:Fs[u][x]) ans.add(it);\n        if (Fs[v][x] != null) for (int it:Fs[v][x]) ans.add(it);\n        u=fa[u][x];\n        v=fa[v][x];\n      }\n    }\n    ans.addAll(C[fa[u][0]]);\n    return fa[u][0];\n  }\n  static void getans(int x, int f) {\n    for (int i = head[x];i > 0;i = nxt[i]) {\n      if (b[i] != f) {\n        getans(b[i], x); \n        cnt[x] += cnt[b[i]];\n      }\n    }\n  }\n\n\n  public static void main(String[] args) {\n    try {\n    MScanner in = new MScanner(System.in);\n    BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out, ""UTF-8""));\n\n    int n = in.nextInt();\n    int m = in.nextInt();\n    int q = in.nextInt();\n    for (int i = 1;i <= n - 1;++i) {\n      int s = in.nextInt();\n      int t = in.nextInt();\n      push(s, t);\n      push(t, s);\n    }\n    for (int i = 0;i <= n;++i) C[i] = new ArrayList<Integer>();\n    \n    for (int i = 1;i <= m;++i) {\n      int c = in.nextInt();\n      C[c].add(i);\n    }\n    for (int i = 1;i <= n;++i) {\n      if (C[i].size() > 10) {\n        Collections.sort(C[i]);\n        while (C[i].size() > 10) C[i].remove(10);\n      }\n    }\n    dfs(1, 0);\n    //DEBUG(n);\n\n\n    for (int i = 1;i <= q;++i) {\n      int x = in.nextInt();\n      int y = in.nextInt();\n      int sz = in.nextInt();\n      \n      Set<Integer> ans = new TreeSet<>();\n      int lca = LCA(x, y, ans);\n      //System.out.println(x + "" "" + y + "" "" + lca);\n      //System.out.println(ans);\n      int asz = Math.min(ans.size(), sz);\n      int cnt = 0;\n      //System.out.print(asz + "" "");\n      out.write(asz + "" "");\n      for (Integer z:ans) {\n        //System.out.print(z + "" "");\n        out.write(z + "" "");\n        if (++cnt >= asz) break;\n      }\n      //System.out.println();\n      out.write(""\n"");\n    }\n    out.flush();\n    out.close();\n    //getans(1, 0);\n\n    //for (int i = 1;i < n;++i) {\n    //  int x = b[(i<<1) - 1];\n    //  int y = b[(i<<1)];\n    //  if (fa[x][0] == y) {\n    //    System.out.print(cnt[x] + "" "");\n    //  } else {\n    //    System.out.print(cnt[y] + "" "");\n    //  }\n    //}\n    //System.out.println();\n\n    } catch (Exception e) {\n      System.out.print(e);\n      System.exit(0);\n    }\n\n\n  }\n  static class MScanner {\n    StringTokenizer st;\n    BufferedReader br;\n    public MScanner(InputStream system) {\n      br = new BufferedReader(new InputStreamReader(system));\n    }\n\n    public MScanner(String file) throws Exception {\n      br = new BufferedReader(new FileReader(file));\n    }\n\n    public String next() throws IOException {\n      while (st == null || !st.hasMoreTokens())\n	st = new StringTokenizer(br.readLine());\n      return st.nextToken();\n    }\n    public int[] takearr(int n) throws IOException {\n      int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n      return in;\n    }\n    public long[] takearrl(int n) throws IOException {\n      long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n      return in;\n    }\n    public Integer[] takearrobj(int n) throws IOException {\n      Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n      return in;\n    }\n    public Long[] takearrlobj(int n) throws IOException {\n      Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n      return in;\n    }\n    public String nextLine() throws IOException {\n      return br.readLine();\n    }\n\n    public int nextInt() throws IOException {\n      return Integer.parseInt(next());\n    }\n\n    public double nextDouble() throws IOException {\n      return Double.parseDouble(next());\n    }\n\n    public char nextChar() throws IOException {\n      return next().charAt(0);\n    }\n\n    public Long nextLong() throws IOException {\n      return Long.parseLong(next());\n    }\n\n    public boolean ready() throws IOException {\n      return br.ready();\n    }\n\n    public void waitForInput() throws InterruptedException {\n      Thread.sleep(3000);\n    }\n  }\n}\n\n","data structures,trees"
"import java.util.Scanner;\n\npublic class E {\n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n		long x = scan.nextLong();\n		long y = scan.nextLong();\n		if(gcd(x,y) != 1) {\n			System.out.println(""Impossible"");\n			return;\n		}\n		System.out.println(ans);\n	}\n	static StringBuilder ans = new StringBuilder();\n	static char c = 'A';\n	static long gcd(long a, long b) {\n		if(b == 0) return a;\n		if(a >= b) {\n			long t = a/b;\n			if(a % b == 0)\n				t--;\n			ans.append(t);\n			ans.append(c);\n		}\n		c = (char) ('A' + 'B' - c);\n		return gcd(b,a%b);\n	}\n}\n",number theory
"import java.util.*;\npublic class Main {\n	static long x,y,p;\n	static String s;\n	static long gcd(long a,long b)\n	{\n		if(a==0) return b;\n		return gcd(b%a,a);\n	}\n\n	public static void main(String[] args) {\n		Scanner in=new Scanner(System.in);\n		x=in.nextLong();y=in.nextLong();\n		if(gcd(x,y)!=1) System.out.println(""Impossible"");\n		else\n		{\n			s="""";\n			while(x!=1&&y!=1)\n			{\n				if(x>y)\n				{\n					p=x/y;x=x%y;\n					s+=p+""A"";\n				}\n				else\n				{\n					p=y/x;y=y%x;\n					s+=p+""B"";\n				}\n			}\n			if(y==1) s+=(x-1)+""A"";\n			else s+=(y-1)+""B"";\n			System.out.println(s);\n		}\n	}\n}\n",number theory
"import java.util.Scanner;\n\npublic class Main {\n	static Scanner sc = new Scanner(System.in);\n\n	public static void main(String[] args) {\n		long X = sc.nextLong();\n		long Y = sc.nextLong();\n		System.out.println(solve(X, Y));\n	}\n\n	static String solve(long x, long y) {\n		StringBuilder sb = new StringBuilder();\n		while (x != y && x > 0 && y > 0) {\n			if (x > y) {\n				if (y == 1) {\n					sb.append((x - 1) + ""A"");\n					x = 1;\n					break;\n				}\n				sb.append((x / y) + ""A"");\n				x %= y;\n			} else {\n				if (x == 1) {\n					sb.append((y - 1) + ""B"");\n					y = 1;\n					break;\n				}\n				sb.append((y / x) + ""B"");\n				y %= x;\n			}\n		}\n		if (x == 1 && y == 1) {\n			return sb.toString();\n		} else {\n			return ""Impossible"";\n		}\n	}\n}\n",number theory
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF585C extends PrintWriter {\n	CF585C() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF585C o = new CF585C(); o.main(); o.flush();\n	}\n\n	long gcd(long a, long b) {\n		return b == 0 ? a : gcd(b, a % b);\n	}\n	void main() {\n		long x = sc.nextLong();\n		long y = sc.nextLong();\n		if (gcd(x, y) != 1) {\n			println(""Impossible"");\n			return;\n		}\n		StringBuilder sb = new StringBuilder();\n		while (x > 1 || y > 1) {\n			long k;\n			char c;\n			if (x > y) {\n				k = x / y;\n				if (y == 1)\n					k--;\n				x %= y;\n				c = 'A';\n			} else {\n				k = y / x;\n				if (x == 1)\n					k--;\n				y %= x;\n				c = 'B';\n			}\n			sb.append(k);\n			sb.append(c);\n		}\n		println(sb);\n	}\n}\n",number theory
"import java.util.*;\npublic class Main {\n	private static boolean prime(int m)\n	{\n		for(int i=2;i<=Math.sqrt(m);i++)\n		{\n			if(m%i==0)\n				return false;\n		}\n		return true;\n	}\npublic static void main(String[]arg)\n{\n	Scanner in=new Scanner(System.in);\n	int n=in.nextInt();\n	if(prime(n))\n	{\n		System.out.println(1);\n		System.out.println(n);\n	}\n	else if(prime(n-2))\n	{\n		System.out.println(2);\n		System.out.println(2+"" ""+(n-2));\n	}\n	else\n	{\n		int i=1;\n		while(!prime(n-i))\n			i++;\n		int m=i;\n		for(int y=2;y<=m/2;y++)\n		{\n			if(prime(y)&&prime(m-y))\n			{\n				System.out.println(3);\n				System.out.println((n-i)+"" ""+y+"" ""+(m-y));\n				break;\n			}\n		}\n			\n	}\n}\n}\n					 		    		    			    	 	 		","brute force,math,number theory"
"\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main {\n	static int mod = 1000000007;\n\n	public static void main(String[] args) {\n		// code\n		Scanner scn = new Scanner(System.in);\n	\n		int t = 1;\n		while (t > 0) {\n			t--;\n			int n = scn.nextInt();\n			if (n == 3) {\n				System.out.println(1 + ""\n"" + 3);\n				continue;\n			}\n\n			int p = n - 2;\n\n			while (checkprime(p) == false) {\n				p--;\n				continue;\n			}\n			//System.out.println(p);\n			int x = n - p;\n			for (int i = 2; i <= x; i++) {\n				if (checkprime(i) && checkprime(x - i)) {\n					if (x - i == 0) {\n						System.out.print(""2"" + ""\n"" + p + "" "" + i);\n					} else {\n						System.out.print(""3"" + ""\n"" + p + "" "" + i + "" "" + (x - i));\n					}\n					break;\n				}\n			}\n\n		}\n	}\n\n	public static boolean checkprime(int n) {\n		for (int i = 2; i <= Math.pow(n, 0.5); i++) {\n			if (n % i == 0) {\n				return false;\n			}\n		}\n		return true;\n	}\n}\n","brute force,math,number theory"
"import java.io.*;\nimport java.util.*;\nimport java.lang.*;\n\npublic class Rextester{\n    static boolean isPrime(int n){\n        for(int i=2;i<=Math.sqrt(n);i++){\n            if(n%i==0){\n                return false;\n            }\n        }\n        return true;\n    }\n    public static void main(String[] args)throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        br.close();\n        if(isPrime(n)){\n            System.out.println(""1\n""+n);\n        }\n        else{\n            int[] ans = new int[3];\n            for(int i=2;i<=Math.sqrt(n);i+=2){\n                if(isPrime(n-i)){\n                    ans[2]=n-i;\n                    break;\n                }\n            }\n            if(n-ans[2]==2){\n                System.out.println(""2\n2 ""+(n-2));\n                return;\n            }\n            for(int i=2;i<n-ans[2];i++){\n                if(isPrime(i)&&isPrime(n-ans[2]-i)){\n                    ans[0]=i;\n                    ans[1]=n-ans[2]-i;\n                    break;\n                }\n            }\n            System.out.println(""3"");\n            for(int i=0;i<3;i++){\n                System.out.print(ans[i]+"" "");\n            }\n        }\n    }\n}","brute force,math,number theory"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Kraken\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    Scanner in = new Scanner(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    TaskD solver = new TaskD();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskD {\n\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n      long n = in.nextLong();\n      if (prime(n)) {\n        out.printf(""%d\n%d\n"", 1, n);\n        return;\n      }\n      long k = n;\n      while (!prime(k))\n        k--;\n      n -= k;\n      assert (n % 2 == 0);\n      int[] si = new int[(int) n + 1];\n      for (int i = 2; i <= n; i++) {\n        if (si[i] != 0)\n          continue;\n        if (n == i) {\n          out.printf(""2\n%d %d\n"", k, n);\n          return;\n        }\n        if (prime(i) && prime(n - i)) {\n          out.printf(""3\n%d %d %d\n"", k, i, n - i);\n          return;\n        }\n        for (int j = i; j <= n; j += i)\n          si[i]++;\n      }\n      out.println(-1);\n    }\n\n    private boolean prime(long n) {\n      for (int i = 2; i <= Math.sqrt(n); i++)\n        if (n % i == 0)\n          return false;\n      return true;\n    }\n\n  }\n}\n\n","brute force,math,number theory"
import java.util.*;\npublic class Main\n{\n	public static int[] myArray = new int[4001];\n	public static int[][] mp = new int[4001][4001];\n \n	public static void main(String[] args) {\n		Scanner myInput= new Scanner(System.in);\n		int ans = 0;\n		int c = 0;\n		int n = myInput.nextInt();\n		int m = myInput.nextInt();\n		for(int i = 0; i < m; i++)\n		{\n			int a = myInput.nextInt();\n			int b = myInput.nextInt();\n			mp[a][b]=mp[b][a]=1;\n			myArray[a]++;myArray[b]++;\n		}\n		ans = -1;\n		for(int i = 1;i <= n; i++)\n		for(int j=i;j<=n;j++)\n		{\n			if(mp[i][j]==0){\n			    continue;\n			}\n			for(int k=1;k<=n;k++)\n			{\n				if(mp[i][k]!=1||mp[j][k]!=1){\n				    continue;\n				} \n				c=myArray[i]+myArray[j]+myArray[k]-6;\n				if(ans==-1||c<ans){\n				    ans = c;\n				} \n			}\n		}\n		System.out.println(ans);\n	}\n},"brute force,dfs and similar,graphs,hashing"
"import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class main{\n	public static void main (String[] args) throws java.lang.Exception{\n		int res = 4001;\n		int deg[] = new int [4001];\n		int mat[][] = new int [4001][4001];\n		Scanner in = new Scanner(System.in);\n    	int n = in.nextInt();\n    	int m = in.nextInt();\n    	for(int i = 0; i < m; ++i){\n    		int x = in.nextInt();\n    		int y = in.nextInt();\n        	mat[x][y] = mat[y][x] = 1; \n        	deg[x]++;\n    	   deg[y]++;\n    	}\n    	for(int i = 1; i <= n; ++i){\n    		for(int j = i + 1; j <= n; ++j){\n    			if(mat[i][j] == 1){\n    				for(int k = j + 1; k <= n; ++k) {\n						if(mat[i][k] == 1 && mat[j][k] == 1){\n							res = Math.min(res, deg[i] + deg[j] + deg[k]);\n						}	\n					}\n    			}\n    		}\n    	}\n    	if(res == 4001){\n    		System.out.print(-1);\n    	}\n		else{\n			System.out.print(res - 6);\n		}\n	}\n}","brute force,dfs and similar,graphs,hashing"
"import java.util.*;\n\npublic class Solve{\n    public static void main(String[] args){\n    Scanner sc=new Scanner(System.in);\n    int size=4005;\n    int ans=Integer.MAX_VALUE;\n    int max=ans;\n    int n=sc.nextInt();\n    int m=sc.nextInt();\n    int[] degree=new int[n+1];\n    int[][] ad=new int[size][size];\n    for(int i=0;i<m;i++){\n        int a=sc.nextInt();\n        int b=sc.nextInt();\n        ad[a][b]=ad[b][a]=1;\n        degree[a]++;\n        degree[b]++;\n        \n    }\n    for(int i=1;i<=n;i++){\n        for(int j=i+1;j<=n;j++){\n            if(ad[i][j]==1){\n                for(int k=j+1;k<=n;k++){\n                    if(ad[i][k]==1 && ad[j][k]==1){\n                        ans=Math.min(ans,degree[i]+degree[j]+degree[k]);\n                    }\n                }\n            }\n        }\n    }\n    \n    if(ans==max)System.out.println(""-1"");\n    else System.out.println(ans-6);\n    }\n}","brute force,dfs and similar,graphs,hashing"
"//Collaborated with no one\n//Written by Adinma Chidumije\nimport java.util.Scanner;\n\npublic class MainTest{\n	public static void main(String[] args){\n		Scanner sc= new Scanner(System.in); //System.in is a standard input stream  \n\n		int maxn = (int) (4e3+5);			 \n		int x [] = new int [maxn];  \n		int y[] = new int [maxn];\n		int arr [] = new int [maxn];\n		boolean g [][] = new boolean[maxn][maxn];	\n		int n,m;\n		\n		n = sc.nextInt();\n		m = sc.nextInt();\n		for(int i=0; i<m; i++)\n		{\n			x[i] = sc.nextInt();\n			y[i] = sc.nextInt();\n			g[x[i]][y[i]] = g[y[i]][x[i]] = true;\n			arr[x[i]]++;\n			arr[y[i]]++;\n		}\n		boolean ok= false;\n		int Min = 999999;\n		for(int i=0; i<m; i++)\n			for(int j=1; j<=n; j++)\n				if(g[x[i]][j] && g[j][y[i]] )\n					if(Min > arr[x[i]]+arr[j]+arr[y[i]])\n					{\n						Min = arr[x[i]]+arr[j]+arr[y[i]];\n						ok = true;\n					}\n		if (!ok) \n		{\n			System.out.print(""-1"");\n		}\n		else\n		{\n			System.out.printf(""%d\n"",Min-6);\n		}\n			sc.close();\n	}\n}\n\n	   				 	  	 	  	 	 					   	","brute force,dfs and similar,graphs,hashing"
"import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n	private ArrayList<ArrayList<Integer>> graph;\n	private boolean[] del;\n	private int[] legs;\n\n	public void solve() {\n		Scanner scanner = new Scanner(System.in);\n		int N = scanner.nextInt();\n		graph = new ArrayList<>();\n		for (int i = 0; i < N; i++) {\n			graph.add(new ArrayList<Integer>());\n		}\n		del = new boolean[N];\n		legs = new int[N];\n\n		for (int i = 0; i < N - 1; i++) {\n			int a = scanner.nextInt() - 1;\n			int b = scanner.nextInt() - 1;\n			graph.get(a).add(b);\n			graph.get(b).add(a);\n		}\n		scanner.close();\n\n		for (int i = 0; i < N; i++) {\n			if (graph.get(i).size() == 1) {\n				dfs(i, -1);\n			}\n		}\n		for (int i = 0; i < N; i++) {\n			for (int b : graph.get(i)) {\n				if (del[b]) {\n					legs[i] = Math.min(legs[i] + 1, 2);\n				}\n			}\n		}\n		for (int i = 0; i < N; i++) {\n			if (!del[i]) {\n				int cnt = 0;\n				for (int b : graph.get(i)) {\n					if (!del[b] && graph.get(b).size() - legs[b] > 1) {\n						cnt++;\n					}\n					if (cnt > 2) {\n						System.out.println(""No"");\n						return;\n					}\n				}\n			}\n		}\n		System.out.println(""Yes"");\n		return;\n\n	}\n\n	private void dfs(int now, int parent) {\n		if (graph.get(now).size() > 2) {\n			return;\n		}\n\n		del[now] = true;\n		for (int b : graph.get(now)) {\n			if (b != parent) {\n				dfs(b, now);\n			}\n		}\n	}\n\n	public static void main(String[] args) {\n		new Main().solve();\n	}\n}","constructive algorithms,dfs and similar,trees"
"import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n    static ArrayList<Integer> G[];\n    static int[] D;\n    static boolean[] F;\n    static int firstfail = -1;\n    \n    static boolean[] dfs(int x) {\n	boolean[] R = new boolean[4];\n	F[x] = true;\n	int cnt = 0, c2 = 0;\n	R[0] = R[1] = R[2] = R[3] = true;\n	for (Integer y : G[x]) {\n	    if (!F[y]) {\n		boolean[] C = dfs(y);\n		++cnt;\n		if (cnt > 1 || !C[3]) R[3] = false;\n		if (cnt > 2 || !C[3]) R[2] = false;\n		if (!C[2]) ++c2;\n		if (c2 > 1 || !C[1]) {if (firstfail < 0) firstfail = x; R[1] = false;}\n		if (c2 > 2 || !C[1]) R[0] = false;\n	    }\n	}\n	//System.out.println(x + "" "" + R[0] + "" "" + R[1] + "" "" + R[2] + "" "" + R[3] + "" "" + cnt + "" "" + c2);\n	return R;\n    }\n\n    public static void main(String args[]) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(in.readLine());\n        int R = 0;\n        G = new ArrayList[n];\n        D = new int[n];\n        \n        for (int i = 0; i < n; i++) G[i] = new ArrayList<Integer>();\n        for (int i = 1; i < n; i++) {\n    	    StringTokenizer t = new StringTokenizer(in.readLine());\n	    int a = Integer.parseInt(t.nextToken()) - 1;\n	    int b = Integer.parseInt(t.nextToken()) - 1;\n	    G[b].add(a);\n	    G[a].add(b);\n	    D[a]++;\n	    D[b]++;\n	    if (D[a] > 2) R = a;\n	    if (D[b] > 2) R = b;\n        }\n        F = new boolean[n];\n        boolean res = dfs(R)[0];\n        if (!res && firstfail >= 0) {\n    	    //System.err.println(""Failed at "" + firstfail + "", recalculating"");\n    	    F = new boolean[n];\n    	    res |= dfs(firstfail)[0];\n    	} \n    	System.out.println(res ? ""Yes"" : ""No"");\n    }\n}\n","constructive algorithms,dfs and similar,trees"
"import java.util.*;\nimport java.io.*;\n\npublic class C {\n	FastScanner in;\n	PrintWriter out;\n\n	ArrayList<Integer>[] g;\n	boolean[] del;\n	int[] leg;\n\n	void dfs(int v, int p) {\n		int deg = g[v].size() - (p != -1 ? 1 : 0);\n		if (deg <= 1) {\n			del[v] = true;\n			for (int u : g[v]) {\n				if (u != p) {\n					dfs(u, v);\n				}\n			}\n		} else {\n			leg[v]++;\n		}\n	}\n\n	public void solve() throws IOException {\n		int n = in.nextInt();\n		g = new ArrayList[n];\n		for (int i = 0; i < n; i++) {\n			g[i] = new ArrayList<>();\n		}\n		for (int i = 0; i < n - 1; i++) {\n			int a = in.nextInt() - 1, b = in.nextInt() - 1;\n			g[a].add(b);\n			g[b].add(a);\n		}\n		del = new boolean[n];\n		leg = new int[n];\n		for (int i = 0; i < n; i++) {\n			if (g[i].size() == 1 && !del[i]) {\n				dfs(i, -1);\n			}\n		}\n		for (int v = 0; v < n; v++) {\n			if (!del[v]) {\n				int cnt = 0;\n				for (int u : g[v]) {\n					if (!del[u]) {\n						if (leg[u] >= 3 || g[u].size() - leg[u] >= 2) {\n							cnt++;\n						}\n					}\n				}\n				if (cnt > 2) {\n					out.println(""No"");\n					return;\n				}\n			}\n		}\n		out.println(""Yes"");\n	}\n\n	public void run() {\n		try {\n			in = new FastScanner();\n			out = new PrintWriter(System.out);\n\n			solve();\n\n			out.close();\n		} catch (IOException e) {\n			e.printStackTrace();\n		}\n	}\n\n	class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		FastScanner() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n\n		String next() {\n			while (st == null || !st.hasMoreTokens()) {\n				try {\n					st = new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			}\n			return st.nextToken();\n		}\n\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n	}\n\n	public static void main(String[] arg) {\n		new C().run();\n	}\n}","constructive algorithms,dfs and similar,trees"
"import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Wuyouwulv {\n    private static final int maxn = 100010;\n    private static ArrayList<Integer> g[];\n    private static int[] legs = new int[maxn];\n    private static int[] degree = new int[maxn];\n    private static boolean[] del = new boolean[maxn];\n    \n    private static void dfs(int u, int pa) {\n        int sz = g[u].size();\n        if(sz > 2) {\n            legs[u] ++;\n            return;\n        }\n        del[u] = true;\n        for(int v : g[u]) {\n            if(v == pa) continue;\n            dfs(v, u);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        while(in.hasNext()) {\n            int n = in.nextInt();\n            g = new ArrayList[n];\n            for(int i=0;i<n;i++) g[i] = new ArrayList<Integer>();\n            for(int i=1;i<n;i++) {\n                int u , v;\n                u = in.nextInt() - 1;\n                v = in.nextInt() - 1;\n                g[u].add(v);\n                g[v].add(u);\n                degree[u] ++;\n                degree[v] ++;\n            }\n            for(int i=0;i<n;i++) {\n                if(!del[i] && degree[i] == 1) {\n                    dfs(i, -1);\n                }\n            }\n            for(int u=0;u<n;u++) {\n                if(!del[u] && degree[u] - Math.min(legs[u], 2) > 1) {\n                    int cnt = 0;\n                    for(int v : g[u]) {\n                        if(!del[v] && degree[v] - Math.min(legs[v], 2) > 1) {\n                            cnt ++;\n                            if(cnt > 2) {\n                                System.out.println(""No"");\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n            System.out.println(""Yes"");\n            return;\n        }\n    }\n}","constructive algorithms,dfs and similar,trees"
"//package round317;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class D {\n	InputStream is;\n	PrintWriter out;\n	String INPUT = """";\n	\n	void solve()\n	{\n		int n = ni(), m = ni();\n		int[][] qs = new int[m][];\n		for(int i = 0;i < m;i++){\n			char t = nc();\n			if(t == 'U' || t == 'M'){\n				qs[i] = new int[]{t, ni()-1, ni()-1};\n			}else{\n				qs[i] = new int[]{t, ni()-1};\n			}\n		}\n		\n		int[] mpar = new int[n+1];\n		int[] mtime = new int[n+1];\n		Arrays.fill(mpar, -1);\n		Arrays.fill(mtime, -1);\n		for(int i = 0;i < m;i++){\n			if(qs[i][0] == 'M'){\n				mpar[qs[i][2]] = qs[i][1];\n				mtime[qs[i][2]] = i;\n			}\n		}\n		for(int i = 0;i < n;i++){\n			if(mpar[i] == -1)mpar[i] = n;\n		}\n		int[][][] mgw = parentToG(mpar, mtime);\n		for(int i = 0;i < n+1;i++){\n			Arrays.sort(mgw[i], new Comparator<int[]>() {\n				public int compare(int[] a, int[] b) {\n					return -(a[1] - b[1]);\n				}\n			});\n		}\n		int[][] mg = new int[n+1][];\n		for(int i = 0;i < n+1;i++){\n			mg[i] = new int[mgw[i].length];\n			for(int j = 0;j < mgw[i].length;j++)mg[i][j] = mgw[i][j][0];\n		}\n		\n		int[][] mrights = makeRights(mg, mpar, n);\n		SegmentTreeOverwrite st = new SegmentTreeOverwrite(n+1);\n		int[] miord = mrights[1], mright = mrights[2];\n		int[] lastReset = new int[m];\n		Arrays.fill(lastReset, -1);\n		int[] mptr = new int[n+1];\n		for(int i = 0;i < n;i++){\n			mptr[i] = mg[i].length-1;\n		}\n		st.update(0, n+1, -1);\n		for(int i = 0;i < m;i++){\n			if(qs[i][0] == 'M'){\n				mptr[qs[i][1]]--;\n			}else if(qs[i][0] == 'Z'){\n				int y = qs[i][1];\n				int L = miord[y];\n				int R = mptr[y] == mg[y].length-1 ? L : mright[miord[mg[y][mptr[y]]]];\n				st.update(L, R+1, i);\n			}else if(qs[i][0] == 'Q'){\n				lastReset[i] = st.val(miord[qs[i][1]]);\n			}\n		}\n		\n		int[] upar = new int[n+1];\n		int[] utime = new int[n+1];\n		Arrays.fill(upar, -1);\n		Arrays.fill(utime, -1);\n		for(int i = 0;i < m;i++){\n			if(qs[i][0] == 'U'){\n				upar[qs[i][2]] = qs[i][1];\n				utime[qs[i][2]] = i;\n			}\n		}\n		for(int i = 0;i < n;i++){\n			if(upar[i] == -1)upar[i] = n;\n		}\n		int[][][] ugw = parentToG(upar, utime);\n		for(int i = 0;i < n+1;i++){\n			Arrays.sort(ugw[i], new Comparator<int[]>() {\n				public int compare(int[] a, int[] b) {\n					return -(a[1] - b[1]);\n				}\n			});\n		}\n		int[][] ug = new int[n+1][];\n		for(int i = 0;i < n+1;i++){\n			ug[i] = new int[ugw[i].length];\n			for(int j = 0;j < ugw[i].length;j++)ug[i][j] = ugw[i][j][0];\n		}\n		\n		int[][] es = new int[m][];\n		int p = 0;\n		for(int i = 0;i < m;i++){\n			if(lastReset[i] >= 0){\n				es[p++] = new int[]{lastReset[i], i};\n			}\n		}\n		Arrays.sort(es, 0, p, new Comparator<int[]>() {\n			public int compare(int[] a, int[] b) {\n				return a[0] - b[0];\n			}\n		});\n		\n		int[][] urights = makeRights(ug, upar, n);\n		int[] uiord = urights[1], uright = urights[2];\n		long[] ft = new long[n+2];\n		int[] uptr = new int[n+1];\n		for(int i = 0;i < n;i++){\n			uptr[i] = ug[i].length-1;\n		}\n		long[] ret = new long[m];\n		int pp = 0;\n		for(int i = 0;i < m;i++){\n			if(qs[i][0] == 'U'){\n				uptr[qs[i][1]]--;\n			}else if(qs[i][0] == 'A'){\n				int y = qs[i][1];\n				int L = uiord[y];\n				int R = uptr[y] == ug[y].length-1 ? L : uright[uiord[ug[y][uptr[y]]]];\n				addFenwick(ft, L, R-L+1);\n				addFenwick(ft, R+1, -(R-L+1));\n			}else if(qs[i][0] == 'Q'){\n				ret[i] += sumFenwick(ft, uiord[qs[i][1]]);\n				out.println(ret[i]);\n			}\n			while(pp < p && es[pp][0] <= i){\n				ret[es[pp][1]] -= sumFenwick(ft, uiord[qs[es[pp][1]][1]]);\n				pp++;\n			}\n		}\n		\n	}\n	\n	public static long sumFenwick(long[] ft, int i)\n	{\n		long sum = 0;\n		for(i++;i > 0;i -= i&-i)sum += ft[i];\n		return sum;\n	}\n	\n	public static void addFenwick(long[] ft, int i, long v)\n	{\n		if(v == 0)return;\n		int n = ft.length;\n		for(i++;i < n;i += i&-i)ft[i] += v;\n	}\n\n	\n	public static long[] restoreFenwick(long[] ft)\n	{\n		int n = ft.length-1;\n		long[] ret = new long[n];\n		for(int i = 0;i < n;i++)ret[i] = sumFenwick(ft, i);\n		for(int i = n-1;i >= 1;i--)ret[i] -= ret[i-1];\n		return ret;\n	}\n\n	public static class SegmentTreeOverwrite {\n		public int M, H, N;\n		public int[] cover;\n		public int I = Integer.MAX_VALUE;\n		\n		public SegmentTreeOverwrite(int n)\n		{\n			N = n;\n			M = Integer.highestOneBit(Math.max(N-1, 1))<<2;\n			H = M>>>1;\n			cover = new int[M];\n		}\n		\n		public void update(int l, int r, int v){ update(l, r, v, 0, H, 1); }\n		\n		private void update(int l, int r, int v, int cl, int cr, int cur)\n		{\n			if(l <= cl && cr <= r){\n				cover[cur] = v;\n			}else{\n				int mid = cl+cr>>>1;\n				if(cover[cur] != I){\n					cover[2*cur] = cover[2*cur+1] = cover[cur];\n					cover[cur] = I;\n				}\n				if(cl < r && l < mid){\n					update(l, r, v, cl, mid, 2*cur);\n				}\n				if(mid < r && l < cr){\n					update(l, r, v, mid, cr, 2*cur+1);\n				}\n			}\n		}\n		\n		public int val(int x) {\n			int ret = I;\n			for(int i = H+x;i >= 1;i>>>=1){\n				if(cover[i] != I)ret = cover[i];\n			}\n			return ret;\n		}\n	}\n	\n	public static int[] sortByPreorder(int[][] g, int root){\n		int n = g.length;\n		int[] stack = new int[n];\n		int[] ord = new int[n];\n		BitSet ved = new BitSet();\n		stack[0] = root;\n		int p = 1;\n		int r = 0;\n		ved.set(root);\n		while(p > 0){\n			int cur = stack[p-1];\n			ord[r++] = cur;\n			p--;\n			for(int e : g[cur]){\n				if(!ved.get(e)){\n					stack[p++] = e;\n					ved.set(e);\n				}\n			}\n		}\n		return ord;\n	}\n	\n	public static int[][] makeRights(int[][] g, int[] par, int root)\n	{\n		int n = g.length;\n		int[] ord = sortByPreorder(g, root);\n		int[] iord = new int[n];\n		for(int i = 0;i < n;i++)iord[ord[i]] = i;\n		\n		int[] right = new int[n];\n		for(int i = n-1;i >= 0;i--){\n			int v = i;\n			for(int e : g[ord[i]]){\n				if(e != par[ord[i]]){\n					v = Math.max(v, right[iord[e]]);\n				}\n			}\n			right[i] = v;\n		}\n		return new int[][]{ord, iord, right};\n	}\n	\n	public static int[][] parents(int[][] g)\n	{\n		int n = g.length;\n		int[] par = new int[n];\n		Arrays.fill(par, -1);\n\n		int[] q = new int[n];\n		int r = 0;\n		for(int u = 0;u < n;u++){\n			if(par[u] == -1){\n				q[r++] = u;\n				for(int p = r-1;p < r;p++) {\n					int cur = q[p];\n					for(int nex : g[cur]){\n						if(par[cur] != nex){\n							q[r++] = nex;\n							par[nex] = cur;\n						}\n					}\n				}\n			}\n		}\n		return new int[][] {par, q};\n	}\n\n	\n	public static int[][][] parentToG(int[] par, int[] time)\n	{\n		int n = par.length;\n		int[] ct = new int[n];\n		for(int i = 0;i < n;i++){\n			if(par[i] >= 0){\n				ct[i]++;\n				ct[par[i]]++;\n			}\n		}\n		int[][][] g = new int[n][][];\n		for(int i = 0;i < n;i++){\n			g[i] = new int[ct[i]][];\n		}\n		for(int i = 0;i < n;i++){\n			if(par[i] >= 0){\n				g[par[i]][--ct[par[i]]] = new int[]{i, time[i]};\n				g[i][--ct[i]] = new int[]{par[i], -2};\n			}\n		}\n		return g;\n	}\n	\n	void run() throws Exception\n	{\n		is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n		out = new PrintWriter(System.out);\n		\n		long s = System.currentTimeMillis();\n		solve();\n		out.flush();\n		tr(System.currentTimeMillis()-s+""ms"");\n	}\n	\n	public static void main(String[] args) throws Exception { new D().run(); }\n	\n	private byte[] inbuf = new byte[1024];\n	private int lenbuf = 0, ptrbuf = 0;\n	\n	private int readByte()\n	{\n		if(lenbuf == -1)throw new InputMismatchException();\n		if(ptrbuf >= lenbuf){\n			ptrbuf = 0;\n			try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n			if(lenbuf <= 0)return -1;\n		}\n		return inbuf[ptrbuf++];\n	}\n	\n	private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n	private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n	\n	private double nd() { return Double.parseDouble(ns()); }\n	private char nc() { return (char)skip(); }\n	\n	private String ns()\n	{\n		int b = skip();\n		StringBuilder sb = new StringBuilder();\n		while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n			sb.appendCodePoint(b);\n			b = readByte();\n		}\n		return sb.toString();\n	}\n	\n	private char[] ns(int n)\n	{\n		char[] buf = new char[n];\n		int b = skip(), p = 0;\n		while(p < n && !(isSpaceChar(b))){\n			buf[p++] = (char)b;\n			b = readByte();\n		}\n		return n == p ? buf : Arrays.copyOf(buf, p);\n	}\n	\n	private char[][] nm(int n, int m)\n	{\n		char[][] map = new char[n][];\n		for(int i = 0;i < n;i++)map[i] = ns(m);\n		return map;\n	}\n	\n	private int[] na(int n)\n	{\n		int[] a = new int[n];\n		for(int i = 0;i < n;i++)a[i] = ni();\n		return a;\n	}\n	\n	private int ni()\n	{\n		int num = 0, b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private long nl()\n	{\n		long num = 0;\n		int b;\n		boolean minus = false;\n		while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n		if(b == '-'){\n			minus = true;\n			b = readByte();\n		}\n		\n		while(true){\n			if(b >= '0' && b <= '9'){\n				num = num * 10 + (b - '0');\n			}else{\n				return minus ? -num : num;\n			}\n			b = readByte();\n		}\n	}\n	\n	private boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n	private void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n","binary search,data structures,dsu,trees"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		InputReader in = new InputReader(inputStream);\n		OutputWriter out = new OutputWriter(outputStream);\n		TaskD solver = new TaskD();\n		solver.solve(1, in, out);\n		out.close();\n	}\n\n	static class TaskD {\n		public void solve(int testNumber, InputReader in, OutputWriter out) {\n			int n = in.readInt();\n			int m = in.readInt();\n			IntList[] dormitories = new IntList[n];\n			IntList[] armies = new IntList[n];\n			for (int i = 0; i < n; i++) {\n				dormitories[i] = new IntArrayList(1);\n				dormitories[i].add(i);\n				armies[i] = new IntArrayList(1);\n				armies[i].add(i);\n			}\n			int[] ignoreArmyBefore = new int[n];\n			int[] lastExplicitArmy = new int[n];\n			Arrays.fill(ignoreArmyBefore, -1);\n			Arrays.fill(lastExplicitArmy, -1);\n			long[] baseQty = new long[n];\n			int[] baseQtyTime = new int[n];\n			Arrays.fill(baseQtyTime, -1);\n			IntList[] updateTimes = new IntList[n];\n			IntList[] updateCumulQtys = new IntList[n];\n			long[] allCumulUpds = new long[m + 1];\n			int cumulUpdsAt = 1;\n			AtomicInteger[] lastArmyVisits = new AtomicInteger[n];\n			for (int i = 0; i < n; i++) {\n				updateTimes[i] = new IntArrayList(1);\n				updateCumulQtys[i] = new IntArrayList(1);\n				updateCumulQtys[i].add(0);\n				lastArmyVisits[i] = new AtomicInteger(-1);\n			}\n			for (int i = 0; i < m; i++) {\n				char type = in.readCharacter();\n				if (type == 'U') {\n					int first = in.readInt() - 1;\n					int second = in.readInt() - 1;\n					if (dormitories[first].size() > dormitories[second].size()) {\n						int temp = first;\n						first = second;\n						second = temp;\n					}\n					IntList toAdd = dormitories[first];\n					dormitories[second].addAll(toAdd);\n					for (int current : toAdd.toArray()) {\n						int lastArmyVisit = lastArmyVisits[current].get();\n						if (lastArmyVisit < ignoreArmyBefore[current]) {\n							lastArmyVisit = lastExplicitArmy[current];\n						}\n						if (baseQtyTime[current] > lastArmyVisit) {\n							lastArmyVisit = baseQtyTime[current];\n						} else {\n							baseQty[current] = 0;\n						}\n						int lastNotNeededUpdate = get(updateTimes[current], lastArmyVisit);\n						baseQty[current] += allCumulUpds[updateCumulQtys[current].get(updateTimes[current].size())] - allCumulUpds[updateCumulQtys[current].get(lastNotNeededUpdate)];\n						baseQtyTime[current] = i;\n						dormitories[current] = dormitories[second];\n						updateTimes[current] = updateTimes[second];\n						updateCumulQtys[current] = updateCumulQtys[second];\n					}\n				} else if (type == 'M') {\n					int first = in.readInt() - 1;\n					int second = in.readInt() - 1;\n					if (armies[first].size() > armies[second].size()) {\n						int temp = first;\n						first = second;\n						second = temp;\n					}\n					IntList toAdd = armies[first];\n					armies[second].addAll(toAdd);\n					for (int current : toAdd.toArray()) {\n						int lastArmyVisit = lastArmyVisits[current].get();\n						if (lastArmyVisit > ignoreArmyBefore[current]) {\n							lastExplicitArmy[current] = lastArmyVisit;\n						}\n						ignoreArmyBefore[current] = i;\n						lastArmyVisits[current] = lastArmyVisits[second];\n						armies[current] = armies[second];\n					}\n				} else if (type == 'A') {\n					int id = in.readInt() - 1;\n					updateTimes[id].add(i);\n					allCumulUpds[cumulUpdsAt] = dormitories[id].size() + allCumulUpds[updateCumulQtys[id].back()];\n					updateCumulQtys[id].add(cumulUpdsAt++);\n				} else if (type == 'Z') {\n					int id = in.readInt() - 1;\n					lastArmyVisits[id].set(i);\n				} else {\n					int current = in.readInt() - 1;\n					int lastArmyVisit = lastArmyVisits[current].get();\n					if (lastArmyVisit < ignoreArmyBefore[current]) {\n						lastArmyVisit = lastExplicitArmy[current];\n					}\n					if (baseQtyTime[current] > lastArmyVisit) {\n						lastArmyVisit = baseQtyTime[current];\n					} else {\n						baseQty[current] = 0;\n					}\n					int lastNotNeededUpdate = get(updateTimes[current], lastArmyVisit);\n					baseQty[current] += allCumulUpds[updateCumulQtys[current].get(updateTimes[current].size())] - allCumulUpds[updateCumulQtys[current].get(lastNotNeededUpdate)];\n					baseQtyTime[current] = i;\n					out.printLine(baseQty[current]);\n				}\n			}\n		}\n\n		private int get(IntList time, int visit) {\n			int left = 0;\n			int right = time.size();\n			while (left < right) {\n				int middle = (left + right) >> 1;\n				if (time.get(middle) > visit) {\n					right = middle;\n				} else {\n					left = middle + 1;\n				}\n			}\n			return left;\n		}\n\n	}\n\n	static class IntArrayList extends IntList {\n		private int[] array;\n		private int size;\n\n		public IntArrayList() {\n			this(10);\n		}\n\n		public IntArrayList(int capacity) {\n			array = new int[capacity];\n		}\n\n		public IntArrayList(IntList list) {\n			this(list.size());\n			addAll(list);\n		}\n\n\n		public int get(int index) {\n			if (index >= size)\n				throw new IndexOutOfBoundsException();\n			return array[index];\n		}\n\n\n		public int size() {\n			return size;\n		}\n\n\n		public void add(int value) {\n			ensureCapacity(size + 1);\n			array[size++] = value;\n		}\n\n		public void ensureCapacity(int newCapacity) {\n			if (newCapacity > array.length) {\n				int[] newArray = new int[Math.max(newCapacity, array.length << 1)];\n				System.arraycopy(array, 0, newArray, 0, size);\n				array = newArray;\n			}\n		}\n\n\n		public int[] toArray() {\n			int[] array = new int[size];\n			System.arraycopy(this.array, 0, array, 0, size);\n			return array;\n		}\n\n	}\n\n	static interface IntIterator {\n		public int value();\n\n		public void advance();\n\n		public boolean isValid();\n\n	}\n\n	static class OutputWriter {\n		private final PrintWriter writer;\n\n		public OutputWriter(OutputStream outputStream) {\n			writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n		}\n\n		public OutputWriter(Writer writer) {\n			this.writer = new PrintWriter(writer);\n		}\n\n		public void close() {\n			writer.close();\n		}\n\n		public void printLine(long i) {\n			writer.println(i);\n		}\n\n	}\n\n	static abstract class IntCollection {\n		public abstract IntIterator iterator();\n\n		public abstract int size();\n\n		public abstract void add(int value);\n\n		public int[] toArray() {\n			int size = size();\n			int[] array = new int[size];\n			int i = 0;\n			for (IntIterator iterator = iterator(); iterator.isValid(); iterator.advance())\n				array[i++] = iterator.value();\n			return array;\n		}\n\n		public void addAll(IntCollection values) {\n			for (IntIterator it = values.iterator(); it.isValid(); it.advance()) {\n				add(it.value());\n			}\n		}\n\n	}\n\n	static class InputReader {\n		private InputStream stream;\n		private byte[] buf = new byte[1024];\n		private int curChar;\n		private int numChars;\n		private SpaceCharFilter filter;\n\n		public InputReader(InputStream stream) {\n			this.stream = stream;\n		}\n\n		public int read() {\n			if (numChars == -1)\n				throw new InputMismatchException();\n			if (curChar >= numChars) {\n				curChar = 0;\n				try {\n					numChars = stream.read(buf);\n				} catch (IOException e) {\n					throw new InputMismatchException();\n				}\n				if (numChars <= 0)\n					return -1;\n			}\n			return buf[curChar++];\n		}\n\n		public int readInt() {\n			int c = read();\n			while (isSpaceChar(c))\n				c = read();\n			int sgn = 1;\n			if (c == '-') {\n				sgn = -1;\n				c = read();\n			}\n			int res = 0;\n			do {\n				if (c < '0' || c > '9')\n					throw new InputMismatchException();\n				res *= 10;\n				res += c - '0';\n				c = read();\n			} while (!isSpaceChar(c));\n			return res * sgn;\n		}\n\n		public boolean isSpaceChar(int c) {\n			if (filter != null)\n				return filter.isSpaceChar(c);\n			return isWhitespace(c);\n		}\n\n		public static boolean isWhitespace(int c) {\n			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n		}\n\n		public char readCharacter() {\n			int c = read();\n			while (isSpaceChar(c))\n				c = read();\n			return (char) c;\n		}\n\n		public interface SpaceCharFilter {\n			public boolean isSpaceChar(int ch);\n\n		}\n\n	}\n\n	static abstract class IntList extends IntCollection implements Comparable<IntList> {\n		public abstract int get(int index);\n\n\n		public IntIterator iterator() {\n			return new IntIterator() {\n				private int size = size();\n				private int index = 0;\n\n				public int value() throws NoSuchElementException {\n					if (!isValid())\n						throw new NoSuchElementException();\n					return get(index);\n				}\n\n				public void advance() throws NoSuchElementException {\n					if (!isValid())\n						throw new NoSuchElementException();\n					index++;\n				}\n\n				public boolean isValid() {\n					return index < size;\n				}\n			};\n		}\n\n		public int back() {\n			return get(size() - 1);\n		}\n\n		public int hashCode() {\n			int hashCode = 1;\n			for (IntIterator i = iterator(); i.isValid(); i.advance())\n				hashCode = 31 * hashCode + i.value();\n			return hashCode;\n		}\n\n\n		public boolean equals(Object obj) {\n			if (!(obj instanceof IntList))\n				return false;\n			IntList list = (IntList) obj;\n			if (list.size() != size())\n				return false;\n			IntIterator i = iterator();\n			IntIterator j = list.iterator();\n			while (i.isValid()) {\n				if (i.value() != j.value())\n					return false;\n				i.advance();\n				j.advance();\n			}\n			return true;\n		}\n\n		public int compareTo(IntList o) {\n			IntIterator i = iterator();\n			IntIterator j = o.iterator();\n			while (true) {\n				if (i.isValid()) {\n					if (j.isValid()) {\n						if (i.value() != j.value()) {\n							if (i.value() < j.value())\n								return -1;\n							else\n								return 1;\n						}\n					} else\n						return 1;\n				} else {\n					if (j.isValid())\n						return -1;\n					else\n						return 0;\n				}\n				i.advance();\n				j.advance();\n			}\n		}\n\n	}\n}\n\n","binary search,data structures,dsu,trees"
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n        \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n    \n    static class OutputWriter {\n        PrintWriter writer;\n        \n        public OutputWriter(OutputStream stream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(stream), 32768));\n        }\n        \n        public void println(int x) {\n            writer.println(x);\n        }\n        \n        public void println(long x) {\n            writer.println(x);\n        }\n        \n        public <T> void print(T x) {\n            writer.print(x);\n        }\n        \n        public <T> void println(T x) {\n            writer.println(x);\n        }\n        \n        public void close() {\n            writer.close();\n        }\n    }\n    \n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        Task t = new Task();\n        t.solve(in, out);\n        out.close();\n    }\n    \n    static class Task {\n    \n        static class AbstractGraphBuilder {\n            int[] whereIsNode;\n            int iterator;\n            \n            public AbstractGraphBuilder(int n, int m) {\n                whereIsNode = new int[n + 1];\n                iterator = n;\n                for (int i = 1; i <= n; i++) {\n                    whereIsNode[i] = i;\n                }\n            }\n            \n            public int askWhereIsNode(int x) {\n                return whereIsNode[x];\n            }\n            \n            public void union(int x, int y) {\n                int z = (++iterator);\n                whereIsNode[x] = z;\n            }\n            \n            public int howManyVertices() {\n                return iterator;\n            }\n            \n            public void clear() {\n                whereIsNode = null;\n            }\n        }\n        \n        static class GraphBuilder {\n            AbstractGraphBuilder agb;\n            ArrayList<Integer>[] adj;\n            public int[] leafsCnt;\n            public int[] subtreeSz;\n            public int[] posInEuler;\n            boolean[] used;\n            int eulerIt;\n            \n            @SuppressWarnings(""unchecked"")\n            public GraphBuilder(int n, int m) {\n                int tmp = n + m + 1;\n                adj = (ArrayList<Integer>[])new ArrayList[tmp];\n                for (int i = 0; i < adj.length; i++) {\n                    adj[i] = new ArrayList<Integer>();\n                }\n                agb = new AbstractGraphBuilder(n, m);\n            }\n            \n            void addDirectedEdge(int x, int y) {\n                adj[x].add(y);\n            }\n            \n            public void union(int x, int y) {\n                int a = agb.askWhereIsNode(x);\n                int b = agb.askWhereIsNode(y);\n                agb.union(x, y);\n                int z = agb.askWhereIsNode(x);\n                addDirectedEdge(z, a);\n                addDirectedEdge(z, b);\n            }\n            \n            public int askWhereIsNode(int x) {\n                return agb.askWhereIsNode(x);\n            }\n            \n            public int howManyVertices() {\n                return agb.howManyVertices();\n            }\n            \n            void dfs(int v, int p) {\n                used[v] = true;\n                subtreeSz[v] = 1;\n                posInEuler[v] = eulerIt++;\n                leafsCnt[v] = 0;\n                \n                for (int to : adj[v]) {\n                    if (to == p) continue;\n                    dfs(to, v);\n                    subtreeSz[v] += subtreeSz[to];\n                    leafsCnt[v] += leafsCnt[to];\n                }\n                \n                if (subtreeSz[v] == 1) leafsCnt[v] = 1;\n            }\n            \n            void clear() {\n                agb.clear();\n                used = null;\n                adj = null;\n            }\n            \n            public void doCalculations() {\n                int n = howManyVertices();\n                eulerIt = 0;\n                leafsCnt = new int[n + 1];\n                subtreeSz = new int[n + 1];\n                posInEuler = new int[n + 1];\n                used = new boolean[n + 1];\n                \n                for (int v = n; v >= 1; v--) {\n                    if (!used[v]) {\n                        dfs(v, -1);\n                    }\n                }\n                \n                clear();\n            }\n        }\n        \n        static class Query {\n            final char type;\n            final int x;\n            final int y;\n            \n            public Query(char type, int x, int y) {\n                this.type = type;\n                this.x = x;\n                this.y = y;\n            }\n        }\n        \n        static class AskValueQuery {\n            int x;\n            long result;\n            AskValueQuery(int x) {\n                this.x = x;\n            }\n            public int getX() {\n                return x;\n            }\n            public void setResult(long result) {\n                this.result = result;\n            }\n            public long getResult() {\n                return result;\n            }\n        }\n        \n        static class FullAskQuery {\n            AskValueQuery l, r;\n            public FullAskQuery(AskValueQuery l, AskValueQuery r) {\n                this.l = l;\n                this.r = r;\n            }\n            public long getResult() {\n                return r.getResult() - l.getResult();\n            }\n        }\n        \n        Query[] queries;\n        ArrayList<AskValueQuery>[] askValueQueries;\n        FullAskQuery[] fullAskQueries;\n        GraphBuilder university, military;\n        int[] militaryTree;\n        \n        void buildMilitaryTree() {\n            militaryTree = new int[military.howManyVertices() * 4];\n        }\n        \n        void pushInMilitaryTree(int v) {\n            int l = v * 2 + 1;\n            int r = v * 2 + 2;\n            if (militaryTree[l] < militaryTree[v]) {\n                militaryTree[l] = militaryTree[v];\n            }\n            if (militaryTree[r] < militaryTree[v]) {\n                militaryTree[r] = militaryTree[v];\n            }\n        }\n        \n        void raidToMilitaryTreeRec(int v, int tl, int tr, int l, int r, int idx) {\n            if (tl == l && tr == r) {\n                militaryTree[v] = idx;\n                return;\n            }\n            pushInMilitaryTree(v);\n            int tm = (tl + tr) / 2;\n            if (r <= tm) {\n                raidToMilitaryTreeRec(v * 2 + 1, tl, tm, l, r, idx);\n            }\n            else if (l > tm) {\n                raidToMilitaryTreeRec(v * 2 + 2, tm + 1, tr, l, r, idx);\n            }\n            else {\n                raidToMilitaryTreeRec(v * 2 + 1, tl, tm, l, tm, idx);\n                raidToMilitaryTreeRec(v * 2 + 2, tm + 1, tr, tm + 1, r, idx);\n            }\n        }\n        \n        void raidToMilitaryTree(int l, int r, int idx) {\n            raidToMilitaryTreeRec(0, 0, military.howManyVertices() - 1, l, r, idx);\n        }\n        \n        int militaryTreeGet(int v, int tl, int tr, int pos) {\n            if (tl == tr) {\n                return militaryTree[v];\n            }\n            pushInMilitaryTree(v);\n            int tm = (tl + tr) / 2;\n            if (pos <= tm) {\n                return militaryTreeGet(v * 2 + 1, tl, tm, pos);\n            }\n            else {\n                return militaryTreeGet(v * 2 + 2, tm + 1, tr, pos);\n            }\n        }\n        \n        int getIdxOfLastRaid(int x) {\n            return militaryTreeGet(0, 0, military.howManyVertices() - 1, military.posInEuler[x]);\n        }\n        \n        long[] universityTree;\n        \n        void buildUniversityTree() {\n            universityTree = new long[university.howManyVertices() * 4];\n        }\n        \n        void addToUniversityTreeRec(int v, int tl, int tr, int l, int r, long val) {\n            if (tl == l && tr == r) {\n                universityTree[v] += val;\n                return;\n            }\n            int tm = (tl + tr) / 2;\n            if (r <= tm) {\n                addToUniversityTreeRec(v * 2 + 1, tl, tm, l, r, val);\n            }\n            else if (l > tm) {\n                addToUniversityTreeRec(v * 2 + 2, tm + 1, tr, l, r, val);\n            }\n            else {\n                addToUniversityTreeRec(v * 2 + 1, tl, tm, l, tm, val);\n                addToUniversityTreeRec(v * 2 + 2, tm + 1, tr, tm + 1, r, val);\n            }\n        }\n        \n        long universityTreeGet(int v, int tl, int tr, int pos) {\n            if (tl == tr) {\n                return universityTree[v];\n            }\n            int tm = (tl + tr) / 2;\n            if (pos <= tm) {\n                return universityTree[v] + universityTreeGet(v * 2 + 1, tl, tm, pos);\n            }\n            else {\n                return universityTree[v] + universityTreeGet(v * 2 + 2, tm + 1, tr, pos);\n            }\n        }\n        \n        long getValueInUniversity(int x) {\n            return universityTreeGet(0, 0, university.howManyVertices() - 1, university.posInEuler[x]);\n        }\n        \n        void addToUniversityTree(int l, int r, long val) {\n            addToUniversityTreeRec(0, 0, university.howManyVertices() - 1, l, r, val);\n        }\n        \n        @SuppressWarnings(""unchecked"")\n        public void solve(InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            \n            queries = new Query[m + 1];\n            askValueQueries = (ArrayList<AskValueQuery>[])new ArrayList[m + 1];\n            for (int i = 0; i < askValueQueries.length; i++) {\n                askValueQueries[i] = new ArrayList<AskValueQuery>();\n            }\n            fullAskQueries = new FullAskQuery[m + 1];\n            \n            for (int i = 1; i <= m; i++) {\n                char type = in.next().charAt(0);\n                int x = 0, y = 0;\n                if (type == 'U' || type == 'M') {\n                    x = in.nextInt();\n                    y = in.nextInt();\n                }\n                else {\n                    x = in.nextInt();\n                }\n                queries[i] = new Query(type, x, y);\n            }\n            \n            university = new GraphBuilder(n, m);\n            \n            for (int i = 1; i <= m; i++) {\n                if (queries[i].type == 'U') {\n                    university.union(queries[i].x, queries[i].y);\n                }\n            }\n            \n            university.doCalculations();\n            \n            military = new GraphBuilder(n, m);\n            \n            for (int i = 1; i <= m; i++) {\n                if (queries[i].type == 'M') {\n                    military.union(queries[i].x, queries[i].y);\n                }\n            }\n            \n            military.doCalculations();\n            \n            buildMilitaryTree();\n        \n            AbstractGraphBuilder abstractMilitary = new AbstractGraphBuilder(n, m);\n            \n            for (int i = 1; i <= m; i++) {\n                if (queries[i].type == 'M') {\n                    abstractMilitary.union(queries[i].x, queries[i].y);\n                }\n                else if (queries[i].type == 'Z') {\n                    int x = abstractMilitary.askWhereIsNode(queries[i].x);\n                    raidToMilitaryTree(military.posInEuler[x], military.posInEuler[x] + military.subtreeSz[x] - 1, i);\n                }\n                else if (queries[i].type == 'Q') {\n                    int x = queries[i].x;\n                    int idxOfLastRaid = getIdxOfLastRaid(queries[i].x);\n                    askValueQueries[idxOfLastRaid].add(new AskValueQuery(x));\n                    askValueQueries[i].add(new AskValueQuery(x));\n                    fullAskQueries[i] = new FullAskQuery(askValueQueries[idxOfLastRaid].get(askValueQueries[idxOfLastRaid].size() - 1),\n                                                        askValueQueries[i].get(askValueQueries[i].size() - 1));\n                }\n            }\n            \n            buildUniversityTree();\n            \n            AbstractGraphBuilder abstractUniversity = new AbstractGraphBuilder(n, m);\n            \n            for (int i = 1; i <= m; i++) {\n                if (queries[i].type == 'U') {\n                    abstractUniversity.union(queries[i].x, queries[i].y);\n                }\n                else if (queries[i].type == 'A') {\n                    int x = abstractUniversity.askWhereIsNode(queries[i].x);\n                    addToUniversityTree(university.posInEuler[x], university.posInEuler[x] + university.subtreeSz[x] - 1, university.leafsCnt[x]);\n                }\n                for (AskValueQuery q : askValueQueries[i]) {\n                    q.setResult(getValueInUniversity(q.getX()));\n                }\n            }\n            \n            for (FullAskQuery q : fullAskQueries) {\n                if (q != null) {\n                    out.println(q.getResult());\n                }\n            }\n            \n            out.close();\n        }\n    }\n}","binary search,data structures,dsu,trees"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), """", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            DCampus solver = new DCampus();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class DCampus {\n        int indicator;\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.ri();\n            int m = in.ri();\n            Node[] U = new Node[n];\n            Node[] M = new Node[n];\n            for (int i = 0; i < n; i++) {\n                U[i] = new Node();\n                M[i] = new Node();\n            }\n            Node[] cloneU = U.clone();\n            Node[] cloneM = M.clone();\n            Query[] queries = new Query[m];\n            for (int i = 0; i < m; i++) {\n                char c = in.rc();\n                queries[i] = new Query();\n                queries[i].t = c;\n                queries[i].a = in.ri() - 1;\n                if (c == 'U' || c == 'M') {\n                    queries[i].b = in.ri() - 1;\n                    if (c == 'U') {\n                        Node node = new Node();\n                        node.left = U[queries[i].a];\n                        node.right = U[queries[i].b];\n                        U[queries[i].a] = node;\n                        U[queries[i].b] = null;\n                    } else {\n                        Node node = new Node();\n                        node.left = M[queries[i].a];\n                        node.right = M[queries[i].b];\n                        M[queries[i].a] = node;\n                        M[queries[i].b] = null;\n                    }\n                }\n            }\n\n            indicator = 0;\n            for (Node node : U) {\n                if (node == null) {\n                    continue;\n                }\n                allocId(node);\n            }\n            indicator = 0;\n            for (Node node : M) {\n                if (node == null) {\n                    continue;\n                }\n                allocId(node);\n            }\n            U = cloneU;\n            M = cloneM;\n            int[][] rangeU = new int[n][2];\n            int[][] rangeM = new int[n][2];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < 2; j++) {\n                    rangeU[i][j] = U[i].id;\n                    rangeM[i][j] = M[i].id;\n                }\n            }\n\n            RangeAffineRangeSum st = new RangeAffineRangeSum(0, n - 1);\n            st.init(0, n - 1, i -> 0);\n            int now = 0;\n\n            MultiWayStack<Query> delete = new MultiWayStack<>(m + 1, m);\n            MultiWayStack<Query> add = new MultiWayStack<>(m + 1, m);\n            for (Query q : queries) {\n                now++;\n                if (q.t == 'U') {\n                    //merge\n                } else if (q.t == 'M') {\n                    merge(rangeM[q.a], rangeM[q.b]);\n                } else if (q.t == 'A') {\n                } else if (q.t == 'Z') {\n                    st.update(rangeM[q.a][0], rangeM[q.a][1], 0, n - 1, 0, now);\n                } else if (q.t == 'Q') {\n                    int lastPurgeTime = (int) st.query(M[q.a].id, M[q.a].id, 0, n - 1);\n                    delete.addLast(lastPurgeTime, q);\n                    add.addLast(now, q);\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < 2; j++) {\n                    rangeU[i][j] = U[i].id;\n                    rangeM[i][j] = M[i].id;\n                }\n            }\n            st.init(0, n - 1, i -> 0);\n            now = 0;\n\n            for (Query q : queries) {\n                now++;\n                for (Query x : delete.getStack(now)) {\n                    x.ans -= st.query(U[x.a].id, U[x.a].id, 0, n - 1);\n                }\n                for (Query x : add.getStack(now)) {\n                    x.ans += st.query(U[x.a].id, U[x.a].id, 0, n - 1);\n                }\n\n                if (q.t == 'U') {\n                    //merge\n                    merge(rangeU[q.a], rangeU[q.b]);\n                } else if (q.t == 'M') {\n                } else if (q.t == 'A') {\n                    int len = rangeU[q.a][1] - rangeU[q.a][0] + 1;\n                    st.update(rangeU[q.a][0], rangeU[q.a][1], 0, n - 1, 1, len);\n                } else if (q.t == 'Z') {\n                } else if (q.t == 'Q') {\n                    out.println(q.ans);\n                }\n            }\n\n        }\n\n        public void merge(int[] a, int[] b) {\n            a[0] = Math.min(a[0], b[0]);\n            a[1] = Math.max(a[1], b[1]);\n        }\n\n        public void allocId(Node root) {\n            if (root.left == null) {\n                root.id = indicator++;\n                return;\n            }\n            allocId(root.left);\n            allocId(root.right);\n        }\n\n    }\n\n    static class Node {\n        Node left;\n        Node right;\n        int id;\n\n    }\n\n    static class RangeAffineRangeSum implements Cloneable {\n        private RangeAffineRangeSum left;\n        private RangeAffineRangeSum right;\n        private long sum;\n        private long da;\n        private long db;\n\n        private void modify(long a, long b) {\n            sum = (sum * a + b);\n            da = (da * a);\n            db = (db * a + b);\n        }\n\n        public void pushUp() {\n        }\n\n        public void pushDown() {\n            if (!(da == 1 && db == 0)) {\n                left.modify(da, db);\n                right.modify(da, db);\n                da = 1;\n                db = 0;\n            }\n        }\n\n        public RangeAffineRangeSum(int l, int r) {\n            if (l < r) {\n                int m = DigitUtils.floorAverage(l, r);\n                left = new RangeAffineRangeSum(l, m);\n                right = new RangeAffineRangeSum(m + 1, r);\n                pushUp();\n            }\n        }\n\n        public void init(int l, int r, IntToIntegerFunction function) {\n            da = 1;\n            db = 0;\n            if (l < r) {\n                int m = DigitUtils.floorAverage(l, r);\n                left.init(l, m, function);\n                right.init(m + 1, r, function);\n                pushUp();\n            } else {\n                sum = function.apply(l);\n            }\n        }\n\n        private boolean covered(int ll, int rr, int l, int r) {\n            return ll <= l && rr >= r;\n        }\n\n        private boolean noIntersection(int ll, int rr, int l, int r) {\n            return ll > r || rr < l;\n        }\n\n        public void update(int ll, int rr, int l, int r, long a, long b) {\n            if (noIntersection(ll, rr, l, r)) {\n                return;\n            }\n            if (covered(ll, rr, l, r)) {\n                modify(a, b);\n                return;\n            }\n            pushDown();\n            int m = DigitUtils.floorAverage(l, r);\n            left.update(ll, rr, l, m, a, b);\n            right.update(ll, rr, m + 1, r, a, b);\n            pushUp();\n        }\n\n        public long query(int ll, int rr, int l, int r) {\n            if (noIntersection(ll, rr, l, r)) {\n                return 0;\n            }\n            if (covered(ll, rr, l, r)) {\n                return sum;\n            }\n            pushDown();\n            int m = DigitUtils.floorAverage(l, r);\n            return left.query(ll, rr, l, m) +\n                    right.query(ll, rr, m + 1, r);\n        }\n\n        private RangeAffineRangeSum deepClone() {\n            RangeAffineRangeSum seg = clone();\n            if (seg.left != null) {\n                seg.left = seg.left.deepClone();\n            }\n            if (seg.right != null) {\n                seg.right = seg.right.deepClone();\n            }\n            return seg;\n        }\n\n        protected RangeAffineRangeSum clone() {\n            try {\n                return (RangeAffineRangeSum) super.clone();\n            } catch (CloneNotSupportedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        private void toString(StringBuilder builder) {\n            if (left == null && right == null) {\n                builder.append(sum).append("","");\n                return;\n            }\n            pushDown();\n            left.toString(builder);\n            right.toString(builder);\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            deepClone().toString(builder);\n            if (builder.length() > 0) {\n                builder.setLength(builder.length() - 1);\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static class Query {\n        char t;\n        int a;\n        int b;\n        long ans;\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static int floorAverage(int x, int y) {\n            return (x & y) + ((x ^ y) >> 1);\n        }\n\n    }\n\n    static interface SimplifiedStack<T> extends Iterable<T> {\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int ri() {\n            return readInt();\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public char rc() {\n            return readChar();\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n    }\n\n    static class MultiWayStack<T> {\n        private Object[] values;\n        private int[] next;\n        private int[] heads;\n        private int alloc;\n        private int stackNum;\n\n        public RevokeIterator<T> iterator(final int queue) {\n            return new RevokeIterator<T>() {\n                int ele = heads[queue];\n                int pre = 0;\n\n\n                public boolean hasNext() {\n                    return ele != 0;\n                }\n\n\n                public T next() {\n                    T ans = (T) values[ele];\n                    pre = ele;\n                    ele = next[ele];\n                    return ans;\n                }\n\n\n                public void revoke() {\n                    ele = pre;\n                    pre = 0;\n                }\n            };\n        }\n\n        public SimplifiedStack<T> getStack(int qId) {\n            return new SimplifiedStack<T>() {\n\n                public boolean isEmpty() {\n                    return MultiWayStack.this.isEmpty(qId);\n                }\n\n\n                public T peekLast() {\n                    return MultiWayStack.this.peekLast(qId);\n                }\n\n\n                public void addLast(T x) {\n                    MultiWayStack.this.addLast(qId, x);\n                }\n\n\n                public T removeLast() {\n                    return MultiWayStack.this.removeLast(qId);\n                }\n\n\n                public Iterator<T> iterator() {\n                    return MultiWayStack.this.iterator(qId);\n                }\n            };\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            values = Arrays.copyOf(values, newSize);\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n        }\n\n        public boolean isEmpty(int qId) {\n            return heads[qId] == 0;\n        }\n\n        public MultiWayStack(int qNum, int totalCapacity) {\n            values = new Object[totalCapacity + 1];\n            next = new int[totalCapacity + 1];\n            heads = new int[qNum];\n            stackNum = qNum;\n        }\n\n        public void addLast(int qId, T x) {\n            alloc();\n            values[alloc] = x;\n            next[alloc] = heads[qId];\n            heads[qId] = alloc;\n        }\n\n        public T peekLast(int qId) {\n            return (T) values[heads[qId]];\n        }\n\n        public T removeLast(int qId) {\n            T ans = (T) values[heads[qId]];\n            heads[qId] = next[heads[qId]];\n            return ans;\n        }\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            for (int i = 0; i < stackNum; i++) {\n                builder.append(i).append("": "");\n                for (Iterator iterator = iterator(i); iterator.hasNext(); ) {\n                    builder.append(iterator.next()).append("","");\n                }\n                if (builder.charAt(builder.length() - 1) == ',') {\n                    builder.setLength(builder.length() - 1);\n                }\n                builder.append('\n');\n            }\n            return builder.toString();\n        }\n\n    }\n\n    static interface RevokeIterator<E> extends Iterator<E> {\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 1 << 13;\n        private final Writer os;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(long c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(String c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput println(long c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            return append(System.lineSeparator());\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static interface IntToIntegerFunction {\n        int apply(int x);\n\n    }\n}\n\n","binary search,data structures,dsu,trees"
"import java.util.Scanner;\n\npublic class Main {\n\n	public void solve() {\n		Scanner scanner = new Scanner(System.in);\n		char[] string = scanner.next().toCharArray();\n		int L = string.length;// 文字列の長さ\n\n		int K = scanner.nextInt();\n		scanner.close();\n\n		// dp[i][j]:= iからjまでの部分文字列が半回文かどうか\n		boolean[][] dp = new boolean[L][L];\n\n		// deques[x]:= xを始点にした半回文が長さ順に並んでいる\n		MyDeque[] deques = new MyDeque[L];\n		for (int i = 0; i < L; i++) {\n			deques[i] = new MyDeque(L);\n		}\n\n		// 短い方から半回文を列挙する\n		for (int length = 0; length < L; length++) {\n			for (int x = 0; x + length < L; x++) {\n				int y = x + length;\n				if (string[x] == string[y] && (length <= 3 || dp[x + 2][y - 2])) {\n					dp[x][x + length] = true;\n					deques[x].add(x + length);\n				}\n			}\n		}\n\n		StringBuilder ans = new StringBuilder();\n		for (int i = 0; i < L; i++) {\n			// i文字目を決める\n			int finished = 0;// 解答の文字列とi-1文字目まで同じで、長さがi-1の文字列の数\n			int a = 0;// i文字目が 'a' となる文字列の合計\n			for (int x = 0; x < L; x++) {\n				if (deques[x].isEmpty()) {\n					continue;\n				}\n				if (deques[x].peek() < x + i) {\n					// i文字より小さい文字列は削除しておく\n					finished++;\n					deques[x].poll();\n				}\n				if (!deques[x].isEmpty() && string[x + i] == 'a') {\n					a += deques[x].size();\n				}\n			}\n\n			if (K <= finished) {\n				break;\n			}\n			K -= finished;\n\n			if (K <= a) {\n				// i文字目がaとなる場合\n				ans.append('a');\n				for (int x = 0; x + i < L; x++) {\n					// i文字目が 'b'となる文字列は、もう候補になりえないので全て削除する\n					if (!deques[x].isEmpty() && string[x + i] == 'b') {\n						deques[x].clear();\n					}\n				}\n			} else {\n				// i文字目がbとなる場合\n				K -= a;\n				ans.append('b');\n				for (int x = 0; x + i < L; x++) {\n					// i文字目がaとなる文字列は全て削除する　\n					if (!deques[x].isEmpty() && string[x + i] == 'a') {\n						deques[x].clear();\n					}\n				}\n			}\n		}\n		System.out.println(ans.toString());\n	}\n\n	public static void main(String[] args) {\n		new Main().solve();\n	}\n}\n\n// ArrayDequeを自分で作る\nclass MyDeque {\n	int[] nums;\n	int size, cur;\n\n	public MyDeque(int N) {\n		this.nums = new int[N];\n		this.size = 0;\n		this.cur = 0;\n	}\n\n	public void add(int a) {\n		nums[size] = a;\n		size++;\n	}\n\n	public int poll() {\n		if (size == 0) {\n			return -1;\n		}\n		cur++;\n		size--;\n		return nums[cur - 1];\n	}\n\n	public int size() {\n		return size;\n	}\n\n	public boolean isEmpty() {\n		return size == 0;\n	}\n\n	public int peek() {\n		if (size == 0) {\n			return -1;\n		}\n		return nums[cur];\n	}\n\n	public void clear() {\n		size = 0;\n		cur = 0;\n	}\n}","data structures,dp,graphs,string suffix structures,strings,trees"
"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n	public void solve() {\n		Scanner scanner = new Scanner(System.in);\n		char[] S = scanner.next().toCharArray();\n		int L = S.length;// 文字列の長さ\n		boolean[] string = new boolean[L];\n		for (int i = 0; i < L; i++) {\n			if (S[i] == 'a') {\n				string[i] = true;\n			}\n		}\n\n		int K = scanner.nextInt();\n		scanner.close();\n\n		// dp[i][j]:= iからjまでの部分文字列が半回文かどうか\n		boolean[][] dp = new boolean[L][L];\n\n		// deques[x]:= xを始点にした半回文が長さ順に並んでいる\n		Node[] deques = new Node[L];\n		for (int i = 0; i < L; i++) {\n			deques[i] = new Node(L);\n		}\n\n		// 短い方から半回文を列挙する\n		for (int length = 0; length < L; length++) {\n			for (int x = 0; x + length < L; x++) {\n				if (string[x] == string[x + length] && (length <= 3 || dp[x + 2][x + length - 2])) {\n					dp[x][x + length] = true;\n					deques[x].add(x + length);\n				}\n			}\n		}\n\n		StringBuilder ans = new StringBuilder();\n		for (int i = 0; i < L; i++) {\n			// i文字目を決める\n			int finished = 0;// 解答の文字列とi-1文字目まで同じで、長さがi-1の文字列の数\n			int a = 0;// i文字目が 'a' となる文字列の合計\n			for (int x = 0; x < L; x++) {\n				if (deques[x].isEmpty()) {\n					continue;\n				}\n				if (deques[x].peek() < x + i) {\n					// i文字より小さい文字列は削除しておく\n					finished++;\n					deques[x].poll();\n				}\n				if (!deques[x].isEmpty() && string[x + i]) {\n					a += deques[x].size();\n				}\n			}\n\n			if (K <= finished) {\n				break;\n			}\n			K -= finished;\n\n			if (K <= a) {\n				// i文字目がaとなる場合\n				ans.append('a');\n				for (int x = 0; x + i < L; x++) {\n					// i文字目が 'b'となる文字列は、もう候補になりえないので全て削除する\n					if (!deques[x].isEmpty() && !string[x + i]) {\n						deques[x].clear();\n					}\n				}\n			} else {\n				// i文字目がbとなる場合\n				K -= a;\n				ans.append('b');\n				for (int x = 0; x + i < L; x++) {\n					// i文字目がaとなる文字列は全て削除する　\n					if (!deques[x].isEmpty() && string[x + i]) {\n						deques[x].clear();\n					}\n				}\n			}\n		}\n		System.out.println(ans.toString());\n	}\n\n	public static void main(String[] args) {\n		new Main().solve();\n	}\n}\n\nclass Node {\n	int[] nums;\n	int size, cur;\n\n	public Node(int N) {\n		this.nums = new int[N];\n		this.size = 0;\n		this.cur = 0;\n	}\n\n	public void add(int a) {\n		nums[size] = a;\n		size++;\n	}\n\n	public int poll() {\n		cur++;\n		size--;\n		return nums[cur - 1];\n	}\n\n	public int size() {\n		return size;\n	}\n\n	public boolean isEmpty() {\n		return size == 0;\n	}\n\n	public int peek() {\n		return nums[cur];\n	}\n\n	public void clear() {\n		Arrays.fill(nums, 0);\n		size = 0;\n		cur = 0;\n	}\n}","data structures,dp,graphs,string suffix structures,strings,trees"
"import java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class CF557E {\n	int[] last;\n	boolean[][] isPalin; // is half Palindrome\n	void findPalindromes() {\n		int n = s.length;\n		last = new int[n];\n		isPalin = new boolean[n][n];\n		for(int i =  0 ; i < n ; i++) { // base cases\n			isPalin[i][i] = true; // check all length 1's\n			last[i] = i;\n			if(i < n - 1 && s[i] == s[i + 1]) { // check all length 2's\n				isPalin[i][i + 1] = true;\n				last[i] = i + 1;\n			}\n			if(i < n - 2 && s[i] == s[i + 2]) { // check all length 3's\n				isPalin[i][i + 2] = true;\n				last[i] = i + 2;\n			}\n			if(i < n - 3 && s[i] == s[i + 3]) { // check all length 4's\n				isPalin[i][i + 3] = true;\n				last[i] = i + 3;\n			}\n		}\n		for(int len = 4 ; len < n ; len++) {\n			for(int i = 0 ; i < n - len ; i++) {\n				int j = i + len;\n				if(s[i] == s[j] && isPalin[i + 2][j - 2]) {\n					isPalin[i][j] = true;\n					last[i] = j;\n				}\n			}\n		}\n	}\n	void addStrings() {\n		int n = s.length;\n		numNodes = 1 + ((n * (n + 1)) / 2);\n		next = 1;\n		cnt = new int[numNodes];\n		end = new int[numNodes];\n		prev = new int[numNodes];\n		trie = new int[2][numNodes];\n		int node = 0;\n		for(int i = 0 ; i < n ; i++) {\n			for(int j = i ; j <= last[i] ; j++) {\n				int let = s[j] - 'a';\n				if(trie[let][node] == 0)\n					trie[let][node] = next++;\n				prev[trie[let][node]] = node;\n				node = trie[let][node];\n				if(isPalin[i][j]) end[node]++;\n			}\n			while(true) {\n				int newcnt = 0;\n				for(int let = 0 ; let < 2 ; let++)\n					if(trie[let][node] != 0)\n						newcnt += cnt[trie[let][node]];\n				cnt[node] = end[node] + newcnt;\n				if(node == 0) break;\n				node = prev[node];\n			}\n		}\n	}\n	char[] s;\n	int next, numNodes, prev[], cnt[], end[], trie[][];\n	public CF557E() {\n		FS scan = new FS();\n		PrintWriter out = new PrintWriter(System.out);\n		s = scan.next().toCharArray();\n		int k = scan.nextInt();\n		findPalindromes();\n		addStrings();\n		int node = 0;\n		int numStrings = 0;\n		StringBuilder res = new StringBuilder();\n		char[] letter = {'a', 'b'};\n		while(true) {\n			numStrings += end[node];\n			if(numStrings >= k) break;\n			for(int let = 0 ; let < 2 ; let++) {\n				if(trie[let][node] != 0) {\n					if(numStrings + cnt[trie[let][node]] >= k) {\n						res.append(letter[let]);\n						node = trie[let][node];\n						break;\n					} else {\n						numStrings += cnt[trie[let][node]];\n					}\n				}\n			}\n		}\n		out.println(res);\n		out.close();\n	}\n	class FS {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer("""");\n		public String next() {\n			while(!st.hasMoreTokens()) {\n				try { st = new StringTokenizer(br.readLine()); }\n				catch(Exception e) { e.printStackTrace(); }\n			}\n			return st.nextToken();\n		}\n		public int nextInt() { return Integer.parseInt(next()); }\n	}\n	public static void main(String[] args) { new CF557E(); }\n}\n","data structures,dp,graphs,string suffix structures,strings,trees"
"import java.util.Scanner;\n\npublic class Main {\n\n	public void solve() {\n		Scanner scanner = new Scanner(System.in);\n		char[] S = scanner.next().toCharArray();\n		int L = S.length;// 文字列の長さ\n		boolean[] string = new boolean[L];\n		for (int i = 0; i < L; i++) {\n			if (S[i] == 'a') {\n				string[i] = true;\n			}\n		}\n\n		int K = scanner.nextInt();\n		scanner.close();\n\n		// dp[i][j]:= iからjまでの部分文字列が半回文かどうか\n		boolean[][] dp = new boolean[L][L];\n\n		// deques[x]:= xを始点にした半回文が長さ順に並んでいる\n		MyDeque[] deques = new MyDeque[L];\n		for (int i = 0; i < L; i++) {\n			deques[i] = new MyDeque(L);\n		}\n\n		// 短い方から半回文を列挙する\n		for (int length = 0; length < L; length++) {\n			for (int x = 0; x + length < L; x++) {\n				if (string[x] == string[x + length] && (length <= 3 || dp[x + 2][x + length - 2])) {\n					dp[x][x + length] = true;\n					deques[x].add(x + length);\n				}\n			}\n		}\n\n		StringBuilder ans = new StringBuilder();\n		for (int i = 0; i < L; i++) {\n			// i文字目を決める\n			int finished = 0;// 解答の文字列とi-1文字目まで同じで、長さがi-1の文字列の数\n			int a = 0;// i文字目が 'a' となる文字列の合計\n			for (int x = 0; x < L; x++) {\n				if (deques[x].isEmpty()) {\n					continue;\n				}\n				if (deques[x].peek() < x + i) {\n					// i文字より小さい文字列は削除しておく\n					finished++;\n					deques[x].poll();\n				}\n				if (!deques[x].isEmpty() && string[x + i]) {\n					a += deques[x].size();\n				}\n			}\n\n			if (K <= finished) {\n				break;\n			}\n			K -= finished;\n\n			if (K <= a) {\n				// i文字目がaとなる場合\n				ans.append('a');\n				for (int x = 0; x + i < L; x++) {\n					// i文字目が 'b'となる文字列は、もう候補になりえないので全て削除する\n					if (!deques[x].isEmpty() && !string[x + i]) {\n						deques[x].clear();\n					}\n				}\n			} else {\n				// i文字目がbとなる場合\n				K -= a;\n				ans.append('b');\n				for (int x = 0; x + i < L; x++) {\n					// i文字目がaとなる文字列は全て削除する　\n					if (!deques[x].isEmpty() && string[x + i]) {\n						deques[x].clear();\n					}\n				}\n			}\n		}\n		System.out.println(ans.toString());\n	}\n\n	public static void main(String[] args) {\n		new Main().solve();\n	}\n}\n\n// ArrayDequeを自分で作る\nclass MyDeque {\n	int[] nums;\n	int size, cur;\n\n	public MyDeque(int N) {\n		this.nums = new int[N];\n		this.size = 0;\n		this.cur = 0;\n	}\n\n	public void add(int a) {\n		nums[size] = a;\n		size++;\n	}\n\n	public int poll() {\n		if (size == 0) {\n			return -1;\n		}\n		cur++;\n		size--;\n		return nums[cur - 1];\n	}\n\n	public int size() {\n		return size;\n	}\n\n	public boolean isEmpty() {\n		return size == 0;\n	}\n\n	public int peek() {\n		if (size == 0) {\n			return -1;\n		}\n		return nums[cur];\n	}\n\n	public void clear() {\n		size = 0;\n		cur = 0;\n	}\n}","data structures,dp,graphs,string suffix structures,strings,trees"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Solution{\n    static class IScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public IScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    static Solution.IScanner in = new IScanner();\n    static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        int n = in.nextInt();\n        int[] H = new int[100001];\n        int[][] E = new int[201][100001];\n\n        int[] L = new int[n];\n        for (int i = 0; i < n; i++){\n             L[i] = in.nextInt();\n             H[L[i]]++;\n        }\n\n        for (int i = 0; i < n; i++){\n            E[in.nextInt()][L[i]]++;\n        }\n\n        for (int i = 0; i < E.length; i++){\n            for (int j = 1; j < E[i].length; j++){\n                E[i][0] += E[i][j];\n            }\n        }\n\n        int ans = Integer.MAX_VALUE;\n        int suffix = 0, count = 0;\n        for (int max = 100000; max >= 1; max--){\n            if(H[max] != 0){\n                int toBeDeleted = n - (H[max] + H[max] - 1) - count;\n                int minEnergy = suffix;\n                for (int j = 1; j <= 200 && toBeDeleted > 0; j++){\n                    int temp = E[j][0] - E[j][max];\n                    if(temp >= toBeDeleted){\n                        minEnergy += toBeDeleted * j;\n                        toBeDeleted = 0;\n                    }else{\n                        toBeDeleted -= temp;\n                        minEnergy += temp * j;\n                    }\n                }\n\n                if(toBeDeleted <= 0)\n                    ans = Math.min(ans, minEnergy);\n\n                for (int j = 1; j <= 200; j++){\n                    E[j][0] -= E[j][max];\n                    count += E[j][max];\n                    suffix += j * E[j][max];\n                }\n            }\n        }\n        out.println(ans);\n        out.flush();\n        out.close();\n    }\n}","brute force,data structures,dp,greedy,math,sortings"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Solution{\n    static class IScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public IScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = """";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    static Solution.IScanner in = new IScanner();\n    static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        int n = in.nextInt();\n        int[] H = new int[100001];\n        int[][] E = new int[201][100001];\n\n        int[] L = new int[n];\n        for (int i = 0; i < n; i++){\n             L[i] = in.nextInt();\n             H[L[i]]++;\n        }\n\n        for (int i = 0; i < n; i++){\n            E[in.nextInt()][L[i]]++;\n        }\n\n        for (int i = 0; i < E.length; i++){\n            for (int j = 1; j < E[i].length; j++){\n                E[i][0] += E[i][j];\n            }\n        }\n\n\n\n        int ans = Integer.MAX_VALUE;\n        int suffix = 0;\n        int count = 0;\n        for (int max = 100000; max >= 1; max--){\n            if(H[max] != 0){\n                int toBeDeleted = n - (H[max] + H[max] - 1) - count;\n                toBeDeleted = toBeDeleted < 0 ? 0 : toBeDeleted;\n                int minEnergy = suffix;\n                for (int j = 1; j <= 200 && toBeDeleted > 0; j++){\n                    int temp = E[j][0] - E[j][max];\n                    if(temp >= toBeDeleted){\n                        minEnergy += toBeDeleted * j;\n                        toBeDeleted = 0;\n                    }else{\n                        toBeDeleted -= temp;\n                        minEnergy += temp * j;\n                    }\n                }\n\n                if(toBeDeleted == 0)\n                    ans = Math.min(ans, minEnergy);\n\n                for (int j = 1; j <= 200; j++){\n                    E[j][0] -= E[j][max];\n                    count += E[j][max];\n                    suffix += j * E[j][max];\n                }\n\n            }\n        }\n        out.println(ans);\n        out.flush();\n        out.close();\n\n    }\n}","brute force,data structures,dp,greedy,math,sortings"
"\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n\n	static long sx = 0, sy = 0, mod = (long) (1e9 + 7);\n\n	// static HashSet<Integer>[] a;\n	static Double[][][] dp;\n	static long[] fa;\n	static long[] farr;\n	public static PrintWriter out = new PrintWriter(System.out);\n	static ArrayList<pair> pa = new ArrayList<>();\n	static long[] fact = new long[(int) 1e6];\n	static StringBuilder sb = new StringBuilder();\n	static boolean cycle = false;\n	static long m = 998244353;\n	static long[] no, col;\n	static String s;\n	static long k = 0, n = 0, one = 0;\n	static int cnt;\n	// static long[] dp;\n	static long[] p;\n	static long[] ans;\n	static Double[][] a = new Double[2][2];\n	static Double[][] b = new Double[2][2];\n	static Double[] x;\n	static Double[] y;\n	static Double[] dis;\n\n	public static void main(String[] args) throws IOException {\n\n		// Scanner scn = new Scanner(new BufferedReader(new\n		// InputStreamReader(System.in)));\n\n		Reader scn = new Reader();\n\n		int n = scn.nextInt();\n		int[] l = scn.nextIntArray(n);\n		int[] d = scn.nextIntArray(n);\n\n		TreeMap<Integer, ArrayList<Integer>> hm = new TreeMap<>();\n\n		int tot = 0;\n\n		for (int i = 0; i < n; i++) {\n\n			if (!hm.containsKey(l[i]))\n				hm.put(l[i], new ArrayList<>());\n			hm.get(l[i]).add(d[i]);\n\n			tot += d[i];\n		}\n\n//		System.out.println(hm);\n//		System.out.println(tot);\n		int ans = Integer.MAX_VALUE;\n\n		int[] prev = new int[201];\n\n		for (int v : hm.keySet()) {\n\n			int sum = 0;\n			for (int i : hm.get(v))\n				sum += i;\n\n			int cnt = hm.get(v).size() - 1;\n\n			for (int i = 200; i >= 1; i--) {\n\n				int x = Math.min(cnt, prev[i]);\n				sum += i * x;\n				cnt -= x;\n			}\n\n			ans = Math.min(ans, tot - sum);\n\n			for (int i : hm.get(v))\n				prev[i]++;\n		}\n\n		System.out.println(ans);\n	}\n\n	// _________________________TEMPLATE_____________________________________________________________\n\n	// public static long lcm(long x, long y) {\n	//\n	// return (x * y) / gcd(x, y);\n	// }\n	//\n	// private static long gcd(long x, long y) {\n	// if (x == 0)\n	// return y;\n	//\n	// return gcd(y % x, x);\n	// }\n	//\n	// static class comp implements Comparator<Integer> {\n	//\n	// @Override\n	// public int compare(Integer p1, Integer p2) {\n	//\n	// return p2 - p1;\n	//\n	// }\n	// }\n	//\n	// }\n	//\n	// public static long pow(long a, long b) {\n	//\n	// if (b < 0)\n	// return 0;\n	// if (b == 0 || b == 1)\n	// return (long) Math.pow(a, b);\n	//\n	// if (b % 2 == 0) {\n	//\n	// long ret = pow(a, b / 2);\n	// ret = (ret % mod * ret % mod) % mod;\n	// return ret;\n	// }\n	//\n	// else {\n	// return ((pow(a, b - 1) % mod) * a % mod) % mod;\n	// }\n	// }\n\n	private static class pair implements Comparable<pair> {\n\n		long val;\n		int d;\n\n		pair(long a, int b) {\n			val = a;\n			d = b;\n		}\n\n		@Override\n		public int compareTo(pair o) {\n			return 1;\n		}\n\n		// @Override\n		//\n		// public int hashCode() {\n		// return i;\n		// }\n		//\n		// @Override\n		//\n		// public boolean equals(Object o) {\n		//\n		// pair p = (pair) o;\n		// return this.i == p.i;\n		// }\n\n	}\n\n	private static String reverse(String s) {\n\n		return new StringBuilder(s).reverse().toString();\n	}\n\n	public static class Reader {\n		final private int BUFFER_SIZE = 1 << 16;\n		private DataInputStream din;\n		private byte[] buffer;\n		private int bufferPointer, bytesRead;\n\n		public Reader() {\n			din = new DataInputStream(System.in);\n			buffer = new byte[BUFFER_SIZE];\n			bufferPointer = bytesRead = 0;\n		}\n\n		public Reader(String file_name) throws IOException {\n			din = new DataInputStream(new FileInputStream(file_name));\n			buffer = new byte[BUFFER_SIZE];\n			bufferPointer = bytesRead = 0;\n		}\n\n		public String readLine() throws IOException {\n			byte[] buf = new byte[1000000 + 1]; // line length\n			int cnt = 0, c;\n			while ((c = read()) != -1) {\n				if (c == '\n')\n					break;\n				buf[cnt++] = (byte) c;\n			}\n			return new String(buf, 0, cnt);\n		}\n\n		public int nextInt() throws IOException {\n			int ret = 0;\n			byte c = read();\n			while (c <= ' ')\n				c = read();\n			boolean neg = (c == '-');\n			if (neg)\n				c = read();\n			do {\n				ret = ret * 10 + c - '0';\n			} while ((c = read()) >= '0' && c <= '9');\n\n			if (neg)\n				return -ret;\n			return ret;\n		}\n\n		public long nextLong() throws IOException {\n			long ret = 0;\n			byte c = read();\n			while (c <= ' ')\n				c = read();\n			boolean neg = (c == '-');\n			if (neg)\n				c = read();\n			do {\n				ret = ret * 10 + c - '0';\n			} while ((c = read()) >= '0' && c <= '9');\n			if (neg)\n				return -ret;\n			return ret;\n		}\n\n		public double nextDouble() throws IOException {\n			double ret = 0, div = 1;\n			byte c = read();\n			while (c <= ' ')\n				c = read();\n			boolean neg = (c == '-');\n			if (neg)\n				c = read();\n\n			do {\n				ret = ret * 10 + c - '0';\n			} while ((c = read()) >= '0' && c <= '9');\n\n			if (c == '.') {\n				while ((c = read()) >= '0' && c <= '9') {\n					ret += (c - '0') / (div *= 10);\n				}\n			}\n\n			if (neg)\n				return -ret;\n			return ret;\n		}\n\n		private void fillBuffer() throws IOException {\n			bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n			if (bytesRead == -1)\n				buffer[0] = -1;\n		}\n\n		private byte read() throws IOException {\n			if (bufferPointer == bytesRead)\n				fillBuffer();\n			return buffer[bufferPointer++];\n		}\n\n		public void close() throws IOException {\n			if (din == null)\n				return;\n			din.close();\n		}\n\n		public int[] nextIntArray(int n) throws IOException {\n			int[] arr = new int[n];\n			for (int i = 0; i < n; i++) {\n				arr[i] = nextInt();\n			}\n			return arr;\n		}\n\n		public long[] nextLongArray(int n) throws IOException {\n			long[] arr = new long[n];\n			for (int i = 0; i < n; i++) {\n				arr[i] = nextLong();\n			}\n			return arr;\n		}\n\n		public int[][] nextInt2DArray(int m, int n) throws IOException {\n			int[][] arr = new int[m][n];\n			for (int i = 0; i < m; i++) {\n				for (int j = 0; j < n; j++)\n					arr[i][j] = nextInt();\n			}\n			return arr;\n		}\n\n		public long[][] nextInt2DArrayL(int m, int n) throws IOException {\n			long[][] arr = new long[m][n];\n			for (int i = 0; i < m; i++) {\n				for (int j = 0; j < n; j++)\n					arr[i][j] = nextInt();\n			}\n			return arr;\n		}\n		// kickstart - Solution\n		// atcoder - Main\n	}\n\n}","brute force,data structures,dp,greedy,math,sortings"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\npublic class d {\n    public static void main(String[] args) throws IOException {\n       // Scanner s = new Scanner(System.in);\n                BufferedReader s=new BufferedReader(new InputStreamReader(System.in));\n         //       String[] st=s.readLine().trim().split(""\\s+"");\n          //      a=Integer.parseInt(st[i]);\n        StringBuilder sb=new StringBuilder();\n        StringBuilder sb1=new StringBuilder();\n        String[] st3=s.readLine().trim().split(""\\s+"");\n\n      int   n=Integer.parseInt(st3[0]);\n        long[] l=new long[n];\n        String[] st1=s.readLine().trim().split(""\\s+"");\n\n        Student[] st=new Student[n];\n        for(int i=0;i<n;i++){\n            l[i]=Integer.parseInt(st1[i]);\n\n        }     String[] st2=s.readLine().trim().split(""\\s+"");\n        long[] d=new long[n];\n         for(int i=0;i<n;i++){\n             d[i]=Integer.parseInt(st2[i]);\n             st[i]=new Student((int)l[i],(int)d[i]);\n          }\n          Arrays.sort(st,new Sortbyroll());long sum=0;\n          HashMap<Integer,Long> h=new HashMap<>();int ac=0;int count=0;\n          HashMap<Integer,Integer> thisc=new HashMap<>();\n        HashMap<Integer,Integer> c=new HashMap<>();\n        h.put(st[n-1].l,0L);c.put(st[n-1].l,0);\n        for(int i=n-1;i>=0;i--){\n            if(i<n-1&&st[i].l!=st[i+1].l){\n                h.put(st[i].l,sum);c.put(st[i].l,count);\n                thisc.put(st[i+1].l,ac);\n                sum+=st[i].r;count+=1;ac=1;\n            }else {\n                sum+=st[i].r;\n                count++;ac++;}\n        }thisc.put(st[0].l,ac);\n        HashMap<Integer,Integer> D=new HashMap<>();long ans=Long.MAX_VALUE;\n        HashMap<Long,Integer> fans=new HashMap<>();\n           for(int i=0;i<n;i++){\n               long tr=h.get(st[i].l);\n               if(fans.containsKey((long)st[i].l)){\n                   if(D.containsKey(st[i].r)) D.put(st[i].r,D.get(st[i].r)+1);else D.put(st[i].r,1);\n                   continue;}\n               fans.put((long)st[i].l,1);\n          //     System.out.println(i+"" ""+tr);\n                long rem=n-(thisc.get(st[i].l)+c.get(st[i].l));\n                if(rem>thisc.get(st[i].l)-1){\n                    rem=rem-(thisc.get(st[i].l)-1);\n        //            System.out.println(i+"" ""+rem);\n                for(int j=1;j<=200;j++){\n                    if(D.containsKey(j)){\n                        if(D.get(j)>rem){\n                            tr+=rem*j;break;\n                        }\n                        tr+=j*D.get(j);\n                        rem-=D.get(j);\n                    }\n                }}\n               if(D.containsKey(st[i].r)) D.put(st[i].r,D.get(st[i].r)+1);else D.put(st[i].r,1);\n\n               ans=Math.min(ans,tr);\n           }\n        System.out.println(ans);\n\n    }\n    static int[] vis;\n    public static int countSetBits(int n)\n    {\n        return (BitsSetTable256[n & 0xff]\n                + BitsSetTable256[(n >> 8) & 0xff]\n                + BitsSetTable256[(n >> 16) & 0xff]\n                + BitsSetTable256[n >> 24]);\n    }\n    static int[] BitsSetTable256 ;\n    public static void initialize(int n)\n    {\n        BitsSetTable256[0] = 0;\n        for (int i = 0; i <=Math.pow(2,n); i++) {\n            BitsSetTable256[i] = (i & 1) + BitsSetTable256[i / 2];\n        }\n    }\n    static HashMap<Integer,Integer>[] val;//static int[] vis;static int y;\n    static boolean dfs(int x ,int i,ArrayList<Integer>[] adj){\n      vis[i]=1;\n     // if(x==1) System.out.print(i+"" "");\n      if(adj[i]==null) return false;\n      for(int j:adj[i]){\n        //  if(x==1) System.out.print(j+"" "");\n          if(j==x) return true;\n          if(vis[j]==0) return dfs(x,j,adj);\n      }return false;\n    }\n\n    static  void computeLPSArray(String pat, int M, int lps[]) {\n        int len = 0;\n        int i = 1;\n        lps[0] = 0;\n        while (i < M) {\n            if (pat.charAt(i) == pat.charAt(len)) {\n                len++;\n                lps[i] = len;\n                i++;\n            }\n            else\n            {\n                if (len != 0) {\n                    len = lps[len - 1];\n                }\n                else\n                {\n                    lps[i] = len;\n                    i++;\n                }\n            }\n        }\n    }\n    static boolean isPrime(int n) {\n        if (n <= 1) return false;\n        if (n <= 3) return true;\n\n        if (n % 2 == 0 || n % 3 == 0) return false;\n\n        for (int i = 5; i * i <= n; i = i + 6)\n            if (n % i == 0 || n % (i + 2) == 0)\n                return false;\n\n        return true;\n    }\n    static long powerwithmod(long  x, long y, int p) {\n        long  res = 1;\n        x = x % p;\n        while (y > 0) {\n            if ((y & 1) == 1)\n                res = (res * x) % p;\n            y = y >> 1;\n            x = (x * x) % p;\n        }\n        return res;\n    }\n    static long  powerwithoutmod(long x, int y) {\n        long  temp;\n        if( y == 0)\n            return 1;\n        temp = powerwithoutmod(x, y/2);\n        if (y%2 == 0)\n            return temp*temp;\n        else\n        {\n            if(y > 0)\n                return x * temp * temp;\n            else\n                return (temp * temp) / x;\n        }\n    }\n    static void fracion(double x) {\n        String a = """" + x;\n        String spilts[] = a.split(""\\.""); // split using decimal\n        int b = spilts[1].length(); // find the decimal length\n        int denominator = (int) Math.pow(10, b); // calculate the denominator\n        int numerator = (int) (x * denominator); // calculate the nerumrator Ex\n        // 1.2*10 = 12\n        int gcd = (int) gcd((long) numerator, denominator); // Find the greatest common\n        // divisor bw them\n        String fraction = """" + numerator / gcd + ""/"" + denominator / gcd;\n        // System.out.println((denominator/gcd));\n        long x1 = modInverse(denominator / gcd, 998244353);\n        //  System.out.println(x1);\n        System.out.println((((numerator / gcd) % 998244353 * (x1 % 998244353)) % 998244353));\n    }\n    static int bfs(int i1, ArrayList<Integer>[] h, int[] vis, int n,int val1) {\n        Queue<Integer> q = new LinkedList<Integer>();\n        q.add(i1);Queue<Integer> aq=new LinkedList<Integer>();\n        aq.add(0);\n        while(!q.isEmpty()){\n            int i=q.poll();\n            int val=aq.poll();\n            if(i==n){\n                return val;\n            }\n            if(h[i]!=null){\n                for(Integer j:h[i]){\n                    if(vis[j]==0){\n                        q.add(j);vis[j]=1;\n                        aq.add(val+1);}\n                }\n            }\n        }return -1;\n    }\n    static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    static long modInverse(long a, int m)\n    {\n        return (powerwithmod(a, m - 2, m));\n    }\n    static int MAXN=100001;\n    static int[] spf=new int[MAXN];\n    static void sieve() {\n        spf[1] = 1;\n        for (int i=2; i<MAXN; i++)\n            spf[i] = i;\n        for (int i=4; i<MAXN; i+=2)\n            spf[i] = 2;\n        for (int i=3; i*i<MAXN; i++)\n        {\n            if (spf[i] == i)\n            {\n                for (int j=i*i; j<MAXN; j+=i)\n\n                    if (spf[j]==j)\n                        spf[j] = i;\n            }\n        }\n    }\n    static Vector<Integer> getFactorizationUsingSeive(int x) {\n        Vector<Integer> ret = new Vector<Integer>();\n        while (x != 1)\n        {\n            ret.add(spf[x]);\n            x = x / spf[x];\n        }\n        return ret;\n    }\n   /*static long[] fac = new long[MAXN+1];\n     static void calculatefac(int mod){\n        for (int i = 1 ;i <= MAXN; i++)\n            fac[i] = fac[i-1] * i % mod;\n     }\n      static long nCrModPFermat(int n, int r, int mod) {\n         if (r == 0)\n            return 1;\n        fac[0] = 1;\n        return (fac[n]* modInverse(fac[r], mod)\n                % mod * modInverse(fac[n-r], mod)\n                                    % mod) % mod;\n    } */}\nclass Student {\n    int l;int r;int x;\n    public Student(int l, int r) {\n        this.l = l;\n        this.r = r;\n    }\n\n    public String toString()\n    {\n        return this.l+"" "";\n    }\n}\nclass Sortbyroll implements Comparator<Student>\n{\n\n    public int compare(Student a, Student b){\n        return a.l-b.l;  }\n}\nclass Sortbyroll1 implements Comparator<Student> {\n    public int compare(Student a, Student b){\n        if(a.r==b.r) return a.l-b.l;\n        return b.l-a.l;\n    }\n}","brute force,data structures,dp,greedy,math,sortings"
import java.util.Scanner;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n=sc.nextInt();\n    int sum=0;\n    for(int i=0; i<n; i++) {\n      int x1 = sc.nextInt();\n      int y1 = sc.nextInt();\n      int x2 = sc.nextInt();\n      int y2 = sc.nextInt();\n      sum+=(x2-x1+1)*(y2-y1+1);\n    }\n    System.out.println(sum);\n  }\n},"implementation,math"
import java.util.Scanner;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n=sc.nextInt();\n    int sum=0;\n    for(int i=0; i<n; i++) {\n      int x1 = sc.nextInt();\n      int y1 = sc.nextInt();\n      int x2 = sc.nextInt();\n      int y2 = sc.nextInt();\n      sum+=(x2-x1+1)*(y2-y1+1);\n    }\n    System.out.println(sum);\n  }\n},"implementation,math"
import java.util.Scanner;\n\npublic class _0746VanyaandTable {\n\n	public static void main(String[] args) {\n		\n		Scanner sc = new Scanner(System.in);\n		int n=sc.nextInt();\n		long ans=0;\n		for(int i=0;i<n;i++) {\n			int x1=sc.nextInt();\n			int y1=sc.nextInt();\n			int x2=sc.nextInt();\n			int y2=sc.nextInt();	\n		ans+=(Math.abs(x2-x1)+1)*(Math.abs(y2-y1)+1);\n		}\n		System.out.println(ans);\n		\n	}\n\n}\n,"implementation,math"
"import java.util.*;\npublic class rate{\n public static void main(String[] args) {\n 	Scanner sc = new Scanner(System.in);\n 	int n,a,b,c,d;\n 	n = sc.nextInt();\n 	int r = 0;\n 	while(n!=0){\n         a = sc.nextInt();\n         b = sc.nextInt();\n         c = sc.nextInt();\n         d = sc.nextInt();\n         a = Math.abs(a-c)+1;\n         b = Math.abs(b-d)+1;\n         r +=a*b;\n        n--;\n 	}\n\n	System.out.println(r);\n}\n}","implementation,math"
"import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashSet;\n\npublic class Main {\n	private final int SIZE_OF_BLOCK = 710;// 1ブロックのサイズ\n	private long[][] blocks;\n	private ArrayList<HashSet<Long>> containList;\n	private long[] add;\n	private int N;\n\n	public void solve() {\n		N = nextInt();\n		int Q = nextInt();\n		int[] array = new int[N];\n		for (int i = 0; i < N; i++) {\n			array[i] = nextInt();\n		}\n\n		int BLOCK_NUM = N / SIZE_OF_BLOCK + 1;\n		containList = new ArrayList<>();\n		for (int i = 0; i < BLOCK_NUM; i++) {\n			containList.add(new HashSet<Long>());\n		}\n\n		blocks = new long[BLOCK_NUM][SIZE_OF_BLOCK];\n		for (int i = 0; i < N; i++) {\n			int block = i / SIZE_OF_BLOCK;\n			int idx = i % SIZE_OF_BLOCK;\n			blocks[block][idx] = array[i];\n			containList.get(block).add(blocks[block][idx]);\n		}\n\n		add = new long[BLOCK_NUM];\n\n		StringBuilder ans = new StringBuilder();\n		for (int q = 0; q < Q; q++) {\n			int type = nextInt();\n			if (type == 1) {\n				// 加算クエリ\n				int from = nextInt() - 1;\n				int to = nextInt() - 1;\n				int addition = nextInt();\n\n				int fromBlock = from / SIZE_OF_BLOCK;\n				int toBlock = to / SIZE_OF_BLOCK;\n				if (fromBlock == toBlock) {\n					if (from % SIZE_OF_BLOCK == 0 && (to + 1) % SIZE_OF_BLOCK == 0) {\n						add[fromBlock] += addition;\n					} else {\n						add2Array(from, to, addition);\n					}\n					continue;\n				}\n\n				if (from % SIZE_OF_BLOCK != 0) {\n					add2Array(from, (fromBlock + 1) * SIZE_OF_BLOCK - 1, addition);\n					fromBlock++;\n				}\n				if ((to + 1) % SIZE_OF_BLOCK != 0) {\n					add2Array(toBlock * SIZE_OF_BLOCK, to, addition);\n					toBlock--;\n				}\n\n				for (int i = fromBlock; i <= toBlock; i++) {\n					add[i] += addition;\n				}\n			} else {\n				// 検索クエリ\n				int target = nextInt();\n				int first = -1;\n				searchFirst: for (int block = 0; block < BLOCK_NUM; block++) {\n					if (containList.get(block).contains(target - add[block])) {\n						for (int i = 0; i < SIZE_OF_BLOCK; i++) {\n							if (blocks[block][i] + add[block] == target) {\n								first = block * SIZE_OF_BLOCK + i;\n								break searchFirst;\n							}\n						}\n					}\n				}\n				if (first == -1) {\n					ans.append(-1 + ""\n"");\n					continue;\n				}\n\n				int last = first;\n				searchLast: for (int block = BLOCK_NUM - 1; block >= 0; block--) {\n					if (containList.get(block).contains(target - add[block])) {\n						for (int i = SIZE_OF_BLOCK - 1; i >= 0; i--) {\n							if (block * SIZE_OF_BLOCK + i >= N) {\n								continue;\n							}\n\n							if (blocks[block][i] + add[block] == target) {\n								last = block * SIZE_OF_BLOCK + i;\n								break searchLast;\n							}\n						}\n					}\n				}\n				ans.append((last - first) + ""\n"");\n			}\n		}\n		System.out.print(ans.toString());\n\n	}\n\n	private void add2Array(int from, int to, int addition) {\n		for (int i = from; i <= to; i++) {\n			int block = i / SIZE_OF_BLOCK;\n			int idx = i % SIZE_OF_BLOCK;\n			blocks[block][idx] += addition;\n		}\n\n		int block = to / SIZE_OF_BLOCK;\n		containList.get(block).clear();\n		for (int i = 0; i < SIZE_OF_BLOCK; i++) {\n			if (block * SIZE_OF_BLOCK + i >= N) {\n				break;\n			}\n			blocks[block][i] += add[block];\n			containList.get(block).add(blocks[block][i]);\n		}\n		add[block] = 0;\n	}\n\n	private int nextInt() {\n		int c;\n		try {\n			c = System.in.read();\n			while (c != '-' && (c < '0' || c > '9'))\n				c = System.in.read();\n			if (c == '-')\n				return -nextInt();\n			int res = 0;\n			while (c >= '0' && c <= '9') {\n				res = res * 10 + c - '0';\n				c = System.in.read();\n			}\n			return res;\n		} catch (IOException e) {\n			// TODO Auto-generated catch block\n			e.printStackTrace();\n		}\n		return -1;\n	}\n\n	public static void main(String[] args) {\n		new Main().solve();\n	}\n}","binary search,data structures,implementation"
"import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashSet;\n\npublic class Main {\n	private long[][] blocks;\n	private ArrayList<HashSet<Long>> containList;\n	private long[] add;\n	private int N, SIZE_OF_BLOCK;\n\n	public void solve() {\n		N = nextInt();\n		SIZE_OF_BLOCK = (int) Math.sqrt(N);// 1ブロックのサイズ\n		int Q = nextInt();\n		int[] array = new int[N];\n		for (int i = 0; i < N; i++) {\n			array[i] = nextInt();\n		}\n\n		int BLOCK_NUM = N / SIZE_OF_BLOCK + 1;\n		containList = new ArrayList<>();\n		for (int i = 0; i < BLOCK_NUM; i++) {\n			containList.add(new HashSet<Long>());\n		}\n\n		blocks = new long[BLOCK_NUM][SIZE_OF_BLOCK];\n		for (int i = 0; i < N; i++) {\n			int block = i / SIZE_OF_BLOCK;\n			int idx = i % SIZE_OF_BLOCK;\n			blocks[block][idx] = array[i];\n			containList.get(block).add(blocks[block][idx]);\n		}\n\n		add = new long[BLOCK_NUM];\n\n		StringBuilder ans = new StringBuilder();\n		for (int q = 0; q < Q; q++) {\n			int type = nextInt();\n			if (type == 1) {\n				// 加算クエリ\n				int from = nextInt() - 1;\n				int to = nextInt() - 1;\n				int addition = nextInt();\n\n				int fromBlock = from / SIZE_OF_BLOCK;\n				int toBlock = to / SIZE_OF_BLOCK;\n				if (fromBlock == toBlock) {\n					if (from % SIZE_OF_BLOCK == 0 && (to + 1) % SIZE_OF_BLOCK == 0) {\n						add[fromBlock] += addition;\n					} else {\n						add2Array(from, to, addition);\n					}\n					continue;\n				}\n\n				if (from % SIZE_OF_BLOCK != 0) {\n					add2Array(from, (fromBlock + 1) * SIZE_OF_BLOCK - 1, addition);\n					fromBlock++;\n				}\n				if ((to + 1) % SIZE_OF_BLOCK != 0) {\n					add2Array(toBlock * SIZE_OF_BLOCK, to, addition);\n					toBlock--;\n				}\n\n				for (int i = fromBlock; i <= toBlock; i++) {\n					add[i] += addition;\n				}\n			} else {\n				// 検索クエリ\n				int target = nextInt();\n				int first = -1;\n				searchFirst: for (int block = 0; block < BLOCK_NUM; block++) {\n					if (containList.get(block).contains(target - add[block])) {\n						for (int i = 0; i < SIZE_OF_BLOCK; i++) {\n							if (blocks[block][i] + add[block] == target) {\n								first = block * SIZE_OF_BLOCK + i;\n								break searchFirst;\n							}\n						}\n					}\n				}\n				if (first == -1) {\n					ans.append(-1 + ""\n"");\n					continue;\n				}\n\n				int last = first;\n				searchLast: for (int block = BLOCK_NUM - 1; block >= 0; block--) {\n					if (containList.get(block).contains(target - add[block])) {\n						for (int i = SIZE_OF_BLOCK - 1; i >= 0; i--) {\n							if (block * SIZE_OF_BLOCK + i >= N) {\n								continue;\n							}\n\n							if (blocks[block][i] + add[block] == target) {\n								last = block * SIZE_OF_BLOCK + i;\n								break searchLast;\n							}\n						}\n					}\n				}\n				ans.append((last - first) + ""\n"");\n			}\n		}\n		System.out.print(ans.toString());\n\n	}\n\n	private void add2Array(int from, int to, int addition) {\n		for (int i = from; i <= to; i++) {\n			int block = i / SIZE_OF_BLOCK;\n			int idx = i % SIZE_OF_BLOCK;\n			blocks[block][idx] += addition;\n		}\n\n		int block = to / SIZE_OF_BLOCK;\n		containList.get(block).clear();\n		for (int i = 0; i < SIZE_OF_BLOCK; i++) {\n			if (block * SIZE_OF_BLOCK + i >= N) {\n				break;\n			}\n			blocks[block][i] += add[block];\n			containList.get(block).add(blocks[block][i]);\n		}\n		add[block] = 0;\n	}\n\n	private int nextInt() {\n		int c;\n		try {\n			c = System.in.read();\n			while (c != '-' && (c < '0' || c > '9'))\n				c = System.in.read();\n			if (c == '-')\n				return -nextInt();\n			int res = 0;\n			while (c >= '0' && c <= '9') {\n				res = res * 10 + c - '0';\n				c = System.in.read();\n			}\n			return res;\n		} catch (IOException e) {\n			// TODO Auto-generated catch block\n			e.printStackTrace();\n		}\n		return -1;\n	}\n\n	public static void main(String[] args) {\n		new Main().solve();\n	}\n}","binary search,data structures,implementation"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class C {\n\n\n	static int N, Q, L, B;\n	static Point[][] arr;\n	static long[] add;\n\n	static void update(int l, int r, long val) {\n		int bL = l / L;\n		int bR = r / L;\n\n		if(bL == bR)\n			updateBlock(l, r, bL, val);\n		else {\n			updateBlock(l, r, bL, val);\n			updateBlock(l, r, bR, val);\n\n			for (int i = bL + 1; i < bR; i++)\n				add[i] += val;\n		}\n	}\n\n	static void updateBlock(int l, int r, int idx, long val) {\n		ArrayList<Point> a1 = new ArrayList<>();\n		ArrayList<Point> a2 = new ArrayList<>();\n		for (int i = 0; i < L; i++) {\n			if(arr[idx][i].idx >= l && arr[idx][i].idx <= r) {\n				arr[idx][i].v += val;\n				a1.add(arr[idx][i]);\n			}else\n				a2.add(arr[idx][i]);\n		}\n\n		Point[] newB = new Point[L];\n		int p1 = 0;\n		int p2 = 0;\n		int p = 0;\n		for (int i = 0; i < L; i++) \n			if(p1 < a1.size() && (p2 >= a2.size() || a1.get(p1).compareTo(a2.get(p2)) < 0))\n				newB[p++] = a1.get(p1++);\n			else\n				newB[p++] = a2.get(p2++);\n\n		arr[idx] = newB;\n	}\n\n	static int first(long val) {\n		int ans = -1;\n		for (int i = 0; i < B; ++i) {\n			int l = 0;\n			int h = L - 1;\n			if(i == B - 1)\n				h = (N - 1) % L;\n			while(l <= h) {\n				int mid = ((l + h) >> 1);\n				if(arr[i][mid].v + add[i] == val) {\n					ans = arr[i][mid].idx;\n					h = mid - 1;\n				}else if(arr[i][mid].v + add[i] > val)\n					h = mid - 1;\n				else\n					l = mid + 1;\n			}\n\n			if(ans != -1)\n				return ans;\n		}\n\n		return ans;\n	}\n\n	static int last(long val) {\n		int ans = -1;\n		for (int i = B - 1; i >= 0; --i) {\n			int l = 0;\n			int h = L - 1;\n			if(i == B - 1)\n				h = (N - 1) % L;\n			while(l <= h) {\n				int mid = ((l + h) >> 1);\n\n				if(arr[i][mid].v + add[i] == val) {\n					ans = arr[i][mid].idx;\n					l = mid + 1;\n				}else if(arr[i][mid].v + add[i] > val)\n					h = mid - 1;\n				else\n					l = mid + 1;\n			}\n\n			if(ans != -1)\n				return ans;\n		}\n\n		return ans;\n	}\n\n	public static void main(String[] args) throws IOException {\n		Scanner sc = new Scanner(System.in);\n		PrintWriter out = new PrintWriter(System.out);\n\n		N = sc.nextInt();\n		Q = sc.nextInt();\n\n		L = 1000;\n\n		B = (N + 999) / L;\n\n		arr = new Point[B][L];\n		add = new long[B];\n		for (int i = 0; i < N; i++) \n			arr[i / L][i % L] = new Point(sc.nextLong(), i);\n\n		for (int i = N; i < L * B; i++) \n			arr[i / L][i % L] = new Point(Long.MAX_VALUE, i);\n\n		for (int i = 0; i < B; i++) \n			Arrays.sort(arr[i]);\n		\n\n\n		for (int i = 0; i < Q; i++) {\n			int t = sc.nextInt();\n			if(t == 1) {\n				int l = sc.nextInt() - 1;\n				int r = sc.nextInt() - 1;\n				long x = sc.nextLong();\n\n				update(l, r, x);\n			} else {\n				long y = sc.nextLong();\n				int f = first(y);\n				if(f == -1)\n					out.println(-1);\n				else\n					out.println(last(y) - f);\n			}\n			\n		}\n\n		out.flush();\n	}\n\n\n	static class Point implements Comparable<Point> {\n		long v;\n		int idx;\n\n		Point(long v, int idx) {\n			this.v = v;\n			this.idx = idx;\n		}\n\n		@Override\n		public int compareTo(Point o) {\n			if(this.v == o.v)\n				return idx - o.idx;\n			\n			if(v > o.v)\n				return 1;\n			return -1;\n		}\n	}\n\n\n\n	static class Scanner {\n		StringTokenizer st;\n		BufferedReader br;\n\n		public Scanner(InputStream s) {\n			br = new BufferedReader(new InputStreamReader(s));\n		}\n\n		public String next() throws IOException {\n			while(st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n\n		public int nextInt() throws NumberFormatException, IOException {\n			return Integer.parseInt(next());\n		}\n\n		public long nextLong() throws NumberFormatException, IOException {\n			return Long.parseLong(next());\n		}\n	}	\n\n}","binary search,data structures,implementation"
"import java.util.Arrays;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Agostinho Junior (junior94)\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		InputReader in = new InputReader(inputStream);\n		OutputWriter out = new OutputWriter(outputStream);\n		TaskE solver = new TaskE();\n		solver.solve(1, in, out);\n		out.close();\n	}\n}\n\nclass TaskE {\n\n	static class Data implements Comparable<Data> {\n		int idx;\n		long value;\n\n		public Data(int idx, int value) {\n			this.idx = idx;\n			this.value = value;\n		}\n\n		public int compareTo(Data other) {\n			return Long.compare(value, other.value);\n		}\n	}\n\n	public void solve(int testNumber, InputReader in, OutputWriter out) {\n		int N = in.readInt();\n		int Q = in.readInt();\n\n		Data[] data = new Data[N];\n		for (int i = 0; i < N; i++) {\n			data[i] = new Data(i, in.readInt());\n		}\n\n		final int blockSize = (int)Math.sqrt(N);\n\n		int[] block = new int[N];\n		int count = 1;\n		for (int i = 1; i < N; i++) {\n			block[i] = block[i - 1];\n			if (count == blockSize) {\n				block[i]++;\n				count = 0;\n			}\n			count++;\n		}\n\n		long[] added = new long[block[N - 1] + 1];\n\n		for (int i = 0; i < N; i += blockSize) {\n			int end = Math.min(N, i + blockSize);\n			Arrays.sort(data, i, end);\n		}\n\n\n		while (Q-- > 0) {\n			int t = in.readInt();\n\n			if (t == 1) {\n				int L = in.readInt() - 1;\n				int R = in.readInt() - 1;\n				long X = in.readInt();\n\n				int firstIn = block[L];\n				if (L > 0 && firstIn == block[L - 1]) {\n					firstIn++;\n				}\n\n				int lastIn = block[R];\n				if (R < N - 1 && lastIn == block[R + 1]) {\n					lastIn--;\n				}\n\n				int end = Math.min(N - 1, blockSize * (block[R] + 1) - 1);\n\n				for (int i = block[L] * blockSize; i <= end; ) {\n					if (firstIn <= block[i] && block[i] <= lastIn) {\n						added[block[i]] += X;\n						i += blockSize;\n					} else {\n						if (L <= data[i].idx && data[i].idx <= R) {\n							data[i].value += X;\n						}\n						if (i == N - 1 || block[i] < block[i + 1]) {\n							int start = block[i] * blockSize;\n							Arrays.sort(data, start, i + 1);\n						}\n						i++;\n					}\n				}\n\n			} else {\n				int X = in.readInt();\n				int first = -1;\n				int last = -1;\n\n				for (int i = 0; i < N; i += blockSize) {\n					int low = i;\n					int high = Math.min(N - 1, i + blockSize - 1);\n					while (low <= high) {\n						int mid = low + high >> 1;\n						long value = data[mid].value + added[block[i]];\n						if (value == X) {\n							if (first == -1) {\n								first = block[i];\n							}\n							last = block[i];\n							break;\n						}\n						if (value < X) {\n							low = mid + 1;\n						} else {\n							high = mid - 1;\n						}\n					}\n				}\n\n				if (first == -1) {\n					out.println(-1);\n				} else {\n					int[] temp = {first, last};\n					first = N - 1;\n					last = 0;\n					for (int b: temp) {\n						int start = b * blockSize;\n						int end = Math.min(N - 1, start + blockSize - 1);\n						for (int i = start; i <= end; i++) {\n							if (data[i].value + added[block[i]] == X) {\n								first = Math.min(first, data[i].idx);\n								last = Math.max(last, data[i].idx);\n							}\n						}\n					}\n					out.println(last - first);\n				}\n\n			}\n		}\n\n	}\n\n\n}\n\nclass InputReader {\n	private BufferedReader input;\n	private StringTokenizer line = new StringTokenizer("""");\n\n	public InputReader(InputStream in) {input = new BufferedReader(new InputStreamReader(in));\n	}\n\n	public void fill() {\n		try {\n			if(!line.hasMoreTokens()) line = new StringTokenizer(input.readLine());\n		} catch(IOException io) { io.printStackTrace(); System.exit(0);}\n	}\n\n	public int readInt() {\n		fill();\n		return Integer.parseInt(line.nextToken());\n	}\n\n}\n\nclass OutputWriter {\n	private PrintWriter output;\n\n	public OutputWriter(OutputStream out) {\n		output = new PrintWriter(out);\n	}\n\n	public void println(Object o) {\n		output.println(o);\n	}\n\n	public void close() {\n		output.close();\n	}\n}\n\n","binary search,data structures,implementation"
"import java.io.*;\nimport java.util.*;\n\npublic class summerdichotomy {\n  private static InputReader in;\n  private static PrintWriter out;\n  public static int t, T, N, M;\n  public static ArrayList<Integer>[] graph;\n  \n  public static boolean[] vis;\n  public static int[] color;\n  public static Interval[] tt;\n  \n  public static void dfs (int node, int c) {\n    if (vis[node]) {\n      if (c != color[node]) {\n        out.println(""IMPOSSIBLE"");\n        out.close();\n        System.exit(0);\n      }\n      return;\n    }\n    vis[node] = true;\n    color[node] = c;\n    for (int x : graph[node]) dfs(x, 1 - c);\n  }\n  \n  static class Interval {\n    public int low, high;\n    public Interval(int low, int high) {\n      this.low = low;\n      this.high = high;\n    }\n    \n    public boolean intersect(int x) {\n      return x >= low && x <= high;\n    }\n  }\n\n  public static void main(String[] args) throws IOException {\n    in = new InputReader(System.in);\n    out = new PrintWriter(System.out, true);\n    t = in.nextInt();\n    T = in.nextInt();\n    N = in.nextInt();\n    M = in.nextInt();\n    tt = new Interval[N];\n    graph = new ArrayList[N];\n    int mx = 0, mn = 1 << 29;\n    for (int i = 0; i < N; i++) {\n      tt[i] = new Interval(in.nextInt(), in.nextInt());\n      mx = Math.max(mx, tt[i].low);\n      mn = Math.min(mn, tt[i].high);\n      graph[i] = new ArrayList<>();\n    }\n    for (int i = 0; i < M; i++) {\n      int a = in.nextInt()-1, b = in.nextInt()-1;\n      graph[a].add(b);\n      graph[b].add(a);\n    }\n    \n    if (mx + mn < t) {\n      mx = t - mn;\n    } else if (mx + mn > T) {\n      mn = T - mx;\n    }\n    \n    if (mx < 0 || mn < 0) {\n      out.println(""IMPOSSIBLE"");\n      out.close();\n      System.exit(0);\n    }\n    \n    vis = new boolean[N];\n    color = new int[N];\n    for (int i = 0; i < N; i++) {\n      if (!tt[i].intersect(mn) && !tt[i].intersect(mx)) {\n        out.println(""IMPOSSIBLE"");\n        out.close();\n        System.exit(0);\n      }\n      \n      if (!tt[i].intersect(mn)) dfs(i, 1);\n      if (!tt[i].intersect(mx)) dfs(i, 0);\n    }\n    for (int i = 0; i < N; i++) {\n      if (!vis[i])\n        dfs(i, 0);\n    }\n    \n    out.println(""POSSIBLE"");\n    out.println(mn+"" ""+mx);\n    for (int i = 0; i < N; i++) {\n      out.print((color[i]+1));\n    }\n    out.println();\n    out.close();\n    System.exit(0);\n  }\n\n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream), 32768);\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n  }\n\n\n}\n","2-sat,data structures,dfs and similar,greedy"
"import java.io.*;\nimport java.util.*;\n\npublic class summerdichotomy {\n  private static InputReader in;\n  private static PrintWriter out;\n  public static int trials = 11;\n  public static int t, T, N, M;\n  public static ArrayList<Integer>[] graph;\n  \n  public static boolean[] vis;\n  public static int[] color;\n  public static Interval[] tt;\n  \n  public static boolean dfs (int node, int c) {\n    if (vis[node]) return c == color[node];\n    vis[node] = true;\n    color[node] = c;\n    for (int x : graph[node]) {\n      if (!dfs(x, 1 - c))\n        return false;\n    }\n    return true;\n  }\n  \n  static class Interval {\n    public int low, high;\n    public Interval(int low, int high) {\n      this.low = low;\n      this.high = high;\n    }\n    \n    public boolean intersect(int x) {\n      return x >= low && x <= high;\n    }\n    \n    public String toString() {\n      return low+"" ""+high;\n    }\n  }\n\n  public static void main(String[] args) throws IOException {\n    in = new InputReader(System.in);\n    out = new PrintWriter(System.out, true);\n    t = in.nextInt();\n    T = in.nextInt();\n    N = in.nextInt();\n    M = in.nextInt();\n    tt = new Interval[N];\n    graph = new ArrayList[N];\n    int mx = 0, mn = 1 << 29;\n    for (int i = 0; i < N; i++) {\n      tt[i] = new Interval(in.nextInt(), in.nextInt());\n      mx = Math.max(mx, tt[i].low);\n      mn = Math.min(mn, tt[i].high);\n      graph[i] = new ArrayList<>();\n    }\n    for (int i = 0; i < M; i++) {\n      int a = in.nextInt()-1, b = in.nextInt()-1;\n      graph[a].add(b);\n      graph[b].add(a);\n    }\n    if (mx + mn < t) {\n      mx = t - mn;\n    } else if (mx + mn > T) {\n      mn = T - mx;\n    }\n    \n    if (mx < 0 || mn < 0) {\n      out.println(""IMPOSSIBLE"");\n      out.close();\n      System.exit(0);\n    }\n    \n    vis = new boolean[N];\n    color = new int[N];\n    for (int i = 0; i < N; i++) {\n      if (!tt[i].intersect(mn) && !tt[i].intersect(mx)) {\n        out.println(""IMPOSSIBLE"");\n        out.close();\n        System.exit(0);\n      }\n      \n      if (!tt[i].intersect(mn)) {\n        if (!dfs(i, 1)) {\n          out.println(""IMPOSSIBLE"");\n          out.close();\n          System.exit(0);\n        }\n      }\n      if (!tt[i].intersect(mx)) {\n        if (!dfs(i, 0)) {\n          out.println(""IMPOSSIBLE"");\n          out.close();\n          System.exit(0);\n        }\n      }\n    }\n    for (int i = 0; i < N; i++) {\n      if (!vis[i]) {\n        if (!dfs(i, 0)) {\n          out.println(""IMPOSSIBLE"");\n          out.close();\n          System.exit(0);\n        }\n      }\n    }\n    \n    out.println(""POSSIBLE"");\n    out.println(mn+"" ""+mx);\n    for (int i = 0; i < N; i++) {\n      out.print((color[i]+1));\n    }\n    out.println();\n    out.close();\n    System.exit(0);\n  }\n\n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream), 32768);\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n  }\n\n\n}","2-sat,data structures,dfs and similar,greedy"
"import java.io.*;\nimport java.util.*;\n\npublic class summerdichotomy {\n  private static InputReader in;\n  private static PrintWriter out;\n  public static int trials = 11;\n  public static int t, T, N, M;\n  public static ArrayList<Integer>[] graph;\n  \n  public static boolean[] vis;\n  public static int[] color;\n  public static Interval[] tt;\n  \n  public static boolean dfs (int node, int c) {\n    if (vis[node]) return c == color[node];\n    vis[node] = true;\n    color[node] = c;\n    for (int x : graph[node]) {\n      if (!dfs(x, 1 - c))\n        return false;\n    }\n    return true;\n  }\n  \n  static class Interval {\n    public int low, high;\n    public Interval(int low, int high) {\n      this.low = low;\n      this.high = high;\n    }\n    \n    public boolean intersect(int x) {\n      return x >= low && x <= high;\n    }\n    \n    public String toString() {\n      return low+"" ""+high;\n    }\n  }\n\n  public static void main(String[] args) throws IOException {\n    in = new InputReader(System.in);\n    out = new PrintWriter(System.out, true);\n    t = in.nextInt();\n    T = in.nextInt();\n    N = in.nextInt();\n    M = in.nextInt();\n    tt = new Interval[N];\n    graph = new ArrayList[N];\n    int mx = 0, mn = 1 << 29;\n    for (int i = 0; i < N; i++) {\n      tt[i] = new Interval(in.nextInt(), in.nextInt());\n      mx = Math.max(mx, tt[i].low);\n      mn = Math.min(mn, tt[i].high);\n      graph[i] = new ArrayList<>();\n    }\n    for (int i = 0; i < M; i++) {\n      int a = in.nextInt()-1, b = in.nextInt()-1;\n      graph[a].add(b);\n      graph[b].add(a);\n    }\n    if (mx + mn < t) {\n      mx = t - mn;\n    } else if (mx + mn > T) {\n      mn = T - mx;\n    }\n    \n    if (mx < 0 || mn < 0) {\n      out.println(""IMPOSSIBLE"");\n      out.close();\n      System.exit(0);\n    }\n    \n    vis = new boolean[N];\n    color = new int[N];\n    for (int i = 0; i < N; i++) {\n      if (!tt[i].intersect(mn) && !tt[i].intersect(mx)) {\n        out.println(""IMPOSSIBLE"");\n        out.close();\n        System.exit(0);\n      }\n      \n      if (!tt[i].intersect(mn)) {\n        if (!dfs(i, 1)) {\n          out.println(""IMPOSSIBLE"");\n          out.close();\n          System.exit(0);\n        }\n      }\n      if (!tt[i].intersect(mx)) {\n        if (!dfs(i, 0)) {\n          out.println(""IMPOSSIBLE"");\n          out.close();\n          System.exit(0);\n        }\n      }\n    }\n    for (int i = 0; i < N; i++) {\n      if (!vis[i]) {\n        if (!dfs(i, 0)) {\n          out.println(""IMPOSSIBLE"");\n          out.close();\n          System.exit(0);\n        }\n      }\n    }\n    \n    out.println(""POSSIBLE"");\n    out.println(mn+"" ""+mx);\n    for (int i = 0; i < N; i++) {\n      out.print((color[i]+1));\n    }\n    out.println();\n    out.close();\n    System.exit(0);\n  }\n\n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream), 32768);\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n  }\n\n\n}\n","2-sat,data structures,dfs and similar,greedy"
"import java.util.TreeMap;\nimport java.util.ArrayList;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.List;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		InputReader in = new InputReader(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		TaskH solver = new TaskH();\n		solver.solve(1, in, out);\n		out.close();\n	}\n}\n\nclass TaskH {\n    static class Teacher {\n        int l;\n        int r;\n        List<Teacher> conflicts = new ArrayList<>(1);\n        int kind;\n        int res;\n\n        public boolean buildComponent(Component c, int k) {\n            if (kind != 0) {\n                return kind == k;\n            }\n            kind = k;\n            if (k == 1) {\n                c.l1 = Math.max(c.l1, l);\n                c.r1 = Math.min(c.r1, r);\n            } else {\n                c.l2 = Math.max(c.l2, l);\n                c.r2 = Math.min(c.r2, r);\n            }\n            for (Teacher t : conflicts) {\n                if (!t.buildComponent(c, 3 - k)) return false;\n            }\n            return true;\n        }\n\n        public void markAs(int as) {\n            if (res != 0) {\n                if (res != as) throw new RuntimeException();\n                return;\n            }\n            res = as;\n            for (Teacher t : conflicts) {\n                t.markAs(3 - as);\n            }\n        }\n    }\n\n    static class Component {\n        Teacher root;\n        int l1;\n        int r1;\n        int l2;\n        int r2;\n        int insideMask;\n\n        public void markAs(int as) {\n            root.markAs(as);\n        }\n    }\n\n    static class Event {\n        int when;\n        Component which;\n        int compIndex;\n\n        public Event(int when, Component which, int compIndex) {\n            this.when = when;\n            this.which = which;\n            this.compIndex = compIndex;\n        }\n    }\n\n    static class SetTrackerWithMax {\n        TreeMap<Integer, Integer> counts = new TreeMap<>();\n\n        public void add(int x) {\n            Integer old = counts.get(x);\n            if (old == null)\n                counts.put(x, 1);\n            else\n                counts.put(x, old + 1);\n        }\n\n        public void remove(int x) {\n            int v = counts.get(x);\n            if (v == 1)\n                counts.remove(x);\n            else\n                counts.put(x, v - 1);\n        }\n\n        int getMax() {\n            return counts.lastKey();\n        }\n    }\n\n    static class Magic {\n        int numImpossible;\n        SetTrackerWithMax lefts = new SetTrackerWithMax();\n        SetTrackerWithMax negativeRights = new SetTrackerWithMax();\n\n        public Magic(int totalComponents) {\n            numImpossible = totalComponents;\n        }\n\n        private void addSegment(int left, int right) {\n            lefts.add(left);\n            negativeRights.add(-right);\n        }\n\n        private void removeSegment(int left, int right) {\n            lefts.remove(left);\n            negativeRights.remove(-right);\n        }\n\n        public void addComponent(Component comp) {\n            if (comp.insideMask == 0) {\n                ++numImpossible;\n            } else if (comp.insideMask == 6) {\n                if (comp.r1 > comp.r2) {\n                    addSegment(comp.l1, comp.r1);\n                } else {\n                    addSegment(comp.l2, comp.r2);\n                }\n            } else if (comp.insideMask == 2) {\n                addSegment(comp.l2, comp.r2);\n            } else if (comp.insideMask == 4) {\n                addSegment(comp.l1, comp.r1);\n            } else {\n                throw new RuntimeException();\n            }\n        }\n\n        public void removeComponent(Component comp) {\n            if (comp.insideMask == 0) {\n                --numImpossible;\n            } else if (comp.insideMask == 6) {\n                if (comp.r1 > comp.r2) {\n                    removeSegment(comp.l1, comp.r1);\n                } else {\n                    removeSegment(comp.l2, comp.r2);\n                }\n            } else if (comp.insideMask == 2) {\n                removeSegment(comp.l2, comp.r2);\n            } else if (comp.insideMask == 4) {\n                removeSegment(comp.l1, comp.r1);\n            } else {\n                throw new RuntimeException();\n            }\n        }\n\n        public void markComponent(Component comp) {\n            if (comp.insideMask == 0) {\n                throw new RuntimeException();\n            } else if (comp.insideMask == 6) {\n                if (comp.r1 > comp.r2) {\n                    comp.markAs(2);\n                } else {\n                    comp.markAs(1);\n                }\n            } else if (comp.insideMask == 2) {\n                comp.markAs(1);\n            } else if (comp.insideMask == 4) {\n                comp.markAs(2);\n            } else {\n                throw new RuntimeException();\n            }\n        }\n    }\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int t = in.nextInt();\n        int T = in.nextInt();\n        int n = in.nextInt();\n        int m = in.nextInt();\n        Teacher[] teachers = new Teacher[n];\n        for (int i = 0; i < n; ++i) {\n            teachers[i] = new Teacher();\n            teachers[i].l = in.nextInt();\n            teachers[i].r = in.nextInt();\n        }\n        for (int i = 0; i < m; ++i) {\n            Teacher a = teachers[in.nextInt() - 1];\n            Teacher b = teachers[in.nextInt() - 1];\n            a.conflicts.add(b);\n            b.conflicts.add(a);\n        }\n\n        List<Component> components = new ArrayList<>(teachers.length);\n        for (Teacher teacher : teachers) if (teacher.kind == 0) {\n            Component c = new Component();\n            c.l1 = 0;\n            c.r1 = T;\n            c.l2 = 0;\n            c.r2 = T;\n            c.root = teacher;\n            if (!teacher.buildComponent(c, 1)) {\n                out.println(""IMPOSSIBLE"");\n                return;\n            }\n            if (c.l1 > c.r1 || c.l2 > c.r2) {\n                out.println(""IMPOSSIBLE"");\n                return;\n            }\n            components.add(c);\n        }\n\n        List<Event> events = new ArrayList<>(4 * components.size());\n        for (Component c : components) {\n            events.add(new Event(c.l1, c, 1));\n            events.add(new Event(c.r1 + 1, c, 1));\n            events.add(new Event(c.l2, c, 2));\n            events.add(new Event(c.r2 + 1, c, 2));\n        }\n        Collections.sort(events, new Comparator<Event>() {\n            public int compare(Event o1, Event o2) {\n                return o1.when - o2.when;\n            }\n        });\n\n        Magic magic = new Magic(components.size());\n\n        int ptr = 0;\n        while (ptr < events.size()) {\n            int count = events.get(ptr).when;\n            while (ptr < events.size() && events.get(ptr).when == count) {\n                Event cur = events.get(ptr++);\n                magic.removeComponent(cur.which);\n                cur.which.insideMask ^= (1 << cur.compIndex);\n                magic.addComponent(cur.which);\n            }\n\n            if (magic.numImpossible == 0) {\n                int nextAt = events.get(ptr).when;\n                int oleft = magic.lefts.getMax();\n                int oright = -magic.negativeRights.getMax();\n                if (oleft <= oright) {\n                    if (count + oleft <= T && nextAt - 1 + oright >= t) {\n                        out.println(""POSSIBLE"");\n                        int n1 = count;\n                        int n2 = oleft;\n                        if (n1 + n2 < t) {\n                            int extra = t - n1 - n2;\n                            int by = Math.min(extra, nextAt - 1 - count);\n                            extra -= by;\n                            n1 += by;\n                            by = Math.min(extra, oright - oleft);\n                            extra -= by;\n                            n2 += by;\n                            if (extra != 0) throw new RuntimeException();\n                        }\n                        if (n1 + n2 < t || n1 + n2 > T) throw new RuntimeException();\n                        out.println(n1 + "" "" + n2);\n                        for (Component c : components) {\n                            magic.markComponent(c);\n                        }\n                        for (Teacher teacher : teachers) {\n                            out.print(teacher.res);\n                        }\n                        out.println();\n                        return;\n                    }\n                }\n            }\n        }\n        out.println(""IMPOSSIBLE"");\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n}\n\n","2-sat,data structures,dfs and similar,greedy"
"import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Div1_296E {\n\n	public static void main(String[] args) throws IOException {\n		new Div1_296E().execute();\n	}\n\n	void execute() throws IOException {\n		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		int nL = Integer.parseInt(reader.readLine());\n		Line[] lines = new Line[nL];\n		for (int i = 0; i < nL; i++) {\n			StringTokenizer inputData = new StringTokenizer(reader.readLine());\n			lines[i] = new Line(Integer.parseInt(inputData.nextToken()), Integer.parseInt(inputData.nextToken()),\n					Integer.parseInt(inputData.nextToken()));\n		}\n\n		Arrays.sort(lines);\n\n		double res = 0;\n		for (int bI = 0; bI < nL; bI++) {\n			Vector pSum = new Vector(0, 0);\n			for (int dI = 1; dI < nL; dI++) {\n				Vector cInter = inter(lines[bI], lines[(bI + dI) % nL]);\n				res += crossMag(pSum, cInter);\n				pSum.pE(cInter);\n			}\n		}\n		res *= 3.0 / ((long) nL * (nL - 1) * (nL - 2));\n		printer.println(res);\n		printer.close();\n	}\n\n	class Line implements Comparable<Line> {\n		double A;\n		double B;\n		double C;\n		double ang;\n\n		Line(int A, int B, int C) {\n			if (A < 0) {\n				A = -A;\n				B = -B;\n				C = -C;\n			}\n			this.A = A;\n			this.B = B;\n			this.C = C;\n			ang = Math.atan2(-B, A);\n		}\n\n		public int compareTo(Line o) {\n			return -Double.compare(ang, o.ang);\n		}\n	}\n\n	// Cramer's rule\n	Vector inter(Line l1, Line l2) {\n		double det = l1.A * l2.B - l1.B * l2.A;\n		return new Vector((l1.C * l2.B - l1.B * l2.C) / det, (l1.A * l2.C - l1.C * l2.A) / det);\n	}\n\n	double crossMag(Vector v1, Vector v2) {\n		return v1.x * v2.y - v1.y * v2.x;\n	}\n\n	class Vector {\n		double x;\n		double y;\n\n		Vector(double x, double y) {\n			this.x = x;\n			this.y = y;\n		}\n\n		void pE(Vector addend) {\n			x += addend.x;\n			y += addend.y;\n		}\n	}\n}\n","geometry,sortings"
"import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Los {\n\n	public static void main(String[] args) throws IOException {\n		new Los().execute();\n	}\n\n	void execute() throws IOException {\n		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n		PrintWriter printer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n		int nL = Integer.parseInt(reader.readLine());\n		Line[] lines = new Line[nL];\n		for (int i = 0; i < nL; i++) {\n			StringTokenizer inputData = new StringTokenizer(reader.readLine());\n			lines[i] = new Line(Integer.parseInt(inputData.nextToken()), Integer.parseInt(inputData.nextToken()),\n					Integer.parseInt(inputData.nextToken()));\n		}\n\n		Arrays.sort(lines);\n\n		double res = 0;\n		for (int bI = 0; bI < nL; bI++) {\n			Vector pSum = new Vector(0, 0);\n			for (int dI = 1; dI < nL; dI++) {\n				Vector cInter = inter(lines[bI], lines[(bI + dI) % nL]);\n				res += crossMag(pSum, cInter);\n				pSum.pE(cInter);\n			}\n		}\n		res *= 3.0 / ((long) nL * (nL - 1) * (nL - 2));\n		printer.println(res);\n		printer.close();\n	}\n\n	class Line implements Comparable<Line> {\n		double A;\n		double B;\n		double C;\n		double ang;\n\n		Line(int A, int B, int C) {\n			if (A < 0) {\n				A = -A;\n				B = -B;\n				C = -C;\n			}\n			this.A = A;\n			this.B = B;\n			this.C = C;\n			ang = Math.atan2(-B, A);\n		}\n\n		public int compareTo(Line o) {\n			return -Double.compare(ang, o.ang);\n		}\n	}\n\n	// Cramer's rule\n	Vector inter(Line l1, Line l2) {\n		double det = l1.A * l2.B - l1.B * l2.A;\n		return new Vector((l1.C * l2.B - l1.B * l2.C) / det, (l1.A * l2.C - l1.C * l2.A) / det);\n	}\n\n	double crossMag(Vector v1, Vector v2) {\n		return v1.x * v2.y - v1.y * v2.x;\n	}\n\n	class Vector {\n		double x;\n		double y;\n\n		Vector(double x, double y) {\n			this.x = x;\n			this.y = y;\n		}\n\n		void pE(Vector addend) {\n			x += addend.x;\n			y += addend.y;\n		}\n	}\n}","geometry,sortings"
"import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		FastScanner in = new FastScanner(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		TaskE solver = new TaskE();\n		solver.solve(1, in, out);\n		out.close();\n	}\n}\n\nclass TaskE {\n	public void solve(int testNumber, FastScanner in, PrintWriter out) {\n		int n = in.nextInt();\n		Line[] lines = new Line[n];\n		for (int i = 0; i < n; i++) {\n			int a = in.nextInt();\n			int b = in.nextInt();\n			int c = in.nextInt();\n			lines[i] = new Line(a, b, c);\n		}\n		Arrays.sort(lines, new Comparator<Line>() {\n			public int compare(Line l1, Line l2) {\n				boolean u1 = l1.b > 0 || l1.b == 0 && l1.a > 0;\n				boolean u2 = l2.b > 0 || l2.b == 0 && l2.a > 0;\n				if (u1 != u2) {\n					return u1 ? 1 : -1;\n				}\n				double cr = l1.a*l2.b - l2.a*l1.b;\n				return -Double.compare(cr, 0);\n			}\n		});\n		double ans = 0;\n		for (int i = 0; i < n; i++) {\n			Point sum = new Point(0, 0);\n			for (int step = 1; step < n; step++) {\n				int j = (i + step) % n;\n				Point p = intersect(lines[i], lines[j]);\n				ans += sum.x * p.y - p.x * sum.y;\n				sum.x += p.x;\n				sum.y += p.y;\n			}\n		}\n		double total = (double) n * (n - 1) * (n - 2) / 6.0;\n		ans /= total;\n		ans /= 2;\n		out.printf(""%.10f\n"", ans);\n	}\n\n	final double eps = 1e-8;\n\n	private Point intersect(Line l1, Line l2) {\n		double det = l1.a*l2.b - l1.b*l2.a;\n		if (Math.abs(det) < eps) {\n			return null;\n		}\n		double x = (l1.c*l2.b - l1.b*l2.c) / det;\n		double y = (l1.a*l2.c - l1.c*l2.a) / det;\n		return new Point(x, y);\n	}\n\n	class Point {\n		double x, y;\n		Point(double x, double y) {\n			this.x = x;\n			this.y = y;\n		}\n	}\n\n	class Line {\n		double a, b, c;\n		Line(double a, double b, double c) {\n			if (a < 0) {\n				a = -a;\n				b = -b;\n				c = -c;\n			}\n			this.a = a;\n			this.b = b;\n			this.c = c;\n		}\n	}\n}\n\nclass FastScanner {\n\n	private BufferedReader in;\n	private StringTokenizer st;\n\n	public FastScanner(InputStream stream) {\n		in = new BufferedReader(new InputStreamReader(stream));\n	}\n\n	public String next() {\n		while (st == null || !st.hasMoreTokens()) {\n			try {\n				String rl = in.readLine();\n				if (rl == null) {\n					return null;\n				}\n				st = new StringTokenizer(rl);\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n		}\n		return st.nextToken();\n	}\n\n	public int nextInt() {\n		return Integer.parseInt(next());\n	}\n\n}\n\n","geometry,sortings"
"import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		FastScanner in = new FastScanner(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		TaskE solver = new TaskE();\n		solver.solve(1, in, out);\n		out.close();\n	}\n}\n\nclass TaskE {\n	public void solve(int testNumber, FastScanner in, PrintWriter out) {\n		int n = in.nextInt();\n		Line[] lines = new Line[n];\n		for (int i = 0; i < n; i++) {\n			int a = in.nextInt();\n			int b = in.nextInt();\n			int c = in.nextInt();\n			lines[i] = new Line(a, b, c);\n		}\n		Arrays.sort(lines, new Comparator<Line>() {\n			public int compare(Line l1, Line l2) {\n				boolean u1 = l1.b > 0 || l1.b == 0 && l1.a > 0;\n				boolean u2 = l2.b > 0 || l2.b == 0 && l2.a > 0;\n				if (u1 != u2) {\n					return u1 ? 1 : -1;\n				}\n				double cr = l1.a*l2.b - l2.a*l1.b;\n				return -Double.compare(cr, 0);\n			}\n		});\n		double ans = 0;\n		for (int i = 0; i < n; i++) {\n			Point sum = new Point(0, 0);\n			for (int step = 1; step < n; step++) {\n				int j = (i + step) % n;\n				Point p = intersect(lines[i], lines[j]);\n				ans += cross(sum, p);\n				sum.x += p.x;\n				sum.y += p.y;\n			}\n		}\n		double total = (double) n * (n - 1) * (n - 2) / 6.0;\n		ans /= total;\n		ans /= 2;\n		out.printf(""%.10f\n"", ans);\n	}\n\n	final double eps = 1e-8;\n\n	private double cross(Point a, Point b) {\n		return a.x*b.y - a.y*b.x;\n	}\n\n	private Point intersect(Line l1, Line l2) {\n		double det = l1.a*l2.b - l1.b*l2.a;\n		if (Math.abs(det) < eps) {\n			return null;\n		}\n		double x = (l1.c*l2.b - l1.b*l2.c) / det;\n		double y = (l1.a*l2.c - l1.c*l2.a) / det;\n		return new Point(x, y);\n	}\n\n	class Point {\n		double x, y;\n		Point(double x, double y) {\n			this.x = x;\n			this.y = y;\n		}\n	}\n\n	class Line {\n		double a, b, c;\n		Line(double a, double b, double c) {\n			if (a < 0) {\n				a = -a;\n				b = -b;\n				c = -c;\n			}\n			this.a = a;\n			this.b = b;\n			this.c = c;\n		}\n	}\n}\n\nclass FastScanner {\n\n	private BufferedReader in;\n	private StringTokenizer st;\n\n	public FastScanner(InputStream stream) {\n		in = new BufferedReader(new InputStreamReader(stream));\n	}\n\n	public String next() {\n		while (st == null || !st.hasMoreTokens()) {\n			try {\n				String rl = in.readLine();\n				if (rl == null) {\n					return null;\n				}\n				st = new StringTokenizer(rl);\n			} catch (IOException e) {\n				throw new RuntimeException(e);\n			}\n		}\n		return st.nextToken();\n	}\n\n	public int nextInt() {\n		return Integer.parseInt(next());\n	}\n\n}\n\n","geometry,sortings"
"import java.io.*;\nimport java.util.*;\npublic class Main\n{\n	int n,k;\n	private void solve()throws IOException\n	{\n		fact();\n		n=nextInt();\n		k=nextInt();\n		String s=nextLine();\n		int a[]=new int[n+1];\n		for(int i=1;i<=n;i++)\n			a[i]=s.charAt(i-1)-'0';\n		if(k==0)\n		{\n			long ans=0;\n			long pow=1;\n			for(int i=n;i>=1;i--)\n			{\n				ans=(ans+(a[i]*pow)%mod)%mod;\n				pow=(pow*10)%mod;\n			}\n			out.println(ans);\n			return;\n		}\n		long sum[]=new long[n+1];\n		long pow[]=new long[n+1];\n		pow[0]=1;\n		for(int i=0;i<=n;i++)\n		{\n			if(i!=0)\n			{\n				sum[i]=sum[i-1];\n				pow[i]=(pow[i-1]*10)%mod;\n			}\n			int gaps=n-2-i;//no of gaps to put k-1 pluses\n			if(gaps>=k-1)\n				sum[i]+=(choose(gaps,k-1)*pow[i])%mod;\n		}\n		long ans=0;\n		for(int i=1;i<=n;i++)\n		{\n			int r=n-i;//highest base with which this number can appear\n			if(r-1>=0)\n			ans=(ans+(sum[r-1]*a[i])%mod)%mod;\n			if(i-1>=k)\n			ans=(ans+(a[i]*(pow[r]*choose(i-1,k))%mod)%mod)%mod;\n		}\n		out.println(ans);\n	}\n\n	final long mod=(long)(1e9+7);\n	final int maxn=(int)(1e5);\n	long choose(int n,int r)\n	{\n		return (((fact[n]*modinv(fact[r]))%mod)*modinv(fact[n-r]))%mod;\n	}\n	long modinv(long x){\n	    return modpow(x,mod-2);\n	}\n	long modpow(long a,long b){\n	    long ret=1;\n	    while(b!=0)\n	    {\n	        if(b%2==1)\n	            ret=(ret*a)%mod;\n	        a=(a*a)%mod;\n	        b=b/2;\n	    }\n	    return ret;\n	} \n	long fact[];\n	void fact(){\n		fact=new long[maxn+1];\n		fact[0]=1;\n		for(int i=1;i<=maxn;i++)\n			fact[i]=(fact[i-1]*i)%mod;\n	}\n\n	 \n	///////////////////////////////////////////////////////////\n\n	public void run()throws IOException\n	{\n		br=new BufferedReader(new InputStreamReader(System.in));\n		st=null;\n		out=new PrintWriter(System.out);\n\n		solve();\n\n		br.close();\n		out.close();\n	}\n	public static void main(String args[])throws IOException{\n		new Main().run();\n	}\n	BufferedReader br;\n	StringTokenizer st;\n	PrintWriter out;\n	String nextToken()throws IOException{\n		while(st==null || !st.hasMoreTokens())\n		st=new StringTokenizer(br.readLine());\n		return st.nextToken();\n	}\n	String nextLine()throws IOException{\n		return br.readLine();\n	}\n	int nextInt()throws IOException{\n		return Integer.parseInt(nextToken());\n	}\n	long nextLong()throws IOException{\n		return Long.parseLong(nextToken());\n	}\n	double nextDouble()throws IOException{\n		return Double.parseDouble(nextToken());\n	}\n}","combinatorics,dp,math,number theory"
"import java.io.*;\nimport static java.lang.Math.*;\nimport java.util.*;\n\npublic class C {\n    public static void main(String[] args) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer stok = new StringTokenizer(in.readLine());\n        int N = Integer.valueOf(stok.nextToken());\n        int K = Integer.valueOf(stok.nextToken());\n        String S = in.readLine().trim();\n\n        fact = new long[N];\n        fact[0] = 1;\n        invFact = new long[N];\n        invFact[0] = 1;\n        for (int i = 1; i < N; i++) {\n            fact[i] = (fact[i - 1] * i) % MOD;\n            invFact[i] = (pow(i, MOD - 2) * invFact[i-1]) % MOD;\n        }\n\n        long ans = ((S.charAt(N - 1) - '0') * choose(N - 1, K)) % MOD;\n        //System.out.println(ans+"" ""+(S.charAt(N-1)-'0')+"" ""+choose(N-1, K));\n        long old = 0;\n        long p10 = 1;\n        for (int i = 1; i < N; i++) {\n            long v = S.charAt(N - i - 1) - '0';\n            old = (old + choose(N - i - 1, K - 1) * p10) % MOD;\n            //System.out.println(v+"" ""+i+"" ""+old +"" ""+ans);\n            p10 = (p10 * 10) % MOD;\n            ans = (ans + v * old) % MOD;\n            ans = (ans + v * choose(N - i - 1, K) * p10) % MOD;\n        }\n        System.out.println(ans);\n    }\n    static long MOD = 1_000_000_007L;\n    static long[] fact, invFact;\n    static long pow(long a, long b) {\n        long ans = 1;\n        while (b > 0) {\n            if (b % 2 == 1) {\n                ans = (ans * a) % MOD;\n            }\n            a = (a * a) % MOD;\n            b /= 2;\n        }\n        return ans;\n    }\n    static long choose(int a, int b) {\n        if (b < 0 || b > a)\n            return 0;\n        long ans = (fact[a] * invFact[b]) % MOD;\n        ans = (ans * invFact[a - b]) % MOD;\n        return ans;\n    }\n}\n","combinatorics,dp,math,number theory"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.StringTokenizer;\n\n/**\n * @author Pavel Mavrin\n */\npublic class E {\n\n    private void solve() throws IOException {\n        int n = nextInt();\n        int k = nextInt();\n        String s = next();\n        init(n);\n        long res = 0;\n        long m = 0;\n        long p10 = 1;\n        for (int i = n - 1; i >= 0; i--) {\n            long q = c(i, k) * p10;\n            q %= MOD;\n            q += m;\n            q %= MOD;\n            q *= (s.charAt(i) - '0');\n            q %= MOD;\n            res += q;\n            res %= MOD;\n\n            m += (c(i - 1, k - 1) * p10) % MOD;\n            m %= MOD;\n\n            p10 = p10 * 10 % MOD;\n        }\n        out.println(res);\n    }\n\n    private static final long MOD = (long) (1e9 + 7);\n    private static final BigInteger MOD2 = BigInteger.valueOf(MOD);\n\n    long[] fact;\n    long[] invf;\n\n    void init(int n) {\n        fact = new long[n + 1];\n        invf = new long[n + 1];\n        fact[0] = 1;\n        invf[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fact[i] = fact[i - 1] * i;\n            fact[i] %= MOD;\n            invf[i] = BigInteger.valueOf(fact[i]).modInverse(MOD2).longValue();\n        }\n    }\n\n    private long c(int n, int k) {\n        if (k > n || k < 0) return 0;\n        long res = fact[n] * invf[k];\n        res %= MOD;\n        res *= invf[n - k];\n        res %= MOD;\n        return res;\n    }\n\n\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer st;\n    PrintWriter out = new PrintWriter(System.out);\n\n    String next() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new E().run();\n    }\n\n    private void run() throws IOException {\n        solve();\n        out.close();\n    }\n\n}\n","combinatorics,dp,math,number theory"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main\n{\n\n    static int maxn = 100005;\n	static char d[];\n	static long pow10[] = new long[maxn];\n	static long fac[] = new long[maxn];\n	static long sum[] = new long[maxn];\n	static long mod = 1000*1000*1000 + 7;\n	\n	static long put(long x, long y)\n	{\n		long p = 1;\n		for(int i= 1 ; i <= y; i<<=1 )\n		{\n			if((y & i) != 0) p= (1L*p*x) %mod;\n			x = (1L*x*x) %mod;\n		}\n		return p;\n	}\n\n	static long nCk(long n,long m)\n	{\n	    if(n < 0 || m < 0 || m > n)\n	    return 0;\n	    \n		return (1L * fac[(int)n] * put( (1L * fac[(int)m] * fac[(int)(n-m)] ) % mod, mod - 2 ))%mod;\n	}\n	static int n,k;\n	public static void main(String[]args)throws Throwable\n	{\n		Scanner sc = new Scanner(System.in);\n		n = sc.nextInt();\n		k = sc.nextInt();\n	    d = sc.next().toCharArray();\n		fac[0] = 1;\n	  pow10[0] = 1;\n 	for (int i = 1 ; i < maxn ; ++i) {\n		fac[i] = 1L*fac[i - 1] * i%mod;\n		fac[i] %= mod;\n		pow10[i] = 10L*pow10[i - 1];\n		pow10[i] %= mod;\n	}\n	\n	sum[0] = d[0] - '0';\n	for(int i = 1 ; i < n ;++i) { \n	    sum[i] = sum[i - 1] + (d[i] - '0');\n	    sum[i]%=mod;\n	}\n	long ans = 0;\n	for(int l = 0 ; l < n ; ++l) {\n		if(n - l - 2 < 0)\n			continue;\n		long cho = nCk(n - l - 2,k - 1);\n		cho %= mod;\n		cho *= pow10[l];\n		cho %= mod;\n		cho *= 1L*sum[n - l - 2];\n		cho %= mod;\n		ans += 1L*cho;\n		ans %= mod;\n	}\n	for(int i = 0 ; i < n ; ++i) {\n		int l = n - i - 1;\n		if(l < 0)\n			continue;\n		long tmp = pow10[l];\n		tmp %= mod;\n		tmp *= (d[i] - '0');\n		tmp %= mod;\n		tmp *= nCk(n - l - 1,k);\n		tmp %= mod;\n		ans += 1L*tmp;\n		ans %= mod;\n	}\n	System.out.println(ans);\n\n	\n\n	}\n\n	static class Scanner\n	{\n		BufferedReader br;\n		StringTokenizer st;\n\n\n		Scanner(InputStream s)  { br = new BufferedReader(new InputStreamReader(s)); }\n\n		String next() throws IOException\n		{\n			while(st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n\n		}\n\n		int nextInt() throws NumberFormatException, IOException { return Integer.parseInt(next()); }\n\n	}\n\n}","combinatorics,dp,math,number theory"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF518E extends PrintWriter {\n	CF518E() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF518E o = new CF518E(); o.main(); o.flush();\n	}\n\n	static final int INF = 0x3f3f3f3f;\n	boolean solve(int[] aa, int i0, int k, int n) {\n		int a_ = -INF;\n		for (int i = -1, j; i < n; i = j) {\n			j = i + 1;\n			while (j < n && aa[i0 + j * k] == INF)\n				j++;\n			int b_ = j == n ? INF : aa[i0 + j * k];\n			if (b_ - a_ < j - i)\n				return false;\n			int m = j - i - 1;\n			int r = (m - 1) / 2;\n			int l = r - m + 1;\n			if (r >= b_) {\n				r = b_ - 1;\n				l = r - m + 1;\n			}\n			if (l <= a_) {\n				l = a_ + 1;\n				r = l + m - 1;\n			}\n			for (int h = i + 1; h < j; h++)\n				aa[i0 + h * k] = l++;\n			a_ = b_;\n		}\n		return true;\n	}\n	void main() {\n		int n = sc.nextInt();\n		int k = sc.nextInt();\n		int[] aa = new int[n];\n		for (int i = 0; i < n; i++) {\n			String s = sc.next();\n			aa[i] = s.charAt(0) == '?' ? INF : Integer.parseInt(s);\n		}\n		for (int i0 = 0; i0 < k; i0++)\n			if (!solve(aa, i0, k, (n - 1 - i0) / k + 1)) {\n				println(""Incorrect sequence"");\n				return;\n			}\n		for (int i = 0; i < n; i++)\n			print(aa[i] + "" "");\n		println();\n	}\n}\n","greedy,implementation,math,ternary search"
"import java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class E {\n	static int n, k, QM;\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		n = in.nextInt();\n		k = in.nextInt();\n		QM = Integer.MAX_VALUE;\n		String reg;\n		List<Integer>[] sseq = new ArrayList[k];\n		for (int i=0; i<n; i++) {\n			int j = i%k;\n			if (sseq[j] == null) {\n				sseq[j] = new ArrayList<Integer>();\n			}\n			reg = in.next();\n			\n			if (reg.equals(""?"")) {\n				sseq[j].add(QM);\n			} else {\n				sseq[j].add(Integer.valueOf(reg));\n			}\n		}\n		for (int i=0; i<sseq.length; i++) {\n			sseq[i] = solve(sseq[i]);\n			if (sseq[i]==null) {\n				System.out.println(""Incorrect sequence"");\n				return;\n}		}\n		\n		for (int i=0; i<n; i++) {\n			System.out.print(sseq[i%k].get(i/k)+"" "");\n		}\n	}\n	private static List<Integer> solve(List<Integer> seq) {\n		seq.add(0, (int)-2e9);\n		seq.add((int) 2e9);\n\n		List<Integer> result = new ArrayList<>();\n		int b, e, cnt;\n\n		for (b=0; b<seq.size()-1;) {\n			e = b+1;\n			\n			while (e<seq.size() && seq.get(e) == QM) {\n				e++;\n			}\n			cnt = e-b-1;\n			if (seq.get(b) + cnt >= seq.get(e)) {\n				return null;\n			}\n			\n			int from  = seq.get(b);\n			int to = seq.get(e);\n			result.add(from);\n			\n			if (from >=0 && to >=0) {\n				for (int i1=0; i1<cnt; i1++) {\n					result.add(from + i1 + 1);\n				}\n			} else if (from <=0 && to <=0){\n				for (int i1=0; i1<cnt; i1++) {\n					result.add(to-cnt+i1);\n				}\n			} else {\n				List<Integer> list = new ArrayList<Integer>();\n				for (int x=0; cnt>0; x++) {\n					if (cnt>0 && from < x && x < to){\n						list.add(x);\n						cnt--;\n					}\n					if (x==0) {\n						continue;\n					}\n					if (cnt>0 && from < -x && -x < to) {\n						list.add(-x);\n						cnt--;\n					}\n				}\n				Collections.sort(list);\n				result.addAll(list);\n			}\n			b = e;\n		}\n		result.remove(0);\n		for (int i=0; i<result.size()-1; i++) {\n			if (result.get(i) >= result.get(i+1)) {\n				return null;\n			}\n		}\n		return result;\n	}\n\n}","greedy,implementation,math,ternary search"
"import java.io.*;\nimport java.util.*;\n\npublic class Div2_293_E{\n	static final int MIN = -2000000010;\n	static final int MAX = 2000000010;\n	public static void main(String[] args) throws IOException{\n		BufferedInputStream bis = new BufferedInputStream(System.in);\n		BufferedReader br = new BufferedReader(new InputStreamReader(bis));\n		PrintWriter prnt = new PrintWriter(System.out);\n		StringTokenizer tok = new StringTokenizer(br.readLine());\n		int n = Integer.parseInt(tok.nextToken());\n		int k = Integer.parseInt(tok.nextToken());\n		ArrayList <Integer> [] chains = new ArrayList [k];\n		tok = new StringTokenizer(br.readLine());\n		for(int i = 0;i < n;i++) {\n			String curr = tok.nextToken();\n			if(chains[i%k] == null) {\n				chains[i%k] = new ArrayList<Integer>();\n				chains[i%k].add(MIN);\n			}\n			if(curr.charAt(0)!='?') {\n				chains[i%k].add(Integer.parseInt(curr));\n			} else\n				chains[i%k].add(Integer.MAX_VALUE); \n		}\n		\n		ArrayList<Integer> chain;\n		for(int i = 0;i < k;i++) {\n			chains[i].add(MAX);\n			ArrayList<Integer> res = new ArrayList<Integer>();\n			int from = 0, to = from;\n			chain = chains[i];\n			while(from < chain.size()-1) {\n				for(to = from+1;to < chain.size() && chain.get(to) == Integer.MAX_VALUE;to ++);\n				int len = (to-from)-1;\n				int maxVal = chain.get(to), minVal = chain.get(from);\n				res.add(minVal);\n				if(maxVal <= minVal+len) {\n					System.out.println(""Incorrect sequence"");\n					return;\n				}\n				if(minVal >= 0 && maxVal >= 0) {\n					for(int j = 1;j <= len;j++) {\n						res.add(minVal+j);\n					}\n				}else if(maxVal <= 0 && minVal <= 0) {\n					for(int j = 0;j < len;j++)\n						res.add(maxVal-len+j);\n				}else if(len != 0){\n					ArrayList<Integer> temp = new ArrayList<Integer>();	\n					if(minVal < 0 && maxVal > 0) {\n						temp.add(0);\n						len--;\n					}\n					for(int cnt = 1;len > 0;cnt++) {\n						if(minVal < cnt && maxVal > cnt && len > 0) {\n							temp.add(cnt);\n							len--;\n						}\n						if(minVal < -cnt && maxVal > -cnt && len > 0) {\n							temp.add(-cnt);\n							len--;\n						}\n					}\n					Collections.sort(temp);\n					res.addAll(temp);\n				}\n				from = to;\n			}\n			res.remove(0);\n			for(int j = 0;j < res.size()-1;j++) {\n				if(res.get(j) >= res.get(j+1)) {\n					prnt.println(""Incorrect sequence"");\n					return;\n				}\n			}\n			chains[i] = res;\n		}\n		prnt.print(chains[0].get(0));\n		for(int i = 1;i < n;i++)\n			prnt.print("" ""+chains[i%k].get(i/k));\n		prnt.println();\n		prnt.close();\n	}\n}\n","greedy,implementation,math,ternary search"
"import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Created by liqiu on 2/24/15.\n */\npublic class E {\n    static long inf = (long) 1e10;\n    public static void main(String[] args) {\n        Scanner cin = new Scanner(System.in);\n        int n = cin.nextInt();\n        int k = cin.nextInt();\n        long[] lower = new long[n];\n        long[] up = new long[n];\n        Arrays.fill(lower, -inf);\n        Arrays.fill(up, inf);\n        long[] a = new long[n];\n        for (int i = 0; i < n; ++i) {\n            String s = cin.next();\n            if (s.equals(""?"")) a[i] = -inf;\n            else a[i] = Long.parseLong(s);\n        }\n        for(int rem = 0; rem < k; ++rem){\n            ArrayList<Integer> pos = new ArrayList<Integer>();\n            long low = -inf; long high = inf;\n            for(int i = rem; i < n; i += k){\n                if( a[i] == -inf ){\n                    pos.add(i);\n                }else {\n                    high = a[i] - 1;\n                    int cnt = pos.size();\n                    if (high - low + 1 < cnt) {\n                        System.out.println(""Incorrect sequence"");\n                        return;\n                    }\n                    if (cnt > 0) {\n                        long lf = low + cnt / 2;\n                        long rt = high - (cnt - 1 - cnt / 2);\n                        long base = 0;\n                        if (lf > 0) base = lf;\n                        else if (rt < 0) base = rt;\n                        else base = 0;\n                        for (int j = 0; j < cnt; ++j) a[pos.get(j)] = j - cnt / 2 + base;\n                        pos.clear();\n                    }\n                    low = a[i] + 1;\n                    high = inf;\n                }\n            }\n            //check last one\n            int cnt = pos.size();\n            if( high  - low + 1 < cnt ){\n                System.out.println(""Incorrect sequence"");\n                return;\n            }\n            if( cnt > 0 ) {\n//                System.out.println(pos.size() + ""--"" + rem);\n                long lf = low + cnt / 2;\n                long rt = high - (cnt - 1 - cnt/2);\n                long base = 0;\n                if( lf > 0 ) base = lf;\n                else if(rt < 0 ) base = rt;\n                else base = 0;\n                for(int j = 0; j < cnt; ++j) a[ pos.get(j) ] = j - cnt / 2 + base;\n                pos.clear();\n            }\n        }\n        for(int i = 0; i < n; ++i)\n            System.out.print(a[i] + "" "");\n        System.out.println();\n    }\n}\n","greedy,implementation,math,ternary search"
"import java.util.Scanner;\nimport java.util.Arrays;\n \npublic class Main {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        char s[] = scan.next().toCharArray();\n        char t[] = scan.next().toCharArray();\n        for(int i = s.length - 1; i >= 0; i--){\n           if(s[i]== 'z'){\n               s[i] = 'a';\n           } else {\n               s[i] += 1;\n               break;\n           }\n        }\n        System.out.print(Arrays.equals(s,t) ? ""No such string"".toCharArray() : s);\n    }\n}","constructive algorithms,strings"
"\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String []arg) {\n\n      Scanner sc  = new Scanner(System.in);\n      char []c1  = sc.nextLine().toCharArray();\n      char []c2 = sc.nextLine().toCharArray();\n\n      for(int i = c1.length -1 ; i>=0 ;--i) {\n          if(c1[i]=='z') {\n              c1[i] = 'a';\n          } else {\n              ++c1[i];\n              break;\n          }\n      }\n\n      for(int i = 0 ; i < c1.length;++i) {\n          if(c1[i]<c2[i]) {\n              System.out.println(new String(c1));\n              return;\n          }\n      }\n        System.out.println(""No such string"");\n\n    }\n\n}\n","constructive algorithms,strings"
"import java.util.*;\n\npublic class VitalyAndStrings {\n\n    static StringBuilder o = new StringBuilder();\n    \n	static StringBuilder f(String s) {\n		if (s.charAt(s.length()-1)=='z') {\n			f(s.substring(0,s.length()-1)).append('a');\n		} else {\n			o.append(s.substring(0,s.length()-1)).append(Character.toString((int)s.charAt(s.length()-1)+1));\n		}\n		return o;\n	}\n\n	static void solve() {\n		Scanner sc = new Scanner(System.in);\n		String s = sc.next(), t = sc.next();\n		s = f(s).toString();\n		if (s.compareTo(t)<0) {\n			System.out.println(s);\n		} else {\n			System.out.println(""No such string"");\n		}\n		sc.close();\n	}\n\n	public static void main(String[] args) {\n		solve();\n	}\n\n}\n","constructive algorithms,strings"
"import java.util.Scanner;\n\npublic class Solution150220 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.nextLine();\n        String t = scanner.nextLine();\n\n        char[] out = s.toCharArray();\n        int length = out.length;\n        for (int i = length - 1; i >= 0; i--){\n            if(out[i] == 'z'){\n                out[i] = 'a';\n            } else {\n                out[i] += 1;\n                break;\n            }\n        }\n        String outString = String.valueOf(out);\n        if(!outString.equals(t)){\n            System.out.println(outString);\n        } else {\n            System.out.println(""No such string"");\n        }\n    }\n}","constructive algorithms,strings"
"import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n\npublic class G1 {\n\n	static int inv = 0;\n	static int K,n;\n	\n	public static void main(String args[] ) throws Exception {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n	    PrintWriter w = new PrintWriter(System.out);\n	        \n	    StringTokenizer st1 = new StringTokenizer(br.readLine());\n	    n = ip(st1.nextToken());\n	    K = ip(st1.nextToken());\n	          \n	    StringTokenizer st2 = new StringTokenizer(br.readLine());\n	    int a[] = new int[n];\n	    for(int i=0;i<n;i++)\n	    	a[i] = ip(st2.nextToken());\n	         \n	    solve(a,0);\n	   \n	    double ans = inv;\n	    long den =(long)Math.pow(n*(n+1)/2,K);\n	    ans = ans/den;\n	    w.println(ans);\n	    w.close(); \n	}\n	\n	public static void solve(int[] a,int k){\n		if(k==K){\n			for(int i=0;i<a.length;i++)\n				for(int j=i+1;j<a.length;j++)\n					if(a[i]>a[j])\n						inv++;\n			return;\n		}\n		\n		for(int i=0;i<a.length;i++){\n			for(int j=i;j<a.length;j++){\n				int temp[] = new int[n];\n				for(int l=0;l<i;l++)\n					temp[l] = a[l];\n				for(int l=i;l<=j;l++)\n					temp[j-l+i]= a[l];\n				for(int l=j+1;l<n;l++)\n					temp[l] = a[l];\n				solve(temp,k+1);\n			}\n		}\n	}\n	\n	public static int ip(String s){\n		return Integer.parseInt(s);\n	}\n}\n","brute force,dfs and similar,dp,meet-in-the-middle"
"import java.util.Scanner;\n\npublic class Rockethon15 {\n    \n    public static double countInv(int[] p){\n        int c=0;\n        \n        for(int i=0;i<p.length;i++){\n            for(int j=i+1;j<p.length;j++){\n                if(p[i]>p[j])\n                    c++;\n            }\n        }\n        \n        return c;\n    }\n\n    static double deno=0;\n    public static double solve(int[] perm, int m){\n    \n        if(m==0){\n            deno++;\n            return countInv(perm);\n        }\n        \n        int n=perm.length;\n        double ans=0;\n        \n        int[] cur;\n        \n        for(int i=0;i<n;i++){\n            cur=new int[n];\n            for(int j=0;j<n;j++){\n                cur[j]=perm[j];\n            }\n            \n            for(int j=i;j<n;j++){\n                \n                for(int k=i;k<=j;k++){\n                    cur[k]=perm[j-k+i];\n                }\n                ans+=solve(cur, m-1);\n            }\n        }\n        \n        return ans;\n    }\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        \n        int n=sc.nextInt();\n        int m=sc.nextInt();\n        \n        int[] in=new int[n];\n        \n        for(int i=0;i<n;i++)\n            in[i]=sc.nextInt();\n        \n        \n        double nume=solve(in, m);\n        \n        System.out.println(nume/deno);\n\n    }\n}\n","brute force,dfs and similar,dp,meet-in-the-middle"
"import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class G1 {\n\n    static int n;\n    static int k;\n    static double ans;\n    static double c;\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        k = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n        c = 1 / Math.pow((n * n + n) / 2, k);\n        go(0, a);\n        System.out.println(ans);\n        in.close();\n    }\n\n    public static void go(int cnt, int[] a) {\n        if (cnt == k) {\n            int sum = 0;\n            for (int i = 0; i < n; i++) {\n                for (int j = i; j < n; j++) {\n                    if (a[i] > a[j]) {\n                        sum++;\n                    }\n                }\n            }\n            ans += (double) sum * c;\n            return;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                for (int r = i; r <= (i + j) / 2; r++) {\n                    int tmp = a[j - (r - i)];\n                    a[j - (r - i)] = a[r];\n                    a[r] = tmp;\n                }\n                go(cnt + 1, a);\n                for (int r = i; r <= (i + j) / 2; r++) {\n                    int tmp = a[j - (r - i)];\n                    a[j - (r - i)] = a[r];\n                    a[r] = tmp;\n                }\n            }\n        }\n    }\n\n}\n","brute force,dfs and similar,dp,meet-in-the-middle"
"import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static int n;\n\n    static double res = 0;\n    static double config = 0;\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        StringTokenizer st = new StringTokenizer(in.readLine());\n        n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        int[] a = new int[n];\n        st = new StringTokenizer(in.readLine());\n        for (int i = 0; i < n; i++) a[i] = Integer.parseInt(st.nextToken());\n        recur(a, k);\n        out.println(res/config);\n        out.close();\n    }\n\n    static void recur(int[] a, int k) {\n        if (k == 0) {\n            int inv = 0;\n            for (int i = 0; i < n; i++) {\n                for (int j = i+1; j < n; j++) {\n                    if (a[j] < a[i]) {\n                        inv++;\n                    }\n                }\n            }\n            res += inv;\n            config++;\n            return;\n        }\n        for (int l = 0; l < n; l++) {\n            for (int r = l; r < n; r++) {\n                int[] copy = Arrays.copyOf(a, n);\n                for (int left = l, right = r; left < right; left++, right--) {\n                    int temp = copy[left];\n                    copy[left]  = copy[right];\n                    copy[right] = temp;\n                }\n                recur(copy, k-1);\n            }\n        }\n    }\n}\n\n/*\n\n */","brute force,dfs and similar,dp,meet-in-the-middle"
"import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main {\n	public static void main(String[] args) {\n		Scanner in = new Scanner(System.in);\n		int n = in.nextInt();\n		final int B = 2000;\n		BitSet[] f = new BitSet[B + 1];\n		BitSet[] b = new BitSet[B + 1];\n		\n		for (int i = 0; i < B; ++i) {\n			f[i] = new BitSet(B);\n			b[i] = new BitSet(n);\n		}\n		\n		for (int i = 0; i < n; ++i) {\n			BigInteger x_ = in.nextBigInteger();\n			BitSet x = new BitSet(n);\n			BitSet s = new BitSet(n);\n			\n			for (int j = 0; j < x_.bitLength(); ++j)\n				x.set(j, x_.testBit(j));\n			\n			for (int j = x.nextSetBit(0); j >= 0; j = x.nextSetBit(j + 1))\n				if (f[j].get(j)) {\n					x.xor(f[j]);\n					s.xor(b[j]);\n				} else {\n					f[j] = x;\n					b[j] = s;\n					b[j].set(i);\n					System.out.println(""0"");\n					break;\n				}\n			if (x.isEmpty()) {\n				StringBuilder t = new StringBuilder();\n				t.append(s.cardinality());\n				for (int j = s.nextSetBit(0); j >= 0; j = s.nextSetBit(j + 1))\n					t.append("" "" + j);\n				System.out.println(t);\n			}\n		}\n	}\n}\n",bitmasks
"import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class solve {\n  private static Scanner in;\n  private static PrintWriter out;\n  \n  \n  public static void main(String[] args) {\n    in = new Scanner(System.in);\n    out = new PrintWriter(System.out);\n    int n = in.nextInt();\n    ArrayList<Tuple> xorSet = new ArrayList<Tuple>();\n    for(int i = 0; i < n; i++){\n      ///number\n      BigInteger a = new BigInteger(in.next());\n      ///bitset holding the numbers that where xored with a till lead to 0\n      BitSet bt = new BitSet();\n      //solve by gauss\n      for(Tuple t : xorSet){\n        BigInteger x = a.xor(t.a);\n        if(x.compareTo(a) < 0){\n          a = x;\n          bt.xor(t.b);\n        }\n      }\n      if(a.compareTo(BigInteger.ZERO) == 0){\n        out.print(bt.cardinality());\n        for(int j = bt.nextSetBit(0); j >= 0; j = bt.nextSetBit(j + 1)){\n          out.print("" "" + j);\n        }\n        out.println();\n      } else {\n        out.println('0');\n        bt.set(i);\n        xorSet.add(new Tuple(a, bt));\n      }\n      \n    }\n    out.close();\n  }\n  public static class Tuple{\n    public BigInteger a;\n    public BitSet b;\n    public Tuple(BigInteger a, BitSet b){\n      this.a = a;\n      this.b = b;\n    }\n  }\n}",bitmasks
"import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main {\n\n    static int MAXB = 2000;\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int m = in.nextInt();\n        BitSet[][] bs = new BitSet[m][2];\n        for (int i = 0; i < m; ++i) {\n            bs[i][0] = new BitSet(MAXB);\n            bs[i][1] = new BitSet(MAXB);\n            BigInteger a = in.nextBigInteger();\n            for (int bit = 0; bit < MAXB; ++bit)\n                if (a.testBit(bit))\n                    bs[i][0].set(bit);\n        }\n\n        for (int i = 0; i < m; ++i) {\n            int bit = bs[i][0].nextSetBit(0);\n            if (bit >= 0) {\n                System.out.println(0);\n                bs[i][1].set(i, true);\n                for (int j = i + 1; j < m; ++j)\n                    if (bs[j][0].get(bit)) {\n                        bs[j][0].xor(bs[i][0]);\n                        bs[j][1].xor(bs[i][1]);\n                    }\n            } else {\n                StringBuilder sb = new StringBuilder();\n                sb.append(bs[i][1].cardinality());\n                for (int j = bs[i][1].nextSetBit(0); j >= 0; j = bs[i][1].nextSetBit(j + 1))\n                    sb.append("" "" + j);\n                System.out.println(sb);\n            }\n        }\n    }\n}\n",bitmasks
"import java.math.BigInteger;\nimport java.io.*;\nimport java.util.*;\npublic final class main {\n    public static void main(String args[]) throws Throwable {\n        BufferedReader bi = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        String line;\n        BitSet r[] = new BitSet[2005];\n        BigInteger b[] = new BigInteger[2005];\n        int o[] = new int[2005];\n        for (int i = 0; i < 2005; i++) {\n            o[i] = -1;\n        }\n        int n = Integer.parseInt(bi.readLine());\n        for (int i = 0; i < n; i++) {\n            String l = bi.readLine();\n            b[i] = new BigInteger(l);\n            r[i] = new BitSet(2005);\n            r[i].set(i);\n            boolean g = false;\n            for (int j = 0; j < 2005; j++) if (b[i].testBit(j)) {\n                if (o[j] == -1) {\n                    o[j] = i;\n                    g = true;\n                    break;\n                } else {\n                    b[i] = b[i].xor(b[o[j]]);\n                    r[i].xor(r[o[j]]);\n                }\n            }\n            if (g) {\n                out.println(""0"");\n            } else {\n                r[i].set(i,false);\n                out.print(r[i].cardinality() + "" "");\n                for (int j = 0; j < i; j++) {\n                    if (r[i].get(j)) {\n                        out.print(j + "" "");\n                    }\n                }\n                out.println("""");\n            }\n        }\n        out.close();\n    }\n}\n\n",bitmasks
"\nimport java.io.*;\npublic class D_Vasya_and_Chess {\n    public static void main(String[] args) throws IOException{\n   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n   int n=Integer.parseInt(br.readLine());\n   if(n%2==0) {System.out.println(""white""); System.out.println(1+"" ""+2);}\n else System.out.println(""black"");\n\n    }\n}","constructive algorithms,games,math"
"import java.io.*;\nimport java.util.*;\npublic class Q3 {\n    public static void main(String[] args)throws IOException{\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(br.readLine());\n        if(n%2==1)\n         System.out.println(""black"");\n        else\n        {\n            System.out.println(""white"");\n            System.out.println(1+"" ""+2);\n        } \n    } \n}","constructive algorithms,games,math"
"import java.util.Scanner;\n\npublic class Solution{\n\n    public static void main(String args[]){\n        Scanner scn = new Scanner(System.in);\n        long n = scn.nextLong();\n        StringBuilder sb = new StringBuilder();\n        if(n%2 == 0){\n            sb.append(""white"");\n            sb.append(""\n"");\n            sb.append(""1 2"");\n            System.out.println(sb.toString());\n            return;\n        }\n        sb.append(""black"");\n        System.out.println(sb.toString());\n    }\n}","constructive algorithms,games,math"
"import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Prueba {\n\n    public static void main(String[] args) {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine());\n            if(n%2!=0){\n                System.out.println(""black"");\n            }else{\n                System.out.println(""white"");\n                System.out.println(""1 2"");\n            }\n            br.close();\n        } catch (Exception e) {\n\n        }\n    }\n}\n	   	 		 	 	      	   			 		 	","constructive algorithms,games,math"
"import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\npublic class Hello {\n  static int n, K;\n  static char [][]mat;\n  public static void main(String[] args) {\n    //try {\n    //  FileInputStream fis = new FileInputStream(""data.txt"");\n    //  System.setIn(fis);\n      //Scanner in = new Scanner(System.in);\n      FastReader in = new FastReader(System.in);\n      \n      n = in.nextInt();\n      K = in.nextInt();\n      mat = new char[2][n];\n      for (int i = 0;i < 2;++i) {\n	String s = in.nextLine();\n	for (int j = 0;j < n;++j) {\n	  mat[i][j] = s.charAt(j);\n	}\n      }\n      //System.out.println(""K "" + K);\n      \n      int [][]wt = new int[K][K];\n      for (int j = 0;j < n;++j) {\n	int i0 = (mat[0][j] >= 'A' && mat[0][j] <= 'Z')?mat[0][j] - 'A' + 26:mat[0][j] - 'a';\n	int i1 = (mat[1][j] >= 'A' && mat[1][j] <= 'Z')?mat[1][j] - 'A' + 26:mat[1][j] - 'a';\n	//System.out.println(i0 + "" "" + i1);\n	wt[i0][i1] += 1;\n      }\n      \n      Graph graph = new Graph(K * 2 + 2);\n\n      int source = 2 * K, sink = K * 2 + 1;\n      \n      \n      for (int i = 0;i < K;++i) {\n	graph.addFlowWeightedEdge(source, i, 0, 1);\n      }\n      for (int i = 0;i < K;++i) {\n	graph.addFlowWeightedEdge(K + i, sink, 0, 1);\n      }\n      \n      Long max = Long.MAX_VALUE;\n      int [][]id = new int[K][K];\n      for (int i = 0;i < K;++i) {\n	for (int j = 0;j < K;++j) {\n	  id[i][j] = graph.addFlowWeightedEdge(i, j + K, max - wt[i][j], 1);\n	}\n      }\n      MinCostFlow mcf = new MinCostFlow(graph, source, sink, false);\n      Pair<Long, Long> ans = mcf.minCostMaxFlow();\n      \n      System.out.println(max * K - ans.first);\n\n      for (int i = 0;i < K;++i) {\n	for (int j = 0;j < K;++j) {\n	  if (graph.flow(id[i][j]) == 1) {\n	    char c = 'a';\n	    if (j >= 26) c = (char)('A' + (j - 26));\n	    else c = (char)('a' + j);\n	    System.out.print(c);\n	  }\n	}\n      }\n      \n	  \n      \n    //} catch (FileNotFoundException e){\n    //  System.out.println(""error"");\n    //}\n  }\n}\n\nclass FastReader {\n    private boolean finished = false;\n \n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n \n    public FastReader(InputStream stream) {\n        this.stream = stream;\n    }\n \n    public int read() {\n        if (numChars == -1) {\n            throw new InputMismatchException();\n        }\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0) {\n                return -1;\n            }\n        }\n \n        return buf[curChar++];\n    }\n \n    public int peek() {\n        if (numChars == -1) {\n            return -1;\n        }\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                return -1;\n            }\n            if (numChars <= 0) {\n                return -1;\n            }\n        }\n        return buf[curChar];\n    }\n \n    public int nextInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c == ',') {\n                c = read();\n            }\n            if (c < '0' || c > '9') {\n                throw new InputMismatchException();\n            }\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n \n    public long nextLong() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9') {\n                throw new InputMismatchException();\n            }\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n \n    public String nextString() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n \n    public boolean isSpaceChar(int c) {\n        if (filter != null) {\n            return filter.isSpaceChar(c);\n        }\n        return isWhitespace(c);\n    }\n \n    public static boolean isWhitespace(int c) {\n        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n    }\n \n    private String readLine0() {\n        StringBuilder buf = new StringBuilder();\n        int c = read();\n        while (c != '\n' && c != -1) {\n            if (c != '\r') {\n                buf.appendCodePoint(c);\n            }\n            c = read();\n        }\n        return buf.toString();\n    }\n \n    public String nextLine() {\n        String s = readLine0();\n        while (s.trim().length() == 0)\n            s = readLine0();\n        return s;\n    }\n \n    public String nextLine(boolean ignoreEmptyLines) {\n        if (ignoreEmptyLines) {\n            return nextLine();\n        } else {\n            return readLine0();\n        }\n    }\n \n    public BigInteger nextBigInteger() {\n        try {\n            return new BigInteger(nextString());\n        } catch (NumberFormatException e) {\n            throw new InputMismatchException();\n        }\n    }\n \n    public char nextCharacter() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        return (char) c;\n    }\n \n    public double nextDouble() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        double res = 0;\n        while (!isSpaceChar(c) && c != '.') {\n            if (c == 'e' || c == 'E') {\n                return res * Math.pow(10, nextInt());\n            }\n            if (c < '0' || c > '9') {\n                throw new InputMismatchException();\n            }\n            res *= 10;\n            res += c - '0';\n            c = read();\n        }\n        if (c == '.') {\n            c = read();\n            double m = 1;\n            while (!isSpaceChar(c)) {\n                if (c == 'e' || c == 'E') {\n                    return res * Math.pow(10, nextInt());\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                m /= 10;\n                res += (c - '0') * m;\n                c = read();\n            }\n        }\n        return res * sgn;\n    }\n \n    public boolean isExhausted() {\n        int value;\n        while (isSpaceChar(value = peek()) && value != -1)\n            read();\n        return value == -1;\n    }\n \n    public String next() {\n        return nextString();\n    }\n \n    public SpaceCharFilter getFilter() {\n        return filter;\n    }\n \n    public void setFilter(SpaceCharFilter filter) {\n        this.filter = filter;\n    }\n \n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n}\nclass Graph {\n  public static final int REMOVED_BIT = 0;\n\n  protected int vertexCount;\n  protected int edgeCount;\n\n  private int[] firstOutbound;\n  private int[] firstInbound;\n\n  private Edge[] edges;\n  private int[] nextInbound;\n  private int[] nextOutbound;\n  private int[] from;\n  private int[] to;\n  private long[] weight;\n  private long[] capacity;\n  private int[] reverseEdge;\n  private int[] flags;\n\n  public Graph(int vertexCount) {\n    this(vertexCount, vertexCount);\n  }\n\n  public Graph(int vertexCount, int edgeCapacity) {\n    this.vertexCount = vertexCount;\n    firstOutbound = new int[vertexCount];\n    Arrays.fill(firstOutbound, -1);\n\n    from = new int[edgeCapacity];\n    to = new int[edgeCapacity];\n    nextOutbound = new int[edgeCapacity];\n    flags = new int[edgeCapacity];\n  }\n\n  public int addEdge(int fromID, int toID, long weight, long capacity, int reverseEdge) {\n    ensureEdgeCapacity(edgeCount + 1);\n    if (firstOutbound[fromID] != -1)\n      nextOutbound[edgeCount] = firstOutbound[fromID];\n    else\n      nextOutbound[edgeCount] = -1;\n    firstOutbound[fromID] = edgeCount;\n    if (firstInbound != null) {\n      if (firstInbound[toID] != -1)\n	nextInbound[edgeCount] = firstInbound[toID];\n      else\n	nextInbound[edgeCount] = -1;\n      firstInbound[toID] = edgeCount;\n    }\n    this.from[edgeCount] = fromID;\n    this.to[edgeCount] = toID;\n    if (capacity != 0) {\n      if (this.capacity == null)\n	this.capacity = new long[from.length];\n      this.capacity[edgeCount] = capacity;\n    }\n    if (weight != 0) {\n      if (this.weight == null)\n	this.weight = new long[from.length];\n      this.weight[edgeCount] = weight;\n    }\n    if (reverseEdge != -1) {\n      if (this.reverseEdge == null) {\n	this.reverseEdge = new int[from.length];\n	Arrays.fill(this.reverseEdge, 0, edgeCount, -1);\n      }\n      this.reverseEdge[edgeCount] = reverseEdge;\n    }\n    if (edges != null)\n      edges[edgeCount] = createEdge(edgeCount);\n    return edgeCount++;\n  }\n\n  protected final GraphEdge createEdge(int id) {\n    return new GraphEdge(id);\n  }\n\n  public final int addFlowWeightedEdge(int from, int to, long weight, long capacity) {\n    if (capacity == 0) {\n      return addEdge(from, to, weight, 0, -1);\n    } else {\n      int lastEdgeCount = edgeCount;\n      addEdge(to, from, -weight, 0, lastEdgeCount + entriesPerEdge());\n      return addEdge(from, to, weight, capacity, lastEdgeCount);\n    }\n  }\n\n  protected int entriesPerEdge() {\n    return 1;\n  }\n\n  public final int addFlowEdge(int from, int to, long capacity) {\n    return addFlowWeightedEdge(from, to, 0, capacity);\n  }\n\n  public final int vertexCount() {\n    return vertexCount;\n  }\n\n  public final int firstOutbound(int vertex) {\n    int id = firstOutbound[vertex];\n    while (id != -1 && isRemoved(id))\n      id = nextOutbound[id];\n    return id;\n  }\n\n  public final int nextOutbound(int id) {\n    id = nextOutbound[id];\n    while (id != -1 && isRemoved(id))\n      id = nextOutbound[id];\n    return id;\n  }\n\n  public final int source(int id) {\n    return from[id];\n  }\n\n  public final int destination(int id) {\n    return to[id];\n  }\n\n  public final long weight(int id) {\n    if (weight == null)\n      return 0;\n    return weight[id];\n  }\n\n  public final long capacity(int id) {\n    if (capacity == null)\n      return 0;\n    return capacity[id];\n  }\n\n  public final long flow(int id) {\n    if (reverseEdge == null)\n      return 0;\n    return capacity[reverseEdge[id]];\n  }\n\n  public final void pushFlow(int id, long flow) {\n    if (flow == 0)\n      return;\n    if (flow > 0) {\n      if (capacity(id) < flow)\n	throw new IllegalArgumentException(""Not enough capacity"");\n    } else {\n      if (flow(id) < -flow)\n	throw new IllegalArgumentException(""Not enough capacity"");\n    }\n    capacity[id] -= flow;\n    capacity[reverseEdge[id]] += flow;\n  }\n\n  public final boolean flag(int id, int bit) {\n    return (flags[id] >> bit & 1) != 0;\n  }\n\n  public final boolean isRemoved(int id) {\n    return flag(id, REMOVED_BIT);\n  }\n\n  protected void ensureEdgeCapacity(int size) {\n    if (from.length < size) {\n      int newSize = Math.max(size, 2 * from.length);\n      if (edges != null)\n	edges = resize(edges, newSize);\n      from = resize(from, newSize);\n      to = resize(to, newSize);\n      nextOutbound = resize(nextOutbound, newSize);\n      if (nextInbound != null)\n	nextInbound = resize(nextInbound, newSize);\n      if (weight != null)\n	weight = resize(weight, newSize);\n      if (capacity != null)\n	capacity = resize(capacity, newSize);\n      if (reverseEdge != null)\n	reverseEdge = resize(reverseEdge, newSize);\n      flags = resize(flags, newSize);\n    }\n  }\n\n  protected final int[] resize(int[] array, int size) {\n    int[] newArray = new int[size];\n    System.arraycopy(array, 0, newArray, 0, array.length);\n    return newArray;\n  }\n\n  private long[] resize(long[] array, int size) {\n    long[] newArray = new long[size];\n    System.arraycopy(array, 0, newArray, 0, array.length);\n    return newArray;\n  }\n\n  private Edge[] resize(Edge[] array, int size) {\n    Edge[] newArray = new Edge[size];\n    System.arraycopy(array, 0, newArray, 0, array.length);\n    return newArray;\n  }\n\n  public final boolean isSparse() {\n    return vertexCount == 0 || edgeCount * 20 / vertexCount <= vertexCount;\n  }\n\n  protected class GraphEdge implements Edge {\n    protected int id;\n\n    protected GraphEdge(int id) {\n      this.id = id;\n    }\n\n  }\n\n}\n\n\nclass MinCostFlow {\n  private final Graph graph;\n  private final int source;\n  private final int destination;\n  private final long[] phi;\n  private final long[] dijkstraResult;\n  private final int[] lastEdge;\n  private final Heap heap;\n  private final int vertexCount;\n  private final int[] visited;\n  private int visitIndex;\n\n  public MinCostFlow(Graph graph, int source, int destination, boolean hasNegativeEdges) {\n    this.graph = graph;\n    this.source = source;\n    this.destination = destination;\n    vertexCount = graph.vertexCount();\n    phi = new long[vertexCount];\n    if (hasNegativeEdges)\n      fordBellman();\n    dijkstraResult = new long[vertexCount];\n    lastEdge = new int[vertexCount];\n    if (graph.isSparse()) {\n      heap = new Heap(vertexCount, new IntComparator() {\n	  public int compare(int first, int second) {\n	  return IntegerUtils.longCompare(dijkstraResult[first], dijkstraResult[second]);\n	  }\n	  }, vertexCount);\n      visited = null;\n    } else {\n      heap = null;\n      visited = new int[vertexCount];\n    }\n  }\n\n  private void fordBellman() {\n    Arrays.fill(phi, Long.MAX_VALUE);\n    phi[source] = 0;\n    boolean[] inQueue = new boolean[vertexCount];\n    int[] queue = new int[vertexCount + 1];\n    queue[0] = source;\n    inQueue[source] = true;\n    int stepCount = 0;\n    int head = 0;\n    int end = 1;\n    int maxSteps = 2 * vertexCount * vertexCount;\n    while (head != end) {\n      int vertex = queue[head++];\n      if (head == queue.length)\n	head = 0;\n      inQueue[vertex] = false;\n      int edgeID = graph.firstOutbound(vertex);\n      while (edgeID != -1) {\n	long total = phi[vertex] + graph.weight(edgeID);\n	int destination = graph.destination(edgeID);\n	if (graph.capacity(edgeID) != 0 && phi[destination] > total) {\n	  phi[destination] = total;\n	  if (!inQueue[destination]) {\n	    queue[end++] = destination;\n	    inQueue[destination] = true;\n	    if (end == queue.length)\n	      end = 0;\n	  }\n	}\n	edgeID = graph.nextOutbound(edgeID);\n      }\n      if (++stepCount > maxSteps)\n	throw new IllegalArgumentException(""Graph contains negative cycle"");\n    }\n  }\n\n  class Heap {\n    IntList list;\n    int shift;\n    int[] index;\n\n    public Heap(int vertexCount, IntComparator intComparator, int vertexCount1) {\n      list = new IntArrayList(vertexCount);\n      index = new int[vertexCount1];\n      Arrays.fill(index, -1);\n    }\n\n    public void add(int source) {\n      index[source] = 0;\n      list.add(source);\n    }\n\n    public boolean isEmpty() {\n      return shift == list.size();\n    }\n\n    public int poll() {\n      int result = list.get(shift++);\n      index[result] = -1;\n      return result;\n    }\n\n    public int getIndex(int next) {\n      return index[next];\n    }\n\n    public void shiftUp(int index) {\n    }\n\n    public void clear() {\n      list = new IntArrayList();\n      shift = 0;\n      Arrays.fill(index, -1);\n    }\n  }\n\n  public Pair<Long, Long> minCostMaxFlow() {\n    return minCostMaxFlow(Long.MAX_VALUE);\n  }\n\n  public Pair<Long, Long> minCostMaxFlow(long maxFlow) {\n    long cost = 0;\n    long flow = 0;\n    while (maxFlow != 0) {\n      if (graph.isSparse())\n	dijkstraAlgorithm();\n      else\n	dijkstraAlgorithmFull();\n      if (lastEdge[destination] == -1)\n	return Pair.makePair(cost, flow);\n      for (int i = 0; i < dijkstraResult.length; i++) {\n	if (dijkstraResult[i] != Long.MAX_VALUE)\n	  phi[i] += dijkstraResult[i];\n      }\n      int vertex = destination;\n      long currentFlow = maxFlow;\n      long currentCost = 0;\n      while (vertex != source) {\n	int edgeID = lastEdge[vertex];\n	currentFlow = Math.min(currentFlow, graph.capacity(edgeID));\n	currentCost += graph.weight(edgeID);\n	vertex = graph.source(edgeID);\n      }\n      maxFlow -= currentFlow;\n      cost += currentCost * currentFlow;\n      flow += currentFlow;\n      vertex = destination;\n      while (vertex != source) {\n	int edgeID = lastEdge[vertex];\n	graph.pushFlow(edgeID, currentFlow);\n	vertex = graph.source(edgeID);\n      }\n    }\n    return Pair.makePair(cost, flow);\n  }\n\n  private void dijkstraAlgorithm() {\n    Arrays.fill(dijkstraResult, Long.MAX_VALUE);\n    Arrays.fill(lastEdge, -1);\n    dijkstraResult[source] = 0;\n    heap.clear();\n    heap.add(source);\n    while (!heap.isEmpty()) {\n      int current = heap.poll();\n      int edgeID = graph.firstOutbound(current);\n      while (edgeID != -1) {\n	if (graph.capacity(edgeID) != 0) {\n	  int next = graph.destination(edgeID);\n	  long total = graph.weight(edgeID) - phi[next] + phi[current] + dijkstraResult[current];\n	  if (dijkstraResult[next] > total) {\n	    dijkstraResult[next] = total;\n	    if (heap.getIndex(next) == -1)\n	      heap.add(next);\n	    else\n	      heap.shiftUp(heap.getIndex(next));\n	    lastEdge[next] = edgeID;\n	  }\n	}\n	edgeID = graph.nextOutbound(edgeID);\n      }\n    }\n  }\n\n  private void dijkstraAlgorithmFull() {\n    visitIndex++;\n    Arrays.fill(dijkstraResult, Long.MAX_VALUE);\n    lastEdge[destination] = -1;\n    dijkstraResult[source] = 0;\n    for (int i = 0; i < vertexCount; i++) {\n      int index = -1;\n      long length = Long.MAX_VALUE;\n      for (int j = 0; j < vertexCount; j++) {\n	if (visited[j] != visitIndex && dijkstraResult[j] < length) {\n	  length = dijkstraResult[j];\n	  index = j;\n	}\n      }\n      if (index == -1) {\n	return;\n      }\n      visited[index] = visitIndex;\n      int edgeID = graph.firstOutbound(index);\n      while (edgeID != -1) {\n	if (graph.capacity(edgeID) != 0) {\n	  int next = graph.destination(edgeID);\n	  if (visited[next] != visitIndex) {\n	    long total = graph.weight(edgeID) - phi[next] + phi[index] + length;\n	    if (dijkstraResult[next] > total) {\n	      dijkstraResult[next] = total;\n	      lastEdge[next] = edgeID;\n	    }\n	  }\n	}\n	edgeID = graph.nextOutbound(edgeID);\n      }\n    }\n  }\n}\n\nclass Pair<U, V> implements Comparable<Pair<U, V>> {\n  public final U first;\n  public final V second;\n\n  public static<U, V> Pair<U, V> makePair(U first, V second) {\n    return new Pair<U, V>(first, second);\n  }\n\n  private Pair(U first, V second) {\n    this.first = first;\n    this.second = second;\n  }\n\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    Pair pair = (Pair) o;\n\n    return !(first != null ? !first.equals(pair.first) : pair.first != null) && !(second != null ? !second.equals(pair.second) : pair.second != null);\n\n  }\n\n  public int hashCode() {\n    int result = first != null ? first.hashCode() : 0;\n    result = 31 * result + (second != null ? second.hashCode() : 0);\n    return result;\n  }\n\n  public String toString() {\n    return ""("" + first + "","" + second + "")"";\n  }\n\n  public int compareTo(Pair<U, V> o) {\n    int value = ((Comparable<U>)first).compareTo(o.first);\n    if (value != 0)\n      return value;\n    return ((Comparable<V>)second).compareTo(o.second);\n  }\n}\n\nabstract class IntCollection {\n  public abstract IntIterator iterator();\n  public abstract int size();\n  public abstract void add(int value);\n\n  public void addAll(IntCollection values) {\n    for (IntIterator it = values.iterator(); it.isValid(); it.advance()) {\n      add(it.value());\n    }\n  }\n\n}\n\ninterface IntIterator {\n  public int value() throws NoSuchElementException;\n  /*\n   * @throws NoSuchElementException only if iterator already invalid\n   */\n  public void advance() throws NoSuchElementException;\n  public boolean isValid();\n}\n\ninterface Edge {\n}\n\nabstract class IntList extends IntCollection implements Comparable<IntList> {\n\n  public abstract int get(int index);\n\n  public IntIterator iterator() {\n    return new IntIterator() {\n      private int size = size();\n      private int index = 0;\n\n      public int value() throws NoSuchElementException {\n	if (!isValid())\n	  throw new NoSuchElementException();\n	return get(index);\n      }\n\n      public void advance() throws NoSuchElementException {\n	if (!isValid())\n	  throw new NoSuchElementException();\n	index++;\n      }\n\n      public boolean isValid() {\n	return index < size;\n      }\n    };\n  }\n\n  public int hashCode() {\n    int hashCode = 1;\n    for (IntIterator i = iterator(); i.isValid(); i.advance())\n      hashCode = 31 * hashCode + i.value();\n    return hashCode;\n  }\n\n  public boolean equals(Object obj) {\n    if (!(obj instanceof IntList))\n      return false;\n    IntList list = (IntList)obj;\n    if (list.size() != size())\n      return false;\n    IntIterator i = iterator();\n    IntIterator j = list.iterator();\n    while (i.isValid()) {\n      if (i.value() != j.value())\n	return false;\n      i.advance();\n      j.advance();\n    }\n    return true;\n  }\n\n  public int compareTo(IntList o) {\n    IntIterator i = iterator();\n    IntIterator j = o.iterator();\n    while (true) {\n      if (i.isValid()) {\n	if (j.isValid()) {\n	  if (i.value() != j.value()) {\n	    if (i.value() < j.value())\n	      return -1;\n	    else\n	      return 1;\n	  }\n	} else\n	  return 1;\n      } else {\n	if (j.isValid())\n	  return -1;\n	else\n	  return 0;\n      }\n      i.advance();\n      j.advance();\n    }\n  }\n\n}\n\nclass IntArrayList extends IntList {\n  private int[] array;\n  private int size;\n\n  public IntArrayList() {\n    this(10);\n  }\n\n  public IntArrayList(int capacity) {\n    array = new int[capacity];\n  }\n\n  public IntArrayList(IntList list) {\n    this(list.size());\n    addAll(list);\n  }\n\n  public int get(int index) {\n    if (index >= size)\n      throw new IndexOutOfBoundsException();\n    return array[index];\n  }\n\n  public int size() {\n    return size;\n  }\n\n  public void add(int value) {\n    ensureCapacity(size + 1);\n    array[size++] = value;\n  }\n\n  public void ensureCapacity(int newCapacity) {\n    if (newCapacity > array.length) {\n      int[] newArray = new int[Math.max(newCapacity, array.length << 1)];\n      System.arraycopy(array, 0, newArray, 0, size);\n      array = newArray;\n    }\n  }\n\n}\n\ninterface IntComparator {\n\n}\n\nclass IntegerUtils {\n\n  public static int longCompare(long a, long b) {\n    if (a < b)\n      return -1;\n    if (a > b)\n      return 1;\n    return 0;\n  }\n\n}\n","flows,graph matchings"
"import java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\nimport java.util.List;\nimport java.math.BigInteger;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.util.Iterator;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.io.InputStream;\nimport java.io.OutputStreamWriter;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskC {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n        int n=in.readInt(), k=in.readInt();\n        char[] str1=IOUtils.readCharArray(in, n), str2= IOUtils.readCharArray(in, n), ret=new char[k];\n        int[][] table=new int[k][k];\n        for (int i=0; i<n; i++) table[id(str1[i])][id(str2[i])]++;\n        Graph graph=new Graph(2*k+2);\n        for (int i=0; i<k; i++) {\n            graph.addFlowWeightedEdge(0, i+1, 0, 1);\n            graph.addFlowWeightedEdge(k+1+i, 2*k+1, 0, 1);\n            for (int j=0; j<k; j++) graph.addFlowWeightedEdge(i+1, k+j+1, -table[i][j], Long.MAX_VALUE);\n        }\n        out.printLine(-MinCostFlow.minCostMaxFlow(graph, 0, 2*k+1, true).first);\n        for (int i=0; i<graph.edgeCount(); i++){\n            int u=graph.source(i), v=graph.destination(i);\n            //out.printLine(u, v, graph.weight(i), graph.flow(i), graph.capacity(i));\n            if (u>=1 && u<=k && v>=k+1 && v<=2*k && graph.flow(i)>0) ret[u-1]=id(v-k-1);\n        }\n        out.printLine(ret);\n    }\n\n    int id(char c) {\n        if (c>='a'&& c<='z') return c-'a';\n        return c-'A'+26;\n    }\n\n    char id(int i) {\n        return (char)(i<26?i+'a':i-26+'A');\n    }\n}\n\nclass InputReader {\n\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public boolean isSpaceChar(int c) {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return isWhitespace(c);\n    }\n\n    public static boolean isWhitespace(int c) {\n        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n    }\n\n    public char readCharacter() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        return (char) c;\n    }\n\n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n}\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public void printLine(char[] array) {\n        writer.println(array);\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n    public void printLine(long i) {\n        writer.println(i);\n    }\n\n}\n\nclass IOUtils {\n\n    public static char[] readCharArray(InputReader in, int size) {\n        char[] array = new char[size];\n        for (int i = 0; i < size; i++)\n            array[i] = in.readCharacter();\n        return array;\n    }\n\n}\n\nclass Graph {\n    public static final int REMOVED_BIT = 0;\n\n    protected int vertexCount;\n    protected int edgeCount;\n\n    private int[] firstOutbound;\n    private int[] firstInbound;\n\n    private Edge[] edges;\n    private int[] nextInbound;\n    private int[] nextOutbound;\n    private int[] from;\n    private int[] to;\n    private long[] weight;\n    public long[] capacity;\n    private int[] reverseEdge;\n    private int[] flags;\n\n    public Graph(int vertexCount) {\n        this(vertexCount, vertexCount);\n    }\n\n    public Graph(int vertexCount, int edgeCapacity) {\n        this.vertexCount = vertexCount;\n        firstOutbound = new int[vertexCount];\n        Arrays.fill(firstOutbound, -1);\n\n        from = new int[edgeCapacity];\n        to = new int[edgeCapacity];\n        nextOutbound = new int[edgeCapacity];\n        flags = new int[edgeCapacity];\n    }\n\n    public int addEdge(int fromID, int toID, long weight, long capacity, int reverseEdge) {\n        ensureEdgeCapacity(edgeCount + 1);\n        if (firstOutbound[fromID] != -1)\n            nextOutbound[edgeCount] = firstOutbound[fromID];\n        else\n            nextOutbound[edgeCount] = -1;\n        firstOutbound[fromID] = edgeCount;\n        if (firstInbound != null) {\n            if (firstInbound[toID] != -1)\n                nextInbound[edgeCount] = firstInbound[toID];\n            else\n                nextInbound[edgeCount] = -1;\n            firstInbound[toID] = edgeCount;\n        }\n        this.from[edgeCount] = fromID;\n        this.to[edgeCount] = toID;\n        if (capacity != 0) {\n            if (this.capacity == null)\n                this.capacity = new long[from.length];\n            this.capacity[edgeCount] = capacity;\n        }\n        if (weight != 0) {\n            if (this.weight == null)\n                this.weight = new long[from.length];\n            this.weight[edgeCount] = weight;\n        }\n        if (reverseEdge != -1) {\n            if (this.reverseEdge == null) {\n                this.reverseEdge = new int[from.length];\n                Arrays.fill(this.reverseEdge, 0, edgeCount, -1);\n            }\n            this.reverseEdge[edgeCount] = reverseEdge;\n        }\n        if (edges != null)\n            edges[edgeCount] = createEdge(edgeCount);\n        return edgeCount++;\n    }\n\n    protected final GraphEdge createEdge(int id) {\n        return new GraphEdge(id);\n    }\n\n    public final int addFlowWeightedEdge(int from, int to, long weight, long capacity) {\n        if (capacity == 0) {\n            return addEdge(from, to, weight, 0, -1);\n        } else {\n            int lastEdgeCount = edgeCount;\n            addEdge(to, from, -weight, 0, lastEdgeCount + entriesPerEdge());\n            return addEdge(from, to, weight, capacity, lastEdgeCount);\n        }\n    }\n\n    protected int entriesPerEdge() {\n        return 1;\n    }\n\n    public final int vertexCount() {\n        return vertexCount;\n    }\n\n    public final int edgeCount() {\n        return edgeCount;\n    }\n\n    public final int firstOutbound(int vertex) {\n        int id = firstOutbound[vertex];\n        while (id != -1 && isRemoved(id))\n            id = nextOutbound[id];\n        return id;\n    }\n\n    public final int nextOutbound(int id) {\n        id = nextOutbound[id];\n        while (id != -1 && isRemoved(id))\n            id = nextOutbound[id];\n        return id;\n    }\n\n    public final int source(int id) {\n        return from[id];\n    }\n\n    public final int destination(int id) {\n        return to[id];\n    }\n\n    public final long weight(int id) {\n        if (weight == null)\n            return 0;\n        return weight[id];\n    }\n\n    public final long capacity(int id) {\n        if (capacity == null)\n            return 0;\n        return capacity[id];\n    }\n\n    public final long flow(int id) {\n        if (reverseEdge == null)\n            return 0;\n        return capacity[reverseEdge[id]];\n    }\n\n    public final void pushFlow(int id, long flow) {\n        if (flow == 0)\n            return;\n        if (flow > 0) {\n            if (capacity(id) < flow)\n                throw new IllegalArgumentException(""Not enough capacity"");\n        } else {\n            if (flow(id) < -flow)\n                throw new IllegalArgumentException(""Not enough capacity"");\n        }\n        capacity[id] -= flow;\n        capacity[reverseEdge[id]] += flow;\n    }\n\n    public final boolean flag(int id, int bit) {\n        return (flags[id] >> bit & 1) != 0;\n    }\n\n    public final boolean isRemoved(int id) {\n        return flag(id, REMOVED_BIT);\n    }\n\n    protected void ensureEdgeCapacity(int size) {\n        if (from.length < size) {\n            int newSize = Math.max(size, 2 * from.length);\n            if (edges != null)\n                edges = resize(edges, newSize);\n            from = resize(from, newSize);\n            to = resize(to, newSize);\n            nextOutbound = resize(nextOutbound, newSize);\n            if (nextInbound != null)\n                nextInbound = resize(nextInbound, newSize);\n            if (weight != null)\n                weight = resize(weight, newSize);\n            if (capacity != null)\n                capacity = resize(capacity, newSize);\n            if (reverseEdge != null)\n                reverseEdge = resize(reverseEdge, newSize);\n            flags = resize(flags, newSize);\n        }\n    }\n\n    protected final int[] resize(int[] array, int size) {\n        int[] newArray = new int[size];\n        System.arraycopy(array, 0, newArray, 0, array.length);\n        return newArray;\n    }\n\n    private long[] resize(long[] array, int size) {\n        long[] newArray = new long[size];\n        System.arraycopy(array, 0, newArray, 0, array.length);\n        return newArray;\n    }\n\n    private Edge[] resize(Edge[] array, int size) {\n        Edge[] newArray = new Edge[size];\n        System.arraycopy(array, 0, newArray, 0, array.length);\n        return newArray;\n    }\n\n    public final boolean isSparse() {\n        return vertexCount == 0 || edgeCount * 20 / vertexCount <= vertexCount;\n    }\n\n    protected class GraphEdge implements Edge {\n        protected int id;\n\n        protected GraphEdge(int id) {\n            this.id = id;\n        }\n\n    }\n\n}\n\nclass MinCostFlow {\n    private final Graph graph;\n    private final int source;\n    private final int destination;\n    private final long[] phi;\n    private final long[] dijkstraResult;\n    private final int[] lastEdge;\n    private final Heap heap;\n    private final int vertexCount;\n    private final int[] visited;\n    private int visitIndex;\n\n    public MinCostFlow(Graph graph, int source, int destination, boolean hasNegativeEdges) {\n        this.graph = graph;\n        this.source = source;\n        this.destination = destination;\n        vertexCount = graph.vertexCount();\n        phi = new long[vertexCount];\n        if (hasNegativeEdges)\n            fordBellman();\n        dijkstraResult = new long[vertexCount];\n        lastEdge = new int[vertexCount];\n        if (graph.isSparse()) {\n            heap = new Heap(vertexCount, new IntComparator() {\n                public int compare(int first, int second) {\n                    return IntegerUtils.longCompare(dijkstraResult[first], dijkstraResult[second]);\n                }\n            }, vertexCount);\n            visited = null;\n        } else {\n            heap = null;\n            visited = new int[vertexCount];\n        }\n    }\n\n    private void fordBellman() {\n        Arrays.fill(phi, Long.MAX_VALUE);\n        phi[source] = 0;\n        boolean[] inQueue = new boolean[vertexCount];\n        int[] queue = new int[vertexCount + 1];\n        queue[0] = source;\n        inQueue[source] = true;\n        int stepCount = 0;\n        int head = 0;\n        int end = 1;\n        int maxSteps = 2 * vertexCount * vertexCount;\n        while (head != end) {\n            int vertex = queue[head++];\n            if (head == queue.length)\n                head = 0;\n            inQueue[vertex] = false;\n            int edgeID = graph.firstOutbound(vertex);\n            while (edgeID != -1) {\n                long total = phi[vertex] + graph.weight(edgeID);\n                int destination = graph.destination(edgeID);\n                if (graph.capacity(edgeID) != 0 && phi[destination] > total) {\n                    phi[destination] = total;\n                    if (!inQueue[destination]) {\n                        queue[end++] = destination;\n                        inQueue[destination] = true;\n                        if (end == queue.length)\n                            end = 0;\n                    }\n                }\n                edgeID = graph.nextOutbound(edgeID);\n            }\n            if (++stepCount > maxSteps)\n                throw new IllegalArgumentException(""Graph contains negative cycle"");\n        }\n    }\n\n    public static Pair<Long, Long> minCostMaxFlow(Graph graph, int source, int destination, boolean hasNegativeEdges) {\n        return new MinCostFlow(graph, source, destination, hasNegativeEdges).minCostMaxFlow();\n    }\n\n    public Pair<Long, Long> minCostMaxFlow() {\n        return minCostMaxFlow(Long.MAX_VALUE);\n    }\n\n    public Pair<Long, Long> minCostMaxFlow(long maxFlow) {\n        long cost = 0;\n        long flow = 0;\n        while (maxFlow != 0) {\n            if (graph.isSparse())\n                dijkstraAlgorithm();\n            else\n                dijkstraAlgorithmFull();\n            if (lastEdge[destination] == -1)\n                return Pair.makePair(cost, flow);\n            for (int i = 0; i < dijkstraResult.length; i++) {\n                if (dijkstraResult[i] != Long.MAX_VALUE)\n                    phi[i] += dijkstraResult[i];\n            }\n            int vertex = destination;\n            long currentFlow = maxFlow;\n            long currentCost = 0;\n            while (vertex != source) {\n                int edgeID = lastEdge[vertex];\n                currentFlow = Math.min(currentFlow, graph.capacity(edgeID));\n                currentCost += graph.weight(edgeID);\n                vertex = graph.source(edgeID);\n            }\n            maxFlow -= currentFlow;\n            cost += currentCost * currentFlow;\n            flow += currentFlow;\n            vertex = destination;\n            while (vertex != source) {\n                int edgeID = lastEdge[vertex];\n                graph.pushFlow(edgeID, currentFlow);\n                vertex = graph.source(edgeID);\n            }\n        }\n        return Pair.makePair(cost, flow);\n    }\n\n    private void dijkstraAlgorithm() {\n        Arrays.fill(dijkstraResult, Long.MAX_VALUE);\n        Arrays.fill(lastEdge, -1);\n        dijkstraResult[source] = 0;\n        heap.add(source);\n        while (!heap.isEmpty()) {\n            int current = heap.poll();\n            int edgeID = graph.firstOutbound(current);\n            while (edgeID != -1) {\n                if (graph.capacity(edgeID) != 0) {\n                    int next = graph.destination(edgeID);\n                    long total = graph.weight(edgeID) - phi[next] + phi[current] + dijkstraResult[current];\n                    if (dijkstraResult[next] > total) {\n                        dijkstraResult[next] = total;\n                        if (heap.getIndex(next) == -1)\n                            heap.add(next);\n                        else\n                            heap.shiftUp(heap.getIndex(next));\n                        lastEdge[next] = edgeID;\n                    }\n                }\n                edgeID = graph.nextOutbound(edgeID);\n            }\n        }\n    }\n\n    private void dijkstraAlgorithmFull() {\n        visitIndex++;\n        Arrays.fill(dijkstraResult, Long.MAX_VALUE);\n        lastEdge[destination] = -1;\n        dijkstraResult[source] = 0;\n        for (int i = 0; i < vertexCount; i++) {\n            int index = -1;\n            long length = Long.MAX_VALUE;\n            for (int j = 0; j < vertexCount; j++) {\n                if (visited[j] != visitIndex && dijkstraResult[j] < length) {\n                    length = dijkstraResult[j];\n                    index = j;\n                }\n            }\n            if (index == -1) {\n                return;\n            }\n            visited[index] = visitIndex;\n            int edgeID = graph.firstOutbound(index);\n            while (edgeID != -1) {\n                if (graph.capacity(edgeID) != 0) {\n                    int next = graph.destination(edgeID);\n                    if (visited[next] != visitIndex) {\n                        long total = graph.weight(edgeID) - phi[next] + phi[index] + length;\n                        if (dijkstraResult[next] > total) {\n                                dijkstraResult[next] = total;\n                            lastEdge[next] = edgeID;\n                        }\n                    }\n                }\n                edgeID = graph.nextOutbound(edgeID);\n            }\n        }\n    }\n}\n\nclass Pair<U, V> implements Comparable<Pair<U, V>> {\n    public final U first;\n    public final V second;\n\n    public static<U, V> Pair<U, V> makePair(U first, V second) {\n        return new Pair<U, V>(first, second);\n    }\n\n    private Pair(U first, V second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Pair pair = (Pair) o;\n\n        return !(first != null ? !first.equals(pair.first) : pair.first != null) && !(second != null ? !second.equals(pair.second) : pair.second != null);\n\n    }\n\n    public int hashCode() {\n        int result = first != null ? first.hashCode() : 0;\n        result = 31 * result + (second != null ? second.hashCode() : 0);\n        return result;\n    }\n\n    public String toString() {\n        return ""("" + first + "","" + second + "")"";\n    }\n\n    public int compareTo(Pair<U, V> o) {\n        int value = ((Comparable<U>)first).compareTo(o.first);\n        if (value != 0)\n            return value;\n        return ((Comparable<V>)second).compareTo(o.second);\n    }\n}\n\ninterface Edge {\n}\n\nclass Heap {\n    private IntComparator comparator;\n    private int size = 0;\n    private int[] elements;\n    private int[] at;\n\n    public Heap(int capacity, IntComparator comparator, int maxElement) {\n        this.comparator = comparator;\n        elements = new int[capacity];\n        at = new int[maxElement];\n        Arrays.fill(at, -1);\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public int add(int element) {\n        ensureCapacity(size + 1);\n        elements[size] = element;\n        at[element] = size;\n        shiftUp(size++);\n        return at[element];\n    }\n\n    public void shiftUp(int index) {\n//      if (index < 0 || index >= size)\n//          throw new IllegalArgumentException();\n        int value = elements[index];\n        while (index != 0) {\n            int parent = (index - 1) >>> 1;\n            int parentValue = elements[parent];\n            if (comparator.compare(parentValue, value) <= 0) {\n                elements[index] = value;\n                at[value] = index;\n                return;\n            }\n            elements[index] = parentValue;\n            at[parentValue] = index;\n            index = parent;\n        }\n        elements[0] = value;\n        at[value] = 0;\n    }\n\n    public void shiftDown(int index) {\n        if (index < 0 || index >= size)\n            throw new IllegalArgumentException();\n        while (true) {\n            int child = (index << 1) + 1;\n            if (child >= size)\n                return;\n            if (child + 1 < size && comparator.compare(elements[child], elements[child + 1]) > 0)\n                child++;\n            if (comparator.compare(elements[index], elements[child]) <= 0)\n                return;\n            swap(index, child);\n            index = child;\n        }\n    }\n\n    public int getIndex(int element) {\n        return at[element];\n    }\n\n    private void swap(int first, int second) {\n        int temp = elements[first];\n        elements[first] = elements[second];\n        elements[second] = temp;\n        at[elements[first]] = first;\n        at[elements[second]] = second;\n    }\n\n    private void ensureCapacity(int size) {\n        if (elements.length < size) {\n            int[] oldElements = elements;\n            elements = new int[Math.max(2 * elements.length, size)];\n            System.arraycopy(oldElements, 0, elements, 0, this.size);\n        }\n    }\n\n    public int poll() {\n        if (isEmpty())\n            throw new IndexOutOfBoundsException();\n        int result = elements[0];\n        at[result] = -1;\n        if (size == 1) {\n            size = 0;\n            return result;\n        }\n        elements[0] = elements[--size];\n        at[elements[0]] = 0;\n        shiftDown(0);\n        return result;\n    }\n\n}\n\ninterface IntComparator {\n\n    public int compare(int first, int second);\n}\n\nclass IntegerUtils {\n\n    public static int longCompare(long a, long b) {\n        if (a < b)\n            return -1;\n        if (a > b)\n            return 1;\n        return 0;\n    }\n\n}\n","flows,graph matchings"
"import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n	public static void main(String[] args) throws IOException {\n		new Main().run();\n	}\n\n	BufferedReader in;\n	PrintWriter out;\n	StringTokenizer st = new StringTokenizer("""");\n\n	private void run() throws IOException {\n		if (new File(""input.txt"").exists())\n			in = new BufferedReader(new FileReader(""input.txt""));\n		else\n			in = new BufferedReader(new InputStreamReader(System.in));\n		if (new File(""output.txt"").exists())\n			out = new PrintWriter(""output.txt"");\n		else\n			out = new PrintWriter(System.out);\n\n		solve();\n\n		in.close();\n		out.close();\n	}\n\n	final int maxn = 1000 * 1000 + 100;\n\n	int n, m;\n	char s[];\n	char temp[] = new char[maxn];\n\n	int a[] = new int[maxn];\n\n	int ans[] = new int[maxn];\n	int swap[] = new int[maxn];\n\n	void pow(int a[], int d) {\n		for (int i = 0; i < n; i++)\n			ans[i] = i;\n\n		while (d > 0) {\n			if ((d & 1) > 0) {\n				for (int i = 0; i < n; i++)\n					swap[i] = ans[a[i]];\n				System.arraycopy(swap, 0, ans, 0, n);\n			}\n\n			for (int i = 0; i < n; i++)\n				swap[i] = a[a[i]];\n			System.arraycopy(swap, 0, a, 0, n);\n\n			d >>= 1;\n		}\n\n		System.arraycopy(ans, 0, a, 0, n);\n\n	}\n\n	void shift(int a[], int n, int sh) {\n		System.arraycopy(a, 0, swap, 0, sh);\n		for (int i = 0, j = sh; j < n; i++, j++)\n			a[i] = a[j];\n		System.arraycopy(swap, 0, a, n - sh, sh);\n	}\n\n	void print(int a[], int n) {\n		for (int i = 0; i < n; i++)\n			System.err.print(a[i]);\n		System.err.println();\n	}\n\n	void solve() throws IOException {\n		s = nextToken().toCharArray();\n		n = s.length;\n		m = nextInt();\n		for (int test = 0; test < m; test++) {\n			final int k = nextInt();\n			final int d = nextInt();\n\n//			for (int i = 0; i < n; i++)\n//				a[i] = i;\n//			shift(a, n, 2);\n//			print(a, n);\n//			pow(a, 6);\n//			print(a, n);\n//			System.err.println();\n			\n			int r = 0;\n			int next = 0;\n			for (int i = 0; i < k; i++) {\n				a[i] = next;\n				next += d;\n				if (next >= k)\n					next = ++r;\n			}\n			for (int i = k; i < n; i++)\n				a[i] = i;\n			shift(a, n, 1);\n			\n//			print(a, n);\n\n			pow(a, n - k + 1);\n			shift(a, n, k - 1);\n\n			for (int i = 0; i < n; i++)\n				temp[i] = s[a[i]];\n\n			char swap[] = s;\n			s = temp;\n			temp = swap;\n\n			for (int i = 0; i < n; i++)\n				out.print(s[i]);\n			out.println();\n\n		}\n	}\n\n	class MyComparator implements Comparator<Integer> {\n\n		int d;\n\n		@Override\n		public int compare(Integer o1, Integer o2) {\n			int cmp = Integer.compare(o1 % d, o2 % d);\n			if (cmp != 0)\n				return cmp;\n			return Integer.compare(o1, o2);\n		}\n\n	}\n\n	String nextLine() throws IOException {\n		st = new StringTokenizer("""");\n		return in.readLine();\n	}\n\n	String nextToken() throws IOException {\n		while (!st.hasMoreTokens()) {\n			st = new StringTokenizer(in.readLine());\n		}\n		return st.nextToken();\n	}\n\n	int nextInt() throws IOException {\n		return Integer.parseInt(nextToken());\n	}\n\n	long nextLong() throws IOException {\n		return Long.parseLong(nextToken());\n	}\n\n	double nextDouble() throws IOException {\n		return Double.parseDouble(nextToken());\n	}\n\n	boolean EOF() throws IOException {\n		while (!st.hasMoreTokens()) {\n			String str = in.readLine();\n			if (str == null)\n				return true;\n			st = new StringTokenizer(str);\n		}\n		return false;\n	}\n\n}\n","implementation,math"
"import java.io.*;\nimport java.util.*;\n\npublic class C_new {\n\n    BufferedReader br;\n    PrintWriter out;\n    StringTokenizer st;\n    boolean eof;\n\n    char[] s;\n    int n;\n\n    int[] getTail(int[] p) {\n        int len = 0;\n        for (int i = p.length - 1; i >= 0; i = p[i]) {\n            len++;\n        }\n        int[] ret = new int[len];\n        for (int i = p.length - 1, j = 0; j < len; i = p[i], j++) {\n            ret[j] = i;\n        }\n        return ret;\n    }\n\n    void shuffle(int k, int d) {\n        int[] p = new int[k];\n        for (int i = 0, z = 0; i < d; i++)\n            for (int j = i; j < k; j += d) {\n                p[j] = z++;\n            }\n        for (int i = 0; i < k; i++) {\n            p[i]--;\n        }\n        int[] tail = getTail(p);\n        boolean[] vis = new boolean[k];\n        for (int i = 0; i < tail.length; i++) {\n            vis[tail[i]] = true;\n        }\n        char[] newS = new char[n];\n        Arrays.fill(newS, '*');\n\n        int spins = n - k + 1;\n\n        // initially in tail\n        for (int i = 0; i < tail.length; i++) {\n            if (i + spins >= tail.length) {\n                // end in -1\n                newS[tail.length - 1 - i] = s[tail[i]];\n            } else {\n                // didn't leave tail\n                int endTailPos = i + spins;\n                int endPos = tail[endTailPos];\n                newS[n - k + endPos + 1] = s[tail[i]];\n            }\n        }\n\n//      System.err.println(Arrays.toString(tail));\n        // starts in the end of tail\n        for (int i = k; i < n; i++) {\n            int endTailPos = n - i;\n            // System.err.println(i + "" "" + endTailPos);\n            if (endTailPos >= tail.length) {\n                // ended in -1\n                newS[tail.length - k + i] = s[i];\n            } else {\n                int endPos = tail[endTailPos];\n                newS[n - k + endPos + 1] = s[i];\n            }\n        }\n\n        // cycles left!\n        // this shit works i think...\n        for (int i = 0; i < k; i++) {\n            if (!vis[i]) {\n                int[] c = getCycle(p, i);\n                for (int j = 0; j < c.length; j++) {\n                    vis[c[j]] = true;\n                    int endPosCycle = (j + n - k + 1) % c.length;\n                    int endPos = c[endPosCycle];\n                    newS[n - k + endPos + 1] = s[c[j]];\n                }\n            }\n        }\n        s = newS;\n    }\n\n    int[] getCycle(int[] p, int from) {\n        int len = 1;\n        for (int i = p[from]; i != from; i = p[i]) {\n            len++;\n        }\n        int[] ret = new int[len];\n        ret[0] = from;\n        for (int i = p[from], j = 1; j < len; i = p[i], j++) {\n            ret[j] = i;\n        }\n        return ret;\n    }\n\n    void solve() throws IOException {\n        s = nextToken().toCharArray();\n        n = s.length;\n        int q = nextInt();\n        while (q-- > 0) {\n            int k = nextInt();\n            int d = nextInt();\n            shuffle(k, d);\n            out.println(new String(s));\n        }\n    }\n\n    C_new() throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new C_new();\n    }\n\n    String nextToken() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                eof = true;\n                return null;\n            }\n        }\n        return st.nextToken();\n    }\n\n    String nextString() {\n        try {\n            return br.readLine();\n        } catch (IOException e) {\n            eof = true;\n            return null;\n        }\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n}","implementation,math"
"import java.util.List;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.ArrayList;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		InputReader in = new InputReader(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		TaskC solver = new TaskC();\n		solver.solve(1, in, out);\n		out.close();\n	}\n}\n\nclass TaskC {\n    int[] whichVector, whichPos, from, sum;\n    boolean[] used;\n    ArrayList<Integer>[] cycles;\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        String S = in.nextString();\n\n        int N = S.length(), Q = in.nextInt();\n\n        whichPos = new int[N + 1];\n        whichVector = new int[N + 1];\n        sum = new int[N + 1];\n        used = new boolean[N + 1];\n        cycles = new ArrayList[N];\n        from = new int[N];\n        char[] newS = new char[N];\n        while (Q-- > 0) {\n            int k = in.nextInt(), d = in.nextInt();\n\n            Arrays.fill(sum, 0);\n            for (int i = 0; i < k; ++i)\n                sum[i % d + 1]++;\n            for (int i = 1; i <= d; ++i)\n                sum[i] += sum[i - 1];\n\n            genNextPos(k, d);\n            for (int i = 0; i < N; ++i) {\n                int c = Math.max(0, i - k + 1), o = i < k ? i: k - 1;\n                int cnt = N - Math.max(i, k - 1);\n                int vec = whichVector[o], pos = whichPos[o];\n                int npos;\n                if (vec == 0) {\n                    if (pos + cnt >= cycles[vec].size() - 1) npos = cycles[vec].size() - 1 - pos + c - 1;\n                    else npos = c + cnt + cycles[vec].get(pos + cnt);\n                } else {\n                    npos = c + cnt + cycles[vec].get((pos + cnt) % cycles[vec].size());\n                }\n\n                newS[npos] = S.charAt(i);\n            }\n\n            S = new String(newS);\n            out.println(S);\n        }\n    }\n\n    void genNextPos(int k, int d) {\n        Arrays.fill(used, false);\n        Arrays.fill(from, -1);\n        for (int i = 1; i < k; ++i)\n            from[sum[i % d] + i / d - 1] = i;\n\n        int cnt = 0;\n        for (int i = 0; i < k; ++i) {\n            if (!used[i]) {\n                if (cycles[cnt] != null) cycles[cnt].clear();\n                else cycles[cnt] = new ArrayList<>();\n                for (int j = i; j != -1 && !used[j]; j = from[j]) {\n                    used[j] = true;\n                    cycles[cnt].add(j);\n                }\n                Collections.reverse(cycles[cnt]);\n                if (cnt == 0) cycles[cnt].add(-1);\n\n                int step = 0;\n                for (int p: cycles[cnt]) {\n                    if (p != -1) {\n                        whichVector[p] = cnt;\n                        whichPos[p] = step++;\n                    }\n                }\n                cnt++;\n            }\n        }\n    }\n}\n\nclass InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(nextString());\n    }\n\n    public String nextString() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuffer res = new StringBuffer();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n\n        return res.toString();\n    }\n\n    private boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n    }\n\n}\n\n","implementation,math"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author ilyakor\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskC {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n        char[] s = in.nextToken().toCharArray();\n        int n = s.length;\n        int m = in.nextInt();\n        for (int it = 0; it < m; ++it) {\n            int k = in.nextInt();\n            int d = in.nextInt();\n            int[] p = new int[2 * n];\n            int[] P = new int[k];\n            int cnt = 0;\n            for (int i = 0; i < d; ++i) {\n                for (int j = i; j < k; j += d)\n                    P[cnt++] = j;\n            }\n            for (int i = 0; i < k; ++i)\n                p[n + i - 1] = P[i] + n;\n            for (int i = 0; i < n - 1; ++i)\n                p[i] = i + 1;\n            for (int i = k - 1; i < n; ++i)\n                p[n + i] = (n + i + 1) % (2 * n);\n            p = calcPow(p, n - k + 1);\n            char[] ns = new char[n];\n            for (int i = 0; i < n; ++i)\n               ns[i] = s[p[i  + k - 1] - n];\n            s = ns;\n            out.printLine(new String(s));\n        }\n    }\n\n    private int[] calcPow(int[] p, int k) {\n        int n = p.length;\n        int[] res = new int[n];\n        for (int i = 0; i < n; ++i)\n            res[i] = i;\n        while (k > 0) {\n            if (k % 2 == 1) {\n                res = mult(res, p);\n                --k;\n            } else {\n                p = mult(p, p);\n                k /= 2;\n            }\n        }\n        return res;\n    }\n\n    private int[] mult(int[] p1, int[] p2) {\n        int n = p1.length;\n        int[] res = new int[n];\n        for (int i = 0; i < n; ++i)\n            res[i] = p2[p1[i]];\n        return res;\n    }\n}\n\nclass InputReader {\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n        return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;\n    }\n\n    public int read() {\n        if (count == -1) {\n            throw new InputMismatchException();\n        }\n        try {\n            if (cur >= count) {\n                cur = 0;\n                count = stream.read(buffer);\n                if (count <= 0)\n                    return -1;\n            }\n        } catch (IOException e) {\n            throw new InputMismatchException();\n        }\n        return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n        int c;\n        do {\n            c = read();\n        } while (isSpace(c));\n        return c;\n    }\n\n    public String nextToken() {\n        int c = readSkipSpace();\n        StringBuilder sb = new StringBuilder();\n        while (!isSpace(c)) {\n            sb.append((char) c);\n            c = read();\n        }\n        return sb.toString();\n    }\n\n    public int nextInt() {\n        int sgn = 1;\n        int c = readSkipSpace();\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9') {\n                throw new InputMismatchException();\n            }\n            res = res * 10 + c - '0';\n            c = read();\n        } while (!isSpace(c));\n        res *= sgn;\n        return res;\n    }\n\n}\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0) {\n                writer.print(' ');\n            }\n            writer.print(objects[i]);\n        }\n    }\n\n    public void printLine(Object... objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n}\n","implementation,math"
"import java.util.Scanner;\n \npublic class Main {\n	final static int N = 2000001;\n	public static void main(String args[]) {\n		Scanner in = new Scanner(System.in);\n		int n = in.nextInt();\n		int[] a = new int[N];\n		for (int i = 0; i < n; ++i) {\n			int x = in.nextInt();\n			++a[x];\n		}\n		int[] pre = new int[N];\n		pre[0] = 0;\n		for (int i = 1; i < N; ++i) {\n			if (a[i - 1] > 0) {\n				pre[i] = i - 1;\n			} else pre[i] = pre[i - 1];\n		}\n		int ans = 0;\n		for (int i = 1; i < N; ++i) {\n			if (a[i] == 0) continue;\n			for (int j = i + i; j < N; j += i) {\n				int foo = pre[j];\n				ans = Math.max(ans, foo % i);\n			}\n		}\n		System.out.println(ans);\n		in.close();\n	}\n}","binary search,math,sortings,two pointers"
"import java.util.Scanner;\n \npublic class Main {\n	final static int N = 2000001;\n	public static void main(String args[]) {\n		Scanner in = new Scanner(System.in);\n		int n = in.nextInt();\n		int[] a = new int[N];\n		for (int i = 0; i < n; ++i) {\n			int x = in.nextInt();\n			++a[x];\n		}\n		int[] pre = new int[N];\n		pre[0] = 0;\n		for (int i = 1; i < N; ++i) {\n			if (a[i - 1] > 0) {\n				pre[i] = i - 1;\n			} else pre[i] = pre[i - 1];\n		}\n		int ans = 0;\n		for (int i = 1; i < N; ++i) {\n			if (a[i] == 0) continue;\n			for (int j = i + i; j < N; j += i) {\n				int foo = pre[j];\n				ans = Math.max(ans, foo % i);\n			}\n		}\n		System.out.println(ans);\n		in.close();\n	}\n}","binary search,math,sortings,two pointers"
"import java.util.*;\nimport static java.lang.Character.*;\n \npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int M = 2_000_009;\n        int[] have = new int[M], previous = new int[M];\n        for (int i = 0; i < n; i++) {\n            int x = in.nextInt();\n            have[x] = 1;\n        }\n        for (int i = 2; i < M; i++) {\n            if (have[i] == 1) {\n                previous[i] = i;\n            } else {\n                previous[i] = previous[i - 1];\n            }\n        }\n        int answer = 0;\n        for (int i = 2; i < M; i++) {\n            if (have[i] == 1){\n                for (int j = i + i; j < M; j += i) {\n                    int result = previous[j - 1] % i;\n                    answer = Math.max(answer, result);\n                }\n            }\n        }\n        System.out.println(answer);\n    }\n}","binary search,math,sortings,two pointers"
"import java.util.*;\nimport java.io.*;\n\n\npublic class hello {\n	public static Scanner sc = new Scanner(System.in);\n	public static void take_array(int arr[], int size) {\n		for (int i = 0; i < size; i++)\n			arr[i] = sc.nextInt();\n	}\n	public static void print_arr(int arr[]) {\n		for (int x : arr)\n			System.out.print(x + "" "");\n	}\n	public static void modulo(int arr[], int n) {\n		int Max = 1000000;\n		boolean[] mat = new boolean[2 * Max + 1];\n		for (int i = 0; i < n; i++)\n			mat[arr[i]] = true;\n		int[] maxLast = new int[2 * Max + 1];\n		maxLast[0] = -1;\n		for (int i = 1; i < maxLast.length; i++) {\n			if (mat[i])\n				maxLast[i] = i;\n			else\n				maxLast[i] = maxLast[i - 1];\n		}\n		Arrays.sort(arr);\n		int res = 0;\n		for (int i = 0; i < n; i++) {\n			if (i > 0 && arr[i] == arr[i - 1])\n				continue;\n			int val = arr[i];\n			for (int j = 2 * val - 1; j <= 2 * Max; j = j + val) {\n				int last = maxLast[j];\n				res = Math.max(res, last % val);\n			}\n		}\n		System.out.print(res);\n	}\n	public static void main(String[] args) throws IOException {\n		// int t = sc.nextInt();\n		// while (t-- > 0) {\n		int size = sc.nextInt();\n		int arr[] = new int[size];\n		take_array(arr, size);\n		modulo(arr, size);\n		// }\n	}\n}","binary search,math,sortings,two pointers"
"import java.util.Scanner;\n \npublic class RedGreenTowers {\n \n	private static final int MOD = 1000000007;\n \n	public static void main(String[] args) {\n		Scanner scan = new Scanner(System.in);\n \n		int R = scan.nextInt();\n		int G = scan.nextInt();\n \n		int[][] dp = new int[2][R + 1];\n		int curr = 0;\n		int res = 0;\n		dp[1][0] = 1;\n		for (int h = 1, sum = 1; sum <= R + G; sum += ++h) {\n			int prev = 1 - curr;\n			res = 0;\n			for (int r = Math.max(0, sum - G); r <= R; ++r) {\n				dp[curr][r] = dp[prev][r];\n				if (r - h >= 0) {\n					dp[curr][r] = (dp[curr][r] + dp[prev][r - h]) % MOD;\n				}\n				res = (res + dp[curr][r]) % MOD;\n			}\n			curr = prev;\n		}\n		System.out.println(res);\n	}\n}",dp
"import java.io.*;\nimport java.util.*;\n\n/**\n * @author Tran Anh Tai\n * @template for CP codes\n * What a trick prob!\n */\npublic class ProbB {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(in, out);\n        out.close();\n    }\n    // main solver\n    static class Task {\n        static int MOD = 1000000007;\n        public void solve(InputReader in, PrintWriter out) {\n            int r = in.nextInt();\n            int g = in.nextInt();\n            int h = (int)(Math.sqrt((r + g) << 1));\n            if ((h) * (h + 1) / 2 > (r + g)){\n                h--;\n            }\n            long result = 0;\n            int beg = Math.max(0, h * (h + 1) / 2 - g);\n            int end = Math.min(r, h *(h + 1) / 2);\n            long dp[] = new long[end + 1];\n            dp[0] = 1;\n            for (int level = 1; level <= h; level++){\n                for (int red = end; red >= 0; red--){\n                    if (red >= level){\n                        dp[red] = mod(dp[red] + dp[red - level]);\n                    }\n                }\n            }\n            for (int red = beg; red <= end; red++){\n                result = mod(result + dp[red]);\n            }\n            out.println(result);\n        }\n\n        private long mod(long l) {\n            if (l >= MOD){\n                l -= MOD;\n            }\n            return l;\n        }\n    }\n    // fast input reader class;\n    static class InputReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public InputReader(InputStream stream) {\n            br = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                String line = null;\n                try {\n                    line = br.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (line == null) {\n                    return null;\n                }\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        public long nextLong(){\n            return Long.parseLong(nextToken());\n        }\n    }\n}",dp
"import java.util.*;import java.io.*;import java.math.*;\npublic class Main\n{\n    public static void process()throws IOException\n    {\n        int r=ni();\n        int g=ni();\n        int n=r+g;\n        int x=(int)((Math.sqrt(8*n+1)-1)/2);\n        int c=(n-(x*(x+1))/2);\n        int hi=r,lo=Math.max(0,r-c);\n        long[]temp=new long[hi+1];\n        long[]curr=new long[hi+1];\n        temp[0]=1;\n        for(int i=1;i<=Math.min(hi,x);i++)\n        {\n            for(int j=i;j<=hi;j++)\n                curr[j]=(temp[j]+temp[j-i]);\n            for(int j=i;j<=hi;j++)\n            {\n                temp[j]=curr[j];\n                if(temp[j]>=mod)\n                    temp[j]-=mod;\n            }\n        }\n        long ans=0;\n        for(int i=lo;i<=hi;i++)\n            ans=(ans+temp[i]);\n        pn(ans%mod);\n    }\n    static long mod=(long)1e9+7l;\n    static AnotherReader sc;\n    static PrintWriter out;\n    public static void main(String[]args)throws IOException\n    {\n        boolean oj = System.getProperty(""ONLINE_JUDGE"") != null;\n        if(oj){sc=new AnotherReader();out=new PrintWriter(System.out);}\n        else{sc=new AnotherReader(100);out=new PrintWriter(""output.txt"");}\n        int t=1;\n        // t=ni();\n        while(t-->0) {process();}\n        out.flush();out.close();  \n    }\n\n    static void pn(Object o){out.println(o);}\n    static void p(Object o){out.print(o);}\n    static void pni(Object o){out.println(o);out.flush();}\n    static int ni()throws IOException{return sc.nextInt();}\n    static long nl()throws IOException{return sc.nextLong();}\n    static double nd()throws IOException{return sc.nextDouble();}\n    static String nln()throws IOException{return sc.nextLine();}\n    static int[] nai(int N)throws IOException{int[]A=new int[N];for(int i=0;i!=N;i++){A[i]=ni();}return A;}\n    static long[] nal(int N)throws IOException{long[]A=new long[N];for(int i=0;i!=N;i++){A[i]=nl();}return A;}\n    static long gcd(long a, long b)throws IOException{return (b==0)?a:gcd(b,a%b);}\n    static int gcd(int a, int b)throws IOException{return (b==0)?a:gcd(b,a%b);}\n    static int bit(long n)throws IOException{return (n==0)?0:(1+bit(n&(n-1)));}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    static class AnotherReader{BufferedReader br; StringTokenizer st;\n    AnotherReader()throws FileNotFoundException{\n    br=new BufferedReader(new InputStreamReader(System.in));}\n    AnotherReader(int a)throws FileNotFoundException{\n    br = new BufferedReader(new FileReader(""input.txt""));}\n    String next()throws IOException{\n    while (st == null || !st.hasMoreElements()) {try{\n    st = new StringTokenizer(br.readLine());}\n    catch (IOException  e){ e.printStackTrace(); }}\n    return st.nextToken(); } int nextInt() throws IOException{\n    return Integer.parseInt(next());}\n    long nextLong() throws IOException\n    {return Long.parseLong(next());}\n    double nextDouble()throws IOException { return Double.parseDouble(next()); }\n    String nextLine() throws IOException{ String str = """"; try{\n    str = br.readLine();} catch (IOException e){\n    e.printStackTrace();} return str;}}\n   \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n}",dp
"/**\n * ******* Created  on 25/12/19 8:47 AM*******\n */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class D478 implements Runnable {\n\n    private static final int MAX = 2*(int) (1E5 + 5);\n    private static final int MOD = (int) (1E9 + 7);\n    private static final long Inf = (long) (1E14 + 10);\n\n    private void solve() throws IOException {\n        int r =reader.nextInt();\n        int g =reader.nextInt();\n        if(r > g)\n            r = swap(g, g=r);\n        int n = r+g;\n        int h = 0;\n        while(true ){\n            int sum = h*(h+1)/2;\n            if(sum > n)break;\n            h++;\n        }\n        h--;\n        int ex = (n) - (h*(h+1))/2;\n        int[][] dp = new int[2][MAX];\n        dp[0][0] =1;\n        int cur=0 , prev =1;\n        for(int i =1;i<=h;i++){\n            int sum = Math.min((i*(i+1))/2, MAX-1 );\n            cur =prev;\n            prev = cur==1 ?0:1;\n            for(int j=0;j<=sum;j++){\n                if(j<i) dp[cur][j] = dp[prev][j];\n                else dp[cur][j] = (dp[prev][j] + dp[prev][j-i] ) %MOD;\n            }\n\n        }\n        long ans = 0;\n        for(int i=0;i<=ex && g-i>=0;i++){\n            ans =(ans+ dp[cur][g-i]) %MOD;\n        }\n        writer.println(ans);\n\n    }\n\n    private int swap(int g, int i) {\n        return g;\n    }\n\n    public static void main(String[] args) throws IOException {\n        try (Input reader = new StandardInput(); PrintWriter writer = new PrintWriter(System.out)) {\n            new D478().run();\n        }\n    }\n\n    StandardInput reader;\n    PrintWriter writer;\n\n    @Override\n    public void run() {\n        try {\n            reader = new StandardInput();\n            writer = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    interface Input extends Closeable {\n        String next() throws IOException;\n\n        default int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        default long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        default double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        default int[] readIntArray() throws IOException {\n            return readIntArray(nextInt());\n        }\n\n        default int[] readIntArray(int size) throws IOException {\n            int[] array = new int[size];\n            for (int i = 0; i < array.length; i++) {\n                array[i] = nextInt();\n            }\n            return array;\n        }\n\n        default long[] readLongArray(int size) throws IOException {\n            long[] array = new long[size];\n            for (int i = 0; i < array.length; i++) {\n                array[i] = nextLong();\n            }\n            return array;\n        }\n    }\n\n    private static class StandardInput implements Input {\n        private final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        private StringTokenizer stringTokenizer;\n\n        @Override\n        public void close() throws IOException {\n            reader.close();\n        }\n\n        @Override\n        public String next() throws IOException {\n            if (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {\n                stringTokenizer = new StringTokenizer(reader.readLine());\n            }\n            return stringTokenizer.nextToken();\n        }\n    }\n}\n",dp
"import java.io.*;\nimport java.util.*;\npublic class Main\n{\n	int n;\n	HashMap<String,Word> map;\n	String[] essay;\n	private void solve()throws IOException\n	{\n		n=nextInt();\n		essay=new String[n+1];\n		map=new HashMap<>();\n		for(int i=1;i<=n;i++)\n		{\n			essay[i]=nextToken().toLowerCase();\n			map.put(essay[i],new Word(essay[i]));\n		}\n		int m=nextInt();\n		while(m-->0)\n		{\n			String u=nextToken().toLowerCase();\n			String v=nextToken().toLowerCase();\n			if(!map.containsKey(u))\n				map.put(u,new Word(u));\n			if(!map.containsKey(v))\n				map.put(v,new Word(v));\n			map.get(v).adjList.add(map.get(u));\n		}\n		ArrayList<Word> words=new ArrayList<>(map.values());\n		Collections.sort(words,new Comparator<Word>(){\n			public int compare(Word a,Word b){\n				return a.rcnt==b.rcnt?a.len-b.len:a.rcnt-b.rcnt;\n			}\n		});\n\n		for(Word w:words)\n		{\n			if(w.best!=null)\n				continue;\n			w.best=w;\n			Queue<Word> queue=new LinkedList<>();\n			queue.add(w);\n			while(!queue.isEmpty())\n			{\n				Word x=queue.remove();\n				for(Word ww:x.adjList)\n					if(ww.best==null)\n					{\n						ww.best=w;\n						queue.add(ww);\n					}\n			}\n		}\n\n		long totalr=0,totall=0;\n		for(int i=1;i<=n;i++)\n		{\n			Word syn=map.get(essay[i]).best;\n			totalr+=syn.rcnt;\n			totall+=syn.len;\n		}\n		out.println(totalr+"" ""+totall);\n	}\n	class Word\n	{\n		int rcnt,len;\n		Word best;\n		ArrayList<Word> adjList;\n		Word(String s)\n		{\n			len=s.length();\n			rcnt=0;\n			for(int i=0;i<len;i++)\n				if(s.charAt(i)=='r')\n					rcnt++;\n			best=null;\n			adjList=new ArrayList<>();\n		}\n	}\n\n	 \n	///////////////////////////////////////////////////////////\n\n	public void run()throws IOException\n	{\n		br=new BufferedReader(new InputStreamReader(System.in));\n		st=null;\n		out=new PrintWriter(System.out);\n\n		solve();\n\n		br.close();\n		out.close();\n	}\n	public static void main(String args[])throws IOException{\n		new Main().run();\n	}\n	BufferedReader br;\n	StringTokenizer st;\n	PrintWriter out;\n	String nextToken()throws IOException{\n		while(st==null || !st.hasMoreTokens())\n		st=new StringTokenizer(br.readLine());\n		return st.nextToken();\n	}\n	String nextLine()throws IOException{\n		return br.readLine();\n	}\n	int nextInt()throws IOException{\n		return Integer.parseInt(nextToken());\n	}\n	long nextLong()throws IOException{\n		return Long.parseLong(nextToken());\n	}\n	double nextDouble()throws IOException{\n		return Double.parseDouble(nextToken());\n	}\n}","dfs and similar,dp,graphs,hashing,strings"
"import java.io.*;\nimport java.util.*;\npublic class  Main{\n	static int[]rs,ls,r,len;\n	static ArrayList<Integer>[] adjList;\n	static int V, counter, SCC, dfs_num[], dfs_low[];\n	static boolean[] inSCC;\n	static Stack<Integer> stack;\n	static LinkedList<Integer>[]comp;\n	\n	static void tarjanSCC()	 	//O(V + E)\n	{\n		for(int i = 0; i < V; ++i)\n			if(dfs_num[i] == 0)\n				tarjanSCC(i);\n	}\n	\n	static void tarjanSCC(int u)\n	{\n		dfs_num[u] = dfs_low[u] = ++counter;\n		stack.push(u);\n		\n		for(int v: adjList[u])\n		{\n			if(dfs_num[v] == 0)\n				tarjanSCC(v);\n			if(!inSCC[v])\n				dfs_low[u] = Math.min(dfs_low[u], dfs_low[v]);	\n		}\n		if(dfs_num[u] == dfs_low[u])\n		{\n			//SCC found\n			while(true)\n			{\n				int v = stack.pop();\n				inSCC[v] = true;\n				comp[SCC].add(v);\n				mapc.put(v, SCC);\n				if(v == u)\n					break;\n			}\n			SCC++;\n		}\n	}\n	static HashMap<Integer, Integer>mapc;\n	static boolean[]vis;\n	static void dfs(int i) {\n		if(vis[i])return;\n		vis[i]=true;\n		for(int o:comp[i]) {\n			\n			for(int j:adjList[o]) {\n				dfs(mapc.get(j));\n				if(rs[mapc.get(j)]<rs[i]) {\n					rs[i]=rs[mapc.get(j)];\n					ls[i]=ls[mapc.get(j)];\n				}\n				else {\n					if(rs[mapc.get(j)]==rs[i] && ls[mapc.get(j)]<ls[i]) {\n						ls[i]=ls[mapc.get(j)];\n					}\n				}\n			}\n		}\n	}\n	public static void main(String[] args) throws Exception{\n		MScanner sc=new MScanner(System.in);\n		PrintWriter pw=new PrintWriter(System.out);\n		int n=sc.nextInt();\n		int c=0;\n		HashMap<String, Integer>map=new HashMap<String, Integer>();\n		r=new int[300000];\n		len=new int[300000];\n		String[]in=new String[n];\n		for(int i=0;i<n;i++) {\n			String x=sc.next().toLowerCase();\n			in[i]=x;\n			if(map.containsKey(x))continue;\n			char[]s=x.toCharArray();\n			len[c]=x.length();\n			for(char o:s) {\n				if(o=='r') {\n					r[c]++;\n				}\n			}\n			map.put(x, c++);\n		}\n		int m=sc.nextInt();\n		adjList=new ArrayList[m*2+n];\n		mapc=new HashMap<Integer, Integer>();\n		comp=new LinkedList[m*2+n];\n		for(int i=0;i<adjList.length;i++)adjList[i]=new ArrayList<Integer>();\n		for(int i=0;i<adjList.length;i++)comp[i]=new LinkedList<Integer>();\n		\n		for(int i=0;i<m;i++) {\n			String s1=sc.next().toLowerCase();\n			String s2=sc.next().toLowerCase();\n			char[]s11=s1.toCharArray();\n			char[]s22=s2.toCharArray();\n			if(!map.containsKey(s1)) {\n				len[c]=s1.length();\n				for(char o:s11) {\n					if(o=='r') {\n						r[c]++;\n					}\n				}\n				map.put(s1, c);\n				c++;\n			}\n			if(!map.containsKey(s2)) {\n				len[c]=s2.length();\n				for(char o:s22) {\n					if(o=='r') {\n						r[c]++;\n					}\n				}\n				map.put(s2, c);\n				c++;\n			}\n			adjList[map.get(s1)].add(map.get(s2));\n		}\n		V=c;counter=0;SCC=0;dfs_num=new int[V];dfs_low=new int[V];\n		inSCC=new boolean[V];\n		stack=new Stack<Integer>();\n		tarjanSCC();\n		rs=new int[c];\n		ls=new int[c];\n		Arrays.fill(rs, 10000000);\n		for(int i=0;i<SCC;i++) {\n			int minr=10000000,minl=10000000;\n			for(int j:comp[i]) {\n				if(r[j]<minr) {\n					minr=r[j];\n					minl=len[j];\n				}\n				else {\n					if(r[j]==minr && len[j]<minl) {\n						minl=len[j];\n					}\n				}\n			}\n			rs[i]=minr;\n			ls[i]=minl;\n		}\n		vis=new boolean[V];\n		long ansr=0,ansl=0;\n		for(int i=0;i<n;i++) {\n			int key=mapc.get(map.get(in[i]));\n			dfs(key);\n			ansr+=rs[key];\n			ansl+=ls[key];\n		}\n		pw.println(ansr+"" ""+ansl);\n		pw.flush();\n	}\n	static class MScanner {\n		StringTokenizer st;\n		BufferedReader br;\n		public MScanner(InputStream system) {\n			br = new BufferedReader(new InputStreamReader(system));\n		}\n \n		public MScanner(String file) throws Exception {\n			br = new BufferedReader(new FileReader(file));\n		}\n \n		public String next() throws IOException {\n			while (st == null || !st.hasMoreTokens())\n				st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n		public int[] takearr(int n) throws IOException {\n	        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public long[] takearrl(int n) throws IOException {\n	        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public Integer[] takearrobj(int n) throws IOException {\n	        Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n	        return in;\n		}\n		public Long[] takearrlobj(int n) throws IOException {\n	        Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n	        return in;\n		}\n		public String nextLine() throws IOException {\n			return br.readLine();\n		}\n \n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n \n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n \n		public char nextChar() throws IOException {\n			return next().charAt(0);\n		}\n \n		public Long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n \n		public boolean ready() throws IOException {\n			return br.ready();\n		}\n \n		public void waitForInput() throws InterruptedException {\n			Thread.sleep(3000);\n		}\n	}\n}","dfs and similar,dp,graphs,hashing,strings"
"import java.io.*;\nimport java.util.*;\npublic final class fedor_and_essay\n{\n    static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n	static FastScanner sc=new FastScanner(br);\n    static PrintWriter out=new PrintWriter(System.out);\n	static Random rnd=new Random();\n	static Map<String,Integer> m1=new HashMap<>();\n	static ArrayList<Integer>[] al;\n	static boolean[] v;\n	static int[] dp;\n	\n	static int get(String s)\n	{\n		int cnt=0;\n		for(int i=0;i<s.length();i++)\n		{\n			if(s.charAt(i)=='r')\n			{\n				cnt++;\n			}\n		}\n		return cnt;\n	}\n	\n	static void put(String curr,int idx)\n	{\n		if(m1.get(curr)==null)\n		{\n			m1.put(curr,idx);\n		}\n	}\n	\n	static int get_idx(String curr)\n	{\n		return (m1.get(curr));	\n	}\n	\n	static void dfs(int u,int s)\n	{\n		v[u]=true;dp[u]=s;\n		for(int x:al[u])\n		{\n			if(!v[x])\n			{\n				dfs(x,s);\n			}\n		}\n	}\n	\n	@SuppressWarnings(""unchecked"")\n    public static void main(String args[]) throws Exception\n    {\n		int m=sc.nextInt();String[] a=new String[m];\n		for(int i=0;i<m;i++)\n		{\n			a[i]=sc.next().toLowerCase();\n		}\n		int n=sc.nextInt();String[] b=new String[n],c=new String[n];\n		for(int i=0;i<n;i++)\n		{\n			b[i]=sc.next().toLowerCase();c[i]=sc.next().toLowerCase();\n		}\n		Node[] arr=new Node[n+n+m];int j=0;\n		for(int i=0;i<m;i++)\n		{\n			arr[j++]=new Node(new String(a[i]),get(a[i]),a[i].length());\n		}\n		for(int i=0;i<n;i++)\n		{\n			arr[j++]=new Node(new String(b[i]),get(b[i]),b[i].length());\n			arr[j++]=new Node(new String(c[i]),get(c[i]),c[i].length());\n		}\n		Arrays.sort(arr);al=new ArrayList[n+n+m];\n		for(int i=0;i<n+n+m;i++)\n		{\n			put(arr[i].curr,i);\n			al[i]=new ArrayList<Integer>();\n		}\n		for(int i=0;i<n;i++)\n		{\n			int val1=get_idx(b[i]),val2=get_idx(c[i]);\n			al[val2].add(val1);\n		}\n		dp=new int[n+n+m];v=new boolean[n+n+m];\n		for(int i=0;i<n+n+m;i++)\n		{\n			int curr=get_idx(arr[i].curr);\n			if(!v[curr])\n			{\n				dfs(curr,curr);\n			}\n		}\n		long res1=0,res2=0;\n		for(int i=0;i<m;i++)\n		{\n			res1+=arr[dp[get_idx(a[i])]].a;res2+=arr[dp[get_idx(a[i])]].b;\n		}\n		out.println(res1+"" ""+res2);out.close();\n    }\n}\nclass Node implements Comparable<Node>\n{\n	String curr;int a,b;\n	public Node(String curr,int a,int b)\n	{\n		this.curr=curr;this.a=a;this.b=b;\n	}\n	public int compareTo(Node x)\n	{\n		if(this.a==x.a)\n		{\n			return Integer.compare(this.b,x.b);\n		}\n		return Integer.compare(this.a,x.a);\n	}\n}\nclass FastScanner\n{\n    BufferedReader in;\n    StringTokenizer st;\n\n    public FastScanner(BufferedReader in) {\n        this.in = in;\n    }\n	\n    public String nextToken() throws Exception {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n	\n	public String next() throws Exception {\n		return nextToken().toString();\n	}\n	\n    public int nextInt() throws Exception {\n        return Integer.parseInt(nextToken());\n    }\n\n    public long nextLong() throws Exception {\n        return Long.parseLong(nextToken());\n    }\n\n    public double nextDouble() throws Exception {\n        return Double.parseDouble(nextToken());\n    }\n}","dfs and similar,dp,graphs,hashing,strings"
"import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n\n\n\npublic class Main {\n	\n\n	public static class FastReader {\n		BufferedReader br;\n		StringTokenizer root;\n		\n \n		public FastReader() {\n			br = new BufferedReader(new InputStreamReader(System.in));\n		}\n \n		String next() {\n			while (root == null || !root.hasMoreTokens()) {\n				try {\n					root = new StringTokenizer(br.readLine());\n				} catch (Exception addd) {\n					addd.printStackTrace();\n				}\n			}\n			return root.nextToken();\n		}\n \n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n \n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n \n		long nextLong() {\n			return Long.parseLong(next());\n		}\n \n		String nextLine() {\n			String str = """";\n			try {\n				str = br.readLine();\n			} catch (Exception addd) {\n				addd.printStackTrace();\n			}\n			return str;\n		}\n	}\n	\n	public static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));\n	\n	public static FastReader sc = new FastReader();\n \n	static int mod = (int) (1e9+7),MAX=(int) (2e5);\n    static List<Integer>[] edges;\n    static int[] dp;\n    static boolean[] vis;\n    \n	public static void main(String[] args){\n		int m = sc.nextInt();\n		String[] str = new String[m];\n		for(int i=0;i<m;++i) str[i] = sc.next().toLowerCase();\n		int n = sc.nextInt();\n		String[] u = new String[n];\n		String[] v = new String[n];\n		for(int i=0;i<n;++i) {\n			u[i] = sc.next().toLowerCase();\n			v[i] = sc.next().toLowerCase();\n		}\n		Node[] node = new Node[2*n];\n		int j = 0;\n		for(int i=0;i<n;++i) {\n			node[j++] = new Node(u[i],cntr(u[i]),u[i].length());\n			node[j++] = new Node(v[i],cntr(v[i]),v[i].length());\n		}\n		Arrays.sort(node);\n		\n		edges = new ArrayList[2*n];\n		Map<String,Integer> map = new HashMap<>();\n		j = 0;\n		for(int i=0;i<edges.length;++i) {\n			map.put(node[i].s,j++); // mapping\n			edges[i] = new ArrayList<>();\n		}\n		\n		for(int i=0;i<n;++i) {\n			int uu = map.get(u[i]);\n			int vv = map.get(v[i]);\n			edges[vv].add(uu); // reverse graph\n		}\n		\n		vis = new boolean[2*n];\n		dp = new int[2*n];\n		for(int i=0;i<node.length;++i) {\n			int vv = map.get(node[i].s);\n			if(!vis[vv]) {\n				dfs(vv,vv);\n			}\n		}\n		\n		long r=0,len=0;\n		\n		for(int i=0;i<m;++i) {\n			if(map.containsKey(str[i])) {\n				int idx = map.get(str[i]);\n				r+=node[dp[idx]].r;\n				len+=node[dp[idx]].len;\n			}else {\n			    r+=cntr(str[i]);\n			    len+=str[i].length();\n			}\n		}\n		out.print(r+"" ""+len);\n		out.close();\n	}\n	private static void dfs(int v, int minIdx) {\n		vis[v] = true;\n		dp[v] = minIdx;\n		for(int child : edges[v]) {\n			if(!vis[child])\n				dfs(child,minIdx);\n		}\n		\n	}\n	private static int cntr(String s) {\n		int ans = 0;\n		for(int i=0;i<s.length();++i) \n			if(s.charAt(i) == 'r') ++ans;\n		return ans;\n	}\n	static class Node implements Comparable<Node>{\n		int r,len;\n		String s;\n		\n		Node(String s,int r, int len) {\n			this.s = s;\n			this.r = r;\n			this.len = len;\n		}\n\n		@Override\n		public int compareTo(Node o) {\n			if(this.r!=o.r) return this.r-o.r;\n			return this.len-o.len;\n		}\n		\n	}\n\n}\n\n\n\n","dfs and similar,dp,graphs,hashing,strings"
"\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class main{ \n	 public static void main(String args[])\n	    { \n		 	Scanner sc = new Scanner(System.in);\n		 	int n = sc.nextInt();\n		 	int k = sc.nextInt();\n		 	char[] ch = sc.next().toCharArray();\n		 	int a[] = new int[26];\n		 	for(int i=0;i<ch.length;i++)\n		 	{\n		 		a[ch[i]-'A']++;\n		 	}\n		 	long x=0,ans=0;\n		 	Arrays.sort(a);\n		 	for(int i=25;i>=0;i--)\n		 	{\n		 		x = Math.min(k,a[i]);\n		 		k -=x;\n		 		ans += x*x;\n		 	}\n		 	\n			System.out.println(ans);\n	    \n	    }\n}",greedy
"import java.util.*;\npublic class MyClass {\n    public static void main(String args[]) {\n      Scanner sc = new Scanner(System.in);\n      int n  = sc.nextInt();\n      int k  = sc.nextInt();\n      String s  = sc.next();\n     int[] arr= new int[26];\n     for(char c:  s.toCharArray())\n     {\n         arr[c-'A']++;\n     }\n      Arrays.sort(arr);\n       long sum=0;\n       \n      for(int i=25;i>=0;i--)\n      {\n         long x = Math.min(k,arr[i]);\n         sum+=x*x;\n         k-=x;\n       \n         \n      }\n      System.out.println(sum);\n    }}\n     ",greedy
"import java.util.Arrays;\nimport java.util.Scanner;\npublic class ApplemanAndCardGame {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        sc.nextInt();\n		long k = sc.nextLong(), f[] = new long[26], ans = 0;\n		String s = sc.next();\n        sc.close();\n		for (char ch : s.toCharArray()) f[ch - 'A']++;\n		Arrays.sort(f);\n		for (int i = 25; i >= 0; i--) {\n			if (f[i] == 0 || k == 0) break;\n			else if (f[i] <= k) {\n \n				ans += (f[i] * f[i]);\n				k -= f[i];\n			}\n            else {\n				ans += (k * k);\n				break;\n			}\n		}\n		System.out.println(ans);\n    }\n}",greedy
"import java.util.*;\n\npublic class Test {\n\n	static Scanner sc;\n\n	public static void main(String[] args) {\n\n		sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int k = sc.nextInt();\n		char[] str = sc.next().toCharArray();\n		int[] cnt = new int[26];\n\n		for (char ch : str) {\n			cnt[ch - 'A']++;\n		}\n		PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n		for (int i = 0; i < 26; i++) {\n			pq.add(cnt[i]);\n		}\n\n		long ans = 0;\n		while (k > 0 && !pq.isEmpty()) {\n			long letter = pq.poll();\n			letter = Math.min(letter, k);\n			ans += letter * letter;\n			k -= letter;\n		}\n		System.out.println(ans);\n\n	}\n}\n",greedy
"import java.io.PrintWriter;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\n\n\npublic class Main {\n    static int inf = (int)(2e9+1e8);\n    static double eps = 1e-9;\n    static double PI = Math.acos(-1.0);\n    static int N = 905;\n    int n, r, ans, cnt;\n    int[] tx = new int[N], ty = new int[N];\n    class point implements Comparable<point> {\n    	int x, y, d;\n    	point(int nx, int ny) {\n    		x = nx;\n    		y = ny;\n    		d = x*x+y*y;\n    	}\n		@Override\n		public int compareTo(point o) {\n			// TODO Auto-generated method stub\n			return ((Integer)(o.d)).compareTo(d);\n//			if(d != o.d) {	\n//				return ((Integer)(d)).compareTo(o.d);\n//			} else {\n//				if(x != o.x) {	\n//					return ((Integer)(x)).compareTo(o.x);\n//				} else {\n//					return ((Integer)(y)).compareTo(o.y);					\n//				}\n//			}\n		}\n    }\n    point[] p = new point[N], a = new point[N];\n  //  ArrayList<point> a = new ArrayList(), p = new ArrayList();\n    void dfs(int f,int s) {\n        int i,j;\n        if(s==n) {\n            int add=0;\n            for(i=0;i<s;i++) {\n                for(j=i+1;j<s;j++)\n                    add+=(tx[i]-tx[j])*(tx[i]-tx[j])+(ty[i]-ty[j])*(ty[i]-ty[j]);\n            }\n            if(add>ans) {\n                ans=add;\n                for(i=0;i<s;i++) {\n                    a[i] = new point(tx[i], ty[i]);\n                }\n            }\n            return;\n        }\n        for(i=f;i<17&&i<cnt;i++) {\n            tx[s] = p[i].x;\n            ty[s] = p[i].y;\n            dfs(i,s+1);\n        }\n    }\n    void work() {\n    	n = cin.nextInt();\n    	r = cin.nextInt();\n    	ans = 0;\n    	cnt = 0;\n    	for(int i=-r;i<=r;i++)\n            for(int j=-r;j<=r;j++) {\n                if(i*i+j*j<=r*r&&i*i+j*j>(r-1)*(r-1)) {\n                	p[cnt++] = new point(i, j);   \n                }\n            }    	\n    	Arrays.sort(p, 0, cnt);\n//    	for(int i = 0; i < cnt; i ++) {\n//    		System.out.println(p[i].x + "" "" + p[i].y + "" "" + p[i].d);\n//    	}\n    	dfs(0, 0);    	\n    	out.println(ans);\n		for(int i=0;i<n;i++) {\n			out.println(a[i].x + "" "" + a[i].y);\n		}\n		\n        out.close();\n    }   \n    Main() {\n        out = new PrintWriter(System.out);\n        cin = new Scanner(System.in);\n    }\n\n    public static void main(String[] args) {\n        Main wo = new Main();\n        wo.work();\n    }\n    DecimalFormat df=new DecimalFormat(""0.000000"");\n    public Scanner cin;\n    public PrintWriter out;\n}","brute force,geometry,math,sortings"
"import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Task {\n\n    static Point[] a;\n    static int sum;\n    static int[] took;\n    static int[] ans;\n    static int size;\n\n    static void go(int need, int last) {\n        if (need == 0) {\n            int ret = 0;\n            for (int i = 0; i < size; ++i) {\n                for (int j = i + 1; j < size; ++j) {\n                    ret += a[took[i]].sub(a[took[j]]).len2();\n                }\n            }\n            if (ret > sum) {\n                sum = ret;\n                ans = Arrays.copyOf(took, size);\n            }\n        } else {\n            ++size;\n            for (int i = last; i < a.length; ++i) {\n                took[size - 1] = i;\n                go(need - 1, i);\n            }\n            --size;\n        }\n    }\n\n    public void solve() throws IOException {\n        int n = in.nextInt();\n        int r = in.nextInt();\n        a = new Point[3000];\n        int s = 0;\n        for (int i = 0; i <= r; ++i) {\n            for (int j = 0; i * i + j * j <= r * r; ++j) {\n                a[s++] = new Point(i, j);\n                if (i > 0) a[s++] = new Point(-i, j);\n                if (i > 0 & j > 0) a[s++] = new Point(-i, -j);\n                if (j > 0) a[s++] = new Point(i, -j);\n            }\n        }\n        a = Point.convexHull(Arrays.copyOf(a, s));\n        took = new int[n];\n        for (int i = 0; i < n / 2 - 1; ++i) {\n            took[size++] = 0;\n        }\n        go(n - n / 2 + 1, 0);\n        out.println(sum);\n        for (int i : ans) {\n            out.println(a[i].x + "" "" + a[i].y);\n        }\n    }\n\n    static FastReader in;\n    static PrintWriter out;\n    static PrintStream err;\n\n    public static void main(String[] args) throws IOException {\n        try {\n            in = new FastReader();\n            out = new PrintWriter(System.out);\n            err = System.err;\n            new Task().solve();\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n}\n\nclass FastReader {\n    BufferedReader br;\n    StringTokenizer in;\n\n    FastReader() {\n        this.br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    FastReader(String filename) {\n        try {\n            this.br = new BufferedReader(new FileReader(filename));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    public String nextToken() throws IOException {\n        while (in == null || !in.hasMoreTokens()) {\n            in = new StringTokenizer(br.readLine());\n        }\n\n        return in.nextToken();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n}\n\nclass Point implements Comparable<Point> {\n    int x;\n    int y;\n\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int mulv(Point a) {\n        return this.x * a.y - this.y * a.x;\n    }\n\n    public int len2() {\n        return x * x + y * y;\n    }\n\n    public int compareTo(Point o) {\n        if (o == null) {\n            return -1;\n        }\n        int m = this.mulv(o);\n        if (m != 0) {\n            return m > 0 ? -1 : 1;\n        }\n        int d = this.len2() - o.len2();\n        return d > 0 ? 1 : d < 0 ? -1 : 0;\n    }\n\n    public Point sub(Point a) {\n        return new Point(this.x - a.x, this.y - a.y);\n    }\n\n    public Point add(Point a) {\n        return new Point(this.x + a.x, this.y + a.y);\n    }\n\n    public static Point[] convexHull(Point[] a) {\n        int n = a.length;\n        int mn = 0;\n        for (int i = 1; i < n; ++i) {\n            if (a[i].x < a[mn].x || (a[i].x == a[mn].x && a[i].y < a[mn].y)) {\n                mn = i;\n            }\n        }\n        Point start = a[mn];\n        a[mn] = a[0];\n        a[0] = start;\n        Point[] b = new Point[n - 1];\n        for (int i = 0; i < n - 1; ++i) {\n            b[i] = a[i + 1].sub(start);\n        }\n        Arrays.sort(b);\n        for (int i = 0; i < n - 1; ++i) {\n            a[i + 1] = b[i].add(start);\n        }\n        Point[] h = new Point[n];\n        int size = 0;\n        for (int i = 0; i < n; ++i) {\n            while (size > 1 && h[size - 1].sub(h[size - 2]).compareTo(a[i].sub(h[size - 2])) == 1) {\n                --size;\n            }\n            h[size++] = a[i];\n        }\n        return Arrays.copyOf(h, size);\n    }\n}\n","brute force,geometry,math,sortings"
"import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Task {\n\n    static Point[] a;\n    static int sum;\n    static int[] took;\n    static int[] ans;\n    static int size;\n    static int[][] d;\n\n    static void go(int need, int last, int cur) {\n        if (need == 0) {\n            if (cur > sum) {\n                sum = cur;\n                ans = Arrays.copyOf(took, size);\n            }\n        } else {\n            ++size;\n            for (int i = last; i < a.length; ++i) {\n                took[size - 1] = i;\n                int now = 0;\n                for (int j = 0; j < size - 1; ++j) {\n                    now += d[took[j]][i];\n                }\n                go(need - 1, i, cur + now);\n            }\n            --size;\n        }\n    }\n\n    public void solve() throws IOException {\n        int n = in.nextInt();\n        int r = in.nextInt();\n        a = new Point[3000];\n        int s = 0;\n        for (int i = 0; i <= r; ++i) {\n            for (int j = 0; i * i + j * j <= r * r; ++j) {\n                a[s++] = new Point(i, j);\n                if (i > 0) a[s++] = new Point(-i, j);\n                if (i > 0 & j > 0) a[s++] = new Point(-i, -j);\n                if (j > 0) a[s++] = new Point(i, -j);\n            }\n        }\n        a = Point.convexHull(Arrays.copyOf(a, s));\n        d = new int[a.length][a.length];\n        for (int i = 0; i < a.length; ++i) {\n            for (int j = 0; j < a.length; ++j) {\n                d[i][j] = a[i].sub(a[j]).len2();\n            }\n        }\n        took = new int[n];\n        go(n, 0, 0);\n        out.println(sum);\n        for (int i : ans) {\n            out.println(a[i].x + "" "" + a[i].y);\n        }\n    }\n\n    static FastReader in;\n    static PrintWriter out;\n    static PrintStream err;\n\n    public static void main(String[] args) throws IOException {\n        try {\n            in = new FastReader();\n            out = new PrintWriter(System.out);\n            err = System.err;\n            new Task().solve();\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n}\n\nclass FastReader {\n    BufferedReader br;\n    StringTokenizer in;\n\n    FastReader() {\n        this.br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    FastReader(String filename) {\n        try {\n            this.br = new BufferedReader(new FileReader(filename));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    public String nextToken() throws IOException {\n        while (in == null || !in.hasMoreTokens()) {\n            in = new StringTokenizer(br.readLine());\n        }\n        return in.nextToken();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n}\n\nclass Point {\n    int x;\n    int y;\n\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int mulv(Point a) {\n        return this.x * a.y - this.y * a.x;\n    }\n\n    public int len2() {\n        return x * x + y * y;\n    }\n\n    public Point sub(Point a) {\n        return new Point(this.x - a.x, this.y - a.y);\n    }\n\n    public Point add(Point a) {\n        return new Point(this.x + a.x, this.y + a.y);\n    }\n\n    public static Point[] convexHull(Point[] a) {\n        int n = a.length;\n        int mn = 0;\n        for (int i = 1; i < n; ++i) {\n            if (a[i].x < a[mn].x || (a[i].x == a[mn].x && a[i].y < a[mn].y)) {\n                mn = i;\n            }\n        }\n        Point start = a[mn];\n        a[mn] = a[0];\n        a[0] = start;\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i].sub(start);\n        }\n        Arrays.sort(a, 1, a.length, new Comparator<Point>() {\n            @Override\n            public int compare(Point o1, Point o2) {\n                int m = o1.mulv(o2);\n                if (m != 0) {\n                    return m > 0 ? -1 : 1;\n                }\n                int d = o1.len2() - o2.len2();\n                return d > 0 ? 1 : d < 0 ? -1 : 0;\n            }\n        });\n        for (int i = 1; i < n; ++i) {\n            a[i] = a[i].add(start);\n        }\n        Point[] h = new Point[n];\n        int size = 0;\n        for (int i = 0; i < n; ++i) {\n            while (size > 1 && h[size - 1].sub(h[size - 2]).mulv(a[i].sub(h[size - 2])) <= 0) {\n                --size;\n            }\n            h[size++] = a[i];\n        }\n        return Arrays.copyOf(h, size);\n    }\n}\n","brute force,geometry,math,sortings"
"import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Task implements Runnable {\n\n    static Point[] a;\n    static int sum;\n    static int[] took;\n    static int[] ans;\n    static int size;\n\n    static void go(int need, int last) {\n        if (need == 0) {\n            int ret = 0;\n            for (int i = 0; i < took.length; ++i) {\n                for (int j = i + 1; j < took.length; ++j) {\n                    ret += a[took[i]].sub(a[took[j]]).len2();\n                }\n            }\n            if (ret > sum) {\n                sum = ret;\n                ans = Arrays.copyOf(took, size);\n            }\n            return;\n        }\n        for (int i = last; i < a.length; ++i) {\n            took[size++] = i;\n            go(need - 1, i);\n            --size;\n        }\n    }\n\n    public void solve() throws IOException {\n        int n = in.nextInt();\n        int r = in.nextInt();\n        a = new Point[3000];\n        int size = 0;\n        for (int i = 0; i <= r; ++i) {\n            for (int j = 0; i * i + j * j <= r * r; ++j) {\n                a[size++] = new Point(i, j);\n                if (i > 0) a[size++] = new Point(-i, j);\n                if (i > 0 & j > 0) a[size++] = new Point(-i, -j);\n                if (j > 0) a[size++] = new Point(i, -j);\n            }\n        }\n        a = Point.convexHull(Arrays.copyOf(a, size));\n        took = new int[n];\n        for (int i = 0; i < n / 2 - 1; ++i) {\n            took[Task.size++] = 0;\n        }\n        go(n - n / 2 + 1, 0);\n        out.println(sum);\n        for (int i : ans) {\n            out.println(a[i].x + "" "" + a[i].y);\n        }\n    }\n\n    public void run() {\n        try {\n            in = new FastReader();\n            out = new PrintWriter(System.out);\n            solve();\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    static FastReader in;\n    static PrintWriter out;\n\n    public static void main(String[] args) throws IOException {\n        new Task().run();\n    }\n\n}\n\nclass FastReader {\n    BufferedReader br;\n    StringTokenizer in;\n\n    FastReader() {\n        this.br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    FastReader(String filename) {\n        try {\n            this.br = new BufferedReader(new FileReader(filename));\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    public String nextToken() throws IOException {\n        while (in == null || !in.hasMoreTokens()) {\n            in = new StringTokenizer(br.readLine());\n        }\n\n        return in.nextToken();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n}\n\nclass Point implements Comparable<Point> {\n    int x;\n    int y;\n\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public Point add(Point a) {\n        return new Point(this.x + a.x, this.y + a.y);\n    }\n\n    public int mulv(Point a) {\n        return this.x * a.y - this.y * a.x;\n    }\n\n    public int len2() {\n        return x * x + y * y;\n    }\n\n    public int compareTo(Point o) {\n        if (o == null) {\n            return -1;\n        }\n        int m = this.mulv(o);\n        if (m != 0) {\n            return m > 0 ? -1 : 1;\n        }\n        int d = this.len2() - o.len2();\n        return d > 0 ? 1 : d < 0 ? -1 : 0;\n    }\n\n    public Point sub(Point a) {\n        return new Point(this.x - a.x, this.y - a.y);\n    }\n\n    public static Point[] convexHull(Point[] a) {\n        int n = a.length;\n        int mn = 0;\n        for (int i = 1; i < n; ++i) {\n            if (a[i].x < a[mn].x || (a[i].x == a[mn].x && a[i].y < a[mn].y)) {\n                mn = i;\n            }\n        }\n        Point start = a[mn];\n        a[mn] = a[0];\n        a[0] = start;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 2; j < n; ++j) {\n                if (a[j].sub(start).compareTo(a[j - 1].sub(start)) == -1) {\n                    Point tmp = a[j];\n                    a[j] = a[j - 1];\n                    a[j - 1] = tmp;\n                }\n            }\n        }\n        Point[] h = new Point[n];\n        int size = 0;\n        for (int i = 0; i < n; ++i) {\n            while (size > 1 && h[size - 1].sub(h[size - 2]).compareTo(a[i].sub(h[size - 2])) == 1) {\n                --size;\n            }\n            h[size++] = a[i];\n        }\n        return Arrays.copyOf(h, size);\n    }\n}\n","brute force,geometry,math,sortings"
"import java.io.*;\nimport java.util.*;\n\npublic class pashmak {\n    public static class FenwickTree {\n        long[] ft;\n        public FenwickTree(int n) {\n            ft = new long[n + 1];\n        }\n\n        long rsq(int b) {\n            long sum = 0;\n            for (; b > 0; b -= (b & (-b))){\n                sum += ft[b];\n            }\n            return sum;\n        }\n\n        long rsq(int a, int b) {\n            return rsq(b) - rsq(a - 1);\n        }\n\n        void update(int k, long v) {\n            for (; k < ft.length; k += (k & (-k))) ft[k] += v;\n        }\n    }\n\n    public static void main (String[] args) throws IOException{\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        String[] d = in.readLine().split("" "");\n        int N = Integer.parseInt(d[0]);\n\n        int[] arr = new int[N];\n        int[] copy = new int[N];\n\n        d = in.readLine().split("" "");\n\n        for (int i = 0; i < N; i++){\n            arr[i] = Integer.parseInt(d[i]);\n            copy[i] = arr[i];\n        }\n\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int curr = 1;\n\n        for (int i = 0; i < N; i++){\n            if (!map.containsKey(copy[i])){\n                map.put(copy[i], curr);\n                curr++;\n            }\n        }\n        for (int i = 0; i < N; i++){\n            arr[i] = map.get(arr[i]);\n        }\n        \n        int[] upd = new int[N+1];\n\n        int[] pref = new int[N];\n        int[] suff = new int[N];\n        \n        for (int i = 0; i < N; i++){\n             upd[arr[i]]++;\n             pref[i] = upd[arr[i]];\n        }\n\n        upd = new int[N+1];\n\n        for (int i = N-1; i >= 0; i--){\n            upd[arr[i]]++;\n            suff[i] = upd[arr[i]];\n        }\n\n        FenwickTree ft = new FenwickTree(N);\n        long ans = 0;\n\n        for (int i = N-1; i >= 0; i--){\n            ans += ft.rsq(pref[i]-1);\n            ft.update(suff[i], 1);\n        }\n\n        System.out.println(ans);\n\n    }\n}\n","data structures,divide and conquer,sortings"
"/*\nhttps://codeforces.com/problemset/problem/459/D\n*/ \nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n    static int n;\n    static int[] fenwick;\n\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        n = scan.nextInt();\n        long[] arr = new long[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = scan.nextLong();\n        }\n\n        /*\n         * Number compression\n         */\n        /*long[] tempCopy = new long[n];\n        for (int i = 0; i < n; i++) {\n            tempCopy[i] = temp[i];\n        }\n        Arrays.sort(tempCopy);\n        int count = 1;\n        Map<Long, Integer> map = new HashMap<>();\n        map.put(tempCopy[0], count);\n        for (int i = 1; i < n; i++) {\n            if (tempCopy[i] != tempCopy[i - 1]) {\n                count++;\n            }\n            map.put(tempCopy[i], count);\n        }\n\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = map.get(temp[i]);\n        }\n        */\n        fenwick = new int[n + 1];\n\n        int[] l = new int[n];\n        int[] r = new int[n];\n        int[] cnt = new int[n + 1]; // cnt[i] counts frequency of r[j] = i\n\n        // count the frequency of r[j] values\n        Map<Long, Integer> freqOfR = new HashMap<>();\n        for (int i = n - 1; i >= 0; i--) {\n            if (freqOfR.containsKey(arr[i])) {\n                freqOfR.put(arr[i], freqOfR.get(arr[i]) + 1);\n            } else {\n                freqOfR.put(arr[i], 1);\n            }\n            r[i] = freqOfR.get(arr[i]);\n            update(r[i], 1); // use Fenwick tree to count frequency of r[i] values (cumulative frequency)\n        }\n\n        Map<Long, Integer> freqOfL = new HashMap<>();\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            if (freqOfL.containsKey(arr[i])) {\n                freqOfL.put(arr[i], freqOfL.get(arr[i]) + 1);\n            } else {\n                freqOfL.put(arr[i], 1);\n            }\n            l[i] = freqOfL.get(arr[i]);\n            update(r[i], -1);\n            res += get(l[i] - 1);\n        }\n\n        System.out.println(res);\n\n    }\n\n    private static void update(int index, int val) {\n        while (index <= n) {\n            fenwick[index] += val;\n            index += (index & (-index));\n        }\n    }\n\n    private static int get(int p) {\n        int ans = 0;\n        while (p > 0) {\n            ans += fenwick[p];\n            p -= (p & (-p));\n        }\n        return ans;\n    }\n\n}\n","data structures,divide and conquer,sortings"
"import java.io.*; \nimport java.util.*;\nimport java.math.*; \n\npublic class Main {\n	static class BIT {\n		int n;\n		int[] tree;\n		\n		public BIT(int n) {\n			this.n = n;\n			tree = new int[n + 2];\n		}\n		\n		int read(int i) {\n			i++;\n			int sum = 0;\n			while (i > 0) {\n				sum += tree[i];\n				i -= i & -i;\n			}\n			return sum;\n		}\n		\n		void update(int i, int val) {\n			i++;\n			while (i <= n) {\n				tree[i] += val;\n				i += i & -i;\n			}\n		}\n	}\n	public static void main(String[] args) throws IOException \n	{ \n		FastScanner f = new FastScanner(); \n		int t=1;\n//		t=f.nextInt();\n		PrintWriter out=new PrintWriter(System.out);\n		while(t>0) {\n			t--;\n			int n=f.nextInt();\n			int[] l=f.readArray(n);\n			HashMap<Integer,Integer> h=new HashMap<>();\n			int[] left=new int[n];\n			int[] right=new int[n];\n			for(int i=0;i<n;i++) {\n				if(h.containsKey(l[i])) {\n					h.put(l[i], h.get(l[i])+1);\n				}\n				else {\n					h.put(l[i],1);\n				}\n				left[i]=h.get(l[i]);\n			}\n			h.clear();\n			for(int i=n-1;i>-1;i--) {\n				if(h.containsKey(l[i])) {\n					h.put(l[i], h.get(l[i])+1);\n				}\n				else {\n					h.put(l[i],1);\n				}\n				right[i]=h.get(l[i]);\n			}\n			int max=1000005;\n			BIT bit=new BIT(max);\n			long ans=0;\n			for(int i=0;i<n;i++) {\n				ans+=bit.read(max)-bit.read(right[i]);\n				bit.update(left[i],1);\n//				for(int j=0;j<bit.tree.length;j++) {\n//					System.out.print(bit.tree[i]+"" "");\n//				}\n//				System.out.println();\n			}\n			System.out.println(ans);\n		}\n		out.close();\n	} \n	static void sort(int [] a) {\n        ArrayList<Integer> q = new ArrayList<>();\n        for (int i: a) q.add(i);\n        Collections.sort(q);\n        for (int i = 0; i < a.length; i++) a[i] = q.get(i);\n    }\n    \n	static class FastScanner {\n		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st=new StringTokenizer("""");\n		String next() {\n			while (!st.hasMoreTokens())\n				try {\n					st=new StringTokenizer(br.readLine());\n				} catch (IOException e) {\n					e.printStackTrace();\n				}\n			return st.nextToken();\n		}\n		\n		int nextInt() {\n			return Integer.parseInt(next());\n		}\n		int[] readArray(int n) {\n			int[] a=new int[n];\n			for (int i=0; i<n; i++) a[i]=nextInt();\n			return a;\n		}\n		long nextLong() {\n			return Long.parseLong(next());\n		}\n		double nextDouble() {\n			return Double.parseDouble(next());\n		}\n		long[] readLongArray(int n) {\n			long[] a=new long[n];\n			for (int i=0; i<n; i++) a[i]=nextLong();\n			return a;\n		}\n	}\n} 	","data structures,divide and conquer,sortings"
"import java.util.*;\nimport java.io.*;\n\npublic class pashmacksproblem {\n	public static void main(String args[]) throws IOException {\n		FastScanner in = new FastScanner(System.in);\n		PrintWriter out = new PrintWriter(System.out);\n		int n = in.nextInt();\n		int[] vals = new int[n];\n\n		int[][] sort = new int[n][2];\n		for (int i = 0; i < n; i++) {\n			vals[i] = in.nextInt();\n			sort[i] = new int[] {vals[i], i};\n		}\n		\n		Arrays.sort(sort, (a,b)->a[0]-b[0]);\n		\n		int[] index = new int[n];\n		Arrays.fill(index, -1);\n		int c = -1;\n		int last = -1;\n		for (int i = 0; i < n; i++) {\n			if (sort[i][0] != last) {\n				c++;\n				last = sort[i][0];\n			}\n			vals[sort[i][1]] = c;\n		}\n		\n		int[] cnt = new int[n];\n		int[] pre = new int[n];\n		\n		for (int i = 0; i < n; i++) {\n			cnt[vals[i]]++;\n			pre[i] = cnt[vals[i]];\n		}\n		cnt = new int[n];\n		int[] suff = new int[n];\n		for (int i = n - 1; i >= 0; i--) {\n			cnt[vals[i]]++;\n			suff[i] = cnt[vals[i]];\n		}\n		\n		// System.out.println(Arrays.toString(pre));\n		// System.out.println(Arrays.toString(suff));\n		\n		BIT bit = new BIT(n);\n		long ans = 0;\n		for (int i = n - 1; i >= 0; i--) {\n			long amt = bit.query(1, pre[i] - 1);\n			bit.update(suff[i], 1);\n			ans += amt;\n			// System.out.println(i + "" "" + amt);\n		}\n		\n		out.println(ans);\n		\n		out.close();\n	}\n\n	\n	static class BIT {\n		int n;\n		long tree[];\n		\n		public String toString() {\n			return Arrays.toString(tree);\n		}\n		\n		public BIT(int N) {\n			n = N;  tree = new long[N + 1];\n		}\n		void update(int i, long val) {\n			for (i++; i <= n; i += i & -i) tree[i] += val;\n		}\n		long read(int i) {\n			long sum = 0;\n			for (i++; i > 0; i -= i & -i) sum += tree[i];\n			return sum;\n		}\n		// query sum of [l, r] inclusive\n		long query(int l, int r) { return read(r) - read(l - 1); }\n		// if the BIT is a freq array, returns the index of the\n		// kth item (0-indexed), or n if there are <= k items.\n		int getKth(int k) {\n			if (k < 0) return -1;\n			int i = 0;\n			for (int pw = Integer.highestOneBit(n); pw > 0; pw >>= 1)\n				if (i + pw <= n && tree[i + pw] <= k) k -= tree[i += pw];\n			return i;\n		}\n	}\n	\n	\n	static class FastScanner {\n		BufferedReader br;\n		StringTokenizer st;\n\n		public FastScanner(InputStream i) {\n			br = new BufferedReader(new InputStreamReader(i));\n			st = new StringTokenizer("""");\n		}\n\n		public String next() throws IOException {\n			if (st.hasMoreTokens())\n				return st.nextToken();\n			else\n				st = new StringTokenizer(br.readLine());\n			return next();\n		}\n\n		public int nextInt() throws IOException {\n			return Integer.parseInt(next());\n		}\n\n		public long nextLong() throws IOException {\n			return Long.parseLong(next());\n		}\n\n		public double nextDouble() throws IOException {\n			return Double.parseDouble(next());\n		}\n	}\n}\n","data structures,divide and conquer,sortings"
"import java.util.*;\nimport java.io.*;\npublic class c {\npublic static void main(String[] args) throws IOException\n{\n    input.init(System.in);\n    int n = input.nextInt();\n    Voter[] data = new Voter[n];\n    for(int i = 0; i<n; i++) data[i] = new Voter(input.nextInt(), input.nextInt());\n    Arrays.sort(data);\n    int lo = 1, hi = n;\n    while(lo < hi - 3)\n    {\n        int mid = (lo+hi)/2;\n        if(go(mid, data) < go(mid+1, data)) hi = mid+1;\n        else lo = mid;\n    }\n    long res = (long)1e12;\n    for(int i = lo; i<=hi; i++) res = Math.min(res, go(i, data));\n    System.out.println(res);\n}\nstatic long go(int votes, Voter[] data)\n{\n    int n = data.length;\n    int[] counts = new int[100001];\n    for(Voter v : data) counts[v.a]++;\n    long res = 0;\n    boolean[] paid = new boolean[n];\n    int soFar = counts[0];\n    for(int i = 0; i<n; i++)\n    {\n        if(counts[data[i].a] >= votes && data[i].a != 0)\n        {\n            soFar++;\n            paid[i] = true;\n            res += data[i].b;\n            counts[data[i].a]--;\n        }\n    }\n    for(int i = 0; i<n; i++)\n    {\n        if(!paid[i] && soFar < votes && data[i].a != 0)\n        {\n            paid[i] = true;\n            soFar++;\n            res += data[i].b;\n        }\n    }\n    return res;\n}\nstatic class Voter implements Comparable<Voter>\n{\n    int a, b;\n    public Voter(int aa, int bb)\n    {\n        a = aa; b = bb;\n    }\n    @Override\n    public int compareTo(Voter o) {\n        // TODO Auto-generated method stub\n        return b - o.b;\n    }\n}\npublic static class input {\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    /** call this method to initialize reader for InputStream */\n    static void init(InputStream input) {\n        reader = new BufferedReader(\n                     new InputStreamReader(input) );\n        tokenizer = new StringTokenizer("""");\n    }\n\n    /** get next word */\n    static String next() throws IOException {\n        while ( ! tokenizer.hasMoreTokens() ) {\n            //TODO add check for eof if necessary\n            tokenizer = new StringTokenizer(\n                   reader.readLine() );\n        }\n        return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt( next() );\n    }\n    \n    static double nextDouble() throws IOException {\n        return Double.parseDouble( next() );\n    }\n    static long nextLong() throws IOException {\n        return Long.parseLong( next() );\n    }\n}\n}\n",brute force
"import java.util.Arrays;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Rubanenko\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		InputReader in = new InputReader(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		TaskC solver = new TaskC();\n		solver.solve(1, in, out);\n		out.close();\n	}\n}\n\nclass TaskC {\n\n\n    class Pair implements Comparable<Pair> {\n        int num, cost;\n        public int compareTo(Pair rhs) {\n            return cost > rhs.cost ? -1 : cost == rhs.cost ? 0 : 1;\n        }\n        public Pair(int num, int cost) {\n            this.num = num;\n            this.cost = cost;\n        }\n    }\n\n    Pair[] a;\n    int[] b = new int[100333];\n    int n;\n    boolean[] used;\n\n    int get(int votes) {\n        Arrays.fill(b, 0);\n        Arrays.fill(used, false);\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (a[i].num == 0) {\n                b[0]++;\n                used[i] = true;\n                continue;\n            }\n            if (b[a[i].num] + 1 == votes) {\n                res += a[i].cost;\n                b[0]++;\n                used[i] = true;\n            }\n            else {\n                b[a[i].num]++;\n            }\n        }\n        for (int i = n - 1; i >= 0 && b[0] < votes; i--) {\n            if (used[i]) continue;\n            res += a[i].cost;\n            b[0]++;\n        }\n        return res;\n    }\n\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        n = in.nextInt();\n        a = new Pair[n];\n        used = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            int num = in.nextInt();\n            int cost = in.nextInt();\n            a[i] = new Pair(num, cost);\n        }\n        Arrays.sort(a);\n        int l = 1;\n        int r = n;\n        while (l + 2 < r) {\n            int m = (r - l) / 3;\n            int c1 = l + m;\n            int c2 = r - m;\n            int f1 = get(c1);\n            int f2 = get(c2);\n            if (f1 < f2) r = c2;\n            else l = c1;\n        }\n        int ans = get(l);\n        l++;\n        while (l <= r) {\n            ans = Math.min(ans, get(l));\n            l++;\n        }\n        out.println(ans);\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream inputStream) {\n        reader = new BufferedReader(new InputStreamReader(inputStream));\n    }\n\n    public String nextLine() {\n        String line = null;\n        try {\n            line = reader.readLine();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return line;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens())\n            tokenizer = new StringTokenizer(nextLine());\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n}\n\n",brute force
"import java.util.List;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.math.BigInteger;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author AlexFetisov\n */\npublic class elections_af {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskD {\n\n    final int MAXN = 100001;\n\n    int[] forWhom;\n    int[] priceToChange;\n    int[] votesForCandidate;\n\n    int forMe;\n\n    class Vote implements Comparable<Vote> {\n        int price;\n        int id;\n\n        boolean mark = false;\n\n        Vote(int price, int id) {\n            this.price = price;\n            this.id = id;\n        }\n\n\n        public int compareTo(Vote o) {\n            if (price != o.price) return price - o.price;\n            return id - o.id;\n        }\n    }\n\n    List<Vote> votes;\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = in.nextInt();\n        votesForCandidate = new int[MAXN];\n        forMe = 0;\n        forWhom = new int[n];\n        votes = new ArrayList<Vote>();\n        priceToChange = new int[n];\n\n        for (int i = 0; i < n; ++i) {\n            forWhom[i] = in.nextInt();\n            priceToChange[i] = in.nextInt();\n            if (forWhom[i] == 0) {\n                ++forMe;\n            } else {\n                votesForCandidate[forWhom[i]]++;\n                votes.add(new Vote(priceToChange[i], forWhom[i]));\n            }\n        }\n        Collections.sort(votes);\n        long res = Long.MAX_VALUE;\n        int S = 1, F = n;\n        while (S + 10 <= F) {\n            int delta = (F - S) / 3;\n            int e1 = S + delta;\n            int e2 = F - delta;\n            long f1 = f(e1);\n            long f2 = f(e2);\n            if (f1 < f2) {\n                F = e2;\n            } else {\n                S = e1;\n            }\n        }\n        for (int i = S; i <= F; ++i) {\n            res = Math.min(res, f(i));\n        }\n        out.println(res);\n    }\n\n    private long f(int needVotes) {\n        int curForMe = forMe;\n        long res = 0;\n        int[] curVotes = new int[MAXN];\n        for (Vote v : votes) {\n            v.mark = false;\n        }\n        System.arraycopy(votesForCandidate, 1, curVotes, 1, MAXN - 1);\n        for (Vote v : votes) {\n            if (curVotes[v.id] >= needVotes) {\n                res += v.price;\n                v.mark = true;\n                ++curForMe;\n                curVotes[v.id]--;\n            }\n        }\n        int need = needVotes - curForMe;\n        if (need > 0) {\n            for (Vote v : votes) {\n                if (!v.mark) {\n                    --need;\n                    res += v.price;\n                    if (need == 0) break;\n                }\n            }\n        }\n        return res;\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer stt;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n    }\n\n    public String nextLine() {\n        try {\n            return reader.readLine().trim();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    public String nextString() {\n        while (stt == null || !stt.hasMoreTokens()) {\n            stt = new StringTokenizer(nextLine());\n        }\n        return stt.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(nextString());\n    }\n\n}\n",brute force
"import java.io.*;\nimport java.util.*;\n\npublic class C {\n\n	BufferedReader br;\n	PrintWriter out;\n	StringTokenizer st;\n	boolean eof;\n\n	static class Voter implements Comparable<Voter> {\n		int id, vote, cost;\n\n		public Voter(int id, int vote, int cost) {\n			this.id = id;\n			this.vote = vote;\n			this.cost = cost;\n		}\n\n		@Override\n		public int compareTo(Voter o) {\n			return Integer.compare(cost, o.cost);\n		}\n	}\n\n	class Node {\n		Node left, right;\n		int l, r;\n		int count, sum;\n\n		public Node(int l, int r) {\n			this.l = l;\n			this.r = r;\n			if (r - l > 1) {\n				int mid = (l + r) >> 1;\n				left = new Node(l, mid);\n				right = new Node(mid, r);\n			}\n		}\n\n		void add(int pos, int cost) {\n			if (l == pos && pos + 1 == r) {\n				count = 1;\n				sum = cost;\n				return;\n			}\n			(pos < left.r ? left : right).add(pos, cost);\n			count = left.count + right.count;\n			sum = left.sum + right.sum;\n		}\n\n		int get(int k) {\n			if (k <= 0) {\n				return 0;\n			}\n			if (count == k) {\n				return sum;\n			}\n			if (k <= left.count) {\n				return left.get(k);\n			} else {\n				return left.sum + right.get(k - left.count);\n			}\n		}\n	}\n\n	void solve() throws IOException {\n		int n = nextInt();\n		List<Voter> all = new ArrayList<Voter>(n);\n		List<Voter>[] byWho = new List[100000];\n		for (int i = 0; i < 100000; i++) {\n			byWho[i] = new ArrayList<>(0);\n		}\n		int have = 0;\n		for (int i = 0; i < n; i++) {\n			int who = nextInt();\n			int cost = nextInt();\n			if (who == 0) {\n				have++;\n			} else {\n				Voter tmp = new Voter(all.size(), who - 1, cost);\n				all.add(tmp);\n				byWho[who - 1].add(tmp);\n			}\n		}\n		Collections.sort(all);\n		int[] sortOrd = new int[n];\n		for (int i = 0; i < all.size(); i++) {\n			sortOrd[all.get(i).id] = i;\n		}\n		Arrays.sort(byWho, new Comparator<List<Voter>>() {\n\n			@Override\n			public int compare(List<Voter> o1, List<Voter> o2) {\n				return -Integer.compare(o1.size(), o2.size());\n			}\n\n		});\n		for (int i = 0; i < 100000; i++) {\n			Collections.sort(byWho[i]);\n		}\n\n		Node root = new Node(0, all.size());\n		int needPay = 0;\n		int countNeedPay = 0;\n		for (int i = 0; i < 100000; i++) {\n			int from = Math.max(byWho[i].size() - Math.max(have - 1, 0), 0);\n			for (int j = from; j < byWho[i].size(); j++) {\n				Voter v = byWho[i].get(j);\n				root.add(sortOrd[v.id], v.cost);\n			}\n			// System.err.println(byWho[i].size() + "" "" + from);\n			for (int j = 0; j < from; j++) {\n				needPay += byWho[i].get(j).cost;\n				countNeedPay++;\n			}\n		}\n		int ans;\n		if (have == 0) {\n			ans = Integer.MAX_VALUE;\n		} else {\n			ans = needPay;\n		}\n		for (int res = have + 1; res <= n; res++) {\n			if (res != 1) {\n				for (int j = 0; j < 100000; j++) {\n					if (byWho[j].size() < res - 1) {\n						break;\n					}\n					// System.err.println(res);\n					Voter v = byWho[j].get(byWho[j].size() - res + 1);\n					needPay -= v.cost;\n					countNeedPay--;\n					root.add(sortOrd[v.id], v.cost);\n				}\n			}\n			// System.err.println(res + "" "" + countNeedPay);\n			// System.err.println(root.count);\n			ans = Math.min(ans, needPay + root.get(res - have - countNeedPay));\n		}\n		out.println(ans);\n	}\n\n	C() throws IOException {\n		br = new BufferedReader(new InputStreamReader(System.in));\n		out = new PrintWriter(System.out);\n		solve();\n		out.close();\n	}\n\n	public static void main(String[] args) throws IOException {\n		new C();\n	}\n\n	String nextToken() {\n		while (st == null || !st.hasMoreTokens()) {\n			try {\n				st = new StringTokenizer(br.readLine());\n			} catch (Exception e) {\n				eof = true;\n				return null;\n			}\n		}\n		return st.nextToken();\n	}\n\n	String nextString() {\n		try {\n			return br.readLine();\n		} catch (IOException e) {\n			eof = true;\n			return null;\n		}\n	}\n\n	int nextInt() throws IOException {\n		return Integer.parseInt(nextToken());\n	}\n\n	long nextLong() throws IOException {\n		return Long.parseLong(nextToken());\n	}\n\n	double nextDouble() throws IOException {\n		return Double.parseDouble(nextToken());\n	}\n}",brute force
"import java.util.Scanner;\n \npublic class a{\n	public static void main (String args[]){\n		Scanner input = new Scanner(System.in);\n		int n = input.nextInt();\n \n		for(int i=0; i<n; i++){\n			if(input.nextInt()!=input.nextInt()){\n				System.out.println(""Happy Alex"");\n				return;\n			}\n			\n		}\n		System.out.println(""Poor Alex"");\n	}\n}",sortings
"import java.util.*;\npublic class Main {\npublic static void main(String [] args){\nScanner sc=new Scanner(System.in);\nint n=sc.nextInt();	\nboolean flag=false;\nfor(int i=0;i<n;i++){\nint a=sc.nextInt();\nint b=sc.nextInt();\nif(a<b)\nflag=true;	\n}\nif(flag)\nSystem.out.println(""Happy Alex"");\nelse\nSystem.out.println(""Poor Alex"");\n}\n}",sortings
"import java.util.*;\npublic class Main {\npublic static void main(String [] args){\nScanner sc=new Scanner(System.in);\nint n=sc.nextInt();	\nboolean flag=false;\nfor(int i=0;i<n;i++){\nint a=sc.nextInt();\nint b=sc.nextInt();\nif(a<b)\nflag=true;	\n}\nif(flag)\nSystem.out.println(""Happy Alex"");\nelse\nSystem.out.println(""Poor Alex"");\n}\n}",sortings
"import java.util.*;\npublic class ILove9 {\npublic static void main(String [] args){\nScanner in=new Scanner(System.in);\nint n=in.nextInt();	\nboolean flag=false;\nfor(int i=0;i<n;i++){\nint a=in.nextInt();\nint b=in.nextInt();\nif(a<b)\nflag=true;	\n}\nif(flag)\nSystem.out.println(""Happy Alex"");\nelse\nSystem.out.println(""Poor Alex"");\n}\n}",sortings
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        BLittlePonyAndHarmonyChest solver = new BLittlePonyAndHarmonyChest();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BLittlePonyAndHarmonyChest {\n        int n;\n        int[] arr;\n        int[][] memo;\n        int[] msks;\n        StringBuilder sb;\n\n        public void readInput(Scanner sc) {\n            n = sc.nextInt();\n            arr = new int[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = sc.nextInt();\n        }\n\n        public void solve(int testNumber, Scanner sc, PrintWriter pw) {\n            readInput(sc);\n            boolean[] isPrime = new boolean[61];\n            Arrays.fill(isPrime, true);\n            isPrime[0] = isPrime[1] = false;\n            for (int i = 2; i * i <= 61; i++) {\n                if (isPrime[i]) {\n                    for (int j = i * i; j < 61; j += i)\n                        isPrime[j] = false;\n                }\n            }\n            memo = new int[n][(1 << 17)];\n            for (int[] x : memo)\n                Arrays.fill(x, -1);\n            msks = new int[61];\n            for (int i = 0; i < msks.length; ++i) {\n                for (int j = 0, k = 0; j < isPrime.length; ++j) {\n                    if (isPrime[j]) {\n                        if (i % j == 0)\n                            msks[i] |= 1 << k;\n                        ++k;\n                    }\n                }\n            }\n            sb = new StringBuilder();\n            trace(0, 0);\n            pw.println(sb);\n        }\n\n        private void trace(int idx, int msk) {\n            if (idx == n)\n                return;\n            int opt = dp(idx, msk);\n            for (int i = 1; i <= 60; i++) {\n                if ((msks[i] & msk) == 0) {\n                    int cost = Math.abs(arr[idx] - i);\n                    if (opt == cost + dp(idx + 1, msk | msks[i])) {\n                        sb.append(i + "" "");\n                        trace(idx + 1, msk | msks[i]);\n                        return;\n                    }\n                }\n            }\n        }\n\n        private int dp(int idx, int msk) {\n            if (idx == n)\n                return 0;\n            int min = (int) 1e9;\n            if (memo[idx][msk] != -1)\n                return memo[idx][msk];\n            for (int i = 1; i <= 60; i++) {\n                if ((msks[i] & msk) == 0) {\n                    int cost = Math.abs(arr[idx] - i);\n                    min = Math.min(min, cost + dp(idx + 1, msk | msks[i]));\n                }\n            }\n            return memo[idx][msk] = min;\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() {\n            try {\n                while (st == null || !st.hasMoreTokens())\n                    st = new StringTokenizer(br.readLine());\n                return st.nextToken();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n","bitmasks,brute force,dp"
"/**\n * ******* Created  on 25/4/20 12:54 AM*******\n */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class B453 implements Runnable {\n\n    private static final int MAX = 60;\n    private static final int MOD = (int) (1E9 + 7);\n    private static final long Inf = (long) (1E14 + 10);\n    private static final double eps = (double) (1E-9);\n\n    /**\n     *  Bitmasks number therory gcd sieve\n     * @throws IOException\n     */\n    int n;\n    int[] a;\n    int[] fact = new int[MAX+1];\n    private void solve() throws IOException {\n        n = reader.nextInt();\n        a = new int[n];\n        for(int i=0;i<n;i++)\n            a[i] = reader.nextInt();\n        List<Integer> primes = getPrimes();\n\n        for(int i=1;i<=MAX;i++){\n            for(int j=0;j<primes.size() ;j++){\n                if(i%primes.get(j)==0)\n                    fact[i] |=(1<<j);\n            }\n        }\n        mem = new int[n][1<<17];\n        for(int i=0;i<n;i++)\n            Arrays.fill(mem[i],-1);\n        dp(0,0);\n        path(0,0);\n    }\n\n    private int path(int i, int mask) {\n        if(i == n)\n            return 0;\n        int ans = dp(i, mask);\n        if(ans == Math.abs(a[i]-1) +dp(i+1, mask) ){\n            writer.print(""1 "");\n            return path(i+1, mask);\n        }\n        for(int j=2;j<=60;j++){\n            if((mask & fact[j]) ==0)\n                if(ans == Math.abs(a[i]-j) + dp(i+1, mask | fact[j])){\n                    writer.print(j +"" "");\n                    return path(i+1, mask | fact[j]);\n                }\n        }\n        return 0;\n    }\n\n    int[][] mem ;\n    int ans ;\n    private int dp(int i, int mask) {\n        if(i == n)\n            return 0;\n        if(mem[i][mask]!=-1)\n            return mem[i][mask];\n        ans =Math.abs(a[i]-1) + dp(i+1, mask);\n        for(int j=2;j<=60;j++){\n            if((mask & fact[j] )==0 )\n                ans = Math.min(ans, Math.abs(a[i]-j)+dp(i+1,mask | fact[j]));\n        }\n        mem[i][mask] = ans;\n        return ans;\n    }\n\n    private List<Integer> getPrimes() {\n        List<Integer> primes = new ArrayList<>();\n        for(int i=2;i<=MAX;i++){\n            boolean flag =true;\n            for(int j=2;j<i;j++)\n                if(i%j==0)\n                    flag =false;\n            if(flag)primes.add(i);\n        }\n\n        return primes;\n    }\n\n    public static void main(String[] args) throws IOException {\n        try (Input reader = new StandardInput(); PrintWriter writer = new PrintWriter(System.out)) {\n            new B453().run();\n        }\n    }\n\n    StandardInput reader;\n    PrintWriter writer;\n\n    @Override\n    public void run() {\n        try {\n            reader = new StandardInput();\n            writer = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n\n    interface Input extends Closeable {\n        String next() throws IOException;\n\n        String nextLine() throws IOException;\n\n        default int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        default long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        default double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        default int[] readIntArray() throws IOException {\n            return readIntArray(nextInt());\n        }\n\n        default int[] readIntArray(int size) throws IOException {\n            int[] array = new int[size];\n            for (int i = 0; i < array.length; i++) {\n                array[i] = nextInt();\n            }\n            return array;\n        }\n\n        default long[] readLongArray(int size) throws IOException {\n            long[] array = new long[size];\n            for (int i = 0; i < array.length; i++) {\n                array[i] = nextLong();\n            }\n            return array;\n        }\n    }\n\n    private static class StandardInput implements Input {\n        private final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        private StringTokenizer stringTokenizer;\n\n        @Override\n        public void close() throws IOException {\n            reader.close();\n        }\n\n        @Override\n        public String next() throws IOException {\n            if (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {\n                stringTokenizer = new StringTokenizer(reader.readLine());\n            }\n            return stringTokenizer.nextToken();\n        }\n\n        @Override\n        public String nextLine() throws IOException {\n            return reader.readLine();\n        }\n    }\n\n}\n","bitmasks,brute force,dp"
"import java.io.BufferedOutputStream;\nimport java.io.Closeable;\nimport java.io.DataInputStream;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	static class TaskAdapter implements Runnable {\n		@Override\n		public void run() {\n			long startTime = System.currentTimeMillis();\n			InputStream inputStream = System.in;\n			OutputStream outputStream = System.out;\n			FastReader in = new FastReader(inputStream);\n			Output out = new Output(outputStream);\n			BLittlePonyAndHarmonyChest solver = new BLittlePonyAndHarmonyChest();\n			solver.solve(1, in, out);\n			out.close();\n			System.err.println(System.currentTimeMillis()-startTime+""ms"");\n		}\n	}\n\n	public static void main(String[] args) throws Exception {\n		Thread thread = new Thread(null, new TaskAdapter(), """", 1<<28);\n		thread.start();\n		thread.join();\n	}\n\n	static class BLittlePonyAndHarmonyChest {\n		private final int iinf = 1_000_000_000;\n\n		public BLittlePonyAndHarmonyChest() {\n		}\n\n		public void solve(int kase, InputReader in, Output pw) {\n			int n = in.nextInt(), m = 17;\n			int[] arr = in.nextInt(n);\n			int[] mask = new int[61];\n			{\n				ArrayList<Integer> primes = Utilities.sieve(60);\n				for(int i = 1; i<=60; i++) {\n					for(int j = 0; j<m; j++) {\n						if(i%primes.get(j)==0) {\n							mask[i] |= 1<<j;\n						}\n					}\n				}\n			}\n			int[][] dp = new int[n+1][1<<m], next = new int[n][1<<m];\n			for(int i = n-1; i>=0; i--) {\n				for(int j = 0; j<1<<m; j++) {\n					dp[i][j] = iinf;\n					for(int k = 1; k<=60; k++) {\n						if((j&mask[k])==0) {\n							int val = Math.abs(k-arr[i])+dp[i+1][j|mask[k]];\n							if(val<dp[i][j]) {\n								dp[i][j] = val;\n								next[i][j] = k;\n							}\n						}\n					}\n				}\n			}\n			int j = 0;\n			for(int i = 0; i<n; i++) {\n				pw.print(next[i][j]+"" "");\n				j |= mask[next[i][j]];\n			}\n			pw.println();\n		}\n\n	}\n\n	static class Utilities {\n		public static ArrayList<Integer> sieve(int n) {\n			ArrayList<Integer> ans = new ArrayList<>();\n			boolean[] prime = new boolean[n+1];\n			Arrays.fill(prime, true);\n			for(int i = 2; i<=n; i++) {\n				if(prime[i]) {\n					ans.add(i);\n				}\n				if((long) i*i>n) {\n					continue;\n				}\n				for(int j = i*i; j<=n; j += i) {\n					prime[j] = false;\n				}\n			}\n			return ans;\n		}\n\n	}\n\n	static class FastReader implements InputReader {\n		final private int BUFFER_SIZE = 1<<16;\n		private DataInputStream din;\n		private byte[] buffer;\n		private int bufferPointer;\n		private int bytesRead;\n\n		public FastReader(InputStream is) {\n			din = new DataInputStream(is);\n			buffer = new byte[BUFFER_SIZE];\n			bufferPointer = bytesRead = 0;\n		}\n\n		public int nextInt() {\n			int ret = 0;\n			byte c = skipToDigit();\n			boolean neg = (c=='-');\n			if(neg) {\n				c = read();\n			}\n			do {\n				ret = ret*10+c-'0';\n			} while((c = read())>='0'&&c<='9');\n			if(neg) {\n				return -ret;\n			}\n			return ret;\n		}\n\n		private boolean isDigit(byte b) {\n			return b>='0'&&b<='9';\n		}\n\n		private byte skipToDigit() {\n			byte ret;\n			while(!isDigit(ret = read())&&ret!='-') ;\n			return ret;\n		}\n\n		private void fillBuffer() {\n			try {\n				bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n			}catch(IOException e) {\n				e.printStackTrace();\n				throw new InputMismatchException();\n			}\n			if(bytesRead==-1) {\n				buffer[0] = -1;\n			}\n		}\n\n		private byte read() {\n			if(bytesRead==-1) {\n				throw new InputMismatchException();\n			}else if(bufferPointer==bytesRead) {\n				fillBuffer();\n			}\n			return buffer[bufferPointer++];\n		}\n\n	}\n\n	static interface InputReader {\n		int nextInt();\n\n		default int[] nextInt(int n) {\n			int[] ret = new int[n];\n			for(int i = 0; i<n; i++) {\n				ret[i] = nextInt();\n			}\n			return ret;\n		}\n\n	}\n\n	static class Output implements Closeable, Flushable {\n		public StringBuilder sb;\n		public OutputStream os;\n		public int BUFFER_SIZE;\n		public String lineSeparator;\n\n		public Output(OutputStream os) {\n			this(os, 1<<16);\n		}\n\n		public Output(OutputStream os, int bs) {\n			BUFFER_SIZE = bs;\n			sb = new StringBuilder(BUFFER_SIZE);\n			this.os = new BufferedOutputStream(os, 1<<17);\n			lineSeparator = System.lineSeparator();\n		}\n\n		public void print(String s) {\n			sb.append(s);\n			if(sb.length()>BUFFER_SIZE >> 1) {\n				flushToBuffer();\n			}\n		}\n\n		public void println() {\n			sb.append(lineSeparator);\n		}\n\n		private void flushToBuffer() {\n			try {\n				os.write(sb.toString().getBytes());\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n			sb = new StringBuilder(BUFFER_SIZE);\n		}\n\n		public void flush() {\n			try {\n				flushToBuffer();\n				os.flush();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n		public void close() {\n			flush();\n			try {\n				os.close();\n			}catch(IOException e) {\n				e.printStackTrace();\n			}\n		}\n\n	}\n}\n\n","bitmasks,brute force,dp"
"import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        BLittlePonyAndHarmonyChest solver = new BLittlePonyAndHarmonyChest();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class BLittlePonyAndHarmonyChest {\n        int n;\n        int[] arr;\n        int[] factors;\n        int[][] dp;\n        int[][] prev;\n        int[][] v;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            n = in.nextInt();\n            arr = in.nextIntArray(n);\n            int[] primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53};\n            int[] pos = new int[60];\n            for (int i = 0; i < primes.length; i++) pos[primes[i]] = i;\n            factors = new int[60];\n            for (int i = 1; i <= 59; i++) {\n                ArrayList<Integer> list = distinctPrimeFactors(i);\n                int mask = 0;\n                for (int a : list) {\n                    mask |= (1 << pos[a]);\n                }\n                factors[i] = mask;\n            }\n            dp = new int[n][1 << primes.length];\n            for (int i = 0; i < n; i++) Arrays.fill(dp[i], -1);\n            prev = new int[n][1 << primes.length];\n            v = new int[n][1 << primes.length];\n            int min = ans(0, 0, -1);\n//        out.println(min);\n            path(0, 0, out);\n        }\n\n        void path(int i, int j, OutputWriter out) {\n            if (i == n) return;\n            out.print(v[i][j] + "" "");\n            path(i + 1, prev[i][j], out);\n        }\n\n        public ArrayList<Integer> distinctPrimeFactors(int N) {\n            ArrayList<Integer> factorials = new ArrayList<>();\n            int limit = (int) Math.sqrt(N);\n            if (N % 2 == 0) {\n                factorials.add(2);\n                while (N % 2 == 0) N /= 2;\n            }\n            for (int i = 3; i <= limit; i += 2) {\n                if (N % i == 0) {\n                    factorials.add(i);\n                    while (N % i == 0) N /= i;\n                }\n            }\n            if (N > 2) factorials.add(N);\n            return factorials;\n        }\n\n        int ans(int i, int mask, int pp) {\n            if (i == n) return 0;\n            if (dp[i][mask] != -1) return dp[i][mask];\n            prev[i][mask] = mask;\n            v[i][mask] = 1;\n            int val = arr[i] - 1 + ans(i + 1, mask, 1);\n            outer:\n            for (int j = 2; j <= Math.min(2 * arr[i] - 2, 58); j++) {\n                if ((mask & factors[j]) != 0) continue;\n                int m1 = mask | factors[j];\n                int x = Math.abs(arr[i] - j);\n                int t = ans(i + 1, m1, j);\n                if (x + t < val) {\n                    val = x + t;\n                    prev[i][mask] = m1;\n                    v[i][mask] = j;\n                }\n            }\n            return dp[i][mask] = val;\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] array = new int[n];\n            for (int i = 0; i < n; ++i) array[i] = nextInt();\n            return array;\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n\n","bitmasks,brute force,dp"
"/* package codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be ""Main"" only if the class is public. */\npublic class Codechef\n{\n	public static void main (String[] args) throws java.lang.Exception\n	{\n		Scanner sc=new Scanner(System.in);\n		int t=sc.nextInt();\n		for(int i=0;i<t;i++){\n		    long n=sc.nextLong();\n		    long k=sc.nextLong();\n		    long d1=sc.nextLong();\n		    long d2=sc.nextLong();\n		    boolean b=false;\n		    if(n%3==0){\n		        long w1=(k-(2*d1)+d2),w2=0,w3=0;\n		        if(w1%3==0){\n		            w1=w1/3;\n		            w2=w1+d1;\n		            w3=w1+d1-d2;\n		            if(w3>=0&&w2>=0&&w1>=0&&w3<=n/3&&w2<=n/3&&w1<=n/3){b=true;}\n		        }\n		        w1=(k-(2*d1)-d2);w2=0;w3=0;\n		        if(w1%3==0){\n		            w1=w1/3;\n		            w2=w1+d1;\n		            w3=w1+d1+d2;\n		            if(w3>=0&&w2>=0&&w1>=0&&w3<=n/3&&w2<=n/3&&w1<=n/3){b=true;}\n		        }\n		        w1=(k+(2*d1)+d2);w2=0;w3=0;\n		        if(w1%3==0){\n		            w1=w1/3;\n		            w2=w1-d1;\n		            w3=w1-d1-d2;\n		            if(w3>=0&&w2>=0&&w1>=0&&w3<=n/3&&w2<=n/3&&w1<=n/3){b=true;}\n		        }\n		        w1=(k+(2*d1)-d2);w2=0;w3=0;\n		        if(w1%3==0){\n		            w1=w1/3;\n		            w2=w1-d1;\n		            w3=w1-d1+d2;\n		            if(w3>=0&&w2>=0&&w1>=0&&w3<=n/3&&w2<=n/3&&w1<=n/3){b=true;}\n		        }\n		    }\n		    if(b) System.out.println(""yes"");\n		    else System.out.println(""no"");\n		    \n		}\n	}\n}\n","brute force,implementation,math"
"import java.io.*;\nimport java.util.*;\n\n \npublic class Practice\n{\n//	static final long mod=7420738134811L;\n	static int mod=998244353;\n	static final int size=100001;\n	static FastReader sc=new FastReader(System.in);\n//	static Reader sc=new Reader();\n	static  PrintWriter out=new PrintWriter(System.out);\n	static long[] factorialNumInverse;\n	// Array to precompute inverse of 1! to N!\n	static long[] naturalNumInverse;\n	// Array to store factorial of first N numbers\n	static long[] fact;\n	public static void main(String[] args) throws IOException, FileNotFoundException\n	{\n//		System.setIn(new FileInputStream(""input.txt""));\n//		System.setOut(new PrintStream(""output.txt""));\n//		factorialNumInverse=new long[size];\n//		naturalNumInverse=new long[size];\n//		fact=new long[size];\n//		factorial(mod);\n//		InverseofNumber(mod);\n//		InverseofFactorial(mod);\n		int t=1;\n		t=sc.nextInt();\n//		StringBuilder sb=new StringBuilder();\n		while(t-->0)\n		{\n			solve();\n//			sb.append(""\n"");\n		}\n//		out.print(sb);\n		out.close();\n		out.flush();\n	}\n	static void solve() throws IOException\n	{\n		long n=sc.nextLong();\n		long k=sc.nextLong();\n		long a=sc.nextLong(),b=sc.nextLong();\n		if(n%3!=0)\n		{\n			out.println(""no"");\n			return;\n		}\n		ArrayList<Tuple> pos=new ArrayList<Practice.Tuple>();	//store all possible predictions of k matches\n//		x+a 	x	 x+b\n//		3*x+a+b = k\n//		x =	(k-a-b)/3  	// a and b can be negative\n		if((k-a-b)>=0 && (k-a-b)%3==0)	\n		{\n			long x=(k-a-b)/3;\n			pos.add(new Tuple(x+a,x,x+b));\n		}\n		if((k+a-b)>=0 && (k+a-b)%3==0)	\n		{\n			long x=(k+a-b)/3;\n			if(x>=a && x<=n)\n				pos.add(new Tuple(x-a,x,x+b));\n		}\n		if((k-a+b)>=0 && (k-a+b)%3==0)	\n		{\n			long x=(k-a+b)/3;\n			if(x>=b && x<=n)\n				pos.add(new Tuple(x+a,x,x-b));\n		}\n		if((k+a+b)>=0 && (k+a+b)%3==0)	\n		{\n			long x=(k+a+b)/3;\n			if(x>=a && x>=b && x<=n)\n				pos.add(new Tuple(x-a,x,x-b));\n		}\n		n=n/3;\n		for(Tuple temp: pos)\n		{\n			if(temp.x<=n && temp.y<=n && temp.z<=n)\n			{\n				out.println(""yes"");\n				return;\n			}\n		}\n		out.println(""no"");\n	}\n	static boolean check(double a)\n	{\n		int A=(int)a;\n		return ((double)A==a);\n	}\n	static class Pair implements Cloneable\n	{\n		int x,y;\n		Pair(int a,int b)\n		{\n			this.x=a;\n			this.y=b;\n		}\n		@Override\n		public String toString() \n		{\n			return ""(""+x+"" at ""+(y+1)+"")"";\n		}\n		@Override\n		protected Pair clone() throws CloneNotSupportedException {\n			return new Pair(this.x,this.y);\n		}\n	}\n	static class Tuple implements Cloneable\n	{\n		long x,y,z;\n		Tuple(long a,long b,long c)\n		{\n			this.x=a;\n			this.y=b;\n			this.z=c;\n		}\n		@Override\n		public String toString() \n		{\n			return ""(""+x+"",""+y+"",""+z+"")"";\n		}\n		@Override\n		protected Tuple clone() throws CloneNotSupportedException {\n			return new Tuple(this.x,this.y,this.z);\n		}\n	}\n	static void arraySort(int arr[])\n	{\n		ArrayList<Integer> a=new ArrayList<Integer>();\n		for (int i = 0; i < arr.length; i++) {\n			a.add(arr[i]);\n		}\n		Collections.sort(a);\n		for (int i = 0; i < arr.length; i++) {\n			arr[i]=a.get(i);\n		}\n	}\n	public static void InverseofNumber(int p)\n	{\n	    naturalNumInverse[0] = naturalNumInverse[1] = 1;\n	    for(int i = 2; i < 200001; i++)\n	        naturalNumInverse[i] = naturalNumInverse[p % i] * (long)(p - p / i) % p;\n	}\n	// Function to precompute inverse of factorials\n	public static void InverseofFactorial(int p)\n	{\n	    factorialNumInverse[0] = factorialNumInverse[1] = 1;\n	    // pre-compute inverse of natural numbers\n	    for(int i = 2; i < 200001; i++)\n	        factorialNumInverse[i] = (naturalNumInverse[i] * factorialNumInverse[i - 1]) % p;\n	}\n	// Function to calculate factorial of 1 to 200001\n	public static void factorial(int p)\n	{\n	    fact[0] = 1;\n	    for(int i = 1; i < 200001; i++)\n	        fact[i] = (fact[i - 1] * (long)i) % p;\n	}\n	 \n	// Function to return nCr % p in O(1) time\n	public static long Binomial(int N, int R, int p)\n	{\n	     \n	    // n C r = n!*inverse(r!)*inverse((n-r)!)\n	    long ans = ((fact[N] * factorialNumInverse[R]) % p * factorialNumInverse[N - R]) % p;\n	     \n	    return ans;\n	}\n	static int findXOR(int x)	//from 0 to x\n	{\n		if(x<0)\n			return 0;\n		if(x%4==0)\n			return x;\n		if(x%4==1)\n			return 1;\n		if(x%4==2)\n			return x+1;\n		return 0;\n	}\n	static boolean isPrime(long x)\n	{\n		if(x==1)\n			return false;\n		if(x<=3)\n			return true;\n		if(x%2==0 || x%3==0)\n			return false;\n		for(int i=5;i<=Math.sqrt(x);i+=2)\n			if(x%i==0)\n				return false;\n		return true;\n	}\n	static double dfs(Node ver,Node par)\n	{\n		if(ver.adj.size()==1 && ver.adj.get(0)==par)\n		{\n			return 0;\n		}\n		else\n		{\n			double sum=0,c=0;			\n			for(Node child: ver.adj)\n			if(child!=par)\n			{\n				c++;\n				sum+=dfs(child, ver);\n			}\n			return 1+(sum/c);\n		}\n	}\n	static long gcd(long a,long b)\n	{\n		return (b==0)?a:gcd(b,a%b);\n	}\n	static class UnionFind\n	{\n		  private int size;\n		  private int[] sz;\n		  private int[] parent;\n		  private int numComponents;\n		  public UnionFind(int size) \n		  {\n		    if (size <= 0) throw new IllegalArgumentException(""Size <= 0 is not allowed"");\n		    this.size = numComponents = size;\n		    sz = new int[size];\n		    parent = new int[size];\n		    for (int i = 0; i < size; i++) \n		    {\n		      parent[i] = i; 									// Link to itself (self root)\n		      sz[i] = 1;								// Each component is originally of size one\n		    }\n		  }\n		  public int find(int p) \n		  {\n		    int root = p;\n		    while (root != parent[root])\n		    	root = parent[root];\n		    while (p != root)\n		    {\n		      int next = parent[p];\n		      parent[p] = root;\n		      p = next;\n		    }\n		    return root;\n		  }\n		  public void makeParent(int p,int u)\n		  {\n			  parent[p]=u;\n		  }\n		  public boolean isConnected(int p, int q) \n		  {\n		    return find(p) == find(q);\n		  }\n		  public int componentSize(int x) \n		  {\n		    return sz[find(x)];\n		  }\n		  public int size() \n		  {\n		    return size;\n		  }\n		  public int components() \n		  {\n		    return numComponents;\n		  }\n		  public void unify(int p, int q) \n		  {\n		    int root1 = find(p);\n		    int root2 = find(q);\n		    if(root1==root2)\n		    {\n		    	return;\n		    }\n		    else if (sz[root1] < sz[root2]) \n		    {\n		    	parent[root1] = root2;\n		    	sz[root2] += sz[root1];\n		    	sz[root1] = 0;\n		  } \n		    else \n		    {\n		    	parent[root2] = root1;\n		    	sz[root1] += sz[root2];\n		    	sz[root2] = 0;\n		    }\n		    numComponents--;\n		  }\n		  void calc()\n		  {\n			  for(int i=0;i<size;i++)\n				  find(i);\n			  \n		  }\n	}\n	static class Node\n	{\n		int vertex;\n		ArrayList<Node> adj;\n		boolean rec;\n		boolean vis;\n		int color;\n		Node(int v)\n		{\n			vertex=v;\n			adj=new ArrayList<Node>();\n			vis=false;\n			color=-1;\n		}\n		@Override\n		public String toString() \n		{\n			return vertex+"" "";\n		}\n	}\n	static class Edge\n	{\n		Node a;\n		Node b;\n		Edge(Node m,Node n)\n		{\n			this.a=m;\n			this.b=n;\n		}\n		@Override\n		public String toString() {\n			return a.vertex+"" ""+b.vertex;\n		}\n	}\n	static long power(long x, long y)\n	  {\n	    long res = 1; \n	    x = x % mod; \n	    if (x == 0)\n	      return 0; \n	    while (y > 0)\n	    {\n	    	if ((y & 1) != 0)\n	    		res = (res * x) % mod;\n	    	\n	    	y = y >> 1; // y = y/2\n	    	x = (x * x) % mod;\n	    }\n	    return res;\n	  }\n	static long binomialCoeff(long n, long k)\n    {\n        long res = 1;\n//        if(k>n)\n//        	return 0;\n        // Since C(n, k) = C(n, n-k)\n        if (k > n - k)\n            k = n - k;\n \n        // Calculate value of\n        // [n * (n-1) *---* (n-k+1)] / [k * (k-1) *----* 1]\n        for (long i = 0; i < k; ++i) {\n            res *= (n - i);\n            res /= (i + 1);\n        }\n \n        return res;\n    }\n	static class FastReader\n	{\n        byte[] buf = new byte[2048];\n        int index, total;\n        InputStream in;\n \n        FastReader(InputStream is) \n        {\n            in = is;\n        }\n \n        int scan() throws IOException \n        {\n            if (index >= total) {\n                index = 0;\n                total = in.read(buf);\n                if (total <= 0) {\n                    return -1;\n                }\n            }\n            return buf[index++];\n        }\n \n        String next() throws IOException \n        {\n            int c;\n            for (c = scan(); c <= 32; c = scan());\n            StringBuilder sb = new StringBuilder();\n            for (; c > 32; c = scan()) {\n                sb.append((char) c);\n            }\n            return sb.toString();\n        }\n \n        int nextInt() throws IOException \n        {\n            int c, val = 0;\n            for (c = scan(); c <= 32; c = scan());\n            boolean neg = c == '-';\n            if (c == '-' || c == '+') {\n                c = scan();\n            }\n            for (; c >= '0' && c <= '9'; c = scan()) {\n                val = (val << 3) + (val << 1) + (c & 15);\n            }\n            return neg ? -val : val;\n        }\n \n        long nextLong() throws IOException \n        {\n            int c;\n            long val = 0;\n            for (c = scan(); c <= 32; c = scan());\n            boolean neg = c == '-';\n            if (c == '-' || c == '+') {\n                c = scan();\n            }\n            for (; c >= '0' && c <= '9'; c = scan()) {\n                val = (val << 3) + (val << 1) + (c & 15);\n            }\n            return neg ? -val : val;\n        }\n    }\n	static class Reader \n	{\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n \n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n \n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(\n                new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n \n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\n') {\n                    if (cnt != 0) {\n                        break;\n                    }\n                    else {\n                        continue;\n                    }\n                }\n                buf[cnt++] = (byte)c;\n            }\n            return new String(buf, 0, cnt);\n        }\n \n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n \n            if (neg)\n                return -ret;\n            return ret;\n        }\n \n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n \n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n \n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n \n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n \n            if (neg)\n                return -ret;\n            return ret;\n        }\n \n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0,\n                                 BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n \n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n \n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n        public void printarray(int arr[])\n        {\n        	for (int i = 0; i < arr.length; i++)\n				System.out.print(arr[i]+"" "");\n        	System.out.println();\n        }\n    }\n}\n\n\n\n\n\n\n\n\n","brute force,implementation,math"
"// JAI SHREE RAM, HAR HAR MAHADEV, Hare Krishna\n\nimport java.util.*;\nimport java.util.stream.*;\nimport java.lang.*;\nimport java.math.BigInteger;\nimport java.text.DecimalFormat;\nimport java.io.*;\n\npublic class Eshan {\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static StringTokenizer st;\n    static PrintWriter out = new PrintWriter(System.out);\n    static DecimalFormat df = new DecimalFormat(""0.0000000"");\n    final static int mod = (int) (1e9 + 7);\n    final static int MAX = Integer.MAX_VALUE;\n    final static int MIN = Integer.MIN_VALUE;\n    static Random rand = new Random();\n\n    // ======================= MAIN ==================================\n\n    public static void main(String[] args) throws IOException {\n        int t = readInt();\n        // int t = 1;\n        preprocess();\n        while (t-- > 0) {\n            solve();\n        }\n        out.flush();\n    }\n\n    private static void solve() throws IOException {\n        long n = readLong(), k = readLong(), d1 = readLong(), d2 = readLong();\n\n        if (n % 3 != 0) {\n            out.println(""no"");\n            return;\n        }\n\n        long[][] signs = new long[][] { { -1L, -1L }, { -1L, 1L }, { 1L, -1L }, { 1L, 1L } };\n\n        for (long[] sign : signs) {\n            if ((k + 2L * sign[0] * d1 + sign[1] * d2) % 3 == 0) {\n                long x = (k + 2L * sign[0] * d1 + sign[1] * d2) / 3;\n                if (x > n / 3 || x - sign[0] * d1 > n / 3 || x - sign[0] * d1 - sign[1] * d2 > n / 3)\n                    continue;\n                if (x < 0 || x - sign[0] * d1 < 0 || x - sign[0] * d1 - sign[1] * d2 < 0)\n                    continue;\n\n                long req = n - (3L * x - 2L * sign[0] * d1 - sign[1] * d2);\n                if (req == n - k) {\n                    out.println(""yes"");\n                    return;\n                }\n            }\n        }\n        out.println(""no"");\n    }\n\n    private static void preprocess() {\n\n    }\n\n    // ======================= FOR INPUT ==================================\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(readLine());\n        return st.nextToken();\n    }\n\n    static long readLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    static int readInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    static double readDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    static char readCharacter() throws IOException {\n        return next().charAt(0);\n    }\n\n    static String readString() throws IOException {\n        return next();\n    }\n\n    static String readLine() throws IOException {\n        return br.readLine().trim();\n    }\n\n    static int[] readIntArray(int n) throws IOException {\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++)\n            arr[i] = readInt();\n        return arr;\n    }\n\n    static long[] readLongArray(int n) throws IOException {\n        long[] arr = new long[n];\n        for (int i = 0; i < n; i++)\n            arr[i] = readLong();\n        return arr;\n    }\n\n    // ========================= FOR OUTPUT ==================================\n\n    private static void printIList(List<Integer> list) {\n        for (int i = 0; i < list.size(); i++)\n            out.print(list.get(i) + "" "");\n        out.println("" "");\n    }\n\n    private static void printLList(List<Long> list) {\n        for (int i = 0; i < list.size(); i++)\n            out.print(list.get(i) + "" "");\n        out.println("" "");\n    }\n\n    private static void printIArray(int[] arr) {\n        for (int i = 0; i < arr.length; i++)\n            out.print(arr[i] + "" "");\n        out.println("" "");\n    }\n\n    private static void printIArray(int[][] arr) {\n        for (int i = 0; i < arr.length; i++)\n            printIArray(arr[i]);\n    }\n\n    private static void printLArray(long[] arr) {\n        for (int i = 0; i < arr.length; i++)\n            out.print(arr[i] + "" "");\n        out.println("" "");\n    }\n\n    // ====================== TO CHECK IF STRING IS NUMBER ========================\n\n    private static boolean isInteger(String s) {\n        try {\n            Integer.parseInt(s);\n        } catch (NumberFormatException e) {\n            return false;\n        } catch (NullPointerException e) {\n            return false;\n        }\n        return true;\n    }\n\n    private static boolean isLong(String s) {\n        try {\n            Long.parseLong(s);\n        } catch (NumberFormatException e) {\n            return false;\n        } catch (NullPointerException e) {\n            return false;\n        }\n        return true;\n    }\n\n    // ==================== FASTER SORT ================================\n\n    private static void sort(int[] arr) {\n        int n = arr.length;\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            list.add(arr[i]);\n        Collections.sort(list);\n        for (int i = 0; i < n; i++)\n            arr[i] = list.get(i);\n    }\n\n    private static void sort(long[] arr) {\n        int n = arr.length;\n        List<Long> list = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            list.add(arr[i]);\n        Collections.sort(list);\n        for (int i = 0; i < n; i++)\n            arr[i] = list.get(i);\n    }\n\n    // ==================== MATHEMATICAL FUNCTIONS ===========================\n\n    private static int gcd(int a, int b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n    private static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n    private static int lcm(int a, int b) {\n        return (a / gcd(a, b)) * b;\n    }\n\n    private static long lcm(long a, long b) {\n        return (a / gcd(a, b)) * b;\n    }\n\n    private static long power(long a, long b) {\n        if (b == 0)\n            return 1L;\n        long ans = power(a, b >> 1);\n        ans *= ans;\n        if ((b & 1) == 1)\n            ans *= a;\n        return ans;\n    }\n\n    private static int mod_power(int a, int b) {\n        if (b == 0)\n            return 1;\n        int temp = mod_power(a, b / 2);\n        temp %= mod;\n        temp = (int) ((1L * temp * temp) % mod);\n        if ((b & 1) == 1)\n            temp = (int) ((1L * temp * a) % mod);\n        return temp;\n    }\n\n    private static int multiply(int a, int b) {\n        return (int) ((((1L * a) % mod) * ((1L * b) % mod)) % mod);\n    }\n\n    private static boolean isPrime(long n) {\n        for (long i = 2; i * i <= n; i++) {\n            if (n % i == 0)\n                return false;\n        }\n        return true;\n    }\n\n    // ==================== Primes using Seive =====================\n\n    private static List<Integer> SeivePrime(int n) {\n        boolean[] prime = new boolean[n + 1];\n        Arrays.fill(prime, true);\n        for (int i = 2; i * i <= n; i++) {\n            if (prime[i]) {\n                for (int j = i * i; j <= n; j += i)\n                    prime[j] = false;\n            }\n        }\n        List<Integer> list = new ArrayList<>();\n        for (int i = 2; i <= n; i++)\n            if (prime[i])\n                list.add(i);\n        return list;\n    }\n\n    // ==================== STRING FUNCTIONS ================================\n\n    private static boolean isPalindrome(String str) {\n        int i = 0, j = str.length() - 1;\n        while (i < j)\n            if (str.charAt(i++) != str.charAt(j--))\n                return false;\n        return true;\n    }\n\n    private static String reverseString(String str) {\n        StringBuilder sb = new StringBuilder(str);\n        return sb.reverse().toString();\n    }\n\n    // ==================== LIS & LNDS ================================\n\n    private static int LIS(int arr[], int n) {\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            int idx = find(list, arr[i]);\n            if (idx < list.size())\n                list.set(idx, arr[i]);\n            else\n                list.add(arr[i]);\n        }\n        return list.size();\n    }\n\n    private static int find(List<Integer> list, int val) {\n        int ret = list.size(), i = 0, j = list.size() - 1;\n        while (i <= j) {\n            int mid = (i + j) / 2;\n            if (list.get(mid) >= val) {\n                ret = mid;\n                j = mid - 1;\n            } else {\n                i = mid + 1;\n            }\n        }\n        return ret;\n    }\n\n    private static int LNDS(int[] arr, int n) {\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            int idx = find2(list, arr[i]);\n            if (idx < list.size())\n                list.set(idx, arr[i]);\n            else\n                list.add(arr[i]);\n        }\n        return list.size();\n    }\n\n    private static int find2(List<Integer> list, int val) {\n        int ret = list.size(), i = 0, j = list.size() - 1;\n        while (i <= j) {\n            int mid = (i + j) / 2;\n            if (list.get(mid) <= val) {\n                i = mid + 1;\n            } else {\n                ret = mid;\n                j = mid - 1;\n            }\n        }\n        return ret;\n    }\n\n    // ==================== UNION FIND =====================\n\n    private static int find(int x, int[] parent) {\n        if (parent[x] == x)\n            return x;\n        return parent[x] = find(parent[x], parent);\n    }\n\n    private static boolean union(int x, int y, int[] parent, int[] rank) {\n        int lx = find(x, parent), ly = find(y, parent);\n        if (lx == ly)\n            return true;\n        if (rank[lx] > rank[ly])\n            parent[ly] = lx;\n        else if (rank[lx] < rank[ly])\n            parent[lx] = ly;\n        else {\n            parent[lx] = ly;\n            rank[ly]++;\n        }\n        return false;\n    }\n\n    // ==================== SEGMENT TREE (RANGE SUM) =====================\n\n    public static class SegmentTree {\n        int n;\n        int[] arr, tree, lazy;\n\n        SegmentTree(int arr[]) {\n            this.arr = arr;\n            this.n = arr.length;\n            this.tree = new int[(n << 2)];\n            this.lazy = new int[(n << 2)];\n            build(1, 0, n - 1);\n        }\n\n        void build(int id, int start, int end) {\n            if (start == end)\n                tree[id] = arr[start];\n            else {\n                int mid = (start + end) / 2, left = (id << 1), right = left + 1;\n                build(left, start, mid);\n                build(right, mid + 1, end);\n                tree[id] = tree[left] + tree[right];\n            }\n        }\n\n        void update(int l, int r, int val) {\n            update(1, 0, n - 1, l, r, val);\n        }\n\n        void update(int id, int start, int end, int l, int r, int val) {\n            distribute(id, start, end);\n            if (end < l || r < start)\n                return;\n            if (start == end)\n                tree[id] += val;\n            else if (l <= start && end <= r) {\n                lazy[id] += val;\n                distribute(id, start, end);\n            } else {\n                int mid = (start + end) / 2, left = (id << 1), right = left + 1;\n                update(left, start, mid, l, r, val);\n                update(right, mid + 1, end, l, r, val);\n                tree[id] = tree[left] + tree[right];\n            }\n        }\n\n        int query(int l, int r) {\n            return query(1, 0, n - 1, l, r);\n        }\n\n        int query(int id, int start, int end, int l, int r) {\n            if (end < l || r < start)\n                return 0;\n            distribute(id, start, end);\n            if (start == end)\n                return tree[id];\n            else if (l <= start && end <= r)\n                return tree[id];\n            else {\n                int mid = (start + end) / 2, left = (id << 1), right = left + 1;\n                return query(left, start, mid, l, r) + query(right, mid + 1, end, l, r);\n            }\n        }\n\n        void distribute(int id, int start, int end) {\n            if (start == end)\n                tree[id] += lazy[id];\n            else {\n                tree[id] += lazy[id] * (end - start + 1);\n                lazy[(id << 1)] += lazy[id];\n                lazy[(id << 1) + 1] += lazy[id];\n            }\n            lazy[id] = 0;\n        }\n    }\n\n    // ==================== TRIE ================================\n\n    static class Trie {\n        class Node {\n            Node[] children;\n            boolean isEnd;\n\n            Node() {\n                children = new Node[26];\n            }\n        }\n\n        Node root;\n\n        Trie() {\n            root = new Node();\n        }\n\n        public void insert(String word) {\n            Node curr = root;\n            for (char ch : word.toCharArray()) {\n                if (curr.children[ch - 'a'] == null)\n                    curr.children[ch - 'a'] = new Node();\n                curr = curr.children[ch - 'a'];\n            }\n            curr.isEnd = true;\n        }\n\n        public boolean find(String word) {\n            Node curr = root;\n            for (char ch : word.toCharArray()) {\n                if (curr.children[ch - 'a'] == null)\n                    return false;\n                curr = curr.children[ch - 'a'];\n            }\n            return curr.isEnd;\n        }\n    }\n\n    // ==================== FENWICK TREE ================================\n\n    static class FT {\n        long[] tree;\n        int n;\n\n        FT(int[] arr, int n) {\n            this.n = n;\n            this.tree = new long[n + 1];\n            for (int i = 1; i <= n; i++) {\n                update(i, arr[i - 1]);\n            }\n        }\n\n        void update(int idx, int val) {\n            while (idx <= n) {\n                tree[idx] += val;\n                idx += idx & -idx;\n            }\n        }\n\n        long query(int l, int r) {\n            return getSum(r) - getSum(l - 1);\n        }\n\n        long getSum(int idx) {\n            long ans = 0L;\n            while (idx > 0) {\n                ans += tree[idx];\n                idx -= idx & -idx;\n            }\n            return ans;\n        }\n    }\n\n    // ==================== BINARY INDEX TREE ================================\n\n    static class BIT {\n        long[][] tree;\n        int n, m;\n\n        BIT(int[][] mat, int n, int m) {\n            this.n = n;\n            this.m = m;\n            tree = new long[n + 1][m + 1];\n            for (int i = 1; i <= n; i++) {\n                for (int j = 1; j <= m; j++) {\n                    update(i, j, mat[i - 1][j - 1]);\n                }\n            }\n        }\n\n        void update(int x, int y, int val) {\n            while (x <= n) {\n                int t = y;\n                while (t <= m) {\n                    tree[x][t] += val;\n                    t += t & -t;\n                }\n                x += x & -x;\n            }\n        }\n\n        long query(int x1, int y1, int x2, int y2) {\n            return getSum(x2, y2) - getSum(x1 - 1, y2) - getSum(x2, y1 - 1) + getSum(x1 - 1, y1 - 1);\n        }\n\n        long getSum(int x, int y) {\n            long ans = 0L;\n            while (x > 0) {\n                int t = y;\n                while (t > 0) {\n                    ans += tree[x][t];\n                    t -= t & -t;\n                }\n                x -= x & -x;\n            }\n            return ans;\n        }\n    }\n\n    // ==================== OTHER CLASSES ================================\n\n    static class Pair implements Comparable<Pair> {\n        int first, second;\n\n        Pair(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        public int compareTo(Pair o) {\n            return this.first - o.first;\n        }\n    }\n\n    static class DequeNode {\n        DequeNode prev, next;\n        int val;\n\n        DequeNode(int val) {\n            this.val = val;\n        }\n\n        DequeNode(int val, DequeNode prev, DequeNode next) {\n            this.val = val;\n            this.prev = prev;\n            this.next = next;\n        }\n    }\n}","brute force,implementation,math"
"//import com.sun.org.apache.xpath.internal.operations.String;\n\nimport java.io.*;\nimport java.util.*;\n\n\npublic class scratch_25 {\n   // int count=0;\n    //static long count=0;\n    static class Reader {\n        static BufferedReader reader;\n        static StringTokenizer tokenizer;\n\n        /**\n         * call this method to initialize reader for InputStream\n         */\n        static void init(InputStream input) {\n            reader = new BufferedReader(\n                    new InputStreamReader(input));\n            tokenizer = new StringTokenizer("""");\n        }\n\n        /**\n         * get next word\n         */\n        static String next() throws IOException {\n            while (!tokenizer.hasMoreTokens()) {\n                //TODO add check for eof if necessary\n                tokenizer = new StringTokenizer(\n                        reader.readLine());\n            }\n            return tokenizer.nextToken();\n        }\n\n        static int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        static double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        static long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n\n    public static class Graph{\n        public static class Vertex{\n            HashMap<Integer,Integer> nb= new HashMap<>();     // for neighbours of each vertex\n        }\n\n        public static HashMap<Integer,Vertex> vt;   // for vertices(all)\n\n        public Graph(){\n            vt= new HashMap<>();\n        }\n\n        public static int numVer(){\n            return vt.size();\n        }\n\n        public static boolean contVer(int ver){\n            return vt.containsKey(ver);\n        }\n\n        public static void addVer(int ver){\n            Vertex v= new Vertex();\n            vt.put(ver,v);\n        }\n\n        public static int numEdg(){\n            int count=0;\n            ArrayList<Integer> vrtc= new ArrayList<>(vt.keySet());\n            for (int i = 0; i <vrtc.size() ; i++) {\n                count+=(vt.get(vrtc.get(i))).nb.size();\n            }\n            return count/2;\n        }\n\n        public static boolean contEdg(int ver1, int ver2){\n            if(vt.get(ver1)==null || vt.get(ver2)==null){\n                return false;\n            }\n\n            Vertex v= vt.get(ver1);\n            if(v.nb.containsKey(ver2)){\n                return true;\n            }\n            return false;\n        }\n\n        public static void addEdge(int ver1, int ver2, int weight){\n            if(!vt.containsKey(ver1) || !vt.containsKey(ver2)){\n                return;\n            }\n            Vertex v1= vt.get(ver1);\n            Vertex v2= vt.get(ver2);\n            v1.nb.put(ver2,weight);                                 // if previously there is an edge, then this replaces that edge\n            v2.nb.put(ver1,weight);\n        }\n\n        public static void delEdge(int ver1, int ver2){\n\n            if(!vt.containsKey(ver1) || !vt.containsKey(ver2)){\n                return;\n            }\n\n            vt.get(ver1).nb.remove(ver2);\n            vt.get(ver2).nb.remove(ver1);\n\n        }\n\n        public static void delVer(int ver){\n            if(!vt.containsKey(ver)){\n                return;\n            }\n            Vertex v1= vt.get(ver);\n            ArrayList<Integer> arr= new ArrayList<>(v1.nb.keySet());\n            for (int i = 0; i <arr.size() ; i++) {\n                int s= arr.get(i);\n                vt.get(s).nb.remove(ver);\n            }\n            vt.remove(ver);\n        }\n\n        public class Pair{\n            int vname;\n            ArrayList<Integer> psf= new ArrayList<>();       // path so far\n            int dis;\n            int col;\n        }\n\n\n\n\n\n\n\n\n\n        public HashMap<Integer,Integer> bfs(int src){\n            HashMap<Integer, Boolean> prcd= new HashMap<>();    // jo jo ho chuke hain unke liye\n\n            HashMap<Integer, Integer> ans= new HashMap<>();\n\n            LinkedList<Pair> queue= new LinkedList<>();      // for bfs queue\n\n            Pair strtp= new Pair();\n\n            strtp.vname= src;\n\n            ArrayList<Integer> ar= new ArrayList<>();\n            ar.add(src);\n\n            strtp.psf= ar;\n            strtp.dis=0;\n\n            queue.addLast(strtp);\n\n            while(!queue.isEmpty()){\n\n                Pair rp =  queue.removeFirst();\n\n                if(prcd.containsKey(rp.vname)){\n                    continue;\n                }\n                prcd.put(rp.vname,true);\n                ans.put(rp.vname,rp.dis);\n\n//                if(contEdg(rp.vname,dst)){\n//                    return true;\n//                }\n\n                Vertex a= vt.get(rp.vname);\n                ArrayList<Integer> arr= new ArrayList<>(a.nb.keySet());\n                for (int i = 0; i <arr.size() ; i++) {\n                    int s= arr.get(i);\n                    if(!prcd.containsKey(s)){\n                        Pair np = new Pair();\n                        np.vname= s;\n                        np.dis+=rp.dis+a.nb.get(s);\n                        np.psf.addAll(rp.psf);\n                        np.psf.add(s);\n//                        np.psf.add(s);\n//                         np.psf= rp.psf+"" ""+s;\n                        queue.addLast(np);\n                    }\n\n                }\n            }\n            return ans;\n\n            //   return false;\n        }\n\n\n\n\n\n\n\n\n        public HashMap<Integer,Integer> dfs(int src){\n            HashMap<Integer, Boolean> prcd= new HashMap<>();    // jo jo ho chuke hain unke liye\n\n            HashMap<Integer, Integer> ans= new HashMap<>();\n\n            LinkedList<Pair> stack= new LinkedList<>();      // for bfs queue\n\n            Pair strtp= new Pair();\n\n            strtp.vname= src;\n\n            ArrayList<Integer> ar= new ArrayList<>();\n            ar.add(src);\n\n            strtp.psf= ar;\n            strtp.dis=0;\n\n            stack.addFirst(strtp);\n\n            while(!stack.isEmpty()){\n\n                Pair rp =  stack.removeFirst();\n\n                if(prcd.containsKey(rp.vname)){\n                    continue;\n                }\n                prcd.put(rp.vname,true);\n                ans.put(rp.vname,rp.dis);\n\n//                if(contEdg(rp.vname,dst)){\n//                    return true;\n//                }\n\n                Vertex a= vt.get(rp.vname);\n                ArrayList<Integer> arr= new ArrayList<>(a.nb.keySet());\n                for (int i = 0; i <arr.size() ; i++) {\n                    int s= arr.get(i);\n                    if(!prcd.containsKey(s)){\n                        Pair np = new Pair();\n                        np.vname= s;\n                        np.dis+=rp.dis+a.nb.get(s);\n                        np.psf.addAll(rp.psf);\n                        np.psf.add(s);\n//                        np.psf.add(s);\n//                         np.psf= rp.psf+"" ""+s;\n                        stack.addFirst(np);\n                    }\n\n                }\n            }\n            return ans;\n\n            //   return false;\n        }\n\n\n\n\n\n\n        public boolean isCycle(){\n            HashMap<Integer, Boolean> prcd= new HashMap<>();    // jo jo ho chuke hain unke liye\n\n            //   HashMap<Integer, Integer> ans= new HashMap<>();\n\n            LinkedList<Pair> queue= new LinkedList<>();      // for bfs queue\n\n\n\n            ArrayList<Integer> keys = new ArrayList<>(vt.keySet());\n            for (int i = 0; i <keys.size(); i++) {\n                int cur= keys.get(i);\n                if(prcd.containsKey(cur)){\n                    continue;\n                }\n\n                Pair sp = new Pair();\n                sp.vname= cur;\n                ArrayList<Integer> as= new ArrayList<>();\n                as.add(cur);\n                sp.psf= as;\n\n                queue.addLast(sp);\n\n                while(!queue.isEmpty()){\n\n\n\n\n                    Pair rp= queue.removeFirst();\n                    if(prcd.containsKey(rp.vname)){\n                        return true;\n                    }\n\n                    prcd.put(rp.vname,true);\n\n\n\n\n                    Vertex v1= vt.get(rp.vname);\n                    ArrayList<Integer> nbrs= new ArrayList<>(v1.nb.keySet());\n                    for (int j = 0; j <nbrs.size() ; j++) {\n                        int u= nbrs.get(j);\n                        Pair np= new Pair();\n                        np.vname= u;\n                        queue.addLast(np);\n                    }\n                }\n\n            }\n            return false;\n        }\n\n\n\n\n\n\n        public  ArrayList<ArrayList<Integer>> genConnctdComp(){\n            HashMap<Integer, Boolean> prcd= new HashMap<>();    // jo jo ho chuke hain unke liye\n\n            ArrayList<ArrayList<Integer>> ans= new ArrayList<>();\n\n            //   HashMap<Integer, Integer> ans= new HashMap<>();\n\n            LinkedList<Pair> queue= new LinkedList<>();      // for bfs queue\n\n            //  int con=-1;\n\n            ArrayList<Integer> keys = new ArrayList<>(vt.keySet());\n            for (int i = 0; i <keys.size(); i++) {\n                int cur= keys.get(i);\n                if(prcd.containsKey(cur)){\n                    //return true;\n                    continue;\n                }\n                int count=0;\n                ArrayList<Integer> fu= new ArrayList<>();\n                fu.add(cur);\n\n\n                Pair sp = new Pair();\n                sp.vname= cur;\n                ArrayList<Integer> as= new ArrayList<>();\n                as.add(cur);\n                sp.psf= as;\n\n                queue.addLast(sp);\n\n                while(!queue.isEmpty()){\n\n\n\n\n                    Pair rp= queue.removeFirst();\n                    if(prcd.containsKey(rp.vname)){\n                        //return true;\n                        continue;\n                    }\n\n                    prcd.put(rp.vname,true);\n                    fu.add(rp.vname);\n\n\n\n                    Vertex v1= vt.get(rp.vname);\n                    ArrayList<Integer> nbrs= new ArrayList<>(v1.nb.keySet());\n                    for (int j = 0; j <nbrs.size() ; j++) {\n                        int u= nbrs.get(j);\n                        if(!prcd.containsKey(u)){\n                            count++;\n                        Pair np= new Pair();\n                        np.vname= u;\n                        queue.addLast(np);\n                    }\n                }}\n                fu.add(count);\n                ans.add(fu);\n\n            }\n            //return false;\n            return ans;\n\n        }\n\n        public boolean isBip(int src){                       // only for connected graph\n\n            HashMap<Integer,Integer> clr= new HashMap<>();\n            // colors are 1 and -1\n\n\n            LinkedList<Integer>q = new LinkedList<Integer>();\n            clr.put(src,1);\n            q.add(src);\n\n\n            while(!q.isEmpty()){\n\n                int u = q.getFirst();\n                q.pop();\n\n                ArrayList<Integer> arr= new ArrayList<>(vt.keySet());\n\n                for (int i = 0; i <arr.size() ; ++i) {\n\n                    int x= arr.get(i);\n\n                    if(vt.get(u).nb.containsKey(x) && !clr.containsKey(x)){\n\n                        if(clr.get(u)==1){\n                            clr.put(x,-1);\n                        }\n                        else{\n                            clr.put(x,1);\n                        }\n                        q.push(x);\n                    }\n\n                    else if(vt.get(u).nb.containsKey(x) && (clr.get(x)==clr.get(u))){\n                        return false;\n                    }\n\n                }\n            }\n            return true;\n        }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        public static void printGr() {\n            ArrayList<Integer> arr= new ArrayList<>(vt.keySet());\n            for (int i = 0; i <arr.size() ; i++) {\n                int ver= arr.get(i);\n                Vertex v1= vt.get(ver);\n                ArrayList<Integer> arr1= new ArrayList<>(v1.nb.keySet());\n                for (int j = 0; j <arr1.size() ; j++) {\n                    System.out.println(ver+""-""+arr1.get(j)+"":""+v1.nb.get(arr1.get(j)));\n                }\n\n            }\n        }\n    }\n\n    static class Cus implements Comparable<Cus>{\n        int size;\n        int mon;\n        int num;\n        public Cus(int size,int mon,int num){\n            this.size=size;\n            this.mon=mon;\n            this.num=num;\n        }\n        @Override\n        public int compareTo(Cus o){\n            if(this.mon!=o.mon){\n                return this.mon-o.mon;}\n\n            else{\n                return o.size-this.size;\n            }\n\n        }\n\n\n\n    }\n\n    static class Table implements Comparable<Table>{\n        int go;\n        int cum;\n        int cost;\n        public Table(int go,int cum,int cost){\n            this.go=go;\n            this.cum=cum;\n            this.cost=cost;\n        }\n        @Override\n        public int compareTo(Table o){\n            if(this.go==o.go){\n                return this.cum-o.cum;\n            }\n            return this.go-o.go;\n\n        }\n\n\n    }\n    static class Table1 implements Comparable<Table1>{\n        int go;\n        int cum;\n        int cost;\n        public Table1(int go,int cum,int cost){\n            this.go=go;\n            this.cum=cum;\n            this.cost=cost;\n        }\n        @Override\n        public int compareTo(Table1 o){\n            return this.cost-o.cost;\n\n\n        }}\n\n    public static class DisjointSet{\n        HashMap<Integer,Node> mp= new HashMap<>();\n\n        public static class Node{\n            int data;\n            Node parent;\n            int rank;\n        }\n\n\n        public void create(int val){\n            Node nn= new Node();\n            nn.data=val;\n            nn.parent=nn;\n            nn.rank=0;\n            mp.put(val,nn);\n        }\n\n        public int find(int val){\n\n            return findn(mp.get(val)).data;\n\n        }\n\n\n        public Node findn(Node n){\n            if(n==n.parent){\n                return n;\n            }\n            Node rr= findn(n.parent);\n            n.parent=rr;\n            return rr;\n        }\n\n\n\n        public void union(int val1, int val2){                                                                               // can also be used to check cycles\n\n            Node n1= findn(mp.get(val1));\n            Node n2= findn(mp.get(val2));\n\n\n            if(n1.data==n2.data) {\n                return;\n            }\n\n\n\n            if(n1.rank<n2.rank){\n                n1.parent=n2;\n            }\n\n            else if(n2.rank<n1.rank){\n                n2.parent=n1;\n            }\n\n            else {\n                n2.parent=n1;\n                n1.rank++;\n            }\n\n        }\n    }\n\n\n\n\n\n\n\n\n\n    public static void main(String[] args)  throws IOException {\n        Reader.init(System.in);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n        int t= Reader.nextInt();\n        for (int i = 0; i <t ; i++) {\n            long n= Reader.nextLong();\n            long x= Reader.nextLong();\n            long d1= Reader.nextLong();\n            long d2= Reader.nextLong();\n            boolean b1=false;\n            long b;\n            long a;\n            long c;\n            long rem= n-x;\n\n\n            if((x-d1-d2)%3==0 && (x+2*d1-d2)%3==0 && (x+2*d2-d1)%3==0){\n             //  System.out.println(1);\n                 b= (x-(d1+d2))/3;\n                 a=(x+2*d1-d2)/3;\n                 c=  (x+2*d2-d1)/3;\n                 if((n)%3==0 && (n/3)>=Math.max(a,Math.max(b,c)) && Math.min(a,Math.min(b,c))>=0) {\n                   //  System.out.println(1);\n                     b1=true;\n                     System.out.println(""yes"");\n                 }\n            }\n            if(!b1 && (x+d1+d2)%3==0 && (x-2*d1+d2)%3==0 && (x-2*d2+d1)%3==0 && (n)%3==0 && (n/3)>=Math.max((x+d1+d2)/3,Math.max((x-2*d1+d2)/3, (x-2*d2+d1)/3)) && Math.min((x+d1+d2)/3,Math.min((x-2*d1+d2)/3, (x-2*d2+d1)/3))>=0){\n                b1=true;\n               // System.out.println(2);\n                System.out.println(""yes"");\n\n            }\n            if(!b1 && (x-d1+d2)%3==0 && (x+2*d1+d2)%3==0 && (x-d1-2*d2)%3==0 && (n)%3==0 && (n/3)>=Math.max((x-d1+d2)/3,Math.max( (x+2*d1+d2)/3,(x-d1-2*d2)/3)) && Math.min((x-d1+d2)/3,Math.min( (x+2*d1+d2)/3,(x-d1-2*d2)/3))>=0) {\n                b1=true;\n               // System.out.println(3);\n                System.out.println(""yes"");\n            }\n            long q= d2;\n            d2=d1;\n            d1=q;\n\n\n            if(!b1 && (x-d1+d2)%3==0 && (x+2*d1+d2)%3==0 && (x-d1-2*d2)%3==0 && (n)%3==0 && (n/3)>=Math.max((x-d1+d2)/3, Math.max((x+2*d1+d2)/3,(x-d1-2*d2)/3 )) && Math.min((x-d1+d2)/3, Math.min((x+2*d1+d2)/3,(x-d1-2*d2)/3 ))>=0){\n                b1=true;\n               // System.out.println(4);\n                System.out.println(""yes"");\n            }\n            if(!b1){\n                System.out.println(""no"");\n            }\n\n\n\n\n\n\n\n\n\n\n\n\n        }\n\n\n\n\n\n\n\n\n\n\n\nout.flush();\n        out.close();\n\n    }\n    static int countDivisibles(int A, int B, int M)\n    {\n        // Add 1 explicitly as A is divisible by M\n        if (A % M == 0)\n            return (B / M) - (A / M) + 1;\n\n        // A is not divisible by M\n        return (B / M) - (A / M);\n    }\n\n\n    public static void df(int x, int y,int n, int m, char[][]ar, int l){\n        boolean done[][]= new boolean[n][m];\n        int count=0;\n        LinkedList<int[]> stk= new LinkedList<>();\n        int a[]= {x,y};\n        stk.addFirst(a);\n        while(!stk.isEmpty() && count<l){\n          //  count++;\n            int b[]=stk.removeFirst();\n            if( done[b[0]][b[1]]){\n                continue;\n            }\n            count++;\n\n            done[b[0]][b[1]]=true;\n            ar[b[0]][b[1]]='@';\n            int arr[][]={{1,0},{-1,0},{0,1},{0,-1}};\n            for (int i = 0; i <arr.length ; i++) {\n                if(!(b[0]+arr[i][0]>=n || b[1]+arr[i][1]>=m || b[0]+arr[i][0]<0 || b[1]+arr[i][1]<0 ||  ar[b[0]+arr[i][0]][b[1]+arr[i][1]]=='#')){\n                    int r[]= {b[0]+arr[i][0], b[1]+arr[i][1]};\n                    stk.addFirst(r);\n                   // continue;\n\n\n\n            }\n        }}\n\n\n        for (int i = 0; i <n ; i++) {\n            for (int j = 0; j <m ; j++) {\n                if(ar[i][j]=='.'){\n                    System.out.print('X');\n                }\n                else if(ar[i][j]=='@'){\n                    System.out.print('.');\n                }\n                else{\n                    System.out.print(ar[i][j]);\n                }\n            }\n            System.out.println();\n        }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    }\n\n\n\n\n\n\n\n\n\n\n\n    static long gcd(long a, long b)\n    {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n\n\n\n    static long gcd1(long a, long b)\n    {\n\n        // Everything divides 0\n        if (a == 0)\n            return b;\n        if (b == 0)\n            return a;\n\n        // base case\n        if (a == b)\n            return a;\n\n        // a is greater\n        //count++;\n        if (a > b){\n            return gcd(a-b, b);\n\n        }\n        return gcd(a, b-a);\n    }\n\n\n\n\n\n    // method to return LCM of two numbers\n    static long lcm(long a, long b)\n    {\n        return (a*b)/gcd(a, b);\n    }\n\n    // Driver method\n\n    static int partition(long arr[],long arr1[], int low, int high)\n    {\n        long pivot = arr[high];\n        int i = (low-1); // index of smaller element\n        for (int j=low; j<high; j++)\n        {\n            // If current element is smaller than the pivot\n            if (arr[j] < pivot)\n            {\n                i++;\n\n                // swap arr[i] and arr[j]\n                long temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n                long temp1=arr1[i];\n                arr1[i]=arr1[j];\n                arr1[j]=temp1;\n\n            }\n        }\n\n        // swap arr[i+1] and arr[high] (or pivot)\n        long temp = arr[i+1];\n        arr[i+1] = arr[high];\n        arr[high] = temp;\n        long temp1= arr1[i+1];\n        arr1[i+1]=arr1[high];\n        arr1[high]= temp1;\n\n        return i+1;\n    }\n\n\n    /* The main function that implements QuickSort()\n      arr[] --> Array to be sorted,\n      low  --> Starting index,\n      high  --> Ending index */\n    static void sort(long arr[],long arr1[], int low, int high)\n    {\n        if (low < high)\n        {\n            /* pi is partitioning index, arr[pi] is\n              now at right place */\n            int pi = partition(arr,arr1, low, high);\n\n            // Recursively sort elements before\n            // partition and after partition\n            sort(arr,arr1, low, pi-1);\n            sort(arr,arr1, pi+1, high);\n        }\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    public static ArrayList<Integer> Sieve(int n) {\n        boolean arr[]= new boolean [n+1];\n        Arrays.fill(arr,true);\n        arr[0]=false;\n        arr[1]=false;\n        for (int i = 2; i*i <=n ; i++) {\n            if(arr[i]){\n                for (int j = 2; j <=n/i ; j++) {\n                    int u= i*j;\n                    arr[u]=false;\n                }}\n        }\n        ArrayList<Integer> ans= new ArrayList<>();\n        for (int i = 0; i <n+1 ; i++) {\n            if(arr[i]){\n                ans.add(i);\n            }\n        }\n        return ans;\n\n\n\n\n\n\n\n\n\n\n    }\n\n\n\n\n\n}","brute force,implementation,math"
"import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n	public static void main(String[] args) {\n		InputStream inputStream = System.in;\n		OutputStream outputStream = System.out;\n		InputReader in = new InputReader(inputStream);\n		PrintWriter out = new PrintWriter(outputStream);\n		TaskE solver = new TaskE();\n		solver.solve(1, in, out);\n		out.close();\n	}\n}\n\nclass TaskE {\n    private static final int MODULO = 1051131;\n    private long days;\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = 1 << in.nextInt();\n        days = in.nextLong();\n        int s = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < s; ++i)\n            a[i] = in.nextInt() % MODULO;\n        for (int i = s; i < n; ++i)\n            a[i] = (101 * a[i - s] + 10007) % MODULO;\n        a = doIt(a, 1, 0);\n        int res = 0;\n        for (int i = 0; i < n; ++i) {\n            if (a[i] < 0)\n                a[i] += MODULO;\n            res ^= a[i];\n        }\n        out.println(res);\n    }\n\n    private int[] doIt(int[] a, int p, int q) {\n        int n = a.length;\n        assert (n & (n - 1)) == 0;\n        if (n == 1) {\n            a[0] = (int) (a[0] * IntegerUtils.powerModulo(p + q, days, MODULO) % MODULO);\n            return a;\n        }\n        n /= 2;\n        int[] b = new int[n];\n        for (int i = 0; i < n; ++i) {\n            b[i] = a[i] + a[i + n];\n            if (b[i] >= MODULO)\n                b[i] -= MODULO;\n        }\n        b = Arrays.copyOf(doIt(b, 2 * p % MODULO, (int) (((n - 1L) * p + q) % MODULO)), 2 * n);\n        System.arraycopy(b, 0, b, n, n);\n        long multiplier = IntegerUtils.powerModulo(((1L - n) * p + q) % MODULO, days, MODULO);\n        for (int i = 0; i < n; ++i) {\n            b[i] = (int) ((b[i] + (a[i] - a[i + n]) * multiplier) % MODULO);\n            b[i + n] = (int) ((b[i + n] - (a[i] - a[i + n]) * multiplier) % MODULO);\n        }\n        for (int i = 0; i < 2 * n; ++i)\n            b[i] = (int) (b[i] * (MODULO + 1L) / 2 % MODULO);\n        return b;\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String next() {\n        try {\n            while(tokenizer == null || !tokenizer.hasMoreTokens())\n                tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n}\n\nclass IntegerUtils {\n\n    public static long powerModulo(long a, long n, long mod) {\n        long res = 1;\n        for(; n > 0; n >>= 1) {\n            if((n & 1) != 0) res = res * a % mod;\n            a = a * a % mod;\n        }\n        return res;\n    }\n\n    }\n\n","math,matrices"
"\n\n/*\nTASK: template\nLANG: JAVA\n */\nimport java.io.*;\nimport java.lang.*;\nimport java.util.*;\n\npublic class C432 {\n    public static void main(String[] args) throws IOException{\n        StringBuffer ans = new StringBuffer();\n        StringTokenizer st;\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        st = new StringTokenizer(f.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int[] arr = new int[n];\n        int[] where = new int[n];\n        st = new StringTokenizer(f.readLine());\n        for(int i = 0; i < n; i++){\n            arr[i] = Integer.parseInt(st.nextToken())-1;\n            where[arr[i]] = i;\n        }\n        f.close();\n        ArrayList<Integer> primeList = getPrimeList(100000);\n        ArrayList<Integer> ft = new ArrayList<>();\n        ArrayList<Integer> sc = new ArrayList<>();\n        for(int i = 0; i < n; i++){\n            while(where[i] != i){\n                int r = Collections.binarySearch(primeList, where[i]-i);\n                if(r < 0) r = -r-2;\n                int move = primeList.get(r);\n                ft.add(where[i]-move);\n                sc.add(where[i]);\n                int tmp = where[i];\n                where[i] = where[i]-move;\n                where[arr[where[i]]] = tmp;\n                arr[tmp] = arr[where[i]];\n                arr[where[i]] = i;\n            }\n        }\n        ans.append(ft.size()).append(""\n"");\n        for(int i = 0; i < ft.size(); i++)\n            ans.append(ft.get(i)+1).append("" "").append(sc.get(i)+1).append(""\n"");\n\n        System.out.print(ans);\n\n    }\n    public static ArrayList<Integer> getPrimeList(int n){\n        ArrayList<Integer> arrl = new ArrayList<>();\n        boolean[] prime = new boolean[n + 1];\n        for (int i = 0; i <= n; i++)\n            prime[i] = true;\n\n        for (int p = 2; p * p <= n; p++)\n        {\n            if (prime[p])\n            {\n                for (int i = p * p; i <= n; i += p)\n                    prime[i] = false;\n            }\n        }\n\n        for (int i = 2; i <= n; i++)\n        {\n            if (prime[i])\n                arrl.add(i-1);\n        }\n        return arrl;\n    }\n}\n","greedy,sortings"
"import java.io.*;\nimport java.util.*;\npublic class Main implements Runnable{\n    boolean prime[];\n    TreeSet<Integer> primeSet;\n    void sieve(){\n        prime=new boolean[maxn+1];\n        Arrays.fill(prime,true);\n        for(int i=2;i*i<=maxn;i++){\n            if(prime[i]==false)\n                continue;\n            for(int j=i*i;j<=maxn;j+=i)\n                prime[j]=false;\n        }\n        primeSet=new TreeSet<>();\n        for(int i=2;i<=maxn;i++)\n            if(prime[i])\n                primeSet.add(i);\n    }\n    private void solve()throws IOException{\n        sieve();\n        int n=nextInt();\n        int a[]=new int[n+1];\n        int elem[]=new int[n+1];\n        for(int i=1;i<=n;i++){\n            elem[i]=nextInt();\n            a[elem[i]]=i;\n        }\n        ArrayList<Pair> list=new ArrayList<>();\n        for(int i=1;i<=n;i++){\n            while(a[i]!=i){\n                int diff=a[i]-i+1;\n                int j=prime[diff]?diff:primeSet.lower(diff);\n                int y=a[i]-j+1;\n                int x=a[i];\n                list.add(new Pair(y,x));\n                a[elem[y]]=x;\n                a[elem[x]]=y;\n                int temp=elem[y];\n                elem[y]=elem[x];\n                elem[x]=temp;\n            }            \n        }\n        out.println(list.size());\n        for(Pair p:list)\n            out.println(p.first+"" ""+p.second);\n    }\n    class Pair{\n        int first,second;\n        Pair(int a,int b){\n            first=a;\n            second=b;\n        }\n    }\n\n     \n    ///////////////////////////////////////////////////////////\n\n    final long mod=(long)(1e9+7);\n    final int inf=(int)(1e9+1);\n    final int maxn=(int)(1e5);\n    final long lim=(long)(1e18);\n\n    public void run(){\n        try{\n            br=new BufferedReader(new InputStreamReader(System.in));\n            st=null;\n            out=new PrintWriter(System.out);\n\n            solve();\n\n            // int t=nextInt();\n            // for(int i=1;i<=t;i++){\n            //     // out.print(""Case #""+i+"": "");\n            //     solve();\n            // }\n\n            br.close();\n            out.close();\n        }catch(Exception e){\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n    public static void main(String args[])throws IOException{\n        new Main().run();\n    } \n    int max(int ... a){\n        int ret=a[0];\n        for(int i=1;i<a.length;i++)\n        ret=Math.max(ret,a[i]);\n        return ret;\n    }\n    int min(int ... a){\n        int ret=a[0];\n        for(int i=1;i<a.length;i++)\n        ret=Math.min(ret,a[i]);\n        return ret;\n    }\n    void debug(Object ... a){\n        System.out.print(""> "");\n        for(int i=0;i<a.length;i++)\n        System.out.print(a[i]+"" "");\n        System.out.println();\n    }\n    void debug(int a[]){debuga(Arrays.stream(a).boxed().toArray());}\n    void debug(long a[]){debuga(Arrays.stream(a).boxed().toArray());}\n    void debuga(Object a[]){\n        System.out.print(""> "");\n        for(int i=0;i<a.length;i++)\n        System.out.print(a[i]+"" "");\n        System.out.println();\n    }\n    BufferedReader br;\n    StringTokenizer st;\n    PrintWriter out;\n    String nextToken()throws IOException{\n        while(st==null || !st.hasMoreTokens())\n        st=new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n    String nextLine()throws IOException{\n        return br.readLine();\n    }\n    int nextInt()throws IOException{\n        return Integer.parseInt(nextToken());\n    }\n    long nextLong()throws IOException{\n        return Long.parseLong(nextToken());\n    }\n    double nextDouble()throws IOException{\n        return Double.parseDouble(nextToken());\n    }\n}","greedy,sortings"
"import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class d {\n    static  BufferedReader s = new BufferedReader(new InputStreamReader(System.in));;\n    public static void main(String[] args) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        String[] s1=s();\n          int n=i(s1[0]);\n          String[] s2=s();\n          int[] a=new int[n];int[] pos=new int[n+1];\n          for(int i=0;i<n;i++){ a[i]=i(s2[i]);pos[a[i]]=i;}\n         int[] b=a.clone();\n          Arrays.sort(a);int ans=0;\n       // System.out.println(pos[1]+"" ""+pos[2]+"" ""+pos[3]);\n        int[] prime=new int[n+1];\n        for(int i=2;i<=n;i++){\n            if(isPrime(i)){\n                prime[i]=i;\n            }else prime[i]=prime[i-1];\n        }\n        for(int i=0;i<n;i++){\n            while(b[i]!=a[i]){ans++;\n                swap(i,pos[a[i]],b,pos,prime,sb);\n            }\n        }\n        System.out.println(ans);\n        System.out.println(sb.toString());\n    }\n    public static void swap(int i,int j,int [] b,int[] pos,int[] prime,StringBuilder sb){\n        i=j+1-prime[j-i+1];\n        sb.append((i+1)+"" ""+(j+1)+""\n"");\n        pos[b[i]]=j;pos[b[j]]=i;\n        int temp=b[i];\n        b[i]=b[j];\n        b[j]=temp;\n    }\n\n    static String[] s()throws  IOException{\n        return s.readLine().trim().split(""\\s+"");\n    }\n    static int i(String ss){\n        return Integer.parseInt(ss);\n    }\n    static long l(String ss) {return Long.parseLong(ss);}\n    static String lexographicallysmallest(String s) {\n        if (s.length() % 2 == 1) return s;\n        String s1 =lexographicallysmallest(s.substring(0, s.length()/2));\n        String s2 = lexographicallysmallest(s.substring(s.length()/2, s.length()));\n        if (s1.compareTo(s2)<0) return s1 + s2;\n        else return s2 + s1;\n    }\n    public static int countSetBits(int n) {\n        return (BitsSetTable256[n & 0xff]\n                + BitsSetTable256[(n >> 8) & 0xff]\n                + BitsSetTable256[(n >> 16) & 0xff]\n                + BitsSetTable256[n >> 24]);\n    }\n    static int[] BitsSetTable256 ;\n    public static void initialize(int n) {\n        BitsSetTable256[0] = 0;\n        for (int i = 0; i <=Math.pow(2,n); i++) {\n            BitsSetTable256[i] = (i & 1) + BitsSetTable256[i / 2];\n        }\n    }\n    static  void computeLPSArray(String pat, int M, int lps[]) {\n        int len = 0;\n        int i = 1;\n        lps[0] = 0;\n        while (i < M) {\n            if (pat.charAt(i) == pat.charAt(len)) {\n                len++;\n                lps[i] = len;\n                i++;\n            }\n            else\n            {\n                if (len != 0) {\n                    len = lps[len - 1];\n                }\n                else\n                {\n                    lps[i] = len;\n                    i++;\n                }\n            }\n        }\n    }\n    static boolean isPrime(int n) {\n        if (n <= 1) return false;\n        if (n <= 3) return true;\n\n        if (n % 2 == 0 || n % 3 == 0) return false;\n\n        for (int i = 5; i * i <= n; i = i + 6)\n            if (n % i == 0 || n % (i + 2) == 0)\n                return false;\n\n        return true;\n    }\n    static long powerwithmod(long  x, long y, long p) {\n        long  res = 1;\n        x = x % p;\n        while (y > 0) {\n            if ((y & 1) == 1)\n                res = (res * x) % p;\n            y = y >> 1;\n            x = (x * x) % p;\n        }\n        return res;\n    }\n    static long  powerwithoutmod(long x, int y) {\n        long  temp;\n        if( y == 0)\n            return 1;\n        temp = powerwithoutmod(x, y/2);\n        if (y%2 == 0)\n            return temp*temp;\n        else\n        {\n            if(y > 0)\n                return x * temp * temp;\n            else\n                return (temp * temp) / x;\n        }\n    }\n    static void fracion(double x) {\n        String a = """" + x;\n        String spilts[] = a.split(""\\.""); // split using decimal\n        int b = spilts[1].length(); // find the decimal length\n        int denominator = (int) Math.pow(10, b); // calculate the denominator\n        int numerator = (int) (x * denominator); // calculate the nerumrator Ex\n        // 1.2*10 = 12\n        int gcd = (int) gcd((long) numerator, denominator); // Find the greatest common\n        // divisor bw them\n        String fraction = """" + numerator / gcd + ""/"" + denominator / gcd;\n        // System.out.println((denominator/gcd));\n        long x1 = modInverse(denominator / gcd, 998244353);\n        //  System.out.println(x1);\n        System.out.println((((numerator / gcd) % 998244353 * (x1 % 998244353)) % 998244353));\n    }\n    static int bfs(int i1, ArrayList<Integer>[] h, int[] vis, int n,int val1) {\n        Queue<Integer> q = new LinkedList<Integer>();\n        q.add(i1);Queue<Integer> aq=new LinkedList<Integer>();\n        aq.add(0);\n        while(!q.isEmpty()){\n            int i=q.poll();\n            int val=aq.poll();\n            if(i==n){\n                return val;\n            }\n            if(h[i]!=null){\n                for(Integer j:h[i]){\n                    if(vis[j]==0){\n                        q.add(j);vis[j]=1;\n                        aq.add(val+1);}\n                }\n            }\n        }return -1;\n    }\n    static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    static long modInverse(long a, long m)\n    {\n        return (powerwithmod(a, m - 2, m));\n    }\n    static int MAXN;\n    static int[] spf;\n    static void sieve() {\n        spf[1] = 1;\n        for (int i=2; i<MAXN; i++)\n            spf[i] = i;\n        for (int i=4; i<MAXN; i+=2)\n            spf[i] = 2;\n        for (int i=3; i*i<MAXN; i++)\n        {\n            if (spf[i] == i)\n            {\n                for (int j=i*i; j<MAXN; j+=i)\n\n                    if (spf[j]==j)\n                        spf[j] = i;\n            }\n        }\n    }\n    static ArrayList<Integer> getFactorizationUsingSeive(int x) {\n        ArrayList<Integer> ret = new ArrayList<Integer>();\n        while (x != 1)\n        {\n            ret.add(spf[x]);\n            if(spf[x]!=0)   x = x / spf[x];\n            else break;       }\n        return ret;\n    }\n    static long[] fac ;\n    static void calculatefac(long mod){\n        fac[0]=1;\n        for (int i = 1 ;i <= MAXN; i++)\n            fac[i] = fac[i-1] * i % mod;\n    }\n    static long nCrModPFermat(int n, int r, long mod) {\n        if (r == 0)\n            return 1;\n        fac[0] = 1;\n        return (fac[n]*\n                modInverse(fac[r], mod)\n                % mod * modInverse(fac[n-r], mod)\n                % mod) % mod;\n    } }\nclass Student {\n    int  l;long r;\n    public Student(int l, long r) {\n        this.l = l;\n        this.r = r;\n    }\n\n    public String toString()\n    {\n        return this.l+"" "";\n    }\n}\nclass Sortbyroll implements Comparator<Student> {\n\n    public int compare(Student a, Student b){\n        if(a.r<b.r) return -1;\n        else if(a.r==b.r){\n            if(a.r==b.r){\n                return 0;\n            }\n            if(a.r<b.r) return -1;\n            return 1;}\n        return 1;  }\n}","greedy,sortings"
"//package CodeForces;\n\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class PrimeSwaps {\n	\n	static int solve(int temp[],int index,int num,int arr[],StringBuilder ans,HashMap<Integer,Integer> map)\n	{\n		if(index==temp.length)\n		{\n			return 0;\n		}\n		int count=0;\n		if(temp[index]==num)\n		{\n			count=count+solve(temp,index+1,num+1,arr,ans,map);\n		}\n		else\n		{\n			count++;\n			int small=map.get(num);\n			int ind=small-arr[small-index+1]+1;\n			int prev=temp[small];\n			map.put(temp[small],ind);map.put(temp[ind],small);\n			temp[small]=temp[ind];\n			temp[ind]=prev;\n			ans.append((ind+1)+"" ""+(small+1)+""\n"");\n			count=count+solve(temp,index,num,arr,ans,map);\n		}\n		return count;\n	}\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner s=new Scanner(System.in);\n		int n=s.nextInt();\n		int arr[]=new int[100001];\n		for(int i=2;i<arr.length;i++)\n		{\n			if(arr[i]==0)\n			{\n				for(int j=2*i;j<arr.length;j=j+i)\n				{\n					arr[j]=-1;\n				}\n				arr[i]=i;\n			}\n		}\n		int prev=0;\n		for(int i=2;i<arr.length;i++)\n		{\n			if(arr[i]==-1)\n			{\n				arr[i]=prev;\n			}\n			else\n			{\n				prev=arr[i];\n			}\n		}\n		int temp[]=new int[n];\n		HashMap<Integer,Integer> map=new HashMap<>();\n		for(int i=0;i<n;i++)\n		{\n			temp[i]=s.nextInt();\n			map.put(temp[i],i);\n		}\n		StringBuilder ans=new StringBuilder();\n		int count=solve(temp,0,1,arr,ans,map);\n		System.out.println(count);\n		System.out.println(ans);\n		\n\n	}\n\n}\n","greedy,sortings"
"import java.util.Scanner;\n \npublic class Main {\n	\n	public static int[][] a=new int[1005][1005];\n	public static int[][] dp1=new int[1005][1005];\n	public static int[][] dp2=new int[1005][1005];\n	public static int[][] dp3=new int[1005][1005];\n	public static int[][] dp4=new int[1005][1005];\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		int n,m;\n		Scanner sc=new Scanner(System.in);\n		n=sc.nextInt();\n		m=sc.nextInt();\n		for(int i=1;i<=n;i++){\n			for(int j=1;j<=m;j++){\n				a[i][j]=sc.nextInt();\n			}\n		}\n		for(int i=1;i<=n;i++){\n			for(int j=1;j<=m;j++){\n				dp1[i][j]=Math.max(dp1[i-1][j],dp1[i][j-1])+a[i][j];\n			}\n		}\n		for(int i=n;i>0;i--){\n			for(int j=1;j<=m;j++){\n				dp2[i][j]=Math.max(dp2[i+1][j],dp2[i][j-1])+a[i][j];\n			}\n		}\n		for(int i=1;i<=n;i++){\n			for(int j=m;j>0;j--){\n				dp3[i][j]=Math.max(dp3[i-1][j],dp3[i][j+1])+a[i][j];\n			}\n		}\n		for(int i=n;i>0;i--){\n			for(int j=m;j>0;j--){\n				dp4[i][j]=Math.max(dp4[i+1][j],dp4[i][j+1])+a[i][j];\n			}\n		}\n		int ans=0;\n		for(int i=2;i<n;i++){\n			for(int j=2;j<m;j++){\n				ans=Math.max(dp1[i-1][j]+dp4[i+1][j]+dp2[i][j-1]+dp3[i][j+1],ans);\n				ans=Math.max(dp1[i][j-1]+dp4[i][j+1]+dp2[i+1][j]+dp3[i-1][j],ans);\n			}\n		}\n		System.out.println(ans);\n	}\n \n}",dp
"import java.util.Scanner;\n\npublic class WorkingOut {\n    public static void main(String[] args) {\n        Scanner scn = new Scanner(System.in);\n        int n = scn.nextInt(), m = scn.nextInt();\n        int[][] arr = new int[n+1][m+1];\n        for(int i = 1 ; i <= n; i++) {\n            for(int j = 1; j <= m; j++) {\n                arr[i][j] = scn.nextInt();\n            }\n        }\n        int[][][] dp = new int[n+5][m+5][4];\n        for(int i = 1 ; i <= n; i++) {\n            for(int j = 1; j <= m; j++) {\n                dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i][j-1][0]) + arr[i][j];\n            }\n        }\n        for(int i = n ; i >= 1; i--) {\n            for(int j = m; j >= 1; j--) {\n                dp[i][j][1] = Math.max(dp[i+1][j][1], dp[i][j+1][1]) + arr[i][j];\n            }\n        }\n        for(int i = n; i >= 1; i--) {\n            for(int j = 1; j <= m; j++) {\n                dp[i][j][2] = Math.max(dp[i+1][j][2], dp[i][j-1][2]) + arr[i][j];\n            }\n        }\n        for(int i = 1 ; i <= n; i++) {\n            for(int j = m; j >= 1; j--) {\n                dp[i][j][3] = Math.max(dp[i-1][j][3], dp[i][j+1][3]) + arr[i][j];\n            }\n        }\n        int ans = 0;\n        for(int i = 2; i < n; i++) {\n            for(int j = 2; j < m; j++) {\n                ans = Math.max(ans, dp[i-1][j][0]+dp[i+1][j][1]+dp[i][j-1][2]+dp[i][j+1][3]);\n                ans = Math.max(ans, dp[i][j-1][0]+dp[i][j+1][1]+dp[i+1][j][2]+dp[i-1][j][3]);\n            }\n        }\n        System.out.println(ans);\n    }\n}\n",dp
"import java.util.Scanner;\n\npublic class Main {\n    public static void main(String agrs[])throws Exception{\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int m=sc.nextInt();\n        int a[][]=new int[n+1][m+1];\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=m;j++){\n                a[i][j]=sc.nextInt();\n            }\n        }\n        int dp1[][]=new int[n+2][m+2];\n        int dp2[][]=new int[n+2][m+2];\n        int dp3[][]=new int[n+2][m+2];\n        int dp4[][]=new int[n+2][m+2];\n        //dp1\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=m;j++){\n                dp1[i][j]=Math.max(dp1[i][j-1],dp1[i-1][j])+a[i][j];\n            }\n        }\n        //dp2\n        for(int i=n;i>=1;i--){\n            for(int j=1;j<=m;j++){\n                dp2[i][j]=Math.max(dp2[i+1][j],dp2[i][j-1])+a[i][j];\n            }\n        }\n        //dp3\n        for(int i=1;i<=n;i++){\n            for(int j=m;j>=1;j--){\n                dp3[i][j]=Math.max(dp3[i-1][j],dp3[i][j+1])+a[i][j];\n            }\n        }\n        //dp4\n        for(int i=n;i>=1;i--){\n            for(int j=m;j>=1;j--){\n                dp4[i][j]=Math.max(dp4[i][j+1],dp4[i+1][j])+a[i][j];\n            }\n        }\n        //solve\n        int max=0;\n        for(int i=2;i<n;i++){\n            for(int j=2;j<m;j++){\n                int x=dp1[i-1][j]+dp2[i][j-1]+dp3[i][j+1]+dp4[i+1][j];\n                int y=dp1[i][j-1]+dp2[i+1][j]+dp3[i-1][j]+dp4[i][j+1];\n                max=Math.max(max,Math.max(x,y));\n\n            }\n        }\n        System.out.println(max);\n    }\n}\n",dp
"import java.util.Scanner;\n\nimport static java.lang.Math.max;\n\npublic class workOut {\n    public static int maxN = 1010;\n    static int n , m;\n    static int [][] a = new int[maxN][maxN];\n    static int [][][] dp = new int [5][maxN][maxN];\n    static int ans;\n    public static void main(String [] args){\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        m = sc.nextInt();\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= m; j++)\n                a[i][j] = sc.nextInt();\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= m; j++)\n                dp[1][i][j] = a[i][j] + max(dp[1][i - 1][j], dp[1][i][j - 1]);\n\n        for (int i = 1; i <= n; i++)\n            for (int j = m; j >= 1; j--)\n                dp[2][i][j] = a[i][j] + max(dp[2][i - 1][j], dp[2][i][j + 1]);\n\n        for (int i = n; i >= 1; i--) {\n            for (int j = 1; j <= m; j++)\n                dp[3][i][j] = a[i][j] + max(dp[3][i + 1][j], dp[3][i][j - 1]);\n        }\n\n        for (int i = n; i >= 1; i--) {\n            for (int j = m; j >= 1; j--)\n                dp[4][i][j] = a[i][j] + max(dp[4][i + 1][j], dp[4][i][j + 1]);\n        }\n        for (int i = 2; i <= n - 1; i++) {\n            for (int j = 2; j <= m - 1; j++) {\n                int temp;\n                temp = dp[1][i][j - 1] + dp[3][i + 1][j] + dp[2][i - 1][j] + dp[4][i][j + 1];\n                temp = Math.max(temp, dp[1][i - 1][j] + dp[3][i][j - 1] + dp[2][i][j + 1] + dp[4][i + 1][j]);\n                ans = Math.max(ans, temp);\n            }\n        }\n        System.out.println(ans);\n    }\n}\n",dp
"import java.util.*;\nimport java.io.*;\n\npublic class d\n{\n	public static void main(String[] arg) throws IOException\n	{\n		new d();\n	}	\n	public d() throws IOException\n	{\n		FastScanner in = new FastScanner(System.in);\n		PrintWriter out = new PrintWriter(System.out);\n\n		int n = in.nextInt();\n		int[] x = new int[n];\n		int[] y = new int[n];\n		HashSet<Integer>[] xList = new HashSet[100_001];\n		HashSet<Integer>[] yList = new HashSet[100_001];\n		int[] xCount = new int[100_001];\n		int[] yCount = new int[100_001];\n		for(int i = 0; i < n; i++)\n		{\n			x[i] = in.nextInt();\n			y[i] = in.nextInt();\n			xCount[x[i]]++;\n			yCount[y[i]]++;\n		}\n		int[][] xl = new int[100_001][];\n		int[][] yl = new int[100_001][];\n\n		for(int i = 0; i <= 100_000; i++)\n		{\n			xl[i] = new int[xCount[i]];\n			yl[i] = new int[yCount[i]];\n			xCount[i] = 0;\n			yCount[i] = 0;\n		}\n		for(int i = 0; i < n; i++)\n		{\n			if(xList[x[i]] == null) xList[x[i]] = new HashSet<Integer>();\n			if(yList[y[i]] == null) yList[y[i]] = new HashSet<Integer>();\n			xList[x[i]].add(y[i]);\n			yList[y[i]].add(x[i]);\n			xl[x[i]][xCount[x[i]]++] = y[i];\n			yl[y[i]][yCount[y[i]]++] = x[i];\n		}\n		for(int i = 0; i <= 100_000; i++)\n		{\n			Arrays.sort(xl[i]);\n			Arrays.sort(yl[i]);\n		}\n		long ans = 0;\n		for(int i = 0; i < n; i++)\n		{\n			if(xl[x[i]].length <= yl[y[i]].length)\n			{\n				for(int v : xl[x[i]])\n				{\n					if(v >= y[i]) break;\n					int dist = y[i]-v;\n					if(x[i]-dist >= 0 && xList[x[i]-dist] != null && xList[x[i]-dist].contains(y[i]) && xList[x[i]-dist].contains(v))\n					{\n						ans++;\n					}\n				}\n			}\n			else\n			{\n				for(int v : yl[y[i]])\n				{\n					if(v >= x[i]) break;\n					int dist = x[i]-v;\n					if(y[i]-dist >= 0 && yList[y[i]-dist] != null && yList[y[i]-dist].contains(x[i]) && yList[y[i]-dist].contains(v))\n					{\n						ans++;\n					}\n				}\n			}\n		}\n\n		out.println(ans);\n		in.close(); out.close();\n	}\n	class FastScanner\n	{\n		BufferedReader br;\n		StringTokenizer st;\n		public FastScanner(InputStream in)\n		{\n			br = new BufferedReader(new InputStreamReader(in));\n			st = new StringTokenizer("""");\n		}\n		public String next() throws IOException\n		{\n			while(!st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n			return st.nextToken();\n		}\n		public int nextInt() throws IOException\n		{\n			return Integer.parseInt(next());\n		}\n		public void close() throws IOException\n		{\n			br.close();\n		}\n	}\n}\n","binary search,data structures,hashing"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF425D extends PrintWriter {\n	CF425D() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF425D o = new CF425D(); o.main(); o.flush();\n	}\n\n	static final int K = 200, Y = 100000;\n	static class P {\n		int x, y;\n		P(int x, int y) {\n			this.x = x; this.y = y;\n		}\n	}\n	static Random rand = new Random();\n	static class V {\n		V l, r;\n		long key;\n		int x;\n		V(long key) {\n			this.key = key;\n			x = rand.nextInt();\n		}\n	}\n	V v_, l_, r_;\n	void split(V v, long key) {\n		if (v == null) {\n			v_ = l_ = r_ = null;\n		} else if (v.key < key) {\n			split(v.r, key);\n			v.r = l_; l_ = v;\n		} else if (v.key > key) {\n			split(v.l, key);\n			v.l = r_; r_ = v;\n		} else {\n			v_ = v; l_ = v.l; r_ = v.r;\n			v.l = v.r = null;\n		}\n	}\n	V merge(V u, V v) {\n		if (u == null)\n			return v;\n		if (v == null)\n			return u;\n		if (u.x < v.x) {\n			u.r = merge(u.r, v);\n			return u;\n		} else {\n			v.l = merge(u, v.l);\n			return v;\n		}\n	}\n	boolean has(long key) {\n		split(v_, key);\n		boolean ans = v_ != null;\n		v_ = merge(l_, merge(v_, r_));\n		return ans;\n	}\n	void add(long key) {\n		split(v_, key);\n		if (v_ == null)\n			v_ = new V(key);\n		v_ = merge(l_, merge(v_, r_));\n	}\n	long compose(int x, int y) {\n		return (long) x * (Y + 1) + y;\n	}\n	void main() {\n		int n = sc.nextInt();\n		P[] pp = new P[n];\n		for (int i = 0; i < n; i++) {\n			int x = sc.nextInt();\n			int y = sc.nextInt();\n			pp[i] = new P(x, y);\n			add(compose(x, y));\n		}\n		int[] ll = new int[Y + 1];\n		int[] rr = new int[Y + 1]; Arrays.fill(rr, -1);\n		Arrays.sort(pp, (p, q) -> p.y != q.y ? p.y - q.y : p.x - q.x);\n		int[] yy = new int[n]; int cnt = 0;\n		for (int i = 0, j; i < n; i = j) {\n			int y = pp[i].y;\n			j = i + 1;\n			while (j < n && pp[j].y == y)\n				j++;\n			ll[y] = i; rr[y] = j;\n			if (j - i > K)\n				yy[cnt++] = y;\n		}\n		int ans = 0;\n		for (int h = 0; h < cnt; h++) {\n			int y = yy[h], l = ll[y], r = rr[y];\n			for (int h_ = h + 1; h_ < cnt; h_++) {\n				int y_ = yy[h_], l_ = ll[y_], r_ = rr[y_];\n				for (int i = l, j = l, i_ = l_, j_ = l_; i < r && j < r && i_ < r_ && j_ < r_; i++) {\n					int x = pp[i].x, x_ = x + y_ - y;\n					while (j < r && pp[j].x < x_)\n						j++;\n					if (j < r && pp[j].x == x_) {\n						while (i_ < r_ && pp[i_].x < x)\n							i_++;\n						if (i_ < r_ && pp[i_].x == x) {\n							while (j_ < r_ && pp[j_].x < x_)\n								j_++;\n							if (j_ < r_ && pp[j_].x == x_)\n								ans++;\n						}\n					}\n				}\n			}\n		}\n		for (int y = 0; y <= Y; y++) {\n			int l = ll[y], r = rr[y];\n			if (r - l > K)\n				continue;\n			for (int i = l; i < r; i++)\n				for (int j = i + 1; j < r; j++) {\n					int x = pp[i].x, x_ = pp[j].x, y_, l_, r_;\n					y_ = y - (x_ - x);\n					if (y_ >= 0 && rr[y_] - ll[y_] > K && has(compose(x, y_)) && has(compose(x_, y_)))\n						ans++;\n					y_ = y + (x_ - x);\n					if (y_ <= Y && rr[y_] - ll[y_] > 0 && has(compose(x, y_)) && has(compose(x_, y_)))\n						ans++;\n				}\n		}\n		println(ans);\n	}\n}\n","binary search,data structures,hashing"
"import java.io.*;\nimport java.util.*;\n\npublic class D {\n\n	BufferedReader br;\n	PrintWriter out;\n	StringTokenizer st;\n	boolean eof;\n\n	static class Point {\n		int x, y;\n\n		@Override\n		public int hashCode() {\n			return x * 1235768 + y * 8636123;\n		}\n\n		@Override\n		public boolean equals(Object obj) {\n			if (this == obj)\n				return true;\n			if (obj == null)\n				return false;\n			Point other = (Point) obj;\n			return x == other.x && y == other.y;\n		}\n\n		public Point(int x, int y) {\n			this.x = x;\n			this.y = y;\n		}\n	}\n\n	Comparator<Point> byX = new Comparator<Point>() {\n\n		@Override\n		public int compare(Point o1, Point o2) {\n			if (o1.x != o2.x) {\n				return Integer.compare(o1.x, o2.x);\n			}\n			return Integer.compare(o1.y, o2.y);\n		}\n	};\n\n	Comparator<Point> byY = new Comparator<Point>() {\n\n		@Override\n		public int compare(Point o1, Point o2) {\n			if (o1.y != o2.y) {\n				return Integer.compare(o1.y, o2.y);\n			}\n			return Integer.compare(o1.x, o2.x);\n		}\n	};\n\n	void solve() throws IOException {\n		int n = nextInt();\n		Point[] ax = new Point[n];\n		Set<Point> set = new HashSet<>();\n		for (int i = 0; i < n; i++) {\n			ax[i] = new Point(nextInt(), nextInt());\n			set.add(ax[i]);\n		}\n		\n		Point[] ay = ax.clone();\n		Arrays.sort(ax, byX);\n		Arrays.sort(ay, byY);\n		\n		Point tmp = new Point(0, 0);\n		\n		long ans = 0;\n		\n		for (int ix = 0; ix < n; ix++) {\n			Point cur = ax[ix];\n			int x1 = cur.x;\n			int y1 = cur.y;\n			int iy = Arrays.binarySearch(ay, cur, byY);\n			\n			tmp.x = x1;\n			tmp.y = INF;\n			int jx = ~Arrays.binarySearch(ax, tmp, byX);\n			\n			tmp.x = INF;\n			tmp.y = y1;\n			int jy = ~Arrays.binarySearch(ay, tmp, byY);\n			\n			if (jx - ix < jy - iy) {\n				for (int k = ix + 1; k < jx; k++) {\n					Point p = ax[k];\n					int y2 = p.y;\n					int x2 = x1 + (y2 - y1);\n					tmp.x = x2;\n					tmp.y = y1;\n					if (set.contains(tmp)) {\n						tmp.y = y2;\n						if (set.contains(tmp)) {\n							ans++;\n						}\n					}\n				}\n			} else {\n				for (int k = iy + 1; k < jy; k++) {\n					Point p = ay[k];\n					int x2 = p.x;\n					int y2 = y1 + (x2 - x1);\n					tmp.x = x1;\n					tmp.y = y2;\n					if (set.contains(tmp)) {\n						tmp.x = x2;\n						if (set.contains(tmp)) {\n							ans++;\n						}\n					}\n				}\n			}\n		}\n		\n		out.println(ans);\n\n	}\n	\n	static final int INF = 100001;\n\n	D() throws IOException {\n		br = new BufferedReader(new InputStreamReader(System.in));\n		out = new PrintWriter(System.out);\n		solve();\n		out.close();\n	}\n\n	public static void main(String[] args) throws IOException {\n		new D();\n	}\n\n	String nextToken() {\n		while (st == null || !st.hasMoreTokens()) {\n			try {\n				st = new StringTokenizer(br.readLine());\n			} catch (Exception e) {\n				eof = true;\n				return null;\n			}\n		}\n		return st.nextToken();\n	}\n\n	String nextString() {\n		try {\n			return br.readLine();\n		} catch (IOException e) {\n			eof = true;\n			return null;\n		}\n	}\n\n	int nextInt() throws IOException {\n		return Integer.parseInt(nextToken());\n	}\n\n	long nextLong() throws IOException {\n		return Long.parseLong(nextToken());\n	}\n\n	double nextDouble() throws IOException {\n		return Double.parseDouble(nextToken());\n	}\n}","binary search,data structures,hashing"
"/*************************************************************************\n  >         File: Main.java\n  >       Author: Riho.Yoshioka\n  >         Mail: riho.yoshioka@yandex.com\n  > Created Time: Sat 30 Jul 2016 09:10:15 PM CST\n*************************************************************************/\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    PrintWriter out = new PrintWriter(outputStream);\n    \n    TaskD solver = new TaskD();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskD {\n    static final int N = 123457;\n    \n    private int hashCode(int x, int y) {\n      return x * N + y;\n    }\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n      int n = in.nextInt();\n      HashSet<Integer> mp = new HashSet<>();\n      ArrayList<Integer>[] points = new ArrayList[100001];\n      for (int i = 0; i < 100001; i++) {\n        points[i] = new ArrayList<>();\n      }\n      for (int i = 0; i < n; i++) {\n        int x = in.nextInt(), y = in.nextInt();\n        points[x].add(y);\n        mp.add(hashCode(x, y));\n      }\n      int sqrt = 320;\n      long answer = 0;\n      for (int i = 0; i < 100001; i++) {\n        Collections.sort(points[i]);\n      }\n      for (int i = 0; i < 100001; i++) {\n        if (points[i].isEmpty()) continue;\n        if (points[i].size() <= sqrt) {\n          for (int a = 0; a < points[i].size(); a++) {\n            for (int b = a + 1; b < points[i].size(); b++) {\n              int distance = points[i].get(b) - points[i].get(a);\n              int hash1 = hashCode(i - distance, points[i].get(a));\n              int hash2 = hashCode(i - distance, points[i].get(b));\n              if (mp.contains(hash1) && mp.contains(hash2)) answer++;\n              if (i + distance < 100001 && points[i + distance].size() > sqrt) {\n                hash1 = hashCode(i + distance, points[i].get(a));\n                hash2 = hashCode(i + distance, points[i].get(b));\n                if (mp.contains(hash1) && mp.contains(hash2)) answer++;\n              }\n            }\n          }\n        }\n        else {\n          for (int j = i + 1; j < 100001; j++) {\n            if (points[j].size() <= sqrt) continue;\n            int a = 0, b = 0;\n            while (a < points[i].size() && b < points[j].size()) {\n              int x = points[i].get(a);\n              int y = points[j].get(b);\n              if (x == y) {\n                a++;\n                int distance = j - i;\n                int hash1 = hashCode(i, x + distance);\n                if (!mp.contains(hash1)) continue;\n                int hash2 = hashCode(j, y + distance);\n                if (!mp.contains(hash2)) continue;\n                answer++;\n              }\n              else if (x < y) a++;\n              else b++;\n            }\n          }\n        }\n      }\n      out.println(answer);\n    }\n  }\n\n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream), 32768);\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n\n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n  }\n}\n","binary search,data structures,hashing"
"import java.util.*;\n\npublic class Program\n{\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n        int n=in.nextInt(),m[]=new int[100001];\n        for(int i=0;i<n;i++)\n        {\n            int x=in.nextInt(),k=in.nextInt();\n            if(m[k]<x)\n            {\n                System.out.println(""NO"");\n                return;\n            }\n            else if(m[k]==x)\n                m[k]++;\n        }\n        System.out.println(""YES"");\n    }\n}",implementation
"import java.util.Scanner;\n\npublic class B417 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int N = in.nextInt();\n        int[] stat = new int[100001];\n        boolean ok = true;\n        for (int n=0; n<N; n++) {\n            int x = in.nextInt();\n            int k = in.nextInt();\n            int seen = stat[k];\n            if (seen < x) {\n                ok = false;\n            } else if (seen == x) {\n                stat[k]++;\n            }\n        }\n        System.out.println(ok ? ""YES"" : ""NO"");\n    }\n\n}\n",implementation
"import java.util.*;\nimport java.io.*;\nimport java.lang.*;\n\n\npublic class B417 {\n\n  public static void main(String[] args) {\n    \n    int n;\n    int[] previous = new int[100001];\n    Arrays.fill(previous, -1);\n\n    Scanner s = new Scanner(System.in);\n    n = s.nextInt();\n    int x, k;\n    Boolean complete = false;\n    for(int i=0;i<n && !complete; i++){\n      x = s.nextInt();\n      k = s.nextInt();\n      complete = x - previous[k] > 1;\n      previous[k] = Math.max(x, previous[k]);\n      if(complete)\n        System.out.println(""NO"");\n    }\n\n    if(!complete)\n      System.out.println(""YES"");\n  }\n}\n",implementation
"import java.util.Scanner;\n\n\npublic final class test_B {\n\n    public static void main(String[] args) {\n        Scanner datain = new Scanner(System.in);\n        int n = datain.nextInt();\n        int res=1;\n        int[]k;\n        k = new int[100000];\n        for(int i=1;i<=100000;i++){k[i-1]=0;}\n        for (int i=1;i<=n;i++){\n            int prev_N = datain.nextInt();\n            int pst=datain.nextInt();\n            if(k[pst-1]<prev_N){res=0;}\n            if(k[pst-1]==prev_N){k[pst-1]++;}\n        }\n        if(res==1){System.out.print(""YES"");}else{System.out.print(""NO"");}\n    }\n\n}\n",implementation
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF200E extends PrintWriter {\n	CF200E() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF200E o = new CF200E(); o.main(); o.flush();\n	}\n\n	int d_, x_, y_;\n	void gcd_(int a, int b) {\n		if (b == 0) {\n			d_ = a;\n			x_ = 1; y_ = 0;\n		} else {\n			gcd_(b, a % b);\n			int t = x_ - a / b * y_; x_ = y_; y_ = t;\n		}\n	}\n	int div(int a, int b) {	// b > 0\n		return a >= 0 ? a / b : -((-a + b - 1) / b);\n	}\n	void main() {\n		int n = sc.nextInt();\n		int s = sc.nextInt();\n		int c3 = 0, c4 = 0, c5 = 0;\n		for (int i = 0; i < n; i++) {\n			int a = sc.nextInt();\n			if (a == 3)\n				c3++;\n			else if (a == 4)\n				c4++;\n			else\n				c5++;\n		}\n		gcd_(c4, c5);\n		int c4_ = c4 / d_, c5_ = c5 / d_;\n		int ans = -1, a3 = -1, a4 = -1, a5 = -1;\n		for (int k3 = 0; k3 * n <= s; k3++) {\n			int t = s - c3 * k3;\n			if (t % d_ != 0)\n				continue;\n			t /= d_;\n			int k4_ = x_ * t, k5_ = y_ * t;\n			// k4 = k4_ + c5_ * k\n			// k5 = k5_ - c4_ * k\n\n			// k4 >= k3\n			// k4_ + c5_ * k >= k3\n			// k4_ + c5_ * k > k3 - 1\n			// c5_ * k > k3 - k4_ - 1\n			// k > (k3 - k4_ - 1) / c5_\n			// k >= (k3 - k4_ - 1) / c5_ + 1\n			int lower = div(k3 - k4_ - 1, c5_) + 1;\n\n			// k5 >= k4\n			// k5_ - c4_ * k >= k4_ + c5_ * k\n			// (c4_ + c5_) * k <= k5_ - k4_\n			// k <= (k5_ - k4_) / (c4_ + c5_)\n			int upper = div(k5_ - k4_, c4_ + c5_);\n\n			if (lower > upper)\n				continue;\n\n			// c3 * k3 >= c4 * k4\n			// c3 * k3 >= c4 * (k4_ + c5_ * k)\n			// c4 * c5_ * k <= c3 * k3 - c4 * k4_\n			// k <= (c3 * k3 - c4 * k4_) / (c4 * c5_)\n			int upper34 = div(c3 * k3 - c4 * k4_, c4 * c5_);\n			// c3 * k3 < c4 * k4\n			int lower34 = upper34 + 1;\n\n			// c4 * k4 >= c5 * k5\n			// c4 * (k4_ + c5_ * k) >= c5 * (k5_ - c4_ * k)\n			// (c4 * c5_ + c5 * c4_) * k >= c5 * k5_ - c4 * k4_\n			// (c4 * c5_ + c5 * c4_) * k > c5 * k5_ - c4 * k4_ - 1\n			// k > (c5 * k5_ - c4 * k4_ - 1) / (c4 * c5_ + c5 * c4_)\n			// k >= (c5 * k5_ - c4 * k4_ - 1) / (c4 * c5_ + c5 * c4_) + 1\n			int lower45 = div(c5 * k5_ - c4 * k4_ - 1, c4 * c5_ + c5 * c4_) + 1;\n			// c4 * k4 < c5 * k5\n			int upper45 = lower45 - 1;\n\n			// Case 1: c3 * k3 >= c4 * k4 && c4 * k4 >= c5 * k5\n			// goal\n			// = c3 * k3 - c4 * k4 + c4 * k4 - c5 * k5\n			// = c3 * k3 - c5 * k5\n			// = c3 * k3 - c5 * (k5_ - c4_ * k)\n			// +k\n			// minimize k\n			int lower1 = Math.max(lower, lower45);\n			int upper1 = Math.min(upper, upper34);\n			if (lower1 <= upper1) {\n				int k = lower1;\n				int k4 = k4_ + c5_ * k;\n				int k5 = k5_ - c4_ * k;\n				int goal = Math.abs(c3 * k3 - c4 * k4) + Math.abs(c4 * k4 - c5 * k5);\n				if (ans == -1 || ans > goal) {\n					ans = goal;\n					a3 = k3; a4 = k4; a5 = k5;\n				}\n			}\n			// Case 2: c3 * k3 >= c4 * k4 && c4 * k4 < c5 * k5\n			// goal\n			// = c3 * k3 - c4 * k4 - c4 * k4 + c5 * k5\n			// = c3 * k3 - 2 * c4 * k4 + c5 * k5\n			// = c3 * k3 - 2 * c4 * (k4_ + c5_ * k) + c5 * (k5_ - c4_ * k)\n			// -k\n			// maximize k\n			int lower2 = lower;\n			int upper2 = Math.min(upper, Math.min(upper34, upper45));\n			if (lower2 <= upper2) {\n				int k = upper2;\n				int k4 = k4_ + c5_ * k;\n				int k5 = k5_ - c4_ * k;\n				int goal = Math.abs(c3 * k3 - c4 * k4) + Math.abs(c4 * k4 - c5 * k5);\n				if (ans == -1 || ans > goal) {\n					ans = goal;\n					a3 = k3; a4 = k4; a5 = k5;\n				}\n			}\n			// Case 3: c3 * k3 < c4 * k4 && c4 * k4 < c5 * k5\n			// goal\n			// = -c3 * k3 + c4 * k4 - c4 * k4 + c5 * k5\n			// = -c3 * k3 + c5 * k5\n			// = -c3 * k3 + c5 * (k5_ - c4_ * k)\n			// -k\n			// maximize k\n			int lower3 = Math.max(lower, lower34);\n			int upper3 = Math.min(upper, upper45);\n			if (lower3 <= upper3) {\n				int k = upper3;\n				int k4 = k4_ + c5_ * k;\n				int k5 = k5_ - c4_ * k;\n				int goal = Math.abs(c3 * k3 - c4 * k4) + Math.abs(c4 * k4 - c5 * k5);\n				if (ans == -1 || ans > goal) {\n					ans = goal;\n					a3 = k3; a4 = k4; a5 = k5;\n				}\n			}\n			// Case 4: c3 * k3 < c4 * k4 && c4 * k4 >= c5 * k5\n			// goal\n			// = -c3 * k3 + c4 * k4 + c4 * k4 - c5 * k5\n			// = -c3 * k3 + 2 * c4 * k4 - c5 * k5\n			// = -c3 * k3 + 2 * c4 * (k4_ + c5_ * k) - c5 * (k5_ - c4_ * k)\n			// +k\n			// minimize k\n			int lower4 = Math.max(lower, Math.max(lower34, lower45));\n			int upper4 = upper;\n			if (lower4 <= upper4) {\n				int k = lower4;\n				int k4 = k4_ + c5_ * k;\n				int k5 = k5_ - c4_ * k;\n				int goal = Math.abs(c3 * k3 - c4 * k4) + Math.abs(c4 * k4 - c5 * k5);\n				if (ans == -1 || ans > goal) {\n					ans = goal;\n					a3 = k3; a4 = k4; a5 = k5;\n				}\n			}\n		}\n		if (ans == -1)\n			println(-1);\n		else\n			println(a3 + "" "" + a4 + "" "" + a5);\n	}\n}\n","implementation,math,number theory,ternary search"
"// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF200E extends PrintWriter {\n	CF200E() { super(System.out, true); }\n	Scanner sc = new Scanner(System.in);\n	public static void main(String[] $) {\n		CF200E o = new CF200E(); o.main(); o.flush();\n	}\n\n	int gcd(int a, int b) {\n		return b == 0 ? a : gcd(b, a % b);\n	}\n	int d_, x_, y_;\n	void gcd_(int a, int b) {\n		if (b == 0) {\n			d_ = a;\n			x_ = 1; y_ = 0;\n		} else {\n			gcd_(b, a % b);\n			int t = x_ - a / b * y_; x_ = y_; y_ = t;\n		}\n	}\n	int div(int a, int b) {	// b > 0\n		return a >= 0 ? a / b : -((-a + b - 1) / b);\n	}\n	void main() {\n		int n = sc.nextInt();\n		int s = sc.nextInt();\n		int c3 = 0, c4 = 0, c5 = 0;\n		for (int i = 0; i < n; i++) {\n			int a = sc.nextInt();\n			if (a == 3)\n				c3++;\n			else if (a == 4)\n				c4++;\n			else\n				c5++;\n		}\n		int d = gcd(c4, c5);\n		int c4_ = c4 / d;\n		int c5_ = c5 / d;\n		int ans = -1, a3 = -1, a4 = -1, a5 = -1;\n		for (int k3 = 0; k3 * n <= s; k3++) {\n			int t = s - c3 * k3;\n			if (t % d != 0)\n				continue;\n			t /= d;\n			gcd_(c4_, c5_);\n			int k4_ = x_ * t, k5_ = y_ * t;\n			// k4 = k4_ + c5_ * k\n			// k5 = k5_ - c4_ * k\n\n			// k4 >= k3\n			// k4_ + c5_ * k >= k3\n			// k4_ + c5_ * k > k3 - 1\n			// c5_ * k > k3 - k4_ - 1\n			// k > (k3 - k4_ - 1) / c5_\n			// k >= (k3 - k4_ - 1) / c5_ + 1\n			int lower = div(k3 - k4_ - 1, c5_) + 1;\n\n			// k5 >= k4\n			// k5_ - c4_ * k >= k4_ + c5_ * k\n			// (c4_ + c5_) * k <= k5_ - k4_\n			// k <= (k5_ - k4_) / (c4_ + c5_)\n			int upper = div(k5_ - k4_, c4_ + c5_);\n\n			if (lower > upper)\n				continue;\n\n			// c3 * k3 >= c4 * k4\n			// c3 * k3 >= c4 * (k4_ + c5_ * k)\n			// c4 * c5_ * k <= c3 * k3 - c4 * k4_\n			// k <= (c3 * k3 - c4 * k4_) / (c4 * c5_)\n			int upper34 = div(c3 * k3 - c4 * k4_, c4 * c5_);\n			// c3 * k3 < c4 * k4\n			int lower34 = upper34 + 1;\n\n			// c4 * k4 >= c5 * k5\n			// c4 * (k4_ + c5_ * k) >= c5 * (k5_ - c4_ * k)\n			// (c4 * c5_ + c5 * c4_) * k >= c5 * k5_ - c4 * k4_\n			// (c4 * c5_ + c5 * c4_) * k > c5 * k5_ - c4 * k4_ - 1\n			// k > (c5 * k5_ - c4 * k4_ - 1) / (c4 * c5_ + c5 * c4_)\n			// k >= (c5 * k5_ - c4 * k4_ - 1) / (c4 * c5_ + c5 * c4_) + 1\n			int lower45 = div(c5 * k5_ - c4 * k4_ - 1, c4 * c5_ + c5 * c4_) + 1;\n			// c4 * k4 < c5 * k5\n			int upper45 = lower45 - 1;\n\n			// Case 1: c3 * k3 >= c4 * k4 && c4 * k4 >= c5 * k5\n			// goal\n			// = c3 * k3 - c4 * k4 + c4 * k4 - c5 * k5\n			// = c3 * k3 - c5 * k5\n			// = c3 * k3 - c5 * (k5_ - c4_ * k)\n			// +k\n			// minimize k\n			int lower1 = Math.max(lower, lower45);\n			int upper1 = Math.min(upper, upper34);\n			if (lower1 <= upper1) {\n				int k = lower1;\n				int k4 = k4_ + c5_ * k;\n				int k5 = k5_ - c4_ * k;\n				int goal = Math.abs(c3 * k3 - c4 * k4) + Math.abs(c4 * k4 - c5 * k5);\n				if (ans == -1 || ans > goal) {\n					ans = goal;\n					a3 = k3; a4 = k4; a5 = k5;\n				}\n			}\n			// Case 2: c3 * k3 >= c4 * k4 && c4 * k4 < c5 * k5\n			// goal\n			// = c3 * k3 - c4 * k4 - c4 * k4 + c5 * k5\n			// = c3 * k3 - 2 * c4 * k4 + c5 * k5\n			// = c3 * k3 - 2 * c4 * (k4_ + c5_ * k) + c5 * (k5_ - c4_ * k)\n			// -k\n			// maximize k\n			int lower2 = lower;\n			int upper2 = Math.min(upper, Math.min(upper34, upper45));\n			if (lower2 <= upper2) {\n				int k = upper2;\n				int k4 = k4_ + c5_ * k;\n				int k5 = k5_ - c4_ * k;\n				int goal = Math.abs(c3 * k3 - c4 * k4) + Math.abs(c4 * k4 - c5 * k5);\n				if (ans == -1 || ans > goal) {\n					ans = goal;\n					a3 = k3; a4 = k4; a5 = k5;\n				}\n			}\n			// Case 3: c3 * k3 < c4 * k4 && c4 * k4 < c5 * k5\n			// goal\n			// = -c3 * k3 + c4 * k4 - c4 * k4 + c5 * k5\n			// = -c3 * k3 + c5 * k5\n			// = -c3 * k3 + c5 * (k5_ - c4_ * k)\n			// -k\n			// maximize k\n			int lower3 = Math.max(lower, lower34);\n			int upper3 = Math.min(upper, upper45);\n			if (lower3 <= upper3) {\n				int k = upper3;\n				int k4 = k4_ + c5_ * k;\n				int k5 = k5_ - c4_ * k;\n				int goal = Math.abs(c3 * k3 - c4 * k4) + Math.abs(c4 * k4 - c5 * k5);\n				if (ans == -1 || ans > goal) {\n					ans = goal;\n					a3 = k3; a4 = k4; a5 = k5;\n				}\n			}\n			// Case 4: c3 * k3 < c4 * k4 && c4 * k4 >= c5 * k5\n			// goal\n			// = -c3 * k3 + c4 * k4 + c4 * k4 - c5 * k5\n			// = -c3 * k3 + 2 * c4 * k4 - c5 * k5\n			// = -c3 * k3 + 2 * c4 * (k4_ + c5_ * k) - c5 * (k5_ - c4_ * k)\n			// +k\n			// minimize k\n			int lower4 = Math.max(lower, Math.max(lower34, lower45));\n			int upper4 = upper;\n			if (lower4 <= upper4) {\n				int k = lower4;\n				int k4 = k4_ + c5_ * k;\n				int k5 = k5_ - c4_ * k;\n				int goal = Math.abs(c3 * k3 - c4 * k4) + Math.abs(c4 * k4 - c5 * k5);\n				if (ans == -1 || ans > goal) {\n					ans = goal;\n					a3 = k3; a4 = k4; a5 = k5;\n				}\n			}\n		}\n		if (ans == -1)\n			println(-1);\n		else\n			println(a3 + "" "" + a4 + "" "" + a5);\n	}\n}\n","implementation,math,number theory,ternary search"
"import java.io.*;\nimport java.util.*;\n\npublic class CF200 implements Runnable {\n\n    private static final boolean ONLINE_JUDGE = System.getProperty(""ONLINE_JUDGE"") != null;\n\n    private BufferedReader in;\n    private PrintWriter out;\n    private StringTokenizer tok = new StringTokenizer("""");\n\n    private void init() throws FileNotFoundException {\n        Locale.setDefault(Locale.US);\n        String fileName = """";\n        if (ONLINE_JUDGE && fileName.isEmpty()) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        } else {\n            if (fileName.isEmpty()) {\n                in = new BufferedReader(new FileReader(""input.txt""));\n                out = new PrintWriter(""output.txt"");\n            } else {\n                in = new BufferedReader(new FileReader(fileName + "".in""));\n                out = new PrintWriter(fileName + "".out"");\n            }\n        }\n    }\n\n    String readString() {\n        while (!tok.hasMoreTokens()) {\n            try {\n                tok = new StringTokenizer(in.readLine());\n            } catch (Exception e) {\n                return null;\n            }\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() {\n        return Double.parseDouble(readString());\n    }\n\n    int[] readIntArray(int size) {\n        int[] a = new int[size];\n        for (int i = 0; i < size; i++) {\n            a[i] = readInt();\n        }\n        return a;\n    }\n\n    public static void main(String[] args) {\n        //new Thread(null, new A(), """", 128 * (1L << 20)).start();\n        new CF200().run();\n    }\n\n    long timeBegin, timeEnd;\n\n    void time() {\n        timeEnd = System.currentTimeMillis();\n        System.err.println(""Time = "" + (timeEnd - timeBegin));\n    }\n\n    @Override\n    public void run() {\n        try {\n            timeBegin = System.currentTimeMillis();\n            init();\n\n            int n = readInt();\n            int s = readInt();\n            int c3 = 0, c4 = 0, c5 = 0;\n            for (int i = 0; i < n; i++) {\n                int x = readInt();\n                if (x == 3) c3++;\n                if (x == 4) c4++;\n                if (x == 5) c5++;\n            }\n\n//            Random random = new Random();\n//            for (int it = 0; it <= 10000; it++) {\n//                int sum = 1 + random.nextInt(1000);\n//                int a = 1 + random.nextInt(100);\n//                int b = 1 + random.nextInt(100);\n//                int c = 1 + random.nextInt(100);\n//                if (solve(a, b, c, sum) != solveBrut(a, b, c, sum)) {\n//                    out.println(""PLOHO "" + a + "" "" + b + "" "" + c + "" "" + sum);\n//                }\n//            }\n\n//            solve(54, 24, 2, 572);\n//            solveBrut(54, 24, 2, 572);\n\n            solve(c3, c4, c5, s);\n\n            out.close();\n            time();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n\n    private int aiverson(boolean good) {\n        return good ? 1 : 0;\n    }\n\n    int[] euclid(int a, int b) {\n        if (a == 0) {\n            return new int[]{0, 1};\n        }\n        int[] coeffs = euclid(b % a, a);\n        int x1 = coeffs[0];\n        int y1 = coeffs[1];\n        return new int[]{y1 - b / a * x1, x1};\n    }\n\n    int gcd(int a, int b) {\n        return a == 0 ? b : gcd(b % a, a);\n    }\n\n    int solveBrut(int c3, int c4, int c5, int s) {\n        int ansK3 = -1, ansK4 = -1, ansK5 = -1;\n        int ans = Integer.MAX_VALUE;\n\n        for (int k3 = 0; k3 <= 1000; k3++) {\n            for (int k4 = k3; k4 <= 1000; k4++) {\n                int rest = s - c3 * k3 - c4 * k4;\n                if (rest % c5 != 0 || rest < 0) continue;\n                int k5 = rest / c5;\n                if (k5 >= k4) {\n                    int f = Math.abs(k3 * c3 - k4 * c4) + Math.abs(k4 * c4 - k5 * c5);\n                    if (f <= ans) {\n                        ans = f;\n                        ansK3 = k3;\n                        ansK4 = k4;\n                        ansK5 = k5;\n                    }\n                }\n            }\n        }\n        if (ansK3 == -1) {\n            out.println(-1);\n        } else {\n            out.printf(""%d %d %d %d\n"", ansK3, ansK4, ansK5, ans);\n        }\n        return ans;\n    }\n\n\n    int ansK3 = -1, ansK4 = -1, ansK5 = -1;\n    int ans = Integer.MAX_VALUE;\n\n    void updateAns(int c3, int k3, int c4, int k4, int c5, int k5, int sum) {\n        if (sum != c3 * k3 + c4 * k4 + c5 * k5) return;\n        if (k3 >= 0 && k3 <= k4 && k4 <= k5 && ans > f(c3, k3, c4, k4, c5, k5)) {\n            ans = f(c3, k3, c4, k4, c5, k5);\n            ansK3 = k3;\n            ansK4 = k4;\n            ansK5 = k5;\n        }\n    }\n\n    int INF = 1000 * 1000;\n\n    private int solve(int c3, int c4, int c5, int s) throws IOException {\n\n        ans = Integer.MAX_VALUE;\n        ansK3 = ansK4 = ansK5 = -1;\n\n        int[] euclid = euclid(c3, c5);\n        int gcd = gcd(c3, c5);\n\n        int d3 = c5 / gcd;\n        int d5 = c3 / gcd;\n\n        for (int k4 = 0; k4 * (c4 + c5) <= s; k4++) {\n            int sum = s - k4 * c4;\n            if (sum % gcd != 0) {\n                continue;\n            }\n            int k3_0 = euclid[0] * (sum / gcd);\n            int k5_0 = euclid[1] * (sum / gcd);\n\n            int left = -BINSEARCH_BORDER, right = BINSEARCH_BORDER;\n            int rightBorder = -INF;\n            while (left <= right) {\n                int i = (left + right) >> 1;\n                if (k3_0 + i * d3 <= k4) {\n                    rightBorder = i;\n                    left = i + 1;\n                } else {\n                    right = i - 1;\n                }\n            }\n\n            left = -BINSEARCH_BORDER;\n            right = rightBorder;\n            while (left <= right) {\n                int i = (left + right) >> 1;\n                if (k5_0 - i * d5 >= k4) {\n                    rightBorder = i;\n                    left = i + 1;\n                } else {\n                    right = i - 1;\n                }\n            }\n\n            left = -BINSEARCH_BORDER;\n            right = BINSEARCH_BORDER;\n            int leftBorder = Integer.MAX_VALUE;\n            while (left <= right) {\n                int i = (left + right) >> 1;\n                if (i * d3 + k3_0 >= 0) {\n                    leftBorder = i;\n                    right = i - 1;\n                } else {\n                    left = i + 1;\n                }\n            }\n\n            left = -BINSEARCH_BORDER;\n            right = BINSEARCH_BORDER;\n            int border = Integer.MAX_VALUE;\n            while (left <= right) {\n                int i = (left + right) >> 1;\n                if (c3 * (i * d3 + k3_0) <= c4 * k4) {\n                    border = i;\n                    left = i + 1;\n                } else {\n                    right = i - 1;\n                }\n            }\n            if (border != Integer.MAX_VALUE && border >= leftBorder && border <= rightBorder) {\n                updateAns(c3, border * d3 + k3_0, c4, k4, c5, k5_0 - border * d5, s);\n                border++;\n                updateAns(c3, border * d3 + k3_0, c4, k4, c5, k5_0 - border * d5, s);\n            }\n\n            left = -BINSEARCH_BORDER;\n            right = BINSEARCH_BORDER;\n            border = Integer.MAX_VALUE;\n            while (left <= right) {\n                int i = (left + right) >> 1;\n                if (c3 * (i * d3 + k3_0) <= c5 * (k5_0 - i * d5)) {\n                    border = i;\n                    left = i + 1;\n                } else {\n                    right = i - 1;\n                }\n            }\n            if (border != Integer.MAX_VALUE && border >= leftBorder && border <= rightBorder) {\n                updateAns(c3, border * d3 + k3_0, c4, k4, c5, k5_0 - border * d5, s);\n                border++;\n                updateAns(c3, border * d3 + k3_0, c4, k4, c5, k5_0 - border * d5, s);\n            }\n\n            left = -BINSEARCH_BORDER;\n            right = BINSEARCH_BORDER;\n            border = Integer.MAX_VALUE;\n            while (left <= right) {\n                int i = (left + right) >> 1;\n                if (c5 * (k5_0 - i * d5) <= c4 * k4) {\n                    border = i;\n                    right = i - 1;\n                } else {\n                    left = i + 1;\n                }\n            }\n            if (border != Integer.MAX_VALUE && border >= leftBorder && border <= rightBorder) {\n                updateAns(c3, border * d3 + k3_0, c4, k4, c5, k5_0 - border * d5, s);\n                border++;\n                updateAns(c3, border * d3 + k3_0, c4, k4, c5, k5_0 - border * d5, s);\n            }\n\n\n            if (leftBorder <= rightBorder) {\n                int k3_1 = k3_0 + leftBorder * d3;\n                int k3_2 = k3_0 + rightBorder * d3;\n                int k5_1 = k5_0 - leftBorder * d5;\n                int k5_2 = k5_0 - rightBorder * d5;\n                updateAns(c3, k3_1, c4, k4, c5, k5_1, s);\n                updateAns(c3, k3_2, c4, k4, c5, k5_2, s);\n            }\n        }\n\n        if (ansK4 == -1) {\n            out.println(-1);\n        } else {\n            out.println(ansK3 + "" "" + ansK4 + "" "" + ansK5);\n        }\n\n        return ans;\n    }\n\n    int f(int c3, int k3, int c4, int k4, int c5, int k5) {\n        return Math.abs(c3 * k3 - c4 * k4) + Math.abs(c4 * k4 - c5 * k5);\n    }\n\n    final int BINSEARCH_BORDER = 1000000;\n}","implementation,math,number theory,ternary search"
"import java.util.*;\n \npublic class C192 {\n    public static void main(String[] args) {\n        Scanner sc= new Scanner(System.in);\n        int n = sc.nextInt();\n        HashSet<Long> hs = new HashSet<>();\n    for (long i = 1, j = i * (i + 1) / 2; j < n; ++i, j = i * (i + 1) / 2) {\n      hs.add(j);\n      long k = n - j;\n      if (hs.contains(k)) {\n          System.out.println(""YES"");\n       \n        return;\n      }\n    }\n \nSystem.out.println(""NO"");\n    }\n}","binary search,brute force,implementation"
"\nimport java.util.*;\n\npublic class C192 {\n    public static void main(String[] args) {\n        Scanner sc= new Scanner(System.in);\n        int n = sc.nextInt();\n        HashSet<Long> hs = new HashSet<>();\n    for (long i = 1, j = i * (i + 1) / 2; j < n; ++i, j = i * (i + 1) / 2) {\n      hs.add(j);\n      long k = n - j;\n      if (hs.contains(k)) {\n          System.out.println(""YES"");\n       \n        return;\n      }\n    }\n \nSystem.out.println(""NO"");\n    }\n}\n","binary search,brute force,implementation"
"import java.util.Scanner;\nimport java.util.*;\npublic class solution{\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int z = 0;\n        for(int i=1;i<n;i++){\n            z = i*(i+1);\n            if(z>n){\n                break;\n            }\n            int t = (int)Math.sqrt(2*n - z);\n            t = t*(t+1);\n            if(t== (2*n - z)){\n                System.out.println(""YES"");\n                return;\n            }\n        }\n        System.out.println(""NO"");\n    }\n}\n\n    \n\n\n","binary search,brute force,implementation"
"import java.util.*;\n// warm-up\n// NICE problem on Binary search. No need for brute force\npublic class FunkyNumbers {\n\n	static void solve() {\n		Scanner sc = new Scanner(System.in);\n		boolean ok = false;\n		double n=sc.nextDouble(),l=1;\n		double r = (Math.round(Math.sqrt(1+(8*n)))-1)/2;\n		while (l<=r) {\n			double a = (l*(l+1))/2;\n			double b = (r*(r+1))/2;\n			if (a+b==n) {\n				ok=true; break;\n			} else if (a+b<n) {\n				l++;\n			} else {\n				r--;\n			}\n		}\n		System.out.println(ok ? ""YES"" : ""NO"");\n		sc.close();		\n	}\n\n	public static void main(String args[]) {\n		solve();\n	}\n\n}\n","binary search,brute force,implementation"
"import java.util.Scanner;\n\npublic class ENUM {\n\n    public static void main(String[] args) {\n\n        Scanner scanner = new Scanner(System.in);\n\n        int N = Integer.parseInt(scanner.nextLine());\n        int[][] board = new int[N][N];\n        int[] input = new int[N * N];\n        for (int i = 0; i < N * N; i++)\n            input[i] = scanner.nextInt();\n        scanner.close();\n\n        boolean[] used = new boolean[N * N];\n        if (put(board, 0, 0, N, input, used)) {\n            System.out.println(record);\n            for (int r = 0; r < N; r++) {\n                for (int c = 0; c < N; c++)\n                    System.out.print(board[r][c] + "" "");\n                System.out.println();\n            }\n        }\n    }\n\n    static int record = 0;\n\n    static boolean put(int[][] board, int r, int c, int N, int[] input, boolean[] used) {\n        if (c == 0 && r == N)\n            return check(board, N);\n        int nr = c == N - 1 ? r + 1 : r;\n        int nc = c == N - 1 ? 0 : c + 1;\n        for (int i = 0; i < N * N; i++) {\n            if (!used[i]) {\n                // if (check(board, r, c, N, input[i])) {\n                used[i] = true;\n                board[r][c] = input[i];\n                if (put(board, nr, nc, N, input, used))\n                    return true;\n                used[i] = false;\n                // }\n            }\n        }\n        return false;\n    }\n\n    static boolean check(int[][] board, int N) {\n        int sum = 0;\n        for (int c = 0; c < N; c++)\n            sum += board[0][c];\n        // check rows\n        for (int r = 1; r < N; r++) {\n            int s = 0;\n            for (int c = 0; c < N; c++)\n                s += board[r][c];\n            if (s != sum)\n                return false;\n        }\n        // check cols\n        for (int c = 0; c < N; c++) {\n            int s = 0;\n            for (int r = 0; r < N; r++)\n                s += board[r][c];\n            if (s != sum)\n                return false;\n        }\n        // check diag\n        int s = 0; \n        for (int r = 0, c = N - 1; r < N && c > -1; r++, c--)\n            s += board[r][c];\n        if (sum != s)\n            return false;\n        s = 0;\n        for (int r = 0, c = 0; r < N && c < N; r++, c++)\n            s += board[r][c];\n        if (sum != s)\n            return false;\n        record = sum;\n        return true;\n    }\n\n    static boolean check(int[][] board, int r, int c, int N, int x) {\n        int sum = 0;\n        if (r > 0) {\n            for (int cc = 0; cc < N; cc++)\n                sum += board[0][cc];\n        } else {\n            return true;\n        }\n        if (r == N - 1) {\n            // check col c\n            int s = x;\n            for (int rr = 0; rr < N - 1; rr++)\n                s += board[rr][c];\n            if (sum != s)\n                return false;\n        }\n        if (c == N - 1) {\n            // check row r\n            int s = x;\n            for (int cc = 0; cc < N - 1; cc++)\n                s += board[r][cc];\n            if (sum != s)\n                return false;\n        }\n        if (r == N - 1 && c == 0) {\n            // check diag\n            int s = x;\n            for (int rr = 0, cc = N - 1; rr < N - 1 && cc > 0; rr++, cc--)\n                s += board[rr][cc];\n            if (sum != s)\n                return false;\n        }\n        if (r == N - 1 && c == N - 1) {\n            // check diag\n            int s = x;\n            for (int rr = 0, cc = 0; rr < N - 1 && cc < N - 1; rr++, cc++)\n                s += board[rr][cc];\n            if (sum != s)\n                return false;\n        }\n        record = sum;\n        return true;\n    }\n}\n",
"import java.util.*;\n\npublic class Magic_Squares {\n	public static void main(String ar[]) {\n		Scanner t = new Scanner(System.in);\n		int n = t.nextInt();\n		int[] a = new int[n * n];\n		int sum = 0;\n\n		for (int i = 0; i < n * n; i++) {\n			a[i] = t.nextInt();\n			sum += a[i];\n		}\n\n		sum = sum / n;\n\n		if (n == 3) {\n			Arrays.sort(a);\n			int z[] = new int[n * n];\n\n			z[0] = a[1];\n			z[1] = a[6];\n			z[2] = a[5];\n			z[3] = a[8];\n			z[4] = a[4];\n			z[5] = a[0];\n			z[6] = a[3];\n			z[7] = a[2];\n			z[8] = a[7];\n\n			if (z[0] + z[3] + z[6] != sum) {\n				int temp = z[1];\n				z[1] = z[2];\n				z[2] = temp;\n				temp = z[6];\n				z[6] = z[7];\n				z[7] = temp;\n			}\n\n			a = z;\n		}\n\n		System.out.println(sum);\n		int k = 0;\n\n		for (int i = 0; i < n; i++) {\n			for (int j = 0; j < n; j++)\n				System.out.print(a[i * n + j] + "" "");\n\n			System.out.println();\n		}\n\n	}\n}",
"import java.util.*;\n// warm-up\npublic class EncryptingMessages {\n\n	static void solve() {\n		Scanner sc = new Scanner(System.in);\n		int noc=sc.nextInt(), n=noc, m=sc.nextInt(), c=sc.nextInt(), i=0, j=0, k=0;\n		int[] a = new int[n];\n		int[] b = new int[m];\n		while (noc-->0) a[i++]=sc.nextInt();\n		noc=m; i=0;\n		while (noc-->0) b[i++]=sc.nextInt();\n		noc=n-m; \n		while (noc-->=0) {\n			k=0; i=j; \n			while (k<m) a[i]=(a[i++]+b[k++])%c;\n			j++;\n		}\n		for (int d : a) System.out.print(d+"" "");\n		sc.close();		\n	}\n\n	public static void main(String args[]) {\n		solve();\n	}\n\n}\n",brute force
"import java.util.*;\n\npublic class encryptingmessages {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        int m = scan.nextInt();\n        int c = scan.nextInt();\n        int[] a1 = new int[n];\n        int[] a2 = new int[m];\n        for (int i = 0; i < n; i++) {\n            a1[i] = scan.nextInt();\n        }\n        for (int i = 0; i < m; i++) {\n            a2[i] = scan.nextInt();\n        }\n        for (int i = 0; i < n - m + 1; i++) {\n            for (int j = 0; j < m; j++) {\n                a1[i + j] = (a1[i + j] + a2[j]) % c;\n            }\n        }\n\n        for (int i : a1) {\n            System.out.print(i + "" "");\n        }\n    }\n}\n",brute force
"/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/**\n *\n * @author WhysoseriousONI\n */\nimport java.util.*;\n\npublic class cf177d1 {\n     public static void main(String args[]) {\n        Scanner s = new Scanner(System.in);\n        int n=s.nextInt(),m=s.nextInt(),c=s.nextInt();\n        int diff=n-m+1;\n        int narr[]=new int[n];\n        int brr[]=new int[m];\n        for(int i=0;i<n;i++)narr[i]=s.nextInt();\n        for(int i=0;i<m;i++)brr[i]=s.nextInt();\n        for(int i=0;i<diff;i++)\n        {\n            for(int j=i,k=0;j<i+m && k<m;j++,k++)\n            {\n                int temp=(narr[j]+brr[k])%c;\n                narr[j]=temp;\n            }\n        }\n        \n        System.out.print(narr[0]);\n        for(int i=1;i<narr.length;i++)System.out.print("" ""+narr[i]);\n\n     }\n}\n",brute force
import java.io.*;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int c = scanner.nextInt();\n\n        int[] arrA = new int[n];\n        int[] arrB = new int[m];\n\n        for (int i = 0; i < n; i++) {\n            arrA[i] = scanner.nextInt();\n        }\n\n        for (int i = 0; i < m; i++) {\n            arrB[i] = scanner.nextInt();\n        }\n\n        int counter = 0;\n        int d = 0;\n        int iPred = 0;\n        for (int i = 0; i < n && counter != (n - m + 1); i++) {\n            arrA[i] += arrB[d];\n            arrA[i] = arrA[i] % c;\n            d++;\n            if (i - iPred + 1 == m) {\n                iPred++;\n                i = iPred - 1;\n                d = 0;\n                counter++;\n            }\n\n        }\n        for (int i = 0; i < n; i++) {\n            System.out.print(arrA[i]);\n            System.out.print(' ');\n        }\n\n\n    }\n}\n,brute force
"import java.util.Scanner;\n\npublic class Tes {\n	\n	static int solve(int l1, int r1, int l2, int r2, int k) \n	{ \n		int m;\n		m = 1 << k;\n		\n	    if (l1 > r1 || l2 > r2) { \n	        return 0; \n	    } \n	    \n	    if (l1 > l2 || l1 == l2 && r1 < r2) { \n	        return solve(l2,r2,l1,r1,k); \n	    } \n	    \n	    if(r1>=r2) {\n	    	return r2-l2+1;\n	    }\n	    \n	    if(l2>m) {\n	    	return solve(l1,r1,l2-m,r2-m,k);\n	    }\n	    \n	    if(r1<m && r2<m) {\n	    	return solve(l1,r1,l2,r2,k-1);\n	    }\n	    \n\n	    return Math.max(Math.max(solve(l1,r1,l2,m-1,k), solve(1,r2-m,l1,r1,k)), r1-l2+1); \n	         \n	} \n	\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int l1 = sc.nextInt();\n		int r1 = sc.nextInt();\n		int l2 = sc.nextInt();\n		int r2 = sc.nextInt();\n		System.out.println(solve(l1, r1,l2,r2,30));\n\n		sc.close();\n	}\n}",divide and conquer
"import java.util.Scanner;\n\npublic class Abracadabra {\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int l1 = sc.nextInt();\n		int r1 = sc.nextInt();\n		int l2 = sc.nextInt();\n		int r2 = sc.nextInt();\n		sc.close();\n		System.out.println(solve(30, l1, r1, l2, r2));\n	}\n\n	private static int solve(int i, int l1, int r1, int l2, int r2) {\n		if (r1 < l1 || r2 < l2) {\n			return 0;\n		}\n		if (i < 0) {\n			return 0;\n		}\n\n		int r = Math.min(r1, r2) - Math.max(l1, l2) + 1;\n\n		if (l1 <= l2 && r1 >= r2) {\n			return r = r2 - l2 + 1;\n		}\n		if (l2 <= l1 && r2 >= r1) {\n			return r = r1 - l1 + 1;\n		}\n\n		int mid = (1 << i);\n\n		if (l1 > mid) {\n			l1 -= mid;\n			r1 -= mid;\n		}\n		if (l2 > mid) {\n			l2 -= mid;\n			r2 -= mid;\n		}\n\n		r = Math.max(r, solve(i - 1, l1, Math.min(r1, mid - 1), l2, Math.min(r2, mid - 1)));\n\n		if (r2 > mid) {\n			r = Math.max(r, solve(i - 1, l1, Math.min(r1, mid - 1), 1, r2 - mid));\n		}\n		if (r1 > mid) {\n			r = Math.max(r, solve(i - 1, 1, r1 - mid, l2, Math.min(r2, mid - 1)));\n			if (r2 > mid) {\n				r = Math.max(r, solve(i - 1, 1, r1 - mid, 1, r2 - mid));\n			}\n		}\n\n		return r;\n	}\n}\n",divide and conquer
"import java.util.Scanner;\n\npublic class Abracadabra {\n\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int l1 = sc.nextInt();\n		int r1 = sc.nextInt();\n		int l2 = sc.nextInt();\n		int r2 = sc.nextInt();\n		sc.close();\n		System.out.println(solve(30, l1, r1, l2, r2));\n	}\n\n	private static int solve(int i, int l1, int r1, int l2, int r2) {\n		if (r1 < l1 || r2 < l2) {\n			return 0;\n		}\n		if (i < 0) {\n			return 0;\n		}\n\n		int r = Math.min(r1, r2) - Math.max(l1, l2) + 1;\n\n		if (l1 <= l2 && r1 >= r2) {\n			return r = r2 - l2 + 1;\n		}\n		if (l2 <= l1 && r2 >= r1) {\n			return r = r1 - l1 + 1;\n		}\n\n		int mid = (1 << i);\n\n		if (l1 > mid) {\n			l1 -= mid;\n			r1 -= mid;\n		}\n		if (l2 > mid) {\n			l2 -= mid;\n			r2 -= mid;\n		}\n\n		r = Math.max(r, solve(i - 1, l1, Math.min(r1, mid - 1), l2, Math.min(r2, mid - 1)));\n\n		if (r2 > mid) {\n			r = Math.max(r, solve(i - 1, l1, Math.min(r1, mid - 1), 1, r2 - mid));\n		}\n		if (r1 > mid) {\n			r = Math.max(r, solve(i - 1, 1, r1 - mid, l2, Math.min(r2, mid - 1)));\n			if (r2 > mid) {\n				r = Math.max(r, solve(i - 1, 1, r1 - mid, 1, r2 - mid));\n			}\n		}\n\n		return r;\n	}\n}\n",divide and conquer
"import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int left1 = input.nextInt();\n        int right1 = input.nextInt();\n        int left2 = input.nextInt();\n        int right2 = input.nextInt();\n        System.out.println(abracadabra(left1, right1, left2, right2, 30));\n    }\n\n    public static int abracadabra(int left1, int right1, int left2, int right2, int k) {\n        int mid;\n        mid = 1 << k;\n\n        if (left1 > right1 || left2 > right2) {\n            return 0;\n        }\n\n        if (left1 > left2 || left1 == left2 && right1 < right2) {\n            return abracadabra(left2, right2, left1, right1, k);\n        }\n\n        if (right1 >= right2) {\n            return right2 - left2 + 1;\n        }\n\n        if (left2 > mid) {\n            return abracadabra(left1, right1, left2 - mid, right2 - mid, k);\n        }\n\n        if (right1 < mid && right2 < mid) {\n            return abracadabra(left1, right1, left2, right2, k - 1);\n        }\n\n        return Math.max(Math.max(abracadabra(left1, right1, left2, mid - 1, k), abracadabra(1, right2 - mid, left1, right1, k)), right1 - left2 + 1);\n    }\n}",divide and conquer
//package codeforce;\nimport java.util.*;\n\npublic class CP1 {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		long mod = 1000000007l;\n		ArrayList<String> names = new ArrayList<>();\n		\n		for(int i=0;i<n;i++) {\n			names.add(sc.next());\n		}\n		\n		long answer = 1l;\n		for(int i=0;i<m;i++) {\n			Set<Character> set = new HashSet<>();\n			for(int j=0;j<n;j++) {\n				set.add(names.get(j).charAt(i));\n			}\n			answer = (answer*set.size())%mod;\n		}\n		\n		System.out.println(answer);\n\n	}\n\n}\n,combinatorics
//package codeforce;\nimport java.util.*;\n\npublic class CP1 {\n\n	public static void main(String[] args) {\n		// TODO Auto-generated method stub\n		Scanner sc = new Scanner(System.in);\n		int n = sc.nextInt();\n		int m = sc.nextInt();\n		long mod = 1000000007l;\n		ArrayList<String> names = new ArrayList<>();\n		\n		for(int i=0;i<n;i++) {\n			names.add(sc.next());\n		}\n		\n		long answer = 1l;\n		for(int i=0;i<m;i++) {\n			Set<Character> set = new HashSet<>();\n			for(int j=0;j<n;j++) {\n				set.add(names.get(j).charAt(i));\n			}\n			answer = (answer*set.size())%mod;\n		}\n		\n		System.out.println(answer%mod);\n\n	}\n\n}\n,combinatorics
"import java.io.*;\nimport java.util.*;\npublic class Hackerrank {\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int n=sc.nextInt();\n		int m=sc.nextInt();\n		String[] arr=new String[n];\n		sc.nextLine();\n		for(int i=0;i<n;i++) {\n			arr[i]=sc.nextLine();\n		}\n		long cost=1;\n		long div=1000000007;\n		for(int i=0;i<m;i++) {\n			Map<String,Integer> s=new HashMap<>();\n			long count=0;\n			for(int j=0;j<n;j++) {\n				if(!s.containsKey(String.valueOf(arr[j].charAt(i)))) {\n					s.put(String.valueOf(arr[j].charAt(i)), 1);\n					count+=1;\n				}\n			}\n			cost=(cost*count)%div;\n		}\n		System.out.println(cost);\n    }\n}",combinatorics
import java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.HashSet;\npublic class pocketBook {\n \n  public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    int m = in.nextInt();\n    \n    HashSet<Character> hs = new HashSet<>();\n    \n    String[] arr = new String[n];\n    \n    for(int i =0;i<n;i++){\n      arr[i]=in.next();\n      \n    }\n    long count=1;\n    int mod =1000000007;\n    for(int i =0;i<m;i++){\n      for(int j=0;j<n;j++){\n        hs.add(arr[j].charAt(i));\n      }\n      count= ((count%mod)*hs.size())%mod;\n     hs.clear();  \n    }\n    System.out.println(count);\n    \n  }\n}\n,combinatorics
