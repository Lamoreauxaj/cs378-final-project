"#include <bits/stdc++.h>\n \nusing namespace std;\n \n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n \nclass segtree {\n public:\n  struct node {\n    int mn = -1;\n    int add = 0;\n    int id = -1;\n \n    void apply(int l, int r, int v, bool to_add) {\n      if (to_add) {\n        add += v;\n        mn += v;\n      } else {\n        mn = v;\n        add = 0;\n        id = l;\n      }\n    }\n  };\n \n  node unite(const node &a, const node &b) const {\n    node res;\n    res.mn = min(a.mn, b.mn);\n    res.id = (res.mn == a.mn ? a.id : b.id);\n    return res;\n  }\n \n  inline void push(int x, int l, int r) {\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    if (tree[x].add != 0) {\n      tree[x + 1].apply(l, y, tree[x].add, true);\n      tree[z].apply(y + 1, r, tree[x].add, true);\n      tree[x].add = 0;\n    }\n  }\n \n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n \n  int n;\n  vector<node> tree;\n \n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n \n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n \n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n \n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n \n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n \n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n \n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n \n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n \n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n \n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n \n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n \n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n \n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n \n \n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n \n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n \ntemplate <typename T>\nclass fenwick {\n public:\n  vector<T> fenw;\n  int n;\n \n  fenwick(int _n) : n(_n) {\n    fenw.resize(n);\n  }\n \n  void modify(int x, T v) {\n    while (x < n) {\n      fenw[x] += v;\n      x |= (x + 1);\n    }\n  }\n \n  T get(int x) {\n    T v{};\n    while (x >= 0) {\n      v += fenw[x];\n      x = (x & (x + 1)) - 1;\n    }\n    return v;\n  }\n};\n \nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n + 2);\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  a[0] = 0;\n  a[n + 1] = n + 1;\n  vector<int> pos(n + 2);\n  for (int i = 0; i <= n + 1; i++) {\n    pos[a[i]] = i;\n  }\n  vector<int> val(n + 2);\n  for (int i = 1; i <= n; i++) {\n    val[i] = (a[i] >= i ? a[i] - i : i - a[i]);\n  }\n  segtree st1(n + 2);\n  segtree st2(n + 2);\n  segtree st3(n + 2);\n  segtree st4(n + 2);\n  for (int i = 0; i <= n + 1; i++) {\n    st1.modify(i, i, a[i] >= i ? a[i] : 10 * n, false);\n    st2.modify(i, i, a[i] >= i ? 10 * n : -a[i], false);\n    st3.modify(i, i, 10 * n, false);\n    st4.modify(i, i, 10 * n, false);\n  }\n  set<int> s1;\n  set<int> s2;\n  vector<int> pr1(n + 2, -1);\n  vector<int> ne1(n + 2, -1);\n  vector<int> pr2(n + 2, -1);\n  vector<int> ne2(n + 2, -1);\n  fenwick<int> fenw_pos(n + 2);\n  fenwick<int> fenw_val(n + 2);\n  vector<int> delta(n + 2);\n  ne1[0] = n + 1;\n  pr1[n + 1] = 0;\n  ne2[0] = n + 1;\n  pr2[n + 1] = 0;\n  int step = 0;\n  function<void(int, int, int, int, int)> Add1 = [&](int x, int y, int rx, int ry, int init) {\n    assert(ne1[x] == y && pr1[y] == x);\n    if (x + 1 <= y - 1) {\n      int z = st1.get(x + 1, y - 1).mn;\n      debug(""1"", x, y, z);\n      if (z > n) {\n        return;\n      }\n      z = pos[z];\n      assert(a[z] > a[x]);\n      if (a[z] < a[y]) {\n        pr1[z] = x;\n        ne1[z] = y;\n        pr1[ne1[z]] = z;\n        ne1[pr1[z]] = z;\n \n        delta[z] = init;\n        delta[z] -= (fenw_pos.get(rx - 1) - fenw_pos.get(z));\n        delta[z] -= (fenw_val.get(a[z] - 1) - fenw_val.get(ry));\n        debug(""!!!"", z);\n        st3.modify(z, z, val[z] + delta[z], false);\n        s1.insert(a[z]);\n        \n        Add1(x, z, rx, ry, init);\n        Add1(z, y, rx, ry, init);\n      }\n    }\n  };\n  Add1(0, n + 1, n, 1, 0);\n  function<void(int, int, int, int, int)> Add2 = [&](int x, int y, int rx, int ry, int init) {\n    assert(ne2[x] == y && pr2[y] == x);\n    if (x + 1 <= y - 1) {\n      int z = -st2.get(x + 1, y - 1).mn;\n      debug(""2"", x, y, z);\n      if (abs(z) > n) {\n        return;\n      }\n      z = pos[z];\n      assert(a[z] < a[y]);\n      if (a[z] > a[x]) {\n        pr2[z] = x;\n        ne2[z] = y;\n        pr2[ne2[z]] = z;\n        ne2[pr2[z]] = z;\n \n        delta[z] = init;\n        delta[z] -= (fenw_pos.get(z - 1) - fenw_pos.get(rx));\n        delta[z] -= (fenw_val.get(ry - 1) - fenw_val.get(a[z]));\n        st4.modify(z, z, val[z] + delta[z], false);\n        s2.insert(a[z]);\n        \n        Add2(x, z, rx, ry, init);\n        Add2(z, y, rx, ry, init);\n      }\n    }\n  };\n  Add2(0, n + 1, 1, n, 0);\n  int ans = 0;\n  for (step = 1; step <= n; step++) {\n    auto nd3 = st3.get(1, n);\n    auto nd4 = st4.get(1, n);\n    debug(step, nd3.mn, nd3.id, nd4.mn, nd4.id);\n    debug(s1, s2);\n    if (nd3.mn < nd4.mn) { \n      auto nd = nd3;\n      ans = max(ans, nd.mn);\n      int i = nd.id;\n      st3.modify(i, i, 10 * n, false);\n      fenw_pos.modify(i, +1);\n      fenw_val.modify(a[i], +1);\n      st1.modify(i, i, 10 * n, false);\n      pr1[ne1[i]] = pr1[i];\n      ne1[pr1[i]] = ne1[i];\n      s1.erase(a[i]);\n      Add1(pr1[i], ne1[i], i, a[i], nd.mn - val[i] - 1);\n      auto iter = s2.lower_bound(a[i]);\n      int L = i;\n      int R = (iter == s2.end() ? n : pos[*iter] - 1);\n      debug(L, R);\n      if (L <= R) {\n        st4.modify(L, R, -1, true);\n      }\n    } else {\n      auto nd = nd4;\n      ans = max(ans, nd.mn);\n      int i = nd.id;\n      st4.modify(i, i, 10 * n, false);\n      fenw_pos.modify(i, +1);\n      fenw_val.modify(a[i], +1);\n      st2.modify(i, i, 10 * n, false);\n      pr2[ne2[i]] = pr2[i];\n      ne2[pr2[i]] = ne2[i];\n      s2.erase(a[i]);\n      Add2(pr2[i], ne2[i], i, a[i], nd.mn - val[i] - 1);\n      debug(s2);\n      auto iter = s1.lower_bound(a[i]);\n      int L = (iter == s1.begin() ? 1 : pos[*prev(iter)] + 1);\n      int R = i;\n      debug(L, R);\n      if (L <= R) {\n        st3.modify(L, R, -1, true);\n      }\n    }\n  }\n  cout << ans << '\n';\n  debug(clock());\n  return 0;\n}\n","data structures,greedy","1672","I"
"#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nclass segtree {\n public:\n  struct node {\n    int mn = -1;\n    int add = 0;\n    int id = -1;\n\n    void apply(int l, int r, int v, bool to_add) {\n      if (to_add) {\n        add += v;\n        mn += v;\n      } else {\n        mn = v;\n        add = 0;\n        id = l;\n      }\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.mn = min(a.mn, b.mn);\n    res.id = (res.mn == a.mn ? a.id : b.id);\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    if (tree[x].add != 0) {\n      tree[x + 1].apply(l, y, tree[x].add, true);\n      tree[z].apply(y + 1, r, tree[x].add, true);\n      tree[x].add = 0;\n    }\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\ntemplate <typename T>\nclass fenwick {\n public:\n  vector<T> fenw;\n  int n;\n\n  fenwick(int _n) : n(_n) {\n    fenw.resize(n);\n  }\n\n  void modify(int x, T v) {\n    while (x < n) {\n      fenw[x] += v;\n      x |= (x + 1);\n    }\n  }\n\n  T get(int x) {\n    T v{};\n    while (x >= 0) {\n      v += fenw[x];\n      x = (x & (x + 1)) - 1;\n    }\n    return v;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n + 2);\n  for (int i = 1; i <= n; i++) {\n    cin >> a[i];\n  }\n  a[0] = 0;\n  a[n + 1] = n + 1;\n  vector<int> pos(n + 2);\n  for (int i = 0; i <= n + 1; i++) {\n    pos[a[i]] = i;\n  }\n  vector<int> val(n + 2);\n  for (int i = 1; i <= n; i++) {\n    val[i] = (a[i] >= i ? a[i] - i : i - a[i]);\n  }\n  segtree st1(n + 2);\n  segtree st2(n + 2);\n  segtree st3(n + 2);\n  segtree st4(n + 2);\n  for (int i = 0; i <= n + 1; i++) {\n    st1.modify(i, i, a[i] >= i ? a[i] : 10 * n, false);\n    st2.modify(i, i, a[i] >= i ? 10 * n : -a[i], false);\n    st3.modify(i, i, 10 * n, false);\n    st4.modify(i, i, 10 * n, false);\n  }\n  set<int> s1;\n  set<int> s2;\n  vector<int> pr1(n + 2, -1);\n  vector<int> ne1(n + 2, -1);\n  vector<int> pr2(n + 2, -1);\n  vector<int> ne2(n + 2, -1);\n  fenwick<int> fenw_pos(n + 2);\n  fenwick<int> fenw_val(n + 2);\n  vector<int> delta(n + 2);\n  ne1[0] = n + 1;\n  pr1[n + 1] = 0;\n  ne2[0] = n + 1;\n  pr2[n + 1] = 0;\n  int step = 0;\n  function<void(int, int, int, int, int)> Add1 = [&](int x, int y, int rx, int ry, int init) {\n    assert(ne1[x] == y && pr1[y] == x);\n    if (x + 1 <= y - 1) {\n      int z = st1.get(x + 1, y - 1).mn;\n      debug(""1"", x, y, z);\n      if (z > n) {\n        return;\n      }\n      z = pos[z];\n      assert(a[z] > a[x]);\n      if (a[z] < a[y]) {\n        pr1[z] = x;\n        ne1[z] = y;\n        pr1[ne1[z]] = z;\n        ne1[pr1[z]] = z;\n\n        delta[z] = init;\n        delta[z] -= (fenw_pos.get(rx - 1) - fenw_pos.get(z));\n        delta[z] -= (fenw_val.get(a[z] - 1) - fenw_val.get(ry));\n        debug(""!!!"", z);\n        st3.modify(z, z, val[z] + delta[z], false);\n        s1.insert(a[z]);\n//        s.emplace(val[z] + delta[z], z);\n        \n        Add1(x, z, rx, ry, init);\n        Add1(z, y, rx, ry, init);\n      }\n    }\n  };\n  Add1(0, n + 1, n, 1, 0);\n  function<void(int, int, int, int, int)> Add2 = [&](int x, int y, int rx, int ry, int init) {\n    assert(ne2[x] == y && pr2[y] == x);\n    if (x + 1 <= y - 1) {\n      int z = -st2.get(x + 1, y - 1).mn;\n      debug(""2"", x, y, z);\n      if (abs(z) > n) {\n        return;\n      }\n      z = pos[z];\n      assert(a[z] < a[y]);\n      if (a[z] > a[x]) {\n        pr2[z] = x;\n        ne2[z] = y;\n        pr2[ne2[z]] = z;\n        ne2[pr2[z]] = z;\n\n        delta[z] = init;\n        delta[z] -= (fenw_pos.get(z - 1) - fenw_pos.get(rx));\n        delta[z] -= (fenw_val.get(ry - 1) - fenw_val.get(a[z]));\n        st4.modify(z, z, val[z] + delta[z], false);\n        s2.insert(a[z]);\n//        s.emplace(val[z] + delta[z], z);\n        \n        Add2(x, z, rx, ry, init);\n        Add2(z, y, rx, ry, init);\n      }\n    }\n  };\n  Add2(0, n + 1, 1, n, 0);\n  int ans = 0;\n  for (step = 1; step <= n; step++) {\n//      debug(step, s, shift);\n    auto nd3 = st3.get(1, n);\n    auto nd4 = st4.get(1, n);\n    debug(step, nd3.mn, nd3.id, nd4.mn, nd4.id);\n    debug(s1, s2);\n    if (nd3.mn < nd4.mn) { \n      auto nd = nd3;\n      ans = max(ans, nd.mn);\n      int i = nd.id;\n      st3.modify(i, i, 10 * n, false);\n      fenw_pos.modify(i, +1);\n      fenw_val.modify(a[i], +1);\n      st1.modify(i, i, 10 * n, false);\n      pr1[ne1[i]] = pr1[i];\n      ne1[pr1[i]] = ne1[i];\n      s1.erase(a[i]);\n      Add1(pr1[i], ne1[i], i, a[i], nd.mn - val[i] - 1);\n      auto iter = s2.lower_bound(a[i]);\n      int L = i;\n      int R = (iter == s2.end() ? n : pos[*iter] - 1);\n      debug(L, R);\n      if (L <= R) {\n        st4.modify(L, R, -1, true);\n      }\n    } else {\n      auto nd = nd4;\n      ans = max(ans, nd.mn);\n      int i = nd.id;\n      st4.modify(i, i, 10 * n, false);\n      fenw_pos.modify(i, +1);\n      fenw_val.modify(a[i], +1);\n      st2.modify(i, i, 10 * n, false);\n      pr2[ne2[i]] = pr2[i];\n      ne2[pr2[i]] = ne2[i];\n      s2.erase(a[i]);\n      Add2(pr2[i], ne2[i], i, a[i], nd.mn - val[i] - 1);\n      debug(s2);\n      auto iter = s1.lower_bound(a[i]);\n      int L = (iter == s1.begin() ? 1 : pos[*prev(iter)] + 1);\n      int R = i;\n      debug(L, R);\n      if (L <= R) {\n        st3.modify(L, R, -1, true);\n      }\n    }\n  }\n  cout << ans << '\n';\n  debug(clock());\n  return 0;\n}\n","data structures,greedy","1672","I"
"#include <bits/stdc++.h>\n\n/** Binary-indexed tree\n *\n *  A binary indexed tree with N nodes of type T provides the\n *  following two functions for 0 <= i <= N:\n *\n *      prefix(int i) -> prefix_iterator<T>\n *      suffix(int i) -> suffix_iterator<T>\n *\n *  such that size(suffix(i) intersect prefix(j)) = (1 if i < j else 0).\n *  Furthermore, the resulting lists always have size at most log_2(N).\n *\n *  This can be used to implement either point-update/(prefix|suffix)-query or\n *  (prefix|suffix)-update/point-query over a virtual array of size N of a\n *  commutative monoid. This can be generalized to implement\n *  point-update/range-query or range-update/point-query over a virtual array\n *  of size N of a commutative group.\n *\n *  With 0-indexed data, prefixes are more natural:\n *   * For range update/query, use for_prefix for the ranges and for_suffix for the points.\n *   * For prefix update/query, no change.\n *   * For suffix update/query, use for_prefix(point + 1); 1-index the data.\n */\ntemplate <typename T> class binary_indexed_tree {\nprivate:\n	std::vector<T> dat;\npublic:\n	binary_indexed_tree() {}\n	explicit binary_indexed_tree(size_t N) : dat(N) {}\n	binary_indexed_tree(size_t N, const T& t) : dat(N, t) {}\n\n	size_t size() const { return dat.size(); }\n	const std::vector<T>& data() const { return dat; }\n	std::vector<T>& data() { return dat; }\n\nprivate:\n	template <typename I, typename S = I> struct iterator_range {\n	private:\n		I begin_;\n		S end_;\n	public:\n		iterator_range() : begin_(), end_() {}\n		iterator_range(const I& begin__, const S& end__) : begin_(begin__), end_(end__) {}\n		iterator_range(I&& begin__, S&& end__) : begin_(begin__), end_(end__) {}\n		I begin() const { return begin_; }\n		S end() const { return end_; }\n	};\n\npublic:\n	class const_suffix_iterator {\n	private:\n		const T* dat;\n		int a;\n		const_suffix_iterator(const T* dat_, int a_) : dat(dat_), a(a_) {}\n		friend class binary_indexed_tree;\n	public:\n		friend bool operator != (const const_suffix_iterator& i, const const_suffix_iterator& j) {\n			assert(j.dat == nullptr);\n			return i.a < j.a;\n		}\n		const_suffix_iterator& operator ++ () {\n			a |= a+1;\n			return *this;\n		}\n		const T& operator * () const {\n			return dat[a];\n		}\n	};\n	using const_suffix_range = iterator_range<const_suffix_iterator>;\n	const_suffix_range suffix(int a) const {\n		assert(0 <= a && a <= int(dat.size()));\n		return const_suffix_range{const_suffix_iterator{dat.data(), a}, const_suffix_iterator{nullptr, int(dat.size())}};\n	}\n\n	class suffix_iterator {\n	private:\n		T* dat;\n		int a;\n		suffix_iterator(T* dat_, int a_) : dat(dat_), a(a_) {}\n		friend class binary_indexed_tree;\n	public:\n		friend bool operator != (const suffix_iterator& i, const suffix_iterator& j) {\n			assert(j.dat == nullptr);\n			return i.a < j.a;\n		}\n		suffix_iterator& operator ++ () {\n			a |= a+1;\n			return *this;\n		}\n		T& operator * () const {\n			return dat[a];\n		}\n	};\n	using suffix_range = iterator_range<suffix_iterator>;\n	suffix_range suffix(int a) {\n		assert(0 <= a && a <= int(dat.size()));\n		return suffix_range{suffix_iterator{dat.data(), a}, suffix_iterator{nullptr, int(dat.size())}};\n	}\n\n	class const_prefix_iterator {\n	private:\n		const T* dat;\n		int a;\n		const_prefix_iterator(const T* dat_, int a_) : dat(dat_), a(a_) {}\n		friend class binary_indexed_tree;\n	public:\n		friend bool operator != (const const_prefix_iterator& i, const const_prefix_iterator& j) {\n			assert(j.dat == nullptr);\n			return i.a > 0;\n		}\n		const_prefix_iterator& operator ++ () {\n			a &= a-1;\n			return *this;\n		}\n		const T& operator * () const {\n			return dat[a-1];\n		}\n	};\n	using const_prefix_range = iterator_range<const_prefix_iterator>;\n	const_prefix_range prefix(int a) const {\n		return const_prefix_range{const_prefix_iterator{dat.data(), a}, const_prefix_iterator{nullptr, 0}};\n	}\n\n	class prefix_iterator {\n	private:\n		T* dat;\n		int a;\n		prefix_iterator(T* dat_, int a_) : dat(dat_), a(a_) {}\n		friend class binary_indexed_tree;\n	public:\n		friend bool operator != (const prefix_iterator& i, const prefix_iterator& j) {\n			assert(j.dat == nullptr);\n			return i.a > 0;\n		}\n		prefix_iterator& operator ++ () {\n			a &= a-1;\n			return *this;\n		}\n		T& operator * () const {\n			return dat[a-1];\n		}\n	};\n	using prefix_range = iterator_range<prefix_iterator>;\n	prefix_range prefix(int a) {\n		return prefix_range{prefix_iterator{dat.data(), a}, prefix_iterator{nullptr, 0}};\n	}\n};\n\nnamespace seg_tree {\n\n// Floor of log_2(a); index of highest 1-bit\ninline int log_2(int a) {\n	return a ? (8 * sizeof(a)) - 1 - __builtin_clz(a) : -1;\n}\n\ninline int next_pow_2(int a) {\n	assert(a > 0);\n	return 1 << log_2(2*a-1);\n}\n\nstruct point {\n	int a;\n	point() : a(0) {}\n	explicit point(int a_) : a(a_) { assert(a >= -1); }\n\n	explicit operator bool () { return bool(a); }\n\n	// This is useful so you can directly do array indices\n	/* implicit */ operator int() const { return a; }\n\n	point c(bool z) const {\n		return point((a<<1)|z);\n	}\n\n	point operator [] (bool z) const {\n		return c(z);\n	}\n\n	point p() const {\n		return point(a>>1);\n	}\n\n	friend std::ostream& operator << (std::ostream& o, const point& p) { return o << int(p); }\n\n	template <typename F> void for_each(F f) const {\n		for (int v = a; v > 0; v >>= 1) {\n			f(point(v));\n		}\n	}\n\n	template <typename F> void for_parents_down(F f) const {\n		// strictly greater than 0\n		for (int L = log_2(a); L > 0; L--) {\n			f(point(a >> L));\n		}\n	}\n\n	template <typename F> void for_parents_up(F f) const {\n		for (int v = a >> 1; v > 0; v >>= 1) {\n			f(point(v));\n		}\n	}\n\n	point& operator ++ () { ++a; return *this; }\n	point operator ++ (int) { return point(a++); }\n	point& operator -- () { --a; return *this; }\n	point operator -- (int) { return point(a--); }\n};\n\nstruct range {\n	int a, b;\n	range() : a(1), b(1) {}\n	range(int a_, int b_) : a(a_), b(b_) {\n		assert(1 <= a && a <= b && b <= 2 * a);\n	}\n	explicit range(std::array<int, 2> r) : range(r[0], r[1]) {}\n\n	explicit operator std::array<int, 2>() const {\n		return {a,b};\n	}\n\n	const int& operator[] (bool z) const {\n		return z ? b : a;\n	}\n\n	friend std::ostream& operator << (std::ostream& o, const range& r) { return o << ""["" << r.a << "".."" << r.b << "")""; }\n\n	// Iterate over the range from outside-in.\n	//   Calls f(point a)\n	template <typename F> void for_each(F f) const {\n		for (int x = a, y = b; x < y; x >>= 1, y >>= 1) {\n			if (x & 1) f(point(x++));\n			if (y & 1) f(point(--y));\n		}\n	}\n\n	// Iterate over the range from outside-in.\n	//   Calls f(point a, bool is_right)\n	template <typename F> void for_each_with_side(F f) const {\n		for (int x = a, y = b; x < y; x >>= 1, y >>= 1) {\n			if (x & 1) f(point(x++), false);\n			if (y & 1) f(point(--y), true);\n		}\n	}\n\n	// Iterate over the range from left to right.\n	//    Calls f(point)\n	template <typename F> void for_each_l_to_r(F f) const {\n		int anc_depth = log_2((a-1) ^ b);\n		int anc_msk = (1 << anc_depth) - 1;\n		for (int v = (-a) & anc_msk; v; v &= v-1) {\n			int i = __builtin_ctz(v);\n			f(point(((a-1) >> i) + 1));\n		}\n		for (int v = b & anc_msk; v; ) {\n			int i = log_2(v);\n			f(point((b >> i) - 1));\n			v ^= (1 << i);\n		}\n	}\n\n	// Iterate over the range from right to left.\n	//    Calls f(point)\n	template <typename F> void for_each_r_to_l(F f) const {\n		int anc_depth = log_2((a-1) ^ b);\n		int anc_msk = (1 << anc_depth) - 1;\n		for (int v = b & anc_msk; v; v &= v-1) {\n			int i = __builtin_ctz(v);\n			f(point((b >> i) - 1));\n		}\n		for (int v = (-a) & anc_msk; v; ) {\n			int i = log_2(v);\n			f(point(((a-1) >> i) + 1));\n			v ^= (1 << i);\n		}\n	}\n\n	template <typename F> void for_parents_down(F f) const {\n		int x = a, y = b;\n		if ((x ^ y) > x) { x <<= 1, std::swap(x, y); }\n		int dx = __builtin_ctz(x);\n		int dy = __builtin_ctz(y);\n		int anc_depth = log_2((x-1) ^ y);\n		for (int i = log_2(x); i > dx; i--) {\n			f(point(x >> i));\n		}\n		for (int i = anc_depth; i > dy; i--) {\n			f(point(y >> i));\n		}\n	}\n\n	template <typename F> void for_parents_up(F f) const {\n		int x = a, y = b;\n		if ((x ^ y) > x) { x <<= 1, std::swap(x, y); }\n		int dx = __builtin_ctz(x);\n		int dy = __builtin_ctz(y);\n		int anc_depth = log_2((x-1) ^ y);\n		for (int i = dx+1; i <= anc_depth; i++) {\n			f(point(x >> i));\n		}\n		for (int v = y >> (dy+1); v; v >>= 1) {\n			f(point(v));\n		}\n	}\n};\n\nstruct in_order_layout {\n	// Alias them in for convenience\n	using point = seg_tree::point;\n	using range = seg_tree::range;\n\n	int N, S;\n	in_order_layout() : N(0), S(0) {}\n	in_order_layout(int N_) : N(N_), S(N ? next_pow_2(N) : 0) {}\n\n	point get_point(int a) const {\n		assert(0 <= a && a < N);\n		a += S;\n		return point(a >= 2 * N ? a - N : a);\n	}\n\n	range get_range(int a, int b) const {\n		assert(0 <= a && a <= b && b <= N);\n		if (N == 0) return range();\n		a += S, b += S;\n		return range((a >= 2 * N ? 2*(a-N) : a), (b >= 2 * N ? 2*(b-N) : b));\n	}\n\n	range get_range(std::array<int, 2> p) const {\n		return get_range(p[0], p[1]);\n	}\n\n	int get_leaf_index(point pt) const {\n		int a = int(pt);\n		assert(N <= a && a < 2 * N);\n		return (a < S ? a + N : a) - S;\n	}\n\n	std::array<int, 2> get_node_bounds(point pt) const {\n		int a = int(pt);\n		assert(1 <= a && a < 2 * N);\n		int l = __builtin_clz(a) - __builtin_clz(2*N-1);\n		int x = a << l, y = (a+1) << l;\n		assert(S <= x && x < y && y <= 2*S);\n		return {(x >= 2 * N ? (x>>1) + N : x) - S, (y >= 2 * N ? (y>>1) + N : y) - S};\n	}\n\n	int get_node_split(point pt) const {\n		int a = int(pt);\n		assert(1 <= a && a < N);\n		int l = __builtin_clz(2*a+1) - __builtin_clz(2*N-1);\n		int x = (2*a+1) << l;\n		assert(S <= x && x < 2*S);\n		return (x >= 2 * N ? (x>>1) + N : x) - S;\n	}\n\n	int get_node_size(point pt) const {\n		auto bounds = get_node_bounds(pt);\n		return bounds[1] - bounds[0];\n	}\n};\n\nstruct circular_layout {\n	// Alias them in for convenience\n	using point = seg_tree::point;\n	using range = seg_tree::range;\n\n	int N;\n	circular_layout() : N(0) {}\n	circular_layout(int N_) : N(N_) {}\n\n	point get_point(int a) const {\n		assert(0 <= a && a < N);\n		return point(N + a);\n	}\n\n	range get_range(int a, int b) const {\n		assert(0 <= a && a <= b && b <= N);\n		if (N == 0) return range();\n		return range(N + a, N + b);\n	}\n\n	range get_range(std::array<int, 2> p) const {\n		return get_range(p[0], p[1]);\n	}\n\n	int get_leaf_index(point pt) const {\n		int a = int(pt);\n		assert(N <= a && a < 2 * N);\n		return a - N;\n	}\n\n	// Returns {x,y} so that 0 <= x < N and 1 <= y <= N\n	// If the point is non-wrapping, then 0 <= x < y <= N\n	std::array<int, 2> get_node_bounds(point pt) const {\n		int a = int(pt);\n		assert(1 <= a && a < 2 * N);\n		int l = __builtin_clz(a) - __builtin_clz(2*N-1);\n		int S = next_pow_2(N);\n		int x = a << l, y = (a+1) << l;\n		assert(S <= x && x < y && y <= 2*S);\n		return {(x >= 2 * N ? x >> 1 : x) - N, (y > 2 * N ? y >> 1 : y) - N};\n	}\n\n	// Returns the split point of the node, such that 1 <= s <= N.\n	int get_node_split(point pt) const {\n		int a = int(pt);\n		assert(1 <= a && a < N);\n		return get_node_bounds(pt.c(0))[1];\n	}\n\n	int get_node_size(point pt) const {\n		auto bounds = get_node_bounds(pt);\n		int r = bounds[1] - bounds[0];\n		return r > 0 ? r : r + N;\n	}\n};\n\n} // namespace seg_tree\n\nint main() {\n	using namespace std;\n	ios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n	int N; cin >> N;\n	std::vector<int> P(N);\n	for (auto& a : P) { cin >> a; a--; }\n\n	binary_indexed_tree<int> bit_idx(N);\n	binary_indexed_tree<int> bit_val(N);\n	for (int i = 0; i < N; i++) {\n		for (auto& a : bit_idx.suffix(i)) a++;\n		for (auto& a : bit_val.suffix(i)) a++;\n	}\n\n	seg_tree::in_order_layout layout(2*N);\n\n	std::vector<int> cnd_seg(4*N, 2*N+1);\n	for (int i = 0; i < N; i++) {\n		if (i <= P[i]) {\n			// i+N, P[i]+N\n			cnd_seg[layout.get_point(i+N)] = P[i]+N;\n		} else {\n			// P[i], i\n			cnd_seg[layout.get_point(P[i])] = i;\n		}\n	}\n	for (auto a = seg_tree::point(2*N-1); a; a--) {\n		cnd_seg[a] = std::min(cnd_seg[a.c(0)], cnd_seg[a.c(1)]);\n	}\n\n	const int INF = 1e9;\n	struct seg_node {\n		int best = INF;\n		int lazy = 0;\n		std::array<int, 2> first{-1, -1};\n		std::array<int, 2> last{-1, -1};\n	};\n	std::vector<seg_node> seg(4*N);\n	auto update_node = [&](seg_tree::point a) -> void {\n		if (seg[a.c(0)].first[0] != -1) {\n			seg[a].first = seg[a.c(0)].first;\n		} else {\n			seg[a].first = seg[a.c(1)].first;\n		}\n		if (seg[a.c(1)].last[0] != -1) {\n			seg[a].last = seg[a.c(1)].last;\n		} else {\n			seg[a].last = seg[a.c(0)].last;\n		}\n		seg[a].best = std::min(seg[a.c(0)].best, seg[a.c(1)].best);\n		assert(seg[a].lazy == 0);\n	};\n	auto apply_lazy = [&](seg_tree::point a, int v) -> void {\n		seg[a].best += v;\n		seg[a].lazy += v;\n	};\n	auto downdate_node = [&](seg_tree::point a) -> void {\n		apply_lazy(a.c(0), seg[a].lazy);\n		apply_lazy(a.c(1), seg[a].lazy);\n		seg[a].lazy = 0;\n	};\n\n	auto insert_pareto = [&](int l, int r) {\n		int val = 0;\n		if (l >= N) {\n			// l = i+N, r = P[i]+N\n			assert(P[l-N] == r-N);\n			for (auto a : bit_idx.prefix(l-N)) val -= a;\n			for (auto a : bit_val.prefix(r-N)) val += a;\n		} else {\n			assert(P[r] == l);\n			for (auto a : bit_val.prefix(l)) val -= a;\n			for (auto a : bit_idx.prefix(r)) val += a;\n		}\n		//cerr << ""insert pareto "" << l << ' ' << r << ' ' << val << '\n';\n		auto a = layout.get_point(l);\n		a.for_parents_down(downdate_node);\n		seg[a].best = val;\n		seg[a].lazy = 0;\n		seg[a].first = seg[a].last = {l, r};\n		a.for_parents_up(update_node);\n	};\n\n	auto fix_pareto = [&](int orig_l) {\n		//cerr << ""fixing pareto "" << orig_l << '\n';\n		int prv_l = -1, prv_r = -1;\n		layout.get_range(0, orig_l).for_each_l_to_r([&](auto a) -> void {\n			if (seg[a].last[0] != -1) {\n				prv_l = seg[a].last[0];\n				prv_r = seg[a].last[1];\n			}\n		});\n		int nxt_l = 2*N, nxt_r = 2*N;\n		layout.get_range(orig_l+1, 2*N).for_each_r_to_l([&](auto a) -> void {\n			if (seg[a].first[0] != -1) {\n				nxt_l = seg[a].first[0];\n				nxt_r = seg[a].first[1];\n			}\n		});\n		// it must start strictly between prv_l and nxt_l\n		while(nxt_l - prv_l > 1) {\n			auto rng = layout.get_range(prv_l + 1, nxt_l);\n			int best_r = 2*N+1;\n			rng.for_each([&](auto a) -> void {\n				best_r = std::min(best_r, cnd_seg[a]);\n			});\n			assert(best_r > prv_r);\n			if (best_r >= nxt_r) break;\n			int best_l = -1;\n			rng.for_each([&](auto a) -> void {\n				if (cnd_seg[a] == best_r) {\n					while (a < 2*N) {\n						a = a.c(cnd_seg[a.c(1)] == best_r);\n						assert(cnd_seg[a] == best_r);\n					}\n					assert(cnd_seg[a] == best_r);\n					best_l = layout.get_leaf_index(a);\n				}\n			});\n			assert(best_l != -1);\n\n			auto p = layout.get_point(best_l);\n			assert(cnd_seg[p] == best_r);\n			cnd_seg[p] = 2*N+1;\n			p.for_parents_up([&](auto a) {\n				cnd_seg[a] = std::min(cnd_seg[a.c(0)], cnd_seg[a.c(1)]);\n			});\n\n			insert_pareto(best_l, best_r);\n			prv_l = best_l;\n			prv_r = best_r;\n		}\n	};\n	fix_pareto(0);\n\n	auto reduce_seg = [&](int l, int r) -> void {\n		//cerr << ""reduce seg "" << l << ' ' << r << '\n';\n		// reduce everything < l which ends > r\n		int bad_l = -1;\n		{\n			auto rng = layout.get_range(0, l);\n			rng.for_each_r_to_l([&](auto a) ->void {\n				if (bad_l != -1) return;\n				if (seg[a].first[0] == -1 || seg[a].first[1] > r) return;\n				while (a < 2*N) {\n					if (seg[a.c(1)].first[0] != -1 && seg[a.c(1)].first[1] <= r) a = a.c(1);\n					else a = a.c(0);\n				}\n				bad_l = layout.get_leaf_index(a);\n			});\n		}\n\n		auto rng = layout.get_range(bad_l+1, l);\n		rng.for_parents_down(downdate_node);\n		rng.for_each([&](auto a) -> void {\n			apply_lazy(a, -1);\n		});\n		rng.for_parents_up(update_node);\n	};\n\n	int ans = -1;\n\n	std::vector<int> q; q.reserve(N);\n	for (int z = 0; z < N; z++) {\n		while (seg[1].best <= ans || z == int(q.size())) {\n			if (seg[1].best > ans) {\n				assert(z == int(q.size()));\n				ans = seg[1].best;\n			}\n			auto a = seg_tree::point(1);\n			while (a < 2*N) {\n				assert(seg[a].best == ans);\n				downdate_node(a);\n				a = a.c(seg[a.c(1)].best == ans);\n			}\n			assert(seg[a].best == ans);\n			assert(seg[a].first == seg[a].last);\n			auto [l, r] = seg[a].first;\n			seg[a].best = INF;\n			seg[a].lazy = 0;\n			seg[a].first = seg[a].last = {-1, -1};\n			a.for_parents_up(update_node);\n			assert(l == layout.get_leaf_index(a));\n\n			if (l >= N) {\n				// i+N, P[i]+N\n				q.push_back(l-N);\n			} else {\n				// P[i], i\n				q.push_back(r);\n			}\n\n			fix_pareto(l);\n		}\n\n		int i = q[z];\n		//cerr << ""ans = "" << ans << '\n';\n		//cerr << ""process "" << i << ' ' << P[i] << '\n';\n		reduce_seg(i+N, P[i]+N);\n		reduce_seg(P[i], i);\n		for (auto& a : bit_idx.suffix(i)) a--;\n		for (auto& a : bit_val.suffix(P[i])) a--;\n	}\n\n	cout << ans << '\n';\n\n	return 0;\n}\n","data structures,greedy","1672","I"
"#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int INF = 0x3f3f3f3f;\n\nstruct segt\n{\n	int tag[1048576];\n	PII val[1048576];\n	segt()\n	{\n		rep(i, 524288) val[i | 524288] = MP(INF, i);\n		for(int i = 524287; i >= 1; i --) val[i] = min(val[i << 1], val[i << 1 | 1]);\n	}\n	void add(int l, int r, int x, int cv = 1, int cl = 0, int cr = 524287)\n	{\n		if(l > cr || r < cl) return;\n		if(l <= cl && r >= cr) {\n			val[cv].first += x; tag[cv] += x; return;\n		}\n		int mid = (cl + cr) >> 1;\n		add(l, r, x, cv << 1, cl, mid);\n		add(l, r, x, cv << 1 | 1, mid + 1, cr);\n		val[cv] = min(val[cv << 1], val[cv << 1 | 1]);\n		val[cv].first += tag[cv];\n	}\n	PII query(int l, int r, int cv = 1, int cl = 0, int cr = 524287)\n	{\n		if(l > cr || r < cl) return MP(INF, -1);\n		if(l <= cl && r >= cr) return val[cv];\n		int mid = (cl + cr) >> 1;\n		PII ret = min(query(l, r, cv << 1, cl, mid), query(l, r, cv << 1 | 1, mid + 1, cr));\n		ret.first += tag[cv];\n		return ret;\n	}\n};\nstruct fwt\n{\n	int dat[500005];\n	void add(int id, int val)\n	{\n		for(; id <= 500000; id += id & -id) dat[id] += val;\n	}\n	int query(int id)\n	{\n		int val = 0;\n		for(; id > 0; id -= id & -id) val += dat[id];\n		return val;\n	}\n};\nint n, a[500005];\nstruct ds\n{\n	segt t0, t1;\n	fwt s0, s1;\n	int x[500005];\n	set<int> S;\n	map<int, int> G;\n	void gen()\n	{\n		x[0] = 0; x[n + 1] = n + 1;\n		S.insert(0); S.insert(n + 1);\n		int mn = INF;\n		for(int i = n; i >= 1; i --) if(x[i]) {\n			mn = min(mn, x[i]);\n			if(mn == x[i]) {\n				S.insert(i); G[x[i]] = i; t0.add(i, i, x[i] - i - INF);\n			} else t1.add(i, i, x[i] - INF);\n		}\n	}\n	void tadd(int x, int y)\n	{\n		s0.add(x, 1);\n		s1.add(y, 1);\n	}\n	void madd(int r, int l)\n	{\n		map<int, int>::iterator it = G.lower_bound(l);\n		if(it != G.end()) t0.add(it->second, r, -1);\n		tadd(r, l);\n	}\n	int cquery(int id)\n	{\n		return s1.query(x[id]) - s0.query(id);\n	}\n	void del(int id)\n	{\n		set<int>::iterator it = S.find(id);\n		int pr = *prev(it), nx = *next(it);\n		G.erase(x[id]); S.erase(it);\n		t0.add(id, id, INF);\n		while(true) {\n			PII cur = t1.query(pr, nx);\n			if(cur.first > x[nx]) break;\n			S.insert(cur.second); G[cur.first] = cur.second;\n			t0.add(cur.second, cur.second, cur.first - cur.second - cquery(cur.second) - t0.query(cur.second, cur.second).first);\n			t1.add(cur.second, cur.second, INF);\n			pr = cur.second;\n		}\n	}\n	PII calc()\n	{\n		return t0.val[1];\n	}\n}dl, dr;\n\nint main()\n{\n	scanf(""%d"", &n);\n	rep1(i, n) scanf(""%d"", &a[i]);\n	rep1(i, n) if(a[i] >= i) dl.x[i] = a[i];\n	else dr.x[n + 1 - i] = n + 1 - a[i];\n	dl.gen();\n	dr.gen();\n	int ans = 0;\n	rep1(i, n) {\n		PII cl = dl.calc(), cr = dr.calc(), cur = min(cl, cr);\n		ans = max(ans, cur.first);\n		if(cur == cl) {\n			dr.madd(n + 1 - cur.second, n + 1 - a[cur.second]); dl.tadd(cur.second, a[cur.second]);\n			dl.del(cur.second);\n		} else {\n			dl.madd(n + 1 - cur.second, a[n + 1 - cur.second]); dr.tadd(cur.second, n + 1 - a[n + 1 - cur.second]);\n			dr.del(cur.second);\n		}\n	}\n	printf(""%d\n"", ans);\n	return 0;\n}","data structures,greedy","1672","I"
"#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define MAXN 200005\nchar c[MAXN];\nint t,n,q,i,j,a[MAXN],b[MAXN],s[MAXN][2];\nint main()\n{\n	scanf(""%d%d%s"",&n,&q,c+1);\n	for(i=1;i<n;i++)\n	{\n		copy(s[i-1],s[i-1]+2,s[i]);\n		if(c[i]==c[i+1])s[i][c[i]^'0']++;\n	}\n	while(q--)\n	{\n		scanf(""%d%d"",&i,&j);\n		i--;\n		j--;\n		printf(""%d\n"",max(s[j][0]-s[i][0],s[j][1]-s[i][1])+1);\n	}\n	return 0;\n}","constructive algorithms,greedy","1672","H"
"#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 5;\nint n, q, l, r, a[N], s[N][2];\nint main() {\n  scanf(""%d%d"", &n, &q);\n  for (int i = 1; i <= n; i++) {\n    scanf(""%1d"", &a[i]);\n    s[i][0] = s[i - 1][0];\n    s[i][1] = s[i - 1][1];\n    s[i][a[i]] += a[i] == a[i - 1];\n  }\n  while (q--) {\n    scanf(""%d%d"", &l, &r);\n    printf(""%d\n"", max(s[r][0] - s[l][0], s[r][1] - s[l][1]) + 1);\n  }\n  return 0;\n}","constructive algorithms,greedy","1672","H"
"#include<bits/stdc++.h>\nusing namespace std;\nint n,q;\nint N,pos[200004],s[200004];\nchar c[200004];\nint main(){\n	scanf(""%d%d%s"",&n,&q,c+1);\n	pos[1]=N=1,s[1]=c[1]=='0'?-1:1;\n	for(int i=2;i<=n;i++){\n		pos[i]=pos[i-1];\n		if(c[i]==c[i-1])\n			s[++N]=c[i]=='0'?-1:1,pos[i]++;\n	}\n	for(int i=1;i<=N;i++)s[i]+=s[i-1];\n	while(q--){\n		int l,r;scanf(""%d%d"",&l,&r);\n		l=pos[l],r=pos[r];\n		printf(""%d\n"",1+(r-l+abs(s[r]-s[l]))/2);\n	}\n}","constructive algorithms,greedy","1672","H"
"#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll n,q,l,r,a[200005],b[200005];\nchar st[2000005];\nint main()\n{\n    scanf(""%lld%lld"",&n,&q);\n    scanf(""%s"",st+1);\n    for(int i=1;i<=n-1;i++)\n    {\n     a[i]=a[i-1];b[i]=b[i-1];\n     if(st[i]==st[i+1])\n     {\n     	if(st[i]=='1')a[i]++;else b[i]++;\n     }\n    }\n    for(int i=1;i<=q;i++)\n    {\n    	scanf(""%lld%lld"",&l,&r);\n    	cout<<1+max(a[r-1]-a[l-1],b[r-1]-b[l-1])<<endl;\n    }\n	return 0;\n}","constructive algorithms,greedy","1672","H"
"#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int M=998244353;\nint r,c,w[4004];\nchar s[2002][2002];\nvector<int>g[4004];\nvoid sol0(){\n	int ans=1;\n	for(int i=1;i<=r;i++)for(int j=1;j<=c;j++)\n		if(s[i][j]=='?')ans=ans*2%M;\n	printf(""%d"",ans);\n	exit(0);\n}\nvoid sol1(){\n	int ans=0;\n	for(int t=0;t<2;t++){\n		int all=1;\n		for(int i=1;i<=r;i++){\n			int cnt=0,sum=0;\n			for(int j=1;j<=c;j++){\n				if(s[i][j]=='?')cnt++;\n				else sum^=(s[i][j]-'0');\n			}\n			if(cnt==0)all=all*(sum==t?1:0);\n			else for(int j=0;j<cnt-1;j++)all=all*2%M;\n		}\n		(ans+=all)%=M;\n	}\n	printf(""%d"",ans);\n	exit(0);\n}\nvoid sol2(){\n	swap(r,c);\n	for(int i=1;i<=max(r,c);i++)for(int j=1;j<=max(r,c);j++)\n		if(i<j)swap(s[i][j],s[j][i]);\n	sol1();\n}\nbool vis[4004];\nint ver,edg,tmp;\nvoid dfs(int x){\n	if(vis[x])return;\n	vis[x]=1,tmp^=w[x],ver++,edg+=g[x].size();\n	for(auto y:g[x])dfs(y);\n}\nvoid sol3(){\n	for(int i=1;i<=r;i++)for(int j=1;j<=c;j++){\n		int a=i,b=r+j;\n		if(s[i][j]=='?')g[a].push_back(b),g[b].push_back(a);\n		else w[a]^=s[i][j]-'0',w[b]^=s[i][j]-'0';\n	}\n	int ans=0;\n	for(int t=0;t<2;t++){\n		int all=1;\n		memset(vis,0,sizeof(vis));\n		for(int i=1;i<=r+c;i++)if(!vis[i]){\n			ver=edg=tmp=0,dfs(i);\n			edg=edg/2-(ver-1);\n			int mul=1;\n			for(int j=0;j<edg;j++)mul=mul*2%M;\n			if(ver&1)all=(ll)all*((tmp^t)?0:mul)%M;\n			else all=(ll)all*(tmp?0:mul)%M;\n		}\n		(ans+=all)%=M;\n	}\n	printf(""%d"",ans);\n}\nint main(){\n	scanf(""%d%d"",&r,&c);\n	for(int i=1;i<=r;i++)scanf(""%s"",s[i]+1);\n	if(r%2==0&&c%2==0)sol0();\n	if(r%2==0&&c%2==1)sol1();\n	if(r%2==1&&c%2==0)sol2();\n	if(r%2==1&&c%2==1)sol3();\n}","constructive algorithms,graphs,math","1672","G"
"//��CF1627G\n#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nconst int N = 4096;\nconst int MO = 998244353;\nint n,m,a[N],f[N],sz[N],g[N],p2[N*N];\nchar c[N][N],d[N][N];\nint fnd(int x){\n	if(f[x]==x)\n		return x;\n	return f[x]=fnd(f[x]);\n}\nvoid uni(int x,int y){\n	if(x!=y){\n		sz[x]+=sz[y];\n		f[y]=x;\n	}\n}\nint main()\n{\n	int i,j,k=0,l,x,s,s0,s1;\n	p2[0]=1;\n	for(i=1;i<N*N;i++)\n		p2[i]=p2[i-1]*2%MO;\n	scanf(""%d%d"",&n,&m);\n	for(i=1;i<=n;i++)\n		scanf(""%s"",c[i]+1);\n	if(n%2==1&&m%2==0){\n		for(i=1;i<=n;i++)\n			for(j=1;j<=m;j++)\n				d[i][j]=c[i][j];\n		for(i=1;i<=n;i++)\n			for(j=1;j<=m;j++)\n				c[j][i]=d[i][j];\n		swap(n,m);\n	}\n	for(i=1;i<=n+m;i++)\n		f[i]=i,sz[i]=1;\n	for(i=1;i<=n;i++){\n		for(j=1;j<=m;j++){\n			if(c[i][j]!='?'){\n				a[i]^=c[i][j]-'0';\n				a[n+j]^=c[i][j]-'0';\n			}\n			else{\n				k++;\n				uni(fnd(i),fnd(n+j));\n			}\n		}\n	}\n	if(n%2==0&&m%2==0){\n		printf(""%d\n"",p2[k]);\n		return 0;\n	}\n	if(n%2==1&&m%2==1){\n		s=0;\n		memset(g,0,sizeof(g));\n		for(i=1;i<=n+m;i++)\n			g[fnd(i)]^=a[i];\n		x=1;\n		l=0;\n		for(i=1;i<=n+m;i++)\n			if(f[i]==i){\n				if(g[i])\n					x=0;\n				l+=sz[i]-1;\n			}\n		s+=x*p2[k-l];\n		for(i=1;i<=n+m;i++)\n			a[i]^=1;\n		memset(g,0,sizeof(g));\n		for(i=1;i<=n+m;i++)\n			g[fnd(i)]^=a[i];\n		x=1;\n		l=0;\n		for(i=1;i<=n+m;i++)\n			if(f[i]==i){\n				if(g[i])\n					x=0;\n				l+=sz[i]-1;\n			}\n		s+=x*p2[k-l];\n		printf(""%d\n"",s%MO);\n		return 0;\n	}\n	s0=1,s1=1;\n	x=0;\n	for(i=1;i<=n;i++){\n		l=0;\n		for(j=1;j<=m;j++)\n			l+=c[i][j]=='?';\n		if(l==0){\n			if(a[i])\n				s0=0;\n			else\n				s1=0;\n		}\n		else\n			x++;\n	}\n	printf(""%d\n"",(LL)(s0+s1)*p2[k-x]%MO);\n	return 0;\n}\n","constructive algorithms,graphs,math","1672","G"
"#include<cstdio>\n#include<vector>\n\nusing namespace std;\n\nconst int MOD=998244353;\nint add(int x,int y){return x+y>=MOD?x+y-MOD:x+y;}\nint sub(int x,int y){return x>=y?x-y:x+MOD-y;}\n\nint pw2[5000000];\nvoid init_pw2(int n)\n{\n	pw2[0]=1;for(int i=1;i<=n;i++)pw2[i]=add(pw2[i-1],pw2[i-1]);\n}\n\nstruct BCJ\n{\n	int fa[10000];\n	void init(int n){for(int i=1;i<=n;i++)fa[i]=i;}\n	int fnd(int x){return x==fa[x]?x:fa[x]=fnd(fa[x]);}\n	void conn(int x,int y){fa[fnd(x)]=fnd(y);}\n}B;\n\nvector<int> V[10000];\n\nchar b[2500][2500];\n\nint cnt_r[2500],cnt_c[2500];\n\nint main()\n{\n	init_pw2(4000000);\n	int r=0,c=0;scanf(""%d%d"",&r,&c);int cnt_q=0;\n	for(int i=1;i<=r;i++)for(int j=1;j<=c;j++)\n	{\n		scanf("" %c"",&b[i][j]);\n		if(b[i][j]=='?')cnt_q++;\n		else if(b[i][j]=='1')cnt_r[i]^=1,cnt_c[j]^=1;\n	}\n	\n	if(r%2==0&&c%2==0)\n	{\n		printf(""%d"",pw2[cnt_q]);return 0;\n	}\n	if(c%2==0)\n	{\n		int ans=cnt_q;bool flag=1;\n		for(int j=1;j<=c;j++)\n		{\n			int x=0;for(int i=1;i<=r;i++)if(b[i][j]=='?'){x=1;break;}\n			if(x){ans--;}\n			else{if(cnt_c[j]){flag=0;break;}}\n		}\n		int sum=flag?pw2[ans]:0;\n		\n		ans=cnt_q,flag=1;\n		for(int j=1;j<=c;j++)\n		{\n			int x=0;for(int i=1;i<=r;i++)if(b[i][j]=='?'){x=1;break;}\n			if(x){ans--;}\n			else{if(!cnt_c[j]){flag=0;break;}}\n		}\n		if(flag)sum=add(sum,pw2[ans]);\n		\n		printf(""%d"",sum);return 0;\n	}\n	if(r%2==0)\n	{\n		int ans=cnt_q;bool flag=1;\n		for(int i=1;i<=r;i++)\n		{\n			int x=0;for(int j=1;j<=c;j++)if(b[i][j]=='?'){x=1;break;}\n			if(x){ans--;}\n			else{if(cnt_r[i]){flag=0;break;}}\n		}\n		int sum=flag?pw2[ans]:0;\n		\n		ans=cnt_q;flag=1;\n		for(int i=1;i<=r;i++)\n		{\n			int x=0;for(int j=1;j<=c;j++)if(b[i][j]=='?'){x=1;break;}\n			if(x){ans--;}\n			else{if(!cnt_r[i]){flag=0;break;}}\n		}\n		if(flag)sum=add(sum,pw2[ans]);\n		\n		printf(""%d"",sum);return 0;\n	}\n	\n	int ans=cnt_q;bool flag=1;\n	B.init(r+c);\n	for(int i=1;i<=r;i++)for(int j=1;j<=c;j++){if(b[i][j]=='?'){B.conn(i,j+r);}}\n	for(int i=1;i<=r+c;i++){V[B.fnd(i)].push_back(i);}\n	\n	for(int i=1;i<=r+c;i++)\n	{\n		if(V[i].size())\n		{\n			int x=0;for(int j=0;j<V[i].size();j++)if(V[i][j]>r)x^=cnt_c[V[i][j]-r];else x^=cnt_r[V[i][j]];\n			if(x){flag=0;break;}\n			else ans-=V[i].size()-1;\n		}\n	}\n	int sum=flag?pw2[ans]:0;\n	\n	ans=cnt_q,flag=1;\n	for(int i=1;i<=r+c;i++)\n	{\n		if(V[i].size())\n		{\n			int x=0;for(int j=0;j<V[i].size();j++)if(V[i][j]>r)x^=cnt_c[V[i][j]-r]^1;else x^=cnt_r[V[i][j]]^1;\n			if(x){flag=0;break;}\n			else ans-=V[i].size()-1;\n		}\n	}\n	if(flag)sum=add(sum,pw2[ans]);\n	\n	printf(""%d"",sum);\n}","constructive algorithms,graphs,math","1672","G"
"#include <bits/stdc++.h>\n\n#define long long long int\nusing namespace std;\n\n// @author: pashka\n\nvector<vector<int>> g;\n\nconst long MOD = 998244353;\n\nvector<bool> z;\nvector<int> d;\nint s1, se, sv;\n\nvoid dfs(int x) {\n    if (z[x]) return;\n    z[x] = true;\n    sv++;\n    if (d[x] == 1) s1++;\n    for (int y: g[x]) {\n        se++;\n        dfs(y);\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n, m;\n    cin >> n >> m;\n    g.resize(n + m);\n    d.resize(n + m);\n    int c = 0;\n    for (int i = 0; i < n; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < m; j++) {\n            if (s[j] == '?') {\n                g[i].push_back(n + j);\n                g[n + j].push_back(i);\n                c++;\n            } else {\n                if (s[j] == '1') {\n                    d[i] ^= 1;\n                    d[n + j] ^= 1;\n                }\n            }\n        }\n    }\n    vector<long> p2(n * m + 1);\n    p2[0] = 1;\n    for (int i = 0; i < n * m; i++) {\n        p2[i + 1] = (p2[i] * 2) % MOD;\n    }\n    if (n % 2 == 0 && m % 2 == 0) {\n        cout << p2[c] << ""\n"";\n        return 0;\n    }\n    if (n % 2 == 0 && m % 2 == 1) {\n        long res = 0;\n        for (int t = 0; t < 2; t++) {\n            long s = 1;\n            for (int i = 0; i < n; i++) {\n                int x = d[i] ^t;\n                if (x == 1 && g[i].size() == 0) {\n                    s = 0;\n                }\n                if (g[i].size() > 0) {\n                    s *= p2[g[i].size() - 1];\n                    s %= MOD;\n                }\n            }\n            res += s;\n            res %= MOD;\n        }\n        cout << res << ""\n"";\n        return 0;\n    }\n    if (n % 2 == 1 && m % 2 == 0) {\n        long res = 0;\n        for (int t = 0; t < 2; t++) {\n            long s = 1;\n            for (int j = 0; j < m; j++) {\n                int x = d[n + j] ^t;\n                if (x == 1 && g[n + j].size() == 0) {\n                    s = 0;\n                }\n                if (g[n + j].size() > 0) {\n                    s *= p2[g[n + j].size() - 1];\n                    s %= MOD;\n                }\n            }\n            res += s;\n            res %= MOD;\n        }\n        cout << res << ""\n"";\n        return 0;\n    }\n    long res = 0;\n    for (int t = 0; t < 2; t++) {\n        long s = 1;\n        z.assign(n + m, false);\n        for (int i = 0; i < n + m; i++) {\n            if (z[i]) continue;\n            s1 = 0;\n            sv = 0;\n            se = 0;\n            dfs(i);\n            if (t == 1) s1 = sv - s1;\n            se /= 2;\n            if (s1 % 2 == 1) {\n                s = 0;\n                break;\n            }\n            int x = se - (sv - 1);\n            s *= p2[x];\n            s %= MOD;\n        }\n        res += s;\n        res %= MOD;\n    }\n    cout << res << ""\n"";\n\n    return 0;\n}","constructive algorithms,graphs,math","1672","G"
"#include<bits/stdc++.h>\nconst int N=2e5+3;\nint n,a[N],t[N],b[N],deg[N],q[N],l,r,cnt;\nstd::vector<int>g[N];\nint main(){\n	int T;scanf(""%d"",&T);for(;T--;){\n	scanf(""%d"",&n);\n	l=0,r=-1,cnt=0;\n	for(int i=1;i<=n;i++)b[i]=0,g[i].clear(),deg[i]=0;\n	for(int i=1;i<=n;i++)scanf(""%d"",a+i),++b[a[i]],t[i]=i;\n	std::sort(t+1,t+1+n,[](const int&i,const int&j){return b[i]<b[j];});\n	for(int i=1;i<=n;i++){\n		scanf(""%d"",b+i);\n		if(a[i]!=t[n]&&b[i]!=t[n])g[a[i]].push_back(b[i]),++deg[b[i]];\n	}\n	for(int i=1;i<=n;i++)if(!deg[i])q[++r]=i;\n	for(;l<=r;){\n		int i=q[l++];\n		++cnt;\n		for(int j=0;j<g[i].size();j++){\n			--deg[g[i][j]];\n			if(!deg[g[i][j]])q[++r]=g[i][j];\n		}\n	}\n	puts(cnt==n?""AC"":""WA"");\n	}return 0;\n}","constructive algorithms,dfs and similar,graphs","1672","F2"
"#include <bits/stdc++.h>\nusing namespace std;\nvoid solve() {\n  int n, p = 0;\n  scanf(""%d"", &n);\n  vector<int> a(n), b(n), vis(n + 1), ins(n + 1);\n  vector<vector<int>> g(n + 1);\n  for (auto& x : a) scanf(""%d"", &x);\n  for (int i = 0; i < n; i++) scanf(""%d"", &b[i]), g[a[i]].push_back(b[i]);\n  for (int i = 1; i <= n; i++) if (g[i].size() > g[p].size()) p = i;\n  vis[p] = 1; bool ok = true;\n  function<void(int)> dfs = [&](int u) {\n    ins[u] = vis[u] = 1;\n    for (auto v : g[u]) ok &= !ins[v], vis[v] ? void() : dfs(v);\n    ins[u] = 0;\n  };\n  for (int i = 1; i <= n; i++) if (!vis[i]) dfs(i);\n  puts(ok ? ""AC"" : ""WA"");\n}\nint main() {\n  int t;\n  scanf(""%d"", &t);\n  while (t--) solve();\n  return 0;\n}","constructive algorithms,dfs and similar,graphs","1672","F2"
"#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+5;\nint cnt[N],a[N],b[N];\nbool vis[N],invis[N];\nvector<int> e[N];\nvoid solve(){\n	int n;\n	cin>>n;\n	for (int i=1;i<=n;++i){\n		cnt[i]=0,e[i].clear();vis[i]=0;\n	}\n	for (int i=1;i<=n;++i){\n		cin>>a[i];cnt[a[i]]++;\n	}\n	for (int i=1;i<=n;++i) cin>>b[i];\n	\n	int mx=max_element(cnt+1,cnt+n+1)-cnt;\n	for (int i=1;i<=n;++i)\n	 if (a[i]!=mx&&b[i]!=mx) e[a[i]].push_back(b[i]);\n	 \n	bool flag=0;\n	\n	function<void(int)> dfs=[&](int u){\n		vis[u]=1;\n		invis[u]=1;\n		for (int v:e[u])\n		  if (!vis[v]) dfs(v);\n		   else if (invis[v]) flag=1;\n		invis[u]=0;\n	};\n	for (int i=1;i<=n;++i)\n	 if (!vis[i]) dfs(i);\n	\n	cout<<(flag?""WA\n"":""AC\n"");\n}\nint main(){\n	ios_base::sync_with_stdio(false);\n	cin.tie(0),cout.tie(0);\n	int T;\n	cin>>T;\n	while (T--) solve();\n}\n","constructive algorithms,dfs and similar,graphs","1672","F2"
"#include<bits/stdc++.h>\nusing namespace std;\nint t,n,num[200004];\nint a[200004],b[200004];\nvector<int>g[400004];\nvector<int>ord;\nbool vis[400004];\nint topo[400004],cnt;\nvoid dfs(int x){\n	if(vis[x])return;\n	vis[x]=1;\n	for(auto y:g[x])dfs(y);\n	topo[x]=++cnt;\n}\nint main(){\n	scanf(""%d"",&t);\n	while(t--){\n		scanf(""%d"",&n);\n		memset(num,0,(n+2)<<2);\n		for(int i=1;i<=n;i++)scanf(""%d"",&a[i]),num[a[i]]++;\n		for(int i=1;i<=n;i++)scanf(""%d"",&b[i]);\n		int val=0;\n		for(int i=1;i<=n;i++)if(num[val]<num[i])val=i;\n		val+=n;\n		for(int i=1;i<=n+n;i++)g[i].clear(),vis[i]=0;\n		for(int i=1;i<=n;i++){\n			g[i].push_back(b[i]+n);\n			g[a[i]+n].push_back(i);\n		}\n		ord.clear(),vis[val]=1,cnt=0;\n		for(int i=1;i<=n+n;i++)if(!vis[i])dfs(i);\n		bool ok=1;\n		for(int i=1;i<=n+n;i++)if(i!=val)\n			for(auto j:g[i])if(j!=val)\n				ok&=topo[i]>topo[j];\n		puts(ok?""AC"":""WA"");\n	}\n}","constructive algorithms,dfs and similar,graphs","1672","F2"
"#include<bits/stdc++.h>\nusing namespace std;\nint t,n,s[200005],ma,xl[200005],sl[200005];\nmap<int,vector<int> >m;\nint main(){\n	cin>>t;\n	while(t--){\n		cin>>n;\n		ma=0;\n		m.clear();\n		for(int i=1;i<=n;++i)sl[i]=0;\n		for(int i=0;i<n;++i){\n			cin>>s[i];\n			xl[i]=s[i];\n			sl[s[i]]++;\n			ma=max(ma,sl[s[i]]);\n		}\n		sort(xl,xl+n);\n		for(int i=0;i<n;++i){\n			m[xl[i]].push_back(xl[(i+ma)%n]);\n		}\n		for(int i=0;i<n;++i){\n			cout<<m[s[i]].back()<<"" "";\n			m[s[i]].pop_back();\n		}\n		cout<<endl;\n	}\n	}","constructive algorithms,graphs,greedy","1672","F1"
"#include <bits/stdc++.h>\nusing namespace std;\nvoid solve() {\n  int n;\n  scanf(""%d"", &n);\n  vector<int> a(n), p(n), cnt(n + 1), ans(n);\n  for (auto& x : a) scanf(""%d"", &x), ++cnt[x];\n  iota(p.begin(), p.end(), 0);\n  sort(p.begin(), p.end(), [&](int i, int j) { return a[i] < a[j]; });\n  int mx = *max_element(cnt.begin(), cnt.end());\n  for (int i = 0; i < n; i++) ans[p[i]] = a[p[(i + mx) % n]];\n  for (auto& x : ans) printf(""%d "", x);\n  puts("""");\n}\nint main() {\n  int t;\n  scanf(""%d"", &t);\n  while (t--) solve();\n  return 0;\n}","constructive algorithms,graphs,greedy","1672","F1"
"#include<bits/stdc++.h>\nconst int N=2e5+3;\nint n,a[N],t[N],b[N];\nstd::vector<int>g[N];\nint main(){\n	int T;scanf(""%d"",&T);for(;T--;){\n	scanf(""%d"",&n);\n	for(int i=1;i<=n;i++)b[i]=0;\n	for(int i=1;i<=n;i++)scanf(""%d"",a+i),++b[a[i]],t[i]=i;\n	std::sort(t+1,t+1+n,[](const int&i,const int&j){return b[i]<b[j];});\n	for(int i=1;i<=n;i++){\n		for(int j=0;j<b[t[i]]-b[t[i-1]];j++)g[t[n]].push_back(t[i]);\n		if(i<n)for(int j=0;j<b[t[i]];j++)g[t[i]].push_back(t[i+1]);\n	}\n	for(int i=1;i<=n;i++)printf(""%d "",g[a[i]].back()),g[a[i]].pop_back();\n	puts("""");\n	}return 0;\n}","constructive algorithms,graphs,greedy","1672","F1"
"#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int, int> PII;\nconst int N = 2e5 + 9;\nint a[N];\nsigned main()\n{\n    int t;\n    cin>>t;\n    while (t--)\n    {\n        multiset<int>se;\n        int n;\n        cin>>n;\n        for (int i=1;i<=n;i++)\n        {\n            cin>>a[i];\n            se.insert(a[i]);\n        }\n        for (int i=1;i<=n;i++)\n        {\n            auto it =  se.upper_bound(a[i]);\n            if (it==se.end()) it = se.begin();\n            cout<<*it<<"" "";se.erase(it);\n        }\n        cout<<endl;\n    }\n}","constructive algorithms,graphs,greedy","1672","F1"
"#include<bits/stdc++.h>\nconst int N=2000;\nint n,ans;\ninline int Query(int x){int res;printf(""? %d\n"",x),fflush(stdout),scanf(""%d"",&res);return res;}\nint main(){\n	scanf(""%d"",&n);\n	int l=1,r=N*N+N,md;\n	for(;l<r;){\n		md=l+r>>1;\n		Query(md)==1?r=md:l=md+1;\n	}\n	ans=l;\n	for(int i=2;i<=n;i++)\n		if(Query(l/i)==i)\n			ans=l/i*i;\n	printf(""! %d\n"",ans);\n	return 0;\n}","binary search,constructive algorithms,greedy,interactive","1672","E"
"#include<bits/stdc++.h>\nconst int N=2000;\nint n,ans;\ninline int Query(int x){int res;printf(""? %d\n"",x),fflush(stdout),scanf(""%d"",&res);return res;}\nint main(){\n	scanf(""%d"",&n);\n	int l=1,r=N*N+N,md;\n	for(;l<r;){\n		md=l+r>>1;\n		Query(md)==1?r=md:l=md+1;\n	}\n	ans=l;\n	for(int i=2;i<=n;i++)\n		if(Query(l/i)==i)\n			ans=std::min(l/i*i,ans);\n	printf(""! %d\n"",ans);\n	return 0;\n}","binary search,constructive algorithms,greedy,interactive","1672","E"
"#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> vec;\nint n,m,i,j,k,t,t1,u,v,a,b;\nint l,r,mid;\nint main()\n{\n	cin>>n;\n	l=1; r=1e7; // binsearch for text length (w/ space)\n	while(l<r) {\n		mid=(l+r)/2;\n		cout<<""? ""<<mid<<endl;\n		cin>>u;\n		if (u==1) r=mid; else l=mid+1;\n	}\n	a=l;\n	// magic!\n	for (i=2;i<=n;i++) {\n		cout<<""? ""<<l/i<<endl;\n		cin>>u;\n		if (u) a=min(a,u*(l/i));\n	}\n	cout<<""! ""<<a<<endl;\n}\n// a;","binary search,constructive algorithms,greedy,interactive","1672","E"
"#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nlong long n,a[4004004],b,c,d,i,l,r,m;\nint main()\n{\n	scanf(""%lld"",&n);l=n;r=2000*n+n;\n	while(l<=r)\n	{\n		m=(l+r)/2;\n		cout<<""? ""<<m<<endl;cin>>b;\n		if(b==1){c=m;r=m-1;}else l=m+1;\n	}\n	d=c;\n	for(i=2;i<=n;i=i+1)\n	{\n		cout<<""? ""<<(c-1)/i<<endl;cin>>b;\n		if(b>0)d=min(d,b*((c-1)/i));\n	}\n	cout<<""! ""<<d<<endl;\n    return 0;\n}\n","binary search,constructive algorithms,greedy,interactive","1672","E"
"#include<stdio.h>\nint main()\n{\n	int t,n,i,cnt[200010],a[200010],b[200010],j;\n	scanf(""%d"",&t);\n	while(t--)\n	{\n		int f=1;\n		scanf(""%d"",&n);\n		for(i=1;i<=n;i++)cnt[i]=0,scanf(""%d"",&a[i]);\n		for(i=1;i<=n;i++)scanf(""%d"",&b[i]);\n		j=1,cnt[a[1]]=1;\n		for(i=1;i<=n;i++)\n		{\n			while(j<=n && (a[j]!=b[i] || !cnt[a[j]]))j++,cnt[a[j]]++;\n			if(j>n)\n			{\n			    f=-1;\n			    printf(""NO\n"");\n			    break;\n			}\n			cnt[b[i]]--;\n		}\n		if(f==1)printf(""YES\n"");\n	}\n}","constructive algorithms,greedy,implementation,two pointers","1672","D"
"#include<bits/stdc++.h>\nusing namespace std;\nint n,a[200010],b[200010],cnt[200010],t;\nbool f;\nint main()\n{\n	cin>>t;\n	while(t--)\n	{\n		cin>>n;\n		f=0;\n		for(int i=1;i<=n;i++) \n		{\n			cin>>a[i];\n			cnt[a[i]]=0;\n		}\n		for(int i=1;i<=n;i++) cin>>b[i];\n		int j=n;\n		for(int i=n;i>=1;i--)\n		{\n			while(b[j]==a[i]&&j>=1) \n			{\n				j--;\n				cnt[a[i]]++;\n			}\n			cnt[a[i]]--;\n			if(cnt[a[i]]<0)\n			{\n				f=1;\n				break;\n			}\n		}\n		if(!f) cout<<""YES""<<endl;\n		else cout<<""NO""<<endl;\n	}\n } \n","constructive algorithms,greedy,implementation,two pointers","1672","D"
"#include <bits/stdc++.h>\nusing namespace std;\nvoid solve() {\n  int n;\n  scanf(""%d"", &n);\n  vector<int> a(n), b(n), cnt(n);\n  for (auto &x : a) scanf(""%d"", &x), --x;\n  for (auto &x : b) scanf(""%d"", &x), --x;\n  int p = n - 1, q = p;\n  while (~p) {\n    int k = a[p];\n    while (~p && a[p] == k) --cnt[k], p--;\n    while (~q && b[q] == k) ++cnt[k], q--;\n    if (cnt[k] < 0) { puts(""NO""); return ; }\n  }\n  puts(""YES"");\n}\nint main() {\n  int t;\n  scanf(""%d"", &t);\n  while (t--) solve();\n  return 0;\n}","constructive algorithms,greedy,implementation,two pointers","1672","D"
"#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define MAXN 200005\nint t,n,i,j,a[MAXN],b[MAXN],s[MAXN];\nint main()\n{\n	scanf(""%d"",&t);\n	while(t--)\n	{\n		scanf(""%d"",&n);\n		for(i=1;i<=n;i++)scanf(""%d"",a+i);\n		for(i=1;i<=n;i++)scanf(""%d"",b+i);\n		fill(s+1,s+n+1,0);\n		for(i=j=1;i<=n;i++)if(j<=n&&b[i]==a[j])j++;\n		else if(i>1&&b[i-1]==b[i]&&s[b[i]])s[b[i]]--;\n		else\n		{\n			for(;j<=n&&b[i]!=a[j];j++)s[a[j]]++;\n			if(j>n)break;\n			else j++;\n		}\n		if(i<=n)puts(""NO"");\n		else puts(""YES"");\n	}\n	return 0;\n}","constructive algorithms,greedy,implementation,two pointers","1672","D"
"#include<bits/stdc++.h>\nusing namespace std;\nint t,n,a[200010],l,r;\nint main()\n{\n	cin>>t;\n	while(t--)\n	{\n		cin>>n;\n		l=-1,r=-1;\n		for(int i=1;i<=n;i++) cin>>a[i];\n		for(int i=1;i<n;i++)\n		{\n			if(a[i]==a[i+1]) \n			{\n				if(l==-1) l=i;\n				r=i;\n			}\n		}\n		if(r==l) cout<<0<<endl;\n		else cout<<max(1,r-l-1)<<endl;\n	}\n}\n","constructive algorithms,greedy,implementation","1672","C"
"#include<bits/stdc++.h>\nconst int N=2e5+3;\nint n,a[N],ans;\nint main(){\n	int T;scanf(""%d"",&T);for(;T--;){\n	scanf(""%d"",&n);\n	ans=0;\n	for(int i=1,j=0;i<=n;i++){\n		scanf(""%d"",a+i);\n		if(i>1&&a[i]==a[i-1]){\n			if(j){\n				if(i-j==1)a[j=i]=-1,++ans;\n				else ans+=i-j-1,j=i-1;\n			}\n			else j=i;\n		}\n	}\n	printf(""%d\n"",ans);\n	}return 0;\n}","constructive algorithms,greedy,implementation","1672","C"
"#include <iostream>\n#define MAXN 200000\nusing namespace std;\nint main(){\n	int T, N, arr[MAXN];\n	for(cin >> T; T; T--){\n		cin >> N;\n		int l=0, r=0;\n		for(int i=0; i<N; i++)\n			cin >> arr[i];\n		for(int i=1; i<N; i++)\n			if(arr[i] == arr[i-1]){\n				l = l? l:i;\n				r = i;\n			}\n		if(r == l+1)\n			cout << 1 << endl;\n		else \n			cout << max(r-l-1, 0) << endl;\n	}\n}\n","constructive algorithms,greedy,implementation","1672","C"
"#include<bits/stdc++.h>\nusing namespace std;\nint t,n,l,r,q[200005];\nint main()\n{\n	cin>>t;\n	for (int i=1;i<=t;i++)\n	{\n		scanf(""%d"",&n);\n		for (int i=1;i<=n;i++)\n		 scanf(""%d"",&q[i]);\n		l=2;\n		while (q[l]!=q[l-1]&&l<=n) l++;\n		r=n-1;\n		while (q[r]!=q[r+1]&&r>0) r--;\n		if (r<l) printf(""0\n""); else if (r==l) printf(""1\n"");\n		 else printf(""%d\n"",r-l); \n	}\n}\n","constructive algorithms,greedy,implementation","1672","C"
"#include<bits/stdc++.h>\nconst int N=2e5+3;\nchar a[N],b;\nint c,ans;\nint main(){\n	int T;scanf(""%d"",&T);for(;T--;){\n	c=0,ans=1;\n	scanf(""%s"",a+1);\n	for(int i=1;a[i];i++){\n		c+=(a[i]=='A')-(a[i]=='B');\n		if(c<0)ans=0;\n		b=a[i];\n	}\n	puts(ans&&b=='B'?""YES"":""NO"");\n	}return 0;\n}","constructive algorithms,implementation","1672","B"
"#include<bits/stdc++.h>\nusing namespace std;\nint t;\nchar s[200004];\nint main(){\n	scanf(""%d"",&t);\n	while(t--){\n		scanf(""%s"",s);\n		int n=strlen(s);\n		int cur=0;\n		bool ok=s[n-1]=='B';\n		for(int i=0;i<n;i++){\n			cur+=s[i]=='A'?1:-1;\n			if(cur<0)ok=0;\n		}\n		puts(ok?""YES"":""NO"");\n	}\n}","constructive algorithms,implementation","1672","B"
"#include<stdio.h>\nchar s[1000001];\nint main(){\n	int i,j,k,n,t;\n	scanf(""%d"",&t);\n	while(t--){\n		scanf(""%s"",s);\n		for(n=0;s[n];n++);\n		k=0;\n		j=0;\n		int err=0;\n		for(i=0;i<n;i++){\n			if(s[i]=='A') k++;\n			else k--,j++;\n			if(k<0) err=1;\n		}\n		puts(!err&&j&&s[n-1]=='B'?""YES"":""NO"");\n	}\n}","constructive algorithms,implementation","1672","B"
"#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{ int t; cin>>t;\nwhile(t--)\n{ string s; cin>>s; long long a=0,b=0;\nint n=s.length(); int f=1;\nfor(int i=0;i<n;i++)\n{ if(s[i]=='A')a++;\n	else\n	b++;\n	if(b>a) f=0;\n	if(s[n-1]=='A') f=0;\n	\n} if(f)\n{\n	cout<<""YES""<<endl;\n}\nelse cout<<""NO""<<endl;\n}\n}\n","constructive algorithms,implementation","1672","B"
"#include<bits/stdc++.h>\nint n,a,s;\nint main(){\n	int T;scanf(""%d"",&T);for(;T--;){\n	s=0;\n	scanf(""%d"",&n);\n	for(int i=1;i<=n;i++)scanf(""%d"",&a),s^=~a&1;\n	puts(s?""errorgorn"":""maomao90"");\n	}return 0;\n}","constructive algorithms,games,implementation,math","1672","A"
"#include<stdio.h>\nint main(){\n	int i,j,k,n,t;\n	scanf(""%d"",&t);\n	while(t--){\n		scanf(""%d"",&n);\n		k=0;\n		while(n--){\n			scanf(""%d"",&j);\n			k+=j-1;\n		}\n		puts(k%2==0?""maomao90"":""errorgorn"");\n	}\n}","constructive algorithms,games,implementation,math","1672","A"
"#include<bits/stdc++.h>\nint n,a,s;\nint main(){\n	int T;scanf(""%d"",&T);for(;T--;){\n	s=0;\n	scanf(""%d"",&n);\n	for(int i=1;i<=n;i++)scanf(""%d"",&a),s^=~a&1;\n	puts(s?""errorgorn"":""maomao90"");\n	}return 0;\n}","constructive algorithms,games,implementation,math","1672","A"
"#include<bits/stdc++.h>\nint n,a,s;\nint main(){\n	int T;scanf(""%d"",&T);for(;T--;){\n	s=0;\n	scanf(""%d"",&n);\n	for(int i=1;i<=n;i++)scanf(""%d"",&a),s^=~a&1;\n	puts(s?""errorgorn"":""maomao90"");\n	}return 0;\n}\n","constructive algorithms,games,implementation,math","1672","A"
"#include <bits/stdc++.h>\n#define F(i, l, r) for (int i = l; i <= r; i++)\nusing namespace std;\nconst int N = 45, K = 13, mod = 998244353;\nint T, f[N][K][K][K], s[K][K][N], inv[N];\nint get(int *A, int x) {\n  int ans = 0;\n  F(i, 1, 20) {\n    int t = A[i];\n    F(j, 1, 20) if (i != j) t = 1ll * t * (x + mod - j) % mod * (i > j ? inv[i - j] : mod - inv[j - i]) % mod;\n    (ans += t) %= mod;\n  }\n  return ans;\n}\nint main() {\n  f[0][0][0][0] = inv[1] = 1;\n  F(i, 2, 40) inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;\n  F(i, 0, 39) F(j, 0, 11) F(k, 0, 11) F(l, 0, 11) F(jj, 0, min(11 - k, i)) {\n    (f[i + 1][jj][k + jj][l + (jj > j)] += f[i][j][k][l]) %= mod;\n  }\n  F(i, 0, 40) F(j, 0, 11) F(k, 0, 11) F(l, 0, 11) (s[k][l][i] += f[i][j][k][l]) %= mod;\n  scanf(""%d"", &T);\n  while (T--) {\n    int n, k, x;\n    scanf(""%d%d%d"", &n, &k, &x);\n    printf(""%d\n"", n <= 40 ? s[k][x][n] : get(s[k][x] + 20, n - 20));\n  }\n  return 0;\n}","brute force,combinatorics,dp,fft,math","1671","F"
"#include<bits/stdc++.h>\nusing namespace std;\nconst int M=998244353;\ntypedef long long ll;\nconst int N=60;\nint T,n,k,x;\nint f[70][14][14][14][14];\nint dp[14][14][14][70];\nint iv[14];\nint myp(int x,int t){\n	int a=1;\n	for(;t;t>>=1,x=(ll)x*x%M)if(t&1)a=(ll)a*x%M;\n	return a;\n}\nvoid init(){\n	for(int i=1;i<=12;i++)iv[i]=myp(i,M-2);\n	for(int i=2;i<=12;i++)f[i][i-1][i][i-1][0]=1;\n	for(int i=1;i<=N;i++)for(int j=11;j;j--)\n		for(int p=1;p<=j+1;p++)for(int k=0;k<=11;k++)for(int x=0;x<=11;x++){\n			if(f[i][j][p][k][x])for(int t=1;t<=12;t++){\n				int ni=i+max(0,t-j),nj=max(j-1,t-1);\n				int np=t,nk=k+(t-1),nx=x+(p>t);\n				if(nk<=11&&nx<=11)\n					(f[ni][nj][np][nk][nx]+=f[i][j][p][k][x])%=M;\n			}\n		}\n	dp[0][0][0][0]=1;\n	for(int t=0;t<=11;t++)for(int k=0;k<=11;k++)for(int x=0;x<=11;x++)for(int i=0;i<=N;i++)\n		for(int kk=0;kk<=k;kk++)for(int xx=0;xx<=x;xx++)for(int j=0;j<=i;j++)\n			(dp[t+1][k][x][i]+=(ll)dp[t][kk][xx][j]*f[i-j][0][1][k-kk][x-xx])%=M;\n}\nint C(int a,int b){\n	int ans=1;\n	for(int i=a,j=1;j<=b;i--,j++)\n		ans=(ll)ans*i%M*iv[j]%M;\n	return ans;\n}\nvoid sol(){\n	int n,k,x;scanf(""%d%d%d"",&n,&k,&x);\n	int ans=0;\n	for(int t=0;t<=11;t++)for(int i=0;i<=N;i++)if(dp[t][k][x][i]&&i<=n)\n		(ans+=(ll)dp[t][k][x][i]*C(n-i+t,t)%M)%=M;\n	printf(""%d\n"",ans);\n}\nint main(){\n	init();\n	scanf(""%d"",&T);\n	while(T--)sol();\n}","brute force,combinatorics,dp,fft,math","1671","F"
"#include<bits/stdc++.h>\nusing namespace std;\nconst int M=998244353;\ntypedef long long ll;\nconst int N=60;\nint T,n,k,x;\nint f[70][14][14][14][14];\nint dp[14][14][14][70];\nint iv[14];\nint myp(int x,int t){\n	int a=1;\n	for(;t;t>>=1,x=(ll)x*x%M)if(t&1)a=(ll)a*x%M;\n	return a;\n}\nvoid init(){\n	for(int i=1;i<=12;i++)iv[i]=myp(i,M-2);\n	for(int i=2;i<=12;i++)f[i][i-1][i][i-1][0]=1;\n	for(int i=1;i<=N;i++)for(int j=11;j;j--)\n		for(int p=1;p<=j+1;p++)for(int k=0;k<=11;k++)for(int x=0;x<=11;x++){\n			if(f[i][j][p][k][x])for(int t=1;t<=12;t++){\n				int ni=i+max(0,t-j),nj=max(j-1,t-1);\n				int np=t,nk=k+(t-1),nx=x+(p>t);\n				if(nk<=11&&nx<=11)\n					(f[ni][nj][np][nk][nx]+=f[i][j][p][k][x])%=M;\n			}\n		}\n	dp[0][0][0][0]=1;\n	for(int t=0;t<=11;t++)for(int k=0;k<=11;k++)for(int x=0;x<=11;x++)for(int i=0;i<=N;i++)\n		for(int kk=0;kk<=k;kk++)for(int xx=0;xx<=x;xx++)for(int j=0;j<=i;j++)\n			(dp[t+1][k][x][i]+=(ll)dp[t][kk][xx][j]*f[i-j][0][1][k-kk][x-xx])%=M;\n}\nint C(int a,int b){\n	int ans=1;\n	for(int i=a,j=1;j<=b;i--,j++)\n		ans=(ll)ans*i%M*iv[j]%M;\n	return ans;\n}\nvoid sol(){\n	int n,k,x;scanf(""%d%d%d"",&n,&k,&x);\n	int ans=0;\n	for(int t=0;t<=11;t++)for(int i=0;i<=N;i++)if(dp[t][k][x][i]&&i<=n)\n		(ans+=(ll)dp[t][k][x][i]*C(n-i+t,t)%M)%=M;\n	printf(""%d\n"",ans);\n}\nint main(){\n	init();\n	scanf(""%d"",&T);\n	while(T--)sol();\n}","brute force,combinatorics,dp,fft,math","1671","F"
"#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstring>\n#define mod 998244353\nusing namespace std;\n\nint db[13][12][12],a[12];\nint dp[13][12][30][12];\n\nint mul(int x,int y){return 1ll*x*y%mod;}\nint add(int x,int y){x+=y;return x>=mod?x-mod:x;}\n\nint qp(int x,int y){\n	int ans=1;while(y){\n		if(y&1)ans=mul(ans,x);x=mul(x,x);y>>=1;\n	}return ans;\n}\n\nint kp[12];\n\nint main(){\n	for(int n=2;n<=10;n++){\n		for(int i=1;i<=n;i++)a[i]=i;\n		do{\n			int k=0,l=0,mx=0;\n			for(int i=1;i<n;i++){\n				mx=max(mx,a[i]);if(mx==i){k=12;l=12;continue;}\n				for(int j=i+1;j<=n;j++){\n					if(a[i]>a[j])k++;\n				}\n				if(a[i]>a[i+1])l++;\n			}\n			if(k<=11 && l<=11)db[n][k][l]++;\n		}while(next_permutation(a+1,a+n+1));\n	}\n	db[11][10][1]=10;\n	db[11][10][2]=120;\n	db[11][10][3]=252;\n	db[11][10][4]=120;\n	db[11][10][5]=10;\n	db[11][11][1]=8;\n	db[11][11][2]=333;\n	db[11][11][3]=1428;\n	db[11][11][4]=1302;\n	db[11][11][5]=252;\n	db[11][11][6]=5;\n	db[12][11][1]=11;\n	db[12][11][2]=165;\n	db[12][11][3]=462;\n	db[12][11][4]=330;\n	db[12][11][5]=55;\n	db[12][11][6]=1;\n	dp[0][0][0][0]=1;\n	for(int i=1;i<=11;i++){\n		for(int j=29;j;j--){\n			for(int k=1;k<=11;k++){\n				for(int l=1;l<=11;l++){\n					for(int n=1;n<=12;n++){\n						for(int d=1;d<=11;d++){\n							for(int dl=1;dl<=11;dl++){\n								if(j>=n && k>=d && l>=dl){\n									dp[k][l][j][i]=add(dp[k][l][j][i],mul(db[n][d][dl],dp[k-d][l-dl][j-n][i-1]));\n								}\n							}\n						}\n					}\n				}\n			}\n		}\n	}int t;\n	scanf(""%d"",&t);\n	for(int i=1;i<=11;i++)kp[i]=qp(i,mod-2);\n	while(t--){\n		int n,m,x;int ans=0;\n		scanf(""%d %d %d"",&n,&m,&x);\n		for(int i=0;i<=29;i++){\n			if(n>=i)\n			for(int j=0;j<=11;j++){\n				int d=n-i+j,dq=1;\n				for(int k=1;k<=j;k++){\n					dq=mul(dq,mul(d-k+1,kp[k]));\n				}\n				ans=add(ans,mul(dp[m][x][i][j],dq));\n			}\n		}\n		printf(""%d\n"",ans);\n	}\n	return 0;\n}\n","brute force,combinatorics,dp,fft,math","1671","F"
"#include<iostream>\nlong long n,a[2<<18],v,i=1,m=998244353;\nstd::string s[2<<18],S;\nint main(){\n	std::cin>>n>>S,n=1<<n;\n	while(i<n) s[i]=S[v++],a[i++]=1;\n	for(i=i/2-1;i;i--){\n		a[i]=a[i*2]*a[i*2+1]%m;\n		if(s[i*2]!=s[i*2+1]) a[i]=a[i]*2%m;\n		s[i*2]>s[i*2+1]?s[i]+=s[i*2+1]+s[i*2]:s[i]+=s[i*2]+s[i*2+1];\n	}\n	std::cout<<a[1];\n}","combinatorics,divide and conquer,dp,hashing,trees","1671","E"
"#include<iostream>\nlong long n,ans[2<<18],v,i=1,m=998244353;\nstd::string s[2<<18],S;\nint main(){\n	std::cin>>n>>S;\n	for(;i<1<<n;i++) s[i]=S[v++],ans[i]=1;\n	for(i=((1<<n)-1)/2;i>=1;i--){\n		ans[i]=ans[i*2]*ans[i*2+1]%m;\n		if(s[i*2]!=s[i*2+1]) ans[i]=ans[i]*2%m;\n		s[i*2]>s[i*2+1]?s[i]+=s[i*2+1]+s[i*2]:s[i]+=s[i*2]+s[i*2+1];\n	}\n	std::cout<<ans[1];\n}","combinatorics,divide and conquer,dp,hashing,trees","1671","E"
"#include<bits/stdc++.h>\nusing namespace std;\nint mod=998244353;\nlong long n,ans[2<<18],v,i=1;\nstring s[2<<18],S;\n\nint main(){\n	cin>>n>>S;\n	for(;i<1<<n;i++) s[i]=S[v++],ans[i]=1;\n	for(i=((1<<n)-1)/2;i>=1;i--){\n		if(s[i*2]>s[i*2+1]) swap(s[i*2],s[i*2+1]);\n		ans[i]=ans[i*2]*ans[i*2+1]%mod;\n		if(s[i*2]!=s[i*2+1]) ans[i]=ans[i]*2%mod;\n		s[i]+=s[i*2]+s[i*2+1];\n	}\n	cout<<ans[1];\n}\n\n","combinatorics,divide and conquer,dp,hashing,trees","1671","E"
"#include<bits/stdc++.h>\n#define int long long \nusing namespace std;\nconst int mod=998244353;\n\nstring s;\nint ans;\nstring dfs(int u)\n{\n	\n	if(u*2+1>=s.size())\n	{\n		return (string)""""+s[u];\n	}\n	\n	string x=dfs(u*2+1);\n	string y=dfs(u*2+2);\n	\n	if(x!=y)ans=ans*2%mod;\n	if(x>y)swap(x,y);\n	\n	return (string)""""+s[u]+x+y;\n	\n}\nsigned main()\n{\n	int n;cin>>n;\n	cin>>s;\n	ans=1;\n	dfs(0);\n	cout<<ans<<endl;\n	\n}","combinatorics,divide and conquer,dp,hashing,trees","1671","E"
"#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nlong long n,x,t,i,k,a[200002],b,c,d;\nint main()\n{\n	cin>>t;\n	for(k=1;k<=t;k=k+1)\n	{\n		cin>>n>>x;d=0;\n		for(i=1;i<=n;i=i+1)cin>>a[i];\n		b=min(a[1]-1,a[n]-1);c=min(x-a[1],x-a[n]);\n		for(i=1;i<=n;i=i+1)\n		{\n			b=min(b,(a[i]-1)*2);\n			c=min(c,(x-a[i])*2);\n			if(i>1)d=d+abs(a[i]-a[i-1]);\n		}\n		if(c<0)c=0;\n		cout<<b+c+d<<endl;\n	}\n	return 0;\n}","brute force,constructive algorithms,greedy","1671","D"
"#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nlong long n,x,t,i,k,a[200002],b,c,d;\nint main()\n{\n	cin>>t;\n	for(k=1;k<=t;k=k+1)\n	{\n		cin>>n>>x;d=0;\n		for(i=1;i<=n;i=i+1)cin>>a[i];\n		b=min(a[1]-1,a[n]-1);c=min(x-a[1],x-a[n]);\n		for(i=1;i<=n;i=i+1)\n		{\n			b=min(b,(a[i]-1)*2);\n			c=min(c,(x-a[i])*2);\n			if(i>1)d=d+abs(a[i]-a[i-1]);\n		}\n		if(c<0)c=0;\n		cout<<b+c+d<<endl;\n	}\n	return 0;\n}","brute force,constructive algorithms,greedy","1671","D"
"#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nlong long n,x,t,i,k,a[200002],b,c,d;\nint main()\n{\n	cin>>t;\n	for(k=1;k<=t;k=k+1)\n	{\n		cin>>n>>x;d=0;\n		for(i=1;i<=n;i=i+1)cin>>a[i];\n		b=min(a[1]-1,a[n]-1);c=min(x-a[1],x-a[n]);\n		for(i=1;i<=n;i=i+1)\n		{\n			b=min(b,(a[i]-1)*2);\n			c=min(c,(x-a[i])*2);\n			if(i>1)d=d+abs(a[i]-a[i-1]);\n		}\n		if(c<0)c=0;\n		cout<<b+c+d<<endl;\n	}\n	return 0;\n}","brute force,constructive algorithms,greedy","1671","D"
"#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nlong long n,x,t,i,k,a[200002],b,c,d;\nint main()\n{\n	cin>>t;\n	for(k=1;k<=t;k=k+1)\n	{\n		cin>>n>>x;d=0;\n		for(i=1;i<=n;i=i+1)cin>>a[i];\n		b=min(a[1]-1,a[n]-1);c=min(x-a[1],x-a[n]);\n		for(i=1;i<=n;i=i+1)\n		{\n			b=min(b,(a[i]-1)*2);\n			c=min(c,(x-a[i])*2);\n			if(i>1)d=d+abs(a[i]-a[i-1]);\n		}\n		if(c<0)c=0;\n		cout<<b+c+d<<endl;\n	}\n	return 0;\n}\n","brute force,constructive algorithms,greedy","1671","D"
"#include<bits/stdc++.h>\nusing namespace std;\nlong long t,n,m,ans,s;\nint a[200010];\nint main(){\n	cin>>t;\n	while(t--){\n		cin>>n>>m;\n		ans=0,s=0;;\n		for(int i=0;i<n;i++){\n			cin>>a[i];\n		} \n		sort(a,a+n);\n		for(int i=0;i<n;i++){\n			s+=a[i];\n			if(s<=m)\n			ans+=(m-s)/(i+1)+1;\n		}\n		\n		cout<<ans<<endl;\n	}\n	\n} ","binary search,brute force,greedy,math","1671","C"
"#include<bits/stdc++.h>\nusing namespace std;\nlong long t,n,m,ans,s;\nint a[200010];\nint main(){\n	cin>>t;\n	while(t--){\n		cin>>n>>m;\n		ans=0,s=0;;\n		for(int i=0;i<n;i++){\n			cin>>a[i];\n		} \n		sort(a,a+n);\n		for(int i=0;i<n;i++){\n			s+=a[i];\n			if(s<=m)\n			ans+=(m-s)/(i+1)+1;\n		}\n		\n		cout<<ans<<endl;\n	}\n	\n} \n","binary search,brute force,greedy,math","1671","C"
"#include<bits/stdc++.h>\nusing namespace std;\n\nint T,n,a[200010],x;\n\nint main() {\n	cin>>T;\n	while(T--) {\n		cin>>n>>x;\n		for(int i=1;i<=n;i++) cin>>a[i];\n		sort(a+1,a+n+1);\n		long long sum=0,res=0;\n		for(int i=1;i<=n;i++) {\n			sum+=a[i];\n			if(x<sum) break;\n			res+=(x-sum)/i+1;\n		}\n		cout<<res<<endl;\n	}\n	return 0;\n}","binary search,brute force,greedy,math","1671","C"
"#include<bits/stdc++.h>\nusing namespace std;\n\nint T,n,a[200010],x;\n\nint main() {\n	cin>>T;\n	while(T--) {\n		cin>>n>>x;\n		for(int i=1;i<=n;i++) cin>>a[i];\n		sort(a+1,a+n+1);\n		long long sum=0,res=0;\n		for(int i=1;i<=n;i++) {\n			sum+=a[i];\n			if(x<sum) break;\n			res+=(x-sum)/i+1;\n		}\n		cout<<res<<endl;\n	}\n	return 0;\n}","binary search,brute force,greedy,math","1671","C"
"#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n	int t,n;\n	cin>>t;\n	while(t--){\n		cin>>n;\n		int a[n],b=0,c=0;\n		for(int i=0;i<n;i++)cin>>a[i];\n		if(a[n-1]-a[0]<=n+1)cout<<""YES\n"";\n		else cout<<""NO\n"";\n	}\n}","brute force,math,sortings","1671","B"
"#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n	int t,n;\n	cin>>t;\n	while(t--){\n		cin>>n;\n		int a[n],b=0,c=0;\n		for(int i=0;i<n;i++)cin>>a[i];\n		if(a[n-1]-a[0]<=n+1)cout<<""YES\n"";\n		else cout<<""NO\n"";\n	}\n}","brute force,math,sortings","1671","B"
"#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n	int t,n;\n	cin>>t;\n	while(t--){\n		cin>>n;\n		int a[n],b=0,c=0;\n		for(int i=0;i<n;i++)cin>>a[i];\n		if(a[n-1]-a[0]<=n+1)cout<<""YES\n"";\n		else cout<<""NO\n"";\n	}\n}","brute force,math,sortings","1671","B"
"#include<bits/stdc++.h>\nusing namespace std;\n \nint main() {\n	int t,n;\n	cin>>t;\n	while(t--){\n		cin>>n;\n		int a[n],b=0,c=0;\n		for(int i=0;i<n;i++)cin>>a[i];\n		if(a[n-1]-a[0]<=n+1)cout<<""YES\n"";\n		else cout<<""NO\n"";\n	}\n}","brute force,math,sortings","1671","B"
"#include<bits/stdc++.h>\nusing namespace std;\nint t;\nstring s;\nint main()\n{\n	cin>>t;\n	while(t--)\n	{\n		cin>>s;\n		bool f=1;\n		for(int i=0;i<s.size();i++)\n		{\n			if(s[i]!=s[i-1]&&s[i]!=s[i+1]) f=0;\n		}\n		if(f) cout<<""Yes""<<endl;\n		else cout<<""No""<<endl;\n	}\n}\n","implementation","1671","A"
"#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n	int t;\n	cin>>t;\n	while(t--){\n		string s;\n		cin>>s;\n		int flag=0;\n		for (int i=0;i<s.length();i++){\n			if (s[i]!=s[i+1]&&s[i]!=s[i-1])\n				flag=1;\n		}\n		if (flag==0)\n			cout<<""YES\n"";\n			else cout<<""NO\n"";\n	}\n}\n","implementation","1671","A"
"#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n	int t;\n	cin>>t;\n	while(t--){\n		string s;\n		cin>>s;\n		int flag=0;\n		for (int i=0;i<s.length();i++){\n			if (s[i]!=s[i+1]&&s[i]!=s[i-1])\n				flag=1;\n		}\n		if (flag==0)\n			cout<<""YES\n"";\n			else cout<<""NO\n"";\n	}\n}\n","implementation","1671","A"
"#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n	int t;\n	cin>>t;\n	while(t--){\n		string s;\n		cin>>s;\n		int flag=0;\n		for (int i=0;i<s.length();i++){\n			if (s[i]!=s[i+1]&&s[i]!=s[i-1])\n				flag=1;\n		}\n		if (flag==0)\n			cout<<""YES\n"";\n			else cout<<""NO\n"";\n	}\n	return 0;\n}","implementation","1671","A"
"#include<bits/stdc++.h>\nusing namespace std;\nint n,a[200005],K;\nvoid Solve(){\n	cin>>n>>K;\n	for(int i=1;i<=n;i++)cin>>a[i];\n	int ans=0;\n	for(int i=30;i>=0;i--){\n		int cnt=0;\n		for(int j=1;j<=n;j++)if(!(a[j]&(1<<i)))cnt++;\n		if(cnt<=K)K-=cnt,ans|=1<<i;\n	}\n	cout<<ans<<'\n';\n}\nint main(){\n	int t;\n	cin>>t;\n	while(t--)Solve();\n}","bitmasks,greedy,math","1669","H"
"#include<bits/stdc++.h>\nusing namespace std;\nint n,a[200005],K;\nvoid Solve(){\n	cin>>n>>K;\n	for(int i=1;i<=n;i++)cin>>a[i];\n	int ans=0;\n	for(int i=30;i>=0;i--){\n		int cnt=0;\n		for(int j=1;j<=n;j++)if(!(a[j]&(1<<i)))cnt++;\n		if(cnt<=K)K-=cnt,ans|=1<<i;\n	}\n	cout<<ans<<'\n';\n}\nint main(){\n	int t;\n	cin>>t;\n	while(t--)Solve();\n}","bitmasks,greedy,math","1669","H"
"#include<iostream>\nusing namespace std;\nlong long t,k,n,m,a[200002],i,j,b,c;\nint main()\n{\n	cin>>t;\n	for(k=1;k<=t;k=k+1)\n	{\n		cin>>n>>m;c=0;\n		for(i=1;i<=n;i=i+1)cin>>a[i];\n		for(i=30;i>=0;i=i-1)\n		{\n			b=0;\n			for(j=1;j<=n;j=j+1)\n			if((a[j]&(1<<i))==0)b=b+1;\n			if(b<=m)\n			{\n				m=m-b;\n				c=c+(1<<i);\n			}\n		}\n		cout<<c<<endl;\n	}\n	return 0;\n}\n","bitmasks,greedy,math","1669","H"
"#include<iostream>\n#include<cstring>\nusing namespace std;\nint cnt[35];\nint main(void){\n	int T;\n	cin>>T;\n	while(T--){\n		int n,k,ans=0;\n		cin>>n>>k;\n		for(int i=0;i<n;i++){\n			int a;\n			cin>>a;\n			for(int j=0;j<=30;j++) if((a>>j)&1) cnt[j]++;\n		}\n		for(int i=30;i>=0;i--){\n			if((n-cnt[i])<=k) k-=(n-cnt[i]),ans+=1<<i;\n			cnt[i]=0;\n		}\n		cout<<ans<<endl;\n	}\n	return 0;\n}","bitmasks,greedy,math","1669","H"
"#include<bits/stdc++.h>\nusing namespace std;\nstring s[60];\nint main ()\n{\n	int t;\n	cin>>t;\n	while(t--)\n	{\n		int n,m;\n		cin>>n>>m;\n		for(int i=0;i<n;i++)cin>>s[i];\n		for(int o=0;o<n;o++)\n		for(int i=1;i<n;i++)\n		{\n			for(int j=0;j<m;j++)\n			{\n				if(s[i][j]=='.'&&s[i-1][j]=='*')s[i][j]='*',s[i-1][j]='.';\n			}\n		}\n		for(int i=0;i<n;i++)cout<<s[i]<<endl;\n	}\n	return 0;\n}","dfs and similar,implementation","1669","G"
"#include<bits/stdc++.h>\nusing namespace std;\nstring s[60];\nint main ()\n{\n	int t;\n	cin>>t;\n	while(t--)\n	{\n		int n,m;\n		cin>>n>>m;\n		for(int i=0;i<n;i++)cin>>s[i];\n		for(int o=0;o<n;o++)\n		for(int i=1;i<n;i++)\n		{\n			for(int j=0;j<m;j++)\n			{\n				if(s[i][j]=='.'&&s[i-1][j]=='*')s[i][j]='*',s[i-1][j]='.';\n			}\n		}\n		for(int i=0;i<n;i++)cout<<s[i]<<endl;\n	}\n	return 0;\n}","dfs and similar,implementation","1669","G"
"#include<bits/stdc++.h>\nusing namespace std;\nstring s[60];\nint main ()\n{\n	int t;\n	cin>>t;\n	while(t--)\n	{\n		int n,m;\n		cin>>n>>m;\n		for(int i=0;i<n;i++)cin>>s[i];\n		for(int o=0;o<n;o++)\n		for(int i=1;i<n;i++)\n		{\n			for(int j=0;j<m;j++)\n			{\n				if(s[i][j]=='.'&&s[i-1][j]=='*')s[i][j]='*',s[i-1][j]='.';\n			}\n		}\n		for(int i=0;i<n;i++)cout<<s[i]<<endl;\n	}\n	return 0;\n}","dfs and similar,implementation","1669","G"
"#include<bits/stdc++.h>\nusing namespace std;\nstring s[60];\nint main ()\n{\n	int t;\n	cin>>t;\n	while(t--)\n	{\n		int n,m;\n		cin>>n>>m;\n		for(int i=0;i<n;i++)cin>>s[i];\n		for(int o=0;o<n;o++)\n		for(int i=1;i<n;i++)\n		{\n			for(int j=0;j<m;j++)\n			{\n				if(s[i][j]=='.'&&s[i-1][j]=='*')s[i][j]='*',s[i-1][j]='.';\n			}\n		}\n		for(int i=0;i<n;i++)cout<<s[i]<<endl;\n	}\n	return 0;\n}","dfs and similar,implementation","1669","G"
"#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n     int T,n,w[200003];\n	cin>>T;\n	while(T--){\n		cin>>n;\n		for(int i=0;i<n;i++)cin >> w[i];\n		int ans=0;\n		for(int i=0,j=n-1,sum=0;i<=j;){\n			if(sum>=0)\n				sum-=w[i++];\n			else\n				sum+=w[j--];\n			if(!sum)ans=max(ans,n+i-j-1);\n		}\n		cout<<ans<<endl;\n	}\n}","binary search,data structures,greedy,two pointers","1669","F"
"#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n     int T,n,w[200003];\n	cin>>T;\n	while(T--){\n		cin>>n;\n		for(int i=0;i<n;i++)cin >> w[i];\n		int ans=0;\n		for(int i=0,j=n-1,sum=0;i<=j;){\n			if(sum>=0)\n				sum-=w[i++];\n			else\n				sum+=w[j--];\n			if(!sum)ans=max(ans,n+i-j-1);\n		}\n		cout<<ans<<endl;\n	}\n}","binary search,data structures,greedy,two pointers","1669","F"
"#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n     int T,n,w[200003];\n	cin>>T;\n	while(T--){\n		cin>>n;\n		for(int i=0;i<n;i++)cin >> w[i];\n		int ans=0;\n		for(int i=0,j=n-1,sum=0;i<=j;){\n			if(sum>=0)\n				sum-=w[i++];\n			else\n				sum+=w[j--];\n			if(!sum)ans=max(ans,n+i-j-1);\n		}\n		cout<<ans<<endl;\n	}\n}","binary search,data structures,greedy,two pointers","1669","F"
"#include<bits/stdc++.h>\nusing namespace std;\nint T,n,w[200003];\nint main(){\n	cin>>T;\n	while(T--){\n		cin>>n;\n		for(int i=0;i<n;i++)\n			scanf(""%d"",w+i);\n		int ans=0;\n		for(int i=0,j=n-1,sum=0;i<=j;){\n			if(sum>=0)\n				sum-=w[i++];\n			else\n				sum+=w[j--];\n			if(!sum)ans=max(ans,n+i-j-1);\n		}\n		cout<<ans<<endl;\n	}\n}","binary search,data structures,greedy,two pointers","1669","F"
"#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nsigned main(){\n    int a;\n    cin>>a;\nwhile(a--){\n   int N,n=0;\n   cin>>N;\n  map<string,int>m1;\n  map<char,int>m2,m3;\n  while(N--){\n    string s;cin>>s;\n    n+=m2[s[0]]+m3[s[1]]-2*m1[s];\n   m1[s]++;m2[s[0]]++;m3[s[1]]++;\n   }\n   cout<<n<<endl;\n}\n}","data structures,math,strings","1669","E"
"#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nsigned main(){\n    int a;\n    cin>>a;\nwhile(a--){\n   int N,n=0;\n   cin>>N;\n  map<string,int>m1;\n  map<char,int>m2,m3;\n  while(N--){\n    string s;cin>>s;\n    n+=m2[s[0]]+m3[s[1]]-2*m1[s];\n   m1[s]++;m2[s[0]]++;m3[s[1]]++;\n   }\n   cout<<n<<endl;\n}\n}","data structures,math,strings","1669","E"
"#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nsigned main(){\n    int a;\n    cin>>a;\nwhile(a--){\n   int N,n=0;\n   cin>>N;\n  map<string,int>m1;\n  map<char,int>m2,m3;\n  while(N--){\n    string s;cin>>s;\n    n+=m2[s[0]]+m3[s[1]]-2*m1[s];\n   m1[s]++;m2[s[0]]++;m3[s[1]]++;\n   }\n   cout<<n<<endl;\n}\n}","data structures,math,strings","1669","E"
"#include <bits/stdc++.h>\nusing namespace std;\nint main(){ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\nint a;cin>>a;\nwhile(a--){\n   long long nu,n=0;cin>>nu;\n  map<string,int>m1;\n  map<char ,int>m2,m3;\n  while(nu--){\n    string s;cin>>s;\n    n=n+m2[s[0]]+m3[s[1]]-2*m1[s];\n   m1[s]++;m2[s[0]]++;m3[s[1]]++;\n   }cout<<n<<endl;\n}\n}\n","data structures,math,strings","1669","E"
"#include<bits/stdc++.h>\nusing namespace std;\nint T;\nint main()\n{\n	cin>>T;\n	while(T--){\n		int n;\n		string s,ans=""YES\n"";\n		cin>>n>>s;s+='W';\n		int sz=0,ok=0;\n		for(int i=0;i<=n;i++)\n			if(s[i]=='W'){\n				if(sz&&!ok)ans=""NO\n"";\n				sz=0;ok=0;\n			}else{\n				sz++;\n				if(i&&s[i-1]-'B'=='R'-s[i])\n					ok=1;\n			}\n		cout<<ans;\n	}\n}\n","implementation","1669","D"
"#include<bits/stdc++.h>\nusing namespace std;\nint T;\nint main()\n{\n	cin>>T;\n	while(T--){\n		int n;\n		string s,ans=""YES\n"";\n		cin>>n>>s;s+='W';\n		int sz=0,ok=0;\n		for(int i=0;i<=n;i++)\n			if(s[i]=='W'){\n				if(sz&&!ok)ans=""NO\n"";\n				sz=0;ok=0;\n			}else{\n				sz++;\n				if(i&&s[i-1]-'B'=='R'-s[i])\n					ok=1;\n			}\n		cout<<ans;\n	}\n}\n","implementation","1669","D"
"#include<bits/stdc++.h>\nusing namespace std;\nint T;\nint main()\n{\n	cin>>T;\n	while(T--){\n		int n;\n		string s,ans=""YES\n"";\n		cin>>n>>s;s+='W';\n		int sz=0,ok=0;\n		for(int i=0;i<=n;i++)\n			if(s[i]=='W'){\n				if(sz&&!ok)ans=""NO\n"";\n				sz=0;ok=0;\n			}else{\n				sz++;\n				if(i&&s[i-1]-'B'=='R'-s[i])\n					ok=1;\n			}\n		cout<<ans;\n	}\n}\n","implementation","1669","D"
"#include<iostream>\nusing namespace std;\nlong long t,k,n,a,b,c,i,j;\nstring s;\nint main()\n{\n	cin>>t;\n	for(k=1;k<=t;k=k+1)\n	{\n		cin>>n>>s;s=s+""W"";b=0;c=0;a=1;\n		for(i=0;i<=n;i=i+1)\n		{\n			if(s[i]=='W'&&b+c==1)a=0;\n			if(s[i]=='W'){b=0;c=0;}\n			if(s[i]=='R')b=1;\n			if(s[i]=='B')c=1;\n		}\n		if(a==0)puts(""NO"");else puts(""YES"");\n	}\n	return 0;\n}\n","implementation","1669","D"
"#include<bits/stdc++.h>\nusing namespace std;\nint n,a[200005];\nvoid Solve(){\n	cin>>n;\n	bool ok=1;\n	for(int i=0;i<n;i++){\n		cin>>a[i];\n		if(a[i]%2!=a[i%2]%2)ok=0;\n	}\n	if(ok)puts(""YES"");\n	else puts(""NO"");\n}\nint main(){\n	int t;\n	cin>>t;\n	while(t--)Solve();\n}\n","greedy,greedy,implementation,math","1669","C"
"#include<bits/stdc++.h>\nusing namespace std;\n\nint n,a[52];\nvoid Solve(){\n	cin>>n;\n	bool ok=1;\n	for(int i=0;i<n;i++){\n		cin>>a[i];\n		if(a[i]%2 != a[i%2]%2) ok=0;\n	}\n	if(ok) cout << ""YES\n"";\n	else cout << ""NO\n"";\n}\nint main(){\n	int t;\n	cin>>t;\n	while(t--)Solve();\n}","greedy,greedy,implementation,math","1669","C"
"#include<bits/stdc++.h>\nusing namespace std;\n\nint n,a[52];\nvoid Solve(){\n	cin>>n;\n	bool ok=1;\n	for(int i=0;i<n;i++){\n		cin>>a[i];\n		if(a[i]%2 != a[i%2]%2) ok=0;\n	}\n	if(ok) cout << ""YES\n"";\n	else cout << ""NO\n"";\n}\nint main(){\n	int t;\n	cin>>t;\n	while(t--)Solve();\n}","greedy,greedy,implementation,math","1669","C"
"#include<bits/stdc++.h>\nusing namespace std;\n\nint n,a[52];\nvoid Solve()\n{\n	cin>>n;\n	bool ok=1;\n	for(int i=0;i<n;i++){\n		cin>>a[i];\n		if(a[i]%2 != a[i%2]%2) ok=0;\n	}\n	if(ok) cout << ""YES\n"";\n	else cout << ""NO\n"";\n}\nint main(){\n	int t;\n	cin>>t;\n	while(t--)Solve();\n}","greedy,greedy,implementation,math","1669","C"
"#include <bits/stdc++.h>\nint main(){int t;std::cin>>t;while(t--){std::map<int,int>m;int k,ans=-1;std::cin>>k;while(k--){int a;std::cin>>a;m[a]++;if(m[a]==3)ans=a;}std::cout<<ans<<std::endl;}}","implementation,sortings","1669","B"
"#include <bits/stdc++.h>\nint main(){int t;std::cin>>t;while(t--){std::map<int,int>m;int k,ans=-1;std::cin>>k;while(k--){int a;std::cin>>a;m[a]++;if(m[a]==3)ans=a;}std::cout<<ans<<std::endl;}}","implementation,sortings","1669","B"
"#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{int t,c;\ncin>>t;\nwhile(t--)\n{map<int,int>m;\nint n,a=-1;\ncin>>n;\nwhile(n--)\n{cin>>c;\nm[c]++;\nif(m[c]==3)\n    a=c;\n\n}\ncout<<a<<endl;\n\n\n}\n    return 0;\n}","implementation,sortings","1669","B"
"#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n	int t;\n	cin>>t;\n	while(t--){\n		map<int,int>m;\n		int k,ans=-1;\n		cin>>k;\n		while(k--){\n			int a;\n			cin>>a;\n			m[a]++;\n			if(m[a]==3)ans=a;\n		}\n		cout<<ans<<endl;\n	}\n}\n","implementation,sortings","1669","B"
"#import<iostream>\nusing namespace std;\nmain(int a){\n	cin>>a;\n	while(cin>>a)a/=100,printf(""Division %d\n"",1+(a<14)+(a<16)+(a<19));\n}\n","implementation","1669","A"
"#include<bits/stdc++.h>\nusing namespace std;\nint t,n;\nint main(){\n	ios::sync_with_stdio(0);\n	for(cin>>t;t--;){\n		cin>>n;\n		cout<<""Division ""<<(n<1400?4:n<1600?3:n<1900?2:1)<<""\n"";\n	}\n	return 0;\n}","implementation","1669","A"
"#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n	int t;\n	cin>>t;\n	while(t--){\n		int n;\n		cin>>n;\n		string num=n<=1399?""Division 4"":n<=1599?""Division 3"":n<=1899?""Division 2"":""Division 1"";\n		cout<<num<<endl;\n	}\n	return 0;\n} ","implementation","1669","A"
"#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n	int t,n;cin>>t;\n	while(t--)\n	{\n		cin>>n;\n		cout<<""Division "";\n		if(n>=1900) cout<<1;\n		else if(n>=1600) cout<<2;\n		else if(n>=1400) cout<<3;\n		else cout<<4;\n		puts("""");\n	}\n}\n","implementation","1669","A"
"#import<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=2e6;\nint n,m,s,a[N];\nmain()\n{\n	for(cin>>n;cin>>n>>m;)\n	{\n		for(int i=1;i<=n;i++)\n			cin>>a[i];\n		sort(a+1,a+n+1),s=0;\n		for(int i=1;i<n;i++)\n			s+=max(a[i],a[i+1]);\n		puts(s+max(a[1],a[n])+n>m?""NO"":""YES"");\n	}\n}\n","greedy,math,sortings","1668","B"
"#include<bits/stdc++.h>\nusing namespace std;\nlong long  i,j,k,n,m,t,a[1005000];\nint main()\n{\n	cin>>t;\n	while(t--)\n	{\n		cin>>n>>m;\n		m-=n;\n		for(int i=1;i<=n;i++)\n		{\n			cin>>a[i];\n			m-=a[i];\n		}\n		sort(a+1,a+1+n);\n		m-=a[n];\n		m+=a[1];\n		cout<<((m<0)?""NO"":""YES"")<<endl;\n	}\n	return 0;\n}\n","greedy,math,sortings","1668","B"
"#include<bits/stdc++.h>\nusing namespace std;\nlong long  i,j,k,n,m,t,a[1005000];\nint main()\n{\n	cin>>t;\n	while(t--)\n	{\n		cin>>n>>m;\n		m-=n;\n		for(int i=1;i<=n;i++)\n		{\n			cin>>a[i];\n			m-=a[i];\n		}\n		sort(a+1,a+1+n);\n		m-=a[n];\n		m+=a[1];\n		cout<<((m<0)?""NO"":""YES"")<<endl;\n	}\n	return 0;\n}\n","greedy,math,sortings","1668","B"
"#include<bits/stdc++.h>\nusing namespace std;\nlong long  i,j,k,n,m,t,a[1005000];\nint main()\n{\n	cin>>t;\n	while(t--)\n	{\n		cin>>n>>m;\n		m-=n;\n		for(int i=1;i<=n;i++)\n		{\n			cin>>a[i];\n			m-=a[i];\n		}\n		sort(a+1,a+1+n);\n		m-=a[n];\n		m+=a[1];\n		cout<<((m<0)?""NO"":""YES"")<<endl;\n	}\n	return 0;\n}\n","greedy,math,sortings","1668","B"
"#import<bits/stdc++.h>\nusing namespace std;\nint n,m;\nmain()\n{\n	for(cin>>n;cin>>n>>m;)\n		cout<<((n==1||m==1)&&n+m>3?-1:n+m-2+abs(n-m)/2*2)<<'\n';\n}","implementation,math","1668","A"
"#import<bits/stdc++.h>\nusing namespace std;\nint n,m;\nmain()\n{\n	for(cin>>n;cin>>n>>m;)\n		cout<<((n==1||m==1)&&n+m>3?-1:n+m-2+abs(n-m)/2*2)<<'\n';\n}\n","implementation,math","1668","A"
"#include<bits/stdc++.h>\nusing namespace std;\nint main(){\nint t;\ncin>>t;\nwhile(t--){\nint n,m;\ncin>>n>>m;\nif(n<m){\nswap(n,m);\n}\nif(m==1 && n>=3){\ncout<<-1<<endl;\n}else{\ncout<<2*n-2-(n+m)%2<<endl;\n}\n}\n}","implementation,math","1668","A"
"#include<bits/stdc++.h>\nusing namespace std;\nint main(){\nint q;\ncin>>q;\nwhile(q--){\nint n,m;\ncin>>n>>m;\nif(n<m){\nswap(n,m);\n}\nif(m==1 && n>=3){\ncout<<-1<<endl;\n}else{\ncout<<2*n-2-(n+m)%2<<endl;\n}\n}\n}","implementation,math","1668","A"
"#include <bits/stdc++.h>\n \nusing namespace std;\nconst int c=505;\nint t, n, m, fix[c][c], ans[c][c], rotcnt, change, old_cl, new_cl;\nint fix2[c][c], ans2[c][c];\nvoid color_boundary() {\n    for (int cnt=1; cnt<=2; cnt++) {\n        for (int j=2; j<=m; j++) {\n            if (!ans[1][j]) ans[1][j]=ans[1][j-1];\n            if (ans[1][j]!=ans[1][j-1]) change++;\n        }\n        for (int i=2; i<=n; i++) {\n            if (!ans[i][m]) ans[i][m]=ans[i-1][m];\n            if (ans[i][m]!=ans[i-1][m]) change++;\n        }\n        for (int j=m-1; j>=1; j--) {\n            if (!ans[n][j]) ans[n][j]=ans[n][j+1];\n            if (ans[n][j]!=ans[n][j+1]) change++;\n        }\n        for (int i=n-1; i>=1; i--) {\n            if (!ans[i][1]) ans[i][1]=ans[i+1][1];\n            if (ans[i][1]!=ans[i+1][1]) change++;\n        }\n        if (!ans[1][1]) ans[1][1]=1;\n        if (cnt==1) change=0;\n    }\n}\nvoid rotate_90() {\n    rotcnt++;\n    for (int i=1; i<=n; i++) {\n        for (int j=1; j<=m; j++) {\n            ans2[i][j]=ans[i][j], fix2[i][j]=fix[i][j];\n        }\n    }\n    for (int i=1; i<=n; i++) {\n        for (int j=1; j<=m; j++) {\n            ans[j][n+1-i]=ans2[i][j];\n            fix[j][n+1-i]=fix2[i][j];\n        }\n    }\n    swap(n, m);\n}\nvoid good_rotation() {\n    for (int cnt=1; cnt<=4; cnt++) {\n        bool same=1, opposite=0;\n        for (int i=1; i<=n; i++) {\n            if (ans[i][1]!=ans[1][1]) same=0;\n            if (1<i && i<n && ans[1][1]!=ans[i][m]) opposite=1;\n        }\n        if (!same || !opposite) rotate_90();\n    }\n}\nvoid color_the_stripes() {\n    for (int i=2; i<n; i++) {\n        for (int j=2; j<m; j++) {\n            if (!fix[i][j]) {\n                if (i%4==2 || i%4==3) ans[i][j]=old_cl;\n                else ans[i][j]=new_cl;\n            }\n        }\n    }\n}\nvoid avoid_touching() {\n    for (int i=1; i<n; i++) {\n        if (ans[i][m-1]==ans[i+1][m] && ans[i+1][m-1]==ans[i][m] && ans[i][m]!=ans[i+1][m]) {\n            if (!fix[i][m]) ans[i][m]=3-ans[i][m];\n            else ans[i+1][m]=3-ans[i+1][m];\n        }\n    }\n}\nvoid boundary_stripe_connection() {\n    int first=0, last=0;\n    for (int i=1; i<=n; i++) {\n        if (ans[i][m]==new_cl) {\n            if (!first) first=i;\n            last=i;\n        }\n    }\n    if (first==0 || (last>3 && first<n-2)) return;\n    if (last<=3 && fix[4][m-1]==old_cl) {\n        for (int i=3; i<=5; i++) {\n            ans[i][m]=new_cl;\n        }\n        return;\n    }\n    if (first>=n-2 && fix[n-3][m-1]==old_cl) {\n        for (int i=n-4; i<=n-2; i++) {\n            ans[i][m]=new_cl;\n        }\n        return;\n    }\n    int x=(last<=3 ? 2 : n-2);\n    for (int i=x; i<=x+1; i++) {\n        for (int j=m-1; j<=m; j++) {\n            if (!fix[i][j]) ans[i][j]=new_cl;\n        }\n    }\n}\nvoid connect_isolated_point(int x, int y) {\n    if (ans[x-1][y]==new_cl || ans[x+1][y]==new_cl || ans[x][y+1]==new_cl) return;\n    int x1=(x==2 ? 1 : n), x2=(x==2 ? 2 : n-1), x3=(x==2 ? 3 : n-2), x4=(x==2 ? 4 : n-3);\n    if (y<=m-2 && ans[x1][y+2]==new_cl) {\n        ans[x1][y]=new_cl;\n        ans[x1][y+1]=new_cl;\n        return;\n    }\n    if (y<=m-2 && ans[x2][y+2]==new_cl) {\n        ans[x2][y+1]=new_cl;\n        return;\n    }\n    if (fix[x4][y]!=old_cl) {\n        ans[x3][y]=new_cl;\n    } else {\n        int y2=(y+1<m ? y+1 : y-1);\n        ans[x2][y2]=new_cl;\n        ans[x3][y2]=new_cl;\n    }\n}\nvoid bridge_through_the_stripe(int x) {\n    for (int j=2; j<=4; j++) {\n        bool good=1;\n        for (int i=x-1; i<=x+2; i++) {\n            if (fix[i][j]==old_cl) good=0;\n        }\n        if (good) {\n            ans[x][j]=new_cl;\n            ans[x+1][j]=new_cl;\n            return;\n        }\n    }\n    for (int i=x-1; i<=x+2; i++) {\n        if (!fix[i][3]) ans[i][3]=new_cl;\n    }\n    if (fix[x-1][3]) {\n        ans[x-1][2]=old_cl;\n        ans[x][4]=new_cl;\n    }\n    if (fix[x+2][3]) {\n        ans[x+2][2]=old_cl;\n        ans[x+1][4]=new_cl;\n    }\n    if (fix[x][3] || fix[x+1][3]) {\n        ans[x][2]=new_cl;\n        ans[x+1][2]=new_cl;\n    }\n}\nint main()\n{\n    cin >> t;\n    for (int tc=1; tc<=t; tc++) {\n        cin >> n >> m;\n        for (int i=1; i<=n; i++) {\n            for (int j=1; j<=m; j++) {\n                char c;\n                cin >> c;\n                fix[i][j]=(c=='B' ? 1 : c=='W' ? 2 : 0);\n                ans[i][j]=fix[i][j];\n            }\n        }\n        color_boundary();\n        if (change>=4) {\n            cout << ""NO\n"";\n        } else {\n            good_rotation();\n            old_cl=ans[1][1], new_cl=3-ans[1][1];\n            color_the_stripes();\n            avoid_touching();\n            boundary_stripe_connection();\n            for (int j=2; j<m; j++) {\n                if (fix[2][j]==new_cl) connect_isolated_point(2, j);\n                if (fix[n-1][j]==new_cl) connect_isolated_point(n-1, j);\n            }\n            for (int i=6; i<=n-6; i+=4) {\n                if (ans[1][1]==ans[i][m] || ans[1][1]==ans[i+1][m]) bridge_through_the_stripe(i);\n            }\n            while (rotcnt<4) rotate_90();\n            cout << ""YES\n"";\n            for (int i=1; i<=n; i++) {\n                for (int j=1; j<=m; j++) {\n                    cout << (ans[i][j]==1 ? ""B"" : ""W"");\n                }\n                cout << ""\n"";\n            }\n        }\n        rotcnt=0, change=0;\n        for (int i=1; i<=n; i++) {\n            for (int j=1; j<=m; j++) {\n                fix[i][j]=0, ans[i][j]=0;\n                fix[j][i]=0, ans[j][i]=0;\n            }\n        }\n    }\n    return 0;\n}","implementation","1667","F"
"#include<bits/stdc++.h>\nusing namespace std;\nenum{N=200009,P=998244353};\nint jc[N],ijc[N],f[N];\nint qp(int a,int b){int r=1;for(;b;b>>=1,a=a*1ll*a%P)if(b&1)r=r*1ll*a%P;return r;}\nint main(){ios::sync_with_stdio(0);cin.tie(0);\n	int n,m,i,w=0;\n	for(cin>>n,m=(n+1)/2,jc[0]=i=1;i<=n;++i)jc[i]=jc[i-1]*1ll*i%P;\n	for(ijc[n]=qp(jc[n],P-2),i=n;i;--i)ijc[i-1]=ijc[i]*1ll*i%P;\n	for(i=m;i>1;--i)f[i]=(jc[n-i]*1ll*jc[n-m]%P*ijc[n-m-i+1]+(P-w)*1ll*jc[i-1]%P*ijc[i])%P,w=(w+f[i])%P;\n	for(f[1]=f[2],i=1;i<=n;++i)cout<<f[i]<<' ';\n}","combinatorics,dp,fft,math","1667","E"
"#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353;\nconst int M=2e5+9;\nint n;\nint f[M],s[M],p[M],ans[M],fac[M],inv[M];\nint c(int x,int y){\n    if(x<y||y<0)return 0;\n    return 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nint main() {\n    fac[0]=fac[1]=inv[0]=inv[1]=1;\n    for(int i=2;i<M;++i){\n        fac[i]=1ll*fac[i-1]*i%mod;\n        inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n    }\n    for(int i=2;i<M;++i)inv[i]=1ll*inv[i]*inv[i-1]%mod;\n    cin>>n;\n    for(int i=2;i<=n/2+1;++i){\n        ans[i]=1ll*c(n/2,i-1)*fac[i-1]%mod*fac[n-i]%mod;\n    }\n    int s=0;\n    for(int i=n/2+1;i>=2;--i){\n        ans[i]=(ans[i]+mod-1ll*s*inv[i]%mod*fac[i-1]%mod)%mod;\n        s=(s+ans[i])%mod;\n    }\n    ans[1]=ans[2];\n    for(int i=1;i<=n;++i)printf(""%d%c"",ans[i],"" \n""[i==n]);\n    return 0;\n}\n","combinatorics,dp,fft,math","1667","E"
"#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod = 998244353;\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int n;\n    cin >> n;\n    vector<int> fact(n),inv(n),ifact(n);\n    fact[0] = 1;\n    for(int i=1;i<n;i++) fact[i] = 1ll*fact[i-1]*i%mod;\n    inv[1] = 1;\n    for(int i=2;i<n;i++) inv[i] = mod-1ll*(mod/i)*inv[mod%i]%mod;\n    ifact[0] = 1;\n    for(int i=1;i<n;i++) ifact[i] = 1ll*ifact[i-1]*inv[i]%mod;\n    vector<int> res(n/2+1);\n    int t = 0;\n    for(int i=n/2+1;i>1;i--){\n        int x = (mod+1ll*fact[n/2]*ifact[n/2-i+1]%mod*fact[n-i]%mod-1ll*t*inv[i]%mod)%mod;\n        t = (t+x)%mod;\n        res[i-1] = x;\n    }\n    res[0] = (mod+fact[n-1]-t)%mod;\n    for(int i=0;i<=n/2;i++) cout << res[i] << "" "";\n    for(int i=0;i<n/2;i++) cout << ""0 "";\n    cout << ""\n"";\n}","combinatorics,dp,fft,math","1667","E"
"#include <cstdio>\n\nconst int md = 998244353;\n\ninline int add(int a, int b) {\n	a += b;\n	if (a >= md) a -= md;\n	return a;\n}\ninline int sub(int a, int b) {\n	a -= b;\n	if (a < 0) a += md;\n	return a;\n}\ninline int mul(int a, int b) {\n	return (long long)a * b % md;\n}\nint po(int a, int b) {\n	int r = 1;\n	while (b) {\n		if (b & 1) r = mul(r, a);\n		a = mul(a, a);\n		b >>= 1;\n	}\n	return r;\n}\ninline int inv(int a) {\n	return po(a, md - 2);\n}\ninline int di(int a, int b) {\n	return mul(a, inv(b));\n}\n\nconst int N = 200005;\nint n, fact[N], d[N];\n\nint nCr(int n, int r) {\n	return di(fact[n], mul(fact[r], fact[n - r]));\n}\n\nint main() {\n	fact[0] = 1;\n	for (int i = 1; i < N; ++i) fact[i] = mul(fact[i - 1], i);\n	scanf(""%d"", &n);\n	for (int i = 0; i <= n / 2; ++i) d[i] = mul(fact[i], mul(fact[n - i - 1], nCr(n / 2, i)));\n	int s = 0;\n	for (int i = n / 2; i >= 0; --i) {\n		int pr = d[i];\n		d[i] = sub(d[i], s);\n		s = add(s, di(pr, i));\n	}\n	for (int i = 0; i < n; ++i) printf(""%d "", d[i]);\n	printf(""\n"");\n	return 0;\n}\n","combinatorics,dp,fft,math","1667","E"
"#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+5;\nint t,n,u,v,h[N],tot;\nbool col[N];\nvector<int> E[N];\nbool dfs(int u,int fa)\n{\n	int c[2]={};\n	for(int v:E[u])\n	{\n		if(v==fa) continue;\n		if(!dfs(v,u)) return false;\n		c[col[v]]++;\n	}\n	if(u>1) c[col[u]=(c[0]>=c[1])]++;\n	return (c[0]+c[1])/2==c[0];\n}\nvoid solve(int u,int fa)\n{\n	vector<int> b[2];\n	for(int v:E[u]) b[col[v==fa?u:v]].push_back(v);\n	for(int p=E[u].size()&1;b[p].size();p^=1)\n	{\n		int v=b[p].back();b[p].pop_back();\n		if(v==fa) printf(""%d %d\n"",u,fa);\n		else solve(v,u);\n	}\n}\nint main()\n{\n	scanf(""%d"",&t);\n	while(t--)\n	{\n		scanf(""%d"",&n);\n		for(int i=1;i<=n;i++) E[i].clear();\n		for(int i=1;i<n;i++)\n		{\n			scanf(""%d%d"",&u,&v);\n			E[u].push_back(v);\n			E[v].push_back(u);\n		}\n		if(!dfs(1,0)) puts(""NO"");\n		else puts(""YES""),solve(1,0);\n	}\n	return 0;\n}\n		 		   				     	  	  	 		 		","constructive algorithms,dfs and similar,dp,trees","1667","D"
"#include<bits/stdc++.h>\nusing namespace std;\nint n,fa[200004];\nvector<int>tr[200004];\nint pr[200004];\nbool dfs(int x){\n	int cnt[2]={0,0};\n	for(auto y:tr[x])if(y!=fa[x]){\n		fa[y]=x;\n		if(dfs(y))return 1;\n		cnt[pr[y]]++;\n	}\n	if(x!=1)pr[x]=cnt[0]>=cnt[1],cnt[pr[x]]++;\n	if(cnt[1]<cnt[0]||cnt[1]>cnt[0]+1)return 1;\n	return 0;\n}\nvoid getans(int x){\n	vector<int>ver[2];\n	for(auto y:tr[x]){\n		if(fa[x]==y)ver[pr[x]].push_back(x);\n		else ver[pr[y]].push_back(y);\n	}\n	int cur=((int)tr[x].size())&1;\n	for(int i=0;i<tr[x].size();i++){\n		int y=ver[cur].back();ver[cur].pop_back();\n		if(y==x)printf(""%d %d\n"",x,fa[x]);\n		else getans(y);\n		cur^=1;\n	}\n}\nvoid sol(){\n	scanf(""%d"",&n);\n	for(int i=1;i<=n;i++)tr[i].clear();\n	for(int i=1;i<n;i++){\n		int u,v;scanf(""%d%d"",&u,&v);\n		tr[u].push_back(v),tr[v].push_back(u);\n	}\n	if(dfs(1)){puts(""NO"");return;}\n	puts(""YES""),getans(1);\n}\nint main(){\n	int tc;scanf(""%d"",&tc);\n	while(tc--)sol();\n}","constructive algorithms,dfs and similar,dp,trees","1667","D"
"#include<bits/stdc++.h>\nusing namespace std;\nint n,fa[200004];\nvector<int>tr[200004];\nint pr[200004];\nbool dfs(int x){\n	int cnt[2]={0,0};\n	for(auto y:tr[x])if(y!=fa[x]){\n		fa[y]=x;\n		if(dfs(y))return 1;\n		cnt[pr[y]]++;\n	}\n	if(x!=1)pr[x]=cnt[0]>=cnt[1],cnt[pr[x]]++;\n	if(cnt[1]<cnt[0]||cnt[1]>cnt[0]+1)return 1;\n	return 0;\n}\nvoid getans(int x){\n	vector<int>ver[2];\n	for(auto y:tr[x]){\n		if(fa[x]==y)ver[pr[x]].push_back(x);\n		else ver[pr[y]].push_back(y);\n	}\n	int cur=((int)tr[x].size())&1;\n	for(int i=0;i<tr[x].size();i++){\n		int y=ver[cur].back();ver[cur].pop_back();\n		if(y==x)printf(""%d %d\n"",x,fa[x]);\n		else getans(y);\n		cur^=1;\n	}\n}\nvoid sol(){\n	scanf(""%d"",&n);\n	for(int i=1;i<=n;i++)tr[i].clear();\n	for(int i=1;i<n;i++){\n		int u,v;scanf(""%d%d"",&u,&v);\n		tr[u].push_back(v),tr[v].push_back(u);\n	}\n	if(dfs(1)){puts(""NO"");return;}\n	puts(""YES""),getans(1);\n}\nint main(){\n	int tc;scanf(""%d"",&tc);\n	while(tc--)sol();\n}","constructive algorithms,dfs and similar,dp,trees","1667","D"
"#include<bits/stdc++.h>\nusing namespace std;\nint n,fa[200004];\nvector<int>tr[200004];\nint pr[200004];\nbool dfs(int x){\n	int cnt[2]={0,0};\n	for(auto y:tr[x])if(y!=fa[x]){\n		fa[y]=x;\n		if(dfs(y))return 1;\n		cnt[pr[y]]++;\n	}\n	if(x!=1)pr[x]=cnt[0]>=cnt[1],cnt[pr[x]]++;\n	if(cnt[1]<cnt[0]||cnt[1]>cnt[0]+1)return 1;\n	return 0;\n}\nvoid getans(int x){\n	vector<int>ver[2];\n	for(auto y:tr[x]){\n		if(fa[x]==y)ver[pr[x]].push_back(x);\n		else ver[pr[y]].push_back(y);\n	}\n	int cur=((int)tr[x].size())&1;\n	for(int i=0;i<tr[x].size();i++){\n		int y=ver[cur].back();ver[cur].pop_back();\n		if(y==x)printf(""%d %d\n"",x,fa[x]);\n		else getans(y);\n		cur^=1;\n	}\n}\nvoid sol(){\n	scanf(""%d"",&n);\n	for(int i=1;i<=n;i++)tr[i].clear();\n	for(int i=1;i<n;i++){\n		int u,v;scanf(""%d%d"",&u,&v);\n		tr[u].push_back(v),tr[v].push_back(u);\n	}\n	if(dfs(1)){puts(""NO"");return;}\n	puts(""YES""),getans(1);\n}\nint main(){\n	int tc;scanf(""%d"",&tc);\n	while(tc--)sol();\n}","constructive algorithms,dfs and similar,dp,trees","1667","D"
"#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nint main()\n{\n	int n;cin>>n;\n	int j=1;\n	int d=(2*n+1)/3;\n	cout<<(2*n+1)/3<<endl;\n	for(int i=1;i<=d;i++)\n	{\n		cout<<i<<"" ""<<j<<endl;\n		j+=2;\n		if(j>d)j=2;\n	}\n}","constructive algorithms,math","1667","C"
"#include<bits/stdc++.h>\nusing namespace std;\nint n,w[100004];\nint main(){\n	scanf(""%d"",&n);\n	int ans=n-(n+1)/3,r=0;\n	printf(""%d\n"",ans);\n	for(int i=1;i<=ans;i+=2)printf(""%d %d\n"",++r,i);\n	for(int i=2;i<=ans;i+=2)printf(""%d %d\n"",++r,i);\n}","constructive algorithms,math","1667","C"
"#include<bits/stdc++.h>\nusing namespace std;\nint n,w[100004];\nint main(){\n	scanf(""%d"",&n);\n	int ans=n-(n+1)/3,r=0;\n	printf(""%d\n"",ans);\n	for(int i=1;i<=ans;i+=2)printf(""%d %d\n"",++r,i);\n	for(int i=2;i<=ans;i+=2)printf(""%d %d\n"",++r,i);\n}","constructive algorithms,math","1667","C"
"﻿#include <iostream>\nusing namespace std;\nint main() {\n	int n;\n	cin >> n;\n	int ans = (2 * n - 1 + 2) / 3;\n	cout << ans << endl;\n	for (int i = 1, j = 1; i <= ans; i ++) {\n		cout << i << ' ' << j << endl;\n		j + 2 > ans ? j = 2 : j += 2;\n	}\n	return 0;\n}","constructive algorithms,math","1667","C"
